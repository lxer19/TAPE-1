URL: http://www.cs.purdue.edu/homes/young/papers/SERC-TR-128-P.ps.Z
Refering-URL: http://www.cs.wustl.edu/~levine/research/cv.html
Root-URL: 
Title: A Concurrency Analysis Tool Suite for Ada Programs: Rationale, Design, and Preliminary Experience  
Author: Michal Young Richard N. Taylor David L. Levine Kari Forester Debra Brodbeck 
Date: Revised November 1994  
Address: West Lafayette, Indiana 47907-1398  Irvine, California 92717-3425  
Affiliation: Software Engineering Research Center Department of Computer Sciences Purdue University  Department of Information and Computer Science University of California  
Pubnum: SERC Technical Report TR-128-P  
Abstract: Cats (Concurrency Analysis Tool Suite) is designed to satisfy several criteria: it must analyze implementation-level Ada source code and check user-specified conditions associated with program source code; it must be modularized in a fashion that supports flexible composition with other tool components, including integration with a variety of testing and analysis techniques; and its performance and capacity must be sufficient for analysis of real application programs. Meeting these objectives together is significantly more difficult than meeting any of them alone. We describe the design and rationale of Cats and report experience with an implementation. The issues addressed here are primarily practical concerns for modularizing and integrating tools for analysis of actual source programs. We also report successfully applying Cats to major subsystems of a (non-toy) highly concurrent user interface system. fl This paper is a major revision of [YTFB89]. This material is based upon work sponsored by the Defense Advanced Research Projects Agency under grant number MDA972-91-J-1010. Additional support was provided by the Software Engineering Research Center, an NSF Industry/University Cooperative Research Center, and by the National Science Foundation under grant number CCR-9010135. The content of the information does not necessarily reflect the position or the policy of the Government and no official endorsement should be inferred. 
Abstract-found: 1
Intro-found: 1
Reference: [ADWR86] <author> George S. Avrunin, Laura K. Dillon, Jack C. Wileden, and William E. Riddle. </author> <title> Constrained expressions: Adding analysis capabilities to design methods for concurrent software systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(2):278-292, </volume> <month> February </month> <year> 1986. </year>
Reference-contexts: This basic framework is general enough to describe testing (where the model is a program, the representation of behaviors is a set of actual runs, and the checking procedure is the test oracle), reachability analysis (where the representation of behaviors is a state-transition graph), and constrained expression analysis <ref> [ADWR86, DAW88] </ref> (where the representation of behaviors is a set of inequalities, and the checking procedure is a linear inequality solver), among many others. Although very broad, the model is not so general as to be devoid of content. <p> Although exponential lower bounds apply to all possible algorithms for deciding exposure to deadlock and other interesting properties of concurrent programs, symbolic techniques may better exploit regularity in some cases. The constrained expression approach represents possible interactions between tasks by a set of inequalities relating counts of event occurrences <ref> [ADWR86, DAW88] </ref>. Binary decision diagrams (BDD's) have been used to represent a transition relation by a characteristic predicate which can be combined with a BDD representation of properties to be verified [BCM + 90].
Reference: [And91] <author> Gregory R. Andrews. </author> <title> Concurrent Programming: </title> <booktitle> Principles and Practice. </booktitle> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <year> 1991. </year>
Reference-contexts: static concurrency analysis with run-time monitoring, so that the accuracy of manually constructed portions of models can be validated through testing. 4.1 Dining Philosophers The dining philosophers problem is a well-known example of exposure to deadlock, and a simplified version of a significant class of problems for concurrent systems. (See <ref> [And91] </ref> for a good modern treatment.) While dining philosophers is a "toy" problem, its simplicity and regular structure are convenient for experimenting with variations on representation and analysis procedures, and for illustrating aspects of the analysis tool. We assume the reader has some familiarity with the problem. Simple dining philosophers.
Reference: [Apt83] <author> Krzysztof R. Apt. </author> <title> A static analysis of CSP programs. </title> <booktitle> In Proceedings of the Workshop on Program Logic, </booktitle> <address> Pittsburgh, PA, </address> <month> June </month> <year> 1983. </year>
Reference-contexts: The composite state-transition model is often called a "reachability graph." These models typically highlight synchronization structure and abstract away other details of execution. Reachability analysis has been applied to Petri nets and CSP-like and CCS-like state machine models, among others <ref> [Apt83, Tay83b, Pet81, MR87, FGM + 92] </ref>. We use the term "static concurrency analysis" for reachability analysis of finite-state models extracted from program source code, as described in [Tay83b].
Reference: [BCM + 90] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Binary decision diagrams (BDD's) have been used to represent a transition relation by a characteristic predicate which can be combined with a BDD representation of properties to be verified <ref> [BCM + 90] </ref>.
Reference: [BHR84] <author> S. D. Brookes, C. A. R. Hoare, and A. W. Roscoe. </author> <title> A theory of communicating sequential processes. </title> <journal> Journal of the ACM, </journal> <volume> 31(3) </volume> <pages> 560-599, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Non-deterministic choices in TIGs are modeled by edge groups, which carry the same information as refusals <ref> [BHR84] </ref> or acceptance sets [Hen88] in process algebras. Each out-edge from a TIG node belongs to a single 4 Since we do not model the values of variables (with a few exceptions described in Section 4), we must consider data-dependent control flow branching as arbitrary choice.
Reference: [BK84] <author> J. A. Bergstra and J. W. Klop. </author> <title> Process algebra for synchronous communication. </title> <journal> Information and Control, </journal> <volume> 60 </volume> <pages> 109-137, </pages> <year> 1984. </year>
Reference-contexts: In order to use a general rule for building reachability graphs from sets of labeled flowgraphs, rather than a case-by-case set of rules for the different synchronization activities in Ada, we introduce a set of labels similar to those used in process algebras for modeling elementary actions <ref> [Mil89, BK84, BvG87] </ref>. It is usual in labeled transition systems to introduce a single unobservable action t , letting all other actions be communication actions.
Reference: [Buh84] <author> Raymond J. A. Buhr. </author> <title> System Design with Ada. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Engle-wood Cliffs, New Jersey, </address> <year> 1984. </year>
Reference-contexts: The task and package structure of a generic Chiron runtime environment is shown in Figure 13 using a simplified variation of Buhr diagrams <ref> [Buh84] </ref>. Rectangles depict packages, nested as drawn. Parallelograms represent tasks, with arrows from callers to entries. Dots beside arrowheads represent guarded entry calls. Shadowed parallelograms with dashed lines indicate optional multiple task instances.
Reference: [BvG87] <author> J. C. M. Baeten and R. J. van Glabeek. </author> <title> Another look at abstraction in process algebra. </title> <booktitle> In Proceedings of the 14th International Colloquium on Automata, Languages, and Programming (ICALP), </booktitle> <pages> pages 84-94, </pages> <address> Karlsruhe, Germany, </address> <month> July </month> <year> 1987. </year> <note> Published as Springer-Verlag Lecture Notes in Computer Science 267. </note>
Reference-contexts: In order to use a general rule for building reachability graphs from sets of labeled flowgraphs, rather than a case-by-case set of rules for the different synchronization activities in Ada, we introduce a set of labels similar to those used in process algebras for modeling elementary actions <ref> [Mil89, BK84, BvG87] </ref>. It is usual in labeled transition systems to introduce a single unobservable action t , letting all other actions be communication actions.
Reference: [CBES85] <author> E. M. Clarke, M. C. Browne, E. A. Emerson, and A. P. Sistla. </author> <title> Using temporal logic for automatic verification of finite state systems. </title> <editor> In K. R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pages 3-26. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: A trace is a degenerate reachability graph, so the Reachability Graph Analyzer (RGA) tool can be applied to the output of either modeling tool. * The analysis component may be used with different models. A temporal logic model checking tool constructed at Carnegie Mellon <ref> [CBES85] </ref> Young et al: Concurrency analysis tool suite 3 AN ANALYSIS TOOLSET 5 has been applied to models of sequential circuits as well as concurrent software, and has also been interfaced to other finite-state verification systems, e.g. the concurrency workbench [CPS90]. * Both the modeling component and the analysis component are
Reference: [CES86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: An enumeration of possible sequences of interactions among tasks is represented by a global state-transition graph, which we call a task interaction concurrency graph (TICG). Explicit specifications in a branching-time propositional temporal logic are checked using the decision procedure described by Clarke, Emerson, and Sistla <ref> [CES86] </ref>, and a separate procedure verifies freedom from deadlock. Behaviors which violate the specification formulas are reported directly to the user. In general, the size of a task interaction concurrency graph may be the product of the sizes of the individual task interaction graphs from which it is constructed. <p> Freedom from deadlock is considered an implicit specification, and is checked using a special-purpose procedure. Additional constraints can be explicitly specified by the user, by embedding temporal logic assertions in the Ada source code. Temporal logic assertions are checked using an adaptation of the model checking algorithm of <ref> [CES86] </ref>. When a sequencing error is detected, example violating behaviors (sequences of events) are produced and reported to the user. Checking for deadlock. We have described in Section 3.2 why checking for deadlock is not a simple matter of recognizing TICG (reachability graph) nodes with no out-edges. <p> Temporal logic assertions. The temporal logic supported by Cats is a propositional, branching time logic based on the computation tree logic (CTL) of <ref> [CES86] </ref>. But whereas the propositions in a CTL formula refer to states, it is often more convenient to describe sequences of events (e.g., rendezvous). Our assertion language is equivalent to CTL (with a different surface syntax) except for the addition of formulae describing events. <p> Temporal logic assertions are extracted from comments in Ada source. An assertion is checked in a bottom-up walk of its expression tree as described in <ref> [CES86] </ref>, with each sub-expression evaluating to a bit vector which is treated as a boolean attribute of the language-independent attributable graph structure; the evaluator invokes the language dependent component only to evaluate atomic propositions. <p> Algorithms for incorporating various notions of fairness in temporal logic model checking are well-known <ref> [CES86] </ref> but have not yet been incorporated in the Cats model checker. Adding a butler. Another well-known solution to the dining philosophers problem is the addition of a "butler" task, which ensures that the number of philosophers at the table is one fewer than the number of forks.
Reference: [CPS90] <author> Rance Cleaveland, Joachim Parrow, and Bernhard Steffen. </author> <title> A semantics-based verification tool for finite-state systems. In Protocol Specification, Testing, and Verification, </title> <booktitle> IX, </booktitle> <pages> pages 287-302. </pages> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: A temporal logic model checking tool constructed at Carnegie Mellon [CBES85] Young et al: Concurrency analysis tool suite 3 AN ANALYSIS TOOLSET 5 has been applied to models of sequential circuits as well as concurrent software, and has also been interfaced to other finite-state verification systems, e.g. the concurrency workbench <ref> [CPS90] </ref>. * Both the modeling component and the analysis component are likely to be simpler. This factoring of analysis from modeling need not imply a sequential two-phase operation in which all modeling precedes all analysis, although current operating system substrates make that the easiest way to compose tool components. <p> Examples include translation of Ada to Petri nets [SMBT90], translation of Lotos to Petri nets [FGM + 92], and translation of CCS process graphs (with labeled edges and unlabeled nodes) into Kripke structures (with unlabeled edges and labeled nodes) to interface with a temporal logic model checker <ref> [CPS90] </ref>. This is attractive when a small translation effort permits reuse of existing analysis tools, and the Young et al: Concurrency analysis tool suite 6 RELATED WORK 43 performance of those tools may conceivably make up for their lack of specialization.
Reference: [DAW88] <author> Laura K. Dillon, George S. Avrunin, and Jack C. Wileden. </author> <title> Constrained expressions: Toward broad applicability of analysis methods for distributed software systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 374-402, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: This basic framework is general enough to describe testing (where the model is a program, the representation of behaviors is a set of actual runs, and the checking procedure is the test oracle), reachability analysis (where the representation of behaviors is a state-transition graph), and constrained expression analysis <ref> [ADWR86, DAW88] </ref> (where the representation of behaviors is a set of inequalities, and the checking procedure is a linear inequality solver), among many others. Although very broad, the model is not so general as to be devoid of content. <p> a set of tasks making up a program. 2 It is necessary to say precisely what one means by "accurate." One approach is to insist that a model represent all and only the possible behaviors of a piece of software (both accurate and precise, in the terminology of [Tay83b] and <ref> [DAW88] </ref>). However, a model which meets this absolute standard cannot overcome fundamental complexity bounds (e.g., undecidability or NP-hardness), because the relation between model and original artifact amounts to a problem reduction. <p> Although exponential lower bounds apply to all possible algorithms for deciding exposure to deadlock and other interesting properties of concurrent programs, symbolic techniques may better exploit regularity in some cases. The constrained expression approach represents possible interactions between tasks by a set of inequalities relating counts of event occurrences <ref> [ADWR86, DAW88] </ref>. Binary decision diagrams (BDD's) have been used to represent a transition relation by a characteristic predicate which can be combined with a BDD representation of properties to be verified [BCM + 90].
Reference: [FGM + 92] <author> Jean-Claude Fernandez, Hubert Garavel, Laurent Mournier, Anne Rasse, Carlos Rodriguez, and Joseph Sifakis. </author> <title> A toolbox for the verification of LO-TOS programs. </title> <booktitle> In Proceedings of the Fourteenth International Conference on Software Engineering, </booktitle> <pages> pages 246-259, </pages> <address> Melbourne, Australia, </address> <year> 1992. </year>
Reference-contexts: The composite state-transition model is often called a "reachability graph." These models typically highlight synchronization structure and abstract away other details of execution. Reachability analysis has been applied to Petri nets and CSP-like and CCS-like state machine models, among others <ref> [Apt83, Tay83b, Pet81, MR87, FGM + 92] </ref>. We use the term "static concurrency analysis" for reachability analysis of finite-state models extracted from program source code, as described in [Tay83b]. <p> The most common approach to integrating concurrency analysis tools in a development environment is to translate software artifacts into a fixed modeling or analysis formalism. Examples include translation of Ada to Petri nets [SMBT90], translation of Lotos to Petri nets <ref> [FGM + 92] </ref>, and translation of CCS process graphs (with labeled edges and unlabeled nodes) into Kripke structures (with unlabeled edges and labeled nodes) to interface with a temporal logic model checker [CPS90].
Reference: [GHP92] <author> Patrice Godefroid, Gerard J. Holzmann, and Didier Pirottin. </author> <title> State space caching revisited. </title> <booktitle> In Proceedings of the Fourth Workshop on Computer-Aided Verification, </booktitle> <pages> pages 175-186, </pages> <address> Montreal, Quebec, Canada, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: Several approaches exploit regularity in sequences of states, noting that many interleavings of independent events are redundant. Godefroid's sleep set avoids exploring all interleavings of independent events; all states are still enumerated, but not all of them must be stored <ref> [GHP92] </ref>. Valmari recognizes a particular kind of independence between events (called "stubbornness," or sometimes "persistence") and elides both redundant event sequences and states [Val90].
Reference: [Hen88] <author> Matthew Hennessy. </author> <title> Algebraic Theory of Processes. MIT Press Series in the Foundations of Computing. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1988. </year> <editor> Young et al: </editor> <title> Concurrency analysis tool suite REFERENCES 47 </title>
Reference-contexts: Non-deterministic choices in TIGs are modeled by edge groups, which carry the same information as refusals [BHR84] or acceptance sets <ref> [Hen88] </ref> in process algebras. Each out-edge from a TIG node belongs to a single 4 Since we do not model the values of variables (with a few exceptions described in Section 4), we must consider data-dependent control flow branching as arbitrary choice.
Reference: [Hil82] <author> Paul N. Hilfinger. </author> <title> Implementation strategies for Ada tasking idioms. </title> <booktitle> In Proceedings of the AdaTEC Conference on Ada, </booktitle> <pages> pages 26-30. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1982. </year>
Reference-contexts: Similar simple flow analyses may eliminate or transform some tasks before analysis, e.g., a simple server task acting as a monitor [Hoa74] to protect a data structure can usually be elided. The interprocedural analysis required is similar to that used in optimizing Ada compilers for recognizing monitor clusters <ref> [Hil82] </ref>, and can be extended to iteratively elide hierarchies of server tasks. TIG and TICG structures can be stored for further use, both for incremental composition with TIG or TICG representations of other parts of a system and for use in other analysis techniques.
Reference: [HM91] <author> David P. Helmbold and Charles E. McDowell. </author> <title> Computing reachable states of parallel programs. </title> <editor> In Barton P. Miller and Charles McDowell, editors, </editor> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 76-84. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1991. </year> <note> Appeared as ACM SIGPLAN Notices 26 (12). </note>
Reference-contexts: Several approaches exploit regularity in state spaces to speed enumeration and reduce storage. McDow-ell [McD89] has implemented a static analyzer that merges a set of related states. Helmbold and McDowell present a generalization called "entity folding" in <ref> [HM91] </ref>. Several approaches exploit regularity in sequences of states, noting that many interleavings of independent events are redundant. Godefroid's sleep set avoids exploring all interleavings of independent events; all states are still enumerated, but not all of them must be stored [GHP92].
Reference: [Hoa74] <author> Charles Anthony Richard Hoare. </author> <title> Monitors: An operating system structuring concept. </title> <journal> Communications of the ACM, </journal> <volume> 17(10), </volume> <month> October </month> <year> 1974. </year>
Reference-contexts: Similar simple flow analyses may eliminate or transform some tasks before analysis, e.g., a simple server task acting as a monitor <ref> [Hoa74] </ref> to protect a data structure can usually be elided. The interprocedural analysis required is similar to that used in optimizing Ada compilers for recognizing monitor clusters [Hil82], and can be extended to iteratively elide hierarchies of server tasks.
Reference: [Hol91] <author> Gerard J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ 07632, </address> <year> 1991. </year>
Reference: [KCTT91] <author> Rudolf K. Keller, Mary Cameron, Richard N. Taylor, and Dennis B. Troup. </author> <title> User interface development and software environments: </title> <booktitle> The Chiron-1 system. In Proceedings of the Thirteenth International Conference on Software Engineering, </booktitle> <pages> pages 208-218, </pages> <address> Austin, TX, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: A solution for this case, namely unrolling the loop in the butler, was analyzed. The practical potential of static analysis with Cats is demonstrated by its application to the runtime environment of Chiron <ref> [KCTT91] </ref>, a highly concurrent user interface development system. These examples exercised all components of Cats. The dining philosophers examples used the complete system, from source code translation through error reporting. <p> Our experience with other examples, real and artificial, bears this out. Second, the "unrolled" version shows that in some cases increasing the accuracy of analysis through symbolic execution can actually improve performance. 4.2 Chiron 1.2 Runtime The Chiron user interface development system (UIDS) <ref> [KCTT91, TJ93] </ref> represents a modern, moderate size system. Chiron 1.2 comprises roughly 10 5 source lines of code, designed and implemented over a two year period with the equivalent of five individuals working at any one time.
Reference: [KS90] <author> Paris C. Kanellakis and Scott A. Smolka. </author> <title> CCS expressions, finite state processes, and three problems of equivalence. </title> <journal> Information and Computation, </journal> <volume> 86 </volume> <pages> 43-68, </pages> <year> 1990. </year>
Reference-contexts: Regions are single entry, which causes duplication of the loop body. The construction is similar to the usual NFA construction for lexical recognizers (Thompson's construction). However, since the axiom "x = x for regular languages has no direct analogue for labeled flowgraphs <ref> [KS90] </ref> (see the discussion of internal choice below), we cannot always build up graphs from subgraphs by adding silent moves. In addition to introducing nodes and labeled edges, we combine single-entry, single-exit flowgraphs by merging nodes.
Reference: [Lad79] <author> Richard E. Ladner. </author> <title> The complexity of problems in systems of communicating sequential processes. </title> <booktitle> In Proceedings of the Eleventh Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 214-223, </pages> <address> Atlanta, GA, </address> <month> April </month> <year> 1979. </year>
Reference-contexts: Second, the size of a global model usually grows as the product of the sizes of individual process models. Moreover, basic complexity results <ref> [Lad79, Tay83a, Smo84] </ref> imply that there is no universally applicable short-cut without further sacrificing accuracy. The so-called "state explosion problem" has been addressed in a number of ways, including compact encodings (e.g., binary decision diagrams, partial order models) and hierarchical analysis methods. General analysis model.
Reference: [LC89] <author> Douglas L. Long and Lori A. Clarke. </author> <title> Task interaction graphs for concurrency analysis. </title> <booktitle> In Proceedings of the Eleventh International Conference on Software Engineering, </booktitle> <pages> pages 44-52, </pages> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: This specificity need not compromise the independence of the two semantics. 3.2 The TIG model of Ada tasking The Task Interaction Graph model of Ada tasking was introduced by Long and Clarke in <ref> [LC89] </ref>. Task interaction graphs (TIGs) represent individual Ada tasks. <p> In the interest of clarity, we describe the TIG model as a kind of labeled transition system, and our terminology and presentation differs somewhat from that of <ref> [LC89] </ref>. A task interaction graph (TIG) represents the structure of a single Ada task. Roughly speaking, TIG nodes represent states and sequences of non-synchronization activities, while TIG edges represent synchronization activities. For present purposes a synchronization activity is an entry call, an accept statement, select, select-else, task-begin, or task-end. <p> The putative bookkeeping advantages of duplication can be obtained at no cost by associating code regions with TIG edges rather than TIG nodes. In the construction below we will actually produce a modified TIG model rather than the original model as described in <ref> [LC89] </ref>, as it is easier to describe translation from the modified model to the original than vice versa. (Implementing either transformation is straightforward.) Constructing TIGs from Ada The first step in the construction of a TIG consists of making all task and entry names unique and removing statements not involving communication. <p> In step (d) nodes are split so that all in-edges to a single node represent the same interaction as required by the original TIG model as described in <ref> [LC89] </ref>. Omitting step (d) improves performance at a slight cost in bookkeeping (edges rather than nodes must be associated with source code regions) but no cost in modeling accuracy. <p> An infinite wait cannot occur in a program execution state in which a select delay or else alternative is possible. However, it is a consequence of the way TIGs are constructed from Ada programs that a TIG node cannot 5 In <ref> [LC89] </ref>, blocking edge groups are called one-edge groups, and non-blocking edge groups are called zero-edge groups. We have modified the terminology to make the discussion clearer. Young et al: Concurrency analysis tool suite 3 AN ANALYSIS TOOLSET 18 have only out-edges belonging to non-blocking edge groups. <p> A more detailed diagram of information flow in the Cats system is presented in Figure 8. The system model is a set of task interaction graphs (TIG's) <ref> [LC89] </ref> derived from the source code of a concurrent Ada program or another design notation for rendezvous-style concurrent systems. A compiler front end produces a semantically-analyzed graph representation of the program, and this representation is then translated into the task interaction graph representation described in Section 3.2. <p> This is a straightforward but tedious process for pure Ada code, as outlined in <ref> [LC89] </ref>. Manual extraction or annotation of synchronization structures continues to have a role for certain program features, e.g., to model interaction with the XView toolkit through Unix signals. <p> In this example, it is also clear that the order in which tasks are initiated is irrelevant; the optimized version does not explicitly model the initiation step of each task. The TIG model as originally described by Long and Clarke <ref> [LC89] </ref> requires that all edges entering a TIG node correspond to a single region of source code; thus the entrance to a loop is often represented twice, distinguishing the first iteration from subsequent iterations. While this restriction makes some bookkeeping chores simpler, it has a cost in performance.
Reference: [LC91] <author> Douglas Long and Lori A. Clarke. </author> <title> Data flow analysis of concurrent systems that use the rendezvous model of synchronization. </title> <booktitle> In Proceedings of the Symposium on Software Testing, Analysis, and Verification (TAV4), </booktitle> <pages> pages 21-35, </pages> <address> Victoria, British Columbia, </address> <month> October </month> <year> 1991. </year> <booktitle> ACM SIGSOFT, </booktitle> <publisher> ACM Press. </publisher>
Reference-contexts: This simplifies bookkeeping and improves the accuracy of analyses other than reachability analysis (e.g., the dataflow analysis reported in <ref> [LC91] </ref>). Duplication of TIG nodes with identical synchronization behavior has a substantial cost, as shown by the experience reported in Section 4.1 (see Table 1, page 30). The putative bookkeeping advantages of duplication can be obtained at no cost by associating code regions with TIG edges rather than TIG nodes.
Reference: [LMC87] <author> Thomas J. LeBlanc and John M. Mellor-Crummey. </author> <title> Debugging parallel programs with instant replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(4):471-482, </volume> <month> April </month> <year> 1987. </year>
Reference-contexts: Similar directed exploration techniques have been proposed as aids to debugging [Tay84] and incorporated in a debugging tool that combines static and dynamic analysis [RCdS90]. Techniques for forcing a concurrent or distributed program through a chosen sequence of nondeterministic choices have been described by LeBlanc and Mellor-Crummey <ref> [LMC87] </ref> and by Tai, Carver, and Obaid [TCO91]. 6 Related Work Variations on the basic reachability analysis technique used in Cats have a long history, with most early work in the field of communication protocol analysis [Sun81].
Reference: [LS84] <author> Simon S. Lam and A. Udaya Shankar. </author> <title> Protocol verification via projections. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):325-342, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: Ultimately no global analysis, whether symbolic or enumerative, will be useful for detecting faults in large-scale software systems. Performance enhancements postpone the inevitable. Practical approaches must parcel analysis into tractable subproblems, and preferably into subproblems that mirror the modular structure of the system under test. Layering and projection <ref> [LS84] </ref> are often used for decomposing models of communication protocols along functional lines.
Reference: [Mas93] <author> Stephen P. Masticola. </author> <title> Static Detection of Deadlocks in Polynomial Time. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <address> New Brunswick, New Jersey, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: An alternative direction is to (further) sacrifice accuracy for performance. Masticola and Ryder <ref> [MR91, Mas93] </ref> have developed a polynomial time deadlock detection algorithm based on data flow analysis. In order to achieve this complexity, reachability is safely overestimated at the expense of precision: spurious deadlocks may be reported.
Reference: [McD89] <author> Charles E. McDowell. </author> <title> A practical algorithm for static analysis of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 6 </volume> <pages> 515-536, </pages> <year> 1989. </year>
Reference-contexts: Computational expense is a continuing concern in reachability analysis techniques for concurrent software. Several approaches exploit regularity in state spaces to speed enumeration and reduce storage. McDow-ell <ref> [McD89] </ref> has implemented a static analyzer that merges a set of related states. Helmbold and McDowell present a generalization called "entity folding" in [HM91]. Several approaches exploit regularity in sequences of states, noting that many interleavings of independent events are redundant.
Reference: [Mil89] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <address> London, </address> <year> 1989. </year>
Reference-contexts: In order to use a general rule for building reachability graphs from sets of labeled flowgraphs, rather than a case-by-case set of rules for the different synchronization activities in Ada, we introduce a set of labels similar to those used in process algebras for modeling elementary actions <ref> [Mil89, BK84, BvG87] </ref>. It is usual in labeled transition systems to introduce a single unobservable action t , letting all other actions be communication actions.
Reference: [MR87] <author> E. Timothy Morgan and Rami R. Razouk. </author> <title> Interactive state-space analysis of concurrent systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(10):1080-1091, </volume> <month> October </month> <year> 1987. </year>
Reference-contexts: The composite state-transition model is often called a "reachability graph." These models typically highlight synchronization structure and abstract away other details of execution. Reachability analysis has been applied to Petri nets and CSP-like and CCS-like state machine models, among others <ref> [Apt83, Tay83b, Pet81, MR87, FGM + 92] </ref>. We use the term "static concurrency analysis" for reachability analysis of finite-state models extracted from program source code, as described in [Tay83b]. <p> An earlier prototype tool for analyzing concurrent Ada programs, constructed at the University of California, Irvine, did just that [Wam85]. In some other reacha-bility analysis tools, analysis of a reachability graph is kept strictly separate from generation of the graph. In the PNut system for analysis of Petri nets <ref> [Raz87, MR87] </ref>, reachability graphs are built by one program and analyzed by a completely separate program, with communication between the two only via the file system or Unix pipes. Important benefits accrue from this separation: * The analysis component can be used with different modeling approaches.
Reference: [MR91] <author> Stephen P. Masticola and Barbara G. Ryder. </author> <title> A model of Ada programs for static deadlock detection in polynomial time. </title> <editor> In Barton P. Miller and Charles McDowell, editors, </editor> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 97-107. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1991. </year> <note> Appeared as ACM SIGPLAN Notices 26 (12). </note> <editor> Young et al: </editor> <title> Concurrency analysis tool suite REFERENCES 48 </title>
Reference-contexts: An alternative direction is to (further) sacrifice accuracy for performance. Masticola and Ryder <ref> [MR91, Mas93] </ref> have developed a polynomial time deadlock detection algorithm based on data flow analysis. In order to achieve this complexity, reachability is safely overestimated at the expense of precision: spurious deadlocks may be reported.
Reference: [MZGT85] <author> D. Mandrioli, R. Zicari, C. Ghezzi, and F. Tisato. </author> <title> Modeling the Ada task system by Petri nets. </title> <journal> Computer Languages, </journal> <volume> 10(1) </volume> <pages> 43-61, </pages> <year> 1985. </year>
Reference-contexts: Performance is not an issue when the purpose of the model is to formalize and clarify language semantics, as in the translation of Ada tasking to Petri nets described by Ghezzi et. al. <ref> [MZGT85] </ref>, but expansion during translation is an important consideration when the goal is automated analysis.
Reference: [Pet81] <author> J. Peterson. </author> <title> Petri Net Theory and the Modeling of Systems. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: The composite state-transition model is often called a "reachability graph." These models typically highlight synchronization structure and abstract away other details of execution. Reachability analysis has been applied to Petri nets and CSP-like and CCS-like state machine models, among others <ref> [Apt83, Tay83b, Pet81, MR87, FGM + 92] </ref>. We use the term "static concurrency analysis" for reachability analysis of finite-state models extracted from program source code, as described in [Tay83b].
Reference: [Raz87] <author> Rami R. Razouk. </author> <title> A guided tour of P-NUT. </title> <type> Technical Report 86-25, </type> <institution> University of California, </institution> <year> 1987. </year>
Reference-contexts: An earlier prototype tool for analyzing concurrent Ada programs, constructed at the University of California, Irvine, did just that [Wam85]. In some other reacha-bility analysis tools, analysis of a reachability graph is kept strictly separate from generation of the graph. In the PNut system for analysis of Petri nets <ref> [Raz87, MR87] </ref>, reachability graphs are built by one program and analyzed by a completely separate program, with communication between the two only via the file system or Unix pipes. Important benefits accrue from this separation: * The analysis component can be used with different modeling approaches.
Reference: [RCdS90] <author> Barbara Raither, Jean-Fran~cois Caillet, and Pascal de Seze. IDEFIX: </author> <title> A tool for debugging Ada tasks in a real-time environment. </title> <journal> Technique et Science Informatiques, </journal> <volume> 9(2) </volume> <pages> 150-156, </pages> <year> 1990. </year>
Reference-contexts: A configuration of Cats providing a suitable directed exploration component could be constructed by replacing a single small module responsible for search strategy. Similar directed exploration techniques have been proposed as aids to debugging [Tay84] and incorporated in a debugging tool that combines static and dynamic analysis <ref> [RCdS90] </ref>.
Reference: [RHR91] <author> Christophe Ratel, Nicolas Halbwachs, and Pascal Raymond. </author> <title> Programming and verifying critical systems by means of the synchronous data-flow language LUSTRE. </title> <booktitle> In Proceedings of the ACM SIGSOFT '91 Conference on Software for Critical Systems, </booktitle> <pages> pages 112-119, </pages> <address> New Orleans, LA, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: The intuitive expectation that symbolic and enumerative approaches will each be capable of tackling some problems that the other cannot is backed by the experience of Ratel, Halbwachs, and Raymond, who implemented both approaches to analyzing safety properties of LUSTRE programs <ref> [RHR91] </ref>. An alternative direction is to (further) sacrifice accuracy for performance. Masticola and Ryder [MR91, Mas93] have developed a polynomial time deadlock detection algorithm based on data flow analysis. In order to achieve this complexity, reachability is safely overestimated at the expense of precision: spurious deadlocks may be reported.
Reference: [SMBT90] <author> Sol M. Shatz, Khanh Mai, Christopher Black, and Shengru Tu. </author> <title> Design and implementation of a Petri net based toolkit for Ada tasking analysis. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(4) </volume> <pages> 424-441, </pages> <month> Octo-ber </month> <year> 1990. </year>
Reference-contexts: In some cases the availability of a body of existing theory and off-the-shelf tools may partly or wholly compensate for clumsy translation (e.g., application of Petri net reductions and reacha-bility analysis tools as in <ref> [SMBT90] </ref>), but in many cases it is worthwhile to customize a modeling formalism to an application domain. <p> The most common approach to integrating concurrency analysis tools in a development environment is to translate software artifacts into a fixed modeling or analysis formalism. Examples include translation of Ada to Petri nets <ref> [SMBT90] </ref>, translation of Lotos to Petri nets [FGM + 92], and translation of CCS process graphs (with labeled edges and unlabeled nodes) into Kripke structures (with unlabeled edges and labeled nodes) to interface with a temporal logic model checker [CPS90].
Reference: [Smo84] <author> Scott A. Smolka. </author> <title> Analysis of Communicating Finite State Processes. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Brown University, </institution> <year> 1984. </year> <note> Department of Computer Science Technical Report No. CS-84-05. </note>
Reference-contexts: Second, the size of a global model usually grows as the product of the sizes of individual process models. Moreover, basic complexity results <ref> [Lad79, Tay83a, Smo84] </ref> imply that there is no universally applicable short-cut without further sacrificing accuracy. The so-called "state explosion problem" has been addressed in a number of ways, including compact encodings (e.g., binary decision diagrams, partial order models) and hierarchical analysis methods. General analysis model.
Reference: [Sun81] <author> Carl A. Sunshine, </author> <title> editor. Communication Protocol Modeling. </title> <publisher> Artech House, </publisher> <address> Dedham, MA, </address> <year> 1981. </year>
Reference-contexts: through a chosen sequence of nondeterministic choices have been described by LeBlanc and Mellor-Crummey [LMC87] and by Tai, Carver, and Obaid [TCO91]. 6 Related Work Variations on the basic reachability analysis technique used in Cats have a long history, with most early work in the field of communication protocol analysis <ref> [Sun81] </ref>. Many concurrency analysis tools have been developed for high-level designs, algorithms, and protocols (e.g.[FGM + 92, Hol91]), but few have been developed for programs (excepting code generated from protocol descriptions). While similar techniques are applicable at both levels, the pragmatic considerations are different.
Reference: [Tay83a] <author> Richard N. Taylor. </author> <title> Complexity of analyzing the synchronization structure of concurrent programs. </title> <journal> Acta Informatica, </journal> <volume> 19 </volume> <pages> 57-84, </pages> <year> 1983. </year>
Reference-contexts: Second, the size of a global model usually grows as the product of the sizes of individual process models. Moreover, basic complexity results <ref> [Lad79, Tay83a, Smo84] </ref> imply that there is no universally applicable short-cut without further sacrificing accuracy. The so-called "state explosion problem" has been addressed in a number of ways, including compact encodings (e.g., binary decision diagrams, partial order models) and hierarchical analysis methods. General analysis model.
Reference: [Tay83b] <author> Richard N. Taylor. </author> <title> A general-purpose algorithm for analyzing concurrent programs. </title> <journal> Communications of the ACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: The composite state-transition model is often called a "reachability graph." These models typically highlight synchronization structure and abstract away other details of execution. Reachability analysis has been applied to Petri nets and CSP-like and CCS-like state machine models, among others <ref> [Apt83, Tay83b, Pet81, MR87, FGM + 92] </ref>. We use the term "static concurrency analysis" for reachability analysis of finite-state models extracted from program source code, as described in [Tay83b]. <p> Reachability analysis has been applied to Petri nets and CSP-like and CCS-like state machine models, among others [Apt83, Tay83b, Pet81, MR87, FGM + 92]. We use the term "static concurrency analysis" for reachability analysis of finite-state models extracted from program source code, as described in <ref> [Tay83b] </ref>. A primary use of reachability analysis is verification of properties of the synchronization structure of software, e.g., freedom from deadlock, freedom from starvation, and mutual exclusion. With respect to these properties, reachability analysis provides the same level of assurance as formal verification. <p> execution of a set of tasks making up a program. 2 It is necessary to say precisely what one means by "accurate." One approach is to insist that a model represent all and only the possible behaviors of a piece of software (both accurate and precise, in the terminology of <ref> [Tay83b] </ref> and [DAW88]). However, a model which meets this absolute standard cannot overcome fundamental complexity bounds (e.g., undecidability or NP-hardness), because the relation between model and original artifact amounts to a problem reduction.
Reference: [Tay84] <author> Richard N. Taylor. </author> <title> Debugging real-time software in a host-target environment. </title> <journal> Technique et Science Informatiques (Technology and Science of Infor-matics), </journal> <volume> 3(4) </volume> <pages> 281-288, </pages> <year> 1984. </year>
Reference-contexts: A configuration of Cats providing a suitable directed exploration component could be constructed by replacing a single small module responsible for search strategy. Similar directed exploration techniques have been proposed as aids to debugging <ref> [Tay84] </ref> and incorporated in a debugging tool that combines static and dynamic analysis [RCdS90].
Reference: [TCO91] <author> K. C. Tai, R. H. Carver, and E. E. Obaid. </author> <title> Debugging concurrent Ada programs by deterministic execution. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 45-63, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Techniques for forcing a concurrent or distributed program through a chosen sequence of nondeterministic choices have been described by LeBlanc and Mellor-Crummey [LMC87] and by Tai, Carver, and Obaid <ref> [TCO91] </ref>. 6 Related Work Variations on the basic reachability analysis technique used in Cats have a long history, with most early work in the field of communication protocol analysis [Sun81].
Reference: [TJ93] <author> Richard N. Taylor and Gregory F. Johnson. </author> <title> Separations of concerns in the Chiron-1 user interface development and management system. </title> <booktitle> In Proceedings of the Conference on Human Factors in Computing Systems, </booktitle> <pages> pages 367-374, </pages> <address> Amsterdam, </address> <month> April </month> <year> 1993. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: Our experience with other examples, real and artificial, bears this out. Second, the "unrolled" version shows that in some cases increasing the accuracy of analysis through symbolic execution can actually improve performance. 4.2 Chiron 1.2 Runtime The Chiron user interface development system (UIDS) <ref> [KCTT91, TJ93] </ref> represents a modern, moderate size system. Chiron 1.2 comprises roughly 10 5 source lines of code, designed and implemented over a two year period with the equivalent of five individuals working at any one time.
Reference: [TLK92] <author> Richard N. Taylor, David L. Levine, and Cheryl D. Kelly. </author> <title> Structural testing of concurrent programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(3) </volume> <pages> 206-215, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: The TICG structure produced by Cats is potentially useful for adequacy criteria. Young et al: Concurrency analysis tool suite 6 RELATED WORK 42 In particular, Taylor, Levine, and Kelly <ref> [TLK92] </ref> describe a method for using concurrency graph models of programs in defining structural test coverage criteria. While they used a flowgraph model for their definition of a test case coverage hierarchy, the results can be transferred to a TICG model.
Reference: [Val90] <author> Antti Valmari. </author> <title> A stubborn attack on state explosion. </title> <editor> In E. M. Clarke and R. P. Kurshan, editors, </editor> <booktitle> Computer-Aided Verification, 2nd International Conference Proceedings, </booktitle> <pages> pages 156-165. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1990. </year> <note> Lecture Notes in Computer Science 531. </note>
Reference-contexts: Godefroid's sleep set avoids exploring all interleavings of independent events; all states are still enumerated, but not all of them must be stored [GHP92]. Valmari recognizes a particular kind of independence between events (called "stubbornness," or sometimes "persistence") and elides both redundant event sequences and states <ref> [Val90] </ref>. Our aim in Cats has been to obtain adequate performance in combination with other important constraints, and our current implementation is already adequate for analysis of systems well beyond the comprehension of an unaided programmer.
Reference: [Wam85] <author> Gordon Kent Wampler. </author> <title> Static concurrency analysis of Ada programs. </title> <type> Master's thesis, </type> <institution> University of California, Irvine, </institution> <year> 1985. </year>
Reference-contexts: For instance, one could easily combine generation of successor states with a check for deadlock, perhaps avoiding some redundant computations. An earlier prototype tool for analyzing concurrent Ada programs, constructed at the University of California, Irvine, did just that <ref> [Wam85] </ref>. In some other reacha-bility analysis tools, analysis of a reachability graph is kept strictly separate from generation of the graph.
Reference: [Wei88] <author> Stewart N. Weiss. </author> <title> A formal framework for the study of concurrent program testing. </title> <booktitle> In Proceedings of the Second Workshop on Software Testing, Verification, and Analysis, </booktitle> <pages> pages 106-113, </pages> <address> Banff, Canada, </address> <month> July </month> <year> 1988. </year> <note> ACM/SIGSOFT and IEEE-CS Software Engineering Technical Committee. </note> <editor> Young et al: </editor> <title> Concurrency analysis tool suite REFERENCES 49 </title>
Reference-contexts: While they used a flowgraph model for their definition of a test case coverage hierarchy, the results can be transferred to a TICG model. Additionally, Weiss <ref> [Wei88] </ref> has developed a formal theory for reasoning about test coverage based on representing concurrent programs as a set of simulating sequential programs termed serializations, which are essentially similar to paths in a concurrency graph.
Reference: [WWFT88] <author> Jack C. Wileden, Alexander L. Wolf, Charles D. Fisher, and Peri L. Tarr. PGRAPHITE: </author> <title> An experiment in persistent typed object management. </title> <booktitle> In Proceedings of ACM SIGSOFT '88: Third Symposium on Software Development Environments, </booktitle> <pages> pages 130-142, </pages> <address> Boston, MA, </address> <month> November </month> <year> 1988. </year>
Reference-contexts: The original structure of TIG's reflects a different set of design tradeoffs than reacha-bility graphs: task interaction graphs of individual tasks are much smaller than TICG's, so compromising abstraction for performance would be inappropriate. They are instead represented by an attributed graph structure automatically generated by P-Graphite <ref> [WWFT88] </ref>. P-Graphite manages persistence of TIG's, allowing them to exist beyond the lifetime of a single program without explicit input/output.
Reference: [Yeh93] <author> Wei Jen Yeh. </author> <title> Controlling State Explosion in Reachability Analysis. </title> <type> PhD thesis, </type> <institution> Purdue University, Department of Computer Sciences, West Lafayette, </institution> <note> IN 47907-1398, </note> <month> December </month> <year> 1993. </year>
Reference-contexts: Analysis of the user interface example described here relies on division along a client/server split. In work reported elsewhere <ref> [Yeh93, YY91, YY93, YY94] </ref> we are developing approaches to hierarchically combine these modular analyses. 2 Analysis approach The term "reachability analysis" is used to describe construction of a state-transition model of larger modules (or a complete system) from models of individual processes. <p> We have constructed a separate prototype to experiment with scalable, divide-and-conquer analysis (but which does not address tool integration or other critical constraints on Cats); the result of this effort is reported elsewhere <ref> [Yeh93, YY91, YY94] </ref>. Our experience suggests a modular analysis will be practical for large but well-structured systems if graphs representing a few thousands of states and events are constructed and analyzed in a few minutes. <p> Since human judgement seems necessary in this modeling decision, we envision (but have not yet implemented) a facility by which the user indicates which variables should be unfolded, and to what extent. We have implemented variable unfolding in a separate prototype tool <ref> [Yeh93, YY93, YY94] </ref> and see no technical obstacle to supporting better user control. A TIG representation of the unrolled version of the butler was constructed and the analysis was repeated, see Table 1 part iii. <p> Cats does not currently provide automated support for dividing a system into modules for analysis or composing analysis results, although a system that uses program scope structure and communication topology to automatically parcel an analysis is reported in <ref> [YY91, YY93, Yeh93] </ref>; this approach will be incorporated in a future version of Cats. 7 Conclusion The challenge in designing Cats was to meet and balance multiple and sometimes conflicting objectives. Any one of these dimensions could have been improved by sacrificing others. <p> While the well-known state explosion problem makes global analysis intractable, task interactions in subsystems well beyond the comprehension of unaided programmers can be exhaustively analyzed in a few minutes, and the hierarchical techniques reported in <ref> [YY91, YY93, Yeh93] </ref> will permit future versions of Cats to analyze considerably larger collections of tasks. Our experience applying Cats to an application built using the Chiron user interface development system suggests that analysis of natural modules of real programs can be both practical and useful.
Reference: [You88] <author> Michal Young. </author> <title> How to leave out details: Error-preserving abstractions of state-space models. </title> <booktitle> In Proceedings of the Second Workshop on Software Testing, Verification, and Analysis, </booktitle> <pages> pages 63-70, </pages> <address> Banff, Canada, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: A reasonable approach is to insist that a model represent all possible erroneous behaviors, but allow the possibility that some impossible erroneous behaviors are also represented. A precise definition of this criterion with sufficient conditions for ensuring accuracy with respect to temporal specification formulae is described in <ref> [You88] </ref>.
Reference: [YT88] <author> Michal Young and Richard N. Taylor. </author> <title> Combining static concurrency analysis with symbolic execution. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(10) </volume> <pages> 1499-1511, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Young et al: Concurrency analysis tool suite 4 EXPERIMENTS AND EXPERIENCE 33 Unrolling the butler. One partial solution to the problem of spurious error reports is to combine static concurrency analysis with symbolic execution. Elsewhere <ref> [YT88] </ref>, we have described an approach in which candidate errors exposed by static concurrency analysis are used to guide a symbolic executor. An alternative approach is to use symbolic execution for partial evaluation before concurrency analysis.
Reference: [YTFB89] <author> Michal Young, Richard N. Taylor, Kari Forester, and Debra A. Brodbeck. </author> <title> Integrated concurrency analysis in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT '89 Third Symposium on Software Testing, Analysis, and Verification (TAV3), </booktitle> <pages> pages 200-209, </pages> <address> Key West, Florida, </address> <month> December </month> <year> 1989. </year> <note> Published as ACM SIGSOFT Software Engineering Notes 14 (8). </note>
Reference: [YY91] <author> Wei Jen Yeh and Michal Young. </author> <title> Compositional reachability analysis using process algebra. </title> <booktitle> In Proceedings of the Symposium on Software Testing, Analysis, and Verification (TAV4), </booktitle> <pages> pages 49-59, </pages> <address> Victoria, British Columbia, </address> <month> October </month> <year> 1991. </year> <booktitle> ACM SIGSOFT, </booktitle> <publisher> ACM Press. </publisher>
Reference-contexts: Analysis of the user interface example described here relies on division along a client/server split. In work reported elsewhere <ref> [Yeh93, YY91, YY93, YY94] </ref> we are developing approaches to hierarchically combine these modular analyses. 2 Analysis approach The term "reachability analysis" is used to describe construction of a state-transition model of larger modules (or a complete system) from models of individual processes. <p> We have constructed a separate prototype to experiment with scalable, divide-and-conquer analysis (but which does not address tool integration or other critical constraints on Cats); the result of this effort is reported elsewhere <ref> [Yeh93, YY91, YY94] </ref>. Our experience suggests a modular analysis will be practical for large but well-structured systems if graphs representing a few thousands of states and events are constructed and analyzed in a few minutes. <p> Symbolic execution to perform such a translation is similar to loop unrolling in an optimizing compiler. We have constructed a separate prototype processor for the Ada-like design language PAL that performs this transformation automatically <ref> [YY91] </ref>, but since the tool described here does not yet include a symbolic evaluator, we performed the unrolling manually. For a fixed value of room_limit, the butler task is unrolled into 8 the code shown in Figure 12. <p> While the gross size of a program to be analyzed (in lines of code or some other measure) is not an issue, analysis is typically limited to small collections of tasks on the order of a dozen. (Hierarchical composition of these small collections is possible; <ref> [YY91] </ref> describes encouraging progress in this direction.) Accuracy of the analysis is limited by elision of details, including control flow determined by variables whose values are not completely modeled. We stress, however, that Cats is not intended to be used as a standalone analysis tool. <p> TIG and TICG structures can be stored for further use, both for incremental composition with TIG or TICG representations of other parts of a system and for use in other analysis techniques. Incremental composition is discussed elsewhere <ref> [YY91] </ref>; here we briefly consider some other uses of TICGs. <p> Cats does not currently provide automated support for dividing a system into modules for analysis or composing analysis results, although a system that uses program scope structure and communication topology to automatically parcel an analysis is reported in <ref> [YY91, YY93, Yeh93] </ref>; this approach will be incorporated in a future version of Cats. 7 Conclusion The challenge in designing Cats was to meet and balance multiple and sometimes conflicting objectives. Any one of these dimensions could have been improved by sacrificing others. <p> While the well-known state explosion problem makes global analysis intractable, task interactions in subsystems well beyond the comprehension of unaided programmers can be exhaustively analyzed in a few minutes, and the hierarchical techniques reported in <ref> [YY91, YY93, Yeh93] </ref> will permit future versions of Cats to analyze considerably larger collections of tasks. Our experience applying Cats to an application built using the Chiron user interface development system suggests that analysis of natural modules of real programs can be both practical and useful.
Reference: [YY93] <author> Wei Jen Yeh and Michal Young. </author> <title> Compositional reachability analysis of Ada programs using process algebra. </title> <type> Technical Report SERC-TR-81-P, </type> <institution> Software Engineering Research Center, Department of Computer Sciences, Purdue University, </institution> <month> July </month> <year> 1993. </year> <note> Submitted for publication. </note>
Reference-contexts: Analysis of the user interface example described here relies on division along a client/server split. In work reported elsewhere <ref> [Yeh93, YY91, YY93, YY94] </ref> we are developing approaches to hierarchically combine these modular analyses. 2 Analysis approach The term "reachability analysis" is used to describe construction of a state-transition model of larger modules (or a complete system) from models of individual processes. <p> Since human judgement seems necessary in this modeling decision, we envision (but have not yet implemented) a facility by which the user indicates which variables should be unfolded, and to what extent. We have implemented variable unfolding in a separate prototype tool <ref> [Yeh93, YY93, YY94] </ref> and see no technical obstacle to supporting better user control. A TIG representation of the unrolled version of the butler was constructed and the analysis was repeated, see Table 1 part iii. <p> Cats does not currently provide automated support for dividing a system into modules for analysis or composing analysis results, although a system that uses program scope structure and communication topology to automatically parcel an analysis is reported in <ref> [YY91, YY93, Yeh93] </ref>; this approach will be incorporated in a future version of Cats. 7 Conclusion The challenge in designing Cats was to meet and balance multiple and sometimes conflicting objectives. Any one of these dimensions could have been improved by sacrificing others. <p> While the well-known state explosion problem makes global analysis intractable, task interactions in subsystems well beyond the comprehension of unaided programmers can be exhaustively analyzed in a few minutes, and the hierarchical techniques reported in <ref> [YY91, YY93, Yeh93] </ref> will permit future versions of Cats to analyze considerably larger collections of tasks. Our experience applying Cats to an application built using the Chiron user interface development system suggests that analysis of natural modules of real programs can be both practical and useful.
Reference: [YY94] <author> Wei Jen Yeh and Michal Young. </author> <title> Redesigning tasking structures of Ada programs for analysis: A case study. Journal of Software Testing, Verification, and Reliability, </title> <month> December </month> <year> 1994. </year> <note> To appear. An earlier version is available as SERC-TR-148-P, </note> <institution> Department of Computer Sciences, Purdue University. Young et al: </institution> <note> Concurrency analysis tool suite </note>
Reference-contexts: Analysis of the user interface example described here relies on division along a client/server split. In work reported elsewhere <ref> [Yeh93, YY91, YY93, YY94] </ref> we are developing approaches to hierarchically combine these modular analyses. 2 Analysis approach The term "reachability analysis" is used to describe construction of a state-transition model of larger modules (or a complete system) from models of individual processes. <p> We have constructed a separate prototype to experiment with scalable, divide-and-conquer analysis (but which does not address tool integration or other critical constraints on Cats); the result of this effort is reported elsewhere <ref> [Yeh93, YY91, YY94] </ref>. Our experience suggests a modular analysis will be practical for large but well-structured systems if graphs representing a few thousands of states and events are constructed and analyzed in a few minutes. <p> Since human judgement seems necessary in this modeling decision, we envision (but have not yet implemented) a facility by which the user indicates which variables should be unfolded, and to what extent. We have implemented variable unfolding in a separate prototype tool <ref> [Yeh93, YY93, YY94] </ref> and see no technical obstacle to supporting better user control. A TIG representation of the unrolled version of the butler was constructed and the analysis was repeated, see Table 1 part iii.
References-found: 56

