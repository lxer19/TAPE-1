URL: ftp://ftp.cs.washington.edu/pub/constraints/papers/hclp-tr-nov-88.ps.Z
Refering-URL: http://www.cs.washington.edu/research/constraints/hclp/hclp-iclp-89.html
Root-URL: 
Email: internet: borning@cs.washington.edu mjm@ibm.com amy@cs.washington.edu molly@cs.washington.edu  
Title: Constraint Hierarchies and Logic Programming  
Author: Alan Borning, Michael Maher, Amy Martindale, and Molly Wilson Alan Borning, Amy Martindale, and Molly Wilson Michael Maher 
Address: P.O. Box 704 Seattle, Washington 98195 Yorktown Heights, New York 10598  
Affiliation: Computer Science Department, FR-35 IBM T.J. Watson Research Center University of Washington  
Note: Authors' addresses:  
Abstract: Technical Report 88-11-10 Computer Science Department University of Washington November 1988 Abstract. Constraint Logic Programming (CLP) is a general scheme for extending logic pro gramming to include constraints. It is parameterized by D, the domain of the constraints. However, CLP(D) languages, as well as most other constraint systems, only allow the programmer to specify constraints that must hold. In many applications, such as interactive graphics, page layout, and decision support, one needs to express preferences as well as strict requirements. If we wish to make full use of the constraint paradigm, we need ways to represent these defaults and preferences declaratively, as constraints, rather than encoding them in the procedural parts of the language. We describe a scheme for extending CLP(D) to include both required and preferential constraints, with an arbitrary number of strengths of preference. We present some of the theory of such languages, and an algorithm for executing them. To test our ideas, we have implemented an interpreter for an instance of this language scheme with D equal to the reals. We describe our interpreter, and outline some examples of using this language. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alan Borning, Robert Duisberg, Bjorn Freeman-Benson, Axel Kramer, and Michael Woolf. </author> <title> Constraint Hierarchies. </title> <booktitle> In Proceedings of the 1987 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 48-60. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1987. </year>
Reference-contexts: Early versions of ThingLab implemented these defaults in an ad hoc fashion as part of the constraint satisfaction algorithm. Later, to allow such defaults and preferences to be specified explicitly and declaratively, we devised a theory of constraint hierarchies <ref> [1] </ref>, which allows a user to specify not only constraints that must hold, but also weaker constraints at an arbitrary number of strengths. The constraint hierarchy scheme is parameterized by a comparator C that allows us to compare different possible solutions to the hierarchy and select the best ones. <p> The constraint hierarchy scheme is parameterized by a comparator C that allows us to compare different possible solutions to the hierarchy and select the best ones. We have also implemented several algorithms for satisfying such hierarchies within ThingLab <ref> [1, 12] </ref>. Defaults and preferences arise naturally when trying to use constraint logic programming for interactive graphics, as well as for other applications, for example, decision support systems. <p> Then S LSB S LB . Proposition: 888H locally-better (; ; H) ! weighted-sum-better (; ; H) Corollary: Let S WSB denote the solutions for a hierarchy H for weighted-sum-better. Then S WSB S LB . The proofs are similar to those given in <ref> [1] </ref>. The converse of each of the propositions and corollaries does not hold: for example, least-squares-better does not imply locally-better. We end this section with a few comments on the comparators. The definitions of the global comparators include weights on the constraints. <p> This allows fact that cannot be proved from 1 If S 0 is non-empty and finite, however, then S will be non-empty as well. See <ref> [1] </ref> for a proof. 2 A little care is needed in writing the comparator, lest we wind up in the same situation as before, where for any possible valuation, a better one exists.
Reference: [2] <author> Alan H. Borning. </author> <title> The Programming Language Aspects of ThingLab, A Constraint-Oriented Simulation Laboratory. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(4) </volume> <pages> 353-387, </pages> <month> October </month> <year> 1981. </year>
Reference-contexts: If we wish to make full use of the constraint paradigm, we need ways to represent these defaults and preferences declaratively, as constraints, rather than encoding them in the procedural parts of the language. Consider an interactive graphics example from our own work on ThingLab <ref> [2] </ref>. Suppose we have a line with a point constrained to lie at its midpoint (Figure 1). If we pick up one end of the line with the mouse and move it about, the constraint will ensure that the midpoint relation remains satisfied. <p> In a similar manner, we can (without any hard thinking required) translate all of the ThingLab examples given in <ref> [2] </ref> into HCLP. For the more complex examples, the HCLP code becomes tediously long. However (as with ThingLab), we envision such code being written automatically by the interactive graphics application, rather than by a person.
Reference: [3] <author> Alan H. Borning and Robert A. Duisberg. </author> <title> Constraint-Based Tools for Building User Interfaces. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5(4), </volume> <month> October </month> <year> 1986. </year>
Reference: [4] <author> K. L. Clark. </author> <title> Negation as Failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Databases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: We write P 0 * for the Clark-completion <ref> [4, 18] </ref> (sometimes called the IFF-definition) of a logic program P 0 .
Reference: [5] <author> Alain Colmerauer. </author> <title> An Introduction to Prolog III. </title> <type> Draft, </type> <institution> Groupe Intelligence Artificielle, Uni-versite Aix-Marseille II, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: In place of unification (which can be viewed as testing the satisfiability of equations over the Herbrand universe), constraints are accumulated and tested for satisfiability over D, using techniques appropriate to the domain. Several such languages have now been implemented, including Prolog III <ref> [5] </ref>, CLP (R) [14, 17] and CHIP [7]. The formal semantics of such languages differ mainly in the choice of underlying domain and constraints, as was shown formally in [16].
Reference: [6] <author> M. Davis and R. Hersh. </author> <title> Nonstandard Analysis. </title> <publisher> Scientific American, </publisher> <month> June </month> <year> 1972. </year>
Reference-contexts: But the valuation mapping N to p=2 is better than v, and so v can't be in S. Hence S is empty. 1 To resolve such problems, we are investigating the use of non-standard analysis <ref> [6, 20, 31] </ref>. Using non-standard analysis, we would define the the error for X &gt; Y to be * if X and Y are equal, for some infinitesimally small number *.
Reference: [7] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Bertheir. </author> <title> The Constraint Logic Programming Language CHIP. </title> <type> Draft, </type> <institution> European Computer-Industry Research Center, Munich, West Germany. </institution>
Reference-contexts: Several such languages have now been implemented, including Prolog III [5], CLP (R) [14, 17] and CHIP <ref> [7] </ref>. The formal semantics of such languages differ mainly in the choice of underlying domain and constraints, as was shown formally in [16].
Reference: [8] <author> Robert A. Duisberg. </author> <title> Constraint-Based Animation: The Implementation of Temporal Constraints in the Animus System. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <year> 1986. </year> <note> Published as U.W. Computer Science Department Technical Report No. 86-09-01. </note>
Reference: [9] <author> Raimund Ege, David Maier, and Alan Borning. </author> <title> The Filter Browser|Defining Interfaces Graphically. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming, </booktitle> <pages> pages 155 165, </pages> <address> Paris, </address> <month> June </month> <year> 1987. </year> <institution> Association Fran~caise pour la Cybernetique Economique et Technique. </institution>
Reference-contexts: However, since we have the full power of logic programming available, we can do considerably more. For example, we have been investigating the use of filters as a technique for the declarative construction of user interfaces. In the filter browser described in <ref> [9] </ref>, the screen view of some source object is constructed by passing the object through a series of filters to produce the final image. Each filter is represented as a constraint relating its input and output. Thus the view is updated if the source changed.
Reference: [10] <author> David W. Etherington. </author> <title> Formalizing Nonmonotonic Reasoning Systems. </title> <journal> Artificial Intelligence, </journal> <volume> 31(1) </volume> <pages> 41-85, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Similarly, a solution to the hierarchy require N&gt;0, prefer N=0 would be a valuation that maps N to an infinitesimal. 2 7.4 Relation to Nonmonotonic Logic The artificial intelligence literature includes a substantial body of literature on nonmonotonic reasoning (see e.g. <ref> [10, 26, 30] </ref>). Some of the high-level goals of this work overlap strongly with those of our own, but once one moves to the actual details of the formalisms, there are distinct differences. Thus another direction for future research will be to elucidate the relation between the formalisms.
Reference: [11] <author> David W. Etherington and Raymond Reiter. </author> <title> On Inheritance Hierarchies With Exceptions. </title> <booktitle> In Proceedings AAAI-83, </booktitle> <year> 1983. </year>
Reference-contexts: Although there are some applications, such as inheritance hierarchies, where the default rules of a default logic can be manipulated to eliminate extensions, the addition of new rules often requires rewriting of the old ones because information about exceptions is encoded explicitly into the rules <ref> [11] </ref>. In HCLP, preferences can be expressed simply by the strength given to a constraint. Adding new constraints may require reordering of existing ones if all the stronger levels are being used, but the constraints themselves can stay the same.
Reference: [12] <author> Bjorn Freeman-Benson and John Maloney. </author> <title> The DeltaBlue Algorithm: An Incremental Constraint Hierarchy Solver. </title> <booktitle> In Proceedings of the Eighth Annual IEEE Phoenix Conference on Computers and Communications, </booktitle> <address> Scottsdale, Arizona, </address> <month> March </month> <year> 1989. </year> <note> IEEE. To appear. </note>
Reference-contexts: The constraint hierarchy scheme is parameterized by a comparator C that allows us to compare different possible solutions to the hierarchy and select the best ones. We have also implemented several algorithms for satisfying such hierarchies within ThingLab <ref> [1, 12] </ref>. Defaults and preferences arise naturally when trying to use constraint logic programming for interactive graphics, as well as for other applications, for example, decision support systems.
Reference: [13] <author> James A. Gosling. </author> <title> Algebraic Constraints. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> May </month> <year> 1983. </year> <note> Published as CMU Computer Science Department tech report CMU-CS-83-132. </note>
Reference: [14] <author> N. Heintze, J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> The CLP(&lt;) Programmer's Manual. </title> <type> Technical report, </type> <institution> Computer Science Dept, Monash University, </institution> <year> 1987. </year>
Reference-contexts: In place of unification (which can be viewed as testing the satisfiability of equations over the Herbrand universe), constraints are accumulated and tested for satisfiability over D, using techniques appropriate to the domain. Several such languages have now been implemented, including Prolog III [5], CLP (R) <ref> [14, 17] </ref> and CHIP [7]. The formal semantics of such languages differ mainly in the choice of underlying domain and constraints, as was shown formally in [16].
Reference: [15] <author> T. Huynh and C. Lassez. </author> <title> A CLP(&lt;) Options Trading Analysis System. </title> <booktitle> In Proceedings of 5th International Conference and Symposium of Logic Programming, </booktitle> <pages> pages 59-69, </pages> <year> 1988. </year>
Reference-contexts: The problem of programming an options trading analysis system (OTAS) <ref> [15] </ref> provides some realistic examples of where it would be useful to compare solutions arising from alternate choices of rules. If this were supported, HCLP would have some clear advantages as a language for implementing such systems.
Reference: [16] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proceedings of the 14th ACM Principles of Programming Languages Conference, </booktitle> <address> Munich, </address> <month> January </month> <year> 1987. </year> <note> ACM. </note>
Reference-contexts: 1 Introduction Recently there has been considerable research on extending logic programming to include constraints. This extension significantly increases the expressiveness of such languages. Constraint Logic Pro gramming <ref> [16] </ref> is a general scheme for such extensions, and is parameterized by D, the domain of the constraints. The language that arises from a fixed set of constraints over D can be denoted by CLP (D). <p> Several such languages have now been implemented, including Prolog III [5], CLP (R) [14, 17] and CHIP [7]. The formal semantics of such languages differ mainly in the choice of underlying domain and constraints, as was shown formally in <ref> [16] </ref>. It was also shown that for every language that can be obtained from the CLP scheme for solution-compact domains D, numerous desirable properties of the declarative and operational semantics hold|properties that had been considered characteristic of logic programming. In particular, CLP languages have coincident logical, fixedpoint, and operational semantics. <p> There are further results|which we will not state formally here|that associate the ground finite failure set with the greatest fixedpoint of T P 0 , and that can give a characterization of finite failure using D instead of D, provided D is solution-compact and the program is canonical <ref> [16] </ref>. 6 An Algorithm for Interpreting HCLP Programs In this section we sketch an algorithm for interpreting HCLP (D; LPB) programs. A complete description is given in Appendix A. In addition, we have written a proof of correctness for the algorithm, which we plan to publish separately [37].
Reference: [17] <author> J. Jaffar and S. Michaylov. </author> <title> Methodology and Implementation of a CLP System. </title> <booktitle> In Proceedings of the 4th International Conference on Logic Programming, </booktitle> <year> 1987. </year>
Reference-contexts: In place of unification (which can be viewed as testing the satisfiability of equations over the Herbrand universe), constraints are accumulated and tested for satisfiability over D, using techniques appropriate to the domain. Several such languages have now been implemented, including Prolog III [5], CLP (R) <ref> [14, 17] </ref> and CHIP [7]. The formal semantics of such languages differ mainly in the choice of underlying domain and constraints, as was shown formally in [16].
Reference: [18] <author> Joxan Jaffar, Jean-Louis Lassez, and Michael J. Maher. </author> <title> A Logic Programming Language Scheme. </title> <editor> In D. DeGroot and G. Lindstrom, editors, </editor> <title> Logic Programming: Relations, Functions and Equations. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year> <month> 20 </month>
Reference-contexts: We write P 0 * for the Clark-completion <ref> [4, 18] </ref> (sometimes called the IFF-definition) of a logic program P 0 .
Reference: [19] <author> Kenneth Kahn, Eric Tribble, Mark Miller, and Daniel Bobrow. </author> <title> Objects in Concurrent Logic Programming Languages. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 242-257, </pages> <address> Portland, Oregon, </address> <month> September </month> <year> 1986. </year> <note> ACM. </note>
Reference-contexts: Concurrent Prolog [32] and Vulcan <ref> [19] </ref>, is to represent an object as a process that consumes messages, recursively calling itself with the next state of the object as an argument.
Reference: [20] <author> J. Keisler. </author> <title> Foundations of Infinitessimal Calculus. </title> <editor> Prindle, Webber and Schmidt, </editor> <publisher> Inc., </publisher> <address> Boston, </address> <year> 1976. </year>
Reference-contexts: But the valuation mapping N to p=2 is better than v, and so v can't be in S. Hence S is empty. 1 To resolve such problems, we are investigating the use of non-standard analysis <ref> [6, 20, 31] </ref>. Using non-standard analysis, we would define the the error for X &gt; Y to be * if X and Y are equal, for some infinitesimally small number *.
Reference: [21] <author> M. Konopasek and S. Jayaraman. </author> <title> The TK!Solver Book. </title> <address> Osborne/McGraw-Hill, Berkeley, CA, </address> <year> 1984. </year>
Reference: [22] <author> William Leler. </author> <title> Specification and Generation of Constraint Satisfaction Systems Using Augmented Term Rewriting. </title> <type> PhD thesis, </type> <institution> University of North Carolina at Chapel Hill, </institution> <year> 1986. </year>
Reference: [23] <author> William Leler. </author> <title> Constraint Programming Languages. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: programming, constraints have proven useful for a variety of applications, in cluding geometric layout, physical simulations, user interface design, document formatting, algorithm animation, and design and analysis of mechanical devices and electrical circuits. (See for example [2, 3, 8, 13, 21, 22, 24, 27, 29, 33, 34, 35, 36], and <ref> [23] </ref> for a survey.) Many such applications require some notion of defaults and preferences. If we wish to make full use of the constraint paradigm, we need ways to represent these defaults and preferences declaratively, as constraints, rather than encoding them in the procedural parts of the language.
Reference: [24] <author> David Levitt. </author> <title> Machine Tongues X: Constraint Languages. </title> <journal> Computer Music Journal, </journal> <volume> 8(1) </volume> <pages> 9-21, </pages> <month> Spring </month> <year> 1984. </year>
Reference: [25] <author> Michael J. Maher. </author> <title> Logic Semantics for a Class of Committed-choice Programs. </title> <booktitle> In Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <pages> pages 858-876, </pages> <address> Melbourne, Australia, </address> <month> May </month> <year> 1987. </year> <note> ICALP. </note>
Reference-contexts: In this paper a constraint is a primitive constraint. However the results of this section extend to larger classes of constraints, as in <ref> [25] </ref>. We write P j= D Q if Q holds in every model of P that has 8 the same universe as D and assigns the same meaning to function symbols and constraint predicate symbols as D. We use (9) to denote existential closure.
Reference: [26] <author> John McCarthy. </author> <title> Circumscription|A Form of Non-Monotonic Reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13(1,2):27-39, </volume> <month> April </month> <year> 1980. </year>
Reference-contexts: Similarly, a solution to the hierarchy require N&gt;0, prefer N=0 would be a valuation that maps N to an infinitesimal. 2 7.4 Relation to Nonmonotonic Logic The artificial intelligence literature includes a substantial body of literature on nonmonotonic reasoning (see e.g. <ref> [10, 26, 30] </ref>). Some of the high-level goals of this work overlap strongly with those of our own, but once one moves to the actual details of the formalisms, there are distinct differences. Thus another direction for future research will be to elucidate the relation between the formalisms.
Reference: [27] <author> Sanjay Mittal, Clive L. Dym, and Mahesh Morjaria. PRIDE: </author> <title> An Expert System for the Design of Paper Handling Systems. </title> <booktitle> Computer, </booktitle> <pages> pages 102-114, </pages> <month> July </month> <year> 1986. </year>
Reference: [28] <author> Katta G. Murty. </author> <title> Linear Programming. </title> <publisher> Wiley, </publisher> <year> 1983. </year>
Reference-contexts: The locally-better comparator is derived from the concept of a vector minimum (or pareto-optimal point, or nondom-inated feasible solution) in multiobjective linear programming problems <ref> [28] </ref>. Finally, the standard linear programming problem of minimizing an objective function subject to a set of linear inequality conditions can be easily expressed as a constraint hierarchy.
Reference: [29] <author> Greg Nelson. Juno, </author> <title> A Constraint-Based Graphics System. </title> <editor> In B.A. Barsky, editor, </editor> <booktitle> SIGGRAPH '85 Conference Proceedings, </booktitle> <pages> pages 235-243, </pages> <address> San Francisco, </address> <month> July </month> <year> 1985. </year> <note> ACM. </note>
Reference: [30] <author> Raymond Reiter. </author> <title> A Logic for Default Reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13(1,2):81-132, </volume> <month> April </month> <year> 1980. </year>
Reference-contexts: Similarly, a solution to the hierarchy require N&gt;0, prefer N=0 would be a valuation that maps N to an infinitesimal. 2 7.4 Relation to Nonmonotonic Logic The artificial intelligence literature includes a substantial body of literature on nonmonotonic reasoning (see e.g. <ref> [10, 26, 30] </ref>). Some of the high-level goals of this work overlap strongly with those of our own, but once one moves to the actual details of the formalisms, there are distinct differences. Thus another direction for future research will be to elucidate the relation between the formalisms.
Reference: [31] <author> A. Robinson. </author> <title> Non-Standard Analysis. </title> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1966. </year>
Reference-contexts: But the valuation mapping N to p=2 is better than v, and so v can't be in S. Hence S is empty. 1 To resolve such problems, we are investigating the use of non-standard analysis <ref> [6, 20, 31] </ref>. Using non-standard analysis, we would define the the error for X &gt; Y to be * if X and Y are equal, for some infinitesimally small number *.
Reference: [32] <author> Ehud Shapiro. </author> <title> Concurrent Prolog: A Progress Report. </title> <journal> IEEE Computer, </journal> <volume> 19(8) </volume> <pages> 44-58, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Concurrent Prolog <ref> [32] </ref> and Vulcan [19], is to represent an object as a process that consumes messages, recursively calling itself with the next state of the object as an argument.
Reference: [33] <author> Guy L. Steele Jr. </author> <title> The Definition and Implementation of a Computer Programming Language Based on Constraints. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <month> August </month> <year> 1980. </year> <note> Published as MIT-AI TR 595, </note> <month> August </month> <year> 1980. </year>
Reference: [34] <author> Gerald J. Sussman and Guy L. Steele Jr. </author> <title> CONSTRAINTS|A Language for Expressing Almost-Hierarchical Descriptions. </title> <journal> Artificial Intelligence, </journal> <volume> 14(1) </volume> <pages> 1-39, </pages> <month> January </month> <year> 1980. </year>
Reference: [35] <author> Ivan Sutherland. </author> <title> Sketchpad: A Man-Machine Graphical Communication System. </title> <booktitle> In Proceedings of the Spring Joint Computer Conference. IFIPS, </booktitle> <year> 1963. </year>
Reference: [36] <author> Christopher J. van Wyk. </author> <title> A High-level Language for Specifying Pictures. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 1(2), </volume> <month> April </month> <year> 1982. </year>
Reference: [37] <author> Molly Wilson. </author> <title> A Proof of Correctness of an Algorithm for Executing Constraint Hierarchy Logic Programs. </title> <note> To be submitted for publication, 1989. 21 </note>
Reference-contexts: A complete description is given in Appendix A. In addition, we have written a proof of correctness for the algorithm, which we plan to publish separately <ref> [37] </ref>. The algorithm works for any constraint domain D, but is specific to the locally-predicate-better comparator. The algorithm has two phases. In the first phase, the algorithm attempts to reduce a goal using only predicates and required constraints, while building up a hierarchy of non-required constraints.
References-found: 37

