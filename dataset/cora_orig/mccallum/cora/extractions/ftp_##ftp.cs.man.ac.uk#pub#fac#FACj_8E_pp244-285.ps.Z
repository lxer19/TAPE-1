URL: ftp://ftp.cs.man.ac.uk/pub/fac/FACj_8E_pp244-285.ps.Z
Refering-URL: http://www.cs.man.ac.uk/fmethods/facj/e-papers/index.html
Root-URL: http://www.cs.man.ac.uk
Title: of Computing A Tactic Calculus Full Version  
Author: A. P. Martin P. H. B. Gardiner and J. C. P. Woodcock ; 
Keyword: Angelic nondeterminism; Tactics; Denotational semantics; Structural combinators; Program transformation  
Address: Oxford, UK  Oxford, UK  
Affiliation: 1 Programming Research Group, Oxford University Computing Laboratory,  Ltd.,  
Note: Formal Aspects of Computing (1996) 8(E): 244-285 c 1996 BCS Formal Aspects  2 Formal Systems (Europe)  
Abstract: We present a very general language for expressing tactic programs. The paper describes some essential tactic combinators (tacticals), and gives them a formal semantics. Those definitions are used to produce a complete calculus for reasoning about tactics written in this language. The language is extended to cover structural combinators which enable the tactics to be precisely targeted upon particular sub-expressions. 
Abstract-found: 1
Intro-found: 1
Reference: [Bir86] <author> Bird, R. S.: </author> <title> An introduction to the theory of lists. </title> <type> Technical Monograph PRG-56, </type> <institution> Oxford University Computing Laboratory, </institution> <address> Wolfson Building, Parks Road, Oxford, OX1 3QD, UK, </address> <year> 1986. </year>
Reference-contexts: Proof. The proofs of these laws depend on simple properties of lists and functional composition. They are all quite similar. Only a small selection is presented here. The lemmas and properties referred to below are discussed in <ref> [Bir88, Bir86] </ref>.
Reference: [Bir88] <author> Bird, R. S.: </author> <title> Lectures on constructive functional programming. </title> <type> Technical Monograph PRG-69, </type> <institution> Oxford University Computing Laboratory, </institution> <address> Wolfson Building, Parks Road, Oxford, OX1 3QD, UK, </address> <year> 1988. </year>
Reference-contexts: We will, therefore, use lists to describe the possible outcomes of a tactic application. A suitable account of the theory of lists will be found in <ref> [Bir88] </ref>. An appendix gives some of the more important definitions. <p> Proof. The proofs of these laws depend on simple properties of lists and functional composition. They are all quite similar. Only a small selection is presented here. The lemmas and properties referred to below are discussed in <ref> [Bir88, Bir86] </ref>. <p> 4 fl t 2 ] fl break Key Lemma = combine fl cross [t 1 ; t 3 ; t 2 ; t 4 ] fl break Definition of ; = (t 1 ; t 3 ) (t 2 ; t 4 ) Definition of Lemmas (to be found in <ref> [Bir88] </ref>) f id fl = f f fl g fl = (f g )fl Key Lemma (subject to proviso): ++= cross [t 3 ; t 4 ] fl cross [t 1 ; t 2 ] = cross [++= t 3 fl t 1 ; ++= t 4 fl t 2 ]
Reference: [BN + 92] <author> Brien, S. M., Nicholls, J. E., et al.: </author> <title> Z base standard. </title> <type> ZIP Project Technical Report ZIP/PRG/92/121, </type> <note> SRC Document: 132, Version 1.0, </note> <institution> Oxford University Computing Laboratory, </institution> <address> Wolfson Building, Parks Road, Oxford, OX1 3QD, UK, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: P. Martin, P. H. B. Gardiner and J. C. P. Woodcock 12.3. Laws on con con distributes whenever no variable capture is caused. The side-conditions are phrased using OE (by analogy with the Z semantics <ref> [BN + 92] </ref> )|intended to extract the set of free (meta-)variables of the tactic to which it is applied.
Reference: [Bro83] <author> Brookes, S. D.: </author> <title> A Model for Communicating Sequential Processes. D.Phil. </title> <type> thesis, </type> <institution> University of Oxford, </institution> <month> January </month> <year> 1983. </year>
Reference-contexts: The ideas are similar to those used in proving the completeness of a proof system for a process algebra, e.g. <ref> [Bro83] </ref>. The completeness is relative to the rule system over which the tactics are applied, since two rules may be equivalent without there being any tactic equivalence between them. As such, we regard tactics as being syntactic objects with the names of the rules they invoke as free variables.
Reference: [Bur75] <author> Burge, W. H.: </author> <title> Recursive Programming Techniques. </title> <publisher> Addison-Wesley, </publisher> <year> 1975. </year>
Reference-contexts: The usefulness of lazy lists to implement backtracking has been known in 18 Strongly valid tactics are those which cannot lead `up a blind alley'. If given an achievable (provable) goal, they return achievable subgoals. A Tactic Calculus | Full Version 281 functional programming circles for some time. Burge <ref> [Bur75] </ref> discusses such backtracking in the context of top-down parsing, and Wadler [Wad85] presents a whole parser toolkit in this style. The parser combinators are very similar to those given here. For example, lit x is a parser combinator which matches a string whose first character is x.
Reference: [Dij76] <author> Dijkstra, E. W.: </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: As well as succeeding (producing a new expression) or failing to apply, it may fail to terminate and run indefinitely. Whilst such a tactic will not in general be useful when writing tactic programs, it is helpful to be able to reason about it. We follow Dijkstra <ref> [Dij76] </ref> and call the non-terminating program abort Depending on the form of the expressions to which the rules and tactics apply, it is often appropriate to incorporate structural combinators 2 in the tactic language. These permit the controlled application of tactics to particular sub-expressions.
Reference: [Fel93] <author> Felty, A.: </author> <title> Implementing tactics and tacticals in a higher-order logic programming language. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 11 </volume> <pages> 43-81, </pages> <year> 1993. </year>
Reference-contexts: Isabelle implements cut as DETERM. The semantics is given using the tacticals' ML definitions; only one algebraic law is given|the one stating that all tac (i.e. skip) is an identity for THEN. Felty's tactic language <ref> [Fel93] </ref> is also very similar to that presented in this paper, complete with the backtracking suggested by the alternation tactical. Its semantics is given via its logic-programming implementation, and as such has a more relational style of approach than that seen here.
Reference: [FrL89] <author> Frost, R. and Launchbury, J.: </author> <title> Constructing natural language interpreters in a lazy functional language. </title> <journal> The Computer Journal, </journal> <volume> 32(2) </volume> <pages> 108-121, </pages> <year> 1989. </year>
Reference-contexts: [("b","anana")] seq list2 (lit 'b') (lit 'a') "banana" = [("ba","nana")] The exhaust tactical is coded as rep: rep (lit 'a') "aardvark" = [("aa","rdvark"),("a","ardvark"),("","aardvark")] Thus we would expect the theory described in this paper to be applicable to this work|and to systems based on it, such as the parser described in <ref> [FrL89] </ref>. Wadler notes that an added benefit of this method of handling backtracking and failure is the avoidance of any need to consider exception handling. Moreover this tactic language may be applied to another idea in the theorem-proving world: in LCF/HOL, rewriting is extensively used for simplification in theorem-proving.
Reference: [GMW79] <author> Gordon, M. J. C., Milner, R. and Wadsworth, C. P.: </author> <title> Edinburgh LCF: A Mecha-nised Logic of Computation, </title> <booktitle> volume 78 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: 1. Introduction The programs which are used to direct theorem-proving tools have traditionally been described as tactics <ref> [GMW79] </ref>. We present Angel|a very general language for expressing tactic programs, making very few assumptions about the form of the expressions (goals) in the target logic, and about the rules which act upon them, transforming one expression into another. <p> Two special atomic tactics exhibit these two behaviours. The first always succeeds, leaving its expression unchanged; the second always fails: skip fail Functions which operate on tactics, returning new tactics as a result, are conventionally called tacticals <ref> [GMW79] </ref>. Fundamentally, tactics can be combined in two ways: in alternation or in sequence. <p> Comparison with Other Work The work on the tactic language follows a long history of work in the theorem-proving and functional programming communities. The fundamental tacticals introduced here originate in the work on Edinburgh LCF <ref> [GMW79] </ref>. There, they appear as THEN and ORELSE|the latter being a cut version of our alternation operator. The LCF treatment of tactics differs from that presented here, in that LCF's inference rules are quite distinct from the set of tactics, and not a subset, as we have presented them here.
Reference: [GSH92] <author> Goguen, J. Stevens, A., Hilberdink, H. and Hobley, K.: 2OBJ: </author> <title> A Metalogical Theorem Prover based on Equational Logic. </title> <journal> Philosophical Transactions of the Royal Society, Series A, </journal> <volume> 339 </volume> <pages> 69-86, </pages> <year> 1992. </year> <note> Also in C. </note> <editor> A. R. Hoare and M. J. C. Gordon, editors, </editor> <title> Mechanized Reasoning and Hardware Design, </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: Schmidt's goal is similar to ours|the discovery of a language which will facilitate `formulation of high level algorithms that can be compared, analyzed, and even ported across theorem proving systems.' He does not present a formal treatment of failure, or of recursion. 2OBJ <ref> [GSH92] </ref> builds on many of the ideas in LCF, but implements rules and tactics in the way which has been discussed above|with rules as a (clearly delineated) subsort of the sort of tactics.
Reference: [HOS85] <editor> Hoare, C. A. R., and Shepherdson, J. C.: editors. </editor> <booktitle> Mathematical Logic and Programming Languages. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference: [LOS87] <author> Loeckx, J. and Sieber, K.: </author> <title> The Foundations of Program Verification. </title> <booktitle> Wiley-Teubner Series in Computer Science, second edition, </booktitle> <year> 1987. </year>
Reference-contexts: This is accomplished in a pointwise manner. A suitable treatment can be found in <ref> [LOS87] </ref>. The relevant definitions are as follows: t 1 v T t 2 , (8 g : G * t 1 g v 1 t 2 g ) T G 9.2. <p> For f a function from tactics to tactics, we have that G i : N * f i (abort) Again, this is a standard construction, covered, for example in <ref> [LOS87] </ref>. It requires that the tacticals used to define f are continuous|and those defined above can be shown to have this property.
Reference: [Mar93] <author> Martin, A.: </author> <title> Infinite lists in Z. </title> <type> Draft paper, </type> <year> 1993. </year>
Reference-contexts: P. Martin, P. H. B. Gardiner and J. C. P. Woodcock 9.1. Infinite Lists The style of infinite lists which we shall use is that found in many treatments of functional programming with lazy evaluation. A suitable model for such lists will be found in <ref> [Mar93] </ref>; the definitions remain consistent with those in Appendix B. The datatype of infinite lists differs from that used above by the incorporation of partial and infinite lists.
Reference: [Mar94] <author> Martin, A.: </author> <title> Machine-Assisted Theorem-Proving for Software Engineering. D.Phil. </title> <type> thesis, </type> <institution> University of Oxford, </institution> <month> Michaelmas </month> <year> 1994. </year>
Reference-contexts: Ways of improving on this are discussed in <ref> [Mar94] </ref>. 250 A. P. Martin, P. H. B. Gardiner and J. C. P. Woodcock For a rule with more instances of ^, a more general (recursive) version of comm is needed. <p> Conversely, fails t behaves like skip if t fails, and fails if t succeeds. These tacticals are useful reasoning tools, and they have shown themselves to be useful in writing real tactics, too (see, for example, <ref> [Mar94] </ref>). <p> The situation is slightly better here|con introduces a simple pattern-matching problem, 15 which is solvable for a first-order language, and may be partially soluble for other languages. In the light-weight implementation introduced in <ref> [Mar94] </ref>, this is achieved by appealing to the unification algorithm in the underlying functional language, thus giving one of the implementations proposed above. Implementation of a unification algorithm to give a tactic interpreter precisely the semantics described here is also possible. 12.2.
Reference: [Mil84] <author> Milner, R.: </author> <title> The use of machines to assist in rigorous proof. </title> <journal> Philosophical Transactions of the Royal Society, London. Series A, </journal> <volume> 312 </volume> <pages> 411-422, </pages> <year> 1984. </year> <note> Also in [HOS85]. </note>
Reference-contexts: As a result, the safe datatype is that of proofs, not (as here) that of tactics; tactics are valid if they are able to be validated by compositions of primitive rules. Strongly valid tactics are related to our functionally correct ones. 18 Milner <ref> [Mil84] </ref> generalizes the ideas from LCF somewhat, observing how the notions present in tactic programming (goal, strategy, achievement, and failure) stand together in a far more general setting than merely in the area of machine-assisted proof. An independent semantics for LCF's tactics is found in [Sch84].
References-found: 15

