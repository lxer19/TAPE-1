URL: http://www.cse.psu.edu/~catuscia/papers/Lics93/lics.ps.gz
Refering-URL: http://www.cse.psu.edu/~catuscia/publications.html
Root-URL: http://www.cse.psu.edu
Title: Compositional Analysis for Concurrent Constraint Programming  
Author: Moreno Falaschi Maurizio Gabbrielli Kim Marriott Catuscia Palamidessi 
Abstract: We propose a framework for the analysis of concurrent constraint programming (ccp). Our approach is based on simple denotational semantics which approximate the usual semantics in the sense that they give a superset of the input-output relation of a ccp program. Analyses based on these semantics can be easily and efficiently implemented using standard techniques from the analysis of logic programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Alpuente, M. Falaschi, and N. Manzo. </author> <title> Analyses of Unsatisfiability for Incremental Logic Programming. </title> <editor> In M. Bruynooghe and M. Wirsing, editors, </editor> <booktitle> Proc. of PLILP'92, </booktitle> <volume> LNCS 631, </volume> <pages> pages 443-457. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: [ O Inf (A), with O Fin (A) = fhc; di j there exists B s.t. hA; ci ! fl hB; di 6! g R1 htell (c); di ! hStop; c ^ di R2 h i=1 g i ! A i ; di ! hA j ; di j 2 <ref> [1; n] </ref> and g j = ask (c) and c d hA; ci ! hA 0 ; c 0 i hB k A; ci ! hB k A 0 ; c 0 i hA; d ^ 9 x ci ! hB; d 0 i x A; ci ! h9 d 0
Reference: [2] <author> M. Codish, M. Falaschi, and K. Marriott. </author> <title> Suspension Analysis for Concurrent Logic Programs. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. of the Eight Int. Conf. on Logic Programming, pages 331- 345. </booktitle> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: A particular analysis is obtained by simply choosing a description domain and defining operations on the domain. Correctness of the resulting analysis is guaranteed by our construction and by results from abstract interpretation [5]. Previous related research includes the works of Codognet et al. [4] and Codish et al. <ref> [2, 3] </ref>, who have investigated the analysis of concurrent logic languages, a particular subclass of the ccp languages. Our work primarily differs from these in the semantic basis of the abstract interpreta tion.
Reference: [3] <author> M. Codish, M. Falaschi, K. Marriott, and W. Winsborough. </author> <title> Efficient Analysis of Concurrent Constraint Logic Programs. </title> <editor> In A. Lingas, editor, </editor> <booktitle> Proc. of ICALP,LNCS 1993. </booktitle>
Reference-contexts: A particular analysis is obtained by simply choosing a description domain and defining operations on the domain. Correctness of the resulting analysis is guaranteed by our construction and by results from abstract interpretation [5]. Previous related research includes the works of Codognet et al. [4] and Codish et al. <ref> [2, 3] </ref>, who have investigated the analysis of concurrent logic languages, a particular subclass of the ccp languages. Our work primarily differs from these in the semantic basis of the abstract interpreta tion. <p> Our work primarily differs from these in the semantic basis of the abstract interpreta tion. Codognet et al. base their analysis on a complex and operational AND-OR tree semantics, while Codish et al. base their analysis on a transition system operational semantics. In <ref> [3] </ref> Codish et al. define a new operational semantics, which approximates the standard one, and which is confluent in the sense that different scheduling strategies give isomorphic results, thus simplifying the analysis. The loss of precision introduced by confluence is orthogonal to the loss of precision in our approach. <p> In order to obtain an approximating semantics we have renounced to model faithfully global choice and continuation point. It would be interesting to investigate alternative approximations based on the same domain. One possibility is, for instance, to adopt the idea of <ref> [3] </ref>, where all the alternatives in a choice are enabled as soon as one of the guards is enabled. The framework we have proposed can be extended smoothly to ccp languages with atomic tell ([13]).
Reference: [4] <author> C. Codognet, P. Codognet, and M. Corsini. </author> <title> Abstract Interpretation for Concurrent Logic Languages. </title> <editor> In S. Debray and M. Hermenegildo, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming, </booktitle> <pages> pages 215-232. </pages> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: A particular analysis is obtained by simply choosing a description domain and defining operations on the domain. Correctness of the resulting analysis is guaranteed by our construction and by results from abstract interpretation [5]. Previous related research includes the works of Codognet et al. <ref> [4] </ref> and Codish et al. [2, 3], who have investigated the analysis of concurrent logic languages, a particular subclass of the ccp languages. Our work primarily differs from these in the semantic basis of the abstract interpreta tion.
Reference: [5] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Proc. of POPL, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: A particular analysis is obtained by simply choosing a description domain and defining operations on the domain. Correctness of the resulting analysis is guaranteed by our construction and by results from abstract interpretation <ref> [5] </ref>. Previous related research includes the works of Codognet et al. [4] and Codish et al. [2, 3], who have investigated the analysis of concurrent logic languages, a particular subclass of the ccp languages. Our work primarily differs from these in the semantic basis of the abstract interpreta tion. <p> Abstract interpretation <ref> [5] </ref> formalizes the idea of "approximate computation", where descriptions of data replace the data itself. The idea is that an analysis is a computation in which the program is evaluated using a non-standard interpretation of data and operators in the program.
Reference: [6] <author> F.S. de Boer and C. Palamidessi. </author> <title> A Fully Abstract Model for Concurrent Constraint Programming. </title> <editor> In S. Abramsky and T.S.E. Maibaum, editors, </editor> <booktitle> Proc. of TAPSOFT/CAAP, </booktitle> <volume> LNCS 493, </volume> <pages> pages 296-319. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [7] <author> S. Debray and D.S. Warren. </author> <title> Functional Computations in Logic Programs. </title> <journal> Proc. of TOPLAS, </journal> <pages> pages 451-481, </pages> <year> 1989. </year>
Reference-contexts: The resulting denotation is a set of input-output pairs. Such a semantics is a good basis for efficient dataflow analysis because it is similar to the standard structures used in the analysis of logic programming languages ([11]). Thus, the same implementation techniques such as memoization tables <ref> [7] </ref> and analysis domains and functions can be used with only slight modification. Our denotational model approximates the standard operational semantics in the sense that it contains the input-output information of every possible computation.
Reference: [8] <editor> L. Henkin, J.D. Monk, and A. Tarski. Cylindric Algebras (Part I). </editor> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference-contexts: In order to treat the hiding operator of the language it will be helpful to introduce a sort of existential quantifier. In this framework it is convenient to formalize this notion by means of the theory of cylindric algebras, due to Henkin, Monk and Tarski <ref> [8] </ref>. This leads to the concept of cylindric constraint system. In the following, we assume given a (denumerable) set of variables Var with typical elements x; y; z; : : :. Definition 2.2 Let hC; ; ^; true; falsei be a constraint system. <p> In order to model parameter passing, it will be useful to consider the so-called diagonal formulas 1 The entailment relation `, which is commonly used in the literature, is the reverse of . Formally: 8c; d 2 C: c ` d , d c: <ref> [8] </ref>.
Reference: [9] <author> K. Horiuchi. </author> <title> Less abstract semantics for abstract interpretation of FGHC programs. </title> <booktitle> In Proc. of the Int. Conf. on Fifth Generation Computer Systems, </booktitle> <pages> pages 897-906, </pages> <address> Tokyo, Japan, </address> <year> 1992. </year>
Reference-contexts: The loss of precision introduced by confluence is orthogonal to the loss of precision in our approach. Another denotational semantics for the analysis of a particular concurrent logic language was developed in <ref> [9] </ref>. This semantics is based on sequences-like structures and is therefore more complex than our semantics. Furthermore, our approach has the advantage that it can be easily implemented using standard techniques from logic programming. The rest of this paper is organized as follows.
Reference: [10] <author> R. Jagadeesan, V.A. Saraswat, and V. Shanbhogue. </author> <title> Angelic non-determinism in concurrent constraint programming. </title> <type> Technical report, </type> <institution> Xerox Park, </institution> <year> 1991. </year>
Reference-contexts: The advantage is that the semantic operators can be defined in a simple way; in particular, k is given by set intersection. In our case, the resulting construction looks very similar to the semantics of Angelic ccp as defined in <ref> [10] </ref>. 2 Given a poset (X; ), a function f : X ! X is a closure operator iff f is extensive (8x 2 X: x f (x)) monotonic (8x; y 2 X: x y ) f (x) f (y)) and idempotent (8x 2 X: f (f (x)) = f (x)).
Reference: [11] <author> K. Marriott and H. Sondergaard. </author> <title> Abstract Interpretation of Logic Programs: the Denotational Approach. </title> <editor> In A. Bossi, editor, </editor> <booktitle> Proc. of the Italian Conf. on Logic Programming, </booktitle> <pages> pages 399-425, </pages> <year> 1990. </year>
Reference: [12] <author> V.A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> January </month> <year> 1989. </year> <note> Published by The MIT Press, </note> <institution> U.S.A., </institution> <year> 1991. </year>
Reference-contexts: 1 Introduction Concurrent constraint programming (ccp) <ref> [12, 13, 14] </ref> is a new programming paradigm which elegantly combines logical concepts and concurrency mechanisms. The computational model of ccp is based on the notion of constraint system, which consists of a set of constraints and an entailment (implication) relation. Processes interact through a common store.
Reference: [13] <author> V.A. Saraswat and M. Rinard. </author> <title> Concurrent constraint programming. </title> <booktitle> In Proc. of POPL, </booktitle> <pages> pages 232-245, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Concurrent constraint programming (ccp) <ref> [12, 13, 14] </ref> is a new programming paradigm which elegantly combines logical concepts and concurrency mechanisms. The computational model of ccp is based on the notion of constraint system, which consists of a set of constraints and an entailment (implication) relation. Processes interact through a common store. <p> In Section 5 we consider a variation of the notion of observables and the corresponding semantics. Finally in Section 6 we give the equations for the abstract denotational semantics. Section 7 concludes. 2 Constraint systems In <ref> [13] </ref> constraint systems are defined following Scott's treatment of information systems [15]. The starting point is a set of simple constraints on which a compact entailment relation ` is defined. Then a constraint system is constructed by considering sets of simple constraints and by extending the entailment relation on it.
Reference: [14] <author> V.A. Saraswat, M. Rinard, and P. Panangaden. </author> <title> Semantics foundations of Concurrent Constraint Programming. </title> <booktitle> In Proc. of POPL, </booktitle> <year> 1991. </year>
Reference-contexts: 1 Introduction Concurrent constraint programming (ccp) <ref> [12, 13, 14] </ref> is a new programming paradigm which elegantly combines logical concepts and concurrency mechanisms. The computational model of ccp is based on the notion of constraint system, which consists of a set of constraints and an entailment (implication) relation. Processes interact through a common store. <p> ~y = y 1 ; : : : ; y n , we use the notation d ~x~y to represent d x 1 y 1 ^ : : : ^ d x n y n . 3 The language ccp In this section we give the definition of ccp, following <ref> [14] </ref>. We refer to that paper for more details. We assume given a cylindric constraint system C on a set of variables Var with typical elements x; y; : : :. <p> This allows us to follow the approach of <ref> [14] </ref>, where a process is represented by a set of constraints, namely the fixpoints of the associated closure operator. The advantage is that the semantic operators can be defined in a simple way; in particular, k is given by set intersection.
Reference: [15] <author> D. Scott. </author> <title> Domains for denotational semantics. </title> <booktitle> In Proc. of ICALP, </booktitle> <year> 1982. </year>
Reference-contexts: In Section 5 we consider a variation of the notion of observables and the corresponding semantics. Finally in Section 6 we give the equations for the abstract denotational semantics. Section 7 concludes. 2 Constraint systems In [13] constraint systems are defined following Scott's treatment of information systems <ref> [15] </ref>. The starting point is a set of simple constraints on which a compact entailment relation ` is defined. Then a constraint system is constructed by considering sets of simple constraints and by extending the entailment relation on it.
Reference: [16] <author> E.Y. Shapiro. </author> <title> The family of concurrent logic programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 412-510, </pages> <year> 1989. </year>
Reference-contexts: Actually, in ccp successful termination can be detected and represented in the final store (see <ref> [16] </ref>, the short-circuit algorithm). In conclusion, for finite computations we can restrict ourselves to observe the final store without loss of generality. Since ask does not modify the store, and tell increases it, the evolution of the store during the computation is monotonic.
References-found: 16

