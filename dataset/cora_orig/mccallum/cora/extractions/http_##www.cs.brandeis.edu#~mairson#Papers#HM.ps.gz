URL: http://www.cs.brandeis.edu/~mairson/Papers/HM.ps.gz
Refering-URL: http://www.cs.brandeis.edu/~mairson/
Root-URL: http://www.cs.brandeis.edu
Phone: 2100  
Title: The Complexity of Type Inference for Higher-Order Typed Lambda Calculi  
Author: Fritz Henglein Harry G. Mairson 
Note: A preliminary version of this work appeared in the Proceedings of the 18th Annual ACM Symposium on Principles of Programming Languages, 1991, pp. 119-130. Research performed at Vaakgroep  supported in part by Office of Naval Research grant N0014-90-J-1110. Supported by NSF Grants CCR-9017125 and CCR-9216185, and grants from Texas Instruments and from the Tyson Foundation. Part of this work was done while the author was on leave at the Cambridge Research Laboratory of Digital Equipment Corporation.  
Date: October 30, 1993  
Address: Universitetsparken 1  Denmark  Waltham, Massachusetts 02254  
Affiliation: DIKU University of Copenhagen  Copenhagen  Computer Science Department Brandeis University  Informatica, University of Utrecht, and Computer Science Department, New York University,  
Abstract: We analyze the computational complexity of type inference for untyped -terms in the second-order polymorphic typed -calculus (F 2 ) invented by Girard and Reynolds, as well as higher-order extensions F 3 ; F 4 ; : : :; F ! proposed by Girard. We prove that recognizing the F 2 - typable terms requires exponential time, and for F ! the problem is nonelementary. We show as well a sequence of lower bounds on recognizing the F k -typable terms, where the bound for F k+1 is exponentially larger than that for F k . The lower bounds are based on generic simulation of Turing Machines, where computation is simulated at the expression and type level simultaneously. Non-accepting computations are mapped to non-normalizing reduction sequences, and hence non-typable terms. The accepting computations are mapped to typable terms, where higher-order types encode reduction sequences, and first-order types encode the entire computation as a circuit, based on a unification simulation of Boolean logic. A primary technical tool in this reduction is the composition of polymorphic functions having different domains and ranges. These results are the first nontrivial lower bounds on type inference for the Girard/Reynolds system as well as its higher-order extensions. We hope that the analysis provides important combinatorial insights which will prove useful in the ultimate resolution of the complexity of the type inference problem. 
Abstract-found: 1
Intro-found: 1
Reference: [AJ89] <author> A. W. Appel and T. Jim. </author> <title> Continuation-Passing, Closure-Passing Style. </title> <booktitle> In Proceedings of the 16th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pp. 293-302, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: True True True False; val it = fn : 'a -&gt; 'b -&gt; 'a The style of this coding is very similar to that used by Mitchell Wand in a framework for verifying compilers, where assembly code is generated in a version of -calculus [Wan92]; the idea also appears in <ref> [AJ89, KH89] </ref>. A trivial analysis shows this translation scheme to be a logarithmic space reduction, since the transducer need only count right parentheses to be output at the end of the expression, instead of storing expressions on a stack.
Reference: [Car89] <author> L. Cardelli. </author> <title> Typeful programming. </title> <booktitle> Lecture Notes for the IFIP Advanced Seminar on Formal Methods in Programming Language Semantics, </booktitle> <address> Rio de Janeiro, Brazil, </address> <year> 1989. </year> <note> See also SRC Report 45, </note> <institution> Digital Equipment Corporation. </institution>
Reference-contexts: We note, however, that F ! is not simply an esoteric variation on F 2 , since it has been proposed as the mathematical foundation for a new generation of typed functional programming languages, for example Cardelli's language Quest <ref> [Car89] </ref>, and the language LEAP of Pfenning and Lee [PL89]. The practical use of such languages, however, is considerably hampered by the absence of any type inference algorithm, forcing the programmer into detail and debugging of types as well as of the program.
Reference: [Coo71] <author> S. A. Cook. </author> <title> The complexity of theorem-proving procedures. </title> <booktitle> Proceedings of the 3rd Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pp. 151-158. </pages>
Reference-contexts: When we existentially quantify over the propositional variables, asking instead whether there exists a substitution for which the formula is true, we get the satisfiability problem, complete for nondeterministic polynomial time <ref> [Coo71, GJ79] </ref>. By alternating existential and universal quantifiers, we derive the polynomial time hierarchy, and in the limit, the problem of quantified boolean formulas, complete for polynomial space [SM73, GJ79].
Reference: [Dam85] <author> L. Damas. </author> <title> Type assignment in programming languages. </title> <publisher> Ph. </publisher> <address> D. </address> <institution> dissertation, CST-33-85, Computer Science Department, Edinburgh University, </institution> <year> 1985. </year>
Reference-contexts: The first, given in [Mit90] 7 , is that the following inference rule for 7 In this survey, the rule is attributed to Albert Meyer. However, it appears as well in the thesis of Luis Damas <ref> [Dam85] </ref>, and in fact a question about it can be found in the 1985 postgraduate examination in computing at Edinburgh University [San88]. 7 let preserves exactly the type judgements for closed terms usually derived using the quantification rules: (let) ` let x = M in N 2 t 1 Because t
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 207-212, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: He gave an algorithm which, presented with an untyped program, could construct the most general type information (known as the principal type <ref> [Hin69, DM82] </ref>) for the program [Mil78].
Reference: [DKM84] <author> C. Dwork, P. C. Kanellakis, and J. C. Mitchell. </author> <title> On the sequential nature of unification. </title> <journal> Journal of Logic Programming 1 </journal> <pages> 35-50, </pages> <year> 1984. </year>
Reference-contexts: As corollaries, we present simple proofs of the DTIME [2 n k ]-completeness of recognizing typable ML programs, as well as an utterly transparent proof that first-order unification is PTIME-complete. The latter is especially perspicuous in that it replaces the ingenious gadgets of <ref> [DKM84] </ref> with classical combinators from the -calculus, and shows how the theorem might have been proved by merely writing a simple, let-free ML program. <p> k , we can then construct an ML expression E containing ID 0 as a subterm, where the type of E necessarily codes whether M rejected x. 8 An alternate proof, based on the analysis of a problem called acyclic seminunification, is found in [KTU90]. 8 Using the methods of <ref> [DKM84] </ref> for coding Boolean logic, the simulation codes the Boolean values true and false as: 9 true x:y:z:K z (Eq x y) 2 a: fl:b: fl:a ! a ! b ! b false x:y:z:z 2 a: fl:b: fl:c: fl:a ! b ! c ! c where Eq x:y:K x (z:K (zx)(zy)) <p> large-scale insight, that they seem virtually useless for showing whether or not the term we have constructed is F 2 -typable. 3.2 Paradise regained: an F 2 lower bound The force of the ML argument can be regained, however, by changing the simulation of Boolean logic from that found in <ref> [DKM84] </ref> to the classic simulation in the -calculus. <p> types are a proper subset of the F 2 types, where any subterm of a type may contain quantifiers. 9 By using this well-known coding of classical logic (see, e.g., [HS86]), we discover a new class of directed acyclic graphs realizing Boolean operations via first-order unification, in the style of <ref> [DKM84] </ref>. Moreover, the analysis of these graphs allows us to view types as explicit codings of certain reduction sequences in the -calculus. <p> 2 shows the relevant dags coding the types of or and not. 3.4 Unification is PTIME-complete The graphs depicted in Figures 1 and 2 have the same computational significance as the gadgets invented by Dwork, Kanellakis, and Mitchell in their well-known proof that unification is complete for deterministic polynomial time <ref> [DKM84] </ref>. In this section, we show how their theorem could have been proved by writing an ML program using the classic -calculus encodings of the logical operations. The insight provided by this simpler problem is important in understanding the more detailed and sophisticated arguments we will see later on. <p> The insight provided by this simpler problem is important in understanding the more detailed and sophisticated arguments we will see later on. The proof of <ref> [DKM84] </ref> was, essentially, that the circuit value problem (given a Boolean circuit with inputs, what is its output?) could be reduced to unification. <p> -&gt; 'j -&gt; 'j) -&gt; 'k -&gt; ('l -&gt; 'm -&gt; 'm) -&gt; ((('n -&gt; ('u -&gt; 'v -&gt; 'v) -&gt; 'w) -&gt; 'w) -&gt; ('c -&gt; (('x -&gt; 'y -&gt; 'x) -&gt; 'z -&gt; -&gt; 'z -&gt; 'ba The type of circuit is the equivalent of the construction in <ref> [DKM84] </ref> of the circuit as a unification structure. <p> Finally, if we allow quantification over functions of Booleans, functions of functions of Booleans, etc., we get a problem complete for nonelementary time [Mey74, Sta79]. The theorems described in this paper follow much the same pattern. First-order unification is complete for polynomial time <ref> [DKM84] </ref>, corresponding to the complexity of first-order type inference. The progressively stronger lower bounds in this paper are derived by similarly allowing greater and greater functional abstraction on types.
Reference: [Gal90] <author> J. Gallier. </author> <title> On Girard's "Candidats de Reductibilite." </title> <booktitle> In Logic and Computer Science, </booktitle> <editor> ed. P. </editor> <booktitle> Odifreddi, </booktitle> <pages> pp. 123-203. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: Finally, by a slight augmentation of the ML proof, we derive a DTIME [2 n k ]-hardness bound on the recognition of F 2 -typable terms. We make essential and powerful use of the strong normalization theorem for F 2 <ref> [Gir72, GLT89, Gal90] </ref>, using the coded Boolean answer A to the question "Did machine M reject its input of length n in 2 n k steps?" to choose between a trivial terminating computation and a clearly nonterminating one: (x:xx)(A (x:x) (y:yy)) Observe that if A &gt; false, then &gt; (x:xx)(y:yy); since
Reference: [GJ79] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractibility: A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference-contexts: When we existentially quantify over the propositional variables, asking instead whether there exists a substitution for which the formula is true, we get the satisfiability problem, complete for nondeterministic polynomial time <ref> [Coo71, GJ79] </ref>. By alternating existential and universal quantifiers, we derive the polynomial time hierarchy, and in the limit, the problem of quantified boolean formulas, complete for polynomial space [SM73, GJ79]. <p> By alternating existential and universal quantifiers, we derive the polynomial time hierarchy, and in the limit, the problem of quantified boolean formulas, complete for polynomial space <ref> [SM73, GJ79] </ref>. Finally, if we allow quantification over functions of Booleans, functions of functions of Booleans, etc., we get a problem complete for nonelementary time [Mey74, Sta79]. The theorems described in this paper follow much the same pattern.
Reference: [GR88] <author> P. Giannini and S. Ronchi Della Rocca. </author> <title> Characterization of typings in polymorphic type discipline. </title> <booktitle> In Proceedings of the 3rd IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pp. 61-70, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Because of this equivalence, we see that arguments about typability based on first-order unification are simply too weak. Proving that strongly normalizing terms are not F 2 -typable is very difficult: as evidence, we point merely to the tremendous effort of Giannini and Ronchi della Rocca <ref> [GR88] </ref> in their identifying a single, simple, strongly normalizing term which is not F 2 -typable. The Giannini-Ronchi results are an indication that F 2 type inference might in fact be decidable, since they achieved a separation between F 2 -typable terms and the r.e.-complete class of strongly normalizable terms.
Reference: [Gir72] <author> J.-Y. Girard. </author> <title> Interpretation Fonctionelle et Elimination des Coupures de l'Arithmetique d'Ordre Superieur. </title> <institution> These de Doctorat d'Etat, Universite de Paris VII, </institution> <year> 1972. </year>
Reference-contexts: 1 Introduction One of the outstanding open problems in programming language theory and type theory is the de-cidability of type inference for the second order polymorphic typed -calculus invented by Jean-Yves Girard <ref> [Gir72] </ref> and John Reynolds [Rey74]. <p> Finally, by a slight augmentation of the ML proof, we derive a DTIME [2 n k ]-hardness bound on the recognition of F 2 -typable terms. We make essential and powerful use of the strong normalization theorem for F 2 <ref> [Gir72, GLT89, Gal90] </ref>, using the coded Boolean answer A to the question "Did machine M reject its input of length n in 2 n k steps?" to choose between a trivial terminating computation and a clearly nonterminating one: (x:xx)(A (x:x) (y:yy)) Observe that if A &gt; false, then &gt; (x:xx)(y:yy); since <p> By Girard's strong normalization theorem <ref> [Gir72, GLT89] </ref>, M;x is not F 2 -typable. It is easily seen that M;x can be constructed in logarithmic space from M and x, since the transducer need only count how many copies of the term 2 to output in the construction of A. <p> As long as we pursue bounds for F 2 based on expressiveness of the type language, we are constrained by the strong normalization theorem, and the representation theorem (that the representable integer functions are those provably total in second order Peano Arithmetic) <ref> [Gir72, GLT89] </ref>. We have some idea how to get around the first hurdle, but are a bit puzzled by the second.
Reference: [GLT89] <author> J.-Y. Girard, Y. Lafont, and P. Taylor. </author> <title> Proofs and Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: Finally, by a slight augmentation of the ML proof, we derive a DTIME [2 n k ]-hardness bound on the recognition of F 2 -typable terms. We make essential and powerful use of the strong normalization theorem for F 2 <ref> [Gir72, GLT89, Gal90] </ref>, using the coded Boolean answer A to the question "Did machine M reject its input of length n in 2 n k steps?" to choose between a trivial terminating computation and a clearly nonterminating one: (x:xx)(A (x:x) (y:yy)) Observe that if A &gt; false, then &gt; (x:xx)(y:yy); since <p> By Girard's strong normalization theorem <ref> [Gir72, GLT89] </ref>, M;x is not F 2 -typable. It is easily seen that M;x can be constructed in logarithmic space from M and x, since the transducer need only count how many copies of the term 2 to output in the construction of A. <p> As long as we pursue bounds for F 2 based on expressiveness of the type language, we are constrained by the strong normalization theorem, and the representation theorem (that the representable integer functions are those provably total in second order Peano Arithmetic) <ref> [Gir72, GLT89] </ref>. We have some idea how to get around the first hurdle, but are a bit puzzled by the second.
Reference: [HMT90] <author> R. Harper, R. Milner, M. Tofte. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: He gave an algorithm which, presented with an untyped program, could construct the most general type information (known as the principal type [Hin69, DM82]) for the program [Mil78]. These insights are implemented in the ML programming language <ref> [HMT90] </ref> as well as a variety 1 In his 1977 Turing Award lecture, as well as his Foreward to Joseph Stoy's book on denotational semantics, Dana Scott mentions that it was physicist Roger Penrose who pointed Strachey in the direction of the -calculus as a useful device for describing programming language <p> Proof. For a description of Core ML|essentially, the first-order typed -calculus with a polymorphic let such that let x = E in B is syntactic sugar for [E=x]B|see <ref> [HMT90, KMM91, Mai92a] </ref>. Assume that F = fq p+1 ; : : : ; q k g Q are the accepting states of M .
Reference: [HS65] <author> J. Hartmanis and R. E. Stearns. </author> <title> On the computational complexity of algorithms. </title> <journal> Transactions of the American Mathematical Society 117, </journal> <pages> pp. 285-306. </pages>
Reference-contexts: In constructing strong lower bounds, the challenge is to encode as rapidly increasing an f (n) as possible, while constraining the transducer reducing M and x to M;x to run in logarithmic space. By the time hierarchy theorem <ref> [HS65, HU79] </ref>, these complexity-class relativized hardness bounds translate (via diagonalization arguments) to nonrelativized bounds. <p> We then use the inductive step to follow through the "chain reaction" of subsequent unifications with separate copies of TM circuitry. Since E reduces to (2 m ffi)ID 0 , the result follows from the so-called subject reduction theorem (see, e.g., <ref> [HS65] </ref>), the -calculus interpretation of cut elimination: namely, if a term has a particular type, then any reduct of that term has the same type. <p> He would also like to thank the Cambridge Research Laboratory of Digital Equipment Corporation, where final work on the paper was completed. 14 This is of course a simply corollary of the Scott-Curry undecidability theorem (see, for example, <ref> [HS65] </ref>). 39
Reference: [Hen90] <author> F. Henglein. </author> <title> A lower bound for full polymorphic type inference: Girard/ Reynolds typability is DEXPTIME-hard. </title> <institution> University of Utrecht, </institution> <type> Technical Report RUU-CS-90-14, </type> <month> April </month> <year> 1990. </year> <month> 40 </month>
Reference-contexts: Encouraged and excited as we are to have made progress on these open questions in programming language theory, the hard work may have only just begun. Acknowledgements. The results of Section 3 were reported earlier in <ref> [Hen90] </ref>. For their encouragement, suggestions and criticisms, we thank Paris Kanellakis, Georg Kreisel, Daniel Leivant, Angus Macintyre, Albert Meyer, Jon Riecke, and Rick Statman.
Reference: [HM91] <author> F. Henglein and H. G. Mairson. </author> <title> The complexity of type inference for higher-order typed lambda calculi. </title> <booktitle> In Proceedings of the 18th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pp. 119-130, </pages> <month> January </month> <year> 1991. </year>
Reference: [Hin69] <author> R. Hindley. </author> <title> The principal type scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society 146 </journal> <pages> 29-60, </pages> <year> 1969. </year>
Reference-contexts: He gave an algorithm which, presented with an untyped program, could construct the most general type information (known as the principal type <ref> [Hin69, DM82] </ref>) for the program [Mil78].
Reference: [HS86] <author> J. R. Hindley and J. P. Seldin. </author> <title> Introduction to Combinators and Lambda Calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: Our tutorial material was in many ways inspired by the presentation of [PDM89], which we enthusiastically recommend to anyone desiring a readable introduction to programming in higher-order typed -calculi. 3 Observe that these type systems preserve typings under fi-reduction, the so-called subject reduction lemma <ref> [HS86] </ref>. 4 2 The second order polymorphic typed -calculus (F 2 ) F 2 is best introduced by a canonical example: the identity function. In F 2 , we write the typed polymorphic identity function 4 as Id flff: fl:x:ff:x. <p> Such types are a proper subset of the F 2 types, where any subterm of a type may contain quantifiers. 9 By using this well-known coding of classical logic (see, e.g., <ref> [HS86] </ref>), we discover a new class of directed acyclic graphs realizing Boolean operations via first-order unification, in the style of [DKM84]. Moreover, the analysis of these graphs allows us to view types as explicit codings of certain reduction sequences in the -calculus.
Reference: [HU79] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison Wesley, </publisher> <year> 1979. </year>
Reference-contexts: In constructing strong lower bounds, the challenge is to encode as rapidly increasing an f (n) as possible, while constraining the transducer reducing M and x to M;x to run in logarithmic space. By the time hierarchy theorem <ref> [HS65, HU79] </ref>, these complexity-class relativized hardness bounds translate (via diagonalization arguments) to nonrelativized bounds.
Reference: [HW88] <editor> P. Hudak and P. L. Wadler, editors. </editor> <title> Report on the functional programming language Haskell. </title> <institution> Yale University Technical Report YALEU/DCS/RR656, </institution> <year> 1988. </year>
Reference-contexts: At the time this suggestion fell on stony ground and had virtually no influence." (p. xxiii) [Sto77] 2 of other functional languages <ref> [HW88, Tur85] </ref>. The principal type of an ML program provides an important functional specification of the program, describing how it can be used by other programs; as such, types are useful as specifications, and to facilitate incremental compilation. The ML module system is an elegant realization of these basic intuitions.
Reference: [KM89] <author> P. C. Kanellakis and J. C. Mitchell. </author> <title> Polymorphic unification and ML typing. </title> <institution> Brown University Technical Report CS-89-40, </institution> <month> August </month> <year> 1989. </year> <booktitle> Also in Proceedings of the 16th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pp. 105-115, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The added combinatorial insight comes from that fact that type inference can be completely reduced to first-order unification. The second observation, due to Paris Kanellakis and John Mitchell, is that let can be used to compose functions an exponential number of times with a polynomial-length expression <ref> [KM89] </ref>: Example 3.1 let x 0 = ffi in let x 2 = y:x 1 (x 1 y) in let x t = y:x t1 (x t1 y) in x t The above expression let-reduces to y:ffi 2 t y, where the occurrences of ffi are polymorphic | each occurrence has
Reference: [KMM91] <author> P. C. Kanellakis, H. G. Mairson, and J. C. Mitchell. </author> <title> Unification and ML type reconstruction. </title> <booktitle> In Computational Logic: Essays in Honor of Alan Robinson, </booktitle> <editor> ed. J.-L. Lassez and G. Plotkin. </editor> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: n ]-hardness bound for typability in F 2 implies a (c n ) lower bound for some constant c &gt; 1. 2 As a consequence, ML is in practice augmented with a set of typed fixpoint operators. 3 The structure of M;x is basically a consequence of the following proposition <ref> [KMM91] </ref>: Proposition 1.1 Given any strongly normalizing -term E, the problem of determining whether the normal form of E is first-order typable is DTIME [f (n)]-hard, for any total recursive function f (n). <p> In the spirit of the Curry-Howard propositions-as-types analogy, it also acts as a sort of cut elimination, preserving propositional theorems at the expense of greatly enlarging the size of the proofs. A proof of this cut elimination theorem appears in the appendix of <ref> [KMM91] </ref>; a different and much cleaner proof inspired by the Tait strong normalization theorem [Tai67] is found in [Mai92a]. The added combinatorial insight comes from that fact that type inference can be completely reduced to first-order unification. <p> The significance of this polymorphism is exploited in the lower bound of <ref> [Mai90, KMM91] </ref>, where it is shown that recognizing typable ML expressions of length n can be solved in DTIME [2 n ], and is DTIME [2 n k ]-hard for every integer k 1 under logspace reduction. 8 The lower bound is a generic reduction: given a TM M accepting or <p> True) (Pair False False); val Fanout = fn : (((('a -&gt; 'b -&gt; 'a) -&gt; ('c -&gt; 'd -&gt; 'c) -&gt; 'e) -&gt; 'e) -&gt; ((('f -&gt; 'g -&gt; 'g) -&gt; ('h -&gt; 'i -&gt; 'i) -&gt; 'j) -&gt; 'j) -&gt; 'k) -&gt; 'k The importance of Fanout, as in <ref> [Mai90, KMM91] </ref>, is that it produces two copies of a logic value which do not share type variables. <p> Because no value is "used" more than once, no side-effecting of type variables occurs, and the fanout gates mentioned earlier, used in the proofs in <ref> [Mai90, KMM91] </ref>, are not necessary. 3.7 Encoding Turing Machines by types The simple encoding ffi of the transition function is typable in ML; moreover, it has the following property: Proposition 3.2 Let ID and ID 0 be -terms coding successive configurations of M , and let and 0 be their respective <p> Proof. For a description of Core ML|essentially, the first-order typed -calculus with a polymorphic let such that let x = E in B is syntactic sugar for [E=x]B|see <ref> [HMT90, KMM91, Mai92a] </ref>. Assume that F = fq p+1 ; : : : ; q k g Q are the accepting states of M .
Reference: [KH89] <author> R. Kelsey and P. Hudak. </author> <title> Realistic Compilation by Program Transformation. </title> <booktitle> In Proceedings of the 16th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pp. 281-292, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: True True True False; val it = fn : 'a -&gt; 'b -&gt; 'a The style of this coding is very similar to that used by Mitchell Wand in a framework for verifying compilers, where assembly code is generated in a version of -calculus [Wan92]; the idea also appears in <ref> [AJ89, KH89] </ref>. A trivial analysis shows this translation scheme to be a logarithmic space reduction, since the transducer need only count right parentheses to be output at the end of the expression, instead of storing expressions on a stack.
Reference: [KTU90] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> ML typability is DEXPTIME-complete. </title> <booktitle> Proceedings of the 15th Colloquium on Trees in Algebra and Programming, </booktitle> <month> May </month> <year> 1990. </year> <note> (See also Boston University Technical Report, </note> <month> October </month> <year> 1989). </year>
Reference-contexts: Taking t = n k , we can then construct an ML expression E containing ID 0 as a subterm, where the type of E necessarily codes whether M rejected x. 8 An alternate proof, based on the analysis of a problem called acyclic seminunification, is found in <ref> [KTU90] </ref>. 8 Using the methods of [DKM84] for coding Boolean logic, the simulation codes the Boolean values true and false as: 9 true x:y:z:K z (Eq x y) 2 a: fl:b: fl:a ! a ! b ! b false x:y:z:z 2 a: fl:b: fl:c: fl:a ! b ! c ! c
Reference: [KT89] <author> A. J. Kfoury and J. Tiuryn. </author> <title> Type reconstruction in finite rank fragments of the second-order lambda calculus. </title> <type> Technical Report BUCS 89-011, </type> <institution> Boston University, </institution> <month> October </month> <year> 1989. </year> <booktitle> Also in Proceedings of the 5th IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pp. 2-11, </pages> <month> June </month> <year> 1990. </year>
Reference: [Lad75] <author> R. E. Ladner. </author> <title> The circuit value problem is log space complete for P. </title> <journal> SIGACT News 7:1, </journal> <year> 1975, </year> <pages> pp. 18-20. </pages>
Reference-contexts: The proof of [DKM84] was, essentially, that the circuit value problem (given a Boolean circuit with inputs, what is its output?) could be reduced to unification. The circuit value problem is logspace complete for polynomial time <ref> [Lad75] </ref>, since any polynomial time TM computation can be described by a polynomial sized circuit, where the input to the circuit is the initial tape contents, and polynomial "layers" of circuitry implement each state transition. <p> For example, deciding whether a propositional formula is true under a particular substitution of true and false for the variables is complete for polynomial time; this is the well-known circuit value problem <ref> [Lad75] </ref>. When we existentially quantify over the propositional variables, asking instead whether there exists a substitution for which the formula is true, we get the satisfiability problem, complete for nondeterministic polynomial time [Coo71, GJ79].
Reference: [Lan66] <author> P. </author> <title> Landin. </title> <booktitle> The next 700 programming languages. Communications of the ACM 9(3): </booktitle> <pages> 157-166. </pages>
Reference-contexts: We hope that the analysis provides important combinatorial insights which will prove useful in the ultimate resolution of the complexity of the type inference problem. The problem of type inference is one of both theoretical and practical interest. Following the insights of Landin <ref> [Lan66] </ref>, Strachey [Str73], Penrose 1 , and others, the untyped -calculus has long been recognized as not merely Turing-complete, but a syntactically natural foundation for the design of programming languages. The process of fi-reduction is a simulation of computation and function call, while normal forms correspond to final returned answers.
Reference: [Mai90] <author> H. G. Mairson. </author> <title> Deciding ML typability is complete for deterministic exponential time. </title> <booktitle> In Proceedings of the 17th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pp. 382-401, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The significance of this polymorphism is exploited in the lower bound of <ref> [Mai90, KMM91] </ref>, where it is shown that recognizing typable ML expressions of length n can be solved in DTIME [2 n ], and is DTIME [2 n k ]-hard for every integer k 1 under logspace reduction. 8 The lower bound is a generic reduction: given a TM M accepting or <p> True) (Pair False False); val Fanout = fn : (((('a -&gt; 'b -&gt; 'a) -&gt; ('c -&gt; 'd -&gt; 'c) -&gt; 'e) -&gt; 'e) -&gt; ((('f -&gt; 'g -&gt; 'g) -&gt; ('h -&gt; 'i -&gt; 'i) -&gt; 'j) -&gt; 'j) -&gt; 'k) -&gt; 'k The importance of Fanout, as in <ref> [Mai90, KMM91] </ref>, is that it produces two copies of a logic value which do not share type variables. <p> Because no value is "used" more than once, no side-effecting of type variables occurs, and the fanout gates mentioned earlier, used in the proofs in <ref> [Mai90, KMM91] </ref>, are not necessary. 3.7 Encoding Turing Machines by types The simple encoding ffi of the transition function is typable in ML; moreover, it has the following property: Proposition 3.2 Let ID and ID 0 be -terms coding successive configurations of M , and let and 0 be their respective
Reference: [Mai92a] <author> H. G. Mairson. </author> <title> Quantifier elimination and parametric polymorphism in programming languages. </title> <editor> J. </editor> <booktitle> Functional Programming 2:2 (April 1992), </booktitle> <pages> pp. 213-226. 41 </pages>
Reference-contexts: A proof of this cut elimination theorem appears in the appendix of [KMM91]; a different and much cleaner proof inspired by the Tait strong normalization theorem [Tai67] is found in <ref> [Mai92a] </ref>. The added combinatorial insight comes from that fact that type inference can be completely reduced to first-order unification. <p> Proof. For a description of Core ML|essentially, the first-order typed -calculus with a polymorphic let such that let x = E in B is syntactic sugar for [E=x]B|see <ref> [HMT90, KMM91, Mai92a] </ref>. Assume that F = fq p+1 ; : : : ; q k g Q are the accepting states of M .
Reference: [Mai92b] <author> H. G. Mairson. </author> <title> A simple proof of a theorem of Statman. </title> <booktitle> Theoretical Computer Science 103 (1992), </booktitle> <pages> pp. 387-394. </pages>
Reference-contexts: The nonelementary lower bound for F ! type inference should immediately call to mind a well-known theorem of Statman: the theorem states that if we have two -terms typable in the first order typed lambda calculus, deciding whether the terms have the same normal form requires nonelementary time <ref> [Sta79, Mai92b] </ref>. The proof of Statman's theorem is a reduction from deciding the truth of expressions in higher-order logic, where quantification is allowed not only over Boolean values, but over higher-order functions over Booleans [Mey74].
Reference: [Mey74] <author> A. R. Meyer. </author> <title> The inherent computational complexity of theories of ordered sets. </title> <booktitle> Proceedings of the International Congress of Mathematicians, </booktitle> <year> 1974, </year> <pages> pp. 477-482. </pages>
Reference-contexts: The proof of Statman's theorem is a reduction from deciding the truth of expressions in higher-order logic, where quantification is allowed not only over Boolean values, but over higher-order functions over Booleans <ref> [Mey74] </ref>. <p> Finally, if we allow quantification over functions of Booleans, functions of functions of Booleans, etc., we get a problem complete for nonelementary time <ref> [Mey74, Sta79] </ref>. The theorems described in this paper follow much the same pattern. First-order unification is complete for polynomial time [DKM84], corresponding to the complexity of first-order type inference. The progressively stronger lower bounds in this paper are derived by similarly allowing greater and greater functional abstraction on types.
Reference: [Mil78] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences 17, </journal> <pages> pp. 348-375, </pages> <year> 1978. </year>
Reference-contexts: He gave an algorithm which, presented with an untyped program, could construct the most general type information (known as the principal type [Hin69, DM82]) for the program <ref> [Mil78] </ref>.
Reference: [Mit90] <author> J. C. Mitchell. </author> <title> Type systems for programming languages. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> vol. B, </volume> <pages> pp. 365-468. </pages> <editor> J. van Leeuwen et al., eds., </editor> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: Naturally, this insight is also crucial in the case of F 2 . The progress in understanding ML quantification and type inference is primarily due to two straightforward observations. The first, given in <ref> [Mit90] </ref> 7 , is that the following inference rule for 7 In this survey, the rule is attributed to Albert Meyer.
Reference: [PW78] <author> M. S. Paterson and M. N. Wegman. </author> <title> Linear unification. </title> <journal> Journal of Computer and System Sciences 16, </journal> <pages> pp. 158-167, </pages> <year> 1978. </year>
Reference-contexts: elegant exposition of this fact can be found in [Wan87], where a syntax-directed algorithm is given that transforms an untyped -term into a linear sized set of type equations of the form X = Y and X = Y ! Z, such that the solution of the equations (via unification <ref> [Rob65, PW78] </ref>) determines the principal type of the term. In progressing from this language to ML, it is necessary to understand the effect of quantification over type variables on the complexity of type inference. Naturally, this insight is also crucial in the case of F 2 .
Reference: [PL89] <author> F. Pfenning and P. Lee. </author> <title> LEAP: a language with eval and polymorphism. </title> <booktitle> TAPSOFT 1989: Proceedings of the International Joint Conference on Theory and Practice in Software Development, </booktitle> <address> Barcelona, Spain. </address> <note> See also CMU Ergo Report 88-065. </note>
Reference-contexts: We note, however, that F ! is not simply an esoteric variation on F 2 , since it has been proposed as the mathematical foundation for a new generation of typed functional programming languages, for example Cardelli's language Quest [Car89], and the language LEAP of Pfenning and Lee <ref> [PL89] </ref>. The practical use of such languages, however, is considerably hampered by the absence of any type inference algorithm, forcing the programmer into detail and debugging of types as well as of the program.
Reference: [Pf88] <author> F. Pfenning. </author> <title> Partial polymorphic type inference and higher-order unification. </title> <booktitle> Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 153-163. </pages>
Reference-contexts: Some arguments have been made that the problem to be solved is partial type inference, where the programmer supplies constraints in the form of type information for certain fragments of the program. In view of the undecidability results of Pfenning <ref> [Pf88] </ref>, from a theoretical perspective, it is clear that partial type inference is not easier than pure type inference; in fact, pure type inference might be decidable.
Reference: [PDM89] <author> B. Pierce, S. Dietzen, and S. Michaylov. </author> <title> Programming in higher-order typed lambda calculi. </title> <type> Technical Report CMU-CS-89-111, </type> <institution> Carnegie Mellon University, </institution> <month> March </month> <year> 1989. </year>
Reference-contexts: In Section 5 we prove the nonelementary lower bound on typability for F ! , and show the connections between this bound and related lower bounds for the F k . Our tutorial material was in many ways inspired by the presentation of <ref> [PDM89] </ref>, which we enthusiastically recommend to anyone desiring a readable introduction to programming in higher-order typed -calculi. 3 Observe that these type systems preserve typings under fi-reduction, the so-called subject reduction lemma [HS86]. 4 2 The second order polymorphic typed -calculus (F 2 ) F 2 is best introduced by a <p> that "make sense." We distinguish this sense of a term by a type judgement ` e 2 t , read "in context , term e has type t ." Type judgements are derived via a set of inference rules characteristic to F 2 ; we adopt the basic presentation of <ref> [PDM89] </ref>. The first inference rules define a well-formed context. A context is a function from a finite domain of expression variables to types.
Reference: [Rey74] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proceedings of the Paris Colloquium on Programming, Lecture Notes in Computer Science 19, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pp. 408-425, </pages> <year> 1974. </year>
Reference-contexts: 1 Introduction One of the outstanding open problems in programming language theory and type theory is the de-cidability of type inference for the second order polymorphic typed -calculus invented by Jean-Yves Girard [Gir72] and John Reynolds <ref> [Rey74] </ref>.
Reference: [Rob65] <author> J. A. Robinson. </author> <title> A machine oriented logic based on the resolution principle. </title> <journal> Journal of the ACM 12(1) </journal> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: elegant exposition of this fact can be found in [Wan87], where a syntax-directed algorithm is given that transforms an untyped -term into a linear sized set of type equations of the form X = Y and X = Y ! Z, such that the solution of the equations (via unification <ref> [Rob65, PW78] </ref>) determines the principal type of the term. In progressing from this language to ML, it is necessary to understand the effect of quantification over type variables on the complexity of type inference. Naturally, this insight is also crucial in the case of F 2 .
Reference: [San88] <author> D. T. Sannella, ed. </author> <title> Postgraduate Examination Questions in Computation Theory, </title> <type> 1978-1988. </type> <institution> Laboratory for Foundations of Computer Science, </institution> <note> Report ECS-LFCS-88-64. </note>
Reference-contexts: However, it appears as well in the thesis of Luis Damas [Dam85], and in fact a question about it can be found in the 1985 postgraduate examination in computing at Edinburgh University <ref> [San88] </ref>. 7 let preserves exactly the type judgements for closed terms usually derived using the quantification rules: (let) ` let x = M in N 2 t 1 Because t 0 and t 1 are first-order types, this alternate inference rule is a classic instance of quantifier elimination.
Reference: [Sch82] <author> H. Schwichtenberg. </author> <title> Complexity of normalization in the pure typed lambda calculus. The L. </title> <editor> E. J. Brouwer Centenary Symposium, A. S. Troelstra and D. van Daalen (eds.), </editor> <booktitle> pp. </booktitle> <pages> 453-457. </pages> <publisher> North-Holland, </publisher> <year> 1982. </year>
Reference-contexts: The "duality" approach forces reductions at the expression level to match those at the type level, and a result of Schwichtenberg <ref> [Sch82] </ref> indicates that our construction is using the type language at its maximum capacity. Encouraged and excited as we are to have made progress on these open questions in programming language theory, the hard work may have only just begun. Acknowledgements.
Reference: [Sco77] <author> D. S. Scott. </author> <booktitle> Logic and programming languages. Communications of the ACM 20(9) </booktitle> <pages> 634-641, </pages> <year> 1977. </year>
Reference-contexts: well as a variety 1 In his 1977 Turing Award lecture, as well as his Foreward to Joseph Stoy's book on denotational semantics, Dana Scott mentions that it was physicist Roger Penrose who pointed Strachey in the direction of the -calculus as a useful device for describing programming language semantics <ref> [Sco77, Sto77] </ref>.
Reference: [Sta79] <author> R. Statman. </author> <title> The typed -calculus is not elementary recursive. </title> <booktitle> Theoretical Computer Science 9, </booktitle> <year> 1979, </year> <pages> pp. 73-81. 42 </pages>
Reference-contexts: The nonelementary lower bound for F ! type inference should immediately call to mind a well-known theorem of Statman: the theorem states that if we have two -terms typable in the first order typed lambda calculus, deciding whether the terms have the same normal form requires nonelementary time <ref> [Sta79, Mai92b] </ref>. The proof of Statman's theorem is a reduction from deciding the truth of expressions in higher-order logic, where quantification is allowed not only over Boolean values, but over higher-order functions over Booleans [Mey74]. <p> Finally, if we allow quantification over functions of Booleans, functions of functions of Booleans, etc., we get a problem complete for nonelementary time <ref> [Mey74, Sta79] </ref>. The theorems described in this paper follow much the same pattern. First-order unification is complete for polynomial time [DKM84], corresponding to the complexity of first-order type inference. The progressively stronger lower bounds in this paper are derived by similarly allowing greater and greater functional abstraction on types.
Reference: [SM73] <author> L. J. Stockmeyer and A. R. Meyer. </author> <title> Word problems requiring exponential time. </title> <booktitle> Pro--ceedings of the 5th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pp. 1-9. </pages>
Reference-contexts: By alternating existential and universal quantifiers, we derive the polynomial time hierarchy, and in the limit, the problem of quantified boolean formulas, complete for polynomial space <ref> [SM73, GJ79] </ref>. Finally, if we allow quantification over functions of Booleans, functions of functions of Booleans, etc., we get a problem complete for nonelementary time [Mey74, Sta79]. The theorems described in this paper follow much the same pattern.
Reference: [Sto77] <author> J. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: well as a variety 1 In his 1977 Turing Award lecture, as well as his Foreward to Joseph Stoy's book on denotational semantics, Dana Scott mentions that it was physicist Roger Penrose who pointed Strachey in the direction of the -calculus as a useful device for describing programming language semantics <ref> [Sco77, Sto77] </ref>. <p> The earliest suggestion that -calculus might be useful in this way that has come to our notice was in a verbal communication from Roger Penrose to [me] in about 1958. At the time this suggestion fell on stony ground and had virtually no influence." (p. xxiii) <ref> [Sto77] </ref> 2 of other functional languages [HW88, Tur85]. The principal type of an ML program provides an important functional specification of the program, describing how it can be used by other programs; as such, types are useful as specifications, and to facilitate incremental compilation.
Reference: [Str73] <author> C. Strachey. </author> <title> The varieties of programming language. </title> <type> Technical Monograph PRG-10, </type> <institution> Programming Research Group, Oxford University, </institution> <year> 1973. </year>
Reference-contexts: We hope that the analysis provides important combinatorial insights which will prove useful in the ultimate resolution of the complexity of the type inference problem. The problem of type inference is one of both theoretical and practical interest. Following the insights of Landin [Lan66], Strachey <ref> [Str73] </ref>, Penrose 1 , and others, the untyped -calculus has long been recognized as not merely Turing-complete, but a syntactically natural foundation for the design of programming languages. The process of fi-reduction is a simulation of computation and function call, while normal forms correspond to final returned answers.
Reference: [Tai67] <author> W. W. Tait. </author> <title> Intensional interpretation of functionals of finite type I. </title> <journal> J. Symbolic Logic 32, </journal> <pages> pp. 198-212, </pages> <year> 1967. </year>
Reference-contexts: A proof of this cut elimination theorem appears in the appendix of [KMM91]; a different and much cleaner proof inspired by the Tait strong normalization theorem <ref> [Tai67] </ref> is found in [Mai92a]. The added combinatorial insight comes from that fact that type inference can be completely reduced to first-order unification.
Reference: [Tur85] <author> D. A. Turner. Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In IFIP International Conference on Functional Programming and Computer Architecture, Nancy, Lecture Notes in Computer Science 201, </booktitle> <pages> pp. 1-16, </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: At the time this suggestion fell on stony ground and had virtually no influence." (p. xxiii) [Sto77] 2 of other functional languages <ref> [HW88, Tur85] </ref>. The principal type of an ML program provides an important functional specification of the program, describing how it can be used by other programs; as such, types are useful as specifications, and to facilitate incremental compilation. The ML module system is an elegant realization of these basic intuitions.
Reference: [Wan87] <author> M. Wand. </author> <title> A simple algorithm and proof for type inference. </title> <note> Fundamenta Informaticae 10 (1987). </note>
Reference-contexts: A simple and elegant exposition of this fact can be found in <ref> [Wan87] </ref>, where a syntax-directed algorithm is given that transforms an untyped -term into a linear sized set of type equations of the form X = Y and X = Y ! Z, such that the solution of the equations (via unification [Rob65, PW78]) determines the principal type of the term.
Reference: [Wan92] <author> M. Wand. </author> <title> Correctness of Procedure Representations in Higher-Order Assembly Language. Mathematical Foundations of Programming Language Semantics 1991 (ed. </title> <editor> S. Brookes). </editor> <booktitle> Springer-Verlag Lecture Notes in Computer Science, </booktitle> <volume> volume 598, </volume> <pages> pp. 294-311, </pages> <year> 1992. </year>
Reference-contexts: 'z -&gt; 'ba circuit False True True True True False; val it = fn : 'a -&gt; 'b -&gt; 'a The style of this coding is very similar to that used by Mitchell Wand in a framework for verifying compilers, where assembly code is generated in a version of -calculus <ref> [Wan92] </ref>; the idea also appears in [AJ89, KH89]. A trivial analysis shows this translation scheme to be a logarithmic space reduction, since the transducer need only count right parentheses to be output at the end of the expression, instead of storing expressions on a stack.
References-found: 49

