URL: http://www.cs.rice.edu/CS/PLT/Publications/tr94-239.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Well-Founded Touch Optimization for Futures  
Author: Cormac Flanagan Matthias Felleisen 
Date: October 1994  
Address: COMP TR94-239  P.O. Box 1892 Houston, TX 77251-1892  
Affiliation: Rice  Department of Computer Science Rice University  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> Aiken, A., and Wimmers, E. L. </author> <title> Soft typing with conditional types. </title> <booktitle> In POPL (1994), </booktitle> <pages> pp. 163-173. </pages>
Reference-contexts: However, a standard technique for increasing execution speed in Scheme systems is to disable type-checking typically based on informal correctness arguments or based on type verifiers for the underlying sequential language <ref> [29, 1] </ref>. When type-checking is disabled, most program operations do not perform a type-dispatch on their arguments. <p> Figures 2). Unlike eval pcek , the evaluator eval pcek is no longer a function. There are programs in fl a for which the evaluator 2 This approach is similar in character to optimization techniques such as soft-typing <ref> [29, 1] </ref> and tagging optimization [14], which remove the type-dispatches required in dynamically-typed languages wherever possible. However, touch-optimization also applies to a statically-typed language with futures, where soft-typing and tagging optimization techniques are not as useful. <p> Other techniques for static analysis of sequential programs include abstract interpretation [4, 5] and Shivers' 0CFA [26]. The relationship between abstract interpretation and set-based analysis was covered by Heintze [12]. Sequential optimization techniques such as tagging optimization [14] and soft-typing <ref> [29, 1] </ref> are similar in character to touch optimization. Both techniques remove the type-dispatches required for dynamic type-checking wherever possible, without changing the behavior of programs, in the same fashion as we remove touch operations.

Reference: [3] <institution> BBN Advanced Computers, Inc., </institution> <address> Cambridge, MA. Inside the GP1000. </address> <year> 1989. </year>
Reference-contexts: They do not affect the validity of the analysis and touch optimization algorithms. Well-Founded Touch Optimization for Futures 25 shared-memory multiprocessor <ref> [3] </ref>. Figure 9 describes these benchmarks. Each benchmark was tested on the original compiler (standard ) and on the modified compiler (touch optimized ). The results of the test runs are documented in Figure 10.
Reference: [4] <author> Cousot, P., and Cousot, R. </author> <title> Abstract interpretation: A unified lattice model for static analyses of programs by construction or approximation of fixpoints. </title> <booktitle> In POPL (1977), </booktitle> <pages> pp. 238-252. </pages>
Reference-contexts: Their semantics and their derivation of the analysis significantly differ from ours so that we have not been able to compare the two analyses in detail. Much work has been done on the static analysis of sequential programs, including abstract interpretation <ref> [4] </ref> and 0CFA [26]. Our analysis most closely follows Heintze's work on set-based analysis for the sequential language ML [12], but the extension of this technique 5 Ito's group [Ito: personal communication, April 22, 1994] reports an attempt at touch optimization based on abstract interpretation. <p> We start from an parallel abstract machine and avoid Heintze's intermediate steps by deriving our set constraints and proving their correctness directly from the abstract machine semantics. Other techniques for static analysis of sequential programs include abstract interpretation <ref> [4, 5] </ref> and Shivers' 0CFA [26]. The relationship between abstract interpretation and set-based analysis was covered by Heintze [12]. Sequential optimization techniques such as tagging optimization [14] and soft-typing [29, 1] are similar in character to touch optimization.
Reference: [5] <author> Cousot, P., and Cousot, R. </author> <title> Higer order abstract interpretation (and application to comportment analysis generalizing strictness, termination, projection and per analysis of functional languages). </title> <booktitle> ICCL (1994), </booktitle> <pages> 95-112. </pages>
Reference-contexts: We start from an parallel abstract machine and avoid Heintze's intermediate steps by deriving our set constraints and proving their correctness directly from the abstract machine semantics. Other techniques for static analysis of sequential programs include abstract interpretation <ref> [4, 5] </ref> and Shivers' 0CFA [26]. The relationship between abstract interpretation and set-based analysis was covered by Heintze [12]. Sequential optimization techniques such as tagging optimization [14] and soft-typing [29, 1] are similar in character to touch optimization.

Reference: [7] <author> Feeley, M., and Miller, J. S. </author> <title> A parallel virtual machine for efficient scheme compilation. </title> <booktitle> In LFP (1990). </booktitle>
Reference-contexts: A quick examination verifies that F is the set environment E we derived previously for the program. 5 Experimental Results We extended the Gambit compiler <ref> [6, 7] </ref>, which makes no attempt to remove touch operations from programs, with a preprocessor that implements the set-based analysis algorithm and the touch optimization algorithm. The analysis and the optimization algorithm are 24 C. Flanagan, M.
Reference: [8] <author> Flanagan, C., and Felleisen, M. </author> <title> The semantics of Future. </title> <institution> Rice University Com puter Science TR94-238. </institution>
Reference-contexts: The specific example we choose to consider is the development of an algorithm that safely eliminates as many touch operations as possible. Other optimizations will be the subject of future efforts. In a previous paper <ref> [8] </ref>, we developed a series of semantics for an idealized functional language with future. The last semantics is particularly suited to the development of analysis and optimization algorithms, because it exposes appropriate details regarding program executions. <p> We believe that this development can be extended to larger languages and other implementation techniques. The presentation of our results proceeds as follows. The second section introduces a 2 C. Flanagan, M. Felleisen simple, functional language with futures, and recalls the low-level parallel abstract machine for the language <ref> [8] </ref>. The third section discusses the cost of touch operations and presents a provably correct algorithm for eliminating unnecessary touch operations. The latter is based on the set-based analysis algorithm of the fourth section. <p> j (let (x (apply y z)) M ) V 2 Value ::= c j x j (x: M ) j (cons x y) (Values) x 2 Vars = fx; y; z; : : :g (Variables) c 2 Const = fnil; 0; 1; : : :g (Constants) In a previous paper <ref> [8] </ref>, we developed a series of abstract machines, each specifying the semantics of futures at a different level of abstraction. The last of these machines, called the P (CEK)-machine, is particularly well-suited for the development of program analyses, since it contains explicit binding information relating program variables to their values.
Reference: [9] <author> Flanagan, C., and Felleisen, M. </author> <title> The semantics of future and its use in program optimizations. </title> <booktitle> In POPL (Jan. </booktitle> <year> 1995). </year>
Reference-contexts: The fifth section describes the implementation of these algorithms on the Gambit compiler and compares the modified compiler to the original compiler on a standard set of benchmarks. The sixth section discusses related work. This technical report is an expansion of a preliminary conference report <ref> [9] </ref>. 2 Review: The Language and Its Parallel Semantics Given the goal of developing a semantics that is useful for proving the soundness of optimizations, we develop the definitional semantics for futures for an intermediate representation of an idealized functional language.
Reference: [10] <author> Flanagan, C., Sabry, A., Duba, B. F., and Felleisen, M. </author> <title> The essence of compiling with continuations. </title> <booktitle> In PLDI (1993), </booktitle> <pages> pp. 237-247. </pages> <note> Well-Founded Touch Optimization for Futures 35 </note>
Reference-contexts: Specifically, we use the subset of A-normal forms <ref> [10] </ref> of an extended -calculus-like language that includes conditionals and a future construct: see Figure 1.
Reference: [11] <author> Halstead, R. </author> <title> Multilisp: A language for concurrent symbolic computataion. </title> <journal> ACM Transactions on Programming Languages and Systems 7, </journal> <volume> 4 (1985), </volume> <pages> 501-538. </pages>
Reference-contexts: However, if such a strategy were applied indiscriminately, the execution of a program would generate far too many parallel threads. The overhead of managing these threads would clearly outweigh any benefits from parallel execution. The future annotations of MultiLisp and its Scheme successors <ref> [2, 11] </ref> provide a simple method for taming the implicit parallelism of functional programs. If a programmer believes that the parallel evaluation of some expression outweighs the overhead of creating a separate task, he may annotate the expression with the keyword future.
Reference: [12] <author> Heintze, N. </author> <title> Set Based Program Analysis. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: Much work has been done on the static analysis of sequential programs, including abstract interpretation [4] and 0CFA [26]. Our analysis most closely follows Heintze's work on set-based analysis for the sequential language ML <ref> [12] </ref>, but the extension of this technique 5 Ito's group [Ito: personal communication, April 22, 1994] reports an attempt at touch optimization based on abstract interpretation. His group abandoned the effort due to the exponential cost of the abstract interpretation algorithm. 26 C. Flanagan, M. <p> Other techniques for static analysis of sequential programs include abstract interpretation [4, 5] and Shivers' 0CFA [26]. The relationship between abstract interpretation and set-based analysis was covered by Heintze <ref> [12] </ref>. Sequential optimization techniques such as tagging optimization [14] and soft-typing [29, 1] are similar in character to touch optimization. Both techniques remove the type-dispatches required for dynamic type-checking wherever possible, without changing the behavior of programs, in the same fashion as we remove touch operations.
Reference: [13] <author> Heintze, N. </author> <title> Set-based analysis of ML programs. </title> <booktitle> In LFP (1994), </booktitle> <pages> pp. 306-317. </pages>
Reference-contexts: Any set environment satisfying these constraints is a valid set environment. Second, we develop an algorithm for finding the minimal (i.e., most accurate) set environment satisfying these constraints. Our set constraints are similar to the constraints in Heintze's work on set-based analysis for SML <ref> [13] </ref>, but our derivation substantially differs from his. 4.1 Deriving Set Constraints for Program Variables Given a program P , a set constraint is of the form: A P where A P and B are statements concerning set environments, and A P also depends on the program.
Reference: [14] <author> Henglein, F. </author> <title> Global tagging optimization by type inference. </title> <booktitle> In LFP (1992), </booktitle> <pages> pp. 205-215. </pages>
Reference-contexts: Figures 2). Unlike eval pcek , the evaluator eval pcek is no longer a function. There are programs in fl a for which the evaluator 2 This approach is similar in character to optimization techniques such as soft-typing [29, 1] and tagging optimization <ref> [14] </ref>, which remove the type-dispatches required in dynamically-typed languages wherever possible. However, touch-optimization also applies to a statically-typed language with futures, where soft-typing and tagging optimization techniques are not as useful. <p> Other techniques for static analysis of sequential programs include abstract interpretation [4, 5] and Shivers' 0CFA [26]. The relationship between abstract interpretation and set-based analysis was covered by Heintze [12]. Sequential optimization techniques such as tagging optimization <ref> [14] </ref> and soft-typing [29, 1] are similar in character to touch optimization. Both techniques remove the type-dispatches required for dynamic type-checking wherever possible, without changing the behavior of programs, in the same fashion as we remove touch operations.
Reference: [15] <editor> Ito, T., and Halstead, R., Eds. </editor> <booktitle> Parallel Lisp: Languages and Systems. Springer-Verlag Lecture Notes in Computer Science 441, </booktitle> <year> 1989. </year>
Reference-contexts: However, even Feeley [6] described these as "poorly parallel" programs, in which the effects of memory contention and communication costs are especially visible. It is therefore not surprising that our optimizing compiler does not improve the running time in these cases. 6 Related Work Kranz et al. <ref> [15, 22] </ref> briefly describe a simplistic algorithm for touch optimization based on a first-order type analysis. The algorithm lowers the touch overhead to 65% from 100% in standard benchmarks, that is, it is significantly less effective than our touch optimization.
Reference: [16] <author> Ito, T., and Matsui, M. </author> <title> A parallel lisp language: Pailisp and its kernel specification. </title> [15:58-100]. 
Reference-contexts: Hence, these operations must be modified so that they first check whether the appropriate arguments are placeholders or proper values and must possibly perform some synchronization. Past research on futures has concentrated on the efficient implementation of the underlying task creation mechanism <ref> [6, 16, 22, 23, 24] </ref> and on the extension of the language with higher-order control constructs [18, 25]. Little effort has gone into the development of a semantic characterization of the idea or the use of such a semantic framework for the optimization of task creation or coordination.
Reference: [17] <author> Jagannathan, S., and Weeks, S. </author> <title> Analyzing stores and references in a parallel symbolic language. </title> <booktitle> In LFP (1994), </booktitle> <pages> pp. 294-305. </pages>
Reference-contexts: His paper presents neither a semantics nor the abstract interpretation. He only reports the reduction of static counts of touch operations for an implementation of Common Lisp with future. Neither paper gives an indication concerning the expense of the analysis algorithms. 5 At LFP '94, Jaganathan and Weeks <ref> [17] </ref> described an analysis for explicitly parallel symbolic programs, which they intend to use in a forthcoming compiler. They remark that the analysis could be used for touch optimizations.
Reference: [18] <author> Katz, M., and Weise, D. </author> <title> Continuing into the future: on the interaction of futures and first-class continuations. </title> <booktitle> In LFP (1990). </booktitle>
Reference-contexts: Past research on futures has concentrated on the efficient implementation of the underlying task creation mechanism [6, 16, 22, 23, 24] and on the extension of the language with higher-order control constructs <ref> [18, 25] </ref>. Little effort has gone into the development of a semantic characterization of the idea or the use of such a semantic framework for the optimization of task creation or coordination.
Reference: [19] <author> Kessler, R.R., and R. Swanson. </author> <title> Concurrent scheme. </title> [15:200-234]. 
Reference-contexts: The classical solution for avoiding this overhead is to provide a compiler switch that disables the automatic insertion of touches, and a touch primitive so that programmers can insert touch operations explicitly where needed <ref> [6, 19, 27] </ref>. We believe that this solution is flawed for several reasons. First, it clearly destroys the transparent character of future annotations. Instead of an annotation that only affects executions on some machines, future is now a task creation construct and touch is a synchronization tool.
Reference: [20] <author> Knopp, J. </author> <title> Improving the performance of parallel lisp by compile time analysis. </title> [15:271-277]. 
Reference-contexts: The algorithm lowers the touch overhead to 65% from 100% in standard benchmarks, that is, it is significantly less effective than our touch optimization. The paper does not address the semantics of future or the well-foundedness of the optimizations. Knopp <ref> [20] </ref> reports the existence of a touch optimization algorithm based on abstract interpretation. His paper presents neither a semantics nor the abstract interpretation. He only reports the reduction of static counts of touch operations for an implementation of Common Lisp with future.
Reference: [21] <author> Kranz, D., Halstead, R., and Mohr, E. Mul-T: </author> <title> A high-performance parallel lisp. </title> [15:306-321]. 
Reference-contexts: Flanagan, M. Felleisen Performing these placeholder? checks can add a significant overhead to the execution time. Kranz <ref> [21] </ref> and Feeley [6] estimated this cost at nearly 100% of the (sequential) execution time, and our experiments confirm these results (see below).
Reference: [22] <author> Kranz, D., Halstead, R., and Mohr, E. Mul-T: </author> <title> A high-performance parallel lisp. </title> <booktitle> In PLDI (1989), </booktitle> <pages> pp. 81-90. </pages>
Reference-contexts: Hence, these operations must be modified so that they first check whether the appropriate arguments are placeholders or proper values and must possibly perform some synchronization. Past research on futures has concentrated on the efficient implementation of the underlying task creation mechanism <ref> [6, 16, 22, 23, 24] </ref> and on the extension of the language with higher-order control constructs [18, 25]. Little effort has gone into the development of a semantic characterization of the idea or the use of such a semantic framework for the optimization of task creation or coordination. <p> However, even Feeley [6] described these as "poorly parallel" programs, in which the effects of memory contention and communication costs are especially visible. It is therefore not surprising that our optimizing compiler does not improve the running time in these cases. 6 Related Work Kranz et al. <ref> [15, 22] </ref> briefly describe a simplistic algorithm for touch optimization based on a first-order type analysis. The algorithm lowers the touch overhead to 65% from 100% in standard benchmarks, that is, it is significantly less effective than our touch optimization.
Reference: [23] <author> Miller, J. MultiScheme: </author> <title> A Parallel Processing System. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1987. </year>
Reference-contexts: Hence, these operations must be modified so that they first check whether the appropriate arguments are placeholders or proper values and must possibly perform some synchronization. Past research on futures has concentrated on the efficient implementation of the underlying task creation mechanism <ref> [6, 16, 22, 23, 24] </ref> and on the extension of the language with higher-order control constructs [18, 25]. Little effort has gone into the development of a semantic characterization of the idea or the use of such a semantic framework for the optimization of task creation or coordination.
Reference: [24] <author> Mohr, E., Kranz, R., and Halstead, R. </author> <title> Lazy task creation: A technique for increasing the granularity of parallel programs. </title> <booktitle> In LFP (1990). </booktitle>
Reference-contexts: Hence, these operations must be modified so that they first check whether the appropriate arguments are placeholders or proper values and must possibly perform some synchronization. Past research on futures has concentrated on the efficient implementation of the underlying task creation mechanism <ref> [6, 16, 22, 23, 24] </ref> and on the extension of the language with higher-order control constructs [18, 25]. Little effort has gone into the development of a semantic characterization of the idea or the use of such a semantic framework for the optimization of task creation or coordination.
Reference: [25] <author> Moreau, L. </author> <title> Sound Evaluation of Parallel Functional Programs with First-Class Continuations. </title> <type> PhD thesis, </type> <institution> Universite de Liege, </institution> <year> 1994. </year>
Reference-contexts: Past research on futures has concentrated on the efficient implementation of the underlying task creation mechanism [6, 16, 22, 23, 24] and on the extension of the language with higher-order control constructs <ref> [18, 25] </ref>. Little effort has gone into the development of a semantic characterization of the idea or the use of such a semantic framework for the optimization of task creation or coordination.
Reference: [26] <author> Shivers, O. </author> <title> Control-flow Analysis of Higher-Order Languages or Taming Lambda. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1991. </year>
Reference-contexts: Their semantics and their derivation of the analysis significantly differ from ours so that we have not been able to compare the two analyses in detail. Much work has been done on the static analysis of sequential programs, including abstract interpretation [4] and 0CFA <ref> [26] </ref>. Our analysis most closely follows Heintze's work on set-based analysis for the sequential language ML [12], but the extension of this technique 5 Ito's group [Ito: personal communication, April 22, 1994] reports an attempt at touch optimization based on abstract interpretation. <p> We start from an parallel abstract machine and avoid Heintze's intermediate steps by deriving our set constraints and proving their correctness directly from the abstract machine semantics. Other techniques for static analysis of sequential programs include abstract interpretation [4, 5] and Shivers' 0CFA <ref> [26] </ref>. The relationship between abstract interpretation and set-based analysis was covered by Heintze [12]. Sequential optimization techniques such as tagging optimization [14] and soft-typing [29, 1] are similar in character to touch optimization.
Reference: [27] <author> Swanson, M., Kessler, R., and Lindstrom, G. </author> <title> An implementation of portable standard lisp on the BBN butterfly. </title> <booktitle> In LFP (1988), </booktitle> <pages> pp. 132-142. </pages>
Reference-contexts: The classical solution for avoiding this overhead is to provide a compiler switch that disables the automatic insertion of touches, and a touch primitive so that programmers can insert touch operations explicitly where needed <ref> [6, 19, 27] </ref>. We believe that this solution is flawed for several reasons. First, it clearly destroys the transparent character of future annotations. Instead of an annotation that only affects executions on some machines, future is now a task creation construct and touch is a synchronization tool.
Reference: [28] <author> Wright, A. K., and Duba, B. F. </author> <title> Pattern matching for Scheme. </title> <type> Unpublished manuscript, </type> <year> 1993. </year>
Reference-contexts: B Set Based Analysis Algorithm A complete O (jP j 3 ) time set-based analysis algorithm 6 for the intermediate language fl a is included in Figures 11 through 13. The algorithm is written in Scheme extended with a special form match for pattern matching <ref> [28] </ref>. The function SBA traverses an expression to derive the representation constraints for that expression. Certain representation constraints cannot be satisfied immediately.
Reference: [29] <author> Wright, A. and R. Cartwright. </author> <title> A practical soft type system for scheme. </title> <booktitle> In LFP (1994), </booktitle> <pages> pp. 250-262. </pages>
Reference-contexts: However, a standard technique for increasing execution speed in Scheme systems is to disable type-checking typically based on informal correctness arguments or based on type verifiers for the underlying sequential language <ref> [29, 1] </ref>. When type-checking is disabled, most program operations do not perform a type-dispatch on their arguments. <p> Figures 2). Unlike eval pcek , the evaluator eval pcek is no longer a function. There are programs in fl a for which the evaluator 2 This approach is similar in character to optimization techniques such as soft-typing <ref> [29, 1] </ref> and tagging optimization [14], which remove the type-dispatches required in dynamically-typed languages wherever possible. However, touch-optimization also applies to a statically-typed language with futures, where soft-typing and tagging optimization techniques are not as useful. <p> Other techniques for static analysis of sequential programs include abstract interpretation [4, 5] and Shivers' 0CFA [26]. The relationship between abstract interpretation and set-based analysis was covered by Heintze [12]. Sequential optimization techniques such as tagging optimization [14] and soft-typing <ref> [29, 1] </ref> are similar in character to touch optimization. Both techniques remove the type-dispatches required for dynamic type-checking wherever possible, without changing the behavior of programs, in the same fashion as we remove touch operations.
References-found: 27

