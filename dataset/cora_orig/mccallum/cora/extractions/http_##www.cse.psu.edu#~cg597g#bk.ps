URL: http://www.cse.psu.edu/~cg597g/bk.ps
Refering-URL: http://www.cse.psu.edu/~cg597g/terzo.html
Root-URL: http://www.cse.psu.edu
Email: dale@saul.cis.upenn.edu  
Title: Prolog: An Introduction to the Language and its Logic Draft: not for general distribution or
Author: c Dale Miller 
Web: http://www.cis.upenn.edu/dale  
Address: Philadelphia, PA 19104-6389 USA Office: +(215)898-1593  
Affiliation: Department of Computer and Information Science University of Pennsylvania  
Date: January 1996  
Pubnum: 6  
Abstract-found: 0
Intro-found: 1
Reference: [ACMP84] <author> Peter B. Andrews, Eve Longini Cohen, Dale Miller, and Frank Pfenning. </author> <title> Automating higher order logic. In Automated Theorem Proving: </title> <type> After 25 Years, </type> <pages> pages 169-192. </pages> <publisher> American Mathematical Society, </publisher> <address> Providence, RI, </address> <year> 1984. </year>
Reference-contexts: Many standard proof-theoretic results such as cut-elimination [Tak67] and [Gir86], unification [Hue75], resolution [And71], and Skolemization and Herbrand's Theorem [Mil87b] have been formulated for this fragment. Using these results as a foundation, it is possible to write theorem provers for this fragment of higher-order logic <ref> [ACMP84] </ref>. The presence of predicate quantification, however, makes theorem proving particularly challenging. In first-order logic, the result of substituting into an expression does not change its logical structure. In the higher-order setting, however, universal instantiation may increase the number of logical connectives and quantifiers in a formulas.
Reference: [And71] <author> Peter B. Andrews. </author> <title> Resolution in type theory. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 36 </volume> <pages> 414-432, </pages> <year> 1971. </year>
Reference-contexts: The first six axioms (which do not include extensionality) describe a logic that extends first-order logic by permitting quantification at all types and by replacing first-order terms by simply typed -terms modulo fi and j-conversion. Many standard proof-theoretic results such as cut-elimination [Tak67] and [Gir86], unification [Hue75], resolution <ref> [And71] </ref>, and Skolemization and Herbrand's Theorem [Mil87b] have been formulated for this fragment. Using these results as a foundation, it is possible to write theorem provers for this fragment of higher-order logic [ACMP84]. The presence of predicate quantification, however, makes theorem proving particularly challenging. <p> It is possible to specify object-level substitution without using the copy-clauses directly. The module in Figure 7.7 provides such a specification, which is based loosely on the equational presentation of -conversion found in <ref> [And71, And86] </ref>. The clauses in that module are also signature dependent. The specification using the copy-clauses, however, seems more natural and flexible.
Reference: [And86] <author> P. B. Andrews. </author> <title> An Introduction to Mathematical Logic and Type Theory. </title> <publisher> Academic Press, </publisher> <year> 1986. </year>
Reference-contexts: Theorem provers in first-order logic need to only consider substitutions that are generated by the unification of atomic formulas. Since logical connectives within substitutions are possible in higher-order logic, as this example shows, atomic formula unification does not suggest enough substitution terms. 6.5. HIGHER-ORDER LOGICS 85 The textbook <ref> [And86] </ref> and the handbook article [Lei95] are good sources for getting more information on higher-order logic. 86 CHAPTER 6. SIMPLY TYPED -TERMS AND FORMULAS Chapter 7 Computing with -terms In this chapter we describe a fragment of Prolog in which -terms first appear within terms. <p> It is possible to specify object-level substitution without using the copy-clauses directly. The module in Figure 7.7 provides such a specification, which is based loosely on the equational presentation of -conversion found in <ref> [And71, And86] </ref>. The clauses in that module are also signature dependent. The specification using the copy-clauses, however, seems more natural and flexible.
Reference: [AvE82] <author> K. R. Apt and M. H. van Emden. </author> <title> Contributions to the theory of logic programming. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <year> 1982. </year>
Reference-contexts: Dually, positive subformulas of D-formulas are D-formulas and negative subformulas of D-formulas are G-formulas. 3.4 The syntax of first-order Horn clauses There are several, roughly equivalent ways to describe first-order Horn clauses (fohc for short). We present three here. A common definition (see, for example, <ref> [AvE82] </ref>) is given using the following grammar.
Reference: [Bar84] <author> Hank Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <address> Elsevier, </address> <note> revised edition, </note> <year> 1984. </year>
Reference-contexts: It is well known that every simply typed -term has a -normal form and that this normal form is unique up to ff-conversion (see <ref> [Bar84, HS86] </ref>). This normal form can be computed by repeatedly replacing subterms of the form (x:s)t by s [t=x] and subterms of the form x:(sx) with s (provided x is not free in s). We denote the -normal form of s by norm (s).
Reference: [CH88] <author> Thierry Coquand and Gerard Huet. </author> <title> The calculus of constructions. </title> <journal> Information and Computation, </journal> 76(2/3):95-120, February/March 1988. 
Reference-contexts: This restriction is made, however, largely because we wish to avoid the operational problems just mentioned. There are, however, meaningful uses to be made of predicates at the head of a clause. For example, Felty has provided an encoding of the Calculus of Constructions <ref> [CH88] </ref> into higher-order logic that makes use of flexible atoms in the heads of clauses [Fel93]. Also, Leibniz defined equality by stating that two terms are equal if they satisfy the same predicates.
Reference: [Chu40] <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: An example of this kind is the specification logic that is used by the Isabelle proof system [Pau90]. 6.5.2 The Simple Theory of Types Church in <ref> [Chu40] </ref> introduced a typing system containing function types and a special type for booleans used to represent formulas and predicates. The logic introduced in [Chu40], called the Simple Theory of Types also contains simply typed -term and -conversion. <p> An example of this kind is the specification logic that is used by the Isabelle proof system [Pau90]. 6.5.2 The Simple Theory of Types Church in <ref> [Chu40] </ref> introduced a typing system containing function types and a special type for booleans used to represent formulas and predicates. The logic introduced in [Chu40], called the Simple Theory of Types also contains simply typed -term and -conversion. <p> The syntax of Prolog terms and formulas is directly inspired by the syntax of term and formulas in <ref> [Chu40] </ref>. <p> These have been added to Prolog to provide for flexible polymorphic typing of some programs. The use of o as the type of formulas and the use of pi and sigma as quantifiers comes directly from <ref> [Chu40] </ref>. 6.5.3 Semantics for the Simple Theory of Types There are many ways to interpret higher-order logic with category theory providing one of the richest possibilities [LS86]. Here we outline an early approach used by Henkin [Hen50]. <p> Intuitionistic variations of such models, based on Kripke models [MM91] or topoi [LS86], might be employed to study the more general versions of higher-order hereditary Harrop formulas presented in Chapter 9. 6.5.4 Proof theory for the Simple Theory of Types In <ref> [Chu40] </ref>, a series of axioms were presented to describe the Simple Theory of Types. The first six axioms (which do not include extensionality) describe a logic that extends first-order logic by permitting quantification at all types and by replacing first-order terms by simply typed -terms modulo fi and j-conversion. <p> When using abstract syntax, details of object-level bound variables and about substitution are handled declaratively by Prolog. Behind the concept of abstract syntax are two notions. First, -terms and their equational theory should be used uniformly to represent syntax containing bound variables. Already in <ref> [Chu40] </ref>, Church was doing exactly this to encoded the universal and existential 110 CHAPTER 7. COMPUTING WITH -TERMS quantifiers as well as the definite description operator. Following this approach, instantiation of quantifiers can be specified using fi-reduction, much as will be done in Subsection 8.3.3.
Reference: [CM84] <author> W. F. Clocksin and C. S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Prolog is not, however, a sublanguage for at least two reasons. First, Prolog contains many special predicates that are not available in Prolog, such as the predicates var, assert, retract, and =.. (see, for example, <ref> [CM84] </ref> and [SS86] for a description of these predicates). Second, Prolog is strongly typed while Prolog has no typing discipline. As a result, there are Prolog programs that cannot be typed within Prolog without trivializing its typing discipline.
Reference: [Ell89] <author> Conal Elliott. </author> <title> Higher-order unification with dependent types. </title> <booktitle> In Rewriting Techniques and Applications, </booktitle> <volume> volume 355, </volume> <pages> pages 121-136. </pages> <publisher> Springer-Verlag LNCS, </publisher> <month> April </month> <year> 1989. </year>
Reference-contexts: Also at about this time, Harper, Honsell, and Plotkin in [HHP87] proposed representing logics in a dependent typed -calculus. While they did not deal with the issue of the computational treatment of syntax directly, this was addressed later by considering the unification of dependent typed -expressions by Elliott <ref> [Ell89] </ref> and Pym [Pym90]. The treatment of abstract syntax in the above mentioned papers had a couple unfortunate aspects. First, the treatments involve unification with respect to the full fij-theory of the -calculus, and this general theory is computational expensive.
Reference: [Fel93] <author> Amy Felty. </author> <title> Encoding the calculus of constructions in a higher-order logic. </title> <editor> In M. Vardi, editor, </editor> <booktitle> Eighth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 233-244. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: There are, however, meaningful uses to be made of predicates at the head of a clause. For example, Felty has provided an encoding of the Calculus of Constructions [CH88] into higher-order logic that makes use of flexible atoms in the heads of clauses <ref> [Fel93] </ref>. Also, Leibniz defined equality by stating that two terms are equal if they satisfy the same predicates. Thus, the equation x + 0 = x could be specified using the two clauses P (X + 0) :- P X. <p> This is, indeed, the approach taken in the definition of hohh in the next section. A. Felty has shown that if disjunctions and existentials are not allowed within formulas and terms, then it is possible to allow implications within terms and still maintain the completeness of goal-directed provability <ref> [Fel93] </ref>. 136 CHAPTER 9. HIGHER-ORDER HEREDITARY HARROP FORMULAS 9.3 The definitions of hohh and hohh + Two possible problems in designing hohh have been discussed. In each case, we can define things so that the problems disappear but this also rules out some interesting and useful programming techniques.
Reference: [FM88] <author> Amy Felty and Dale Miller. </author> <title> Specifying theorem provers in a higher-order logic programming language. </title> <booktitle> In Ninth International Conference on Automated Deduction, </booktitle> <pages> pages 61-80, </pages> <address> Argonne, IL, May 1988. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In that paper the central ideas and advantages behind abstract syntax are discussed. Further examples were also contained in the paper <ref> [FM88] </ref> by Felty and Miller. In the context of theorem proving, Paulson also independently proposed similar ideas [Pau86]. In [PE88] Pfenning and Elliot extended the observations in [MN87b] by producing examples where the meta-language that incorporated -abstractions contained not just simple types but also product types.
Reference: [G 65] <author> Kurt Godel. </author> <title> On formally undecidable propositions of the principia mathematica and related systems. </title> <editor> I. In Martin Davis, </editor> <title> The Undecidable. </title> <publisher> Raven Press, </publisher> <year> 1965. </year> <note> 145 146 BIBLIOGRAPHY </note>
Reference-contexts: It is possible to identify at least three different readings for this term. 1. Philosophers of mathematics usually divide logic into first-order logic and second-order logic. The latter is a formal basis for all of mathematics and, as a consequence of Godel's first incompleteness theorem <ref> [G 65] </ref>, cannot be recursively axiomatized. Thus, higher-order logic in this sense is basically a model theoretic study [Sha85]. 2. To a proof theorist, all logics correspond to formal systems that are recursively presented and a higher-order logic is no different.
Reference: [Gir86] <author> Jean-Yves Girard. </author> <title> The system F of variable types: Fifteen years later. </title> <journal> Theoretical Computer Science, </journal> <volume> 45 </volume> <pages> 159-192, </pages> <year> 1986. </year>
Reference-contexts: The first six axioms (which do not include extensionality) describe a logic that extends first-order logic by permitting quantification at all types and by replacing first-order terms by simply typed -terms modulo fi and j-conversion. Many standard proof-theoretic results such as cut-elimination [Tak67] and <ref> [Gir86] </ref>, unification [Hue75], resolution [And71], and Skolemization and Herbrand's Theorem [Mil87b] have been formulated for this fragment. Using these results as a foundation, it is possible to write theorem provers for this fragment of higher-order logic [ACMP84]. The presence of predicate quantification, however, makes theorem proving particularly challenging.
Reference: [GTL89] <author> Jean-Yves Girard, Paul Taylor, and Yves Lafont. </author> <title> Proofs and Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: HIGHER-ORDER LOGICS 83 Cut-elimination proofs for higher-order logics differ qualitatively from those for first-order logic in that they need techniques such as Girard's "candidats de reductibilite," whereas proofs in first-order logics can generally be done by induction <ref> [GTL89] </ref>. Semantic arguments can be employed in this setting, but general models (including non-standard models) in the sense of Henkin [Hen50] must be considered. 3.
Reference: [Hen50] <author> Leon Henkin. </author> <title> Completeness in the theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 15 </volume> <pages> 81-91, </pages> <year> 1950. </year>
Reference-contexts: Semantic arguments can be employed in this setting, but general models (including non-standard models) in the sense of Henkin <ref> [Hen50] </ref> must be considered. 3. To many working in automated deduction, higher-order logic refers to any computational logic that contains typed -terms and/or variables of some higher-order type, although not necessarily of predicate type. <p> Here we outline an early approach used by Henkin <ref> [Hen50] </ref>. Higher-order logic can be interpreted over a pair hfD oe g oe ; J i, where oe ranges over all types. <p> It is possible to interpret terms and formulas over domains other than the standard one. Henkin <ref> [Hen50] </ref> developed a notion of general model that included non-standard as well as standard models.
Reference: [HHP87] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <booktitle> In Second Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 194-204, </pages> <address> Ithaca, NY, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: In [PE88] Pfenning and Elliot extended the observations in [MN87b] by producing examples where the meta-language that incorporated -abstractions contained not just simple types but also product types. In that paper they coined the expression higher-order abstract syntax. Also at about this time, Harper, Honsell, and Plotkin in <ref> [HHP87] </ref> proposed representing logics in a dependent typed -calculus. While they did not deal with the issue of the computational treatment of syntax directly, this was addressed later by considering the unification of dependent typed -expressions by Elliott [Ell89] and Pym [Pym90].
Reference: [HL78] <author> Gerard Huet and Bernard Lang. </author> <title> Proving and applying program transformations expressed with second-order patterns. </title> <journal> Acta Informatica, </journal> <volume> 11 </volume> <pages> 31-55, </pages> <year> 1978. </year>
Reference-contexts: The second important notion behind abstract syntact is that of defining operations for composing and decomposing syntax that respect ff-equivalence classes. This appears to have first been done by Huet and Lang in <ref> [HL78] </ref> where the authors clearly discuss the advantages of using simply typed -terms and with doing matching modulo the equational rules for - conversion. Their approach, however, was rather weak since it only used matching (not unification more generally). <p> The treatment of abstract syntax in the above mentioned papers had a couple unfortunate aspects. First, the treatments involve unification with respect to the full fij-theory of the -calculus, and this general theory is computational expensive. In the case, of <ref> [HL78] </ref>, only second-order matching was used and this is NP-complete. In the later papers, full unification was used and this is an undecidable operation. Second, various different type systems were employed to illustrate abstract syntax: simple types, product types, and dependent types.
Reference: [HL94] <author> Pat Hill and John Lloyd. </author> <title> The Godel Programming Language. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: A major goal of this monograph is to present a coherent and useful interpretation of these language features. For various reasons, it seems clear that Prolog is not ready for a formal definition in the style of those given for Standard ML [MTH90] and Godel <ref> [HL94] </ref>. What is contained here is an informal description of the language. Major changes to at least the parts of the language outside of its logical core should be expected. Provide a description of various subsets of Prolog. The largeness of Prolog is both an advantage and a disadvantage.
Reference: [HM91] <author> Joshua Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuitionistic linear logic: Extended abstract. </title> <editor> In G. Kahn, editor, </editor> <booktitle> Sixth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 32-42, </pages> <address> Amsterdam, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: It is the higher-order version of hereditary Harrop formulas that is now the basis of Prolog as it is described here. The notion of goal directed search has been used to also identify extensions to hereditary Harrop formulas involving linear logic <ref> [HM91, HM94, Mil94] </ref>: these extensions are not incorporated into the following description of Prolog. Along with the development of Prolog's design and logical foundations, numerous implementations have been written and planned.
Reference: [HM94] <author> Joshua Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuitionistic linear logic. </title> <journal> Information and Computation, </journal> <volume> 110(2) </volume> <pages> 327-365, </pages> <year> 1994. </year>
Reference-contexts: It is the higher-order version of hereditary Harrop formulas that is now the basis of Prolog as it is described here. The notion of goal directed search has been used to also identify extensions to hereditary Harrop formulas involving linear logic <ref> [HM91, HM94, Mil94] </ref>: these extensions are not incorporated into the following description of Prolog. Along with the development of Prolog's design and logical foundations, numerous implementations have been written and planned.
Reference: [HS86] <author> J. Roger Hindley and Jonathan P. Seldin. </author> <title> Introduction to Combinatory Logic and Lambda Calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: It is well known that every simply typed -term has a -normal form and that this normal form is unique up to ff-conversion (see <ref> [Bar84, HS86] </ref>). This normal form can be computed by repeatedly replacing subterms of the form (x:s)t by s [t=x] and subterms of the form x:(sx) with s (provided x is not free in s). We denote the -normal form of s by norm (s).
Reference: [Hue75] <author> Gerard Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: The first six axioms (which do not include extensionality) describe a logic that extends first-order logic by permitting quantification at all types and by replacing first-order terms by simply typed -terms modulo fi and j-conversion. Many standard proof-theoretic results such as cut-elimination [Tak67] and [Gir86], unification <ref> [Hue75] </ref>, resolution [And71], and Skolemization and Herbrand's Theorem [Mil87b] have been formulated for this fragment. Using these results as a foundation, it is possible to write theorem provers for this fragment of higher-order logic [ACMP84]. The presence of predicate quantification, however, makes theorem proving particularly challenging. <p> Second, it should be expected that any implementation of fij-unification will actually provide an effective implementation of L -unification. Huet's procedure for fij-unification <ref> [Hue75] </ref>, can be easily modified to do L -unification: the modification is that flexible-flexible pairs in the L -setting can be solved uniquely, where as Huet's procedure do not attempt to solve them.
Reference: [Lei95] <author> Daniel Leivant. </author> <title> Higher-order logics, volume 5, </title> <publisher> chapter ? Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Since logical connectives within substitutions are possible in higher-order logic, as this example shows, atomic formula unification does not suggest enough substitution terms. 6.5. HIGHER-ORDER LOGICS 85 The textbook [And86] and the handbook article <ref> [Lei95] </ref> are good sources for getting more information on higher-order logic. 86 CHAPTER 6. SIMPLY TYPED -TERMS AND FORMULAS Chapter 7 Computing with -terms In this chapter we describe a fragment of Prolog in which -terms first appear within terms.
Reference: [LMR89] <author> J. Lobo, J. Minker, and A. Rajasekar. </author> <title> Extending the semantics of logic programs to disjunctive logic programs. </title> <booktitle> In Sixth International Logic Programming Conference, </booktitle> <pages> pages 255-267, </pages> <address> Lisbon, Portugal, June 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: All of the extensions of Horn clauses encompassed by Prolog are logic programming languages in this abstract sense (the underlying logic is that of intuitionistic logic). The logic programming literature includes proposals for logic programming languages that contain disjunctions and for which goal-directed provability is not complete <ref> [LMR89] </ref>. Prolog does not encompass such extensions of Horn clauses. Goal-directed search has been formalized using the notion of uniform proofs. For more on that topic, see [MNPS91]. 5.2 Three presentations of fohh In this section we present the first-order hereditary Harrop formulas or fohh, for short.
Reference: [LS86] <author> J. Lambek and P. J. Scott. </author> <title> Introduction to Higher Order Categorical Logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: The use of o as the type of formulas and the use of pi and sigma as quantifiers comes directly from [Chu40]. 6.5.3 Semantics for the Simple Theory of Types There are many ways to interpret higher-order logic with category theory providing one of the richest possibilities <ref> [LS86] </ref>. Here we outline an early approach used by Henkin [Hen50]. Higher-order logic can be interpreted over a pair hfD oe g oe ; J i, where oe ranges over all types. <p> See also [Wol95]. The work by Church, Henkin, and Nadathur all focused on classical versions of the Simple Theory of Types. Intuitionistic variations of such models, based on Kripke models [MM91] or topoi <ref> [LS86] </ref>, might be employed to study the more general versions of higher-order hereditary Harrop formulas presented in Chapter 9. 6.5.4 Proof theory for the Simple Theory of Types In [Chu40], a series of axioms were presented to describe the Simple Theory of Types.
Reference: [Mil86] <author> Dale Miller. </author> <title> A theory of modules for logic programming. </title> <editor> In Robert M. Keller, editor, </editor> <booktitle> Third Annual IEEE Symposium on Logic Programming, </booktitle> <pages> pages 106-114, </pages> <address> Salt Lake City, Utah, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: This choice of formalism was fortunate since it helped isolate some intrinsic and high-level characteristics of logic programming. In particular, computation in logic programming can be usefully identified with the search for proofs, in particular, with goal-directed search of cut-free sequent proofs. In a series of papers <ref> [Mil86, Mil87a, MNS87, MNPS91] </ref> this characterization was used to develop and justify the intuitionistic theory of hereditary Harrop formulas as a suitable basis for logic programming. It is the higher-order version of hereditary Harrop formulas that is now the basis of Prolog as it is described here.
Reference: [Mil87a] <author> Dale Miller. </author> <title> Hereditary harrop formulas and logic programming. </title> <booktitle> In Proceedings of the VIII International Congress of Logic, Methodology, and Philosophy of Science, </booktitle> <pages> pages 153-156, </pages> <address> Moscow, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: This choice of formalism was fortunate since it helped isolate some intrinsic and high-level characteristics of logic programming. In particular, computation in logic programming can be usefully identified with the search for proofs, in particular, with goal-directed search of cut-free sequent proofs. In a series of papers <ref> [Mil86, Mil87a, MNS87, MNPS91] </ref> this characterization was used to develop and justify the intuitionistic theory of hereditary Harrop formulas as a suitable basis for logic programming. It is the higher-order version of hereditary Harrop formulas that is now the basis of Prolog as it is described here.
Reference: [Mil87b] <author> Dale A. Miller. </author> <title> A compact representation of proofs. </title> <journal> Studia Logica, </journal> <volume> 46(4) </volume> <pages> 347-370, </pages> <year> 1987. </year> <note> BIBLIOGRAPHY 147 </note>
Reference-contexts: Many standard proof-theoretic results such as cut-elimination [Tak67] and [Gir86], unification [Hue75], resolution [And71], and Skolemization and Herbrand's Theorem <ref> [Mil87b] </ref> have been formulated for this fragment. Using these results as a foundation, it is possible to write theorem provers for this fragment of higher-order logic [ACMP84]. The presence of predicate quantification, however, makes theorem proving particularly challenging.
Reference: [Mil91] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <journal> Journal of Logic and Computation, </journal> <volume> 1(4) </volume> <pages> 497-536, </pages> <year> 1991. </year>
Reference-contexts: Skolemization is not used further here: see [Mil92] for more about both raising and Skolemization. 7.4 Specifying an object-logic Much of the formal and technical detail of a complete specification of L <ref> [Mil91] </ref> is caused by needing to keep track of bound variable names and scope. Since all these details are formally incorporated into L , programs written using L should be relieved of much of the need to deal with such details. The following examples attempt to illustrate this point. <p> Second, various different type systems were employed to illustrate abstract syntax: simple types, product types, and dependent types. However, if abstract syntax is essentially just about a treatment of bound variables in syntax, it should have a form that is independent from typing. The introduction of L in <ref> [Mil91] </ref> provided solutions to both of these problems regarding abstract syntax. First, L provides a setting where the unification of -terms is computational cheap: it was shown by Qian [Qia93] that L -unification can be done in linear time and space (as with first-order unification). <p> First, L provides a setting where the unification of -terms is computational cheap: it was shown by Qian [Qia93] that L -unification can be done in linear time and space (as with first-order unification). Also, Nipkow showed that the exponential unification algorithm presented in <ref> [Mil91] </ref> can be effective used [Nip93]. Second, it was also shown in [Mil91] that L -unification can be described for untyped -terms: that is, typing may impose additional constraints on unification, but the L -unification can be defined without types. <p> Also, Nipkow showed that the exponential unification algorithm presented in <ref> [Mil91] </ref> can be effective used [Nip93]. Second, it was also shown in [Mil91] that L -unification can be described for untyped -terms: that is, typing may impose additional constraints on unification, but the L -unification can be defined without types. Thus, it is possible then to define L -like unification for various typed calculi [Pfe91].
Reference: [Mil92] <author> Dale Miller. </author> <title> Unification under a mixed prefix. </title> <journal> Journal of Symbolic Computation, </journal> <pages> pages 321-358, </pages> <year> 1992. </year>
Reference-contexts: Second, Skolemization causes an introduction of a new constant of type oe ! o instead of type oe, while raising causes an introduction of a new free variable of type oe ! o instead of type oe. Skolemization is not used further here: see <ref> [Mil92] </ref> for more about both raising and Skolemization. 7.4 Specifying an object-logic Much of the formal and technical detail of a complete specification of L [Mil91] is caused by needing to keep track of bound variable names and scope.
Reference: [Mil94] <editor> Dale Miller. A multiple-conclusion meta-logic. In S. Abramsky, editor, </editor> <booktitle> Ninth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 272-281, </pages> <address> Paris, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: It is the higher-order version of hereditary Harrop formulas that is now the basis of Prolog as it is described here. The notion of goal directed search has been used to also identify extensions to hereditary Harrop formulas involving linear logic <ref> [HM91, HM94, Mil94] </ref>: these extensions are not incorporated into the following description of Prolog. Along with the development of Prolog's design and logical foundations, numerous implementations have been written and planned.
Reference: [MM91] <author> John C. Mitchell and Eugenio Moggi. </author> <title> Kripke-style models for typed lambda calculus. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51, </volume> <year> 1991. </year>
Reference-contexts: These models might be useful in studying the semantics of, say, higher-order Horn clauses, as presented in Chapter 8. See also [Wol95]. The work by Church, Henkin, and Nadathur all focused on classical versions of the Simple Theory of Types. Intuitionistic variations of such models, based on Kripke models <ref> [MM91] </ref> or topoi [LS86], might be employed to study the more general versions of higher-order hereditary Harrop formulas presented in Chapter 9. 6.5.4 Proof theory for the Simple Theory of Types In [Chu40], a series of axioms were presented to describe the Simple Theory of Types.
Reference: [MN85] <author> Dale Miller and Gopalan Nadathur. </author> <title> A computational logic approach to syntax and semantics. </title> <booktitle> Presented at the Tenth Symposium of the Mathematical Foundations of Computer Science, </booktitle> <address> IBM Japan, </address> <month> May </month> <year> 1985. </year>
Reference-contexts: Miller and G. Nadathur worked at designing a higher-order extension of Horn clauses and at understanding their properties, possible applications, and the design of a logic programming language based on such clauses. The first paper describing this early work on Prolog was <ref> [MN85] </ref>. The theory and applications of higher-order Horn clauses was developed further in [MN86a, MN86b, Nad87, NM90].
Reference: [MN86a] <author> Dale Miller and Gopalan Nadathur. </author> <title> Higher-order logic programming. </title> <editor> In Ehud Shapiro, editor, </editor> <booktitle> Proceedings of the Third International Logic Programming Conference, </booktitle> <pages> pages 448-462, </pages> <address> London, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: The first paper describing this early work on Prolog was [MN85]. The theory and applications of higher-order Horn clauses was developed further in <ref> [MN86a, MN86b, Nad87, NM90] </ref>. Since the traditional techniques in the literature of logic programming appeared to be over-specialized for first-order, classical logic or were lacking in explanatory powers, the theoretical part of this early work relied, to a large extent, on the sequent calculus. <p> Their approach, however, was rather weak since it only used matching (not unification more generally). These restrictions make it impossible to express all but the simplest operations on syntax. Their approach was extended by Miller and Nadathur in [MN87b] (also see earlier papers <ref> [MN86a] </ref> and [MN86b]) by moving to a logic programming setting that contained fij-unification of simply typed -terms. In that paper the central ideas and advantages behind abstract syntax are discussed. Further examples were also contained in the paper [FM88] by Felty and Miller.
Reference: [MN86b] <author> Dale Miller and Gopalan Nadathur. </author> <title> Some uses of higher-order logic in computational linguistics. </title> <booktitle> In Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics, </booktitle> <pages> pages 247-255. </pages> <institution> Association for Computational Linguistics, Morristown, </institution> <address> New Jersey, </address> <year> 1986. </year>
Reference-contexts: The first paper describing this early work on Prolog was [MN85]. The theory and applications of higher-order Horn clauses was developed further in <ref> [MN86a, MN86b, Nad87, NM90] </ref>. Since the traditional techniques in the literature of logic programming appeared to be over-specialized for first-order, classical logic or were lacking in explanatory powers, the theoretical part of this early work relied, to a large extent, on the sequent calculus. <p> Their approach, however, was rather weak since it only used matching (not unification more generally). These restrictions make it impossible to express all but the simplest operations on syntax. Their approach was extended by Miller and Nadathur in [MN87b] (also see earlier papers [MN86a] and <ref> [MN86b] </ref>) by moving to a logic programming setting that contained fij-unification of simply typed -terms. In that paper the central ideas and advantages behind abstract syntax are discussed. Further examples were also contained in the paper [FM88] by Felty and Miller.
Reference: [MN87a] <author> Dale Miller and Gopalan Nadathur. </author> <title> Prolog Version 2.6. Distribution in C-Prolog sources, </title> <month> August </month> <year> 1987. </year>
Reference-contexts: Do not suspend the flexible goal. Instead simply instantiate the predicate variable head with the substitution described above. 3. Produce an error message. The first option can be shown to be complete [Nad87, NM90]: the other two are incomplete. An early implementation of Prolog <ref> [MN87a] </ref> chose not to reorder or suspend goals and used the second option. Experience with that implementation suggested that in the 8.2.
Reference: [MN87b] <author> Dale Miller and Gopalan Nadathur. </author> <title> A logic programming approach to manipulating formulas and programs. </title> <editor> In Seif Haridi, editor, </editor> <booktitle> IEEE Symposium on Logic Programming, </booktitle> <pages> pages 379-388, </pages> <address> San Francisco, </address> <month> September </month> <year> 1987. </year>
Reference-contexts: Their approach, however, was rather weak since it only used matching (not unification more generally). These restrictions make it impossible to express all but the simplest operations on syntax. Their approach was extended by Miller and Nadathur in <ref> [MN87b] </ref> (also see earlier papers [MN86a] and [MN86b]) by moving to a logic programming setting that contained fij-unification of simply typed -terms. In that paper the central ideas and advantages behind abstract syntax are discussed. Further examples were also contained in the paper [FM88] by Felty and Miller. <p> In that paper the central ideas and advantages behind abstract syntax are discussed. Further examples were also contained in the paper [FM88] by Felty and Miller. In the context of theorem proving, Paulson also independently proposed similar ideas [Pau86]. In [PE88] Pfenning and Elliot extended the observations in <ref> [MN87b] </ref> by producing examples where the meta-language that incorporated -abstractions contained not just simple types but also product types. In that paper they coined the expression higher-order abstract syntax. Also at about this time, Harper, Honsell, and Plotkin in [HHP87] proposed representing logics in a dependent typed -calculus.
Reference: [MNPS91] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: This choice of formalism was fortunate since it helped isolate some intrinsic and high-level characteristics of logic programming. In particular, computation in logic programming can be usefully identified with the search for proofs, in particular, with goal-directed search of cut-free sequent proofs. In a series of papers <ref> [Mil86, Mil87a, MNS87, MNPS91] </ref> this characterization was used to develop and justify the intuitionistic theory of hereditary Harrop formulas as a suitable basis for logic programming. It is the higher-order version of hereditary Harrop formulas that is now the basis of Prolog as it is described here. <p> The logic programming literature includes proposals for logic programming languages that contain disjunctions and for which goal-directed provability is not complete [LMR89]. Prolog does not encompass such extensions of Horn clauses. Goal-directed search has been formalized using the notion of uniform proofs. For more on that topic, see <ref> [MNPS91] </ref>. 5.2 Three presentations of fohh In this section we present the first-order hereditary Harrop formulas or fohh, for short. These formulas extend Horn clauses by allowing implications and universal quantifiers in goals (and, thus, in the body of program clauses). <p> The resulting language, unfortunately, does not constitute a logic programming language in the sense that there are be provable formulas that do not have goal-directed proofs (Section 5.1). For example, consider the formula <ref> [MNPS91] </ref> 9Q [8p8q [r (p oe q) oe r (Qpq)] ^ Q (t _ s)(s _ t)]; where r is a constant of type o ! o, s and t are constants of type o, Q is a variable of type o ! o ! o, and p and q are <p> The D-formulas will be called higher-order hereditary Harrop formulas. It is proved in <ref> [MNPS91] </ref> that goal-directed search in intuitionistic logic is complete in this setting. This definition can be liberalized a bit to hohh + , where richer quantification of predicates is allowed and where a proof that goal-directed search in intuitionistic logic is complete.
Reference: [MNS87] <author> Dale Miller, Gopalan Nadathur, and Andre Scedrov. </author> <title> Hereditary Harrop formulas and uniform proof systems. </title> <editor> In David Gries, editor, </editor> <booktitle> Symposium on Logic in Computer Science, </booktitle> <pages> pages 98-105, </pages> <address> Ithaca, NY, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: This choice of formalism was fortunate since it helped isolate some intrinsic and high-level characteristics of logic programming. In particular, computation in logic programming can be usefully identified with the search for proofs, in particular, with goal-directed search of cut-free sequent proofs. In a series of papers <ref> [Mil86, Mil87a, MNS87, MNPS91] </ref> this characterization was used to develop and justify the intuitionistic theory of hereditary Harrop formulas as a suitable basis for logic programming. It is the higher-order version of hereditary Harrop formulas that is now the basis of Prolog as it is described here.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Our descriptions of these topics will, however, be partial: we shall deal only with those aspects of these formal systems that support the operational reading of Prolog specifications and programs. Familiarity with the programming language 1.4. GOALS OF THIS MONOGRAPH 13 ML <ref> [MTH90] </ref> would be helpful although is not required: the type system of Prolog is related to that of ML and both languages permit higher-order programming, modules, abstract data-types, and polymorphic types. 1.4 Goals of this monograph Informally describe Prolog. <p> A major goal of this monograph is to present a coherent and useful interpretation of these language features. For various reasons, it seems clear that Prolog is not ready for a formal definition in the style of those given for Standard ML <ref> [MTH90] </ref> and Godel [HL94]. What is contained here is an informal description of the language. Major changes to at least the parts of the language outside of its logical core should be expected. Provide a description of various subsets of Prolog. <p> Free and bound variables are also typed but since their types can be inferred simply from the context in which they appear they are not given explicit typing declarations. Prolog is strongly typed in the style of the ML programming language <ref> [MTH90] </ref> on which its typing system was based. There are, however, significant differences between what typing means in ML and what it means in Prolog. For example, types in Prolog 15 16 CHAPTER 2. <p> Each of these types are describe further in subsections below. 4.6.1 Integers and Reals The syntax and semantics numbers is similiar to that adopted by Standard ML <ref> [MTH90] </ref>. Thus, negative integers and real numbers use ~ for the negative sign | ~5 is "minus 5" and ~5.4 is "minus 5.4". One major difference with Standard ML is that ad hoc polymorphism is advoided with the built-in operations.
Reference: [Nad87] <author> Gopalan Nadathur. </author> <title> A Higher-Order Logic as the Basis for Logic Programming. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <month> May </month> <year> 1987. </year>
Reference-contexts: The first paper describing this early work on Prolog was [MN85]. The theory and applications of higher-order Horn clauses was developed further in <ref> [MN86a, MN86b, Nad87, NM90] </ref>. Since the traditional techniques in the literature of logic programming appeared to be over-specialized for first-order, classical logic or were lacking in explanatory powers, the theoretical part of this early work relied, to a large extent, on the sequent calculus. <p> That is, instantiate such predicate variables with the universally true relation of the correct type. 2. Do not suspend the flexible goal. Instead simply instantiate the predicate variable head with the substitution described above. 3. Produce an error message. The first option can be shown to be complete <ref> [Nad87, NM90] </ref>: the other two are incomplete. An early implementation of Prolog [MN87a] chose not to reorder or suspend goals and used the second option. Experience with that implementation suggested that in the 8.2. <p> It is possible to prove sigma x"(p x) from this disjunction although no instance of this existential quantifier are provable from the disjunction (provability could be either classical or intuitionistic). Fortunately, it turns out that this apparent problem can be overcome. It was shown in <ref> [Nad87] </ref> (and later in [NM90]) that whenever there is any proof that a certain goal follows from a set of higher-order Horn clauses, there is a goal directed proof, and furthermore, all instances of Horn clauses in that proof will again be Horn clauses (substitution terms only need to be selected
Reference: [Nad94] <author> Gopalan Nadathur. </author> <title> A notion of models for higher-order logic. </title> <type> Technical Report CS-1994-34, </type> <institution> Department of Computer Science, Duke University, </institution> <month> October </month> <year> 1994. </year> <note> 148 BIBLIOGRAPHY </note>
Reference-contexts: Recently Nadathur has proposed a definition of model for the Simple Theory of Types without extensionality and for these models he provides a soundness and completeness result <ref> [NM95, Nad94] </ref>. These models might be useful in studying the semantics of, say, higher-order Horn clauses, as presented in Chapter 8. See also [Wol95]. The work by Church, Henkin, and Nadathur all focused on classical versions of the Simple Theory of Types.
Reference: [Nip93] <author> Tobias Nipkow. </author> <title> Functional unification of higher-order patterns. </title> <editor> In M. Vardi, editor, </editor> <booktitle> Eighth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 64-74. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: First, L provides a setting where the unification of -terms is computational cheap: it was shown by Qian [Qia93] that L -unification can be done in linear time and space (as with first-order unification). Also, Nipkow showed that the exponential unification algorithm presented in [Mil91] can be effective used <ref> [Nip93] </ref>. Second, it was also shown in [Mil91] that L -unification can be described for untyped -terms: that is, typing may impose additional constraints on unification, but the L -unification can be defined without types. Thus, it is possible then to define L -like unification for various typed calculi [Pfe91].
Reference: [NM90] <author> Gopalan Nadathur and Dale Miller. </author> <title> Higher-order Horn clauses. </title> <journal> Journal of the ACM, </journal> <volume> 37(4) </volume> <pages> 777-814, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The first paper describing this early work on Prolog was [MN85]. The theory and applications of higher-order Horn clauses was developed further in <ref> [MN86a, MN86b, Nad87, NM90] </ref>. Since the traditional techniques in the literature of logic programming appeared to be over-specialized for first-order, classical logic or were lacking in explanatory powers, the theoretical part of this early work relied, to a large extent, on the sequent calculus. <p> That is, instantiate such predicate variables with the universally true relation of the correct type. 2. Do not suspend the flexible goal. Instead simply instantiate the predicate variable head with the substitution described above. 3. Produce an error message. The first option can be shown to be complete <ref> [Nad87, NM90] </ref>: the other two are incomplete. An early implementation of Prolog [MN87a] chose not to reorder or suspend goals and used the second option. Experience with that implementation suggested that in the 8.2. <p> It is possible to prove sigma x"(p x) from this disjunction although no instance of this existential quantifier are provable from the disjunction (provability could be either classical or intuitionistic). Fortunately, it turns out that this apparent problem can be overcome. It was shown in [Nad87] (and later in <ref> [NM90] </ref>) that whenever there is any proof that a certain goal follows from a set of higher-order Horn clauses, there is a goal directed proof, and furthermore, all instances of Horn clauses in that proof will again be Horn clauses (substitution terms only need to be selected from H 1 ).
Reference: [NM95] <author> Gopalan Nadathur and Dale Miller. </author> <title> Higher-order logic programming, volume 5, </title> <publisher> chapter ? Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Recently Nadathur has proposed a definition of model for the Simple Theory of Types without extensionality and for these models he provides a soundness and completeness result <ref> [NM95, Nad94] </ref>. These models might be useful in studying the semantics of, say, higher-order Horn clauses, as presented in Chapter 8. See also [Wol95]. The work by Church, Henkin, and Nadathur all focused on classical versions of the Simple Theory of Types.
Reference: [Pau86] <author> Lawrence C. Paulson. </author> <title> Natural deduction as higher-order resolution. </title> <journal> Journal of Logic Programming, </journal> <volume> 3 </volume> <pages> 237-258, </pages> <year> 1986. </year>
Reference-contexts: In that paper the central ideas and advantages behind abstract syntax are discussed. Further examples were also contained in the paper [FM88] by Felty and Miller. In the context of theorem proving, Paulson also independently proposed similar ideas <ref> [Pau86] </ref>. In [PE88] Pfenning and Elliot extended the observations in [MN87b] by producing examples where the meta-language that incorporated -abstractions contained not just simple types but also product types. In that paper they coined the expression higher-order abstract syntax.
Reference: [Pau90] <author> Lawrence C. Paulson. </author> <title> Isabelle: The next 700 theorem provers. </title> <editor> In Piergiorgio Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 361-386. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: Conversely, a logic that is higher-order in the third sense may well not permit a quantification over predicates and, thus, may not be higher-order in the second sense. An example of this kind is the specification logic that is used by the Isabelle proof system <ref> [Pau90] </ref>. 6.5.2 The Simple Theory of Types Church in [Chu40] introduced a typing system containing function types and a special type for booleans used to represent formulas and predicates. The logic introduced in [Chu40], called the Simple Theory of Types also contains simply typed -term and -conversion.
Reference: [PE88] <author> Frank Pfenning and Conal Elliot. </author> <title> Higher-order abstract syntax. </title> <booktitle> In Proceedings of the ACM-SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 199-208. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: In that paper the central ideas and advantages behind abstract syntax are discussed. Further examples were also contained in the paper [FM88] by Felty and Miller. In the context of theorem proving, Paulson also independently proposed similar ideas [Pau86]. In <ref> [PE88] </ref> Pfenning and Elliot extended the observations in [MN87b] by producing examples where the meta-language that incorporated -abstractions contained not just simple types but also product types. In that paper they coined the expression higher-order abstract syntax.
Reference: [Pfe91] <author> Frank Pfenning. </author> <title> Unification and anti-unification in the Calculus of Constructions. </title> <editor> In G. Kahn, editor, </editor> <booktitle> Sixth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 74-85. </pages> <publisher> IEEE, </publisher> <month> July </month> <year> 1991. </year>
Reference-contexts: Second, it was also shown in [Mil91] that L -unification can be described for untyped -terms: that is, typing may impose additional constraints on unification, but the L -unification can be defined without types. Thus, it is possible then to define L -like unification for various typed calculi <ref> [Pfe91] </ref>. Thus L seems to be natural setting for supporting abstract syntax. Since types are not necessary, it seems best to avoid the adjective "higher-order" with respect to abstract syntax, since orders are generally calculated from types.
Reference: [Pym90] <author> David Pym. </author> <title> Proofs, Search and Computation in General Logic. </title> <type> PhD thesis, </type> <institution> LFCS, University of Edinburgh, </institution> <year> 1990. </year>
Reference-contexts: While they did not deal with the issue of the computational treatment of syntax directly, this was addressed later by considering the unification of dependent typed -expressions by Elliott [Ell89] and Pym <ref> [Pym90] </ref>. The treatment of abstract syntax in the above mentioned papers had a couple unfortunate aspects. First, the treatments involve unification with respect to the full fij-theory of the -calculus, and this general theory is computational expensive.
Reference: [Qia93] <author> Zhenyu Qian. </author> <title> Linear unification of higher-order patterns. </title> <editor> In J.-P. Jouannaud, editor, </editor> <booktitle> Proc. 1993 Coll. Trees in Algebra and Programming. </booktitle> <publisher> Springer Verlag LNCS, </publisher> <year> 1993. </year>
Reference-contexts: The introduction of L in [Mil91] provided solutions to both of these problems regarding abstract syntax. First, L provides a setting where the unification of -terms is computational cheap: it was shown by Qian <ref> [Qia93] </ref> that L -unification can be done in linear time and space (as with first-order unification). Also, Nipkow showed that the exponential unification algorithm presented in [Mil91] can be effective used [Nip93].
Reference: [Sha85] <author> Steward Shapiro. </author> <title> Second-order languages and mathematical practice. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 50(3) </volume> <pages> 714-742, </pages> <month> September </month> <year> 1985. </year>
Reference-contexts: Philosophers of mathematics usually divide logic into first-order logic and second-order logic. The latter is a formal basis for all of mathematics and, as a consequence of Godel's first incompleteness theorem [G 65], cannot be recursively axiomatized. Thus, higher-order logic in this sense is basically a model theoretic study <ref> [Sha85] </ref>. 2. To a proof theorist, all logics correspond to formal systems that are recursively presented and a higher-order logic is no different.
Reference: [SS86] <author> Leon Sterling and Ehud Shapiro. </author> <title> The Art of Prolog: Advanced Programming Techniques. </title> <publisher> MIT Press, </publisher> <address> Cambridge MA, </address> <year> 1986. </year>
Reference-contexts: In various chapters (to be included here later), several extended examples of the use of Prolog in various domains are given. 1.3 Prerequisites This monograph assumes some familiarity with programming with Prolog as well as an informal understanding of deduction within logic. The text <ref> [SS86] </ref>, for example, provides more than an adequate background. In the course of this monograph, we shall have occasion to speak about the first-order and higher-order versions of classical and intuitionistic logics as well as the -calculus and sequential proof systems. <p> Prolog is not, however, a sublanguage for at least two reasons. First, Prolog contains many special predicates that are not available in Prolog, such as the predicates var, assert, retract, and =.. (see, for example, [CM84] and <ref> [SS86] </ref> for a description of these predicates). Second, Prolog is strongly typed while Prolog has no typing discipline. As a result, there are Prolog programs that cannot be typed within Prolog without trivializing its typing discipline. <p> One such data structures is called difference lists (see, for example, <ref> [SS86] </ref>). Difference lists can be represented simply in Prolog as terms of type (pair (list A) (list A)) where the second list of the pair is a tail of the first list; for example, (pair (a::b::c::L) L).
Reference: [Sta79] <author> Richard Statman. </author> <title> The type calculus is not elementary recursive. </title> <journal> Theoretical Computer Science, </journal> <volume> 9 </volume> <pages> 73-81, </pages> <year> 1979. </year>
Reference-contexts: Statman has further analyzed the computational costs of -conversion with the simply type -calculus in <ref> [Sta79] </ref>. In most of the Prolog programs we shall consider, such blow-ups in the size of -normal terms is the exception. There are several reasons for this. * When computing with structures such as integers, we make use of built-in integers instead of those constructed as above.
Reference: [Tak67] <author> M. Takahashi. </author> <title> A proof of cut-elimination theorem in simple type-theory. </title> <journal> Journal of the Mathematical Society of Japan, </journal> <volume> 19 </volume> <pages> 399-410, </pages> <year> 1967. </year>
Reference-contexts: The first six axioms (which do not include extensionality) describe a logic that extends first-order logic by permitting quantification at all types and by replacing first-order terms by simply typed -terms modulo fi and j-conversion. Many standard proof-theoretic results such as cut-elimination <ref> [Tak67] </ref> and [Gir86], unification [Hue75], resolution [And71], and Skolemization and Herbrand's Theorem [Mil87b] have been formulated for this fragment. Using these results as a foundation, it is possible to write theorem provers for this fragment of higher-order logic [ACMP84]. The presence of predicate quantification, however, makes theorem proving particularly challenging.
Reference: [Tar92] <author> Paul Tarau. </author> <title> Program transformations and WAM-support for the compilation of definite metaprograms. </title> <booktitle> In Logic Programming: Proceedings of the First and Second Russian Conferences on Logic Programming, number 592 in LNAI, </booktitle> <pages> pages 462-473. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: As a final example of a style of programming that should be available in a higher-order version of Horn clauses, consider continuation passing style programming in the logic programming setting. For example, in <ref> [Tar92] </ref>, Horn clauses of the form A 1 ^ : : : ^ A n oe A 0 (n &gt; 0) are transformed to higher-order clauses of the form (A 1 (: : : (A n G) : : :)) oe (A 0 G): The simple clause A 0 is transformed
Reference: [Wad91] <author> William W. Wadge. </author> <title> Higher-order Horn logic programming. </title> <booktitle> In Proceedings of the 1991 International Symposium on Logic Programming, </booktitle> <pages> pages 289-303, </pages> <month> October </month> <year> 1991. </year> <note> BIBLIOGRAPHY 149 </note>
Reference-contexts: a logic can be higher-order in the second sense but not in the third: there have been proposals for adding forms of predicate quantification to computational logics that do not use -terms and in which the equality of expressions continues to be based on the identity relation (see, for example, <ref> [Wad91] </ref>). Conversely, a logic that is higher-order in the third sense may well not permit a quantification over predicates and, thus, may not be higher-order in the second sense. <p> If our goal had been to simply capture a suitable generalization of the functionality behind higher-order programming in functional programming then we should have restricted the structure of hohc greatly. For example, quantification over higher-order but non-predicate types would not be necessary. For more on such restrictions, see <ref> [Wad91] </ref>. While such a restriction has its interest and merits, it only provides logic programming with a concept (higher-order programming) that is already familiar. With the stronger definition above, new programming features emerge that did not appear in any existing programming language.
Reference: [Wol95] <author> D.A. Wolfram. </author> <title> A semantics for Prolog. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: These models might be useful in studying the semantics of, say, higher-order Horn clauses, as presented in Chapter 8. See also <ref> [Wol95] </ref>. The work by Church, Henkin, and Nadathur all focused on classical versions of the Simple Theory of Types.
References-found: 58

