URL: http://www.cs.nmsu.edu/~epontell/ilps97/16.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/ilps97/programme.html
Root-URL: http://www.cs.nmsu.edu
Email: popow@ps.uni-sb.de  
Title: A Parallel Abstract Machine for the Thread-Based Concurrent Language Oz  
Author: Konstantin Popov 
Date: September 22, 1997  
Address: Geb. 45, Postfach 15 11 50, D-66041 Saarbrucken, Germany  
Affiliation: PS Lab, University of Saarland  
Abstract: A parallel abstract machine for Oz (PAMOz) is presented in this paper. Oz is a thread-based concurrent constraint programming language with state. Oz is convenient for concurrent programming like modelling multi-agent systems, as well as for solving combinatoric problems. PAMOz models the execution of a sublanguage of Oz without its constraint solving facilities. PAMOz has been implemented in the parallel Oz system, which is derived from the sequential Oz system and inherits its optimizations. PAMOz is targeted to shared-memory multiprocessors. PAMOz executes Oz threads in parallel. PAMOz is derived from AMOz, a sequential abstract machine for Oz. There are two principal differences between PAMOz and AMOz: the architecture of the abstract machine, and the implementation of operations on stateful data. PAMOz can be conservatively extended for full Oz; there is an interface between PAMOz and its constraint solving extension. 
Abstract-found: 1
Intro-found: 1
Reference: [AK91] <author> Hassan Ait-Kaci. </author> <title> The WAM: A Real Tutorial. Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: PAMOz is derived from AMOz [MSS95], an abstract machine for the sequential implementation of Oz [OzS]. Both abstract machines are emulator-based, as opposed to native-code compilation systems. They inherit ideas for data representation and code generation from the WAM <ref> [AK91] </ref>, and the representation scheme for first-class procedures and compilation of pattern matching from functional languages [PJ87]. PAMOz executes Oz threads in parallel. Threads are executed by running parallel workers. Workers are the only active entities in PAMOz. <p> It is similar to the AMOz one, which, in turn, is based on ideas from WAM <ref> [AK91] </ref>. 8 Bool StoreObject::bind (StoreObject flvar, StoreObject flto) f if (var!type == Var) f var!type = Ref; var!u.ref.ptr = to; return (TRUE); g else f return (FALSE); g A store object contains a type tag and further data depending on its type (the C++ like notation is used here): typedef enum <p> PAMOz models an implementation of a subset of Oz without constraint solving facilities. PAMOz is derived from AMOz a sequential abstract machine for Oz, which, in turn, has its origins in works on implementations of Prolog <ref> [AK91] </ref>, concurrent constraint languages [JH94], and functional programming languages [PJ87]. It turns out that PAMOz can be derived from a sequential abstract machine like AMOz only with a few changes. The first one is the implementation of primitives dealing with stateful data structures variables and cells.
Reference: [Cra88] <author> J. A. Crammond. </author> <title> Implementation of committed choice logic languages on shared memory multiprocessors. </title> <type> PhD thesis, </type> <institution> Heriot-Watt University, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: Compared to Oz variables and cells, Oz values are stateless and accessed as in a sequential 3 system. Correctness of the bind and block operations on variables is guaranteed by serializing them for each variable. This is achieved by means of so-called "spin locks", known from <ref> [Cra88, LMT95, MA95] </ref>. A spin lock transforms temporarily the variable object into the self-reference object. The effect of the lock is that the original object becomes inaccessible to other thread (s): a worker executing it falls into an endless loop until the object is unlocked.
Reference: [FCRN94] <author> Tetsuro Fujise, Takashi Chikayama, Kazuaki Rokusawa, and Akihiko Nakase. KLIC: </author> <title> A portable implementation of KL1. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 66-79, </pages> <publisher> ICOT, </publisher> <address> Tokyo, Japan, </address> <month> December </month> <year> 1994. </year> <note> ACM Press. </note>
Reference-contexts: KL1 is a fine-grained concurrent programming language with annotations for controlling parallelism. KL1 does not contain constraint solving facilities. Its parallel implementaion KLIC <ref> [FCRN94] </ref> is a native-code system. Synchronizing between executed in parallel activ 1 While, of course, constraint systems and synchronized entities are in general different. 4 ities has been added to the original sequential system through a special construct, instead of re-implementing basic primitives in PAMOz. <p> I believe that the most effective optimization among those that serve for better speedups is the per-worker memory management scheme, as implemented in [Mon97], and to some extent in <ref> [FCRN94] </ref>. Each worker has a local memory pool that is used to allocate locally created store objects. This eliminates the contention on memory manager that takes place in the case of a shared memory pool. <p> As a result, two processors interactively invalidate that cache line. Eliminating false sharing could result in 10% speedups [TLH94]. 15 KL1/KLIC <ref> [FCRN94] </ref>. KL1 is a fine-grain concurrent programming language with logic variables. The KLIC system exploits annotations to control the amount of parallelism. KLIC is a native code system: KL1 programs are translated into C. The system contains both local and shared heaps.
Reference: [Gud93] <author> David Gudeman. </author> <title> Representing type information in dynamically typed languages. </title> <type> TR 93-27, </type> <institution> Department of Computer Science, University of Arizona, </institution> <address> Tucson, AZ 85721, USA, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: In general, optimizations that are applicable to AMOz will be also applicable to PAMOz, possibly excepting those dealing with synchronizing primitives. Both sequential and parallel systems feature space- and speed- efficient representations of data. Primarily, they exploit tagged pointers instead of tagged data (as described e.g. in <ref> [Gud93] </ref>). Both systems exploit threaded code made possible by the GNU C compiler [Sta96], which reduces the overhead of emulation by up to 50% [Sch97a].
Reference: [Hen97] <author> Martin Henz. </author> <title> Objects in Oz. </title> <type> Doctoral dissertation, </type> <institution> Technische Fakultat der Universitat des Saarlandes, Universitat des Saarlandes, 66041 Saarbrucken, Germany, </institution> <month> May </month> <year> 1997. </year> <month> 17 </month>
Reference-contexts: The speed of the sequential system is comparable to "state-of-the-art" implementations of Prolog like SICStus. Detailed analysis and evaluation of optimizations can be found in <ref> [Meh97, Sch97a, Hen97] </ref>. The parallel system is optimized on its own. Optimizations serve for better sequential (i.e. on a single worker) speed and/or help to obtain better parallel speedups. The most essential one among the first group is the locking scheme that does not consume additional memory.
Reference: [HLL + 95] <author> Mark D. Hill, James R. Larus, Alvin R. Lebeck, Madhusudhan Talluri, and David A. Wood. </author> <title> Wisconsin Architectural Research Tool Set. </title> <institution> Computer Science Department, University of Wisconsin-Madison, </institution> <address> 1210 West Dayton Street, Madison, WI 53706, </address> <month> May 4 </month> <year> 1995. </year>
Reference-contexts: In the future I plan the implementation of a parallel garbage collector, and a complete evaluation of the system simultaneously with its profiling and further optimizations. Profiling is performed using both standard profiling techniques (like GNU gprof), as well as memory simulators like SimICS and WARTS <ref> [MW95, HLL + 95] </ref>. 11 Acknowledgments I am thankful to all members of Programming Systems Lab at the University of Saarland, Germany for fruitful discussions during my work on the parallel system and this presentation of it.
Reference: [HW95] <author> M. Henz and J. Wurtz. </author> <title> Using Oz for college time tabling. </title> <booktitle> In International Conference on the Practice and Theory of Automated Time Tabling, </booktitle> <address> Edinburgh, Scotland, </address> <month> August/September </month> <year> 1995. </year>
Reference-contexts: PAMOz is implemented in the parallel Oz system [Pop97] with the goal to achieve parallel speedups, compared to the existing sequential implementation of Oz [OzS]. Parallelizing Oz is promising because: * Oz is convenient and efficient programming language for concurrent programming (e.g. modelling multi-agent systems) and constraint solving <ref> [HW95, Wur96b, Wur96a] </ref>. * There is an efficient sequential implementation of Oz. The parallel system is derived from it and preserves its optimizations. 1 * A parallel implementation of Oz is arguably less complex than implementations of similar concurrent constraint languages like AKL [JH94].
Reference: [JH94] <author> Sverker Janson and Seif Haridi. </author> <title> An introduction to AKL, a multi-paradigm programming language. </title> <editor> In B. Mayoh, E. Tyugu, and J. Penjaam, editors, </editor> <booktitle> Constraint Programming: Proceedings 1993 NATO ASI Parnu, Estonia, NATO Advanced Science Institute Series, </booktitle> <pages> pages 411-443. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: The parallel system is derived from it and preserves its optimizations. 1 * A parallel implementation of Oz is arguably less complex than implementations of similar concurrent constraint languages like AKL <ref> [JH94] </ref>. Oz [Smo95a, Smo95b] is a concurrent constraint (henceforth cc, see [SR90]) programming language with state. Computation in Oz is organized into sequential threads. Threads are created explicitly. Oz provides for convenient functional and object-oriented programming. <p> Authors motivate this solution by measurements saying that goals block rather seldom (which is also true for Oz). However, the impact of contention on a shared global hook table is not measured. AKL/Penny [MA95]. AKL (Agents Kernel Language <ref> [JH94] </ref>) is a concurrent constraint programming language with fine-grain implicit concurrency. Penny exploits a store model and compilation techniques similar to (P)AMOz. Since AKL does not contain a sub-language without constraint solving facilities, the Penny abstract machine implements the whole language. <p> PAMOz models an implementation of a subset of Oz without constraint solving facilities. PAMOz is derived from AMOz a sequential abstract machine for Oz, which, in turn, has its origins in works on implementations of Prolog [AK91], concurrent constraint languages <ref> [JH94] </ref>, and functional programming languages [PJ87]. It turns out that PAMOz can be derived from a sequential abstract machine like AMOz only with a few changes. The first one is the implementation of primitives dealing with stateful data structures variables and cells. Accessing stateless data is not changed.
Reference: [Lam79] <author> Leslie Lamport. </author> <title> How to make a multiprocessor that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):690-691, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: The structure of procedures is considered in Section 5. The blockedThreads substructure holds a list of threads; its purpose is discussed in Section 6. PAMOz assumes that an underlying SMP computer is sequentially consistent. That is <ref> [Lam79] </ref>, "the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program" 3 .
Reference: [LMT95] <author> J.S. Larson, B.C. Massey, and E. Tick. </author> <title> Super Monaco: Its portable and efficient parallel runtime system. </title> <editor> In Seif Haridi, Khayri Ali, and Peter Magnusson, editors, </editor> <booktitle> Proceedings of the First International EURO-PAR Conference, number 966 in Lecture Notes in Computer Science, </booktitle> <pages> pages 527-538, </pages> <address> Stockholm, Sweden, </address> <month> August 29-31 </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: Compared to Oz variables and cells, Oz values are stateless and accessed as in a sequential 3 system. Correctness of the bind and block operations on variables is guaranteed by serializing them for each variable. This is achieved by means of so-called "spin locks", known from <ref> [Cra88, LMT95, MA95] </ref>. A spin lock transforms temporarily the variable object into the self-reference object. The effect of the lock is that the original object becomes inaccessible to other thread (s): a worker executing it falls into an endless loop until the object is unlocked. <p> Synchronizing between executed in parallel activ 1 While, of course, constraint systems and synchronized entities are in general different. 4 ities has been added to the original sequential system through a special construct, instead of re-implementing basic primitives in PAMOz. Another implementation of KL1 the Super Monaco system <ref> [LMT95] </ref> is also a native-code system, which was specially designed for parallel execution. AKL is a fine-grained concurrent constraint programming language, suitable for both concurrent programming and constraint solving. Its parallel implementation Penny [MA95] constitutes a major redesign of the original sequential, emulation-based implementation of AKL. <p> Methods of a generic object are applied whenever a variable is bound or a concurrent activity blocks on it. The generic objects mechanism allows to preserve the sequential core unchanged at the expense of an additional object type. KL1/Super Monaco <ref> [LMT95] </ref>. Super Monaco is also a native code system. The native code is derived by macro-expansion from the intermediate code. Native code calls functions from a run-time library with implementations of complex operations like memory management and unification. <p> The native code is derived by macro-expansion from the intermediate code. Native code calls functions from a run-time library with implementations of complex operations like memory management and unification. Operations crucial for parallel execution are encapsulated in the run-time library; their implementations are not described in <ref> [LMT95] </ref>. Variable objects in the system do not contain references to goals blocked on them; instead, suspensions are accessed through a global "hook" table. Authors motivate this solution by measurements saying that goals block rather seldom (which is also true for Oz).
Reference: [MA95] <author> Johan Montelius and Khayri A. M. Ali. </author> <title> An And/Or-parallel implementation of AKL. </title> <journal> New Generation Computing, </journal> <volume> 13(4), </volume> <month> December </month> <year> 1995. </year>
Reference-contexts: Compared to Oz variables and cells, Oz values are stateless and accessed as in a sequential 3 system. Correctness of the bind and block operations on variables is guaranteed by serializing them for each variable. This is achieved by means of so-called "spin locks", known from <ref> [Cra88, LMT95, MA95] </ref>. A spin lock transforms temporarily the variable object into the self-reference object. The effect of the lock is that the original object becomes inaccessible to other thread (s): a worker executing it falls into an endless loop until the object is unlocked. <p> Extending PAMOz for constraint solving. PAMOz can be extended nearly conservatively for full Oz. This proceeds as follows: first, one adds unification like it is done in <ref> [MA95] </ref>. Second, PAMOz is extended for first-class spaces through a dedicated interface, and finally it is extended for other constraint systems like finite domains, sets, etc. by means of a parallel implementation of the constraint programming interface (Cpi) [MW97]. PAMOz and the parallel Oz system. <p> Another implementation of KL1 the Super Monaco system [LMT95] is also a native-code system, which was specially designed for parallel execution. AKL is a fine-grained concurrent constraint programming language, suitable for both concurrent programming and constraint solving. Its parallel implementation Penny <ref> [MA95] </ref> constitutes a major redesign of the original sequential, emulation-based implementation of AKL. The abstract machine for Penny deals with full AKL; there are no obvious components dealing with concurrent programming and constraint solving. <p> Authors motivate this solution by measurements saying that goals block rather seldom (which is also true for Oz). However, the impact of contention on a shared global hook table is not measured. AKL/Penny <ref> [MA95] </ref>. AKL (Agents Kernel Language [JH94]) is a concurrent constraint programming language with fine-grain implicit concurrency. Penny exploits a store model and compilation techniques similar to (P)AMOz. Since AKL does not contain a sub-language without constraint solving facilities, the Penny abstract machine implements the whole language.
Reference: [Meh97] <author> Michael Mehl. </author> <title> The Architecture and Implementation of an Abstract Machine for Oz. </title> <type> PhD thesis, </type> <institution> Technische Fakultat der Universitat des Saarlandes, </institution> <year> 1997. </year> <note> In preparation (preliminary title). </note>
Reference-contexts: The speed of the sequential system is comparable to "state-of-the-art" implementations of Prolog like SICStus. Detailed analysis and evaluation of optimizations can be found in <ref> [Meh97, Sch97a, Hen97] </ref>. The parallel system is optimized on its own. Optimizations serve for better sequential (i.e. on a single worker) speed and/or help to obtain better parallel speedups. The most essential one among the first group is the locking scheme that does not consume additional memory.
Reference: [ML92a] <author> Evangelos P. Markatos and Thomas J. LeBlanc. </author> <title> Load balancing vs. locality management in shared-memory multiprocessoss. </title> <booktitle> In 1992 International Conference on Parallel Processing, </booktitle> <volume> volume I, </volume> <pages> pages 258-267, </pages> <address> St. Charles, Ill., </address> <month> August </month> <year> 1992. </year>
Reference-contexts: A naive implementation of the pool contains a queue. A more elaborated one could try e.g. to avoid moving threads between workers (while preserving fairness), if it would help to improve the performance of the memory subsystem of the computer (see e.g. <ref> [ML92a, ML92b] </ref>). 4 Data Representation The PAMOz data representation model is a specialization of the Oz storage model.
Reference: [ML92b] <author> Evangelos P. Markatos and Thomas J. LeBlanc. </author> <title> Using processor affinity on loop scheduling on shared-memory multiprocessors. </title> <type> Technical Report 410, </type> <institution> The University of Rochester, Computer Science Department, Rochester, </institution> <address> New York 14627, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: A naive implementation of the pool contains a queue. A more elaborated one could try e.g. to avoid moving threads between workers (while preserving fairness), if it would help to improve the performance of the memory subsystem of the computer (see e.g. <ref> [ML92a, ML92b] </ref>). 4 Data Representation The PAMOz data representation model is a specialization of the Oz storage model.
Reference: [MM97] <author> Tobias Muller and Martin Muller. </author> <title> Finite set constraints in Oz, </title> <note> 1997. To appear at WLP'97. </note>
Reference-contexts: In problem solving, a next node to be explored in a search tree is chosen by a sequential algorithm too. Such an algorithm consequently collects information about the current node, applies a heuristic to that information, and finally decides which node to take as a next one <ref> [Smo95a, MPSW94, MM97] </ref>. On the contrary, implicit concurrency in concurrent constraint languages like AKL makes it difficult to encode sequential algorithms. In general, implicit concurrency tends to be fine-grained.
Reference: [Mon97] <author> Johan Montelius. </author> <title> Exploiting Fine-grain Parallelism in Concurrent Constraint Languages. </title> <type> Dissertation, </type> <institution> SICS - Swedish Institute of Computer Science, and Uppsala University, SICS, </institution> <address> Box 1263, S-164 28 Kista, Sweden, </address> <year> 1997. </year> <note> Uppsala Theses in Computing Science 28, and SICS Dissertation Series 25. </note>
Reference-contexts: PAMOz unification exploits a different scheme for keeping track of rational (cyclic) trees. Another point is that the variable-variable unification may not neither produce endless reference chains nor allow workers to deadlock. Techniques used in PAMOz are similar to those described in e.g. <ref> [Mon97] </ref>. The first-class spaces and general conditionals are implemented on the top of the PAMOz local computation spaces. The PAMOz implementation of the Oz store together with the threads' management routines can be seen as a primitive version of computation spaces. <p> I believe that the most effective optimization among those that serve for better speedups is the per-worker memory management scheme, as implemented in <ref> [Mon97] </ref>, and to some extent in [FCRN94]. Each worker has a local memory pool that is used to allocate locally created store objects. This eliminates the contention on memory manager that takes place in the case of a shared memory pool.
Reference: [MPSW94] <author> Tobias Muller, Konstantin Popow, Christian Schulte, and Jorg Wurtz. </author> <title> Constraint programming in Oz. DFKI Oz documentation series, </title> <booktitle> DFKI, Stuhlsatzenhausweg 3, D-66123 Saarbrucken, </booktitle> <address> Germany, </address> <year> 1994. </year>
Reference-contexts: In problem solving, a next node to be explored in a search tree is chosen by a sequential algorithm too. Such an algorithm consequently collects information about the current node, applies a heuristic to that information, and finally decides which node to take as a next one <ref> [Smo95a, MPSW94, MM97] </ref>. On the contrary, implicit concurrency in concurrent constraint languages like AKL makes it difficult to encode sequential algorithms. In general, implicit concurrency tends to be fine-grained.
Reference: [MSS95] <author> Michael Mehl, Ralf Scheidhauer, and Christian Schulte. </author> <title> An abstract machine for Oz. </title> <editor> In Manuel Hermenegildo and S. Doaitse Swierstra, editors, </editor> <booktitle> Programming Languages: Implementations, Logics and Programs, 7 th International Symposium, PLILP'95, volume 982 of Lecture Notes in Computer Science, </booktitle> <pages> pages 151-168, </pages> <address> Utrecht, The Netherlands, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: PAMOz essentials. PAMOz is targeted for shared-memory multiprocessor (SMP in the 2 following) computers. The Oz computation model is mapped naturally on SMP computers: Oz threads are executed by working in parallel processors, and the shared Oz store lies in the computer's shared memory. PAMOz is derived from AMOz <ref> [MSS95] </ref>, an abstract machine for the sequential implementation of Oz [OzS]. Both abstract machines are emulator-based, as opposed to native-code compilation systems. <p> on SPARC multiprocessors running in the so-called "total store order" mode, which relaxes the order constraints in the case of a write followed by a read to a different location [SPA92]. 9 A straightforward encoding of the bind operation (see the code on Figure 4) is sufficient for sequential AMOz <ref> [MSS95] </ref>, but needs improvement when put into a parallel system. This is illustrated on Figure 4. There, the first thread binds the variable Y (at t 3 ) between checking the variable (at t 2 ) and binding it (at t 4 ) by the second thread. <p> Oz unification and general conditional can be seen as constructs orthogonal to binding and matching conditional. The AMOz unification algorithm is described in <ref> [MSS95] </ref>. PAMOz unification exploits a different scheme for keeping track of rational (cyclic) trees. Another point is that the variable-variable unification may not neither produce endless reference chains nor allow workers to deadlock. Techniques used in PAMOz are similar to those described in e.g. [Mon97]. <p> This eliminates the contention on memory manager that takes place in the case of a shared memory pool. Apparently, this helps also to reduce the so-called false sharing of cache lines [TLH94] 4 . 9 Related Work Oz/AMOz <ref> [MSS95] </ref>. The most direct sibling for PAMOz is the sequential abstract machine for Oz. Both use similar data representation schemes and ideas for translating and executing (P)AMOz code.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: The matching procedure is similar to e.g. the SML's one <ref> [MTH90] </ref>. Records match if they have the same label and the same components' names. Variables y from a pattern have the scope of E, and are bound to corresponding components of a record being matched.
Reference: [MW95] <author> Peter Magnusson and Bengt Werner. </author> <title> Efficient memory simulation in SimICS. </title> <booktitle> In Proceedings of the 28 th Annual Simulation Symposium, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: In the future I plan the implementation of a parallel garbage collector, and a complete evaluation of the system simultaneously with its profiling and further optimizations. Profiling is performed using both standard profiling techniques (like GNU gprof), as well as memory simulators like SimICS and WARTS <ref> [MW95, HLL + 95] </ref>. 11 Acknowledgments I am thankful to all members of Programming Systems Lab at the University of Saarland, Germany for fruitful discussions during my work on the parallel system and this presentation of it.
Reference: [MW97] <author> Tobias Muller and Jorg Wurtz. </author> <title> Extending a concurrent constraint language by propagators. </title> <booktitle> In International Logic Programming Symposium, </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Second, PAMOz is extended for first-class spaces through a dedicated interface, and finally it is extended for other constraint systems like finite domains, sets, etc. by means of a parallel implementation of the constraint programming interface (Cpi) <ref> [MW97] </ref>. PAMOz and the parallel Oz system. PAMOz is implemented in the parallel Oz system [Pop97]. The parallel implementation of Oz is concerned with the full language except (by now) its finite domains and sets constraint systems. <p> In this case there are two consequent reads followed by two consequent stores, so both cell exchanges return the same 12 values, and the first value stored just disappears. 7 Towards PAMOz for Full Oz Full Oz is characterized by its constraint solving facilities <ref> [SSW94, MW97] </ref>: * There is unification known from Prolog, and the matching conditional is extended to conditionals if then E else F fi, where is a constraint which needs to be entailed by the constraint store when taking the "then" branch. * It offers a control mechanism suitable for programming search <p> If the space fails, then the constraint is disentailed, and the "else" expression is choosen. When a thread blocks on a space, then there is not yet enough information to determine entailment, the the conditional blocks. PAMOz for full Oz can be extended for the constraint programming interface (Cpi) <ref> [MW97] </ref>. Cpi is an interface between an abstract machine for Oz and propagators written in C++ which are used to express non-trivial constraints. Propagators are sequential programs that try to amplify information in the store.
Reference: [OzS] <institution> The Oz 2.0 programming system. </institution> <note> Check http://www.ps.uni-sb.de/oz2. </note>
Reference-contexts: This paper is dedicated to motivating it, explaining it, and sketching both its usage in the parallel Oz system and its extensions. Parallelizing Oz. PAMOz is implemented in the parallel Oz system [Pop97] with the goal to achieve parallel speedups, compared to the existing sequential implementation of Oz <ref> [OzS] </ref>. Parallelizing Oz is promising because: * Oz is convenient and efficient programming language for concurrent programming (e.g. modelling multi-agent systems) and constraint solving [HW95, Wur96b, Wur96a]. * There is an efficient sequential implementation of Oz. <p> In general, implicit concurrency tends to be fine-grained. This has also performance disadvantages: as the amount of concurrency increases, lower parallel speedups can be obtained because of the scheduling overhead. The parallel Oz system is derived from the sequential one <ref> [OzS] </ref>. The parallel system inherits optimizations of the sequential one. The parallel system running on a single processor approaches the speed of the sequential system: currently it is about 70% as fast, but evaluating and optimizing it is not yet completed. The Oz sub-language for PAMOz. <p> The Oz computation model is mapped naturally on SMP computers: Oz threads are executed by working in parallel processors, and the shared Oz store lies in the computer's shared memory. PAMOz is derived from AMOz [MSS95], an abstract machine for the sequential implementation of Oz <ref> [OzS] </ref>. Both abstract machines are emulator-based, as opposed to native-code compilation systems. They inherit ideas for data representation and code generation from the WAM [AK91], and the representation scheme for first-class procedures and compilation of pattern matching from functional languages [PJ87]. PAMOz executes Oz threads in parallel. <p> Note that after the modification of the Cpi implementation the propagators originally written for the sequential Oz system are reused in the parallel one. 8 Parallel Oz Implementation PAMOz has been implemented in the parallel Oz system [Pop97]. The origin of this implementation is the (sequential) DFKI Oz System <ref> [OzS] </ref>. The emulator which is implemented in C++ has been converted to the parallel one, while the Oz Compiler remained unchanged. The parallel system runs currently on SPARC multiprocessors under Solaris 5.*.
Reference: [PJ87] <editor> Simon L. Peyton-Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: Both abstract machines are emulator-based, as opposed to native-code compilation systems. They inherit ideas for data representation and code generation from the WAM [AK91], and the representation scheme for first-class procedures and compilation of pattern matching from functional languages <ref> [PJ87] </ref>. PAMOz executes Oz threads in parallel. Threads are executed by running parallel workers. Workers are the only active entities in PAMOz. Runnable threads are taken from the thread pool which is shared among workers. The thread pool also implements a scheduling strategy, for instance - FIFO. <p> PAMOz models an implementation of a subset of Oz without constraint solving facilities. PAMOz is derived from AMOz a sequential abstract machine for Oz, which, in turn, has its origins in works on implementations of Prolog [AK91], concurrent constraint languages [JH94], and functional programming languages <ref> [PJ87] </ref>. It turns out that PAMOz can be derived from a sequential abstract machine like AMOz only with a few changes. The first one is the implementation of primitives dealing with stateful data structures variables and cells. Accessing stateless data is not changed.
Reference: [Pop97] <author> Konstantin Popov. </author> <title> Exploiting Coarse-grain Concurrency in Constraint-Based Programming Languages. </title> <type> Doctoral dissertation, </type> <institution> Technische Fakultat der Universita des Saarlandes, Universitat des Saarlandes, 66041 Saarbrucken, Germany, </institution> <year> 1997. </year> <note> In Preparation (preliminary title). </note>
Reference-contexts: 1 Introduction PAMOz (Parallel Abstract Machine for Oz) is an abstract machine for a parallel implementation of Oz. This paper is dedicated to motivating it, explaining it, and sketching both its usage in the parallel Oz system and its extensions. Parallelizing Oz. PAMOz is implemented in the parallel Oz system <ref> [Pop97] </ref> with the goal to achieve parallel speedups, compared to the existing sequential implementation of Oz [OzS]. <p> PAMOz and the parallel Oz system. PAMOz is implemented in the parallel Oz system <ref> [Pop97] </ref>. The parallel implementation of Oz is concerned with the full language except (by now) its finite domains and sets constraint systems. The main implementation detail is that methods of PAMOz abstract objects whose implementation are not considered here are atomic. <p> Note that after the modification of the Cpi implementation the propagators originally written for the sequential Oz system are reused in the parallel one. 8 Parallel Oz Implementation PAMOz has been implemented in the parallel Oz system <ref> [Pop97] </ref>. The origin of this implementation is the (sequential) DFKI Oz System [OzS]. The emulator which is implemented in C++ has been converted to the parallel one, while the Oz Compiler remained unchanged. The parallel system runs currently on SPARC multiprocessors under Solaris 5.*.
Reference: [Sch97a] <author> Ralf Scheidhauer. </author> <title> Effiziente Implementierung von nebenlaufigem Constraint-Programmieren mit hoheren Prozeduren. </title> <type> Doctoral dissertation, </type> <institution> DFKI GmbH, Stuhlsatzenhausweg 3, 66123 Saarbrucken, Germany, </institution> <year> 1997. </year> <note> In german. In Preparation. </note>
Reference-contexts: Primarily, they exploit tagged pointers instead of tagged data (as described e.g. in [Gud93]). Both systems exploit threaded code made possible by the GNU C compiler [Sta96], which reduces the overhead of emulation by up to 50% <ref> [Sch97a] </ref>. Oz object-oriented capabilities are supported directly by the emulator: method applications, first-class methods and attribute accesses are as fast as procedure applications and accessing record components. The speed of the sequential system is comparable to "state-of-the-art" implementations of Prolog like SICStus. <p> The speed of the sequential system is comparable to "state-of-the-art" implementations of Prolog like SICStus. Detailed analysis and evaluation of optimizations can be found in <ref> [Meh97, Sch97a, Hen97] </ref>. The parallel system is optimized on its own. Optimizations serve for better sequential (i.e. on a single worker) speed and/or help to obtain better parallel speedups. The most essential one among the first group is the locking scheme that does not consume additional memory.
Reference: [Sch97b] <author> Christian Schulte. </author> <title> Oz Explorer: A visual constraint programming tool. </title> <editor> In Lee Naish, editor, </editor> <booktitle> Proceedings of the 14 th International Conference on Logic Programming, </booktitle> <address> Leuven, Belgium, 8-11July 1997. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Computation in Oz is organized into sequential threads. Threads are created explicitly. Oz provides for convenient functional and object-oriented programming. It provides also for constraint solving based on its constraint systems (rational tree, finite domains and finite sets) and innovative control facilities as first-class computation spaces <ref> [Sch97b, SS94] </ref>. Concurrent threads and sequential composition within threads in Oz allow to exploit concurrency where it is necessary and avoid it where it is not desirable [Smo95a]. This makes it easy to model, for instance, a multi-agent system whose agents' behaviors are specified by sequential algorithms.
Reference: [Sch97c] <author> Christian Schulte. </author> <title> Programming constraint inference engines. </title> <editor> In Gert Smolka, editor, </editor> <booktitle> Proceedings of the Third International Conference on Principles and Practice of Constraint Programming (CP'97), </booktitle> <address> Schloss Hagenberg, Linz, Austria, </address> <month> October </month> <year> 1997. </year> <note> To Appear. </note>
Reference-contexts: is unification known from Prolog, and the matching conditional is extended to conditionals if then E else F fi, where is a constraint which needs to be entailed by the constraint store when taking the "then" branch. * It offers a control mechanism suitable for programming search first-class computation spaces <ref> [SSW94, Sch97c] </ref>. A computation space encapsulate threads and constraints produced by them. Spaces allow to explicitly exploit search alternatives.
Reference: [Smo95a] <author> Gert Smolka. </author> <title> An Oz primer. DFKI Oz documentation series, </title> <booktitle> DFKI, Stuhlsatzenhausweg 3, D-66123 Saarbrucken, </booktitle> <address> Germany, </address> <year> 1995. </year>
Reference-contexts: The parallel system is derived from it and preserves its optimizations. 1 * A parallel implementation of Oz is arguably less complex than implementations of similar concurrent constraint languages like AKL [JH94]. Oz <ref> [Smo95a, Smo95b] </ref> is a concurrent constraint (henceforth cc, see [SR90]) programming language with state. Computation in Oz is organized into sequential threads. Threads are created explicitly. Oz provides for convenient functional and object-oriented programming. <p> Concurrent threads and sequential composition within threads in Oz allow to exploit concurrency where it is necessary and avoid it where it is not desirable <ref> [Smo95a] </ref>. This makes it easy to model, for instance, a multi-agent system whose agents' behaviors are specified by sequential algorithms. In problem solving, a next node to be explored in a search tree is chosen by a sequential algorithm too. <p> In problem solving, a next node to be explored in a search tree is chosen by a sequential algorithm too. Such an algorithm consequently collects information about the current node, applies a heuristic to that information, and finally decides which node to take as a next one <ref> [Smo95a, MPSW94, MM97] </ref>. On the contrary, implicit concurrency in concurrent constraint languages like AKL makes it difficult to encode sequential algorithms. In general, implicit concurrency tends to be fine-grained.
Reference: [Smo95b] <author> Gert Smolka. </author> <title> The Oz programming model. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Current Trends in Computer Science, volume 1000 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1995. </year>
Reference-contexts: The parallel system is derived from it and preserves its optimizations. 1 * A parallel implementation of Oz is arguably less complex than implementations of similar concurrent constraint languages like AKL [JH94]. Oz <ref> [Smo95a, Smo95b] </ref> is a concurrent constraint (henceforth cc, see [SR90]) programming language with state. Computation in Oz is organized into sequential threads. Threads are created explicitly. Oz provides for convenient functional and object-oriented programming.
Reference: [SPA92] <author> SPARC International, Inc. </author> <title> The SPARC Architecture Manual. Version 8. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ 07632, </address> <year> 1992. </year> <month> 18 </month>
Reference-contexts: The real parallel Oz system runs on SPARC multiprocessors running in the so-called "total store order" mode, which relaxes the order constraints in the case of a write followed by a read to a different location <ref> [SPA92] </ref>. 9 A straightforward encoding of the bind operation (see the code on Figure 4) is sufficient for sequential AMOz [MSS95], but needs improvement when put into a parallel system. This is illustrated on Figure 4.
Reference: [SR90] <author> V.A. Saraswat and M. Rinard. </author> <title> Concurrent constraint programming. </title> <booktitle> In Proceedings of the 7 th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The parallel system is derived from it and preserves its optimizations. 1 * A parallel implementation of Oz is arguably less complex than implementations of similar concurrent constraint languages like AKL [JH94]. Oz [Smo95a, Smo95b] is a concurrent constraint (henceforth cc, see <ref> [SR90] </ref>) programming language with state. Computation in Oz is organized into sequential threads. Threads are created explicitly. Oz provides for convenient functional and object-oriented programming.
Reference: [SS94] <author> Christian Schulte and Gert Smolka. </author> <title> Encapsulated search in higher-order concurrent constraint programming. </title> <editor> In Maurice Bruynooghe, editor, </editor> <booktitle> Logic Programming: Proceedings of the 1994 International Symposium, </booktitle> <pages> pages 505-520, </pages> <address> Ithaca, New York, USA, </address> <month> November </month> <year> 1994. </year> <pages> MIT-Press. </pages>
Reference-contexts: Computation in Oz is organized into sequential threads. Threads are created explicitly. Oz provides for convenient functional and object-oriented programming. It provides also for constraint solving based on its constraint systems (rational tree, finite domains and finite sets) and innovative control facilities as first-class computation spaces <ref> [Sch97b, SS94] </ref>. Concurrent threads and sequential composition within threads in Oz allow to exploit concurrency where it is necessary and avoid it where it is not desirable [Smo95a]. This makes it easy to model, for instance, a multi-agent system whose agents' behaviors are specified by sequential algorithms.
Reference: [SSW94] <author> Christian Schulte, Gert Smolka, and Jorg Wurtz. </author> <title> Encapsulated search and constraint programming in Oz. </title> <editor> In A.H. Borning, editor, </editor> <booktitle> Second Workshop on Principles and Practice of Constraint Programming, volume 874 of Lecture Notes in Computer Science, </booktitle> <pages> pages 134-150, </pages> <address> Orcas Island, Washington, USA, 2-4 May 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In this case there are two consequent reads followed by two consequent stores, so both cell exchanges return the same 12 values, and the first value stored just disappears. 7 Towards PAMOz for Full Oz Full Oz is characterized by its constraint solving facilities <ref> [SSW94, MW97] </ref>: * There is unification known from Prolog, and the matching conditional is extended to conditionals if then E else F fi, where is a constraint which needs to be entailed by the constraint store when taking the "then" branch. * It offers a control mechanism suitable for programming search <p> is unification known from Prolog, and the matching conditional is extended to conditionals if then E else F fi, where is a constraint which needs to be entailed by the constraint store when taking the "then" branch. * It offers a control mechanism suitable for programming search first-class computation spaces <ref> [SSW94, Sch97c] </ref>. A computation space encapsulate threads and constraints produced by them. Spaces allow to explicitly exploit search alternatives.
Reference: [Sta96] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC. Free Software Foundation, </title> <publisher> Inc., </publisher> <month> June 27 </month> <year> 1996. </year>
Reference-contexts: Both sequential and parallel systems feature space- and speed- efficient representations of data. Primarily, they exploit tagged pointers instead of tagged data (as described e.g. in [Gud93]). Both systems exploit threaded code made possible by the GNU C compiler <ref> [Sta96] </ref>, which reduces the overhead of emulation by up to 50% [Sch97a]. Oz object-oriented capabilities are supported directly by the emulator: method applications, first-class methods and attribute accesses are as fast as procedure applications and accessing record components.
Reference: [TLH94] <author> Josep Torrellas, Monica S. Lam, and John L. Hennessy. </author> <title> False sharing and spatial locality in multiprocessor caches. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 43(6) </volume> <pages> 651-663, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Each worker has a local memory pool that is used to allocate locally created store objects. This eliminates the contention on memory manager that takes place in the case of a shared memory pool. Apparently, this helps also to reduce the so-called false sharing of cache lines <ref> [TLH94] </ref> 4 . 9 Related Work Oz/AMOz [MSS95]. The most direct sibling for PAMOz is the sequential abstract machine for Oz. Both use similar data representation schemes and ideas for translating and executing (P)AMOz code. <p> As a result, two processors interactively invalidate that cache line. Eliminating false sharing could result in 10% speedups <ref> [TLH94] </ref>. 15 KL1/KLIC [FCRN94]. KL1 is a fine-grain concurrent programming language with logic variables. The KLIC system exploits annotations to control the amount of parallelism. KLIC is a native code system: KL1 programs are translated into C. The system contains both local and shared heaps.
Reference: [Wur96a] <author> Jorg Wurtz. </author> <title> Constraint-based scheduling in Oz. </title> <booktitle> In Proceedings of Symposium on Operations Research, </booktitle> <pages> pages 218-223, </pages> <address> Braun-schweig, Germany, September 1996. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: PAMOz is implemented in the parallel Oz system [Pop97] with the goal to achieve parallel speedups, compared to the existing sequential implementation of Oz [OzS]. Parallelizing Oz is promising because: * Oz is convenient and efficient programming language for concurrent programming (e.g. modelling multi-agent systems) and constraint solving <ref> [HW95, Wur96b, Wur96a] </ref>. * There is an efficient sequential implementation of Oz. The parallel system is derived from it and preserves its optimizations. 1 * A parallel implementation of Oz is arguably less complex than implementations of similar concurrent constraint languages like AKL [JH94].
Reference: [Wur96b] <author> Jorg Wurtz. </author> <title> Oz Scheduler: A workbench for scheduling problems. </title> <booktitle> In Proceedings of the 8th IEEE International Conference on Tools with Artificial Intelligence, </booktitle> <pages> pages 132-139, </pages> <address> Toulouse, France, November16-19 1996. </address> <publisher> IEEE Computer Society Press. </publisher> <pages> 19 </pages>
Reference-contexts: PAMOz is implemented in the parallel Oz system [Pop97] with the goal to achieve parallel speedups, compared to the existing sequential implementation of Oz [OzS]. Parallelizing Oz is promising because: * Oz is convenient and efficient programming language for concurrent programming (e.g. modelling multi-agent systems) and constraint solving <ref> [HW95, Wur96b, Wur96a] </ref>. * There is an efficient sequential implementation of Oz. The parallel system is derived from it and preserves its optimizations. 1 * A parallel implementation of Oz is arguably less complex than implementations of similar concurrent constraint languages like AKL [JH94].
References-found: 37

