URL: http://www.cs.wisc.edu/~condon/papers/condonlewandowski96.ps
Refering-URL: http://www.cs.wisc.edu/~condon/condon.html
Root-URL: 
Title: Experiments with Parallel Graph Coloring Heuristics and Applications of Graph Coloring  
Author: GARY LEWANDOWSKI AND ANNE CONDON 
Keyword: Key words and phrases. parallel, graph coloring, scheduling.  
Web: 68U30,05C15, 05C90, 68R05,68R10.  
Date: November 1994  
Note: DIMACS Series in Discrete Mathematics and Theoretical Computer Science Volume 00, 0000  1991 Mathematics Subject Classification. 90C35; Secondary  Research by both authors was supported by NSF grant number CCR-9257241, and by a grant from the AT&T Foundation. Research by the first author was also supported by NSF grant DCR-9208639 Research on the Connection Machine CM-5 was supported by NSF Institutional Infrastruc ture grant CDA-9024618 and by the Thinking Machines Corporation. c fl0000 American Mathematical Society 0000-0000/00 $1.00 $.25 per page  
Abstract: We introduce a new hybrid graph coloring algorithm, which combines a parallel version of Morgenstern's S-Impasse algorithm [26], with exhaustive search. Our goal is progress towards a coloring heuristic that works well without extensive tuning of algorithm parameters. We also contribute new test data arising in five different application domains, including register allocation and course scheduling. Hybrid was implemented on a Connection Machine CM-5, and tested on the application data as well as several types of randomly generated graphs. The results are compared with results of two simple sequential heuristics, the Saturation algorithm of Brelaz [5] and the Recursive Largest First (RLF) algorithm of Leighton [24], as well as with previous work reported by Morgenstern [26] and John-son et al. [17]. On many random graphs, the performance of Hybrid without tuning of parameters is comparable or better than tuned sequential algorithms; on large random graphs, Hybrid does not come close to the best colorings found by tuned time-intensive algorithms such as XRLF [17] and Morgenstern's tuned S-Impasse [26]. Of the application data, three applications are easily colored even by the simple sequential heuristics; one (the course scheduling data) is optimally colored by Hybrid but not by the simple heuristics, and one appears to be very hard. In several cases, however, we found that finding an optimal coloring is not sufficient to solve the problem at hand, rather colorings satisfying additional restrictions are needed. We find that the course scheduling applications is not well-modeled by random graphs, which suggests that more application data should be collected for testing heuristics and that new random generators are needed to model these problems. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> D. Aldous and U. Vazirani, </author> <title> "Go with the winners" algorithms, </title> <booktitle> Proceedings of the 35th IEEE Symposium on the Foundations of Computer Science, </booktitle> <year> 1994, </year> <pages> 492-501. </pages>
Reference-contexts: They then do an s-chain move as an extra precaution against duplicating the search the sending processor. (Other processors who similarly appear to be following a dead end in their search but do not receive the current solution, do a large s-chain move instead.) Recent results by Aldous and Vazirani <ref> [1] </ref> give theoretical support to the approach of following the current best solution. 2.3. The Parallel Exhaustive Search Algorithm. This algorithm is a straightforward branch-and-bound procedure, as described by Johnson et al. [17]. <p> Further testing is needed to see a more general correlation between the improvement in perfor PARALLEL GRAPH COLORING AND APPLICATIONS 17 mance and the number of processors. Work by Morgenstern [27] and Aldous & Vazirani <ref> [1] </ref> supports our belief that in general, having the processors work in parallel yields better colorings faster than simply using multiple independent runs. 4.3.2. Parallel vs. Sequential Exhaustive Search. We ran several additional experiments to test the parallel exhaustive search algorithm, and concluded that it performs very well.
Reference: 2. <author> Appel, K. I., W. Haken and J. Koch, </author> <title> Every planar map is four colorable, Part I: </title> <journal> Discharging, Illinois Journal of Mathematics, </journal> <volume> 21, </volume> <year> 1977, </year> <pages> 429-490. </pages>
Reference-contexts: Subsequent work on that problem not only spurred the development of graph theory, but ultimately led to the famous four-color theorem of Appel and Haken <ref> [2] </ref>, based on an extensive computer search. Graph coloring has many uses beyond map coloring, and one would expect that computers can be used to solve not just the four-color problem, but general graph coloring problems.
Reference: 3. <author> R. Azencott, </author> <title> Editor, Simulated Annealing: Parallelization Techniques, </title> <address> New York, </address> <publisher> John Wiley and Sons, </publisher> <year> 1992. </year>
Reference-contexts: studies of simulated annealing algorithms for other applications indicate that if the number of processors is small, this is a reasonable approach to parallelizing the S-Impasse algorithm, because the more paths that are explored independently, the smaller the expected time for one to reach a new best coloring. (See Azencott <ref> [3] </ref>, for example.) We later show that this is in fact true for the S-Impasse algorithm on our test data. Another advantage of this parallel approach is that, since the computation of distinct processors is almost completely independent, the amount of interprocessor communication is kept to a minimum.
Reference: 4. <author> B. Bollobas and A. Thomason, </author> <title> Random Graphs of Small Order, </title> <journal> Ann. Discrete Math, </journal> <volume> 28 1985, </volume> <pages> 47-97. </pages>
Reference: 5. <author> D. Brelaz, </author> <title> New methods to color vertices of a graph, </title> <journal> Communications of the ACM, </journal> <volume> 22, </volume> <year> 1979, </year> <pages> 251-256. </pages>
Reference-contexts: There is a fairly extensive body of literature on experimental graph coloring algorithms. These have been tested primarily on random graphs, such as the G n;p graphs mentioned above. One of the simplest coloring algorithms is the Saturation algorithm of Brelaz <ref> [5] </ref>. It is based on the following principle: the vertex which is adjacent to the greatest number of differently-colored neighbors PARALLEL GRAPH COLORING AND APPLICATIONS 3 is colored first, with a new color if necessary.
Reference: 6. <author> Carraghan and Paradalos, </author> <title> An exact algorithm for the maximum clique problem, </title> <journal> Operation Research Letters, </journal> <volume> 9, </volume> <year> 1990, </year> <pages> 375-382. </pages>
Reference-contexts: Register Allocation Graphs. (See Table 2.) The Saturation and RLF algorithms performed just as well as Hybrid on these graphs, and all algorithms halted quickly. We verified that the results were optimal by using dfmax <ref> [6] </ref> to find the largest clique in each of the graphs; these cliques were the same size as the colorings found. Although Hybrid did not prove that it exactly colored the register allocation graphs, it would be easy to add dfmax to the implementation to prove the colorings optimal. 4.2.4.
Reference: 7. <author> G.J. Chaitin and M. Auslander and A.K. Chandra and J. Cocke and M.E. Hopkins and P. Markstein, </author> <title> Register allocation via coloring, </title> <journal> Computer Languages, </journal> <volume> 6, </volume> <year> 1981, </year> <pages> 47-57. </pages>
Reference-contexts: Garey, Johnson and So [11] showed that graph coloring can be used for short circuit testing for printed circuits. Chaitin <ref> [7, 8] </ref> reduced register allocation to graph coloring and used it in a compiler. Poole and Ortega [30] showed how to use graph coloring to decompose matrices used to solve sparse systems of linear equations; the decomposition gives a method for easy parallelization of the solution.
Reference: 8. <author> G.J. Chaitin, </author> <title> Register allocation and spilling via graph coloring, </title> <booktitle> Proceedings of the ACM SIGPLAN 82 Symposium on Compiler Construction, </booktitle> <year> 1982, </year> <pages> 98-105. </pages>
Reference-contexts: Garey, Johnson and So [11] showed that graph coloring can be used for short circuit testing for printed circuits. Chaitin <ref> [7, 8] </ref> reduced register allocation to graph coloring and used it in a compiler. Poole and Ortega [30] showed how to use graph coloring to decompose matrices used to solve sparse systems of linear equations; the decomposition gives a method for easy parallelization of the solution.
Reference: 9. <author> J. Culberson and F. Luo, </author> <title> Exploring the k-colorable landscape with iterated greedy, Cliques, Coloring and Satisfiability: Second DIMACS Implementation Challenge, </title> <editor> David S. Johnson 20 LEWANDOWSKI AND CONDON and Michael A. Trick (eds.), </editor> <booktitle> DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <publisher> American Mathematical Society, </publisher> <year> 1995. </year>
Reference-contexts: The experiments look at graphs of size 300 with k = 20; 26; 28 and of size 1000 with k = 50; 60; 76. The target p is 0:5. The graphs are designated flat n k. See Culberson and Luo <ref> [9] </ref> for more discussion on the construction of these graphs. 3.2. Application Graphs. We have gathered data from several problems commonly referred to as applications of coloring. Our experiments test the saturation and RLF algorithms on these graphs as well as the Hybrid algorithm.
Reference: 10. <author> D. de Werra, </author> <title> An introduction to timetabling, </title> <journal> European Journal of Operations Research, </journal> <volume> 19, </volume> <year> 1985, </year> <pages> 151-162. </pages>
Reference-contexts: It is an abstraction of time-tabling problems, in which lists of courses desired by students are given, and the minimal number of class periods such that all students can take their desired courses must be determined (de Werra <ref> [10] </ref>, Leighton [24], Opsut and Roberts [29]). Garey, Johnson and So [11] showed that graph coloring can be used for short circuit testing for printed circuits. Chaitin [7, 8] reduced register allocation to graph coloring and used it in a compiler.
Reference: 11. <author> M. R. Garey and D. S. Johnson and H. C. </author> <title> So, An application of graph coloring to printed circuit testing, </title> <journal> IEEE Transactions on Circuits and Systems, </journal> <volume> 23, </volume> <year> 1976, </year> <pages> 591-599. </pages>
Reference-contexts: It is an abstraction of time-tabling problems, in which lists of courses desired by students are given, and the minimal number of class periods such that all students can take their desired courses must be determined (de Werra [10], Leighton [24], Opsut and Roberts [29]). Garey, Johnson and So <ref> [11] </ref> showed that graph coloring can be used for short circuit testing for printed circuits. Chaitin [7, 8] reduced register allocation to graph coloring and used it in a compiler.
Reference: 12. <author> J.W. Greene and K. J. Supowit, </author> <title> Simulated annealing without rejected moves, </title> <journal> IEEE Transactions on Computer-aided Design, </journal> <volume> CAD-5, </volume> <month> January </month> <year> 1986, </year> <pages> 221-228. </pages>
Reference: 13. <author> G.R. Grimmet and C.J.H. McDiarmid, </author> <title> On colouring random graphs, </title> <booktitle> Mathematical Proceedings of the Cambridge Philosophical Society, </booktitle> <volume> 77, </volume> <year> 1975, </year> <pages> 313-324. </pages>
Reference-contexts: On the other hand, the results of Grimmet and McDiarmid <ref> [13] </ref> on coloring algorithms for random graphs offer the algorithm designer some reason for optimism. They consider random graphs such as the G n;p graphs, which have n nodes, where each pair is connected with independent probability p.
Reference: 14. <author> F. Glover, </author> <title> Tabu search, part 1, </title> <journal> ORSA Journal on Computing, </journal> <volume> 1, </volume> <year> 1989, </year> <pages> 190-206. </pages>
Reference-contexts: A quite different approach has been taken with iterative improvement algorithms, which include the simulated annealing algorithm of Johnson et al. [17], the Tabu Search algorithm of Glover <ref> [14] </ref> and the S-Impasse algorithm of Morgenstern [26]. Briefly, iterative improvement algorithms differ from successive augmentation algorithms in that the colors of individual nodes may change several times over the course of the algorithm. Of the iterative improvement algorithms, Morgenstern reports the best results for the S-Impasse algorithm.
Reference: 15. <author> M. M. Halldorsson, </author> <title> A still better performance guarantee for approximate graph coloring, </title> <type> DIMACS Technical report 1990, </type> <pages> 91-35. </pages>
Reference-contexts: Lund and Yannakakis [25] proved that for some * &gt; 0, approximating the chromatic number within a factor of n * is NP-hard. The best known approximation algorithm, due to Halldorsson <ref> [15] </ref>, provides an extremely poor performance guarantee of O (n (log log n) 2 =(log n) 3 ) for an n-node graph. (The performance guarantee is the maximum ratio, taken over all inputs, of the number of colors used over the chromatic number).
Reference: 16. <author> D. Hanson, </author> <title> Fast allocation and deallocation of memory based on object lifetimes, Software Practices and Experience, </title> <month> January </month> <year> 1990. </year>
Reference-contexts: The register allocation scheme used by Briggs was based on the arena algorithm for memory allocation of Hanson <ref> [16] </ref>. 3.2.2. Course Scheduling Graphs.
Reference: 17. <author> D. S. Johnson, C. R. Aragon, L. A. McGeoch and C. Schevon, </author> <title> Optimization by simulated annealing: an experimental evaluation; part II, graph coloring and number partitioning, </title> <journal> Operations Research, </journal> <volume> 3, </volume> <year> 1991, </year> <pages> 378-406. </pages>
Reference-contexts: These two algorithms have very efficient implementations, but as we will see, do not produce very good colorings on standard test data. Johnson et al. <ref> [17] </ref> pushed the successive augmentation approach much further with the XRLF algorithm, which is essentially a semi-exhaustive version of Leighton's RLF algorithm, based on ideas of Johri and Matula [18]. <p> A quite different approach has been taken with iterative improvement algorithms, which include the simulated annealing algorithm of Johnson et al. <ref> [17] </ref>, the Tabu Search algorithm of Glover [14] and the S-Impasse algorithm of Morgenstern [26]. Briefly, iterative improvement algorithms differ from successive augmentation algorithms in that the colors of individual nodes may change several times over the course of the algorithm. <p> order to get good results, sequential implementations may take several hours on a standard workstation, even on relatively small graphs of 1,000 nodes or less, and the time to reduce the size of a coloring by 1 increases greatly as better colorings are found (results reported by Johnson et al. <ref> [17] </ref> and Morgenstern [26] are on machines 20-100 times slower than the processors of the CM-5 we used for our experiments). Finally, there is little experimental work on data from real applications of graph coloring. <p> The Parallel Exhaustive Search Algorithm. This algorithm is a straightforward branch-and-bound procedure, as described by Johnson et al. <ref> [17] </ref>. A tree of partial colorings is expanded, using the size of the current best coloring to prune the tree. Each node in the tree represents a partial coloring and its children are all the possible extensions of that coloring obtained by coloring one more node. <p> Geometric Graphs. Geometric random graphs, Rx:y, are formed by randomly placing x vertices in a unit square, then putting edges between any two vertices which are within 0:y of each other. These graphs may model applications 8 LEWANDOWSKI AND CONDON such as assigning cellular phone frequencies <ref> [17] </ref>. The algorithms are tested on eight instances of geometric graphs, of size 125, 250, 500, and 1000, with y parameters of 1 and 5. <p> We also test them on complements of Rx:1 graphs, denoted Rx:1c. (Some of these geometric graphs are actually labeled DSJRx.y, indicating they come from the Johnson et al. <ref> [17] </ref> benchmarks. The Johnson et al. paper referred to these graphs as U n;d graphs, where n is the number of vertices and d is the distance parameter.) 3.1.4. Flat Graphs. These graphs are G n;p;k graphs modified to have the density of a G n;p graph. <p> Still, our results are obtained with no tuning of parameters; this is an important advantage over previous work. Our algorithm performs most poorly on large, randomly generated graphs. For example, using his tuned S-impasse algorithm, Morgenstern [26] obtains better results on large G n;p graphs. Also, Johnson et al. <ref> [17] </ref> obtain better colorings with their XRLF algorithm. <p> For the 500 vertex graphs, DSJR500.1, DSJR500.1c and DSJR500.5, previous results were reported by Johnson et al. <ref> [17] </ref> so we compare our results with theirs on these graphs. The performance of Hybrid was mixed on the 500 vertex graphs. <p> In contrast, the best colorings obtained by the RLF and Saturation algorithms were of size 89 and 88, respectively. Also, Johnson et al. <ref> [17] </ref> reported that the best coloring they obtained was of size 85, using a tuned version of an annealing-type algorithm (the Fixed-K Annealing algorithm) which ran for over 75 hours on a Sequent. <p> In contrast to S-Impasse, the XRLF algorithm runs well on random G n;p graphs, given enough time; for example, an 86-coloring of a G 1000;0:5 graph is found in 68.3 hours <ref> [17] </ref>. (This was on a VAX 750, which is 20-100 times slower than current machines.) In our implementation of XRLF, we use Hybrid as a replacement for the exhaustive search alone at the end of the XRLF algorithm.
Reference: 18. <author> A. Johri and D. W. Matula, </author> <title> Probabilistic bounds and heuristic algorithms for coloring large random graphs, </title> <type> Technical report, </type> <institution> Southern Methodist University, Texas, </institution> <year> 1982. </year>
Reference-contexts: Johnson et al. [17] pushed the successive augmentation approach much further with the XRLF algorithm, which is essentially a semi-exhaustive version of Leighton's RLF algorithm, based on ideas of Johri and Matula <ref> [18] </ref>. The XRLF algorithm finds better colorings than the simpler successive augmentation algorithms on random G n;p graphs, but takes significantly more time and is beaten by the simpler Saturation algorithm on other randomly generated classes of graphs.
Reference: 19. <author> M. Jones and P. Plassman, </author> <title> The efficient parallel iterative solution of large sparse linear systems, Graph Theory and Sparse Matrix Computation, </title> <editor> Alan George, John Gilber, J. Liu, Editors (eds.), </editor> <booktitle> IMA volumes in Mathematics and its Applications, </booktitle> <volume> 56, </volume> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The parallelization does not actually require a true coloring of the graph; it is sufficient to color the vertices so that no positive cycle contains only vertices of the same color. (For more discussion see, for example, Poole and Ortega [30] and Jones and Plassmann <ref> [19] </ref>.) There are many applications of sparse linear systems; our graphs are examples from power systems, of sizes 1993, 1084, 707, and 147. We refer to these graphs as sparse1993, sparse1084, sparse707 and sparse147 respectively. 3.2.6. Final Exam Scheduling.
Reference: 20. <author> R. M. Karp, </author> <title> Reducibility among combinatorial problems, Complexity of computer computations (R.E. </title> <editor> Miller and J.W. Thatcher, eds.), </editor> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1972, </year> <pages> 85-103. </pages>
Reference-contexts: Given the practical importance of the graph coloring problem, it is unfortunate that, in theory at least, the cards are stacked against the designer of graph coloring algorithms. Not only is it NP-complete to determine if a graph can be colored with a given number of colors <ref> [20] </ref>, but it is also hard even to approximate the chromatic number of a graph. Lund and Yannakakis [25] proved that for some * &gt; 0, approximating the chromatic number within a factor of n * is NP-hard.
Reference: 21. <author> A. B. Kempe, </author> <title> On the geographical problem of the four-colors, </title> <journal> American Journal of Mathematics, </journal> <volume> 2, 1879, </volume> <pages> 193-200. </pages>
Reference-contexts: The sets V i have the property that placing set V i into the color class V (i+1)mods maintains a valid coloring. That is, the s-chain "shu*es" the coloring. (This is a generalization of Kempe chains, an idea used by Kempe <ref> [21] </ref> in his flawed proof of the four-color theorem.) A parameter, , is a scaling factor that determines how often the s-chain moves are performed. Morgenstern's version of the algorithm ran for a number of iterations before halting. Our algorithm runs until it has reached its time bound.
Reference: 22. <author> G. Lewandowski. </author> <title> Practical implementations and applications of graph coloring, </title> <type> Ph.D. thesis, </type> <institution> Computer Sciences Department, University of Wisconsin- Madison, </institution> <year> 1994. </year>
Reference-contexts: Unfortunately, assigning students to sections in the best possible way is also difficult, and one approach, minimizing the density of the resulting conflict graph (in the hopes that this will reduce the chromatic number of the conflict graph), is NP-Complete <ref> [22] </ref>. Lewandowski [22] discusses this problem in much greater detail. Here we note that the problem is more involved than simply coloring, but concentrate only on the coloring problem, namely the construction of the timetable after students are assigned to sections of courses. <p> Unfortunately, assigning students to sections in the best possible way is also difficult, and one approach, minimizing the density of the resulting conflict graph (in the hopes that this will reduce the chromatic number of the conflict graph), is NP-Complete <ref> [22] </ref>. Lewandowski [22] discusses this problem in much greater detail. Here we note that the problem is more involved than simply coloring, but concentrate only on the coloring problem, namely the construction of the timetable after students are assigned to sections of courses. <p> For further discussion of the generators and other possible techniques for assigning students to sections, see Lewandowski <ref> [22] </ref>. <p> The largest clique in the model graph is 26 while the school-as graph has a clique of size 18. Further discussion of models for the course scheduling problem can be found in Lewandowski <ref> [22] </ref>. Unlike the 14-colorable school graphs, the model graph and the school graph with sections generated automatically are not easily exactly-colored. The Hybrid algorithm spent around an hour on each graph without finishing its search. 4.2.3. <p> We have already made some progress in the area of course scheduling (see Lewandowski <ref> [22] </ref>), and plan to work on other problems as well in the future. In the future we also plan to add XRLF to our Hybrid, to run in parallel with PARALLEL GRAPH COLORING AND APPLICATIONS 19 S-Impasse and exhaustive search.
Reference: 23. <author> Kiaer, Lynn. </author> <title> Discrete optimization strategies for timetabling, </title> <type> Ph.D. thesis, </type> <institution> Department of Applied Mathematics, Florida Institute of Technology, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Final Exam Scheduling. As with class scheduling, final exam scheduling must avoid scheduling courses taken by the same student simultaneously. Vertices are courses, edges are between courses taken by the same student. We have acquired data from Florida Institute of Technology (provided by Lynn Ki-aer <ref> [23] </ref>) for exam scheduling. <p> Kiaer has constructed heuristics to use the weights of the conflicts to find a 6 coloring with no severe (weight 3) conflicts, 5 medium (weight 2) conflicts and 42 small (weight 1) conflicts <ref> [23] </ref>. 4.2.6. Latin Square Graph. (See Table 2.) All the algorithms performed poorly on this application. The RLF algorithm used at least 146 colors to color this graph. The Saturation algorithm used 132 colors.
Reference: 24. <author> F.T. Leighton, </author> <title> A graph coloring algorithm for large scheduling problems, </title> <journal> Journal of Research of the National Bureau of Standards, </journal> <volume> 84, </volume> <year> 1979, </year> <pages> 489-506. </pages>
Reference-contexts: It is an abstraction of time-tabling problems, in which lists of courses desired by students are given, and the minimal number of class periods such that all students can take their desired courses must be determined (de Werra [10], Leighton <ref> [24] </ref>, Opsut and Roberts [29]). Garey, Johnson and So [11] showed that graph coloring can be used for short circuit testing for printed circuits. Chaitin [7, 8] reduced register allocation to graph coloring and used it in a compiler. <p> Thus, if ever the color of a vertex is forced, that is, there is at most one possible choice from the current set of colors, that vertex is colored first. Another example of such a "successive augmentation" algorithm is the Recursive Largest First (RLF) algorithm, proposed by Leighton <ref> [24] </ref> when studying the exam scheduling problem at Princeton. This algorithm colors the vertices one color class at a time, adding vertices one at a time to the current color class so as to reduce as much as possible the number of edges left in the uncolored subgraph. <p> Test Data Our algorithms have been tested on random graphs, Leighton graphs, register allocation graphs and two graphs constructed from a course scheduling problem. Below we give a brief description of each graph class. 3.1. Random Graphs. 3.1.1. Leighton Graphs. Leighton graphs <ref> [24] </ref> are random graphs with a fixed number of edges and predetermined chromatic number. The graphs are constructed by implanting cliques of sizes ranging from (G) to 2 into the graph.
Reference: 25. <author> C. Lund and M. Yannakakis, </author> <title> On the hardness of approximating minimization problems, </title> <booktitle> Proceedings 25th ACM Symposium on Theory of Computing, </booktitle> <year> 1993, </year> <pages> 286-293. </pages>
Reference-contexts: Not only is it NP-complete to determine if a graph can be colored with a given number of colors [20], but it is also hard even to approximate the chromatic number of a graph. Lund and Yannakakis <ref> [25] </ref> proved that for some * &gt; 0, approximating the chromatic number within a factor of n * is NP-hard.
Reference: 26. <author> C. A. Morgenstern, </author> <title> Algorithms for general graph coloring, </title> <type> Ph.D. thesis, Technical report CS89-16, </type> <institution> Department of Computer Science, University of New Mexico, </institution> <address> Albuquerque, </address> <year> 1989. </year> <title> 27. , Distributed coloration neighborhood search, Cliques, Coloring, and Satisfiability: Second DIMACS Implementation Challenge, </title> <editor> David S. Johnson and Michael A. Trick (eds.), </editor> <booktitle> DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <publisher> American Mathematical Society, </publisher> <year> 1995. </year>
Reference-contexts: A quite different approach has been taken with iterative improvement algorithms, which include the simulated annealing algorithm of Johnson et al. [17], the Tabu Search algorithm of Glover [14] and the S-Impasse algorithm of Morgenstern <ref> [26] </ref>. Briefly, iterative improvement algorithms differ from successive augmentation algorithms in that the colors of individual nodes may change several times over the course of the algorithm. Of the iterative improvement algorithms, Morgenstern reports the best results for the S-Impasse algorithm. <p> good results, sequential implementations may take several hours on a standard workstation, even on relatively small graphs of 1,000 nodes or less, and the time to reduce the size of a coloring by 1 increases greatly as better colorings are found (results reported by Johnson et al. [17] and Morgenstern <ref> [26] </ref> are on machines 20-100 times slower than the processors of the CM-5 we used for our experiments). Finally, there is little experimental work on data from real applications of graph coloring. <p> Our parallel algorithm outperforms the sequential algorithms, both in the quality of the colorings obtained and in the time spent to obtain the colorings, on all but the simplest test graphs, where all algorithms find an optimal coloring very quickly. However, both Morgenstern's tuned sequential implementation of S-Impasse <ref> [26] </ref> and Johnson et al.'s XRLF algorithm find better colorings than our algorithm on large G n;p graphs. (Recall that our tests of Hybrid are untuned.) Our conclusion is that our parallel methods are certainly useful in solving the graph coloring problems, and are a step towards creating a heuristic that <p> A brief concluding summary and directions for future work are presented in Section 5. PARALLEL GRAPH COLORING AND APPLICATIONS 5 2. Algorithm Description We first briefly review Morgenstern's S-Impasse algorithm <ref> [26] </ref>. We then describe a parallel version of the S-Impasse algorithm, a parallel exhaustive search algorithm, and finally our Hybrid algorithm. 2.1. The S-Impasse Algorithm. This is an example of an iterative improvement algorithm, proposed by Morgenstern [26]. In the following description, the parameters of the algorithm are italicized. <p> Algorithm Description We first briefly review Morgenstern's S-Impasse algorithm <ref> [26] </ref>. We then describe a parallel version of the S-Impasse algorithm, a parallel exhaustive search algorithm, and finally our Hybrid algorithm. 2.1. The S-Impasse Algorithm. This is an example of an iterative improvement algorithm, proposed by Morgenstern [26]. In the following description, the parameters of the algorithm are italicized. Initially, a target number of color classes is chosen, and a naive coloring of the graph is quickly computed. All vertices from color classes beyond the target are placed in an impasse set. <p> Our algorithm runs until it has reached its time bound. We set our parameters to be the same for all graph classes. The initial target is simply set to be the number of nodes in the graph. For explanations of exactly how the other parameters are used, see Morgenstern <ref> [26] </ref>. In our implementation, the length s of a Kempe chain is set to 3; the temperature is 0:6 and the parameter is set to 10. These are the parameters used by Morgenstern [26] for G n;p graphs of size less than 500. <p> For explanations of exactly how the other parameters are used, see Morgenstern <ref> [26] </ref>. In our implementation, the length s of a Kempe chain is set to 3; the temperature is 0:6 and the parameter is set to 10. These are the parameters used by Morgenstern [26] for G n;p graphs of size less than 500. The temperature was lowered for graphs of size 500 or more. <p> Still, our results are obtained with no tuning of parameters; this is an important advantage over previous work. Our algorithm performs most poorly on large, randomly generated graphs. For example, using his tuned S-impasse algorithm, Morgenstern <ref> [26] </ref> obtains better results on large G n;p graphs. Also, Johnson et al. [17] obtain better colorings with their XRLF algorithm. <p> Progress after the initial stages, however, was made by the S-Impasse algorithm. Hybrid also surpassed previous results of Morgenstern <ref> [26] </ref>. His tuned, sequential S-Impasse algorithm only found a 20-coloring, in somewhat less than an hour, for each of the two 15-colorable graphs on which we find a 16-coloring. 4.1.2. <p> On the G 1000;0:5 graph, which has an estimated lower bound of 80, the best coloring found was 99 colors, found in just under 2:5 hours. Still, Hybrid always outperformed the simpler heuristic algorithms on all of these graphs. The poor results are perhaps not too surprising, as Morgenstern <ref> [26] </ref> also reported difficulty in obtaining good colorings for large G n;p graphs, even with his tuned sequential S-Impasse algorithm.
Reference: 28. <author> W. Myrvold, </author> <type> Personal communication, </type> <month> October </month> <year> 1993. </year>
Reference-contexts: The graph represents a formulation of a question regarding the number of orthogonal size 10 latin squares. It is an open problem whether or not this graph can be colored in 90 colors. (This graph was provided by Wendy Myrvold <ref> [28] </ref>.) Unlike the other application and random graphs in our test suite, this graph has a high density of about 76%. 3.2.5. Graphs for Parallelizing Iterative Solutions of Sparse Linear Systems.
Reference: 29. <author> R.J. Opsut and Fred S. Roberts, </author> <title> On the fleet maintenance, mobile radio frequency, task assignment and traffic phasing problems, The Theory and Applications of Graphs (G. </title> <editor> Char-trand, Y. Alavi, D.L. Goldsmith, L. Lesniak-Foster and D.R. Lick, eds.), </editor> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1981, </year> <pages> 479-492. </pages>
Reference-contexts: It is an abstraction of time-tabling problems, in which lists of courses desired by students are given, and the minimal number of class periods such that all students can take their desired courses must be determined (de Werra [10], Leighton [24], Opsut and Roberts <ref> [29] </ref>). Garey, Johnson and So [11] showed that graph coloring can be used for short circuit testing for printed circuits. Chaitin [7, 8] reduced register allocation to graph coloring and used it in a compiler.
Reference: 30. <author> E. L. Poole and J. M. Ortega, </author> <title> Multicolor ICCG methods for vector computers, </title> <journal> SIAM Journal of Numerical Analysis, </journal> <volume> 24, </volume> <year> 1987, </year> <pages> 1394-1418. </pages>
Reference-contexts: Garey, Johnson and So [11] showed that graph coloring can be used for short circuit testing for printed circuits. Chaitin [7, 8] reduced register allocation to graph coloring and used it in a compiler. Poole and Ortega <ref> [30] </ref> showed how to use graph coloring to decompose matrices used to solve sparse systems of linear equations; the decomposition gives a method for easy parallelization of the solution. <p> The parallelization does not actually require a true coloring of the graph; it is sufficient to color the vertices so that no positive cycle contains only vertices of the same color. (For more discussion see, for example, Poole and Ortega <ref> [30] </ref> and Jones and Plassmann [19].) There are many applications of sparse linear systems; our graphs are examples from power systems, of sizes 1993, 1084, 707, and 147. We refer to these graphs as sparse1993, sparse1084, sparse707 and sparse147 respectively. 3.2.6. Final Exam Scheduling.
Reference: 31. <author> D. C. Wood, </author> <title> A technique for coloring a graph applicable to large scale time-tabling problems, </title> <journal> Computer Journal, </journal> <volume> 12, </volume> <year> 1969, </year> <month> 317-319. </month> <title> PARALLEL GRAPH COLORING AND APPLICATIONS 21 </title>
References-found: 30

