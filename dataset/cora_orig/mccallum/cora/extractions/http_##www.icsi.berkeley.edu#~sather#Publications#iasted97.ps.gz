URL: http://www.icsi.berkeley.edu/~sather/Publications/iasted97.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/~sather/Publications/iasted97.html
Root-URL: http://www.icsi.berkeley.edu
Email: cfl@zurich.ibm.com  
Title: Fair Multi-Branch Locking of Several Locks  
Author: Claudio M. Fleiner Michael Philippsen 
Address: Germany  
Affiliation: IBM Research Division Zurich Research Laboratory  Computer Science Department University of Karlsruhe,  
Abstract: phlipp@ira.uka.de This paper appeared in: IASTED International Conference on Parallel and Distributed Computing and Systems, pages 537-545, Washington D.C., October 13-16, 1997 Abstract Thread-based concurrent languages currently do not provide much support to (a) avoid deadlocks, (b) treat competing threads in a fair way, and (c) allow branching depending on lock availability. This makes parallel programming difficult and error prone and thus reduces the programmer's productivity. In this paper we present a lock statement for fair atomic locking of several locks that supports (a), (b), and (c). We discuss the expressive power of the new lock statement and show the basic principles of an efficient implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G.R. Andrews and R.A. Olsson. </author> <title> The SR Programming Language: Concurrency in Practice. </title> <publisher> Ben-jamin/Cummings Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: Thread-based O-O Languages. Several parallel object-oriented languages or systems, for example Amber [4], Java [6], MeldC [7], C++ [2, 3], and SR <ref> [1] </ref> are available that are based on thread parallelism. Although all offer basic locking mechanisms of some kind, none of them offers atomic locking of multiple locks and multiple branches.
Reference: [2] <author> P.A. Buhr, G. Ditchfield, R.A. Stroobosscher, B.M. Younger, and C.R. Zarnke. </author> <title> C++: concurrency in the object-oriented language C++. </title> <journal> Software Practice and Experience, </journal> <volume> 22(2) </volume> <pages> 137-172, </pages> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: Thread-based O-O Languages. Several parallel object-oriented languages or systems, for example Amber [4], Java [6], MeldC [7], C++ <ref> [2, 3] </ref>, and SR [1] are available that are based on thread parallelism. Although all offer basic locking mechanisms of some kind, none of them offers atomic locking of multiple locks and multiple branches.
Reference: [3] <author> P.A. Buhr and R.A. Stroobosscher. </author> <title> C++ Annotated Reference Manual. </title> <institution> University of Waterloo, </institution> <year> 1993. </year>
Reference-contexts: Thread-based O-O Languages. Several parallel object-oriented languages or systems, for example Amber [4], Java [6], MeldC [7], C++ <ref> [2, 3] </ref>, and SR [1] are available that are based on thread parallelism. Although all offer basic locking mechanisms of some kind, none of them offers atomic locking of multiple locks and multiple branches.
Reference: [4] <author> J.S. Chase, F.G. Amador, E.D. Lazowska, H.M. Levy, and R.J. Littlefield. </author> <title> The Amber system: Parallel programming on a network of multiprocessors. </title> <type> TR 89-04-01, </type> <institution> Dept. of Computer Science, University of Wash-ington, </institution> <address> Seattle, </address> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: Thread-based O-O Languages. Several parallel object-oriented languages or systems, for example Amber <ref> [4] </ref>, Java [6], MeldC [7], C++ [2, 3], and SR [1] are available that are based on thread parallelism. Although all offer basic locking mechanisms of some kind, none of them offers atomic locking of multiple locks and multiple branches.
Reference: [5] <author> C. Fleiner. </author> <title> Parallel Optimizations: Optimizations for a Parallel, Object Oriented, Shared Memory Language running on a distributed System. </title> <type> PhD thesis, </type> <institution> University of Fribourg, Switzerland, </institution> <year> 1997. </year>
Reference-contexts: It is not possible that some conditions evaluate to true while others evaluate to false, so all plates see either an open stick or a closed one. In either case no plate can pass in front of another one, so the order of the plates does not change. See <ref> [5] </ref> for details.
Reference: [6] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Thread-based O-O Languages. Several parallel object-oriented languages or systems, for example Amber [4], Java <ref> [6] </ref>, MeldC [7], C++ [2, 3], and SR [1] are available that are based on thread parallelism. Although all offer basic locking mechanisms of some kind, none of them offers atomic locking of multiple locks and multiple branches.
Reference: [7] <author> G.E. Kaiser, W. Hseush, J.C. Lee, S.F. Wu, E. Woo, E. Hilsdale, and S. Meyer. MeldC: </author> <title> A reflective object-oriented coordination language. </title> <type> TR CUCS-001-93, </type> <institution> Columbia University, </institution> <address> New York, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: Thread-based O-O Languages. Several parallel object-oriented languages or systems, for example Amber [4], Java [6], MeldC <ref> [7] </ref>, C++ [2, 3], and SR [1] are available that are based on thread parallelism. Although all offer basic locking mechanisms of some kind, none of them offers atomic locking of multiple locks and multiple branches.
Reference: [8] <author> C. Lim. </author> <title> A Parallel Object-Oriented System for Realizing Reusable and Efficient Data Abstractions. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <year> 1993. </year>
Reference-contexts: Conditional locks greatly enhance the simplicity and readability of parallel programs and simplify maintenance and reusability. For a formal presentation of the construct we use pSather <ref> [10, 13, 8] </ref> although other languages would have been equally appropriate. In section 3 we present the basic principles of our implementation and give a formal proof of fairness and absence of starvation.
Reference: [9] <author> P.E. McKenney. </author> <title> Selecting locking designs for parallel programs. </title> <editor> In Vlissides, Coplin, and Kerth, editors, </editor> <booktitle> Pattern Languages of Program Design 2, </booktitle> <pages> pages 501-548. </pages> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Software Design Patterns. Recently, design pattern researchers focus their attention on parallel patterns [11]. However, the locking statement presented here is not yet identified as a pattern although it neatly extends previous work, e.g. <ref> [9] </ref>. 6 Conclusion This locking mechanism that allows atomic locking of several locks improves the programmer's productivity 8 In Java there are situations where the programmer cannot even control the order in which locks are re-acquired. by reducing or even eliminating deadlock considerations.
Reference: [10] <author> S.M. Omohundro. </author> <title> The Sather programming language. </title> <journal> Dr. Dobb's Journal, </journal> <volume> 18(11) </volume> <pages> 42-48, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Conditional locks greatly enhance the simplicity and readability of parallel programs and simplify maintenance and reusability. For a formal presentation of the construct we use pSather <ref> [10, 13, 8] </ref> although other languages would have been equally appropriate. In section 3 we present the basic principles of our implementation and give a formal proof of fairness and absence of starvation.
Reference: [11] <author> D.C. Schmidt, M. Fayad, and R.E. Johnson. </author> <title> Software patterns. </title> <journal> Communications of the ACM, </journal> <volume> 39(10) </volume> <pages> 36-39, </pages> <year> 1996. </year>
Reference-contexts: If they are, reader/writer protocols can be used, which are offered in pSather and are handled by the lock manager in a fair and starvation-free way. Software Design Patterns. Recently, design pattern researchers focus their attention on parallel patterns <ref> [11] </ref>.
Reference: [12] <author> A. Silberschatz and J.L. Peterson. </author> <title> Operating System Concepts. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: acquired atomically, deadlock can never occur due to concurrent execution of two or more lock statements with multiple locks, although it is possible for deadlock to occur by dynamic nesting of lock statements or in other ways. 2.2 Examples In contrast to other languages, the core of the dining philosophers <ref> [12] </ref> implementation is straightforward with multiple locking because the system guarantees the absence of deadlocks and starvation.
Reference: [13] <author> Sather and pSather. </author> <note> http://icsi.berkeley.edu/Sather. </note>
Reference-contexts: Conditional locks greatly enhance the simplicity and readability of parallel programs and simplify maintenance and reusability. For a formal presentation of the construct we use pSather <ref> [10, 13, 8] </ref> although other languages would have been equally appropriate. In section 3 we present the basic principles of our implementation and give a formal proof of fairness and absence of starvation. <p> Then we show the corresponding release of locks. To ease the presentation, the code is simplified; the complete code can be found in <ref> [13] </ref>. Finally, we show that by simply adding a few lines of code, the locking routine can be extended to handle else branches with blocktry semantics as well. Locking. A thread executing a lock statement calls multilock which returns the branch number to be executed.
Reference: [14] <author> A.S. Tanenbaum. </author> <title> Modern Operating Systems. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1992. </year>
Reference-contexts: When we assume that all locks will eventually be released, the oldest plate certainly will succeed. Stubbornness is similar to the concept of aging found in several operating system scheduling policies, see for example <ref> [14] </ref>. In section 3.6 we formally prove the absence of starvation. 3.2 Implementation of Else Branches The semantics of the lock statement dictate that the else branch is selected if there is no when branch for which the necessary locks can be acquired.
Reference: [15] <author> D. Zobel. </author> <title> The deadlock problem: A classifying bibliography. </title> <journal> Operating Systems Review, </journal> <volume> 17(4) </volume> <pages> 6-16, </pages> <month> Oct. </month> <year> 1983. </year>
Reference-contexts: To our knowledge fairness is not addressed in any of them. 8 Hence, all the languages mentioned (and several others) could be improved by a multi-branch locking of several locks. Operating Systems. Deadlocks have been an important topic of operating system research for several decades. <ref> [15] </ref> gives an overview of the literature. Compared to operating systems, a run-time system has different intentions. Since neither deadlock avoidance and detection nor usage quotas are of interest, we rely on the programmer to make his application fair and deadlock free.
References-found: 15

