URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/papers/cpsstack96.ps.gz
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/papers/
Root-URL: 
Email: fdanvy,belminag@brics.dk  fp@cs.cmu.edu  
Phone: Phone: (+45) 89 42 33 69. Fax: (+45) 89 42 32 55. 5000  
Title: On the Overhead of CPS  
Author: Olivier Danvy and Belmina Dzafic Frank Pfenning 
Keyword: direct style, continuation-passing style, -calculus, abstract machine, logical framework.  
Note: Draft Summary Basic Research in Computer Science, Centre of the Danish National Research Foundation.  This work is supported by NSF Grant CCR-9303383.  
Date: November 18, 1996  
Address: Aarhus University  Building 540, Ny Munkegade, DK-8000 Aarhus C, Denmark.  Forbes Ave., Pittsburgh, PA 15213-3891, USA.  
Affiliation: BRICS Department of Computer Science  School of Computer Science Carnegie Mellon University  
Abstract: Continuation-passing style (CPS) is often criticized to be more expensive than the usual direct style of functional programming. By structure, CPS functions indeed are passed one extra argument (the continuation), and each intermediate result indeed occurs in a function call (to the continuation). As higher-order functions, continuations are also more expensive. However, by structure also, CPS exhibits a great deal of syntactic regularity. We show how to exploit this regularity to implement CPS with two stacks | one for continuation parameters and one for the parameters of continuations | in a way that reduces the extra price of CPS to managing those two stacks. In effect, the stack for continuation parameters acts as a control stack for calls and returns, and the stack for parameters of continuations acts as a data stack for intermediate results. This demonstrates that CPS is just about as expensive as direct style, where calls, returns, and intermediate results also have to be dealt with. To this end, we present four abstract machines for CPS -terms | a bare one, one with a control stack, one with a data stack, and one with both a control stack and a data stack | and we prove their equivalence. Our result also applies to A-normal forms, i.e., monadic style. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: r 2 DRoot | DS terms r ::= e e 2 DExp | DS expressions e ::= e 0 e 1 j t t 2 DTriv | DS trivial expressions t ::= x j x:r x 2 Ide | identifiers Direct-style terms are transformed into continuation-passing style by CPS transformation <ref> [1, 7, 16, 17, 24, 25] </ref>. (We consider left-to-right call by value, and Plotkin-style CPS, i.e., with continuations last. <p> Exceptions include Appel, who uses the heap as his unique memory resource [2]. CPS-compiler writers have not been without noticing that the free variables of the continuation could naturally be implemented with the target-machine registers <ref> [1, 4, 17, 28] </ref>.
Reference: [2] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In Jan Maluszynski and Martin Wirsing, editors, </editor> <booktitle> Third International Symposium on Programming Language Implementation and Logic Programming, number 528 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-13, </pages> <address> Passau, Germany, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: Doubtlessly it would be interesting to recast this work in a categorical setting, but that is not our point here. 8 Related work Since Milne and Strachey [19], virtually everybody uses a control stack for continuation parameters. Exceptions include Appel, who uses the heap as his unique memory resource <ref> [2] </ref>. CPS-compiler writers have not been without noticing that the free variables of the continuation could naturally be implemented with the target-machine registers [1, 4, 17, 28].
Reference: [3] <author> Hans-J. Boehm, </author> <title> editor. </title> <booktitle> Proceedings of the Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year> <note> ACM Press. 10 </note>
Reference: [4] <author> William Clinger. </author> <title> The Scheme 311 compiler, an exercise in Denotational Semantics. </title> <editor> In Guy L. Steele Jr., editor, </editor> <booktitle> Conference Record of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 356-364, </pages> <address> Austin, Texas, </address> <month> August </month> <year> 1984. </year>
Reference-contexts: Exceptions include Appel, who uses the heap as his unique memory resource [2]. CPS-compiler writers have not been without noticing that the free variables of the continuation could naturally be implemented with the target-machine registers <ref> [1, 4, 17, 28] </ref>.
Reference: [5] <editor> William Clinger and Jonathan Rees (editors). </editor> <title> Revised 4 report on the algorithmic language Scheme. LISP Pointers, </title> <address> IV(3):1-55, </address> <month> July-September </month> <year> 1991. </year>
Reference-contexts: Our work shows that all is not lost for CPS programs when it comes to stackability. Let us conclude with a word on proper tail-recursion. In some situations, it is essential to process tail-calls properly, e.g., in the implementation of a programming language such as Scheme <ref> [5] </ref>. As analyzed elsewhere [6, Section 3], it is in the CPS transformation itself that tail-calls need to be treated specially.
Reference: [6] <author> Olivier Danvy. </author> <title> Back to direct style. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 22(3) </volume> <pages> 183-195, </pages> <year> 1994. </year>
Reference-contexts: e CExp Var t 0 t 1 v:e ffi j= CTriv Var x ; ffi j= CRoot Var r ffi j= CTriv Var x:r ; ffi ffi; v j= CTriv Var v ; ffi 4 One data stack for the parameters of continuations An earlier work on the direct-style transformation <ref> [6] </ref> made it necessary to characterize the occurrences of the parameters of continuations in CPS terms (see Figure 4). <p> let v = t 0 t 1 in e j return (t) t 2 MTriv | monadic-style trivial expressions t ::= x j x:r j v x 2 Ide | source identifiers v 2 Var | fresh let parameters This BNF is in bijective correspondence with the BNF of CPS <ref> [6, 12, 15] </ref>. It is thus simple to state occurrence conditions over let parameters, given a monadic-style transformation [12, Figure 9], and to write the corresponding stack-based abstract machine, similar to the one of Figure 5. Note that we have been careful to write "monadic style". <p> Let us conclude with a word on proper tail-recursion. In some situations, it is essential to process tail-calls properly, e.g., in the implementation of a programming language such as Scheme [5]. As analyzed elsewhere <ref> [6, Section 3] </ref>, it is in the CPS transformation itself that tail-calls need to be treated specially.
Reference: [7] <author> Olivier Danvy and Andrzej Filinski. </author> <title> Representing control, a study of the CPS transformation. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 361-391, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: r 2 DRoot | DS terms r ::= e e 2 DExp | DS expressions e ::= e 0 e 1 j t t 2 DTriv | DS trivial expressions t ::= x j x:r x 2 Ide | identifiers Direct-style terms are transformed into continuation-passing style by CPS transformation <ref> [1, 7, 16, 17, 24, 25] </ref>. (We consider left-to-right call by value, and Plotkin-style CPS, i.e., with continuations last.
Reference: [8] <author> Olivier Danvy and Frank Pfenning. </author> <title> The occurrence of continuation parameters in CPS terms. </title> <type> Technical report CMU-CS-95-121, </type> <institution> School of Computer Science, Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: This proof takes advantage of the characterization of occurrences of continuation parameters given in Figure 3, which we have proven elsewhere <ref> [8] </ref>. <p> We did meet this challenge after formalizing both the CPS transformation and the occurrence conditions in Elf, and we report this case of machine-assisted proof discovery elsewhere <ref> [8] </ref>. Using the same proof technique, the second author has shown that the occurrence conditions are closed under beta and eta reduction [10]. This previous work makes it clear that for each CPS -abstraction, intermediate results are produced and consumed in a stack-like fashion. <p> We have formalized all the abstract machines in Elf [21], a constraint logic-programming language based on the logical framework LF [14] and we are currently implementing their equivalence proofs based on the techniques outlined in our earlier work <ref> [8] </ref>. The expensive reputation of CPS is thus unfounded. These results also apply to other evaluation orders than left-to-right call by value, and also to A-normal forms (monadic style). <p> The enabling technologies of our work are the occurrence conditions of parameters in CPS terms, and the proof technique for establishing the correctness of these conditions (a unary logical relation) <ref> [8] </ref>. As outlined at the end of Section 1, we believe that the conditions and the abstract machines can be extended for a full-fledged Scheme-like language.
Reference: [9] <author> Bruce F. Duba, Robert Harper, and David B. MacQueen. </author> <title> Typing first-class continuations in ML. </title> <editor> In Robert (Corky) Cartwright, editor, </editor> <booktitle> Proceedings of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <address> Orlando, Florida, </address> <month> January </month> <year> 1991. </year> <note> ACM Press. </note>
Reference-contexts: Furthermore, the development should also apply to statically typed languages such as ML, as long as polymorphism is handled correctly as suggested by Duba, Harper, and MacQueen <ref> [9] </ref>.
Reference: [10] <author> Belmina Dzafic. </author> <title> Closure properties for an occurrence condition in CPS terms. </title> <type> Student report, DAIMI, </type> <institution> Computer Science Department, Aarhus University, Aarhus, Denmark, </institution> <month> October </month> <year> 1996. </year>
Reference-contexts: We did meet this challenge after formalizing both the CPS transformation and the occurrence conditions in Elf, and we report this case of machine-assisted proof discovery elsewhere [8]. Using the same proof technique, the second author has shown that the occurrence conditions are closed under beta and eta reduction <ref> [10] </ref>. This previous work makes it clear that for each CPS -abstraction, intermediate results are produced and consumed in a stack-like fashion. One could thus implement CPS programs by allocating one stack per closure, to store its intermediate results, and deallocating this stack before returning or performing a tail-call. <p> Lemma 1 The following properties hold for stack substitution. 1. efffig = e. 2. (ef~; v; ~ 0 g)[t=v] = ef~; t; ~ 0 g. We also need Dzafic's result that the occurrence conditions are closed under substitution <ref> [10] </ref>. From this we can prove the equivalence of the machines by structural induction on the derivations of the evaluation judgment. In addition to the occurrence conditions, we now also assume that the data stacks ~ are closed, that is, they contain no free variables x or v.
Reference: [11] <author> Anthony J. Field and Peter G. Harrison. </author> <title> Functional Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: As we have seen, such objects are much less efficient to implement than data, and the continuations passed as parameters in an application of the transformed function become increasingly complex, rendering the transformation worthless." <ref> [11, Page 498] </ref> CPS thus is expensive, as illustrated in Figure 1, where we display an abstract machine reducing CPS terms.
Reference: [12] <author> Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen. </author> <title> The essence of compiling with continuations. </title> <editor> In David W. Wall, editor, </editor> <booktitle> Proceedings of the ACM SIGPLAN'93 Conference on Programming Languages Design and Implementation, SIGPLAN Notices, </booktitle> <volume> Vol. 28, No 6, </volume> <pages> pages 237-247, </pages> <address> Albuquerque, New Mexico, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Our result directly applies to A-normal forms <ref> [12, Figure 9] </ref>, monadic normal forms [15], nqCPS, etc., a monadic style that originates in Moggi's work [20] and has been transposed in the functional-programming world by Wadler [27]. Namely, let-bound variables in a monadic program encoding a particular evaluation order obey a stack discipline. <p> Therefore no occurrence conditions are needed to specify stack machines for CPS programs. 2 7 Monadic style A-normal forms essentially amount to CPS without continuations <ref> [12] </ref>. <p> let v = t 0 t 1 in e j return (t) t 2 MTriv | monadic-style trivial expressions t ::= x j x:r j v x 2 Ide | source identifiers v 2 Var | fresh let parameters This BNF is in bijective correspondence with the BNF of CPS <ref> [6, 12, 15] </ref>. It is thus simple to state occurrence conditions over let parameters, given a monadic-style transformation [12, Figure 9], and to write the corresponding stack-based abstract machine, similar to the one of Figure 5. Note that we have been careful to write "monadic style". <p> It is thus simple to state occurrence conditions over let parameters, given a monadic-style transformation <ref> [12, Figure 9] </ref>, and to write the corresponding stack-based abstract machine, similar to the one of Figure 5. Note that we have been careful to write "monadic style". Our analogy is purely syntactic, and based on the bijective correspondence between CPS and A-normal forms.
Reference: [13] <author> John Hannan and Dale Miller. </author> <title> From operational semantics to abstract machines. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 415-459, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: CPS terms are remarkable in that they satisfy the three properties of indifference, simulation, and translation [22]. Indifference: CPS terms are evaluation-order independent. Simulation: the CPS transformation encodes an evaluation order. Translation: an equational correspondence exists between DS and CPS calculi. [18] and operational semantics <ref> [13, 22, 23] </ref>.
Reference: [14] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the ACM, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <year> 1993. </year> <booktitle> A preliminary version appeared in the proceedings of the First IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 194-204, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: We have formalized all the abstract machines in Elf [21], a constraint logic-programming language based on the logical framework LF <ref> [14] </ref> and we are currently implementing their equivalence proofs based on the techniques outlined in our earlier work [8]. The expensive reputation of CPS is thus unfounded. These results also apply to other evaluation orders than left-to-right call by value, and also to A-normal forms (monadic style).
Reference: [15] <author> John Hatcliff and Olivier Danvy. </author> <title> A generic account of continuation-passing styles. </title> <booktitle> In Boehm [3], </booktitle> <pages> pages 458-471. </pages>
Reference-contexts: Our result directly applies to A-normal forms [12, Figure 9], monadic normal forms <ref> [15] </ref>, nqCPS, etc., a monadic style that originates in Moggi's work [20] and has been transposed in the functional-programming world by Wadler [27]. Namely, let-bound variables in a monadic program encoding a particular evaluation order obey a stack discipline. <p> let v = t 0 t 1 in e j return (t) t 2 MTriv | monadic-style trivial expressions t ::= x j x:r j v x 2 Ide | source identifiers v 2 Var | fresh let parameters This BNF is in bijective correspondence with the BNF of CPS <ref> [6, 12, 15] </ref>. It is thus simple to state occurrence conditions over let parameters, given a monadic-style transformation [12, Figure 9], and to write the corresponding stack-based abstract machine, similar to the one of Figure 5. Note that we have been careful to write "monadic style".
Reference: [16] <author> John Hatcliff and Olivier Danvy. </author> <title> Thunks and the -calculus. </title> <journal> Journal of Functional Programming, </journal> <note> 1996. To appear. </note>
Reference-contexts: r 2 DRoot | DS terms r ::= e e 2 DExp | DS expressions e ::= e 0 e 1 j t t 2 DTriv | DS trivial expressions t ::= x j x:r x 2 Ide | identifiers Direct-style terms are transformed into continuation-passing style by CPS transformation <ref> [1, 7, 16, 17, 24, 25] </ref>. (We consider left-to-right call by value, and Plotkin-style CPS, i.e., with continuations last.
Reference: [17] <author> David Kranz, Richard Kesley, Jonathan Rees, Paul Hudak, Jonathan Philbin, and Norman Adams. </author> <title> Orbit: An optimizing compiler for Scheme. </title> <booktitle> In Proceedings of the ACM SIGPLAN'86 Symposium on Compiler Construction, </booktitle> <pages> pages 219-233, </pages> <address> Palo Alto, California, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: r 2 DRoot | DS terms r ::= e e 2 DExp | DS expressions e ::= e 0 e 1 j t t 2 DTriv | DS trivial expressions t ::= x j x:r x 2 Ide | identifiers Direct-style terms are transformed into continuation-passing style by CPS transformation <ref> [1, 7, 16, 17, 24, 25] </ref>. (We consider left-to-right call by value, and Plotkin-style CPS, i.e., with continuations last. <p> Exceptions include Appel, who uses the heap as his unique memory resource [2]. CPS-compiler writers have not been without noticing that the free variables of the continuation could naturally be implemented with the target-machine registers <ref> [1, 4, 17, 28] </ref>.
Reference: [18] <author> Peter J. Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> Computer Journal, </journal> <volume> 6 </volume> <pages> 308-320, </pages> <year> 1964. </year>
Reference-contexts: We thus include them here. CPS terms are remarkable in that they satisfy the three properties of indifference, simulation, and translation [22]. Indifference: CPS terms are evaluation-order independent. Simulation: the CPS transformation encodes an evaluation order. Translation: an equational correspondence exists between DS and CPS calculi. <ref> [18] </ref> and operational semantics [13, 22, 23].
Reference: [19] <author> Robert E. Milne and Christopher Strachey. </author> <title> A Theory of Programming Language Semantics. </title> <publisher> Chapman and Hall, London, and John Wiley, </publisher> <address> New York, </address> <year> 1976. </year>
Reference-contexts: Doubtlessly it would be interesting to recast this work in a categorical setting, but that is not our point here. 8 Related work Since Milne and Strachey <ref> [19] </ref>, virtually everybody uses a control stack for continuation parameters. Exceptions include Appel, who uses the heap as his unique memory resource [2]. CPS-compiler writers have not been without noticing that the free variables of the continuation could naturally be implemented with the target-machine registers [1, 4, 17, 28].
Reference: [20] <author> Eugenio Moggi. </author> <title> Notions of computation and monads. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 55-92, </pages> <year> 1991. </year>
Reference-contexts: Our result directly applies to A-normal forms [12, Figure 9], monadic normal forms [15], nqCPS, etc., a monadic style that originates in Moggi's work <ref> [20] </ref> and has been transposed in the functional-programming world by Wadler [27]. Namely, let-bound variables in a monadic program encoding a particular evaluation order obey a stack discipline.
Reference: [21] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year> <month> 11 </month>
Reference-contexts: We have proven the equivalence of these four abstract machines (the equivalence proof between (1) and (3) and (3) and (4) is outlined in the appendix of the present submission). We have formalized all the abstract machines in Elf <ref> [21] </ref>, a constraint logic-programming language based on the logical framework LF [14] and we are currently implementing their equivalence proofs based on the techniques outlined in our earlier work [8]. The expensive reputation of CPS is thus unfounded.
Reference: [22] <author> Gordon D. Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: We thus include them here. CPS terms are remarkable in that they satisfy the three properties of indifference, simulation, and translation <ref> [22] </ref>. Indifference: CPS terms are evaluation-order independent. Simulation: the CPS transformation encodes an evaluation order. Translation: an equational correspondence exists between DS and CPS calculi. [18] and operational semantics [13, 22, 23]. <p> CPS terms are remarkable in that they satisfy the three properties of indifference, simulation, and translation [22]. Indifference: CPS terms are evaluation-order independent. Simulation: the CPS transformation encodes an evaluation order. Translation: an equational correspondence exists between DS and CPS calculi. [18] and operational semantics <ref> [13, 22, 23] </ref>.
Reference: [23] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report FN-19, DAIMI, </type> <institution> Computer Science Department, Aarhus University, Aarhus, Denmark, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: CPS terms are remarkable in that they satisfy the three properties of indifference, simulation, and translation [22]. Indifference: CPS terms are evaluation-order independent. Simulation: the CPS transformation encodes an evaluation order. Translation: an equational correspondence exists between DS and CPS calculi. [18] and operational semantics <ref> [13, 22, 23] </ref>.
Reference: [24] <author> Amr Sabry and Matthias Felleisen. </author> <title> Reasoning about programs in continuation-passing style. </title> <journal> LISP and Symbolic Computation, </journal> 6(3/4):289-360, December 1993. 
Reference-contexts: r 2 DRoot | DS terms r ::= e e 2 DExp | DS expressions e ::= e 0 e 1 j t t 2 DTriv | DS trivial expressions t ::= x j x:r x 2 Ide | identifiers Direct-style terms are transformed into continuation-passing style by CPS transformation <ref> [1, 7, 16, 17, 24, 25] </ref>. (We consider left-to-right call by value, and Plotkin-style CPS, i.e., with continuations last.
Reference: [25] <author> Guy L. Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Technical Report AI-TR-474, </type> <institution> Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, Massachusetts, </institution> <month> May </month> <year> 1978. </year>
Reference-contexts: r 2 DRoot | DS terms r ::= e e 2 DExp | DS expressions e ::= e 0 e 1 j t t 2 DTriv | DS trivial expressions t ::= x j x:r x 2 Ide | identifiers Direct-style terms are transformed into continuation-passing style by CPS transformation <ref> [1, 7, 16, 17, 24, 25] </ref>. (We consider left-to-right call by value, and Plotkin-style CPS, i.e., with continuations last.
Reference: [26] <author> Mads Tofte and Jean-Pierre Talpin. </author> <title> Implementation of the typed call-by-value lambda-calculus using a stack of regions. </title> <booktitle> In Boehm [3], </booktitle> <pages> pages 188-201. </pages>
Reference-contexts: One could thus implement CPS programs by allocating one stack per closure, to store its intermediate results, and deallocating this stack before returning or performing a tail-call. While this strategy might well be interesting on its own right <ref> [26] </ref>, the new insight which is at the core of the present work is that these stacks can be implemented using one global stack of intermediate results. To this end we introduce parameter stacks ffi. <p> dedicated abstract machines for CPS terms, and certainly of none that implements continuation-passing with two stacks. (We are currently investigating how our new machine compare with traditional abstract machines for direct style.) Tofte and Talpin have suggested to implement the -calculus with a stack of regions and no garbage collector <ref> [26] </ref>. Their basic idea is to associate a region for each lexical block, and to garbage-collect it on block exit. This scheme is of course very much allergic to CPS (which "never returns"). Our work shows that all is not lost for CPS programs when it comes to stackability.
Reference: [27] <author> Philip Wadler. </author> <title> The essence of functional programming (tutorial). </title> <editor> In Andrew W. Appel, editor, </editor> <booktitle> Proceedings of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1992. </year> <note> ACM Press. </note>
Reference-contexts: Our result directly applies to A-normal forms [12, Figure 9], monadic normal forms [15], nqCPS, etc., a monadic style that originates in Moggi's work [20] and has been transposed in the functional-programming world by Wadler <ref> [27] </ref>. Namely, let-bound variables in a monadic program encoding a particular evaluation order obey a stack discipline.
Reference: [28] <author> Mitchell Wand. </author> <title> Deriving target code as a representation of continuation semantics. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 496-517, </pages> <year> 1982. </year> <month> 12 </month>
Reference-contexts: Exceptions include Appel, who uses the heap as his unique memory resource [2]. CPS-compiler writers have not been without noticing that the free variables of the continuation could naturally be implemented with the target-machine registers <ref> [1, 4, 17, 28] </ref>.
References-found: 28

