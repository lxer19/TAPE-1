URL: http://www.win.tue.nl/~hooman/Bremen.ps
Refering-URL: http://www.win.tue.nl/~hooman/Bremen.html
Root-URL: http://www.win.tue.nl
Email: e-mail: hooman@win.tue.nl  
Title: Developing Proof Rules for Distributed Real-Time Systems with PVS  
Author: Jozef Hooman 
Address: P.O. Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Dept. of Computing Science Eindhoven University of Technology  
Abstract: In previous work, the verification system PVS has been used to support an assertional method for the specification and verification of distributed real-time systems. Essential part of the method is a compositional rule for parallel composition. In this paper we focus on the formalization of parallel composition in PVS. Two, equivalent, versions of the semantics of parallel composition are formulated in the specification language of PVS. Based on this semantics, several proof rules are shown to be sound, using the interactive proof checker of PVS. We indicate how the general framework can be instantiated for a particular class of applications by giving an axiomatization of asynchronous communication. 
Abstract-found: 1
Intro-found: 1
Reference: [Bn96] <author> M. Butler and T. Langbacka. </author> <title> Program derivation using the refinement calculator. </title> <booktitle> In Theorem Proving in Higher Order Logics, </booktitle> <pages> pages 93-108. </pages> <publisher> LNCS 1125, Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The sequential programming constructs that have been formalized earlier [Hoo94b] should be incorporated in the current framework. Then it is relevant to make a comparison with related work, such as the formalization of the refinement calculus in HOL <ref> [Bn96] </ref>, although that work does not deal with real-time and parallelism. In other work we will report about the addition of a hiding construct to encapsulate internal channels. More complex examples should indicate other required adaptations and extensions.
Reference: [Hoa69] <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) 576-580,583, </volume> <year> 1969. </year>
Reference-contexts: (s,o) AND A2 (s,o) ); Valid (A) : bool = FORALL s, o : A (s,o) Specifications consist of a set of observable events, a set of local variables and two assertions, an assumption A and a commitment C, which play a similar role as the well-known pre- and postconditions <ref> [Hoa69] </ref>. spec (Eset, Vset, A, C) : Components = (# alpha := Eset, vari := Vset, sem := LAMBDA s0, s1, o : CompInterface (Eset,Vset,s0,s1,o) AND NonTerm (s0,s1) AND TimeAdvance (s0,s1) AND (A (s0,o) IMPLIES C (s1,o)) #) Finally we define a conversion At which allows us to consider observation functions
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: We use the infix operator //, which means that we can write comp1 // comp2. The difference with the previous definition is the treatment of the observation functions. Similar to the definition for traces in <ref> [Hoa85] </ref>, we require that the projection of an observation function of the parallel construct onto the alphabet of one of the components leads to an observation of this component.
Reference: [Hoo91] <author> J. Hooman. </author> <title> Specification and Compositional Verification of Real-Time Sys--tems. </title> <publisher> LNCS 558, Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction Based on Hoare triples (precondition, program, postcondition), a formal framework for the specification and verification of distributed real-time systems has been developed <ref> [Hoo91] </ref>. This framework has been applied to a number of case studies, such as a water level monitoring system [Hoo93] and a distributed real-time arbitration protocol [Hoo94a]. Although these examples have been verified manually, it became clear that for more complex applications some form of mechanical support is indispensable.
Reference: [Hoo93] <author> J. Hooman. </author> <title> A compositional approach to the design of hybrid systems. </title> <booktitle> In Workshop on Theory of Hybrid Systems, </booktitle> <pages> pages 121-148. </pages> <note> LNCS 736, </note> <year> 1993. </year>
Reference-contexts: 1 Introduction Based on Hoare triples (precondition, program, postcondition), a formal framework for the specification and verification of distributed real-time systems has been developed [Hoo91]. This framework has been applied to a number of case studies, such as a water level monitoring system <ref> [Hoo93] </ref> and a distributed real-time arbitration protocol [Hoo94a]. Although these examples have been verified manually, it became clear that for more complex applications some form of mechanical support is indispensable. Therefore we have experimented with the verification system PVS 1 (Prototype Verification System) [ORS92, ORSvH95].
Reference: [Hoo94a] <author> J. Hooman. </author> <title> Compositional verification of a distributed real-time arbitration protocol. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 6(2) </volume> <pages> 173-205, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction Based on Hoare triples (precondition, program, postcondition), a formal framework for the specification and verification of distributed real-time systems has been developed [Hoo91]. This framework has been applied to a number of case studies, such as a water level monitoring system [Hoo93] and a distributed real-time arbitration protocol <ref> [Hoo94a] </ref>. Although these examples have been verified manually, it became clear that for more complex applications some form of mechanical support is indispensable. Therefore we have experimented with the verification system PVS 1 (Prototype Verification System) [ORS92, ORSvH95].
Reference: [Hoo94b] <author> J. Hooman. </author> <title> Correctness of real time systems by construction. </title> <booktitle> In Formal Techniques in Real-Time and Fault-Tolerant Systems, </booktitle> <pages> pages 19-40. </pages> <publisher> LNCS 863, Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: This allows, e.g., the parallel composition of specifications. By means of refinement steps, justified by proof rules, specifications can be transformed into complete 1 PVS is free available, see http://www.csl.sri.com/sri-csl-pvs.html programs. The resulting PVS framework (see <ref> [Hoo94b] </ref>) has been applied to sev-eral examples, including the RPC-Memory specification problem [Hoo96], part of the ACCESS.bus protocol [Hoo95], a steam boiler control system [VH96], and a membership protocol for a dynamic network with node failures and local clocks [Hoo97] 2 . <p> To obtain a theory which can be applied in many different situations, it is parameterized by the types of the values, the variables and the events. In previous work <ref> [Hoo94b] </ref> the semantics of sequential real-time programs has been formulated in terms of an initial state, which describes the situation at the start of the execution, and a final state for the state of affairs at termination. <p> To avoid deep encodings and to have more flexibility to mix programs and specifications, we follow here the alternative approach (as in <ref> [Hoo94b] </ref>) and identify programming constructs and their semantics. The semantics of parallel composition is defined in theory SemParComp. First par (comp1,comp2) is defined, requiring that the sets of variables of the two components are disjoint. <p> Concerning the work described here, there are several directions for future research. The sequential programming constructs that have been formalized earlier <ref> [Hoo94b] </ref> should be incorporated in the current framework. Then it is relevant to make a comparison with related work, such as the formalization of the refinement calculus in HOL [Bn96], although that work does not deal with real-time and parallelism.
Reference: [Hoo95] <author> J. Hooman. </author> <title> Verifying part of the ACCESS.bus protocol using PVS. </title> <booktitle> In Proceedings 15th Conference on the Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 96-110. </pages> <publisher> LNCS 1026, Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: By means of refinement steps, justified by proof rules, specifications can be transformed into complete 1 PVS is free available, see http://www.csl.sri.com/sri-csl-pvs.html programs. The resulting PVS framework (see [Hoo94b]) has been applied to sev-eral examples, including the RPC-Memory specification problem [Hoo96], part of the ACCESS.bus protocol <ref> [Hoo95] </ref>, a steam boiler control system [VH96], and a membership protocol for a dynamic network with node failures and local clocks [Hoo97] 2 . As a start, these examples were verified using a simplified version of the formal framework.
Reference: [Hoo96] <author> J. Hooman. </author> <title> Using PVS for an assertional verification of the RPC-memory specification problem. </title> <booktitle> In Formal Systems Specification; The RPC-Memory Specification Case Study, </booktitle> <pages> pages 275-304. </pages> <publisher> LNCS 1169, Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: This allows, e.g., the parallel composition of specifications. By means of refinement steps, justified by proof rules, specifications can be transformed into complete 1 PVS is free available, see http://www.csl.sri.com/sri-csl-pvs.html programs. The resulting PVS framework (see [Hoo94b]) has been applied to sev-eral examples, including the RPC-Memory specification problem <ref> [Hoo96] </ref>, part of the ACCESS.bus protocol [Hoo95], a steam boiler control system [VH96], and a membership protocol for a dynamic network with node failures and local clocks [Hoo97] 2 . As a start, these examples were verified using a simplified version of the formal framework.
Reference: [Hoo97] <author> J. Hooman. </author> <title> Verification of distributed real-time and fault-tolerant protocols. </title> <booktitle> In Algebraic Methodology and Software Technology (AMAST'97), </booktitle> <pages> pages 261-275. </pages> <publisher> LNCS 1349, Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: The resulting PVS framework (see [Hoo94b]) has been applied to sev-eral examples, including the RPC-Memory specification problem [Hoo96], part of the ACCESS.bus protocol [Hoo95], a steam boiler control system [VH96], and a membership protocol for a dynamic network with node failures and local clocks <ref> [Hoo97] </ref> 2 . As a start, these examples were verified using a simplified version of the formal framework. The semantics of sequential constructs has been formulated and proof rules (e.g. for iteration) have been proved as a theorem in PVS.
Reference: [J96] <author> M. Joseph, </author> <title> Editor. Real-time Systems: Specification, Verification and Analysis. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: Then OnlyDepEve (C1,Eset1) implies C1 (s1,intersection (o1,Eset1)), thus C1 (s1,intersection (o,Eset1)), and again using OnlyDepEve (C1,Eset1) we obtain C1 (s1,o). Finally, StateIndep (C1) leads to C1 (s,o). 4.3 Example Parallel Composition As an application of RulePar, we consider a simplified version of a mine pump example <ref> [J96] </ref>. Consider a mine where the presence of gas could lead to an explosion. No local variables are needed and Vars is declared as an uninterpreted type.
Reference: [Old85] <author> E.-R. Olderog. </author> <title> Process theory: Semantics, specification and verification. </title> <booktitle> In Current Trends in Concurrency, </booktitle> <pages> pages 442-509. </pages> <publisher> LNCS 224, Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The main ingredients of our formal framework have been formulated in the language of PVS. To be able to represent design steps formally, specifications and programming constructs can be mixed freely, similar to the untimed framework of <ref> [Old85, Zwi89] </ref> and more recent work on timed systems [SO98]. This allows, e.g., the parallel composition of specifications. By means of refinement steps, justified by proof rules, specifications can be transformed into complete 1 PVS is free available, see http://www.csl.sri.com/sri-csl-pvs.html programs. <p> The next two sections deal with parallel composition. The aim is to obtain a rule where the commitment of a parallel composition is essentially the conjunction of the commitments of the components, inspired by similar rules for untimed systems (see, e.g., <ref> [Old85, Zwi89] </ref>). 4.1 The Consequence Rule To allow weakening of commitments and strengthening of assumptions, the usual consequence rule is proved as a theorem in PVS.
Reference: [ORS92] <author> S. Owre, J. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <booktitle> In 11th Conference on Automated Deduction, volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 748-752. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Although these examples have been verified manually, it became clear that for more complex applications some form of mechanical support is indispensable. Therefore we have experimented with the verification system PVS 1 (Prototype Verification System) <ref> [ORS92, ORSvH95] </ref>. The PVS specification language is a higher-order typed logic, with many built-in types including booleans, integers, reals, sets, lists, and records. Further the tool contains a proof checker which makes it possible to construct proofs interactively and to rerun proofs automatically after small changes.
Reference: [ORSvH95] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <year> 1995. </year>
Reference-contexts: Although these examples have been verified manually, it became clear that for more complex applications some form of mechanical support is indispensable. Therefore we have experimented with the verification system PVS 1 (Prototype Verification System) <ref> [ORS92, ORSvH95] </ref>. The PVS specification language is a higher-order typed logic, with many built-in types including booleans, integers, reals, sets, lists, and records. Further the tool contains a proof checker which makes it possible to construct proofs interactively and to rerun proofs automatically after small changes.
Reference: [Rus95] <author> J. Rushby. </author> <title> Mechanizing formal methods: Opportunities and challenges. </title> <booktitle> In ZUM '95: The Z Formal Specification Notation; 9th International Conference of Z Users, </booktitle> <pages> pages 105-113. </pages> <publisher> LNCS 967, Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: waitsend (ch) : ChanEvents MinWaitSend : AXIOM o (waitsend (ch))(t) IMPLIES OccNumber (send (ch),o,t) = OccNumber (rec (ch),o,t) + N END AsynBoundBuf 6 Concluding Remarks Other applications of PVS often concern the use of this tool during the early phases of system design, when the requirements are formulated and formalized <ref> [Rus95] </ref>. This is motivated by the fact that most errors are often due to mistakes in the requirements specification and high-level design. To investigate a requirements specification one can try to prove so-called putative theorems stating properties that ought to hold in the system.
Reference: [SO98] <author> M. Schenke and E.-R. Olderog. </author> <title> Transformational design of real-time systems Part I: From requirements to program specification. </title> <journal> Acta Infor-matica, </journal> <note> to appear, </note> <year> 1998. </year>
Reference-contexts: The main ingredients of our formal framework have been formulated in the language of PVS. To be able to represent design steps formally, specifications and programming constructs can be mixed freely, similar to the untimed framework of [Old85, Zwi89] and more recent work on timed systems <ref> [SO98] </ref>. This allows, e.g., the parallel composition of specifications. By means of refinement steps, justified by proof rules, specifications can be transformed into complete 1 PVS is free available, see http://www.csl.sri.com/sri-csl-pvs.html programs.
Reference: [VH96] <author> J. Vitt and J. Hooman. </author> <title> Assertional specification and verification using PVS of the steam boiler control system. </title> <editor> In J.-R. Abrial, E. Borger, and H. Langmaack, editors, </editor> <title> Formal Methods for Industrial Applications: </title> <booktitle> Specifying and Programming the Steam Boiler Control, </booktitle> <pages> pages 453-472. </pages> <publisher> LNCS 1165, Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The resulting PVS framework (see [Hoo94b]) has been applied to sev-eral examples, including the RPC-Memory specification problem [Hoo96], part of the ACCESS.bus protocol [Hoo95], a steam boiler control system <ref> [VH96] </ref>, and a membership protocol for a dynamic network with node failures and local clocks [Hoo97] 2 . As a start, these examples were verified using a simplified version of the formal framework.
Reference: [Zwi89] <author> J. Zwiers. </author> <title> Compositionality, Concurrency and Partial Correctness. </title> <publisher> LNCS 321, Springer-Verlag, </publisher> <year> 1989. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: The main ingredients of our formal framework have been formulated in the language of PVS. To be able to represent design steps formally, specifications and programming constructs can be mixed freely, similar to the untimed framework of <ref> [Old85, Zwi89] </ref> and more recent work on timed systems [SO98]. This allows, e.g., the parallel composition of specifications. By means of refinement steps, justified by proof rules, specifications can be transformed into complete 1 PVS is free available, see http://www.csl.sri.com/sri-csl-pvs.html programs. <p> The next two sections deal with parallel composition. The aim is to obtain a rule where the commitment of a parallel composition is essentially the conjunction of the commitments of the components, inspired by similar rules for untimed systems (see, e.g., <ref> [Old85, Zwi89] </ref>). 4.1 The Consequence Rule To allow weakening of commitments and strengthening of assumptions, the usual consequence rule is proved as a theorem in PVS.
References-found: 18

