URL: http://shiva.di.uminho.pt/%7Ecbm/ps/cbm-fsm-4-2-0001.ps
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fmescbm,fsmg@di.uminho.pt  
Title: Concurrency Annotations in C++  
Author: Carlos Baquero Francisco Moura 
Note: Financed by JNICT grant BM92 3556 IA. Part of this work was supported by JNICT PMCT 163/90.  
Date: February 4, 1994  
Address: 4700 Braga, Portugal  
Affiliation: DI INESC Universidade do Minho  
Abstract: This paper describes CA/C++, Concurrency Annotations in C++, a language extension that regulates method invocations from multiple threads of execution in a shared-memory multiprocessor system. This system provides threads as an orthogonal element to the language, allowing them to travel through more than one object. Statically type-ckecked synchronous and asynchronous method invocations are supported, with return values from asynchronous invocations accessed through first class future-like objects. Method invocations are regulated with synchronization code defined in a separate class hierarchy, allowing separate definition and inheritance of synchronization mechanisms. Each method is protected by an access flag that can be switched in pre and post-actions, and by a predicate. Both must evaluate to true in order to enable a thread to animate the method code. Flags and method predicates are independently redefinable along the inheritance chain, thus avoiding the inheritance anomaly. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Pierre America. </author> <title> A parallel object-oriented language with inheritance and subtyping. </title> <booktitle> In ECOOP/OOPSLA'90, </booktitle> <pages> pages 161-168. </pages> <institution> Philips Research Laboratories, ACM, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: 1 Introduction In the past, several approaches to concurrent object-oriented programming (COOP) raised the inheritance anomaly [10, 8], which restricts reuse by inheritance in the presence of synchronization code. Initial proposals to COOP were in fact largely exposed to this anomaly <ref> [6, 16, 1, 3] </ref>. Partial solutions to this problem were sought through (a) the separation of synchronization code and its reuse by inheritance [12, 15, 10] and (b) the first classing of synchronization code elements [5, 11].
Reference: [2] <author> G. R. Andrews and F. B. Schnider. </author> <title> Concepts and notations for concurrent programming. </title> <journal> ACM Computing Surveys, </journal> <volume> 15(1) </volume> <pages> 3-43, </pages> <month> March </month> <year> 1983. </year>
Reference-contexts: This is denoted by the pre-action @pop-; @push-; and its corresponding post-action (figure 2). This is the traditional mutual exclusion synchronization that is necessary regardless of the stack internal state. Condition synchronization <ref> [2] </ref> is necessary for expressing state-dependent semantics, for example to delay a pop invocation on an empty stack. In CA/C++ this is achieved with the predicate. Note that unlike traditional guards and guarded commands, these predicates can be refined in derived classes, and are clearly separated from operational code.
Reference: [3] <author> Jan Van Den Bos and Chris Laffra. </author> <title> Procol, a parallel object language with protocols. </title> <booktitle> In OOPSLA '89 Proceedings, </booktitle> <pages> pages 95-102, </pages> <address> P.O. Box 9512, 2300 RA Leiden, The Netherlands, </address> <month> October </month> <year> 1989. </year> <institution> University of Leiden, Department of Computer Science, ACM. </institution>
Reference-contexts: 1 Introduction In the past, several approaches to concurrent object-oriented programming (COOP) raised the inheritance anomaly [10, 8], which restricts reuse by inheritance in the presence of synchronization code. Initial proposals to COOP were in fact largely exposed to this anomaly <ref> [6, 16, 1, 3] </ref>. Partial solutions to this problem were sought through (a) the separation of synchronization code and its reuse by inheritance [12, 15, 10] and (b) the first classing of synchronization code elements [5, 11].
Reference: [4] <author> Gilad Bracha and William Cook. </author> <title> Mixin-based inheritance. </title> <booktitle> In ECOOP/OOPSLA '90 Proceedings, </booktitle> <pages> pages 303-311. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1990. </year>
Reference-contexts: This extension, presented in figure 6, is a typical use of generic mixin classes <ref> [4] </ref> in multiple inheritance schemes, although not as generic as mixin classes, it shows how this behavior can be provided whenever needed.
Reference: [5] <author> Dennis G. Kafura and R. Greg Lavender. </author> <title> Concurrent object-oriented languages and the inheritance anomaly. </title> <booktitle> In ISIPCALA'93, </booktitle> <pages> pages 183,213, </pages> <year> 1993. </year>
Reference-contexts: Initial proposals to COOP were in fact largely exposed to this anomaly [6, 16, 1, 3]. Partial solutions to this problem were sought through (a) the separation of synchronization code and its reuse by inheritance [12, 15, 10] and (b) the first classing of synchronization code elements <ref> [5, 11] </ref>. Recently the use of multiple synchronization schemes in the same language was advocated, allowing the programmer to choose the most appropriate scheme for each case [9, 8]. CA/C++ follows these ideas and provides two distinct synchronization mechanisms, thereby regulating both internal and external concurrency. <p> The client thread proceeds in parallel, though it can synchronize with the spanned thread and receive the results of the invocation by means of a future-like object. Note that all asynchronous interaction can be statically type-checked at compile time. According to Kafura and Lavender's taxonomy of COOP <ref> [5] </ref> (which extends previous surveys [14, 13]), CA/C++ is classified as an unrelated language in the animation model. This means that threads are not confined to the object boundaries but are able to animate several objects during their lifetime. As a result, threads represent an orthogonal element to the language. <p> As a result, threads represent an orthogonal element to the language. Since concurrency is external to the objects, simultaneous access to an object's state by multiple threads must now be synchronized. By contrast, recent proposals that cope with the inheritance anomaly, specially those derived from the Actor model <ref> [5] </ref>, are classified as related approaches because threads exist only within an object. <p> Concurrency annotations are specified by a small amount of code and require less knowledge about the inherited synchronization code (annotations) than the approaches based on named sets of methods such as those present in ABCL/R2 [9, 8] and some Actor languages <ref> [5, 16] </ref>. It contemplates synchronization schemes for both internal and external concurrency, raising a new 2 class Stack - protected: // private stuff public: void push (); void pop (); -; // client code ... Stack a, *pa=&a; a.push (); pa-&gt;pop (); perspective of the problem. <p> RRStack : public RStack - state: - int calls; - start: - calls=0; @stat+; @empty+; - empty () -- stat () - cond: return ( calls&gt;=100 ); - - pop2 () post:- calls++ ; - push () post:- calls++ ; - pop () post:- calls++ ; - - 9 sets <ref> [5, 9] </ref> require much more information about the previous synchroniza-tion code, since new methods must be added to existing sets or force some set's redefinition.
Reference: [6] <author> Dennis G. Kafura and Keung Hae Lee. </author> <title> Inheritance in actor based con-current object-oriented languages. </title> <booktitle> In ECOOP'89 Proceedings, </booktitle> <pages> pages 131-145. </pages> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction In the past, several approaches to concurrent object-oriented programming (COOP) raised the inheritance anomaly [10, 8], which restricts reuse by inheritance in the presence of synchronization code. Initial proposals to COOP were in fact largely exposed to this anomaly <ref> [6, 16, 1, 3] </ref>. Partial solutions to this problem were sought through (a) the separation of synchronization code and its reuse by inheritance [12, 15, 10] and (b) the first classing of synchronization code elements [5, 11].
Reference: [7] <author> Svend Frtlund. </author> <title> Inheritance of synchronization constraints in concurrent object-oriented programming languages. </title> <booktitle> In ECOOP '92 Proceedings, </booktitle> <pages> pages 185-196, </pages> <publisher> 1304 W. </publisher> <address> Springfield Avenue, Urbana, IL 61801, USA, </address> <year> 1992. </year> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, Springer-Verlag. </institution>
Reference-contexts: Its omission leads to a redefinition of the method predicate; this conjunction creates a more restrictive predicate, similar to the ones proposed by Frolund <ref> [7] </ref>. 5 Conclusions The current version of the CA/C++ translator uses the threads package of Solaris 2.3 on a SparcCenter 2000.
Reference: [8] <author> Satoshi Matsuoka. </author> <title> Language Features for Re-use and Extensibility in Concurrent Object-Oriented Programming. </title> <type> PhD thesis, </type> <institution> Department of Information Science, The University of Tokyo, </institution> <address> 7-3-1 Hongo, Bunkyo-ku, Tokyo 113, Japan, </address> <month> April </month> <year> 1993. </year> <type> Thesis draft. </type>
Reference-contexts: 1 Introduction In the past, several approaches to concurrent object-oriented programming (COOP) raised the inheritance anomaly <ref> [10, 8] </ref>, which restricts reuse by inheritance in the presence of synchronization code. Initial proposals to COOP were in fact largely exposed to this anomaly [6, 16, 1, 3]. <p> Recently the use of multiple synchronization schemes in the same language was advocated, allowing the programmer to choose the most appropriate scheme for each case <ref> [9, 8] </ref>. CA/C++ follows these ideas and provides two distinct synchronization mechanisms, thereby regulating both internal and external concurrency. In CA/C++ method invocations on any object can be specified on the client code as synchronous or asynchronous. <p> Concurrency annotations are specified by a small amount of code and require less knowledge about the inherited synchronization code (annotations) than the approaches based on named sets of methods such as those present in ABCL/R2 <ref> [9, 8] </ref> and some Actor languages [5, 16]. It contemplates synchronization schemes for both internal and external concurrency, raising a new 2 class Stack - protected: // private stuff public: void push (); void pop (); -; // client code ...
Reference: [9] <author> Satoshi Matsuoka, Kenjiro Taura, and Akinori Yonezawa. </author> <title> Highly efficient and encapsulated re-use of synchronization code in concurrent object-oriented languages. In OOSPLA '93 Proceedings, </title> <journal> ACM SIG-PLAN Notices, </journal> <volume> volume 28, </volume> <pages> pages 109-126. </pages> <address> n, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: Recently the use of multiple synchronization schemes in the same language was advocated, allowing the programmer to choose the most appropriate scheme for each case <ref> [9, 8] </ref>. CA/C++ follows these ideas and provides two distinct synchronization mechanisms, thereby regulating both internal and external concurrency. In CA/C++ method invocations on any object can be specified on the client code as synchronous or asynchronous. <p> Concurrency annotations are specified by a small amount of code and require less knowledge about the inherited synchronization code (annotations) than the approaches based on named sets of methods such as those present in ABCL/R2 <ref> [9, 8] </ref> and some Actor languages [5, 16]. It contemplates synchronization schemes for both internal and external concurrency, raising a new 2 class Stack - protected: // private stuff public: void push (); void pop (); -; // client code ... <p> RRStack : public RStack - state: - int calls; - start: - calls=0; @stat+; @empty+; - empty () -- stat () - cond: return ( calls&gt;=100 ); - - pop2 () post:- calls++ ; - push () post:- calls++ ; - pop () post:- calls++ ; - - 9 sets <ref> [5, 9] </ref> require much more information about the previous synchroniza-tion code, since new methods must be added to existing sets or force some set's redefinition.
Reference: [10] <author> Satoshi Matsuoka and Akinori Yonezawa. </author> <title> Analysis of inheritance anomaly in object-oriented concurrent programming languages. Research Directions in Concurrent Object Oriented Programming, </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction In the past, several approaches to concurrent object-oriented programming (COOP) raised the inheritance anomaly <ref> [10, 8] </ref>, which restricts reuse by inheritance in the presence of synchronization code. Initial proposals to COOP were in fact largely exposed to this anomaly [6, 16, 1, 3]. <p> Initial proposals to COOP were in fact largely exposed to this anomaly [6, 16, 1, 3]. Partial solutions to this problem were sought through (a) the separation of synchronization code and its reuse by inheritance <ref> [12, 15, 10] </ref> and (b) the first classing of synchronization code elements [5, 11]. Recently the use of multiple synchronization schemes in the same language was advocated, allowing the programmer to choose the most appropriate scheme for each case [9, 8].
Reference: [11] <author> Jose Meseguer. </author> <title> Solving the inheritance anomaly in concurrent object-oriented programming. </title> <type> Technical report, </type> <institution> Computer Science Laboratory, SRI International, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: Initial proposals to COOP were in fact largely exposed to this anomaly [6, 16, 1, 3]. Partial solutions to this problem were sought through (a) the separation of synchronization code and its reuse by inheritance [12, 15, 10] and (b) the first classing of synchronization code elements <ref> [5, 11] </ref>. Recently the use of multiple synchronization schemes in the same language was advocated, allowing the programmer to choose the most appropriate scheme for each case [9, 8]. CA/C++ follows these ideas and provides two distinct synchronization mechanisms, thereby regulating both internal and external concurrency.
Reference: [12] <author> Christian Neusius. </author> <title> Synchronizing actions. </title> <booktitle> In ECOOP '91 Proceedings, </booktitle> <pages> pages 118-132. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Initial proposals to COOP were in fact largely exposed to this anomaly [6, 16, 1, 3]. Partial solutions to this problem were sought through (a) the separation of synchronization code and its reuse by inheritance <ref> [12, 15, 10] </ref> and (b) the first classing of synchronization code elements [5, 11]. Recently the use of multiple synchronization schemes in the same language was advocated, allowing the programmer to choose the most appropriate scheme for each case [9, 8].
Reference: [13] <author> M. Papathomas. </author> <title> Concurrency issues in object-oriented programming languages. </title> <type> Technical report, </type> <address> s, </address> <year> 1989. </year>
Reference-contexts: Note that all asynchronous interaction can be statically type-checked at compile time. According to Kafura and Lavender's taxonomy of COOP [5] (which extends previous surveys <ref> [14, 13] </ref>), CA/C++ is classified as an unrelated language in the animation model. This means that threads are not confined to the object boundaries but are able to animate several objects during their lifetime. As a result, threads represent an orthogonal element to the language.
Reference: [14] <author> Michael Papathomas and Oscar Nierstrasz. </author> <title> Supporting software reuse in concurrent object-oriented languages: Exploring the language design space. </title> <type> Technical report, </type> <year> 1990. </year> <month> 13 </month>
Reference-contexts: Note that all asynchronous interaction can be statically type-checked at compile time. According to Kafura and Lavender's taxonomy of COOP [5] (which extends previous surveys <ref> [14, 13] </ref>), CA/C++ is classified as an unrelated language in the animation model. This means that threads are not confined to the object boundaries but are able to animate several objects during their lifetime. As a result, threads represent an orthogonal element to the language.
Reference: [15] <author> S. Crespi Reghizzi, G. Galli de Paratesi, and S. Genolini. </author> <title> Definition of reusable concurrent software components. </title> <booktitle> In ECOOP '91 Proceedings, </booktitle> <pages> pages 148-166. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Initial proposals to COOP were in fact largely exposed to this anomaly [6, 16, 1, 3]. Partial solutions to this problem were sought through (a) the separation of synchronization code and its reuse by inheritance <ref> [12, 15, 10] </ref> and (b) the first classing of synchronization code elements [5, 11]. Recently the use of multiple synchronization schemes in the same language was advocated, allowing the programmer to choose the most appropriate scheme for each case [9, 8].
Reference: [16] <author> Chris Tomlinson and Vineet Singh. </author> <title> Inheritance and synchronization with enabled-sets. </title> <booktitle> In OOPSLA '89 Proceedings, </booktitle> <pages> pages 103-112, </pages> <address> 3500 West Balcones Center Drive, Austin, Texa 78759, </address> <month> October </month> <year> 1989. </year> <title> MCC, </title> <journal> ACM. </journal> <volume> 14 </volume>
Reference-contexts: 1 Introduction In the past, several approaches to concurrent object-oriented programming (COOP) raised the inheritance anomaly [10, 8], which restricts reuse by inheritance in the presence of synchronization code. Initial proposals to COOP were in fact largely exposed to this anomaly <ref> [6, 16, 1, 3] </ref>. Partial solutions to this problem were sought through (a) the separation of synchronization code and its reuse by inheritance [12, 15, 10] and (b) the first classing of synchronization code elements [5, 11]. <p> Concurrency annotations are specified by a small amount of code and require less knowledge about the inherited synchronization code (annotations) than the approaches based on named sets of methods such as those present in ABCL/R2 [9, 8] and some Actor languages <ref> [5, 16] </ref>. It contemplates synchronization schemes for both internal and external concurrency, raising a new 2 class Stack - protected: // private stuff public: void push (); void pop (); -; // client code ... Stack a, *pa=&a; a.push (); pa-&gt;pop (); perspective of the problem.
References-found: 16

