URL: http://www-sal.cs.uiuc.edu/~harrison/pubs/research/proposal.ps.Z
Refering-URL: http://www-sal.cs.uiuc.edu/~harrison/pubs/research/research.html
Root-URL: http://www.cs.uiuc.edu
Email: harrison@cs.uiuc.edu  
Title: Deriving Compilers from Monadic Semantics  
Author: William L. Harrison 
Date: November 26, 1997  
Address: 1304 West Springfield Avenue, Urbana, Illinois, 61801-2987  
Affiliation: Department of Computer Science University of Illinois, Urbana-Champaign  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: compilation semantics, respectively. 9 Output from partial evaluator: (lambda (halt store add negate read) (lambda (a0) (lambda (sto1) (cons (cons ((store 1 (negate (read 0))) ((store 0 1) sto1)) 2) ((store "ACC" (negate (read 1))) ((store 1 (negate (read 0))) ((store 0 1) sto1))))))) Pretty printed version: [0] := 1; <ref> [1] </ref> := -[0]; Acc := -[1]; n 2 Numeral c 2 Cmd ::= c 1 ;c 2 j Addr:=Exp j if Bool then c t 2 Exp ::= n, b 2 Bool ::= T rue j F alse j not b j bor b 0 To produce code, we residualize updates <p> : unit (c:c bind : inEnv [s 7! unit ] C [[t]]) C [[ v s : intexp: t]] = newAddr bind a: rdEnv bind : unit (c:c bind : (v:updateloc (a; v)) bind : inEnv [s 7! unit (fi:fi (reada))] C [[t]]) CBN evaluation: CBV evaluation: [0] := 1; <ref> [1] </ref> := 1; [2] := [0]+[1]; [3] := [1]+[2]; [4] := [2]+[3]; [5] := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; 18 let p = let f = x: x + s in (g 5) CBN + static scope: <p> s ; fi c &gt; :updateSto (: ) bind (: fi s ( l)) Source Code: new g:intvar in let f = v: intvar: e: intexp: v := 1 + e ; v := (g + 1) + e in f g (g + 1) Target Code: [0] := 0; <ref> [1] </ref> := [0]+1; [0] := 1+[1]; [1] := [0]+1; [2] := [0]+1; [0] := [1]+[2]; 6.1 Recursive Bindings In Section 5.4, procedures were compiled via inlining, but that approach will not suffice for recursive bindings. <p> (: ) bind (: fi s ( l)) Source Code: new g:intvar in let f = v: intvar: e: intexp: v := 1 + e ; v := (g + 1) + e in f g (g + 1) Target Code: [0] := 0; <ref> [1] </ref> := [0]+1; [0] := 1+[1]; [1] := [0]+1; [2] := [0]+1; [0] := [1]+[2]; 6.1 Recursive Bindings In Section 5.4, procedures were compiled via inlining, but that approach will not suffice for recursive bindings. Furthermore, inlining may, in some cases, drastically increase target code size for non-recursive procedures, so some alternative method may be desirable. <p> ]] = rdEnv bind : inEnv [ 7! fix (:[[c]])] [[c 0 ]] C [[letrec c : comm in c 0 ]] = rdEnv bind : currentFrame bind f: newlabel bind L c : C [[c]] bind : newSegment (L c ; inEnv [ 7! mkCall L c f] (return <ref> [f + 1; 1] </ref>)) bind : inEnv [ 7! mkCall L c f] C [[c 0 ]] mkCall L c f = newlabel bind L : unit: newSegment (L ; ) bind : updateSto ([f + 1; 1] 7! L ) bind : call L c call L c = rdSeg <p> call L c = rdSeg L c return [f; e] = rdloc [f; e] bind L :rdSegL rdSeg L = updateC (:) bind :l currentFrame = updateA (a:a) bind &lt;f; d&gt;:unitf locations are non-negative integer pairs &lt; f rame; disp &gt;, which may be thought of as a display address <ref> [1] </ref>, or alternatively, as a stack shape [24]. Intuitively, f rame points to an activation record and disp is an offset within that record. Following Reynolds [24], we assume each activation record has a call block where the labels of argument parameters are stored. <p> Heretofore, we have not precisely defined what our target language is. Figure 23 gives the syntax and direct-style semantics for the machine language fragment necessary to compile expressions. Observe that the "pretty-printed" version of the residualized semantic term in Figure 5: 26 [0] := 1; <ref> [1] </ref> := -[0]; Acc := -[1]; is a M achLang program (referred to as hereafter). We will argue that this particular compilation is correct, and suggest how a proof of compiler correctness may follow along similar lines.
Reference: [2] <author> H. Christiansen and Neil Jones. </author> <title> Control Flow Treatment in a Simple Semantics-directed Compiler Generator. Formal Description of Programming Concepts II, </title> <publisher> North-Holland Publishing Company 1983. </publisher>
Reference-contexts: newlabel bind L end : unit : newSegment (L end ; ) bind : newSegment (L test ; fi &lt;jump L c ; jump L end &gt;) bind : newSegment (L c ; fC [[c]];jumpL end g) bind : jump L test 15 0: jump 1; 1: [0] := 1; <ref> [2] </ref> := [0]+[1]; [4] := [2]+[3]; jump 2; 2: halt; 5.3 Combining Simple Expressions with Control Flow The additional "intermediate data structure" occuring in the compilation semantics for the simple expression language of Subsection 5.1 was the type Addr of addresses and the type Sto of integer storage. <p> bind : inEnv [s 7! unit ] C [[t]]) C [[ v s : intexp: t]] = newAddr bind a: rdEnv bind : unit (c:c bind : (v:updateloc (a; v)) bind : inEnv [s 7! unit (fi:fi (reada))] C [[t]]) CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; <ref> [2] </ref> := [0]+[1]; [3] := [1]+[2]; [4] := [2]+[3]; [5] := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; 18 let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic <p> <ref> [2] </ref>+[3]; [5] := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; 18 let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5; [2] := [0]+[1]; [2] := [0]+[1]; ACC := [2]+[3]; ACC := [2]+[3]; i 2 Var n 2 Numeral c 2 Cmd ::= new Var:intvar in c j c 1 ; c 2 j i := e j skip j if b then c 1 else c 1 e 2 Exp ::= <p> [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; 18 let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5; <ref> [2] </ref> := [0]+[1]; [2] := [0]+[1]; ACC := [2]+[3]; ACC := [2]+[3]; i 2 Var n 2 Numeral c 2 Cmd ::= new Var:intvar in c j c 1 ; c 2 j i := e j skip j if b then c 1 else c 1 e 2 Exp ::= n j i <p> Both semantics for and = are very similar to those of addition, and so have not been included for reasons of space. An example is presented in Figure 19. Observe the use of temporary storage at <ref> [2] </ref> for the calculation of (g + 1) + e. 21 [[new i in c]] = unit (: rdEnv bind : allocLoc bind S: inEnv [i 7! unit &lt;set S; get S &gt;] [[c]] bind : (deAlloc bind :)) [[i := e]] = rdEnv bind : ( i) bind &lt;ia; &gt; <p> (: fi s ( l)) Source Code: new g:intvar in let f = v: intvar: e: intexp: v := 1 + e ; v := (g + 1) + e in f g (g + 1) Target Code: [0] := 0; [1] := [0]+1; [0] := 1+[1]; [1] := [0]+1; <ref> [2] </ref> := [0]+1; [0] := [1]+[2]; 6.1 Recursive Bindings In Section 5.4, procedures were compiled via inlining, but that approach will not suffice for recursive bindings. Furthermore, inlining may, in some cases, drastically increase target code size for non-recursive procedures, so some alternative method may be desirable. <p> number of constant assignments to the states Addr, Label, and CodeStore. 28 M achLang : 2 Stmt ::= 1 ; 2 j Addr := r j Acc := r r 2 Rhs ::= s j s 1 + s 2 j s s 2 Srhs ::= n j [Addr] M <ref> [[ 1 ; 2 ] </ref>] = M [[ 1 ]] bind ( :M [[ 2 ]]) M [[lhs:=r]] = M [[r]] bind (v:updateloc (lhs; v)) M [[s 1 + s 2 ]] = M [[s 1 ]] bind (v 1 :M [[s 2 ]] bind (v 2 :unit (v 1 +
Reference: [3] <author> C. Consel and O. Danvy. </author> <title> Static and Dynamic Semantics Processing. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: [s 7! unit ] C [[t]]) C [[ v s : intexp: t]] = newAddr bind a: rdEnv bind : unit (c:c bind : (v:updateloc (a; v)) bind : inEnv [s 7! unit (fi:fi (reada))] C [[t]]) CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; [2] := [0]+[1]; <ref> [3] </ref> := [1]+[2]; [4] := [2]+[3]; [5] := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; 18 let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := <p> An example is presented in Figure 14. The case of dynamic binding, when the body of f is evaluated, the most recent binding of s (i.e., 5) is stored in <ref> [3] </ref>, rather than the value of s when f was defined (i.e., 10). 6 Compilation of Idealized Algol is the language compiled by Reynolds in [24], and the compiler we derive is essentially identical to Reynolds for the non-recursive fragment.
Reference: [4] <author> O. Danvy. </author> <title> Type-Directed Partial Evaluation. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <year> 1996. </year>
Reference-contexts: This code generation technique is due to Danvy and Vestergaard [5]; we use Danvy's type-directed partial evaluator <ref> [4] </ref> to accomplish it. An example is presented in Figure 5. The "code" produced takes the form of a number of stores and reads from storage (it is underlined in the figure). <p> end : unit : newSegment (L end ; ) bind : newSegment (L test ; fi &lt;jump L c ; jump L end &gt;) bind : newSegment (L c ; fC [[c]];jumpL end g) bind : jump L test 15 0: jump 1; 1: [0] := 1; [2] := [0]+[1]; <ref> [4] </ref> := [2]+[3]; jump 2; 2: halt; 5.3 Combining Simple Expressions with Control Flow The additional "intermediate data structure" occuring in the compilation semantics for the simple expression language of Subsection 5.1 was the type Addr of addresses and the type Sto of integer storage. <p> ] C [[t]]) C [[ v s : intexp: t]] = newAddr bind a: rdEnv bind : unit (c:c bind : (v:updateloc (a; v)) bind : inEnv [s 7! unit (fi:fi (reada))] C [[t]]) CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; [2] := [0]+[1]; [3] := [1]+[2]; <ref> [4] </ref> := [2]+[3]; [5] := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; 18 let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] :=
Reference: [5] <author> O. Danvy and R. Vestergaard. </author> <title> Semantics-Based Compiling: A Case Study in Type-Directed Partial Evaluation. </title> <booktitle> Eighth International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <year> 1996, </year> <pages> pages 182-197. </pages>
Reference-contexts: They showed how compilers could be constructed by introducing intermediate data structures into an interpreter and then partially evaluating. Their interpreter had no monadic structure. Also, their derivations were non-automatic, as the introduction and exploitation of intermediate data structure was quite subtle. Danvy and Vestergaard <ref> [5] </ref> show how to produce code that "looks like" machine language, by expressing the source language semantics in terms of machine language-like combinators (e.g., "update", "popblock", "push"). <p> This code generation technique is due to Danvy and Vestergaard <ref> [5] </ref>; we use Danvy's type-directed partial evaluator [4] to accomplish it. An example is presented in Figure 5. The "code" produced takes the form of a number of stores and reads from storage (it is underlined in the figure). <p> C [[ v s : intexp: t]] = newAddr bind a: rdEnv bind : unit (c:c bind : (v:updateloc (a; v)) bind : inEnv [s 7! unit (fi:fi (reada))] C [[t]]) CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; [2] := [0]+[1]; [3] := [1]+[2]; [4] := [2]+[3]; <ref> [5] </ref> := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; 18 let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5; [2] :=
Reference: [6] <author> D. Espinosa. </author> <title> Semantic Lego. </title> <type> Doctoral Dissertation, </type> <institution> Columbia University, </institution> <year> 1995. </year>
Reference-contexts: Monads and monad transformers have been used in the past to structure denotational definitions <ref> [16, 6, 27, 18] </ref> where they allow a mix-and-match (what Espinosa calls a "semantic lego") approach. It is argued here that similar benefits can be obtained for compilers. This method of compiler generation can be summarized as: 1. Start with a monad-structured semantics. <p> I propose to fulfill my doctoral research by proving the correctness 2 of the compilers developed here following the outline discussed in Section 7. 2 Related Work Structuring denotational semantics with monads and monad transformers was originally proposed by Moggi [18]. Hudak, Liang, and Jones [16], Espinosa <ref> [6] </ref>, and Wadler [27] use monads and monad transformers to create modular, extensible interpreters. This work shows how interpreters can be developed in a modular way, leaving open the question of whether compilers can be developed similarly. <p> The pass separation transformations used here make fairly minimal changes to the standard semantic equations and result in a compilation semantics which is recognizably a more implementation-oriented version of the standard semantics. 3 Monads and Monad Transformers Recent work in semantics <ref> [27, 16, 6] </ref> indicates that the denotational semantics for languages can be constructed modularly using monads and monad transformers as building blocks. When applied to a monad M, a monad transformer T creates a new monad M 0 with some additional features (e.g., 4 states, environments, etc.). <p> These features are usually encapsulated by one or more combinators. For example, if T were the state transformer, a combinator: updateSto : (Sto ! Sto) ! M 0 Sto can be defined to manipulate the newly added state type Sto <ref> [16, 6] </ref>. The existing combinators of M are lifted through T meaning that they are redefined in a canonical manner for M 0 . <p> In this sense, it is similar to action semantics [21, 20] and high-level semantics [14]. However, monad transformers allow extensions to existing language specifications in a well-understood and canonical manner. For further background on monads and monad transformers, please see <ref> [27, 16, 6] </ref>. For our purposes, a monad M can be viewed as a type constructor with two operations unit : t ! M t and bind : M t 1 fi (t 1 ! M t 2 ) ! M t 2 which obey certain laws [27, 16, 6]. <p> transformers, please see <ref> [27, 16, 6] </ref>. For our purposes, a monad M can be viewed as a type constructor with two operations unit : t ! M t and bind : M t 1 fi (t 1 ! M t 2 ) ! M t 2 which obey certain laws [27, 16, 6]. The simplest monad is the identity monad Id, which is defined in Figure 1. Monads can be constructed from other monads using monad transformers. Two transformers used frequently in this work are the environment transformer EnvT and the state transformer StateT. <p> s : intexp: t]] = newAddr bind a: rdEnv bind : unit (c:c bind : (v:updateloc (a; v)) bind : inEnv [s 7! unit (fi:fi (reada))] C [[t]]) CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; [2] := [0]+[1]; [3] := [1]+[2]; [4] := [2]+[3]; [5] := [3]+[4]; <ref> [6] </ref> := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; 18 let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5; [2] := [0]+[1]; [2] := <p> t]] = newAddr bind a: rdEnv bind : unit (c:c bind : (v:updateloc (a; v)) bind : inEnv [s 7! unit (fi:fi (reada))] C [[t]]) CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; [2] := [0]+[1]; [3] := [1]+[2]; [4] := [2]+[3]; [5] := [3]+[4]; <ref> [6] </ref> := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; 18 let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5; [2] := [0]+[1]; [2] := [0]+[1]; ACC := <p> Figure 20 contains the standard and compilation semantics for letrec and Figure 21 presents an example. 7 Correctness In the previous sections, we have developed a "mix-and-match" compilation method similar to the modular interpreter constructions of <ref> [16, 6, 27] </ref>. <p> The use of partial evaluation in the compiler clarifies the relationship between the compilation semantics and the machine language semantics. One of the remaining issues with this compilation method is to establish a formal correctness proof. Claims have been made <ref> [15, 17, 6] </ref> that proofs about monadic specifications retain some modularity as well, and a correctness proof of this method would be a good test of this assertion.
Reference: [7] <author> W. Harrison and S. Kamin. </author> <title> Compilation as Partial Evaluation of Functor Category Semantics. </title> <type> Unpublished manuscript. </type>
Reference: [8] <author> N. D. Jones and D. A. Schmidt. </author> <title> Compiler Generation from Denotational Semantics. </title> <editor> In N. D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, </booktitle> <address> LNCS94, </address> <year> 1980, </year> <pages> pages 70-93. </pages>
Reference-contexts: bind a: rdEnv bind : unit (c:c bind : (v:updateloc (a; v)) bind : inEnv [s 7! unit (fi:fi (reada))] C [[t]]) CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; [2] := [0]+[1]; [3] := [1]+[2]; [4] := [2]+[3]; [5] := [3]+[4]; [6] := 1 [6] := [0]; <ref> [8] </ref> := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; 18 let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5; [2] := [0]+[1]; [2] := [0]+[1]; ACC := [2]+[3]; ACC :=
Reference: [9] <author> N. D. Jones, C. K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> Prentice-Hall International Series in Computer Science, Prentice-Hall 1993. </booktitle>
Reference-contexts: 1 Introduction This proposal addresses the classic problem of generating compilers from denotational specifications of programming languages. A compilation method is developed systematically using three tools: * monadic semantics structured with monad transformers [16], * pass separation [12], and * partial evaluation <ref> [9] </ref> Partial evaluation and pass separation have long been used in semantics-directed compilation, but the use of monadic semantics and monad transformers is new in this setting. <p> Monad transformers also come equipped with lift operators for lifting computations in M into the newly created M 0 , and also with operation (s) for manipulating the newly added feature. 4 Partial Evaluation Partial evaluation <ref> [9] </ref> is a program transformation technique which takea a program p (x,y) and part of its input x and returns a specialized version of p (sometimes written p x ). Given x, parts 1 Some care must be taken in the order of application of monad transformers.
Reference: [10] <author> N. D. Jones, P. Sestoft, and H. Sondergaard. </author> <title> An Experiment in Partial Evaluation: The Generation of a Compiler Generator. </title> <booktitle> Proceedings of the First International Conference on Rewriting Techniques and Applications, </booktitle> <month> May </month> <year> 1985. </year> <month> 29 </month>
Reference-contexts: (c:c bind : (v:updateloc (a; v)) bind : inEnv [s 7! unit (fi:fi (reada))] C [[t]]) CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; [2] := [0]+[1]; [3] := [1]+[2]; [4] := [2]+[3]; [5] := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; <ref> [10] </ref> := [8]+[9]; ACC := [5]+[11]; 18 let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5; [2] := [0]+[1]; [2] := [0]+[1]; ACC := [2]+[3]; ACC := [2]+[3]; i 2 Var n 2
Reference: [11] <author> N. D. Jones, P. Sestoft, and H. Sondergaard. </author> <title> MIX: A Self-applicable Partial Evaluator for Experiments in Compiler Generation. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2, </volume> <month> 9-50 </month> <year> (1989). </year>
Reference: [12] <author> U. Jorring and W. </author> <title> Scherlis. </title> <booktitle> Compilers and Staging Transformations Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <year> 1986. </year>
Reference-contexts: 1 Introduction This proposal addresses the classic problem of generating compilers from denotational specifications of programming languages. A compilation method is developed systematically using three tools: * monadic semantics structured with monad transformers [16], * pass separation <ref> [12] </ref>, and * partial evaluation [9] Partial evaluation and pass separation have long been used in semantics-directed compilation, but the use of monadic semantics and monad transformers is new in this setting. <p> Liang's work is the most closely related to ours, but since he does not compile to machine language, many of the issues we confront|especially pass separation|do not arise. Jorring and Scherlis <ref> [12] </ref> introduced the term "pass separation", which they defined as: The idea of pass separation is to introduce intermediate data structure to pass values between two phases of computation, enabling separation of the two phases. <p> Assuming that the standard semantics is written in terms of a monad M, where M = T ID for the monad transformer T and identity monad ID, we can add the intermediate data structure for pass separation <ref> [12] </ref> by substituting a "larger" monad than ID in the definition of M, and lifting the additional combinators through T . So the new monad is defined as: M c = T (StateT Addr (StateT Sto ID)) where Addr = int and Sto = Addr ! int 2 .
Reference: [13] <author> R. Kelsey and P. Hudak. </author> <title> Realistic Compilation by Program Transformation. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference: [14] <author> P. Lee. </author> <title> Realistic Compiler Generation. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Monadic semantics separate the description of a language (i.e., its specification) from its definition (i.e., its denotation or underlying model). In this sense, it is similar to action semantics [21, 20] and high-level semantics <ref> [14] </ref>. However, monad transformers allow extensions to existing language specifications in a well-understood and canonical manner. For further background on monads and monad transformers, please see [27, 16, 6]. <p> One of the advantages of the monadic approach is that the underlying denotational model can be made arbitrarily complex through application of monad transformers without complicating the denotational description unnecessarily, and because of this separability as Lee calls it <ref> [14] </ref>, monadic specifications are a natural setting for pass separation. The use of partial evaluation in the compiler clarifies the relationship between the compilation semantics and the machine language semantics. One of the remaining issues with this compilation method is to establish a formal correctness proof.
Reference: [15] <author> S. Liang. </author> <title> A Modular Semantics for Compiler Generation. </title> <institution> Yale University Department of Computer Science Technical Report TR-1067, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: Hudak, Liang, and Jones [16], Espinosa [6], and Wadler [27] use monads and monad transformers to create modular, extensible interpreters. This work shows how interpreters can be developed in a modular way, leaving open the question of whether compilers can be developed similarly. Liang <ref> [15, 17] </ref> addresses that question, proposing that monadic semantics constructed from monad transformers and monadic specifications provide a modular and extensible basis for semantics-directed compilation. <p> The use of partial evaluation in the compiler clarifies the relationship between the compilation semantics and the machine language semantics. One of the remaining issues with this compilation method is to establish a formal correctness proof. Claims have been made <ref> [15, 17, 6] </ref> that proofs about monadic specifications retain some modularity as well, and a correctness proof of this method would be a good test of this assertion.
Reference: [16] <author> S. Liang, P. Hudak, and M. Jones. </author> <title> Monad Transformers and Modular Interpreters. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <year> 1995. </year>
Reference-contexts: 1 Introduction This proposal addresses the classic problem of generating compilers from denotational specifications of programming languages. A compilation method is developed systematically using three tools: * monadic semantics structured with monad transformers <ref> [16] </ref>, * pass separation [12], and * partial evaluation [9] Partial evaluation and pass separation have long been used in semantics-directed compilation, but the use of monadic semantics and monad transformers is new in this setting. <p> Monads and monad transformers have been used in the past to structure denotational definitions <ref> [16, 6, 27, 18] </ref> where they allow a mix-and-match (what Espinosa calls a "semantic lego") approach. It is argued here that similar benefits can be obtained for compilers. This method of compiler generation can be summarized as: 1. Start with a monad-structured semantics. <p> It is argued here that similar benefits can be obtained for compilers. This method of compiler generation can be summarized as: 1. Start with a monad-structured semantics. More precisely, the semantics is based on monad transformers <ref> [16] </ref>. 2. If pass separation requires an intermediate data structure (e.g., labels, addresses, code seg ments), it is added by applying a state monad transformer. 3. <p> I propose to fulfill my doctoral research by proving the correctness 2 of the compilers developed here following the outline discussed in Section 7. 2 Related Work Structuring denotational semantics with monads and monad transformers was originally proposed by Moggi [18]. Hudak, Liang, and Jones <ref> [16] </ref>, Espinosa [6], and Wadler [27] use monads and monad transformers to create modular, extensible interpreters. This work shows how interpreters can be developed in a modular way, leaving open the question of whether compilers can be developed similarly. <p> The pass separation transformations used here make fairly minimal changes to the standard semantic equations and result in a compilation semantics which is recognizably a more implementation-oriented version of the standard semantics. 3 Monads and Monad Transformers Recent work in semantics <ref> [27, 16, 6] </ref> indicates that the denotational semantics for languages can be constructed modularly using monads and monad transformers as building blocks. When applied to a monad M, a monad transformer T creates a new monad M 0 with some additional features (e.g., 4 states, environments, etc.). <p> These features are usually encapsulated by one or more combinators. For example, if T were the state transformer, a combinator: updateSto : (Sto ! Sto) ! M 0 Sto can be defined to manipulate the newly added state type Sto <ref> [16, 6] </ref>. The existing combinators of M are lifted through T meaning that they are redefined in a canonical manner for M 0 . <p> In this sense, it is similar to action semantics [21, 20] and high-level semantics [14]. However, monad transformers allow extensions to existing language specifications in a well-understood and canonical manner. For further background on monads and monad transformers, please see <ref> [27, 16, 6] </ref>. For our purposes, a monad M can be viewed as a type constructor with two operations unit : t ! M t and bind : M t 1 fi (t 1 ! M t 2 ) ! M t 2 which obey certain laws [27, 16, 6]. <p> transformers, please see <ref> [27, 16, 6] </ref>. For our purposes, a monad M can be viewed as a type constructor with two operations unit : t ! M t and bind : M t 1 fi (t 1 ! M t 2 ) ! M t 2 which obey certain laws [27, 16, 6]. The simplest monad is the identity monad Id, which is defined in Figure 1. Monads can be constructed from other monads using monad transformers. Two transformers used frequently in this work are the environment transformer EnvT and the state transformer StateT. <p> Given x, parts 1 Some care must be taken in the order of application of monad transformers. Cf. <ref> [16] </ref> 5 Identity Monad Id: Idt = t unit Id x = x xbind Id f = fx Environment Monad Transformer EnvT: M 0 t = EnvT env M t = env ! Mt unit M 0 x = : env: unit M x x bind M 0 f = : <p> However, it is quite simple to add address allocation and store using the state monad transformer <ref> [16, 27] </ref>. In the parlance of pass separation, the addresses and storage are intermediate data structures. We do not claim that the standard monadic definition in Figure 3 can be used to obtain machine language programs. <p> Semantically, this requires that environments be added to the underlying monad, and we accomplish this by applying the environment monad transformer EnvT <ref> [16] </ref>. <p> Figure 20 contains the standard and compilation semantics for letrec and Figure 21 presents an example. 7 Correctness In the previous sections, we have developed a "mix-and-match" compilation method similar to the modular interpreter constructions of <ref> [16, 6, 27] </ref>.
Reference: [17] <author> S. Liang. </author> <title> Modular Monadic Semantics and Compilation. </title> <type> Doctoral Thesis, </type> <institution> Yale University, </institution> <year> 1997. </year>
Reference-contexts: Hudak, Liang, and Jones [16], Espinosa [6], and Wadler [27] use monads and monad transformers to create modular, extensible interpreters. This work shows how interpreters can be developed in a modular way, leaving open the question of whether compilers can be developed similarly. Liang <ref> [15, 17] </ref> addresses that question, proposing that monadic semantics constructed from monad transformers and monadic specifications provide a modular and extensible basis for semantics-directed compilation. <p> As an example of reasoning in monadic style, he axiomatizes the environment combinators rdEnv and inEnv, shows that these axioms hold in any monad constructed with standard monad transformers, and proves a small theorem. He describes an experiment in <ref> [17] </ref> wherein the Glasgow Haskell compiler is retargeted to the SML/NJ back-end, and develops many examples of reasoning about monadic specifications. Liang's work is the most closely related to ours, but since he does not compile to machine language, many of the issues we confront|especially pass separation|do not arise. <p> The use of partial evaluation in the compiler clarifies the relationship between the compilation semantics and the machine language semantics. One of the remaining issues with this compilation method is to establish a formal correctness proof. Claims have been made <ref> [15, 17, 6] </ref> that proofs about monadic specifications retain some modularity as well, and a correctness proof of this method would be a good test of this assertion.
Reference: [18] <author> E. Moggi. </author> <title> An Abstract View of Programming Languages. </title> <type> Technical Report ECS-LFCS-90-113, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <year> 1990. </year>
Reference-contexts: Monads and monad transformers have been used in the past to structure denotational definitions <ref> [16, 6, 27, 18] </ref> where they allow a mix-and-match (what Espinosa calls a "semantic lego") approach. It is argued here that similar benefits can be obtained for compilers. This method of compiler generation can be summarized as: 1. Start with a monad-structured semantics. <p> I propose to fulfill my doctoral research by proving the correctness 2 of the compilers developed here following the outline discussed in Section 7. 2 Related Work Structuring denotational semantics with monads and monad transformers was originally proposed by Moggi <ref> [18] </ref>. Hudak, Liang, and Jones [16], Espinosa [6], and Wadler [27] use monads and monad transformers to create modular, extensible interpreters. This work shows how interpreters can be developed in a modular way, leaving open the question of whether compilers can be developed similarly.
Reference: [19] <author> F. L. </author> <title> Morris Advice on structuring compilers and proving them correct. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <year> 1973. </year>
Reference-contexts: So, if the same integer is being computed by C [[t]] and [[t]], then (2) will hold. 3. Proving the compiler's correctness from the correctness of the phrase types. 7.2 Relating C [[]] and M [[]] In <ref> [19, 26] </ref>, the correctness of a compiler from source language L to target language M achLang would be expressed by the following diagram: L compile - M achLang M source semantics ? encode - U target semantics where M and U are the possibly distinct source and target semantic models and <p> This is essentially the same diagram as occurs in <ref> [19, 26] </ref>, although, broadly speaking, the pass separations performed to produce C [[]] fold "encode" into the compilation semantics.
Reference: [20] <author> P. Mosses. </author> <title> Abstract semantic algebras! Formal description of programming concepts II, </title> <booktitle> IFIP IC-2 Working Conference, </booktitle> <editor> D. Bjorner, Ed., </editor> <publisher> North-Holland, Amsterdam, </publisher> <pages> 63-88. </pages>
Reference-contexts: Monadic semantics separate the description of a language (i.e., its specification) from its definition (i.e., its denotation or underlying model). In this sense, it is similar to action semantics <ref> [21, 20] </ref> and high-level semantics [14]. However, monad transformers allow extensions to existing language specifications in a well-understood and canonical manner. For further background on monads and monad transformers, please see [27, 16, 6].
Reference: [21] <author> P. Mosses. </author> <title> Action Semantics, </title> <booktitle> volume 26 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Monadic semantics separate the description of a language (i.e., its specification) from its definition (i.e., its denotation or underlying model). In this sense, it is similar to action semantics <ref> [21, 20] </ref> and high-level semantics [14]. However, monad transformers allow extensions to existing language specifications in a well-understood and canonical manner. For further background on monads and monad transformers, please see [27, 16, 6].
Reference: [22] <author> L. C. Paulson. </author> <title> Compiler Generation from Denotational Semantics. </title> <editor> In Bernard Lorho, editor, </editor> <booktitle> Methods and Tools for Compiler Construction, </booktitle> <pages> pages 219-250. </pages> <publisher> Cambridge University Press, </publisher> <year> 1984. </year>
Reference: [23] <author> J. Reynolds. </author> <title> The Essence of Algol Algorithmic Languages, </title> <booktitle> Proceedings of the International Symposium on Algorithmic Languages, </booktitle> <address> Amsterdam, </address> <month> October 26-29, </month> <year> 1981, </year> <pages> pp. 345-372. </pages>
Reference-contexts: Its standard semantics is presented in Figure 18. The integer variable i is bound to an acceptor-expresser pair as in <ref> [23] </ref>. In Figure 18, "set S" returns an integer acceptor which takes an integer value, assigns the value to location S, and continues with the program.
Reference: [24] <author> J. Reynolds. </author> <title> Using Functor Categories to Generate Intermediate Code. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <pages> pages 25-36, </pages> <year> 1995. </year>
Reference-contexts: We then define call-by-value and call-by-name procedures, and dynamic binding, as examples of the kinds of features that can be compiled in this modular fashion. Our final example is the idealized Algol compiled by Reynolds in <ref> [24] </ref>. Establishing the correctness of this method consists of two parts. Firstly, the relationship between the original "standard" semantics and the more implementation-oriented "compilation" semantics resulting from the pass separation transformations must be specified and demonstrated. <p> These combinators, then, constitute the target language 3 of the compiler. This approach is key to making the monadic structure useful for compilation. Reynolds <ref> [24] </ref> demonstration of how to produce efficient code in a compiler derived from the functor category semantics of an Algol-like language was an original inspiration for this study. <p> As in the first half of <ref> [24] </ref>, this compilation semantics corresponds to treating -expressions as open procedures, that is, procedures that are expanded like macros. Observe that the CBN standard and compilation semantics are identical (as is the case in [24]). <p> As in the first half of <ref> [24] </ref>, this compilation semantics corresponds to treating -expressions as open procedures, that is, procedures that are expanded like macros. Observe that the CBN standard and compilation semantics are identical (as is the case in [24]). <p> The case of dynamic binding, when the body of f is evaluated, the most recent binding of s (i.e., 5) is stored in [3], rather than the value of s when f was defined (i.e., 10). 6 Compilation of Idealized Algol is the language compiled by Reynolds in <ref> [24] </ref>, and the compiler we derive is essentially identical to Reynolds for the non-recursive fragment. <p> c (v 1 + v 2 ); &gt; The underlying monad for the compilation semantics for this language must contain all of the intermediate data structure included when the features were compiled in isolation in Section 5: EnvT env (StateT Addr (StateT Sto (StateT CodeStore (State label Id)))) As in <ref> [24] </ref>, expressions are divided into those requiring temporary storage and those that do not. We give each expression two continuations, a "simple" and a "complex" one. <p> Addition is defined analogously, although is more complicated due to the possibility that one or both of its arguments may require storage. While our method for compiling expressions results in similar code to that of Reynolds <ref> [24] </ref>, the use of double continuations is more straightforward, while yielding a fine-grained control of temporary storage. <p> return [f; e] = rdloc [f; e] bind L :rdSegL rdSeg L = updateC (:) bind :l currentFrame = updateA (a:a) bind &lt;f; d&gt;:unitf locations are non-negative integer pairs &lt; f rame; disp &gt;, which may be thought of as a display address [1], or alternatively, as a stack shape <ref> [24] </ref>. Intuitively, f rame points to an activation record and disp is an offset within that record. Following Reynolds [24], we assume each activation record has a call block where the labels of argument parameters are stored. <p> updateA (a:a) bind &lt;f; d&gt;:unitf locations are non-negative integer pairs &lt; f rame; disp &gt;, which may be thought of as a display address [1], or alternatively, as a stack shape <ref> [24] </ref>. Intuitively, f rame points to an activation record and disp is an offset within that record. Following Reynolds [24], we assume each activation record has a call block where the labels of argument parameters are stored. Call block entries are denoted [f; e] which points to the e-th argument in the activation pointed to by f .
Reference: [25] <author> J. E. Stoy. </author> <title> Denotational Semantics: the Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: Finally, the compilation of recursive procedures is outlined in Section 6.1. 5.1 Simple Expression Language We first consider the compilation of a simple expression language consisting of integer constants with negation and addition. Its syntax is given in Figure 2 and its standard semantics is given in arithmetic expressions <ref> [25] </ref>. 7 [[n]] = unit fi: fin [[t]] = [[t]] bind e: unit fi: e (i:fi (i)) [[t 1 ]] bind e 1 : [[t 2 ]] bind e 2 : unit fi:(e 1 (v 1 :e 2 (v 2 :fi (v 1 + v 2 )))) Given an expression like <p> Also, this would result in considerable code duplication, since may be repeated many times. We remedy this situation with a common technique from denotational semantics <ref> [25] </ref>. The idea is simple: when a command jumps to a label, it invokes the continuation "stored" at that label. We 11 make this "continuation store" explicit, and use it to store continuations that will be the targets of jumps.
Reference: [26] <author> J. Thatcher, E. Wagner, and J. Wright. </author> <title> More On Advice On Structuring Compilers and Proving Them Correct. </title> <type> Research Report, </type> <institution> Mathematical Sciences Department, IBM Thomas J. Watson Research Center, </institution> <year> 1979. </year>
Reference-contexts: So, if the same integer is being computed by C [[t]] and [[t]], then (2) will hold. 3. Proving the compiler's correctness from the correctness of the phrase types. 7.2 Relating C [[]] and M [[]] In <ref> [19, 26] </ref>, the correctness of a compiler from source language L to target language M achLang would be expressed by the following diagram: L compile - M achLang M source semantics ? encode - U target semantics where M and U are the possibly distinct source and target semantic models and <p> This is essentially the same diagram as occurs in <ref> [19, 26] </ref>, although, broadly speaking, the pass separations performed to produce C [[]] fold "encode" into the compilation semantics.
Reference: [27] <author> P. Wadler. </author> <title> The essence of functional programming. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <year> 1992. </year>
Reference-contexts: Monads and monad transformers have been used in the past to structure denotational definitions <ref> [16, 6, 27, 18] </ref> where they allow a mix-and-match (what Espinosa calls a "semantic lego") approach. It is argued here that similar benefits can be obtained for compilers. This method of compiler generation can be summarized as: 1. Start with a monad-structured semantics. <p> Hudak, Liang, and Jones [16], Espinosa [6], and Wadler <ref> [27] </ref> use monads and monad transformers to create modular, extensible interpreters. This work shows how interpreters can be developed in a modular way, leaving open the question of whether compilers can be developed similarly. <p> The pass separation transformations used here make fairly minimal changes to the standard semantic equations and result in a compilation semantics which is recognizably a more implementation-oriented version of the standard semantics. 3 Monads and Monad Transformers Recent work in semantics <ref> [27, 16, 6] </ref> indicates that the denotational semantics for languages can be constructed modularly using monads and monad transformers as building blocks. When applied to a monad M, a monad transformer T creates a new monad M 0 with some additional features (e.g., 4 states, environments, etc.). <p> In this sense, it is similar to action semantics [21, 20] and high-level semantics [14]. However, monad transformers allow extensions to existing language specifications in a well-understood and canonical manner. For further background on monads and monad transformers, please see <ref> [27, 16, 6] </ref>. For our purposes, a monad M can be viewed as a type constructor with two operations unit : t ! M t and bind : M t 1 fi (t 1 ! M t 2 ) ! M t 2 which obey certain laws [27, 16, 6]. <p> transformers, please see <ref> [27, 16, 6] </ref>. For our purposes, a monad M can be viewed as a type constructor with two operations unit : t ! M t and bind : M t 1 fi (t 1 ! M t 2 ) ! M t 2 which obey certain laws [27, 16, 6]. The simplest monad is the identity monad Id, which is defined in Figure 1. Monads can be constructed from other monads using monad transformers. Two transformers used frequently in this work are the environment transformer EnvT and the state transformer StateT. <p> However, it is quite simple to add address allocation and store using the state monad transformer <ref> [16, 27] </ref>. In the parlance of pass separation, the addresses and storage are intermediate data structures. We do not claim that the standard monadic definition in Figure 3 can be used to obtain machine language programs. <p> Figure 20 contains the standard and compilation semantics for letrec and Figure 21 presents an example. 7 Correctness In the previous sections, we have developed a "mix-and-match" compilation method similar to the modular interpreter constructions of <ref> [16, 6, 27] </ref>.
Reference: [28] <author> M. Wand. </author> <title> Different Advice on Structuring Compilers and Proving Them Correct/ Technical Report No. </title> <type> 95, </type> <institution> Indiana University, </institution> <month> September </month> <year> 1980. </year>
Reference-contexts: After rotation, this tree resembles and evaluates like machine language code. In [31], Wand extends this work with explicit loops by reintroducing variables in a restricted way resembling labels in machine code. <ref> [28] </ref> describes the correctness proof of the compilers from [29, 30]. The present work differs from Wand's in that our combinators are constructed semi-automatically via monad transformation and lifting, and thus a number of properties of monadic operations (e.g., the associativity of bind) are preserved.
Reference: [29] <author> M. Wand. </author> <title> Semantics-Directed Machine Architecture. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <pages> pages 234-241, </pages> <year> 1982. </year>
Reference-contexts: Our compiler for that language, presented in Section 6, improves on Reynolds in two ways: it is monad-structured|that is, built from interchangeable parts|and it includes jumps and labels where Reynolds simply allowed code duplication and infinite programs. In <ref> [29, 30] </ref>, Wand presents a combinator-based approach to compilation, in which a continuation semantics is rewritten in terms of special-purpose machine language-like combinators. <p> After rotation, this tree resembles and evaluates like machine language code. In [31], Wand extends this work with explicit loops by reintroducing variables in a restricted way resembling labels in machine code. [28] describes the correctness proof of the compilers from <ref> [29, 30] </ref>. The present work differs from Wand's in that our combinators are constructed semi-automatically via monad transformation and lifting, and thus a number of properties of monadic operations (e.g., the associativity of bind) are preserved. Many of Wand's combinators appear to be ad hoc versions of bind.
Reference: [30] <author> M. Wand. </author> <title> Deriving Target Code as a Representation of Continuation Semantics. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 4, No. 3, </volume> <month> July </month> <year> 1982, </year> <pages> Pages 496-517. </pages>
Reference-contexts: Our compiler for that language, presented in Section 6, improves on Reynolds in two ways: it is monad-structured|that is, built from interchangeable parts|and it includes jumps and labels where Reynolds simply allowed code duplication and infinite programs. In <ref> [29, 30] </ref>, Wand presents a combinator-based approach to compilation, in which a continuation semantics is rewritten in terms of special-purpose machine language-like combinators. <p> After rotation, this tree resembles and evaluates like machine language code. In [31], Wand extends this work with explicit loops by reintroducing variables in a restricted way resembling labels in machine code. [28] describes the correctness proof of the compilers from <ref> [29, 30] </ref>. The present work differs from Wand's in that our combinators are constructed semi-automatically via monad transformation and lifting, and thus a number of properties of monadic operations (e.g., the associativity of bind) are preserved. Many of Wand's combinators appear to be ad hoc versions of bind.
Reference: [31] <author> M. Wand. </author> <title> Loops in Combinator-based Compilers. </title> <journal> Information and Control, </journal> <volume> 57, </volume> <pages> Pages 148-164 (1983). </pages>
Reference-contexts: After rotation, this tree resembles and evaluates like machine language code. In <ref> [31] </ref>, Wand extends this work with explicit loops by reintroducing variables in a restricted way resembling labels in machine code. [28] describes the correctness proof of the compilers from [29, 30].
References-found: 31

