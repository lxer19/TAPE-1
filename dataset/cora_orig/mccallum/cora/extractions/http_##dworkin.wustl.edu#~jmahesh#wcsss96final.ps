URL: http://dworkin.wustl.edu/~jmahesh/wcsss96final.ps
Refering-URL: http://www.cs.wustl.edu/~cytron/
Root-URL: 
Phone: (314) 935-6160  
Title: Efficient Demultiplexing of Network Packets by Automatic Parsing (Extended Abstract)  
Author: Mahesh Jayaram Ron K. Cytron 
Keyword: Network Software, Packet Demultiplexing, Packet Filter, Compiler Techniques, Parsing.  
Address: Box 1045  St. Louis, Missouri 63130  
Affiliation: Washington University  Department of Computer Science  
Abstract: Packet filters are a mechanism for efficiently demultiplexing network packets to application endpoints. There is currently no general, formal specification method for packet filters that allows for easy or efficient composition of specifications. In this paper we present an automatic approach that achieves all of these goals. We approach packet filter specification as a language recognition problem: each filter is represented by a context-free grammar, whose language is the set of packets the filter should accept. Thus, packet filters can be formulated through a general, well defined specification; further, the grammar-based approach simplifies filter composition, which is essential where scalability is important. However packet filters based on standard LR parsing techniques suffer from poor performance: they touch every portion of the input, they check input bit by bit, they occupy large amount of space. We present new optimizations to LR parsing that enable our automatic approach to overcome the above problems and achieve performance rivalling hand-crafted approaches. We present results that compare our approach to the BSD packet filter for TCP connections; our approach shows significant improvement when there are multiple filters installed: for 50 TCP connections our approach is 6 times faster. 
Abstract-found: 1
Intro-found: 1
Reference: [ABB + 86] <author> M. J. Accetta, R. V. Baron, W. Bolosky, D. B. Golub, R. F. Rashid, A. Tevanian. Jr, and M. W. Young. </author> <title> Mach: A new kernel foundation for unix development. </title> <booktitle> In Winter 1986 USENIX Conference, </booktitle> <month> July </month> <year> 1986. </year>
Reference: [App91] <author> Andrew W. Appel. </author> <title> Garbage collection. </title> <editor> In Peter Lee, editor, </editor> <booktitle> Topics in Advanced Language Implementation, chapter 4. </booktitle> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In systems with virtual memory hardware, the cost of maintaining safety is minimal <ref> [App91] </ref>, especially where safety is not violated. Specification generality: The specification language, LR grammars, is powerful enough to allow easy specification of different kinds of filters. For example, no special treatment is needed for packets with varying length fields.
Reference: [BGS + 94] <author> M. L. Bailey, B. Gopal, P. Sarkar, M. A. Pagels, and L. L. Peterson. Pathfinder: </author> <title> A pattern-based packet classifier. </title> <booktitle> In Proceedings of the 1 st Symposium on Operating System Design and Implementation. USENIX, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: The code could be compiled and executed for greater efficiency, if the security of executing the packet filter were not a concern. * Alternately the specification can be in the form of a pattern, or a set of rules <ref> [BGS + 94] </ref>. The filter mechanism then checks whether a packet conforms to the pattern. This is the approach followed in this paper. Scalability is especially important when there are a large number of recipient endpoints: as the number of host consumer applications grows, the burden of packet filtering increases. <p> Existing packet filter mechanisms CSPF [MRA87] and BPF [MJ93] are interpreter-based filter mechanisms that do not support composition. MPF [YBMM94] is similar to BPF but adds support for composing filter specifications for special cases and for dealing with fragmented packets. PathFinder <ref> [BGS + 94] </ref> is a pattern-based filtering mechanism that allows a greater degree of composition than MPF and allows for an efficient implementation. We discuss the above filter mechanisms in greater detail in Section 5. <p> With 100 connections our mechanism performs about 10 times better. 5 Related Work In this section we describe related work in the areas of packet filters and LR parsing . We discuss four major packet filter schemes: CSPF [MRA87], BPF [MJ93], MPF [YBMM94], PathFinder <ref> [BGS + 94] </ref>. We also discuss related work in optimizing LR parsing [Pen86, HW90]. CSPF: The CMU/Stanford packet filter (CSPF) is an interpreter based filtering mechanism. The filter specification language is stack based and contains binary operations which are used to evaluate boolean expressions.
Reference: [Bra88] <author> R. T. Braden. </author> <title> A pseudo-machine for packet monitoring and statistics. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols(SIGCOMM), </booktitle> <address> Stanford, CA, </address> <month> August </month> <year> 1988. </year> <note> ACM. </note>
Reference: [DDH84] <author> P. Dencker, K. Durre, and J. Heuft. </author> <title> Optimization of parser tables for portable compilers. </title> <journal> ACM Trans. Prog. Lang. and Systems, </journal> <volume> 6(4), </volume> <year> 1984. </year>
Reference-contexts: LR parsing optimizations: There has been a lot of work in optimizing LR parsing. Some of the optimizations have been : optimization of the driver program of LR parsing [Gro88] , converting table-driven LR parsers to directly executable code [Pen86], reducing storage requirements for parsers <ref> [DDH84] </ref>, 8 making stack access optimizations [HW90]. As of now, there has been no attempt to skip past input tokens which are irrelevant to the process of parsing or matching multiple tokens simultaneously, as suggested in this paper.
Reference: [GJS94] <author> N. Gehani, H. V. Jagadish, and O. Shmueli. Compose: </author> <title> A system for composite event specification and detection. In Book chapter in Advanced Database Concepts and Research Issues (N. </title> <editor> R. Adam and B. Bhargava, eds.), </editor> <booktitle> Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference: [Gro88] <author> J. Grosch. </author> <title> Generators for high-speed front ends. </title> <type> Technical Report 11, </type> <institution> University of Karlsruhe, </institution> <month> September </month> <year> 1988. </year>
Reference-contexts: LR parsing optimizations: There has been a lot of work in optimizing LR parsing. Some of the optimizations have been : optimization of the driver program of LR parsing <ref> [Gro88] </ref> , converting table-driven LR parsers to directly executable code [Pen86], reducing storage requirements for parsers [DDH84], 8 making stack access optimizations [HW90].
Reference: [HW90] <author> R. Nigel. Horspool and Michael Whitney. </author> <title> Even faster LR parsing. </title> <journal> Software-Practice and Experience, </journal> <volume> 20(6), </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: A tool such as yacc [Joh79] then generates an LR parse table for the grammar, assuming the grammar presents no conflicts. As discussed in Section 3, we optimize the tables produced by yacc, in a manner quite different from optimizations typically seen in the context of parsing programming languages <ref> [Pen86, HW90] </ref>. The tables are in fact optimized for a modified LR parsing engine, which has the ability to skip tokens. It is this engine (driven by the optimized LR table) that acts as a packet filter, accepting packets conforming to the grammar specification. a number of rules. <p> We discuss four major packet filter schemes: CSPF [MRA87], BPF [MJ93], MPF [YBMM94], PathFinder [BGS + 94]. We also discuss related work in optimizing LR parsing <ref> [Pen86, HW90] </ref>. CSPF: The CMU/Stanford packet filter (CSPF) is an interpreter based filtering mechanism. The filter specification language is stack based and contains binary operations which are used to evaluate boolean expressions. <p> Some of the optimizations have been : optimization of the driver program of LR parsing [Gro88] , converting table-driven LR parsers to directly executable code [Pen86], reducing storage requirements for parsers [DDH84], 8 making stack access optimizations <ref> [HW90] </ref>. As of now, there has been no attempt to skip past input tokens which are irrelevant to the process of parsing or matching multiple tokens simultaneously, as suggested in this paper.
Reference: [isi94] <institution> Isis Distributed Systems Inc., </institution> <month> Marlboro, </month> <title> MA, Isis User's Guide: Reliable Distributed Objects for C++, </title> <month> April </month> <year> 1994. </year>
Reference: [JLM89] <author> V. Jacobson, C. Leres, and S. McCanne. </author> <title> The Tcpdump Manual Page. </title> <institution> Lawrence Berkeley Laboratory, Berkeley, </institution> <address> CA, </address> <month> June </month> <year> 1989. </year>
Reference: [Joh79] <author> S. C. Johnson. </author> <title> YACC yet another compiler compiler in UNIX Programmer's manual, </title> <address> 7 edition, </address> <year> 1979. </year>
Reference-contexts: Figure 3 shows the basic filtering mechanism. The pattern to be matched in the packets is encoded in the form of an LR grammar, so that the desired packets form the language recognized by the grammar. A tool such as yacc <ref> [Joh79] </ref> then generates an LR parse table for the grammar, assuming the grammar presents no conflicts. As discussed in Section 3, we optimize the tables produced by yacc, in a manner quite different from optimizations typically seen in the context of parsing programming languages [Pen86, HW90].
Reference: [Ler92] <author> C. Leres. </author> <title> The Arpwatch Manual Page. </title> <institution> Lawrence Berkeley Laboratory, Berkeley, </institution> <address> CA, </address> <month> Sept. </month> <year> 1992. </year>
Reference: [MJ93] <author> Steven McCanne and Van Jacobson. </author> <title> The BSD Packet Filter. </title> <booktitle> In Winter USENIX, </booktitle> <pages> pages 259-269, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Depending on the specification, filtering mechanisms are of two kinds: * The specification can take the form of code in a filter language, which is interpreted by the filtering mechanism to test whether the packet is to be accepted <ref> [MRA87, MJ93, YBMM94] </ref>. The code could be compiled and executed for greater efficiency, if the security of executing the packet filter were not a concern. * Alternately the specification can be in the form of a pattern, or a set of rules [BGS + 94]. <p> To improve scalability it is desirable to be able to combine individual specifications into a composite specification. This would enable the filter mechanism to determine which applications should receive the packet in just a single pass over a packet. Existing packet filter mechanisms CSPF [MRA87] and BPF <ref> [MJ93] </ref> are interpreter-based filter mechanisms that do not support composition. MPF [YBMM94] is similar to BPF but adds support for composing filter specifications for special cases and for dealing with fragmented packets. <p> With 100 connections our mechanism performs about 10 times better. 5 Related Work In this section we describe related work in the areas of packet filters and LR parsing . We discuss four major packet filter schemes: CSPF [MRA87], BPF <ref> [MJ93] </ref>, MPF [YBMM94], PathFinder [BGS + 94]. We also discuss related work in optimizing LR parsing [Pen86, HW90]. CSPF: The CMU/Stanford packet filter (CSPF) is an interpreter based filtering mechanism. The filter specification language is stack based and contains binary operations which are used to evaluate boolean expressions.
Reference: [MRA87] <author> Jeffrey C. Mogul, Richard F. Rashid, and Michael J. Accetta. </author> <title> The Packet Filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proceedings of 11th Symposium on Operating Systems Principles. ACM, </booktitle> <pages> pages 39-51, </pages> <month> November </month> <year> 1987. </year> <month> 9 </month>
Reference-contexts: process and then switch again when the intermediate process transfers the packet to the final recipient process. fl Research supported by the National Science Foundation Grant NCR-9405444 y Contact author (cytron@cs.wustl.edu). 1 Packet filter: To overcome the disadvantages of the above two approaches, the idea of packet filtering was developed <ref> [MRA87] </ref>, as depicted in Figure 1 (Right). A packet filter mechanism is essentially a kernel agent close to the network device that checks incoming packets and sends them to the appropriate user endpoints. <p> Depending on the specification, filtering mechanisms are of two kinds: * The specification can take the form of code in a filter language, which is interpreted by the filtering mechanism to test whether the packet is to be accepted <ref> [MRA87, MJ93, YBMM94] </ref>. The code could be compiled and executed for greater efficiency, if the security of executing the packet filter were not a concern. * Alternately the specification can be in the form of a pattern, or a set of rules [BGS + 94]. <p> To improve scalability it is desirable to be able to combine individual specifications into a composite specification. This would enable the filter mechanism to determine which applications should receive the packet in just a single pass over a packet. Existing packet filter mechanisms CSPF <ref> [MRA87] </ref> and BPF [MJ93] are interpreter-based filter mechanisms that do not support composition. MPF [YBMM94] is similar to BPF but adds support for composing filter specifications for special cases and for dealing with fragmented packets. <p> With 100 connections our mechanism performs about 10 times better. 5 Related Work In this section we describe related work in the areas of packet filters and LR parsing . We discuss four major packet filter schemes: CSPF <ref> [MRA87] </ref>, BPF [MJ93], MPF [YBMM94], PathFinder [BGS + 94]. We also discuss related work in optimizing LR parsing [Pen86, HW90]. CSPF: The CMU/Stanford packet filter (CSPF) is an interpreter based filtering mechanism. The filter specification language is stack based and contains binary operations which are used to evaluate boolean expressions.
Reference: [nit90] <institution> Sun Microsystems Inc. Mountain View, CA, </institution> <note> NIT(4P); SunOS 4.11 Reference Manual, </note> <month> Oct. </month> <year> 1990. </year>
Reference: [Pen86] <author> T. J. Pennello. </author> <title> Very fast LR parsing. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(7), </volume> <year> 1986. </year>
Reference-contexts: A tool such as yacc [Joh79] then generates an LR parse table for the grammar, assuming the grammar presents no conflicts. As discussed in Section 3, we optimize the tables produced by yacc, in a manner quite different from optimizations typically seen in the context of parsing programming languages <ref> [Pen86, HW90] </ref>. The tables are in fact optimized for a modified LR parsing engine, which has the ability to skip tokens. It is this engine (driven by the optimized LR table) that acts as a packet filter, accepting packets conforming to the grammar specification. a number of rules. <p> We discuss four major packet filter schemes: CSPF [MRA87], BPF [MJ93], MPF [YBMM94], PathFinder [BGS + 94]. We also discuss related work in optimizing LR parsing <ref> [Pen86, HW90] </ref>. CSPF: The CMU/Stanford packet filter (CSPF) is an interpreter based filtering mechanism. The filter specification language is stack based and contains binary operations which are used to evaluate boolean expressions. <p> LR parsing optimizations: There has been a lot of work in optimizing LR parsing. Some of the optimizations have been : optimization of the driver program of LR parsing [Gro88] , converting table-driven LR parsers to directly executable code <ref> [Pen86] </ref>, reducing storage requirements for parsers [DDH84], 8 making stack access optimizations [HW90]. As of now, there has been no attempt to skip past input tokens which are irrelevant to the process of parsing or matching multiple tokens simultaneously, as suggested in this paper.
Reference: [Sch94] <author> Douglas C. Schmidt. </author> <title> High-Performance Event Filtering for Dynamic Multi-point Applications. In 1 st Workshop on High Performance Protocol Architectures (HIPPARCH), </title> <institution> Sophia Antipolis, France, </institution> <month> December </month> <year> 1994. </year> <note> INRIA. </note>
Reference: [YBMM94] <author> Masanobu Yuhara, Brian. N. Bershad, Chris Maeda, and J. Elliot B. Moss. </author> <title> Efficient packet demultiplexing for multiple endpoints and large messages. </title> <booktitle> In Winter 1994 USENIX Conference, </booktitle> <month> January </month> <year> 1994. </year> <month> 10 </month>
Reference-contexts: Depending on the specification, filtering mechanisms are of two kinds: * The specification can take the form of code in a filter language, which is interpreted by the filtering mechanism to test whether the packet is to be accepted <ref> [MRA87, MJ93, YBMM94] </ref>. The code could be compiled and executed for greater efficiency, if the security of executing the packet filter were not a concern. * Alternately the specification can be in the form of a pattern, or a set of rules [BGS + 94]. <p> This would enable the filter mechanism to determine which applications should receive the packet in just a single pass over a packet. Existing packet filter mechanisms CSPF [MRA87] and BPF [MJ93] are interpreter-based filter mechanisms that do not support composition. MPF <ref> [YBMM94] </ref> is similar to BPF but adds support for composing filter specifications for special cases and for dealing with fragmented packets. PathFinder [BGS + 94] is a pattern-based filtering mechanism that allows a greater degree of composition than MPF and allows for an efficient implementation. <p> With 100 connections our mechanism performs about 10 times better. 5 Related Work In this section we describe related work in the areas of packet filters and LR parsing . We discuss four major packet filter schemes: CSPF [MRA87], BPF [MJ93], MPF <ref> [YBMM94] </ref>, PathFinder [BGS + 94]. We also discuss related work in optimizing LR parsing [Pen86, HW90]. CSPF: The CMU/Stanford packet filter (CSPF) is an interpreter based filtering mechanism. The filter specification language is stack based and contains binary operations which are used to evaluate boolean expressions.
References-found: 18

