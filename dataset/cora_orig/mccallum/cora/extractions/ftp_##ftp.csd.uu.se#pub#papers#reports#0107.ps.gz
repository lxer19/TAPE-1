URL: ftp://ftp.csd.uu.se/pub/papers/reports/0107.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: Logic Programs  
Author: Henrik Arro and Jonas Barklund 
Keyword: Sequential and Parallel Iteration  
Address: Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Uppsala University Computing Science Department  
Note: in  
Abstract: UPMAIL Technical Report No. 107 5 May, 1995 ISSN 1100-0686 Abstract Iterative programs are more elegant than their recursive counterparts for many problems and can be executed more efficiently than recursive programs run in the usual way on sequential computers. Moreover, they can often be executed with low overhead on parallel computers. We propose to employ bounded quantifications as an explicit iteration construct for Prolog programs and show that they do run efficiently on both sequential and data parallel computers. We increase the usefulness of our approach by showing how the iteration in an interesting class of recursive programs can be made explicit by transformation to bounded quantification programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abelson, H., Sussman, G. J. and Sussman, J., </author> <title> Structure and Interpretation of Computer Programs, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1985. </year>
Reference-contexts: Example 1.4 The value of an arithmetic expression n X E [i]; is a number that is the combination by addition of the values of the expressions E <ref> [1] </ref>, : : : , E [n]. Definite iteration has the following four important advantages over other ways of expressing repetition in computer programming languages, when it is appropriate at all. 1. It is explicitly definite, leading to programs that are easier to under stand and make correct. 2. <p> The bounded universal quantification is then equivalent to the conjunction fi <ref> [1] </ref> ^ fi [2] ^ ^ fi [10]. If is an arithmetic quantifier, the body expression should be numeric. The numbers to which 5 the instances of the body expression evaluate are combined to give the value of the quantification. <p> For example, suppose that the quantifier is summation (i.e., the combination is through addition), that the range formula is as above and that the body is a numeric expression fi. The bounded sum quantification is then equivalent to the summation fi <ref> [1] </ref> + fi [2] + + fi [10]. Example 2.1 A bounded universal quantification with local variable i, range formula 1 i 4 and body x [i] = 2 fi x [i 1] will have the same meaning as a conjunction x [1] = 2 fi x [0] ^ x [2] <p> quantification is then equivalent to the summation fi <ref> [1] </ref> + fi [2] + + fi [10]. Example 2.1 A bounded universal quantification with local variable i, range formula 1 i 4 and body x [i] = 2 fi x [i 1] will have the same meaning as a conjunction x [1] = 2 fi x [0] ^ x [2] = 2 fi x [1] ^ x [3] = 2 fi x [2] ^ x [4] = 2 fi x [3] because fi ! 1; i ! 2; i ! 3; i ! 4g are all variable assignments that satisfy the range <p> Example 2.1 A bounded universal quantification with local variable i, range formula 1 i 4 and body x [i] = 2 fi x [i 1] will have the same meaning as a conjunction x <ref> [1] </ref> = 2 fi x [0] ^ x [2] = 2 fi x [1] ^ x [3] = 2 fi x [2] ^ x [4] = 2 fi x [3] because fi ! 1; i ! 2; i ! 3; i ! 4g are all variable assignments that satisfy the range formula and 8 is ^. <p> in P 0 looks more complicated than the pre-recursion bounded quantification is that we wished to preserve the operational semantics under sequential semantics | the body instances should be processed beginning with Q 2 (u [n 1]; v [n]; v [n 1]) and finishing with Q 2 (u [0]; v <ref> [1] </ref>; v [0]). In a language with such semantics it seems conventient to provide a way of expressing that a certain bounded quantification should be processed in reverse order. <p> Most of the work on transforming arbitrary (e.g., imperative) recursive programs to iterative programs has had the purpose to obtain programs that yield iterative processes instead of recursive processes <ref> [1] </ref>. That is a somewhat different problem from ours, which mainly aims as extracting definite iteration when possible. Still some of the techniques developed, e.g., by Harrison & Khoshnevisan [17, 18] might be useful also in connection with our transformation, e.g., for improving the I P predicates.
Reference: [2] <author> Anderson, S. and Hudak, P., </author> <title> Compilation of Haskell Array Comprehensions for Scientific Computing, </title> <booktitle> in: Proc. SIGPLAN '90 Conf. on Programming Language Design and Implementation, </booktitle> <publisher> ACM Press, </publisher> <address> New York, N.Y., </address> <year> 1990. </year> <month> 37 </month>
Reference-contexts: The bounded universal quantification is then equivalent to the conjunction fi [1] ^ fi <ref> [2] </ref> ^ ^ fi [10]. If is an arithmetic quantifier, the body expression should be numeric. The numbers to which 5 the instances of the body expression evaluate are combined to give the value of the quantification. <p> For example, suppose that the quantifier is summation (i.e., the combination is through addition), that the range formula is as above and that the body is a numeric expression fi. The bounded sum quantification is then equivalent to the summation fi [1] + fi <ref> [2] </ref> + + fi [10]. Example 2.1 A bounded universal quantification with local variable i, range formula 1 i 4 and body x [i] = 2 fi x [i 1] will have the same meaning as a conjunction x [1] = 2 fi x [0] ^ x [2] = 2 fi <p> [1] + fi <ref> [2] </ref> + + fi [10]. Example 2.1 A bounded universal quantification with local variable i, range formula 1 i 4 and body x [i] = 2 fi x [i 1] will have the same meaning as a conjunction x [1] = 2 fi x [0] ^ x [2] = 2 fi x [1] ^ x [3] = 2 fi x [2] ^ x [4] = 2 fi x [3] because fi ! 1; i ! 2; i ! 3; i ! 4g are all variable assignments that satisfy the range formula and 8 is ^. <p> quantification with local variable i, range formula 1 i 4 and body x [i] = 2 fi x [i 1] will have the same meaning as a conjunction x [1] = 2 fi x [0] ^ x <ref> [2] </ref> = 2 fi x [1] ^ x [3] = 2 fi x [2] ^ x [4] = 2 fi x [3] because fi ! 1; i ! 2; i ! 3; i ! 4g are all variable assignments that satisfy the range formula and 8 is ^. <p> SEL is a logic programming language with a set data type. Operations on sets are similar to bounded quantifications with set range formulas. There are many similarities between bounded quantifications with array expressions and the array comprehensions of the language Haskell <ref> [2] </ref>, and with the FORALL statement in Fortran 90. In all cases the idea is to create larger blocks of computation that can be automatically divided into sequential or parallel subtasks.
Reference: [3] <author> Ashcroft, E. A. and Wadge, W. W., </author> <title> Lucid|A Formal System for Writ--ing and Proving Programs, </title> <journal> SIAM J. Comput., </journal> <volume> 5(3) </volume> <month> 336-354 </month> <year> (1976). </year>
Reference-contexts: Example 2.1 A bounded universal quantification with local variable i, range formula 1 i 4 and body x [i] = 2 fi x [i 1] will have the same meaning as a conjunction x [1] = 2 fi x [0] ^ x [2] = 2 fi x [1] ^ x <ref> [3] </ref> = 2 fi x [2] ^ x [4] = 2 fi x [3] because fi ! 1; i ! 2; i ! 3; i ! 4g are all variable assignments that satisfy the range formula and 8 is ^. <p> i 4 and body x [i] = 2 fi x [i 1] will have the same meaning as a conjunction x [1] = 2 fi x [0] ^ x [2] = 2 fi x [1] ^ x <ref> [3] </ref> = 2 fi x [2] ^ x [4] = 2 fi x [3] because fi ! 1; i ! 2; i ! 3; i ! 4g are all variable assignments that satisfy the range formula and 8 is ^. We see that the meaning of a bounded quantification depends directly on the quantifier and the range formula used. <p> Besides Voronkov [31, 32] and ourselves [5] we know of no proposed construct for expressing iteration directly in logic programs. Lucid <ref> [3, 4] </ref> is not a logic programming language but is an interesting comparison because it has a concept of declarative iteration.
Reference: [4] <author> Ashcroft, E. A. and Wadge, W. W., </author> <title> Lucid, a Nonprocedural Language with Iteration, </title> <journal> Commun. ACM, </journal> <volume> 20(7) </volume> <month> 519-526 </month> <year> (1977). </year>
Reference-contexts: variable i, range formula 1 i 4 and body x [i] = 2 fi x [i 1] will have the same meaning as a conjunction x [1] = 2 fi x [0] ^ x [2] = 2 fi x [1] ^ x [3] = 2 fi x [2] ^ x <ref> [4] </ref> = 2 fi x [3] because fi ! 1; i ! 2; i ! 3; i ! 4g are all variable assignments that satisfy the range formula and 8 is ^. <p> Besides Voronkov [31, 32] and ourselves [5] we know of no proposed construct for expressing iteration directly in logic programs. Lucid <ref> [3, 4] </ref> is not a logic programming language but is an interesting comparison because it has a concept of declarative iteration.
Reference: [5] <author> Barklund, J., </author> <title> Bounded Quantifications for Iteration and Concur-rency in Logic Programming, </title> <journal> New Generation Computing, </journal> <volume> 12 </volume> <month> 161-182 </month> <year> (1994). </year>
Reference-contexts: 1 INTRODUCTION The main thesis proposed and defended in this article is that iteration, in particular definite iteration, can be run more efficiently than general recursion also for logic programs, and that this should be exploited. A second point, which we have already developed elsewhere <ref> [5] </ref>, is that including an explicit definite iteration construct in a logic programming language allows many programs to be written more clearly. Definition 1.1 By iteration we mean a computation that carries out some subcomputation for each element of a sequence of values, combining the results. <p> In order to gain the operational advantages mentioned above, nontrivial analysis is required. Barklund <ref> [5] </ref> and Voronkov [31] have proposed incorporation of bounded quantifications, such as the expression of Example 3, in logic programming languages, but also generalized bounded quantifications expressing arithmetic definite iterations as in Example 4. <p> Note that requiring the limit N to be ground means that the program cannot be run `backwards' for computing a number n so that n! equals a given number. Barklund <ref> [5] </ref> proposes various other range expressions, such as elements of finite sets, elements or suffixes of lists, elements of a discrete type and array elements. Of these we will discuss range formulas based on arrays further in the following sections. <p> In order to test our hypotheses that bounded quantifications can be run more efficiently than recursive logic programs and that they can be run with high efficiency on a data parallel computer, we have run programs for computing Euclidean inner product (Example 4), integral approximation <ref> [5, p. 171] </ref>, root finding in oriented forests [5, p. 170] and matrix multiplication (Example 5) for various sizes of inputs. We have run two programs for each problem: one recursive and one with bounded quantifications. <p> test our hypotheses that bounded quantifications can be run more efficiently than recursive logic programs and that they can be run with high efficiency on a data parallel computer, we have run programs for computing Euclidean inner product (Example 4), integral approximation [5, p. 171], root finding in oriented forests <ref> [5, p. 170] </ref> and matrix multiplication (Example 5) for various sizes of inputs. We have run two programs for each problem: one recursive and one with bounded quantifications. <p> Still some of the techniques developed, e.g., by Harrison & Khoshnevisan [17, 18] might be useful also in connection with our transformation, e.g., for improving the I P predicates. Besides Voronkov [31, 32] and ourselves <ref> [5] </ref> we know of no proposed construct for expressing iteration directly in logic programs. Lucid [3, 4] is not a logic programming language but is an interesting comparison because it has a concept of declarative iteration.
Reference: [6] <author> Barklund, J. and Bevemyr, J., </author> <title> Executing Bounded Quantifications on Shared Memory Multiprocessors, </title> <editor> in: J. Penjam (ed.), </editor> <booktitle> Proc. Intl. Conf. on Programming Language Implementation and Logic Programming 1993, </booktitle> <publisher> LNCS 714, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: Its next construct might be a useful addition to bounded quantifications, as it would make it possible to communicate values between iteration steps without having to 36 introduce an array. Barklund & Bevemyr <ref> [6] </ref> have successfully investigated running bounded quantifications on shared-memory multiprocessors using the Reform Prolog machinery. This confirms that in many cases, the parallel execution of Reform Prolog programs is quite similar to that of bounded quantification programs.
Reference: [7] <author> Barklund, J. and Bevemyr, J., </author> <title> Prolog with Arrays and Bounded Quantifications, </title> <editor> in: A. Voronkov (ed.), </editor> <booktitle> Logic Programming and Automated Reasoning|Proc. 4th Intl. Conf., </booktitle> <publisher> LNCS 698, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: It would often be possible to use Prolog's ordinary structured terms instead of arrays, using the metalogical predicate arg for accessing the elements. However, as we have argued elsewhere <ref> [7] </ref>, there are good reasons for providing arrays separately, particularly on parallel computers (cf. Section 6.2 for a discussion of array representation on parallel computers). For convenience when using arrays in bounded quantification, we allow the predicate index_of as a range formula. <p> In Section 7, we present execution times for running Prolog programs with bounded quantifications on a sequential machine, comparing the results with corresponding recursive programs. The extended WAM and compilation for it is described in more detail by Barklund & Bevemyr <ref> [7, 8] </ref>. 5 PARALLEL EXECUTION OF BOUNDED QUANTIFICATIONS We have already shown that programs with bounded quantifications can be efficiently executed on sequential computers. It is also possible to compute the instances of the body of a bounded quantification in parallel. <p> For tail recursive programs, Meier obtains code which is quite similar to what we propose here (and in more detail elsewhere <ref> [7, 8] </ref>). However, we have defined a small collection of new abstract machine instructions while Meier's code is a mix of WAM-code, C, etc. Meier also considers "backtracking" iteration, which is similar to running bounded existential quantifications, a subject we have not discussed here.
Reference: [8] <author> Barklund, J. and Bevemyr, J., </author> <title> Prolog with Arrays and Bounded Quantifications, </title> <type> UPMAIL Tech. Rep. 77, </type> <institution> Comp. Sci. Dept., Uppsala Univ., Uppsala, </institution> <year> 1993. </year>
Reference-contexts: In Section 7, we present execution times for running Prolog programs with bounded quantifications on a sequential machine, comparing the results with corresponding recursive programs. The extended WAM and compilation for it is described in more detail by Barklund & Bevemyr <ref> [7, 8] </ref>. 5 PARALLEL EXECUTION OF BOUNDED QUANTIFICATIONS We have already shown that programs with bounded quantifications can be efficiently executed on sequential computers. It is also possible to compute the instances of the body of a bounded quantification in parallel. <p> For tail recursive programs, Meier obtains code which is quite similar to what we propose here (and in more detail elsewhere <ref> [7, 8] </ref>). However, we have defined a small collection of new abstract machine instructions while Meier's code is a mix of WAM-code, C, etc. Meier also considers "backtracking" iteration, which is similar to running bounded existential quantifications, a subject we have not discussed here.
Reference: [9] <author> Barklund, J. and Hill, P. M., </author> <title> Extending Godel for Expressing Restricted Quantifications and Arrays, </title> <type> UPMAIL Tech. Rep. 102, </type> <institution> Comp. Sci. Dept., Uppsala Univ., Uppsala, </institution> <year> 1995. </year>
Reference-contexts: However, in order to allow concrete examples, we will describe in particular how Prolog could be extended with bounded quantifications. Nevertheless, everything in this paper could be applied to other logic languages as well. For example, Bark-lund & Hill <ref> [9] </ref> discuss how the logic programming language Godel [23] could be extended with bounded quantifications (or an extension of them). 2.1 Syntax and Declarative Semantics of Bounded Quantifications A bounded quantification is a formula that consists of a quantifier , a collection of iteration variables I 1 , : : :
Reference: [10] <author> Barklund, J., Jayaraman, B. and Tanaka, J. (eds.), </author> <title> Parallel and Data Parallel Execution of Logic Programs (workshop proceedings), number 78 in UPMAIL Tech. </title> <type> Rep. </type> <institution> Series, Uppsala, </institution> <year> 1994. </year>
Reference-contexts: The bounded universal quantification is then equivalent to the conjunction fi [1] ^ fi [2] ^ ^ fi <ref> [10] </ref>. If is an arithmetic quantifier, the body expression should be numeric. The numbers to which 5 the instances of the body expression evaluate are combined to give the value of the quantification. <p> For example, suppose that the quantifier is summation (i.e., the combination is through addition), that the range formula is as above and that the body is a numeric expression fi. The bounded sum quantification is then equivalent to the summation fi [1] + fi [2] + + fi <ref> [10] </ref>.
Reference: [11] <author> Bevemyr, J., </author> <title> A Recursion Parallel Prolog Engine, Ph.L. </title> <type> Thesis, </type> <institution> Comp. Sci. Dept., Uppsala Univ., Uppsala, </institution> <year> 1993. </year>
Reference-contexts: The recursive call in P 0 will then take care of the remaining input. 3.5 Optimizing the Transformed Programs Many of the optimizations described in this section are similar to primitives in the more specialized Reform Prolog system by Bevemyr, Lindgren and Millroth <ref> [11, 12, 13] </ref>. 3.5.1 Combining Counting and Testing. An obvious improvement is to combine the computation of I P (x; n) with the test n &gt; 0. 3.5.2 Eliminating Duplicated Traversal. <p> He then discusses compilation of SLDR-resolution in a way where each step is run by one or more loops. Bevemyr, Lindgren and Millroth have then studied this compilation in great detail <ref> [11, 12, 13, 26] </ref>, in particular concerning parallel implemen 35 Recursive Seq. B.Q. Data Parallel B.Q. Runtime Runtime Speed-up Runtime Speed-up Size Seq. (A) Seq. (B) A=B Seq. Par.
Reference: [12] <author> Bevemyr, J., Lindgren, T. and Millroth, H., </author> <title> Exploiting Recursion-Parallelism in Prolog, </title> <booktitle> in: Proc. </booktitle> <address> PARLE-93, </address> <publisher> LNCS 694, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: The recursive call in P 0 will then take care of the remaining input. 3.5 Optimizing the Transformed Programs Many of the optimizations described in this section are similar to primitives in the more specialized Reform Prolog system by Bevemyr, Lindgren and Millroth <ref> [11, 12, 13] </ref>. 3.5.1 Combining Counting and Testing. An obvious improvement is to combine the computation of I P (x; n) with the test n &gt; 0. 3.5.2 Eliminating Duplicated Traversal. <p> He then discusses compilation of SLDR-resolution in a way where each step is run by one or more loops. Bevemyr, Lindgren and Millroth have then studied this compilation in great detail <ref> [11, 12, 13, 26] </ref>, in particular concerning parallel implemen 35 Recursive Seq. B.Q. Data Parallel B.Q. Runtime Runtime Speed-up Runtime Speed-up Size Seq. (A) Seq. (B) A=B Seq. Par.
Reference: [13] <author> Bevemyr, J., Lindgren, T. and Millroth, H., </author> <title> Reform Prolog: The Language and its Implementation, </title> <booktitle> in: Logic Programming|Proc. Tenth Intl. Conf., </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference-contexts: The recursive call in P 0 will then take care of the remaining input. 3.5 Optimizing the Transformed Programs Many of the optimizations described in this section are similar to primitives in the more specialized Reform Prolog system by Bevemyr, Lindgren and Millroth <ref> [11, 12, 13] </ref>. 3.5.1 Combining Counting and Testing. An obvious improvement is to combine the computation of I P (x; n) with the test n &gt; 0. 3.5.2 Eliminating Duplicated Traversal. <p> He then discusses compilation of SLDR-resolution in a way where each step is run by one or more loops. Bevemyr, Lindgren and Millroth have then studied this compilation in great detail <ref> [11, 12, 13, 26] </ref>, in particular concerning parallel implemen 35 Recursive Seq. B.Q. Data Parallel B.Q. Runtime Runtime Speed-up Runtime Speed-up Size Seq. (A) Seq. (B) A=B Seq. Par.
Reference: [14] <author> Clark, K. L. and Gregory, S., </author> <title> PARLOG: Parallel Programming in Logic, </title> <type> Technical Report DOC 84/4, </type> <institution> Dept. of Computing, Imperial College, </institution> <address> London, </address> <month> Apr. </month> <year> 1984. </year> <month> 38 </month>
Reference-contexts: define a unique execution order. (If the result depends on the actual order of execution, such as when Prolog's meta-logical facilities are used, then the result is not well-defined.) The `some order' semantics would be the natural choice for languages with a concurrent computation rule, such as Godel [23], Parlog <ref> [14] </ref> and various constraint languages. Notice that when all body instances are independent, all semantics above are equivalent.
Reference: [15] <author> Conery, J. S., </author> <title> The AND/OR Process Model for Parallel Interpretation of Logic Programs, </title> <type> Ph.D. Thesis, </type> <institution> University of California, Irvine, </institution> <year> 1983. </year>
Reference-contexts: Table 1: Operational semantics and execution strategies 25 When the subexpressions share variables, the problem of parallel execu-tion becomes harder still. This is confirmed by Conery, who showed that the problem of finding simultaneous variable assignments for a set of nondeterministic conjuncts is very difficult <ref> [15] </ref>. 6 EXECUTION OF BOUNDED QUANTIFICATIONS ON A DATA PARALLEL COMPUTER To verify some of our ideas of parallel execution, we have designed an abstract machine for Prolog with bounded quantifications and implemented it on a data parallel computer. Our implementation is an extension of WAM.
Reference: [16] <author> DeGroot, D., </author> <title> Restricted AND-Parallelism, </title> <booktitle> in: Proc. Intl. Conf. on Fifth Generation Computer Systems 1984, </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: The simplest case is, of course, when there are no data dependencies between the various instances of the body (we may say that they are independent 9 <ref> [16] </ref>). In this case, all operational semantics above are equivalent and the implementation may choose to run them in any order or all at once.
Reference: [17] <author> Harrison, P. G. and Khoshnevisan, H., </author> <title> Efficient Compilation of Linear Recursive Functions into Object Level Loops, </title> <booktitle> in: Proc. ACM SIG-PLAN 86 Symp. on Compiler Construction, ACM, </booktitle> <address> New York, </address> <year> 1986. </year>
Reference-contexts: That is a somewhat different problem from ours, which mainly aims as extracting definite iteration when possible. Still some of the techniques developed, e.g., by Harrison & Khoshnevisan <ref> [17, 18] </ref> might be useful also in connection with our transformation, e.g., for improving the I P predicates. Besides Voronkov [31, 32] and ourselves [5] we know of no proposed construct for expressing iteration directly in logic programs.
Reference: [18] <author> Harrison, P. G. and Khoshnevisan, H., </author> <title> A New Approach to Recursion Removal, </title> <journal> Theor. Comput. Sci., </journal> <volume> 93 </volume> <month> 91-113 </month> <year> (1992). </year>
Reference-contexts: That is a somewhat different problem from ours, which mainly aims as extracting definite iteration when possible. Still some of the techniques developed, e.g., by Harrison & Khoshnevisan <ref> [17, 18] </ref> might be useful also in connection with our transformation, e.g., for improving the I P predicates. Besides Voronkov [31, 32] and ourselves [5] we know of no proposed construct for expressing iteration directly in logic programs.
Reference: [19] <author> Hermenegildo, M. V. and Greene, K. J., </author> <title> &-Prolog and its Performance: Exploiting Independent And-Parallelism, </title> <editor> in: D. H. D. Warren and P. Szeredi (eds.), </editor> <booktitle> Logic Programming|Proc. Seventh Intl. Conf., </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: In that case, the nondeterminism is local and there are well-known methods for implementing it <ref> [19, 21] </ref>. However, in the case of bounded quantifications, where the goals to be computed are likely to be quite similar (i.e., if one body instance is nondeterministic, then typcially all instances are nondeterministic), the number of solutions grows exponentially.
Reference: [20] <author> Hermenegildo, M. V. and Nasr, R. I., </author> <title> Efficient Management of Backtracking in AND-parallelism, </title> <editor> in: E. Shapiro (ed.), </editor> <booktitle> Third International Conference on Logic Programming, </booktitle> <publisher> LNCS 225, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: Section 4) but it does not seem useful in practice. Note that the basis of this assumption is that all goals are nondeterministic: if only a small number of goals are nondeterministic, they may be possible to compute in parallel (this is the case in, e.g., &-Prolog <ref> [20] </ref>). 24 Sequential `Any order' `Some order' semantics semantics semantics Sequential execution An obvious combination that is used in many languages with a sequential computation rule, e.g., Prolog without a freeze facility. The computation gives a run-time error if data dependencies are detected.
Reference: [21] <author> Hermenegildo, M. V., </author> <title> An Abstract Machine for Restricted AND-parallel Execution of Logic Programs, </title> <editor> in: E. Shapiro (ed.), </editor> <booktitle> Third International Conference on Logic Programming, </booktitle> <publisher> LNCS 225, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: In that case, the nondeterminism is local and there are well-known methods for implementing it <ref> [19, 21] </ref>. However, in the case of bounded quantifications, where the goals to be computed are likely to be quite similar (i.e., if one body instance is nondeterministic, then typcially all instances are nondeterministic), the number of solutions grows exponentially.
Reference: [22] <author> Hermenegildo, M. V. and Rossi, F., </author> <title> Non-Strict Independent And-Parallelism, </title> <editor> in: D. H. D. Warren and P. Szeredi (eds.), </editor> <booktitle> Logic Programming|Proc. Seventh Intl. Conf., </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: Notice that when all body instances are independent, all semantics above are equivalent. The condition of independence is trivially satisfied if the subexpressions do not share any variables (in the terminology of Hermengildo and Rossi <ref> [22] </ref>, this is strict independence), but it can also be satisfied if every shared variable is instantiated before the bounded quantification is executed, or 10 if different instances access different parts of a structured term (nonstrict indepence). Example 2.6 Apply to all.
Reference: [23] <author> Hill, P. M. and Lloyd, J. W., </author> <title> The Godel Programming Language, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: However, in order to allow concrete examples, we will describe in particular how Prolog could be extended with bounded quantifications. Nevertheless, everything in this paper could be applied to other logic languages as well. For example, Bark-lund & Hill [9] discuss how the logic programming language Godel <ref> [23] </ref> could be extended with bounded quantifications (or an extension of them). 2.1 Syntax and Declarative Semantics of Bounded Quantifications A bounded quantification is a formula that consists of a quantifier , a collection of iteration variables I 1 , : : : , I n , a range formula [I <p> need not define a unique execution order. (If the result depends on the actual order of execution, such as when Prolog's meta-logical facilities are used, then the result is not well-defined.) The `some order' semantics would be the natural choice for languages with a concurrent computation rule, such as Godel <ref> [23] </ref>, Parlog [14] and various constraint languages. Notice that when all body instances are independent, all semantics above are equivalent.
Reference: [24] <author> Kacsuk, P., </author> <title> Execution Models of Prolog for Parallel Computers, </title> <publisher> Pitman, </publisher> <address> London, </address> <year> 1990. </year>
Reference-contexts: This confirms that in many cases, the parallel execution of Reform Prolog programs is quite similar to that of bounded quantification programs. An attempt to run logic programs with arrays on data parallel computers, which is somewhat similar to our work, is the DAP Prolog described by Kacsuk <ref> [24] </ref>. DAP Prolog has support for arrays, and there is an array mode, where some operations are extended to operate on elements of parallel arrays. The array mode gives a way to express data parallel computations.
Reference: [25] <author> Li, Z., Yew, P. and Zhu, C., </author> <title> An Efficient Data Dependence Analysis for Parallelizing Compilers, </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <month> 26-34 </month> <year> (1990). </year>
Reference-contexts: Methods for static scheduling have long been used for Fortran programs, and the subject has been thoroughly researched. For example, it is possible to relax data dependencies for array programs to allow simple scheduling <ref> [25] </ref>. Of course, it is also possible to use a combination of the two methods, where dynamic scheduling is used to ensure that the data dependencies are satisfied, but the processes are started in a statically determined order that is intended to maximize the concurrency.
Reference: [26] <author> Lindgren, T., </author> <title> The Compilation and Execution of Recursion-Parallel Prolog on Shared Memory Multiprocessors, Ph.L. </title> <type> Thesis, </type> <institution> Comp. Sci. Dept., Uppsala Univ., Uppsala, </institution> <month> Nov. </month> <year> 1993. </year> <month> 39 </month>
Reference-contexts: The problem of analysing such computations has been studied by Lindgren <ref> [26] </ref>. 20 4 SEQUENTIAL EXECUTION OF BOUNDED QUANTIFICATIONS Bounded quantifications can be implemented with very low overhead as definite or indefinite iteration on sequential computers. <p> He then discusses compilation of SLDR-resolution in a way where each step is run by one or more loops. Bevemyr, Lindgren and Millroth have then studied this compilation in great detail <ref> [11, 12, 13, 26] </ref>, in particular concerning parallel implemen 35 Recursive Seq. B.Q. Data Parallel B.Q. Runtime Runtime Speed-up Runtime Speed-up Size Seq. (A) Seq. (B) A=B Seq. Par.
Reference: [27] <author> Meier, M., </author> <title> Recursion vs. Iteration in Prolog, </title> <editor> in: K. Furukawa (ed.), </editor> <booktitle> Logic Programming|Proc. Eighth Intl. Conf., </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: All runtimes are in milliseconds. 8 RELATED WORK Surprisingly little attention has been paid to exploiting iteration when running logic programs. However, the work by Millroth [28, 29] and Meier <ref> [27] </ref> have both investigated how to compile recursive Prolog programs to iterative code. Millroth's method is based on an analysis of variable binding 5 A SUN 670MP with 64MB memory. 6 A Thinking Machines Corp. Connection Machine Model 200 with 16K one-bit proces sors and 2GB memory. 34 Recursive Seq.
Reference: [28] <author> Millroth, H., </author> <title> Reforming Compilation of Logic Programs, </title> <type> Ph.D. Thesis, </type> <institution> Comp. Sci. Dept., Uppsala Univ., Uppsala, </institution> <year> 1990. </year>
Reference-contexts: All runtimes are in milliseconds. 8 RELATED WORK Surprisingly little attention has been paid to exploiting iteration when running logic programs. However, the work by Millroth <ref> [28, 29] </ref> and Meier [27] have both investigated how to compile recursive Prolog programs to iterative code. Millroth's method is based on an analysis of variable binding 5 A SUN 670MP with 64MB memory. 6 A Thinking Machines Corp.
Reference: [29] <author> Millroth, H., SLDR-Resolution: </author> <title> Parallelizing Structural Recursion in Logic Programs, </title> <type> UPMAIL Technical Report 91, </type> <institution> Comp. Sci. Dept., Uppsala Univ., </institution> <month> Nov. </month> <year> 1994, </year> <note> to appear in J. Logic Programming. </note>
Reference-contexts: All runtimes are in milliseconds. 8 RELATED WORK Surprisingly little attention has been paid to exploiting iteration when running logic programs. However, the work by Millroth <ref> [28, 29] </ref> and Meier [27] have both investigated how to compile recursive Prolog programs to iterative code. Millroth's method is based on an analysis of variable binding 5 A SUN 670MP with 64MB memory. 6 A Thinking Machines Corp.
Reference: [30] <author> Succi, G., Marino, G. A. and Colla, G., </author> <title> Modelling the Connection Machine 2 as an Emulator of Subset-based Declarative Languages, </title> <editor> in: Barklund et al. </editor> <volume> [10]. </volume>
Reference-contexts: DAP Prolog has support for arrays, and there is an array mode, where some operations are extended to operate on elements of parallel arrays. The array mode gives a way to express data parallel computations. Succi, Marino and Colla <ref> [30] </ref> describe an implementation of the language SEL on a data parallel computer. SEL is a logic programming language with a set data type. Operations on sets are similar to bounded quantifications with set range formulas.
Reference: [31] <author> Voronkov, A., </author> <title> Logic Programming with Bounded Quantifiers, </title> <type> Technical Report ECRC-92-29, </type> <institution> ECRC, Munich, </institution> <year> 1992. </year>
Reference-contexts: In order to gain the operational advantages mentioned above, nontrivial analysis is required. Barklund [5] and Voronkov <ref> [31] </ref> have proposed incorporation of bounded quantifications, such as the expression of Example 3, in logic programming languages, but also generalized bounded quantifications expressing arithmetic definite iterations as in Example 4. <p> Voronkov gives a proof procedure where bounded quantifications can be used also to generate instances of the range formula, this corresponds to a form of unbounded iteration <ref> [31, 32] </ref>. We will not discuss such range formulas further in this article. For Prolog, our most basic range formula is one that constrains a variable to a finite range of integers. <p> Of these we will discuss range formulas based on arrays further in the following sections. Range formulas based on lists and their elements are discussed in detail by Voronkov <ref> [31, 32] </ref>. 2.4 Arrays Although arrays and definite iteration can be argued for separately, they are naturally brought together. <p> That is a somewhat different problem from ours, which mainly aims as extracting definite iteration when possible. Still some of the techniques developed, e.g., by Harrison & Khoshnevisan [17, 18] might be useful also in connection with our transformation, e.g., for improving the I P predicates. Besides Voronkov <ref> [31, 32] </ref> and ourselves [5] we know of no proposed construct for expressing iteration directly in logic programs. Lucid [3, 4] is not a logic programming language but is an interesting comparison because it has a concept of declarative iteration.
Reference: [32] <author> Voronkov, A., </author> <title> Logic Programming with Bounded Quantifiers, </title> <editor> in: A. Voronkov (ed.), </editor> <booktitle> Logic Programming|Proc. Second Russian Conf. on Logic Programming, </booktitle> <publisher> LNCS 592, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Voronkov gives a proof procedure where bounded quantifications can be used also to generate instances of the range formula, this corresponds to a form of unbounded iteration <ref> [31, 32] </ref>. We will not discuss such range formulas further in this article. For Prolog, our most basic range formula is one that constrains a variable to a finite range of integers. <p> Of these we will discuss range formulas based on arrays further in the following sections. Range formulas based on lists and their elements are discussed in detail by Voronkov <ref> [31, 32] </ref>. 2.4 Arrays Although arrays and definite iteration can be argued for separately, they are naturally brought together. <p> That is a somewhat different problem from ours, which mainly aims as extracting definite iteration when possible. Still some of the techniques developed, e.g., by Harrison & Khoshnevisan [17, 18] might be useful also in connection with our transformation, e.g., for improving the I P predicates. Besides Voronkov <ref> [31, 32] </ref> and ourselves [5] we know of no proposed construct for expressing iteration directly in logic programs. Lucid [3, 4] is not a logic programming language but is an interesting comparison because it has a concept of declarative iteration.
Reference: [33] <author> Warren, D. H. D., </author> <title> An Abstract Prolog Instruction Set, </title> <type> SRI Tech. Note 309, </type> <institution> SRI Intl., Menlo Park, Calif., </institution> <year> 1983. </year> <month> 40 </month>
Reference-contexts: In fact, such early failure and exit from the loop means that the iteration is not actually definite. However, the answer would be no different if all instances were executed. For Prolog, it is very easy to extend Warren's abstract machine <ref> [33] </ref>, WAM, with instruction for such loops. Only one new instruction is needed: the contents of a temporary register (representing i above) is incremented and if the result is less than the contents of another register (containing the value of e 2 above), jump (back) to some address.
References-found: 33

