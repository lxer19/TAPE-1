URL: http://www.cs.ucsb.edu/~kravi/opt.ps
Refering-URL: http://www.cs.ucsb.edu/~kravi/pub.html
Root-URL: http://www.cs.ucsb.edu
Email: fkravi, ambujg@cs.ucsb.edu  
Phone: Tel: (805) 893 4178  
Title: Optimal Dynamic Range Searching in Non-Replicating Index Structures  
Author: K. V. Ravi Kanth and Ambuj K. Singh 
Note: Work supported in part by a research grant from NSF/ARPA/NASA IRI-9411330 and NSF instrumentation grant CDA 9421978.  
Address: Santa Barbara, CA 93106  
Affiliation: Department of Computer Science University of California at Santa Barbara  
Abstract: Multi-dimensional range searching has important applications in several fields including spatial, image and text databases. Several data structures using linear and non-linear storage space have been proposed in database and computational geometry literature. Using O(n log d n) space for n d-dimensional points, range queries can be supported in poly-logarithmic time [3]. Using linear-space, query times of O(n * ) for any * &gt; 0 can be achieved by replicating each data item at least (1=*) d times. Such large storage-space structures may not be feasible for several databases. In this paper, we examine the complexity of range searching when data items are not replicated. Such non-replicating structures achieve low storage costs and fast update times due to lack of multiple copies. Examples of non-replicating structures include R-trees [1, 5, 13], Bang files [10, 11], quad trees [22] and k-d trees [2]. In this paper, we first obtain a lower bound for range searching in such non-replicating index structures. Assuming a simple tree structure model of an index, we prove that the worst-case query time for a query retrieving t out of n data items is ((n=b) (d1)=d + t=b), where d is the data dimensionality and b is the capacity of index nodes. We then propose a new index structure, called the O-tree, that achieves this query time in dynamic environments. Updates are supported in O(log b n) amortized time and exact match queries in O(log b n) worst-case time. This structure improves the query time of the best known non-replicating structure, the divided k-d tree, and is optimal for both queries and updates in non-replicating tree structures. In contrast to these lower and upper bounds, we prove that index structures such as R-trees and Bang files exhibit a worst-case complexity of O(n=b). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Beckmann, H. Kriegel, R. Schneider, and B. Seeger. </author> <title> The R* tree: An efficient and robust access method for points and rectangles. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 322-331, </pages> <month> May 23-25 </month> <year> 1990. </year>
Reference-contexts: They are the most appropriate structures for large multi-dimensional database systems with small external-memory resources. Examples of such structures include k-d trees [2], divided k-d trees [27], R-trees <ref> [13, 1, 5] </ref>, Bang files [10, 11], SS-trees [28]. All these data structures use linear space. However, they differ considerably in their query and update time complexities. <p> Note that the factor of log 1=d n is asymptotically smaller than n * . Therefore, the divided k-d tree is the best known non-replicating structure for low query time complexity. In contrast, other data structures such as R-trees <ref> [13, 1, 5] </ref>, Bang files [10] which also achieve logarithmic update times, have O (n) query time complexity. In this paper, we propose a new data structure, called the O-tree, that obtains optimal query and update times. <p> set of queries Q = S 1id Q i , where Q i is the set of queries with the following specification: * the interval along the i th dimension X i is : [2c; 2c] for some c: 1 c k, and, * intervals in all other dimensions are: <ref> [1; 2k + 1] </ref>. Note that none of the queries in Q retrieve any data from the set S d . Hence, they are referred to as hole queries in general, and as i-hole queries if they are specifically from Q i . <p> The minimum and maximum x-coordinates for points in S 0 are 1 and 7. Therefore, the x-interval of the bounding rectangle for S 0 is b x (S 0 ) = <ref> [1; 7] </ref>. Similarly, the minimum and maximum y-coordinates are 1 and 6. Therefore, the y-interval is b y (S) = [1; 6]. Total orders, such as x and y above, can be used to partition a set S into smaller subsets that are disjoint and are of approximately same size. <p> Therefore, the x-interval of the bounding rectangle for S 0 is b x (S 0 ) = [1; 7]. Similarly, the minimum and maximum y-coordinates are 1 and 6. Therefore, the y-interval is b y (S) = <ref> [1; 6] </ref>. Total orders, such as x and y above, can be used to partition a set S into smaller subsets that are disjoint and are of approximately same size. We refer to such subsets as partitions of S in the specified order. <p> Figure 1 (b) shows the augmented B-tree using x-order for the set S 0 . The bounding rectangle for the set P = P 1 [ P 2 is h <ref> [1; 3] </ref>; [1; 6]i. This is stored in the first entry of the root vertex leading to the subtree containing P 1 and P 2 . The bounding rectangles for the other entries can be similarly explained. <p> Figure 1 (b) shows the augmented B-tree using x-order for the set S 0 . The bounding rectangle for the set P = P 1 [ P 2 is h [1; 3]; <ref> [1; 6] </ref>i. This is stored in the first entry of the root vertex leading to the subtree containing P 1 and P 2 . The bounding rectangles for the other entries can be similarly explained. Hereafter, we assume every B-tree for a set of partitions is augmented with bounding rectangles. <p> For example, in Figure 1 (b) a query accesses vertex v from the root vertex only if it intersects the bounding rectangle h <ref> [1; 3] </ref>; [1; 6]i associated with the entry for v in the root vertex. Since checking for intersection involves a conjunction of binary comparisons, this structure satisfies the model of Section 2. Before proceeding further, we prove the following property. <p> For example, in Figure 1 (b) a query accesses vertex v from the root vertex only if it intersects the bounding rectangle h [1; 3]; <ref> [1; 6] </ref>i associated with the entry for v in the root vertex. Since checking for intersection involves a conjunction of binary comparisons, this structure satisfies the model of Section 2. Before proceeding further, we prove the following property. <p> Not much theoretical basis exists for data structures that do not replicate data items, although several structures such as R-trees <ref> [1, 5, 13] </ref> and Bang files [10, 11] are known to perform well for most multi-dimensional databases. In this paper, we examine the complexity of range searching in such non-replicating data structures. <p> In future, we will experiment with the optimal non-replicating index structure and compare its performance with other structures such as R fl -trees <ref> [1] </ref> and Bang files [10]. <p> Appendix A Analysis of R-trees and Bang Files A.1 Range Query Time Complexity of R-trees We demonstrate that for specific data points and queries, the R-tree and its variants <ref> [1, 5, 13, 23] </ref> have a worst-case complexity of O (n) for range queries on n data points. The R-tree is an extension of the B + -tree for 12 multidimensional data. As in the B + -tree, data is stored in the leaves. <p> This conformance of the leaf nodes to the two cluster types is a consequence of the area minimization split criteria of the R-tree [13]. Since the clusters themselves do not overlap (nor do their parents), other variants such as R*-trees <ref> [1] </ref> and X-trees [5] also yield the same 13 configuration. Next, (M 2m) points are deleted from the leaf node N 2 . This is followed by an insertion of the next (M m) points (corresponding to a C 1 cluster at offset Lm). <p> The i th leaf node of this R-tree is a C 2 cluster if i is even and a C 1 cluster otherwise. Since the bounding box of any C 1 =C 2 type cluster overlaps with the y-interval [4; 5] and is contained in the x-interval <ref> [1; n] </ref>, it follows that the range query q = [1; n][4; 5] retrieves all the leaf nodes. <p> Since the bounding box of any C 1 =C 2 type cluster overlaps with the y-interval [4; 5] and is contained in the x-interval <ref> [1; n] </ref>, it follows that the range query q = [1; n][4; 5] retrieves all the leaf nodes. <p> We give a specific dataset for which all the leaf nodes (specified by their bounding rectangles) in the BANG file intersect a specific query q. Since, the BANG file [10] partitions the domain alternately, we choose each axis to be of length D = <ref> [1; 4 nm ] </ref>. We specify the set of points at different stages of the index construction. We start off with the following initial set of points. <p> Consequently, all nodes that are formed intersect a query q = <ref> [1; 4 nm ] </ref>[2; 2] leading to a time complexity of O (n). As in the case of R-trees, every query that intersects a leaf node also intersects its ancestors, the query time complexity in terms of the node accesses is O (n). <p> Proof: First, we estimate the number of i-hole queries that satisfy cond (v). Each i-hole query corresponds to a gap in the i th dimension and has an interval <ref> [1; 2k + 1] </ref> in all other dimensions. Now, consider cond (v). <p> First, we show that, when j 6= i, the conjunct C j is satisfied by the corresponding interval of every i-hole query. Consider any i-hole query. It has a query interval of <ref> [1; 2k + 1] </ref> in dimension X j . Since D (v) 6= , there exists a point p 2 D (v) and since D (v) S d , the X j -coordinate of the point p, p j , satisfies: 1 p j 2k + 1. <p> Then, from Lemma A.2 it follows that the sub-clause C j is satisfied by an interval <ref> [1; 2k + 1] </ref>, i.e., by the j th interval of any i-hole query. Given the above argument, the total number of i-holes that satisfy cond (v) is given by the number of them satisfying the sub-clause C i of cond (v). <p> Consider a specific gap in P i (D v ). This corresponds to the i th interval of an i-hole query. From Lemma A.4, this interval satisfies the sub-clause C i of cond (u). Besides, the j th interval of this i-hole query is <ref> [1; 2k + 1] </ref>, which satisfies the sub-clause C j of cond (u) (by Lemma A.2). Hence, the i-hole query (corresponding to a gap in P i (D v )) satisfies cond (u). Note that the same i-hole also satisfies cond (v) (by Lemma A.4).
Reference: [2] <author> J. L. Bentley. </author> <title> Multi-dimensional binary search trees used for associative searching. </title> <journal> Communications of the ACM, </journal> <volume> 18 </volume> <pages> 509-517, </pages> <year> 1975. </year>
Reference-contexts: Non-replicating structures have several advantages such as low storage costs and simple updating procedures due to lack of multiple copies of data items. They are the most appropriate structures for large multi-dimensional database systems with small external-memory resources. Examples of such structures include k-d trees <ref> [2] </ref>, divided k-d trees [27], R-trees [13, 1, 5], Bang files [10, 11], SS-trees [28]. All these data structures use linear space. However, they differ considerably in their query and update time complexities. <p> Our lower bound answers this question for non-replicating tree structures. Our result shows that simple tree structures cannot reduce the overhead of data access by storing information about the data layouts; the overhead of accessing data objects dominates the overall query overhead. Bentley's k-d tree <ref> [2] </ref> meets the proposed lower bound on query time for a static database. Among dynamic structures, the pseudo quad and k-d trees [19] support updates in O (log 2 n) time and queries in O (n (d1)fl (1+*)=d ) time. <p> In the next section, we propose new data structures for achieving optimal query time with logarithmic update times. 4 In the next two sections, we describe non-replicating data structures that meet the proposed lower bound for range query time complexity. In static environments, Bentley's k-d trees <ref> [2] </ref> and Mehlhorn's dd-trees [17] meet the lower bound when b = 2. We briefly describe how the k-d trees can be extended to arbitrary b-ary tree in the next section. We show that the resultant structure meets the above lower bound for query complexity in b-ary trees. <p> We show that the resultant structure meets the above lower bound for query complexity in b-ary trees. We then describe how to extend this result to dynamic environments. 3 Optimal Non-Replicating Structure for Static Environments Given n data points, a k-d tree <ref> [2] </ref> can be constructed for the points in O (n log n) time as suggested by Bentley. This tree is designed as a balanced binary tree and achieves O (n (d1)=d + t) time for a range query.
Reference: [3] <author> J. L. Bentley. </author> <title> Multi-dimensional divide and conquer. </title> <journal> Communications of the ACM, </journal> <volume> 23 </volume> <pages> 214-228, </pages> <year> 1980. </year>
Reference-contexts: In this paper, we examine the complexity of range searching in such external-memory index structures and specifically concentrate on data structures that do not replicate data items. Several efficient structures have been proposed for supporting range searching in database and computational geometry literature. Range trees <ref> [3] </ref> and its variants obtain poly-logarithmic query and update times using O (n log n) storage space for n d-dimensional items. <p> Figure 1 (b) shows the augmented B-tree using x-order for the set S 0 . The bounding rectangle for the set P = P 1 <ref> [ P 2 is h [1; 3] </ref>; [1; 6]i. This is stored in the first entry of the root vertex leading to the subtree containing P 1 and P 2 . The bounding rectangles for the other entries can be similarly explained. <p> Figure 1 (b) shows the augmented B-tree using x-order for the set S 0 . The bounding rectangle for the set P = P 1 [ P 2 is h <ref> [1; 3] </ref>; [1; 6]i. This is stored in the first entry of the root vertex leading to the subtree containing P 1 and P 2 . The bounding rectangles for the other entries can be similarly explained. <p> For example, in Figure 1 (b) a query accesses vertex v from the root vertex only if it intersects the bounding rectangle h <ref> [1; 3] </ref>; [1; 6]i associated with the entry for v in the root vertex. Since checking for intersection involves a conjunction of binary comparisons, this structure satisfies the model of Section 2. Before proceeding further, we prove the following property. <p> Insertions and deletions are supported in O (log b n) amortized time. Storage space used is O (n=b). 5 Conclusions In this paper, we examined the complexity of range searching in external-memory structures. Most existing results for range searching such as the range trees <ref> [3, 6, 8, 24] </ref> and multi-level range trees [4, 29, 20] involve high-replication of data items and consequently high storage costs and update times.
Reference: [4] <author> J. L. Bentley and H. A. Maurer. </author> <title> Efficient worst-case data structures for range searching. </title> <journal> Acta Informatica, </journal> <pages> pages 155-168, </pages> <year> 1980. </year>
Reference-contexts: This structure when combined with Chazelle's proposal extends the range searching results of Chazelle to external-memory structures with an arbitrary node capacity b. All these structures use non-linear storage space which may be too high for large database systems. When only linear-space is used, Bentley's multi-level range structures <ref> [4] </ref> and its dynamic variants [29, 21] obtain O (n * ) query times for any * &gt; 0. However, these structures replicate each data item at least (1=*) d times. This storage cost may be still quite high for most database systems. <p> Storage space used is O (n=b). 5 Conclusions In this paper, we examined the complexity of range searching in external-memory structures. Most existing results for range searching such as the range trees [3, 6, 8, 24] and multi-level range trees <ref> [4, 29, 20] </ref> involve high-replication of data items and consequently high storage costs and update times. <p> The i th leaf node of this R-tree is a C 2 cluster if i is even and a C 1 cluster otherwise. Since the bounding box of any C 1 =C 2 type cluster overlaps with the y-interval <ref> [4; 5] </ref> and is contained in the x-interval [1; n], it follows that the range query q = [1; n][4; 5] retrieves all the leaf nodes.
Reference: [5] <author> S. Berchtold, D. A. Keim, and H. P. Kreigel. </author> <title> The X-tree: An index structure for high dimensional data. </title> <booktitle> Proc. of the Intl. Conf. on Very Large Databases, </booktitle> <year> 1996. </year>
Reference-contexts: They are the most appropriate structures for large multi-dimensional database systems with small external-memory resources. Examples of such structures include k-d trees [2], divided k-d trees [27], R-trees <ref> [13, 1, 5] </ref>, Bang files [10, 11], SS-trees [28]. All these data structures use linear space. However, they differ considerably in their query and update time complexities. <p> Note that the factor of log 1=d n is asymptotically smaller than n * . Therefore, the divided k-d tree is the best known non-replicating structure for low query time complexity. In contrast, other data structures such as R-trees <ref> [13, 1, 5] </ref>, Bang files [10] which also achieve logarithmic update times, have O (n) query time complexity. In this paper, we propose a new data structure, called the O-tree, that obtains optimal query and update times. <p> Not much theoretical basis exists for data structures that do not replicate data items, although several structures such as R-trees <ref> [1, 5, 13] </ref> and Bang files [10, 11] are known to perform well for most multi-dimensional databases. In this paper, we examine the complexity of range searching in such non-replicating data structures. <p> Appendix A Analysis of R-trees and Bang Files A.1 Range Query Time Complexity of R-trees We demonstrate that for specific data points and queries, the R-tree and its variants <ref> [1, 5, 13, 23] </ref> have a worst-case complexity of O (n) for range queries on n data points. The R-tree is an extension of the B + -tree for 12 multidimensional data. As in the B + -tree, data is stored in the leaves. <p> This conformance of the leaf nodes to the two cluster types is a consequence of the area minimization split criteria of the R-tree [13]. Since the clusters themselves do not overlap (nor do their parents), other variants such as R*-trees [1] and X-trees <ref> [5] </ref> also yield the same 13 configuration. Next, (M 2m) points are deleted from the leaf node N 2 . This is followed by an insertion of the next (M m) points (corresponding to a C 1 cluster at offset Lm). <p> The i th leaf node of this R-tree is a C 2 cluster if i is even and a C 1 cluster otherwise. Since the bounding box of any C 1 =C 2 type cluster overlaps with the y-interval <ref> [4; 5] </ref> and is contained in the x-interval [1; n], it follows that the range query q = [1; n][4; 5] retrieves all the leaf nodes.
Reference: [6] <author> B. Chazelle. </author> <title> Filtering search: A new approach to query-answering. </title> <booktitle> Proc. IEEE Symp. on Foundataions of Computer Science, </booktitle> <volume> 24 </volume> <pages> 122-132, </pages> <year> 1983. </year>
Reference-contexts: To answer the question if poly-logarithmic query times can be achieved using linear storage space, Chazelle [8] proved that poly-logarithmic query times require at least O (n (log n= log log n) d1 ) storage space. His technique <ref> [6] </ref>, which combines the dd-trees of Mehlhorn [17] with the priority search trees of [16], achieved poly-logarithmic query and update times using optimal storage space. Since priority search trees are defined in terms of balanced binary trees, this technique does not extend to external-memory structures with arbitrary node capacities (b). <p> Therefore, the x-interval of the bounding rectangle for S 0 is b x (S 0 ) = [1; 7]. Similarly, the minimum and maximum y-coordinates are 1 and 6. Therefore, the y-interval is b y (S) = <ref> [1; 6] </ref>. Total orders, such as x and y above, can be used to partition a set S into smaller subsets that are disjoint and are of approximately same size. We refer to such subsets as partitions of S in the specified order. <p> Figure 1 (b) shows the augmented B-tree using x-order for the set S 0 . The bounding rectangle for the set P = P 1 [ P 2 is h [1; 3]; <ref> [1; 6] </ref>i. This is stored in the first entry of the root vertex leading to the subtree containing P 1 and P 2 . The bounding rectangles for the other entries can be similarly explained. Hereafter, we assume every B-tree for a set of partitions is augmented with bounding rectangles. <p> For example, in Figure 1 (b) a query accesses vertex v from the root vertex only if it intersects the bounding rectangle h [1; 3]; <ref> [1; 6] </ref>i associated with the entry for v in the root vertex. Since checking for intersection involves a conjunction of binary comparisons, this structure satisfies the model of Section 2. Before proceeding further, we prove the following property. <p> Insertions and deletions are supported in O (log b n) amortized time. Storage space used is O (n=b). 5 Conclusions In this paper, we examined the complexity of range searching in external-memory structures. Most existing results for range searching such as the range trees <ref> [3, 6, 8, 24] </ref> and multi-level range trees [4, 29, 20] involve high-replication of data items and consequently high storage costs and update times.
Reference: [7] <author> B. Chazelle. </author> <title> A functional approach to data structures and its use in multi-dimensional searching. </title> <journal> SIAM Journal of Computing, </journal> <volume> 17(3) </volume> <pages> 427-462, </pages> <year> 1988. </year>
Reference-contexts: Chazelle illustrated this as follows. While O (n log n= log log n) storage is a lower bound for obtaining poly-logarithmic query times in a pointer-machine model, O (n log * n) space is sufficient to achieve the same in a RAM model <ref> [7, 8] </ref>. This query time is achieved using his functional approach to data structures where internal nodes store functions to "compute" data items in subtrees. Grossi and Italiano [12] also apply similar functional techniques to obtain, among other things, an efficient structure for range searching. <p> Queries evaluate these functions as they navigate in the index. If such compute functions are not allowed (as in the case of pointer-machines), Grossi notes that the storage requirements become non-linear. Since our model is a direct extension of the pointer-machine model, functional data structures of Chazelle <ref> [7] </ref> do not fit in it. 2.2 Lower Bound In this subsection, we obtain a lower bound on range query time complexity in non-replicating structures. Our lower bound extends the result of Mehlhorn [17]. His proof does not consider b, the node capacity of index nodes. <p> The minimum and maximum x-coordinates for points in S 0 are 1 and 7. Therefore, the x-interval of the bounding rectangle for S 0 is b x (S 0 ) = <ref> [1; 7] </ref>. Similarly, the minimum and maximum y-coordinates are 1 and 6. Therefore, the y-interval is b y (S) = [1; 6]. Total orders, such as x and y above, can be used to partition a set S into smaller subsets that are disjoint and are of approximately same size.
Reference: [8] <author> B. Chazelle. </author> <title> Lower bounds for orthogonal range searching: I. The reporting case. </title> <journal> Journal of the ACM, </journal> <volume> 37(2) </volume> <pages> 200-212, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Range trees [3] and its variants obtain poly-logarithmic query and update times using O (n log n) storage space for n d-dimensional items. To answer the question if poly-logarithmic query times can be achieved using linear storage space, Chazelle <ref> [8] </ref> proved that poly-logarithmic query times require at least O (n (log n= log log n) d1 ) storage space. His technique [6], which combines the dd-trees of Mehlhorn [17] with the priority search trees of [16], achieved poly-logarithmic query and update times using optimal storage space. <p> Instead it is a constant. This model is a direct extension of Mehlhorn's decision tree model from ternary trees to arbitrary b-ary trees, assuming each node has at most b children. Note that this tree model is more restrictive than Chazelle's model <ref> [8] </ref>, where data structures are represented as DAGs, or the more general "pointer-machine" model of Tarjan [25]. Non-replication is hard to enforce in a graph model since multiple paths to same data items are possible without actually replicating the data items themselves. <p> Chazelle illustrated this as follows. While O (n log n= log log n) storage is a lower bound for obtaining poly-logarithmic query times in a pointer-machine model, O (n log * n) space is sufficient to achieve the same in a RAM model <ref> [7, 8] </ref>. This query time is achieved using his functional approach to data structures where internal nodes store functions to "compute" data items in subtrees. Grossi and Italiano [12] also apply similar functional techniques to obtain, among other things, an efficient structure for range searching. <p> Insertions and deletions are supported in O (log b n) amortized time. Storage space used is O (n=b). 5 Conclusions In this paper, we examined the complexity of range searching in external-memory structures. Most existing results for range searching such as the range trees <ref> [3, 6, 8, 24] </ref> and multi-level range trees [4, 29, 20] involve high-replication of data items and consequently high storage costs and update times.
Reference: [9] <author> Y. J. Chiang and R. Tamassia. </author> <title> Dynamic algorithms in computational geometry. </title> <journal> Proc. of the IEEE, </journal> <volume> 80(9) </volume> <pages> 1412-1433, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Each entry is of the form - (c; br), where c refers to a child node and br is the bounding rectangle for all points in the subtree rooted at child c. The R-tree is a dynamic structure and supports insertions/deletions by local rebuilding <ref> [9, 19] </ref>. Local rebuilding (or balancing) denotes the technique applied to search trees so that they maintain logarithmic height during a sequence of updates. Since the R-tree is based on a B + -tree structure, it employs a similar local rebuilding technique as the latter.
Reference: [10] <author> M. W. Freeston. </author> <title> The BANG file: A new kind of grid file. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 260-269, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: They are the most appropriate structures for large multi-dimensional database systems with small external-memory resources. Examples of such structures include k-d trees [2], divided k-d trees [27], R-trees [13, 1, 5], Bang files <ref> [10, 11] </ref>, SS-trees [28]. All these data structures use linear space. However, they differ considerably in their query and update time complexities. <p> Note that the factor of log 1=d n is asymptotically smaller than n * . Therefore, the divided k-d tree is the best known non-replicating structure for low query time complexity. In contrast, other data structures such as R-trees [13, 1, 5], Bang files <ref> [10] </ref> which also achieve logarithmic update times, have O (n) query time complexity. In this paper, we propose a new data structure, called the O-tree, that obtains optimal query and update times. <p> b Structure Lower Bound O (n (d1) [17] b 4 Pseudo k-d tree O (n (d1)(1+*) [19] Divided k-d tree O (n (d1) [19] Lower Bound O ((n=b) (d1) [this paper] Arbitrary b O-tree O ((n=b) (d1) [this paper] R-trees, Bang Files O ((n=b) + t=b) O (log b n) <ref> [13, 10] </ref> Table 1: Comparison of Index Structures for Dynamic Range Searching: The results of this paper are shown highlighted. <p> Not much theoretical basis exists for data structures that do not replicate data items, although several structures such as R-trees [1, 5, 13] and Bang files <ref> [10, 11] </ref> are known to perform well for most multi-dimensional databases. In this paper, we examine the complexity of range searching in such non-replicating data structures. <p> The O-tree improved the query time complexity of the best known non-replicating dynamic structure, the divided k-d tree, by a factor of O (log 1=d n). As opposed to these lower and upper bounds, existing structures such as R-trees [13] and Bang files <ref> [10] </ref> are shown to have O (n=b) query time complexity. In future, we will experiment with the optimal non-replicating index structure and compare its performance with other structures such as R fl -trees [1] and Bang files [10]. <p> lower and upper bounds, existing structures such as R-trees [13] and Bang files <ref> [10] </ref> are shown to have O (n=b) query time complexity. In future, we will experiment with the optimal non-replicating index structure and compare its performance with other structures such as R fl -trees [1] and Bang files [10]. Appendix A Analysis of R-trees and Bang Files A.1 Range Query Time Complexity of R-trees We demonstrate that for specific data points and queries, the R-tree and its variants [1, 5, 13, 23] have a worst-case complexity of O (n) for range queries on n data points. <p> Our proof is similar to the one for the R-trees. We give a specific dataset for which all the leaf nodes (specified by their bounding rectangles) in the BANG file intersect a specific query q. Since, the BANG file <ref> [10] </ref> partitions the domain alternately, we choose each axis to be of length D = [1; 4 nm ]. We specify the set of points at different stages of the index construction. We start off with the following initial set of points.
Reference: [11] <author> M. W. Freeston. </author> <title> A general solution of the n-dimensional B-tree problem. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: They are the most appropriate structures for large multi-dimensional database systems with small external-memory resources. Examples of such structures include k-d trees [2], divided k-d trees [27], R-trees [13, 1, 5], Bang files <ref> [10, 11] </ref>, SS-trees [28]. All these data structures use linear space. However, they differ considerably in their query and update time complexities. <p> Not much theoretical basis exists for data structures that do not replicate data items, although several structures such as R-trees [1, 5, 13] and Bang files <ref> [10, 11] </ref> are known to perform well for most multi-dimensional databases. In this paper, we examine the complexity of range searching in such non-replicating data structures.
Reference: [12] <author> R. Grossi and F. </author> <title> Italiano. Efficient splitting and merging algorithms for order-decomposable searching problems. </title> <booktitle> ICALP, </booktitle> <year> 1996. </year>
Reference-contexts: The only other result matching this query complexity is the Cross-tree of Grossi and Italiano <ref> [12] </ref>. This structure, however, does not fit in a non-replicating index structure model. (This is discussed further in Section 2.) Table 1 summarizes the results of this paper. The complexity results are expressed for n d-dimensional data items, assuming a node capacity of b for the data structures. <p> This model for non-replicating index structures excludes threaded search trees where data items can be reached via multiple paths in the tree, and therefore, also excludes the Cross tree of Grossi and Italiano <ref> [12] </ref>. Next, we describe complexity measures for comparing data structures in this model. The space complexity of a data structure is determined by the total size for leaf and non-leaf nodes in the index structure. <p> This query time is achieved using his functional approach to data structures where internal nodes store functions to "compute" data items in subtrees. Grossi and Italiano <ref> [12] </ref> also apply similar functional techniques to obtain, among other things, an efficient structure for range searching. In this structure, data items are stored explicitly at the root and implicitly at its descendants.
Reference: [13] <author> A. Guttman. R-trees: </author> <title> A dynamic index structure for spatial searching. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 47-57, </pages> <year> 1984. </year>
Reference-contexts: They are the most appropriate structures for large multi-dimensional database systems with small external-memory resources. Examples of such structures include k-d trees [2], divided k-d trees [27], R-trees <ref> [13, 1, 5] </ref>, Bang files [10, 11], SS-trees [28]. All these data structures use linear space. However, they differ considerably in their query and update time complexities. <p> Note that the factor of log 1=d n is asymptotically smaller than n * . Therefore, the divided k-d tree is the best known non-replicating structure for low query time complexity. In contrast, other data structures such as R-trees <ref> [13, 1, 5] </ref>, Bang files [10] which also achieve logarithmic update times, have O (n) query time complexity. In this paper, we propose a new data structure, called the O-tree, that obtains optimal query and update times. <p> b Structure Lower Bound O (n (d1) [17] b 4 Pseudo k-d tree O (n (d1)(1+*) [19] Divided k-d tree O (n (d1) [19] Lower Bound O ((n=b) (d1) [this paper] Arbitrary b O-tree O ((n=b) (d1) [this paper] R-trees, Bang Files O ((n=b) + t=b) O (log b n) <ref> [13, 10] </ref> Table 1: Comparison of Index Structures for Dynamic Range Searching: The results of this paper are shown highlighted. <p> Not much theoretical basis exists for data structures that do not replicate data items, although several structures such as R-trees <ref> [1, 5, 13] </ref> and Bang files [10, 11] are known to perform well for most multi-dimensional databases. In this paper, we examine the complexity of range searching in such non-replicating data structures. <p> The O-tree improved the query time complexity of the best known non-replicating dynamic structure, the divided k-d tree, by a factor of O (log 1=d n). As opposed to these lower and upper bounds, existing structures such as R-trees <ref> [13] </ref> and Bang files [10] are shown to have O (n=b) query time complexity. In future, we will experiment with the optimal non-replicating index structure and compare its performance with other structures such as R fl -trees [1] and Bang files [10]. <p> Appendix A Analysis of R-trees and Bang Files A.1 Range Query Time Complexity of R-trees We demonstrate that for specific data points and queries, the R-tree and its variants <ref> [1, 5, 13, 23] </ref> have a worst-case complexity of O (n) for range queries on n data points. The R-tree is an extension of the B + -tree for 12 multidimensional data. As in the B + -tree, data is stored in the leaves. <p> Let N 1 be the leftmost node in this sequence (i.e., the node corresponding to the cluster C 1 ) and N 2 the other node. This conformance of the leaf nodes to the two cluster types is a consequence of the area minimization split criteria of the R-tree <ref> [13] </ref>. Since the clusters themselves do not overlap (nor do their parents), other variants such as R*-trees [1] and X-trees [5] also yield the same 13 configuration. Next, (M 2m) points are deleted from the leaf node N 2 .
Reference: [14] <author> J. M. Hellerstein, J. M. Koutsoupias, and C. H. Papadimitrou. </author> <title> On the analysis of indexing schemes. </title> <booktitle> Proc. of the ACM Priniciples of Database Systems, </booktitle> <month> May </month> <year> 1997. </year>
Reference-contexts: In doing so, it also considers the impact of the node capacity b on the query time complexity. Note the similarity of our lower bound result with the bound for data access overheads obtained by Hellerstein et al. <ref> [14] </ref>. They estimate the overhead of accessing data objects when the data objects are stored in blocks of size b. They show that for n d-dimensional objects, a query may retrieve as many as (n=b) (d1)=d blocks. <p> Since the number of hole queries is at most d (n 1=d 1), by pigeonhole principle it follows that there is a hole query overhead is O (n (d1)=d ):Combiningitwiththeleastcostf oraccessingdataitems;t/b; weobtainthedesiredbound. 2 Note that this lower bound is similar to the blocking overhead bounds of Hellerstein et al. <ref> [14] </ref>. They estimate the overheads of accessing data items when they are stored in blocks of b items each.
Reference: [15] <author> D. T. Lee and C. Wong. </author> <title> Worst-case analysis of region and partial region searches in multi-dimensional binary search trees and balanced quad trees. </title> <journal> Acta Informatica, </journal> <year> 1977. </year>
Reference-contexts: The structure can be constructed in O (n log b n) time and requires O (n=b) storage space. Proof: The static k-d tree has dn=be leaf nodes, or, partitions of data space. From Lee and Wong's arguments <ref> [15] </ref>, it follows that the maximum number of nodes that are visited in a query which does not retrieve any data points is c = (n=b) (d1)=d . This is because the query partially intersects these partitions.
Reference: [16] <author> E. M. McCreight. </author> <title> Priority search trees. </title> <journal> SIAM Journal of Computing, </journal> <volume> 14(2) </volume> <pages> 257-275, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: His technique [6], which combines the dd-trees of Mehlhorn [17] with the priority search trees of <ref> [16] </ref>, achieved poly-logarithmic query and update times using optimal storage space. Since priority search trees are defined in terms of balanced binary trees, this technique does not extend to external-memory structures with arbitrary node capacities (b).
Reference: [17] <author> K. Mehlhorn. </author> <title> Data Structures and Algorithms 3: Multidimensional Searching and Computational Geometry. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: To answer the question if poly-logarithmic query times can be achieved using linear storage space, Chazelle [8] proved that poly-logarithmic query times require at least O (n (log n= log log n) d1 ) storage space. His technique [6], which combines the dd-trees of Mehlhorn <ref> [17] </ref> with the priority search trees of [16], achieved poly-logarithmic query and update times using optimal storage space. Since priority search trees are defined in terms of balanced binary trees, this technique does not extend to external-memory structures with arbitrary node capacities (b). <p> In contrast, structures such as R-trees and Bang files which are popular in database literature for their (experimental) average performance have a worst-case time complexity of O (n=b). Node Non-Replicating Query Time Insert/Delete Times Capacity b Structure Lower Bound O (n (d1) <ref> [17] </ref> b 4 Pseudo k-d tree O (n (d1)(1+*) [19] Divided k-d tree O (n (d1) [19] Lower Bound O ((n=b) (d1) [this paper] Arbitrary b O-tree O ((n=b) (d1) [this paper] R-trees, Bang Files O ((n=b) + t=b) O (log b n) [13, 10] Table 1: Comparison of Index Structures <p> Since our model is a direct extension of the pointer-machine model, functional data structures of Chazelle [7] do not fit in it. 2.2 Lower Bound In this subsection, we obtain a lower bound on range query time complexity in non-replicating structures. Our lower bound extends the result of Mehlhorn <ref> [17] </ref>. His proof does not consider b, the node capacity of index nodes. As a result, the ensuing lower bound is independent of b. For realistic external-memory devices, the 3 value of b could be quite large and cannot be ignored in complexity analysis. <p> In static environments, Bentley's k-d trees [2] and Mehlhorn's dd-trees <ref> [17] </ref> meet the lower bound when b = 2. We briefly describe how the k-d trees can be extended to arbitrary b-ary tree in the next section. We show that the resultant structure meets the above lower bound for query complexity in b-ary trees. <p> Therefore, our lower bound estimated query time complexity as a function of the number of data items (n), their dimensionality (d) and the capacity of an index node (b). In contrast, the existing bound by Mehlhorn <ref> [17] </ref> did not take the node capacity into account. We then proposed a new dynamic structure, called the O-tree, that meets the lower bound for query time complexity. This is the only dynamic structure that meets the lower bound in a pointer-machine model of external memory.
Reference: [18] <author> M. Overmars. </author> <title> The design of dynamic data structures. </title> <booktitle> Lecture Notes in Computer Science 156, </booktitle> <year> 1983. </year>
Reference-contexts: Since this number is O (n=(km)) = O (log 2 n), each insertion/deletion takes at least O ((log 2 n) log (log 2 n)) time in Step 2. In Step 3, re-balancing of the trees can be accomplished using the technique of partial rebuilding <ref> [18] </ref>. Here, each B-tree of n partitions is reconstructed after ffn more partitions are created or deleted, where ff is a small fraction. Since there are at most O (log n) levels in a tree of n points, the time for such reconstruction is O (n log n).
Reference: [19] <author> M. Overmars and J. van Leeuwen. </author> <title> Worst-case optimal insertion and deletion methods for decomposable searching problems. </title> <journal> Information Processing Letters, </journal> <volume> 12(4) </volume> <pages> 168-172, </pages> <year> 1981. </year>
Reference-contexts: Bentley's k-d tree [2] meets the proposed lower bound on query time for a static database. Among dynamic structures, the pseudo quad and k-d trees <ref> [19] </ref> support updates in O (log 2 n) time and queries in O (n (d1)fl (1+*)=d ) time. The divided k-d tree of [27] improves both the update time and the query time of the pseudo k-d trees to O (log n) and O (n (d1)=d log 1=d n) respectively. <p> Node Non-Replicating Query Time Insert/Delete Times Capacity b Structure Lower Bound O (n (d1) [17] b 4 Pseudo k-d tree O (n (d1)(1+*) <ref> [19] </ref> Divided k-d tree O (n (d1) [19] Lower Bound O ((n=b) (d1) [this paper] Arbitrary b O-tree O ((n=b) (d1) [this paper] R-trees, Bang Files O ((n=b) + t=b) O (log b n) [13, 10] Table 1: Comparison of Index Structures for Dynamic Range Searching: The results of this paper <p> Node Non-Replicating Query Time Insert/Delete Times Capacity b Structure Lower Bound O (n (d1) [17] b 4 Pseudo k-d tree O (n (d1)(1+*) <ref> [19] </ref> Divided k-d tree O (n (d1) [19] Lower Bound O ((n=b) (d1) [this paper] Arbitrary b O-tree O ((n=b) (d1) [this paper] R-trees, Bang Files O ((n=b) + t=b) O (log b n) [13, 10] Table 1: Comparison of Index Structures for Dynamic Range Searching: The results of this paper are shown highlighted. <p> The above arguments show that this organization achieves optimal range query time and logarithmic update time. The update times are amortized bounds and can be turned into worst-case using the techniques of <ref> [19] </ref>. A detailed analysis of these results is provided in [21]. Note that in the above description, we assumed a 2-3 tree as the basic building structure. By appropriately modifying it with an arbitrary b-ary tree, we obtain the following result. <p> Each entry is of the form - (c; br), where c refers to a child node and br is the bounding rectangle for all points in the subtree rooted at child c. The R-tree is a dynamic structure and supports insertions/deletions by local rebuilding <ref> [9, 19] </ref>. Local rebuilding (or balancing) denotes the technique applied to search trees so that they maintain logarithmic height during a sequence of updates. Since the R-tree is based on a B + -tree structure, it employs a similar local rebuilding technique as the latter.
Reference: [20] <author> K. V. Ravi Kanth and Ambuj K. Singh. </author> <title> Efficient dynamic range searching using data replication. </title> <type> Technical Report TRCS97-12, </type> <institution> UCSB, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: Storage space used is O (n=b). 5 Conclusions In this paper, we examined the complexity of range searching in external-memory structures. Most existing results for range searching such as the range trees [3, 6, 8, 24] and multi-level range trees <ref> [4, 29, 20] </ref> involve high-replication of data items and consequently high storage costs and update times.
Reference: [21] <author> K. V. Ravi Kanth and Ambuj K. Singh. </author> <title> Optimal dynamic range searching in non-replicating index structures. </title> <type> Technical Report TRCS97-13, </type> <institution> UCSB, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: All these structures use non-linear storage space which may be too high for large database systems. When only linear-space is used, Bentley's multi-level range structures [4] and its dynamic variants <ref> [29, 21] </ref> obtain O (n * ) query times for any * &gt; 0. However, these structures replicate each data item at least (1=*) d times. This storage cost may be still quite high for most database systems. <p> This adds a logarithmic amortized cost to each update due to reconstruction of each layer B-tree. Since the number of such layers is d, the total accrued cost for an update is O (log n). More details are given in <ref> [21] </ref>. Combining the above three costs, a C-tree for n points supports range queries in optimal time and insertions/deletions in O (log n + (log 2 n) log (log 2 n)) time. <p> The above arguments show that this organization achieves optimal range query time and logarithmic update time. The update times are amortized bounds and can be turned into worst-case using the techniques of [19]. A detailed analysis of these results is provided in <ref> [21] </ref>. Note that in the above description, we assumed a 2-3 tree as the basic building structure. By appropriately modifying it with an arbitrary b-ary tree, we obtain the following result.
Reference: [22] <author> H. Samet. </author> <title> The design and analysis of spatial data structures. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference: [23] <author> T. Sellis, N. Roussopoulos, and C. Faloutsos. </author> <title> The R+ tree: A dynamic index for multi-dimensional objects. </title> <booktitle> Proc. of the Intl. Conf. on Very Large Databases, </booktitle> <pages> pages 507-518, </pages> <year> 1988. </year> <month> 17 </month>
Reference-contexts: Appendix A Analysis of R-trees and Bang Files A.1 Range Query Time Complexity of R-trees We demonstrate that for specific data points and queries, the R-tree and its variants <ref> [1, 5, 13, 23] </ref> have a worst-case complexity of O (n) for range queries on n data points. The R-tree is an extension of the B + -tree for 12 multidimensional data. As in the B + -tree, data is stored in the leaves.
Reference: [24] <author> S. Subramanian and S. Ramaswamy. </author> <title> The P-range tree: A new data structure for range searching in secondary memory. </title> <booktitle> Proc. ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 378-387, </pages> <year> 1995. </year>
Reference-contexts: Large block sizes of external-memory devices, which correspond to node sizes of an index structure, lead to higher node capacities than 2 or 3. Sensing this need for large node capacities and their subsequent impact on query performance, Subramanian and Ramaswamy <ref> [24] </ref> propose the P-range tree as an extension of binary priority range search tree for realistic external-memory environments. This structure when combined with Chazelle's proposal extends the range searching results of Chazelle to external-memory structures with an arbitrary node capacity b. <p> Insertions and deletions are supported in O (log b n) amortized time. Storage space used is O (n=b). 5 Conclusions In this paper, we examined the complexity of range searching in external-memory structures. Most existing results for range searching such as the range trees <ref> [3, 6, 8, 24] </ref> and multi-level range trees [4, 29, 20] involve high-replication of data items and consequently high storage costs and update times.
Reference: [25] <author> R. E. Tarjan. </author> <title> A class of algorithms which require non-linear time to maintain disjoint sets. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 18 </volume> <pages> 110-127, </pages> <year> 1979. </year>
Reference-contexts: Note that this tree model is more restrictive than Chazelle's model [8], where data structures are represented as DAGs, or the more general "pointer-machine" model of Tarjan <ref> [25] </ref>. Non-replication is hard to enforce in a graph model since multiple paths to same data items are possible without actually replicating the data items themselves.
Reference: [26] <author> P. M. Vaidya. </author> <title> Space-time tradeoffs for orthogonal range queries. </title> <journal> SIAM Journal of Computing, </journal> <volume> 18(4) </volume> <pages> 748-758, </pages> <year> 1989. </year>
Reference-contexts: The result of a query is obtained by the union of the result sets of all visited index nodes. The above model for an index structure is similar to the tree model of Vaidya <ref> [26] </ref>. However, there are two differences: (1) Search predicates are represented as conjunction of comparisons rather than a disjunction of comparisons. (2) The data associated with an index node is bounded.
Reference: [27] <author> M. van Kreveld and M. Overmars. </author> <title> The divided k-d tree. </title> <journal> Algorithmica, </journal> <volume> 6 </volume> <pages> 840-858, </pages> <year> 1991. </year>
Reference-contexts: Non-replicating structures have several advantages such as low storage costs and simple updating procedures due to lack of multiple copies of data items. They are the most appropriate structures for large multi-dimensional database systems with small external-memory resources. Examples of such structures include k-d trees [2], divided k-d trees <ref> [27] </ref>, R-trees [13, 1, 5], Bang files [10, 11], SS-trees [28]. All these data structures use linear space. However, they differ considerably in their query and update time complexities. <p> Bentley's k-d tree [2] meets the proposed lower bound on query time for a static database. Among dynamic structures, the pseudo quad and k-d trees [19] support updates in O (log 2 n) time and queries in O (n (d1)fl (1+*)=d ) time. The divided k-d tree of <ref> [27] </ref> improves both the update time and the query time of the pseudo k-d trees to O (log n) and O (n (d1)=d log 1=d n) respectively. Note that the factor of log 1=d n is asymptotically smaller than n * . <p> This latter organization corresponds to the divided k-d tree of Kreveld and Overmars <ref> [27] </ref>. Consider an alternative organization for the data in sub-partitions of Figure 2 to reduce the search costs. Assume each sub-partition is organized as a static k-d tree. <p> Hence, this structure is optimal 8 for range queries. We refer to this structure as the combined k-d tree, C-tree for short, since it combines the divided k-d tree with the static k-d trees. As in the divided k-d tree <ref> [27] </ref>, the C-tree has 2-layers of B-trees, each organized on a different dimension. However, at both the layers, every B-tree has k = O ( p n= log n) partitions. The exact value of k will be specified later.
Reference: [28] <author> D. White and R. Jain. </author> <title> Similarity indexing with the SS-tree. </title> <booktitle> International Conference on Data Engineering, </booktitle> <year> 1996. </year>
Reference-contexts: They are the most appropriate structures for large multi-dimensional database systems with small external-memory resources. Examples of such structures include k-d trees [2], divided k-d trees [27], R-trees [13, 1, 5], Bang files [10, 11], SS-trees <ref> [28] </ref>. All these data structures use linear space. However, they differ considerably in their query and update time complexities.
Reference: [29] <author> D. E. Willard. </author> <title> On the application of sheared retrieval to orthogonal range queries. </title> <booktitle> ACM Symposium on Computational Geometry, </booktitle> <pages> pages 80-86, </pages> <year> 1986. </year> <month> 18 </month>
Reference-contexts: All these structures use non-linear storage space which may be too high for large database systems. When only linear-space is used, Bentley's multi-level range structures [4] and its dynamic variants <ref> [29, 21] </ref> obtain O (n * ) query times for any * &gt; 0. However, these structures replicate each data item at least (1=*) d times. This storage cost may be still quite high for most database systems. <p> Storage space used is O (n=b). 5 Conclusions In this paper, we examined the complexity of range searching in external-memory structures. Most existing results for range searching such as the range trees [3, 6, 8, 24] and multi-level range trees <ref> [4, 29, 20] </ref> involve high-replication of data items and consequently high storage costs and update times.
References-found: 29

