URL: http://robotics.eecs.berkeley.edu/~emiris/papers/scog92journal.ps.gz
Refering-URL: http://robotics.eecs.berkeley.edu/~emiris/
Root-URL: 
Title: Efficient Perturbations for Handling Geometric Degeneracies  
Author: Ioannis Z. Emiris, John F. Canny, and Raimund Seidel 
Keyword: Key words. Input degeneracy, efficient perturbations, algorithm implementation, general-dimensional convex hulls.  
Date: February 16, 1995  
Abstract: This article defines input perturbations so that an algorithm designed under certain restrictions on the input can execute on arbitrary instances. A syntactic definition of perturbations is proposed and certain properties specified under which an algorithm executed on perturbed input produces an output from which the exact answer can be recovered. A general framework is adopted for linear perturbations, which are efficient from the point of view of worst-case complexity. The deterministic scheme of Emiris and Canny [1] was the first efficient scheme and is extended in a consistent manner, most notably to the InSphere primitive. We introduce a variant scheme, applicable to a restricted class of algorithms, which is almost optimal in terms of the algebraic as well as the bit complexity. Neither scheme requires any symbolic computation and both are simple to use as illustrated by our implementation of a Convex Hull algorithm in arbitrary dimension. Empirical results and a concrete application in robotics are discussed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> I.Z. Emiris and J.F. Canny. </author> <title> A general approach to removing degeneracies. </title> <journal> SIAM J. Computing, </journal> <volume> 24(3), </volume> <year> 1995. </year> <note> To appear. A preliminary version in Proc. FOCS '91, pp. 405-413. </note>
Reference-contexts: The main drawback of previous approaches [2, 3] is that they increase the worst-case asymptotic complexity by an exponential factor in the space dimension, which makes them unattractive for algorithms in general dimension. The deterministic perturbation of Emiris and Canny <ref> [1] </ref> was the first efficient scheme in the sense that the algebraic complexity overhead is at most logarithmic in the dimension. It was applied to the Orientation and Transversality primitives. The second contribution of this article is to extend the applicability of this scheme to the InSphere and Ordering primitives. <p> The conclusion summarizes the main results and suggests some open questions. This article represents the final version of certain results presented in preliminary form in [14]. 2 Definitions Our approach is largely based on those of Edelsbrunner [2] and Yap [3]. The formalization of Emiris and Canny <ref> [1] </ref> focuses on the desired effects of the perturbation. The current setting, first introduced by Seidel [15], offers a syntactic definition of perturbations. <p> All inputs not dealt with by a program can be modeled by the vanishing of some polynomial in the input. Conforming to the standard viewpoint in the literature <ref> [2, 3, 1] </ref> we have Definition 5 An input instance is degenerate with respect to some program if and only if it causes some numerator or denominator polynomial f at a branch to vanish, where f is not identically zero. <p> He uses towers of infinitesimals to eliminate degeneracies while preserving essential properties of the sets, namely emptiness and cardinality of connected components. Emiris and Canny presented in <ref> [1] </ref> an infinitesimal perturbation that constitutes the first efficient scheme, inspired by the SoS method. For geometric algorithms, every coordinate x i;j is deterministically perturbed into x i;j (*) = x i;j + * i j ; (1) where * is a symbolic infinitesimal. <p> These bounds are obtained by assuming that the unperturbed program implements sign determination by determinant evaluation and that a constant fraction of input points are distinct. For a wider class of algorithms with branching at arbitrary rational expressions randomization is traded for efficiency <ref> [1] </ref>. The i-th perturbed point is x i (*) = x i + *r i ; 1 i N; where r i is a random integer uniformly chosen from a sufficiently large interval R Z. <p> For completeness we state the following proposition which relies on Theorem 8, the properties of Vandermonde matrices and Corollary 14. Proposition 16 <ref> [1] </ref> Perturbation (1) is valid with respect to algorithms that branch on determinants of fl ffi+1 and ffi , for ffi d, where d is the space dimension. The perturbation increases the asymptotic running-time complexity of evaluating the primitive, under the algebraic model, by O (log d).
Reference: [2] <author> H. Edelsbrunner and E.P. Mucke. </author> <title> Simulation of simplicity: A technique to cope with degenerate cases in geometric algorithms. </title> <journal> ACM Trans. Graphics, </journal> <volume> 9(1) </volume> <pages> 67-104, </pages> <year> 1990. </year>
Reference-contexts: We discuss how to recover the answer to the original problem from the output on perturbed input, either directly or after some case-specific postprocessing. Some general techniques for designing and evaluating efficient perturbations for a wide class of geometric primitives are suggested. The main drawback of previous approaches <ref> [2, 3] </ref> is that they increase the worst-case asymptotic complexity by an exponential factor in the space dimension, which makes them unattractive for algorithms in general dimension. <p> The conclusion summarizes the main results and suggests some open questions. This article represents the final version of certain results presented in preliminary form in [14]. 2 Definitions Our approach is largely based on those of Edelsbrunner <ref> [2] </ref> and Yap [3]. The formalization of Emiris and Canny [1] focuses on the desired effects of the perturbation. The current setting, first introduced by Seidel [15], offers a syntactic definition of perturbations. <p> All inputs not dealt with by a program can be modeled by the vanishing of some polynomial in the input. Conforming to the standard viewpoint in the literature <ref> [2, 3, 1] </ref> we have Definition 5 An input instance is degenerate with respect to some program if and only if it causes some numerator or denominator polynomial f at a branch to vanish, where f is not identically zero. <p> Edelsbrunner and Mucke generalize in <ref> [2] </ref> a technique called Simulation of Simplicity (SoS for short), already presented in [21], which refines the above method. Every input coordinate x i;j is perturbed into x i;j (*) = x i;j + * 2 iffij ; where ffi &gt; d and d is the dimension. <p> Specifically, deciding the sign of a d fi d perturbed determinant, although rather fast on the average, requires the calculation of (2 d ) minors in the worst case. We indicate how this bound is established for the case of the Orientation primitive. In <ref> [2] </ref> the Orientation primitive on perturbed input is reduced to the evaluation of a sequence of minors of the original d fi d matrix. <p> d+1 ;2 : : : x i d+1 ;d j=1 x 2 1 x i d+2 ;1 x i d+2 ;2 : : : x i d+2 ;d j=1 x 2 3 7 7 7 : Eliminating degeneracies for the particular matrix could be achieved by the "cheap trick" of <ref> [2] </ref> which perturbs the points on the higher-dimensional paraboloid, by perturbing the sum of squares as if it were an additional coordinate. However, this may lead to inconsistencies in some special configurations, if the same algorithm also uses another primitive such as fl d+1 .
Reference: [3] <author> C.-K. Yap. </author> <title> Symbolic treatment of geometric degeneracies. </title> <journal> J. Symbolic Comput., </journal> <volume> 10 </volume> <pages> 349-370, </pages> <year> 1990. </year>
Reference-contexts: We discuss how to recover the answer to the original problem from the output on perturbed input, either directly or after some case-specific postprocessing. Some general techniques for designing and evaluating efficient perturbations for a wide class of geometric primitives are suggested. The main drawback of previous approaches <ref> [2, 3] </ref> is that they increase the worst-case asymptotic complexity by an exponential factor in the space dimension, which makes them unattractive for algorithms in general dimension. <p> The conclusion summarizes the main results and suggests some open questions. This article represents the final version of certain results presented in preliminary form in [14]. 2 Definitions Our approach is largely based on those of Edelsbrunner [2] and Yap <ref> [3] </ref>. The formalization of Emiris and Canny [1] focuses on the desired effects of the perturbation. The current setting, first introduced by Seidel [15], offers a syntactic definition of perturbations. <p> All inputs not dealt with by a program can be modeled by the vanishing of some polynomial in the input. Conforming to the standard viewpoint in the literature <ref> [2, 3, 1] </ref> we have Definition 5 An input instance is degenerate with respect to some program if and only if it causes some numerator or denominator polynomial f at a branch to vanish, where f is not identically zero. <p> Equivalently, an input instance is generic with respect to this program if there is no such branch polynomial. Yap <ref> [3] </ref> distinguishes between problem-dependent degeneracies i.e. those where is discontinuous, and algorithm induced degeneracies, such as the covertical points for the sweep-line algorithm. <p> A simple counting argument now implies the lower bound. For other primitives a similar argument works. Yap <ref> [3] </ref> deals with the more general setting in which branching occurs at arbitrary rational expressions and proposes a method which is equivalent to an infinitesimal perturbation [22]. Recently, it has been extended to analytic test functions [15].
Reference: [4] <author> S. Teller and C.H. Sequin. </author> <title> Visibility preprocessing for interactive walkthroughs. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '91), </booktitle> <volume> 25(4) </volume> <pages> 61-69, </pages> <year> 1991. </year>
Reference-contexts: Supported by NSF PYI Grant CCR-9058440. geometric problem with a wide variety of applications, such as visibility and illumination in geometric modeling and graphics <ref> [4, 5] </ref>, predicting the poses of industrial parts on a conveyor belt and computing stable grasps [6, 7], collision detection in robotics and animation [8], material identification in geology [9], molecular docking in drug fabrication [10] as well as in solving systems of nonlinear equations [11, 12, 13].
Reference: [5] <author> S. Teller, C. Fowler, T. Funkhouser, and P. Hanrahan. </author> <title> Partitioning and Ordering Large Radiosity Computations. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '94), </booktitle> <volume> 28, </volume> <year> 1994. </year>
Reference-contexts: Supported by NSF PYI Grant CCR-9058440. geometric problem with a wide variety of applications, such as visibility and illumination in geometric modeling and graphics <ref> [4, 5] </ref>, predicting the poses of industrial parts on a conveyor belt and computing stable grasps [6, 7], collision detection in robotics and animation [8], material identification in geology [9], molecular docking in drug fabrication [10] as well as in solving systems of nonlinear equations [11, 12, 13].
Reference: [6] <author> J. Wiegley, A. Rao, and K. Goldberg. </author> <title> Computing a statistical distribution of stable poses for a polyhedron. </title> <booktitle> In Proc. 30th Annual Allerton Conf. on Comm. Control and Computing, </booktitle> <address> U.Ill. Urbana-Champaign, </address> <year> 1992. </year>
Reference-contexts: Supported by NSF PYI Grant CCR-9058440. geometric problem with a wide variety of applications, such as visibility and illumination in geometric modeling and graphics [4, 5], predicting the poses of industrial parts on a conveyor belt and computing stable grasps <ref> [6, 7] </ref>, collision detection in robotics and animation [8], material identification in geology [9], molecular docking in drug fabrication [10] as well as in solving systems of nonlinear equations [11, 12, 13]. This article is organized as follows. <p> The first author has adapted this program for commercial use in computing the pose of an industrial part that falls on a conveyor belt. The algorithm computes the convex hull facets, then projects them on a sphere to compute the probability of the object landing on this facet <ref> [6] </ref>. This information is then used by the gripper in order to grasp and move the part from the belt. The input comes in floating-point numbers: we calculate the smallest power of 10 that produces signed integers of at most 31 bits and multiply the data by this power.
Reference: [7] <editor> K. Goldberg and M.T. Mason. </editor> <booktitle> Bayesian grasping. In Proc. IEEE Conf. on Robotics and Automation, </booktitle> <year> 1990. </year>
Reference-contexts: Supported by NSF PYI Grant CCR-9058440. geometric problem with a wide variety of applications, such as visibility and illumination in geometric modeling and graphics [4, 5], predicting the poses of industrial parts on a conveyor belt and computing stable grasps <ref> [6, 7] </ref>, collision detection in robotics and animation [8], material identification in geology [9], molecular docking in drug fabrication [10] as well as in solving systems of nonlinear equations [11, 12, 13]. This article is organized as follows.
Reference: [8] <author> M.C. Lin, D. Manocha, and J. Canny. </author> <title> Efficient Contact Determination for Dynamic Environments. </title> <booktitle> In Proc. IEEE Intern. Conf. Robotics and Automation, </booktitle> <pages> pages 602-608, </pages> <year> 1994. </year>
Reference-contexts: Supported by NSF PYI Grant CCR-9058440. geometric problem with a wide variety of applications, such as visibility and illumination in geometric modeling and graphics [4, 5], predicting the poses of industrial parts on a conveyor belt and computing stable grasps [6, 7], collision detection in robotics and animation <ref> [8] </ref>, material identification in geology [9], molecular docking in drug fabrication [10] as well as in solving systems of nonlinear equations [11, 12, 13]. This article is organized as follows.
Reference: [9] <author> J.W. Boardman. </author> <title> Automated spectral unmixing of aviris data using convex geometry concepts. </title> <booktitle> In Proc. 4th Airborne Geoscience Workshop, </booktitle> <address> Washington, D.C., </address> <month> October </month> <year> 1993. </year>
Reference-contexts: PYI Grant CCR-9058440. geometric problem with a wide variety of applications, such as visibility and illumination in geometric modeling and graphics [4, 5], predicting the poses of industrial parts on a conveyor belt and computing stable grasps [6, 7], collision detection in robotics and animation [8], material identification in geology <ref> [9] </ref>, molecular docking in drug fabrication [10] as well as in solving systems of nonlinear equations [11, 12, 13]. This article is organized as follows.
Reference: [10] <author> M.L. Connolly. </author> <title> Molecular Interstitial Skeleton. </title> <journal> Computers Chem., </journal> <volume> 15(1) </volume> <pages> 37-45, </pages> <year> 1991. </year>
Reference-contexts: a wide variety of applications, such as visibility and illumination in geometric modeling and graphics [4, 5], predicting the poses of industrial parts on a conveyor belt and computing stable grasps [6, 7], collision detection in robotics and animation [8], material identification in geology [9], molecular docking in drug fabrication <ref> [10] </ref> as well as in solving systems of nonlinear equations [11, 12, 13]. This article is organized as follows. The next section defines the computational model, the problem at hand, the notion of perturbations and how they are implemented and examines some positive and negative consequences of applying them.
Reference: [11] <author> B. Huber and B. Sturmfels. </author> <title> A polyhedral method for solving sparse polynomial systems. </title> <journal> Math. Comp. </journal> <note> To appear. A preliminary version presented at the Workshop on Real Algebraic Geometry, </note> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: in geometric modeling and graphics [4, 5], predicting the poses of industrial parts on a conveyor belt and computing stable grasps [6, 7], collision detection in robotics and animation [8], material identification in geology [9], molecular docking in drug fabrication [10] as well as in solving systems of nonlinear equations <ref> [11, 12, 13] </ref>. This article is organized as follows. The next section defines the computational model, the problem at hand, the notion of perturbations and how they are implemented and examines some positive and negative consequences of applying them.
Reference: [12] <author> I. Emiris and J. Canny. </author> <title> A practical method for the sparse resultant. </title> <booktitle> In Proc. ACM Intern. Symp. on Symbolic and Algebraic Computation, </booktitle> <pages> pages 183-192, </pages> <address> Kiev, </address> <year> 1993. </year> <month> 15 </month>
Reference-contexts: in geometric modeling and graphics [4, 5], predicting the poses of industrial parts on a conveyor belt and computing stable grasps [6, 7], collision detection in robotics and animation [8], material identification in geology [9], molecular docking in drug fabrication [10] as well as in solving systems of nonlinear equations <ref> [11, 12, 13] </ref>. This article is organized as follows. The next section defines the computational model, the problem at hand, the notion of perturbations and how they are implemented and examines some positive and negative consequences of applying them.
Reference: [13] <author> I.Z. Emiris. </author> <title> Sparse Eliminations and Applications in Kinematics. </title> <type> PhD thesis, </type> <institution> Computer Science Division, Department of Electrical Engineering and Computer Science, University of California, Berkeley, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: in geometric modeling and graphics [4, 5], predicting the poses of industrial parts on a conveyor belt and computing stable grasps [6, 7], collision detection in robotics and animation [8], material identification in geology [9], molecular docking in drug fabrication [10] as well as in solving systems of nonlinear equations <ref> [11, 12, 13] </ref>. This article is organized as follows. The next section defines the computational model, the problem at hand, the notion of perturbations and how they are implemented and examines some positive and negative consequences of applying them. <p> If A r is singular the approach of <ref> [13] </ref> can be applied; in the current context A r is always nonsingular.
Reference: [14] <author> I. Emiris and J. Canny. </author> <title> An efficient approach to removing geometric degeneracies. </title> <booktitle> In Proc. 8th ACM Symp. on Computational Geometry, </booktitle> <pages> pages 74-82, </pages> <year> 1992. </year>
Reference-contexts: Section 7 presents our implementation of the Beneath-Beyond algorithm and a specific application to robotics. The conclusion summarizes the main results and suggests some open questions. This article represents the final version of certain results presented in preliminary form in <ref> [14] </ref>. 2 Definitions Our approach is largely based on those of Edelsbrunner [2] and Yap [3]. The formalization of Emiris and Canny [1] focuses on the desired effects of the perturbation. The current setting, first introduced by Seidel [15], offers a syntactic definition of perturbations.
Reference: [15] <author> R. Seidel. </author> <title> The nature and meaning of perturbations in geometric computing. </title> <booktitle> In Proc. 11th Symp. Theoret. Aspects Computer Science, Lect. Notes Computer Science 775, </booktitle> <pages> pages 3-17. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The formalization of Emiris and Canny [1] focuses on the desired effects of the perturbation. The current setting, first introduced by Seidel <ref> [15] </ref>, offers a syntactic definition of perturbations. All approaches, however, are essentially equivalent and lead, for a given set of primitives, to the same requirements on the perturbation schemes. 2.1 Computational model Our model is the real Random Access Machine (RAM) of [16]. <p> For other primitives a similar argument works. Yap [3] deals with the more general setting in which branching occurs at arbitrary rational expressions and proposes a method which is equivalent to an infinitesimal perturbation [22]. Recently, it has been extended to analytic test functions <ref> [15] </ref>.
Reference: [16] <author> F.P. Preparata and M.I. Shamos. </author> <title> Computational Geometry: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: The current setting, first introduced by Seidel [15], offers a syntactic definition of perturbations. All approaches, however, are essentially equivalent and lead, for a given set of primitives, to the same requirements on the perturbation schemes. 2.1 Computational model Our model is the real Random Access Machine (RAM) of <ref> [16] </ref>. The input is organized as a set of n vectors in R d , where n d &gt; 0 and the i-th vector is x i = (x i;1 ; : : : ; x i;d ) for 1 i n; 1 j d.
Reference: [17] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass, </address> <year> 1974. </year>
Reference-contexts: More realistically, we must keep track of the operands' bit size: under the bit model only the input, output and branching instructions are assigned unit cost. For integers of size O (b), addition and subtraction require O (b) bit operations <ref> [17] </ref> while multiplication and division require O (b log b log log b) bit operations. We shall use M (b) = O (b log b log log b) as an upper bound on the bit complexity of any arithmetic operation between any two integers of size O (b). <p> These are pairs of * specializations, usually at distinct primes, and the respective values of the polynomial. If ffi + 1 interpolation pairs are available, dense interpolation can be used to compute the coefficients in O (ffi log 2 ffi) arithmetic operations <ref> [17] </ref>. If, furthermore, there is an a priori bound T on the number of nonzero terms that is significantly lower than the maximum number ffi + 1, then sparse interpolation is preferable.
Reference: [18] <author> K. Dobrindt, K. Mehlhorn, and M. Yvinec. </author> <title> A complete framework for the intersection of a general polyhedron with a convex one. </title> <booktitle> In Proc. 3rd Workshop Algorithms Data Struct., Lect. Notes Comp. Science 709, </booktitle> <pages> pages 314-324. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: Postprocessing then has to merge these segments by eliminating points in the interior of polygon edges. This process is analyzed for the general CHF problem in Section 7 and a practical approach is discussed for the three-dimensional CHF problem. Postprocessing for the problem of polytope intersection is examined in <ref> [18] </ref>. 2.3 Computing with Perturbations Given a program that implements , the question is how to obtain another real RAM program that implements . <p> covering some common geometric primitives and study the issue of efficiently executing a transformed program. 4 3 Previous work The simplest approach in coping with degeneracies is to handle each special case separately, which is tedious for implementors and unattractive for theoreticians, though some recent work re-examines this common belief <ref> [18, 19] </ref>. Dantzig's [20] symmetry breaking rules in Linear Programming are regarded as the precursor of current systematic perturbations. The principal idea is to perturb the right-hand side of every constrain by an infinitesimal quantity that depends on the index of this constrain. <p> Since we are free in choosing this matrix, it is possible to simulate either SoS or any of our schemes presented below. Dobrindt, Mehlhorn and Yvinec proposed an efficient scheme specifically for coping with degenerate intersections between a convex and a general polyhedron in three dimensions <ref> [18] </ref>. Since the vertices of the convex polyhedron 5 are guaranteed to be perturbed in a specific direction with respect to the given facets, this is another instance of a controlled perturbation. <p> The basic existential question on the perturbation method is still open. After the flurry of papers proposing different perturbation schemes, recent work argues against the general applicability of this method <ref> [18, 19, 36] </ref> motivated by the observation that the difficulty and complexity of postprocessing might sometimes dominate that of the entire program. Indeed, perturbations should not be treated as a panacea but should rather be considered in the specific context of the algorithm and the output desired.
Reference: [19] <author> C. Burnikel, K. Mehlhorn, and S. Schirra. </author> <title> On degeneracy in geometric computations. </title> <booktitle> In Proc. 5th ACM-SIAM Symp. on Discr. Algorithms, </booktitle> <pages> pages 16-23, </pages> <year> 1994. </year>
Reference-contexts: covering some common geometric primitives and study the issue of efficiently executing a transformed program. 4 3 Previous work The simplest approach in coping with degeneracies is to handle each special case separately, which is tedious for implementors and unattractive for theoreticians, though some recent work re-examines this common belief <ref> [18, 19] </ref>. Dantzig's [20] symmetry breaking rules in Linear Programming are regarded as the precursor of current systematic perturbations. The principal idea is to perturb the right-hand side of every constrain by an infinitesimal quantity that depends on the index of this constrain. <p> For instance, given n coincident points as input to an algorithm solving the CHF problem, the exact output is a single point whereas the perturbed output is a polytope with n bd=2c facets. See <ref> [19] </ref> for a discussion of limitations of the perturbation approach. 6.1 Ordering The Ordering, or Sorting, primitive decides the order of two quantities expressing the k-th coordinate of the i 1 -th and i 2 -th input points. <p> The basic existential question on the perturbation method is still open. After the flurry of papers proposing different perturbation schemes, recent work argues against the general applicability of this method <ref> [18, 19, 36] </ref> motivated by the observation that the difficulty and complexity of postprocessing might sometimes dominate that of the entire program. Indeed, perturbations should not be treated as a panacea but should rather be considered in the specific context of the algorithm and the output desired.
Reference: [20] <author> G.B. Dantzig. </author> <title> Linear Programming and Extensions. </title> <publisher> Princeton University Press, Princeton, </publisher> <year> 1963. </year>
Reference-contexts: Dantzig's <ref> [20] </ref> symmetry breaking rules in Linear Programming are regarded as the precursor of current systematic perturbations. The principal idea is to perturb the right-hand side of every constrain by an infinitesimal quantity that depends on the index of this constrain.
Reference: [21] <author> H. Edelsbrunner. </author> <title> Algorithms in Combinatorial Geometry. </title> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1987. </year>
Reference-contexts: Edelsbrunner and Mucke generalize in [2] a technique called Simulation of Simplicity (SoS for short), already presented in <ref> [21] </ref>, which refines the above method. Every input coordinate x i;j is perturbed into x i;j (*) = x i;j + * 2 iffij ; where ffi &gt; d and d is the dimension. <p> The hardest primitive here is to decide for the intersection of two segments its halfplane with respect to a third segment. 7 Computing Convex Hulls This section discusses our implementation of the Beneath-Beyond algorithm <ref> [21] </ref> which solves the Convex Hull Volume (CHV) problem for finite input sets of integral points in arbitrary dimension, and reports on the running-time performance. The implementation produces approximate solutions to the Convex Hull Face-Structure (CHF) problem, in a sense specified later.
Reference: [22] <author> C.-K. Yap. </author> <title> A geometric consistency theorem for a symbolic perturbation scheme. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 40 </volume> <pages> 2-18, </pages> <year> 1990. </year>
Reference-contexts: A simple counting argument now implies the lower bound. For other primitives a similar argument works. Yap [3] deals with the more general setting in which branching occurs at arbitrary rational expressions and proposes a method which is equivalent to an infinitesimal perturbation <ref> [22] </ref>. Recently, it has been extended to analytic test functions [15].
Reference: [23] <author> J.F. Canny. </author> <title> Computing roadmaps of semi-algebraic sets. </title> <booktitle> In Proc. Intern. Symp. Applied Algebra, Algebraic Algor. and Error-Corr. Codes, </booktitle> <address> New Orleans, </address> <year> 1991. </year>
Reference-contexts: Another merit of this work is that it discusses postprocessing in detail in order to recover the exact solution. A structural perturbation for a motion-planning algorithm, in which the input objects are the semi-algebraic sets describing the obstacles, is given by Canny in <ref> [23] </ref>. He uses towers of infinitesimals to eliminate degeneracies while preserving essential properties of the sets, namely emptiness and cardinality of connected components. Emiris and Canny presented in [1] an infinitesimal perturbation that constitutes the first efficient scheme, inspired by the SoS method.
Reference: [24] <author> R. Zippel. </author> <title> Interpolating polynomials from their values. </title> <journal> J. Symbolic Computation, </journal> <volume> 9 </volume> <pages> 375-403, </pages> <year> 1990. </year>
Reference-contexts: In general, though, defining perturbation vectors b 1 ; : : : ; b n is a hard problem, a stronger version, in fact, of the zero avoidance problem <ref> [24] </ref>. This theorem can be generalized to nonlinear perturbations. 6 4.1 A Validity Criterion We establish a rather general criterion for showing validity. This criterion was motivated by the application of scheme (1) to the InSphere primitive. <p> A deterministic algorithm has complexity O (T 2+ff log ffi) and requires 2T interpolation pairs, where ff again accounts for the polylogarithmic factor. Both algorithms are surveyed in <ref> [24] </ref>. Traditionally, the cost of evaluating the unknown polynomial is of minor concern in the context of the interpolation problem, yet here this cost must be assessed. In general, computing one interpolation pair takes time proportional to the complexity of evaluating the polynomial.
Reference: [25] <author> G.E. Collins and R. Loos. </author> <title> Real zeros of polynomials. </title> <editor> In B. Buchberger, G.E. Collins, and R. Loos, editors, </editor> <booktitle> Computer Algebra: Symbolic and Algebraic Computation, </booktitle> <pages> pages 83-94. </pages> <publisher> Springer-Verlag, Wien, </publisher> <address> 2nd edition, </address> <year> 1982. </year>
Reference-contexts: Proposition 9 (Descartes' Rule of Sign) <ref> [25] </ref> The number of sign variations of a polynomial's nonzero coeffi cients exceeds the number of positive zeros, multiplicities counted, by an even non-negative integer. Proposition 10 Matrix W d+2 is nonsingular for distinct positive i j , 1 j d + 2.
Reference: [26] <author> D. Coppersmith and S. Winograd. </author> <title> Matrix multiplication via arithmetic progressions. </title> <journal> J. Symbolic Computation, </journal> <volume> 9 </volume> <pages> 251-280, </pages> <year> 1990. </year>
Reference-contexts: The rest of this section concentrates on determinantal tests of order t and develops more efficient ways for the combined problem of evaluation and sign determination. Let MM (t) = O (t 2:376 ) <ref> [26] </ref> be the algebraic complexity of multiplying two t fi t matrices and I (I t ) the identity matrix (of order t). The total cost of dense interpolation is O (ffiMM (t)), where ffi t.
Reference: [27] <author> D. Manocha and J. Canny. </author> <title> Multipolynomial resultants and linear algebra. </title> <booktitle> In Proc. ACM Intern. Symp. on Symbolic and Algebraic Computation, </booktitle> <pages> pages 96-102, </pages> <year> 1992. </year>
Reference-contexts: The total cost of dense interpolation is O (ffiMM (t)), where ffi t. An improved technique for 8 interpolating determinants whose entries are higher-degree polynomials in several variables appears in <ref> [27] </ref>. Here we present a near-optimal technique for the case in which the entries are univariate polynomials.
Reference: [28] <author> I. Gohberg, P. Lancaster, and L. Rodman. </author> <title> Matrix Polynomials. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1982. </year>
Reference-contexts: Then we premultiply both sides by A 1 r to obtain A 1 r A r1 * r1 + + A 1 r A 0 : The determinant of the right-hand side equals <ref> [28] </ref> the characteristic polynomial of C = 6 6 6 0 I t 0 0 . . . . . . 0 0 0 I t r A 0 A 1 r A 2 A 1 3 7 7 5 This discussion reduces the sign determination of a univariate matrix to
Reference: [29] <author> J.H. Davenport, Y. Siret, and E. Tournier. </author> <title> Computer Algebra. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1988. </year>
Reference-contexts: For this we may use double precision floating point numbers which provide 53 bits for storing an integer. Besides the classical application of modular arithmetic to integer arithmetic, it can be used with rational data with the same asymptotic complexity <ref> [29] </ref>. The basic approach is as follows.
Reference: [30] <author> W. Keller-Gehrig. </author> <title> Fast algorithms for the characteristic polynomial. </title> <journal> Theor. Comp. Sci., </journal> <volume> 36 </volume> <pages> 309-317, </pages> <year> 1985. </year>
Reference-contexts: Each takes O (MM (t)) time, except from the last step which takes O (MM (t) log t) time, for arbitrary matrices, due to an algorithm by Keller-Gehrig <ref> [30] </ref>. To establish the bit complexity bound, the transformation of Theorem 13 is used. The bit size of the coefficients of the *-polynomial representing the determinant is O (ts) since the original matrix entries have size s and its order is t.
Reference: [31] <author> K.L. Clarkson. </author> <title> Safe and effective determinant evaluation. </title> <booktitle> In Proc. IEEE Symp. Foundations of Comp. Sci., </booktitle> <pages> pages 387-395, </pages> <year> 1992. </year>
Reference-contexts: We make two assumptions in estimating the complexity of the original program. First, that sign determination of determinants is implemented by a determinant calculation. If some cheaper way was employed to find out the sign <ref> [31] </ref> the overhead would increase roughly by a linear factor in d. Second, we assume that the number of distinct input parameters is a constant fraction of n. Hence, if s denotes an upper bound on the bit size of the input data, s = (log n).
Reference: [32] <author> J. von zur Gathen. </author> <title> Algebraic complexity theory. </title> <editor> In J. Traub, editor, </editor> <booktitle> Annual Review of Computer Science, </booktitle> <pages> pages 317-347. </pages> <publisher> Annual Reviews, </publisher> <address> Palo Alto, CA, </address> <year> 1988. </year>
Reference-contexts: Theorem 17 Perturbation (5) is valid with respect to Orientation and Transversality. It increases the worst-case algebraic and bit complexities of the Orientation and Transversality primitives by a O (log d) factor. Proof Validity follows from Theorem 8. The original algebraic complexity is fi (MM (d)) <ref> [32] </ref>. From Corollary 14, the complexity on perturbed input is O (MM (d) log d). The original worst-case bit complexity depends on the size of the answer which is fi (ds).
Reference: [33] <author> T. Thiele, </author> <year> 1993. </year> <type> Personal Communication. </type>
Reference-contexts: Unfortunately, the hypothesis of the theorem is not readily satisfied by the second perturbation (5). A similar scheme, with residues taken mod q, with q = (n d1 ), has been recently shown <ref> [33] </ref> to be valid, offering a slight improvement on complexity.
Reference: [34] <author> H. Edelsbrunner and R. Waupotitsch. </author> <title> Computing a ham-sandwich cut in two dimensions. </title> <journal> J. Symbolic Comput., </journal> <volume> 2 </volume> <pages> 171-178, </pages> <year> 1986. </year>
Reference-contexts: Consider, for instance, the two-dimensional ham-sandwich algorithm in <ref> [34] </ref>, where lines are the input objects and their intersection points are the derived objects. The three primitives of the algorithm are: deciding whether a point lies above or below a line; comparing the first coordinate of two points; and comparing the distances of two points from a line.
Reference: [35] <author> J.L. Bentley, H.T. Kung, M. Schkolnick, and C.D. Thompson. </author> <title> On the average number of maxima in a set of vectors. </title> <journal> J. ACM, </journal> <volume> 25 </volume> <pages> 536-543, </pages> <year> 1978. </year>
Reference-contexts: In the worst case, the hull of n points in d dimensions has O (n bd=2c ) facets. However, the expected number of facets for points selected randomly as above is proportional to log d1 n <ref> [35] </ref>; this is verified by our experimental results. The first author has adapted this program for commercial use in computing the pose of an industrial part that falls on a conveyor belt.
Reference: [36] <author> P. Schorn. </author> <title> Degeneracy in geometric computation and the perturbation approach. </title> <journal> The Computer Journal, </journal> <volume> 37(1) </volume> <pages> 35-42, </pages> <year> 1994. </year>
Reference-contexts: The basic existential question on the perturbation method is still open. After the flurry of papers proposing different perturbation schemes, recent work argues against the general applicability of this method <ref> [18, 19, 36] </ref> motivated by the observation that the difficulty and complexity of postprocessing might sometimes dominate that of the entire program. Indeed, perturbations should not be treated as a panacea but should rather be considered in the specific context of the algorithm and the output desired.
References-found: 36

