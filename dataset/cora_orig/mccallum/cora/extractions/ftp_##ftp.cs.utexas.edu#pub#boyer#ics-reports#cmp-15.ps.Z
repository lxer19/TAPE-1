URL: ftp://ftp.cs.utexas.edu/pub/boyer/ics-reports/cmp-15.ps.Z
Refering-URL: ftp://ftp.cs.utexas.edu/pub/boyer/ics-reports/index.html
Root-URL: 
Phone: (512) 471-1901  
Title: Principals of Proving Concurrent Programs in Gypsy  
Address: 2100 Main Building  Austin, Texas 78712  
Affiliation: Institute for Computing Science  The University of Texas at Austin  
Abstract: Donald I. Good Richard M. Cohen James Keeton-Williams Technical Report 15 January, 1979 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Per Brinch Hansen. </author> <booktitle> Operating Systems Principles. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1973. </year>
Reference-contexts: A process can communicate with another concurrently active process only through a common buffer passed as an actual parameter when the processes were created. Buffers are a predefined structure in Gypsy and closely resemble those defined in <ref> [1] </ref>. A typical buffer declaration is type OBJ_BUF = buffer (MAXSIZE) of object; Buffers are strictly first-in, first-out queues upon which language-defined send and receive operations are mutually excluded in time. <p> The await waits until it can select (nondeterministically) some guard that is not blocked, does the buffer operations and the statement list, then exits the await. Process coordination in Gypsy is done strictly by means of message buffers <ref> [1] </ref>, as opposed to semaphores [4], monitors [8], or conditional critical regions [14]. The buffers are strictly FIFO queues upon which send and receive operations are excluded in time. Similar synchronization mechanisms have been used in the RC4000 operating system [1], and Hydra [18]; but as far as we know, message <p> in Gypsy is done strictly by means of message buffers <ref> [1] </ref>, as opposed to semaphores [4], monitors [8], or conditional critical regions [14]. The buffers are strictly FIFO queues upon which send and receive operations are excluded in time. Similar synchronization mechanisms have been used in the RC4000 operating system [1], and Hydra [18]; but as far as we know, message buffers have not been used previously as a basis for specification and proofs. The Gypsy message buffers are predefined types with predefined axiomatic properties.
Reference: [2] <author> Per Brinch Hansen. </author> <title> The Purpose of Concurrent Pascal. </title> <note> In Proceedings ICRS. </note> <author> Per Brinch Hansen, </author> <year> 1975. </year>
Reference-contexts: The cobegin structure is the basis for decomposing systems into independently verifiable subsystems. This decomposition is possible even in the presence of distributed processing. The similarity of the cobegin to a procedure call is in direct contrast to Concurrent Pascal <ref> [2] </ref> and Modula [17]. In these languages, processes are initialized and then run forever. Restricting the cobegin only to call procedures also is substantially different from [15], which allows arbitrary statement lists as the subprocesses of a cobegin.
Reference: [3] <author> R.M. Cohen. </author> <title> Formal Specifications for Real-Time Systems. </title> <booktitle> In Proceedings Seventh Texas Conference on Computing Systems. R.M. Cohen, </booktitle> <year> 1978. </year>
Reference-contexts: This is the basis for isolating the effects of a procedure so that it can be specified and proved independently of all other procedures. The time stamped buffer histories are being used as a basis for formal specifications of real-time constraints <ref> [3] </ref>. 17 Specifications for procedures that manipulate buffers can be stated in terms of entry and exit assertions about the local buffer histories. The technique for nonterminating processes is similar to the intermittent assertions of [13].
Reference: [4] <author> E.W. Dijkstra. </author> <title> Programming Languages. </title> <publisher> Academic Press, </publisher> <year> 1968, </year> <title> Chapter Cooperating Sequential Processes. </title>
Reference-contexts: The await waits until it can select (nondeterministically) some guard that is not blocked, does the buffer operations and the statement list, then exits the await. Process coordination in Gypsy is done strictly by means of message buffers [1], as opposed to semaphores <ref> [4] </ref>, monitors [8], or conditional critical regions [14]. The buffers are strictly FIFO queues upon which send and receive operations are excluded in time.
Reference: [5] <author> E.W. Dijkstra. </author> <title> Guarded Commands, Nondeterminacy, and Formal Derivation of Programs. </title> <type> CACM 18-8, </type> <year> 1975. </year>
Reference-contexts: In these languages, processes are initialized and then run forever. Restricting the cobegin only to call procedures also is substantially different from [15], which allows arbitrary statement lists as the subprocesses of a cobegin. The await statement is similar to the guarded command of <ref> [5] </ref>, where the guards are buffer operation statements (send, receive) and the commands are arbitrary Gypsy statement lists. The await waits until it can select (nondeterministically) some guard that is not blocked, does the buffer operations and the statement list, then exits the await.
Reference: [6] <author> D.I. Good, R.M. Cohen, C.G. Hoch, L.W. Hunter, D.F. Hare. </author> <title> Report on the Language Gypsy, Version 2.0. </title> <type> Technical Report ICSCA-CMP-10, </type> <institution> Certifiable Minicomputer Project, ICSCA, The University of Texas at Austin, </institution> <month> September, </month> <year> 1978. </year>
Reference-contexts: 1. Introduction The primary objective of Gypsy is to provide an effective, practical language for developing operational software systems of substantial size (1000 - 2000 lines of code) that are formally verified. This goal has been attained by developing Gypsy <ref> [6] </ref> from Pascal [11] in parallel with an integrated set of formal specification and verification methods. Both programs and their formal specifications are expressed directly in Gypsy, and methods for specifying, implementing and verifying systems of concurrent processes have been a major part of this development.
Reference: [7] <author> A.N. Habermann. </author> <title> Synchronizing of Communicating Processes. </title> <journal> CACM 15-3, </journal> <volume> 72. </volume>
Reference-contexts: Transaction histories have been used in most approaches to specifying and proving properties of systems of concurrent processes and shared objects ( <ref> [7] </ref>; (Hoare74); (Owicki76); (Howard76). These approaches, however, have used the installation of "ghost" variables to record transaction histories in an ad hoc way. <p> Verification conditions are constructed and proved independently for each procedure. All consideration of the interactions of procedures running concurrently is isolated to the verification conditions for the cobegin. It is never necessary to consider simultaneously all processes running concurrently, as in <ref> [7] </ref>, or to prove noninterference, as in [14]. 7. Summary This paper has described the basic principles for specifying and proving systems of concurrent processes in Gypsy, including automatable methods for both terminating and nonterminating processes.
Reference: [8] <author> C.A.R. Hoare. </author> <title> Monitors - an Operating System Structuring Concept. </title> <type> CACM 17-10, </type> <month> October, </month> <year> 1974. </year>
Reference-contexts: The await waits until it can select (nondeterministically) some guard that is not blocked, does the buffer operations and the statement list, then exits the await. Process coordination in Gypsy is done strictly by means of message buffers [1], as opposed to semaphores [4], monitors <ref> [8] </ref>, or conditional critical regions [14]. The buffers are strictly FIFO queues upon which send and receive operations are excluded in time. <p> The Gypsy message buffers are predefined types with predefined axiomatic properties. This is in direct contrast to the monitors of <ref> [8] </ref>, and [10] as well as the conditional critical regions of [14] in which axiomatic properties of each shared object must be specified and proved.
Reference: [9] <author> Gary R. Horn. </author> <title> Specifications for a Secure Computer Communications Newtork. </title> <type> Master's thesis, </type> <institution> The University of Texas at Austin, 1977. ICSCA-Cmp-8, The University of Texas at Austin. </institution>
Reference-contexts: Gypsy has been used successfully in two major experimental applications involving significant amounts of concurrency. [16] describes a complete message switching network of 16 concurrent processes involving a total of approximately 1500 lines of specifications and 1000 lines of code. <ref> [9] </ref> gives a 900 line specification of a system of processes that will be used experimentally in conjunction with the ARPANET. In both applications, all parts of the sytems involving concurrency were formally verified. These verifications have contributed strongly to attaining high quality system design.
Reference: [10] <author> J. Howard. </author> <title> Proving Monitors Correct. </title> <type> CACM 19(5), </type> <month> May, </month> <year> 1976. </year>
Reference-contexts: The Gypsy message buffers are predefined types with predefined axiomatic properties. This is in direct contrast to the monitors of [8], and <ref> [10] </ref> as well as the conditional critical regions of [14] in which axiomatic properties of each shared object must be specified and proved. Transaction histories have been used in most approaches to specifying and proving properties of systems of concurrent processes and shared objects ( [7]; (Hoare74); (Owicki76); (Howard76).
Reference: [11] <author> K. Jensen, N. Wirth. </author> <title> Pascal User Manual and Report. </title> <publisher> Springer Verlag, </publisher> <year> 1974. </year>
Reference-contexts: 1. Introduction The primary objective of Gypsy is to provide an effective, practical language for developing operational software systems of substantial size (1000 - 2000 lines of code) that are formally verified. This goal has been attained by developing Gypsy [6] from Pascal <ref> [11] </ref> in parallel with an integrated set of formal specification and verification methods. Both programs and their formal specifications are expressed directly in Gypsy, and methods for specifying, implementing and verifying systems of concurrent processes have been a major part of this development.
Reference: [12] <editor> A.K. Jones, B.H. </editor> <publisher> Liskov. </publisher>
Reference-contexts: The block specifications also can be verified independently for each procedure. Operation restrictions may be declared on a buffer. A buffer may be declared to be used strictly for input or for output. These restictions are in the spirit of <ref> [12] </ref> and are enforced statically. These restrictions reduce the size of specifications, and their static enforcement significantly simplifies proofs. The proofs are done by an extension of the inductive assertion method. Assertions may refer to buffers and their respective transaction histories.
References-found: 12

