URL: http://www.cs.pitt.edu/~moir/Papers/buhrman-garay-hoepman-moir-podc95.ps
Refering-URL: http://www.cs.pitt.edu/~moir/papers.html
Root-URL: 
Title: Long-Lived Renaming Made Fast  
Author: Harry Buhrman Juan A. Garay Jaap-Henk Hoepman Mark Moir 
Abstract: In the long-lived renaming problem | a generalization of the classical one-time renaming problem | n processors with unique names ranging over a source name space f0; : : : ; S 1g repeatedly acquire and release unique names from a (smaller) destination name space f0; : : : ; D 1g. It is assumed that at most k out of n processors concurrently request or hold names. An efficient renaming protocol provides a useful front-end for protocols whose time complexity depends on the size of the name space containing the participating processes. We consider long-lived renaming in the context of asynchronous, shared-memory multiprocessing systems that provide only read and write operations. A renaming protocol is fast iff the time complexity of acquiring and releasing a name is polynomial in k and independent of n and S. We present a wait-free, read/write protocol for long-lived renaming that achieves a destination name space of size O(k 2 ) with time complexity O(k 3 ). If S is polynomial in k, we further improve the time-complexity to O(k log k). This shows, for the first time, that fast, read/write protocols for long-lived renaming exist. Part of our wait-free solution uses mutual exclusion tournament trees, where we apply hashing based on polynomials over finite fields to avoid blocking. This technique may be of general interest. 
Abstract-found: 1
Intro-found: 1
Reference: [ABND + 90] <author> Attiya, H., Bar-Noy, A., Dolev, D., Peleg, D., and Reischuk, R. </author> <title> Renaming in an asynchronous environment. </title> <journal> Journal of the ACM 37, </journal> <volume> 3 (1990), </volume> <pages> 524-548. </pages>
Reference-contexts: 1 Introduction In the one-time renaming problem <ref> [ABND + 90, BND89, BG93, PPTV94] </ref>, n processes with unique identifiers in the range f0; : : : ; S 1g obtain distinct names from the fl CWI, Amsterdam, The Netherlands. Partially supported by the Dutch foundation for scientific research (NWO) through NFI Project ALADDIN, under contract number NF 62-376.
Reference: [AM94] <author> Anderson, J. H., and Moir, M. </author> <title> Using k-exclusion to implement resilient, scalable shared objects. </title> <booktitle> In 13th Ann. Symp. on Principles of Distributed Computing (Los Angeles, </booktitle> <address> CA, USA, </address> <year> 1994), </year> <pages> pp. 141-150. </pages>
Reference-contexts: In particular, Moir and Anderson have shown that the overhead associated with accessing a resilient shared object can be reduced by combining a long-lived renaming protocol with a shared object implementation for fewer processes <ref> [AM94] </ref>. Efficient renaming protocols can also be useful, for example, in Unix-based multiprocessing systems. In such systems, processes have unique identifiers from a large range, but the number of processes that run concurrently is much smaller.
Reference: [BG93] <author> Borowsky, E., and Gafni, E. </author> <title> Immediate atomic snapshots and fast renaming. </title> <booktitle> In 12th Ann. Symp. on Principles of Distributed Computing (Ithaca, </booktitle> <address> N.Y., USA, </address> <year> 1993), </year> <pages> pp. 41-51. </pages>
Reference-contexts: 1 Introduction In the one-time renaming problem <ref> [ABND + 90, BND89, BG93, PPTV94] </ref>, n processes with unique identifiers in the range f0; : : : ; S 1g obtain distinct names from the fl CWI, Amsterdam, The Netherlands. Partially supported by the Dutch foundation for scientific research (NWO) through NFI Project ALADDIN, under contract number NF 62-376. <p> Herlihy and Shavit [HS93] have shown that one-time renaming (and hence long-lived renaming) cannot be solved in a wait-free manner using atomic reads and writes unless D 2k 1. For one-time renaming this bound is tight <ref> [BG93, MA94] </ref>; for long-lived renaming the best upper bound known is D 2 O (k 2 ), independent of whether the implementation is fast or not [MA94].
Reference: [BLS93] <author> H. Buhrman, L. Longpr e, and E. Spaan. </author> <title> Sparse reduces conjunctively to tally. </title> <booktitle> In 8th Ann. Conf. Structure in Complexity Theory, </booktitle> <address> (San Diego, CA, USA, </address> <year> 1993), </year> <pages> pp. 208-214. </pages> <note> To appear in SIAM Journal on Computing 1995. </note>
Reference-contexts: The collection of sets N p is constructed using a special hashing technique involving polynomials over a finite field, such that no set is covered by the union of k 1 others. Collections with that property were studied by Erdos et al. <ref> [EFF85, BLS93] </ref>. In our application this property ensures that, at any time, there is some name m 2 N p for which p is competing alone. Section 4.1 below explains this hashing technique in detail. Then, in Section 4.2, we present the modified mutual exclusion tree and the Filter protocol.
Reference: [BND89] <author> Bar-Noy, A., and Dolev, D. </author> <title> Shared memory versus message-passing in an asynchronous distributed environment. </title> <booktitle> In 8th Ann. Symp. on Principles of Distributed Computing (Edmonton, </booktitle> <address> Alberta, Canada, </address> <year> 1989), </year> <pages> pp. 307-318. </pages>
Reference-contexts: 1 Introduction In the one-time renaming problem <ref> [ABND + 90, BND89, BG93, PPTV94] </ref>, n processes with unique identifiers in the range f0; : : : ; S 1g obtain distinct names from the fl CWI, Amsterdam, The Netherlands. Partially supported by the Dutch foundation for scientific research (NWO) through NFI Project ALADDIN, under contract number NF 62-376.
Reference: [BNDKP91] <author> Bar-Noy, A., Dolev, D., Koller, D., and Peleg, D. </author> <title> Fault-tolerant critical section management in asynchronous environments. </title> <booktitle> Information and Computation 95, 1 (1991), </booktitle> <pages> 1-20. </pages>
Reference-contexts: We consider long-lived renaming protocols for asynchronous, shared-memory, multiprocessing systems. The long-lived renaming problem has been considered in this context by Moir and Anderson [MA94], and in message-passing systems by Bar-Noy et al. <ref> [BNDKP91] </ref>. We call a renaming protocol fast iff acquiring and releasing a name takes time O (p (k)) where p is a polynomial that is independent of both n, the total number of processes, and S, the size of their original name space.
Reference: [Che52] <author> Chebyshev, L. </author> <title> Memoire sur les nom-bres premiers. </title> <journal> Journal de Math. </journal> <volume> 17 (1852), </volume> <pages> 366-390. </pages>
Reference-contexts: S 3 k1 : If we set d = (k 2)=2 we get, by equation (2) in Section 4.1, z k 2 3k + 2. As for any a there is a prime between a and 2a <ref> [Che52] </ref>, we select k 2 z 2k 2 . Then z d+1 (k 2 ) ((k2)=2)+1 = k k . As k k 3 k1 if k 1, this satisfies equation (1), and, by equation (3), D 2k 2 (k 2)(k 1) 2k 4 .
Reference: [Coh74] <author> Cohn, P. M. </author> <title> Algebra Volume 1. </title> <publisher> John Wiley & Sons, </publisher> <year> 1974. </year>
Reference-contexts: Also, for distinct polynomials Q p and Q q of degree d over a finite field GF (z) with z prime, there are at most d values of x such that Q p (x) = Q q (x) <ref> [Coh74] </ref>. Recall that for p 6= q, Q p and Q q are distinct. Then z 2d (k 1) (2) implies kN p " N q k d. Furthermore, suppose P is an arbitrary set of k 1 processes such that p 62 P .
Reference: [EFF85] <author> Erd os, P., Frankl, P., and F uredi, Z. </author> <title> Families of finite sets in which no set is covered by the union of r others. </title> <journal> Israel Journal of Mathematics 51, </journal> <month> 1-2 </month> <year> (1985), </year> <pages> 79-89. </pages>
Reference-contexts: This is achieved by the use of a special hashing technique that is based on unique polynomials over a finite field <ref> [EFF85] </ref>. Because there is always some tree T in which p is participating alone, the FIFO property of the mutual exclusion ensures that next time p participates in tree T , p makes progress towards the critical section of T . Therefore, p can eventually acquire a name. <p> The collection of sets N p is constructed using a special hashing technique involving polynomials over a finite field, such that no set is covered by the union of k 1 others. Collections with that property were studied by Erdos et al. <ref> [EFF85, BLS93] </ref>. In our application this property ensures that, at any time, there is some name m 2 N p for which p is competing alone. Section 4.1 below explains this hashing technique in detail. Then, in Section 4.2, we present the modified mutual exclusion tree and the Filter protocol. <p> Unfortu--nately, Proposition 3.4 of Erdos et al. <ref> [EFF85] </ref> shows that multiple applications of protocol Filter will not lead to a name space smaller than k (k + 1)=2.
Reference: [HS93] <author> Herlihy, M., and Shavit, N. </author> <title> The asynchronous computability theorem for t-resilient tasks. </title> <booktitle> In 25th Ann. Symp. on Theory of Computing (San Diego, </booktitle> <address> CA, USA, </address> <year> 1993), </year> <pages> pp. 111-120. </pages>
Reference-contexts: Thus, we are motivated to seek renaming protocols whose destination name spaces are as small as possible. Herlihy and Shavit <ref> [HS93] </ref> have shown that one-time renaming (and hence long-lived renaming) cannot be solved in a wait-free manner using atomic reads and writes unless D 2k 1.
Reference: [MA94] <author> Moir, M., and Anderson, J. H. </author> <title> Fast, long-lived renaming. </title> <booktitle> In 8th Int. Workshop on Distributed Algorithms (Terschelling, </booktitle> <address> The Netherlands, </address> <year> 1994), </year> <pages> pp. 141-155. </pages> <note> To appear in Science of Computer Programming. </note>
Reference-contexts: We consider long-lived renaming protocols for asynchronous, shared-memory, multiprocessing systems. The long-lived renaming problem has been considered in this context by Moir and Anderson <ref> [MA94] </ref>, and in message-passing systems by Bar-Noy et al. [BNDKP91]. <p> In this paper, we present two long-lived renaming protocols: Split and Filter. These two protocols, combined with the non-fast protocol Ma <ref> [MA94] </ref>, yield the first fast and long-lived renaming protocol that is based on reads and writes. Our protocol renames k processes to a name space of size k (k + 1)=2, with time complex-ity O (k 3 ). <p> If f = 3 k1 , then Filter renames to a name space of size 2k 4 in time O (k 3 ). If f = 2k 4 , Filter renames to a name space of size 72k 2 in time O (k log k). Using protocol Ma <ref> [MA94] </ref> we can further reduce the size of the name space to k (k + 1)=2 in time O (k 3 ). In practice we can assume f 2 O (3 k ), so the first stage implemented by Split is unnecessary. <p> Split uses a "building block" similar to the one employed by Moir and Anderson <ref> [MA94] </ref>. Processes accessing our building block, which is presented in Section 3.1 below, are dynamically partitioned into three output sets, denoted 1, 0 and 1. <p> Herlihy and Shavit [HS93] have shown that one-time renaming (and hence long-lived renaming) cannot be solved in a wait-free manner using atomic reads and writes unless D 2k 1. For one-time renaming this bound is tight <ref> [BG93, MA94] </ref>; for long-lived renaming the best upper bound known is D 2 O (k 2 ), independent of whether the implementation is fast or not [MA94]. <p> For one-time renaming this bound is tight [BG93, MA94]; for long-lived renaming the best upper bound known is D 2 O (k 2 ), independent of whether the implementation is fast or not <ref> [MA94] </ref>. It would be interesting to close this gap, either by finding a long-lived renaming protocol with a smaller destination name space, or by showing that this is impossible.
Reference: [PF77] <author> Peterson, G. L., and Fischer, M. J. </author> <title> Economical solutions for the critical section problem in a distributed system. </title> <booktitle> In 9th Ann. Symp. on Theory of Computing (Boulder, </booktitle> <address> Colorado, USA, </address> <year> 1977). </year>
Reference-contexts: In order to acquire a name, a process p competes for each of a set N p of names by participating in the mutual exclusion tree associated with each name in N p . We present a modified version of Peterson and Fischer's mutual exclusion tournament trees <ref> [PF77] </ref> that enables a process p to compete for all of the names in N p "in parallel". <p> The use of mutual exclusion in a wait-free protocol might seem counterintuitive. However, as described in detail below, each process p competes "in parallel" for each of a set N p of names. This is achieved by the use of a modified version of Peterson and Fischer's <ref> [PF77] </ref> mutual exclusion trees. The modification allows a process to detect that it is blocked in one tree, and to attempt to acquire another name from N p by continuing to compete in another tree associated with that name. <p> To allow processes to compete in several mutual exclusion trees "in parallel", each node in the mutual exclusion trees contains a modified version of the two-process mutual exclusion algorithm of Peterson and Fischer <ref> [PF77] </ref>. Peterson and Fischer's algorithm is split into three procedures, Enter , Check , and Release, and uses multi-writer variables to avoid the costly search for an opponent. Except for these modifications, both algorithms are essentially the same. The three procedures are shown in Figure 3. <p> Then there at most two processors p; q, visitors of ME, concurrently accessing ME: one with fi = 0, the other with fi = 1. Now the original proof of mutual exclusion can be applied to show that at most one process can win <ref> [PF77] </ref>. This contradicts that both are in T m at level `. Lemma 7 If p is stuck in round r in tree T m at level `, then there is another process q 6= p in tree T m at the start of the r-th round of p.
Reference: [PPTV94] <author> Panconesi, A., Papatriantafilou, M., Tsigas, P., and Vit anyi, P. M. B. </author> <title> Randomized wait-free distributed naming. </title> <booktitle> In 5th Int. Symp. on Algorithms and Computation (Beijing, </booktitle> <address> China, </address> <year> 1994), </year> <pages> pp. 83-91. </pages>
Reference-contexts: 1 Introduction In the one-time renaming problem <ref> [ABND + 90, BND89, BG93, PPTV94] </ref>, n processes with unique identifiers in the range f0; : : : ; S 1g obtain distinct names from the fl CWI, Amsterdam, The Netherlands. Partially supported by the Dutch foundation for scientific research (NWO) through NFI Project ALADDIN, under contract number NF 62-376.
References-found: 13

