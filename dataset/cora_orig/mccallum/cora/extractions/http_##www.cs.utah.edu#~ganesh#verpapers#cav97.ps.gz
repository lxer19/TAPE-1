URL: http://www.cs.utah.edu/~ganesh/verpapers/cav97.ps.gz
Refering-URL: http://www.cs.utah.edu/~mjones/papers/utah.notes.html
Root-URL: 
Email: fratan,ganeshg@cs.utah.edu  
Title: Automatic Protocol Synthesis by Refining Rendezvous Communication into Asynchronous Communication  
Author: Ratan Nalumasu Ganesh Gopalakrishnan 
Note: Category: A  
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science University of Utah,  
Abstract: Many distributed protocols that interact via messages are specified directly at a low level using asynchronous communication discipline, even though designers of these protocols may be aware of a much simpler conceptual model using the rendezvous communication discipline for the same protocols. This situation is easily explained when one considers the variety of complex ways in which the rendezvous based model is implemented in real systems using asynchronous communication messages primarily to gain performance advantages. To the best of our knowledge, no one has formalized the transformational steps that designers apply in arriving at the asynchronous protocols. Direct coding using the asynchronous communication discipline is tedious and error prone. It also invites state explosion when model checked, due to the sheer number of interleavings possible. Verifying these asynchronous protocols using theorem-proving based methods (e.g., by first aggregating asynchronous communication actions into equivalent synchronous communication actions [PD96]) is also labor intensive. We show that by suitably engineering an input specification language and a set of refinement rules based on it, designers will be able to express these protocols directly at the rendezvous conceptual model and refine them to obtain non-trivial high-performance asynchronous protocols. We demonstrate this by deriving asynchronous versions of two distributed directory based cache coherence protocols for a new multiprocessor under development. High-level specifications are written in a notation (largely based on CSP) suitably engineered to guarantee adequate expressive power as well as preservation of LTL properties with respect to specification variables during refinement. We show that applying our three refinement rules (acking, nacking, and reqrepl ) we can systematically derive the cache coherency protocols of a state of the art multiprocessor under development. We also show that the rendezvous protocols are substantially cheaper to model check, and also that the refinement rules can result in an asynchronous protocol whose performance is close to that of manually designed asynchronous cache coherency protocols. We describe our input language, provide a semantic characterization of our refinement rules, and summarize our experimental results. 
Abstract-found: 1
Intro-found: 1
Reference: [BD94] <author> J. R. Burch and D. L. Dill. </author> <title> Automatic verification of pipelined microprocessor control. </title> <booktitle> In CAV, </booktitle> <pages> pages 68-80, </pages> <address> Stanford, CA, USA, </address> <year> 1994. </year>
Reference-contexts: Our proof arguments are based on showing correspondence between implementation steps and specification steps, and defining an abstraction mapping in terms of aggregating actions, similar to <ref> [BD94, PD96] </ref>. The strength of our approach is that we need to formally prove our refinement rules only once as opposed to redoing the proof for each protocol in the case of the aggregation technique.
Reference: [BS83] <author> G. N. Buckley and A. Silberschatz. </author> <title> An effective implementation for the generalized input-output construct of CSP. </title> <journal> ACM TOPLAS, </journal> <volume> 5(2) </volume> <pages> 223-235, </pages> <month> April </month> <year> 1983. </year>
Reference-contexts: Lamport and Schneider [LS89] have 1 explored the theoretical foundations of comparing atomic transactions (e.g., rendezvous com-munication) and split transactions (e.g., asynchronous communication), based on left and right movers [Lip75], but have not considered specific refinement rules such as we do. In <ref> [BS83] </ref>, Buckley and Silberschatz consider the problem of adding unrestricted output guards to CSP. <p> In CSP [Hoa78], all non-determinism is resolved on input, i.e., no output guards are allowed. This proved quite restrictive in our context. We originally considered relaxing this restriction completely; i.e., having both input and output guards. This modification requires an expensive solution such as <ref> [BS83] </ref>. The simpler solution we propose cannot preserve even simple progress properties that hold in the original specification. We now discuss this problem in more detail, and present our solution in terms of the CSP-f language.
Reference: [CKK96] <author> John B. Carter, Chen-Chi Kuo, and Ravindra Kuramkote. </author> <title> A comparison of software and hardware synchronization mechanisms for distributed shared memory multiprocessors. </title> <type> Technical Report UUCS-96-011, </type> <institution> University of Utah, </institution> <address> Salt Lake City, UT, USA, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: Our ideas originated in the context of designing cache coherence protocols for a new multiprocessor machine under construction <ref> [CKK96] </ref>, and as such, most of our examples will be drawn from this area. Nevertheless, our technique is believed to be more widely applicable. <p> ) messages (the acking rule), into request and acknowledge/negative acknowledge (nack ) messages (the nacking rule), and a less straightforward method where the handshake is implicit as in a request/reply communication (the reqrepl rule). * We take two non-trivial directory based coherency protocols in actual use in the Avalanche multiprocessor <ref> [CKK96] </ref> called migratory and invalidate. These protocols have a simple high-level specification that can be readily expressed in CSP-f. The architectural team of Avalanche obtained asynchronous protocols implementing these specifications directly and tuned the protocols for maximum performance using a state of the art performance simulator [SSK96]. <p> Table 1 shows correspondence between implementation transitions and specification transitions for the three refinement rules 5 . 5 Experimental Results We applied the above rules on two of the protocols that implement shared memory in Avalanche multiprocessor <ref> [CKK96] </ref>. As the efficiency of these protocols greatly affects the overall efficiency of the machine, the Avalanche architecture team developed these two protocols namely migratory and invalidate, with time efficiency as a prime concern.
Reference: [Gri90] <author> E. </author> <title> Pascal Gribo mont. From synchronous to asynchronous communication. </title> <editor> In C. Rat-tay, editor, </editor> <booktitle> Specification and Verification of Concurrent Systems, </booktitle> <pages> pages 368-383. </pages> <institution> Springer-Verilog, University of Stirling, </institution> <address> Scotland, </address> <year> 1990. </year> <note> Workshops in Computing. </note>
Reference-contexts: Related Work Methods for refining synchronous communications into asynchronous communications through handshaking have been developed in the context of asynchronous circuit synthesis (e.g. [Mar90, SZ93]). The main difference with our work is that the set of "protocols" considered by them are much more limited in scope. Gribo mont <ref> [Gri90] </ref> explored the protocols where the rendezvous communication can be simply replaced by asynchronous communication without affecting the processes in any other way. In contrast, we show how to change the processes when the rendezvous communication is replaced by asynchronous communication.
Reference: [Hoa78] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> CACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference-contexts: Nevertheless, our technique is believed to be more widely applicable. Our key contributions are the following. * We first identify a notation called CSP-f based on Hoare's original CSP <ref> [Hoa78] </ref> to express the high level (rendezvous) protocol. CSP-f is designed with the dual objective of being adequately expressive as well as sufficiently restrictive (the latter to preserve LTL properties during refinement). It slightly extends the original CSP to include a very restricted form of output guards. <p> The advantages of our method are that the refinement rules can be verified once and for all (for example, using a theorem-prover). 2 Protocol Specification Language As said earlier, our protocol specification language CSP-f is largely similar to CSP <ref> [Hoa78] </ref>. In CSP [Hoa78], all non-determinism is resolved on input, i.e., no output guards are allowed. This proved quite restrictive in our context. We originally considered relaxing this restriction completely; i.e., having both input and output guards. This modification requires an expensive solution such as [BS83]. <p> The advantages of our method are that the refinement rules can be verified once and for all (for example, using a theorem-prover). 2 Protocol Specification Language As said earlier, our protocol specification language CSP-f is largely similar to CSP <ref> [Hoa78] </ref>. In CSP [Hoa78], all non-determinism is resolved on input, i.e., no output guards are allowed. This proved quite restrictive in our context. We originally considered relaxing this restriction completely; i.e., having both input and output guards. This modification requires an expensive solution such as [BS83]. <p> While waiting for the ack, the request from refQ would be treated as interference by refP and vice versa. Hence both processes generate nack which would cause both of them to go back to the initial state. This way, the two refined processes might continually nack 1 CSP <ref> [Hoa78] </ref> uses the "direct addressing" notation where the rendezvous partner|as opposed to a channel name|is used to specify the rendezvous; we find direct addressing to be handy for explaining our refinement rules, and hence use it in the rest of this paper. 2 Process P:: Process Q:: Process refP:: if if
Reference: [Hol91] <author> Gerard Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Table 2 shows the complexity of model checking the migratory and invalidate protocols. As can be seen the rendezvous versions of the protocols are more tractable to model check than the asynchronous versions thereof using the SPIN <ref> [Hol91] </ref> model checker. A description of the rendezvous version of the protocols and the refinement rules applied on these protocols to obtain the asynchronous protocol are given in [Nal]. 6 Conclusions We presented a notation called CSP-f to express distributed protocols using rendezvous communication.
Reference: [Lip75] <author> Richard J. Lipton. </author> <title> Reduction: A method of proving properties of parallel programs. </title> <journal> CACM, </journal> <volume> 18(12) </volume> <pages> 717-721, </pages> <month> December </month> <year> 1975. </year>
Reference-contexts: In contrast, we show how to change the processes when the rendezvous communication is replaced by asynchronous communication. Lamport and Schneider [LS89] have 1 explored the theoretical foundations of comparing atomic transactions (e.g., rendezvous com-munication) and split transactions (e.g., asynchronous communication), based on left and right movers <ref> [Lip75] </ref>, but have not considered specific refinement rules such as we do. In [BS83], Buckley and Silberschatz consider the problem of adding unrestricted output guards to CSP.
Reference: [LS89] <author> Leslie Lamport and Fred B. Schneider. </author> <note> Pretending atomicity. In Research Report 44, </note> <institution> Digital Equipment Corporation Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Gribo mont [Gri90] explored the protocols where the rendezvous communication can be simply replaced by asynchronous communication without affecting the processes in any other way. In contrast, we show how to change the processes when the rendezvous communication is replaced by asynchronous communication. Lamport and Schneider <ref> [LS89] </ref> have 1 explored the theoretical foundations of comparing atomic transactions (e.g., rendezvous com-munication) and split transactions (e.g., asynchronous communication), based on left and right movers [Lip75], but have not considered specific refinement rules such as we do.
Reference: [Mar90] <author> Alain J. Martin. </author> <title> Programming in VLSI: From communication processes to delay-insensitive circuits. </title> <editor> In C. A. R. Hoare, editor, </editor> <title> Developments in Concurrency and Communication. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year> <booktitle> UT Year of Programming Institute on Concurrent Programming. </booktitle>
Reference-contexts: Related Work Methods for refining synchronous communications into asynchronous communications through handshaking have been developed in the context of asynchronous circuit synthesis (e.g. <ref> [Mar90, SZ93] </ref>). The main difference with our work is that the set of "protocols" considered by them are much more limited in scope. Gribo mont [Gri90] explored the protocols where the rendezvous communication can be simply replaced by asynchronous communication without affecting the processes in any other way.
Reference: [Nal] <institution> See http://www.cs.utah.edu/~ratan/cav-97/. </institution>
Reference-contexts: A description of the rendezvous version of the protocols and the refinement rules applied on these protocols to obtain the asynchronous protocol are given in <ref> [Nal] </ref>. 6 Conclusions We presented a notation called CSP-f to express distributed protocols using rendezvous communication. Protocols written in this notation can be refined using three syntax directed rules, 5 This table doesn't list all the proof obligations. <p> Adding this external process also makes some of the 2 entries in the third column to have different entries (e.g., specification transition corresponding to W2-W3 entry of acking rule changes to reflect the external process). See <ref> [Nal] </ref> for the complete table. 9 acking, nacking, and reqrepl . The three refinement rules are applied on two realistic protocols: migratory and invalidate. These protocols are also independently developed by the Avalanche architectural team with performance as one of the goals.
Reference: [ORR + 96] <author> S. Owre, S. Rajan, J. M. Rushby, N. Shankar, and M. Srivas. PVS: </author> <title> Combining specification, proof checking and model checking. </title> <booktitle> In CAV, </booktitle> <pages> pages 411-414, </pages> <address> New Brunswick, NJ, USA, </address> <year> 1996. </year>
Reference-contexts: A mechanical proof is underway using PVS <ref> [ORR + 96] </ref>. The basic idea is to show that every transition of the refined protocol is allowed by the original protocol.
Reference: [PD96] <author> Seungjoon Park and David L. Dill. </author> <title> Protocol verification by aggregation of distributed transactions. </title> <booktitle> In CAV, </booktitle> <pages> pages 300-309, </pages> <address> New Brunswick, NJ, USA, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: Direct coding of protocols using the asynchronous communication discipline is tedious and error prone, and invites state explosion during model checking. Also, theorem-proving based methods (e.g., <ref> [PD96] </ref>) when applied to these protocols are labor-intensive. In this paper, we provide an approach for specifying these protocols at the high level using rendezvous communication actions, model checking them much more cheaply at this level, and then automatically synthesizing high performance asynchronous protocols. <p> Our proof arguments are based on showing correspondence between implementation steps and specification steps, and defining an abstraction mapping in terms of aggregating actions, similar to <ref> [BD94, PD96] </ref>. The strength of our approach is that we need to formally prove our refinement rules only once as opposed to redoing the proof for each protocol in the case of the aggregation technique. <p> In contrast our refinement rules do not incur these overheads, due to the fact that CSP-f does not allow unrestricted output guards. In <ref> [PD96] </ref>, the authors present a method for aggregating split transactions ("implementation steps") into atomic transactions ("specification steps"). This process, in a sense, is opposite of what we propose in this paper. <p> In other words, the abs function simply completes the rendezvous transaction by generating and consuming of the ack and nack messages and then projects onto the specification variables. This idea is referred to as aggregation of actions in <ref> [PD96] </ref>. Note that in reqrepl there is no explicit ack message. <p> Similarly, we must ensure that a process generates at most one ack or nack in a response to any given message. It is easy to see that the refinement rules ensure these two conditions. <ref> [PD96] </ref> also requires similar conditions. 8 Protocol N Asynchronous Rendezvous Protocol Protocol Migratory 2 23163/2.84 54/0.1 4 Unfinished 235/0.4 8 Unfinished 965/0.5 Invalidate 2 193389/19.23 546/0.6 4 Unfinished 18686/2.3 6 Unfinished 228334/18.4 Table 2: Number of states visited and time taken in seconds for reachability analysis of the rendezvous and asynchronous
Reference: [SSK96] <author> Leigh B. Stoller, Mark R. Swanson, and Ravindra Kuramkote. Paint: </author> <title> PA instruction set interpreter. </title> <type> Technical Report UUCS-96-009, </type> <institution> University of Utah, </institution> <address> Salt Lake City, UT, USA, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: These protocols have a simple high-level specification that can be readily expressed in CSP-f. The architectural team of Avalanche obtained asynchronous protocols implementing these specifications directly and tuned the protocols for maximum performance using a state of the art performance simulator <ref> [SSK96] </ref>. <p> As the efficiency of these protocols greatly affects the overall efficiency of the machine, the Avalanche architecture team developed these two protocols namely migratory and invalidate, with time efficiency as a prime concern. The performance of these asynchronous protocols were measured using a state of the art performance simulator <ref> [SSK96] </ref>. Both the migratory and invalidate protocols have an informal specification that can be readily translated into a rendezvous notation.
Reference: [SZ93] <author> Scott F. Smith and Amy E. Zwarico. </author> <title> Correct compilation of specifications to deterministic asynchronous circuits. </title> <booktitle> In CHARME, </booktitle> <month> May </month> <year> 1993. </year> <booktitle> Lecture Notes in Computer Science. </booktitle> <pages> 10 </pages>
Reference-contexts: Related Work Methods for refining synchronous communications into asynchronous communications through handshaking have been developed in the context of asynchronous circuit synthesis (e.g. <ref> [Mar90, SZ93] </ref>). The main difference with our work is that the set of "protocols" considered by them are much more limited in scope. Gribo mont [Gri90] explored the protocols where the rendezvous communication can be simply replaced by asynchronous communication without affecting the processes in any other way.
References-found: 14

