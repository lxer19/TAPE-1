URL: http://www.first.gmd.de/persons/Santen.Thomas/pub/arbeitspapier986.ps.gz
Refering-URL: http://www.first.gmd.de/~espress/gesamt_public.html
Root-URL: 
Email: fbu,kolg@informatik.uni-bremen.de  santen@first.gmd.de  
Title: Towards a Structure Preserving Encoding of Z in HOL  
Author: Kolyang T. Santen B. Wolff 
Date: April 1986  
Address: FB3 P.O. Box 330440 D-28334 Bremen  First Rudower Chaussee 5 D-12489 Berlin  986  D-53754 Sankt Augustin  
Affiliation: Universitat Bremen,  GMD  Arbeitspapiere der GMD  GMD Forschungszentrum Informationstechnik GmbH  
Abstract-found: 0
Intro-found: 1
Reference: [BG94] <author> J. P. Bowen and M. J. C. Gordon. </author> <title> Z and HOL. </title> <publisher> In Bowen and Hall [BH94], </publisher> <pages> pages 141-167. </pages>
Reference-contexts: It is important to note that the signature of a referenced schema is unified with the environment on the basis of lexical identity: in B, the explicitly declared x 1 is identified with the corresponding declaration in A. Bowen and Gordon's encoding "Z in HOL" <ref> [BG94] </ref> represents A in the syntax of HOL88 by x1 IN S1 /" ... /" xn IN Sn /" P1 /" ... /" Pm where Si is a HOL term denoting a set (in HOL set theory) and P1 . . . Pm are boolean terms constituting the schema's predicate. <p> In the Section 4, we discuss proof support for our encoding "Z in Isabelle/HOL". 3 Representing Z in Isabelle/HOL Previous Z encodings cope differently with the question of Z syntax. Most of them try to encompass the L A T E X presentation of the Z syntax, e.g. <ref> [BG94, KB95] </ref>. Since lexical issues are very important for both presentation and readability, we decided to remain close to the Z syntax as presented in TZN. The draft standard proposes several ASCII-based representations of Z. <p> This type will be used to shape all sorts of function spaces. According to our principles on lexical issues, we are now able to present the toolkit as a suite of constant definitions (the technique is equivalent to <ref> [BG94] </ref>). <p> As a consequence of modeling functions as binary relations, we need a new application operator to apply f "^^":: ['a set &lt;=&gt; 'b set, 'a] =&gt; 'b which is defined by the Hilbert operator (as in <ref> [BG94] </ref>): f ^^ x == (@y. (x,y) : f) This treatment of partiality again conforms to TZN, where this extension of the semantic function is explicitly justified (p. 36): An example is the definition of application: for example, in function application, when the argument is outside the domain of the function, <p> This choice lead to the idea of schema lifters and consequently enabled us to come up with a representation of the schema calculus which, to our knowledge, is the first in a shallow embedding. As did Bowen and Gordon <ref> [BG94] </ref>, we map the set theory of Z to the one of HOL. Z is strongly typed and the apparent similarities to the HOL set theory are much greater than to other set theories like, e.g., ZF.
Reference: [BH94] <editor> J. P. Bowen and J. A. Hall, editors. </editor> <booktitle> Z User Workshop, Workshops in Computing. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference: [BH95] <editor> J. P. Bowen and M. G. Hinchey, editors. ZUM'95: </editor> <title> The Z Formal Specification Notation, </title> <publisher> LNCS 967. Springer Verlag, </publisher> <year> 1995. </year> <month> 19 </month>
Reference: [EM85] <author> Hartmut Ehrig and Bernd Mahr. </author> <title> Fundamentals of Algebraic Spec--ification 1. </title> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Schemas have significantly more syntactic flavour than, for example, the notion of an "parametrized abstract data type" used in the algebraic specification community which corresponds to a free functor relating certain categories of algebras (see <ref> [EM85] </ref>). A purely syntactical understanding of structuring would in fact be satisfying neither for theoretical nor for practical purposes. It would mean that structured specifications must be expanded (flattened) before any semantic treatment. As a consequence, the schema calculus and reasoning at the structural level would be impossible.
Reference: [GM93] <author> M. J. C. Gordon and T. M. Melham. </author> <title> Introduction to HOL: A theorem proving environment for higher order logics. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: They usually lack sophisticated implementations of advanced deduction techniques like, e.g., higher-order rewriting. In contrast to direct implementation, there is the choice of semantically embedding Z in a logical framework. An implementation within a "tactical theorem prover" in the tradition of LCF like HOL <ref> [GM93] </ref> or Isabelle/HOL [Pau94] is particularly attractive: large libraries, e.g. for set theory, that are proven consistent with the kernel logic of HOL can be used to implement and enhance the mathematical toolkit of Z.
Reference: [Har91] <author> W. T. Harwood. </author> <title> Proof rules for Balzac. </title> <type> Technical Report WTH/P7/001, </type> <institution> Imperial Software Technology, </institution> <address> Cambridge, UK, </address> <year> 1991. </year>
Reference-contexts: Proof procedures that produce proofs for each instance of the schematic theorem have to be coded instead. Reasoning in a deep encoding in this way reduces performance considerably. Furthermore, Maharaj has encoded Z in type-theory using LEGO [Mah90]. There also are direct implementations for dialects of Z, e.g. Balzac <ref> [Har91, Jor91] </ref> and CADiZ [TH95] allowing at least for single step inferences. CADiZ is based on a sequent calculus that is applied using a proof procedure called "Gentzen".
Reference: [Jon92] <author> R. B. Jones. </author> <title> ICL ProofPower. </title> <booktitle> BCS FACS FACTS Series III 1(1) </booktitle> <pages> 10-13, 1192. </pages>
Reference-contexts: The interpretation of [..|..] is similar to the one of "Z in HOL": all parameters are conjoined. The consequence of making the signatures of schemas globally visible is that all schema expressions have to be expanded by the parser. ICL's ProofPower <ref> [Jon92] </ref> is a commercial product based on a deep encoding. Schemas are represented as sets of bindings, and schema operations work on these sets. <p> The mechanisms needed here can easily be understood as manipulations of sets of identifiers, and can hence safely be implemented in a parser by introducing appropriate schema binders "SB". An advantage of this approach is that we, unlike deep embeddings like ProofPower <ref> [Jon92] </ref>, need not deal with "syntactical" issues in the logic. This also includes the issue of type checking. Since Z types are handled by 18 the Isabelle parser, we do not need to reason about them explicitly. Un--typed provers like Ergo [RS93] must provide specialised tactics to prove type constraints.
Reference: [Jor91] <author> L. E. Jordan. </author> <title> The Z syntax supported by Balzac ii/1. </title> <type> Technical Report LEJS1/0015, </type> <institution> Imperial Software Technology, </institution> <address> Cambridge, UK, </address> <year> 1991. </year>
Reference-contexts: Proof procedures that produce proofs for each instance of the schematic theorem have to be coded instead. Reasoning in a deep encoding in this way reduces performance considerably. Furthermore, Maharaj has encoded Z in type-theory using LEGO [Mah90]. There also are direct implementations for dialects of Z, e.g. Balzac <ref> [Har91, Jor91] </ref> and CADiZ [TH95] allowing at least for single step inferences. CADiZ is based on a sequent calculus that is applied using a proof procedure called "Gentzen".
Reference: [KB95] <author> I. Kraan and P. Baumann. </author> <title> Implementing Z in isabelle. </title> <booktitle> In Bowen and Hinchey [BH95], </booktitle> <pages> pages 355-373. </pages>
Reference-contexts: Schema references as imports and sets, and schema expressions are represented by expansion into the representation above; hence their structure is "parsed away". Pretty-printing suppresses the printing of the expanded schemas | this helps the eye, but not the prover. In Kraan and Baumann's representation "Z-in-Isabelle" <ref> [KB95] </ref> a schema A is represented as a theory in Isabelle and the variables in the declaration part as constants: AA = Toolkit + consts x1 :: "S1_t" ... xn :: "Sn_t" translations "A" == " [ x1 : S1; ...; xn : Sn | P1 ...Pm]" Here the Si t <p> In the Section 4, we discuss proof support for our encoding "Z in Isabelle/HOL". 3 Representing Z in Isabelle/HOL Previous Z encodings cope differently with the question of Z syntax. Most of them try to encompass the L A T E X presentation of the Z syntax, e.g. <ref> [BG94, KB95] </ref>. Since lexical issues are very important for both presentation and readability, we decided to remain close to the Z syntax as presented in TZN. The draft standard proposes several ASCII-based representations of Z. <p> Although counter-intuitive propositions like 1=0 = 1=0 are indeed provable by reflexivity in our encoding | in contrast, e.g., to the one of Kraan and Baumann <ref> [KB95] </ref> | we believe that our model of function application considerably simplifies deduction while still conforming to the semantics of Z. Since the semantics of Z is partial, specifiers cannot rely on any semantics of function applications outside their domain.
Reference: [KSW96] <author> Kolyang, T. Santen, and B. Wolff. </author> <title> Correct and user-friendly implementation of transformation systems. </title> <editor> In M.-C. Gaudel and J. Woodcock, editors, </editor> <booktitle> FME '96 | Industrial Benefits and Advances in Formal Methods, </booktitle> <volume> LNCS 1051, </volume> <pages> pages 629-648. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Coming with an open system design going back to Milner, these systems allow for safe user-programmed extensions to support tedious proof tasks often arising in explicit (predicative) type checking or in transformational program development over specifications <ref> [KSW96] </ref>. 1.1 The Challenge A lot of criticism from other scientific communities on Z is related to the fact that Z defines itself as a notation on the basis of set theory. The essential vehicle to structure Z specifications at the level of concrete syntax is called schema.
Reference: [Mah90] <author> S. Maharaj. </author> <title> Implementing Z in LEGO. </title> <type> Master's thesis, </type> <institution> Dept. of Computer Science, University of Edinburgh, </institution> <year> 1990. </year>
Reference-contexts: Proof procedures that produce proofs for each instance of the schematic theorem have to be coded instead. Reasoning in a deep encoding in this way reduces performance considerably. Furthermore, Maharaj has encoded Z in type-theory using LEGO <ref> [Mah90] </ref>. There also are direct implementations for dialects of Z, e.g. Balzac [Har91, Jor91] and CADiZ [TH95] allowing at least for single step inferences. CADiZ is based on a sequent calculus that is applied using a proof procedure called "Gentzen".
Reference: [Mar94] <author> A. Martin. </author> <title> Machine-Assisted Theorem-Proving for Software Engineering. </title> <type> PhD thesis, </type> <institution> University of Oxford, </institution> <year> 1994. </year>
Reference-contexts: The basic proof commands of EVES are specialized on syntactic categories of formulas, e.g. "instantiate a quantifier". Proven theorems are used automatically by more complex rewriting and simplification procedures. JigsaW <ref> [Mar94] </ref> is a deep encoding done in 2OBJ for W, a logic proposed for Z [WB92], which it faithfully encodes. Since there are no meta-variables in 2OBJ general theorems about Z cannot be expresses schematically.
Reference: [MS95] <author> I. Meisels and M. Z. Saaltink. </author> <title> The Z/EVES reference manual (draft). </title> <type> Technical Report TR-95-5493-03, </type> <institution> ORA Canada, </institution> <year> 1995. </year>
Reference-contexts: Because of the lacking type system, many "typing" subgoals arise during proofs. Automatically invoked tactics called elves are used to try and proof these subgoals. If the elves fail, the user has to tackle these subgoals interactively. Like Ergo, the implementation of Z in EVES <ref> [Saa92, MS95] </ref> incorporates the mathematical toolkit of Z and uses theorems about it as rewrite rules. The basic proof commands of EVES are specialized on syntactic categories of formulas, e.g. "instantiate a quantifier". Proven theorems are used automatically by more complex rewriting and simplification procedures.
Reference: [Nic95] <author> J. </author> <title> Nicholls. Z Notation version 1.2. Draft ISO standard, </title> <year> 1995. </year>
Reference-contexts: 1 Introduction Implementations of proof support for Z <ref> [Spi92b, Nic95] </ref> can roughly be divided into two categories. In direct implementations, the rules of the logic are directly represented by functions of the prover's implementation language. These implementations are error-prone (in the mathematical toolkit, there are hundreds of rules!) and tend to be difficult to modify. <p> Before we discuss some of them, let us briefly introduce the concepts of Z crucial for such an embedding. As basis for this paper, we will use the draft standard <ref> [Nic95] </ref>, which we will call "The Z Notation" (TZN) in the sequel. An alternative would have been "The Z Reference Manual" (ZRM) [Spi92b], but we felt it more appropriate to follow the proposal for a future ISO-Standard for Z, although it may still evolve.
Reference: [Pau94] <author> L. C. Paulson. </author> <title> Isabelle A Generic Theorem Prover. </title> <publisher> LNCS 828. Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: They usually lack sophisticated implementations of advanced deduction techniques like, e.g., higher-order rewriting. In contrast to direct implementation, there is the choice of semantically embedding Z in a logical framework. An implementation within a "tactical theorem prover" in the tradition of LCF like HOL [GM93] or Isabelle/HOL <ref> [Pau94] </ref> is particularly attractive: large libraries, e.g. for set theory, that are proven consistent with the kernel logic of HOL can be used to implement and enhance the mathematical toolkit of Z.
Reference: [RS93] <author> P. J. Robinson and J. </author> <title> Staples. Formalizing a hierarchical structure of practical mathematical reasoning. </title> <journal> Journal of Logic and Computation, </journal> <volume> 3(1) </volume> <pages> 47-61, </pages> <year> 1993. </year> <month> 20 </month>
Reference-contexts: Usually, deep encodings are perfectly suited for studying the semantical properties of a specification language but less suited for applying it. The theorem prover Ergo <ref> [RS93] </ref> implements an untyped meta-logic in Prolog on top of which Zermelo-Frankel set theory and a theory for Z are encoded. The basic proof mechanism of Ergo is window inference which is augmented by a tactic language. Because of the lacking type system, many "typing" subgoals arise during proofs. <p> This also includes the issue of type checking. Since Z types are handled by 18 the Isabelle parser, we do not need to reason about them explicitly. Un--typed provers like Ergo <ref> [RS93] </ref> must provide specialised tactics to prove type constraints. A first experiment based on the ZF encoding of Isabelle has shown that the type constraints provided by HOL greatly enhance efficiency of deduction.
Reference: [Saa92] <editor> M. Z. Saaltink. Z and EVES. In J. E. Nicholls, editor, </editor> <booktitle> Z User Workshop 1991, Workshops in Computing, </booktitle> <pages> pages 223-242. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Because of the lacking type system, many "typing" subgoals arise during proofs. Automatically invoked tactics called elves are used to try and proof these subgoals. If the elves fail, the user has to tackle these subgoals interactively. Like Ergo, the implementation of Z in EVES <ref> [Saa92, MS95] </ref> incorporates the mathematical toolkit of Z and uses theorems about it as rewrite rules. The basic proof commands of EVES are specialized on syntactic categories of formulas, e.g. "instantiate a quantifier". Proven theorems are used automatically by more complex rewriting and simplification procedures.
Reference: [Spi92a] <author> J. M. Spivey. </author> <title> The fuzz manual. </title> <booktitle> Computing Science Consultancy, </booktitle> <address> Oxford, UK, </address> <year> 1992. </year>
Reference-contexts: Each "given set" of a Z specification is associated with a primitive type. Type constructors for power-set types, product types, and schema types correspond to the respective set theoretic constructions. Type correctness with respect to these types is checked by Z type checkers like fuzz <ref> [Spi92a] </ref>. In the following, we use the term "type" for Z types while "HOL-type" shall refer to types of higher-order logic. Types are not explicitly denoted in Z specifications.
Reference: [Spi92b] <author> J. M. Spivey. </author> <title> The Z Notation A Refenrence Manual. </title> <publisher> Prentice Hall, </publisher> <address> 2nd edition, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Implementations of proof support for Z <ref> [Spi92b, Nic95] </ref> can roughly be divided into two categories. In direct implementations, the rules of the logic are directly represented by functions of the prover's implementation language. These implementations are error-prone (in the mathematical toolkit, there are hundreds of rules!) and tend to be difficult to modify. <p> As basis for this paper, we will use the draft standard [Nic95], which we will call "The Z Notation" (TZN) in the sequel. An alternative would have been "The Z Reference Manual" (ZRM) <ref> [Spi92b] </ref>, but we felt it more appropriate to follow the proposal for a future ISO-Standard for Z, although it may still evolve. The semantics of Z given in TZN is based on Zermelo-Frankel set theory (ZF) | which is untyped | but nevertheless Z is a strongly typed language. <p> Furthermore, the laws given in <ref> [Spi92b] </ref> can be derived as theorems from ZMathTool. Especially the theorem: " P (x ) = fy: trueg holds, in contrast to ZF where the result of this intersection is defined equal to fg because there are no universal sets in this untyped theory. <p> Note that the construction of signatures will always assure that the signature of the context will contain the elements of x . 2 Since functional abstraction is not defined in the current version of TZN, we use the definition of <ref> [Spi92b] </ref> to justify the conformity of our encoding. 11 However, the type-scheme t = ff 1 " : : : " ff n " bool for the representation of a schema is inappropriate because, in some places, we need an Isabelle type-scheme that subsumes all types of schema representations.
Reference: [TH95] <author> I. Toyn and J. Hall. </author> <title> Proving Conjectures using CadiZ. </title> <institution> York Software Engineering Ltd., </institution> <year> 1995. </year>
Reference-contexts: Reasoning in a deep encoding in this way reduces performance considerably. Furthermore, Maharaj has encoded Z in type-theory using LEGO [Mah90]. There also are direct implementations for dialects of Z, e.g. Balzac [Har91, Jor91] and CADiZ <ref> [TH95] </ref> allowing at least for single step inferences. CADiZ is based on a sequent calculus that is applied using a proof procedure called "Gentzen".
Reference: [WB92] <author> J. C. P. Woodcock and S. M. Brien. </author> <title> W: A logic for Z. </title> <editor> In J. E. Nicholls, editor, </editor> <booktitle> Z User Workshop 1991, Workshops in Computing, </booktitle> <pages> pages 77-96. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year> <month> 21 </month>
Reference-contexts: The basic proof commands of EVES are specialized on syntactic categories of formulas, e.g. "instantiate a quantifier". Proven theorems are used automatically by more complex rewriting and simplification procedures. JigsaW [Mar94] is a deep encoding done in 2OBJ for W, a logic proposed for Z <ref> [WB92] </ref>, which it faithfully encodes. Since there are no meta-variables in 2OBJ general theorems about Z cannot be expresses schematically. Proof procedures that produce proofs for each instance of the schematic theorem have to be coded instead. Reasoning in a deep encoding in this way reduces performance considerably.
References-found: 21

