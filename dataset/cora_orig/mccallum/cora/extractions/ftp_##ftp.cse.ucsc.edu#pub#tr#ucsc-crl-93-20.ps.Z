URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-93-20.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Email: daniel@cse.ucsc.edu edelson@sor.inria.fr  
Title: Comparing Two Garbage Collectors for C++  For Electronic Distribution Only  
Author: Daniel R. Edelson Daniel R. Edelson 
Note: Copyright (C) 1992 by  
Date: 16 Jan 1992  
Address: Santa Cruz, CA 95064 F-78153 Rocquencourt Cedex USA France  
Affiliation: University of California INRIA Project SOR  
Pubnum: Technical Report UCSC-CRL-93-20  
Abstract: Our research is concerned with compiler-independent, tag-free garbage collection for the C ++ programming language. This paper presents a mark-and-sweep collector, and explains how it ameliorates shortcomings of a previous copy collector. The new collector, like the old, uses C ++ 's facilities for creating abstract data types to define a tracked reference type, called roots, at the level of the application program. A programmer wishing to utilize the garbage collection service uses these roots in place of normal, raw pointers. We present a detailed study of the cost of using roots, as compared to both normal pointers and reference counted pointers, in terms of instruction counts. We examine the efficiency of a small C++ application using roots, reference counting, manual reclamation, and conservative collection. Coding the application to use garbage collection, and analyzing the resulting efficiency, helped us identify a number of memory leaks and inefficiencies in the original, manually reclaimed version. We find that for this program, garbage collection using roots is much more efficient than reference counting, though less efficient than manual reclamation. It is hard to directly compare our collector to the conservative collector because of the differing efficiencies of their respective memory allocators. This paper is a longer, more thorough version of a paper that appears in POPL '92 under the title, A mark-and-sweep collector for C++. 
Abstract-found: 1
Intro-found: 1
Reference: [ACM91] <editor> ACM. </editor> <booktitle> Proc. Programming Languages Design and Implementation, </booktitle> <month> June </month> <year> 1991. </year> <journal> SIGPLAN Notices 26(6). </journal>
Reference: [AL91] <author> Andrew W. Appel and Kai Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In Proc. International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 96-107, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year> <journal> SIGPLAN Notices 26(4). </journal>
Reference-contexts: This must be true, because when the table is allocated, all of its cells are free, and they are all linked into a free list. We read protect the last page of this table <ref> [AL91] </ref>. During program execution, when we attempt to load the link stored in the first cell on the read protected page, the program receives and handles a signal. That signal tells the system to allocate and link in a new root table.
Reference: [ANS89] <author> ANSI X3.159-1989, </author> <year> 1989. </year> <title> American national standard for the C programming language. </title>
Reference-contexts: To understand this description it is not necessary to know C, but we will sometimes provide descriptions in the form of comparisons with C. 3.1 Overview and Motivation C ++ is based largely on the C programming language <ref> [ISO90, ANS89, KR88, KP90] </ref> from which it inherits run-time efficiency. C ++ adds to C the notion of classes, a concept that it borrows from Simula-67 [DN66]. C is a good language for writing efficient, terse code.
Reference: [ANS93] <institution> Draft proposed international standard for information systems|Programming language C++, </institution> <month> January </month> <year> 1993. </year> <title> ANSI document X3J16/93-0010, ISO document WG21/N0218. </title>
Reference-contexts: It can find them it if has their addresses. Thus, the solution to this problem is, upon every member function invocation, store the address of the this pointer in a data structure analogous to the root stack. However, the C++ language definition <ref> [ANS93, Str91] </ref> forbids taking the address of this pointers. Thus, the collector can only be implemented in a customized compiler; it cannot be implemented and distributed in a library, as is our goal. The copy collector requires the addresses of the this pointers.
Reference: [App89] <author> Andrew W. Appel. </author> <title> Runtime tags aren't necessary. </title> <booktitle> In Lisp and Symbolic Computation, </booktitle> <volume> volume 2, </volume> <pages> pages 153-162, </pages> <year> 1989. </year>
Reference-contexts: After that, all objects with non-zero reference counts are root-referenced. The root-referenced objects serve as the root set for a standard mark-and-sweep garbage collection. Goldberg describes tag-free garbage collection for polymorphic statically-typed languages using compile-time information [Gol92] building on work by Appel <ref> [App89] </ref>. Goldberg's compiler emits functions that know how to collect garbage at various points in the program. Upon a collection, the collector follows the chain of return addresses up the run-time stack. As each stack frame is visited an associated garbage collection function is invoked.
Reference: [Bak78] <author> H. G. Baker. </author> <title> List processing in real time on a serial computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <month> April </month> <year> 1978. </year>
Reference: [Bar88] <author> Joel F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Technical Report 88/2, </type> <institution> Digital Equipment Corporation, Western Research Laboratory, Palo Alto, Califor-nia, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: Since they are fully conservative, during a collection they must examine every word of the stack, of global data, and of every marked object. Bartlett has written the Mostly Copying Collector, a generational garbage collector for Scheme and C++ that uses both conservative and copying techniques <ref> [Bar89, Bar88] </ref>. This collector divides the heap into logical pages, each of which has a space-identifier.
Reference: [Bar89] <author> Joel F. Bartlett. </author> <title> Mostly copying garbage collection picks up generations and C++. </title> <type> Technical Report TN-12, </type> <institution> DEC WRL, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: There are a number of ways that internal pointers can be identified. Bartlett's collector requires that the internal pointers be located at the beginning of the object, and that a count of the pointers be made available to the collector when the object is allocated <ref> [Bar89, Det90] </ref>. Detlefs' collector stores map information in an allocator header located immediately before the beginning of the object; the collector interprets this information to locate the internal pointers. <p> Since they are fully conservative, during a collection they must examine every word of the stack, of global data, and of every marked object. Bartlett has written the Mostly Copying Collector, a generational garbage collector for Scheme and C++ that uses both conservative and copying techniques <ref> [Bar89, Bar88] </ref>. This collector divides the heap into logical pages, each of which has a space-identifier.
Reference: [BDS91] <author> Hans-J. Boehm, Alan J. Demers, and Scott Shenker. </author> <title> Mostly parallel garbage collection. </title> <booktitle> In Proc. Programming Languages Design and Implementation [ACM91], </booktitle> <pages> pages 157-164. </pages> <note> SIG-PLAN Notices 26(6). </note>
Reference-contexts: Several of these collectors have been made publically available, as ours will be in the near future. Boehm et al. have conducted research in conservative garbage collectors <ref> [BDS91, BW88] </ref>. Their garbage collectors work without any compiler support in languages like C and C++. These collectors are sequential and parallel non-generational mark-and-sweep collectors. Russo has adapted these techniques for use in Choices, a C++ object-oriented operating system toolkit [Rus91, RMC90].
Reference: [BW88] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Boehm and Weiser's collector scans the entire object conservatively: The size of the object is available in the allocator header preceding the object <ref> [BW88] </ref>. Our collector associates a mark function with every collected type. While marking roots, the appropriate mark function is selected using the language's compile-time function overloading. <p> Several of these collectors have been made publically available, as ours will be in the near future. Boehm et al. have conducted research in conservative garbage collectors <ref> [BDS91, BW88] </ref>. Their garbage collectors work without any compiler support in languages like C and C++. These collectors are sequential and parallel non-generational mark-and-sweep collectors. Russo has adapted these techniques for use in Choices, a C++ object-oriented operating system toolkit [Rus91, RMC90].
Reference: [CDG + 88] <author> L. Cardelli, J. Donahue, L. Glassman, M. Jor-dan, B. Kalsow, and G. Nelson. </author> <type> Modula-3 report. Technical report, </type> <institution> Digital Systems Research Center and Olivetti Research Center, </institution> <address> Palo Alto, CA, </address> <year> 1988. </year>
Reference: [Coh81] <author> Jacques Cohen. </author> <title> Garbage collection of linked data structures. </title> <journal> ACM Computing Surveys, </journal> <volume> 13(3) </volume> <pages> 341-367, </pages> <month> September </month> <year> 1981. </year>
Reference: [CUL89] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An efficient implementation of SELF a dynamically-typed object-oriented language based on prototypes. </title> <booktitle> In Proc. Object-Oriented Programming Systems Languages and Applications, </booktitle> <pages> pages 49-70, </pages> <month> October </month> <year> 1989. </year> <journal> SIGPLAN Notices 24(10). </journal>
Reference: [Det90] <author> David Detlefs. </author> <title> Concurrent garbage collection for C++. </title> <type> Technical Report CMU-CS-90-119, </type> <institution> Carnegie Mellon, </institution> <year> 1990. </year>
Reference-contexts: There are a number of ways that internal pointers can be identified. Bartlett's collector requires that the internal pointers be located at the beginning of the object, and that a count of the pointers be made available to the collector when the object is allocated <ref> [Bar89, Det90] </ref>. Detlefs' collector stores map information in an allocator header located immediately before the beginning of the object; the collector interprets this information to locate the internal pointers. <p> Those objects are promoted by having the space identifiers of their pages advanced. Then the root-referenced objects are (type-accurately) scanned; the objects they reference are compactly copied to the new space. This collector works only with non-polymorphic data structures. Detlefs' generalizes Bartlett's collector in two ways <ref> [Det90] </ref>. Bartlett's collector contains two restrictions: 1. Internal pointers must be located at the beginning of objects, and 2. heap-allocated objects may not contain "unsure" pointers. 1 Detlefs' relaxes these by maintaining type-specific map information in a header in front of every object.
Reference: [DLM + 78] <author> Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Stef-fens. </author> <title> On-the-fly garbage collection: An ex-cercise in cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-974, </pages> <month> November </month> <year> 1978. </year>
Reference: [DN66] <author> O. J. Dahl and K. Nygaard. </author> <title> Simula|An Algol-based simulation language. </title> <journal> Communications of the ACM, </journal> <volume> 9 </volume> <pages> 671-678, </pages> <year> 1966. </year>
Reference-contexts: C ++ adds to C the notion of classes, a concept that it borrows from Simula-67 <ref> [DN66] </ref>. C is a good language for writing efficient, terse code. However, for a number of reasons, C is not a good programming language for writing abstractions: * C data types are only minimally partitioned into interface and implementation.
Reference: [Ede92] <author> Daniel R. Edelson. </author> <title> A mark-and-sweep collector for C++. </title> <booktitle> In Proc. Principles of Programming Languages, </booktitle> <pages> pages 51-58. </pages> <publisher> ACM, ACM, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: There are a few aspects that should be kept in mind before jumping to this conclusion. Chief among these is the cost of external fragmentation in the root tables. This is discussed in x5.8. 5.6.6 An application In a previous paper <ref> [Ede92] </ref>, we empirically compared the efficiency of an early version of this mark and sweep collector to that of the Boehm/Weiser conservative collector. The application we used was a VLSI CAD application called ITEM that performed logic minimization on If-Then-Else tuples. <p> Furthermore, there are risks associated with the use of conservative collection. For example, Wentworth has found that conservative collection can perform poorly in terms of retention of garbage in densely populated address spaces [Wen90]. In <ref> [Ede92] </ref>, we found that conservative collection was unable to reclaim any data from 4-8 megabyte garbage data structures. The reason was that the garbage data structures were strongly connected, and a few false pointers in global data into the data structure prevented any garbage from being reclaimed.
Reference: [EP89] <author> Daniel R. Edelson and Ira Pohl. </author> <title> Solving C's shortcomings: Use C++. </title> <journal> Computer Languages, </journal> <volume> 14(3), </volume> <year> 1989. </year>
Reference-contexts: C ++ retains C's ability to program close to the machine level <ref> [EP89, PE88] </ref> making it a good language for writing efficient code. However, it adds high-level abstraction and object-oriented mechanisms allowing it to ameliorate the aforementioned deficiencies of C. We use C ++ 's abstraction mechanisms to provide a GC service.
Reference: [EP91] <author> Daniel R. Edelson and Ira Pohl. </author> <title> A copying collector for C++. </title> <booktitle> In Proc. Usenix C++ Conference [Use91], </booktitle> <pages> pages 85-102. </pages>
Reference-contexts: For this reason, the second invocation of id () from whos there () causes the string "derived" to be printed. 4 A Copy Collector We have used root registration to implement a copy collector <ref> [EP91] </ref>. It implements the basic copy collector algorithm as described in [FY69]. 4.1 Locating Roots Since this is a copy collector it moves objects and must be able to modify roots.
Reference: [FY69] <author> R. Fenichel and J. Yochelson. </author> <title> A LISP garbage-collector for virtual-memory systems. </title> <journal> Communications of the ACM, </journal> <volume> 12(11) </volume> <pages> 611-612, </pages> <month> Novem-ber </month> <year> 1969. </year>
Reference-contexts: For this reason, the second invocation of id () from whos there () causes the string "derived" to be printed. 4 A Copy Collector We have used root registration to implement a copy collector [EP91]. It implements the basic copy collector algorithm as described in <ref> [FY69] </ref>. 4.1 Locating Roots Since this is a copy collector it moves objects and must be able to modify roots. This contrasts with a mark 9 and-sweep collector in which is it sufficient to have a copy of every root.
Reference: [Gol92] <author> Benjamin Goldberg. </author> <title> Tag-free garbage collection for strongly typed programming languages. </title> <booktitle> In Proc. Programming Languages Design and Implementation [ACM91], </booktitle> <pages> pages 165-176. </pages> <booktitle> SIGPLAN Notices 26(6). </booktitle>
Reference-contexts: After that, all objects with non-zero reference counts are root-referenced. The root-referenced objects serve as the root set for a standard mark-and-sweep garbage collection. Goldberg describes tag-free garbage collection for polymorphic statically-typed languages using compile-time information <ref> [Gol92] </ref> building on work by Appel [App89]. Goldberg's compiler emits functions that know how to collect garbage at various points in the program. Upon a collection, the collector follows the chain of return addresses up the run-time stack.
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference: [ISO90] <institution> ISO 9899-1990, </institution> <year> 1990. </year> <title> International standard for the C programming language. </title>
Reference-contexts: To understand this description it is not necessary to know C, but we will sometimes provide descriptions in the form of comparisons with C. 3.1 Overview and Motivation C ++ is based largely on the C programming language <ref> [ISO90, ANS89, KR88, KP90] </ref> from which it inherits run-time efficiency. C ++ adds to C the notion of classes, a concept that it borrows from Simula-67 [DN66]. C is a good language for writing efficient, terse code.
Reference: [Ken91] <author> Brian Kennedy. </author> <title> The features of the object-oriented abstract type hierarchy (OATH). </title> <booktitle> In 24 Proc. Usenix C++ Conference [Use91], </booktitle> <pages> pages 41-50. </pages>
Reference-contexts: The header can represent information about both sure pointers and unsure pointers. The collector treats sure pointers accurately and unsure pointers conservatively. Detlefs' collector is concurrent and is implemented in the cfront C++ compiler. Kennedy describes a C++ type hierarchy called OATH that uses garbage collection <ref> [Ken91] </ref>. Its collector algorithm uses a combination of reference counting and mark-and-sweep. In OATH objects are accessed exclusively through references called accessors. An ac-cessor implements reference semantics and reference counting on its referent. OATH uses a three-phase mark-and-sweep algorithm.
Reference: [Knu73] <author> Donald E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> volume 1. </volume> <publisher> Addison, Wesley, </publisher> <address> Reading, Mass., </address> <year> 1973. </year> <note> Second ed. </note>
Reference: [KP90] <author> Al Kelley and Ira Pohl. </author> <title> A Book on C: Second Edition. </title> <address> Benjamin/Cummings, Redwood City, California, </address> <year> 1990. </year>
Reference-contexts: To understand this description it is not necessary to know C, but we will sometimes provide descriptions in the form of comparisons with C. 3.1 Overview and Motivation C ++ is based largely on the C programming language <ref> [ISO90, ANS89, KR88, KP90] </ref> from which it inherits run-time efficiency. C ++ adds to C the notion of classes, a concept that it borrows from Simula-67 [DN66]. C is a good language for writing efficient, terse code.
Reference: [KR88] <author> Brian Kernighan and Dennis Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood-Cliffs, N.J., 2 nd ed. edition, </address> <year> 1988. </year>
Reference-contexts: To understand this description it is not necessary to know C, but we will sometimes provide descriptions in the form of comparisons with C. 3.1 Overview and Motivation C ++ is based largely on the C programming language <ref> [ISO90, ANS89, KR88, KP90] </ref> from which it inherits run-time efficiency. C ++ adds to C the notion of classes, a concept that it borrows from Simula-67 [DN66]. C is a good language for writing efficient, terse code.
Reference: [Lam83] <author> Butler W. Lampson. </author> <title> A description of the Cedar language: A Cedar language reference manual. </title> <type> Technical Report CLS-83-15, </type> <note> Xerox PARC, </note> <year> 1983. </year>
Reference-contexts: The use of constructors is perfectly consistent with garbage collection. Destructors, however, present a problem. Precisely when garbage collected objects become inaccessible is generally unknown. This renders synchronous destruction impossible [Str91]. Instead, we provide finalization <ref> [Lam83] </ref>. Finalization is essentially the equivalent of an asynchronous destructor. When an object is garbage collected, immediately before its storage is deallocated, the object is finalized. Thus, finalization is used to "clean-up" after an object.
Reference: [Lea91] <author> Doug Lea. </author> <title> A memory allocator for libg++. </title> <type> Private communication, </type> <year> 1991. </year>
Reference-contexts: the garbage-collection specific memory allocator rather than the standard one. 17 class anything - ... public: virtual void mark (); void * operator new (size_t sz) return gc_malloc (sz); - void operator delete (void * p) - gc_free (p); - -; Our memory allocator is derived from Lea's libg++ allocator <ref> [Lea91] </ref>. It uses lists of blocks whose sizes are powers of two as well as intermediate sizes. To satisfy an allocation request, the smallest block size that is large enough is used. If no block of the desired size is available, a larger block is broken up.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference: [Mil87] <author> J. S. Miller. Multischeme: </author> <title> A Parallel Processing System Based on MIT Scheme. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1987. </year> <note> MIT/LCS/Tech. Rep.-402. </note>
Reference-contexts: Indeed, the careful use of direct pointers represents a useful (if dangerous) optimization. This also provides weak pointers. A weak pointer is a reference that does not cause an object to be retained during garbage collection <ref> [Mil87] </ref>. The object will be retained only if it is also referenced by a non-weak pointer. Ideally, an access through a weak pointer can detect when the object has been deallocated. That is not possible when using raw pointers for weak pointers.
Reference: [Min63] <author> M. L. Minsky. </author> <title> A LISP garbage collector algorithm using serial secondary storage. </title> <type> Technical Report Memo 58 (rev.), </type> <institution> Project Mac, MIT, </institution> <address> Cambridge, MA, </address> <month> December </month> <year> 1963. </year>
Reference: [Pat85] <author> David Patterson. </author> <title> Reduced Instruction Set Computers. </title> <journal> Communications of the ACM, </journal> <volume> 28(1) </volume> <pages> 8-21, </pages> <year> 1985. </year>
Reference-contexts: This is a good measure of complexity because it is independent of system load, clock speed, or other architecture-dependent parameters. On common RISC processors, instructions that reference memory tend to be more expensive than pure register operations, because memories are slower than processors <ref> [Pat85] </ref>. Likewise, branches are disruptive because they interrupt instruction pipelines. Therefore, in our tables of complexity, we indicate not just the number of instructions, but also the number of memory references and whether or not a branch is involved.
Reference: [PE88] <author> Ira Pohl and Daniel R. Edelson. A-Z: </author> <title> C language shortcomings. </title> <journal> Computer Languages, </journal> <volume> 13(2), </volume> <year> 1988. </year>
Reference-contexts: C ++ retains C's ability to program close to the machine level <ref> [EP89, PE88] </ref> making it a good language for writing efficient code. However, it adds high-level abstraction and object-oriented mechanisms allowing it to ameliorate the aforementioned deficiencies of C. We use C ++ 's abstraction mechanisms to provide a GC service.
Reference: [Poh92] <author> Ira Pohl, </author> <year> 1992. </year> <title> Private communication. </title>
Reference: [RMC90] <author> Vincent Russo, Peter W. Madany, and Roy H. Campbell. </author> <title> C++ and operating systems performance: A case study. </title> <booktitle> In Usenix C++ Conference, </booktitle> <pages> pages 103-114. </pages> <publisher> Usenix Association, </publisher> <month> April </month> <year> 1990. </year>
Reference-contexts: Their garbage collectors work without any compiler support in languages like C and C++. These collectors are sequential and parallel non-generational mark-and-sweep collectors. Russo has adapted these techniques for use in Choices, a C++ object-oriented operating system toolkit <ref> [Rus91, RMC90] </ref>. Since they are fully conservative, during a collection they must examine every word of the stack, of global data, and of every marked object. Bartlett has written the Mostly Copying Collector, a generational garbage collector for Scheme and C++ that uses both conservative and copying techniques [Bar89, Bar88].
Reference: [Rus91] <author> Vincent Russo. </author> <title> Using the parallel Boehm/Weiser/Demers collector in an operating system, 1991. </title> <type> Private communication. </type>
Reference-contexts: Their garbage collectors work without any compiler support in languages like C and C++. These collectors are sequential and parallel non-generational mark-and-sweep collectors. Russo has adapted these techniques for use in Choices, a C++ object-oriented operating system toolkit <ref> [Rus91, RMC90] </ref>. Since they are fully conservative, during a collection they must examine every word of the stack, of global data, and of every marked object. Bartlett has written the Mostly Copying Collector, a generational garbage collector for Scheme and C++ that uses both conservative and copying techniques [Bar89, Bar88].
Reference: [Str91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> second edition, </address> <year> 1991. </year>
Reference-contexts: It can find them it if has their addresses. Thus, the solution to this problem is, upon every member function invocation, store the address of the this pointer in a data structure analogous to the root stack. However, the C++ language definition <ref> [ANS93, Str91] </ref> forbids taking the address of this pointers. Thus, the collector can only be implemented in a customized compiler; it cannot be implemented and distributed in a library, as is our goal. The copy collector requires the addresses of the this pointers. <p> In the case of local variables, for example, this is when the variable leaves scope. The use of constructors is perfectly consistent with garbage collection. Destructors, however, present a problem. Precisely when garbage collected objects become inaccessible is generally unknown. This renders synchronous destruction impossible <ref> [Str91] </ref>. Instead, we provide finalization [Lam83]. Finalization is essentially the equivalent of an asynchronous destructor. When an object is garbage collected, immediately before its storage is deallocated, the object is finalized. Thus, finalization is used to "clean-up" after an object.
Reference: [Ung86] <author> David Ungar. </author> <title> The Design and Evaluation of a High Performance Smalltalk System. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference: [Use91] <editor> Usenix Association. </editor> <booktitle> Proc. Usenix C++ Conference, </booktitle> <month> April </month> <year> 1991. </year>
Reference: [War87] <author> The Soft Warehouse. </author> <title> muLISP Reference Manual. </title> <address> Honolulu, </address> <year> 1987. </year>
Reference: [Wen88] <author> E. P. Wentworth. </author> <title> An environment for investigating functional languages and implementations. </title> <type> PhD thesis, </type> <institution> University of Port Elizabeth, South Africa, </institution> <year> 1988. </year>
Reference: [Wen90] <author> E. P. Wentworth. </author> <title> Pitfalls of conservative garbage collection. </title> <journal> Software Practice and Experience, </journal> <pages> pages 719-727, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Furthermore, there are risks associated with the use of conservative collection. For example, Wentworth has found that conservative collection can perform poorly in terms of retention of garbage in densely populated address spaces <ref> [Wen90] </ref>. In [Ede92], we found that conservative collection was unable to reclaim any data from 4-8 megabyte garbage data structures. The reason was that the garbage data structures were strongly connected, and a few false pointers in global data into the data structure prevented any garbage from being reclaimed.
Reference: [Wik87] <author> Ake Wikstrom. </author> <title> Functional programming using standard ML. </title> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference: [Wir71] <author> N. Wirth. </author> <title> The programming language PAS-CAL. </title> <journal> Acta Informatica, </journal> <volume> 1 </volume> <pages> 35-63, </pages> <year> 1971. </year> <month> 25 </month>
Reference-contexts: In this discussion we refer to an object whose type is "class X" (type "X" for short) as an instance of X. Similarly to a struct in C, or a record in Pascal <ref> [Wir71] </ref>, a class describes the data that its instances contain. However, a class also can describe numerous other attributes of the type: 1. A class lists the methods (operations) that are provided for objects of the type. 2.
References-found: 45

