URL: http://www-ccs.cs.umass.edu/recpub-rts/rtas98.ps
Refering-URL: http://www-ccs.cs.umass.edu/recpub-rts/index.html
Root-URL: 
Email: shree@cs.umass.edu)  (shen@merl.com)  
Title: Using Windows NT for Real-Time Applications: Experimental Observations and Recommendations  
Author: Krithi Ramamritham, Chia Shen(), Oscar Gonzalez, Subhabrata Sen and Shreedhar Shirgurkar 
Address: Amherst, MA 01003 (krithi, ogonzale, sen,  Cambridge, MA 02139  
Affiliation: Computer Science Department University of Massachusetts  MERL A Mitsubishi Electric Research Lab  
Abstract: Windows NT was not designed as a real-time operating system, but market forces and the acceptance of NT in industrial applications have generated a need for achieving real-time functionality with NT. As its use for real-time applications proliferates, based on an experimental evaluation of NT, we quantitatively characterize the obstacles placed by NT. As a result of these observations, we provide a set of recommendations for users to consider while building real-time applications on NT. These are validated by the use of NT for a prototype application involving real-time control that includes multimedia information processing. The results of the above study should provide system designers with guidelines, as well as insight, into the design of an architecture based on NT for supporting applications with components having real-time constraints. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Custer, </author> <title> Inside Windows NT, </title> <publisher> Microsoft Press, </publisher> <year> 1993. </year>
Reference-contexts: The I/O manager completes the I/O request. In the third step of I/O processing, the system writes the data from the I/O operation into the address space of the thread which requested the I/O. In this step, two mechanisms are used <ref> [1] </ref>: * Buffered I/O: Used for slower I/O devices where the data transfer first takes place into the system memory area and an Asynchronous Procedure Call (APC) is queued to copy this data into the user thread' s local area. * Direct I/O: Used for faster devices like the disk.
Reference: [2] <author> HyperKernel, </author> <note> http://www.imagination.com/. </note>
Reference-contexts: The HAL trappings attempt to assign interrupt handlers to interrupts reserved for real-time kernel use. * RadiSys also claims to maintain complete address space isolation and memory protection between real time and Windows NT processes. Anther commercial solution is the one offered by Imagination Systems <ref> [2] </ref>. Their real-time subsystem called Hy-perKernel has its own scheduler, its own set of services, and its own internal kernel. From the literature, it seems that they are using hardware support to achieve a complete separation between two co-resident operating systems and also do not modify the HAL.
Reference: [3] <author> G. Bollella and K. Jeffay. </author> <title> Support for Real-Time Computing within General Purpose Operating Systems, </title> <booktitle> In Proceedings of the IEEE Real-Time Technology and Applications Symposium, </booktitle> <address> Chicago, IL, </address> <month> May </month> <year> 1995, </year> <month> pp.4-14. </month>
Reference-contexts: The two OSs are able to communicate via an extension to the Win--dows NT API. This mechanism uses hardware support in order to achieve a complete separation between two co-resident operating systems. This approach is similar to the work done by Jeffay and Bollela <ref> [3] </ref>. The latter work implemented a small CPU executive which multiplexes the CPU between their own real-time kernel and an IBM microkernel with an OSF1 server. The difference between INtime and [3] is that INtime runs Windows NT as its lowest priority process and in [3] the CPU is shared between <p> This approach is similar to the work done by Jeffay and Bollela <ref> [3] </ref>. The latter work implemented a small CPU executive which multiplexes the CPU between their own real-time kernel and an IBM microkernel with an OSF1 server. The difference between INtime and [3] is that INtime runs Windows NT as its lowest priority process and in [3] the CPU is shared between the two operating systems. <p> done by Jeffay and Bollela <ref> [3] </ref>. The latter work implemented a small CPU executive which multiplexes the CPU between their own real-time kernel and an IBM microkernel with an OSF1 server. The difference between INtime and [3] is that INtime runs Windows NT as its lowest priority process and in [3] the CPU is shared between the two operating systems. <p> Also, it seems that interrupts are controlled by direct access to the Interrupt controller. Superficially at least, their methodology appears to have elements of commonality to the approach taken by RadiSys as well as the work by Jeffay and Bollela <ref> [3] </ref>. The VenturCom approach [14] places a real-time OS (RTX) as a subsystem inside Windows NT in the form of a device driver. RTX facilities include priority scheduling, non-degrading priorities, inversion management, IPC support, fast clocks and timers, memory allocation and page fault elimination.
Reference: [4] <author> Z. Deng and J.W.S. Liu. </author> <title> Scheduling Real-Time Applications in an Open Environment. </title> <booktitle> 18th Real-Time Systems Symposium, </booktitle> <month> Dec </month> <year> 1997, </year> <pages> pp. 308-319. </pages>
Reference-contexts: The solution involves using a restricted set of support from Windows NT, and using careful analysis to reduce the timing unpredictability. Once such an application is implemented, changes are either disallowed or require a complete overhaul in order to guarantee the timing requirements. * Modify the Windows NT kernel <ref> [4] </ref>. This option requires continuous changes to the modifications as new versions of NT appear. * Couple real-time operating systems with Windows NT, with each OS running in a different machine. * Provide a Win32 API wrapper around a real-time OS.
Reference: [5] <author> O. Gonzalez, C. Shen, I. Mizunuma, and M. Takegaki. </author> <title> Implementation and Performance of MidART. </title> <booktitle> In IEEE Workshop on Middleware for Distributed Real-time systems and Services, </booktitle> <address> San Francisco, CA, </address> <month> December </month> <year> 1997. </year>
Reference-contexts: But, used judiciously, it may be useful for applications that (1) can tolerate occasional deadline misses, and (2) have delay/response time requirements in the tens to hundreds of milliseconds range such as those described in <ref> [5, 7, 9] </ref>. To this end, a key element of our study is to see to what extent the unpredictable parts of NT can be masked. We begin, in Section 2, by giving an overview of the capabilities of NT that are potentially useful to real-time system builders.
Reference: [6] <author> I. Kawakami, Y. Katayama, and H. Kurosawa. </author> <title> A Newly Structured Real-Time Control Mechanism based on Personal Computers(RT-PC). </title> <booktitle> In International Conference on Electrical Engineering, </booktitle> <address> Matsue, Japan, </address> <month> July </month> <year> 1997. </year>
Reference-contexts: This is only a partial solution, which needs to be coupled with a small real-time executive as is done in Ventur com's RTX [14] and Real-Time Linux [13]. * Compose a Windows NT driver to run all the time critical threads. This is the approach taken in <ref> [6] </ref>. This approach has the drawback of (1) having to create a totally new API for users to construct real-time tasks to run in this driver environment, and (2) potentially still incurring all potential blocking from other ISR and DPCs.
Reference: [7] <author> I. Mizunuma, C. Shen, and M. Takegaki. </author> <title> Middleware for Distributed Industrial Real-Time Systems on ATM Networks. </title> <booktitle> In 17th IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1996. </year>
Reference-contexts: But, used judiciously, it may be useful for applications that (1) can tolerate occasional deadline misses, and (2) have delay/response time requirements in the tens to hundreds of milliseconds range such as those described in <ref> [5, 7, 9] </ref>. To this end, a key element of our study is to see to what extent the unpredictable parts of NT can be masked. We begin, in Section 2, by giving an overview of the capabilities of NT that are potentially useful to real-time system builders.
Reference: [8] <institution> Approaches to Real-Time Windows NT, </institution> <address> http://www.radisys.com/products/rtos/intime app.html. </address>
Reference-contexts: In this work our intention is to evaluate NT as is for real-time uses. On the other hand, various commercial efforts are aggressively working towards extending NT (typically by modifying NT or its underlying layers <ref> [8] </ref>, [14]). Section 5 critically evaluates these efforts as well as Windows CE (intended for embedded applications) and other research efforts. Although there have been efforts in qualitatively analyzing Windows NT's suitability for real-time applications [11], this paper is the first effort in quantitatively studying NT via an experimental approach. <p> The following are some of the limitations in Windows NT due mostly to the lack of provisions that take into account the priority of an event/object by various services/mechanisms that may contribute to unpredictable delays for user applications <ref> [8, 11, 14] </ref>. The priority level of interrupts is always higher than that of a user-level thread, including threads in the real-time class. When an interrupt occurs, the trap handler saves the machine's state and calls the interrupt dispatcher. <p> We now discuss other approaches that can be envisaged for overcoming the limitations of NT <ref> [8] </ref>. * Use a highly constrained and fine tuned Windows NT and application environment. This approach is suitable mainly for applications whose worst case resource behavior can be determined beforehand. <p> The objective of the device driver is to provide the services which are not supported by NT and to trap hardware interrupts. The following is a description of commercial products using these approaches: RadiSys <ref> [8] </ref> places INtime, a real-time kernel based on iRMX, outside the Windows NT address space. The two OSs are able to communicate via an extension to the Win--dows NT API. This mechanism uses hardware support in order to achieve a complete separation between two co-resident operating systems.
Reference: [9] <author> C. Shen and I. Mizunuma. RT-CRM: </author> <title> Real-Time Channel-Based Reflective Memory. </title> <booktitle> In IEEE Real-Time Technology and Applications Symposium, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: But, used judiciously, it may be useful for applications that (1) can tolerate occasional deadline misses, and (2) have delay/response time requirements in the tens to hundreds of milliseconds range such as those described in <ref> [5, 7, 9] </ref>. To this end, a key element of our study is to see to what extent the unpredictable parts of NT can be masked. We begin, in Section 2, by giving an overview of the capabilities of NT that are potentially useful to real-time system builders. <p> Evaluating NT in a Real-Time Setting To understand NT better, we prototyped a real-time control scenario involving multimedia information. In particular the focus was on the operator's workstation <ref> [9] </ref>. The software running on the workstation has the following components [10]. Operator input: The operator inputs control messages and actuator settings. An input has to be recognized, processed and sent to a remote destination through the network.
Reference: [10] <author> H. Shimakawa, </author> <title> Mitsubishi Electric Corporation, </title> <type> personal communication, </type> <year> 1996. </year>
Reference-contexts: Evaluating NT in a Real-Time Setting To understand NT better, we prototyped a real-time control scenario involving multimedia information. In particular the focus was on the operator's workstation [9]. The software running on the workstation has the following components <ref> [10] </ref>. Operator input: The operator inputs control messages and actuator settings. An input has to be recognized, processed and sent to a remote destination through the network. The control message is processed at the remote node and the necessary control action is taken. <p> As for the workload tested, what we have experimented with is a real work load <ref> [10] </ref> characterizing a typical operator workstation which experiences periodic sensor data input in 1K byte sizes, sends out sporadic operator commands not more often than every 100ms, and displays one video window.
Reference: [11] <author> M. Timmerman, </author> <title> Windows NT as Real-Time OS, Real Time Magazine, </title> <note> 1Q97 Issue, http://www.realtime-info.be/encyc/magazine/articles/winnt/winnt.htm#backfive. </note>
Reference-contexts: Section 5 critically evaluates these efforts as well as Windows CE (intended for embedded applications) and other research efforts. Although there have been efforts in qualitatively analyzing Windows NT's suitability for real-time applications <ref> [11] </ref>, this paper is the first effort in quantitatively studying NT via an experimental approach. We hope this paper, based on systematic experimental evaluations, will provide guidelines, as well as insight, needed to design a software ar-chitecture based on Windows NT capable of supporting hard and soft real-time tasks. <p> The following are some of the limitations in Windows NT due mostly to the lack of provisions that take into account the priority of an event/object by various services/mechanisms that may contribute to unpredictable delays for user applications <ref> [8, 11, 14] </ref>. The priority level of interrupts is always higher than that of a user-level thread, including threads in the real-time class. When an interrupt occurs, the trap handler saves the machine's state and calls the interrupt dispatcher.
Reference: [12] <editor> Windows CE web pages: </editor> <address> http://www.microsoft.com/windowsce/ </address>
Reference-contexts: Most of these products are still in the development or initial deployment stage and more details of their approaches are needed for in-depth evaluation and understanding. Another alternative to NT is Windows CE <ref> [12] </ref> that is targeted at embedded applications. Unlike Windows NT, Windows CE does not provide process priority classes. At any time, there can be a maximum of 32 processes within the system.
Reference: [13] <author> V. Yodaiken, </author> <title> A Real-Time Linux, </title> <address> http://luz.cs.nmt.edu/ rtlinux/. </address>
Reference-contexts: This is only a partial solution, which needs to be coupled with a small real-time executive as is done in Ventur com's RTX [14] and Real-Time Linux <ref> [13] </ref>. * Compose a Windows NT driver to run all the time critical threads. This is the approach taken in [6]. <p> We believe that NT is also considered the lowest priority process, but have not been able to confirm this. The approach taken by VenturCom is similar to the one taken in Real-Time Linux <ref> [13] </ref>. Here a software emulation of the interrupt control hardware interacts with the OS. Interrupts directed to Linux are passed to the emulation software after real-time tasks are executed by a small real-time executive.
Reference: [14] <institution> VenturCom home page: </institution> <note> http://www.vci.com/. </note>
Reference-contexts: In this work our intention is to evaluate NT as is for real-time uses. On the other hand, various commercial efforts are aggressively working towards extending NT (typically by modifying NT or its underlying layers [8], <ref> [14] </ref>). Section 5 critically evaluates these efforts as well as Windows CE (intended for embedded applications) and other research efforts. Although there have been efforts in qualitatively analyzing Windows NT's suitability for real-time applications [11], this paper is the first effort in quantitatively studying NT via an experimental approach. <p> The following are some of the limitations in Windows NT due mostly to the lack of provisions that take into account the priority of an event/object by various services/mechanisms that may contribute to unpredictable delays for user applications <ref> [8, 11, 14] </ref>. The priority level of interrupts is always higher than that of a user-level thread, including threads in the real-time class. When an interrupt occurs, the trap handler saves the machine's state and calls the interrupt dispatcher. <p> This alternative does not meet the requirement of running Windows NT applications in unison with the real-time tasks. * Modify the Hardware Abstraction Layer (HAL). This is only a partial solution, which needs to be coupled with a small real-time executive as is done in Ventur com's RTX <ref> [14] </ref> and Real-Time Linux [13]. * Compose a Windows NT driver to run all the time critical threads. This is the approach taken in [6]. <p> Also, it seems that interrupts are controlled by direct access to the Interrupt controller. Superficially at least, their methodology appears to have elements of commonality to the approach taken by RadiSys as well as the work by Jeffay and Bollela [3]. The VenturCom approach <ref> [14] </ref> places a real-time OS (RTX) as a subsystem inside Windows NT in the form of a device driver. RTX facilities include priority scheduling, non-degrading priorities, inversion management, IPC support, fast clocks and timers, memory allocation and page fault elimination.
References-found: 14

