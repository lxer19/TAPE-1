URL: http://theory.lcs.mit.edu/tds/papers/Lynch/REX91.ps
Refering-URL: http://theory.lcs.mit.edu/tds/papers/Lynch/REX91.html
Root-URL: 
Title: Forward and Backward Simulations for Timing-Based Systems  
Author: Nancy Lynch and Frits Vaandrager 
Keyword: Simulations, timing-based systems, real-time, timed automata, refinement mappings, forward simulations, backward simulations, forward-backward simulations, backward-forward simulations, history variables, prophecy variables, history relations, prophecy relations.  
Note: Contents  
Address: Cambridge, MA 02139, USA  
Affiliation: MIT Laboratory for Computer Science  
Abstract: A general automaton model for timing-based systems is presented and is used as the context for developing a variety of simulation proof techniques for such systems. As a first step, a comprehensive overview of simulation techniques for simple untimed automata is given. In particular, soundness and completeness results for (1) refinements, (2) forward and backward simulations, (3) forward-backward and backward-forward simulations, and (4) history and prophecy relations are given. History and prophecy relations are new and are abstractions of the history variables of Owicki and Gries and the prophecy variables of Abadi and Lamport, respectively. As a subsequent step, it is shown how most of the results for untimed automata can be carried over to the setting of timed automata. In fact, many of the results for the timed case are obtained as consequences of the analogous results for the untimed case. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 2(82) </volume> <pages> 253-284, </pages> <year> 1991. </year>
Reference-contexts: We prove basic results for these kinds of simulations, in particular, soundness and completeness theorems. We also define history relations and prophecy relations, which are abstract versions of the history and prophecy variables of Abadi and Lamport <ref> [1] </ref>. We prove theorems describing the properties of these various kinds of simulations and relating the different kinds of simulations to each other. The goal of extending simulation techniques to timing-based systems is also the motivation for the work of Lynch and Attiya in [19]. <p> Backward simulations occurred first in [9] under the name of upward simulations and were used later in the setting of CSP in [14, 8]. In [21, 12] it is observed that they are closely related to the prophecy variables first defined in <ref> [1] </ref>. <p> Abadi and Lamport <ref> [1] </ref> demonstrate the usefulness of prophecy variables (and hence backward simulations) in the untimed setting, with some simple examples. Again, we give soundness and partial completeness results for the timed setting. <p> While some of the results for this case are symmetric with the forward-backward case, others (notably, certain completeness results) do not hold. We also provide redefinitions of the history variable notion of [27] and the prophecy variable notions of <ref> [1] </ref>, in terms of timed automata, and prove equivalence results between these explicit definitions and our more abstract simulation definitions. In order to present our results for timed automata, we find it convenient first to describe corresponding results for the simpler untimed setting. <p> second case saying that if B has fin and A flT B, then A iBF B. 4.4 Auxiliary Variable Constructions In this subsection, we present two new types of relations, history relations and prophecy relations, which correspond to the notions of history variable and prophecy variable of Abadi and Lamport <ref> [1] </ref>. We show that there exists a close connection between history relations and forward simulations, and also between prophecy relations and backward simulations. <p> Using these connections together with the earlier results of this section, we can easily derive a completeness theorem for refinements similar to the one of Abadi and Lamport <ref> [1] </ref>. <p> It now follows that h 0 ffi h is a history relation from A to C. The notion of a history relation is a new contribution of this paper. It provides a simple and abstract view of the history variables of Abadi and Lamport <ref> [1] </ref>. Translated to the setting of this paper history variables can be simply defined in terms of history relations, as follows. <p> Theorem 4.42 1. A B B , (9C : A P C R B), Proof: The proof of 1 is analogous to that of Theorem 4.36, using Lemma 4.41. 2 can be proved similarly. We finish this section with versions of the completeness results of <ref> [1] </ref>. Theorem 4.43 (Completeness of history relations, prophecy relations and refinements, [1]) Suppose A flT B. Then 1. 9C; D : A H C P D R B, and 2. if B has fin then 9C; D : A H C iP D R B. <p> We finish this section with versions of the completeness results of <ref> [1] </ref>. Theorem 4.43 (Completeness of history relations, prophecy relations and refinements, [1]) Suppose A flT B. Then 1. 9C; D : A H C P D R B, and 2. if B has fin then 9C; D : A H C iP D R B. Proof: By Theorem 4.16, there exists an automaton E with A F E B B.
Reference: [2] <author> J.C.M. Baeten and J.A. Bergstra. </author> <title> Real time process algebra. </title> <journal> Journal of Formal Aspects of Computing Science, </journal> <volume> 3(2) </volume> <pages> 142-188, </pages> <year> 1991. </year>
Reference-contexts: We propose a notion of timed automaton, which is just an automaton (or labeled transition system) equipped with some additional structure. Specifically, each state of the automaton has an associated time, which indicates the current time. (Thus we use absolute time in the sense of <ref> [2] </ref>.) The actions of the automaton are of three kinds: visible actions, time-passage actions, and a special internal action t . <p> As in many other formalisms for real-time, see for instance <ref> [2, 3, 7, 22, 24, 25, 32] </ref>, all actions except for the time-passage actions are modeled as occurring instantaneously, i.e., they do not change the time component of the state.
Reference: [3] <author> G. Berry and L. Cosserat. </author> <title> The ESTEREL synchronous programming language and its mathematical semantics. </title> <editor> In A.W. Roscoe & G. Winskel S.D. Brookes, editor, </editor> <booktitle> Seminar on Concurrency, </booktitle> <pages> pages 389-448, </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: As in many other formalisms for real-time, see for instance <ref> [2, 3, 7, 22, 24, 25, 32] </ref>, all actions except for the time-passage actions are modeled as occurring instantaneously, i.e., they do not change the time component of the state.
Reference: [4] <author> R. Gerber and I. Lee. </author> <title> The formal treatment of priorities in real-time computation. </title> <booktitle> In Proceedings 6th IEEE Workshop on Real-Time Software and Operating Systems, </booktitle> <year> 1989. </year>
Reference-contexts: To specify times, we use a dense time domain, specifically, the nonnegative reals (starting with time 0 in the initial state), and we impose no lower bound on the time between events. This choice distinguishes our work from many others', e.g., <ref> [4, 7, 24, 25, 29, 33] </ref>, in which discrete time values or universal positive lower bounds on step time are used. Use of real-valued time is less restrictive, and we believe that the extra flexibility will be useful in the design and analysis of timing-based distributed algorithms.
Reference: [5] <author> R. Gerth. </author> <title> Foundations of compositional program refinement (first version). </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> REX Workshop on Stepwise Refinement of Distributed Systems: Models, Formalism, Correctness, Mook, </title> <booktitle> The Netherlands 1989, </booktitle> <pages> pages 777-560, </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: They also occur in the work of Jonsson [13] under the name subset simulations, and are related to the failure simulations of Gerth <ref> [5] </ref>. Forward-backward simulations combine in a single relation both a forward and a backward simulation. Below we present simple proofs of their soundness and completeness by making this connection explicit.
Reference: [6] <author> A. Ginzburg. </author> <title> Algebraic Theory of Automata. </title> <publisher> Academic Press, </publisher> <address> New York - London, </address> <year> 1968. </year>
Reference-contexts: The simplest kind of simulation we consider is a refinement, which is a functional simulation similar to those studied in [17] and very similar to a homomorphism between automata in the sense of classical automata theory <ref> [6] </ref>. <p> If s 0 a ! A s then r (s 0 ) ^a =) B r (s). We write A R B if there exists a refinement from A to B. This notion is similar to that of a homomorphism in classical automata theory; see for instance Ginzberg <ref> [6] </ref>. Besides our additional treatment of internal actions, a difference between the two notions is that the classical notion involves a mapping between the action sets of the automata, whereas our refinements do not.
Reference: [7] <author> J.F. Groote. </author> <title> Specification and Verification of Real Time Systems in ACP. </title> <type> Report CS-R9015, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <year> 1990. </year> <note> An extended abstract appeared in L. </note> <editor> Logrippo, R.L. Probert and H. Ural, editors, </editor> <booktitle> Proceedings 10 th International Symposium on Protocol Specification, Testing and Verification, Ottawa, </booktitle> <pages> pages 261-274, </pages> <year> 1990. </year>
Reference-contexts: As in many other formalisms for real-time, see for instance <ref> [2, 3, 7, 22, 24, 25, 32] </ref>, all actions except for the time-passage actions are modeled as occurring instantaneously, i.e., they do not change the time component of the state. <p> To specify times, we use a dense time domain, specifically, the nonnegative reals (starting with time 0 in the initial state), and we impose no lower bound on the time between events. This choice distinguishes our work from many others', e.g., <ref> [4, 7, 24, 25, 29, 33] </ref>, in which discrete time values or universal positive lower bounds on step time are used. Use of real-valued time is less restrictive, and we believe that the extra flexibility will be useful in the design and analysis of timing-based distributed algorithms.
Reference: [8] <author> J. </author> <title> He. Process simulation and refinement. </title> <journal> Journal of Formal Aspects of Computing Science, </journal> <volume> 1 </volume> <pages> 229-241, </pages> <year> 1989. </year>
Reference-contexts: We then consider forward simulations and backward simulations, which are generalizations of refinements that allow a set of states of B to correspond to a single state of A. Forward simulations are similar to the the simulations of [28, 10], the possibilities mappings of [20], the downward simulations of <ref> [9, 14, 8] </ref>, and the forward simulations of [13]. <p> Backward simulations occurred first in [9] under the name of upward simulations and were used later in the setting of CSP in <ref> [14, 8] </ref>. In [21, 12] it is observed that they are closely related to the prophecy variables first defined in [1]. <p> a backward simulation from G to H, but even though H is deterministic there is no image-finite backward simulation. ? q q * fi ? G 6 iB 4.2.3 Combined Forward and Backward Simulations Several authors have observed that forward and backward simulations together give a complete proof method (see <ref> [9, 8, 14, 12] </ref>): if A flT B then there exists an intermediate automaton C with a forward simulation from A to C and a backward simulation from C to B. We prove this below.
Reference: [9] <author> C.A.R. Hoare, J. He, and J.W. Sanders. </author> <title> Prespecification in data refinement. </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <pages> 71-76, </pages> <year> 1987. </year>
Reference-contexts: We then consider forward simulations and backward simulations, which are generalizations of refinements that allow a set of states of B to correspond to a single state of A. Forward simulations are similar to the the simulations of [28, 10], the possibilities mappings of [20], the downward simulations of <ref> [9, 14, 8] </ref>, and the forward simulations of [13]. <p> The usefulness of such simulations in proving correctness in the untimed setting has been well demonstrated. (See, e.g., [18] for some examples.) Again, we give soundness and partial completeness results for the timed setting. Backward simulations occurred first in <ref> [9] </ref> under the name of upward simulations and were used later in the setting of CSP in [14, 8]. In [21, 12] it is observed that they are closely related to the prophecy variables first defined in [1]. <p> a backward simulation from G to H, but even though H is deterministic there is no image-finite backward simulation. ? q q * fi ? G 6 iB 4.2.3 Combined Forward and Backward Simulations Several authors have observed that forward and backward simulations together give a complete proof method (see <ref> [9, 8, 14, 12] </ref>): if A flT B then there exists an intermediate automaton C with a forward simulation from A to C and a backward simulation from C to B. We prove this below.
Reference: [10] <author> B. Jonsson. </author> <title> Compositional Verification of Distributed Systems. </title> <type> PhD thesis, </type> <institution> Department of Computer Systems, Uppsala University, </institution> <year> 1987. </year> <note> DoCS 87/09. </note>
Reference-contexts: We then consider forward simulations and backward simulations, which are generalizations of refinements that allow a set of states of B to correspond to a single state of A. Forward simulations are similar to the the simulations of <ref> [28, 10] </ref>, the possibilities mappings of [20], the downward simulations of [9, 14, 8], and the forward simulations of [13].
Reference: [11] <author> B. Jonsson. </author> <title> Modular verification of asynchronous networks. </title> <booktitle> In Proceedings of the 6 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Vancouver, Canada, </address> <pages> pages 152-166, </pages> <year> 1987. </year>
Reference-contexts: For transitivity, use Lemma 4.6 to show that if f and f 0 are forward simulations from A to B and from B to C, respectively, f 0 ffi f is a forward simulation from A to C. Theorem 4.8 (Soundness of forward simulations, <ref> [20, 11, 30] </ref>) A F B ) A T B. Proof: Versions of this proof appears in the cited papers. The proof is similar to that of Theorem 4.3. Theorem 4.9 (Partial completeness of forward simulations) Suppose B is deterministic and A flT B. Then A F B.
Reference: [12] <author> B. Jonsson. </author> <title> On decomposing and refining specifications of distributed systems. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> REX Workshop on Stepwise Refinement of Distributed Systems: Models, Formalism, Correctness, Mook, </title> <booktitle> The Netherlands 1989, </booktitle> <pages> pages 361-387, </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Backward simulations occurred first in [9] under the name of upward simulations and were used later in the setting of CSP in [14, 8]. In <ref> [21, 12] </ref> it is observed that they are closely related to the prophecy variables first defined in [1]. <p> We do not explore this extension in this paper, primarily because it lacks a key feature of simulation techniques. Namely, it fails to reduce global reasoning about infinite behaviors to local reasoning about states and actions. The following partial completeness result slightly generalizes a similar result of Jonsson <ref> [12] </ref> in that it also alllows for t -steps in the B automaton. Theorem 4.14 (Partial completeness of backward simulations) Suppose A is a forest and A flT B. Then 1. A B B, and 2. if B has fin then A iB B. <p> a backward simulation from G to H, but even though H is deterministic there is no image-finite backward simulation. ? q q * fi ? G 6 iB 4.2.3 Combined Forward and Backward Simulations Several authors have observed that forward and backward simulations together give a complete proof method (see <ref> [9, 8, 14, 12] </ref>): if A flT B then there exists an intermediate automaton C with a forward simulation from A to C and a backward simulation from C to B. We prove this below.
Reference: [13] <author> B. Jonsson. </author> <title> Simulations between specifications of distributed systems. </title> <editor> In J.C.M. Baeten and J.F. Groote, editors, </editor> <booktitle> Proceedings CONCUR 91, Amsterdam, </booktitle> <pages> pages 346-360, </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Forward simulations are similar to the the simulations of [28, 10], the possibilities mappings of [20], the downward simulations of [9, 14, 8], and the forward simulations of <ref> [13] </ref>. <p> An advantage of this two-phase approach is that it highlights the adaptability of the various verification techniques from the untimed to the timed setting. As far as the classification of simulations is concerned, our work is closely related to and extends that of Jonsson <ref> [13] </ref>. However, whereas we focus on real-time issues, Jonsson addresses fairness instead. Also, Jonsson has more powerful notion of backward simulation, which we prefer not to use since it fails to reduce global reasoning about infinite behaviors to local reasoning about states and actions. <p> This corresponds directly to an execution ff 0 of B having trace (ff 0 ) = trace (ff) = fi. Hence, fi 2 traces (B). In a recent paper, Jonsson <ref> [13] </ref> considers a weaker image-finiteness condition for backward simulations. <p> If B has fin then C iB B follows by Theorem 4.14 (2). 4.3 Forward-Backward and Backward-Forward Simulations 4.3.1 Forward-Backward Simulations Forward-backward simulations were introduced by Klarlund and Schneider [15] who call them invariants. They also occur in the work of Jonsson <ref> [13] </ref> under the name subset simulations, and are related to the failure simulations of Gerth [5]. Forward-backward simulations combine in a single relation both a forward and a backward simulation. Below we present simple proofs of their soundness and completeness by making this connection explicit.
Reference: [14] <author> M.B. Josephs. </author> <title> A state-based approach to communicating processes. </title> <journal> Distributed Computing, </journal> <volume> 3 </volume> <pages> 9-18, </pages> <year> 1988. </year>
Reference-contexts: We then consider forward simulations and backward simulations, which are generalizations of refinements that allow a set of states of B to correspond to a single state of A. Forward simulations are similar to the the simulations of [28, 10], the possibilities mappings of [20], the downward simulations of <ref> [9, 14, 8] </ref>, and the forward simulations of [13]. <p> Backward simulations occurred first in [9] under the name of upward simulations and were used later in the setting of CSP in <ref> [14, 8] </ref>. In [21, 12] it is observed that they are closely related to the prophecy variables first defined in [1]. <p> a backward simulation from G to H, but even though H is deterministic there is no image-finite backward simulation. ? q q * fi ? G 6 iB 4.2.3 Combined Forward and Backward Simulations Several authors have observed that forward and backward simulations together give a complete proof method (see <ref> [9, 8, 14, 12] </ref>): if A flT B then there exists an intermediate automaton C with a forward simulation from A to C and a backward simulation from C to B. We prove this below.
Reference: [15] <author> N. Klarlund and F.B. Schneider. </author> <title> Verifying Safety Properties Using Infinite-state Automata. </title> <type> Technical Report 89-1039, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <year> 1989. </year>
Reference-contexts: We also consider forward-backward and backward-forward simulations, which are essentially compositions of one forward and one backward simulation, in the two possible orders. The definition of a forward-backward simulation has been inspired by the work of Klarlund and Schneider <ref> [15] </ref> for the untimed setting (with no internal actions) again, we extend these ideas to the timed setting (with internal actions). The notion of a backward-forward simulation is suggested by symmetry with forward-backward simulations. <p> If B has fin then C iB B follows by Theorem 4.14 (2). 4.3 Forward-Backward and Backward-Forward Simulations 4.3.1 Forward-Backward Simulations Forward-backward simulations were introduced by Klarlund and Schneider <ref> [15] </ref> who call them invariants. They also occur in the work of Jonsson [13] under the name subset simulations, and are related to the failure simulations of Gerth [5]. Forward-backward simulations combine in a single relation both a forward and a backward simulation. <p> Finally, it is immediate from the definitions that, if g and g 0 are image-2 finite, g 0 * g is also image-2-finite. Proposition 4.21 FB and iFB are preorders. Proof: By Lemma 4.20. Theorem 4.22 (Soundness of forward-backward simulations, <ref> [15] </ref>) 1. A FB B ) A flT B, and Proof: For part 1, suppose A FB B. By Theorem 4.19, there exists an automaton C with A F C B B. <p> By soundness of forward simulations, Theorem 4.8, A T C, and by soundness of backward simulations, Theorem 4.13, C flT B. This implies A flT B. Part 2 is similar. Theorem 4.23 (Completeness of forward-backward simulations, <ref> [15] </ref>) Suppose A flT B. Then 1. A FB B. 2. If B has fin then A iFB B. Proof: By Theorem 4.16, there exists an automaton C with A F C B B. Moreover, if B has fin then A F C iB B.
Reference: [16] <author> D.E. Knuth. </author> <title> Fundamental Algorithms. </title> <booktitle> Volume 1 of The Art of Computer Programming, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1973. </year> <note> Second edition. </note>
Reference-contexts: If f is a relation over X and P (Y ), then we say that f is image-2-finite if every set in the range of f is finite. 2.3 A Basic Graph Lemma We require the following lemma, a generalization of Konig's Lemma <ref> [16] </ref>. If G is a digraph, then a root of G is defined to be a node with no incoming edges. Lemma 2.1 Let G be an infinite digraph that satisfies the following properties. 1. G has finitely many roots. 2. Each node of G has finite outdegree. 3.
Reference: [17] <author> L. Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 190-222, </pages> <year> 1983. </year>
Reference-contexts: The simulations we consider are derived from simulations studied in many places in the research literature. The simplest kind of simulation we consider is a refinement, which is a functional simulation similar to those studied in <ref> [17] </ref> and very similar to a homomorphism between automata in the sense of classical automata theory [6].
Reference: [18] <author> N.A. Lynch. </author> <title> Multivalued possibilities mappings. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> REX Workshop on Stepwise Refinement of Distributed Systems: Models, Formalism, Correctness, Mook, </title> <booktitle> The Netherlands 1989, </booktitle> <pages> pages 519-543, </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The usefulness of such simulations in proving correctness in the untimed setting has been well demonstrated. (See, e.g., <ref> [18] </ref> for some examples.) Again, we give soundness and partial completeness results for the timed setting. Backward simulations occurred first in [9] under the name of upward simulations and were used later in the setting of CSP in [14, 8].
Reference: [19] <author> N.A. Lynch and H. Attiya. </author> <title> Using mappings to prove timing properties. </title> <booktitle> In Proceedings of the 9 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Quebec, Canada, </address> <month> August </month> <year> 1990. </year> <note> Expanded version: Technical Memo MIT/LCS/TM-412.c, </note> <institution> Laboratory for Computer Science, MIT, </institution> <month> March </month> <year> 1991. </year> <note> Submitted for publication. </note>
Reference-contexts: We prove theorems describing the properties of these various kinds of simulations and relating the different kinds of simulations to each other. The goal of extending simulation techniques to timing-based systems is also the motivation for the work of Lynch and Attiya in <ref> [19] </ref>. That work, however, only explores forward simulations. Also, the model used in [19] has considerably more structure than the very general model proposed here; it is based closely on the timed automaton model of Merritt, Modugno and Tuttle [22], which assumes that the system being modeled is describable in terms <p> The goal of extending simulation techniques to timing-based systems is also the motivation for the work of Lynch and Attiya in <ref> [19] </ref>. That work, however, only explores forward simulations. Also, the model used in [19] has considerably more structure than the very general model proposed here; it is based closely on the timed automaton model of Merritt, Modugno and Tuttle [22], which assumes that the system being modeled is describable in terms of a collection of separate tasks, each with associated upper and lower bounds <p> This extra structure supports the development of some useful progress measure proof methods, which we do not develop here. On the other hand, the basic theorems about forward simulations that appear in <ref> [19] </ref> are stated in a setting that has more structure than is really necessary for those theorems. In this paper, we make only those assumptions that are needed for the basic results about simulation proof techniques. <p> One of the main objectives of this paper is to develop proof techniques to show that one automaton implements another in this sense. Even though our notion of timed automata has less structure than those of [22] and <ref> [19] </ref>, it is closely related to those models. Ours can be regarded as a generalization of the model in [19], in which the notion of separate tasks is removed. (There are some minor distinctions; for instance, we do not include names for internal actions, but label them all by the special <p> Even though our notion of timed automata has less structure than those of [22] and <ref> [19] </ref>, it is closely related to those models. Ours can be regarded as a generalization of the model in [19], in which the notion of separate tasks is removed. (There are some minor distinctions; for instance, we do not include names for internal actions, but label them all by the special symbol t . <p> This will involve applying the simulation techniques to a wide range of examples. It may also involve development of techniques analogous to the progress measure techniques in <ref> [19] </ref>, based on extra structure to be added to our timed automaton model. Finally, it remains to carry out process algebraic work using the same timed automaton model.
Reference: [20] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the 6 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Vancouver, Canada, </address> <pages> pages 137-151, </pages> <month> August </month> <year> 1987. </year> <note> A full version is available as MIT Technical Report MIT/LCS/TR-387. </note>
Reference-contexts: This distinction is unimportant in a setting without separate tasks.) On the other hand, the model of [22] includes treatment of fairness and liveness, whereas our model does not. (The model in [22] was originally designed as an extension of the non-timing-based input/output automaton model of <ref> [20] </ref>, which emphasizes the notion of fair execution.) The reason we have not equipped our model with facilities for handling fairness and liveness is that we believe that in the setting of timing-based systems, all properties of practical importance can be expressed as safety properties, given the admissibility assumption that time <p> We then consider forward simulations and backward simulations, which are generalizations of refinements that allow a set of states of B to correspond to a single state of A. Forward simulations are similar to the the simulations of [28, 10], the possibilities mappings of <ref> [20] </ref>, the downward simulations of [9, 14, 8], and the forward simulations of [13]. <p> For transitivity, use Lemma 4.6 to show that if f and f 0 are forward simulations from A to B and from B to C, respectively, f 0 ffi f is a forward simulation from A to C. Theorem 4.8 (Soundness of forward simulations, <ref> [20, 11, 30] </ref>) A F B ) A T B. Proof: Versions of this proof appears in the cited papers. The proof is similar to that of Theorem 4.3. Theorem 4.9 (Partial completeness of forward simulations) Suppose B is deterministic and A flT B. Then A F B.
Reference: [21] <author> M. Merritt. </author> <title> Completeness theorems for automata. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> REX Workshop on Stepwise Refinement of Distributed Systems: Models, Formalism, Correctness, Mook, </title> <booktitle> The Netherlands 1989, </booktitle> <pages> pages 544-560, </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Backward simulations occurred first in [9] under the name of upward simulations and were used later in the setting of CSP in [14, 8]. In <ref> [21, 12] </ref> it is observed that they are closely related to the prophecy variables first defined in [1]. <p> A considerable amount of further work remains to be done. First, there is a technical issue. Some of the other work on simulations (e.g., <ref> [21] </ref>) includes reachability restrictions in the step correspondence conditions; we would like theorems justifying the soundness of those simulations in terms of the soundness of our simulations (without reachability hypotheses).
Reference: [22] <author> M. Merritt, F. Modugno, and M. Tuttle. </author> <title> Time constrained automata. </title> <editor> In J.C.M. Baeten and J.F. Groote, editors, </editor> <booktitle> Proceedings CONCUR 91, Amsterdam, </booktitle> <pages> pages 408-423, </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: That work, however, only explores forward simulations. Also, the model used in [19] has considerably more structure than the very general model proposed here; it is based closely on the timed automaton model of Merritt, Modugno and Tuttle <ref> [22] </ref>, which assumes that the system being modeled is describable in terms of a collection of separate tasks, each with associated upper and lower bounds on its speed. This extra structure supports the development of some useful progress measure proof methods, which we do not develop here. <p> As in many other formalisms for real-time, see for instance <ref> [2, 3, 7, 22, 24, 25, 32] </ref>, all actions except for the time-passage actions are modeled as occurring instantaneously, i.e., they do not change the time component of the state. <p> One of the main objectives of this paper is to develop proof techniques to show that one automaton implements another in this sense. Even though our notion of timed automata has less structure than those of <ref> [22] </ref> and [19], it is closely related to those models. <p> This distinction is unimportant in a setting without separate tasks.) On the other hand, the model of <ref> [22] </ref> includes treatment of fairness and liveness, whereas our model does not. (The model in [22] was originally designed as an extension of the non-timing-based input/output automaton model of [20], which emphasizes the notion of fair execution.) The reason we have not equipped our model with facilities for handling fairness and <p> This distinction is unimportant in a setting without separate tasks.) On the other hand, the model of <ref> [22] </ref> includes treatment of fairness and liveness, whereas our model does not. (The model in [22] was originally designed as an extension of the non-timing-based input/output automaton model of [20], which emphasizes the notion of fair execution.) The reason we have not equipped our model with facilities for handling fairness and liveness is that we believe that in the setting of timing-based systems, all properties of
Reference: [23] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, </address> <year> 1989. </year>
Reference-contexts: Theorem 4.34 (Soundness of history relations) A H B ) A T B. Proof: Immediate from the soundness of refinements and forward simulations. In fact, a history relation from A to B is just a functional bisimulation between A and B in the sense of Park [28] and Milner <ref> [23] </ref>. This implies that if there exists a history relation from A to B, both automata are bisimulation equivalent. Hence, history relations preserve the behavior of automata in a very strong sense. <p> This reduction solves our problem, in a sense, since it allows us to use the various simulation techniques in Section 4 to prove inclusion results for timed automata. The approach is analogous to that followed for Milner's CCS <ref> [23] </ref> where the problem of deciding weak observation equivalence is reduced to the problem of deciding strong bisimulation.
Reference: [24] <author> F. Moller and C. Tofts. </author> <title> A temporal calculus of communicating systems. </title> <editor> In J.C.M. Baeten and J.W. Klop, editors, </editor> <booktitle> Proceedings CONCUR 90, Amsterdam, </booktitle> <pages> pages 401-415, </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: As in many other formalisms for real-time, see for instance <ref> [2, 3, 7, 22, 24, 25, 32] </ref>, all actions except for the time-passage actions are modeled as occurring instantaneously, i.e., they do not change the time component of the state. <p> To specify times, we use a dense time domain, specifically, the nonnegative reals (starting with time 0 in the initial state), and we impose no lower bound on the time between events. This choice distinguishes our work from many others', e.g., <ref> [4, 7, 24, 25, 29, 33] </ref>, in which discrete time values or universal positive lower bounds on step time are used. Use of real-valued time is less restrictive, and we believe that the extra flexibility will be useful in the design and analysis of timing-based distributed algorithms.
Reference: [25] <author> X. Nicollin, J.-L. Richier, J. Sifakis, and J. Voiron. </author> <title> ATP: an algebra for timed processes. </title> <editor> In M. Broy and C.B. Jones, editors, </editor> <booktitle> Proceedings IFIP TC2 Working Conference on Programming Concepts and Methods, Sea of Gallilea, Israel, </booktitle> <pages> pages 402-429, </pages> <year> 1990. </year>
Reference-contexts: As in many other formalisms for real-time, see for instance <ref> [2, 3, 7, 22, 24, 25, 32] </ref>, all actions except for the time-passage actions are modeled as occurring instantaneously, i.e., they do not change the time component of the state. <p> To specify times, we use a dense time domain, specifically, the nonnegative reals (starting with time 0 in the initial state), and we impose no lower bound on the time between events. This choice distinguishes our work from many others', e.g., <ref> [4, 7, 24, 25, 29, 33] </ref>, in which discrete time values or universal positive lower bounds on step time are used. Use of real-valued time is less restrictive, and we believe that the extra flexibility will be useful in the design and analysis of timing-based distributed algorithms.
Reference: [26] <author> X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> From ATP to timed graphs and hybrid systems. </title> <booktitle> 1991. This volume. </booktitle>
Reference-contexts: Also, time can advance by a particular amount in one time-passage step if and only if it can also advance by the same amount in two steps. (This property is called continuity in [32] and, more appropriately, time additivity in <ref> [26] </ref>.) We attempt to use as few axioms as possible to obtain the results about simulations. Later, as we try to express different proof methods in terms of this model, we expect to have to add additional requirements to obtain the desired properties. <p> Later, as we try to express different proof methods in terms of this model, we expect to have to add additional requirements to obtain the desired properties. A typical axiom we may have to add at some point is the axiom of time determinism <ref> [32, 26] </ref>, which says that if from a given state s there are time-passage actions leading to states s 0 and s 00 , which both have the same time, s 0 and s 00 must be equal.
Reference: [27] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs. </title> <journal> Acta Informatica, </journal> <volume> 6(4) </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: The notion of a backward-forward simulation is suggested by symmetry with forward-backward simulations. While some of the results for this case are symmetric with the forward-backward case, others (notably, certain completeness results) do not hold. We also provide redefinitions of the history variable notion of <ref> [27] </ref> and the prophecy variable notions of [1], in terms of timed automata, and prove equivalence results between these explicit definitions and our more abstract simulation definitions. In order to present our results for timed automata, we find it convenient first to describe corresponding results for the simpler untimed setting.
Reference: [28] <author> D.M.R. Park. </author> <title> Concurrency and automata on infinite sequences. </title> <editor> In P. Deussen, editor, </editor> <booktitle> 5 th GI Conference, </booktitle> <pages> pages 167-183, </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: We then consider forward simulations and backward simulations, which are generalizations of refinements that allow a set of states of B to correspond to a single state of A. Forward simulations are similar to the the simulations of <ref> [28, 10] </ref>, the possibilities mappings of [20], the downward simulations of [9, 14, 8], and the forward simulations of [13]. <p> Theorem 4.34 (Soundness of history relations) A H B ) A T B. Proof: Immediate from the soundness of refinements and forward simulations. In fact, a history relation from A to B is just a functional bisimulation between A and B in the sense of Park <ref> [28] </ref> and Milner [23]. This implies that if there exists a history relation from A to B, both automata are bisimulation equivalent. Hence, history relations preserve the behavior of automata in a very strong sense.
Reference: [29] <author> G.M. Reed and A.W. Roscoe. </author> <title> A timed model for communicating sequential processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 58 </volume> <pages> 249-261, </pages> <year> 1988. </year>
Reference-contexts: To specify times, we use a dense time domain, specifically, the nonnegative reals (starting with time 0 in the initial state), and we impose no lower bound on the time between events. This choice distinguishes our work from many others', e.g., <ref> [4, 7, 24, 25, 29, 33] </ref>, in which discrete time values or universal positive lower bounds on step time are used. Use of real-valued time is less restrictive, and we believe that the extra flexibility will be useful in the design and analysis of timing-based distributed algorithms. <p> Zeno executions arise due to the inability of automaton models to deal with an infinite amount of activity within a bounded period of time. Some models of real-time computation, for instance the model of real-time CSP <ref> [29] </ref>, exclude Zeno executions altogether. As a result of our attempt to make our results as general as possible, our model does allow for both time deadlocks and Zeno executions. However, in several of our theorems we will require that the automata be feasible.
Reference: [30] <author> E. W. Stark. </author> <title> Proving entailment between conceptual state specifications. </title> <journal> Theoretical Computer Science, </journal> <volume> 56 </volume> <pages> 135-154, </pages> <year> 1988. </year>
Reference-contexts: For transitivity, use Lemma 4.6 to show that if f and f 0 are forward simulations from A to B and from B to C, respectively, f 0 ffi f is a forward simulation from A to C. Theorem 4.8 (Soundness of forward simulations, <ref> [20, 11, 30] </ref>) A F B ) A T B. Proof: Versions of this proof appears in the cited papers. The proof is similar to that of Theorem 4.3. Theorem 4.9 (Partial completeness of forward simulations) Suppose B is deterministic and A flT B. Then A F B.
Reference: [31] <author> F.W. Vaandrager and N.A. Lynch. </author> <title> Process algebras for timed automata. </title> <note> 1991. In preparation. </note>
Reference-contexts: It may also involve development of techniques analogous to the progress measure techniques in [19], based on extra structure to be added to our timed automaton model. Finally, it remains to carry out process algebraic work using the same timed automaton model. A paper in progress <ref> [31] </ref> contains the beginning of such work, including definitions of interesting operators on timed automata, and proofs of substitutivity results for the timed trace semantics. However, much remains to be done.
Reference: [32] <author> Wang Yi. </author> <title> Real-time behaviour of asynchronous agents. </title> <editor> In J.C.M. Baeten and J.W. Klop, editors, </editor> <booktitle> Proceedings CONCUR 90, Amsterdam, </booktitle> <pages> pages 502-520, </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: As in many other formalisms for real-time, see for instance <ref> [2, 3, 7, 22, 24, 25, 32] </ref>, all actions except for the time-passage actions are modeled as occurring instantaneously, i.e., they do not change the time component of the state. <p> Also, time can advance by a particular amount in one time-passage step if and only if it can also advance by the same amount in two steps. (This property is called continuity in <ref> [32] </ref> and, more appropriately, time additivity in [26].) We attempt to use as few axioms as possible to obtain the results about simulations. Later, as we try to express different proof methods in terms of this model, we expect to have to add additional requirements to obtain the desired properties. <p> Later, as we try to express different proof methods in terms of this model, we expect to have to add additional requirements to obtain the desired properties. A typical axiom we may have to add at some point is the axiom of time determinism <ref> [32, 26] </ref>, which says that if from a given state s there are time-passage actions leading to states s 0 and s 00 , which both have the same time, s 0 and s 00 must be equal.
Reference: [33] <author> A. Zwarico. </author> <title> Timed Acceptance: An Algebra of Time Dependent Computing. </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <year> 1988. </year>
Reference-contexts: To specify times, we use a dense time domain, specifically, the nonnegative reals (starting with time 0 in the initial state), and we impose no lower bound on the time between events. This choice distinguishes our work from many others', e.g., <ref> [4, 7, 24, 25, 29, 33] </ref>, in which discrete time values or universal positive lower bounds on step time are used. Use of real-valued time is less restrictive, and we believe that the extra flexibility will be useful in the design and analysis of timing-based distributed algorithms.
References-found: 33

