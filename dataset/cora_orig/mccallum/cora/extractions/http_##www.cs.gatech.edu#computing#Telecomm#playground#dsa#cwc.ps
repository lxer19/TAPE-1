URL: http://www.cs.gatech.edu/computing/Telecomm/playground/dsa/cwc.ps
Refering-URL: http://www.cs.gatech.edu/computing/Telecomm/playground/dsa/index.html
Root-URL: 
Email: clayton@cc.gatech.edu calvert@cc.gatech.edu  
Phone: voice: 404 853 9913 voice: 404 894 9107 fax: 404 894 0272  
Title: A Data-Stream Language for Protocols  
Author: R. Clayton K. Calvert 
Date: 31 October 1995  
Address: Atlanta, Georgia 30332-0280  
Affiliation: Networking and Telecommunications Group, College of Computing Georgia Institute of Technology,  
Abstract: The trade-off between protocol structure and protocol performance is usually treated as a balancing act, with improvements on one side coming at the expense of the other side. The project described in this paper treats the structure/ performance trade-off as an obstacle and eliminates it with a combination of structuring and compilation techniques. The structuring techniques are based on data-stream computations and give the protocol developer a convenient way of arranging and implementing protocol function. The compilation techniques remove the inefficiencies introduced by the structuring techniques and further tailor the code to the host system, providing a high performance implementation. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Abbott, M. B. and L. L. Peterson (1992, </author> <month> August). </month> <title> A language-based approach to protocol implementation. </title> <booktitle> Computer Communications Review (SIGCOMM '92 Proceedings) 23 (4), </booktitle> <pages> 27-38. </pages>
Reference-contexts: Object-oriented structuring mechanisms, however, are generally antithetical to convenient, compile-time optimizations and are expensive at execution time, although some work is being done on the second problem (Schmidt, Harri-son, and Al-Shaer 1995). Morpheus <ref> (Abbott and Peterson 1992) </ref> is an interesting approach to object-oriented protocol development. Recognizing the inefficiency of general object-oriented mechanisms, Morpheus tailors its objects to allow for compilation into efficient code. It is unclear how far into implementation Morpheus has been carried.
Reference: <author> Aho, A. V., R. Sethi, and J. D. </author> <title> Ullman (1986). </title> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <address> Reading, Mass.: </address> <publisher> Addison-Wesley. </publisher>
Reference-contexts: At that point it transfers control back to the scheduler, which is responsible for picking the next co-routine to resume. The scheduler also detects termination, either normally or through deadlock. The compiler uses standard issue technology <ref> (Aho, Sethi, and Ullman 1986) </ref>, and consists of a front-end and a back end. The compiler front-end is written using lex and yacc. Within the compiler programs are represented as abstract syntax trees in which the nodes are instances of C ++ classes.
Reference: <author> Calvert, K. L. </author> <year> (1993, </year> <month> 19-22 October). </month> <title> Beyond layering: Modularity considerations for protocol architectures. </title> <booktitle> In International Conference on Network Protocols, </booktitle> <address> San Francisco, Calif., </address> <pages> pp. 90-97. </pages> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: This work is being carried out independent of a particular protocol subsystem. However, to provide a realistic context for exercising and evaluating stream functions, we are incorporating the language and compiler into the tau (transport and above) project <ref> (Calvert 1993) </ref>. 3 The Language This section presents features of the data-stream language by describing a stream function implementing run-length encoding (rle). This implementation of run-length encoding is expository, not exemplary. The first two statements in figure 1 define the structure of the input and output streams.
Reference: <author> Clark, D. D. and D. L. </author> <month> Tennenhouse </month> <year> (1990, </year> <month> 24-27 September). </month> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In SIGCOMM '90 Symposium on Communication Architectures and Protocols, Philadelphia, Penn., </booktitle> <pages> pp. 200-208. </pages> <publisher> ACM Press. </publisher>
Reference-contexts: Loop fusion: do f (data) write n bytes od read n bytes g (data) . . . ! . . . f (data) g (data) . . . 5 Discussion 5.1 ILP and ALF Current thinking on protocol software seems dominated by integrated layer processing (ILP) and application-level framing (ALF) <ref> (Clark and Tennenhouse 1990) </ref>. Integrated layer processing revises the notion that monolithic architectures are good for performance and makes it appropriate for protocol software.
Reference: <author> Cooper, E., R. Harper, and P. Lee (1991, </author> <month> August). </month> <title> The Fox project: Advanced development of systems software. </title> <type> Technical Report CMU-CS-91-178, </type> <institution> School of Computer Science, Carnegie Mellon University, Pittsburgh, Penn. </institution>
Reference-contexts: Recognizing the inefficiency of general object-oriented mechanisms, Morpheus tailors its objects to allow for compilation into efficient code. It is unclear how far into implementation Morpheus has been carried. Functional computation is another possible architecture, one taken up by the Fox Project <ref> (Cooper, Harper, and Lee 1991) </ref>, which is applying the programming language Standard ML (SML) to systems software. Adopting a powerful language such as SML to the wide-ranging tasks required by system software requires more resources than we had to spend, even if we restricted attention to just protocol software.
Reference: <author> Hutchinson, N. C. and L. L. </author> <title> Peterson (1991, Jan-uary). The x -kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering 17 (1), </journal> <pages> 64-75. </pages>
Reference-contexts: For example, the x-kernel <ref> (Hutchinson and Peterson 1991) </ref> has established an effective balance by providing a quasi-object-oriented architecture for protocol software while implementing efficient inter-layer communication through subroutine calls.
Reference: <author> Lavender, R. G., D. G. Kafura, and C. J. </author> <title> Tomlinson (1992, March). Implementing communication protocols using object-oriented techniques. </title> <type> Technical Report Carnot-060-92, </type> <institution> Microelectronics and Computer Technology Corp., Austin, Texas. </institution>
Reference: <author> Nakata, I. and M. </author> <month> Sassa </month> <year> (1983, </year> <month> 18 January). </month> <title> Programming with streams. </title> <type> Technical Report RJ 3751, </type> <institution> IBM Research Laboratory, </institution> <address> San Jose, Cal-ifornia. </address>
Reference-contexts: The return value is a pointer to the byte immediately following the last byte written in dst. 4 The Compiler The general compilation technique is to translate a data-stream program into a set of co-routines and a scheduler <ref> (Nakata and Sassa 1983) </ref>. Each stream function is translated into a co-routine, and adjacent stream functions in a pipeline share a fixed-length buffer. Each co-routine executes until it's blocked by either an empty buffer on input or a full buffer on output.
Reference: <author> Ritchie, D. M. </author> <year> (1984, </year> <month> October). </month> <title> A stream input-output system. </title> <journal> AT&T Bell Laboratories Technical Journal 63 (8), </journal> <pages> 311-324. </pages>
Reference-contexts: Data stream architectures have also been applied to protocols; the most notable example is the Unix Streams subsystem <ref> (Ritchie 1984) </ref>. However, the relation between Streams and data streams exists mostly in name only: Streams programmers deal with queues of pointers to buffers, and there is no Streams-specific optimization applied either within or between modules.
Reference: <author> Schmidt, D., T. Harrison, and E. </author> <month> Al-Shaer </month> <year> (1995, </year> <month> 26-29 June). </month> <title> Object-oriented programming for high-speed network programming. </title> <booktitle> In USENIX Conference on Object-Oriented Technologies, </booktitle> <address> Monterey, California. </address>
Reference-contexts: Of course, object-oriented architectures have attracted attention (Lavender, Kafura, and Tom-linson 1992; Schmidt, Box, and Suda 1993). Object-oriented structuring mechanisms, however, are generally antithetical to convenient, compile-time optimizations and are expensive at execution time, although some work is being done on the second problem <ref> (Schmidt, Harri-son, and Al-Shaer 1995) </ref>. Morpheus (Abbott and Peterson 1992) is an interesting approach to object-oriented protocol development. Recognizing the inefficiency of general object-oriented mechanisms, Morpheus tailors its objects to allow for compilation into efficient code. It is unclear how far into implementation Morpheus has been carried.
Reference: <author> Schmidt, D. C., D. F. Box, and T. </author> <month> Suda </month> <year> (1993, </year> <month> June). </month> <title> ADAPTIVE: A dynamically assembled protocol transformation, integration, and evaluation environment. </title> <journal> Journal of Concurrency: Practice and Experience 5 (4), </journal> <pages> 269-286. </pages>
Reference: <author> Stallman, R. M. </author> <year> (1995, </year> <month> 14 June). </month> <title> Using and Porting GNU CC (ver. </title> <address> 2.7). Cambridge, Mass.: </address> <publisher> Free Software Foundation. </publisher>
Reference-contexts: The compiler has two back ends, each differing from the other in the type of code analysis done and the output produced. One back end | the high-level back end | does host-architecture independent analysis and produces Gnu extended ANSI C code <ref> (Stallman 1995) </ref>. The other, low-level back end does host-architecture specific analysis and produces assembly code. The high-level back end performs host-architecture independent optimizations such as code motion and loop fusion.
Reference: <author> Waters, R. C. </author> <year> (1991, </year> <month> January). </month> <title> Automatic transformation of series expressions into loops. </title> <booktitle> ACM Transactions on Programming Languages and Systems 13 (1), </booktitle> <pages> 52-98. </pages> <note> Ver. 1.5 Page 6 of 6 </note>
References-found: 13

