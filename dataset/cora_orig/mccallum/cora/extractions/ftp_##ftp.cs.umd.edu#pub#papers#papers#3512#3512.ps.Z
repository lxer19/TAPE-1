URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3512/3512.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: f kossmann j franklin g@cs.umd.edu  
Title: A Study of Query Execution Strategies for Client-Server Database Systems  
Author: Donald Kossmann Michael J. Franklin 
Address: College Park, MD 20742  
Affiliation: Department of Computer Science and UMIACS University of Maryland  
Pubnum: Technical Report CS-TR-3512 and UMIACS-TR-95-85  
Abstract: Query processing in a client-server database system raises the question of where to execute queries to minimize the communication costs and response time of a query, and to load-balance the system. This paper evaluates the two common query execution strategies, data shipping and query shipping, and a policy referred to as hybrid shipping. Data shipping determines that queries be executed at clients; query shipping determines that queries be executed at servers; and hybrid shipping provides the flexibility to execute queries at clients and servers. The experiments with a client-server model confirm that the query execution policy is critical for the performance of a system. Neither data nor query shipping are optimal in all situations, and the performance penalities can be substantial. Hybrid shipping at least matches the best performance of data and query shipping and shows better performance than both in many cases. The performance of hybrid shipping plans, however, is shown to be sensitive to changes in the state of the system (e.g., the load of machines and the contents of caches). Initial experiments indicate that an extended version of a 2-step optimization may be an effective strategy for adjusting plans according to the state of the system at runtime.
Abstract-found: 1
Intro-found: 1
Reference: [BDT83] <author> D. Bitton, D. J. DeWitt, and C. Turbyfil. </author> <title> Benchmarking database systems: A systematic approach. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <year> 1983. </year>
Reference-contexts: In our experiments, we have found that most of the effects reported in Section 5 also arise (albeit sometimes less dramatically) when using less complex queries such as the Wisconsin Benchmark <ref> [BDT83] </ref>.
Reference: [BGW + 81] <author> P. A. Bernstein, N. Goodman, E. Wong, C. Reeve, and J. B. Rothnie. </author> <title> Query processing in a system for distributed databases (sdd-1). </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 6(4), </volume> <month> December </month> <year> 1981. </year>
Reference-contexts: At that time, several prototype systems were developed such as: System R fl [WDH + 81], SDD-1 <ref> [BGW + 81] </ref>, and distributed INGRES [Sto85]. Typically, these systems focused on optimizing the cost of a query; in particular, much effort was made to minimize the communication cost since the systems were designed to run on slow networks. 6 Many of the concepts are still valid, today.
Reference: [Cat94] <author> R. G. G. Cattell. </author> <title> Object Database Standard. </title> <publisher> Morgan-Kaufmann Publ. Co., </publisher> <address> San Mateo, CA, USA, </address> <year> 1994. </year>
Reference-contexts: System builders have been approaching this perceived need in several ways. Vendors of relational systems are moving towards integrating object-oriented features into their systems (e.g., the emerging SQL3 standard [Kul94]), and vendors of object-oriented systems are adding more powerful query facilities <ref> [Cat94] </ref>. fl This work was partially supported by NSF Grant IRI-94-09575. Donald Kossmann was supported by the Humboldt-Stiftung. 1 Furthermore, a new class of hybrid "Object-Relational" systems has recently started to emerge (e.g., Illus--tra [Sto93], and UniSQL [Kim93]).
Reference: [CDF + 94] <author> M. J. Carey, D. J. DeWitt, M. J. Franklin, N. E. Hall, M. L. McAuliffe, J. F. Naughton, D. T. Schuh, M. H. Solomon, C. K. Tan, O. G. Tsatalos, S. J. White, and M. J. Zwilling. </author> <title> Shoring up persistent applications. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 383-394, </pages> <address> Minneapolis, MI, USA, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Like many other studies, they concentrated on a system with only one server, and therefore, could not realize the potential to execute the operators of a query on different sites in parallel. Examples of research prototypes that support multiple servers are Orion-2 [JWKL90], SHORE <ref> [CDF + 94] </ref> and Mariposa [SAD + 94, SDK + 94]. In these systems, the design of the execution policy plays an important role. In the current version, SHORE only uses data shipping.
Reference: [CL86] <author> M. Carey and H. Lu. </author> <title> Load balancing in a locally distributed database system. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 108-119, </pages> <address> Washington, USA, </address> <year> 1986. </year>
Reference-contexts: The main factor contributing to the performance degradation was seen to be the site selection, rather than the join ordering. This observation indicates that a 2-step optimization similar to that proposed by Carey and Lu <ref> [CL86] </ref> and similar to that used by XPRS [HS90] and Mariposa [SAD + 94] may be a good basis for generating query plans that can be modified dynamically prior to query execution in order to adapt to changes in the run-time environment. <p> This study, therefore, uses a client-server environment. In addition to cost, this study also analyzes the response time of queries, the parallel execution of operators of a query on different sites, and the load balancing of systems. Load balancing has also been investigated by Carey and Lu <ref> [CL86] </ref>; they propose an approach that exploits the replication of data on different sites.
Reference: [DFMV90] <author> D. J. DeWitt, P. Futtersack, D. Maier, and F. Velez. </author> <title> A study of three alternative workstation server architectures for object-oriented database systems. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 107-121, </pages> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: By now, many studies have been carried out investigating various aspects of client-server databases; e.g., <ref> [DFMV90, FC94] </ref>. Most of these studies, however, have been influenced by the dichotomy between relational and object-oriented systems and were carried out using either pure query shipping or pure data shipping.
Reference: [DG92] <author> D. DeWitt and J. Gray. </author> <title> Parallel database systems: The future of high performance database systems. </title> <journal> Communications of the ACM, </journal> <volume> 35(6) </volume> <pages> 85-98, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: This study also varies from the performance studies that have been carried out for the design of parallel database systems. Much of the emphasis in studying parallel database systems was to exploit intra-operator parallelism <ref> [DG92] </ref>.
Reference: [DR92] <author> A. Delis and N. Roussopoulos. </author> <title> Performance and scalability of client-server database architectures. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 610-623, </pages> <address> Vancouver, Canada, </address> <year> 1992. </year>
Reference-contexts: Most of these studies, however, have been influenced by the dichotomy between relational and object-oriented systems and were carried out using either pure query shipping or pure data shipping. A related study that analyzed the utilization of resources in client-server systems was carried out by Delis and Roussopoulos <ref> [DR92] </ref>. Like many other studies, they concentrated on a system with only one server, and therefore, could not realize the potential to execute the operators of a query on different sites in parallel.
Reference: [ESW78] <author> R. Epstein, M. Stonebraker, and E. Wong. </author> <title> Query processing in a distributed relational database system. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <year> 1978. </year>
Reference-contexts: that 2-step optimization is a potential approach towards addressing the need for dynamic query optimization in the client-server environment, significant additional work is required in order to develop practical and robust implementations of such an approach. 6 Related Work Distributed database systems were first investigated in the late seventies; e.g., <ref> [ESW78] </ref>. At that time, several prototype systems were developed such as: System R fl [WDH + 81], SDD-1 [BGW + 81], and distributed INGRES [Sto85].
Reference: [FC94] <author> M. Franklin and M. Carey. </author> <title> Client-server caching revisited. </title> <editor> In Ozsu et al. [ ODV94]. </editor> <booktitle> International Workshop on Distributed Object Management. </booktitle>
Reference-contexts: By now, many studies have been carried out investigating various aspects of client-server databases; e.g., <ref> [DFMV90, FC94] </ref>. Most of these studies, however, have been influenced by the dichotomy between relational and object-oriented systems and were carried out using either pure query shipping or pure data shipping.
Reference: [FCL93] <author> M. J. Franklin, M. J. Carey, and M. Livny. </author> <title> Local disk caching for client-server database systems. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 543-554, </pages> <address> Dublin, Ireland, </address> <year> 1993. </year>
Reference-contexts: A single client machine and between one and ten server machines are used in each experiment. Queries are submitted at the client machine, which has no primary copies of base relations. The client machine has a local disk which is used to cache data <ref> [FCL93] </ref> and as temporary storage during join processing. Servers are responsible for managing primary copies of relations. Each server is responsible for the primary copy of at least one base relation. The primary copy of each relation resides on a single server (i.e., relations are not declustered).
Reference: [Fra93] <author> M. Franklin. </author> <title> Caching and Memory Management in Client-Server Database Systems. </title> <type> PhD thesis, </type> <institution> University of Wisconsin, Madison, Wisconsin, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Data that is cached at clients is assumed to be initially resident on the client's local disk. 4.1.2 System Parameters and Execution Model Table 2 shows the parameters of the cost model and their default values used in the study. The parameter values are based on those used in <ref> [Fra93] </ref> and [SC90].
Reference: [GHK92] <author> S. Ganguly, W. Hasan, and R. Krishnamurthy. </author> <title> Query optimization for parallel execution. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 9-18, </pages> <address> San Diego, USA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: It can be used to produce both total resource usage (i.e., cost) and response-time estimates. The response-time estimates are produced using the model of operator parallelism developed by Ganguly, Hasan, and Krishnamurthy <ref> [GHK92] </ref>. The query optimizer is based on randomized two-phase query optimization (2PO), which combines simulated annealing and iterative improvement, as proposed by Ioannidis and Kang [IK90]. Optimization can be aimed at minimizing either the cost or the response time predictions of the cost model. <p> The response time estimates generated by the model are based on the approach taken in <ref> [GHK92] </ref>. The response time of a query is defined to be the elapsed time from the initiation of query execution until the time that the last tuple of the query result is displayed at the client. <p> In contrast, pipelined parallelism arises between producer and consumer operators. Using pipelined execution, an operator can begin executing as soon as each of its producer operators has produced at least one tuple. In this case the consumer can run in parallel with its producer operators. The model of <ref> [GHK92] </ref> estimates response times using a simplified notion of parallelism and resource contention. All operators that run in parallel are considered to complete at the same time. <p> The calculations of response time are applied to a query plan tree in a bottom-up fashion, ultimately resulting in an estimate of the response time for the entire plan. The model of <ref> [GHK92] </ref> is intended to capture the affects of operator parallelism in a very coarse-grained fashion and is computationally efficient enough to allow many complex query plans to be evaluated in a 7 reasonable amount of time. <p> For these reasons, this simple model was chosen for this study. In addition to the assumptions used in the response time model of <ref> [GHK92] </ref>, the environment constructed for this study makes several other simplifications. These include: 1. Synchronization overhead between parallel operators is not modeled. For example, in pipelined parallelism, synchronization is typically required to ensure that the producer does not flood the buffers of the consumer.
Reference: [HF86] <author> R. Hagmann and D. Ferrari. </author> <title> Performance analysis of several back-end database architectures. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 11(1) </volume> <pages> 1-26, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: Hagmann and Ferrari were among the first to study query processing in a client-server environment <ref> [HF86] </ref>. They investigated different ways to split the functionality of a DBMS (e.g., query parsing, optimization, and execution) between client (front-end in their terminology) and server (back-end) machines.
Reference: [HS90] <author> W. Hong and M. Stonebraker. </author> <title> Parallel query processing in XPRS. </title> <type> Technical report UCB/ERL M90/47, </type> <institution> Department of Industrial Engineering and Operations Research and School of Business Administration, University of California, Berkeley, </institution> <address> CA, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: The main factor contributing to the performance degradation was seen to be the site selection, rather than the join ordering. This observation indicates that a 2-step optimization similar to that proposed by Carey and Lu [CL86] and similar to that used by XPRS <ref> [HS90] </ref> and Mariposa [SAD + 94] may be a good basis for generating query plans that can be modified dynamically prior to query execution in order to adapt to changes in the run-time environment.
Reference: [IK90] <author> Y. E. Ioannidis and Y. C. Kang. </author> <title> Randomized algorithms for optimizing large join queries. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 312-321, </pages> <address> Atlantic City, USA, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: The response-time estimates are produced using the model of operator parallelism developed by Ganguly, Hasan, and Krishnamurthy [GHK92]. The query optimizer is based on randomized two-phase query optimization (2PO), which combines simulated annealing and iterative improvement, as proposed by Ioannidis and Kang <ref> [IK90] </ref>. Optimization can be aimed at minimizing either the cost or the response time predictions of the cost model. The search space explored by the optimizer includes the full range of shipping strategies; it can, however, be restricted so that the optimizer produces only data-shipping or query-shipping plans. <p> guarantee the minimum buffer allocation, and at least p M B buffer frames are allocated to model the execution of joins with very small relations realistically. 4.2 Query Optimization The query plans that are evaluated in the performance study of Section 5 are obtained using randomized two-phase query optimization (2PO) <ref> [IK90] </ref>. Randomized query optimization was chosen for this study for the following reasons. First, randomized approaches have been shown to be successful at finding very good join orderings [IK90, SMK93] and generating efficient plans for parallel execution with very large search spaces [LVZ93]. <p> Randomized query optimization was chosen for this study for the following reasons. First, randomized approaches have been shown to be successful at finding very good join orderings <ref> [IK90, SMK93] </ref> and generating efficient plans for parallel execution with very large search spaces [LVZ93]. Second, the simplicity of the approach allowed the optimizer to be constructed quickly, and to be easily configured to generate plans for the three different execution strategies. <p> However, queries with large numbers of joins are becoming increasingly common, due 3 This study uses the same parameter settings to control the II and SA phases as used in <ref> [IK90] </ref>. 4 Note that after every move the commutativity of joins is exploited to ensure that the right (or outer) relation of each join is the larger of the two. 10 to applications with complex queries such as decision support and data mining, as well as to the use of path
Reference: [JWKL90] <author> B. P. Jenq, D. Woelk, W. Kim, and W. L. Lee. </author> <title> Query processing in distributed ORION. </title> <booktitle> In Proc. of the Intl. Conf. on Extending Database Technology (EDBT), </booktitle> <pages> pages 169-187, </pages> <address> Venice, Italy, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: Like many other studies, they concentrated on a system with only one server, and therefore, could not realize the potential to execute the operators of a query on different sites in parallel. Examples of research prototypes that support multiple servers are Orion-2 <ref> [JWKL90] </ref>, SHORE [CDF + 94] and Mariposa [SAD + 94, SDK + 94]. In these systems, the design of the execution policy plays an important role. In the current version, SHORE only uses data shipping.
Reference: [Kim93] <author> W. Kim. </author> <title> Object-oriented database systems: Promises, reality, and future. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <address> Dublin, Ireland, </address> <year> 1993. </year>
Reference-contexts: Donald Kossmann was supported by the Humboldt-Stiftung. 1 Furthermore, a new class of hybrid "Object-Relational" systems has recently started to emerge (e.g., Illus--tra [Sto93], and UniSQL <ref> [Kim93] </ref>). These efforts have resulted in significant progress towards integrating object and relational concepts, but this progress has been primarily at the language and data model levels.
Reference: [Kul94] <author> K. G. Kulkarni. </author> <title> Object-oriented extensions in SQL3: A status report. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> page 478, </pages> <address> Minneapolis, MI, USA, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: System builders have been approaching this perceived need in several ways. Vendors of relational systems are moving towards integrating object-oriented features into their systems (e.g., the emerging SQL3 standard <ref> [Kul94] </ref>), and vendors of object-oriented systems are adding more powerful query facilities [Cat94]. fl This work was partially supported by NSF Grant IRI-94-09575. Donald Kossmann was supported by the Humboldt-Stiftung. 1 Furthermore, a new class of hybrid "Object-Relational" systems has recently started to emerge (e.g., Illus--tra [Sto93], and UniSQL [Kim93]).
Reference: [LVZ93] <author> R. Lanzelotte, P. Valduriez, and M. Zait. </author> <title> On the effectiveness of optimization search strategies for parallel execution spaces. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 493-504, </pages> <address> Dublin, Ireland, </address> <year> 1993. </year>
Reference-contexts: Randomized query optimization was chosen for this study for the following reasons. First, randomized approaches have been shown to be successful at finding very good join orderings [IK90, SMK93] and generating efficient plans for parallel execution with very large search spaces <ref> [LVZ93] </ref>. Second, the simplicity of the approach allowed the optimizer to be constructed quickly, and to be easily configured to generate plans for the three different execution strategies.
Reference: [MGS + 94] <author> D. Maier, G. Graefe, L. Shapiro, S. Daniels, T. Keller, and B. Vance. </author> <title> Issues in distributed object assembly. </title> <editor> In Ozsu et al. </editor> [ <booktitle> ODV94], </booktitle> <pages> pages 165-181. </pages> <booktitle> International Workshop on Distributed Object Management. </booktitle>
Reference-contexts: Several execution policies that allow a flexible decision where to execute a query are also incorporated in Orion. An initial discussion of execution policies for the specific task of distributed object assembly can also be found in <ref> [MGS + 94] </ref>. Multidatabases [SL90] are also examples of distributed systems.
Reference: [ML86] <author> L. Mackert and G. Lohman. </author> <title> R fl optimizer validation and performance evaluation for distributed queries. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 149-159, </pages> <address> Kyoto, Japan, </address> <year> 1986. </year>
Reference-contexts: Following the model of Mackert and Lohman <ref> [ML86] </ref>, the cost of a query plan is defined as the sum of the total time used to read pages from disks plus the total time used to execute CPU instructions plus the total time used to transmit messages over the network.
Reference: [ ODV94] <author> T. Ozsu, U. Dayal, and P. Valduriez, </author> <title> editors. Distributed Object Management. </title> <publisher> Morgan-Kaufmann Publ. Co., </publisher> <address> San Mateo, CA, USA, </address> <month> May </month> <year> 1994. </year> <booktitle> International Workshop on Distributed Object Management. </booktitle> <pages> 24 </pages>
Reference: [S + 90] <author> M. Stonebraker et al. </author> <title> Third generation data base system manifesto. </title> <type> Technical Report No. </type> <institution> UCB/ERL M90/28, UC Berkeley, Berkeley, </institution> <address> CA, </address> <year> 1990. </year>
Reference-contexts: Because of these different (and in some ways, complimentary) strengths, it has become apparent that database systems combining the best aspects of the relational and object-oriented approaches are likely to gain acceptance across a larger range of applications <ref> [S + 90] </ref>. System builders have been approaching this perceived need in several ways.
Reference: [SAC + 79] <author> P. G. Selinger, M. M. Astrahan, D. D. Chamberlin, R. A. Lorie, and T. G. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 23-34, </pages> <address> Boston, USA, </address> <month> May </month> <year> 1979. </year>
Reference-contexts: To focus on these two dimensions, most of the options of other dimensions are not taken into account; for example, no indexes are used, and the hybrid-hash join method [Sha86] is the only join method used. In most database systems, the join order is restricted to a left-deep tree <ref> [SAC + 79] </ref>; that is, at most one of the inputs of a join is the result of another join. In this study, however, bushy trees are allowed.
Reference: [SAD + 94] <author> M. Stonebraker, P. M. Aoki, R. Devine, W. Litwin, and M. Olson. Mariposa: </author> <title> A new architecture for distributed data. </title> <booktitle> In Proc. IEEE Conf. on Data Engineering, </booktitle> <pages> pages 54-65, </pages> <address> Houston, TX, </address> <year> 1994. </year>
Reference-contexts: The main factor contributing to the performance degradation was seen to be the site selection, rather than the join ordering. This observation indicates that a 2-step optimization similar to that proposed by Carey and Lu [CL86] and similar to that used by XPRS [HS90] and Mariposa <ref> [SAD + 94] </ref> may be a good basis for generating query plans that can be modified dynamically prior to query execution in order to adapt to changes in the run-time environment. <p> Like many other studies, they concentrated on a system with only one server, and therefore, could not realize the potential to execute the operators of a query on different sites in parallel. Examples of research prototypes that support multiple servers are Orion-2 [JWKL90], SHORE [CDF + 94] and Mariposa <ref> [SAD + 94, SDK + 94] </ref>. In these systems, the design of the execution policy plays an important role. In the current version, SHORE only uses data shipping. Mariposa supports both query and data ship 6 Only distributed INGRES could be parametrized to optimize response time. 22 ping.
Reference: [SC90] <author> E. J. Shekita and M. J. Carey. </author> <title> A performance evaluation of pointer-based joins. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 300-311, </pages> <address> Atlantic City, NJ, </address> <month> May 90. </month>
Reference-contexts: The parameter values are based on those used in [Fra93] and <ref> [SC90] </ref>.
Reference: [SDK + 94] <author> M. Stonebraker, R. Devine, M. Kornacker, W. Litwin, A. Pfeffer, A. Sah, and C. Staelin. </author> <title> An economic paradigm for query processing and data migration in Mariposa. </title> <booktitle> In Proc. of the IEEE Conf. on Parallel and Distributed Information Systems, </booktitle> <pages> pages 58-67, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Like many other studies, they concentrated on a system with only one server, and therefore, could not realize the potential to execute the operators of a query on different sites in parallel. Examples of research prototypes that support multiple servers are Orion-2 [JWKL90], SHORE [CDF + 94] and Mariposa <ref> [SAD + 94, SDK + 94] </ref>. In these systems, the design of the execution policy plays an important role. In the current version, SHORE only uses data shipping. Mariposa supports both query and data ship 6 Only distributed INGRES could be parametrized to optimize response time. 22 ping.
Reference: [Sha86] <author> L. D. Shapiro. </author> <title> Join processing in database systems with large main memories. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 11(9) </volume> <pages> 239-264, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: To focus on these two dimensions, most of the options of other dimensions are not taken into account; for example, no indexes are used, and the hybrid-hash join method <ref> [Sha86] </ref> is the only join method used. In most database systems, the join order is restricted to a left-deep tree [SAC + 79]; that is, at most one of the inputs of a join is the result of another join. In this study, however, bushy trees are allowed. <p> For example, in pipelined parallelism, synchronization is typically required to ensure that the producer does not flood the buffers of the consumer. The cost of such synchronization is not captured in the model. 2. All joins are performed using the hybrid-hash join method <ref> [Sha86] </ref>. No indexes are used. 3. Results are obtained for single queries running in isolation. As a result, the only resource contention that is directly modeled is that resulting from the parallel execution of operators from a single query. This restriction is mitigated in two ways, however. <p> The cost of displaying the query result at the client is modeled by the DISPLAY parameter, which is set to zero in this study. As stated in Section 2, all joins are modeled as hybrid-hash joins. The cost of hybrid-hash joins is estimated using the cost formulas of <ref> [Sha86] </ref>; the corresponding COMPARE, HASH, MOVE, and F parameters are listed in Table 2.
Reference: [SL90] <author> A. Sheth and J. Larson. </author> <title> Federated database systems for manageing distributed, heterogeneous, and autonmous databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(3) </volume> <pages> 183-236, </pages> <year> 1990. </year>
Reference-contexts: Several execution policies that allow a flexible decision where to execute a query are also incorporated in Orion. An initial discussion of execution policies for the specific task of distributed object assembly can also be found in [MGS + 94]. Multidatabases <ref> [SL90] </ref> are also examples of distributed systems.
Reference: [SMK93] <author> M. Steinbrunn, G. Moerkotte, and A. Kemper. </author> <title> Optimizing join orders. </title> <type> Technical Report MIP-9307, </type> <institution> Universitat Passau, </institution> <address> 94030 Passau, Germany, </address> <year> 1993. </year>
Reference-contexts: Randomized query optimization was chosen for this study for the following reasons. First, randomized approaches have been shown to be successful at finding very good join orderings <ref> [IK90, SMK93] </ref> and generating efficient plans for parallel execution with very large search spaces [LVZ93]. Second, the simplicity of the approach allowed the optimizer to be constructed quickly, and to be easily configured to generate plans for the three different execution strategies.
Reference: [Sto85] <author> M. Stonebraker. </author> <title> The design and implementation of distributed INGRES. </title> <editor> In M. Stonebraker, editor, </editor> <title> The INGRES Papers: Anatomy of a Relational Database System. </title> <publisher> Addison-Wesley Pub., </publisher> <year> 1985. </year>
Reference-contexts: At that time, several prototype systems were developed such as: System R fl [WDH + 81], SDD-1 [BGW + 81], and distributed INGRES <ref> [Sto85] </ref>. Typically, these systems focused on optimizing the cost of a query; in particular, much effort was made to minimize the communication cost since the systems were designed to run on slow networks. 6 Many of the concepts are still valid, today.
Reference: [Sto93] <author> M. Stonebraker. </author> <title> The Miro DBMS. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <address> Washington, DC, USA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Donald Kossmann was supported by the Humboldt-Stiftung. 1 Furthermore, a new class of hybrid "Object-Relational" systems has recently started to emerge (e.g., Illus--tra <ref> [Sto93] </ref>, and UniSQL [Kim93]). These efforts have resulted in significant progress towards integrating object and relational concepts, but this progress has been primarily at the language and data model levels.
Reference: [WDH + 81] <author> R. Williams, D. Daniels, L. Haas, G. Lapis, B. Lindsay, P. Ng, R. Obermarck, P. Selinger, A. Walker, P. Wilms, and R. Yost. </author> <title> R fl : An overview of the architecture. </title> <institution> IBM Research, </institution> <address> San Jose, CA, RJ3325, </address> <month> December </month> <year> 1981. </year> <month> 25 </month>
Reference-contexts: At that time, several prototype systems were developed such as: System R fl <ref> [WDH + 81] </ref>, SDD-1 [BGW + 81], and distributed INGRES [Sto85].
References-found: 34

