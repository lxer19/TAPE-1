URL: http://www.cs.cornell.edu/home/jgm/papers/mcc.ps
Refering-URL: http://www.cs.cornell.edu/home/jgm/papers.html
Root-URL: 
Email: fms@cs.cornell.edu  jgm@cs.cornell.edu  
Title: Mostly-Copying Collection: A Viable Alternative to Conservative Mark-Sweep  
Author: Frederick Smith Greg Morrisett 
Address: Ithaca, New York 14853-7501, USA  
Affiliation: Computer Science Department Cornell University  
Abstract: Many high-level language compilers generate C code and then invoke a C compiler to do code generation, register allocation, stack management, and low-level optimization. To date, most of these compilers link the resulting code against a conservative mark-sweep garbage collector in order to reclaim unused memory. We introduce a new collector, MCC, based on mostly-copying collection, and characterize the conditions that favor such a collector over a mark-sweep collector. In particular we demonstrate that mostly-copying collection outperforms conservative mark-sweep under the same conditions that accurate copying collection outperforms accurate mark-sweep: Specifically, MCC meets or exceeds the performance of a mature mark-sweep collector when allocation rates are high, and physical memory is large relative to the live data.
Abstract-found: 1
Intro-found: 1
Reference: 1. <institution> American National Standards Institute, </institution> <address> 1430 Broadway, New York, NY 10018, USA. </address> <booktitle> American National Standard Programming Language C, ANSI X3.159-1989, </booktitle> <month> Dec. 14 </month> <year> 1989. </year>
Reference-contexts: 1 High Level Overview Languages such as C <ref> [1] </ref> and C++ [27] are GC-unfriendly because they allow programs to violate the key premise of tracing garbage collection|that all live objects are reachable by a sequence of pointer traversals from the root set. For example, a program might violate this premise by using pointer arithmetic or casting.
Reference: 2. <author> A. W. Appel and D. B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In M. Wirsing, editor, </editor> <booktitle> Third International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> Aug. </month> <year> 1991. </year> <title> Springer-Verlag. </title> <booktitle> Volume 528 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: We would have liked to compile larger, longer running ML programs, but most such programs use the ML-module system which TIL/C does not currently support. Instead we selected benchmarks that have been used in the literature [20, 28, 26, 25] to measure the performance of TIL and SML/NJ <ref> [2] </ref>. Since most of these ran very quickly, we modified the programs slightly to make them run longer (e.g., by increasing the data set sizes or number of iterations). We compiled the C code using gcc -O2 on a 256 MB Sparc 20 running Solaris 2.5.
Reference: 3. <author> A. W. Appel and Z. Shao. </author> <title> An empirical and analytic study of stack vs. heap cost for languages with closures. </title> <journal> Journal of Functional Programming, </journal> <volume> 1, </volume> <month> January </month> <year> 1993. </year>
Reference-contexts: Of these instructions 1 and, 1 add, 1 compare, and 1 branch are used to determine whether there is enough space to proceed. With additional changes to the compiler we could achieve an amortized performance of 3 instructions per object allocation using the same techniques suggested by Appel <ref> [3] </ref>. 3.2 Heap Structure MCC maintains a heap structure consisting of heap blocks which are divided into pages. The collector allocates large (1/2 MB) heap blocks using memalign so that the most significant bits uniquely identify the block.
Reference: 4. <author> G. Attardi and T. Flagella. </author> <title> Customising object allocation. </title> <editor> In M. Tokoro and R. Pareschi, editors, </editor> <booktitle> Object Oriented Programming, Proceedings of the 8th ECOOP, Lecture Notes in Computer Science 821, </booktitle> <pages> pages 320-343. </pages> <address> Berlin: </address> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: BiBoP obviates the need for a header word per object but it also makes it difficult to associate state with each object, and to allocate quickly. To the best of our knowledge since Bartlett's original work there has only been one other mostly-copying collector: CMM <ref> [4, 5, 6] </ref> (for C++). CMM improves on Bartlett's algorithm in that it associates a bitmap with each page which allows it to mark individual objects, thus achieving less false retention. However, CMM did not make any fundamental changes and therefore still requires two passes over the live data. <p> However, CMM did not make any fundamental changes and therefore still requires two passes over the live data. Some data comparing CMM to Bartlett's collector and to BWC in the context of C++ is published in <ref> [4] </ref>. 4 Comparison of Overall Costs for ML To compare MCC to BWC, we added a C back end to the TIL compiler [30, 29] and targeted it to use both collectors.
Reference: 5. <author> G. Attardi and T. Flagella. </author> <title> A customizable memory management framework. </title> <booktitle> In USENIX Association, editor, Proceedings of the 1994 USENIX C++ Conference: </booktitle> <address> April 11-14, 1994, Cambridge, MA, </address> <pages> pages 123-142, </pages> <address> Berkeley, CA, USA, </address> <month> Apr. </month> <year> 1994. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: BiBoP obviates the need for a header word per object but it also makes it difficult to associate state with each object, and to allocate quickly. To the best of our knowledge since Bartlett's original work there has only been one other mostly-copying collector: CMM <ref> [4, 5, 6] </ref> (for C++). CMM improves on Bartlett's algorithm in that it associates a bitmap with each page which allows it to mark individual objects, thus achieving less false retention. However, CMM did not make any fundamental changes and therefore still requires two passes over the live data.
Reference: 6. <author> G. Attardi, T. Flagella, and P. Iglio. </author> <title> Performance tuning in a customizable collector. </title> <editor> In H. Baker, editor, </editor> <booktitle> Proceedings of International Workshop on Memory Management, Lecture Notes in Computer Science, </booktitle> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <address> Sept. 1995. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: BiBoP obviates the need for a header word per object but it also makes it difficult to associate state with each object, and to allocate quickly. To the best of our knowledge since Bartlett's original work there has only been one other mostly-copying collector: CMM <ref> [4, 5, 6] </ref> (for C++). CMM improves on Bartlett's algorithm in that it associates a bitmap with each page which allows it to mark individual objects, thus achieving less false retention. However, CMM did not make any fundamental changes and therefore still requires two passes over the live data.
Reference: 7. <author> J. F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Technical Report 88/2, </type> <institution> Digital Equipment Corporation Western Research Laboratory, Palo Alto, California, </institution> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: Consequently, compilers for GC-unfriendly languages do not support garbage collection and do not provide the information necessary to distinguish pointers from other data. This makes accurate garbage collection infeasible. Conservative tracing garbage collection is a practical memory management approach for GC-unfriendly languages <ref> [14, 11, 13, 12, 16, 8, 7, 9, 10] </ref>. <p> In this paper, we present a new collector based on an improved version of the mostly-copying collection algorithm of Bartlett <ref> [7, 8, 10] </ref> as an alternative to BWC. Our collector (MCC), in contrast to BWC, is targeted at code generated by compilers, and thus expects type information to be available for most, but not all objects.
Reference: 8. <author> J. F. Bartlett. </author> <title> Mostly-copying garbage collection picks up generations and C++. </title> <type> Technical report, </type> <institution> DEC WRL, </institution> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: Consequently, compilers for GC-unfriendly languages do not support garbage collection and do not provide the information necessary to distinguish pointers from other data. This makes accurate garbage collection infeasible. Conservative tracing garbage collection is a practical memory management approach for GC-unfriendly languages <ref> [14, 11, 13, 12, 16, 8, 7, 9, 10] </ref>. <p> In this paper, we present a new collector based on an improved version of the mostly-copying collection algorithm of Bartlett <ref> [7, 8, 10] </ref> as an alternative to BWC. Our collector (MCC), in contrast to BWC, is targeted at code generated by compilers, and thus expects type information to be available for most, but not all objects. <p> The speed of pointer testing makes completely conservative collectors such as BWC possible. 3 MCC Algorithm & Implementation In this section, we present the details of our mostly copying collector MCC, which extends the algorithm presented by Bartlett <ref> [9, 8, 10] </ref>. Section 3.1 discusses object representations and allocation. Section 3.2 presents the overall structure of the heap and the data structures used during collection. Section 3.3 presents our algorithm for determining whether a value in the heap is a pointer. Section 3.4 discusses the collection algorithm itself.
Reference: 9. <author> J. F. Bartlett. </author> <title> A generational, compacting collector for C++. </title> <editor> In E. Jul and N.-C. Juul, editors, </editor> <booktitle> OOPSLA/ECOOP '90 Workshop on Garbage Collection in Object-Oriented Systems, </booktitle> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: Consequently, compilers for GC-unfriendly languages do not support garbage collection and do not provide the information necessary to distinguish pointers from other data. This makes accurate garbage collection infeasible. Conservative tracing garbage collection is a practical memory management approach for GC-unfriendly languages <ref> [14, 11, 13, 12, 16, 8, 7, 9, 10] </ref>. <p> The speed of pointer testing makes completely conservative collectors such as BWC possible. 3 MCC Algorithm & Implementation In this section, we present the details of our mostly copying collector MCC, which extends the algorithm presented by Bartlett <ref> [9, 8, 10] </ref>. Section 3.1 discusses object representations and allocation. Section 3.2 presents the overall structure of the heap and the data structures used during collection. Section 3.3 presents our algorithm for determining whether a value in the heap is a pointer. Section 3.4 discusses the collection algorithm itself.
Reference: 10. <author> J. F. Bartlett. </author> <title> System and method for garbage collection with ambiguous roots. </title> <type> US Patent, </type> <month> March </month> <year> 1990. </year> <type> Patent number 4907151. </type> <institution> Assignee Digital Equipment Corporation. </institution>
Reference-contexts: Consequently, compilers for GC-unfriendly languages do not support garbage collection and do not provide the information necessary to distinguish pointers from other data. This makes accurate garbage collection infeasible. Conservative tracing garbage collection is a practical memory management approach for GC-unfriendly languages <ref> [14, 11, 13, 12, 16, 8, 7, 9, 10] </ref>. <p> In this paper, we present a new collector based on an improved version of the mostly-copying collection algorithm of Bartlett <ref> [7, 8, 10] </ref> as an alternative to BWC. Our collector (MCC), in contrast to BWC, is targeted at code generated by compilers, and thus expects type information to be available for most, but not all objects. <p> The speed of pointer testing makes completely conservative collectors such as BWC possible. 3 MCC Algorithm & Implementation In this section, we present the details of our mostly copying collector MCC, which extends the algorithm presented by Bartlett <ref> [9, 8, 10] </ref>. Section 3.1 discusses object representations and allocation. Section 3.2 presents the overall structure of the heap and the data structures used during collection. Section 3.3 presents our algorithm for determining whether a value in the heap is a pointer. Section 3.4 discusses the collection algorithm itself.
Reference: 11. <author> H.-J. Boehm. </author> <title> Space-efficient conservative garbage collection. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 197-206, </pages> <address> Albuquerque, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Consequently, compilers for GC-unfriendly languages do not support garbage collection and do not provide the information necessary to distinguish pointers from other data. This makes accurate garbage collection infeasible. Conservative tracing garbage collection is a practical memory management approach for GC-unfriendly languages <ref> [14, 11, 13, 12, 16, 8, 7, 9, 10] </ref>. <p> This paper requires familiarity with many garbage collection concepts that for the sake of brevity have been omitted. The reader requiring more clarification is referred to Wilson's survey on garbage collection techniques [32] or Richard Jones' text [19]. 2 The Boehm-Weiser Conservative Collector BWC <ref> [14, 11] </ref> is a conservative mark-sweep collector available on a wide variety of platforms. It is used by at least ten systems to date and has been under development since 1987 x .
Reference: 12. <author> H.-J. Boehm. </author> <title> Simple garbage-collector safety. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 89-98, </pages> <address> Philadelphia, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Consequently, compilers for GC-unfriendly languages do not support garbage collection and do not provide the information necessary to distinguish pointers from other data. This makes accurate garbage collection infeasible. Conservative tracing garbage collection is a practical memory management approach for GC-unfriendly languages <ref> [14, 11, 13, 12, 16, 8, 7, 9, 10] </ref>.
Reference: 13. <author> H.-J. Boehm and D. R. Chase. </author> <title> A proposal for garbage-collector-safe C compilation. C Language Translation, </title> <year> 1992. </year>
Reference-contexts: Consequently, compilers for GC-unfriendly languages do not support garbage collection and do not provide the information necessary to distinguish pointers from other data. This makes accurate garbage collection infeasible. Conservative tracing garbage collection is a practical memory management approach for GC-unfriendly languages <ref> [14, 11, 13, 12, 16, 8, 7, 9, 10] </ref>. <p> The results show that the characteristics of each program determine which collector performs best, and that the tradeoffs involved in choosing MCC over BWC are the same as those involved in choosing an accurate copying collector over an accurate mark-sweep collector. In particular, MCC z See <ref> [13] </ref> for a discussion of what compiler support is required. 2 is favored when physical memory is plentiful, when the amount of live data is small relative to the amount of allocation, and when allocation rates are high.
Reference: 14. <author> H.-J. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <year> 1988. </year>
Reference-contexts: Consequently, compilers for GC-unfriendly languages do not support garbage collection and do not provide the information necessary to distinguish pointers from other data. This makes accurate garbage collection infeasible. Conservative tracing garbage collection is a practical memory management approach for GC-unfriendly languages <ref> [14, 11, 13, 12, 16, 8, 7, 9, 10] </ref>. <p> Given the many compilers using conservative collection it is remarkable that all of the above compilers link the resulting code against the same conservative collector: The Boehm-Weiser collector (BWC) <ref> [14] </ref>. BWC is based on a mark-sweep algorithm, and was designed to be used in systems where type information is generally unavailable. <p> This paper requires familiarity with many garbage collection concepts that for the sake of brevity have been omitted. The reader requiring more clarification is referred to Wilson's survey on garbage collection techniques [32] or Richard Jones' text [19]. 2 The Boehm-Weiser Conservative Collector BWC <ref> [14, 11] </ref> is a conservative mark-sweep collector available on a wide variety of platforms. It is used by at least ten systems to date and has been under development since 1987 x .
Reference: 15. <author> J. Dean, G. DeFouw, D. Grove, V. Livinov, and C. Chambers. </author> <title> Vortex: An optimizing compiler for object-oriented languages. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 31(10) </volume> <pages> 83-100, </pages> <month> Oct. </month> <year> 1996. </year> <title> Discusses performance of Vortex compiler for Cecil, C++, Java, and Modula-3. </title> <type> 20 </type>
Reference-contexts: Indeed, conservative collectors are so practical that a variety of compilers for GC-friendly languages, including TIL/C [29, 20, 28, 30], Toba [22], Harissa [21], Bigloo [24] and Vortex <ref> [15] </ref>, have chosen to use a conservative collector and to compile to C rather than use an accurate collector and generate assembly code. The implementors of these systems have decided that the portability of C, and the optimizations afforded by pre-existing C compilers outweigh the benefits of accurate collection.
Reference: 16. <author> A. Demers, M. Weiser, B. Hayes, H. Boehm, D. Bobrow, and S. Shenker. </author> <title> Combin--ing generational and conservative garbage collection: Framework and implementations. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 261-269, </pages> <address> San Francisco, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Consequently, compilers for GC-unfriendly languages do not support garbage collection and do not provide the information necessary to distinguish pointers from other data. This makes accurate garbage collection infeasible. Conservative tracing garbage collection is a practical memory management approach for GC-unfriendly languages <ref> [14, 11, 13, 12, 16, 8, 7, 9, 10] </ref>.
Reference: 17. <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Two facts mitigate BWC's space advantage. First, BWC double word aligns all objects that are greater than two words in size. So for objects of odd size, BWC loses the advantages of not having a header word. Second, other languages such as Java <ref> [17] </ref> and C++ require a header word (i.e., a class pointer). In those contexts the header word would not be a factor. MCC is favored by small amounts of live data, because the copy is cheap, and no work proportional to the heap is necessary.
Reference: 18. <author> M. W. Hicks, J. T. Moore, and S. M. Nettles. </author> <title> The measured cost of copying garbage collection mechanisms. </title> <booktitle> In International Conference on Functional Programming, </booktitle> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: In addition, MCC implements a slow pointer testing routine which penalizes it further in the presence of a deep stack or many conservative objects. Despite these drawbacks, MCC is comparable if not better than BWC on almost all benchmarks. The study in <ref> [18] </ref> suggests that more sophisticated techniques such as generations, and segregating objects may yield another 20% improvement in collector times. And, a few modifications to our compiler may further decrease the cost of allocation.
Reference: 19. <author> R. E. Jones. </author> <title> Garbage Collection: Algorithms for Automatic Dynamic Memory Management. </title> <publisher> Wiley, </publisher> <month> July </month> <year> 1996. </year> <title> With a chapter on Distributed Garbage Collection by R. </title> <type> Lins. </type> <note> Reprinted February 1996. </note>
Reference-contexts: Because MCC is mostly a copying collector it has many of the same performance characteristics as an accurate copying collector: compaction, fast allocation, and running time proportional to the live data <ref> [19] </ref>. Briefly this is how MCC achieves these characteristics. To achieve fast allocation, MCC organizes the heap into pages. The client first allocates a page from the collector, and then fills the page with objects in a contiguous fashion. <p> This paper requires familiarity with many garbage collection concepts that for the sake of brevity have been omitted. The reader requiring more clarification is referred to Wilson's survey on garbage collection techniques [32] or Richard Jones' text <ref> [19] </ref>. 2 The Boehm-Weiser Conservative Collector BWC [14, 11] is a conservative mark-sweep collector available on a wide variety of platforms. It is used by at least ten systems to date and has been under development since 1987 x . <p> Almost all false references fail the first two tests, taking only a few instructions. A successful test for a pointer will take approximately 30 instructions <ref> [19] </ref>. The speed of pointer testing makes completely conservative collectors such as BWC possible. 3 MCC Algorithm & Implementation In this section, we present the details of our mostly copying collector MCC, which extends the algorithm presented by Bartlett [9, 8, 10]. Section 3.1 discusses object representations and allocation.
Reference: 20. <author> G. Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: For a typical collector these invariants might include not mangling pointers, always retaining a pointer to the beginning of an object that is in use, and only using the collector's allocation routines. Indeed, conservative collectors are so practical that a variety of compilers for GC-friendly languages, including TIL/C <ref> [29, 20, 28, 30] </ref>, Toba [22], Harissa [21], Bigloo [24] and Vortex [15], have chosen to use a conservative collector and to compile to C rather than use an accurate collector and generate assembly code. <p> We would have liked to compile larger, longer running ML programs, but most such programs use the ML-module system which TIL/C does not currently support. Instead we selected benchmarks that have been used in the literature <ref> [20, 28, 26, 25] </ref> to measure the performance of TIL and SML/NJ [2]. Since most of these ran very quickly, we modified the programs slightly to make them run longer (e.g., by increasing the data set sizes or number of iterations).
Reference: 21. <author> G. Muller, B. Moura, F. Bellard, and C. Consel. Harissa: </author> <title> a flexible and efficient java environment mixing bytecode and compiled code. </title> <booktitle> In Usenix Conference on Object-Oriented Technlogies and Systems, </booktitle> <address> Oregon, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Indeed, conservative collectors are so practical that a variety of compilers for GC-friendly languages, including TIL/C [29, 20, 28, 30], Toba [22], Harissa <ref> [21] </ref>, Bigloo [24] and Vortex [15], have chosen to use a conservative collector and to compile to C rather than use an accurate collector and generate assembly code.
Reference: 22. <author> T. A. Proebsting, G. Townsend, P. Bridges, J. H. Hartman, T. Newsham, and S. A. Watterson. Toba: </author> <title> Java for applications: A way ahead of time (WAT) compiler. </title> <type> Technical Report TR97-01, </type> <institution> The Department of Computer Science, University of Arizona, </institution> <address> Jan. 8 1997. Wed, 08 Jan 97 00:00:00 GMT. </address>
Reference-contexts: Indeed, conservative collectors are so practical that a variety of compilers for GC-friendly languages, including TIL/C [29, 20, 28, 30], Toba <ref> [22] </ref>, Harissa [21], Bigloo [24] and Vortex [15], have chosen to use a conservative collector and to compile to C rather than use an accurate collector and generate assembly code. <p> We are particularly interested in how the language context affects collector performance, and are thus in the process of porting MCC to Toba <ref> [22] </ref>, a Java compiler. We are also reworking TIL/C to support modules. Hence, we hope to have results for larger, longer-running programs in the near future. On a more speculative note, mostly-copying collection may be well suited to a multi-threaded environment.
Reference: 23. <author> C. Reade. </author> <title> Elements of Functional Programming. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, </address> <year> 1989. </year>
Reference-contexts: This situation reflects the space needed to copy objects (Figure 3). 13 Fig. 4. Life: Wall clock times as a function of heap size. Life This benchmark runs 10; 000 generations of the Life simulation <ref> [23] </ref> for a small self-replicating automata. It allocates mostly lists, and pairs of integers. The pairs are allocated atomically for BWC and make up about 35% of the heap. On the other hand, there are typically only 4 KB of live data at any point in time.
Reference: 24. <author> M. Serrano and P. Weis. Bigloo: </author> <title> a portable and optimizing compiler for strict functional languages. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 983 </volume> <pages> 366-81, </pages> <year> 1995. </year>
Reference-contexts: Indeed, conservative collectors are so practical that a variety of compilers for GC-friendly languages, including TIL/C [29, 20, 28, 30], Toba [22], Harissa [21], Bigloo <ref> [24] </ref> and Vortex [15], have chosen to use a conservative collector and to compile to C rather than use an accurate collector and generate assembly code.
Reference: 25. <author> Z. Shao and A. W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 150-161, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: We would have liked to compile larger, longer running ML programs, but most such programs use the ML-module system which TIL/C does not currently support. Instead we selected benchmarks that have been used in the literature <ref> [20, 28, 26, 25] </ref> to measure the performance of TIL and SML/NJ [2]. Since most of these ran very quickly, we modified the programs slightly to make them run longer (e.g., by increasing the data set sizes or number of iterations).
Reference: 26. <author> Z. Shao and A. W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In ACM SIG-PLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 116-129, </pages> <address> La Jolla, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: We would have liked to compile larger, longer running ML programs, but most such programs use the ML-module system which TIL/C does not currently support. Instead we selected benchmarks that have been used in the literature <ref> [20, 28, 26, 25] </ref> to measure the performance of TIL and SML/NJ [2]. Since most of these ran very quickly, we modified the programs slightly to make them run longer (e.g., by increasing the data set sizes or number of iterations).
Reference: 27. <author> B. Stroustrup. </author> <title> The C++ programming language. </title> <publisher> Addison-Wesley series in computer science. Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <note> reprinted with corrections edition, </note> <year> 1987. </year>
Reference-contexts: 1 High Level Overview Languages such as C [1] and C++ <ref> [27] </ref> are GC-unfriendly because they allow programs to violate the key premise of tracing garbage collection|that all live objects are reachable by a sequence of pointer traversals from the root set. For example, a program might violate this premise by using pointer arithmetic or casting.
Reference: 28. <author> D. Tarditi. </author> <title> Design and Implementation of Code Optimizations for a TypeDirected Compiler for Standard ML. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> December </month> <year> 1996. </year>
Reference-contexts: For a typical collector these invariants might include not mangling pointers, always retaining a pointer to the beginning of an object that is in use, and only using the collector's allocation routines. Indeed, conservative collectors are so practical that a variety of compilers for GC-friendly languages, including TIL/C <ref> [29, 20, 28, 30] </ref>, Toba [22], Harissa [21], Bigloo [24] and Vortex [15], have chosen to use a conservative collector and to compile to C rather than use an accurate collector and generate assembly code. <p> We would have liked to compile larger, longer running ML programs, but most such programs use the ML-module system which TIL/C does not currently support. Instead we selected benchmarks that have been used in the literature <ref> [20, 28, 26, 25] </ref> to measure the performance of TIL and SML/NJ [2]. Since most of these ran very quickly, we modified the programs slightly to make them run longer (e.g., by increasing the data set sizes or number of iterations).
Reference: 29. <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 181-192, </pages> <address> Philadelphia, Pennsylvania, </address> <month> 21- May </month> <year> 1996. </year>
Reference-contexts: For a typical collector these invariants might include not mangling pointers, always retaining a pointer to the beginning of an object that is in use, and only using the collector's allocation routines. Indeed, conservative collectors are so practical that a variety of compilers for GC-friendly languages, including TIL/C <ref> [29, 20, 28, 30] </ref>, Toba [22], Harissa [21], Bigloo [24] and Vortex [15], have chosen to use a conservative collector and to compile to C rather than use an accurate collector and generate assembly code. <p> Some data comparing CMM to Bartlett's collector and to BWC in the context of C++ is published in [4]. 4 Comparison of Overall Costs for ML To compare MCC to BWC, we added a C back end to the TIL compiler <ref> [30, 29] </ref> and targeted it to use both collectors. We chose TIL because we were familiar with it, and because we were able to generate fairly natural C code.
Reference: 30. <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 31(5) </volume> <pages> 181-192, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: For a typical collector these invariants might include not mangling pointers, always retaining a pointer to the beginning of an object that is in use, and only using the collector's allocation routines. Indeed, conservative collectors are so practical that a variety of compilers for GC-friendly languages, including TIL/C <ref> [29, 20, 28, 30] </ref>, Toba [22], Harissa [21], Bigloo [24] and Vortex [15], have chosen to use a conservative collector and to compile to C rather than use an accurate collector and generate assembly code. <p> Some data comparing CMM to Bartlett's collector and to BWC in the context of C++ is published in [4]. 4 Comparison of Overall Costs for ML To compare MCC to BWC, we added a C back end to the TIL compiler <ref> [30, 29] </ref> and targeted it to use both collectors. We chose TIL because we were familiar with it, and because we were able to generate fairly natural C code.
Reference: 31. <author> K. G. Waugh, P. McAndrew, and G. Michaelson. </author> <title> Parallel implementations from function prototypes: a case study. </title> <institution> Technical Report Computer Science 90/4, Heriot-Watt University, Edinburgh, </institution> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: Pia: Wall clock times as a function of heap size. Pia This benchmark runs a perspective inversion algorithm that decides the location of an object in a perspective video image <ref> [31] </ref>. Most of the objects allocated are double-precision floating point values. The remainder (45%) are closures (3 words) and cons-cells (2 words). Since the floating point values are allocated atomically for BWC, the advantage of having type information is not as great for MCC.
Reference: 32. <author> P. R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <editor> In Y. Bekkers and J. Cohen, editors, </editor> <booktitle> International Workshop on Memory Management, number 637 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-42, </pages> <address> St. Malo, Sept. 1992. </address> <publisher> Springer-Verlag. </publisher> <pages> 21 </pages>
Reference-contexts: This paper requires familiarity with many garbage collection concepts that for the sake of brevity have been omitted. The reader requiring more clarification is referred to Wilson's survey on garbage collection techniques <ref> [32] </ref> or Richard Jones' text [19]. 2 The Boehm-Weiser Conservative Collector BWC [14, 11] is a conservative mark-sweep collector available on a wide variety of platforms. It is used by at least ten systems to date and has been under development since 1987 x .
Reference: 33. <author> B. Zorn. </author> <title> The measured cost of conservative garbage collection. </title> <journal> Software Practice and Experience, </journal> <volume> 23 </volume> <pages> 733-756, </pages> <year> 1993. </year>
Reference-contexts: BWC is very successful because it is easy to use (programs need only redirect malloc and free to the appropriate collector routines) and has performance comparable to explicit memory management for almost all programs <ref> [33] </ref>. In the remainder of this section, we briefly describe a simplified version of the algorithm and data structures that BWC employs. BWC breaks the heap into 4 KB blocks. Each block contains objects of a particular size, and has a header associated with it.
References-found: 33

