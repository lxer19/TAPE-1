URL: http://www.cs.indiana.edu/database/Ode/doc/att-db-93-22.ps.Z
Refering-URL: http://www.cs.indiana.edu/database/Ode/doc/
Root-URL: http://www.cs.indiana.edu
Email: fbiliris, thimiosg@research.att.com  
Title: EOS User's Guide Release 2.0 For UNIX-based Systems  
Author: Alexandros Biliris Euthimios Panagos 
Note: Release  Release  Print date:  
Date: May 5, 1993  2.0.1: May 5, 1993  2.0.2: October 1, 1993  October 5, 1993  
Address: Mountain Avenue  Murray Hill, NJ 07974  
Affiliation: 600  AT&T Bell Laboratories  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [AG89] <author> R. Agrawal and N. Gehani. </author> <title> ODE (Object Database and Environment): The Language and the Data Model. </title> <booktitle> In Proceedings of ACM-SIGMOD 1989 International Conference on Management of Data, </booktitle> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: Thus, the call to eosdatabase::open that triggered this action returns NULL it is as if EOS could not open this database. 7.11.7 Example 2 Fixing C++ Pointers This example is taken from the implementation of Ode <ref> [AG89] </ref>, a C++ based database system, that uses EOS as its storage manager. The problem encountered during the implementation was that C++ objects of types that have virtual functions or virtual base classes contain hidden pointers pointers that they were not specified by the user.
Reference: [BDG93] <author> A. Biliris, S. Dar, and N. Gehani. </author> <title> Making C++ Objects Persistent: Hidden Pointers. </title> <journal> Software Practice and Experience, </journal> <year> 1993. </year>
Reference-contexts: In the case of virtual base classes, the hidden pointers are used for sharing base classes [Str87]. Hidden pointers are invalid across program invocations and they need to be fixed. A solution to this problem was proposed in <ref> [BDG93] </ref> where these pointers are fixed when an object is fetched from storage. We define an extension that is triggered right after an object fault occurs. That is, the event that triggers this extension is AFTER OBJECT FAULT.
Reference: [Bil92a] <author> A. Biliris. </author> <title> An Efficient Database Storage Structure for Large Dynamic Objects. </title> <booktitle> In Proceedings of the Eighth International Conference on Data Engineering, </booktitle> <address> Tempe, Arizona, </address> <pages> pages 301-308, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: With 4K-byte disk blocks, the maximum segment size that can be supported is 2 13 pages (32 megabytes). The extent size can be approximately at most 63.5 megabytes <ref> [Bil92a] </ref>. The above numbers show upper limits in terms of maximum segment and buddy space sizes. To maximize performance, the extent size may have to be carefully matched to the physical properties of the disk device. <p> To summarize, on a steady state, the cost of allocating and deallocating a segment from a buddy space is going to be at most 1 disk 3 access, regardless of the area size <ref> [Bil92a] </ref>. 2.1.3 Object Identifiers (OIDs) EOS objects are stored on slotted pages and they are identified by system generated object ids (oids).
Reference: [Bil92b] <author> A. Biliris. </author> <title> The Performance of Three Database Storage Structures for Managing Large Objects. </title> <booktitle> In Proceedings of ACM-SIGMOD 1992 International Conference on Management of Data, </booktitle> <address> San Diego, California, </address> <pages> pages 276-285, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: For example, with T = 16, a large object that is 2 pages and a half long is kept in three pages, not in 16 pages. The tradeoffs that need to be examined in order to set this value are the following. (See also <ref> [Bil92b] </ref> for performance results.) Larger segments lead to better storage utilization, lower (sequential and random) read costs and higher update cost; i.e., the only aspect of the performance that might be affected negatively by larger segments is the cost of byte inserts and deletes. 2.1.9 Indexes EOS provides extendible hashing indexes.
Reference: [FNPS79] <author> R. Fagin, J. Nievergelt, N. Pippenger, and H. R. </author> <title> Strong. Extendible Hashing a Fast Access Method for Dynamic Files. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(3) </volume> <pages> 315-344, </pages> <month> September </month> <year> 1979. </year>
Reference-contexts: More information about the extendible hashing can be found in <ref> [FNPS79] </ref>. The keys can be either fixed-length structures or variable length strings.
Reference: [GR93] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1993. </year>
Reference-contexts: A page can be locked in shared (S), exclusive (X), or commit (C) mode. A file and/or a database can be locked in one of the following modes: no lock (NOL), S, intention shared (IS), X, intention exclusive (IX), shared intention exclusive (SIX), C, and intention commit (IC). (See <ref> [GR93] </ref> for a general description on transaction processing). Lock acquisition and release is implicit for each operation. When a page is locked, the file containing this page is locked too in the corresponding intention mode.
Reference: [KP84] <author> B. Kernighan and R. Pike. </author> <title> The UNIX Programming Environment. </title> <booktitle> Prentice-Hall Software Series, </booktitle> <year> 1984. </year>
Reference-contexts: In addition, the server spawns the checkpoint and the global log processes, and allocates a number of UNIX system V shared memory segments and semaphores <ref> [KP84, Ste90] </ref>. The shared memory segments are used by the shared buffer pool and the concurrency control module to allow all the processes spawned by the server, both during start up and when a new client is connected, to access the same structures.
Reference: [Ste90] <author> R. Stevens. </author> <title> UNIX Network Programming. </title> <booktitle> Prentice-Hall Software Series, </booktitle> <year> 1990. </year>
Reference-contexts: In addition, the server spawns the checkpoint and the global log processes, and allocates a number of UNIX system V shared memory segments and semaphores <ref> [KP84, Ste90] </ref>. The shared memory segments are used by the shared buffer pool and the concurrency control module to allow all the processes spawned by the server, both during start up and when a new client is connected, to access the same structures.
Reference: [Str87] <author> B. Stroustrup. </author> <title> C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year> <note> 2nd ed. </note>
Reference-contexts: In the case of virtual functions, the hidden pointer points to a virtual function table that is used to determine which function is to be called. In the case of virtual base classes, the hidden pointers are used for sharing base classes <ref> [Str87] </ref>. Hidden pointers are invalid across program invocations and they need to be fixed. A solution to this problem was proposed in [BDG93] where these pointers are fixed when an object is fetched from storage. We define an extension that is triggered right after an object fault occurs.
References-found: 9

