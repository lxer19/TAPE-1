URL: ftp://ftp.cs.colorado.edu/users/alw/papers/c++3.ps.Z
Refering-URL: http://www.cs.colorado.edu/~arcadia/Papers/lp/cu_lp_papers.html
Root-URL: http://www.cs.colorado.edu
Email: (dsr@research.att.com)  (alw@research.att.com)  
Title: Representing Semantically Analyzed C++ Code with Reprise  
Author: David S. Rosenblum Alexander L. Wolf 
Address: 600 Mountain Avenue Murray Hill, NJ 07974-2070  
Affiliation: AT&T Bell Laboratories  
Date: April 22-25, 1991  
Note: from the Proceedings of the USENIX C++ Conference, Washington, DC,  
Abstract: A prominent stumbling block in the spread of the C++ programming language has been a lack of programming and analysis tools to aid development and maintenance of C++ systems. One way to make the job of tool developers easier and to increase the quality of the tools they create is to factor out the common components of tools and provide the components as easily (re)used building blocks. Those building blocks include lexical, syntactic, and semantic analyzers, tailored database derivers, code annotators and instrumentors, and code generators. From these building blocks, tools such as structure browsers, data-flow analyzers, program/specification verifiers, metrics collectors, compilers, interpreters, and the like can be built more easily and cheaply. We believe that for C++ programming and analysis tools the most primitive building blocks are centered around a common representation of semantically analyzed C++ code. In this paper we describe such a representation, called Reprise (REPResentation Including SEmantics). The conceptual model underlying Reprise is based on the use of expressions to capture all semantic information about both the C++ language and code written in C++. The expressions can be viewed as forming a directed graph, where there is an explicit connection from each use of an entity to the declaration giving the semantics of that entity. We elaborate on this model, illustrate how various features of C++ are represented, discuss some categories of tools that would create and manipulate Reprise representations, and briefly describe our current implementation. This paper is not intended to provide a complete definition of Reprise. Rather, its purpose is to introduce at a high level the basic approach we are taking in representing C++ code. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> AT&T. </author> <title> UNIX r fl System V C++ Language System Release Notes, </title> <note> release 2.1 edition, 1990. Select Code 307-160. </note>
Reference-contexts: Thus, CIA++ is a building-block tool in the sense that it offers a common service, namely the specialized filtering and structuring of information about C++ code, to a number of other tools. The current version of CIA++ was built by painful modification of cfront <ref> [1] </ref>, which is a tool that performs lexical, syntactic, and semantic analysis of C++ code, as well as a translation of the C++ code into C. Relatively simple modifications included the careful removal of all code performing the actual generation of C code. <p> The connection between that data structure and the C++ code is made by the unique identity of nodes and edges representing branches and statements in a Reprise graph. An interesting tool to consider in this category is the preprocessor cpp <ref> [1] </ref>. This tool interprets special statements, called preprocessor directives, that appear in files containing C++ code. The preprocessor uses the directives to determine what C++ code to pass on to other tools for processing.
Reference: [2] <author> G.S. Avrunin, L.K. Dillon, and J.C. Wileden. </author> <title> Experiments with constrained expression analysis of concurrent software systems. </title> <booktitle> In Proceedings of the SIGSOFT '89 Third Symposium on Software Testing, Analysis, and Verification (TAV3), </booktitle> <pages> pages 124-130, </pages> <address> Key West, FL, </address> <month> December </month> <year> 1989. </year> <booktitle> ACM SIGSOFT. </booktitle>
Reference-contexts: The Arcadia environment [17], for example, has a full arsenal of concurrency analysis <ref> [2, 21] </ref>, interface analysis [20], testing [4], and interpretation [22] tools, all based on such representations of Ada and Ada-like code. Reprise represents an application of this technology to C++ programming environments. To date, we have implemented the Reprise data structures as a library of C++ classes.
Reference: [3] <author> D.A. Baker, D.A. Fisher, and J.C. Shultis. </author> <title> The gardens of Iris. </title> <type> Technical report, </type> <institution> Incremental Systems Corporation, </institution> <address> Pittsburgh, PA, </address> <year> 1988. </year>
Reference-contexts: In other words, we see Reprise increasing the tempo at which C++ programming and analysis tools are developed, and orchestrating an harmonious interaction among them. Acknowledgements The conceptual model underlying the design of Reprise was strongly influenced by Iris <ref> [3] </ref>. Iris is being used in the Arcadia software development environment research project [17] as the basis for representations of code written in a number of languages, including Ada, PIC/ADL [20], and GDL [5].
Reference: [4] <author> L.A. Clarke, D.J. Richardson, and S.J. Zeil. </author> <title> TEAM: A support environment for testing, evaluation, and analysis. </title> <booktitle> In Proceedings of SIGSOFT '88: Third Symposium on Software Development Environments, </booktitle> <pages> pages 153-162, </pages> <address> Boston, MA, </address> <month> November </month> <year> 1988. </year> <booktitle> ACM SIGSOFT. Appears in ACM SIGSOFT Notes, </booktitle> <volume> Vol. 13, No. </volume> <pages> 5. </pages>
Reference-contexts: The Arcadia environment [17], for example, has a full arsenal of concurrency analysis [2, 21], interface analysis [20], testing <ref> [4] </ref>, and interpretation [22] tools, all based on such representations of Ada and Ada-like code. Reprise represents an application of this technology to C++ programming environments. To date, we have implemented the Reprise data structures as a library of C++ classes.
Reference: [5] <author> L.A. Clarke, J.C. Wileden, and A.L. Wolf. Graphite: </author> <title> A meta-tool for Ada environment development. </title> <booktitle> In Proceedings of the Second International Conference on Ada Applications and Environments, </booktitle> <pages> pages 81-90, </pages> <address> Miami Beach, FL, April 1986. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: An additional benefit of this approach is that tools operating on the same C++ code can share the Reprise representation of that code, resulting in a significant savings in both space and time. Given our experience in defining, building, and using Ada programming and analysis tools (e.g., <ref> [5, 14, 15, 20] </ref>) based on the Diana [7] and Paris [8] representations, we believe that this approach to the development of tools for C++ is a viable one to consider. We begin in Section 2 by describing the model upon which the representation is based. <p> Acknowledgements The conceptual model underlying the design of Reprise was strongly influenced by Iris [3]. Iris is being used in the Arcadia software development environment research project [17] as the basis for representations of code written in a number of languages, including Ada, PIC/ADL [20], and GDL <ref> [5] </ref>.
Reference: [6] <author> M.A. Ellis and B. Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The terminology we use generally follows that of the C++ reference manual <ref> [6] </ref>. For purposes of illustration, we use the Reprise representation of the C+ program of Figure 2, a simple example involving a class called ical. The Reprise representation of this program is shown in Figure 3, except that core graph entities are represented by the pictorial abbreviation !"entity", as before. <p> The operator class is used to represent the definition of a class, structure, or union. All non 7 User-defined types are referred to as "derived types" in Section 3.6.2 of the C++ reference manual <ref> [6] </ref>. 124 C++ Conference USENIX Association USENIX Association C++ Conference 125 union classes are subtypes of the meta-type %class. Anonymous unions are subtypes of the meta-type %anon union, while all other unions are subtypes of the meta-type %union (see Figure 4).
Reference: [7] <author> A. Evans, K.J. Butler, G. Goos, </author> <title> and W.A. Wulf. DIANA Reference Manual, </title> <type> Revision 3. </type> <institution> Tartan Laboratories, Inc., </institution> <address> Pittsburgh, PA, </address> <year> 1983. </year>
Reference-contexts: Given our experience in defining, building, and using Ada programming and analysis tools (e.g., [5, 14, 15, 20]) based on the Diana <ref> [7] </ref> and Paris [8] representations, we believe that this approach to the development of tools for C++ is a viable one to consider. We begin in Section 2 by describing the model upon which the representation is based.
Reference: [8] <author> K. Forester, I. Shy, and S. Zeil. </author> <title> PARIS operators: An Arcadia perspective. </title> <type> Technical Report Arcadia Document UCI-88-01, </type> <institution> Department of Information and Computer Science, University of California at Irvine, </institution> <year> 1988. </year> <booktitle> USENIX Association C++ Conference 133 </booktitle>
Reference-contexts: Given our experience in defining, building, and using Ada programming and analysis tools (e.g., [5, 14, 15, 20]) based on the Diana [7] and Paris <ref> [8] </ref> representations, we believe that this approach to the development of tools for C++ is a viable one to consider. We begin in Section 2 by describing the model upon which the representation is based. In Section 3 we sketch, through examples, how C++ code is actually represented in Reprise.
Reference: [9] <author> J.E. Grass and Y. Chen. </author> <title> The C++ information abstractor. </title> <booktitle> In Proceedings of the Second C++ Conference, </booktitle> <address> San Francisco, CA, </address> <month> April </month> <year> 1990. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: We believe that for C++ programming and analysis tools the most primitive building blocks are centered around a common representation of semantically analyzed C++ code. Consider, for example, the design of the C++ Information Abstractor (CIA++) <ref> [9] </ref>. CIA++ is a tool that constructs a database of information about the non-local entities in a C++ program. A variety of display and analysis tools make use of this database to provide information to developers.
Reference: [10] <author> A.R. Koenig and B. Stroustrup. </author> <title> Exception handling for C++ (revised). </title> <booktitle> In Proceedings of the Second C++ Conference, </booktitle> <address> San Francisco, CA, </address> <month> April </month> <year> 1990. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: We cannot expect to be able to anticipate the needs of all tools and, moreover, those needs may be in conflict. * Evolvability of representation. Although the language definition is stabilizing, there continue to be proposals for changes (e.g., for templates [16] and exception handling <ref> [10] </ref>). It is important, therefore, that the representation can be easily evolved along with the language. To facilitate this, the representation must capture more than just the surface-level, user-visible semantics.
Reference: [11] <author> W. Morris, </author> <title> editor. The American Heritage Dictionary of the English Language. </title> <publisher> Houghton Mi*in Company, </publisher> <address> Boston, MA, </address> <year> 1975. </year>
Reference-contexts: We intend this name to evoke a feeling of reuse of representations, as in the musical term reprise, "a repetition of a phrase or verse" <ref> [11] </ref>. 2 Whether something is viewed as a tool or as a building block for tools is, of course, a matter of perspective.
Reference: [12] <author> J.E.B. Moss and A.L. Wolf. </author> <title> Toward principles of inheritance and subtyping in programming languages. </title> <note> (available as AT&T Bell Laboratories Technical Memorandum 59113-881010-12TM), </note> <month> October </month> <year> 1988. </year>
Reference-contexts: If there also happens to be a subtype relationship between C and D, this fact can be determined from their inheritance relationship and from their definitions. The differences in the semantics of the inheritance and subtype relationships are discussed in detail by Moss and Wolf <ref> [12] </ref>. devoted to the representation of class ical. As shown in the figure, class takes a name as its first argument, the appropriate supertype as its second argument, a list of base classes as its third argument, and a list of member declarations as its fourth argument.
Reference: [13] <author> D.S. Rosenblum. </author> <title> App: An annotation preprocessor for creating self-checking C programs. </title> <note> (in preparation). </note>
Reference-contexts: Examples of tools that produce or make use of such decorations are test-coverage tools, performance analyzers, debuggers, and tools that produce embedded constraint-checking code from formal specifications (e.g., App <ref> [13] </ref>). A test-coverage tool, for example, might work as follows: Given a piece of code and some test input, the tool tries to make a determination of which branches would be taken in the code and which statements would be executed.
Reference: [14] <author> D.S. Rosenblum. </author> <title> A methodology for the design of Ada transformation tools in a DIANA environment. </title> <journal> IEEE Software, </journal> <volume> 2(2) </volume> <pages> 24-33, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: An additional benefit of this approach is that tools operating on the same C++ code can share the Reprise representation of that code, resulting in a significant savings in both space and time. Given our experience in defining, building, and using Ada programming and analysis tools (e.g., <ref> [5, 14, 15, 20] </ref>) based on the Diana [7] and Paris [8] representations, we believe that this approach to the development of tools for C++ is a viable one to consider. We begin in Section 2 by describing the model upon which the representation is based.
Reference: [15] <author> S. Sankar, D.S. Rosenblum, and R.B. Neff. </author> <title> An implementation of Anna. In Ada in Use: </title> <booktitle> Proceedings of the Ada International Conference, </booktitle> <pages> pages 285-296, </pages> <address> Paris, France, May 1985. </address> <publisher> Cambridge University Press. </publisher>
Reference-contexts: An additional benefit of this approach is that tools operating on the same C++ code can share the Reprise representation of that code, resulting in a significant savings in both space and time. Given our experience in defining, building, and using Ada programming and analysis tools (e.g., <ref> [5, 14, 15, 20] </ref>) based on the Diana [7] and Paris [8] representations, we believe that this approach to the development of tools for C++ is a viable one to consider. We begin in Section 2 by describing the model upon which the representation is based.
Reference: [16] <author> B. Stroustrup. </author> <title> Parameterized types for C++. </title> <booktitle> In Proceedings of the C++ Conference, </booktitle> <pages> pages 1-18, </pages> <address> Denver, CO, </address> <month> October </month> <year> 1988. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: We cannot expect to be able to anticipate the needs of all tools and, moreover, those needs may be in conflict. * Evolvability of representation. Although the language definition is stabilizing, there continue to be proposals for changes (e.g., for templates <ref> [16] </ref> and exception handling [10]). It is important, therefore, that the representation can be easily evolved along with the language. To facilitate this, the representation must capture more than just the surface-level, user-visible semantics.
Reference: [17] <author> R.N. Taylor, F.C. Belz, L.A. Clarke, L.J. Osterweil, R.W. Selby, J.C. Wileden, A.L. Wolf, and M. Young. </author> <title> Foundations for the Arcadia environment architecture. </title> <booktitle> In Proceedings of SIGSOFT '88: Third Symposium on Software Development Environments, </booktitle> <pages> pages 1-13, </pages> <address> Boston, MA, </address> <month> November </month> <year> 1988. </year> <booktitle> ACM SIGSOFT. Appears in ACM SIGSOFT Notes, </booktitle> <volume> Vol. 13, No. </volume> <pages> 5. </pages>
Reference-contexts: The Arcadia environment <ref> [17] </ref>, for example, has a full arsenal of concurrency analysis [2, 21], interface analysis [20], testing [4], and interpretation [22] tools, all based on such representations of Ada and Ada-like code. Reprise represents an application of this technology to C++ programming environments. <p> Acknowledgements The conceptual model underlying the design of Reprise was strongly influenced by Iris [3]. Iris is being used in the Arcadia software development environment research project <ref> [17] </ref> as the basis for representations of code written in a number of languages, including Ada, PIC/ADL [20], and GDL [5].
Reference: [18] <author> J.C. Wileden, L.A. Clarke, and A.L. Wolf. </author> <title> A comparative evaluation of object definition techniques for large prototype systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 670-699, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: To some extent, this is a question of how Reprise as an abstraction is actually implemented, since the choice of implementation technique can have a significant impact on this issue <ref> [18] </ref>. In general, however, we note that Reprise lends itself to an approach in which nodes and edges can be uniquely identified, and that those identities can be used as keys for auxiliary data structures.
Reference: [19] <author> A.L. Wolf. </author> <title> Abstraction mechanisms and persistence. </title> <booktitle> In Proceedings of the Fourth International Workshop on Persistent Object Systems, </booktitle> <month> September </month> <year> 1990. </year>
Reference-contexts: Reprise represents an application of this technology to C++ programming environments. To date, we have implemented the Reprise data structures as a library of C++ classes. The classes are built on top of a persistence library called Persi <ref> [19] </ref>, which supports long-term storage of C++ objects and shared concurrent access to those objects. We have built an enhanced version of cfront called rfront, which generates pre-semantic Reprise graphs from C++ source code.
Reference: [20] <author> A.L. Wolf, L.A. Clarke, and J.C. Wileden. </author> <title> The AdaPIC Tool Set: Supporting interface control and analysis throughout the software development process. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-15(3):250-263, </volume> <month> March </month> <year> 1989. </year>
Reference-contexts: An additional benefit of this approach is that tools operating on the same C++ code can share the Reprise representation of that code, resulting in a significant savings in both space and time. Given our experience in defining, building, and using Ada programming and analysis tools (e.g., <ref> [5, 14, 15, 20] </ref>) based on the Diana [7] and Paris [8] representations, we believe that this approach to the development of tools for C++ is a viable one to consider. We begin in Section 2 by describing the model upon which the representation is based. <p> The Arcadia environment [17], for example, has a full arsenal of concurrency analysis [2, 21], interface analysis <ref> [20] </ref>, testing [4], and interpretation [22] tools, all based on such representations of Ada and Ada-like code. Reprise represents an application of this technology to C++ programming environments. To date, we have implemented the Reprise data structures as a library of C++ classes. <p> Acknowledgements The conceptual model underlying the design of Reprise was strongly influenced by Iris [3]. Iris is being used in the Arcadia software development environment research project [17] as the basis for representations of code written in a number of languages, including Ada, PIC/ADL <ref> [20] </ref>, and GDL [5].
Reference: [21] <author> M. Young, R.N. Taylor, K. Forester, and D. Brodbeck. </author> <title> Integrated concurrency analysis in a software development environment. </title> <booktitle> In Proceedings of the SIGSOFT '89 Third Symposium on Software Testing, Analysis, and Verification (TAV3), </booktitle> <pages> pages 200-209, </pages> <address> Key West, FL, </address> <month> December </month> <year> 1989. </year> <booktitle> ACM SIGSOFT. </booktitle>
Reference-contexts: The Arcadia environment [17], for example, has a full arsenal of concurrency analysis <ref> [2, 21] </ref>, interface analysis [20], testing [4], and interpretation [22] tools, all based on such representations of Ada and Ada-like code. Reprise represents an application of this technology to C++ programming environments. To date, we have implemented the Reprise data structures as a library of C++ classes.
Reference: [22] <author> S.J. Zeil and E.C. Epp. </author> <title> Interpretation in a tool-fragment environment. </title> <booktitle> In Proceedings of the 10th International Conference on Software Engineering, </booktitle> <pages> pages 241-248, </pages> <address> Singapore, </address> <month> April </month> <year> 1988. </year> <booktitle> IEEE Computer Society. 134 C++ Conference USENIX Association </booktitle>
Reference-contexts: The Arcadia environment [17], for example, has a full arsenal of concurrency analysis [2, 21], interface analysis [20], testing [4], and interpretation <ref> [22] </ref> tools, all based on such representations of Ada and Ada-like code. Reprise represents an application of this technology to C++ programming environments. To date, we have implemented the Reprise data structures as a library of C++ classes.
References-found: 22

