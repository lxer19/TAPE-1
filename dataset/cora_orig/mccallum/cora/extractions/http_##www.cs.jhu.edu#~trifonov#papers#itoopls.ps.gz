URL: http://www.cs.jhu.edu/~trifonov/papers/itoopls.ps.gz
Refering-URL: http://www.cs.jhu.edu/~trifonov/papers/
Root-URL: http://www.cs.jhu.edu
Email: eifrig@cs.jhu.edu  scott@cs.jhu.edu  trifonov@cs.jhu.edu  amy@cs.jhu.edu  
Title: An Interpretation of Typed OOP in a Language with State  
Author: JONATHAN EIFRIG SCOTT SMITH VALERY TRIFONOV AMY ZWARICO Editor: Ian A. Mason, Martin Odersky 
Keyword: Object-oriented programming, type systems, state in programming  
Date: Received May 1, 1991  
Affiliation: Department of Computer Science, The Johns Hopkins University  
Note: 1-41 c Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.  
Abstract: In this paper we give semantics to Loop, an expressive typed object-oriented programming language with updatable instance variables. Loop has a rich type system that allows for the typing of methods operating over an open-ended "self" type. We prove the type system given is sound; i.e., well-typed programs do not experience "message not understood" errors. The semantics of Loop is given by a translation into a state-based language, Soop, that contains reference cells, records, and a form of F-bounded polymorphic type. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Abadi and L. Cardelli. </author> <title> A semantics of object types. </title> <booktitle> In Proceedings of the Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 332-341, </pages> <year> 1994. </year>
Reference-contexts: So, for practical reasons we now find it more fruitful to pursue a translative approach to meaning. The risk is the possibility that a translation will miss some key idea; we see no evidence for this as of yet but that does not rule out the possibility. See <ref> [1] </ref> for an alternative, primitive theory of object execution and typing. Definition 5 A Loop program e becomes stuck if its corresponding Soop translation in empty memory h;; [[e]]i gets stuck.
Reference: 2. <author> R. Amadio and L. Cardelli. </author> <title> Subtyping recursive types. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: We focus on the three most common varieties. First and second, object folding and unfolding rules are derivable from (Fix) and (Fold), Obj (t)(M [Obj (t)M=t]) Obj (t)M . Third, the (Fold) and (Fix) rules allow for an "inductive" comparison of object types in the spirit of <ref> [2] </ref> via the following derived rule: (ObjFix) C k t PreObj M 0 [Obj (t 0 )M 0 =t 0 ] ` PreObj M PreObj M 0 [Obj (t 0 )M 0 =t 0 ] C ` Obj (t)M Obj (t 0 )M 0 Using this derived rule, o ab o <p> Thus we establish that a recursive type is equivalent to its unrolling with respect to subtyping; this relation is weaker than the type equivalence defined by Amadio and Cardelli in <ref> [2] </ref>, and as a result some judgements, provable in the system of [2], are not provable in Soop (e.g. C ` t: Nat -&gt; t t: Nat -&gt; Nat -&gt; t). However (fix) is stronger than the rule for subtyping recursive types of [2] () C ` t 0 : o <p> Thus we establish that a recursive type is equivalent to its unrolling with respect to subtyping; this relation is weaker than the type equivalence defined by Amadio and Cardelli in <ref> [2] </ref>, and as a result some judgements, provable in the system of [2], are not provable in Soop (e.g. C ` t: Nat -&gt; t t: Nat -&gt; Nat -&gt; t). However (fix) is stronger than the rule for subtyping recursive types of [2] () C ` t 0 : o 0 t: o In fact, () is a meta-rule in the Soop <p> equivalence defined by Amadio and Cardelli in <ref> [2] </ref>, and as a result some judgements, provable in the system of [2], are not provable in Soop (e.g. C ` t: Nat -&gt; t t: Nat -&gt; Nat -&gt; t). However (fix) is stronger than the rule for subtyping recursive types of [2] () C ` t 0 : o 0 t: o In fact, () is a meta-rule in the Soop type system: each valid subtyping derivation using () can be transformed by (1) replacing t by t: o in the derivation of the antecedent of (), producing a proof of Ckt <p> The type system of Soop offers recursive types with subtyping weaker than the one defined in <ref> [2] </ref> but stronger than that of [3]. The novel (fix) rule may be of independent interest. The presentation also differs from others because type generalization and instantiation is implicit as in ML, not explicit as in System F.
Reference: 3. <author> K. Bruce. </author> <title> Safe type checking in a statically-typed object-oriented programming language. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285-298, </pages> <year> 1993. </year>
Reference-contexts: To frame the problem we desire a static type system that preserves all of the classic features of (untyped) class-based OOP, including treatment of two particularly difficult issues: binary methods and object subsumption. Significant steps have recently been made toward solving this problem [10], [7], [4], <ref> [3] </ref>, [22]. One major gap in the aforementioned works is they take a functional view of objects, whereas objects are inherently state-carrying entities. What we accomplish here is a provably sound interpretation of a typed imperative OOP language. <p> This principle is currently at the core of most of the commonly used typed object-oriented programming languages, including C++ and Object Pascal. However, problems arise in the presence of methods that take and/or return objects of "self-type," the type of the object containing the method itself [10], <ref> [3] </ref>. There are two common views of how "self" should be treated when typing a class expression. In one view, its type is fixed and thus denotes an object of the current class only. <p> Ghelli presents another solution to the fixed/open "self" problem that always preserves subtyping between subclass and superclass objects, but at the expense of requiring redefinition of a method whenever the type changes, and doing dynamic dispatching based on the type information at run-time [15]. See [10], <ref> [3] </ref> for more discussion of how the open-ended view of "self" relates to other approaches in the literature. <p> The type system of Soop offers recursive types with subtyping weaker than the one defined in [2] but stronger than that of <ref> [3] </ref>. The novel (fix) rule may be of independent interest. The presentation also differs from others because type generalization and instantiation is implicit as in ML, not explicit as in System F. <p> The proof of subject reduction for Soop is involved, but it may be that no significantly simpler form exists. Bruce and van Gent [6] have defined an imperative OOP language, TOIL, which is an imperative extension of Bruce's TOOPL language <ref> [3] </ref>. TOOPL/TOIL and Loop are closely related, since they are all ultimately based on F-bounded polymorphism; here we outline some differences. We interpret Loop via translation to Soop, while TOIL is given semantics directly.
Reference: 4. <author> K. Bruce and J. Mitchell. </author> <title> PER models of subtyping, recursive types and higher-order poly-morphism. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 316-327, </pages> <year> 1992. </year>
Reference-contexts: To frame the problem we desire a static type system that preserves all of the classic features of (untyped) class-based OOP, including treatment of two particularly difficult issues: binary methods and object subsumption. Significant steps have recently been made toward solving this problem [10], [7], <ref> [4] </ref>, [3], [22]. One major gap in the aforementioned works is they take a functional view of objects, whereas objects are inherently state-carrying entities. What we accomplish here is a provably sound interpretation of a typed imperative OOP language.
Reference: 5. <author> K. B. Bruce, J. Crabtree, T. P. Murtagh, R. van Gent, A. Dimock, and R. Muller. </author> <title> Safe and decidable type checking in an object-oriented language. </title> <booktitle> In OOPSLA '93 Conference Proceedings, </booktitle> <year> 1993. </year>
Reference-contexts: However, an explicitly-typed version of Loop that is closely related to the language of this paper is proven to have a decidable type-checking algorithm in [13]. A decidability proof for type-checking a variant of TOOPL is presented in <ref> [5] </ref>. Acknowledgments We would like to thank the anonymous referees for helpful comments, in particular motivating us to come up with a cleaner translation from Loop to Soop, and to extend the Soop type system with stronger rules.
Reference: 6. <author> Kim B. Bruce and Robert van Gent. </author> <title> TOIL: A new type-safe object-oriented imperative language. </title> <type> Technical report, </type> <institution> Williams College, </institution> <year> 1993. </year>
Reference-contexts: The presentation also differs from others because type generalization and instantiation is implicit as in ML, not explicit as in System F. The proof of subject reduction for Soop is involved, but it may be that no significantly simpler form exists. Bruce and van Gent <ref> [6] </ref> have defined an imperative OOP language, TOIL, which is an imperative extension of Bruce's TOOPL language [3]. TOOPL/TOIL and Loop are closely related, since they are all ultimately based on F-bounded polymorphism; here we outline some differences.
Reference: 7. <author> P. Canning, W. Cook, W. Hill, J. Mitchell, and W. Olthoff. </author> <title> F-bounded polymorphism for object-oriented programming. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference-contexts: To frame the problem we desire a static type system that preserves all of the classic features of (untyped) class-based OOP, including treatment of two particularly difficult issues: binary methods and object subsumption. Significant steps have recently been made toward solving this problem [10], <ref> [7] </ref>, [4], [3], [22]. One major gap in the aforementioned works is they take a functional view of objects, whereas objects are inherently state-carrying entities. What we accomplish here is a provably sound interpretation of a typed imperative OOP language. <p> The type expression 8 [t i i ]: ' binds the type variables t i in each of their upper bounds i as well as in the body '; this allows a form of F-bounded polymorphism <ref> [7] </ref>. A recursive type is of the form t: o ; the type variable t is bound in o . By convention 8 and have lower precedence than the arrow and Ref. <p> Proof: Suppose ;; ; ` e:o . By Lemma 19, ;; ; ` [[e]]:[[o]] is then a provable Soop judgement, and by Theorem 2 h;; [[e]]i does not get stuck. 5. Discussion We have shown here how the ideas of <ref> [7] </ref> used to model typed functional OOP can be applied to Loop, a state-based object-oriented programming language. The 39 problem of OOP typing cannot be said to be completely solved, however.
Reference: 8. <author> L. Cardelli. </author> <title> A semantics of multiple inheritance. In Semantics of Data Types, </title> <booktitle> volume 173 of Lecture notes in Computer Science, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: C k t PreObj M denotes the constraint system C extended by mapping t to PreObj M . Some basic notions of subtyping are now reviewed <ref> [8] </ref>, with special attention to issues that arise in Loop subtyping. The subtype relation on types o o 0 at first approximation corresponds to subset. <p> There is an analogous derived rule for recursive types in Soop, and in Section 3 the relationship between this rule and other rules in the literature will be discussed in more detail. In the classic function subtyping rule (Fun) from <ref> [8] </ref>, o 1 and o 0 1 are reversed since a "smaller" input o 0 1 leads to "more" type-correct outputs possible. <p> This system is an extension of the standard record subtyping <ref> [8] </ref> with recursive and F-bounded polymorphic types. Soop is not a second order calculus (there are no type abstractions and applications), therefore we use subtyping to instantiate the type of a polymorphic function.
Reference: 9. <author> W. Cook and J. Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In OOPSLA '89 Proceedings, </booktitle> <pages> pages 433-443, </pages> <year> 1989. </year>
Reference-contexts: We develop independent translations of Loop terms and types. The translation of terms interprets objects as a form of record and classes as object generators as in <ref> [9] </ref>, [18]. The main difference is use of a special memory-based "weak" fixed-point combinator in place of the normal Y . In a functional world the two are equivalent, but not in the presence of state. <p> Semantics of Loop terms The semantics of Loop terms is defined via a translation into Soop terms; this translation is given in Figure 14. In many encodings of object-oriented languages <ref> [9] </ref>, [18] an object is defined as a record formed by taking a fixed point of a class function, a function mapping records to records. This results in a recursive record, and the methods of the object|fields of the record|gain access to its "self" by unrolling the fixed point expression.
Reference: 10. <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: To frame the problem we desire a static type system that preserves all of the classic features of (untyped) class-based OOP, including treatment of two particularly difficult issues: binary methods and object subsumption. Significant steps have recently been made toward solving this problem <ref> [10] </ref>, [7], [4], [3], [22]. One major gap in the aforementioned works is they take a functional view of objects, whereas objects are inherently state-carrying entities. What we accomplish here is a provably sound interpretation of a typed imperative OOP language. <p> The main improvement is Loop's richer type system, which allows for typing of class methods that take and return objects of an open-ended "self-type." We base our approach on the ideas * Partially supported by NSF grant CCR-9109070 ** Partially supported by AFOSR grant F49620-93-1-0169 2 of <ref> [10] </ref>. In addition, we show how these notions may be combined with subtype-based inheritance, which is sometimes more powerful. <p> The most important feature of the type translation is the use of F-bounded polymorphism in Soop to interpret the open-ended notion of "self" type needed for the class types of Loop. This means we obtain the proper typings of methods that take objects of "self" type as argument <ref> [10] </ref>. Section 2 presents the syntax and type rules for Loop, and concludes with an example that both illustrates how to program in Loop, and shows some of the problems involved in typing binary methods and the competing "fixed-self" and "open-self" solutions. <p> This principle is currently at the core of most of the commonly used typed object-oriented programming languages, including C++ and Object Pascal. However, problems arise in the presence of methods that take and/or return objects of "self-type," the type of the object containing the method itself <ref> [10] </ref>, [3]. There are two common views of how "self" should be treated when typing a class expression. In one view, its type is fixed and thus denotes an object of the current class only. <p> In purely functional languages this encoding produces good results, but the situation changes with the introduction of effects and call-by-value semantics. The associated fixed-point operator is then only well-defined on functionals, but as pointed out for instance in <ref> [10] </ref>, classes do not correspond to functionals. Several solutions with various limitations have been proposed. <p> Ghelli presents another solution to the fixed/open "self" problem that always preserves subtyping between subclass and superclass objects, but at the expense of requiring redefinition of a method whenever the type changes, and doing dynamic dispatching based on the type information at run-time [15]. See <ref> [10] </ref>, [3] for more discussion of how the open-ended view of "self" relates to other approaches in the literature.
Reference: 11. <author> E. Crank and M. Felleisen. </author> <title> Parameter-passing and the lambda calculus. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: Type inference in Soop seems unlikely, considering the problems in similar systems [23]; the possibility of having it in versions of the language is the topic of ongoing research. 3.1. Operational Semantics of Soop We present semantics of Soop in the general framework of [14], [21], <ref> [11] </ref>, [26]. The operational interpreter of the language is specified by representing the notion of computation as a binary relation between Soop terms in memory environments. As in [26] the memory is treated as a function from variables to values.
Reference: 12. <author> J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico. </author> <title> A simple interpretation of OOP in a language with state. </title> <type> Technical Report YALEU/DCS/RR-968, </type> <institution> Yale University, </institution> <year> 1993. </year>
Reference-contexts: Section 4 contains the translation of Loop into Soop and a proof of the soundness of this translation, yielding the fact that typed Loop programs do not experience "message not understood" errors. This paper is a significantly extended version of <ref> [12] </ref>. 2. The Loop Language and Type System We begin our discussion by defining a representative object-oriented programming language, Loop (Little Object-Oriented Programming language). Loop is an extension of call-by-value PCF, with added syntax for classes, objects, object creation, message send, and instance variable access.
Reference: 13. <author> J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico. </author> <title> Application of OOP type theory: State, decidability, integration. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <year> 1994. </year>
Reference-contexts: Also, the question of 40 decidable type checking or decidable type inference is not addressed here. However, an explicitly-typed version of Loop that is closely related to the language of this paper is proven to have a decidable type-checking algorithm in <ref> [13] </ref>. A decidability proof for type-checking a variant of TOOPL is presented in [5]. Acknowledgments We would like to thank the anonymous referees for helpful comments, in particular motivating us to come up with a cleaner translation from Loop to Soop, and to extend the Soop type system with stronger rules.
Reference: 14. <author> M. Felleisen and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 102 </volume> <pages> 235-271, </pages> <year> 1992. </year>
Reference-contexts: Type inference in Soop seems unlikely, considering the problems in similar systems [23]; the possibility of having it in versions of the language is the topic of ongoing research. 3.1. Operational Semantics of Soop We present semantics of Soop in the general framework of <ref> [14] </ref>, [21], [11], [26]. The operational interpreter of the language is specified by representing the notion of computation as a binary relation between Soop terms in memory environments. As in [26] the memory is treated as a function from variables to values.
Reference: 15. <author> Giorgio Ghelli. </author> <title> A static type system for message passing. </title> <booktitle> In Proc. OOPSLA, </booktitle> <pages> pages 129-145, </pages> <year> 1991. </year> <month> 41 </month>
Reference-contexts: In particular, it is possible to have positive occurrences of SelfType be open-ended and negative occurrences fixed, preserving some open-endedness and at the same time conforming to the subclasses-generate-subtypes principle. The terms covariance and contravariance are sometimes used in the literature when discussing this topic <ref> [15] </ref>. <p> Ghelli presents another solution to the fixed/open "self" problem that always preserves subtyping between subclass and superclass objects, but at the expense of requiring redefinition of a method whenever the type changes, and doing dynamic dispatching based on the type information at run-time <ref> [15] </ref>. See [10], [3] for more discussion of how the open-ended view of "self" relates to other approaches in the literature.
Reference: 16. <author> C. Gunter and J. Mitchell. </author> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language Design. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference: 17. <author> A. V. Hense. </author> <title> Wrapper semantics of an object-oriented programming language with state. </title> <booktitle> In Proceedings of the International Conference on Theoretical Aspects of Computer Software, volume 526 of Lecture notes in Computer Science, </booktitle> <pages> pages 548-567. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: support mutable instance variables belonging to objects|in the straightforward implementations their allocation takes place either "too early" (they are shared by all objects of the class) or "too late" (new cells are being allocated at each access to the object). 32 Two approaches to solving this problem are discussed in <ref> [17] </ref>; the one for which the author gives a denotational semantics is based on the interpretation of the fixed points of class functions as state transformers.
Reference: 18. <author> Samuel N. Kamin and Uday S. Reddy. </author> <title> Two semantic models of object-oriented languages. </title> <editor> In Carl A. Gunter and John C. Mitchell, editors, </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming, chapter 13, </booktitle> <pages> pages 464-495. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: We develop independent translations of Loop terms and types. The translation of terms interprets objects as a form of record and classes as object generators as in [9], <ref> [18] </ref>. The main difference is use of a special memory-based "weak" fixed-point combinator in place of the normal Y . In a functional world the two are equivalent, but not in the presence of state. <p> Semantics of Loop terms The semantics of Loop terms is defined via a translation into Soop terms; this translation is given in Figure 14. In many encodings of object-oriented languages [9], <ref> [18] </ref> an object is defined as a record formed by taking a fixed point of a class function, a function mapping records to records. This results in a recursive record, and the methods of the object|fields of the record|gain access to its "self" by unrolling the fixed point expression.
Reference: 19. <author> P. J. Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> Computer Journal, </journal> <volume> 6 </volume> <pages> 308-320, </pages> <year> 1964. </year>
Reference-contexts: Our approach allows using self in instance variable initializations by defining a "weak" fixed-point combinator (a fixed-point operator on functionals, i.e. expressions of the form x: y: e [21]) in terms of mutable cells in the spirit of Landin <ref> [19] </ref>. A first approximation to this is Y r = f: let r = ref null in (set (r; f (r)); ! r); where null is some "dummy" initial value.
Reference: 20. <author> D. B. MacQueen, G. Plotkin, and R. Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> <volume> 71 </volume> <pages> 95-130, </pages> <year> 1986. </year>
Reference-contexts: Soop is not a second order calculus (there are no type abstractions and applications), therefore we use subtyping to instantiate the type of a polymorphic function. The rules for subtyping polymorphic types reflect the view that the set of values (ideal <ref> [20] </ref>) corresponding to a polymorphic type is the intersection of the sets corresponding to all of its instances. <p> The subtyping rules for recursive types are (fold) and (fix). In the latter, o must be contractive in t (in the sense of <ref> [20] </ref>), written o # t; in our system this means that o cannot be of the form t 1 : : : : t m : t for any m 0.
Reference: 21. <author> I. A. Mason and C. L. Talcott. </author> <title> Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 287-327, </pages> <year> 1991. </year>
Reference-contexts: Type inference in Soop seems unlikely, considering the problems in similar systems [23]; the possibility of having it in versions of the language is the topic of ongoing research. 3.1. Operational Semantics of Soop We present semantics of Soop in the general framework of [14], <ref> [21] </ref>, [11], [26]. The operational interpreter of the language is specified by representing the notion of computation as a binary relation between Soop terms in memory environments. As in [26] the memory is treated as a function from variables to values. <p> See the end of Section 2.1 for an implementation of updateable methods in Loop. Our approach allows using self in instance variable initializations by defining a "weak" fixed-point combinator (a fixed-point operator on functionals, i.e. expressions of the form x: y: e <ref> [21] </ref>) in terms of mutable cells in the spirit of Landin [19]. A first approximation to this is Y r = f: let r = ref null in (set (r; f (r)); ! r); where null is some "dummy" initial value. <p> It is worth noting that Y 0 r (f ) is the fixed point of f when f is a functional, for its application evaluates without side effects <ref> [21] </ref>. Let us now examine the encoding of Figure 14 more carefully. For uniformity, we interpret classes as functions from frozen records -- -&gt; - : : : to frozen records, and objects as frozen records.
Reference: 22. <author> J. Mitchell. </author> <title> Towards a typed foundation for method specialization and inheritance. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1990. </year>
Reference-contexts: To frame the problem we desire a static type system that preserves all of the classic features of (untyped) class-based OOP, including treatment of two particularly difficult issues: binary methods and object subsumption. Significant steps have recently been made toward solving this problem [10], [7], [4], [3], <ref> [22] </ref>. One major gap in the aforementioned works is they take a functional view of objects, whereas objects are inherently state-carrying entities. What we accomplish here is a provably sound interpretation of a typed imperative OOP language.
Reference: 23. <author> B. Pierce. </author> <title> Bounded quantification is undecidable. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 305-315, </pages> <year> 1992. </year>
Reference-contexts: Rule (gen) provides for e.g. comparing two polymorphic types; the intuition behind the rule is that a type ' is a subtype of a polymorphic type o if ' is a subtype of all instances of o . The standard rule for (F-)bounded quantification <ref> [23] </ref> (S-All) C ` 8 [t 1 ]: o 1 8 [t 2 ]: o 2 14 (refl) C ` o o (trans) C ` o o 0 ; o 0 o 00 (var) C ` t C (t) C ` o 0 2 1 -&gt; o 0 (record) C ` <p> Type inference in Soop seems unlikely, considering the problems in similar systems <ref> [23] </ref>; the possibility of having it in versions of the language is the topic of ongoing research. 3.1. Operational Semantics of Soop We present semantics of Soop in the general framework of [14], [21], [11], [26].
Reference: 24. <author> Didier Remy. </author> <title> Type inference for records in a natural extension of ML. </title> <editor> In Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects Of Object-Oriented Programming. Types, Semantics and Language Design. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Loop is monomorphic, even though it is translated to a polymorphic language. It would not be difficult to lift the F-bounded polymorphism of Soop into Loop. Classes are not fully "first-class citizens" in Loop; to achieve this, some notion of extensible record would need to be added to Soop <ref> [24] </ref>. There is no analogue here to the "friend" functions or "private" class variables of C++. Also, the question of 40 decidable type checking or decidable type inference is not addressed here.
Reference: 25. <author> J.P. Seldin. </author> <title> A sequent calculus for type assignment. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 42 </volume> <pages> 11-28, </pages> <year> 1977. </year>
Reference-contexts: The first implies that the type of a computation state is preserved by the single-step computation relation; together with the second this means that the stuck states are unreachable from a typable initial state. In comparison with proofs of subject reduction for the -calculus <ref> [25] </ref> and ML-style polymorphic languages [26], the proof for the Soop type system is complicated by the rich subtyping relation.
Reference: 26. <author> A. Wright and M. Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91-160, </type> <institution> Rice University Department of Computer Science, </institution> <year> 1991. </year> <note> To appear in Information and Computation. </note>
Reference-contexts: Type inference in Soop seems unlikely, considering the problems in similar systems [23]; the possibility of having it in versions of the language is the topic of ongoing research. 3.1. Operational Semantics of Soop We present semantics of Soop in the general framework of [14], [21], [11], <ref> [26] </ref>. The operational interpreter of the language is specified by representing the notion of computation as a binary relation between Soop terms in memory environments. As in [26] the memory is treated as a function from variables to values. <p> Operational Semantics of Soop We present semantics of Soop in the general framework of [14], [21], [11], <ref> [26] </ref>. The operational interpreter of the language is specified by representing the notion of computation as a binary relation between Soop terms in memory environments. As in [26] the memory is treated as a function from variables to values. We use the notation [ x 7! v ] for the map defined only on x with value v, and f kg for the functional extension of f by g. <p> Lemma 2 (Deterministic Computation) 7! 1 defines a partial function on the closed computation states. Corollary 1 A computation state computes to a value, or diverges, or gets stuck. 3.2. Soundness of the Soop Type System Following <ref> [26] </ref> we establish soundness of the type system of Soop with respect to the computation relations by proving that a subject reduction property holds for this type system, and that the stuck states cannot be given types. <p> The first implies that the type of a computation state is preserved by the single-step computation relation; together with the second this means that the stuck states are unreachable from a typable initial state. In comparison with proofs of subject reduction for the -calculus [25] and ML-style polymorphic languages <ref> [26] </ref>, the proof for the Soop type system is complicated by the rich subtyping relation. The only analog of subtyping in the ML type system is that an expression of a polymorphic type scheme is also of each type produced by any instantiation of the type variables of the scheme.
References-found: 26

