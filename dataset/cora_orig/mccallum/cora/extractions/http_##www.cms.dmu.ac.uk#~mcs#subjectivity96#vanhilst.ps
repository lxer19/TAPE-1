URL: http://www.cms.dmu.ac.uk/~mcs/subjectivity96/vanhilst.ps
Refering-URL: http://www.cms.dmu.ac.uk/~mcs/subjectivity96/papers.html
Root-URL: 
Title: Using Parameterized Types for Subject-Oriented Programming  
Author: Michael VanHilst 
Date: September 1, 1995  
Abstract: This paper presents a method to achieve subject-oriented programming in C++ using the standard parameterized type mechanisms of the language. The central idea is to parameterize references to types that could potentially be affected by subject composition. Subjects are formed of groups of objects and views, where the views are implemented as mixins. The type parameter binding is used to specify both the types and their compositions. Composition and type checking occurs when the source-code is compiled. This method of subject-oriented programming has many advantages including static type checking and instance-specific composition.
Abstract-found: 1
Intro-found: 1
Reference: [Cop92] <author> James Coplien. </author> <title> Advanced C Plus Plus Programming Styles and Idioms. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: When an object is merged with another its type is extended. Normal object-oriented programming does not allow objects to be extended in place because doing so changes their type. Some approaches to this problem include the use of prototypes [UCCH91], complicated pointer mechanisms (or exemplars) <ref> [Cop92, Won93] </ref>, and mechanisms that create meta-level interfaces on classes (Ossher,Mirra) [HOSU94]. We solve the problem by parameterizing references to types. The actual types are specified separately in a high level description that also specifies the composition.
Reference: [HO93] <author> William Harrison and Harold Ossher. </author> <title> Subject-oriented programming (a critique of pure objects). </title> <booktitle> In Proceedings of the 1993 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 411-428, </pages> <year> 1993. </year>
Reference-contexts: But their proposal was limited in detail and did not consider parameterizing an entire application. Their Agora language poses interesting possibilities for dynamic mixin composition [SCD + 93]. The work of Ossher and Harrison <ref> [HO93, HOSU94] </ref> is parallel to our own. They have a source-code converter, called a "subjectifier," that transforms C++ source code to work with an external module for method dispatch and the management of instance variables.
Reference: [HOSU94] <author> William Harrison, Harold Ossher, Randall B. Smith, and David Ungar. </author> <booktitle> Subjectivity in object-ooriented systems workshop summary. In Addendum to the 9 Proceedings of the 1993 ACM Conference on Object-Oriented Programming Sys--tems, Languages and Applications, </booktitle> <pages> pages 131-136, </pages> <year> 1994. </year>
Reference-contexts: Normal object-oriented programming does not allow objects to be extended in place because doing so changes their type. Some approaches to this problem include the use of prototypes [UCCH91], complicated pointer mechanisms (or exemplars) [Cop92, Won93], and mechanisms that create meta-level interfaces on classes (Ossher,Mirra) <ref> [HOSU94] </ref>. We solve the problem by parameterizing references to types. The actual types are specified separately in a high level description that also specifies the composition. <p> Similarly, the extensive support for 8 parameterized types in Eiffel [Mey92] makes it likely that this technique will also work there, although differences in the instantiation mechanism may prove to be an issue. 5 Related Work Lucas and Boyen <ref> [HOSU94] </ref> proposed the idea of using mixins to implement views for subject-oriented programming. But their proposal was limited in detail and did not consider parameterizing an entire application. Their Agora language poses interesting possibilities for dynamic mixin composition [SCD + 93]. <p> But their proposal was limited in detail and did not consider parameterizing an entire application. Their Agora language poses interesting possibilities for dynamic mixin composition [SCD + 93]. The work of Ossher and Harrison <ref> [HO93, HOSU94] </ref> is parallel to our own. They have a source-code converter, called a "subjectifier," that transforms C++ source code to work with an external module for method dispatch and the management of instance variables.
Reference: [LR88] <author> Karl J. Lieberherr and Arthur J. Riel. </author> <title> Demeter: A CASE study of software growth through parameterized classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 8-22, </pages> <month> August/September </month> <year> 1988. </year>
Reference-contexts: However, their system is dependent on the system-specific dispatch module, and, to date, only supports class-level composition. This latter restriction, we feel, severely effects its ability to support extension-by-addition [HO92]. In our small example, Labels and Sets are both involved in several different compositions. The Demeter system of Lieberherr <ref> [LR88, LX93] </ref> is also very similar to the work presented here. Our series of typedef statements is analogous to Demeter's class dictionary. But the class dictionary uses a much richer language and is used to implement the details of each class, as well as define their composition.
Reference: [LX93] <author> Karl J. Lieberherr and Cun Xiao. </author> <title> Object-oriented software evolution. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(4) </volume> <pages> 313-343, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: However, their system is dependent on the system-specific dispatch module, and, to date, only supports class-level composition. This latter restriction, we feel, severely effects its ability to support extension-by-addition [HO92]. In our small example, Labels and Sets are both involved in several different compositions. The Demeter system of Lieberherr <ref> [LR88, LX93] </ref> is also very similar to the work presented here. Our series of typedef statements is analogous to Demeter's class dictionary. But the class dictionary uses a much richer language and is used to implement the details of each class, as well as define their composition.
Reference: [Mey92] <author> Bertrand Meyer. </author> <title> Eiffel: the Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Seidewitz's paper on how to do generics and mixins in Ada [Sei92, Sei94] leads us to believe that this method of doing subject-oriented programming might also be possible in Ada95. Similarly, the extensive support for 8 parameterized types in Eiffel <ref> [Mey92] </ref> makes it likely that this technique will also work there, although differences in the instantiation mechanism may prove to be an issue. 5 Related Work Lucas and Boyen [HOSU94] proposed the idea of using mixins to implement views for subject-oriented programming.
Reference: [SCD + 93] <author> Patrick Steyaert, Win Codented, Theo D'Hondt, Koen De Hondt, Carine Lucas, and Van Linberghen Marc. </author> <title> Nested mixin-methods in agora. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 197-219, </pages> <year> 1993. </year>
Reference-contexts: But their proposal was limited in detail and did not consider parameterizing an entire application. Their Agora language poses interesting possibilities for dynamic mixin composition <ref> [SCD + 93] </ref>. The work of Ossher and Harrison [HO93, HOSU94] is parallel to our own. They have a source-code converter, called a "subjectifier," that transforms C++ source code to work with an external module for method dispatch and the management of instance variables.
Reference: [Sei92] <author> Ed Seidewitz. </author> <title> Object-oriented programming with mixins in ada. </title> <journal> Ada letters, </journal> <pages> pages 76-90, </pages> <month> March-April </month> <year> 1992. </year>
Reference-contexts: We have not explored how our techniques would interact with any database packages. Perhaps most significantly, we have not explored how our techniques would generalize to other languages. Seidewitz's paper on how to do generics and mixins in Ada <ref> [Sei92, Sei94] </ref> leads us to believe that this method of doing subject-oriented programming might also be possible in Ada95.
Reference: [Sei94] <author> Ed Seidewitz. </author> <title> Genericity versus inheritance reconsidered: Self-reference using generics. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 153-163, </pages> <year> 1994. </year>
Reference-contexts: We have not explored how our techniques would interact with any database packages. Perhaps most significantly, we have not explored how our techniques would generalize to other languages. Seidewitz's paper on how to do generics and mixins in Ada <ref> [Sei92, Sei94] </ref> leads us to believe that this method of doing subject-oriented programming might also be possible in Ada95.
Reference: [UCCH91] <author> David Ungar, Craig Chambers, Bay-Wei Chang, and Urs Holzle. </author> <title> Organizing programs without classes. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 4(3) </volume> <pages> 223-242, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: When an object is merged with another its type is extended. Normal object-oriented programming does not allow objects to be extended in place because doing so changes their type. Some approaches to this problem include the use of prototypes <ref> [UCCH91] </ref>, complicated pointer mechanisms (or exemplars) [Cop92, Won93], and mechanisms that create meta-level interfaces on classes (Ossher,Mirra) [HOSU94]. We solve the problem by parameterizing references to types. The actual types are specified separately in a high level description that also specifies the composition.
Reference: [Won93] <author> William Wong. </author> <title> Plug and Play Programming and Object-Oriented Construction Kit. M and T Books, </title> <booktitle> 1993. </booktitle> <pages> 10 </pages>
Reference-contexts: When an object is merged with another its type is extended. Normal object-oriented programming does not allow objects to be extended in place because doing so changes their type. Some approaches to this problem include the use of prototypes [UCCH91], complicated pointer mechanisms (or exemplars) <ref> [Cop92, Won93] </ref>, and mechanisms that create meta-level interfaces on classes (Ossher,Mirra) [HOSU94]. We solve the problem by parameterizing references to types. The actual types are specified separately in a high level description that also specifies the composition.
References-found: 11

