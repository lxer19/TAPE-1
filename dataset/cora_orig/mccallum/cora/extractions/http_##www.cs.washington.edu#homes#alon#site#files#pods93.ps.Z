URL: http://www.cs.washington.edu/homes/alon/site/files/pods93.ps.Z
Refering-URL: http://www.cs.washington.edu/homes/alon/site/PaperAbstractPresentation_bib12.html
Root-URL: 
Email: levy@cs.stanford.edu  mumick@research.att.com  sagiv@cs.huji.ac.il  oshmu@cs.technion.ac.il  
Title: Equivalence, Query-Reachability, and Satisfiability in Datalog Extensions Extended Abstract  
Author: Alon Y. Levy Inderpal Singh Mumick Yehoshua Sagiv Oded Shmueli 
Affiliation: Stanford University  AT&T Bell Laboratories  Hebrew University  Technion|Israel Institute of Technology  
Abstract: We consider the problems of equivalence, satisfiability and query-reachability for datalog programs with negation and dense-order constraints. These problems are important for optimizing datalog programs. We show that both query-reachability and satisfiability are decidable for programs with stratified negation provided that negation is applied only to EDB predicates or that all EDB predicates are unary. In the latter case, we show that equivalence is also decidable. The algorithms we present are also used to push constraints from a given query to the EDB predicates. Finally, we show that satisfiability is undecidable for datalog programs with unary IDB predicates, stratified negation and the interpreted predicate 6=. 
Abstract-found: 1
Intro-found: 1
Reference: [AH88] <author> Serge Abiteboul and Richard Hull. </author> <title> Data functions, datalog, and negation. </title> <booktitle> In Proceedings of ACM SIGMOD 1988 International Conference on Management of Data, </booktitle> <address> Chicago, IL, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: P ) : f1; 2g ! f3; 4g cannot be inferred. 2 Corollary 6.2 Satisfiability is undecidable for datalog programs with 6=, but without negation or any other interpreted predicates, if EDBs are required to satisfy some functional dependencies. 2 Proof: Follows from the above reduction and the proof of <ref> [AH88] </ref> that inference of functional dependencies in datalog programs is undecidable. 2 7 Conclusions We identified new classes of programs for which equivalence, query-reachability and satisfiability are either decidable or undecidable. Table 1 summarizes the classes of programs for which answers to the decidability problems are now available.
Reference: [CV92] <author> Surajit Chaudhuri and Moshe Vardi. </author> <title> On the equivalence of recursive and nonre-cursive datalog programs. </title> <booktitle> In Proceedings of the Eleventh Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 55-66, </pages> <address> San Diego, CA, </address> <month> June 2-4 </month> <year> 1992. </year> <note> ACM SIGACT-SIGMOD-SIGART. </note>
Reference-contexts: monadic dat-alog program, with a single linear recursive rule, in a monadic nonrecursive program with 6= should be contrasted with the following results: First, containment of a recursive datalog program in a nonrecursive program, where IDB predicates are of any arity but there is neither negation nor 6=, is decidable <ref> [CV92] </ref>. Second, containment between two recursive datalog programs with only unary predicates (and neither negation nor 6=) is decidable [CGKV88]. Acknowledgment The authors thank Ron van der Meyden for pointing out the connection between his work and this paper.
Reference: [CGKV88] <author> S. S. Cosmadakis, H. Gaifman, Paris C. Kanellakis, and Moshe Y. Vardi. </author> <title> Decidable optimization problems for database logic programs. </title> <booktitle> In Proceedings of the Twentieth Symposium on Theory of Computing, </booktitle> <pages> pages 477-490, </pages> <year> 1988. </year>
Reference-contexts: These undecidability results apply to datalog programs with unary IDB predicates, negation, and the interpreted predicate 6=. In contrast, note that equivalence is decidable for datalog programs with only unary IDB predicates (and neither negation nor interpreted predicates) <ref> [CGKV88] </ref>. In proving some of the decidability results, we use a rather powerful tool, the query-tree, which was first used in [LS92]. A query-tree is a finite structure that encodes all symbolic derivation trees (of a datalog program P ) that satisfy some given property. <p> D (p; P ) : f1; 2g ! f3; 4g is deciding whether for all EDBs D, the relation for p computed by program P satisfies f1; 2g ! f3; 4g, i.e., if two tuples are equal on the first and second Datalog Extension/Restriction Sat/QR EQ/CN Unary idb's Decidable Decidable <ref> [CGKV88] </ref> Unary idb's, negation on nonrecursive predicates, 1 recursive rule, 6= Undecidable Undecidable Unary recursive idb's, binary nonrecursive idbs, negation on nonrecursive predicates, 1 recursive rule, no 6= Undecidable Undecidable Binary idb's Decidable [Shm87] Undecidable [Shm87, UV88] Dense order constraints Decidable [KKR90, LS92] Undecidable Unary edb's, stratified negation Decidable Decidable Dense <p> Second, containment between two recursive datalog programs with only unary predicates (and neither negation nor 6=) is decidable <ref> [CGKV88] </ref>. Acknowledgment The authors thank Ron van der Meyden for pointing out the connection between his work and this paper.
Reference: [GMSV87] <author> H. Gaifman, H. Mairson, Yehoshua Sagiv, and Moshe Y. Vardi. </author> <title> Undecidable optimization problems for database logic programs. </title> <booktitle> In Proceedings of the Second IEEE Symposium on Logic in Computer Science(LICS), </booktitle> <pages> pages 106-115, </pages> <address> Ithaca, NY, </address> <year> 1987. </year>
Reference-contexts: The proof is based on a construction of a datalog program that checks whether a given computation of a two counter machine is a halting computation. The construction is similar to the one used in <ref> [GMSV87] </ref> to show that boundedness of datalog programs with unary IDB predicates and 6= is undecidable. The computation is stored in the EDB.
Reference: [KKR90] <author> Paris C. Kanellakis, Gabriel M. Kuper, and Peter Z. Revesz. </author> <title> Constraint query languages. </title> <booktitle> In Proceedings of the Ninth Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 299-313, </pages> <address> Nashville, TN, </address> <month> April 2-4 </month> <year> 1990. </year> <note> ACM SIGACT-SIGMOD-SIGART. </note>
Reference-contexts: Specifically, satisfiability and query-reachability are approximately at the same level of difficulty, while equivalence is harder than them. In previous work, satisfiability was shown decidable for pure datalog programs [Shm87] and decidability for datalog with dense-order constraints follows from the work of <ref> [KKR90] </ref>. Query-reachability was shown decidable for datalog with dense-order constraints [LS92]. In this paper, we show that both satisfiability and query-reachability are decidable for datalog programs with dense-order constraints and safe stratified negation provided that 1. negation is applied only to EDB predicates, or 2. all EDB predicates are unary. <p> second Datalog Extension/Restriction Sat/QR EQ/CN Unary idb's Decidable Decidable [CGKV88] Unary idb's, negation on nonrecursive predicates, 1 recursive rule, 6= Undecidable Undecidable Unary recursive idb's, binary nonrecursive idbs, negation on nonrecursive predicates, 1 recursive rule, no 6= Undecidable Undecidable Binary idb's Decidable [Shm87] Undecidable [Shm87, UV88] Dense order constraints Decidable <ref> [KKR90, LS92] </ref> Undecidable Unary edb's, stratified negation Decidable Decidable Dense order constraints, negation on edbs Decidable Undecidable 6=, functional dependencies in edb Undecidable Undecidable Table 1: The Decidability Question argument positions then they must also be equal on the third and fourth argument positions.
Reference: [Levy93] <author> Alon Y. Levy. </author> <title> Relevance Reasoning in Knowledge Based Systems. </title> <type> Ph.D Thesis, </type> <institution> Stanford University, </institution> <year> 1993. </year>
Reference-contexts: We then build a query-tree for the resulting program, and q ( X) is query-reachable if and only if some atom of q 0 appears in the resulting query-tree. For the complete details, see <ref> [Levy93] </ref>. As a corollary of the above theorems, we get the following: Corollary 3.2 Given a datalog program P with negated EDB subgoals, the following problems are decidable. First, testing satisfiability of a predicate q. <p> Consequently, we get the following result (for full details, see <ref> [Levy93] </ref>): Theorem 3.3 Satisfiability and query-reachability are decidable for programs with dense-order constraints and negated EDB subgoals. 2 4 Programs With Unary EDBs In this section, we consider programs in which all EDB predicates are unary. <p> In doing so, we should evaluate P over an abstract interpretation of generalized tuples that are conjunctions of EDB literals and constraint literals; for full details, see <ref> [Levy93] </ref>. Finally, given an arbitrary datalog program P 0 (where EDB predicates are not necessarily unary), we can replace each EDB predicate of P 0 by the cartesian product of its columns, resulting in a program P . As earlier, we create the corresponding non-recursive program P 1 .
Reference: [LS92] <author> Alon Levy and Yehoshua Sagiv. </author> <title> Constraints and redundancy in datalog. </title> <booktitle> In Proceedings of the Eleventh Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 67-80, </pages> <address> San Diego, CA, </address> <month> June 2-4 </month> <year> 1992. </year> <note> ACM SIGACT-SIGMOD-SIGART. </note>
Reference-contexts: In previous work, satisfiability was shown decidable for pure datalog programs [Shm87] and decidability for datalog with dense-order constraints follows from the work of [KKR90]. Query-reachability was shown decidable for datalog with dense-order constraints <ref> [LS92] </ref>. In this paper, we show that both satisfiability and query-reachability are decidable for datalog programs with dense-order constraints and safe stratified negation provided that 1. negation is applied only to EDB predicates, or 2. all EDB predicates are unary. <p> In contrast, note that equivalence is decidable for datalog programs with only unary IDB predicates (and neither negation nor interpreted predicates) [CGKV88]. In proving some of the decidability results, we use a rather powerful tool, the query-tree, which was first used in <ref> [LS92] </ref>. A query-tree is a finite structure that encodes all symbolic derivation trees (of a datalog program P ) that satisfy some given property. Query-trees can be used not just for decision problems, but also for analyzing datalog programs and transforming those programs into more efficient ones. <p> In proving this result we use a powerful tool, the query-tree, first introduced in <ref> [LS92] </ref>. <p> However, when we have dense-order constraints, this may not be the case. Fortunately, there is an easy fix for this problem. We begin by building a query-tree with constraint-labels as described in <ref> [LS92] </ref>. This results in an equivalent program P c with rules that are refined by constraint labels. These rules will have the property that in building symbolic derivations, we do not perform nontrivial unifications, nor will we need to propagate constraints through the rules. <p> second Datalog Extension/Restriction Sat/QR EQ/CN Unary idb's Decidable Decidable [CGKV88] Unary idb's, negation on nonrecursive predicates, 1 recursive rule, 6= Undecidable Undecidable Unary recursive idb's, binary nonrecursive idbs, negation on nonrecursive predicates, 1 recursive rule, no 6= Undecidable Undecidable Binary idb's Decidable [Shm87] Undecidable [Shm87, UV88] Dense order constraints Decidable <ref> [KKR90, LS92] </ref> Undecidable Unary edb's, stratified negation Decidable Decidable Dense order constraints, negation on edbs Decidable Undecidable 6=, functional dependencies in edb Undecidable Undecidable Table 1: The Decidability Question argument positions then they must also be equal on the third and fourth argument positions.
Reference: [Shm87] <author> Oded Shmueli. </author> <title> Decidability and expressiveness aspects of logic queries. </title> <booktitle> In Proceedings of the Sixth Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 237-249, </pages> <address> San Diego, CA, </address> <month> March </month> <year> 1987. </year> <note> ACM SIGACT-SIGMOD-SIGART. </note>
Reference-contexts: Specifically, satisfiability and query-reachability are approximately at the same level of difficulty, while equivalence is harder than them. In previous work, satisfiability was shown decidable for pure datalog programs <ref> [Shm87] </ref> and decidability for datalog with dense-order constraints follows from the work of [KKR90]. Query-reachability was shown decidable for datalog with dense-order constraints [LS92]. <p> one new trivial rule. 2 Lemma 2.5 An instance P 1 6 P 2 can be reduced to an instance of the satisfiability problem by adding rules that apply negation just once to a 0-arity predicate and do not increase the arity of predicates. 2 Finally, since it follows from <ref> [Shm87, UV88] </ref> that both containment and equivalence are undecidable for datalog programs with binary IDB predicates (and no negation or interpreted predicates), we get the following. <p> two tuples are equal on the first and second Datalog Extension/Restriction Sat/QR EQ/CN Unary idb's Decidable Decidable [CGKV88] Unary idb's, negation on nonrecursive predicates, 1 recursive rule, 6= Undecidable Undecidable Unary recursive idb's, binary nonrecursive idbs, negation on nonrecursive predicates, 1 recursive rule, no 6= Undecidable Undecidable Binary idb's Decidable <ref> [Shm87] </ref> Undecidable [Shm87, UV88] Dense order constraints Decidable [KKR90, LS92] Undecidable Unary edb's, stratified negation Decidable Decidable Dense order constraints, negation on edbs Decidable Undecidable 6=, functional dependencies in edb Undecidable Undecidable Table 1: The Decidability Question argument positions then they must also be equal on the third and fourth argument <p> are equal on the first and second Datalog Extension/Restriction Sat/QR EQ/CN Unary idb's Decidable Decidable [CGKV88] Unary idb's, negation on nonrecursive predicates, 1 recursive rule, 6= Undecidable Undecidable Unary recursive idb's, binary nonrecursive idbs, negation on nonrecursive predicates, 1 recursive rule, no 6= Undecidable Undecidable Binary idb's Decidable [Shm87] Undecidable <ref> [Shm87, UV88] </ref> Dense order constraints Decidable [KKR90, LS92] Undecidable Unary edb's, stratified negation Decidable Decidable Dense order constraints, negation on edbs Decidable Undecidable 6=, functional dependencies in edb Undecidable Undecidable Table 1: The Decidability Question argument positions then they must also be equal on the third and fourth argument positions.
Reference: [Ull88] <author> Jeffrey D. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> Volume 1. </volume> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference: [Ull89] <author> Jeffrey D. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> Volume 2. </volume> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: A query tree is a rule-goal tree <ref> [Ull89] </ref> that is made finite by not expanding some IDB goal-nodes. Recall that a rule-goal tree is an AND-OR tree consisting of goal-nodes (the OR nodes) and rule-nodes (the AND nodes).
Reference: [UV88] <author> Jeffrey D. Ullman and Allen Van Gelder. </author> <title> Parallel complexity of logical query programs. </title> <journal> Algorithmica, </journal> <volume> 3 </volume> <pages> 5-42, </pages> <year> 1988. </year>
Reference-contexts: one new trivial rule. 2 Lemma 2.5 An instance P 1 6 P 2 can be reduced to an instance of the satisfiability problem by adding rules that apply negation just once to a 0-arity predicate and do not increase the arity of predicates. 2 Finally, since it follows from <ref> [Shm87, UV88] </ref> that both containment and equivalence are undecidable for datalog programs with binary IDB predicates (and no negation or interpreted predicates), we get the following. <p> are equal on the first and second Datalog Extension/Restriction Sat/QR EQ/CN Unary idb's Decidable Decidable [CGKV88] Unary idb's, negation on nonrecursive predicates, 1 recursive rule, 6= Undecidable Undecidable Unary recursive idb's, binary nonrecursive idbs, negation on nonrecursive predicates, 1 recursive rule, no 6= Undecidable Undecidable Binary idb's Decidable [Shm87] Undecidable <ref> [Shm87, UV88] </ref> Dense order constraints Decidable [KKR90, LS92] Undecidable Unary edb's, stratified negation Decidable Decidable Dense order constraints, negation on edbs Decidable Undecidable 6=, functional dependencies in edb Undecidable Undecidable Table 1: The Decidability Question argument positions then they must also be equal on the third and fourth argument positions.
Reference: [vdM92] <author> Ronald van der Meyden. </author> <title> The Complexity of Querying Indefinite Information: Defined Relations, Recursion and Linear Order. </title> <type> PhD thesis, </type> <institution> Rutgers, The State University of New Jersey, </institution> <address> New Brunswick, NJ, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Previously known results are in regular font. Italic font indicates results that follow from previous and new results by applying the Lemmas and Propositions of Section 2. Results that follow trivially from previously known results are shown in small teletype font. In <ref> [vdM92] </ref>, van der Meyden proved an undecidability result that implies the following. First, satisfiability is undecidable for datalog programs with unary IDB predicates, 6= and negation. <p> First, satisfiability is undecidable for datalog programs with unary IDB predicates, 6= and negation. Second, containment of a recursive program in a nonrecursive program is undecidable even if there are only unary IDB predicates and 6= (i.e., negation is not needed). The first result of <ref> [vdM92] </ref> is similar to our result in Theorem 5.1 on undecidability of satisfiability. As for the second result of [vdM92], we can modify the proof in Section 5 to show the same (details will be given in the full paper). It should be noted, however, that the proof in [vdM92] uses <p> The first result of <ref> [vdM92] </ref> is similar to our result in Theorem 5.1 on undecidability of satisfiability. As for the second result of [vdM92], we can modify the proof in Section 5 to show the same (details will be given in the full paper). It should be noted, however, that the proof in [vdM92] uses many recursive rules, compared to just one recursive rule in our proof. <p> of <ref> [vdM92] </ref> is similar to our result in Theorem 5.1 on undecidability of satisfiability. As for the second result of [vdM92], we can modify the proof in Section 5 to show the same (details will be given in the full paper). It should be noted, however, that the proof in [vdM92] uses many recursive rules, compared to just one recursive rule in our proof.
Reference: [Var89] <author> Moshe Y. Vardi. </author> <title> Automata theory for database theoreticians. </title> <booktitle> In Proceedings of the Eighth Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 83-92, </pages> <address> Philadelphia, PA, </address> <month> March </month> <year> 1989. </year> <note> ACM SIGACT-SIGMOD-SIGART. </note>
Reference-contexts: Query-trees can be viewed as a refinement of tree automata techniques for the special purpose of representing symbolic derivation trees of datalog programs. The importance of tree-automata techniques for decision problems of datalog programs was shown in <ref> [Var89] </ref>.
References-found: 13

