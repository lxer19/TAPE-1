URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/views/thesis.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Title: Abstract  
Abstract: Object-oriented databases are used mainly in new application domains that are not covered efficiently by past-generation systems. However, requiring all users to work on the same information model limits the extensibility of the system, and introduces difficulties when, for instance, considering data restructuring and database integration. This thesis, presents a view mechanism that confronts these problems by allowing programmers to restructure the class hierarchy and modify the behaviour and structure of objects. A view is a virtual schema graph created by importing data from the database, and then restructuring the imported data. The programmer derives new, virtual classes by populating them with existing objects, or with newly created objects. These classes are classified according to their subsumption relationships with the existing classes. Two subsumption testing techniques are presented. We specify our view mechanism by means of a deductive object-oriented language, namely F-logic, and address the arising issues. 
Abstract-found: 1
Intro-found: 1
Reference: [AB91] <author> S. Abiteboul and A.J. Bonner. </author> <title> Objects and Views. </title> <booktitle> In Proceedings of ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 238-247, </pages> <address> Denver, Colorado, </address> <year> 1991. </year>
Reference-contexts: Some of the proposals for view models in this direction are by Tanaka et al. [TYI88], by E.A.Rundensteiner [Run92b] and by Abiteboul and Bonner <ref> [AB91] </ref>. Tanaka et al. deal with schema virtualization. In their approach they do not clearly distinguish between the integration of derived classes into one common schema and the generation of view schemata. <p> Even though they point out the need for the integration of the virtual classes, no general classification algorithm is presented. On the contrary, they allow manual addition of is-a edges into a virtual schema which, in many cases, may lead to inconsistencies due to human errors. Abiteboul and Bonner <ref> [AB91] </ref> present a view mechanism for the O 2 database system. They use a slightly modified version of the O 2 data model, which does not distinguish between (stored) attributes and (derived) methods, resulting in a flexible and informative model. <p> The above definition enables us to see a view just as a database, but with no proper data of its own. We will also use the term virtual schema, to refer to a view, as it is commonly used in <ref> [TYI88, AB91] </ref>. 3.2 The Model in General The model we are going to present in the rest of this chapter, comes from the earlier work by S.Abiteboul and A.J.Bonner. In [AB91] they give an informal description of a view mechanism for the O 2 object-oriented data model. <p> We will also use the term virtual schema, to refer to a view, as it is commonly used in [TYI88, AB91]. 3.2 The Model in General The model we are going to present in the rest of this chapter, comes from the earlier work by S.Abiteboul and A.J.Bonner. In <ref> [AB91] </ref> they give an informal description of a view mechanism for the O 2 object-oriented data model. In what follows, we outline the basic features of this approach and clarify the semantics through examples and schematical representations. <p> It will not, however, have any proper data of its own. Treating the view as another database makes it possible to define views on top of views, as we demonstrate in Chapter 4. Some basic ideas underlying the design of the view mechanism, taken from <ref> [AB91] </ref>, are summarized bellow: 1. A view should be treated as a database, which implies that virtual classes should be useable as base ones. 2. View construction should be a simple procedure, even for the inexperienced user. 3. <p> One of the most common of restructurings is to hide attributes or methods. Hiding is a type manipulation operation and does not in any way 3. The View Model 29 affect the set content of a class. As first pointed out in <ref> [AB91] </ref>, in object-oriented databases, the hiding of a property must be performed explicitly, in contrast to hiding in relational databases, where it is done in an implicit manner. For instance, consider a Student relation with attributes [N ame; StudentN o; GP A]. <p> This section, on the other hand, presents ways to popu 3. The View Model 39 late virtual classes with generated objects, that is, objects not previously existing in the database. Such objects are called imaginary objects and are considered in a number of papers (e.g., <ref> [AK89, Kim89, AB91, KLW93] </ref>]). The main objective behind using such objects is to increase the power of the view model. <p> Imaginary classes can be treated like any other class. Other attributes can, therefore, be defined for &lt;imaginary-class&gt;. These attributes are virtual. As an example of object creation we consider grouping person objects into larger, family objects <ref> [AB91] </ref>. Each family object will have two core attributes Husband and W if e. <p> The generated objects are said to be imaginary, since they did not previously exist in the database <ref> [AB91] </ref>. As demonstrated in Chapter 3, such objects increase the flexibility of the view mechanism, by allowing sophisticated restructurings that turn objects into values and vice versa. Furthermore, small objects can be combined into larger ones, while large objects can be decomposed into smaller ones. <p> Any change in the state or behavior of the base object propagates directly to the corresponding view object. It therefore becomes clear that such objects, though not previously existing in the database, do not actually correspond to the notion of imaginary objects as developed in <ref> [AB91] </ref>. Consequently, we will modify this notion, and use the term imaginary objects to characterize those objects generated within the boundaries of the view, which normally have a structure different from all other view objects. <p> A more detailed 4. The Underlying F-logic Implementation 75 discussion of this issue is given later on, in the next chapter. 4.3.3 View Closure V iew closure [TYI88, HZ90, Run92b], also known as interf ace coherence <ref> [AB91] </ref>, is an issue concerning the property decomposition hierarchy. A view is called closed (or type-closed) when for every property visible in the view, its arguments and results are also visible in the same view. <p> In this chapter, we argue that it is quite advantageous to integrate the derived classes into the is-a hierarchy. The necessity of classifying the virtual classes has been indicated in many other approaches <ref> [TYI88, AB91, SLT91, Run92a] </ref>, in contrast to earlier approaches, in which the virtual classes are treated as "stand-alone"objects [HZ90] or are attached as direct subclasses to the schema root class [Kim89]. 5.1 Classification in General Class classif ication, also called class integration, is the process of taking a new class and <p> In general, assume a virtual class V C defined as including classes C 1 ... C k as well as objects from classes C k+1 ... C n . Then the superclasses and subclasses of V C are defined as follows <ref> [AB91] </ref> : 1. If D is a superclass of C 1 ... C n , then D is also a superclass of virtual class C, 2. Each C i is a subclass of C for 1 i k. <p> After the relationships are acquired, V C is placed above all its direct subclasses and bellow all its direct superclasses. In [Run92a] it is claimed that such a classification algorithm, which is repeatedly advocated in the literature <ref> [SL83, TYI88, AB91] </ref>, does not correctly account for the type inheritance underlying the schema graph. This is because of two problems that this algorithm does not address properly. These are the type inheritance mismatch and the is-a incompatibility problems. <p> Classes 94 5.8 Placing the Derived Classes in the Hierarchy Once the Subsumes () function is defined and the subsumption relationships between classes can be derived, we follow a common approach for the actual placement of the derived classes that is used in many of the proposed object-oriented view models <ref> [SL83, TYI88, AB91, Run92a] </ref>. This approach consists of finding all the direct super-and sub-classes of the virtual class and placing it under the former and above the latter. A very simple example of this technique was presented in Figure 5.2. <p> Subsuming the Class Relationships 131 Properties can still be inherited properly from C1 and C2 to V C, by upward inheritance <ref> [AB91] </ref> as described in section 3.3.4. With the above remarks, we conclude the presentation of the second technique for testing subsumption in the context of our model. This technique tests subsumption with complexity exponential to the size of the input queries. <p> Allowing, for example, an object instance to simultaneously be a member of many classes means that this object can take on different types <ref> [AB91, SLT91] </ref>. This immediately raises several implementation issues, as for instance, 7. Conclusions and Future Work 135 the development of efficient strategies for method resolution. Other important database issues for future work, include query processing techniques on views, materialized views and view updates.
Reference: [AFD + 89] <author> M. Atkinson, F.Bancilhon, D.DeWitt, K.Dittrich, D.Maier, and S.Zdonik. </author> <title> The Object-Oriented Database System Manifesto. </title> <booktitle> In Proc. 1st International DOOD Conf., </booktitle> <address> Kyoto, Japan, </address> <year> 1989. </year>
Reference-contexts: The concept of a view was first introduced in the relational database model, and within this context, it has been studied and explored extensively. However, since object-oriented databases are relative newcomers to the database field, and since to date, there is no consensus on a unique object-oriented data model <ref> [AFD + 89] </ref>, object-oriented views have not been as extensively and thoroughly explored as their relational predecessors. In this chapter, I give a spherical and descriptive presentation of related work done on database views. <p> We then describe the view definition process, and finally we discuss issues on generating new objects. 3.1 Preliminary Definitions In this section, we provide some basic definitions needed in the rest of the thesis. These definitions are similar in flavour to others in the literature <ref> [Ban88, AFD + 89, SLT91, Run92b] </ref>. Objects are instances of abstract data types (ADT's). Each object, o, in the infinite set of object instances, O, has an interface, by which the user can access and manipulate it.
Reference: [AK89] <author> S. Abiteboul and P.C. Kanellakis. </author> <title> Object Identity as a Query Language Primitive. </title> <booktitle> In Proceedings of ACM-SIGMOD Conference on Management of Data, </booktitle> <pages> pages 159-173, </pages> <address> Portland, </address> <year> 1989. </year>
Reference-contexts: This section, on the other hand, presents ways to popu 3. The View Model 39 late virtual classes with generated objects, that is, objects not previously existing in the database. Such objects are called imaginary objects and are considered in a number of papers (e.g., <ref> [AK89, Kim89, AB91, KLW93] </ref>]). The main objective behind using such objects is to increase the power of the view model. <p> U (F ) is called the Herbrand U niverse. At the conceptual level, ground id-terms are used to denote logical object-ids. A logical object-id is a logical abstraction of the concept of physical object identity <ref> [KC86, AK89] </ref>. Hence, for example, person is the oid of the class denoting all people. Henceforth, a symbol that begins with a lower-case letter denotes a ground id-term, while one beginning with a capital letter denotes an id-term that may be non-ground.
Reference: [Ban88] <author> F. Bancilhon. </author> <title> Object-Oriented Database Systems. </title> <booktitle> In Proc. 8th ACM Symposium on Principles of Database Systems., </booktitle> <pages> pages 152-162, </pages> <year> 1988. </year>
Reference-contexts: We then describe the view definition process, and finally we discuss issues on generating new objects. 3.1 Preliminary Definitions In this section, we provide some basic definitions needed in the rest of the thesis. These definitions are similar in flavour to others in the literature <ref> [Ban88, AFD + 89, SLT91, Run92b] </ref>. Objects are instances of abstract data types (ADT's). Each object, o, in the infinite set of object instances, O, has an interface, by which the user can access and manipulate it. <p> These features include object identity, complex objects, inheritance, polymorphic types, methods, encapsulation and others. Moreover, F-logic combines the deductive and object-oriented paradigms into one coherent framework, overcoming the so-called impedance mismatch problem <ref> [Ban88] </ref>. At the same time it provides logical semantics for the object-oriented model and allows the definition and manipulation of database schema and types. F-logic has a model-theoretic semantics and a sound and complete resolution-based proof procedure. It represents object-oriented concepts, both semantically and syntactically.
Reference: [BCG + 87] <author> J. Banerjee, H.T. Chou, J.F. Garza, W. Kim, D. Woelk, N. Ballou, and H.J. Kim. </author> <title> Data Model Issues for Object-Oriented Applications. </title> <journal> Transactions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 3-26, </pages> <year> 1987. </year>
Reference: [Ber92] <author> E. Bertino. </author> <title> A View Mechanism for Object-Oriented Databases. </title> <booktitle> In Proc. Int. Conf. on Extended Data Base Technology, </booktitle> <pages> pages 136-152, </pages> <year> 1992. </year>
Reference-contexts: We should note however, that the view mechanism we present here does not depend on imaginary objects and can work without them. In fact, many other approaches <ref> [Run92b, SLT91, Ber92] </ref> do not even consider such objects.
Reference: [BL84] <author> R.J Brachman and H.J Levesque. </author> <title> The Tractability of Subsumption in Frame-Based Description Languages. </title> <booktitle> In Proc. 4th National Conference on Artificial Intelligence., </booktitle> <pages> pages 34-37, </pages> <year> 1984. </year> <type> 136 8. Bibliography 137 </type>
Reference-contexts: Subsumption is a relation between classes, such that class A subsumes class B only if the extent (A) includes the extent (B). Subsumption is also an issue in the context of Concept [NS90], Frame-Based <ref> [BL84] </ref> and Semantic-Based Network [SL83] languages. <p> Therefore subsumption is a relation between classes, such that class A subsumes class B only if the extent (A) includes the extent (B). Subsumption has also been an issue in the context of Concept [NS90], Frame-Based <ref> [BL84] </ref> and Semantic-Based Network [SL83] languages. Testing for subsumption can be done by using a function Subsumes () defined as: 96 6. <p> Basic Notions Concept languages provide a means for expressing knowledge about hierarchies of concepts, i.e. classes of objects with common properties [DLNN91]. They are given a Tarski style declarative semantics that allows them to be conceived as sublanguages of predicate logic <ref> [BL84] </ref>. The basic reasoning tasks on concepts are unsatisfiability and subsumption 6. Subsuming the Class Relationships 100 testing. We say that a concept is unsatisfiable if it always denotes an empty set. A concept C is subsumed by a concept D if C always denotes a subset of D. <p> Subsuming the Class Relationships 100 testing. We say that a concept is unsatisfiable if it always denotes an empty set. A concept C is subsumed by a concept D if C always denotes a subset of D. PL 1 is an extension of the polynomial language F L <ref> [BL84] </ref>. The later includes conjunction of concepts (C u D), universal role quantification (8R:C) and unqualified existential role quantification (9R), where C and D are concepts and R is a role (a role corresponds to the notion of an attribute).
Reference: [BM87] <editor> M.L Brodie and J. Mylopoulos. (eds). </editor> <booktitle> On Knowledge Base Management Systems. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: This can eliminate ambiguities when updating an object-oriented view. A model for updatable object-oriented views is presented in [SLT91]. 2. Database Views: A Trip Through the Past 15 2.2 Extending Relational Views In order to deal with the relational view update problem, Mylopoulos and Brodie <ref> [BMS84, BM87] </ref> presented an approach based on the notion of an abstract data type (ADT ). In this approach every object of a particular type is characterized by the operations performed on it. The details of the presentation of each object are not for the user to see.
Reference: [BMS84] <editor> M.L Brodie, J. Mylopoulos, and J.W Schmidt. (eds). </editor> <booktitle> On Conceptual Mod-elling. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: This can eliminate ambiguities when updating an object-oriented view. A model for updatable object-oriented views is presented in [SLT91]. 2. Database Views: A Trip Through the Past 15 2.2 Extending Relational Views In order to deal with the relational view update problem, Mylopoulos and Brodie <ref> [BMS84, BM87] </ref> presented an approach based on the notion of an abstract data type (ADT ). In this approach every object of a particular type is characterized by the operations performed on it. The details of the presentation of each object are not for the user to see.
Reference: [BS81] <author> F. Bancilhon and N. Spyratos. </author> <title> Update Semantics in Relational Views. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 6(4) </volume> <pages> 557-575, </pages> <year> 1981. </year>
Reference-contexts: Theodora 712165 Comp.Eng. Name Major George Comp.Eng. George Comp.Eng. Theodora Comp.Eng. unique and unambiguous update on the global schema, or it may be the case that such an update presents undesirable side effects on the view itself. These two facts constitute the view update problem <ref> [BS81, DB82] </ref>, that is, the problem of properly translating an update request on a view, into an update request on the underlying global schema. In general, there are only a few cases in which the view update can be unambiguously translated into an update on the base schema.
Reference: [CM77] <author> A.K. Chandra and P.M. Merlin. </author> <title> Optimal Implementation of Conjunctive Queries in Relational Databases. </title> <booktitle> In Proc. Ninth Annual Symp. on the Theory of Computing, </booktitle> <pages> pages 77-90, </pages> <year> 1977. </year>
Reference-contexts: This technique is based on earlier work done on optimization of conjunctive queries in the context of the relational model <ref> [CM77, SY81, ?, Ull89] </ref>. In that framework, testing for equivalence of conjunctive queries is translated into testing containment in both directions. One conjunctive query is contained in another in the sense that every answer returned by the former is also returned by the latter.
Reference: [Cod70] <author> E.F. Codd. </author> <title> A Relational Model for Large Shared Data Banks. </title> <journal> Communications of the ACM, </journal> <volume> 13(6) </volume> <pages> 377-387, </pages> <year> 1970. </year>
Reference: [Dat90] <author> C.J. Date. </author> <title> An Introduction to Database Systems. </title> <journal> Vol. </journal> <volume> 1, </volume> <editor> Fifth ed., </editor> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Database Views: A Trip Through the Past 12 Name Department Salary White Comp.Sci. 85,000 Greene Comp.Sci. 80,000 Black Math 76,000 scheme corresponds to a set of unrelated relation schemes. A view in this model is a named; derived relation, which is defined by a query <ref> [Dat90] </ref>. This can be seen in Figure 2.2. The view is named Bigshot and is derived via the query: SELECT N ame; Department F ROM Employee W HERE Salary &gt; 75; 000. <p> It is, more specifically, a set manipulation operator that selects a set of objects from a class. It resembles the selection operation of relational algebra <ref> [Ull88, Dat90] </ref>. The view classes created by specialization can be further specialized. schema. All subclasses of employee are imported as well.
Reference: [DB82] <author> U. Dayal and P.A. Bernstein. </author> <title> On Correct Translation of Update Operations on Relational Views. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 7(3) </volume> <pages> 381-416, </pages> <year> 1982. </year>
Reference-contexts: Theodora 712165 Comp.Eng. Name Major George Comp.Eng. George Comp.Eng. Theodora Comp.Eng. unique and unambiguous update on the global schema, or it may be the case that such an update presents undesirable side effects on the view itself. These two facts constitute the view update problem <ref> [BS81, DB82] </ref>, that is, the problem of properly translating an update request on a view, into an update request on the underlying global schema. In general, there are only a few cases in which the view update can be unambiguously translated into an update on the base schema.
Reference: [DHL + 90] <editor> F.M. Donini, B. Hollunder, A. Lanzerini, A.M. Spaccamela, D. Nardi, and W. </editor> <title> Nutt. The Complexity of Existential Quantification in Concept Languages. </title> <type> Technical report, </type> <institution> DFKI, Kaiserslautern Germany, </institution> <year> 1990. </year>
Reference-contexts: However, adding this qualified existential role quantification construct to PL 1 would result in the ALE concept language [SSS88], for which satisfiability (and therefore subsumption) is proved to be N P -complete <ref> [DHL + 90] </ref>. Hence, although we cannot test subsumption in polynomial time in the presence of set valued attributes, it can still be 6. Subsuming the Class Relationships 106 done in time exponential in the size of the query.
Reference: [DLNN91] <author> F.M Donini, M. Lanzerini, D. Nardi, and W. Nutt. </author> <title> Tractable Concept Languages. </title> <booktitle> International Joint Conference on Artificial Intelligence (IJCAI'91, </booktitle> <pages> pages 458-463, </pages> <year> 1991. </year>
Reference-contexts: Moving in this direction, we present in the sequel two approaches to subsumption testing within the context of our model. The first approach is based on earlier work done in the field of concept languages <ref> [DLNN91] </ref>, while the second is based on containment of conjunctive queries in the context of query optimization [Ull89]. 6. <p> ) 6 type (C 1 ), then Subsumes (C 1 ; C 2 ) will return f ail, and there is no need to test the membership predicates of the corresponding classes. 6.2.1 A Polynomial Approach to Subsumption Our first approach is based on work done by Donini et al. <ref> [DLNN91] </ref> in the context of concept languages. There, a concept language, namely PL 1 , for which subsumption can be checked in polynomial time, is presented. <p> The technique falls into the category of those permitting only decidable membership predicates. Basic Notions Concept languages provide a means for expressing knowledge about hierarchies of concepts, i.e. classes of objects with common properties <ref> [DLNN91] </ref>. They are given a Tarski style declarative semantics that allows them to be conceived as sublanguages of predicate logic [BL84]. The basic reasoning tasks on concepts are unsatisfiability and subsumption 6. Subsuming the Class Relationships 100 testing. <p> This can be done because the language contains no disjunction or qualified existential role quantification, by means of the following rewriting rule <ref> [DLNN91] </ref>: 8R:(C u D) ! 8R:C u 8R:D (1) Then C is subsumed by D if and only if for every conjunction-free component D i of D, C u :D i is unsatisfiable. <p> If not, then subsumption is false. The computation of the completion of a constraint system fx : C u :D i g takes polynomial time <ref> [DLNN91] </ref> and, hence, subsumption in PL 1 can be solved in polynomial time. Adapting the Technique In the following lines, we will consider the way in which the technique described above can be adapted and used to test subsumption in our model. <p> The complexity of this function strongly affects the overall complexity of the whole classification algorithm. Efficient subsumption techniques are, therefore, a necessity. We have devised two such techniques. The first adopts earlier work done on this issue in the context of concept languages <ref> [DLNN91] </ref>. This technique is of complexity 7. Conclusions and Future Work 134 polynomial in the size of the input queries, i.e., the queries that describe the classes that are tested for subsumption. Low complexity is achieved by restricting the set of permitted queries for class derivation.
Reference: [HZ90] <author> S. Heiler and S.B. Zdonik. </author> <title> Schema Virtualization in Object-Oriented Databases. </title> <booktitle> In Proc. IEEE Data Eng. Conf., </booktitle> <pages> pages 86-93, </pages> <year> 1990. </year>
Reference-contexts: The view mechanism defined by Kim for the Orion model [Kim89], as well as the one defined for the Fugue model <ref> [HZ90] </ref> by Heiler and Zdonik are two examples that follow the aforementioned approach. However, no extra care is taken for the classification of the derived virtual classes. <p> These relationships have to be explicitly stated, in order to share properties and to avoid information duplication. This issue, as stated earlier, is neither considered in <ref> [HZ90] </ref> where the derived classes are treated as `stand-alone' objects, nor is it properly dealt with in [Kim89] where the derived classes are attached directly as subclasses of the schema root class. Another proposal that considers a view to be a virtual class is that of Scholl et al. [SLT91]. <p> Instead, he can import classes and objects from the existing view schema and perform slight restructurings, avoiding potentially large overhead. A more detailed 4. The Underlying F-logic Implementation 75 discussion of this issue is given later on, in the next chapter. 4.3.3 View Closure V iew closure <ref> [TYI88, HZ90, Run92b] </ref>, also known as interf ace coherence [AB91], is an issue concerning the property decomposition hierarchy. A view is called closed (or type-closed) when for every property visible in the view, its arguments and results are also visible in the same view. <p> The necessity of classifying the virtual classes has been indicated in many other approaches [TYI88, AB91, SLT91, Run92a], in contrast to earlier approaches, in which the virtual classes are treated as "stand-alone"objects <ref> [HZ90] </ref> or are attached as direct subclasses to the schema root class [Kim89]. 5.1 Classification in General Class classif ication, also called class integration, is the process of taking a new class and placing it in the appropriate position in the class hierarchy.
Reference: [KC86] <author> S.N. </author> <title> Khoshafian and G.P. Copeland. Object Identity. </title> <booktitle> In Proc. of the International Conference of Object-Oriented Programming, Systems, Languages and Applications (OOPSLA'86), </booktitle> <pages> pages 406-416, </pages> <year> 1986. </year> <note> 8. Bibliography 138 </note>
Reference-contexts: The base tuples &lt;George; 718932; Comp:Eng:&gt; and &lt;George; 729921; Comp:Eng:&gt; are both reduced to &lt;George; Comp:Eng:&gt; in the view relation of Figure 2.3, Thus the resulting view will actually be the one in Figure 2.4. In the object-oriented case however, each object is assigned a unique, time-invariant identifier <ref> [KC86] </ref>. This identifier assures that even if the external characteristics of a particular object are changed, the system will be able to keep track of it. Therefore, side-effects similar to the one presented in Figure 2.4 are not likely to occur. <p> U (F ) is called the Herbrand U niverse. At the conceptual level, ground id-terms are used to denote logical object-ids. A logical object-id is a logical abstraction of the concept of physical object identity <ref> [KC86, AK89] </ref>. Hence, for example, person is the oid of the class denoting all people. Henceforth, a symbol that begins with a lower-case letter denotes a ground id-term, while one beginning with a capital letter denotes an id-term that may be non-ground.
Reference: [Kim89] <author> W. Kim. </author> <title> A Model of Queries in Object-Oriented Databases. </title> <booktitle> In Proc., VLDB 1989, </booktitle> <pages> pages 423-432, </pages> <year> 1989. </year>
Reference-contexts: The view mechanism defined by Kim for the Orion model <ref> [Kim89] </ref>, as well as the one defined for the Fugue model [HZ90] by Heiler and Zdonik are two examples that follow the aforementioned approach. However, no extra care is taken for the classification of the derived virtual classes. <p> These relationships have to be explicitly stated, in order to share properties and to avoid information duplication. This issue, as stated earlier, is neither considered in [HZ90] where the derived classes are treated as `stand-alone' objects, nor is it properly dealt with in <ref> [Kim89] </ref> where the derived classes are attached directly as subclasses of the schema root class. Another proposal that considers a view to be a virtual class is that of Scholl et al. [SLT91]. They present a view mechanism for the COCOON object model. <p> This section, on the other hand, presents ways to popu 3. The View Model 39 late virtual classes with generated objects, that is, objects not previously existing in the database. Such objects are called imaginary objects and are considered in a number of papers (e.g., <ref> [AK89, Kim89, AB91, KLW93] </ref>]). The main objective behind using such objects is to increase the power of the view model. <p> The necessity of classifying the virtual classes has been indicated in many other approaches [TYI88, AB91, SLT91, Run92a], in contrast to earlier approaches, in which the virtual classes are treated as "stand-alone"objects [HZ90] or are attached as direct subclasses to the schema root class <ref> [Kim89] </ref>. 5.1 Classification in General Class classif ication, also called class integration, is the process of taking a new class and placing it in the appropriate position in the class hierarchy.
Reference: [Kim90] <author> W. Kim. </author> <title> Introduction to Object-Oriented Databases. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference: [KLW93] <author> M. Kifer, G. Lausen, and J. Wu. </author> <title> Logical Foundations of Object-Oriented and Frame-Based Languages. </title> <type> Technical Report 93-06, </type> <institution> SUNY, at Stony Brook, </institution> <year> 1993. </year>
Reference-contexts: This section, on the other hand, presents ways to popu 3. The View Model 39 late virtual classes with generated objects, that is, objects not previously existing in the database. Such objects are called imaginary objects and are considered in a number of papers (e.g., <ref> [AK89, Kim89, AB91, KLW93] </ref>]). The main objective behind using such objects is to increase the power of the view model. <p> Attributes of an imaginary object which might be affected by updating this object, should be defined as virtual attributes, rather than as core attributes. Chapter 4 The Underlying F-logic Implementation 4.1 Getting to Know F-logic F rame Logic (abbr. F-logic) <ref> [KLW93] </ref> is a formalism which accounts in a clean, declarative fashion for most of the structural aspects of object-oriented languages. These features include object identity, complex objects, inheritance, polymorphic types, methods, encapsulation and others. <p> In practice, complex values are used in fairly restricted ways; primarily as weak entities in the Entity-Relationship approach <ref> [KLW93] </ref>. It does not seem reasonable for the user to have to assign id's to objects that are not going to be accessed through these id's. For this reason, F-logic permits the use of "don't care" object id's.
Reference: [Mot87] <author> A. Motro. Superviews: </author> <title> Virtual Integration of Multiple Databases. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(7) </volume> <pages> 785-798, </pages> <year> 1987. </year>
Reference: [MS87] <author> D. Maier and J. Stein. </author> <title> Development and Implementation of an Object-Oriented DBMS. In Research Directions in Object-Oriented Programming., </title> <editor> B.Shrier and P.Wegner, (Eds.), </editor> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference: [MS89] <author> M. Missikoff and M. Scholl. </author> <title> An Algorithm for Classification Into a Lattice: Application to Type Classification. </title> <booktitle> In 3rd Int'l Conf. on Foundations of Data Organization and Algorithms, </booktitle> <pages> pages 64-82, </pages> <year> 1989. </year>
Reference-contexts: Consequently there is no proper location for the virtual class to be inserted into the hierarchy. 5. Classifying the Virtual Classes 88 5.6 Overcoming the Type Inheritance Mismatch Problem A solution to problem is presented in <ref> [MS89, Run92a] </ref>. The latter is more general since it deals with the type and set content of the class, while Missikoff and Scholl focus only on type classification.
Reference: [NS90] <author> B. Nebel and G. Smolka. </author> <title> Representation and Reasoning with Attributive Descriptions. </title> <editor> In Blasius,K.H., Hedstuck,U., Rollinger,C.R. (Eds.), </editor> <booktitle> Lecture Notes in Artificial Inteligence 418, </booktitle> <pages> pages 112-139, </pages> <year> 1990. </year>
Reference-contexts: Subsumption is a relation between classes, such that class A subsumes class B only if the extent (A) includes the extent (B). Subsumption is also an issue in the context of Concept <ref> [NS90] </ref>, Frame-Based [BL84] and Semantic-Based Network [SL83] languages. <p> Therefore subsumption is a relation between classes, such that class A subsumes class B only if the extent (A) includes the extent (B). Subsumption has also been an issue in the context of Concept <ref> [NS90] </ref>, Frame-Based [BL84] and Semantic-Based Network [SL83] languages. Testing for subsumption can be done by using a function Subsumes () defined as: 96 6.
Reference: [RB92] <author> E.A. Rundensteiner and L. Bic. </author> <title> Automatic View Generation in Object-Oriented Databases. </title> <type> Technical Report 92-15, </type> <institution> University of Cal., Irvine, </institution> <year> 1992. </year>
Reference-contexts: It can guarantee a correct and complete placement of the derived classes in the schema and wipe out the possibility of an inconsistent database system. Algorithms can be devised to handle correct placement of virtual classes, insertion of all required and deletion of all redundant or inconsistent is-a arcs <ref> [RB92] </ref>. Consequently, we choose to automate the classification procedure and gain the aforementioned advantages. However, the view definer is not prevented from classifying the virtual classes manually, if he desires to do so. <p> One should note that even if we choose to classify within one global schema, we still have to eventually select the classes that comprise each view and form them into a view schema, as is done in <ref> [RB92] </ref>. There, an algorithm with complexity O (jGSj 3 ), where jGSj is the number of classes in the global schema, is used to construct a view schema by choosing the appropriate classes from the global schema. This algorithm is executed one time for each view that is created.
Reference: [RBKW91] <author> F. Rabitti, E. Bertino, W. Kim, and D. Woelk. </author> <title> A Model of Authorization for Next Generation Database Systems. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 16(1) </volume> <pages> 88-131, </pages> <year> 1991. </year>
Reference: [Run92a] <author> E.A. Rundensteiner. </author> <title> A Class Classification Algorithm and its Application For Supporting Consistent Object Views. </title> <type> Technical Report 92-50, </type> <institution> University of Cal., Irvine, </institution> <year> 1992. </year> <note> 8. Bibliography 139 </note>
Reference-contexts: In this chapter, we argue that it is quite advantageous to integrate the derived classes into the is-a hierarchy. The necessity of classifying the virtual classes has been indicated in many other approaches <ref> [TYI88, AB91, SLT91, Run92a] </ref>, in contrast to earlier approaches, in which the virtual classes are treated as "stand-alone"objects [HZ90] or are attached as direct subclasses to the schema root class [Kim89]. 5.1 Classification in General Class classif ication, also called class integration, is the process of taking a new class and <p> After the relationships are acquired, V C is placed above all its direct subclasses and bellow all its direct superclasses. In <ref> [Run92a] </ref> it is claimed that such a classification algorithm, which is repeatedly advocated in the literature [SL83, TYI88, AB91], does not correctly account for the type inheritance underlying the schema graph. This is because of two problems that this algorithm does not address properly. <p> These problems are closely related to object-oriented data models and, therefore, are not handled appropriately by earlier work on classification. The first problem is the inheritance mismatch in the type hierarchy <ref> [SLT91, Run92a] </ref>, and the other is composing is-a incompatible subset and subtype hierarchies into one consistent class hierarchy [Run92a]. <p> These problems are closely related to object-oriented data models and, therefore, are not handled appropriately by earlier work on classification. The first problem is the inheritance mismatch in the type hierarchy [SLT91, Run92a], and the other is composing is-a incompatible subset and subtype hierarchies into one consistent class hierarchy <ref> [Run92a] </ref>. Although in [Run92a] it is claimed that a simple classification algorithm like the one described in the previous section does not overcome these problems, I will demonstrate in the following how these can be dealt with in the context of our semantics. 5.5.1 The Type Inheritance Mismatch Problem This problem <p> The first problem is the inheritance mismatch in the type hierarchy [SLT91, Run92a], and the other is composing is-a incompatible subset and subtype hierarchies into one consistent class hierarchy <ref> [Run92a] </ref>. Although in [Run92a] it is claimed that a simple classification algorithm like the one described in the previous section does not overcome these problems, I will demonstrate in the following how these can be dealt with in the context of our semantics. 5.5.1 The Type Inheritance Mismatch Problem This problem arises when the <p> Consequently there is no proper location for the virtual class to be inserted into the hierarchy. 5. Classifying the Virtual Classes 88 5.6 Overcoming the Type Inheritance Mismatch Problem A solution to problem is presented in <ref> [MS89, Run92a] </ref>. The latter is more general since it deals with the type and set content of the class, while Missikoff and Scholl focus only on type classification. <p> This is demonstrated in Figure 5.5. The insertion of the two intermediate classes ic is done so that the properties common to V C and the two base classes are filtered out. After this, V C can be correctly inserted into the schema. The algorithm that <ref> [Run92a] </ref> presents reorganizes the schema graph in order to produce a class hierarchy closed under u, where u denotes the least common supertype of two types. <p> Therefore no is-a hierarchy mismatch problem would occur. Hence, we have demonstrated the way in which our semantics successfully overcomes the type inheritance problem. This is done without using a type preparation algorithm, as in <ref> [Run92a] </ref>, which would result in a quadratic (with respect to the number of is-a arcs in the global schema) complexity overhead every time a specific type of virtual class is derived. 5.7 Overcoming the is-a Incompatibility Problem A general solution to this problem is presented in [Run92a]. <p> preparation algorithm, as in <ref> [Run92a] </ref>, which would result in a quadratic (with respect to the number of is-a arcs in the global schema) complexity overhead every time a specific type of virtual class is derived. 5.7 Overcoming the is-a Incompatibility Problem A general solution to this problem is presented in [Run92a]. It is based on creating additional intermediate classes, so that the virtual class can be correctly integrated. Figure 5.7 shows how. The hierarchy is reorganized by the creation and insertion of classes C2 0 and C3 0 (Figure 5.7 (b)). <p> These conflicting dictations of where the virtual class should be placed comprise the is-a incompatibility problem. However, this problem is solved in <ref> [Run92a] </ref> when using the type preparation algorithm to solve the previously mentioned type inheritance problem. Therefore, no extra solution is provided. 5. Classifying the Virtual Classes 93 In our case, the situation is similar. All the operators used for deriving virtual classes are not subject to the subclass/subtype incompatibility problem. <p> Classes 94 5.8 Placing the Derived Classes in the Hierarchy Once the Subsumes () function is defined and the subsumption relationships between classes can be derived, we follow a common approach for the actual placement of the derived classes that is used in many of the proposed object-oriented view models <ref> [SL83, TYI88, AB91, Run92a] </ref>. This approach consists of finding all the direct super-and sub-classes of the virtual class and placing it under the former and above the latter. A very simple example of this technique was presented in Figure 5.2. <p> Specific algorithms for finding the direct superclasses and direct subclasses of the virtual class to be integrated can be found in <ref> [Run92a] </ref>. The set of direct superclasses can be found by a depth-first search of the global schema (in our case the view schema). This can be performed with linear complexity in the number of is-a arcs in the schema. <p> Subsuming the Class Relationships 97 Subsumes (A; B) = ( true; if B is-a A f ail; otherwise The general features of the Subsumes () function are described in [SL83]. In the context of object-oriented data models <ref> [Run92a] </ref>, Subsumes (A; B) is true if and only if: 1. For each property p i of A, there is an equivalent property p j defined for B. 2. <p> Comparing actual function bodies to determine equivalence of properties in condition 1 above is a potentially undecidable problem. Similarly, comparing arbitrary expressions that denote membership predicates, for instance, when considering condition 4 above, is also undecidable in general <ref> [Run92a] </ref>. We could, however, assume that each property function (method) has a unique property identifier. Then two property functions are equivalent if they have the same property identifier.
Reference: [Run92b] <author> E.A. Rundensteiner. </author> <title> Multiview: A Methodology for Supporting Multiple Views in Object-Oriented Databases. </title> <booktitle> In Proc., 18th VLDB Conf., </booktitle> <pages> pages 187-198, </pages> <year> 1992. </year>
Reference-contexts: Some of the proposals for view models in this direction are by Tanaka et al. [TYI88], by E.A.Rundensteiner <ref> [Run92b] </ref> and by Abiteboul and Bonner [AB91]. Tanaka et al. deal with schema virtualization. In their approach they do not clearly distinguish between the integration of derived classes into one common schema and the generation of view schemata. <p> After the definition and population of the virtual classes the system derives the internal structure and the behavior of that class. The new class can then be treated as any other class. 2. Database Views: A Trip Through the Past 18 Rundensteiner presents in <ref> [Run92b] </ref> a methodology, called M ultiview, for supporting multiple view schemata of a global schema. The view specification process is broken into three tasks. First new classes are derived, by means of an object algebra. Then the derived classes are integrated into one global schema. <p> We then describe the view definition process, and finally we discuss issues on generating new objects. 3.1 Preliminary Definitions In this section, we provide some basic definitions needed in the rest of the thesis. These definitions are similar in flavour to others in the literature <ref> [Ban88, AFD + 89, SLT91, Run92b] </ref>. Objects are instances of abstract data types (ADT's). Each object, o, in the infinite set of object instances, O, has an interface, by which the user can access and manipulate it. <p> The property is hidden in the class and in all its subclasses. To our knowledge, other approaches to object-oriented views <ref> [SLT91, Run92b] </ref>, when hiding a property in a class, create a new virtual class identical to the source class, but without the hidden property. <p> One way around this is to assume that each property has only one definition, and therefore, only one type. This is a common assumption in other models, including <ref> [SLT91, Run92b] </ref>. By using this assumption it would not be possible for us to have a salary of type integer and a salary of type letter. We would have to use a different name for defining an abstract salary, e.g., salaryLevel ) letter. <p> We should note however, that the view mechanism we present here does not depend on imaginary objects and can work without them. In fact, many other approaches <ref> [Run92b, SLT91, Ber92] </ref> do not even consider such objects. <p> AsiaOrAmerica I : ag InsectsOf (America) ag InsectsOf AsiaOrAmerica [X ) T ] ag InsectsOf (Asia)[X ) T 1 ] ^ ag InsectsOf (America)[X ) T 2 ] ^ lub (T 1 ; T 2 ; T ) 4.3 Special Issues 4.3.1 View Independence The concept view independence, introduced in <ref> [Run92b] </ref>, is intended to complement the earlier notion of data independence, developed for the relational model. A system is said to provide logical data independence if it supports a view mechanism which allows the user to support his own view schema on top of the common logical schema. <p> A database is said to provide view independence if "the specification and the semantics of existing view schemata are not affected by the definition of new view 4. The Underlying F-logic Implementation 74 schemata" <ref> [Run92b] </ref>. Therefore, proving a database to be view independent ensures that the view schema definition and semantics will be immune to changes of the underlying global schema. Within our model, however, the concept of view independence does not seem to have any significance. <p> Instead, he can import classes and objects from the existing view schema and perform slight restructurings, avoiding potentially large overhead. A more detailed 4. The Underlying F-logic Implementation 75 discussion of this issue is given later on, in the next chapter. 4.3.3 View Closure V iew closure <ref> [TYI88, HZ90, Run92b] </ref>, also known as interf ace coherence [AB91], is an issue concerning the property decomposition hierarchy. A view is called closed (or type-closed) when for every property visible in the view, its arguments and results are also visible in the same view. <p> When base class employee is imported into the view, its subclass, ta, of teaching assistants is automatically imported too. However, ta has a property teaches with domain teaches (ta) := student, which suggests that student should also be imported into the view, in order to avoid inconsistencies. In <ref> [Run92b] </ref> a simple algorithm that, given a view schema, calculates the minimal set of classes that should be added to it to make it closed, is presented. For every view 4. The Underlying F-logic Implementation 76 class C i , all its properties are checked in the following way.
Reference: [SL83] <author> J.G Schmolze and T.A Lipkis. </author> <title> Classification in the KL-ONE Knowledge Representation System. </title> <booktitle> International Joint Conference on Artificial Intelligence (IJCAI'83), </booktitle> <volume> 1 </volume> <pages> 330-332, </pages> <year> 1983. </year>
Reference-contexts: By doing so we get to enjoy all the previously described advantages of classification. To classify a 5. Classifying the Virtual Classes 84 virtual class, essentially means to take the class and place it where it belongs in the class hierarchy <ref> [SL83] </ref>. In general, assume a virtual class V C defined as including classes C 1 ... C k as well as objects from classes C k+1 ... C n . Then the superclasses and subclasses of V C are defined as follows [AB91] : 1. <p> Subsumption is a relation between classes, such that class A subsumes class B only if the extent (A) includes the extent (B). Subsumption is also an issue in the context of Concept [NS90], Frame-Based [BL84] and Semantic-Based Network <ref> [SL83] </ref> languages. <p> After the relationships are acquired, V C is placed above all its direct subclasses and bellow all its direct superclasses. In [Run92a] it is claimed that such a classification algorithm, which is repeatedly advocated in the literature <ref> [SL83, TYI88, AB91] </ref>, does not correctly account for the type inheritance underlying the schema graph. This is because of two problems that this algorithm does not address properly. These are the type inheritance mismatch and the is-a incompatibility problems. <p> Classes 94 5.8 Placing the Derived Classes in the Hierarchy Once the Subsumes () function is defined and the subsumption relationships between classes can be derived, we follow a common approach for the actual placement of the derived classes that is used in many of the proposed object-oriented view models <ref> [SL83, TYI88, AB91, Run92a] </ref>. This approach consists of finding all the direct super-and sub-classes of the virtual class and placing it under the former and above the latter. A very simple example of this technique was presented in Figure 5.2. <p> Therefore subsumption is a relation between classes, such that class A subsumes class B only if the extent (A) includes the extent (B). Subsumption has also been an issue in the context of Concept [NS90], Frame-Based [BL84] and Semantic-Based Network <ref> [SL83] </ref> languages. Testing for subsumption can be done by using a function Subsumes () defined as: 96 6. Subsuming the Class Relationships 97 Subsumes (A; B) = ( true; if B is-a A f ail; otherwise The general features of the Subsumes () function are described in [SL83]. <p> and Semantic-Based Network <ref> [SL83] </ref> languages. Testing for subsumption can be done by using a function Subsumes () defined as: 96 6. Subsuming the Class Relationships 97 Subsumes (A; B) = ( true; if B is-a A f ail; otherwise The general features of the Subsumes () function are described in [SL83]. In the context of object-oriented data models [Run92a], Subsumes (A; B) is true if and only if: 1. For each property p i of A, there is an equivalent property p j defined for B. 2.
Reference: [SLT91] <author> M. Scholl, C. Laasch, and M. Tresch. </author> <title> Updatable Views in Object-Oriented Databases. </title> <booktitle> In Proc 2nd DOOD Conf., </booktitle> <pages> pages 190-207, </pages> <address> Germany, </address> <year> 1991. </year>
Reference-contexts: Moreover, in an object-oriented view description, it is possible to include type descriptions as well as access and update methods. This can eliminate ambiguities when updating an object-oriented view. A model for updatable object-oriented views is presented in <ref> [SLT91] </ref>. 2. Database Views: A Trip Through the Past 15 2.2 Extending Relational Views In order to deal with the relational view update problem, Mylopoulos and Brodie [BMS84, BM87] presented an approach based on the notion of an abstract data type (ADT ). <p> Another proposal that considers a view to be a virtual class is that of Scholl et al. <ref> [SLT91] </ref>. They present a view mechanism for the COCOON object model. They use a subset of the operations of the COOL query language to derive virtual classes, each of which denotes a separate view. <p> We then describe the view definition process, and finally we discuss issues on generating new objects. 3.1 Preliminary Definitions In this section, we provide some basic definitions needed in the rest of the thesis. These definitions are similar in flavour to others in the literature <ref> [Ban88, AFD + 89, SLT91, Run92b] </ref>. Objects are instances of abstract data types (ADT's). Each object, o, in the infinite set of object instances, O, has an interface, by which the user can access and manipulate it. <p> A second issue related to imaginary objects concerns view updates. In the context of views, there are two directions in which updates can propagate <ref> [SLT91] </ref>: * updates on base objects should propagate to the corresponding view objects, and 3. The View Model 43 * updates on view objects should propagate to the underlying base objects, whenever possible. The latter is difficult to accomplish in the relational context. <p> Since, "object identity" corresponds to key attribute values, only views containing a key may be updated [SLW88]. On the other hand, in the object-oriented case, when only object-preserving operations are used, then updates seem to propagate in a natural way <ref> [SLT91] </ref>. However, updating in the presence of imaginary objects is not quite so straightforward. As we have already seen, to create imaginary objects, we assign object identifiers to tuples of values. That is, we map tuples to object identifiers. <p> The property is hidden in the class and in all its subclasses. To our knowledge, other approaches to object-oriented views <ref> [SLT91, Run92b] </ref>, when hiding a property in a class, create a new virtual class identical to the source class, but without the hidden property. <p> One way around this is to assume that each property has only one definition, and therefore, only one type. This is a common assumption in other models, including <ref> [SLT91, Run92b] </ref>. By using this assumption it would not be possible for us to have a salary of type integer and a salary of type letter. We would have to use a different name for defining an abstract salary, e.g., salaryLevel ) letter. <p> We should note however, that the view mechanism we present here does not depend on imaginary objects and can work without them. In fact, many other approaches <ref> [Run92b, SLT91, Ber92] </ref> do not even consider such objects. <p> In this chapter, we argue that it is quite advantageous to integrate the derived classes into the is-a hierarchy. The necessity of classifying the virtual classes has been indicated in many other approaches <ref> [TYI88, AB91, SLT91, Run92a] </ref>, in contrast to earlier approaches, in which the virtual classes are treated as "stand-alone"objects [HZ90] or are attached as direct subclasses to the schema root class [Kim89]. 5.1 Classification in General Class classif ication, also called class integration, is the process of taking a new class and <p> These problems are closely related to object-oriented data models and, therefore, are not handled appropriately by earlier work on classification. The first problem is the inheritance mismatch in the type hierarchy <ref> [SLT91, Run92a] </ref>, and the other is composing is-a incompatible subset and subtype hierarchies into one consistent class hierarchy [Run92a]. <p> Allowing, for example, an object instance to simultaneously be a member of many classes means that this object can take on different types <ref> [AB91, SLT91] </ref>. This immediately raises several implementation issues, as for instance, 7. Conclusions and Future Work 135 the development of efficient strategies for method resolution. Other important database issues for future work, include query processing techniques on views, materialized views and view updates. <p> Conclusions and Future Work 135 the development of efficient strategies for method resolution. Other important database issues for future work, include query processing techniques on views, materialized views and view updates. When updates are considered and when imaginary objects are not allowed, updates can propagate naturally <ref> [SLT91] </ref>. In our case, however, where additional functionality is provided by permitting the generation of new objects, the issue of view updates requires a further examination. Generated objects result from the assignment of object identifiers to tuples of values. As a result of an update, two tuples can become identical.
Reference: [SLW88] <author> A.P. Sheth, J.A. Larson, and E. Watkins. TAILOR, </author> <title> a Tool for Updating Views. </title> <editor> In J.W.Shmidt, S.Ceri, and M. Missikofff, editors,. </editor> <booktitle> In Proc. Int. Conf. on Advances in Database Technology (EDBT), </booktitle> <pages> pages 190-213. </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The View Model 43 * updates on view objects should propagate to the underlying base objects, whenever possible. The latter is difficult to accomplish in the relational context. Since, "object identity" corresponds to key attribute values, only views containing a key may be updated <ref> [SLW88] </ref>. On the other hand, in the object-oriented case, when only object-preserving operations are used, then updates seem to propagate in a natural way [SLT91]. However, updating in the presence of imaginary objects is not quite so straightforward.
Reference: [SS89] <author> J.J. Shilling and P.F. Sweeney. </author> <title> Extending the Object-Oriented Paradigm. </title> <booktitle> In Proc. of the International Conference of Object-Oriented Programming, Systems, Languages and Applications (OOPSLA'89), </booktitle> <pages> pages 353-361, </pages> <address> New Orleans, </address> <year> 1989. </year>
Reference-contexts: Methods for the verifying the correctness of these updates have to be used. 2.3 Other Ob ject-Oriented Approaches 2.3.1 Allowing Multiple ADT Interfaces Shilling and Sweeney's approach <ref> [SS89] </ref> falls into this category. They allow a class to have multiple abstract data type interfaces (types), instead of having just one. This can be used in order to limit the access rights to property functions and to control the visibility of instance variables.
Reference: [SSS88] <author> M. Schmidt-Schaus and G. Smolka. </author> <title> Attributive Concept Descriptions with Unions and Complements. </title> <type> Technical Report SR-88-21, SEKI, </type> <institution> FB Informatik, Univeristat Kaiserslauten, Kaiserslauten, Germany, </institution> <year> 1988. </year>
Reference-contexts: However, adding this qualified existential role quantification construct to PL 1 would result in the ALE concept language <ref> [SSS88] </ref>, for which satisfiability (and therefore subsumption) is proved to be N P -complete [DHL + 90]. Hence, although we cannot test subsumption in polynomial time in the presence of set valued attributes, it can still be 6.
Reference: [SY81] <author> Y. Sagiv and M. Yannakakis. </author> <title> Equivalence Among Relational Expressions With the Union and Difference Operators. </title> <journal> J.ACM, </journal> <volume> 27(4) </volume> <pages> 633-655, </pages> <year> 1981. </year>
Reference-contexts: This technique is based on earlier work done on optimization of conjunctive queries in the context of the relational model <ref> [CM77, SY81, ?, Ull89] </ref>. In that framework, testing for equivalence of conjunctive queries is translated into testing containment in both directions. One conjunctive query is contained in another in the sense that every answer returned by the former is also returned by the latter.
Reference: [Thu89] <author> M.B. Thuraisinghani. </author> <title> Mandatory and Discretionary Security Issues in Object-Oriented Database Systems. </title> <booktitle> In Proc. of Object-Oriented Programming Languages, Systems and Applications Conf., </booktitle> <year> 1989. </year>
Reference: [TYI88] <author> K. Tanaka, M. Yoshikawa, and K. Ishihara. </author> <title> Schema Virtualization in Object-Oriented Databases. </title> <booktitle> In Proc. IEEE Data Eng. Conf., </booktitle> <pages> pages 23-30, </pages> <year> 1988. </year> <note> 8. Bibliography 140 </note>
Reference-contexts: Some of the proposals for view models in this direction are by Tanaka et al. <ref> [TYI88] </ref>, by E.A.Rundensteiner [Run92b] and by Abiteboul and Bonner [AB91]. Tanaka et al. deal with schema virtualization. In their approach they do not clearly distinguish between the integration of derived classes into one common schema and the generation of view schemata. <p> The above definition enables us to see a view just as a database, but with no proper data of its own. We will also use the term virtual schema, to refer to a view, as it is commonly used in <ref> [TYI88, AB91] </ref>. 3.2 The Model in General The model we are going to present in the rest of this chapter, comes from the earlier work by S.Abiteboul and A.J.Bonner. In [AB91] they give an informal description of a view mechanism for the O 2 object-oriented data model. <p> Instead, he can import classes and objects from the existing view schema and perform slight restructurings, avoiding potentially large overhead. A more detailed 4. The Underlying F-logic Implementation 75 discussion of this issue is given later on, in the next chapter. 4.3.3 View Closure V iew closure <ref> [TYI88, HZ90, Run92b] </ref>, also known as interf ace coherence [AB91], is an issue concerning the property decomposition hierarchy. A view is called closed (or type-closed) when for every property visible in the view, its arguments and results are also visible in the same view. <p> In this chapter, we argue that it is quite advantageous to integrate the derived classes into the is-a hierarchy. The necessity of classifying the virtual classes has been indicated in many other approaches <ref> [TYI88, AB91, SLT91, Run92a] </ref>, in contrast to earlier approaches, in which the virtual classes are treated as "stand-alone"objects [HZ90] or are attached as direct subclasses to the schema root class [Kim89]. 5.1 Classification in General Class classif ication, also called class integration, is the process of taking a new class and <p> After the relationships are acquired, V C is placed above all its direct subclasses and bellow all its direct superclasses. In [Run92a] it is claimed that such a classification algorithm, which is repeatedly advocated in the literature <ref> [SL83, TYI88, AB91] </ref>, does not correctly account for the type inheritance underlying the schema graph. This is because of two problems that this algorithm does not address properly. These are the type inheritance mismatch and the is-a incompatibility problems. <p> Classes 94 5.8 Placing the Derived Classes in the Hierarchy Once the Subsumes () function is defined and the subsumption relationships between classes can be derived, we follow a common approach for the actual placement of the derived classes that is used in many of the proposed object-oriented view models <ref> [SL83, TYI88, AB91, Run92a] </ref>. This approach consists of finding all the direct super-and sub-classes of the virtual class and placing it under the former and above the latter. A very simple example of this technique was presented in Figure 5.2.
Reference: [Ull88] <author> J.D. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems. </booktitle> <volume> Vol. 1, </volume> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: These operations can be easily combined with the use of an algebraic notation called relational algebra. All these lead to the ability of the relational model to support simple, yet powerful, declarative languages, which is perhaps the most important reason for the model's popularity <ref> [Ull88] </ref>. However, besides being an important feature, value-orientation is also a serious drawback. One reason is the lack of an explicit modelling of relationships between tuples, and of relationships between relation schemes. <p> It is, more specifically, a set manipulation operator that selects a set of objects from a class. It resembles the selection operation of relational algebra <ref> [Ull88, Dat90] </ref>. The view classes created by specialization can be further specialized. schema. All subclasses of employee are imported as well.
Reference: [Ull89] <author> J.D. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems. </booktitle> <volume> Vol. 2, </volume> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: The first approach is based on earlier work done in the field of concept languages [DLNN91], while the second is based on containment of conjunctive queries in the context of query optimization <ref> [Ull89] </ref>. 6. Subsuming the Class Relationships 99 6.2 Subsumption Within our Model When a virtual class C is derived, the classifier will use the subsumption procedure to derive any relationships holding between the new class and the other existing view classes C i . <p> This technique is based on earlier work done on optimization of conjunctive queries in the context of the relational model <ref> [CM77, SY81, ?, Ull89] </ref>. In that framework, testing for equivalence of conjunctive queries is translated into testing containment in both directions. One conjunctive query is contained in another in the sense that every answer returned by the former is also returned by the latter. <p> As is easy to see, the notion of containment is identical to that of sub-sumption. We will, therefore, be using both terms interchangeably. Basic Notions We start out with some basic notions, and then go on to describe the technique as devised for the relational case <ref> [Ull89] </ref>. A conjunctive query is a single rule consisting of a conjunction (logical AND) of subgoals. <p> Containment mappings are used to determine containment of conjunctive queries. More specifically, if Q 1 and Q 2 are as above, then Q 1 is contained in Q 2 , if and only if there is a containment mapping from Q 2 to Q 1 <ref> [Ull89] </ref>. An example illustrating all the above is presented next. Consider the conjunctive queries a 1 and a 2 : a 1 : p (X,Y) :- e (Y,X) & e (X,Z). 6. <p> A containment, ff, from Q to R is a map from the conjunctive queries in Q to those in R, such that if ff (Q i ) = R j , then Q i R j <ref> [Ull89] </ref>, where the latter is a containment between two conjunctive queries (as defined above). <p> We will discuss the problems that arise and devise appropriate solutions. All this is done in a descriptive manner accompanied by the presentation of illustrative examples. The technique The technique for testing subsumption in the relational model has as follows <ref> [Ull89] </ref>. To test whether Q 1 Q 2 it suffices to test for an existing containment mapping from Q 2 to 6. Subsuming the Class Relationships 114 Q 1 . <p> Therefore, testing for subsumption between two classes that have extended definitions is translated into testing for containment between unions of conjunctive queries. Such a test has the same complexity as the complexity of testing containment between two conjunctive queries. That is, exponential in the size of the queries <ref> [Ull89] </ref>. Placing a derived class V C in the hierarchy can now be summarized as follows. The F-logic rule used to specify V C serves as V C's original predicate. This predicate comprises V C's initial definition. <p> The compatibility of our technique with that devised for the relational model, allows our technique to be extended in a natural way whenever the technique for the relational case is extended, e.g., to include arithmetic comparison predicates or logical recursions <ref> [Ull89] </ref>. Chapter 7 Conclusions and Future Work 7.1 Contributions In the preceding chapters, we presented an approach to supporting multiple views of an object-oriented database schema. In this approach, a view is treated as a database that imports all its data from other databases. <p> Low complexity is achieved by restricting the set of permitted queries for class derivation. The second technique is based on a technique for testing containment of conjunctive queries in the context of the relational model <ref> [Ull89] </ref>. We have modified the technique in order to make it suitable for the object-oriented model. Our technique accounts for all conjunctive queries. This expressiveness is accomplished with a complexity that is exponential to the size of the input queries.
References-found: 39

