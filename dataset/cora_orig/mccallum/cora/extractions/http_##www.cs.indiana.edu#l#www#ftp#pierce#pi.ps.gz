URL: http://www.cs.indiana.edu/l/www/ftp/pierce/pi.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/
Root-URL: http://www.cs.indiana.edu
Title: Typing and Subtyping for Mobile Processes  
Author: Benjamin Pierce Davide Sangiorgi 
Date: May 10, 1994  
Abstract: The -calculus is a process algebra that supports process mobility by focusing on the communication of channels. Milner's presentation of the -calculus includes a type system assigning arities to channels and enforcing a corresponding discipline in their use. We extend Milner's language of types by distinguishing between the ability to read from a channel, the ability to write to a channel, and the ability both to read and to write. This refinement gives rise to a natural subtype relation similar to those studied in typed -calculi. The greater precision of our type discipline yields stronger versions of standard theorems about the -calculus. These can be used, for example, to obtain the validity of fi-reduction for the more efficient of Milner's encodings of the call-by-value -calculus, which fails in the ordinary -calculus. We define the syntax, typing, subtyping, and operational semantics of our calculus, prove that the typing rules are sound, apply the system to Milner's -calculus encodings, and sketch extensions to higher-order process calculi and polymorphic typing.
Abstract-found: 1
Intro-found: 1
Reference: [Abr89] <author> S. Abramsky. </author> <title> The lazy lambda calculus. </title> <editor> In D. Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, </booktitle> <pages> pages 65-116. </pages> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Finally, for the case of the rule R-Eqv, use Lemmas 3.3.1 and 3.3.2 and the induction assumption. 2 16 4 Lambda calculus encodings The use of I/O tags arises naturally in many applications. As an example, we consider Milner's encodings [Mil90] of lazy -calculus and call-by-value -calculus <ref> [Abr89, Plo75] </ref>. For each encoding, we first present Milner's original version and then assign sorts to the channels in the translation. We abbreviate the process expression (- m) (P j !m (~x) : R) as P fm (~x) := Rg. <p> We give fm (~x) := Rg tighter precedence than j ; thus Q j P fm (~x) := Rg stands for Q j (P fm (~x) := Rg). 4.1 The lazy -calculus In Abramsky's lazy lambda calculus <ref> [Abr89] </ref>, only leftmost redexes can be reduced. There are two reduction rules: (fi) (x:M )N =) M fN=xg (App) M N =) M 0 N The core of the encoding of lazy -terms into -calculus is the translation of function application.
Reference: [AC91] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <booktitle> In Proceedings of the Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 104-118, </pages> <address> Orlando, FL, </address> <month> January </month> <year> 1991. </year> <note> Also available as DEC Systems Research Center Research Report number 62, August 1990. To appear in TOPLAS. </note>
Reference-contexts: The subsort relation is formalized in Section 2 using a notion of simulation of regular trees and treated using techniques similar to those developed by Amadio and Cardelli for -calculi with subtyping and recursive types <ref> [AC91] </ref>. Section 3 proves the soundness of the resulting type system. The greater precision of our type discipline yields stronger versions of some standard theorems about the -calculus.
Reference: [Car86] <author> Luca Cardelli. </author> <title> Amber. </title> <editor> In Guy Cousineau, Pierre-Louis Curien, and Bernard Robinet, editors, </editor> <booktitle> Combinators and Functional Programming Languages, </booktitle> <pages> pages 21-47. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> Lecture Notes in Computer Science No. 242. </note>
Reference-contexts: The ref constructor, like our b tag, is constrained by both requirements and behaves non-variantly in the subtype relation. A different analogy relates our definition of subsorting and the subtype relations found in some typed -calculi <ref> [Car86, CW85, Rey85] </ref>. <p> The subsort relation now generates a natural subtype relation using the standard subtyping rule for function types. This extension essentially amounts to adjoining to our system a standard functional type system along the lines of Cardelli's simply typed -calculi with subtyping <ref> [Car86] </ref>. 6.3 Polymorphism A general theme in this paper has been the observation that a type system for a process calculus can be presented using concepts familiar from the literature on typed -calculi.
Reference: [Cou83] <author> B. Courcelle. </author> <title> Fundamental properties of infinite trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 25 </volume> <pages> 95-169, </pages> <year> 1983. </year>
Reference-contexts: Although the change from by-name to by-structure matching entails some loss of precision in the sortings (we give up the ability to prevent mixing of "accidentally isomorphic" data structures) it substantially simplifies the technical aspects of the system by allowing sorts to be treated as regular trees <ref> [Cou83] </ref>. Our subsort relation can be motivated by the common situation in which two processes must cooperate in the use of a shared resource such as a printer.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: The ref constructor, like our b tag, is constrained by both requirements and behaves non-variantly in the subtype relation. A different analogy relates our definition of subsorting and the subtype relations found in some typed -calculi <ref> [Car86, CW85, Rey85] </ref>.
Reference: [dB72] <author> Nicolas G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: This is equivalent to regarding alphabetic variable names | channel names and sort variables | as informal abbreviations for an underlying representation based on de Bruijn indices <ref> [dB72] </ref>, and implies the usual conventions about name capture during substitution, alpha-conversion, side-conditions concerning freshness of names, etc.
Reference: [EN86] <author> U. Engberg and M. Nielsen. </author> <title> A calculus of communicating systems with label-passing. </title> <type> Report DAIMI PB-208, </type> <institution> Computer Science Department, University of Aarhus, Denmark, </institution> <year> 1986. </year>
Reference-contexts: 1 Introduction Milner, Parrow, and Walker's -calculus [MPW92] achieved a remarkable simplification and generalization of its predecessors (including CCS [Mil89] and ECCS <ref> [EN86] </ref>) by focusing on naming and allowing the data values communicated along channels to be channels themselves. The calculus can be presented with a handful of rules, but is sufficiently expressive to describe concurrent systems in which the topology of communication may evolve dynamically.
Reference: [Gay93] <author> Simon J. Gay. </author> <title> A sort inference algorithm for the polyadic -calculus. </title> <booktitle> In Proceedings of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: Milner's sort discipline plays an essential role in later papers on properties of the -calculus [Wal92, San92]; it has been further studied by Turner [Tur94], Gay <ref> [Gay93] </ref>, and Vasconcelos and Honda [VH93], who consider the problem of inferring most general sortings. Our typing discipline retains the basic character of Milner's, while extending it in two dimensions. <p> The algorithmic problem of inferring these annotations is deferred to future investigation (c.f. <ref> [Tur94, Gay93, VH93] </ref>). Our basic syntactic categories are defined by the grammar in We use the metavariables S, T , and U for sorts; P , Q, and R for process expressions; and for sorting assumptions (or sortings); and a, b, c, etc. for channels (or names).
Reference: [Gir72] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: Carrying this program a step further leads us to wonder what role the polymorphism found in ML [Mil78] or the polymorphic -calculus <ref> [Gir72, Rey74] </ref> might play in typing for processes.
Reference: [GR93] <author> P. Glavan and D. Rosenzweig. </author> <title> Communicating evolving algebras. </title> <editor> In E. Borger, S. Martini, G. Jager, H. Kleine Buning, and M.M. Richter, editors, </editor> <booktitle> Computer Science Logic, Selected Papers from CSL'92, volume 702 of Lecture Notes in Computer Science, </booktitle> <pages> pages 186-215. </pages> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The results preceding Lemma A.5 are needed for its proof. We start by noticing that the derivation of an interaction can be put into a standard form in which the rule R-Eqv is used at most once, at the end (this lemma also appears in <ref> [GR93] </ref>). A.1. Lemma: Suppose Q!Q 0 . Then there is a derivation of Q!Q 0 in which R-Eqv appears only as the outermost step, or not at all.
Reference: [Mil78] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: Carrying this program a step further leads us to wonder what role the polymorphism found in ML <ref> [Mil78] </ref> or the polymorphic -calculus [Gir72, Rey74] might play in typing for processes.
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Milner, Parrow, and Walker's -calculus [MPW92] achieved a remarkable simplification and generalization of its predecessors (including CCS <ref> [Mil89] </ref> and ECCS [EN86]) by focusing on naming and allowing the data values communicated along channels to be channels themselves. The calculus can be presented with a handful of rules, but is sufficiently expressive to describe concurrent systems in which the topology of communication may evolve dynamically. <p> A.9. Lemma: Suppose &lt; is a barbed -bisimulation up to ~ ; then &lt; ~ Proof: Standard technique for bisimulation up to a strong bisimulation <ref> [Mil89] </ref>. 2 We are now ready to give the proof of Lemma 5.2.2. We first recall its assertion: Lemma 5.2.2: Let P 1 and P 2 be two processes obeying the sorting .
Reference: [Mil90] <author> R. Milner. </author> <title> Functions as processes. </title> <type> Research Report 1154, </type> <institution> INRIA, Sophia Antipolis, </institution> <year> 1990. </year> <note> Final version in Journal of Mathem. Structures in Computer Science 2(2) 119-141, </note> <year> 1992. </year>
Reference-contexts: The calculus can be presented with a handful of rules, but is sufficiently expressive to describe concurrent systems in which the topology of communication may evolve dynamically. Moreover, the existence of natural embeddings of both lazy and call-by-value - calculi into the -calculus <ref> [Mil90] </ref> suggests that it may form an appropriate foundation for the design of new programming languages. Milner extended the original -calculus to a polyadic -calculus, in which finite tuples of names, instead of single names, are the atomic unit of communication [Mil91]. <p> The result follows by induction. Finally, for the case of the rule R-Eqv, use Lemmas 3.3.1 and 3.3.2 and the induction assumption. 2 16 4 Lambda calculus encodings The use of I/O tags arises naturally in many applications. As an example, we consider Milner's encodings <ref> [Mil90] </ref> of lazy -calculus and call-by-value -calculus [Abr89, Plo75]. For each encoding, we first present Milner's original version and then assign sorts to the channels in the translation. We abbreviate the process expression (- m) (P j !m (~x) : R) as P fm (~x) := Rg. <p> The reduction relation used by Milner in <ref> [Mil90] </ref> is described by the rules fi v , App L , App R : (fi v ) (x:M )(y:N ) =) M fy:N=xg (App L ) M N =) M 0 N N =) N 0 17 By contrast with the lazy -calculus, in the application M N , also <p> We call v a pivot. (In the lazy -calculus encoding, the role of the pivot names was played by the argument port names.) In the original version of his paper on Functions as Processes <ref> [Mil90] </ref>, Milner presented two candidates for the encoding of a version of call-by-value -calculus [Plo75]. They follow the same idea of translation, but with a technical difference in the rule for variables. <p> As the computation proceeds, these buffers are chained together, gradually increasing the number of steps necessary to simulate a fi-reduction. This phenomenon does not occur in V 0 , where a variable disappears after it is used. But the proofs in <ref> [Mil90] </ref> were conducted with V; the analysis of V 0 seemed more difficult and was left open. Indeed, Sangiorgi showed [San92] that, in the standard -calculus, fi-reduction is not valid for V 0 , i.e. <p> lazy -calculus, the outermost tag of the sort of the names bound by a restriction is b; therefore, such argument ports, triggers, and pivots have sorts (S t ) b , (S p ) b and (S t ; S a ) b , respectively. 1 The final version of <ref> [Mil90] </ref>, which appeared in the Joural of Mathematical Structures, was written after the results in [San92] were known and presents only the encoding V. 18 5 Behavioral equivalence In this section we examine the effect of our sorting discipline on the semantics of processes. 5.1 Contexts A process context (or just <p> For instance, these theorems play a pivotal role in the proof of validity of fi-reduction for Milner's encodings of -calculus <ref> [Mil90] </ref>, as well as in the proof of representability of higher-order -calculus in first order -calculus [San92].
Reference: [Mil91] <author> R. Milner. </author> <title> The polyadic -calculus: a tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> LFCS, Dept. of Comp. Sci., Edinburgh Univ., </institution> <month> October </month> <year> 1991. </year> <title> Also in Logic and Algebra of Specification, </title> <editor> ed. F.L. Bauer, W. Brauer and H. Schwichtenberg, </editor> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Milner extended the original -calculus to a polyadic -calculus, in which finite tuples of names, instead of single names, are the atomic unit of communication <ref> [Mil91] </ref>. <p> We call a sort S guarded if it has the form S = ( ~ S) I . We often write the process expression ff: 0, where ff is an input or output prefix, as just ff. Also, following Milner <ref> [Mil91] </ref>, we introduce an explicit replication operator ! instead of allowing systems of recursive definitions of process expressions; ! P stands for the parallel composition of an infinite (countable) number of copies of P . To simplify the presentation, we omit the notational devices of abstraction and concretion [Mil91] and the <p> following Milner <ref> [Mil91] </ref>, we introduce an explicit replication operator ! instead of allowing systems of recursive definitions of process expressions; ! P stands for the parallel composition of an infinite (countable) number of copies of P . To simplify the presentation, we omit the notational devices of abstraction and concretion [Mil91] and the basic operations of summation of processes and matching of names. We believe that our results can be extended straightforwardly to a calculus including summation, abstraction, and concretion, while the case of matching is more delicate; Section 6.1 discusses these extensions. <p> Other papers on the -calculus or extensions of it (e.g. <ref> [Mil91, San92] </ref>) use a similar bracket nesting notation for higher-order sorts, i.e. sorts of process abstractions. <p> I ((S 1 ; : : : ; S n ) ) = I I i extracts the I/O annotation of the ith component of a sort: I i ((S 1 ; : : : ; S n ) ) = I (S i ) 2.2 Reduction Semantics Following Milner <ref> [Mil91] </ref>, we present the operational semantics of the -calculus using two relations: a structural equivalence on process terms that permits the rearrangement of parallel compositions, replications, and restrictions so that the participants in a potential communication can be brought into immediate proximity; and a reduction relation that describes the act of <p> Then it holds that (ff: P )fa (~x) := Rg ~ ff: (P fa (~x) := Rg). The schema of the proof of validity of fi reduction for V 0 is the same used by Milner to show the analogous result for the lazy -calculus encoding <ref> [Mil91] </ref>. The sorts of the names for V 0 have been described in Section 4; for simplicity, explicit sort annotations and subscripts (e.g. on bisimulations) are omitted. C.2. Theorem: V 0 [[(x:M )(y:N )]]hpi V 0 [[M f y:N =xg]]hpi.
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, (Parts I and II). </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Milner, Parrow, and Walker's -calculus <ref> [MPW92] </ref> achieved a remarkable simplification and generalization of its predecessors (including CCS [Mil89] and ECCS [EN86]) by focusing on naming and allowing the data values communicated along channels to be channels themselves.
Reference: [MS92] <author> R. Milner and D. Sangiorgi. </author> <title> Barbed bisimulation. </title> <editor> In W. Kuich, editor, </editor> <booktitle> 19th ICALP, volume 623 of Lecture Notes in Computer Science, </booktitle> <pages> pages 685-695. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In <ref> [MS92, San92] </ref>, Milner and Sangiorgi propose barbed bisimulation as a tool for uniformly defining bisimulation-based equivalences in different calculi.
Reference: [Plo75] <author> G.D Plotkin. </author> <title> Call by name, call by value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: Finally, for the case of the rule R-Eqv, use Lemmas 3.3.1 and 3.3.2 and the induction assumption. 2 16 4 Lambda calculus encodings The use of I/O tags arises naturally in many applications. As an example, we consider Milner's encodings [Mil90] of lazy -calculus and call-by-value -calculus <ref> [Abr89, Plo75] </ref>. For each encoding, we first present Milner's original version and then assign sorts to the channels in the translation. We abbreviate the process expression (- m) (P j !m (~x) : R) as P fm (~x) := Rg. <p> We call v a pivot. (In the lazy -calculus encoding, the role of the pivot names was played by the argument port names.) In the original version of his paper on Functions as Processes [Mil90], Milner presented two candidates for the encoding of a version of call-by-value -calculus <ref> [Plo75] </ref>. They follow the same idea of translation, but with a technical difference in the rule for variables.
Reference: [PS93] <author> J. Parrow and D. Sangiorgi. </author> <title> Algebraic theories for name-passing calculi. </title> <type> Technical Report ECS-LFCS-93-262, </type> <institution> LFCS, Dept. of Comp. Sci., Edinburgh Univ., </institution> <year> 1993. </year> <note> To appear in Information and Compuation. Short version to appear in the Proc. REX Summer School/Symposium 1993, </note> <editor> LNCS, </editor> <publisher> Springer Verlag. </publisher>
Reference-contexts: abort the others, and a matching operator [a = c]P , which allows P to proceed only if a and c are the same channel. (It seems that both operators may often be avoided in practice, although they play an important theoretical role, for instance, in axiomatisations of behavioral equivalences <ref> [San93, PS93] </ref>.) Our basic results should extend straightforwardly to summation, whose behavior under typing is exactly like that of parallel composition. Matching, however, is more problematic, since adding it in unrestricted form would destroy some of the basic results presented in Section 5.
Reference: [Rey74] <author> John Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proc. Colloque sur la Programmation, </booktitle> <pages> pages 408-425, </pages> <address> New York, 1974. </address> <publisher> Springer-Verlag LNCS 19. </publisher>
Reference-contexts: Carrying this program a step further leads us to wonder what role the polymorphism found in ML [Mil78] or the polymorphic -calculus <ref> [Gir72, Rey74] </ref> might play in typing for processes.
Reference: [Rey85] <author> John Reynolds. </author> <title> Three approaches to type structure. </title> <booktitle> In Mathematical Foundations of Software Development. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <note> Lecture Notes in Computer Science No. 185. </note>
Reference-contexts: The ref constructor, like our b tag, is constrained by both requirements and behaves non-variantly in the subtype relation. A different analogy relates our definition of subsorting and the subtype relations found in some typed -calculi <ref> [Car86, CW85, Rey85] </ref>.
Reference: [Rey88] <author> John C. Reynolds. </author> <title> Preliminary design of the programming language Forsythe. </title> <type> Technical Report CMU-CS-88-159, </type> <institution> Carnegie Mellon University, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: Note that the subsort relation is invariant under folding and unfolding of recursively defined sorts, since Tree (A: S) = Tree (Sf (A: S) =Ag). There is a close analogy between channel sorts and the reference types found in some programming languages. In Reynolds's language Forsythe <ref> [Rey88] </ref>, for example, the type of a mutable storage cell holding a value of type T can be written ref (T ), an abbreviation for sink (T )^source (T ). (Reynolds's actual notation is slightly different.) That is, a mutable cell containing an element of T is viewed as a connected
Reference: [San92] <author> D. Sangiorgi. </author> <title> Expressing Mobility in Process Algebras: First-Order and Higher-Order Paradigms. </title> <type> PhD thesis CST-99-93, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1992. </year> <month> 34 </month>
Reference-contexts: Milner's sort discipline plays an essential role in later papers on properties of the -calculus <ref> [Wal92, San92] </ref>; it has been further studied by Turner [Tur94], Gay [Gay93], and Vasconcelos and Honda [VH93], who consider the problem of inferring most general sortings. Our typing discipline retains the basic character of Milner's, while extending it in two dimensions. <p> Other papers on the -calculus or extensions of it (e.g. <ref> [Mil91, San92] </ref>) use a similar bracket nesting notation for higher-order sorts, i.e. sorts of process abstractions. <p> This phenomenon does not occur in V 0 , where a variable disappears after it is used. But the proofs in [Mil90] were conducted with V; the analysis of V 0 seemed more difficult and was left open. Indeed, Sangiorgi showed <ref> [San92] </ref> that, in the standard -calculus, fi-reduction is not valid for V 0 , i.e. V 0 [[(x:M )y:N ]]hpi and V 0 [[M f y:N =xg]]hpi may not be behaviorally equivalent 1 (the same counterexample used in [San92] applies to the calculus used in this paper, which is a subcalculus <p> Indeed, Sangiorgi showed <ref> [San92] </ref> that, in the standard -calculus, fi-reduction is not valid for V 0 , i.e. V 0 [[(x:M )y:N ]]hpi and V 0 [[M f y:N =xg]]hpi may not be behaviorally equivalent 1 (the same counterexample used in [San92] applies to the calculus used in this paper, which is a subcalculus of the one in [San92]). Nevertheless V 0 yields a precise operational correspondence between -terms and their process encodings, and intuitively one expects V 0 to be correct. <p> V 0 [[(x:M )y:N ]]hpi and V 0 [[M f y:N =xg]]hpi may not be behaviorally equivalent 1 (the same counterexample used in <ref> [San92] </ref> applies to the calculus used in this paper, which is a subcalculus of the one in [San92]). Nevertheless V 0 yields a precise operational correspondence between -terms and their process encodings, and intuitively one expects V 0 to be correct. <p> is b; therefore, such argument ports, triggers, and pivots have sorts (S t ) b , (S p ) b and (S t ; S a ) b , respectively. 1 The final version of [Mil90], which appeared in the Joural of Mathematical Structures, was written after the results in <ref> [San92] </ref> were known and presents only the encoding V. 18 5 Behavioral equivalence In this section we examine the effect of our sorting discipline on the semantics of processes. 5.1 Contexts A process context (or just context) C is a process expression with a hole in it. <p> In <ref> [MS92, San92] </ref>, Milner and Sangiorgi propose barbed bisimulation as a tool for uniformly defining bisimulation-based equivalences in different calculi. <p> By itself, barbed bisimulation is a rather coarse relation. Better discriminating power is achieved by considering the induced congruence, called barbed congruence. It can be shown <ref> [San92] </ref> that barbed congruence coincides in both CCS and -calculus with the standard bisimilarity congruences, at least if the grammar of these languages is sufficiently rich (for instance, in [San92] infinite recursive definitions of agents and agents with an infinite number of free names are allowed). <p> Better discriminating power is achieved by considering the induced congruence, called barbed congruence. It can be shown <ref> [San92] </ref> that barbed congruence coincides in both CCS and -calculus with the standard bisimilarity congruences, at least if the grammar of these languages is sufficiently rich (for instance, in [San92] infinite recursive definitions of agents and agents with an infinite number of free names are allowed). Of course, in a sorted calculus, the processes being compared must obey the same sorting and the contexts employed must be compatible with this sorting. 5.2.1. <p> For instance, these theorems play a pivotal role in the proof of validity of fi-reduction for Milner's encodings of -calculus [Mil90], as well as in the proof of representability of higher-order -calculus in first order -calculus <ref> [San92] </ref>. However, in the basic -calculus the theorems must be accompanied by a fairly heavy side condition on the use of names in P , Q, and R, namely that m may occur free only as the channel along which an output occurs. <p> Following Sangiorgi <ref> [San92] </ref>, we can enrich our language of sorts to include descriptions of channels carrying processes | e.g. (ffi) b | channels carrying processes abstracted on processes | e.g. (ffi!ffi) b | and so on.
Reference: [San93] <author> D. Sangiorgi. </author> <title> A theory of bisimulation for the -calculus. </title> <type> Technical Report ECS-LFCS-93-270, </type> <institution> LFCS, Dept. of Comp. Sci., Edinburgh Univ., </institution> <year> 1993. </year> <title> Extended Abstract in Proc. </title> <booktitle> CONCUR '93, volume 715 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: abort the others, and a matching operator [a = c]P , which allows P to proceed only if a and c are the same channel. (It seems that both operators may often be avoided in practice, although they play an important theoretical role, for instance, in axiomatisations of behavioral equivalences <ref> [San93, PS93] </ref>.) Our basic results should extend straightforwardly to summation, whose behavior under typing is exactly like that of parallel composition. Matching, however, is more problematic, since adding it in unrestricted form would destroy some of the basic results presented in Section 5.
Reference: [Tur94] <author> David N. Turner, </author> <year> 1994. </year> <type> Ph.D. thesis, </type> <institution> LFCS, University of Edinburgh. </institution> <note> In preparation. </note>
Reference-contexts: Milner's sort discipline plays an essential role in later papers on properties of the -calculus [Wal92, San92]; it has been further studied by Turner <ref> [Tur94] </ref>, Gay [Gay93], and Vasconcelos and Honda [VH93], who consider the problem of inferring most general sortings. Our typing discipline retains the basic character of Milner's, while extending it in two dimensions. <p> the sorting a : S S 7! (S 1 ) S 2 7! () even though it is well formed under the isomorphic sorting a : S S 7! (S 1 ) S 2 7! (): 2 A by-structure presentation of Milner's -calculus sorting has been studied independently by Turner <ref> [Tur94] </ref>. His system is essentially identical to the fragment of ours in which subtyping is omitted. 2 By contrast, in our system only the recursive structure of sorts is significant. <p> The algorithmic problem of inferring these annotations is deferred to future investigation (c.f. <ref> [Tur94, Gay93, VH93] </ref>). Our basic syntactic categories are defined by the grammar in We use the metavariables S, T , and U for sorts; P , Q, and R for process expressions; and for sorting assumptions (or sortings); and a, b, c, etc. for channels (or names). <p> A similar polymorphic extension of -calculus sorting has been proposed independently by Turner; it will be described in his forthcoming Ph.D. thesis <ref> [Tur94] </ref>. Acknowledgements This research was begun while both authors were visitors at INRIA-Roquencourt (in projects Formel and Para, respectively), and was partially supported by ESPRIT Basic Research Action Types and Confer and by the British Science and Engineering Research Council.
Reference: [VH93] <author> Vasco T. Vasconcelos and Kohei Honda. </author> <title> Principal typing schemes in a polyadic pi-calculus. </title> <booktitle> In Proceedings of CONCUR '93, </booktitle> <month> July </month> <year> 1993. </year> <note> Also available as Keio University Report CS-92-004. </note>
Reference-contexts: Milner's sort discipline plays an essential role in later papers on properties of the -calculus [Wal92, San92]; it has been further studied by Turner [Tur94], Gay [Gay93], and Vasconcelos and Honda <ref> [VH93] </ref>, who consider the problem of inferring most general sortings. Our typing discipline retains the basic character of Milner's, while extending it in two dimensions. <p> The algorithmic problem of inferring these annotations is deferred to future investigation (c.f. <ref> [Tur94, Gay93, VH93] </ref>). Our basic syntactic categories are defined by the grammar in We use the metavariables S, T , and U for sorts; P , Q, and R for process expressions; and for sorting assumptions (or sortings); and a, b, c, etc. for channels (or names).
Reference: [Wal92] <author> David Walker. </author> <title> Objects in the pi-calculus. </title> <note> To appear in Information and Computation, 1992. 35 </note>
Reference-contexts: Milner's sort discipline plays an essential role in later papers on properties of the -calculus <ref> [Wal92, San92] </ref>; it has been further studied by Turner [Tur94], Gay [Gay93], and Vasconcelos and Honda [VH93], who consider the problem of inferring most general sortings. Our typing discipline retains the basic character of Milner's, while extending it in two dimensions.
References-found: 26

