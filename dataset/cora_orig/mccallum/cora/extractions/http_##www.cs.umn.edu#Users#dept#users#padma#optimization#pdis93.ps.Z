URL: http://www.cs.umn.edu/Users/dept/users/padma/optimization/pdis93.ps.Z
Refering-URL: http://www.cs.umn.edu/Users/dept/users/padma/optimization/
Root-URL: http://www.cs.umn.edu
Title: Optimizing Multi-Join Queries in Parallel Relational Databases  
Author: Jaideep Srivastava Gary Elsesser 
Address: Minneapolis, MN 55455  
Affiliation: Computer Science Department University of Minnesota  
Abstract: Query optimization for parallel machines needs to consider machine architecture, processor and memory resources available, and different types of parallelism, making the search space much larger than the sequential case. In this paper our aim is to determine a plan that makes the execution of an individual query very fast, making minimizing parallel execution time the right objective. This creates the following circular dependence: a plan tree is needed for effective resource assignment, which is needed to estimate the parallel execution time, and this is needed for the cost-based search for a good plan tree. In this paper we propose a new search heuristic that breaks the cycle by constructing the plan tree layer by layer in a bottom-up manner. To select nodes at the next level, the lower and upper bounds on the execution time for plans consistent with the decisions made so far are estimated and are used to guide the search. A query plan representation for intra- and inter-operator parallelism, pipelining, and processor and memory assignment is proposed. Also proposed is a new approach to estimating the parallel execution time of a plan that considers sum and max of operators working sequentially and in parallel, respectively. The results obtained from a prototype optimizer are presented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. K. Baru, O. Frieder, D. Kanflur, and M. Se-gal. </author> <title> Join on a cube: Analysis, simulation, and implementation. </title> <editor> In Kitsuregawa and H. Tanaka, editors, </editor> <booktitle> Database Machines and Knowledge Base Machines, </booktitle> <pages> pages 61-74. </pages> <publisher> Kluwer, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: For a parallel machine, however, the two problems are different since the solution with the minimum amount of work may have a higher degree of sequential dependency. Various algorithms for the processing of relational operators on general-purpose parallel machines have been proposed in recent years <ref> [1, 2, 15, 17, 4] </ref>.
Reference: [2] <author> D. J. Dewitt and R. Gerber. </author> <title> Multiprocessor hash-based join algorithms. </title> <booktitle> In Proceedings of 11th VLDB Conference, </booktitle> <volume> volume 11, </volume> <pages> pages 151-164, </pages> <year> 1985. </year>
Reference-contexts: For a parallel machine, however, the two problems are different since the solution with the minimum amount of work may have a higher degree of sequential dependency. Various algorithms for the processing of relational operators on general-purpose parallel machines have been proposed in recent years <ref> [1, 2, 15, 17, 4] </ref>.
Reference: [3] <author> D. J. DeWitt and J. Gray. </author> <title> Parallel database systems: The future of database processing or a passing fad? CACM, </title> <type> 35(6), </type> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction The relational data model has been found especially suited for massive parallelization due to its set-oriented nature <ref> [3, 8] </ref>. The focus in query optimization so far has been on finding least work plans, since on a uniprocessor the time taken is proportional to the work done. <p> The Papyrus project [9] has developed a model which considers inter-operator dependent and independent parallelism, as well as operator cloning, i.e. intra-operator parallelism. Cost Model for Query Plans: No good cost models currently exist for the parallel environment <ref> [3] </ref>. Cost models for the sequential environment consider the cost of a query plan to be the sum of the costs of its components [7]. <p> It details for specific architectures remain to be investigated. In summary, analytical cost expressions for parallel implementations of relational operators are limited to only a few algorithms for some architectures. Also, cost models for parallel query plans are far from validation <ref> [3] </ref>. Search Algorithm: Determining the optimal sequential plan is a hard combinatorial problem. Since for every sequential query plan a number of parallel ones are possible, the search space for parallel query optimization is much larger.
Reference: [4] <author> D. J. DeWitt et al. </author> <title> The gamma database machine project. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1), </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: A common approach is to take a good sequential plan, fl This work has been supported in part by the National Science Foundation through grant number IRI-91-10584. typically a linear join tree, and parallelize each operation using intra-operation parallelism <ref> [4] </ref>. This approach does not exploit the full range of parallelism achievable. Recent work has proposed to apply inter-operator [11] and pipelining [18] parallelism to query processing. <p> For a parallel machine, however, the two problems are different since the solution with the minimum amount of work may have a higher degree of sequential dependency. Various algorithms for the processing of relational operators on general-purpose parallel machines have been proposed in recent years <ref> [1, 2, 15, 17, 4] </ref>.
Reference: [5] <author> H. Pirahesh et al. </author> <title> Parallelism in relational database systems: </title> <booktitle> Architectural issues and design approaches. In Proc. of 2nd Intl. Symp. on Database in Parallel and Distributed Systems, </booktitle> <month> July </month> <year> 1990. </year> <month> 8 </month>
Reference-contexts: In the XPRS system [6] the main focus is on intra-operator parallelism, and a comprehensive notation for plans is not discussed. Recent work [13] has evaluated the technique of parallelizing a good sequential plan. <ref> [5] </ref> depicts the parallelism in an example query plan using a time-resource diagram, without however a systematic way of generating the diagram for a given plan. [20] has proposed a dataflow query execution model which can represent pipelined query execution. [14] has proposed a model in which intra- and inter-operator parallelism
Reference: [6] <author> M. R. Stonebraker et al. </author> <booktitle> The design of xprs. In Proc. of the 14th Very Large Database Conference, </booktitle> <month> August </month> <year> 1988. </year>
Reference-contexts: This distinction has been discussed in [11], but no notation to distinguish between them is proposed. In the XPRS system <ref> [6] </ref> the main focus is on intra-operator parallelism, and a comprehensive notation for plans is not discussed. <p> Search Algorithm: Determining the optimal sequential plan is a hard combinatorial problem. Since for every sequential query plan a number of parallel ones are possible, the search space for parallel query optimization is much larger. The XPRS optimizer <ref> [6, 13] </ref> reduces the search space by finding a good sequential plan and parallelizing it.
Reference: [7] <author> P. P. Selinger et al. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proc. of ACM-SIGMOD Intl. Conf. on Mgmt. of Data, </booktitle> <year> 1979. </year>
Reference-contexts: Cost Model for Query Plans: No good cost models currently exist for the parallel environment [3]. Cost models for the sequential environment consider the cost of a query plan to be the sum of the costs of its components <ref> [7] </ref>. This observation does not hold in the parallel environment, where the cost of the plan is the sum of the costs of the tasks only on the critical path (of the tree representing the plan). <p> Detailed analytical formulae of the cost model have not been reported, and it is not clear how Selinger type <ref> [7] </ref> cost-based optimization may be done. [14] has proposed a cost model in which parallel execution time is considered as the objective function. However, the complete details of the cost model have not been reported.
Reference: [8] <author> The Committee for Advanced DBMS Function. </author> <title> Third generation database manifesto. </title> <journal> ACM SIG-MOD, </journal> <volume> 19(3), </volume> <month> September </month> <year> 1990. </year>
Reference-contexts: 1 Introduction The relational data model has been found especially suited for massive parallelization due to its set-oriented nature <ref> [3, 8] </ref>. The focus in query optimization so far has been on finding least work plans, since on a uniprocessor the time taken is proportional to the work done.
Reference: [9] <author> S. Ganguly, W. Hasan, and R. Krishnamurthy. </author> <title> Query optimization for parallel execution. </title> <booktitle> In Proc. of ACM-SIGMOD Intl. Conf. on Mgmt. of Data, </booktitle> <year> 1992. </year>
Reference-contexts: The Papyrus project <ref> [9] </ref> has developed a model which considers inter-operator dependent and independent parallelism, as well as operator cloning, i.e. intra-operator parallelism. Cost Model for Query Plans: No good cost models currently exist for the parallel environment [3]. <p> However, the complete details of the cost model have not been reported. In [20] a cost model based on input and output rates to join operators has been proposed. It is an interesting approach whose details need to be worked out. The cost model in <ref> [9] </ref> is quite comprehensive, but at a very abstract level. It details for specific architectures remain to be investigated. In summary, analytical cost expressions for parallel implementations of relational operators are limited to only a few algorithms for some architectures. <p> The XPRS optimizer [6, 13] reduces the search space by finding a good sequential plan and parallelizing it. The bottom-up search approach proposed in [14] is a promising one, whose details of how the cost estimate is used to guide the search have not been reported. <ref> [9] </ref> proposes the use of dynamic programming as the search algorithm. However, specific pruning heuristics and their performance evaluation has not been reported.
Reference: [10] <author> R. Gerber. </author> <title> Dataflow Query Processing using Multiprocessor Hash-Partitioned Algorithms. </title> <type> PhD dissertation, </type> <institution> University of Wisconsin, </institution> <month> October </month> <year> 1986. </year>
Reference-contexts: This approach does not exploit the full range of parallelism achievable. Recent work has proposed to apply inter-operator [11] and pipelining [18] parallelism to query processing. Query Plan Representation: Left- and right-deep trees to represent parallelism and pipelining were introduced in <ref> [10] </ref>, and an experimental analysis of the query processing tradeoffs among them is presented in [18]. An important finding was that right-deep trees perform very well, given sufficient resources, primarily memory.
Reference: [11] <author> G. Graefe. </author> <title> Encapsulation of parallelism in the volcano query processing system. </title> <booktitle> ACM SIGMOD Intl. Conf. on Mgmt. of Data, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: This approach does not exploit the full range of parallelism achievable. Recent work has proposed to apply inter-operator <ref> [11] </ref> and pipelining [18] parallelism to query processing. Query Plan Representation: Left- and right-deep trees to represent parallelism and pipelining were introduced in [10], and an experimental analysis of the query processing tradeoffs among them is presented in [18]. <p> Since memory size is an important constraint for query plan selection [18] it is important to distinguish between plans with different memory requirements, both for individual operator evaluation and for buffer space between successive producer-consumer pairs of pipelined operators. This distinction has been discussed in <ref> [11] </ref>, but no notation to distinguish between them is proposed. In the XPRS system [6] the main focus is on intra-operator parallelism, and a comprehensive notation for plans is not discussed.
Reference: [12] <author> J. L. Gustafson. </author> <title> Challenges to parallel processing. </title> <institution> talk given at University of Minnesota, Minneapo-lis, </institution> <month> September </month> <year> 1989. </year>
Reference-contexts: This observation does not hold in the parallel environment, where the cost of the plan is the sum of the costs of the tasks only on the critical path (of the tree representing the plan). The impact of this is clear from the following (approximate) quote from <ref> [12] </ref>, 1 For a sequential machine the problems of minimizing execution time and minimizing the amount of work done are the same, since the same processor has to do all the work.
Reference: [13] <author> W. Hong and M.R. Stonebraker. </author> <title> Optimization of parallel query execution plans in XPRS. </title> <booktitle> In Proceedings of First International Conference on Parallel and Distributed Information Systems, </booktitle> <month> December </month> <year> 1991. </year>
Reference-contexts: This distinction has been discussed in [11], but no notation to distinguish between them is proposed. In the XPRS system [6] the main focus is on intra-operator parallelism, and a comprehensive notation for plans is not discussed. Recent work <ref> [13] </ref> has evaluated the technique of parallelizing a good sequential plan. [5] depicts the parallelism in an example query plan using a time-resource diagram, without however a systematic way of generating the diagram for a given plan. [20] has proposed a dataflow query execution model which can represent pipelined query execution. <p> by simulation or implementation, very little effort has been made in deriving analytical cost expressions for them. [15] provides expressions for the hybrid-hash and join-index join algorithms for the hypercube and ring architectures, while [16] provides cost expressions for sort-merge, hash-based sort-merge and hybrid-hash join algorithms for a specific multiprocessor. <ref> [13] </ref> uses work, i.e. uniprocessor execution time, as the objective function in phase 1, and a weighted sum of the resource consumption and response time in phase 2. <p> Search Algorithm: Determining the optimal sequential plan is a hard combinatorial problem. Since for every sequential query plan a number of parallel ones are possible, the search space for parallel query optimization is much larger. The XPRS optimizer <ref> [6, 13] </ref> reduces the search space by finding a good sequential plan and parallelizing it.
Reference: [14] <author> H. Lu, M.-C. Shan, and K.-L. Tan. </author> <title> Parallel query optimization for shared memory multiprocessors. </title> <booktitle> In Proceedings of 17th VLDB Conference, </booktitle> <month> August </month> <year> 1991. </year>
Reference-contexts: has evaluated the technique of parallelizing a good sequential plan. [5] depicts the parallelism in an example query plan using a time-resource diagram, without however a systematic way of generating the diagram for a given plan. [20] has proposed a dataflow query execution model which can represent pipelined query execution. <ref> [14] </ref> has proposed a model in which intra- and inter-operator parallelism can be expressed but not pipelining. The Papyrus project [9] has developed a model which considers inter-operator dependent and independent parallelism, as well as operator cloning, i.e. intra-operator parallelism. <p> Detailed analytical formulae of the cost model have not been reported, and it is not clear how Selinger type [7] cost-based optimization may be done. <ref> [14] </ref> has proposed a cost model in which parallel execution time is considered as the objective function. However, the complete details of the cost model have not been reported. In [20] a cost model based on input and output rates to join operators has been proposed. <p> Since for every sequential query plan a number of parallel ones are possible, the search space for parallel query optimization is much larger. The XPRS optimizer [6, 13] reduces the search space by finding a good sequential plan and parallelizing it. The bottom-up search approach proposed in <ref> [14] </ref> is a promising one, whose details of how the cost estimate is used to guide the search have not been reported. [9] proposes the use of dynamic programming as the search algorithm. However, specific pruning heuristics and their performance evaluation has not been reported.
Reference: [15] <author> E. R. Omiecinsky and E. T. Lin. </author> <title> Hash-based and index-based join algorithms for cube and ring connected multicomputers. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(3), </volume> <month> September </month> <year> 1989. </year>
Reference-contexts: For a parallel machine, however, the two problems are different since the solution with the minimum amount of work may have a higher degree of sequential dependency. Various algorithms for the processing of relational operators on general-purpose parallel machines have been proposed in recent years <ref> [1, 2, 15, 17, 4] </ref>. <p> Various algorithms for the processing of relational operators on general-purpose parallel machines have been proposed in recent years [1, 2, 15, 17, 4]. While most of these have been evaluated either by simulation or implementation, very little effort has been made in deriving analytical cost expressions for them. <ref> [15] </ref> provides expressions for the hybrid-hash and join-index join algorithms for the hypercube and ring architectures, while [16] provides cost expressions for sort-merge, hash-based sort-merge and hybrid-hash join algorithms for a specific multiprocessor. [13] uses work, i.e. uniprocessor execution time, as the objective function in phase 1, and a weighted sum
Reference: [16] <author> J. Richardson, H. Lu, and K. Mikkilineni. </author> <title> Design and evaluation of parallel pipelined join algorithms. </title> <booktitle> In Proc. of ACM-SIGMOD Intl. Conf. on Mgmt. of Data, </booktitle> <pages> pages 399-409, </pages> <year> 1987. </year>
Reference-contexts: While most of these have been evaluated either by simulation or implementation, very little effort has been made in deriving analytical cost expressions for them. [15] provides expressions for the hybrid-hash and join-index join algorithms for the hypercube and ring architectures, while <ref> [16] </ref> provides cost expressions for sort-merge, hash-based sort-merge and hybrid-hash join algorithms for a specific multiprocessor. [13] uses work, i.e. uniprocessor execution time, as the objective function in phase 1, and a weighted sum of the resource consumption and response time in phase 2.
Reference: [17] <author> D. A. Schneider and D. J. DeWitt. </author> <title> A performance evaluation of four parallel join algorithms in a shared-nothing multiprocessor. </title> <booktitle> In Proc. of ACM-SIGMOD Intl. Conf. on Mgmt. of Data, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: For a parallel machine, however, the two problems are different since the solution with the minimum amount of work may have a higher degree of sequential dependency. Various algorithms for the processing of relational operators on general-purpose parallel machines have been proposed in recent years <ref> [1, 2, 15, 17, 4] </ref>.
Reference: [18] <author> D. A. Schneider and D. J. DeWitt. </author> <title> Tradeoffs in processing complex join queries via hashing in multiprocessor database machines. </title> <booktitle> In Proc. of the 16th Very Large Database Conference, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: This approach does not exploit the full range of parallelism achievable. Recent work has proposed to apply inter-operator [11] and pipelining <ref> [18] </ref> parallelism to query processing. Query Plan Representation: Left- and right-deep trees to represent parallelism and pipelining were introduced in [10], and an experimental analysis of the query processing tradeoffs among them is presented in [18]. <p> Recent work has proposed to apply inter-operator [11] and pipelining <ref> [18] </ref> parallelism to query processing. Query Plan Representation: Left- and right-deep trees to represent parallelism and pipelining were introduced in [10], and an experimental analysis of the query processing tradeoffs among them is presented in [18]. An important finding was that right-deep trees perform very well, given sufficient resources, primarily memory. No analytical cost expressions were provided which can be used by an optimizer, and no notation is provided for depicting the degree of intra-operator parallelism for an operator. <p> No analytical cost expressions were provided which can be used by an optimizer, and no notation is provided for depicting the degree of intra-operator parallelism for an operator. Since memory size is an important constraint for query plan selection <ref> [18] </ref> it is important to distinguish between plans with different memory requirements, both for individual operator evaluation and for buffer space between successive producer-consumer pairs of pipelined operators. This distinction has been discussed in [11], but no notation to distinguish between them is proposed. <p> This is determined by estimating the lower and upper bounds on Cost est. It was observed by <ref> [18] </ref> that a right-deep tree is preferable for minimizing parallel execution time. Under our assumption of having the smaller relation completely in memory during the execution of an operator, the right-deep tree would lead to the maximal degree of pipelining.
Reference: [19] <author> J. Srivastava and G.W. Elsesser. </author> <title> Optimizing multi-join queries in parallel relational databases. </title> <institution> Computer Science Department Technical Report, </institution> <month> November </month> <year> 1992. </year> <institution> University of Minnesota. </institution>
Reference-contexts: In our notation the parallel execution time of the entire plan is root:end. 4 Search Algorithm Beyond six joins, the number of plans quickly becomes too large for exhaustive search to be practical (see <ref> [19] </ref>). It is therefore necessary to consider heuristic methods to narrow the search space and thereby reduce query planning time. Our cost model uses two cost measures: work, i.e. sequential time, and (parallel) execution time. <p> These estimates are used in guiding the search, i.e. deciding which trees will be merged at this level. The main procedure, namely Heuristic Plan, is described in Figure 8. Detailed descriptions of all the procedures are in <ref> [19] </ref>. function Heurstic Plan ( R 1 ; : : : ; R n ) return Plan tree is start with a forest of n one node trees: F 1 ; : : : ; F n . for i 2 1 : : : n do F i := tree
Reference: [20] <author> A.N. Wilschut and P.M.G. Apers. </author> <title> Dataflow query execution in a parallel main-memory environment. </title> <booktitle> In Proceedings of First International Conference on Parallel and Distributed Information Systems, </booktitle> <month> December </month> <year> 1991. </year> <month> 9 </month>
Reference-contexts: Recent work [13] has evaluated the technique of parallelizing a good sequential plan. [5] depicts the parallelism in an example query plan using a time-resource diagram, without however a systematic way of generating the diagram for a given plan. <ref> [20] </ref> has proposed a dataflow query execution model which can represent pipelined query execution. [14] has proposed a model in which intra- and inter-operator parallelism can be expressed but not pipelining. <p> However, the complete details of the cost model have not been reported. In <ref> [20] </ref> a cost model based on input and output rates to join operators has been proposed. It is an interesting approach whose details need to be worked out. The cost model in [9] is quite comprehensive, but at a very abstract level.
References-found: 20

