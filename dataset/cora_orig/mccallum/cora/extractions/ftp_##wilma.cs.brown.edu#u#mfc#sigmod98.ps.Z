URL: ftp://wilma.cs.brown.edu/u/mfc/sigmod98.ps.Z
Refering-URL: http://www.cs.brown.edu/software/cokokola/
Root-URL: http://www.cs.brown.edu
Email: mfc@cs.brown.edu  sbz@cs.brown.edu  
Title: Changing the Rules: Transformations for Rule-Based Optimizers Nobody realizes that some people expend tremendous en
Author: Mitch Cherniack Stan Zdonik Albert Camus 
Address: Providence, RI 02912-1910  Providence, RI 02912-1910  
Affiliation: Department of Computer Science, Brown University  Department of Computer Science, Brown University  
Abstract: Rule-based optimizers are extensible because they consist of modifiable sets of rules. For modification to be straightforward, rules must be easily reasoned about (i.e., understood and verified). At the same time, rules must be expressive and efficient (to fire) for rule-based optimizers to be practical. Production-style rules (as in [15]) are expressed with code and are hard to reason about. Pure rewrite rules (as in [1]) lack code, but cannot atomically express complex transformations (e.g., normalizations). Some systems allow rules to be grouped, but sacrifice efficiency by providing limited control over their firing. Therefore, none of these approaches succeeds in making rules expressive, efficient and understandable. We propose a language (COKO) for expressing an alternative form of input to a rule-based optimizer. A COKO transformation consists of a set of declarative (KOLA) rewrite rules and a (firing) algorithm that specifies their firing. It is straightforward to reason about COKO transformations because all query modification is expressed with declarative rewrite rules. Firing is specified algorithmically with an expressive language that provides direct control over how query representations are traversed, and under what conditions rules are fired. Therefore, COKO achieves a delicate balance of understandability, efficiency and expressivity. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Becker and R. H. Guting. </author> <title> Rule-based optimization and query processing in an extensible geometric database system. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(2):247303, </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: As with production rules, code-supplemented rules are expressive, but at the expense of understandability. Of the rewrite rule-based systems, Gral <ref> [1] </ref> comes closest to ours in its effort to make rules declarative by avoiding code. Gral expands the expressive power of a rewrite rule without adding code supplements. <p> Such control is not provided with Gral rules and instead must be expressed using the Gral meta-rule language as discussed below. Expressing Complex Query Rewrites with Rule Groups: Many systems (e.g. [15], <ref> [1] </ref>, [7], [13] [17]) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing. Rule groups can be associated with search strategies that indicate how the rules in a group should be fired. <p> Thus, whereas COKO groups rules to cooperatively specify a query rewrite, other systems group rules to face-off against one another. The search strategies that are provided by these systems reflect this objective. Most (e.g., [15], <ref> [1] </ref>, [7]) include exhaustive search (fire everything everywhere until firing no longer has any effect), with the goal of generating all possible alternatives before comparing them. <p> Other systems provide pruning strategies so that only some alternatives are generated (e.g, [17] provide such strategies as branch-and-bound and simulated annealing). Some systems try to avoid generating poor alternatives by ranking rules (e.g., [15], [13] and [2]) or algebraic operators (e.g., <ref> [1] </ref>) to choose a rule to apply next. COKO groups KOLA rules, not to generate alternatives, but to modularize the expression of a single complex query rewrite. There is no search involved. <p> On the other hand, the meta-rule languages of other rule-based systems such as [15], <ref> [1] </ref>, and [6] do not give us enough expressive power to implement transformations efficiently. A more theoretical analysis of expressivity in this context is called for. A second interesting direction concerns normalization. Normalization gets little attention in the optimizer literature.
Reference: [2] <author> M. J. Carey, D. J. DeWitt, G. Graefe, D. M. Haight, J. E. Richardson, D. T. Schuh, E. J. Shekita, and S. L. Vandenberg. </author> <title> The EXODUS extensible DBMS project: An overview. </title> <editor> In S. B. Zdonik and D. Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, pages 474499.Morgan KaufmannPublishers, </booktitle> <publisher> Inc., </publisher> <address> Los Altos, California, </address> <year> 1990. </year>
Reference-contexts: However, Starburst rules are difficult to understand and reason about, requiring a detailed understanding of the underlying graph-based query representation (QGM). Expressing Complex Query Rewrites with Extended Rewrite Rules: Exodus <ref> [2] </ref> (and its successors, Volcano [9] and Cascades [8]) and ESL [7] use rules that resemble rewrite rules, but that can have code supplements. As with production rules, code-supplemented rules are expressive, but at the expense of understandability. <p> Other systems provide pruning strategies so that only some alternatives are generated (e.g, [17] provide such strategies as branch-and-bound and simulated annealing). Some systems try to avoid generating poor alternatives by ranking rules (e.g., [15], [13] and <ref> [2] </ref>) or algebraic operators (e.g., [1]) to choose a rule to apply next. COKO groups KOLA rules, not to generate alternatives, but to modularize the expression of a single complex query rewrite. There is no search involved.
Reference: [3] <author> M. Cherniack. </author> <title> Translating queries into combinators. </title> <month> September </month> <year> 1996. </year>
Reference-contexts: Because they are expressed with combina-tors, KOLA queries can be difficult to read. But KOLA is intended to be an internal query representation and not a query language. Translation into KOLA from user-friendly query languages such as OQL is discussed elsewhere <ref> [3] </ref>. More comprehensive presentations of KOLA can be found in [5] and [4]. KOLA functions and predicates have no variables. They are either predefined primitives (e.g., eq) or are constructed from other functions and predicates with formers.
Reference: [4] <author> M. Cherniack. </author> <title> Building query optimizers with combinators. </title> <type> Ph.D. Dissertation Proposal. </type> <institution> Brown University, </institution> <year> 1997. </year>
Reference-contexts: But KOLA is intended to be an internal query representation and not a query language. Translation into KOLA from user-friendly query languages such as OQL is discussed elsewhere [3]. More comprehensive presentations of KOLA can be found in [5] and <ref> [4] </ref>. KOLA functions and predicates have no variables. They are either predefined primitives (e.g., eq) or are constructed from other functions and predicates with formers. <p> We showed a COKO transformation (CNF) that performs this rewrite for predicates lacking negations. (A transformation that also processes negations is not much more complex and is presented in <ref> [4] </ref>.) Because its rules are confluent, CNF could also use an exhaustive firing algorithm as it likely would be in other systems that provide rule grouping. But exhaustive firing is an inefficient means of performing this transformation. <p> Table 3 gives the semantics of the KOLA query operators used in this paper. [5] and <ref> [4] </ref> provide more comprehensive descriptions of KOLA. Of these, the latter is more up-to-date. Since [5], we have defined KOLA over multisets and not just sets, so as to be able to capture the semantics of OQL and SQL. KOLA collections are (finite) multisets and sets. <p> Space does not permit a full presentation of these transformations. Instead, we describe the firing algorithms and relevant rewrite rules of these transformations and refer interested readers to more complete descriptions in <ref> [4] </ref>. 4.3.1 Predicate Pushdown joins. This rule identifies predicates in join queries that apply only to one argument (p and q) and pushes them out of the join and onto the join inputs. This is a useful heuristic as it will usually result in a join of smaller collections. <p> Second, MEmp would return a relation with attributes, Dno, Eno, and Sal rather than every attribute of Emp, as the other attributes are not necessary to compute the rest of the query. We express DSet as a view over Emp to simplify presentation; <ref> [4] </ref> presents a COKO transformation that generates DSet properly. The second deviation is more problematic to address, for it may require a COKO transformation to examine an entire query to see which attributes of Emp are used elsewhere. COKO is not designed to express this kind of global transformation. <p> Aside from these, we have also implemented (and generalized) the query unnesting transformations of [11] (modulo their bug fixes) and the nested object query transformation presented in [5]. Details can be found in <ref> [4] </ref>. Though COKO is evolving, this is not to say that it is immature. We believe that COKO already provides most of the useful idioms required to express query rewriting.
Reference: [5] <author> M. Cherniack and S. B. Zdonik. </author> <title> Rule languages and internal algebras for rule-based optimizers. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <address> Montreal, Quebec, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Rule-based optimizers are extensible because an optimizer's behavior can be modified by changing its rule set. But this is difficult unless rules are straightforward to understand and reason about. Therefore, extensibility is best achieved by expressing rules declaratively, rather than with code. (e.g., with rewrite rules). In <ref> [5] </ref>, we showed that the choice of query representation determines the effectiveness with which rewrite rules can express query rewrites. Rewrite rules use pairs of patterns to specify rewrites that identify and rearrange subexpressions. <p> A COKO transformation is understandable; it can be decomposed into its rewrite rules and even shown to preserve the semantics of the queries it transforms by proving the same property of these rules. As we showed in <ref> [5] </ref>, this can be done with help from a theorem prover [10]. At the same time, COKO firing algorithms make transformations capable of expressing a wide variety of efficient query rewrites, as we later show. This work generalizes and extends our KOLA work. <p> But KOLA is intended to be an internal query representation and not a query language. Translation into KOLA from user-friendly query languages such as OQL is discussed elsewhere [3]. More comprehensive presentations of KOLA can be found in <ref> [5] </ref> and [4]. KOLA functions and predicates have no variables. They are either predefined primitives (e.g., eq) or are constructed from other functions and predicates with formers. <p> Table 3 gives the semantics of the KOLA query operators used in this paper. <ref> [5] </ref> and [4] provide more comprehensive descriptions of KOLA. Of these, the latter is more up-to-date. Since [5], we have defined KOLA over multisets and not just sets, so as to be able to capture the semantics of OQL and SQL. KOLA collections are (finite) multisets and sets. <p> Table 3 gives the semantics of the KOLA query operators used in this paper. <ref> [5] </ref> and [4] provide more comprehensive descriptions of KOLA. Of these, the latter is more up-to-date. Since [5], we have defined KOLA over multisets and not just sets, so as to be able to capture the semantics of OQL and SQL. KOLA collections are (finite) multisets and sets. <p> Aside from these, we have also implemented (and generalized) the query unnesting transformations of [11] (modulo their bug fixes) and the nested object query transformation presented in <ref> [5] </ref>. Details can be found in [4]. Though COKO is evolving, this is not to say that it is immature. We believe that COKO already provides most of the useful idioms required to express query rewriting. <p> COKO transformations are easily understood because they are modular; they are built from simpler transformations and declarative rules. Moreover, COKO transformations can be verified as being semantics-preserving simply by proving the same property of the rewrite rules are fired. As we showed in <ref> [5] </ref>, KOLA rules can be verified with a theorem prover. Because of COKO's language for expressing firing algorithms, COKO transformations can be made efficient and expressive. The language for firing algorithms includes the kinds of operators that are most useful for describing rewrites.
Reference: [6] <author> B. Finance and G. Gardarin. </author> <title> A rule-based query rewriter in an extensible dbms. </title> <booktitle> In Proceedings of the Seventh International Conference on Data Engineering, </booktitle> <pages> pages 248256, </pages> <address> Kobe, Japan, </address> <month> April </month> <year> 1991. </year> <note> IEEE. </note>
Reference-contexts: On the other hand, the meta-rule languages of other rule-based systems such as [15], [1], and <ref> [6] </ref> do not give us enough expressive power to implement transformations efficiently. A more theoretical analysis of expressivity in this context is called for. A second interesting direction concerns normalization. Normalization gets little attention in the optimizer literature.
Reference: [7] <author> B. Finance and G. Gardarin. </author> <title> A rule-based query optimizer with multiple search strategies. </title> <journal> Data and Knowledge Engineering, </journal> <volume> 13:129, </volume> <year> 1994. </year>
Reference-contexts: However, Starburst rules are difficult to understand and reason about, requiring a detailed understanding of the underlying graph-based query representation (QGM). Expressing Complex Query Rewrites with Extended Rewrite Rules: Exodus [2] (and its successors, Volcano [9] and Cascades [8]) and ESL <ref> [7] </ref> use rules that resemble rewrite rules, but that can have code supplements. As with production rules, code-supplemented rules are expressive, but at the expense of understandability. Of the rewrite rule-based systems, Gral [1] comes closest to ours in its effort to make rules declarative by avoiding code. <p> Such control is not provided with Gral rules and instead must be expressed using the Gral meta-rule language as discussed below. Expressing Complex Query Rewrites with Rule Groups: Many systems (e.g. [15], [1], <ref> [7] </ref>, [13] [17]) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing. Rule groups can be associated with search strategies that indicate how the rules in a group should be fired. <p> Thus, whereas COKO groups rules to cooperatively specify a query rewrite, other systems group rules to face-off against one another. The search strategies that are provided by these systems reflect this objective. Most (e.g., [15], [1], <ref> [7] </ref>) include exhaustive search (fire everything everywhere until firing no longer has any effect), with the goal of generating all possible alternatives before comparing them. Some systems permit some variations on exhaustive search (such as prioritizing rules [15] or limiting the number of passes over the query in advance [7]). <p> [1], <ref> [7] </ref>) include exhaustive search (fire everything everywhere until firing no longer has any effect), with the goal of generating all possible alternatives before comparing them. Some systems permit some variations on exhaustive search (such as prioritizing rules [15] or limiting the number of passes over the query in advance [7]). Other systems provide pruning strategies so that only some alternatives are generated (e.g, [17] provide such strategies as branch-and-bound and simulated annealing).
Reference: [8] <author> G. Graefe. </author> <title> The Cascades framework for query optimization. </title> <journal> Data Engineering Bulletin, </journal> <volume> 18(3):1929, </volume> <month> September </month> <year> 1995. </year>
Reference-contexts: However, Starburst rules are difficult to understand and reason about, requiring a detailed understanding of the underlying graph-based query representation (QGM). Expressing Complex Query Rewrites with Extended Rewrite Rules: Exodus [2] (and its successors, Volcano [9] and Cascades <ref> [8] </ref>) and ESL [7] use rules that resemble rewrite rules, but that can have code supplements. As with production rules, code-supplemented rules are expressive, but at the expense of understandability.
Reference: [9] <author> G. Graefe and W. J. McKenna. </author> <title> The Volcano optimizer generator: Extensibility and efficient search. </title> <booktitle> In Proceedings of the Ninth International Conference on Data Engineering, pages 209218, </booktitle> <address> Vienna, Austria, </address> <month> April </month> <year> 1993. </year> <note> IEEE. </note>
Reference-contexts: However, Starburst rules are difficult to understand and reason about, requiring a detailed understanding of the underlying graph-based query representation (QGM). Expressing Complex Query Rewrites with Extended Rewrite Rules: Exodus [2] (and its successors, Volcano <ref> [9] </ref> and Cascades [8]) and ESL [7] use rules that resemble rewrite rules, but that can have code supplements. As with production rules, code-supplemented rules are expressive, but at the expense of understandability.
Reference: [10] <author> J. Guttag, J. Horning, S. Garland, K. Jones, A. Modet, and J. Wing. </author> <title> Larch: Languages and Tools for Formal Specifications. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A COKO transformation is understandable; it can be decomposed into its rewrite rules and even shown to preserve the semantics of the queries it transforms by proving the same property of these rules. As we showed in [5], this can be done with help from a theorem prover <ref> [10] </ref>. At the same time, COKO firing algorithms make transformations capable of expressing a wide variety of efficient query rewrites, as we later show. This work generalizes and extends our KOLA work. COKO transformations behave like rewrite rules; they can be fired and can succeed or fail as a result. <p> Therefore, CNF is semantics-preserving if both rewrite rules are semantics-preserving. d1 and d2 are proved to be semantics preserving by execution of the theorem prover scripts of Appendix A using the theorem prover, LP <ref> [10] </ref>. 2 Lemma 2.1 Let p be a KOLA predicate tree lacking negations, and whose child subtrees are in CNF. Then CNFAux (p) is in CNF.
Reference: [11] <author> W. Kim. </author> <title> On optimizing an SQL-like nested query. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(3):443469, </volume> <month> September </month> <year> 1982. </year>
Reference-contexts: In this paper, we have presented some of the transformations that we have generated with COKO including CNF (exhaustive and non-exhaustive versions), SNF, Pushdown and MagicSets. Aside from these, we have also implemented (and generalized) the query unnesting transformations of <ref> [11] </ref> (modulo their bug fixes) and the nested object query transformation presented in [5]. Details can be found in [4]. Though COKO is evolving, this is not to say that it is immature. We believe that COKO already provides most of the useful idioms required to express query rewriting.
Reference: [12] <author> J.-S. Lee, K.-E. Kim, and M. Cherniack. </author> <title> A COKO compiler. </title> <note> Available at http://www.cs.brown.edu/software/cokokola/coko.tar.Z, 1996. </note>
Reference: [13] <author> G. Mitchell, U. Dayal, and S. B. Zdonik. </author> <title> Control of and extensible query optimizer: A planning-basedapproach. </title> <booktitle> In Proc. 19th Int'l Conference on Very Large Data Bases, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: Such control is not provided with Gral rules and instead must be expressed using the Gral meta-rule language as discussed below. Expressing Complex Query Rewrites with Rule Groups: Many systems (e.g. [15], [1], [7], <ref> [13] </ref> [17]) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing. Rule groups can be associated with search strategies that indicate how the rules in a group should be fired. <p> Other systems provide pruning strategies so that only some alternatives are generated (e.g, [17] provide such strategies as branch-and-bound and simulated annealing). Some systems try to avoid generating poor alternatives by ranking rules (e.g., [15], <ref> [13] </ref> and [2]) or algebraic operators (e.g., [1]) to choose a rule to apply next. COKO groups KOLA rules, not to generate alternatives, but to modularize the expression of a single complex query rewrite. There is no search involved.
Reference: [14] <author> I. S. Mumick, S. J. Finkelstein, H. Pirahesh, and R. Ramakrishnan. </author> <title> Magic is relevant. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <pages> pages 247258, </pages> <year> 1990. </year>
Reference-contexts: Figure 1b shows an equivalent predicate that has been normalized into CNF. 2 A similar schema is used in papers from the Starburst group such as <ref> [14] </ref> and [18]. (P AND Q AND R) OR S (P OR S) AND (Q OR S) AND (R OR S) P = e:Dno == d:Dno Q = e:Sal &gt; d:ASal R = e:Job == ``Mgr'' 2.2 KOLA and CNF KOLA is the language of queries and rewrite rules assumed by <p> Therefore firing a subsequent rule, iterate (K p (T); id) ! A ! would result in the query, join (t k ; Eno ffi 1 ) ! [iterate ( k ; id) ! Emp; Dept k ]: 4.3.2 Magic Sets The idea behind the Magic Sets transformation for relational queries <ref> [14] </ref> is to restrict inputs to joins by filtering those that cannot possibly satisfy the join predicate. <p> The filtered set of departments used by MDept is defined by the (magic) view DSet. We have deviated from the Magic Sets transformation presented in <ref> [14] </ref> in two respects. First, the Magic Sets transformation of [14] would express DSet as a view over MEmp rather than over Emp to avoid the redundant work of computing which employees are managers. <p> The filtered set of departments used by MDept is defined by the (magic) view DSet. We have deviated from the Magic Sets transformation presented in <ref> [14] </ref> in two respects. First, the Magic Sets transformation of [14] would express DSet as a view over MEmp rather than over Emp to avoid the redundant work of computing which employees are managers.
Reference: [15] <author> H. Pirahesh, J. M. Hellerstein, and W. Hasan. </author> <title> Extensible/rulebased query rewrite optimization in Starburst. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <pages> pages 3948, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: However, the rules of these systems are not declarative rewrite rules. Starburst <ref> [15] </ref> performs query rewrites during the query rewriting phase of optimization, firing production rules as in expert systems. These rules consist of two code routines (loosely corresponding to the lhs (left-hand side) and rhs (right-hand side) of a rewrite rule) programmed in C. <p> Because they are programmed with a general purpose programming language, Starburst rules are able to express a wide variety of transformations including view merging and query unnesting (both discussed in <ref> [15] </ref>) and magic sets transformations ([14]). However, Starburst rules are difficult to understand and reason about, requiring a detailed understanding of the underlying graph-based query representation (QGM). <p> Such control is not provided with Gral rules and instead must be expressed using the Gral meta-rule language as discussed below. Expressing Complex Query Rewrites with Rule Groups: Many systems (e.g. <ref> [15] </ref>, [1], [7], [13] [17]) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing. Rule groups can be associated with search strategies that indicate how the rules in a group should be fired. <p> Thus, whereas COKO groups rules to cooperatively specify a query rewrite, other systems group rules to face-off against one another. The search strategies that are provided by these systems reflect this objective. Most (e.g., <ref> [15] </ref>, [1], [7]) include exhaustive search (fire everything everywhere until firing no longer has any effect), with the goal of generating all possible alternatives before comparing them. Some systems permit some variations on exhaustive search (such as prioritizing rules [15] or limiting the number of passes over the query in advance <p> Most (e.g., <ref> [15] </ref>, [1], [7]) include exhaustive search (fire everything everywhere until firing no longer has any effect), with the goal of generating all possible alternatives before comparing them. Some systems permit some variations on exhaustive search (such as prioritizing rules [15] or limiting the number of passes over the query in advance [7]). Other systems provide pruning strategies so that only some alternatives are generated (e.g, [17] provide such strategies as branch-and-bound and simulated annealing). Some systems try to avoid generating poor alternatives by ranking rules (e.g., [15], [13] and [2]) <p> as prioritizing rules <ref> [15] </ref> or limiting the number of passes over the query in advance [7]). Other systems provide pruning strategies so that only some alternatives are generated (e.g, [17] provide such strategies as branch-and-bound and simulated annealing). Some systems try to avoid generating poor alternatives by ranking rules (e.g., [15], [13] and [2]) or algebraic operators (e.g., [1]) to choose a rule to apply next. COKO groups KOLA rules, not to generate alternatives, but to modularize the expression of a single complex query rewrite. There is no search involved. <p> On the other hand, the meta-rule languages of other rule-based systems such as <ref> [15] </ref>, [1], and [6] do not give us enough expressive power to implement transformations efficiently. A more theoretical analysis of expressivity in this context is called for. A second interesting direction concerns normalization. Normalization gets little attention in the optimizer literature.
Reference: [16] <author> R. Ramakrishnan. </author> <title> Database Management Systems. </title> <publisher> McGraw-Hill, </publisher> <year> 1996. </year>
Reference-contexts: the forms, p 1 , or p 2 , if possible. (Appendix B gives an induction proof showing that SimpLits accomplishes this goal for a class of predicates that includes P k , Q k , R k , and S k .) More precisely, SimpLits transforms any qualification predicate <ref> [16] </ref> lacking subfunctions of the form, f ffi 1 , to either of the forms, p 2 , or K p (x) (and similarly for predicates lacking f ffi 2 as a subfunction).) SimpLits performs a single bottom-up pass of the input predicate, firing rules sl1; : : : ; sl7
Reference: [17] <author> E. Sciore and J. Sieg Jr. </author> <title> A modular query optimizer generator. </title> <booktitle> In Proceedings of the 6th International Conference on Data Engineering, </booktitle> <pages> pages 146153, </pages> <address> Los Angeles, USA, </address> <year> 1990. </year>
Reference-contexts: Such control is not provided with Gral rules and instead must be expressed using the Gral meta-rule language as discussed below. Expressing Complex Query Rewrites with Rule Groups: Many systems (e.g. [15], [1], [7], [13] <ref> [17] </ref>) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing. Rule groups can be associated with search strategies that indicate how the rules in a group should be fired. <p> Some systems permit some variations on exhaustive search (such as prioritizing rules [15] or limiting the number of passes over the query in advance [7]). Other systems provide pruning strategies so that only some alternatives are generated (e.g, <ref> [17] </ref> provide such strategies as branch-and-bound and simulated annealing). Some systems try to avoid generating poor alternatives by ranking rules (e.g., [15], [13] and [2]) or algebraic operators (e.g., [1]) to choose a rule to apply next.
Reference: [18] <author> P. Seshadri, J. M. Hellerstein, H. Pirahesh, T. C. Leung, R. Ramakrishnan, D. Sri-vastava, P. J. Stuckey, and S. Sudarshan. </author> <title> Cost-based optimization for magic: Algebra and implementation. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <address> Montreal, Quebec, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Figure 1b shows an equivalent predicate that has been normalized into CNF. 2 A similar schema is used in papers from the Starburst group such as [14] and <ref> [18] </ref>. (P AND Q AND R) OR S (P OR S) AND (Q OR S) AND (R OR S) P = e:Dno == d:Dno Q = e:Sal &gt; d:ASal R = e:Job == ``Mgr'' 2.2 KOLA and CNF KOLA is the language of queries and rewrite rules assumed by COKO transformations.
References-found: 18

