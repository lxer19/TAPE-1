URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3370/3370.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: Laurent.Amsaleg@inria.fr franklin@cs.umd.edu Olivier.Gruber@inria.fr  
Title: Efficient Incremental Garbage Collection for Workstation/Server Database Systems  
Author: Laurent Amsaleg Michael Franklin Olivier Gruber 
Address: Rocquencourt  
Affiliation: Project Rodin Dept. of Computer Science Project Rodin INRIA Rocquencourt University of Maryland INRIA  
Abstract: We describe an efficient server-based algorithm for garbage collecting object-oriented databases in a workstation/server environment. The algorithm is incremental and runs concurrently with client transactions, however, it does not hold any locks on data and does not require callbacks to clients. It is fault tolerant, but performs very little logging. The algorithm has been designed to be integrated into existing OODB systems, and therefore it works with standard implementation techniques such as two-phase locking and write-ahead-logging. In addition, it supports client-server performance optimizations such as client caching and flexible management of client buffers. We describe an implementation of the algorithm in the EXODUS storage manager and present results from an initial performance study of the implementation. These results demonstrate that the introduction of the garbage collector adds minimal overhead to client operations.
Abstract-found: 1
Intro-found: 1
Reference: [Bak78] <author> H. Baker. </author> <title> List Processing in Real Time on a Serial Computer. Com. </title> <journal> of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <month> April </month> <year> 1978. </year>
Reference-contexts: Finally, it should be noted that the problems discussed in this section have analogs in incremental collection algorithms for traditional programming languages. Dijkstra and Baker have described invariants that ensure correctness for incremental collectors <ref> [DLM + 78, Bak78] </ref>. In Section 4.1 we provide invariants that reflect the transactional nature of the client-server DBMS environment. 2.4 Problem III: Overwriting Collected Pages A third set of problems involves the overwriting of a garbage collected page. One way that this can occur is during transaction REDO. <p> As stated previously, these invariants are similar in spirit to invariants that have been proposed for traditional incremental garbage collectors <ref> [DLM + 78, Bak78] </ref>. In contrast to that earlier work, however, these invariants reflect the transactional nature of database accesses. Invariant I1 (in conjunction with assumption A1) protects against the rollback problem, as only objects made garbage by committed transactions will be eligible for reclamation. <p> Surveys of this work include [Coh81] and [Wil92]. The invariants that an incremental collector must respect were first proposed by <ref> [DLM + 78, Bak78] </ref>. Our work addresses the efficient implementation of similar invariants in a (transactional) client-server DBMS context. The earliest study of garbage collection for object-oriented databases was done by Butler [But87].
Reference: [BD90] <author> V. Benzaken and C. Delobel. </author> <title> Enhancing Performance in a Persistent Object Store: </title> <booktitle> Clustering Strategies in O 2 . In 4th Int. Workshop on Persistent Object Systems, </booktitle> <pages> pages 403-412, </pages> <address> Martha-Vineyard, Mass., </address> <month> September </month> <year> 1990. </year>
Reference-contexts: However, a copying collector will typically cluster objects in the order that they are visited (e.g., depth first search). This clustering produced by the collector may be in conflict with database requirements or user-specified hints (e.g, <ref> [BD90, GA92] </ref>). For example, using generation scavenging, objects of that differ widely in age can not be clustered together. Fault-Tolerance: Copying causes objects to move between pages, which can greatly complicate recovery [KLW89, MRV91, YNY94].
Reference: [BDK91] <author> F. Bancilhon, C. Delobel, and P. Kannellakis. </author> <title> Building an object-oriented database : the O 2 story. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: Reachability-based persistence provides a simple way to express persistence that is implicit and orthogonal to object type [ZM90]; therefore, some database systems, such as GemStone [BOS91] and O2 <ref> [BDK91] </ref>, directly implement persistence based on reachability. 1 In addition, there has been a growing research interest in applying garbage collection techniques to OODBMS [But87, FCW89, KLW89, ONG93, ML94, YNY94]. In general, however, many existing systems still require programmers to explicitly deallocate objects.
Reference: [BOS91] <author> P. Butterworth, A. Otis, and J. Stein. </author> <title> The GemStone Object Database Management System. Com. </title> <journal> of the ACM, </journal> <volume> 34(10), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: Reachability-based persistence provides a simple way to express persistence that is implicit and orthogonal to object type [ZM90]; therefore, some database systems, such as GemStone <ref> [BOS91] </ref> and O2 [BDK91], directly implement persistence based on reachability. 1 In addition, there has been a growing research interest in applying garbage collection techniques to OODBMS [But87, FCW89, KLW89, ONG93, ML94, YNY94]. In general, however, many existing systems still require programmers to explicitly deallocate objects.
Reference: [But87] <author> M. Butler. </author> <title> Storage Reclamation in Object Oriented Database Systems. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <pages> pages 410-425, </pages> <address> San Francisco, CA, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: provides a simple way to express persistence that is implicit and orthogonal to object type [ZM90]; therefore, some database systems, such as GemStone [BOS91] and O2 [BDK91], directly implement persistence based on reachability. 1 In addition, there has been a growing research interest in applying garbage collection techniques to OODBMS <ref> [But87, FCW89, KLW89, ONG93, ML94, YNY94] </ref>. In general, however, many existing systems still require programmers to explicitly deallocate objects. Such systems therefore, typically provide off-line utilities which must be run periodically in order to reclaim lost storage and detect dangling references. <p> It has long been recognized that traditional garbage collection techniques developed for programming languages are not directly applicable in a database context <ref> [But87, FCW89, KLW89] </ref>. OODBMS introduce several complications that can impact the correctness and/or performance of traditional garbage collection approaches. These include: Atomic Transactions: The abort of a partially completed transaction requires that the effects of any changes made by the transaction be completely rolled-back. <p> The invariants that an incremental collector must respect were first proposed by [DLM + 78, Bak78]. Our work addresses the efficient implementation of similar invariants in a (transactional) client-server DBMS context. The earliest study of garbage collection for object-oriented databases was done by Butler <ref> [But87] </ref>. This work simulated the behavior of several kinds of collectors running against a centralized OODBMS, but did not consider interactions with concurrency control, recovery, and caching mechanisms.
Reference: [Cat94] <author> R. Cattell. </author> <title> The ODMG Object Database Standard, </title> <address> Rel 1.1. Morgan-Kaufman, San Mateo, CA, </address> <year> 1994. </year>
Reference-contexts: Disk-Resident Data: Because much of the data managed by an OODBMS is disk resident, the garbage collector must be efficient with respect to I/O. 1 Also, garbage collection is specified in the ODMG object database standard Smalltalk binding <ref> [Cat94] </ref>. 2 Persistence: Modern garbage collectors for programming languages are based on the assump-tion that the volume of live (i.e, non-garbage) objects is small compared to the volume of garbage objects. Due to persistence, this assumption is not valid for OODBMS.
Reference: [CDN93] <author> M. Carey, D. Dewitt, and J. Naughton. </author> <title> The OO7 Benchmark. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf, </booktitle> <address> Washington D.C., </address> <month> May 93. </month>
Reference-contexts: EXODUS is a client-server, multi-user system which runs on many Unix platforms. It has been shown to have performance that is competitive with existing commercial OODBMS <ref> [CDN93] </ref>. EXODUS supports the transactional management of untyped objects of variable length, and has full support for indexing, concurrency control, recovery, multiple clients and multiple servers. Data is locked using a strict two-phase locking protocol at the page or coarser granularity.
Reference: [CDRS86] <author> M. Carey, D. DeWitt, J. Richarson, and E. Shekita. </author> <title> Object and File Management in the EXODUS Extensible Database System. </title> <booktitle> In Proc. of the 12th VLDB Int. Conf., </booktitle> <address> Kyoto, Japan, </address> <year> 1986. </year>
Reference-contexts: Data is locked using a strict two-phase locking protocol at the page or coarser granularity. Recovery is provided by an ARIES-based [MHL + 92] WAL protocol [FZT + 92]. EXODUS extends a traditional slotted page structure to support objects of arbitrary length <ref> [CDRS86] </ref>. "Small" data items (those that are smaller than a page) and the headers of larger ones are stored on slotted pages. Internally, objects are identified using physical OIDs that allow pages to be reorganized without changing the identifiers of objects.
Reference: [CFLS91] <author> M. Carey, M. Franklin, M. Livny, and E. Shekita. </author> <title> Data Caching Tradeoffs in Client-Server DBMS Architectures. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <address> Denver, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: It can co-exist with performance enhancements such as inter-transaction caching <ref> [CFLS91] </ref> and flexible "steal" buffer management between clients and servers, which allows dirty pages to be sent to the server at any time during a transaction. * It has been implemented in the client-server EXODUS storage manager, and has been shown to impose very little performance overhead. <p> At commit time, copies of any remaining dirty pages are sent to the server. The client retains the contents of its cache across transaction boundaries, but no locks are held on those pages. Cache consistency is maintained using a check-on-access policy (based on "Caching 2PL" <ref> [CFLS91] </ref>). For recovery purposes all pages are tagged with a Log Sequence Number (LSN) which serves as a timestamp for the page. The server keeps a small list of the current LSNs for pages that have been recently requested by clients.
Reference: [CFZ94] <author> M. Carey, M. Franklin, and M. Zaharioudakis. </author> <title> Fine-Grained Sharing in a Page Server OODBMS. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <address> Minneapolis, MN, </address> <month> May 94. </month>
Reference-contexts: Data-shipping systems can be structured as page servers, which send physical units of data between servers and clients, and object servers, in which clients and servers interact using logical units of data <ref> [DFMV90, CFZ94] </ref>. 2 Each Client DBMS process is responsible for translating local application data requests into requests for specific database items (i.e., pages or objects) and for bringing those items into memory at the client.
Reference: [Coh81] <author> J. Cohen. </author> <title> Garbage Collection of Linked Data Structures. </title> <journal> Computing Surveys, </journal> <volume> 13(3) </volume> <pages> 341-367, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: Manual detection and reclamation of garbage increases code complexity and is highly error-prone, raising the risk of memory leaks and dangling pointers. For these reasons automated garbage collection for programming languages has been a major area of investigation <ref> [Coh81, Wil92] </ref>. The shared and persistent nature of databases, combined with the importance of efficient storage utilization provide additional motivation for the introduction of automated garbage collection. <p> Surveys of this work include <ref> [Coh81] </ref> and [Wil92]. The invariants that an incremental collector must respect were first proposed by [DLM + 78, Bak78]. Our work addresses the efficient implementation of similar invariants in a (transactional) client-server DBMS context. The earliest study of garbage collection for object-oriented databases was done by Butler [But87].
Reference: [Col60] <author> G. Collins. </author> <title> A method for overlapping and erasure of lists. Com. </title> <journal> of the ACM, </journal> <volume> 2(12) </volume> <pages> 655-657, </pages> <month> December </month> <year> 1960. </year>
Reference-contexts: In general, there are two families of garbage collection techniques: Reference Counting and Tracing. 3.1 Reference Counting In reference counting systems <ref> [Col60, McB63] </ref>, a count of the number of references (pointers) to each object is kept. The reference count for an object is incremented every time a new reference to it is created and is decremented every time an existing reference to it is removed.
Reference: [CWZ94] <author> J. Cook, A. Wolf, and B. Zorn. </author> <title> Partition Selection Policies in Object Database Garbage Collection. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <pages> pages 371-382, </pages> <address> Mineapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Similar to other recent work on DBMS garbage collection <ref> [CWZ94, YNY94, ML94] </ref> we have adopted a partitioned approach in order to avoid the need to scan an entire database before reclaiming any space. In contrast to the other work, which advocated copying or reference counting approaches however, we have chosen to implement a non-copying Mark & Sweep algorithm. <p> The IRL serves as an additional root of per-sistence for the partition-local collector. Options for deciding when a partition should be collected have been studied in <ref> [CWZ94] </ref>. Note that the objects themselves point directly to each other and do not involve the inter-partition reference list. Similar schemes are often used by distributed garbage collection algorithms to handle inter-node references (e.g.,[SGP90, ML94]).
Reference: [DB76] <author> L. Deutsch and D. Bobrow. </author> <title> An Efficient, Incremental, Automatic Garbage Collector. Com. </title> <journal> of the ACM, </journal> <volume> 19(9) </volume> <pages> 522-526, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: Reference counting, however, is not suitable for garbage collecting client-server OODBMS for several reasons. First, as it is well known, reference counting schemes fail to reclaim circular structures [McB63]; garbage objects that mutually reference one another will not be collected. Second, even under deferred reference counting (e.g., <ref> [DB76] </ref>), the overhead of maintaining reference counts for the objects in a large database can be quite high [YNY94] and can require additional I/O.
Reference: [DFMV90] <author> D. DeWitt, P. Futtersack, D. Maier, and F. Velez. </author> <title> A Study of Three Alternative Workstation-Server Architectures for Object-Oriented Database Systems. </title> <booktitle> In Proc. of the 16th VLDB Int. Conf., </booktitle> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Data-shipping systems can be structured as page servers, which send physical units of data between servers and clients, and object servers, in which clients and servers interact using logical units of data <ref> [DFMV90, CFZ94] </ref>. 2 Each Client DBMS process is responsible for translating local application data requests into requests for specific database items (i.e., pages or objects) and for bringing those items into memory at the client.
Reference: [DLM + 78] <author> E. Dijkstra, L. Lamport, A. Martin, C. Scholten, and E. Steffens. </author> <title> On-the-Fly Garbage Collection: An Exercise in Cooperation. Com. </title> <journal> of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: Finally, it should be noted that the problems discussed in this section have analogs in incremental collection algorithms for traditional programming languages. Dijkstra and Baker have described invariants that ensure correctness for incremental collectors <ref> [DLM + 78, Bak78] </ref>. In Section 4.1 we provide invariants that reflect the transactional nature of the client-server DBMS environment. 2.4 Problem III: Overwriting Collected Pages A third set of problems involves the overwriting of a garbage collected page. One way that this can occur is during transaction REDO. <p> As stated previously, these invariants are similar in spirit to invariants that have been proposed for traditional incremental garbage collectors <ref> [DLM + 78, Bak78] </ref>. In contrast to that earlier work, however, these invariants reflect the transactional nature of database accesses. Invariant I1 (in conjunction with assumption A1) protects against the rollback problem, as only objects made garbage by committed transactions will be eligible for reclamation. <p> Surveys of this work include [Coh81] and [Wil92]. The invariants that an incremental collector must respect were first proposed by <ref> [DLM + 78, Bak78] </ref>. Our work addresses the efficient implementation of similar invariants in a (transactional) client-server DBMS context. The earliest study of garbage collection for object-oriented databases was done by Butler [But87].
Reference: [Exo93] <author> EXODUS Project Group. </author> <title> EXODUS Storage Manager Architectural Overview, </title> <year> 1993. </year>
Reference-contexts: In order to assess our algorithm in light of these requirements we have implemented it in the client-server version of the EXODUS storage manager <ref> [FC92, Exo93] </ref>. In this section we describe the implementation of a single-partition collector. The extensions for multiple partitions with inter-partition references discussed in Section 4.6 are currently being added. 5.1 The EXODUS Storage Manager Our initial implementation is based is the EXODUS storage manager v3.1 [Exo93]. <p> In this section we describe the implementation of a single-partition collector. The extensions for multiple partitions with inter-partition references discussed in Section 4.6 are currently being added. 5.1 The EXODUS Storage Manager Our initial implementation is based is the EXODUS storage manager v3.1 <ref> [Exo93] </ref>. EXODUS is a client-server, multi-user system which runs on many Unix platforms. It has been shown to have performance that is competitive with existing commercial OODBMS [CDN93].
Reference: [FC92] <author> M. Franklin and M. Carey. </author> <title> Client-Server Caching Revisited. </title> <booktitle> In Proc. of the Int. Workshop on Distributed Object Management, </booktitle> <address> Edmonton, Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: In order to assess our algorithm in light of these requirements we have implemented it in the client-server version of the EXODUS storage manager <ref> [FC92, Exo93] </ref>. In this section we describe the implementation of a single-partition collector. The extensions for multiple partitions with inter-partition references discussed in Section 4.6 are currently being added. 5.1 The EXODUS Storage Manager Our initial implementation is based is the EXODUS storage manager v3.1 [Exo93].
Reference: [FCL93] <author> M. Franklin, M. Carey, and M. Livny. </author> <title> Local Disk Caching in Client-Server Database Systems. </title> <booktitle> In Proc. of the 19th VLDB Int. Conf, </booktitle> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: A2 must be supported by any client-server DBMS that implements WAL-based recovery (e.g., EXODUS [FZT + 92], and ARIES/CSA [MN94]). A3 simplifies recovery and avoids the need for client checkpoints. The tradeoffs involved in relaxing A3 in the workstation/server DBMS environment are discussed in [FZT + 92], <ref> [FCL93] </ref>, and [MN94]. 4.1 Algorithm Overview A traditional Mark&Sweep [McC60] algorithm associates a "color" with each object in the object space. An object can have one of two colors: live or garbage.
Reference: [FCW89] <author> M. Franklin, G. Copeland, and G. Weikum. </author> <title> What's Different About Garbage Collection For Persistent Programming Languages? Technical Report ACA-ST-062-89, </title> <institution> MCC, Austin, Texas, </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: provides a simple way to express persistence that is implicit and orthogonal to object type [ZM90]; therefore, some database systems, such as GemStone [BOS91] and O2 [BDK91], directly implement persistence based on reachability. 1 In addition, there has been a growing research interest in applying garbage collection techniques to OODBMS <ref> [But87, FCW89, KLW89, ONG93, ML94, YNY94] </ref>. In general, however, many existing systems still require programmers to explicitly deallocate objects. Such systems therefore, typically provide off-line utilities which must be run periodically in order to reclaim lost storage and detect dangling references. <p> It has long been recognized that traditional garbage collection techniques developed for programming languages are not directly applicable in a database context <ref> [But87, FCW89, KLW89] </ref>. OODBMS introduce several complications that can impact the correctness and/or performance of traditional garbage collection approaches. These include: Atomic Transactions: The abort of a partially completed transaction requires that the effects of any changes made by the transaction be completely rolled-back.
Reference: [FZT + 92] <author> M. Franklin, M. Zwilling, C. Tan, M. Carey, and D. DeWitt. </author> <title> Crash Recovery in Client-Server EXODUS. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <address> San Diego, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: A2 must be supported by any client-server DBMS that implements WAL-based recovery (e.g., EXODUS <ref> [FZT + 92] </ref>, and ARIES/CSA [MN94]). A3 simplifies recovery and avoids the need for client checkpoints. The tradeoffs involved in relaxing A3 in the workstation/server DBMS environment are discussed in [FZT + 92], [FCL93], and [MN94]. 4.1 Algorithm Overview A traditional Mark&Sweep [McC60] algorithm associates a "color" with each object in <p> A2 must be supported by any client-server DBMS that implements WAL-based recovery (e.g., EXODUS <ref> [FZT + 92] </ref>, and ARIES/CSA [MN94]). A3 simplifies recovery and avoids the need for client checkpoints. The tradeoffs involved in relaxing A3 in the workstation/server DBMS environment are discussed in [FZT + 92], [FCL93], and [MN94]. 4.1 Algorithm Overview A traditional Mark&Sweep [McC60] algorithm associates a "color" with each object in the object space. An object can have one of two colors: live or garbage. <p> Data is locked using a strict two-phase locking protocol at the page or coarser granularity. Recovery is provided by an ARIES-based [MHL + 92] WAL protocol <ref> [FZT + 92] </ref>. EXODUS extends a traditional slotted page structure to support objects of arbitrary length [CDRS86]. "Small" data items (those that are smaller than a page) and the headers of larger ones are stored on slotted pages.
Reference: [GA92] <author> O. Gruber and L. Amsaleg. </author> <title> Object Grouping in Eos. </title> <booktitle> In Proc. of the Int. Workshop on Distributed Object Management, </booktitle> <pages> pages 117-131, </pages> <address> Edmonton, Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: However, a copying collector will typically cluster objects in the order that they are visited (e.g., depth first search). This clustering produced by the collector may be in conflict with database requirements or user-specified hints (e.g, <ref> [BD90, GA92] </ref>). For example, using generation scavenging, objects of that differ widely in age can not be clustered together. Fault-Tolerance: Copying causes objects to move between pages, which can greatly complicate recovery [KLW89, MRV91, YNY94].
Reference: [GR93] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <address> Morgan-Kaufman, San Mateo, CA, </address> <year> 1993. </year> <month> 26 </month>
Reference-contexts: Our collector has the following characteristics: * It is server-based, but requires no callbacks to clients and performs only minimal synchro nization with client processes. * It works in the context of ACID transactions <ref> [GR93] </ref> with standard implementation techniques such as two-phase locking and write-ahead-logging; it requires no special hardware. * It is incremental and non-disruptive; it holds no locks and introduces very little additional logging. <p> The algorithm is based on the following assumptions about the client-server database system: Assumption A1: All user operations involving pointer updates are done in the context of ACID transactions <ref> [GR93] </ref>. 3 Assumption A2: The system follows the write-ahead-logging (WAL) protocol between clients and the server.
Reference: [Hug85] <author> J. Hughes. </author> <title> A Distributed Garbage Collection Algorithm. </title> <booktitle> In Functional Languages and Computer Architectures, number 201 in Lecture Notes in Computer Science, </booktitle> <pages> pages 256-272, </pages> <address> Nancy (France), </address> <month> September </month> <year> 1985. </year> <note> Springer-Verlag. </note>
Reference-contexts: Thus, IRLs must be maintained in database pages (rather than with in-memory structures), and updates to them must be logged. Secondly, as is well known, this type of approach can not collect cycles of garbage that are distributed across multiple partitions. Separate algorithms such as Hughes' inter-partition collector <ref> [Hug85] </ref> can be used to collect such cycles periodically.
Reference: [KLW89] <author> E. Kolodner, B. Liskov, and W. Weihl. </author> <title> Atomic Garbage collection: Managing a Stable Heap. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <pages> pages 15-25, </pages> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: provides a simple way to express persistence that is implicit and orthogonal to object type [ZM90]; therefore, some database systems, such as GemStone [BOS91] and O2 [BDK91], directly implement persistence based on reachability. 1 In addition, there has been a growing research interest in applying garbage collection techniques to OODBMS <ref> [But87, FCW89, KLW89, ONG93, ML94, YNY94] </ref>. In general, however, many existing systems still require programmers to explicitly deallocate objects. Such systems therefore, typically provide off-line utilities which must be run periodically in order to reclaim lost storage and detect dangling references. <p> It has long been recognized that traditional garbage collection techniques developed for programming languages are not directly applicable in a database context <ref> [But87, FCW89, KLW89] </ref>. OODBMS introduce several complications that can impact the correctness and/or performance of traditional garbage collection approaches. These include: Atomic Transactions: The abort of a partially completed transaction requires that the effects of any changes made by the transaction be completely rolled-back. <p> This clustering produced by the collector may be in conflict with database requirements or user-specified hints (e.g, [BD90, GA92]). For example, using generation scavenging, objects of that differ widely in age can not be clustered together. Fault-Tolerance: Copying causes objects to move between pages, which can greatly complicate recovery <ref> [KLW89, MRV91, YNY94] </ref>. Object movement requires the use of forwarding pointers or logical object identifiers (OIDs), both of which must be updated atomically with the object movement. <p> This work simulated the behavior of several kinds of collectors running against a centralized OODBMS, but did not consider interactions with concurrency control, recovery, and caching mechanisms. More recent work has investigated fault-tolerant garbage collection techniques for transactional persistent systems in centralized <ref> [KLW89, KW93, ONG93] </ref> and distributed [MRV91, MS91] architectures. This work addresses fault tolerance but does not consider dynamic page replication and caching as arises in a workstation/server environment. A reference counting collection scheme for MIT's Thor system is described in [ML94].
Reference: [KW93] <author> E. Kolodner and W. Weihl. </author> <title> Atomic incremental garbage collection and recovery for large stable heap. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <address> Washington D.C., </address> <month> June </month> <year> 1993. </year>
Reference-contexts: At the server, the incoming log records are examined, and those that represent the cutting of a reference will cause a PRT entry to be made. Note that unlike previous work that exploits logs (e.g., <ref> [KW93, ONG93] </ref>), this algorithm processes log records as they arrive from the server | prior 11 to their reaching stable storage. When a transaction terminates (commits or aborts), its entries in the PRT are flagged. <p> This work simulated the behavior of several kinds of collectors running against a centralized OODBMS, but did not consider interactions with concurrency control, recovery, and caching mechanisms. More recent work has investigated fault-tolerant garbage collection techniques for transactional persistent systems in centralized <ref> [KLW89, KW93, ONG93] </ref> and distributed [MRV91, MS91] architectures. This work addresses fault tolerance but does not consider dynamic page replication and caching as arises in a workstation/server environment. A reference counting collection scheme for MIT's Thor system is described in [ML94].
Reference: [LDS92] <author> B. Liskov, M. Day, and L. Shrira. </author> <title> Distributed Object Management in Thor. </title> <booktitle> In Proc. of the Int. Workshop on Distributed Object Management, </booktitle> <pages> pages 79-91, </pages> <address> Edmonton, Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: This work addresses fault tolerance but does not consider dynamic page replication and caching as arises in a workstation/server environment. A reference counting collection scheme for MIT's Thor system is described in [ML94]. Thor <ref> [LDS92] </ref> is a distributed OODBMS which uses optimistic concurrency control to regulate accesses to objects. This paper focuses on distributed collection across servers in a client-server environment rather than on collection that is local to a server.
Reference: [McB63] <author> J. McBeth. </author> <title> On the Reference Counter Method. Com. </title> <booktitle> of the ACM, </booktitle> <address> 6(9):575, </address> <month> September </month> <year> 1963. </year>
Reference-contexts: In general, there are two families of garbage collection techniques: Reference Counting and Tracing. 3.1 Reference Counting In reference counting systems <ref> [Col60, McB63] </ref>, a count of the number of references (pointers) to each object is kept. The reference count for an object is incremented every time a new reference to it is created and is decremented every time an existing reference to it is removed. <p> Second, this approach is inherently incremental; the garbage collector can be easily interleaved with transaction execution. Reference counting, however, is not suitable for garbage collecting client-server OODBMS for several reasons. First, as it is well known, reference counting schemes fail to reclaim circular structures <ref> [McB63] </ref>; garbage objects that mutually reference one another will not be collected. Second, even under deferred reference counting (e.g., [DB76]), the overhead of maintaining reference counts for the objects in a large database can be quite high [YNY94] and can require additional I/O.
Reference: [McC60] <author> J. McCarthy. </author> <title> Recursive Functions of Symbolic Expressions and their Computation by Machine. Com. </title> <journal> of the ACM, </journal> <volume> 3(4) </volume> <pages> 184-195, </pages> <month> April </month> <year> 1960. </year>
Reference-contexts: A3 simplifies recovery and avoids the need for client checkpoints. The tradeoffs involved in relaxing A3 in the workstation/server DBMS environment are discussed in [FZT + 92], [FCL93], and [MN94]. 4.1 Algorithm Overview A traditional Mark&Sweep <ref> [McC60] </ref> algorithm associates a "color" with each object in the object space. An object can have one of two colors: live or garbage. The colors for objects are stored in special color maps that are not part of the persistent object space.
Reference: [MHL + 92] <author> C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh, and P. Schwarz. </author> <title> ARIES: A Transaction Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(1), </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: EXODUS supports the transactional management of untyped objects of variable length, and has full support for indexing, concurrency control, recovery, multiple clients and multiple servers. Data is locked using a strict two-phase locking protocol at the page or coarser granularity. Recovery is provided by an ARIES-based <ref> [MHL + 92] </ref> WAL protocol [FZT + 92]. EXODUS extends a traditional slotted page structure to support objects of arbitrary length [CDRS86]. "Small" data items (those that are smaller than a page) and the headers of larger ones are stored on slotted pages.
Reference: [ML94] <author> U. Maheshwari and B. Liskov. </author> <title> Fault-Tolerant Distributed Garbage Collection in a Client-Server Object-Oriented Database. </title> <booktitle> In Proc. of the 3rd PDIS Int. Conf., </booktitle> <address> Austin, TX, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: provides a simple way to express persistence that is implicit and orthogonal to object type [ZM90]; therefore, some database systems, such as GemStone [BOS91] and O2 [BDK91], directly implement persistence based on reachability. 1 In addition, there has been a growing research interest in applying garbage collection techniques to OODBMS <ref> [But87, FCW89, KLW89, ONG93, ML94, YNY94] </ref>. In general, however, many existing systems still require programmers to explicitly deallocate objects. Such systems therefore, typically provide off-line utilities which must be run periodically in order to reclaim lost storage and detect dangling references. <p> Similar to other recent work on DBMS garbage collection <ref> [CWZ94, YNY94, ML94] </ref> we have adopted a partitioned approach in order to avoid the need to scan an entire database before reclaiming any space. In contrast to the other work, which advocated copying or reference counting approaches however, we have chosen to implement a non-copying Mark & Sweep algorithm. <p> This work addresses fault tolerance but does not consider dynamic page replication and caching as arises in a workstation/server environment. A reference counting collection scheme for MIT's Thor system is described in <ref> [ML94] </ref>. Thor [LDS92] is a distributed OODBMS which uses optimistic concurrency control to regulate accesses to objects. This paper focuses on distributed collection across servers in a client-server environment rather than on collection that is local to a server. <p> The algorithm uses a "no-steal" policy so that modified objects are not sent to the servers prior to commit. This policy avoids the problems due to partial flushes of updates (Section 2.3) at the expense of reduced flexibility in client cache management. <ref> [ML94] </ref> describes the algorithm but does not discuss an implementation and provides no performance analysis. The work that is most relevant to our algorithm is [YNY94]. This paper investigates the performance tradeoffs of several reclamation algorithms for client-server persistent object stores.
Reference: [MN94] <author> C. Mohan and I. Narang. ARIES/CSA: </author> <title> A method for Database Recovery in Client-Server Architectures. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <address> Minneapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: A2 must be supported by any client-server DBMS that implements WAL-based recovery (e.g., EXODUS [FZT + 92], and ARIES/CSA <ref> [MN94] </ref>). A3 simplifies recovery and avoids the need for client checkpoints. The tradeoffs involved in relaxing A3 in the workstation/server DBMS environment are discussed in [FZT + 92], [FCL93], and [MN94]. 4.1 Algorithm Overview A traditional Mark&Sweep [McC60] algorithm associates a "color" with each object in the object space. <p> A2 must be supported by any client-server DBMS that implements WAL-based recovery (e.g., EXODUS [FZT + 92], and ARIES/CSA <ref> [MN94] </ref>). A3 simplifies recovery and avoids the need for client checkpoints. The tradeoffs involved in relaxing A3 in the workstation/server DBMS environment are discussed in [FZT + 92], [FCL93], and [MN94]. 4.1 Algorithm Overview A traditional Mark&Sweep [McC60] algorithm associates a "color" with each object in the object space. An object can have one of two colors: live or garbage. The colors for objects are stored in special color maps that are not part of the persistent object space.
Reference: [MRV91] <author> L. Mancini, V. Rotella, and S. Venosa. </author> <title> Copying Garbage Collection for Distributed Object Stores. </title> <booktitle> In 10th Symposium on Reliable Distributed Systems, </booktitle> <address> Pisa, Italy, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: This clustering produced by the collector may be in conflict with database requirements or user-specified hints (e.g, [BD90, GA92]). For example, using generation scavenging, objects of that differ widely in age can not be clustered together. Fault-Tolerance: Copying causes objects to move between pages, which can greatly complicate recovery <ref> [KLW89, MRV91, YNY94] </ref>. Object movement requires the use of forwarding pointers or logical object identifiers (OIDs), both of which must be updated atomically with the object movement. <p> This work simulated the behavior of several kinds of collectors running against a centralized OODBMS, but did not consider interactions with concurrency control, recovery, and caching mechanisms. More recent work has investigated fault-tolerant garbage collection techniques for transactional persistent systems in centralized [KLW89, KW93, ONG93] and distributed <ref> [MRV91, MS91] </ref> architectures. This work addresses fault tolerance but does not consider dynamic page replication and caching as arises in a workstation/server environment. A reference counting collection scheme for MIT's Thor system is described in [ML94].
Reference: [MS91] <author> L. Mancini and S. Shrinivastava. </author> <title> Fault-tolerant Reference Counting for Garbage Colection in Distributed Systems. </title> <journal> Computer Journal, </journal> <volume> 34(6) </volume> <pages> 503-513, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: This work simulated the behavior of several kinds of collectors running against a centralized OODBMS, but did not consider interactions with concurrency control, recovery, and caching mechanisms. More recent work has investigated fault-tolerant garbage collection techniques for transactional persistent systems in centralized [KLW89, KW93, ONG93] and distributed <ref> [MRV91, MS91] </ref> architectures. This work addresses fault tolerance but does not consider dynamic page replication and caching as arises in a workstation/server environment. A reference counting collection scheme for MIT's Thor system is described in [ML94].
Reference: [ONG93] <author> J. O'Toole, S. Nettles, and D. Gifford. </author> <title> Concurrent Compacting Garbage Collection of a Persistent Heap. </title> <booktitle> In Proc. of the 14th SOSP, </booktitle> <pages> pages 161-174, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year> <note> ACM Press. </note>
Reference-contexts: provides a simple way to express persistence that is implicit and orthogonal to object type [ZM90]; therefore, some database systems, such as GemStone [BOS91] and O2 [BDK91], directly implement persistence based on reachability. 1 In addition, there has been a growing research interest in applying garbage collection techniques to OODBMS <ref> [But87, FCW89, KLW89, ONG93, ML94, YNY94] </ref>. In general, however, many existing systems still require programmers to explicitly deallocate objects. Such systems therefore, typically provide off-line utilities which must be run periodically in order to reclaim lost storage and detect dangling references. <p> At the server, the incoming log records are examined, and those that represent the cutting of a reference will cause a PRT entry to be made. Note that unlike previous work that exploits logs (e.g., <ref> [KW93, ONG93] </ref>), this algorithm processes log records as they arrive from the server | prior 11 to their reaching stable storage. When a transaction terminates (commits or aborts), its entries in the PRT are flagged. <p> This work simulated the behavior of several kinds of collectors running against a centralized OODBMS, but did not consider interactions with concurrency control, recovery, and caching mechanisms. More recent work has investigated fault-tolerant garbage collection techniques for transactional persistent systems in centralized <ref> [KLW89, KW93, ONG93] </ref> and distributed [MRV91, MS91] architectures. This work addresses fault tolerance but does not consider dynamic page replication and caching as arises in a workstation/server environment. A reference counting collection scheme for MIT's Thor system is described in [ML94].
Reference: [SGP90] <author> M. Shapiro, O. Gruber, and D. Plainfosse. </author> <title> A Garbage Detection Protocol for a Realistic Distributed Object-support System. </title> <type> Technical Report INRIA-1320, </type> <institution> INRIA, Rocquencourt, </institution> <month> Novem-ber </month> <year> 1990. </year>
Reference: [Wil92] <author> P. Wilson. </author> <title> Uniprocessor Garbage Collection Techniques. </title> <booktitle> In Int. Workshop on Memory Management, </booktitle> <volume> volume 637, </volume> <pages> pages 1-43, </pages> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference-contexts: Manual detection and reclamation of garbage increases code complexity and is highly error-prone, raising the risk of memory leaks and dangling pointers. For these reasons automated garbage collection for programming languages has been a major area of investigation <ref> [Coh81, Wil92] </ref>. The shared and persistent nature of databases, combined with the importance of efficient storage utilization provide additional motivation for the introduction of automated garbage collection. <p> Therefore, a single PRT entry transitively protects all of the objects that are reachable from the protected object. In order to make the necessary entries in the PRT, all updates to pointer fields in objects must be trapped. Traps of this form are typically implemented using a write barrier <ref> [Wil92, YNY94] </ref>. A write barrier detects when an assignment operation occurs and performs any bookkeeping that is required by the garbage collector. Recall that the garbage collector (and hence, the PRT) reside at the server while updates are performed on cached data copies at clients. <p> Surveys of this work include [Coh81] and <ref> [Wil92] </ref>. The invariants that an incremental collector must respect were first proposed by [DLM + 78, Bak78]. Our work addresses the efficient implementation of similar invariants in a (transactional) client-server DBMS context. The earliest study of garbage collection for object-oriented databases was done by Butler [But87].
Reference: [YNY94] <author> V. Yong, J. Naughton, and J. Yu. </author> <title> Storage Reclamation and Reorganization in Client-Server Persistent Object Stores. </title> <booktitle> In Proc. of the Data Engineering Int. Conf., </booktitle> <pages> pages 120-133, </pages> <address> Houston, TX, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: provides a simple way to express persistence that is implicit and orthogonal to object type [ZM90]; therefore, some database systems, such as GemStone [BOS91] and O2 [BDK91], directly implement persistence based on reachability. 1 In addition, there has been a growing research interest in applying garbage collection techniques to OODBMS <ref> [But87, FCW89, KLW89, ONG93, ML94, YNY94] </ref>. In general, however, many existing systems still require programmers to explicitly deallocate objects. Such systems therefore, typically provide off-line utilities which must be run periodically in order to reclaim lost storage and detect dangling references. <p> Similar to other recent work on DBMS garbage collection <ref> [CWZ94, YNY94, ML94] </ref> we have adopted a partitioned approach in order to avoid the need to scan an entire database before reclaiming any space. In contrast to the other work, which advocated copying or reference counting approaches however, we have chosen to implement a non-copying Mark & Sweep algorithm. <p> Second, even under deferred reference counting (e.g., [DB76]), the overhead of maintaining reference counts for the objects in a large database can be quite high <ref> [YNY94] </ref> and can require additional I/O. Furthermore, the reference count structures must be fault-tolerant, as reconstructing them as part of recovery from a system crash is prohibitively expensive. 3.2 Tracing The other main family of collection techniques are based on Tracing. Tracing collectors consist of two basic functions. <p> This clustering produced by the collector may be in conflict with database requirements or user-specified hints (e.g, [BD90, GA92]). For example, using generation scavenging, objects of that differ widely in age can not be clustered together. Fault-Tolerance: Copying causes objects to move between pages, which can greatly complicate recovery <ref> [KLW89, MRV91, YNY94] </ref>. Object movement requires the use of forwarding pointers or logical object identifiers (OIDs), both of which must be updated atomically with the object movement. <p> Therefore, a copying collector requires a close coordination with the recovery system, and may require the acquisition of multiple write locks during object movement (as in <ref> [YNY94] </ref>). In contrast, sweeping is relatively easy to make fault-tolerant (assuming the use of slotted pages), as live objects always maintain their addressability. These considerations have led us to adopt a sweeping-based approach to garbage collection in workstation/server OODBMS. <p> Therefore, a single PRT entry transitively protects all of the objects that are reachable from the protected object. In order to make the necessary entries in the PRT, all updates to pointer fields in objects must be trapped. Traps of this form are typically implemented using a write barrier <ref> [Wil92, YNY94] </ref>. A write barrier detects when an assignment operation occurs and performs any bookkeeping that is required by the garbage collector. Recall that the garbage collector (and hence, the PRT) reside at the server while updates are performed on cached data copies at clients. <p> This policy avoids the problems due to partial flushes of updates (Section 2.3) at the expense of reduced flexibility in client cache management. [ML94] describes the algorithm but does not discuss an implementation and provides no performance analysis. The work that is most relevant to our algorithm is <ref> [YNY94] </ref>. This paper investigates the performance tradeoffs of several reclamation algorithms for client-server persistent object stores. Some of the results are obtained from an implementation of an incremental partitioned Mark & Sweep algorithm, although very few details of this algorithm or its implementation are given. <p> Measurements of the implementation showed that the write barrier has only minimal impact on client performance; our measurements support this result. Several other algorithms are examined in <ref> [YNY94] </ref>, including a partitioned copy-based collection algorithm. This algorithm obtains non-two-phase exclusive transactional locks for moving objects and uses callbacks, it also requires the use of logical OIDs.
Reference: [ZM90] <author> S. Zdonik and D. Maier. </author> <title> Readings in Object-Oriented Database Systems. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1990. </year> <month> 27 </month>
Reference-contexts: Reachability-based persistence provides a simple way to express persistence that is implicit and orthogonal to object type <ref> [ZM90] </ref>; therefore, some database systems, such as GemStone [BOS91] and O2 [BDK91], directly implement persistence based on reachability. 1 In addition, there has been a growing research interest in applying garbage collection techniques to OODBMS [But87, FCW89, KLW89, ONG93, ML94, YNY94].
References-found: 39

