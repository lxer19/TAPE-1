URL: ftp://ftp.cs.rutgers.edu/pub/borgida/clasp-reconstructed-KR92.ps.gz
Refering-URL: http://www.cs.rutgers.edu/~borgida/index.html
Root-URL: http://www.cs.rutgers.edu
Title: Towards the Systematic Development of Description Logic Reasoners: CLASP reconstructed  
Author: Alex Borgida 
Address: New Brunswick, NJ 08903  
Affiliation: Dept. of Computer Science Rutgers University  
Abstract: It is argued that considerable benefits can be obtained by making KR&R systems easily extendable, so that new language constructs can be added on a per-application basis. In order to achieve this extensibility we need techniques for formally specifying the extensions, and for modularly and locally modifying the implementations. We present two such techniques applicable to the family of reasoners based on Description/Terminological Logics, namely natural semantics rules of inference, and the protodl customizable KBMS architecture. The bulk of the paper aims to demonstrate the efficacy of these techniques, together with some heuristics for their use, by showing how we could reconstruct a previously proposed description logic: Devanbu and Litman's extension to classic, called clasp, designed to reason about actions and plans. In the process, we uncover a few deficiencies in the original proposal, and provide for the first time a formal semantics for clasp.
Abstract-found: 1
Intro-found: 1
Reference: [Aho et al, 1986] <author> Aho, A., R. Sethi, and J. Ullman, </author> <booktitle> Compilers: Principles, Techniques, and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986 </year>
Reference-contexts: Assuming that extensibility is a desirable property, how can we achieve it? In looking around for an analogy, we find that modern pro gramming language theory and compiler technology (PL&C) (e.g., <ref> [Aho et al, 1986] </ref>) supports language extensibility: for example, to add a case-statement to an Algol-like language we can first specify its syntax, type-correctness rule, and semantics; and we can then change the compiler implementation by modifying some of its modules (e.g., lexical/syntactic/semantic analyzers, intermediate code generator) but usually not others <p> The implementations of Normalize SINGLE, Normalize SEQ, Normalize ALTERN and Normalize LOOP therefore build up a non-deterministic automaton with null-transitions, according to a standard algorithm, such as the one presented in <ref> [Aho et al, 1986] </ref>. For example, Normalize SINGLE (single (A)) returns two states connected by a single transition, labeled by Normalize ACT (A).
Reference: [Borgida 1991] <author> Borgida, A., </author> <title> "Terminologic Frames as Types: Inference rules and prospective applications", </title> <type> Technical Report, </type> <institution> Department of Computer Science, Rutgers University, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: comparison, we invite the reader to give corresponding semantics for clasp in First Order Logic, say.) Compared to other axiomatic approaches, they have advantages such as the existence of PL&C tools like Ty-pol [Despeyroux 1984] for rapid prototyping in Prolog, and the suitability of natural deduction proofs for explanation (see <ref> [Borgida 1991] </ref>). (3) The protodl system. While elsewhere we show how constructors in classic can be added to protodl, here we showed how protodl can be used to implement the subsumption--reasoning of clasp.
Reference: [Borgida 1992a] <author> Borgida, A., </author> <title> "From Type Systems to Knowledge Representation: Natural Semantics Specifications for Description Logics," </title> <booktitle> Int. J. of Intelligent and Cooperative Information Systems 1(1), </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Specifically, this paper aims to provide (further) evidence for the following claims: (1) The inferences that are performed by a DL-reasoners should be extended through the addition of new, possibly domain-specific, description constructors. (2) Natural semantics axiomati-zations, as used in <ref> [Borgida 1992a] </ref>, are a useful alternative way to present the semantics of DLs. (3) protodl [Borgida & Brachman, 1992] offers an architecture for effective DL reasoners that allows DL implementations to be built up from small components, which are either prefabricated or need to be filled in by the implementors. (4) <p> For any language, it is beneficial to have alternative formalizations, which can be proven equivalent (see [Hoare & Lauer, 1974]). Axiomatic specifications appear to have the advantage (not demonstrated here, but shown in <ref> [Borgida 1992a] </ref>) of describing incomplete reasoners more easily than denotational semantics.
Reference: [Borgida 1992b] <author> Borgida, A., </author> <title> "A new look at Description Logics and their Utility in Information Management ( or Description Logics are not just for the Flightless-Birds)", </title> <type> Technical Report, </type> <institution> Rutgers University, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: For example, we can state that some procedure being planned, NewSort, has at least two parameters, by ascribing to it the term at-least (2,params), and we can do so without having to know yet their exact identity. (See <ref> [Borgida 1992b] </ref> for a survey of DL applications.) DL-based systems perform several different kinds of reasoning using descriptions: determining whether one description subsumes another, whether two descriptions are mutually disjoint, classifying a new description in the hierarchy of previously defined ones, testing individuals for membership in concepts, etc.
Reference: [Borgida et al, 1989] <author> Borgida, A., Brachman, R. J., McGuinness, D. L., and L.A. Resnick, </author> <title> "CLASSIC: A Structural Data Model for Objects," </title> <booktitle> Proc. 1989 ACM SIGMOD International Conference on Management of Data, </booktitle> <month> June, </month> <year> 1989, </year> <pages> pp. 59-67. </pages>
Reference-contexts: The above claims are empirical in nature: we argue for them by showing that the techniques mentioned can be used to achieve useful results. In the previously cited papers we have shown how natural semantics and protodl can be used to describe the classic system <ref> [Borgida et al, 1989] </ref>. In this paper, we propose to revisit clasp - Devanbu and Litman's DL to support reasoning about actions and plans [Devanbu & Litman, 1991].
Reference: [Borgida & Brachman, 1992] <author> Borgida, A., and R.J. Brachman, "ProtoDL: </author> <title> A Customizable Knowledge Base Management System", </title> <booktitle> Conf. on Information and Knowledge Management, </booktitle> <address> Baltimore, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: provide (further) evidence for the following claims: (1) The inferences that are performed by a DL-reasoners should be extended through the addition of new, possibly domain-specific, description constructors. (2) Natural semantics axiomati-zations, as used in [Borgida 1992a], are a useful alternative way to present the semantics of DLs. (3) protodl <ref> [Borgida & Brachman, 1992] </ref> offers an architecture for effective DL reasoners that allows DL implementations to be built up from small components, which are either prefabricated or need to be filled in by the implementors. (4) The previous techniques, combined with heuristic guidelines for their use, can lead to a more <p> The following syntax is the starting point of the family of DLs implemented by the protodl system <ref> [Borgida & Brachman, 1992] </ref>: &lt;Description&gt; ::= &lt;Obj-Desc&gt; j nothing ;; the inconsistent description &lt;Obj-Desc&gt; ::= &lt;class identifier&gt; j and (&lt;Obj-Desc&gt;+) ;; intersection j any-object ;; the class of all objects &lt;role&gt; ::= &lt;identifier&gt; j &lt;attribute&gt; &lt;attribute&gt; ::= &lt;identifier&gt; One can therefore see protodl as a system which knows about conjunction, and <p> Note also that this was achieved by the simple addition of two abstract syntax constructors, for single and top-plan-exp. As detailed in <ref> [Borgida & Brachman, 1992] </ref>, the protodl system comes with built-in algorithms of general use in DL processing, including implementations of inheritance and classification algorithms, efficient management of large transitive is-a and disjointness hierarchies, symbol table management, error reporting, etc.
Reference: [Cohen et al, 1992] <author> Cohen, W., A. Borgida and H. Hirsch, </author> <title> "Computing Least Common Subsumers in Description Logics", </title> <booktitle> Proc. </booktitle> <address> AAAI'92 (San Jose), </address> <month> July </month> <year> 1992. </year>
Reference-contexts: Three attributes, ini 6 This function is potentially useful for many other purposes in a DL reasoner <ref> [Cohen et al, 1992] </ref>. tial, goal and steps, record this information. Steps however are not regular object individuals | they are sequences of action objects called scenarios in [Devanbu & Litman, 1991], and these are a key contribution of clasp.
Reference: [Despeyroux 1984] <author> Despeyroux, T., </author> <title> "Executable specification of static semantics", </title> <booktitle> Semantics of Data Types, </booktitle> <volume> LNCS Vol. 173, </volume> <month> June </month> <year> 1984. </year>
Reference-contexts: The rules of inference presented in this paper are "natural", elegant and concise. (For comparison, we invite the reader to give corresponding semantics for clasp in First Order Logic, say.) Compared to other axiomatic approaches, they have advantages such as the existence of PL&C tools like Ty-pol <ref> [Despeyroux 1984] </ref> for rapid prototyping in Prolog, and the suitability of natural deduction proofs for explanation (see [Borgida 1991]). (3) The protodl system. While elsewhere we show how constructors in classic can be added to protodl, here we showed how protodl can be used to implement the subsumption--reasoning of clasp.
Reference: [Devanbu & Litman, 1991] <author> Devanbu, P., and D. Lit-man, </author> <title> "Plan-based Terminological Reasoning," </title> <booktitle> Proc. KR'91, </booktitle> <address> Boston, MA, </address> <year> 1991. </year>
Reference-contexts: 1983, Lenat & Guha, 1990, Rowley et al, 1986, Gaines 1991]), we mention two particular benefits we would hope to achieve: It would facilitate the design and implementation of domain-specific DL-reasoners that are now being proposed in the literature, such as ones dealing with time (e.g., [Schmiedel, 1990]), planning (e.g., <ref> [Devanbu & Litman, 1991, Heinsohn 1992] </ref>), and constraint-networks (e.g., [Weida & Litman, 1992]). <p> In the previously cited papers we have shown how natural semantics and protodl can be used to describe the classic system [Borgida et al, 1989]. In this paper, we propose to revisit clasp - Devanbu and Litman's DL to support reasoning about actions and plans <ref> [Devanbu & Litman, 1991] </ref>. In some sense this is an independent test of the proposed approach, applied to a practically significant system: clasp was used in a Software Information System [Devanbu et al, 1991]. <p> Next, we consider how plans, and especially plan steps which are sequences of actions can be added to our reasoner, and show how the implementation in <ref> [Devanbu & Litman, 1991] </ref> can be reproduced in our framework. 2 DL Reasoners In addition to defining classes of individuals, descriptions can be used for a number of purposes, such as abstracting commonalities of other sets of descriptions, providing "descriptive" answers rather than just enumerations of values, and ascribing incomplete information <p> Three attributes, ini 6 This function is potentially useful for many other purposes in a DL reasoner [Cohen et al, 1992]. tial, goal and steps, record this information. Steps however are not regular object individuals | they are sequences of action objects called scenarios in <ref> [Devanbu & Litman, 1991] </ref>, and these are a key contribution of clasp. Since scenarios are no longer regular objects a la DL 0 they are sequences we must extend the language at the top level to deal with them: &lt;Description&gt;::=&lt;Scenario-Desc&gt;, rather than &lt;Obj-Desc&gt;::=&lt;Scenario-Desc&gt;. <p> <ref> [Devanbu & Litman, 1991] </ref>, and these are a key contribution of clasp. Since scenarios are no longer regular objects a la DL 0 they are sequences we must extend the language at the top level to deal with them: &lt;Description&gt;::=&lt;Scenario-Desc&gt;, rather than &lt;Obj-Desc&gt;::=&lt;Scenario-Desc&gt;. Classes of scenarios (called "plan expressions" in [Devanbu & Litman, 1991]) are described using a regular expression-like notation, which we represent as follows: &lt;Scenario-Desc&gt; ::= single (&lt;Act-Desc&gt;) j seq (&lt;Scenario-Desc&gt;,&lt;Scenario-Desc&gt;) j altern (&lt;Scenario-Desc&gt;,&lt;Scenario-Desc&gt;) j loop (&lt;Scenario-Desc&gt;) The constructor single takes as argument a single action description and denotes the set of action individuals that are its instances 7 <p> others, this can lead to discovering incoherent plans, as in the case of a sequence of actions where the start state of the second action is inconsistent with the end state of the first action. (We remark that this aspect of the semantics of action sequences was not considered in <ref> [Devanbu & Litman, 1991] </ref>.) 4.1 Implementing plan expressions In contrast to act, the implementation of plan expression descriptions is much more complicated, due to the fact that there is no known normal form for regular expressions. <p> we augment the abstract syntax of the language with another constructor, top-plan-exp, which dominates the topmost plan expression constructor, and we put all the work in the implementation of top-plan-exp: Normalize TOPEXP uses the above Normalize functions to create the non-deterministic finite automaton, and then exactly the algorithm described in <ref> [Devanbu & Litman, 1991] </ref> is used to make it "deterministic". <p> Inconsistent TOPEXP eliminates arcs with inconsistent actions on them. If as a result no final state is reachable, the plan expression is inconsistent. SubsumesSame TOPEXP behaves as in <ref> [Devanbu & Litman, 1991] </ref>: it computes the intersection automaton and checks for the absence of (Nonfinal,Final) states. ConjoinToSame TOPEXP, which was also absent in [Devanbu & Litman, 1991], just builds the intersection deterministic finite automaton. SubsumesDifferent TOPEXP, ConjoinToDiffer-ent TOPEXP and FindOtherImplications TOPEXP are all left empty. <p> If as a result no final state is reachable, the plan expression is inconsistent. SubsumesSame TOPEXP behaves as in <ref> [Devanbu & Litman, 1991] </ref>: it computes the intersection automaton and checks for the absence of (Nonfinal,Final) states. ConjoinToSame TOPEXP, which was also absent in [Devanbu & Litman, 1991], just builds the intersection deterministic finite automaton. SubsumesDifferent TOPEXP, ConjoinToDiffer-ent TOPEXP and FindOtherImplications TOPEXP are all left empty. This completes the implementation of plan expression reasoning for subsumption. <p> Note again that the implementation of plan expression reasoning presented here is not novel: except for some additional inconsistency checking, it is taken from <ref> [Devanbu & Litman, 1991] </ref>; nor was it made any easier by the use of protodl. <p> new constructor could be implemented with this new semantics, while the semantics of subsumption for all in DL 0 could not be altered just for the role delete A second advantage of extending the language, rather than building a new system on top of an existing DL-reasoner as done in <ref> [Devanbu & Litman, 1991, Heinsohn 1992, Weida & Litman, 1992] </ref>, is that the resulting system is "orthogonal": the new kinds of descriptions can be combined with the old ones, as role restrictions for example. (2) Natural semantics specifications. <p> We emphasize that our extension performs the same efficient, custom-made actions (ignoring the "improvements" we made | see below) as originally proposed in <ref> [Devanbu & Litman, 1991] </ref>: there is no meta-interpreter to slow things down, and we are in fact not paying any measurable additional run-time price for having used protodl. Note also that this was achieved by the simple addition of two abstract syntax constructors, for single and top-plan-exp.
Reference: [Devanbu et al, 1991] <author> Devanbu, P., Brachman, R. J., Ballard, B. W., and P.G. Selfridge, </author> <note> "LaSSIE: </note>
Reference-contexts: In some sense this is an independent test of the proposed approach, applied to a practically significant system: clasp was used in a Software Information System <ref> [Devanbu et al, 1991] </ref>. By being able to reconstruct the actual implementation of clasp, we provide evidence for claim (3), and by finding lacunae and alternatives not considered in the original paper on clasp, we give additional credence to claims (1),(2), and (4).
References-found: 10

