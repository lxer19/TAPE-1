URL: http://www.cs.wisc.edu/wpis/papers/tr1315.ps
Refering-URL: http://www.cs.wisc.edu/wpis/papers/
Root-URL: 
Email: siff@cs.wisc.edu  reps@cs.wisc.edu  
Title: Program Generalization for Software Reuse: From C to C++  
Author: Michael Siff Thomas Reps 
Address: 1210 West Dayton Street Madison, WI 53706  
Affiliation: University of Wisconsin-Madison  
Abstract: We consider the problem of software generalization: Given a program component C, create a parameterized program component C 0 such that C 0 is usable in a wider variety of syntactic contexts than C. Furthermore, C 0 should be a semantically meaningful generalization of C; namely, there must exist an instantiation of C 0 that is equivalent in functionality to C. In this paper, we present an algorithm that generalizes C functions via type inference. The original functions operate on specific data types; the result of generalization is a collection of C++ function templates that operate on parameterized types. This version of the generalization problem is useful in the context of converting existing C programs to C++.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Caldiera and V. R. Basili. </author> <title> Identifying and analyzing reusable software components. </title> <journal> IEEE Comp., </journal> <volume> 24 </volume> <pages> 61-70, </pages> <year> 1991. </year>
Reference-contexts: use of global variables. * Functions that modify the elements of structures generalize nicely. * Over-generalization does not seem to be a big problem. 7 Related Work Although much has been written about the problem of software reuse (for example, see [17, 8, 13]), including work on identifying reusable components <ref> [3, 1] </ref>, we are unaware of previous work on the problem of automatically creating polymorphic functions from monomorphic functions. Our work may be contrasted with what is provided by the NORA system, which also makes use of type inference to support polymorphic components [4].
Reference: [2] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, </title> <journal> and polymor-phism. Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: We adopt the standard notion of subtype between C structures (based on the presentation of record subtyping in <ref> [2] </ref>): The subtype relation is the trivial relation (i.e., t is a subtype of t 0 if and only if t and t 0 are the same type) for all types except structures; 3 a structure type s is a subtype of another structure type s 0 if, for every field
Reference: [3] <author> A. Cimitile and G. Visaggio. </author> <title> Software salvaging and the call dominance tree. </title> <journal> J. Systems Software, </journal> <volume> 28 </volume> <pages> 117-127, </pages> <year> 1995. </year> <month> 20 </month>
Reference-contexts: use of global variables. * Functions that modify the elements of structures generalize nicely. * Over-generalization does not seem to be a big problem. 7 Related Work Although much has been written about the problem of software reuse (for example, see [17, 8, 13]), including work on identifying reusable components <ref> [3, 1] </ref>, we are unaware of previous work on the problem of automatically creating polymorphic functions from monomorphic functions. Our work may be contrasted with what is provided by the NORA system, which also makes use of type inference to support polymorphic components [4].
Reference: [4] <author> F.-J. Grosch and G. Snelting. </author> <title> Polymorphic components for monomorphic languages. </title> <editor> In R. Prieto-Diaz and W.B. Frakes, editors, </editor> <booktitle> Advances in software reuse: Selected papers from the Second International Workshop on Software Reusability, </booktitle> <pages> pages 47-55, </pages> <address> Lucca, Italy, March 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Our work may be contrasted with what is provided by the NORA system, which also makes use of type inference to support polymorphic components <ref> [4] </ref>. The paradigm in NORA is to extend a base language (e.g., C, Pascal, Modula-2) with a more powerful type system that permits fragments to be given types and units containing unbound names to be given types. <p> A generalizer could be used to create code to be placed into libraries and the signature matcher could be used to retrieve generalized code. The idea of mixing polymorphism with C appears in several places, among them <ref> [4, 14, 11] </ref>. [14] concerns a new dialect of C that is polymorphic and type safe.
Reference: [5] <author> R. Hindley. </author> <title> The principal type-scheme of an object in combinatory logic. </title> <journal> Trans. AMS, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <year> 1969. </year>
Reference-contexts: issues that have been examined in previous studies of type inference, there are various details that concern the application of type inference to the problem of program generalization. (Some related issues, concerning differences between our approach to type inference and the ways in which type inference has been traditionally formulated <ref> [5, 9, 10] </ref>, are discussed in Section 3.) 4 2.1 Parametric Polymorphism Via Operator Overloading Parametric polymorphism captures certain kinds of commonalities among similar operations on different types. This is a powerful mechanism for code-oriented software reuse. <p> Ordinarily, type inference is treated as a problem of showing that type annotations are completely superfluous. Specifically, many type-inference problems can be cast in the following framework, in which a typed language is related to an untyped language <ref> [5, 9, 10] </ref>: Suppose L is a typed language, L 0 is a related untyped language, and "erasure" function Erase : L ! L 0 removes type annotations from terms of L.
Reference: [6] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Member functions would remain essentially the same, except for the types of arguments, local variables, and return values, which would also be determined by type inference. The potential for combining program-generalization operations with other program-transformation operations, such as program slicing <ref> [16, 12, 6] </ref>, has not escaped our attention. In the scenario we envision, program slicing and generalization would be used in concert to "mine" existing C software for useful components.
Reference: [7] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> second edition, </address> <year> 1988. </year>
Reference-contexts: The Valid-Code Assumption also allows us to ignore issues about implicit type conversions and promotions that can occur among arithmetic types <ref> [7, pages 197-202] </ref>. For this reason, the type system uses a single symbol, , to represent monomorphic types. (Most other type-inference systems have collection of different monomorphic types, e.g., int, float, int ! float, etc.) Type is the one "base type" of the type system. <p> These measures all help to prevent the creation of overly general templates. However, it is still possible for over-generalization to occur. For instance, consider the version of the power function shown in Figure 7 <ref> [7, page 25] </ref>. This version is equivalent to the function given in Figure 1, but has a second local variable, i, which is used as the iteration variable in the loop.
Reference: [8] <author> Hafedh Mili, Fatma Mili, and Ali Mili. </author> <title> Reusing software: Issues and research directions. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(6), </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: that produced the least generalization tended to make heavy use of global variables. * Functions that modify the elements of structures generalize nicely. * Over-generalization does not seem to be a big problem. 7 Related Work Although much has been written about the problem of software reuse (for example, see <ref> [17, 8, 13] </ref>), including work on identifying reusable components [3, 1], we are unaware of previous work on the problem of automatically creating polymorphic functions from monomorphic functions.
Reference: [9] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: issues that have been examined in previous studies of type inference, there are various details that concern the application of type inference to the problem of program generalization. (Some related issues, concerning differences between our approach to type inference and the ways in which type inference has been traditionally formulated <ref> [5, 9, 10] </ref>, are discussed in Section 3.) 4 2.1 Parametric Polymorphism Via Operator Overloading Parametric polymorphism captures certain kinds of commonalities among similar operations on different types. This is a powerful mechanism for code-oriented software reuse. <p> The type system treats the standard C operators as operators with polymorphic types. In this case, &lt; has type 8ff:ff fi ff ! . 2 At each occurrence of a standard operator, the generic type is instantiated in the usual way <ref> [9] </ref>; that is, the quantifiers are stripped off, and the body of the type is instantiated with fresh type variables different from all other type variables used elsewhere. Unification of type expressions allows the system to deduce how certain types are related to other types. <p> Ordinarily, type inference is treated as a problem of showing that type annotations are completely superfluous. Specifically, many type-inference problems can be cast in the following framework, in which a typed language is related to an untyped language <ref> [5, 9, 10] </ref>: Suppose L is a typed language, L 0 is a related untyped language, and "erasure" function Erase : L ! L 0 removes type annotations from terms of L.
Reference: [10] <author> John C. Mitchell. </author> <title> Type systems for programming languages. </title> <booktitle> In Handbook of Theoretical Computer Science, </booktitle> <volume> Volume B, </volume> <pages> pages 365-458. </pages> <publisher> The M.I.T. </publisher> <address> Press/Elsevier, </address> <year> 1990. </year>
Reference-contexts: issues that have been examined in previous studies of type inference, there are various details that concern the application of type inference to the problem of program generalization. (Some related issues, concerning differences between our approach to type inference and the ways in which type inference has been traditionally formulated <ref> [5, 9, 10] </ref>, are discussed in Section 3.) 4 2.1 Parametric Polymorphism Via Operator Overloading Parametric polymorphism captures certain kinds of commonalities among similar operations on different types. This is a powerful mechanism for code-oriented software reuse. <p> Ordinarily, type inference is treated as a problem of showing that type annotations are completely superfluous. Specifically, many type-inference problems can be cast in the following framework, in which a typed language is related to an untyped language <ref> [5, 9, 10] </ref>: Suppose L is a typed language, L 0 is a related untyped language, and "erasure" function Erase : L ! L 0 removes type annotations from terms of L.
Reference: [11] <author> Robert O'Callahan and Daniel Jackson. </author> <title> Detecting shared representations using type inference. </title> <type> Technical Report CMU-CS-95-202, </type> <institution> Carnegie Mellon University, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: A generalizer could be used to create code to be placed into libraries and the signature matcher could be used to retrieve generalized code. The idea of mixing polymorphism with C appears in several places, among them <ref> [4, 14, 11] </ref>. [14] concerns a new dialect of C that is polymorphic and type safe. <p> The idea of mixing polymorphism with C appears in several places, among them [4, 14, 11]. [14] concerns a new dialect of C that is polymorphic and type safe. This differs from our approach in that it is not aimed at adding polymorphism to existing code. <ref> [11] </ref> uses polymorphic type inference 19 on existing C programs, but for determining information about the transfer of values, as opposed to producing reusable code. 8 Conclusions and Future Work This paper has discussed the problem of C function generalization and given an algorithm that provides a way to transform one
Reference: [12] <author> K.J. Ottenstein and L.M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <year> 1984. </year>
Reference-contexts: Member functions would remain essentially the same, except for the types of arguments, local variables, and return values, which would also be determined by type inference. The potential for combining program-generalization operations with other program-transformation operations, such as program slicing <ref> [16, 12, 6] </ref>, has not escaped our attention. In the scenario we envision, program slicing and generalization would be used in concert to "mine" existing C software for useful components.
Reference: [13] <editor> Ruben Prieto-D iaz and William B. Frakes, editors. </editor> <booktitle> Advances in Software Reuse. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> March </month> <year> 1993. </year>
Reference-contexts: that produced the least generalization tended to make heavy use of global variables. * Functions that modify the elements of structures generalize nicely. * Over-generalization does not seem to be a big problem. 7 Related Work Although much has been written about the problem of software reuse (for example, see <ref> [17, 8, 13] </ref>), including work on identifying reusable components [3, 1], we are unaware of previous work on the problem of automatically creating polymorphic functions from monomorphic functions.
Reference: [14] <author> Geoffrey Smith and Dennis Volpano. </author> <title> Towards an ML-style polymorphic type system for C. </title> <booktitle> In 1996 European Symposium on Programming, </booktitle> <month> April </month> <year> 1996. </year> <note> to appear. </note>
Reference-contexts: A generalizer could be used to create code to be placed into libraries and the signature matcher could be used to retrieve generalized code. The idea of mixing polymorphism with C appears in several places, among them <ref> [4, 14, 11] </ref>. [14] concerns a new dialect of C that is polymorphic and type safe. <p> A generalizer could be used to create code to be placed into libraries and the signature matcher could be used to retrieve generalized code. The idea of mixing polymorphism with C appears in several places, among them [4, 14, 11]. <ref> [14] </ref> concerns a new dialect of C that is polymorphic and type safe.
Reference: [15] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: In particular, C++ function templates are subject to the following restriction: Each template argument must affect the type of at least one of the function argu ments <ref> [15, page 280] </ref>. Nor does C++ offer any way of expressing "the type of the i field in class T". <p> The topic of generalizing programs to create class templates is beyond the scope of this paper; however, the following example, adapted from <ref> [15, pages 256-257] </ref>, demonstrates how the generalization paradigm could be used to transform C++ classes into class templates: A class representing a bounded stack of integers is defined in Figure 5. (For simplicity, the stack ignores such issues as underflow and overflow.) class stack f private: int *sp; public: stack (int <p> For example, a function template containing a cast (int)e can only be called with arguments that have an int conversion, either predefined, as one has for arithmetic and pointer types, or explicitly defined (see <ref> [15, page 232] </ref>).
Reference: [16] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: Member functions would remain essentially the same, except for the types of arguments, local variables, and return values, which would also be determined by type inference. The potential for combining program-generalization operations with other program-transformation operations, such as program slicing <ref> [16, 12, 6] </ref>, has not escaped our attention. In the scenario we envision, program slicing and generalization would be used in concert to "mine" existing C software for useful components.
Reference: [17] <author> Mansour Zand and Mansur Samadzadeh. </author> <title> Special issue on software reuse. </title> <journal> J. Systems Software, </journal> <volume> 30(3), </volume> <month> September </month> <year> 1995. </year>
Reference-contexts: that produced the least generalization tended to make heavy use of global variables. * Functions that modify the elements of structures generalize nicely. * Over-generalization does not seem to be a big problem. 7 Related Work Although much has been written about the problem of software reuse (for example, see <ref> [17, 8, 13] </ref>), including work on identifying reusable components [3, 1], we are unaware of previous work on the problem of automatically creating polymorphic functions from monomorphic functions.
Reference: [18] <author> Amy Moorman Zaremski and Jeannette M. Wing. </author> <title> Signature matching: a tool for using software libraries. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> April </month> <year> 1995. </year> <month> 21 </month>
Reference-contexts: In other words, whereas NORA supports the use of polymorphic components, our goal is to provide support for extracting such components from existing code. Our work may also be contrasted with the signature matching tool described in <ref> [18] </ref>. While that work also employs type inference to facilitate software reuse, it does so by assisting the user in finding suitable code from software libraries rather than automatically producing generalized code. A signature matching tool might work nicely in conjunction with the work described in this paper.
References-found: 18

