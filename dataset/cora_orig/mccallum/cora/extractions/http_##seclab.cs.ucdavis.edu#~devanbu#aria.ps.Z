URL: http://seclab.cs.ucdavis.edu/~devanbu/aria.ps.Z
Refering-URL: http://seclab.cs.ucdavis.edu/~devanbu/prem_papers.html
Root-URL: http://www.cs.ucdavis.edu
Email: fprem,dsrg@research.att.com alw@cs.colorado.edu  
Title: Automated Construction of Testing and Analysis Tools Research Paper  
Author: Premkumar T. Devanbu David S. Rosenblum Alexander L. Wolf 
Address: Murray Hill, NJ 07974 USA Boulder, CO 80309 USA  
Affiliation: Software and Systems Research Laboratory Department of Computer Science AT&T Bell Laboratories University of Colorado  
Abstract: Many software testing and analysis tools manipulate graph representations of programs, such as abstract syntax trees or abstract semantics graphs. Hand-crafting such tools in conventional programming languages can be difficult, error prone, and time consuming. Our approach is to use application generators targeted for the domain of graph-representation-based testing and analysis tools. Moreover, we generate the generators themselves, so that the development of tools based on different languages and/or representations can also be supported better. In this paper we report on our experiences in developing a system called Aria that generates testing and analysis tools based on an abstract semantics graph representation for C and C ++ called Reprise. Aria itself was generated by the Genoa system. We demonstrate the utility of Aria and, thereby, the power of our approach, by showing Aria's use in the development of a tool that derives control dependence graphs directly from Reprise abstract semantics graphs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R.A. Ballance, S.L. Graham, and M.L. Van De Van-ter. </author> <title> The Pan Language-Based Editing System For Integrated Development Environments. </title> <booktitle> In SIGSOFT '90: Proceedings of the Fourth Symposium on Software Development Environments, </booktitle> <pages> pages 77-93. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> December </month> <year> 1990. </year>
Reference-contexts: Typically, they also derive more specialized structures, such as control flow graphs, from the basic graph representations. While builders of compilers, interpreters, editors, and the like have numerous construction aids available to them (e.g., Gandalf [6], the Cornell Synthesizer Generator [10], Centaur [2], Refine [9], Pan <ref> [1] </ref>, and Eli [5]), the same cannot be said for builders of testing and analysis tools. Typically, testing and analysis tools are individually hand-crafted in a conventional programming language such as Ada, C, or Lisp and can require thousands of lines of code. <p> In contrast with Aria, previous application generators have been built around a monolithic architecture in which the front-end processing component and the tool-generation component are custom-designed from scratch and supplied as an integrated package (e.g., Gandalf [6], Centaur [2], Refine [9] and Pan <ref> [1] </ref>). A detailed discussion of this issue can be found in the previous paper on Genoa [3]. As was predicted in the initial work on Genoa, the loosely-coupled architecture of Aria saved us a great deal of work by allowing us to reuse an existing front-end processing component (namely Reprise).
Reference: [2] <author> P. Borras, D. Clement, T. Despeyroux, J. Incerpi, G. Kahn, B. Lang, and V. Pascual. </author> <title> Centaur: The System. </title> <booktitle> In SIGSOFT '88: Proceedings of the Third Symposium on Software Development Environments, </booktitle> <pages> pages 14-24. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> November </month> <year> 1988. </year>
Reference-contexts: Typically, they also derive more specialized structures, such as control flow graphs, from the basic graph representations. While builders of compilers, interpreters, editors, and the like have numerous construction aids available to them (e.g., Gandalf [6], the Cornell Synthesizer Generator [10], Centaur <ref> [2] </ref>, Refine [9], Pan [1], and Eli [5]), the same cannot be said for builders of testing and analysis tools. Typically, testing and analysis tools are individually hand-crafted in a conventional programming language such as Ada, C, or Lisp and can require thousands of lines of code. <p> In contrast with Aria, previous application generators have been built around a monolithic architecture in which the front-end processing component and the tool-generation component are custom-designed from scratch and supplied as an integrated package (e.g., Gandalf [6], Centaur <ref> [2] </ref>, Refine [9] and Pan [1]). A detailed discussion of this issue can be found in the previous paper on Genoa [3].
Reference: [3] <author> P.T. Devanbu. </author> <title> GENOA|A Customizable, Language- and Front-end-independent Code Analyzer. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <pages> pages 307-317. </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1992. </year>
Reference-contexts: We developed Aria by wedding a generic, language-independent tool generator, called Genoa, to a specific program representation, called Reprise. Genoa and Reprise were developed independently and each has been described and compared to related work in previous papers <ref> [3, 12] </ref>. Reprise provides a powerful and convenient ASG representation for C and C ++ programs, but its use as the basis for testing and analysis tools was hindered by the lack of good tool construction aids. <p> A detailed discussion of this issue can be found in the previous paper on Genoa <ref> [3] </ref>. As was predicted in the initial work on Genoa, the loosely-coupled architecture of Aria saved us a great deal of work by allowing us to reuse an existing front-end processing component (namely Reprise).
Reference: [4] <author> J. Ferrante, K.J. Ottenstein, and J.D. Warren. </author> <title> The Program Dependence Graph and its Use in Optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: Tosca produces a control dependence graph (CDG) of a program. A CDG is commonly used as one of the two main components of a well-known graph-based formalism called a program dependence graph (PDG) <ref> [4] </ref>. 3 PDGs have been used primarily for program optimization and parallelization. For instance, parallelizing FORTRAN compilers use PDGs to analyze dependencies among iterations of a loop in order to schedule the loop iterations for correct parallel execution. <p> Traditionally, a CDG is constructed by first deriving a control flow graph (CFG) from an AST or ASG and then performing various transitive-closure and state-maintenance operations to derive the CDG. This two-step implementation strategy directly follows from the standard CFG-based definition of CDGs <ref> [4] </ref>. In our formulation for Tosca, the CDG is derived directly from the Reprise ASG, eliminating the need for the CFG. <p> Our initial version of Tosca handles unstructured programs containing if- and while-statements that have within them arbitrarily nested break, continue, and return statements. We also make the standard assumption <ref> [4] </ref> that the program being analyzed does not contain unreachable statements. depiction of the CDG that Tosca constructs from this input. The numbers on the nodes are statement line numbers from the program text, and the edges indicate direct control dependencies.
Reference: [5] <author> R.W. Gray, V.P. Heuring, S.P. Levi, A.M. Sloane, and W.M. Waite. Eli: </author> <title> A Complete, Flexible Compiler Construction System. </title> <journal> Communications of the ACM, </journal> <volume> 35(2) </volume> <pages> 121-131, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: Typically, they also derive more specialized structures, such as control flow graphs, from the basic graph representations. While builders of compilers, interpreters, editors, and the like have numerous construction aids available to them (e.g., Gandalf [6], the Cornell Synthesizer Generator [10], Centaur [2], Refine [9], Pan [1], and Eli <ref> [5] </ref>), the same cannot be said for builders of testing and analysis tools. Typically, testing and analysis tools are individually hand-crafted in a conventional programming language such as Ada, C, or Lisp and can require thousands of lines of code.
Reference: [6] <author> N. Habermann and D. Notkin. </author> <title> Gandalf: Software Development Environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(12):1117-1127, </volume> <month> Decem-ber </month> <year> 1986. </year>
Reference-contexts: Typically, they also derive more specialized structures, such as control flow graphs, from the basic graph representations. While builders of compilers, interpreters, editors, and the like have numerous construction aids available to them (e.g., Gandalf <ref> [6] </ref>, the Cornell Synthesizer Generator [10], Centaur [2], Refine [9], Pan [1], and Eli [5]), the same cannot be said for builders of testing and analysis tools. <p> In contrast with Aria, previous application generators have been built around a monolithic architecture in which the front-end processing component and the tool-generation component are custom-designed from scratch and supplied as an integrated package (e.g., Gandalf <ref> [6] </ref>, Centaur [2], Refine [9] and Pan [1]). A detailed discussion of this issue can be found in the previous paper on Genoa [3].
Reference: [7] <author> M.J. Harrold, B. Malloy, and G. Rothermel. </author> <title> Efficient Construction of Program Dependence Graphs. </title> <booktitle> In Proceedings of the 1993 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 160-170. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: CDGs, both by themselves and as part of PDGs, have also been used in a variety of ways in testing and analysis. For examples, see Podgurski and Clarke [8], Harrold et al. <ref> [7] </ref>, and the citations contained therein. Constructing CDGs for arbitrary programs is a complex task; implementations of CDG tools can run 3 The other main component of a PDG is the data dependence graph. into several thousand lines of code.
Reference: [8] <author> A. Podgurski and L.A. Clarke. </author> <title> A Formal Model of Program Dependencies and its Implications for Software Testing, Debugging, and Maintenance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 965-979, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: CDGs, both by themselves and as part of PDGs, have also been used in a variety of ways in testing and analysis. For examples, see Podgurski and Clarke <ref> [8] </ref>, Harrold et al. [7], and the citations contained therein. Constructing CDGs for arbitrary programs is a complex task; implementations of CDG tools can run 3 The other main component of a PDG is the data dependence graph. into several thousand lines of code.
Reference: [9] <institution> The Reasoning Systems Corporation, Palo Alto, Cal-ifornia. </institution> <note> Refine Users Manual. </note>
Reference-contexts: Typically, they also derive more specialized structures, such as control flow graphs, from the basic graph representations. While builders of compilers, interpreters, editors, and the like have numerous construction aids available to them (e.g., Gandalf [6], the Cornell Synthesizer Generator [10], Centaur [2], Refine <ref> [9] </ref>, Pan [1], and Eli [5]), the same cannot be said for builders of testing and analysis tools. Typically, testing and analysis tools are individually hand-crafted in a conventional programming language such as Ada, C, or Lisp and can require thousands of lines of code. <p> In contrast with Aria, previous application generators have been built around a monolithic architecture in which the front-end processing component and the tool-generation component are custom-designed from scratch and supplied as an integrated package (e.g., Gandalf [6], Centaur [2], Refine <ref> [9] </ref> and Pan [1]). A detailed discussion of this issue can be found in the previous paper on Genoa [3].
Reference: [10] <author> T. Reps and T. Teitelbaum. </author> <title> The Synthesizer Generator. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 42-48. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> April </month> <year> 1984. </year>
Reference-contexts: Typically, they also derive more specialized structures, such as control flow graphs, from the basic graph representations. While builders of compilers, interpreters, editors, and the like have numerous construction aids available to them (e.g., Gandalf [6], the Cornell Synthesizer Generator <ref> [10] </ref>, Centaur [2], Refine [9], Pan [1], and Eli [5]), the same cannot be said for builders of testing and analysis tools. Typically, testing and analysis tools are individually hand-crafted in a conventional programming language such as Ada, C, or Lisp and can require thousands of lines of code.
Reference: [11] <author> D.J. Richardson, </author> <title> T.O. O'Malley, C.T. Moore, and S.L. Aha. Developing and Integrating ProDAG in the Arcadia Environment. </title> <booktitle> In SIGSOFT '92: Proceedings of the Fifth Symposium on Software Development Environments, </booktitle> <pages> pages 109-119. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> Decem-ber </month> <year> 1992. </year>
Reference-contexts: In addition, we believe that Aria's terse traversal operations compare favorably with the more complex pattern- and rule-based language of Refine and with the Pascal-like language of Gandalf. The approach most similar to ours is found in the ProDAG Toolset <ref> [11] </ref>. ProDAG provides its users with extensive facilities for deriving arbitrary kinds of dependence graphs from a common program representation. These include a generic program representation data structure and a control flow graph generator.
Reference: [12] <author> D.S. Rosenblum and A.L. Wolf. </author> <title> Representing Semantically Analyzed C++ Code with Reprise. </title> <booktitle> In Proceedings of the Third C++ Technical Conference, </booktitle> <pages> pages 119-134. </pages> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1991. </year>
Reference-contexts: We developed Aria by wedding a generic, language-independent tool generator, called Genoa, to a specific program representation, called Reprise. Genoa and Reprise were developed independently and each has been described and compared to related work in previous papers <ref> [3, 12] </ref>. Reprise provides a powerful and convenient ASG representation for C and C ++ programs, but its use as the basis for testing and analysis tools was hindered by the lack of good tool construction aids. <p> Builders of testing and analysis tools|that is, the users of Aria|need to understand the Reprise ASG in order to specify manipulations of the program representation. For purposes of this paper, we give only a brief overview of the representation; details of Reprise can be found elsewhere <ref> [12] </ref>. The conceptual model underlying Reprise is that of strongly-typed expressions, where all semantic information is uniformly represented as the application of operators to arguments.
References-found: 12

