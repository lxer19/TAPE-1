URL: http://www.cs.uoregon.edu/paracomp/proj/ariadne/papers/icpp95/icpp95.ps.gz
Refering-URL: http://www.cs.uoregon.edu/paracomp/proj/ariadne/publications.html
Root-URL: http://www.cs.uoregon.edu
Title: The Integration of Event- and State-Based Debugging in Ariadne  
Author: Joydip Kundu Janice E. Cuny 
Address: Amherst, MA 01003 Eugene, OR 97403  
Affiliation: Department of Computer Science Department of Computer Science University of Massachusetts University of Oregon  
Abstract: Parallel programs often have complex behaviors that require multi-level debugging strategies. Here, we propose an integration of event- and state-based strategies that initially uses event-based behavioral modeling to narrow the focus of attention and then uses state-based techniques to relate observed errors to specific code segments. Our debugger supports this strategy, allowing the results of behavioral analysis to be used in specifying consistent, global breakpoints. These breakpoints differ from those provided by other debuggers in that they are meaningful in the context of the ongoing event-based analysis. In addition, the breakpoints that users select with our debugger would be difficult to set using existing state-based approaches. We demonstrate here that the combination of event- and state-based debugging is significantly more powerful than either strategy alone. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. C. Bates. </author> <title> Debugging Programs in a Distributed System Environment. </title> <type> PhD Thesis, </type> <institution> University of Massachusetts, </institution> <year> 1986. </year>
Reference-contexts: 1 Introduction The complex behavior of parallel programs often requires a multi-level debugging strategy. Such a strategy might, for example, employ event-based techniques <ref> [1, 3, 7, 9] </ref> at the highest level where gross patterns of process interactions are investigated. As debugging proceeds and the focus of attention narrows, the behavior of progressively smaller parts of the program could be analyzed in progressively finer detail, using a combination of event- and state-based techniques.
Reference: [2] <author> J. E. Cuny, G. Forman, A. Hough, J. Kundu, C. Lin, L. Snyder, and D. Stemple. </author> <title> The Ari-adne debugger: scalable application of event-based abstraction. </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 28, No. 12, </volume> <pages> pages 85-95, </pages> <year> 1994. </year>
Reference-contexts: A number of event- and state-based debuggers already exist. Here we discuss the integration of two - Ariadne <ref> [2] </ref> and ipd [10] into a single environment. The key to this integration is the use of user-defined abstract events in establishing consistent, global breakpoints: the states we provide are meaningful in the context of the user's ongoing event-based analysis. <p> A complete description of the modeling language is beyond the scope of this paper but can be found in other references <ref> [2] </ref>. The behavior of the originating node was more complex because it must also collect responses.
Reference: [3] <author> R. J. Fowler, T. J. Leblanc, and J. M. Mellor-Crummey. </author> <title> An integrated approach to parallel program debugging and performance analysis on large-scale multiprocessors. </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 163-173, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction The complex behavior of parallel programs often requires a multi-level debugging strategy. Such a strategy might, for example, employ event-based techniques <ref> [1, 3, 7, 9] </ref> at the highest level where gross patterns of process interactions are investigated. As debugging proceeds and the focus of attention narrows, the behavior of progressively smaller parts of the program could be analyzed in progressively finer detail, using a combination of event- and state-based techniques.
Reference: [4] <author> A. P. Goldberg, A. Gopal, A, Lowry, and R. Strom. </author> <title> Restoring consistent global states of distributed computations. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 144-154, </pages> <year> 1991. </year>
Reference-contexts: In some cases, this procedure results in a state that is not consistent, that is, a state that could not have occurred in an actual execution. We define consistency as in <ref> [4] </ref>.
Reference: [5] <author> M. Greenberg and J. Cuny. </author> <title> Parallelism in knowledge-based systems with inheritance. </title> <booktitle> In Proceedings of the 1988 International Conference on Parallel Processing, </booktitle> <pages> pages 141-145, </pages> <year> 1988. </year>
Reference-contexts: user's breakpointing request would result in an inconsistent state, our debugger automatically constructs an earlier, consistent state using a greedy algorithm. 3 Tracking Elusive States with Event Based Breakpointing In this section, we demonstrate the use of our integrated debugging environment on a parallel program for querying a knowledge base <ref> [5] </ref>. The knowledge is stored hierarchically as objects and classes of objects related by the is-a relation. To avoid redundancy, object attributes are stored as high as possible in the hierarchy and are then inherited at the lower levels.
Reference: [6] <author> D. Haban, and W. Weigel. </author> <title> Global events and global breakpoints in distributed systems. </title> <booktitle> 21st Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 166-174, </pages> <year> 1988. </year>
Reference-contexts: Alternatively, local breakpoints can be extended dynamically to global breakpoints <ref> [6, 16, 18] </ref>. Unfortunately, debuggers that support this typically allow processes not directly involved in the breakpoint to continue executing for some time, potentially obliterating information 1 relevant to the source of the error.
Reference: [7] <author> A. A. Hough. </author> <title> Debugging Parallel Programs Using Abstract Visualizations. </title> <type> PhD Thesis, </type> <institution> University of Massachusetts, </institution> <year> 1991. </year>
Reference-contexts: 1 Introduction The complex behavior of parallel programs often requires a multi-level debugging strategy. Such a strategy might, for example, employ event-based techniques <ref> [1, 3, 7, 9] </ref> at the highest level where gross patterns of process interactions are investigated. As debugging proceeds and the focus of attention narrows, the behavior of progressively smaller parts of the program could be analyzed in progressively finer detail, using a combination of event- and state-based techniques.
Reference: [8] <author> A. A. Hough and J. E. Cuny. </author> <title> Perspective views: A technique for enchancing visualizations of parallel programs. </title> <booktitle> In 1990 International Conference on Parallel Processing, </booktitle> <pages> pages II 124-132, </pages> <year> 1990. </year>
Reference-contexts: Event-based techniques can incorporate replay mechanisms that support reproducible execution [13] and logical time transformations to filter out perturbations due to asynchrony <ref> [8, 12] </ref>. State-based techniques, on the other hand, allow the user to directly examine an execution to an arbitrary level of detail and often make it easier to relate errors to source code constructs. A number of event- and state-based debuggers already exist.
Reference: [9] <author> W. Hseush and G. E. Kaiser. </author> <title> Modeling concur-rency in parallel debugging. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 11-20, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction The complex behavior of parallel programs often requires a multi-level debugging strategy. Such a strategy might, for example, employ event-based techniques <ref> [1, 3, 7, 9] </ref> at the highest level where gross patterns of process interactions are investigated. As debugging proceeds and the focus of attention narrows, the behavior of progressively smaller parts of the program could be analyzed in progressively finer detail, using a combination of event- and state-based techniques.
Reference: [10] <author> Intel Supercomputer Systems Division. </author> <title> Paragon Interactive Parallel Debugger Reference Manual. Paragon Documentation, </title> <year> 1994. </year>
Reference-contexts: A number of event- and state-based debuggers already exist. Here we discuss the integration of two - Ariadne [2] and ipd <ref> [10] </ref> into a single environment. The key to this integration is the use of user-defined abstract events in establishing consistent, global breakpoints: the states we provide are meaningful in the context of the user's ongoing event-based analysis.
Reference: [11] <author> J. Kundu and J. E. Cuny. </author> <title> A scalable, visual interface for debugging with event-based behavioral abstraction. </title> <booktitle> In Proceedings of New Frontiers on Massively Parallel Processing, </booktitle> <pages> pages 472-479, </pages> <year> 1995. </year>
Reference-contexts: Again, the complete description of this figure is be yond the scope of this paper <ref> [11] </ref>. match in knowledge-base example. This first step in debugging did not show any obvious error in query handling. It is possible that the interprocess communication patterns were, in fact, correct, but it is also possible that our model was too coarse to detect the error. <p> To rule out the latter, we examined the matched behavior more thoroughly using Ariadne's query facility which provides a spreadsheet-like interface for computing incremental attributes of a match tree <ref> [11] </ref>. With a few simple queries, we were able to ascertain the following: 1. The number of found messages received by the originating node was one more than the number of ignore messages received. (Thus, it appeared that a valid attribute value was found but some how discarded.) 2.
Reference: [12] <author> R. J. LeBlanc and A. D. Robbins. </author> <title> Event-driven monitoring of distributed programs. </title> <booktitle> In Proceedings of the 5th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 515-522, </pages> <year> 1985. </year>
Reference-contexts: Event-based techniques can incorporate replay mechanisms that support reproducible execution [13] and logical time transformations to filter out perturbations due to asynchrony <ref> [8, 12] </ref>. State-based techniques, on the other hand, allow the user to directly examine an execution to an arbitrary level of detail and often make it easier to relate errors to source code constructs. A number of event- and state-based debuggers already exist.
Reference: [13] <author> T. J. LeBlanc and J. M. Mellor-Crummey. </author> <title> Debugging parallel programs with instant replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol C-36, No. 4, </volume> <pages> pages 471-482, </pages> <year> 1987. </year>
Reference-contexts: The initial use of event-based techniques focuses the user's attention on manageable portions of the state space and (as we will see below) provides the basis for establishing consistent, meaningful, global breakpoints. Event-based techniques can incorporate replay mechanisms that support reproducible execution <ref> [13] </ref> and logical time transformations to filter out perturbations due to asynchrony [8, 12]. State-based techniques, on the other hand, allow the user to directly examine an execution to an arbitrary level of detail and often make it easier to relate errors to source code constructs.
Reference: [14] <author> T. J. LeBlanc, J. M. Mellor-Crummey, and R. J. Fowler. </author> <title> Analyzing parallel program executions using multiple views. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol 9, </volume> <pages> pages 203-217, </pages> <year> 1990. </year>
Reference: [15] <author> Y. Manabe, and M. Imase. </author> <title> Global conditions in debugging distributed programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol. 15, </volume> <pages> pages 62-69, </pages> <year> 1992. </year>
Reference-contexts: We choose instead to take advantage of replay mechanisms: we use the results of post mortem modeling to insert directives that will, during replay, halt each process at the latest point at which it could have influenced the event (s) triggering the breakpoint. Manabe and Imase <ref> [15] </ref> also use this approach, allowing breakpoints to be to specified as conjunctions and disjunctions of local predicates. It may, however, be difficult to determine the appropriate predicates: errors observable only as incorrect output are often hard to relate back to individual, local predicates in specific processes.
Reference: [16] <author> K. Mani Chandy, and L. Lamport. </author> <title> Distributed snapshots: determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol 3, No. 1, </volume> <pages> pages 63-74, </pages> <year> 1985. </year>
Reference-contexts: Alternatively, local breakpoints can be extended dynamically to global breakpoints <ref> [6, 16, 18] </ref>. Unfortunately, debuggers that support this typically allow processes not directly involved in the breakpoint to continue executing for some time, potentially obliterating information 1 relevant to the source of the error.
Reference: [17] <author> D. Brown, S. Hackstadt, A. Malony, B. Mohr. </author> <title> Program Analysis Environments for Parallel Language Systems: The TAU Environment. </title> <booktitle> Proceedings of the 2nd Workshop on Environments and Tools For Parallel Scientific Computing, </booktitle> <pages> pages 162-171, </pages> <year> 1994. </year>
Reference-contexts: are problematic: How are the breakpoints to be specified across multiple processes? Must they be globally consistent or are local break-points sufficient? If local, how and when should the remaining processes be stopped in order to provide a meaningful state? One possibility is to allow breakpoints only at barrier synchronizations <ref> [17] </ref> but this is overly constraining in multithreaded language environments. Alternatively, local breakpoints can be extended dynamically to global breakpoints [6, 16, 18]. <p> These breakpoints would be difficult or impossible to set with standard breakpoint debuggers. We are currently extending the implementation to a number of different platforms, focusing on an integration of Ariadne and the Breezy breakpoint debugger <ref> [17] </ref>. Acknowledgements George Forman, Alfred Hough, Calvin Lin, Lawrence Snyder, and David Stemple contributed to the initial design of Ariadne.
Reference: [18] <author> B. Miller, and J. -D. Choi. </author> <title> Breakpoints and halting in distributed programs. </title> <booktitle> Proceedings of 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 316-323, </pages> <year> 1988. </year>
Reference-contexts: Alternatively, local breakpoints can be extended dynamically to global breakpoints <ref> [6, 16, 18] </ref>. Unfortunately, debuggers that support this typically allow processes not directly involved in the breakpoint to continue executing for some time, potentially obliterating information 1 relevant to the source of the error.
References-found: 18

