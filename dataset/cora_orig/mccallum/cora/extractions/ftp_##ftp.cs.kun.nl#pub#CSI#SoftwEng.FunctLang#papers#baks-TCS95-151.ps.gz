URL: ftp://ftp.cs.kun.nl/pub/CSI/SoftwEng.FunctLang/papers/baks-TCS95-151.ps.gz
Refering-URL: http://www.cs.kun.nl/~clean/Clean.Papers.html
Root-URL: 
Email: steffen@cs.kun.nl  
Title: Intersection Type Assignment Systems  
Author: Steffen van Bakel 
Address: Toernooiveld 1, 6525 ED Nijmegen, Nederland.  
Affiliation: Afdeling Informatica, Universiteit Nijmegen,  
Abstract: This paper gives an overview of intersection type assignment for the Lambda Calculus, as well as compare in detail variants that have been defined in the past. It presents the essential intersection type assignment system, that will prove to be as powerful as the well-known BCD-system. It is essential in the following sense: it is an almost syntax directed system that satisfies all major properties of the BCD-system, and the types used are the representatives of equivalence classes of types in the BCD-system. The set of typeable terms can be characterized in the same way, the system is complete with respect to the simple type semantics, and it has the principal type property.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. van Bakel. </author> <title> Complete restrictions of the Intersection Type Discipline. </title> <journal> Theoretical Computer Science, </journal> <volume> 102 </volume> <pages> 135-163, </pages> <year> 1992. </year>
Reference-contexts: Current affiliation: Diparti-mento di Informatica, Universit a degli Studi di Torino, Corso Svizzera 185, 10149 Torino, Italia, bakel@di.unito.it 1 property that immediately shows that type assignment (even in the system that does not contain !, see <ref> [1] </ref>) is undecidable. Also, by introducing this extension a system is obtained that is closed under fi-equality: if B ` M : and M = fi N , then B ` N :. <p> These two features are supported by a less complicated type structure. The system presented here is also an extension of the strict type assignment system as presented in <ref> [1] </ref>. The major difference is that the essential system will prove to be closed for -reduction: If B ` E M : and M ! N , then B ` E N :. This does not hold for the strict system. <p> Subsection 1.1 presents the Coppo-Dezani system as defined in [7], Subsection 1.2 presents two Coppo-Dezani-Venneri systems as first defined in [10], Subsection 1.3 presents the Barendregt-Coppo-Dezani system that can be found in [6], and Subsection 1.4 presents the strict system of <ref> [1] </ref>. Section 2 contains the presentation of the essential type assignment system, an extension of the strict system, and a restriction of the BCD-system that will prove to be equally powerful as the BCD-system. <p> It is even possible to prove that, in this system: If B ` M :, then M is strongly normalizable (in fact, this follows from a similar result of <ref> [1] </ref>; there the BCD-system without ! is studied, which is a supersystem of the CD-system). That the system is closed under subject reduction can be illustrated by the following `Cut and Paste' proof: Suppose that B ` (x:M )N :. <p> Notice that ! is treated as a true type constant; the view of the strict intersection system presented in <ref> [1] </ref> (see Subsection 1.4) and that of the essential system presented in this paper (see Section 2) is to treat ! as the empty intersection. The changes with respect to the system of [7] are small, but important. <p> The proof of completeness is obtained in a way very similar to that of Theorem 4.3.6. The results of [6] in fact show that type assignment in the BCD-system is complete with respect to simple type semantics; this in contrast to strict type assignment (presented in <ref> [1] </ref>, see also the next subsection), that is complete with respect to the inference semantics. 1.4 The strict type assignment system The strict type assignment system as defined in [1] is a restriction of the system of [6]; it is a type assignment system in which the relation and the derivation <p> assignment in the BCD-system is complete with respect to simple type semantics; this in contrast to strict type assignment (presented in <ref> [1] </ref>, see also the next subsection), that is complete with respect to the inference semantics. 1.4 The strict type assignment system The strict type assignment system as defined in [1] is a restriction of the system of [6]; it is a type assignment system in which the relation and the derivation rule () are no longer present. The elimination of induces a set of strict types, that is actually the set of normalized tail-proper types of [10]. <p> The strict system gives rise to a strict filter -model F S , that satisfies all major properties of the filter -model F " as presented in [6], but is an essentially different -model, equivalent to Engeler's model D A [18]. In <ref> [1] </ref> was shown that soundness for the notion of type assignment of [6] is lost if instead of simple type semantics, the inference type semantics is used. <p> Take, for example, the statement x:x:(!)!("t )!: this statement is derivable in the system ` " , but it is not valid in F S . With the use of the inference type semantics, in <ref> [1] </ref> soundness and completeness for strict type assignment was proved, without having the necessity of introducing ; this was done using F S . <p> Moreover, ~ S if and only if can be obtained from by premuting components of an intersection subtype, e.g. in "!t ~ S "!t . The definition of ~ S as in <ref> [1] </ref> did not contain part 1.4.1 (iii.b), but was defined by: S t S () ~ S t . As was remarked by Professor G. <p> Another difference is that, while the analogue of G in F " chooses the minimal representative of functions, this is not the case in F S . Moreover, it is straightforward to show that F S is equivalent to Engeler's model D A . The main results of <ref> [1] </ref> are: * Soundness and completeness of type assignment with respect to inference type semantics. * If B ` " M : then there are B 0 ; 0 2 T S such that B 0 ` S M : 0 , 0 and B B 0 . * Conservativity. <p> The major feature of this restricted system is, compared to the BCD-system, a restricted version of the derivation rules and the use of strict types. It also forms a slight extension of the strict type assignment system that was presented in <ref> [1] </ref> (see Subsection 1.4); the main difference is that the strict system is not closed for -reduction, whereas the essential system presented here is. Recall Definition 1.4.1. <p> Take strict, such that ! does not occur in , and B = PfB 1 ; : : :; B n ; fx: 1 ! ! n !gg. Then B ` E xA 1 A n :, and B and , are !-free. Now, as in <ref> [1] </ref> for the strict system, it is possible to prove that the essential type assignment system satisfies the main properties of the BCD-system. <p> Also using this last result, it is possible to prove completeness of essential type assignment with respect to the simple type semantics (see Theorem 4.3.7). 4.2 An essential filter -model As in [6] and <ref> [1] </ref>, a filter -model can be constructed. Names will be used to distinguish between the definition of filters in those papers and the one given here. <p> Notice that an essential filter is never empty; because of part (i.a), for all d, ! 2 d. Notice also that the application on filters as in Definition 1.3.4 is not useful for F E , since it would not be well defined. As in <ref> [1] </ref>, application must be forced to yield filters, since in each arrow type scheme !t 2 T S , t is strict. &lt;F E , &gt; is a cpo and henceforward it will be considered with the corresponding Scott topology.
Reference: [2] <author> S. van Bakel. </author> <title> Partial Intersection Type Assignment of Rank 2 in Applicative Term Rewriting Systems. </title> <type> Technical Report 92-03, </type> <institution> Department of Computer Science, University of Nijmegen, </institution> <year> 1992. </year>
Reference-contexts: A disadvantage of the BCD-system is that type assignment in this system is undecidable. In recent years, some decidable restrictions have been studied. The first was the Rank2 intersection type assignment system <ref> [2] </ref>, as first suggested by D. Leivant in [26], that is very close to the notion of type assignment as used in ML.
Reference: [3] <author> S. van Bakel. </author> <title> Essential Intersection Type Assignment. </title> <editor> In R.K. Shyamasunda, editor, </editor> <booktitle> Proceedings of FST&TCS '93. 13 th Conference on Foundations of Software Technology and Theoretical Computer Science, Bombay, India, volume 761 of Lecture Notes in Computer Science, </booktitle> <pages> pages 13-23. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Finally, in Section 6, the proof for the principal type property for the essential system will be sketched. The results presented in this paper first appeared, in a condensed and slightly different form, in <ref> [3] </ref>. Notations In this paper, the symbol ' will be a type-variable; Greek symbols like ff, fi, , , , and t will range over types, and will be used for principal types. `!' will be assumed to associate to the right, and `"' binds stronger than `!'.
Reference: [4] <author> S. van Bakel. </author> <title> Principal type schemes for the Strict Type Assignment System. </title> <journal> Logic and Computation, </journal> <volume> 3(6) </volume> <pages> 643-670, </pages> <year> 1993. </year>
Reference-contexts: For three of these systems presented in the past (one CDV system, the BCD system and the strict system) the principal type property has been shown to hold in, respectively, [9], [34], and <ref> [4] </ref>; in Section 5 the constructions of the proofs of the various papers will be discussed. Finally, in Section 6, the proof for the principal type property for the essential system will be sketched. <p> There exist three intersection systems for which the principal type property is proved: a CDV-system in [9], the BCD-system in [34], and the strict system in <ref> [4] </ref>. The technique used for the proofs of these properties is very different for the one used for Curry's sytem. The principal type scheme for a term is in [9], [34], and [4] studied through the notion of approximant of a term; terms with a finite number of approximants have finite <p> principal type property is proved: a CDV-system in [9], the BCD-system in [34], and the strict system in <ref> [4] </ref>. The technique used for the proofs of these properties is very different for the one used for Curry's sytem. The principal type scheme for a term is in [9], [34], and [4] studied through the notion of approximant of a term; terms with a finite number of approximants have finite principal type schemes, while terms with a infinite number of approximants have `infinite' principal type schemes. <p> If ! is also a subtype of , then just replacing by an intersection of copies of , would generate !( 1 " " n ). This is a not a legal type in [9] and <ref> [4] </ref>. <p> This technique is the same as for example used in [34], <ref> [4] </ref>, and Section 6 of this paper. The set of ground pairs for a term A 2 N, as defined in [9], is proved to be complete for A, in the sense that all other pairs for A can be generated from a ground pair for A. <p> Then there exist a pair hP; i2 fPp (A) j A 2 A (M )g and a chain C, such that C (hP; i) = hB; i. 5.4 The system of <ref> [4] </ref> The proof of the principal type property for the strict system as presented in [4] is achieved in a way similar to, but significantly different from, the two techniques sketched above. In that paper, three operations on pairs of basis and types are defined: substitution, expansion, and lifting. <p> Then there exist a pair hP; i2 fPp (A) j A 2 A (M )g and a chain C, such that C (hP; i) = hB; i. 5.4 The system of <ref> [4] </ref> The proof of the principal type property for the strict system as presented in [4] is achieved in a way similar to, but significantly different from, the two techniques sketched above. In that paper, three operations on pairs of basis and types are defined: substitution, expansion, and lifting. <p> Because of technical reasons, substitution is in <ref> [4] </ref> defined as (' 7! ff), where ' is a type-variable and ff 2 T s [ f!g, so it can also replace type-variables by the type constant ! (this is not needed in the proofs of Section 6). <p> Therefore, for strict types substitution is not defined as an operation that replaces type-variables by types, but as a mapping from types to types, that, in a certain sense, `normalizes while substituting'. The operation of expansion, as defined in <ref> [4] </ref>, corresponds to the one given in [9] and is a simplified version of the one defined in [34]. A difference is that in those definitions subtypes are collected, whereas the definition of expansion in [4] (see Definition 6.2.5) collects type-variables. Recall Definition 2.1. <p> The operation of expansion, as defined in <ref> [4] </ref>, corresponds to the one given in [9] and is a simplified version of the one defined in [34]. A difference is that in those definitions subtypes are collected, whereas the definition of expansion in [4] (see Definition 6.2.5) collects type-variables. Recall Definition 2.1. Observe that strict type assignment is not closed for the relation E , so the following does not hold: If B ` S M : and E t , then B ` S M :. <p> As a counter example, take fx:!g ` s x:!. Notice that ! E "t !, but it is impossible to derive fx:!g ` S x:"t !. The operation of lifting as defined in <ref> [4] </ref> (see Definition 6.2.16) is based on the relation E , in the same way as the operation of rise is based on . As shown there, and illustrated above, that operation is not sound on all pairs hB; i. (In fact, as argued in [4], it is impossible to formulate <p> of lifting as defined in <ref> [4] </ref> (see Definition 6.2.16) is based on the relation E , in the same way as the operation of rise is based on . As shown there, and illustrated above, that operation is not sound on all pairs hB; i. (In fact, as argued in [4], it is impossible to formulate an operation that performs the desired lifting and is sound on all pairs.) The reason for this is that introducing a derivation rule, allowed on all terms, using the relation E , corresponds to a -reduction step (see Theorem 2.8), and the strict system is <p> Since strict type assignment is not closed for E , and the operation of lifting applies E to a derivation, it is clear that a conflict arises. However, in <ref> [4] </ref> it is shown that the operation defined there is sound on primitive pairs. The definition for primitive pairs is based on the definition of ground pairs as given in [9]. <p> The problem mentioned above is then solved by allowing liftings only on primitive 32 pairs for terms. The result of <ref> [4] </ref> follows from: * Every principal pair is a ground pair. * Forevery expansion Exp, if hB; i is a ground pair for A and Exp (hB; i) = hB 0 ; 0 i, then hB 0 ; 0 i is a ground pair for A. <p> Although lifting is not sound on all pairs, using the results mentioned above it is possible to prove that the three operations defined in <ref> [4] </ref> are sufficient (complete): for every pair hB; i and A 2 N, if B ` S A:, then there exists a number of expansion, one lifting, and a substitution, such that hB; i can be obtained from Pp (A) by performing these operations in sequence. <p> Using this result, the principal type property for the essential system will be proved. In <ref> [4] </ref>, the main problem to solve was to find an operation of lifting that was able to take the special role of the relation S into account. As argued in Subsection 5.4, for the strict system there exist no operation of lifting that is sound on all pairs. <p> Since the essential system is more liberal than the strict one, in the sense that the essential system is closed for the relation E , the operation of lifting as defined in <ref> [4] </ref> is a sound operation for the essential system (see Theorem 6.2.17). It is then easy to show that, with just the operations as defined in [4], the principal type property holds for the essential system. In this subsection a different proof will be presented, that follows a new approach. <p> the strict one, in the sense that the essential system is closed for the relation E , the operation of lifting as defined in <ref> [4] </ref> is a sound operation for the essential system (see Theorem 6.2.17). It is then easy to show that, with just the operations as defined in [4], the principal type property holds for the essential system. In this subsection a different proof will be presented, that follows a new approach. <p> In [34], there is an overlap between operations; for example, intersections can be introduced by expansions as well as by substitutions and rise. Also, in <ref> [4] </ref> the step from the 33 pair hB; i to hB; !i can be made using a lifting as well as a substitution. <p> The operations of expansion, covering, and substitution as defined in this paper are `orthogonal' in that sense; no kind of operation can be mimicked by another kind of operation. The difference between the operations specified in <ref> [4] </ref> and this paper lie in the fact that here the operation of substitution has been changed, in a subtle, natural, but drastic way: a substitution can no longer replace a type-variable by !. In the papers discussed above that possibility existed and, especially in [9] and [4], caused inconvenience, since <p> operations specified in <ref> [4] </ref> and this paper lie in the fact that here the operation of substitution has been changed, in a subtle, natural, but drastic way: a substitution can no longer replace a type-variable by !. In the papers discussed above that possibility existed and, especially in [9] and [4], caused inconvenience, since there a `normalization-after-substitution' was called for, explicitly defined in [9], and part of the definition of substitution in [4]. <p> In the papers discussed above that possibility existed and, especially in [9] and <ref> [4] </ref>, caused inconvenience, since there a `normalization-after-substitution' was called for, explicitly defined in [9], and part of the definition of substitution in [4]. <p> Proof: Easy. The notion of principal pairs for terms in N will be generalized to arbitrary lambda terms in Definition 6.3.5. 35 The principal pairs in the systems as presented in [9], [34], and <ref> [4] </ref> are exactly the same. <p> The operation of expansion of types defined here corresponds to the notion of expansion as defined in [34] and <ref> [4] </ref>. A difference between the notions of expansion as defined in [9] and [34] is that in those papers a set of types involved in the expansion is created. As in [4], here just type-variables are collected, so the definition of expansion presented here is less complicated. 36 Definition 6.2.4 i) <p> The operation of expansion of types defined here corresponds to the notion of expansion as defined in [34] and <ref> [4] </ref>. A difference between the notions of expansion as defined in [9] and [34] is that in those papers a set of types involved in the expansion is created. As in [4], here just type-variables are collected, so the definition of expansion presented here is less complicated. 36 Definition 6.2.4 i) If B is a basis and 2T S , then T hB;i is the set of all strict subtypes occurring in the pair hB; i. ii) The last type-variable of a <p> Then by induction, for 1 i n, B 0 i , so also PfB 0 1 ; : : : ; B 0 1 ! ! 0 The last operation needed in this paper is that of lifting, as first presented in <ref> [4] </ref>: Definition 6.2.16 A lifting Lift is an operation denoted by a pair of pairs &lt;hB 0 ; t 0 i,hB 1 ; t 1 i&gt; such that t 0 E t 1 and B 1 E B 0 , and is defined by: i) Lift () = t 1 ,
Reference: [5] <author> H. Barendregt. </author> <title> The Lambda Calculus: its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <note> revised edition, </note> <year> 1984. </year>
Reference-contexts: Wadsworth [37] and is defined using the notion of terms in ?-normal form (like in <ref> [5] </ref>, ? is used, instead of W; also, the symbol &lt; ~ is used as a relation on L?-terms, inspired by a similar relation defined on Bohm-trees in [5]). <p> Wadsworth [37] and is defined using the notion of terms in ?-normal form (like in <ref> [5] </ref>, ? is used, instead of W; also, the symbol &lt; ~ is used as a relation on L?-terms, inspired by a similar relation defined on Bohm-trees in [5]).
Reference: [6] <author> H. Barendregt, M. Coppo, and M. Dezani-Ciancaglini. </author> <title> A filter lambda model and the completeness of type assignment. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 48(4) </volume> <pages> 931-940, </pages> <year> 1983. </year>
Reference-contexts: It is, for example, not possible to assign a type to the term (x:xx), and terms that are fi-equal can have different principal type schemes. The Intersection Type Discipline as presented in [10] by M. Coppo, M. Dezani-Ciancaglini, and B. Venneri (a more enhanced system was presented in <ref> [6] </ref> by H. Barendregt, M. Coppo, and M. Dezani-Ciancaglini) is an extension of Curry's system that does not have these drawbacks. The extension being made consists mainly of allowing for term variables (and terms) to have more than one type. <p> Also, by introducing this extension a system is obtained that is closed under fi-equality: if B ` M : and M = fi N , then B ` N :. The type assignment system presented in <ref> [6] </ref> (the BCD-system) is based on the system as presented in [10]. <p> A big contribution of <ref> [6] </ref> to the theory of intersection types is the introduction of a filter -model and the proof of completeness of type assignment; to achieve the latter, the system is strengthened further by introducing a partial order relation `' on types as well as adding the type assignment rule (). <p> These rules not only allow of superfluous steps in derivations, but also make it possible to give essentially different derivations for the same result. Moreover, in <ref> [6] </ref> the relation induced an equivalence relation ~ on types. Equivalence classes are big (for example: ! ~ (!!), for all types ) and type assignment is closed for ~. <p> It will be shown that, in order to prove a completeness result using intersection types, there is no need to be as general as in <ref> [6] </ref>; this result can also be obtained for the essential system. The main advantage of the essential system over the BCD-system is that the set of types assignable to a term is significantly smaller. <p> This paper also gives an overview of various notions of intersection type assignment, in order to give insight and intuition, and to compare in detail the various systems and their development. The main objective of this paper is to show that the treatment of intersection types as in <ref> [6] </ref> has been too general; the same results could have been obtained for a far less complicated system, that follows more closely the syntactical structure of terms, and treats the type ! not as a type constant, but as the empty intersection. <p> Subsection 1.1 presents the Coppo-Dezani system as defined in [7], Subsection 1.2 presents two Coppo-Dezani-Venneri systems as first defined in [10], Subsection 1.3 presents the Barendregt-Coppo-Dezani system that can be found in <ref> [6] </ref>, and Subsection 1.4 presents the strict system of [1]. Section 2 contains the presentation of the essential type assignment system, an extension of the strict system, and a restriction of the BCD-system that will prove to be equally powerful as the BCD-system. <p> Therefore, it is possible to derive ` yz:(b:z)(yz):(!t )!! and ` yz:z:t !!, but not to give a derivation for yz:(b:z)(yz):t !!. From this initial system several others emerged. The best known and most frequently quoted is the one presented in <ref> [6] </ref>, but there are two earlier papers ([10] and [9]) that investigate interesting systems which can be regarded as in-between those of in [7] and [6]. In fact, the system that will be presented in Section 2 is more close to the system of [10] that to that of [6]. 1.2 <p> From this initial system several others emerged. The best known and most frequently quoted is the one presented in <ref> [6] </ref>, but there are two earlier papers ([10] and [9]) that investigate interesting systems which can be regarded as in-between those of in [7] and [6]. In fact, the system that will be presented in Section 2 is more close to the system of [10] that to that of [6]. 1.2 The Coppo-Dezani-Venneri type assignment systems In [10] two type assignment systems are presented, that, in approach, are more general than the Coppo-Dezani system: in addition <p> in <ref> [6] </ref>, but there are two earlier papers ([10] and [9]) that investigate interesting systems which can be regarded as in-between those of in [7] and [6]. In fact, the system that will be presented in Section 2 is more close to the system of [10] that to that of [6]. 1.2 The Coppo-Dezani-Venneri type assignment systems In [10] two type assignment systems are presented, that, in approach, are more general than the Coppo-Dezani system: in addition to the type constructors `!' and `"', they also contain the type constant `!'. <p> system; properties of this restricted system proved in [10] are: * If B ` M :, then is a normalized type. * If B ` M : and M ! N , then B ` N :. 9 1.3 The Barendregt-Coppo-Dezani type assignment system The type assignment system presented in <ref> [6] </ref> by H. Barendregt, M. Coppo and M. Dezani-Ciancaglini is based on the first, unrestricted system as presented in [10]. <p> In order to prove the `('-part of this statement (completeness), the relation is needed. Other interesting applications of filter -models can be found in [8], [11], [16], and [17]. Definition 1.3.1 i) T " , the set of types in <ref> [6] </ref> is inductively defined by: a) All type-variables ' 0 , ' 1 , : : : 2 T " . b) ! 2 T " . c) If and t 2 T " , then !t and "t 2 T " . ii) On T " , the type inclusion <p> This system would then have been identical to the essential system as presented in this paper (Section 2). 10 Definition 1.3.2 i) Type assignment and derivations are in <ref> [6] </ref> defined by the following natural deduction system. [x:] M :t x:M :!t (!E): M : M :t M :"t ("E): M :"t M : t M :t M :! (a) If x: is the only statement about x on which M :t depends. ii) B ` " M : means <p> An advantage of the presentation in <ref> [6] </ref> is, clearly, a very easy type definition and easy understandable derivation rules. But this advantage is superficial, since all difficulties now show up while proving theorems; especially the complexity of and ~ causes confusion. <p> In other words: those systems are syntax directed. The BCD-system has the same expressive power as the previous unrestricted CDV-system: all solvable terms have types other than !, and a term has a normal form if and only if it has a type without !-occurrences. The main result of <ref> [6] </ref> is the proof for completeness of type assignment. <p> Notice that, because of part (i.a), a filter is never empty. The following properties are proved in <ref> [6] </ref>: * 8 M 2 L [f j9 B [B ` " M :g 2F " ]]. * Let ~ be a valuation of term-variables in F " and B ~ = fx: j 2 ~ (x)g. <p> Since no confusion is possible, the superscript on [[ ]] is omitted. The main result of <ref> [6] </ref> is obtained by proving: Property 1.3.7 i) Soundness. B ` " M : ) B ` ` s M :. ii) Completeness. B ` ` s M : ) B ` " M :. <p> B ` " M : ) B ` ` s M :. ii) Completeness. B ` ` s M : ) B ` " M :. The proof of completeness is obtained in a way very similar to that of Theorem 4.3.6. The results of <ref> [6] </ref> in fact show that type assignment in the BCD-system is complete with respect to simple type semantics; this in contrast to strict type assignment (presented in [1], see also the next subsection), that is complete with respect to the inference semantics. 1.4 The strict type assignment system The strict type <p> to simple type semantics; this in contrast to strict type assignment (presented in [1], see also the next subsection), that is complete with respect to the inference semantics. 1.4 The strict type assignment system The strict type assignment system as defined in [1] is a restriction of the system of <ref> [6] </ref>; it is a type assignment system in which the relation and the derivation rule () are no longer present. The elimination of induces a set of strict types, that is actually the set of normalized tail-proper types of [10]. <p> Although the rather strong restrictions imposed, the provable results for the strict system are very close to those for the system of <ref> [6] </ref>. For example, the sets of normalizable terms and those having a normal form can be equally elegantly characterized. The main difference between the two systems is that the strict system is not closed for -reduction, whereas the BCD-system is. <p> The main difference between the two systems is that the strict system is not closed for -reduction, whereas the BCD-system is. The strict system gives rise to a strict filter -model F S , that satisfies all major properties of the filter -model F " as presented in <ref> [6] </ref>, but is an essentially different -model, equivalent to Engeler's model D A [18]. In [1] was shown that soundness for the notion of type assignment of [6] is lost if instead of simple type semantics, the inference type semantics is used. <p> rise to a strict filter -model F S , that satisfies all major properties of the filter -model F " as presented in <ref> [6] </ref>, but is an essentially different -model, equivalent to Engeler's model D A [18]. In [1] was shown that soundness for the notion of type assignment of [6] is lost if instead of simple type semantics, the inference type semantics is used. Take, for example, the statement x:x:(!)!("t )!: this statement is derivable in the system ` " , but it is not valid in F S . <p> Also, the derivation rules (!I) and ("E) together correspond to the derivation rule (!I) of the unrestricted CDV-system (Definition 1.2.1). The strict filter -model F S is defined in a way very similar to F " defined in <ref> [6] </ref>, by defining filters of types and a map from terms to filters. <p> without !: fM j M is typeable by means of the derivation rules ("I), ("E), (!I) and (!E)g = fM j M is strongly normalizableg. 2 The essential intersection type assignment system In this section the essential type assignment system is presented, a restricted version of the system presented in <ref> [6] </ref>, together with some of its properties. The major feature of this restricted system is, compared to the BCD-system, a restricted version of the derivation rules and the use of strict types. <p> In [34] this result is obtained through a normalization of derivations, where all (!I)-(!E) pairs, that derive a type for a redex (x:M )N , are replaced by one for its reduct M [N=x], and all pairs of ("I)-("E) are eliminated. (This technique is also used in [9] and <ref> [6] </ref>. It requires a rather difficult notion of length of a 19 derivation to show that this process terminates.) In this paper, this result will be proved using the computability technique, following Tait [36], as was done in [11], and [17]. <p> Also using this last result, it is possible to prove completeness of essential type assignment with respect to the simple type semantics (see Theorem 4.3.7). 4.2 An essential filter -model As in <ref> [6] </ref> and [1], a filter -model can be constructed. Names will be used to distinguish between the definition of filters in those papers and the one given here. <p> This is done in a way very similar to the one used in <ref> [6] </ref>, using the essential filter -model as defined in the previous subsection. Theorem 4.3.1 Soundness. B ` E M : ) B ` ` s M :. Proof: By induction on the structure of derivations. The method followed in [6] for the proof of completeness of type assignment is to define <p> done in a way very similar to the one used in <ref> [6] </ref>, using the essential filter -model as defined in the previous subsection. Theorem 4.3.1 Soundness. B ` E M : ) B ` ` s M :. Proof: By induction on the structure of derivations. The method followed in [6] for the proof of completeness of type assignment is to define a simple type interpretation that satisfies: for all types , () = fd 2 F " j 2 dg. The approach taken here is to define a type interpretation, and to show that it is simple. <p> Using the relation between the two notions of type assignment that was defined in the previous subsection, soundness and completeness of essential type assignment can also be proved using the result of <ref> [6] </ref> (Property 1.3.7). Theorem 4.3.7 Soundness and completeness of essential type assignment. Let B and contain types in T S . Then B ` E M : () B ` ` s M :. <p> results mentioned above, a ground pair for (x:x?(y:y)). [x : !!(' 2 !' 2 )"(' 3 !' 3 )!' 1 ] [y : ' 2 ] [y : ' 3 ] x?(y:y) : ' 1 (See Definition 6.2.5.) 30 5.3 The system of [34] For the system as defined in <ref> [6] </ref>, principal type schemes can be defined as in [34]. There three operations are provided substitution, expansion, and rise that are sound and sufficient to generate all suitable pairs for a term M from its principal pair. <p> In this paper, all constructions and definitions are made modulo the equivalence relation ~. In fact, the complexity inserted in the type language of <ref> [6] </ref> by allowing for intersection types on the right of the arrow type constructor, disturbs greatly the accessibility of this paper. As shown in Section 6, the results of [34] can also be obtained for the essential system presented here, that is equally powerful. <p> Conclusions This paper presented the essential intersection type assignment system, as a true restriction of the BCD-system that satisfies all properties of that system, where derivations are syntax-directed. Since all properties of the BCD-system are shown to hold for the essential system, the treatment of intersection types as in <ref> [6] </ref> has been too general. Instead of introducing " as a general type-constructor, and ! as a type-constant, it is better to treat ! as the empty intersection, and to allow intersections only on the left of the !.
Reference: [7] <author> M. Coppo and M. Dezani-Ciancaglini. </author> <title> An Extension of the Basic Functionality Theory for the -Calculus. </title> <journal> Notre Dame, Journal of Formal Logic, </journal> <volume> 21(4) </volume> <pages> 685-693, </pages> <year> 1980. </year>
Reference-contexts: The outline of this paper is as follows. Section 1 will give an overview of, in total, five notions of intersection type assignment, that will be compared and discussed. Subsection 1.1 presents the Coppo-Dezani system as defined in <ref> [7] </ref>, Subsection 1.2 presents two Coppo-Dezani-Venneri systems as first defined in [10], Subsection 1.3 presents the Barendregt-Coppo-Dezani system that can be found in [6], and Subsection 1.4 presents the strict system of [1]. <p> Coppo and M. Dezani-Ciancaglini from the University of Turin, Italy that introduced intersection types is <ref> [7] </ref> (in this paper, instead of the word `intersection', the word `sequence' was used). <p> Definition 1.1.1 i) The set of types considered in <ref> [7] </ref> is inductively defined by: a) All type-variables ' 0 , ' 1 , : : : are types. b) If 1 ; : : : ; n are types (n 1), then 1 " " n is a sequence. c) If 1 " " n is a sequence and is <p> The main properties of that system proved in <ref> [7] </ref> are: * Subject reduction: If B ` M : and M ! fi N , then B ` N :. * Normalizability of typeable terms: If B ` M :, then M has a normal form. * Typeability of all terms in normal form. * Closure for fi-equality in the <p> From this initial system several others emerged. The best known and most frequently quoted is the one presented in [6], but there are two earlier papers ([10] and [9]) that investigate interesting systems which can be regarded as in-between those of in <ref> [7] </ref> and [6]. <p> The first type discipline as presented in [10] (a similar system was presented in [35]) is a true extension of the one presented in <ref> [7] </ref>; the second one limits the use of intersection types in bases. <p> The changes with respect to the system of <ref> [7] </ref> are small, but important. First of all, the type constant !, assignable to all terms, is introduced, which makes all terms having a head normal form typeable; the type ! is needed to cover the subterms that have no normal form. Also, the ("E) rule of [7] is implicitly present <p> the system of <ref> [7] </ref> are small, but important. First of all, the type constant !, assignable to all terms, is introduced, which makes all terms having a head normal form typeable; the type ! is needed to cover the subterms that have no normal form. Also, the ("E) rule of [7] is implicitly present in (!I). <p> Moreover, intersection type schemes (so also !) occur in strict types only as subtypes at the left-hand side of an arrow type scheme, as in the types of <ref> [7] </ref>, [9], and [10].
Reference: [8] <author> M. Coppo, M. Dezani-Ciancaglini, F. Honsell, and G. Longo. </author> <title> Extended type structures and filter lambda models. </title> <editor> In G. Lolli, G. Longo, and A. Marcja, editors, </editor> <booktitle> Logic Colloquium 82, </booktitle> <pages> pages 241-262, </pages> <address> Amsterdam, the Netherlands, 1984. </address> <publisher> North-Holland. </publisher>
Reference-contexts: In order to prove the `('-part of this statement (completeness), the relation is needed. Other interesting applications of filter -models can be found in <ref> [8] </ref>, [11], [16], and [17].
Reference: [9] <author> M. Coppo, M. Dezani-Ciancaglini, and B. Venneri. </author> <title> Principal type schemes and -calculus semantics. </title> <editor> In J.R. Hindley and J.P. Seldin, editors, </editor> <booktitle> To H.B. Curry, Essays in combinatory logic, lambda-calculus and formalism, </booktitle> <pages> pages 535-560. </pages> <publisher> Academic press, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: For three of these systems presented in the past (one CDV system, the BCD system and the strict system) the principal type property has been shown to hold in, respectively, <ref> [9] </ref>, [34], and [4]; in Section 5 the constructions of the proofs of the various papers will be discussed. Finally, in Section 6, the proof for the principal type property for the essential system will be sketched. <p> From this initial system several others emerged. The best known and most frequently quoted is the one presented in [6], but there are two earlier papers ([10] and <ref> [9] </ref>) that investigate interesting systems which can be regarded as in-between those of in [7] and [6]. <p> Moreover, intersection type schemes (so also !) occur in strict types only as subtypes at the left-hand side of an arrow type scheme, as in the types of [7], <ref> [9] </ref>, and [10]. <p> In [34] this result is obtained through a normalization of derivations, where all (!I)-(!E) pairs, that derive a type for a redex (x:M )N , are replaced by one for its reduct M [N=x], and all pairs of ("I)-("E) are eliminated. (This technique is also used in <ref> [9] </ref> and [6]. It requires a rather difficult notion of length of a 19 derivation to show that this process terminates.) In this paper, this result will be proved using the computability technique, following Tait [36], as was done in [11], and [17]. <p> Since substitution is an easy operation, in Curry's system the set fhB; ijB ` M :g can be computed in a simple way from the principal pair for M . There exist three intersection systems for which the principal type property is proved: a CDV-system in <ref> [9] </ref>, the BCD-system in [34], and the strict system in [4]. The technique used for the proofs of these properties is very different for the one used for Curry's sytem. The principal type scheme for a term is in [9], [34], and [4] studied through the notion of approximant of a <p> for which the principal type property is proved: a CDV-system in <ref> [9] </ref>, the BCD-system in [34], and the strict system in [4]. The technique used for the proofs of these properties is very different for the one used for Curry's sytem. The principal type scheme for a term is in [9], [34], and [4] studied through the notion of approximant of a term; terms with a finite number of approximants have finite principal type schemes, while terms with a infinite number of approximants have `infinite' principal type schemes. <p> Therefore, a functional characterization of these terms, through a principal type, cannot be represented in a finite way. 5.1 The operation of expansion As mentioned in the introduction of <ref> [9] </ref>, using intersection types different types can be assigned to the same component of a given term. Therefore, the structure of derivation does not follow the syntactic structure of terms, and with the only operation of substitution, for a given term, not all types can be obtained. <p> Therefore, the structure of derivation does not follow the syntactic structure of terms, and with the only operation of substitution, for a given term, not all types can be obtained. This difficulty is overcome in <ref> [9] </ref> by introducing the (context-dependent) operation of expansion. The definition of expansion is very complicated. It is an operation on types that deals with the replacement of (sub)types by a number of copies of that type. <p> If ! is also a subtype of , then just replacing by an intersection of copies of , would generate !( 1 " " n ). This is a not a legal type in <ref> [9] </ref> and [4]. <p> Then types are traversed top down, and types are replaced if they end with one of the sub-types found. 5.2 The system of <ref> [9] </ref> In [9] principal type schemes are defined for a type assignment system that is like the restricted one from [10], but uses the set of types of the unrestricted system. <p> Then types are traversed top down, and types are replaced if they end with one of the sub-types found. 5.2 The system of <ref> [9] </ref> In [9] principal type schemes are defined for a type assignment system that is like the restricted one from [10], but uses the set of types of the unrestricted system. <p> This technique is the same as for example used in [34], [4], and Section 6 of this paper. The set of ground pairs for a term A 2 N, as defined in <ref> [9] </ref>, is proved to be complete for A, in the sense that all other pairs for A can be generated from a ground pair for A. <p> The first operation defined is substitution, that is defined without restriction: the type that is to be substituted can be every element of T " . Next, the operation of expansion is defined, which is a generalization of the notion of expansion defined in <ref> [9] </ref>. Both substitution and expansions are in the natural way extended to operations on bases and pairs. The third operation defined (on pairs) is the operation of rise: it consists of adding applications of the derivation rule () to a derivation. <p> This definition is not complete, in the sense that the fact that the chain ends with one rise is essential in the proof for completeness.) As in <ref> [9] </ref>, principal pairs are defined for terms in ?-normal form. <p> In order to prove that the operations defined are sufficient, three subsets of the set of all pairs of basis and type are defined, namely: principal pairs, ground pairs, and primitive pairs. (The definition of ground pairs coincides with the one given in <ref> [9] </ref>.) In that paper is shown that these form a true hierarchy, that the set of ground pairs for a term is closed under the operation of expansion, that the set of primitive pairs is closed under the operation of lifting, and that the set of pairs is closed for substitution. <p> Therefore, for strict types substitution is not defined as an operation that replaces type-variables by types, but as a mapping from types to types, that, in a certain sense, `normalizes while substituting'. The operation of expansion, as defined in [4], corresponds to the one given in <ref> [9] </ref> and is a simplified version of the one defined in [34]. A difference is that in those definitions subtypes are collected, whereas the definition of expansion in [4] (see Definition 6.2.5) collects type-variables. Recall Definition 2.1. <p> However, in [4] it is shown that the operation defined there is sound on primitive pairs. The definition for primitive pairs is based on the definition of ground pairs as given in <ref> [9] </ref>. The main difference between ground pairs and primitive pairs is that in a primitive pair a predicate for a term-variable (bound or free) is not the smallest type needed, but can contain some additional, irrelevant types. <p> A relevant restriction of the essential system will be presented ( ` R ), that is close to the system defined in Definition 1.2.3. For this system, the principal type property will be proved, using a technique different from the one used in <ref> [9] </ref>. In fact, it will be shown that, if B ` R M : and hP; i is the principal pair for M , then there is a chain C of operations, consisting of expansions, one covering, and one substitution, such that C (hP; i) = hB; i. <p> In the papers discussed above that possibility existed and, especially in <ref> [9] </ref> and [4], caused inconvenience, since there a `normalization-after-substitution' was called for, explicitly defined in [9], and part of the definition of substitution in [4]. <p> In the papers discussed above that possibility existed and, especially in <ref> [9] </ref> and [4], caused inconvenience, since there a `normalization-after-substitution' was called for, explicitly defined in [9], and part of the definition of substitution in [4]. <p> Proof: Easy. The notion of principal pairs for terms in N will be generalized to arbitrary lambda terms in Definition 6.3.5. 35 The principal pairs in the systems as presented in <ref> [9] </ref>, [34], and [4] are exactly the same. <p> The operation of expansion of types defined here corresponds to the notion of expansion as defined in [34] and [4]. A difference between the notions of expansion as defined in <ref> [9] </ref> and [34] is that in those papers a set of types involved in the expansion is created.
Reference: [10] <author> M. Coppo, M. Dezani-Ciancaglini, and B. Venneri. </author> <title> Functional characters of solvable terms. </title> <journal> Zeitschrift f ur Mathematische Logik und Grundlagen der Mathematik, </journal> <volume> 27 </volume> <pages> 45-58, </pages> <year> 1981. </year>
Reference-contexts: Though the Curry system is already powerful and convenient for use in programming practice, it has drawbacks. It is, for example, not possible to assign a type to the term (x:xx), and terms that are fi-equal can have different principal type schemes. The Intersection Type Discipline as presented in <ref> [10] </ref> by M. Coppo, M. Dezani-Ciancaglini, and B. Venneri (a more enhanced system was presented in [6] by H. Barendregt, M. Coppo, and M. Dezani-Ciancaglini) is an extension of Curry's system that does not have these drawbacks. <p> Also, by introducing this extension a system is obtained that is closed under fi-equality: if B ` M : and M = fi N , then B ` N :. The type assignment system presented in [6] (the BCD-system) is based on the system as presented in <ref> [10] </ref>. <p> The outline of this paper is as follows. Section 1 will give an overview of, in total, five notions of intersection type assignment, that will be compared and discussed. Subsection 1.1 presents the Coppo-Dezani system as defined in [7], Subsection 1.2 presents two Coppo-Dezani-Venneri systems as first defined in <ref> [10] </ref>, Subsection 1.3 presents the Barendregt-Coppo-Dezani system that can be found in [6], and Subsection 1.4 presents the strict system of [1]. <p> quoted is the one presented in [6], but there are two earlier papers (<ref> [10] </ref> and [9]) that investigate interesting systems which can be regarded as in-between those of in [7] and [6]. In fact, the system that will be presented in Section 2 is more close to the system of [10] that to that of [6]. 1.2 The Coppo-Dezani-Venneri type assignment systems In [10] two type assignment systems are presented, that, in approach, are more general than the Coppo-Dezani system: in addition to the type constructors `!' and `"', they also contain the type constant `!'. <p> (<ref> [10] </ref> and [9]) that investigate interesting systems which can be regarded as in-between those of in [7] and [6]. In fact, the system that will be presented in Section 2 is more close to the system of [10] that to that of [6]. 1.2 The Coppo-Dezani-Venneri type assignment systems In [10] two type assignment systems are presented, that, in approach, are more general than the Coppo-Dezani system: in addition to the type constructors `!' and `"', they also contain the type constant `!'. The first type discipline as presented in [10] (a similar system was presented in [35]) is a true <p> that of [6]. 1.2 The Coppo-Dezani-Venneri type assignment systems In <ref> [10] </ref> two type assignment systems are presented, that, in approach, are more general than the Coppo-Dezani system: in addition to the type constructors `!' and `"', they also contain the type constant `!'. The first type discipline as presented in [10] (a similar system was presented in [35]) is a true extension of the one presented in [7]; the second one limits the use of intersection types in bases. <p> Definition 1.2.1 i) The set of types is inductively defined in <ref> [10] </ref> by: a) All type-variables ' 0 , ' 1 , : : : are types. b) ! is a type. c) If 1 ; : : : ; n are types, (n 1), then 1 " " n is a sequence. d) If 1 " " n is a sequence <p> The type is called tail-proper if 6= !. iii) Type assignment and derivations are in <ref> [10] </ref> defined by: [x: i ] [x: n ] M : x:M :t ! ("I): 7 (!): M : 1 " " n ! N : 1 " " n M N : (a) If x: 1 , : : : , x: n are all and nothing but the statements <p> Also, the ("E) rule of [7] is implicitly present in (!I). The main properties of this system proved in <ref> [10] </ref> are: * If B ` M : and M = fi N , then B ` N :. * B ` M : and is tail-proper, if and only if M has a head normal form. * B ` M : and ! does not occur in B and , <p> within a derivation; they are used for the cases that N occurs more than once in M [N=x], and these occurrences were typed in the derivation for B ` M [N=x]: with different types. (See also Lemma 2.9.) Definition 1.2.2 i) The set of normalized types is inductively defined in <ref> [10] </ref> by: a) All type-variables ' 0 , ' 1 , : : : are normalized types. b) ! is a normalized sequence. c) If 1 ; : : : ; n are normalized types (n 1) and, for 1 i n, i 6= !, then 1 " " n is <p> The second type assignment system presented in <ref> [10] </ref> is a restricted version of the first. <p> This system is also used in [19]. Definition 1.2.3 Restricted type assignment and restricted derivations are in <ref> [10] </ref> defined by: [x: 1 ] [x: n ] M : x:M : 1 " " n ! ("I): (b) (!): M : 1 " " n ! N : 1 " " n M N : (a) If 6= ! and x: 1 , : : : , x: n <p> This means that the statement xy:xy:(!t )!"!t cannot be derived, since the type is not used for the application xy. The closure under -reduction, however, holds for the restricted system; properties of this restricted system proved in <ref> [10] </ref> are: * If B ` M :, then is a normalized type. * If B ` M : and M ! N , then B ` N :. 9 1.3 The Barendregt-Coppo-Dezani type assignment system The type assignment system presented in [6] by H. Barendregt, M. Coppo and M. <p> Barendregt, M. Coppo and M. Dezani-Ciancaglini is based on the first, unrestricted system as presented in <ref> [10] </ref>. It extended the set of types to T " , introduced a partial order relation `' on types, added the type assignment rule (), and introduced a more general form of the rules concerning intersection. The rule () was mainly introduced to prove completeness of type assignment. <p> The goal of this paper is to show that, had the authors restricted themselves to the normalized types of <ref> [10] </ref> (Definition 1.2.2) and introduced a relation on those types (essentially composed of parts (ii.a), (ii.b), (ii.d), (ii.f), (ii.g), and (ii.h)), they would have obtained a system with the same expressiveness as that one they defined. <p> The elimination of induces a set of strict types, that is actually the set of normalized tail-proper types of <ref> [10] </ref>. Moreover, there the relation S on strict types is presented, that is more restricted than just the relation restricted to strict types. <p> Instead, it is the relation generated by interpreting the type-constructor " as intersection on sets; in particular, S is not defined over `!'-types, so part (ii.h) of Definition 1.3.1 is missing. The derivation rules used are similar to those of the unrestricted system in <ref> [10] </ref>. This implies that, formally, the strict system is a system in between the two presented in [10]; a significant difference with the restricted system of [10] is that type assignment in the strict system is not relevant in the sense of [15]. <p> The derivation rules used are similar to those of the unrestricted system in <ref> [10] </ref>. This implies that, formally, the strict system is a system in between the two presented in [10]; a significant difference with the restricted system of [10] is that type assignment in the strict system is not relevant in the sense of [15]. Although the rather strong restrictions imposed, the provable results for the strict system are very close to those for the system of [6]. <p> The derivation rules used are similar to those of the unrestricted system in <ref> [10] </ref>. This implies that, formally, the strict system is a system in between the two presented in [10]; a significant difference with the restricted system of [10] is that type assignment in the strict system is not relevant in the sense of [15]. Although the rather strong restrictions imposed, the provable results for the strict system are very close to those for the system of [6]. <p> Moreover, intersection type schemes (so also !) occur in strict types only as subtypes at the left-hand side of an arrow type scheme, as in the types of [7], [9], and <ref> [10] </ref>. <p> Then types are traversed top down, and types are replaced if they end with one of the sub-types found. 5.2 The system of [9] In [9] principal type schemes are defined for a type assignment system that is like the restricted one from <ref> [10] </ref>, but uses the set of types of the unrestricted system. The reason to not use the normalized 29 types as well is the fact that ! is treated as a type constant; since ! can be substituted for ' in !', also !! is considered a type.
Reference: [11] <author> M. Coppo, M. Dezani-Ciancaglini, and M. Zacchi. </author> <title> Type Theories, Normal Forms and D 1 -Lambda-Models. </title> <journal> Information and Computation, </journal> <volume> 72(2) </volume> <pages> 85-116, </pages> <year> 1987. </year> <month> 45 </month>
Reference-contexts: In order to prove the `('-part of this statement (completeness), the relation is needed. Other interesting applications of filter -models can be found in [8], <ref> [11] </ref>, [16], and [17]. <p> It requires a rather difficult notion of length of a 19 derivation to show that this process terminates.) In this paper, this result will be proved using the computability technique, following Tait [36], as was done in <ref> [11] </ref>, and [17].
Reference: [12] <author> M. Coppo and P. Giannini. </author> <title> A complete type inference algorithm for simple intersection types. </title> <editor> In J.-C. Raoult, editor, </editor> <booktitle> Proceedings of CAAP '92. 17th Colloquim on Trees in Algebra and Programming, Rennes, France, volume 581 of Lecture Notes in Computer Science, </booktitle> <pages> pages 102-123. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This Rank 2 system was later used as a basis for the notion of type assignment as studied by M. Coppo and P. Giannini in <ref> [12] </ref>. In that paper the idea behind the let-construct of ML is generalized. <p> In ML, quantification of type-variables is introduced, with the normal restriction that a term variable can only be bound if it does not occur free in the basis (context) for a term; only those type-variables can be instantiated by types. Similarly in <ref> [12] </ref>, only those type-variables can be expanded (for the notion of expansion, see Subsection 5.1). Since the operation of expansion uses also the notion of quantification, intersection types in this system are limited to those that have the same shape, instead of allowing for arbitrary intersections. <p> Since the operation of expansion uses also the notion of quantification, intersection types in this system are limited to those that have the same shape, instead of allowing for arbitrary intersections. The system studied by F. Damiani and P. Giannini in [15] is a restriction of the system in <ref> [12] </ref>, in that an (!I)-step can only be performed against the types actually used for the term-variable; the notion of type assignment of that paper is, therefore, called relevant. That intersection types can be used as a basis for programming languages was first discussed by J. Reynolds in [32].
Reference: [13] <author> H.B. Curry. </author> <title> Functionality in combinatory logic. </title> <journal> In Proc. Nat. Acad. Sci. U.S.A., </journal> <volume> volume 20, </volume> <pages> pages 584-590, </pages> <year> 1934. </year>
Reference-contexts: Curry in <ref> [13] </ref>. (See also [14].) Curry's system the first and most primitive one expresses abstraction and application and its major advantage is that the problem of type assignment is decidable. The types used in this system are those obtained from type-variables and the type-constructor ! `arrow'.
Reference: [14] <author> H.B. Curry and R. </author> <title> Feys. </title> <booktitle> Combinatory Logic, </booktitle> <volume> volume 1. </volume> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1958. </year>
Reference-contexts: Introduction In the recent years several notions of type assignment for several (extended) lambda calculi have been studied. The oldest among these is a well understood and elegantly defined notion of type assignment on lambda terms, known as the Curry type assignment system <ref> [14] </ref>. It expresses abstraction and application, and can be used to obtain a (basic) functional characterization of terms. <p> Curry in [13]. (See also <ref> [14] </ref>.) Curry's system the first and most primitive one expresses abstraction and application and its major advantage is that the problem of type assignment is decidable. The types used in this system are those obtained from type-variables and the type-constructor ! `arrow'.
Reference: [15] <author> F. Damiani and P. Giannini. </author> <title> A Decidable Intersection Type System based on Relevance. </title> <editor> In M. Hagiya and J.C. Mitchell, editors, </editor> <booktitle> Proceedings of TACS '94. International Symposium on Theoretical Aspects of Computer Software, Sendai, Japan, volume 789 of Lecture Notes in Computer Science, </booktitle> <pages> pages 707-725. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Since the operation of expansion uses also the notion of quantification, intersection types in this system are limited to those that have the same shape, instead of allowing for arbitrary intersections. The system studied by F. Damiani and P. Giannini in <ref> [15] </ref> is a restriction of the system in [12], in that an (!I)-step can only be performed against the types actually used for the term-variable; the notion of type assignment of that paper is, therefore, called relevant. <p> If n = 0, so in the derivation for M : there is no premise whose subject is x, then 1 " " n = !. This notion of type assignment is relevant in the sense of <ref> [15] </ref>: in the (!I)-rule, only those types actually used in the derivation can be abstracted. This implies that, for example, for the lambda term (ab:a) the type !t ! cannot be derived. <p> This implies that, formally, the strict system is a system in between the two presented in [10]; a significant difference with the restricted system of [10] is that type assignment in the strict system is not relevant in the sense of <ref> [15] </ref>. Although the rather strong restrictions imposed, the provable results for the strict system are very close to those for the system of [6]. For example, the sets of normalizable terms and those having a normal form can be equally elegantly characterized.
Reference: [16] <author> M. Dezani-Ciancaglini and I. Margaria. </author> <title> F-semantics for intersection type discipline. </title> <editor> In G. R. Kahn, D. B. Macqueen, and G. Plotkin, editors, </editor> <booktitle> Semantics of data types. International symposium, Sophia-Antipolis, France, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 279-300. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: In order to prove the `('-part of this statement (completeness), the relation is needed. Other interesting applications of filter -models can be found in [8], [11], <ref> [16] </ref>, and [17].
Reference: [17] <author> M. Dezani-Ciancaglini and I. Margaria. </author> <title> A characterisation of F-complete type assignments. </title> <journal> Theoretical Computer Science, </journal> <volume> 45 </volume> <pages> 121-157, </pages> <year> 1986. </year>
Reference-contexts: In order to prove the `('-part of this statement (completeness), the relation is needed. Other interesting applications of filter -models can be found in [8], [11], [16], and <ref> [17] </ref>. <p> Using the definition of Hindley and Longo [24] it is shown that hF " , , [[ ]] i is a -model. In constructing a complete system, the semantics of types plays a crucial role. As in <ref> [17] </ref>, [29], and essentially following [22], a distinction can be made between several notions of type interpretations and semantic satisfiability. There are, roughly, three notions of type semantics that differ in the meaning of an arrow type scheme: inference type interpretations, simple type interpretations and F type interpretations. <p> It requires a rather difficult notion of length of a 19 derivation to show that this process terminates.) In this paper, this result will be proved using the computability technique, following Tait [36], as was done in [11], and <ref> [17] </ref>.
Reference: [18] <author> E. </author> <title> Engeler. Algebras and combinators. </title> <journal> Algebra universalis, </journal> <volume> 13(3) </volume> <pages> 389-392, </pages> <year> 1981. </year>
Reference-contexts: The strict system gives rise to a strict filter -model F S , that satisfies all major properties of the filter -model F " as presented in [6], but is an essentially different -model, equivalent to Engeler's model D A <ref> [18] </ref>. In [1] was shown that soundness for the notion of type assignment of [6] is lost if instead of simple type semantics, the inference type semantics is used.
Reference: [19] <author> P. Gardner. </author> <title> Discovering Needed Reductions Using Type Theory. </title> <editor> In M. Hagiya and J.C. Mitchell, editors, </editor> <booktitle> Proceedings of TACS '94. International Symposium on Theoretical Aspects of Computer Software, Sendai, Japan, volume 789 of Lecture Notes in Computer Science, </booktitle> <pages> pages 555-597. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: This system is also used in <ref> [19] </ref>. <p> by strict types, and to introduce a separate operation of covering, that deals with the assignment of ! to subterms. 6.1 Relevant intersection type assignment The next definition presents a restricted variant of the essential system, that is similar to that of Definition 1.2.3, and is the system used in <ref> [19] </ref>. Since bases play a more significant role in this system, the presentation of the derivation rules differs from the one used above.
Reference: [20] <author> J.Y. Girard. </author> <title> The System F of Variable Types, Fifteen years later. </title> <journal> Theoretical Computer Science, </journal> <volume> 45 </volume> <pages> 159-192, </pages> <year> 1986. </year>
Reference-contexts: First, a substitution lemma is proved. Notice that, unlike for many other notions of type 18 assignment (Curry's system, the CD-system, the polymorphic type discipline <ref> [20] </ref>), the implication holds in both directions. Lemma 2.9 9 [B; x: ` E M : & B ` E N :] () B ` E M [N=x]:. Proof: By induction on M . <p> In that paper principal typings for the type assignment system as presented in [25] are studied. That system is a combination of the BCD-system and the polymorphic type discipline as presented in <ref> [20] </ref>, and can be seen as an extension of the BCD-system by adding quantification over type-variables. In [27], for every A in ?-normal form a relation A is defined on the inductively defined set of pairs hB; i admissible for A (i.e. such that B ` A:).
Reference: [21] <author> J.R. Hindley. </author> <title> The principal type scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <year> 1969. </year>
Reference-contexts: The type is then called the principal type for M . For Curry's system the operation O consists entirely of substitutions, i.e. operations that replace type-variables by types. Principal type schemes for Curry's system are defined by J.R. Hindley in <ref> [21] </ref>. In this paper the author actually proved the existence of principal types for an object in Combinatory Logic, but the same construction can be used for a proof of the principal type property for terms in Lambda Calculus. The basic idea used in [21] is to define a unification-algorithm, that <p> Hindley in <ref> [21] </ref>. In this paper the author actually proved the existence of principal types for an object in Combinatory Logic, but the same construction can be used for a proof of the principal type property for terms in Lambda Calculus. The basic idea used in [21] is to define a unification-algorithm, that is used to construct the principal type for an application form the principal types deduced for its components.
Reference: [22] <author> J.R. Hindley. </author> <title> The simple semantics for Coppo-Dezani-Salle type assignment. </title> <editor> In M. Dezani and U. Montanari, editors, </editor> <booktitle> International symposium on programming, volume 137 of Lecture Notes in Computer Science, </booktitle> <pages> pages 212-226. </pages> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: Using the definition of Hindley and Longo [24] it is shown that hF " , , [[ ]] i is a -model. In constructing a complete system, the semantics of types plays a crucial role. As in [17], [29], and essentially following <ref> [22] </ref>, a distinction can be made between several notions of type interpretations and semantic satisfiability. There are, roughly, three notions of type semantics that differ in the meaning of an arrow type scheme: inference type interpretations, simple type interpretations and F type interpretations.
Reference: [23] <author> J.R. Hindley. </author> <title> The Completeness Theorem for Typing -terms. </title> <journal> Theoretical Computer Science, </journal> <volume> 22(1) </volume> <pages> 1-17, </pages> <year> 1983. </year>
Reference-contexts: The main result of that paper is that, using this model, completeness is proved by proving the statement: ` " M : () [[ M ]] 2 (), where : T " ! F " is a simple type interpretation as defined in <ref> [23] </ref> (see Definition 1.3.5 (ii)). In order to prove the `('-part of this statement (completeness), the relation is needed. Other interesting applications of filter -models can be found in [8], [11], [16], and [17]. <p> A mapping : T " ! -(D) = fX j X Dg is a type interpretation if and only if: a) f" d j 8 e 2 () [d e 2 (t )]g (!t ). c) ("t ) = () " (t ). ii) Following <ref> [23] </ref>, a type interpretation is simple if also: (!t ) = fd j8 e 2 () [d e 2 (t )]g. iii) A type interpretation is called an F type interpretation if it satisfies: (!t ) = f" d j 8 e 2 () [d e 2 (t )]g.
Reference: [24] <author> R. Hindley and G. Longo. </author> <title> Lambda calculus models and extensionality. </title> <journal> Zeitschrift f ur Mathematische Logik und Grundlagen der Mathematik, </journal> <volume> 26 </volume> <pages> 289-310, </pages> <year> 1980. </year>
Reference-contexts: For M 2 L define [[ M ]] ~ = f j B ~ ` " M :g. Using the definition of Hindley and Longo <ref> [24] </ref> it is shown that hF " , , [[ ]] i is a -model. In constructing a complete system, the semantics of types plays a crucial role. As in [17], [29], and essentially following [22], a distinction can be made between several notions of type interpretations and semantic satisfiability.
Reference: [25] <author> B. Jacobs, I. Margaria, and M. Zacchi. </author> <title> Filter Models with Polymorphic Types. </title> <journal> Theoretical Computer Science, </journal> <volume> 95 </volume> <pages> 143-158, </pages> <year> 1992. </year>
Reference-contexts: As mentioned above, the operation of covering defined here is inspired by the relation &lt; ~ on terms in N, and, in fact, is very close to a notion defined in [27]. In that paper principal typings for the type assignment system as presented in <ref> [25] </ref> are studied. That system is a combination of the BCD-system and the polymorphic type discipline as presented in [20], and can be seen as an extension of the BCD-system by adding quantification over type-variables.
Reference: [26] <author> D. Leivant. </author> <title> Polymorphic Type Inference. </title> <booktitle> In Proceedings 10 th ACM Symposium on Principles of Program ming Languages, </booktitle> <address> Austin Texas, </address> <pages> pages 88-98, </pages> <year> 1983. </year>
Reference-contexts: A disadvantage of the BCD-system is that type assignment in this system is undecidable. In recent years, some decidable restrictions have been studied. The first was the Rank2 intersection type assignment system [2], as first suggested by D. Leivant in <ref> [26] </ref>, that is very close to the notion of type assignment as used in ML.
Reference: [27] <author> I. Margaria and M. Zacchi. </author> <title> Principal Typing in a 8"-Discipline. </title> <journal> Logic and Computation. </journal> <note> To appear. </note>
Reference-contexts: As mentioned above, the operation of covering defined here is inspired by the relation &lt; ~ on terms in N, and, in fact, is very close to a notion defined in <ref> [27] </ref>. In that paper principal typings for the type assignment system as presented in [25] are studied. That system is a combination of the BCD-system and the polymorphic type discipline as presented in [20], and can be seen as an extension of the BCD-system by adding quantification over type-variables. In [27], <p> <ref> [27] </ref>. In that paper principal typings for the type assignment system as presented in [25] are studied. That system is a combination of the BCD-system and the polymorphic type discipline as presented in [20], and can be seen as an extension of the BCD-system by adding quantification over type-variables. In [27], for every A in ?-normal form a relation A is defined on the inductively defined set of pairs hB; i admissible for A (i.e. such that B ` A:).
Reference: [28] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: These two properties found their way into programming, mainly through the pioneering work of R. Milner <ref> [28] </ref>. He introduced a functional programming language ML, of which the underlying type system is an extension of Curry's system. The extension consists of the introduction of polymorphic functions, i.e. functions that can be applied to various kinds of arguments, even of incomparable type.
Reference: [29] <author> J.C. Mitchell. </author> <title> Polymorphic Type Inference and Containment. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 211-249, </pages> <year> 1988. </year>
Reference-contexts: Using the definition of Hindley and Longo [24] it is shown that hF " , , [[ ]] i is a -model. In constructing a complete system, the semantics of types plays a crucial role. As in [17], <ref> [29] </ref>, and essentially following [22], a distinction can be made between several notions of type interpretations and semantic satisfiability. There are, roughly, three notions of type semantics that differ in the meaning of an arrow type scheme: inference type interpretations, simple type interpretations and F type interpretations.
Reference: [30] <author> B.C. Pierce. </author> <title> Programming with Intersection Types and Bounded Polymorphism. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, School of Computer Science, Pitssburgh, </institution> <year> 1991. </year> <month> CMU-CS-91-205. </month>
Reference: [31] <author> B.C. Pierce. </author> <title> Intersection Types and Bounded Polymorphism. </title> <editor> In M. Bezem and J.F. Groote, editors, </editor> <booktitle> Proceedings of TLCA '93. International Conference on Typed Lambda Calculi and Applications, Utrecht, the Netherlands, volume 664 of Lecture Notes in Computer Science, </booktitle> <pages> pages 346-360. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [32] <author> J.C. Reynolds. </author> <title> The essence of Algol. </title> <editor> In J.W. de Bakker and J.C. van Vliet, editors, </editor> <booktitle> Algorithmic languages, </booktitle> <pages> pages 345-372. </pages> <publisher> North-Holland, </publisher> <year> 1981. </year>
Reference-contexts: That intersection types can be used as a basis for programming languages was first discussed by J. Reynolds in <ref> [32] </ref>. This led to the development of the (typed) programming language Forsythe [33], and to the work of B.C. Pierce [30,31], who studied intersection types and bounded polymor-phism in the field of typed lambda calculi. Because there only typed systems are considered, the systems are decidable.
Reference: [33] <author> J.C. Reynolds. </author> <title> Preliminary design of the programming language Forsythe. </title> <type> Technical Report CMU-CS-88 159, </type> <institution> Carnegie Mellon University, Pitssburgh, </institution> <year> 1988. </year>
Reference-contexts: That intersection types can be used as a basis for programming languages was first discussed by J. Reynolds in [32]. This led to the development of the (typed) programming language Forsythe <ref> [33] </ref>, and to the work of B.C. Pierce [30,31], who studied intersection types and bounded polymor-phism in the field of typed lambda calculi. Because there only typed systems are considered, the systems are decidable.
Reference: [34] <author> S. Ronchi della Rocca and B. Venneri. </author> <title> Principal type schemes for an extended type theory. </title> <journal> Theoretical Computer Science, </journal> <volume> 28 </volume> <pages> 151-169, </pages> <year> 1984. </year> <month> 46 </month>
Reference-contexts: Moreover, in [6] the relation induced an equivalence relation ~ on types. Equivalence classes are big (for example: ! ~ (!!), for all types ) and type assignment is closed for ~. The BCD-system has the principal type property, as was shown in <ref> [34] </ref>; the set of operations needed for this system consists of substitutions, expansions, and rises; although for every M the set fhB; i j B ` M :g can be generated using those operations specified in [34], the problem of type-checking Given a term M and type , is there a <p> The BCD-system has the principal type property, as was shown in <ref> [34] </ref>; the set of operations needed for this system consists of substitutions, expansions, and rises; although for every M the set fhB; i j B ` M :g can be generated using those operations specified in [34], the problem of type-checking Given a term M and type , is there a basis B such that B ` M :? 2 is complicated. This is not only due to the undecidability of the problem, but even a semi-algorithm is difficult to define, due to the equivalence relation. <p> For three of these systems presented in the past (one CDV system, the BCD system and the strict system) the principal type property has been shown to hold in, respectively, [9], <ref> [34] </ref>, and [4]; in Section 5 the constructions of the proofs of the various papers will be discussed. Finally, in Section 6, the proof for the principal type property for the essential system will be sketched. <p> To conclude, notice that, if B ` E (x:M )N :, then, by Lemma 2.5 (ii) & (iii), 9 [B; x: ` E M : & B ` E N :]. The result follows then by applying Lemma 2.9. 3 Approximation and normalization results In <ref> [34] </ref> an approximation theorem is proved, that formulates the relation between the types assignable to a term and those assignable to its approximants, as defined in [37] (see Definition 3.1.1 below). <p> In this section, an `essential' variant of this property will be proved; for every M; B and such that B ` E M :, there is an A 2 A (M ) such that B ` E A:. In <ref> [34] </ref> this result is obtained through a normalization of derivations, where all (!I)-(!E) pairs, that derive a type for a redex (x:M )N , are replaced by one for its reduct M [N=x], and all pairs of ("I)-("E) are eliminated. (This technique is also used in [9] and [6]. <p> There exist three intersection systems for which the principal type property is proved: a CDV-system in [9], the BCD-system in <ref> [34] </ref>, and the strict system in [4]. The technique used for the proofs of these properties is very different for the one used for Curry's sytem. The principal type scheme for a term is in [9], [34], and [4] studied through the notion of approximant of a term; terms with a <p> which the principal type property is proved: a CDV-system in [9], the BCD-system in <ref> [34] </ref>, and the strict system in [4]. The technique used for the proofs of these properties is very different for the one used for Curry's sytem. The principal type scheme for a term is in [9], [34], and [4] studied through the notion of approximant of a term; terms with a finite number of approximants have finite principal type schemes, while terms with a infinite number of approximants have `infinite' principal type schemes. <p> This technique is the same as for example used in <ref> [34] </ref>, [4], and Section 6 of this paper. The set of ground pairs for a term A 2 N, as defined in [9], is proved to be complete for A, in the sense that all other pairs for A can be generated from a ground pair for A. <p> 1 )i = which is, by the results mentioned above, a ground pair for (x:x?(y:y)). [x : !!(' 2 !' 2 )"(' 3 !' 3 )!' 1 ] [y : ' 2 ] [y : ' 3 ] x?(y:y) : ' 1 (See Definition 6.2.5.) 30 5.3 The system of <ref> [34] </ref> For the system as defined in [6], principal type schemes can be defined as in [34]. There three operations are provided substitution, expansion, and rise that are sound and sufficient to generate all suitable pairs for a term M from its principal pair. <p> : !!(' 2 !' 2 )"(' 3 !' 3 )!' 1 ] [y : ' 2 ] [y : ' 3 ] x?(y:y) : ' 1 (See Definition 6.2.5.) 30 5.3 The system of <ref> [34] </ref> For the system as defined in [6], principal type schemes can be defined as in [34]. There three operations are provided substitution, expansion, and rise that are sound and sufficient to generate all suitable pairs for a term M from its principal pair. In this paper, all constructions and definitions are made modulo the equivalence relation ~. <p> In fact, the complexity inserted in the type language of [6] by allowing for intersection types on the right of the arrow type constructor, disturbs greatly the accessibility of this paper. As shown in Section 6, the results of <ref> [34] </ref> can also be obtained for the essential system presented here, that is equally powerful. The first operation defined is substitution, that is defined without restriction: the type that is to be substituted can be every element of T " . <p> Then B 0 ` " A: 0 . Linear chains of operations are defined as sequences of operations that start with a number of expansions, followed by a number of substitutions, and that end with one rise. (In <ref> [34] </ref>, linear chains are defined as those sequences of operations that start with a number of expansions, followed by a number of substitutions or rises; both are allowed. <p> In that paper, three operations on pairs of basis and types are defined: substitution, expansion, and lifting. The operation of lifting resembles the operation of rise as defined in <ref> [34] </ref>, the operation of substitution is a modification of the one normally used, and the operation of expansion coincides with the one 31 given in [9,34]. <p> The operation of expansion, as defined in [4], corresponds to the one given in [9] and is a simplified version of the one defined in <ref> [34] </ref>. A difference is that in those definitions subtypes are collected, whereas the definition of expansion in [4] (see Definition 6.2.5) collects type-variables. Recall Definition 2.1. <p> As in <ref> [34] </ref>, this result is then generalized to arbitrary lambda terms (see Property 5.3.1 and Theorem 6.3.6). 6 Principal type property for the essential system Using a technique different from those discussed above, in this section the proof for the principal type property of the essential system will be given. <p> The most significant difference between proofs for the principal type property made in other papers and the one presented here, is that, in a certain sense, the operations presented in this section are more elegant. In <ref> [34] </ref>, there is an overlap between operations; for example, intersections can be introduced by expansions as well as by substitutions and rise. Also, in [4] the step from the 33 pair hB; i to hB; !i can be made using a lifting as well as a substitution. <p> Proof: Easy. The notion of principal pairs for terms in N will be generalized to arbitrary lambda terms in Definition 6.3.5. 35 The principal pairs in the systems as presented in [9], <ref> [34] </ref>, and [4] are exactly the same. <p> The operation of expansion of types defined here corresponds to the notion of expansion as defined in <ref> [34] </ref> and [4]. A difference between the notions of expansion as defined in [9] and [34] is that in those papers a set of types involved in the expansion is created. <p> The operation of expansion of types defined here corresponds to the notion of expansion as defined in <ref> [34] </ref> and [4]. A difference between the notions of expansion as defined in [9] and [34] is that in those papers a set of types involved in the expansion is created. <p> Like in [9,34,4], it can be proved that there exists a precise relation between terms in N and principal pairs, both equipped with an appropriate ordering. This relation is in <ref> [34] </ref> defined using substitution of type-variables by the type constant !. Using the notion of substitution defined here, this approach cannot be taken; instead, the relation on pairs as given in Definition 6.2.12 is used. Theorem 6.3.4 hP; i is a meet semilattice isomorphic to hN; &lt; ~ i.
Reference: [35] <author> P. </author> <title> Salle. Une extension de la theorie des types. </title> <editor> In G. Ausiello and C. Bohm, editors, </editor> <booktitle> Automata, languages and programming. Fifth Colloquium, Udine, Italy, volume 62 of Lecture Notes in Computer Science, </booktitle> <pages> pages 398-410, </pages> <address> Udine, Italy, 1978. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The first type discipline as presented in [10] (a similar system was presented in <ref> [35] </ref>) is a true extension of the one presented in [7]; the second one limits the use of intersection types in bases.
Reference: [36] <author> W.W. Tait. </author> <title> Intensional interpretation of functional of finite types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 32, </volume> <year> 1967. </year>
Reference-contexts: It requires a rather difficult notion of length of a 19 derivation to show that this process terminates.) In this paper, this result will be proved using the computability technique, following Tait <ref> [36] </ref>, as was done in [11], and [17].
Reference: [37] <author> C.P. Wadsworth. </author> <title> The relation between computational and denotational properties for Scott's D 1 -models of the lambda-calculus. </title> <journal> SIAM J. Comput., </journal> <volume> 5 </volume> <pages> 488-521, </pages> <year> 1976. </year> <month> 47 </month>
Reference-contexts: The result follows then by applying Lemma 2.9. 3 Approximation and normalization results In [34] an approximation theorem is proved, that formulates the relation between the types assignable to a term and those assignable to its approximants, as defined in <ref> [37] </ref> (see Definition 3.1.1 below). Property 3.1 B ` " M : if and only if there exists A 2 A (M ) such that B ` " A:. <p> Wadsworth <ref> [37] </ref> and is defined using the notion of terms in ?-normal form (like in [5], ? is used, instead of W; also, the symbol &lt; ~ is used as a relation on L?-terms, inspired by a similar relation defined on Bohm-trees in [5]).
References-found: 37

