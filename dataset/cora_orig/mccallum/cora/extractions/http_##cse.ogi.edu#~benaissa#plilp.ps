URL: http://cse.ogi.edu/~benaissa/plilp.ps
Refering-URL: http://www.cse.ogi.edu/~benaissa/
Root-URL: http://www.cse.ogi.edu
Title: Modeling Sharing and Recursion for Weak Reduction Strategies using Explicit Substitution  
Author: Zine-El-Abidine Benaissa, Pierre Lescanne, and Kristoer Hgsbro Rose 
Keyword: Implementation of functional programming, lambda calcu lus, weak reduction, explicit substitution, sharing, recursion, space leaks.  
Note: w and use this to detne a space leak free calculus; this suggests optimisations for call-by-need reduction that prevent space leaking and enables us to prove that the trimming performed  
Address: Nancy, France  
Affiliation: INRIA Lorraine CRIN,  
Abstract: We present the a w -calculus, a formal synthesis of the concepts of sharing and explicit substitution for weak reduction. We show how a w can be used as a foundation of implementations of functional programming languages by modeling the essential ingredients of such implementations, namely weak reduction strategies, recursion, space leaks, recursive data structures, and parallel evaluation. We use a w to give a united model of several computational aspects. First, we give a precise account of the major reduction strategies used in functional programming and the consequences of choosing -graph-reduction vs. environment-based evaluation. Second, we show how to add constructors and explicit recursion to give a precise account of recursive functions and data structures even with respect to space complexity. Third, we formalize the notion of space leaks in a by the STG machine does not leak space. In summary we give a formal account of several implementation techniques used by state of the art implementations of functional programming languages.
Abstract-found: 1
Intro-found: 1
Reference: <author> Ariola, Z. M., Felleisen, M., Maraist, J., Odersky, M. and Wadler, P. </author> <year> (1995). </year> <title> A call-by-need lambda calculus. </title> <booktitle> 22nd POPL. </booktitle> <address> San Francisco, California. </address> <pages> pp. 233246. </pages>
Reference: <author> Ariola, Z. M. and Klop, J. W. </author> <year> (1994). </year> <title> Cyclic lambda graph rewriting. LICS. </title> <publisher> IEEE Computer Society Press. </publisher> <address> Paris, France. </address> <pages> pp. 416425. </pages>
Reference-contexts: Another solution consists in delaying unfolding until needed. The trick is to augment the explicit "horizontal" sharing that we have introduced in previous sections through addresses with explicit "vertical" sharing <ref> (using the terminology of Ariola and Klop 1994) </ref>.
Reference: <author> Bloo, R. and Rose, K. H. </author> <year> (1995). </year> <title> Preservation of strong normalisation in named lambda calculi with explicit substitution and garbage collection. </title> <booktitle> CSN '95 Computer Science in the Netherlands. </booktitle> <pages> pp. 6272. </pages> <address> hurl: ftp://ftp.diku.dk/diku/semantics/papers/ D-246.psi Curien, P.-L. </address> <year> (1991). </year> <title> An abstract framework for environment machines. </title> <booktitle> Theoretical Computer Science 82: </booktitle> <pages> 389402. </pages>
Reference: <author> Curien, P.-L., Hardin, T. and Lvy, J.-J. </author> <title> (to appear). Conuence properties of weak and strong calculi of explicit substitutions. </title> <note> J.ACM . Also INRIA rep.1617 (1992). </note> <author> de Bruijn, N. G. </author> <year> (1972). </year> <title> Lambda calculus with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser theorem. </title> <journal> Proc. Koninkl. Nederl. Akademie van Wetenschappen 75(5): </journal> <volume> 381392. </volume>
Reference: <author> Felleisen, M. and Friedman, D. P. </author> <year> (1989). </year> <title> A syntactic theory of sequential state. </title> <booktitle> Theoretical Computer Science 69: </booktitle> <pages> 243287. </pages>
Reference-contexts: The trick is to augment the explicit "horizontal" sharing that we have introduced in previous sections through addresses with explicit "vertical" sharing (using the terminology of Ariola and Klop 1994). We have chosen to do this using the * a "back pointer" syntax of Rose (1996) <ref> (the notation first described by Felleisen and Friedman 1989) </ref>: reducing a fixed point operator places a * at the location where unfolding should happen when (if) it is needed. The difference is illustrated on the right. Consider the initial term with a large (shaded) -redex containing a smaller (white) redex.
Reference: <author> Huet, G. and Lvy, J.-J. </author> <year> (1991). </year> <title> Computations in orthogonal rewriting systems, II. </title> <editor> In Lassez, J.-L. and Plotkin, G. (eds), </editor> <booktitle> Computational Logic. </booktitle> <publisher> The MIT press. </publisher> <pages> Chapter 12: pp. 415443. </pages>
Reference-contexts: Let 0 = fApp; RVar; VarIdg. Then g = 0 [ fFVarGg and e = 0 [ fFVarEg. A consequence of mixing those two systems is the creation of a critical pair (non-determinism) and thus non-orthogonality. Fortunately, since this critical pair is at the root, the residual redex notion <ref> (Huet and Levy 1991) </ref> can be extended in a straight-forward way: We just observe that there is no residual redex of FVarG (resp. FVarE) after applying FVarE (resp. FVarG). We first establish that this is safe before we give the definition (Def. 7). Detnition 3.
Reference: <author> Klop, J. W. </author> <year> (1990). </year> <title> Term Rewriting Systems. </title> <editor> In Abramsky, S., Gabbay, D. and Maibaum, T. (eds), </editor> <booktitle> Handbook of Logic in Computer Science. </booktitle> <volume> Vol. 1. </volume> <publisher> Oxford University Press. </publisher> <address> Chapter 6. </address>
Reference: <author> Launchbury, J. </author> <year> (1993). </year> <title> A natural semantics for lazy evaluation. </title> <booktitle> 20th POPL. </booktitle> <pages> pp. 144 154. </pages>
Reference: <author> Maranget, L. </author> <year> (1991). </year> <title> Optimal Derivations in Weak Lambda Calculi and in Orthogonal Rewriting Systems. </title> <booktitle> 18th POPL. </booktitle> <pages> pp. 255268. </pages>
Reference: <author> Peyton Jones, S. L. </author> <year> (1992). </year> <title> Implementing lazy functional programming languages on stock hardware: </title> <journal> the spineless tagless g-machine. Journal of Functional Programming 2(2): </journal> <volume> 127202. </volume>
Reference-contexts: The STG machine computes <ref> (see Peyton Jones 1992, section 5.3) </ref> that expression by placing the N i 's in the heap and then trimming the associated environment w.r.t. each N i . This obviously corresponds to n applications of TAppN.
Reference: <author> Plotkin, G. D. </author> <year> (1975). </year> <title> Call-by-name, call-by-value, and the -calculus. </title> <booktitle> Theoretical Computer Science 1: </booktitle> <pages> 125159. </pages>
Reference: <author> Rose, K. H. </author> <year> (1996). </year> <title> Operational Reduction Models for Functional Programming Languages. </title> <type> PhD thesis. </type> <institution> DIKU. </institution> <note> Universitetsparken 1, DK-2100 Kbenhavn . DIKU report 96/1. </note>
Reference: <author> Sestoft, P. </author> <year> (1994). </year> <title> Deriving a lazy abstract machine. </title> <type> Technical Report ID-TR 1994-146. </type> <institution> Dept. of Computer Science, Technical University of Denmark. hurl: ftp://ftp.dina.kvl.dk/pub/Sta/Peter.Sestoft/papers/amlazy4.dvi.gz i Wadsworth, </institution> <address> C. </address> <year> (1971). </year> <title> Semantics and pragmatics of the lambda calculus. </title> <type> PhD thesis. </type> <month> Oxford. </month> <title> This article was typeset using the L A T E X macro package with the LLNCS2E class. </title>
Reference-contexts: Detnition 24. Garbage-free terms are characterized by the requirement that for every subterm M [s] a , s = sj fi (M) . Proposition 25. If T // C addr (T ) U , then U is a garbage-free term. Space leak freeness <ref> (first precisely formulated for a lazy abstract machine by Sestoft 1994) </ref> means that every Collect-redex will eventually disappear in a computation. In other words, no unreachable subterm stays indefinitely. Detnition 26 (space leak free reduction).
References-found: 13

