URL: http://www.cs.cmu.edu/afs/cs/project/iwarp/archive/fx-papers/cmu-cs-96-106.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/gyl/www/publications.html
Root-URL: 
Title: Global Register Allocation Based on Graph Fusion  
Author: Guei-Yuan Lueh, Thomas Gross, and Ali-Reza Adl-Tabatabai 
Note: This research was sponsored in part by the Advanced Research Projects Agency/ITO monitored by SPAWAR under contract N00039-93-C-0152. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of ARPA, SPAWAR, or the U.S. Government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: March 1996  
Pubnum: CMU-CS-96-106  
Abstract: A register allocator must effectively deal with three issues: live range splitting, live range spilling, and register assignment. This paper presents a new coloring-based global register allocation algorithm that addresses all three issues in an integrated way: the algorithm starts with an interference graph for each region of the program, where a region can be a basic block, a loop nest, a superblock, a trace, or another combination of basic blocks. Region formation is orthogonal to register allocation in this framework. Then the interference graphs for adjacent regions are fused to build up the complete interference graph. The algorithm delays decisions on splitting, spilling, and register assignment, and therefore, the register allocation may be better than what is obtained by a Chatin-style allocator. This algorithm uses execution probabilities, derived from either profiles or static estimates, to guide fusing interference graphs, allowing an easy integration of this register allocator into a region-based compiler. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Bernstein, D. Q. Goldin, M. C. Golumbic, H. Krawczyk, Y. Mansour, I. Nahshon, and R. Y. Pinter. </author> <title> Spill code minimization techniques for optimizing compilers. </title> <booktitle> In Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 258-263. </pages> <publisher> ACM, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: Since registers must also be assigned to spill code, the process of building the interference graph and performing simplification is repeated until no more spilling is necessary. Several refinements to this basic algorithm have been implemented. The coloring based register allocation algorithm used in the RS/6000 compiler <ref> [1] </ref> improves on this basic algorithm in two ways. First, the interference graph is colored three times, each time using a variation of the cost function, and the coloring with the least resulting total spill cost is selected. <p> And if M N &gt; T , we must spill some non-transparent live ranges, which are selected by a heuristic based on spill cost, area, and the degrees in the interference graph <ref> [1] </ref>. We now describe in more detail the delayed spilling technique used to handle the case where M N &lt; T . Since all transparent live ranges conflict with each other, these live ranges form a clique in a region's interference graph.
Reference: [2] <author> P. Briggs. </author> <title> Register Allocation via Graph Coloring. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Besides, despite all the attempts to improve spill code, in practice there are situations where splitting produces better results <ref> [2] </ref>. It is difficult to adopt live range splitting into Chaitin's approach. Since the interference graph does not encode information about the program control flow structure and reference patterns of live ranges, this graph cannot be used to guide partitioning of live ranges. <p> The motivation is to reduce the degree of the interference graph and to allow the spilling of only those live range segments that span program regions of high register pressure. Aggressive live range splitting <ref> [2] </ref> uses the Static Single Assignment (SSA) representation of a program to determine split points. A live range is split at a node when the incoming values to the node result from distinct assignments. <p> Thus, live ranges are split unnecessarily, resulting in a performance degradation due to unnecessary shuffle code. Various heuristics have been developed to eliminate shuffle code by increasing the chance that the same color is given to partner live ranges, e.g., biased-coloring or conservative coalescing <ref> [2] </ref>. Rather than determining the critical regions where splitting and spilling are beneficial, these approaches split live ranges arbitrarily and greedily, with the hopes that later heuristical steps will clean up unnecessary splits. <p> While a general partial redundancy elimination algorithm could be used to optimize the shuffle code, a simple technique is effective in practice, details of which are discussed in Section 5. There exist further opportunities for improving the code in this phase: biased coloring <ref> [2] </ref> may eliminate shuffle code, optimistic coloring [3] may assign registers to live ranges that have been spilled by simplification, and if we notice that a live range gets a caller-saved register in a region with high call frequency, then the register assigner may decide to spill this live range nevertheless.
Reference: [3] <author> P. Briggs, K. D. Cooper, K. Kennedy, and L. Torczon. </author> <title> Coloring heuristics for register allocation. </title> <booktitle> In Proc. SIGPLAN Symp. on Programming Language Design and Implementation, </booktitle> <pages> pages 275-284. </pages> <publisher> ACM, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: This process blocks when either all vertices have degree greater than N (the number of registers) [5] or when no legal color exists for a node <ref> [7, 3] </ref>. When coloring blocks, the compiler must somehow lower the maximum degree of the vertices in the interference graph to allow coloring to proceed. <p> In effect, L is split into segments that span at most a basic block. Simplification is a heuristic approach to coloring, and as such may miss legal coloring opportunities. Optimistic coloring <ref> [3] </ref> improves simplification by attempting to assign colors to live ranges that would have been spilled by the basic algorithm. Optimistic coloring delays spill decisions until the register assignment phase. <p> There exist further opportunities for improving the code in this phase: biased coloring [2] may eliminate shuffle code, optimistic coloring <ref> [3] </ref> may assign registers to live ranges that have been spilled by simplification, and if we notice that a live range gets a caller-saved register in a region with high call frequency, then the register assigner may decide to spill this live range nevertheless. 4 Fusing two interference graphs Consider two
Reference: [4] <author> D. Callahan and B. Koblenz. </author> <title> Register allocation via hierarchical graph coloring. </title> <booktitle> In Proc. SIGPLAN'91 on Programming Language Design and Implementation, </booktitle> <pages> pages 192-203, </pages> <address> Toronto, </address> <month> June </month> <year> 1991. </year> <note> ACM. </note>
Reference-contexts: This framework allows us to model a number of different approaches to register allocation <ref> [4, 9, 16] </ref>, including the classical Chaitin-style register allocation [5] if a region is a function. The key idea of our approach is to incrementally build up the interference graph. Consider the task of allocating registers for a compilation unit, e.g., a function. <p> The register allocator than colors regions in order of their priorities, and shuffle is code is inserted at the boundaries of these regions. Representative program structure based approaches include the Tera <ref> [4] </ref>, Multiflow [9] and RAG [16] compilers. The Tera compiler (as described in [4]) constructs a tile tree for a program; this tree corresponds to the control-flow hierarchy of the program. Register allocation colors the tiles in two phases. <p> The register allocator than colors regions in order of their priorities, and shuffle is code is inserted at the boundaries of these regions. Representative program structure based approaches include the Tera <ref> [4] </ref>, Multiflow [9] and RAG [16] compilers. The Tera compiler (as described in [4]) constructs a tile tree for a program; this tree corresponds to the control-flow hierarchy of the program. Register allocation colors the tiles in two phases. <p> If lr 0 (x) and lr (x) use the same pseudo register, no shuffle code is required, but that this mapping is beneficial can only be determined when dealing with B 6 . This paper presents an approach to address this deficiency by delaying binding decisions. In contrast to <ref> [4] </ref>, our algorithm takes a lazy approach to color assignment so as to avoid premature coloring decisions. Instead of a tile tree, the RAG compiler colors the region nodes in a function's Program Dependence Graph (PDG), proceeding in a hierarchical manner from the leaves to the root [16]. <p> In the region formation phase, regions are formed using any number of possible techniques. For example, a region can be a single basic block, a trace [15], a superblock [11], a region as defined in [10], the blocks at a particular static loop nesting level <ref> [4] </ref>, or the blocks within a PDG region node [16]. Control flow edges that lie outside of regions are then ordered according to some priority function consistent with the region formation approach, e.g., edges entering innermost loop regions are ordered before those entering outermost loop regions.
Reference: [5] <author> G. J. Chaitin, M. A. Auslander, A. K. Chandra, J. Cocke, M. E. Hopkins, and P. W. Markstein. </author> <title> Register allocation by coloring. </title> <type> Research Report 8395, </type> <institution> IBM Watson Research Center, </institution> <year> 1981. </year>
Reference-contexts: All functions called by the main loop of this program are inlined. On the left, we see the number of data movement operations for an enhanced Chaitin-style register allocator <ref> [5] </ref>. In the middle, we see the results for the approach described in this paper which removes about 50 % of the data movement operations compared to a Chaitin-style register allocator. <p> This framework allows us to model a number of different approaches to register allocation [4, 9, 16], including the classical Chaitin-style register allocation <ref> [5] </ref> if a region is a function. The key idea of our approach is to incrementally build up the interference graph. Consider the task of allocating registers for a compilation unit, e.g., a function. <p> This process blocks when either all vertices have degree greater than N (the number of registers) <ref> [5] </ref> or when no legal color exists for a node [7, 3]. When coloring blocks, the compiler must somehow lower the maximum degree of the vertices in the interference graph to allow coloring to proceed. <p> Then, liveness analysis and reaching analysis determine the live range for each virtual register. Live ranges that are constructed in this manner, however, may be comprised of disjoint 2 segments, resulting in an unnecessarily high number of conflicts for a live range. Renumbering <ref> [5] </ref> and web analysis [12] are two techniques to construct concise live ranges, which result in interference graphs of potentially lower degree.
Reference: [6] <author> P. P. Chang, S. A. Mahlke, W. Y. Chen, N. J. Warter, and W. W. Hwu. </author> <title> Impact: An architectural framework for multiple-instruction-issue processors. </title> <booktitle> In Proc. 18th Intl. Symp. on Computer Architecture, </booktitle> <pages> pages 266-275. </pages> <address> ACM/IEEE, </address> <month> May </month> <year> 1991. </year> <month> 17 </month>
Reference-contexts: Regions can be individual basic blocks, traces [15], superblocks [11], or any other grouping used in the compiler (e.g., the loop structure). This framework fits nicely into code generators that take a similar approach to instruction scheduling <ref> [15, 6] </ref>: the register allocator now uses the same units of compilation and the same execution probability estimates as the instruction scheduler.
Reference: [7] <author> F. C. Chow and J. L. Hennessy. </author> <title> A priority-based coloring approach to register allocation. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 12 </volume> <pages> 501-535, </pages> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: This process blocks when either all vertices have degree greater than N (the number of registers) [5] or when no legal color exists for a node <ref> [7, 3] </ref>. When coloring blocks, the compiler must somehow lower the maximum degree of the vertices in the interference graph to allow coloring to proceed. <p> Candidates can be user variables, constants, or compiler generated temporaries, depending on the strategy chosen <ref> [7] </ref>. Then, liveness analysis and reaching analysis determine the live range for each virtual register. Live ranges that are constructed in this manner, however, may be comprised of disjoint 2 segments, resulting in an unnecessarily high number of conflicts for a live range. <p> That is, the register allocator runs the risk of either splitting too much (leading to unnecessary shuffle code), or not enough (with the consequence that high-frequency live ranges are spilled). 2.3 Priority-based coloring The priority-based coloring <ref> [7] </ref> approach is an alternative framework that allows splitting decisions to be delayed until coloring blocks. In contrast to Chaitin's approach, where the register allocator assigns physical registers to virtual registers, this approach begins with each live range assigned a home location in memory. <p> This priority function can be based on either profile information or static estimates, e.g., live ranges that have references within deeply nested-loops can be given high priority <ref> [7] </ref>. Before colors are assigned, unconstrained live ranges are removed from the interference graph, since unconstrained live ranges can always be assigned a legal color, after colors have been assigned to other live ranges. Unlike simplification, the degree of nodes neighboring the removed unconstrained nodes are not decremented. <p> Splitting forms a new live range L 0 by starting from a seed live unit and incrementally adding live units to the new live range until adding one more live unit renders L 0 uncolorable. In <ref> [7] </ref>, live units are added in a breadth-first traversal of the control flow graph, preferably starting from a live unit where the first reference to 4 V is a definition. <p> Shuffle code induced by a split may end up, e.g., on a loop back arc. Code motion techniques are used after register assignment, to optimize placement of shuffle code <ref> [7] </ref>. 2.4 Program structure based approaches Several more recent approaches to register allocation attempt to make graph coloring sensitive to program structure by dividing a program into regions and prioritizing the regions according to execution probabilities. <p> One particularly attractive priority function is the use of execution probabilities. These can be derived either from profile information [8, 18], from static estimates such as loop nesting depth <ref> [7] </ref>, or from static branch estimates [15]. <p> is that all values can be kept in registers with an additional register move instruction at the end of block B 3 . 4.2 Splitting to reduce call cost Dividing the registers into two sets, callee-save and caller-save registers, provides the register allocation more freedom when minimizing the call overhead <ref> [7] </ref>. There is a cost associated with each kind of register assigned to a live range. When a live range lr ends up in a caller-save register, we must pay the cost of saving and restoring lr's value at all function calls that are crossed by lr.
Reference: [8] <author> J. A. Fisher and S. M. Freudenberger. </author> <title> Predicting conditional branch direction from previous runs of a program. </title> <booktitle> In Proc. Fifth Intl. Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS V), </booktitle> <pages> pages 85-97. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1992. </year>
Reference-contexts: One particularly attractive priority function is the use of execution probabilities. These can be derived either from profile information <ref> [8, 18] </ref>, from static estimates such as loop nesting depth [7], or from static branch estimates [15].
Reference: [9] <author> S. Freudenberger and J. Ruttenberg. </author> <title> Phase ordering of register allocation and instruction scheduling. </title> <editor> In R. Giegerich and S. L. Graham, editors, </editor> <title> Code Generation Concepts, </title> <booktitle> Tools, Techniques, </booktitle> <pages> pages 146-170. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This framework allows us to model a number of different approaches to register allocation <ref> [4, 9, 16] </ref>, including the classical Chaitin-style register allocation [5] if a region is a function. The key idea of our approach is to incrementally build up the interference graph. Consider the task of allocating registers for a compilation unit, e.g., a function. <p> The register allocator than colors regions in order of their priorities, and shuffle is code is inserted at the boundaries of these regions. Representative program structure based approaches include the Tera [4], Multiflow <ref> [9] </ref> and RAG [16] compilers. The Tera compiler (as described in [4]) constructs a tile tree for a program; this tree corresponds to the control-flow hierarchy of the program. Register allocation colors the tiles in two phases. <p> The Multiflow compiler employs trace scheduling as a framework for both register allocation and schedul 5 ing <ref> [9] </ref>. The trace scheduler picks a trace and then passes it to the code scheduler; the code scheduler then performs register allocation and scheduling together. The code scheduler records register usage preferences for the scheduled trace; this information is maintained for each exit from or entry into a trace.
Reference: [10] <author> R. Hank, W. Hwu, and B. Rau. </author> <title> Region-based compilation: An introduction and motivation. </title> <booktitle> In Proc. 28th Annual ACM/IEEE Intl. Symposium on Microarchitecture, page (to appear), </booktitle> <address> Ann Arbor, </address> <month> Nov </month> <year> 1995. </year> <month> ACM/IEEE. </month>
Reference-contexts: A simple enhancement, based on the observation that using caller-saved or callee-saved registers implies different costs, improves the results further and reduces the data movement overhead by 80%, as shown on the right. The framework presented in this paper is region-based <ref> [10] </ref>: the register allocator operates on groups of basic blocks formed using either profile information or static analysis. The register allocator does not dictate how these regions are formed and thus provides a general and flexible approach to register allocation; form and priorities of regions are parameters to our algorithm. <p> In the region formation phase, regions are formed using any number of possible techniques. For example, a region can be a single basic block, a trace [15], a superblock [11], a region as defined in <ref> [10] </ref>, the blocks at a particular static loop nesting level [4], or the blocks within a PDG region node [16].
Reference: [11] <author> W. W. Hwu, S. A. Mahlke, W. Y. Chen, P. P. Chang, N. J. Warter, R. A. Bringmann, R. O. Ouellette, R. E. Hank, T. Kiyohara, G. E. Haab, J. G. Holm, and D. M. Lavery. </author> <title> The superblock: An effective technique for vliw and superscalar compilation. </title> <journal> Journal of Supercomputing, </journal> <volume> 7(1,2):229-248, </volume> <month> March </month> <year> 1993. </year>
Reference-contexts: The register allocator does not dictate how these regions are formed and thus provides a general and flexible approach to register allocation; form and priorities of regions are parameters to our algorithm. Regions can be individual basic blocks, traces [15], superblocks <ref> [11] </ref>, or any other grouping used in the compiler (e.g., the loop structure). This framework fits nicely into code generators that take a similar approach to instruction scheduling [15, 6]: the register allocator now uses the same units of compilation and the same execution probability estimates as the instruction scheduler. <p> There are four phases in this framework: region formation, graph simplification, graph merging, and register assignment. In the region formation phase, regions are formed using any number of possible techniques. For example, a region can be a single basic block, a trace [15], a superblock <ref> [11] </ref>, a region as defined in [10], the blocks at a particular static loop nesting level [4], or the blocks within a PDG region node [16].
Reference: [12] <author> M. S. Johnson and T. C. Miller. </author> <title> Effectiveness of a machine-level global optimizer. </title> <booktitle> In Proceedings of the ACM SIGPLAN '86 Symposium on Compler Construction, </booktitle> <pages> pages 99-108. </pages> <publisher> ACM, </publisher> <month> July </month> <year> 1986. </year>
Reference-contexts: Then, liveness analysis and reaching analysis determine the live range for each virtual register. Live ranges that are constructed in this manner, however, may be comprised of disjoint 2 segments, resulting in an unnecessarily high number of conflicts for a live range. Renumbering [5] and web analysis <ref> [12] </ref> are two techniques to construct concise live ranges, which result in interference graphs of potentially lower degree.
Reference: [13] <author> P. Kolte and M. J. Harrold. </author> <title> Load/store range analysis for global register allocation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 268-277. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: A live range is split at a node when the incoming values to the node result from distinct assignments. The approach also splits all live ranges that span a loop by splitting these live ranges immediately before and after the loop. Kolte and Harrold <ref> [13] </ref> partition a live range at a finer granularity by considering the ranges of instructions between loads and stores of a virtual register. These approaches to splitting live ranges before coloring have several drawbacks. First, decisions regarding which live ranges to split and where to split them are made prematurely.
Reference: [14] <author> S. M. Kurlander and C. N. Fischer. </author> <title> Zero-cost range splitting. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 257-265. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: It is not obvious in the paper how outer loops deal with those shuffle code. Kurlander and Fischer <ref> [14] </ref> perform live range splitting after register allocation to free up registers that can be used to improve code scheduling. Empty delay slots in the final schedule are filled with shuffle code to split and spill live ranges.
Reference: [15] <author> P. G. Lowney, S. M. Freudenberger, T. J. Karzes, W. D. Lichtenstein, R. P. Nix, J. O'Donnell, and J. C. Ruttenberg. </author> <title> The multiflow trace scheduling compiler. </title> <journal> Journal of Supercomputing, </journal> <volume> 7(1,2):51-142, </volume> <month> March </month> <year> 1993. </year>
Reference-contexts: The register allocator does not dictate how these regions are formed and thus provides a general and flexible approach to register allocation; form and priorities of regions are parameters to our algorithm. Regions can be individual basic blocks, traces <ref> [15] </ref>, superblocks [11], or any other grouping used in the compiler (e.g., the loop structure). <p> Regions can be individual basic blocks, traces [15], superblocks [11], or any other grouping used in the compiler (e.g., the loop structure). This framework fits nicely into code generators that take a similar approach to instruction scheduling <ref> [15, 6] </ref>: the register allocator now uses the same units of compilation and the same execution probability estimates as the instruction scheduler. <p> There are four phases in this framework: region formation, graph simplification, graph merging, and register assignment. In the region formation phase, regions are formed using any number of possible techniques. For example, a region can be a single basic block, a trace <ref> [15] </ref>, a superblock [11], a region as defined in [10], the blocks at a particular static loop nesting level [4], or the blocks within a PDG region node [16]. <p> One particularly attractive priority function is the use of execution probabilities. These can be derived either from profile information [8, 18], from static estimates such as loop nesting depth [7], or from static branch estimates <ref> [15] </ref>.
Reference: [16] <author> C. Norris and L. L. Pollock. </author> <title> Register allocation over the program dependence graph. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 266-277. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: This framework allows us to model a number of different approaches to register allocation <ref> [4, 9, 16] </ref>, including the classical Chaitin-style register allocation [5] if a region is a function. The key idea of our approach is to incrementally build up the interference graph. Consider the task of allocating registers for a compilation unit, e.g., a function. <p> The register allocator than colors regions in order of their priorities, and shuffle is code is inserted at the boundaries of these regions. Representative program structure based approaches include the Tera [4], Multiflow [9] and RAG <ref> [16] </ref> compilers. The Tera compiler (as described in [4]) constructs a tile tree for a program; this tree corresponds to the control-flow hierarchy of the program. Register allocation colors the tiles in two phases. <p> Instead of a tile tree, the RAG compiler colors the region nodes in a function's Program Dependence Graph (PDG), proceeding in a hierarchical manner from the leaves to the root <ref> [16] </ref>. Chaitin's algorithm is used at each region node. The coloring decision made for a region is preserved by the parent nodes of the region. This may prevent graph coloring from finding the best solution and affects live range splitting as well. <p> For example, a region can be a single basic block, a trace [15], a superblock [11], a region as defined in [10], the blocks at a particular static loop nesting level [4], or the blocks within a PDG region node <ref> [16] </ref>. Control flow edges that lie outside of regions are then ordered according to some priority function consistent with the region formation approach, e.g., edges entering innermost loop regions are ordered before those entering outermost loop regions. One particularly attractive priority function is the use of execution probabilities.
Reference: [17] <author> T. A. Proebsting and C. N. Fischer. </author> <title> Probablistic register allocation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 300-310. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: One drawback of the approach is that coloring is not used for register allocation. 2.5 Other approaches There exist other approaches to register allocation and live range splitting. For example, probabilistic register allocation <ref> [17] </ref> is a hybrid of the priority-based and program structure based approaches. The approach consists of three steps, local register allocation, global register allocation, and register assignment. Variables initially reside in memory instead of virtual registers (with load/store for every use/definition).
Reference: [18] <author> D. Wall. </author> <title> Predicting program behavior using real or estimated profiles. </title> <booktitle> In Proc. ACM SIGPLAN '91 Symposium on Compiler Construction, </booktitle> <pages> pages 59-70. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1991. </year> <month> 18 </month>
Reference-contexts: One particularly attractive priority function is the use of execution probabilities. These can be derived either from profile information <ref> [8, 18] </ref>, from static estimates such as loop nesting depth [7], or from static branch estimates [15].
References-found: 18

