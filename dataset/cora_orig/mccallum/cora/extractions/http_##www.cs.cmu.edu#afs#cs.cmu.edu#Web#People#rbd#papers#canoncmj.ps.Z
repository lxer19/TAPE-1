URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/Web/People/rbd/papers/canoncmj.ps.Z
Refering-URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/Web/People/rbd/bib-arctic.html
Root-URL: http://www.cs.cmu.edu
Title: The Canon Score Language  
Author: Roger B. Dannenberg 
Address: Pittsburgh, PA 15213  
Affiliation: Computer Science Department Carnegie Mellon University  
Abstract: Canon is both a notation for musical scores and a programming language. Canon offers a combination of declarative style and a powerful abstraction capability which allows a very high-level notation for sequences of musical events and structures. Transformations are operators that can adjust common parameters such as loudness or duration. Transformations can be nested and time-varying, and their use avoids the problem of having large numbers of explicit parameters. Behavioral abstraction, the concept of making behavior an arbitrary function of the environment, is supported by Canon and extends the usefulness of transformations. A non-real-time implementation of Canon is based on Lisp and produces scores that control MIDI synthesizers. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Abbot, C., </author> <year> 1981. </year> <title> ``The 4CED Program.'' </title> <journal> Computer Music Journal 5(1) </journal> <pages> 13-33. </pages>
Reference-contexts: Consider the following: (sim (note c4) (at 300 (note a4))) The at transformation shifts scores in time. Intuitively, (at x y) means ``at time x, do y'' and the at operator is reminiscent of the ``@'' operator in 4CED <ref> (Abbot 1981) </ref> and Arctic (Dannenberg 1986). In this example, the time of the second note is shifted by 3 seconds.
Reference: <author> Anderson, D., and R. Kuivila, </author> <year> 1986. </year> <title> ``Accurately Timed Generation of Discrete Musical Events.'' </title> <journal> Computer Music Journal 10(3) </journal> <pages> 48-56. </pages>
Reference-contexts: This tends to force the programmer to be aware of implementation details. An advantage of the Formes approach is that output is computed in time order, so it is possible to have simultaneous activities that influence one another. 12 Formula <ref> (Anderson 1986) </ref> is a real-time system based on the use of multiple tasks for expressing scores and allowing various transformations. One very interesting property of Formula is that time-varying transformations (like Canon's envelopes) can be programmed procedurally and each envelope runs as a separate process.
Reference: <author> Betz, D. </author> <year> 1986. </year> <title> ``XLISP: An Experimental Object-oriented Language, Version 1.7.'' (program documentation). </title>
Reference-contexts: An alternative 7 to tasks, which are often large and slow to create, is to use a calculation tree of objects as in Formes. I am currently pursuing this approach in a real-time implementation of Arctic. Acknowledgments An Xlisp <ref> (Betz 1986) </ref> programming environment for the Apple Macintosh was the enabling condition for the implementation of Canon. David Betz wrote Xlisp which has proved to be virtually bug-free and a model of good coding style. Blair Evans and Robert Joseph modified Xlisp to create a nicer programming environment.
Reference: <author> Cointe, P., and X. Rodet, </author> <year> 1984. </year> <title> ``Formes: an Object & Time Oriented System for Music Composition and Synthesis.'' </title> <booktitle> Proceedings of the 1984 ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pp 85-95. </pages> <month> 7 Usually, </month> <title> each task requires a contiguous stack. Stacks must be large enough to ensure that they do not overflow. 14 Dannenberg, </title> <editor> R., P. McAvinney, D. Rubine, </editor> <year> 1986. </year> <title> ``Arctic: A Functional Language for Real-Time Systems.'' </title> <journal> Computer Music Journal 10(4) </journal> <pages> 67-78. </pages>
Reference-contexts: This allows scores to be parameterized and to incorporate arbitrary calculations including 1 Published as: Dannenberg, ``The Canon Score Language,'' Computer Music Journal, 13 (1) (Spring 1989), pp. 47-56. Copyright (c) 1989 MIT 2 compositional algorithms. The same could be said of languages like Formes <ref> (Cointe 1984, Rodet 1984) </ref> and Pla (Schottstaedt 1983), but Canon goes further to blur the distinction between data and program. This is possible because Canon is a declarative language. <p> The standard data type in Arctic is a time-varying real-valued function rather than a score, so Arctic has a different set of operators. The idea of a transformation environment and the ability to create abstract behaviors is a common theme in the two languages. Formes <ref> (Cointe 1984) </ref> has been used to program at both the note and the control function level. Formes programs are less declarative than Canon programs in that Formes objects contain state information that must be initialized and modified as time progresses.
Reference: <author> Greenberg, G., </author> <year> 1987. </year> <title> ``Procedural Composition.'' </title> <booktitle> Proceedings of the 1987 International Computer Music Conference. </booktitle> <address> San Francisco: </address> <publisher> Computer Music Association, </publisher> <pages> pp 25-32. </pages>
Reference: <author> Greenberg, G., </author> <year> 1988. </year> <title> ``Composing With Performer Objects.'' </title> <booktitle> Proceedings of the 1988 International Computer Music Conference. </booktitle> <address> San Francisco: </address> <publisher> Computer Music Association, </publisher> <pages> pp 142-149. </pages>
Reference: <author> Jaffe, D., </author> <year> 1985. </year> <title> ``Ensemble Timing in Computer Music.'' </title> <journal> Computer Music Journal 9(4) </journal> <pages> 38-48. </pages>
Reference: <author> Kornfeld, W., </author> <year> 1980. </year> <title> ``Machine Tongues VII: LISP.'' </title> <journal> Computer Music Journal 4(2) </journal> <pages> 6-12. </pages>
Reference-contexts: Score Primitives and Operator Definition Canon allows the composer/programmer to create, manipulate, and combine scores. A score is usually obtained by combining other scores, but there a few built-in, or primitive scores from which other scores are composed. Before describing these primitives, a brief explanation of Lisp <ref> (Kornfeld 1980, Touretzky 1984) </ref> syntax (used by Canon) is presented as a guide to readers who are not familiar with Lisp. Lisp programmers should skip ahead to ``Primitive Operators''. Lisp Syntax 2 Virtually every procedural language provides some form of procedural abstraction through the definition of new subroutines or procedures.
Reference: <author> Krakowsky, P., ed., </author> <year> 1986. </year> <title> Object LOGO Reference Manual. </title> <institution> Cambridge Massachusetts: Coral Software Corp. </institution>
Reference-contexts: Pla (Schottstaedt 1983), like Formes, is an object-oriented language, but Pla seems more note-list oriented. A central idea in Pla is the use of objects called voices to interpret note lists. This idea is also used in Greenberg's (1987, 1988) Object LOGO Music Environment <ref> (Krakowsky 1986) </ref>. Neither of these languages supports nested transformations in the sense of Formes or Canon. On the other hand, Formes and Canon do not have built-in facilities for building voices or performers that interpret note-list data.
Reference: <author> Loy, G., </author> <year> 1985. </year> <title> ``Musicians Make a Standard: The MIDI Phenomenon.'' </title> <journal> Computer Music Journal 9(4) </journal> <pages> 8-26. </pages>
Reference-contexts: duration is 150, then the note will be turned on for .75 seconds (50 percent of 150 hundredths) rather than the full duration of 1.5 seconds. (The remaining .75 seconds will consist of the release of the note followed by silence.) Velocity and channel refer to the corresponding MIDI parameters <ref> (Loy 1985) </ref>. Any operands not specified take on default values. The default note is a middle C lasting 1 second with 100% duty, a velocity of 100, and channel 1. The rest operator has only one operand that specifies duration.
Reference: <author> Pratt, T., </author> <year> 1975. </year> <booktitle> Programming Languages: Design and Implementation. </booktitle> <address> Englewood Cliffs: </address> <publisher> Prentice-Hall. </publisher>
Reference-contexts: The effect is to transpose the ascending scale so that it starts on the pitch provided as the operand: (defun up (root) (seq (note root) (note (+ root 2)) (note (+ root 5)) (note (+ root 7)))) Here, root is the formal operand <ref> (Pratt 1975) </ref> for which actual operands are substituted when up is used.
Reference: <author> Rodet, X. and P. Cointe, </author> <year> 1984. </year> <title> ``FORMES: Composition and Scheduling of Processes.'' </title> <journal> Computer Music Journal 8(3): </journal> <pages> 32-50. </pages>
Reference-contexts: This allows scores to be parameterized and to incorporate arbitrary calculations including 1 Published as: Dannenberg, ``The Canon Score Language,'' Computer Music Journal, 13 (1) (Spring 1989), pp. 47-56. Copyright (c) 1989 MIT 2 compositional algorithms. The same could be said of languages like Formes <ref> (Cointe 1984, Rodet 1984) </ref> and Pla (Schottstaedt 1983), but Canon goes further to blur the distinction between data and program. This is possible because Canon is a declarative language.
Reference: <author> Rogers, J., J. Rockstroh, and P. Batstone, </author> <year> 1980. </year> <title> ``Music-Time and Clock-Time Similarities Under Tempo Changes.'' </title> <booktitle> Proceedings of the 1980 International Computer Music Conference. </booktitle> <address> San Francisco: </address> <publisher> Computer Music Association, </publisher> <pages> pp 404-442. </pages>
Reference-contexts: This leads to a complex interdependency in which the starting times of notes depend upon durations and duration is a function of starting time. A saner way to deal with time and duration is to provide a function from ``score time'' to ``performance time'' <ref> (Rogers 1980, Jaffe 1985) </ref>. The corresponding operators are warp and warp-abs, and the envelope function provides a mapping from score time to real time. Further details are given in the next section.
Reference: <author> Rubine, D. and Dannenberg, R., </author> <year> 1987. </year> <title> ``Arctic Programmer's Manual and Tutorial.'' </title> <institution> Carnegie Mellon Computer Science Department Technical Report CMU-CS-87-110. </institution>
Reference: <author> Schottstaedt, B., </author> <year> 1983. </year> <title> ``Pla: A Composer's Idea of a Language.'' </title> <journal> Computer Music Journal 7(1) </journal> <pages> 11-20. </pages>
Reference-contexts: Copyright (c) 1989 MIT 2 compositional algorithms. The same could be said of languages like Formes (Cointe 1984, Rodet 1984) and Pla <ref> (Schottstaedt 1983) </ref>, but Canon goes further to blur the distinction between data and program. This is possible because Canon is a declarative language. <p> One very interesting property of Formula is that time-varying transformations (like Canon's envelopes) can be programmed procedurally and each envelope runs as a separate process. Formula does not have any built-in mechanisms for nesting transformations except for time-deformation analogous to the warp operator in Canon. Pla <ref> (Schottstaedt 1983) </ref>, like Formes, is an object-oriented language, but Pla seems more note-list oriented. A central idea in Pla is the use of objects called voices to interpret note lists. This idea is also used in Greenberg's (1987, 1988) Object LOGO Music Environment (Krakowsky 1986).
Reference: <author> Touretzky, D., </author> <year> 1984. </year> <title> LISP: a gentle introduction to symbolic computation. </title> <address> New York: </address> <publisher> Harper & Row. </publisher>
References-found: 16

