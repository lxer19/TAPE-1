URL: http://theory.lcs.mit.edu/tds/papers/Lynch/FTCS97.ps
Refering-URL: http://theory.lcs.mit.edu/tds/papers/Lynch/FTCS97.html
Root-URL: 
Title: Robust emulation of shared memory using dynamic quorum-acknowledged broadcasts using invariants and partial-order-based methods. Approximate
Author: Nancy Lynch Alex Shvartsman 
Keyword: atomic replicated read/write objects. Keywords Distributed algorithms, fault-tolerance, atomic registers, message-passing, quorums.  
Note: The algorithms are specified here in terms of I/O automata [8, 9], and their correctness is proven  It is shown that the algorithm is correct, and that it implements  Author  (primary contact), alex@theory.lcs.mit.edu. Submission category Regular paper.  This material has been cleared through author affiliations.  
Address: 545 Technology Square, NE43-365, Cambridge, MA 02139, USA.  
Affiliation: Massachusetts Institute of Technology, Laboratory for Computer Science,  
Email: e-mail lynch@theory.lcs.mit.edu  
Date: December 2, 1996  
Abstract: This paper presents robust emulation of multi-writer/multi-reader registers in message-passing systems using dynamic quorum configurations. In addition to processor and link failures, this emulation tolerates changes in quorum configurations, i.e., on-line replacements of one quorum system consisting of read and write quorums with another such system. This work extends the results of Attiya, Bar-Noy and Dolev [1] who showed how to emulate single-writer/multi-reader registers robustly in message-passing systems using majorities. The emulation in this paper is specified using a modular two-layer architecture. The lower layer uses unreliable broadcast to disseminate a request from the higher layer to a set of processors, and then to collect responses from a subset of the processors. The subset can be specified by a predicate or by using a quorum system. The lower layer then computes a function on the collected responses and returns the result to the higher layer. The broadcast can take advantage of hardware-assisted broadcast as we do not assume that the broadcast is reliable or that it has fifo, causal or atomic properties. The higher layer algorithm emulates robust multi-writer/multi-reader registers where quorum configurations are used to ensure that the registers are atomic. A unique feature of the read/write service is that it implements dynamically changing quorum configurations. The service includes two interfaces, a functional interface for reads and writes, and a management interface for reconfiguration. The processor designated as the reconfigurer executes requests that replace the current quorum configuration with the new configuration. The combination of the higher and lower layers allows essentially unlimited concurrency and does not involve locks. Waiting can occur only (a) due to processor or link failures that disconnect at least one processor in each read and write quorum of the specified configurations, or (b) when frequent reconfigurations interfere with reads/writes and cause them to contribute to reconfigurations. However, as soon as reconfigurations stop, and as long as for each lower level request specifying a set of read or write quorums there exists a single quorum of active and connected processors, then reads and writes complete without waiting. All of this is transparent to the clients of the service. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Attiya, A. Bar-Noy and D. Dolev, </author> <title> "Sharing Memory Robustly in Message Passing Systems", </title> <journal> J. of the ACM, </journal> <volume> vol. 42, no. 1, </volume> <pages> pp. 124-142, </pages> <year> 1996. </year>
Reference-contexts: Consequently, in such cases there is value in developing an algorithm first for the shared-memory model and then automatically converting it to run in the message-passing model. Among the important results in this area are the algorithms of Attiya, Bar-Noy and Dolev <ref> [1] </ref> who showed that it is possible to emulate shared memory robustly in message-passing systems. Their very interesting, fully asynchronous algorithm implements atomic single-writer/multi-reader registers in unreliable, asynchronous networks. Our work is inspired by and builds on their results. In more detail, [1] shows that any wait-free algorithm for the shared-memory <p> are the algorithms of Attiya, Bar-Noy and Dolev <ref> [1] </ref> who showed that it is possible to emulate shared memory robustly in message-passing systems. Their very interesting, fully asynchronous algorithm implements atomic single-writer/multi-reader registers in unreliable, asynchronous networks. Our work is inspired by and builds on their results. In more detail, [1] shows that any wait-free algorithm for the shared-memory model that uses atomic single-writer/multi-reader registers can be emulated in the message-passing model where processors or links are subject to crash failures. The authors of [1] give a basic algorithm for complete networks using unbounded timestamps, a version for arbitrary network topologies, <p> Our work is inspired by and builds on their results. In more detail, <ref> [1] </ref> shows that any wait-free algorithm for the shared-memory model that uses atomic single-writer/multi-reader registers can be emulated in the message-passing model where processors or links are subject to crash failures. The authors of [1] give a basic algorithm for complete networks using unbounded timestamps, a version for arbitrary network topologies, and they also modify their algorithms so that it uses only bounded timestamps. <p> These algorithms are based on processor majorities and thus are able to tolerate scenarios where any minority of processors are disabled or are unable to communicate. The algorithms <ref> [1] </ref> are constructed with the help of a communicate procedure that uses half-duplex, ping-pong, point-to-point links to broadcast messages and to collect responses from any majority of processors. The basic algorithmic techniques are very efficient and they render the algorithm suitable for an effective implementation. <p> Such systems have been used to implement distributed mutual exclusion [5] and data replication protocols [4, 7]. Quorums can be used with replicated data in transaction-style synchronization that limits concurrency (cf. [2]), whereas our goal and the goal of <ref> [1] </ref> is to reduce restrictions on asynchrony and concurrency. In this paper we present a service that emulates shared memory registers using broadcasts and dynamically changing quorum configurations. Our algorithms extend the unbounded-timestamp single-writer solution of Attiya, Bar-Noy and Dolev [1] in four ways: 1. <p> concurrency (cf. [2]), whereas our goal and the goal of <ref> [1] </ref> is to reduce restrictions on asynchrony and concurrency. In this paper we present a service that emulates shared memory registers using broadcasts and dynamically changing quorum configurations. Our algorithms extend the unbounded-timestamp single-writer solution of Attiya, Bar-Noy and Dolev [1] in four ways: 1. Our construction emulates multi-writer/multi-reader registers. 2. We replace the majority-based approach of [1] with a quorum-based approach this is done in a way that does not involve synchronization and that preserves the asynchrony and non-determinism found in the original solution [1]. 3. <p> In this paper we present a service that emulates shared memory registers using broadcasts and dynamically changing quorum configurations. Our algorithms extend the unbounded-timestamp single-writer solution of Attiya, Bar-Noy and Dolev <ref> [1] </ref> in four ways: 1. Our construction emulates multi-writer/multi-reader registers. 2. We replace the majority-based approach of [1] with a quorum-based approach this is done in a way that does not involve synchronization and that preserves the asynchrony and non-determinism found in the original solution [1]. 3. <p> of Attiya, Bar-Noy and Dolev <ref> [1] </ref> in four ways: 1. Our construction emulates multi-writer/multi-reader registers. 2. We replace the majority-based approach of [1] with a quorum-based approach this is done in a way that does not involve synchronization and that preserves the asynchrony and non-determinism found in the original solution [1]. 3. We augment the multi-writer/multi-reader service with a management interface used to reconfigure the quorum system on-the-fly without changing the functional interface of the service and without suspending any reads/writes in progress or disabling new requests. 4. <p> Our use of the primitive illustrates how computing with the primitive can be an effective tool in developing distributed algorithms. * The higher layer algorithm emulates robust multi-writer/multi-reader registers where quorum systems are used to ensure that the registers are atomic. This layer extends the single writer protocol <ref> [1] </ref> to a multi-writer protocol. We use quorum systems in a way that ensures the atomicity of the multi-writer/multi-reader registers without resorting to locking or mutual exclusion. A unique feature of this layer is that we deal with dynamically changing quorum configurations. <p> In general, using a quorum system that is k versions older than the current system increases time by at most 2dk, thus reads and writes take at most time 4d + 2dk. In our implementation, we assume the availability of unbounded counters, whereas Attiya, Bar-Noy and Dolev <ref> [1] </ref> also provide an implementation using bounded counters. We discuss this assumption at the end of the paper. The rest of this paper is as follows. In Sec. 2 we define models and conventions. In Sec. 3 we present (C) and primitives. <p> The presentation illustrates the main algorithmic ideas and proof techniques used in the next section in the more complicated algorithm using dynamic quorum configurations. 4.1 Fixed quorums algorithm specification In the approach of Attiya, Bar-Noy and Dolev <ref> [1] </ref>, each copy of the register is stored together with a label used to order the writes and to determine the result of which write is returned by reads. In their single-writer approach the monotonically increasing label is maintained by the writer and is associated with the register. <p> We generalize this approach by using a quorum configuration instead of majorities. Our solution is a pleasingly uniform algorithm for the readers and the (now multiple) writers. We replace the labels of <ref> [1] </ref> with the tags generated by the writers. The tags are pairs consisting of the sequence number seq and the processor identifier pid , and the tags are ordered lexicographically. Thus each register is represented locally at each processor by its value val and its tag tag. <p> The single-writer algorithm of Attiya, Bar-Noy and Dolev <ref> [1] </ref> is refined by the authors to use bounded counters at a modest increase in storage in message sizes. The implementation of [1] relies on a reliable ping-pong mechanism. This is done to allow, in a particular section of the protocol, only a single unacknowledged message between any two processors. <p> The single-writer algorithm of Attiya, Bar-Noy and Dolev <ref> [1] </ref> is refined by the authors to use bounded counters at a modest increase in storage in message sizes. The implementation of [1] relies on a reliable ping-pong mechanism. This is done to allow, in a particular section of the protocol, only a single unacknowledged message between any two processors. Furthermore, any link is assumed to be reliable unless it crashes, after which the link remains forever inoperable.
Reference: [2] <author> P.A. Bernstein, V. Hadzilacos and N. Goodman, </author> <title> Concurrency Control and Recovery in Database Systems, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: Such systems have been used to implement distributed mutual exclusion [5] and data replication protocols [4, 7]. Quorums can be used with replicated data in transaction-style synchronization that limits concurrency (cf. <ref> [2] </ref>), whereas our goal and the goal of [1] is to reduce restrictions on asynchrony and concurrency. In this paper we present a service that emulates shared memory registers using broadcasts and dynamically changing quorum configurations.
Reference: [3] <author> S.E. Deering and D.R. Cheriton, </author> <title> "Multicast Routing in Datagram Internetworks and Extended LANs", </title> <journal> ACM TOCS, </journal> <volume> vol. 8, no. 2, </volume> <year> 1990. </year>
Reference-contexts: In the network settings where processors closely cooperate, it is increasingly important to assume the availability of efficient broadcast or multicast. This assumption is reasonable for LAN-based environments and for emerging high-speed WANs. The availability of hardware-assisted broadcast <ref> [14, 3] </ref> makes the cost of using broadcast similar to the cost of sending a point-to-point message. Note that our algorithms do not require such broadcast to have atomic, fifo, or causal properties. Our robust emulation can tolerate a broad range of patterns of processor and link failures.
Reference: [4] <author> S.B. Davidson, H. Garcia-Molina and D. Skeen, </author> <title> "Consistency in Partitioned Networks", </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 15, no. 3, </volume> <pages> pp. 341-370, </pages> <year> 1985. </year>
Reference-contexts: A more refined approach divides the quorum system into a collection of read quorums and a collection of write quorums such that any read quorum intersects any write quorum. Such systems have been used to implement distributed mutual exclusion [5] and data replication protocols <ref> [4, 7] </ref>. Quorums can be used with replicated data in transaction-style synchronization that limits concurrency (cf. [2]), whereas our goal and the goal of [1] is to reduce restrictions on asynchrony and concurrency.
Reference: [5] <author> H. Garcia-Molina and D. Barbara, </author> <title> "How to Assign Votes in a Distributed System," </title> <journal> J. of the ACM, </journal> <volume> vol. 32, no. 4, </volume> <pages> pp. 841-860, </pages> <year> 1985. </year>
Reference-contexts: The basic algorithmic techniques are very efficient and they render the algorithm suitable for an effective implementation. Using majorities is a special case of quorum systems [6]. A simple quorum system (also called coterie) is a collection of sets such that any two sets, called quorums, intersect <ref> [5] </ref>. A more refined approach divides the quorum system into a collection of read quorums and a collection of write quorums such that any read quorum intersects any write quorum. Such systems have been used to implement distributed mutual exclusion [5] and data replication protocols [4, 7]. <p> of sets such that any two sets, called quorums, intersect <ref> [5] </ref>. A more refined approach divides the quorum system into a collection of read quorums and a collection of write quorums such that any read quorum intersects any write quorum. Such systems have been used to implement distributed mutual exclusion [5] and data replication protocols [4, 7]. Quorums can be used with replicated data in transaction-style synchronization that limits concurrency (cf. [2]), whereas our goal and the goal of [1] is to reduce restrictions on asynchrony and concurrency.
Reference: [6] <author> D.K. Gifford, </author> <title> "Weighted voting for Replicated Data", </title> <booktitle> in Proc. of 7th ACM Symp. on Oper. Sys. Princ., </booktitle> <pages> pp. 150-162, </pages> <year> 1979. </year>
Reference-contexts: The basic algorithmic techniques are very efficient and they render the algorithm suitable for an effective implementation. Using majorities is a special case of quorum systems <ref> [6] </ref>. A simple quorum system (also called coterie) is a collection of sets such that any two sets, called quorums, intersect [5].
Reference: [7] <author> M.P. Herlihy, </author> <title> Replication Methods for Abstract Data Types, Doctoral Dissertation, </title> <publisher> MIT, </publisher> <address> LCS/TR-319, </address> <year> 1984. </year>
Reference-contexts: A more refined approach divides the quorum system into a collection of read quorums and a collection of write quorums such that any read quorum intersects any write quorum. Such systems have been used to implement distributed mutual exclusion [5] and data replication protocols <ref> [4, 7] </ref>. Quorums can be used with replicated data in transaction-style synchronization that limits concurrency (cf. [2]), whereas our goal and the goal of [1] is to reduce restrictions on asynchrony and concurrency.
Reference: [8] <author> N.A. Lynch, </author> <title> Distributed Algorithms, </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1996. </year>
Reference-contexts: In achieving the above, we formally specify and analyze the algorithms for the multi-writer/multi-reader service. Our algorithms are specified in terms of I/O automata <ref> [8, 9] </ref>. We use invariants and partial-order based methods to prove that our algorithms are correct, and that it implements atomic replicated read/write objects. The main proof introduces a new "Fill" notion used to predict the acknowledgment vector of invocations. <p> The specifications in this paper are done in terms of I/O automata <ref> [8, 9] </ref>. <p> The implementation uses send/receive point-to-point channels. Each channel is modelled having send (m) i;j and recv (m) j;i actions, and channel i;j state variables for i; j 2 PID. Such channels have very simple specifications (cf. <ref> [8] </ref>) which are omitted here. Lemma 3.2 The composition of (C) and the channel automata implements (C). <p> Note that these derived variables are otherwise not used in any way by the algorithm. 4.2 Proof of correctness For any execution we are interested in showing the atomicity of the read and write operations. We show atomicity of the implementation by using the following lemma of <ref> [8] </ref>: Lemma 4.1 [8] Let fi be a (finite or infinite) sequence of actions of a read/write object external interface. Suppose that fi is well-formed for each i 2 PID, and contains no incomplete operations. Let be the set of all operations in fi. <p> We show atomicity of the implementation by using the following lemma of <ref> [8] </ref>: Lemma 4.1 [8] Let fi be a (finite or infinite) sequence of actions of a read/write object external interface. Suppose that fi is well-formed for each i 2 PID, and contains no incomplete operations. Let be the set of all operations in fi. <p> It appears that such reliable ping-pong mechanism would assume too much reliability on the part of the communication subsystem. We conjecture that either the underlying subsystem may need itself either to use unbounded counters or to use messages of unbounded size (cf. the result <ref> [8, Thm. 22.11] </ref> due to Lynch, Mansour and Fekete). On failure models considered: We have considered only the benign component failures the processor and link failures never create spontaneous messages and the messages that are sent are delivered without alteration.
Reference: [9] <author> N.A. Lynch and M.R. Tuttle, </author> <title> "An Introduction to Input/Output Automata", </title> <journal> CWI Quarterly, vol.2, </journal> <volume> no. 3, </volume> <pages> pp. 219-246, </pages> <year> 1989. </year>
Reference-contexts: In achieving the above, we formally specify and analyze the algorithms for the multi-writer/multi-reader service. Our algorithms are specified in terms of I/O automata <ref> [8, 9] </ref>. We use invariants and partial-order based methods to prove that our algorithms are correct, and that it implements atomic replicated read/write objects. The main proof introduces a new "Fill" notion used to predict the acknowledgment vector of invocations. <p> The specifications in this paper are done in terms of I/O automata <ref> [8, 9] </ref>.
Reference: [10] <author> D. Malki and M. Reiter, </author> <title> "Byzantine Quorum Systems", </title> <type> TR CS96-8, </type> <institution> Inst. of Comp. Sci, the Hebrew Univ. of Jerusalem, </institution> <month> July 9, </month> <year> 1996. </year>
Reference-contexts: On failure models considered: We have considered only the benign component failures the processor and link failures never create spontaneous messages and the messages that are sent are delivered without alteration. Malki and Reiter <ref> [10] </ref> recently explored the use of quorum systems in the presence of Byzantine failures. It would be interesting to examine additional failure models that can be handled by atomic register emulations.
Reference: [11] <author> M.H. Olsen, E. Oskiewicz and J.P. Warne, </author> <title> "A Model for Interface Groups", </title> <booktitle> IEEE 10th Symp. on Reliable Distributed Systems, </booktitle> <pages> pp. 98-107, </pages> <year> 1991. </year>
Reference: [12] <author> J.-F. Paris and P.K.Sloope, </author> <title> "Dynamic Management of Highly Replicated Data", </title> <booktitle> in IEEE 11th Symp. on Reliable Distr. Systems, </booktitle> <pages> pp. 20-27, </pages> <year> 1992. </year>
Reference: [13] <author> D. Peleg and A. Wool, </author> <title> "How to be an Efficient Snoop, or the Probe Complexity of Quorum Systems", </title> <booktitle> in Proc. of the 15th ACM Symp. on Princ. of Distr. Comput., </booktitle> <pages> pp. 290-299, </pages> <year> 1996. </year>
Reference-contexts: We have argued in the introduction that in contemporary networks the use of hardware-assisted broadcast is more efficient than its linear-in-the-number-of-destinations message complexity suggests. In addition, the results of Peleg and Wool <ref> [13] </ref> indicate that for many quorum systems a linear number of messages would in fact be required to either reach a single active quorum or to detect a quorum all of whose members have either failed or are inaccessible.
Reference: [14] <author> RFC 1112, </author> <title> Internet Group Multicast Protocol, Internet Standard Protocol (Recommended). </title>
Reference-contexts: In the network settings where processors closely cooperate, it is increasingly important to assume the availability of efficient broadcast or multicast. This assumption is reasonable for LAN-based environments and for emerging high-speed WANs. The availability of hardware-assisted broadcast <ref> [14, 3] </ref> makes the cost of using broadcast similar to the cost of sending a point-to-point message. Note that our algorithms do not require such broadcast to have atomic, fifo, or causal properties. Our robust emulation can tolerate a broad range of patterns of processor and link failures.
Reference: [15] <author> A.A. Shvartsman, </author> <title> "Dealing with History and Time in a Distributed Enterprise Manager", </title> <journal> IEEE Network, </journal> <volume> vol. 7, no. 6, </volume> <pages> pp. 32-41, </pages> <year> 1993. </year>
Reference-contexts: The successful deployment and use of complex distributed applications often depends on our ability to manage the application as a distributed resource on the basis of current and historical observations <ref> [15] </ref>. A resource manager can monitor the environment for changing performance requirements and availability conditions and, in our case, evolve the quorum system using the management interface of the service. In achieving the above, we formally specify and analyze the algorithms for the multi-writer/multi-reader service.

References-found: 15

