URL: http://www.cs.cornell.edu/Info/People/chandra/podc97/papers/hirt.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/chandra/podc97/newProgram.html
Root-URL: 
Email: fhirt,maurerg@inf.ethz.ch  
Title: Complete Characterization of Adversaries Tolerable in Secure MultiParty Computation (Extended Abstract) complexities of the protocols
Author: Martin Hirt Ueli Maurer 
Note: The  
Address: CH-8092 Zurich, Switzerland  
Affiliation: Department of Computer Science Swiss Federal Institute of Technology (ETH), Zurich  
Abstract: The classical results in unconditional multi-party computation among a set of n players state that less than n=2 passive or less than n=3 active adversaries can be tolerated; assuming a broadcast channel the threshold for active adversaries is n=2. Strictly generalizing these results we specify the set of potentially misbehaving players as an arbitrary set of subsets of the player set. We prove the necessary and sufficient conditions for the existence of secure multi-party protocols in terms of the potentially misbehaving player sets. For every function there exists a protocol secure against a set of potential passive collusions if and only if no two of these collusions add up to the full player set. The same condition applies for active adversaries when assuming a broadcast channel. Without broadcast channels, for every function there exists a protocol secure against a set of potential active adverse player sets if and only if no three of these sets add up to the full player set. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Beaver, D. </author> <title> Foundations of secure interactive computing. </title> <booktitle> In Advances in Cryptology | CRYPTO '91 (1991), vol. 576 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 377-391. </pages>
Reference-contexts: The presented techniques are general in the sense that they can be applied to any multi-party protocols. The player substitution techniques can also be applied in the computational model of multi-party computation, but the security of such composite protocols remains to be proven <ref> [1, 24] </ref>. Acknowledgments We would like to thank Matthias Fitzi for his contributions on efficient protocols. We are very grateful to Oded Gold reich for his detailed comments, and for repeatedly encouraging us to improve the clarity of the presentation.
Reference: [2] <author> Ben-Or, M., Goldwasser, S., and Wigderson, A. </author> <title> Completeness theorems for non-cryptographic fault-tolerant distributed computation. </title> <booktitle> In Proc. 20th ACM Symposium on the Theory of Computing (STOC) (1988), </booktitle> <pages> pp. 1-10. </pages>
Reference-contexts: This is the well-known secure multiparty computation problem (e.g. [29, 21]). For an excellent overview see [17, 3, 16]. There exists a rich literature on the subject. These approaches can be classified according to a number of criteria that are briefly discussed below. Some papers (e.g. <ref> [29, 21, 19, 2, 7, 27] </ref>) describe protocol constructors which To appear in the Proceedings of the Sixteenth ACM Symposium on Principles of Distributed Computing (PODC), August 1997. for any function generate a protocol for securely computing it, while other approaches are tailored to a particular function like voting (e.g. [10]), <p> Adversaries are classified according to their computational resources (limited, hence cryptographic security, e.g. [8, 21], or unlimited, hence unconditional or information theoretic security, e.g. <ref> [2, 7, 27] </ref>), and according to whether they cheat actively or passively. A set of active adverse players is called an adversary, a set of passive cheaters is called a (passive) collusion. <p> A set of active adverse players is called an adversary, a set of passive cheaters is called a (passive) collusion. In the information-theoretic model one can distinguish between protocols with small (e.g. [7, 27]) or with zero failure probability (e.g. <ref> [2] </ref>). We refer to the latter as perfect multi-party computation. The types of tolerable adversaries have recently been generalized in a number of directions (adaptive adversaries [4] and uncoercibil-ity [5]), and some authors have investigated multi-party computation for various minimality and complexity criteria [12, 11, 18, 26, 27, 22]. <p> All previous results in the literature specify the sets of potential adverse players (passive or active) that can be tolerated by their cardinality, i.e. by a threshold. In a setting with perfect security, Ben-Or, Goldwasser and Wigderson <ref> [2] </ref> proved that with n players all passive collusions with less than n=2 members or, alternatively, all active adversaries with less than n=3 members can be tolerated. We refer to these two models as the passive and the active model. <p> First, we provide a framework for player substitution and derive the corresponding tolerated adversary structures (Theorems 1 and 2). Second, we give the exact characterization of which collusion structures and which adversary structures can be tolerated: 1. As a strict generalization of the threshold-type results of <ref> [2, 7] </ref>, we prove that in the passive model, perfect multi-party computation for any function is possible if and only if no two potential passive collusions add up to the full player set. 2. As a strict generalization of the threshold-type result of [2, 7] we prove that in the active <p> strict generalization of the threshold-type results of <ref> [2, 7] </ref>, we prove that in the passive model, perfect multi-party computation for any function is possible if and only if no two potential passive collusions add up to the full player set. 2. As a strict generalization of the threshold-type result of [2, 7] we prove that in the active model, perfect multi-party computation for any function is possible if and only if no three potential active adversaries add up to the full player set. 3. <p> Due to the exponential size of the description of a general adversary structure, our protocols are in general not (and cannot be) polynomial in the number of players. Note that there exist polynomial (in the number of players) protocols for specific adversary structures (e.g. for threshold structures <ref> [2] </ref> and certain other types of structures). 1.3 Motivation and outline All protocols in the literature provide only security of a threshold type. <p> By assigning an integer valued weight w i to each player p i and having every player act for w i players in the threshold-type protocol of <ref> [2] </ref> they can tolerate the stated collusions. <p> This results in a total weight of 9. The multi-party protocol of <ref> [2] </ref> among 9 players for the passive model tolerates all collusions with at most 4 members. One can easily verify that all stated subsets have total weight at most 4. <p> Note that A-robustness implies A-fairness. Our protocols are A-resilient and A-robust, thus fairness need not and will not be considered further. 2.5 Models We distinguish between three models: The passive model and the active model are the same as those of <ref> [2] </ref>: We assume reliable synchronous secure channels between every pair of two players but we do not assume a broadcast channel. The basic protocols of [2] can be realized without broadcast or, more precisely, by simulating it with a protocol among the sender and the receivers of the broadcast [23, 13]. <p> will not be considered further. 2.5 Models We distinguish between three models: The passive model and the active model are the same as those of <ref> [2] </ref>: We assume reliable synchronous secure channels between every pair of two players but we do not assume a broadcast channel. The basic protocols of [2] can be realized without broadcast or, more precisely, by simulating it with a protocol among the sender and the receivers of the broadcast [23, 13]. <p> In our construction we use a protocol generator for each model. Let G p3 denote the three-party protocol generator of <ref> [2] </ref> in the passive model (see below), tolerating all collusions containing one single player, and let G a4 denote the four-party protocol generator of [2] in the active model, tolerating one arbitrary adversary containing a single player. <p> In our construction we use a protocol generator for each model. Let G p3 denote the three-party protocol generator of <ref> [2] </ref> in the passive model (see below), tolerating all collusions containing one single player, and let G a4 denote the four-party protocol generator of [2] in the active model, tolerating one arbitrary adversary containing a single player. Furthermore, let G a3b denote the three-party protocol generator of [27] in the active model with broadcast, tolerating one arbitrary adversary with a single player. <p> Furthermore, let G a3b denote the three-party protocol generator of [27] in the active model with broadcast, tolerating one arbitrary adversary with a single player. In order to explicitly construct the protocol generators G p3 , G a4 , and G a3b using the results of <ref> [2] </ref> and [27], we scan the multi-party computation specification statement by statement. <p> In the active model, G a4 is constructed similarly. Instead of the secret sharing protocol, a verifiable secret sharing protocol is used. Moreover, reconstruction involves error correction. As multiplication protocol we use the protocol that robustly multiplies two shared values, as described in <ref> [2] </ref>. The protocol to jointly select a random field element (as described above) uses verifiable secret sharing. <p> This is a strict extension of the adversary structure tolerated by the 6-player protocol of <ref> [2] </ref>, which consists of all adversaries containing a single player. 3.2 Definitions Consider a multi-party protocol S among the player set ^ P . <p> adversary structure A := fA P : fp r i 2 P : A =2 A i g 2 Ag : 4 Completeness results In the passive model, the only basic protocol generator we use in the constructions is G p3 , the protocol generator of Ben-Or, Goldwasser, and Wigderson <ref> [2] </ref> with three players for the passive model that tolerates all single-player collu sions. In the active model, the only basic protocol generator we use in the constructions is G a4 , the protocol generator of [2] with four players for the active model that tolerates all single-player adversaries. <p> the constructions is G p3 , the protocol generator of Ben-Or, Goldwasser, and Wigderson <ref> [2] </ref> with three players for the passive model that tolerates all single-player collu sions. In the active model, the only basic protocol generator we use in the constructions is G a4 , the protocol generator of [2] with four players for the active model that tolerates all single-player adversaries. In the active model with broadcast, the only basic protocol generator we use is G a3b , the protocol generator of [27] with three players that tolerates all single-player adversaries. <p> A protocol generator G fl that tolerates C can be constructed as follows: Remember that G p3 is the standard 1-private protocol generator of <ref> [2] </ref> for the three-player set ~ P = f ~p 1 ; ~p 2 ; ~p 3 g, tolerating the collusion structure ~ C = ff ~p 1 g; f ~p 2 g; f ~p 3 gg. <p> Such a protocol does not exist for most functions (for example for the binary OR-function), as stated in <ref> [2] </ref>, thus resulting in a contradiction. <p> The protocols in the passive and the active model offer perfect security (as those of <ref> [2] </ref>) and have complexities polynomial in the size of the description of the adversary structure. The protocols in the active model with broadcast offer unconditional security. The achieved efficiency is slightly greater than polynomial. It remains an open problem to construct such protocols that are strictly polynomial.
Reference: [3] <author> Canetti, R. </author> <title> Studies in Secure Multiparty Computation and Applications. </title> <type> PhD thesis, </type> <institution> Weizmann Institute of Science, Rehovot 76100, Israel, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: Nevertheless they want to compute some agreed function of their inputs in a secure way. Security here means maintaining correctness of the output while keeping the players' inputs private. This is the well-known secure multiparty computation problem (e.g. [29, 21]). For an excellent overview see <ref> [17, 3, 16] </ref>. There exists a rich literature on the subject. These approaches can be classified according to a number of criteria that are briefly discussed below.
Reference: [4] <author> Canetti, R., Feige, U., Goldreich, O., and Naor, M. </author> <title> Adaptively secure multi-party computation. </title> <booktitle> In Proc. 28th ACM Symposium on the Theory of Computing (STOC) (1996), </booktitle> <pages> pp. 639-648. </pages>
Reference-contexts: In the information-theoretic model one can distinguish between protocols with small (e.g. [7, 27]) or with zero failure probability (e.g. [2]). We refer to the latter as perfect multi-party computation. The types of tolerable adversaries have recently been generalized in a number of directions (adaptive adversaries <ref> [4] </ref> and uncoercibil-ity [5]), and some authors have investigated multi-party computation for various minimality and complexity criteria [12, 11, 18, 26, 27, 22]. All previous results in the literature specify the sets of potential adverse players (passive or active) that can be tolerated by their cardinality, i.e. by a threshold.
Reference: [5] <author> Canetti, R., and Gennaro, R. </author> <title> Incoercible multi-party computation. </title> <booktitle> In Proc. 37th IEEE Symposium on the Foundations of Computer Science (FOCS) (1996). </booktitle>
Reference-contexts: In the information-theoretic model one can distinguish between protocols with small (e.g. [7, 27]) or with zero failure probability (e.g. [2]). We refer to the latter as perfect multi-party computation. The types of tolerable adversaries have recently been generalized in a number of directions (adaptive adversaries [4] and uncoercibil-ity <ref> [5] </ref>), and some authors have investigated multi-party computation for various minimality and complexity criteria [12, 11, 18, 26, 27, 22]. All previous results in the literature specify the sets of potential adverse players (passive or active) that can be tolerated by their cardinality, i.e. by a threshold.
Reference: [6] <editor> Chaum, D. </editor> <booktitle> The spymasters double-agent problem. In Advances in Cryptology | CRYPTO '89 (1989), vol. 435 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 591-602. </pages>
Reference-contexts: However, such generalized threshold-type results are not sufficient for capturing general scenarios of mutual trust and distrust. For example, assume that a number of spy-masters wish to compute a list of double agents <ref> [6] </ref>, i.e., agents working for at least two different countries, without revealing the agent lists to each other. <p> in S by a subprotocol among a set 9 P 0 of players (the players in P 0 can be members of ^ P and also need not be distinct) applying a protocol generator G 0 8 The idea of replacing a single player by a subprotocol was used in <ref> [6] </ref> for a different purpose. 9 Formally, this is a list of players.
Reference: [7] <author> Chaum, D., Cr epeau, C., and Damg -ard, I. </author> <title> Mul-tiparty unconditionally secure protocols (extended abstract). </title> <booktitle> In Proc. 20th ACM Symposium on the Theory of Computing (STOC) (1988), </booktitle> <pages> pp. 11-19. </pages>
Reference-contexts: This is the well-known secure multiparty computation problem (e.g. [29, 21]). For an excellent overview see [17, 3, 16]. There exists a rich literature on the subject. These approaches can be classified according to a number of criteria that are briefly discussed below. Some papers (e.g. <ref> [29, 21, 19, 2, 7, 27] </ref>) describe protocol constructors which To appear in the Proceedings of the Sixteenth ACM Symposium on Principles of Distributed Computing (PODC), August 1997. for any function generate a protocol for securely computing it, while other approaches are tailored to a particular function like voting (e.g. [10]), <p> Adversaries are classified according to their computational resources (limited, hence cryptographic security, e.g. [8, 21], or unlimited, hence unconditional or information theoretic security, e.g. <ref> [2, 7, 27] </ref>), and according to whether they cheat actively or passively. A set of active adverse players is called an adversary, a set of passive cheaters is called a (passive) collusion. <p> A set of active adverse players is called an adversary, a set of passive cheaters is called a (passive) collusion. In the information-theoretic model one can distinguish between protocols with small (e.g. <ref> [7, 27] </ref>) or with zero failure probability (e.g. [2]). We refer to the latter as perfect multi-party computation. <p> We refer to these two models as the passive and the active model. The same results were obtained independently by Chaum, Crepeau and Damg-ard <ref> [7] </ref> in an unconditional model with exponentially small error probability. Rabin and Ben-Or [27] proved that, in an unconditional (but not perfect) model with a broadcast channel, active adversaries with less than n=2 members can be tolerated. <p> First, we provide a framework for player substitution and derive the corresponding tolerated adversary structures (Theorems 1 and 2). Second, we give the exact characterization of which collusion structures and which adversary structures can be tolerated: 1. As a strict generalization of the threshold-type results of <ref> [2, 7] </ref>, we prove that in the passive model, perfect multi-party computation for any function is possible if and only if no two potential passive collusions add up to the full player set. 2. As a strict generalization of the threshold-type result of [2, 7] we prove that in the active <p> strict generalization of the threshold-type results of <ref> [2, 7] </ref>, we prove that in the passive model, perfect multi-party computation for any function is possible if and only if no two potential passive collusions add up to the full player set. 2. As a strict generalization of the threshold-type result of [2, 7] we prove that in the active model, perfect multi-party computation for any function is possible if and only if no three potential active adversaries add up to the full player set. 3.
Reference: [8] <author> Chaum, D., Damg -ard, I., and Graaf, J. v. </author> <title> Mul-tiparty computations ensuring privacy of each party's input and correctness of the result. </title> <booktitle> In Advances in Cryptology | CRYPTO '87 (1987), vol. 293 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 87-119. </pages>
Reference-contexts: The communication models differ with respect to whether or not broadcast channels and/or secure communication channels are available, and whether the communication channels are synchronous or asynchronous. Adversaries are classified according to their computational resources (limited, hence cryptographic security, e.g. <ref> [8, 21] </ref>, or unlimited, hence unconditional or information theoretic security, e.g. [2, 7, 27]), and according to whether they cheat actively or passively. A set of active adverse players is called an adversary, a set of passive cheaters is called a (passive) collusion.
Reference: [9] <author> Chor, B., and Kushilevitz, E. </author> <title> A zero-one law for Boolean privacy. </title> <booktitle> In Proc. 21st ACM Symposium on the Theory of Computing (STOC) (1989), </booktitle> <volume> vol. 21, </volume> <pages> pp. 62-72. </pages>
Reference-contexts: The sequence t i is hence defined by 10 If the two sets in C add up to the full player set, almost every nontrivial function cannot be computed securely. A similar statement hold for the active case (Theorems 4 and 5). For a more precise analysis see <ref> [9, 22] </ref>. t 0 = 2, t 1 = 3, and t i+1 = t i + bt i =2c. One can show that (3=2) i t i (3=2) i+2 .
Reference: [10] <author> Cramer, R., Franklin, M., Schoenmakers, B., and Yung, M. </author> <title> Multi-authority secret-ballot elections with linear work. </title> <booktitle> In Advances in Cryptology | EU-ROCRYPT '96 (1996), vol. 1070 of Lecture Notes in Computer Science, </booktitle> <address> IACR, </address> <publisher> Springer-Verlag, </publisher> <pages> pp. 72-83. </pages>
Reference-contexts: [29, 21, 19, 2, 7, 27]) describe protocol constructors which To appear in the Proceedings of the Sixteenth ACM Symposium on Principles of Distributed Computing (PODC), August 1997. for any function generate a protocol for securely computing it, while other approaches are tailored to a particular function like voting (e.g. <ref> [10] </ref>), auctioning [15], or collective signing [28]. The major reason for considering special functions is the potential gain of efficiency compared to a general solution.
Reference: [11] <author> Cr epeau, C., Graaf, J. v., and Tapp, A. </author> <title> Committed oblivious transfer and private multi-party computation. </title> <booktitle> In Advances in Cryptology | CRYPTO '95 (1995), vol. 963 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 110-123. 9 </pages>
Reference-contexts: We refer to the latter as perfect multi-party computation. The types of tolerable adversaries have recently been generalized in a number of directions (adaptive adversaries [4] and uncoercibil-ity [5]), and some authors have investigated multi-party computation for various minimality and complexity criteria <ref> [12, 11, 18, 26, 27, 22] </ref>. All previous results in the literature specify the sets of potential adverse players (passive or active) that can be tolerated by their cardinality, i.e. by a threshold.
Reference: [12] <author> Feige, U., Kilian, J., and Naor, M. </author> <title> A minimal model for secure computation. </title> <booktitle> In Proc. 26th ACM Symposium on the Theory of Computing (STOC) (1994), </booktitle> <pages> pp. 554-563. </pages>
Reference-contexts: We refer to the latter as perfect multi-party computation. The types of tolerable adversaries have recently been generalized in a number of directions (adaptive adversaries [4] and uncoercibil-ity [5]), and some authors have investigated multi-party computation for various minimality and complexity criteria <ref> [12, 11, 18, 26, 27, 22] </ref>. All previous results in the literature specify the sets of potential adverse players (passive or active) that can be tolerated by their cardinality, i.e. by a threshold.
Reference: [13] <author> Feldman, P., and Micali, S. </author> <title> Optimal algorithms for Byzantine agreement. </title> <booktitle> In Proc. 20th ACM Symposium on the Theory of Computing (STOC) (1988), </booktitle> <pages> pp. 148-161. </pages>
Reference-contexts: The basic protocols of [2] can be realized without broadcast or, more precisely, by simulating it with a protocol among the sender and the receivers of the broadcast <ref> [23, 13] </ref>. The active model with broadcast is the same as that of [27]: We assume reliable synchronous secure channels between every pair of two players and a broadcast channel. More formally, in the passive model we assume that all players correctly follow the protocol.
Reference: [14] <author> Fitzi, M. </author> <title> Erweiterte Zugriffstrukturen in Multi-Party-Computation. </title> <type> Diploma thesis, </type> <institution> ETH Zurich, </institution> <year> 1996. </year>
Reference-contexts: However, in a more general scenario the 1 The constructions of polynomial protocols are based on joint work with Matthias Fitzi <ref> [14] </ref>. set of tolerated dishonest players is not specified by a threshold.
Reference: [15] <author> Franklin, M., and Reiter, M. </author> <title> The design and implementation of a secure auction service. </title> <journal> IEEE Transactions on Software Engineering 22, </journal> <volume> 5 (1996), </volume> <pages> 302-312. </pages>
Reference-contexts: 19, 2, 7, 27]) describe protocol constructors which To appear in the Proceedings of the Sixteenth ACM Symposium on Principles of Distributed Computing (PODC), August 1997. for any function generate a protocol for securely computing it, while other approaches are tailored to a particular function like voting (e.g. [10]), auctioning <ref> [15] </ref>, or collective signing [28]. The major reason for considering special functions is the potential gain of efficiency compared to a general solution. The communication models differ with respect to whether or not broadcast channels and/or secure communication channels are available, and whether the communication channels are synchronous or asynchronous.
Reference: [16] <author> Franklin, M., and Yung, M. </author> <title> The varieties of secure distributed computation. In Sequences II: Methods in Communication, Security, </title> <booktitle> and Computer Science (1991), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 392-417. </pages>
Reference-contexts: Nevertheless they want to compute some agreed function of their inputs in a secure way. Security here means maintaining correctness of the output while keeping the players' inputs private. This is the well-known secure multiparty computation problem (e.g. [29, 21]). For an excellent overview see <ref> [17, 3, 16] </ref>. There exists a rich literature on the subject. These approaches can be classified according to a number of criteria that are briefly discussed below.
Reference: [17] <author> Franklin, M. K. </author> <title> Complexity and Security of Distributed Protocols. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <year> 1993. </year>
Reference-contexts: Nevertheless they want to compute some agreed function of their inputs in a secure way. Security here means maintaining correctness of the output while keeping the players' inputs private. This is the well-known secure multiparty computation problem (e.g. [29, 21]). For an excellent overview see <ref> [17, 3, 16] </ref>. There exists a rich literature on the subject. These approaches can be classified according to a number of criteria that are briefly discussed below.
Reference: [18] <author> Franklin, M. K., and Yung, M. </author> <title> Communication complexity of secure computation. </title> <booktitle> In Proc. 24th ACM Symposium on the Theory of Computing (STOC) (1992), </booktitle> <pages> pp. 699-710. </pages>
Reference-contexts: We refer to the latter as perfect multi-party computation. The types of tolerable adversaries have recently been generalized in a number of directions (adaptive adversaries [4] and uncoercibil-ity [5]), and some authors have investigated multi-party computation for various minimality and complexity criteria <ref> [12, 11, 18, 26, 27, 22] </ref>. All previous results in the literature specify the sets of potential adverse players (passive or active) that can be tolerated by their cardinality, i.e. by a threshold.
Reference: [19] <author> Galil, Z., Haber, S., and Yung, M. </author> <title> Cryptographic computation: Secure fault-tolerant protocols and the public-key model. </title> <booktitle> In Advances in Cryptology | CRYPTO '87 (1987), vol. 293 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 135-155. </pages>
Reference-contexts: This is the well-known secure multiparty computation problem (e.g. [29, 21]). For an excellent overview see [17, 3, 16]. There exists a rich literature on the subject. These approaches can be classified according to a number of criteria that are briefly discussed below. Some papers (e.g. <ref> [29, 21, 19, 2, 7, 27] </ref>) describe protocol constructors which To appear in the Proceedings of the Sixteenth ACM Symposium on Principles of Distributed Computing (PODC), August 1997. for any function generate a protocol for securely computing it, while other approaches are tailored to a particular function like voting (e.g. [10]),
Reference: [20] <author> Gennaro, R. </author> <title> Theory and Practice of Verifiable Secret Sharing. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology (MIT), </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: Third, our results can also be seen in the context of verifiable secret sharing: we implicitly provide such schemes for general access structures, thereby solving some open problems stated at the end of Chapter 3 in Gennaro's Ph.D. thesis <ref> [20] </ref>. The emphasis of this paper is on the existence of protocols. In addition, the presented protocols for the passive and the active model have time and communication complexities polynomial in the size of the description of the adversary structures 1 .
Reference: [21] <author> Goldreich, O., Micali, S., and Wigderson, A. </author> <title> How to play any mental game | a completeness theorem for protocols with honest majority. </title> <booktitle> In Proc. 19th ACM Symposium on the Theory of Computing (STOC) (1987), </booktitle> <pages> pp. 218-229. </pages>
Reference-contexts: Nevertheless they want to compute some agreed function of their inputs in a secure way. Security here means maintaining correctness of the output while keeping the players' inputs private. This is the well-known secure multiparty computation problem (e.g. <ref> [29, 21] </ref>). For an excellent overview see [17, 3, 16]. There exists a rich literature on the subject. These approaches can be classified according to a number of criteria that are briefly discussed below. <p> This is the well-known secure multiparty computation problem (e.g. [29, 21]). For an excellent overview see [17, 3, 16]. There exists a rich literature on the subject. These approaches can be classified according to a number of criteria that are briefly discussed below. Some papers (e.g. <ref> [29, 21, 19, 2, 7, 27] </ref>) describe protocol constructors which To appear in the Proceedings of the Sixteenth ACM Symposium on Principles of Distributed Computing (PODC), August 1997. for any function generate a protocol for securely computing it, while other approaches are tailored to a particular function like voting (e.g. [10]), <p> The communication models differ with respect to whether or not broadcast channels and/or secure communication channels are available, and whether the communication channels are synchronous or asynchronous. Adversaries are classified according to their computational resources (limited, hence cryptographic security, e.g. <ref> [8, 21] </ref>, or unlimited, hence unconditional or information theoretic security, e.g. [2, 7, 27]), and according to whether they cheat actively or passively. A set of active adverse players is called an adversary, a set of passive cheaters is called a (passive) collusion. <p> These protocols consist of three stages: the input stage, the computation stage and the output stage. In this paper, we consider a more general model in which a multi-party computation is seen as the simulation of a trusted party <ref> [21] </ref>. A protocol S among a player set ^ P involving variables from the variable space X is a sequence s 1 ; s 2 ; : : : ; s l of statements (see below).
Reference: [22] <author> Kushilevitz, E. </author> <title> Privacy and communication complexity (extended abstract). </title> <booktitle> In Proc. 30th IEEE Symposium on the Foundations of Computer Science (FOCS) (1989), </booktitle> <pages> pp. 416-421. </pages>
Reference-contexts: We refer to the latter as perfect multi-party computation. The types of tolerable adversaries have recently been generalized in a number of directions (adaptive adversaries [4] and uncoercibil-ity [5]), and some authors have investigated multi-party computation for various minimality and complexity criteria <ref> [12, 11, 18, 26, 27, 22] </ref>. All previous results in the literature specify the sets of potential adverse players (passive or active) that can be tolerated by their cardinality, i.e. by a threshold. <p> The sequence t i is hence defined by 10 If the two sets in C add up to the full player set, almost every nontrivial function cannot be computed securely. A similar statement hold for the active case (Theorems 4 and 5). For a more precise analysis see <ref> [9, 22] </ref>. t 0 = 2, t 1 = 3, and t i+1 = t i + bt i =2c. One can show that (3=2) i t i (3=2) i+2 .
Reference: [23] <author> Lamport, L., Shostak, R., and Pease, M. </author> <title> The Byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems 4, </journal> <volume> 3 (1982), </volume> <pages> 382-401. </pages>
Reference-contexts: The basic protocols of [2] can be realized without broadcast or, more precisely, by simulating it with a protocol among the sender and the receivers of the broadcast <ref> [23, 13] </ref>. The active model with broadcast is the same as that of [27]: We assume reliable synchronous secure channels between every pair of two players and a broadcast channel. More formally, in the passive model we assume that all players correctly follow the protocol. <p> Such a protocol does not exist for most functions (for example for the broadcast function, as proven in <ref> [25, 23] </ref>), thus resulting in a contradiction. 7 Theorem 5 In the active model with broadcast, a player set P can compute every function unconditionally A-privately, A-resiliently and A-robustly if no two adversaries in the adversary structure A add up to the full player set P (i.e. if Q (2) (P;
Reference: [24] <author> Micali, S., and Rogaway, P. </author> <title> Secure computation. </title> <booktitle> In Advances in Cryptology | CRYPTO '91 (1991), vol. 576 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 392-404. </pages>
Reference-contexts: The presented techniques are general in the sense that they can be applied to any multi-party protocols. The player substitution techniques can also be applied in the computational model of multi-party computation, but the security of such composite protocols remains to be proven <ref> [1, 24] </ref>. Acknowledgments We would like to thank Matthias Fitzi for his contributions on efficient protocols. We are very grateful to Oded Gold reich for his detailed comments, and for repeatedly encouraging us to improve the clarity of the presentation.
Reference: [25] <author> Pease, M., Shostak, R., and Lamport, L. </author> <title> Reaching agreement in the presence of faults. </title> <journal> Journal of the ACM 27, </journal> <volume> 2 (1980), </volume> <pages> 228-234. </pages>
Reference-contexts: Such a protocol does not exist for most functions (for example for the broadcast function, as proven in <ref> [25, 23] </ref>), thus resulting in a contradiction. 7 Theorem 5 In the active model with broadcast, a player set P can compute every function unconditionally A-privately, A-resiliently and A-robustly if no two adversaries in the adversary structure A add up to the full player set P (i.e. if Q (2) (P;
Reference: [26] <author> Rabin, T. </author> <title> Robust sharing of secrets when the dealer is honest or cheating. </title> <journal> Journal of the ACM 41, </journal> <volume> 6 (1994), </volume> <pages> 1089-1109. </pages>
Reference-contexts: We refer to the latter as perfect multi-party computation. The types of tolerable adversaries have recently been generalized in a number of directions (adaptive adversaries [4] and uncoercibil-ity [5]), and some authors have investigated multi-party computation for various minimality and complexity criteria <ref> [12, 11, 18, 26, 27, 22] </ref>. All previous results in the literature specify the sets of potential adverse players (passive or active) that can be tolerated by their cardinality, i.e. by a threshold.
Reference: [27] <author> Rabin, T., and Ben-Or, M. </author> <title> Verifiable secret sharing and multiparty protocols with honest majority. </title> <booktitle> In Proc. 21st ACM Symposium on the Theory of Computing (STOC) (1989), </booktitle> <pages> pp. 73-85. </pages>
Reference-contexts: This is the well-known secure multiparty computation problem (e.g. [29, 21]). For an excellent overview see [17, 3, 16]. There exists a rich literature on the subject. These approaches can be classified according to a number of criteria that are briefly discussed below. Some papers (e.g. <ref> [29, 21, 19, 2, 7, 27] </ref>) describe protocol constructors which To appear in the Proceedings of the Sixteenth ACM Symposium on Principles of Distributed Computing (PODC), August 1997. for any function generate a protocol for securely computing it, while other approaches are tailored to a particular function like voting (e.g. [10]), <p> Adversaries are classified according to their computational resources (limited, hence cryptographic security, e.g. [8, 21], or unlimited, hence unconditional or information theoretic security, e.g. <ref> [2, 7, 27] </ref>), and according to whether they cheat actively or passively. A set of active adverse players is called an adversary, a set of passive cheaters is called a (passive) collusion. <p> A set of active adverse players is called an adversary, a set of passive cheaters is called a (passive) collusion. In the information-theoretic model one can distinguish between protocols with small (e.g. <ref> [7, 27] </ref>) or with zero failure probability (e.g. [2]). We refer to the latter as perfect multi-party computation. <p> We refer to the latter as perfect multi-party computation. The types of tolerable adversaries have recently been generalized in a number of directions (adaptive adversaries [4] and uncoercibil-ity [5]), and some authors have investigated multi-party computation for various minimality and complexity criteria <ref> [12, 11, 18, 26, 27, 22] </ref>. All previous results in the literature specify the sets of potential adverse players (passive or active) that can be tolerated by their cardinality, i.e. by a threshold. <p> We refer to these two models as the passive and the active model. The same results were obtained independently by Chaum, Crepeau and Damg-ard [7] in an unconditional model with exponentially small error probability. Rabin and Ben-Or <ref> [27] </ref> proved that, in an unconditional (but not perfect) model with a broadcast channel, active adversaries with less than n=2 members can be tolerated. <p> As a strict generalization of the threshold-type result of <ref> [27] </ref> we prove that in the active model with broadcast, unconditional multiparty computation for any function is possible if and only if no two potential active adversaries add up to the full player set. <p> The basic protocols of [2] can be realized without broadcast or, more precisely, by simulating it with a protocol among the sender and the receivers of the broadcast [23, 13]. The active model with broadcast is the same as that of <ref> [27] </ref>: We assume reliable synchronous secure channels between every pair of two players and a broadcast channel. More formally, in the passive model we assume that all players correctly follow the protocol. <p> Furthermore, let G a3b denote the three-party protocol generator of <ref> [27] </ref> in the active model with broadcast, tolerating one arbitrary adversary with a single player. In order to explicitly construct the protocol generators G p3 , G a4 , and G a3b using the results of [2] and [27], we scan the multi-party computation specification statement by statement. <p> Furthermore, let G a3b denote the three-party protocol generator of <ref> [27] </ref> in the active model with broadcast, tolerating one arbitrary adversary with a single player. In order to explicitly construct the protocol generators G p3 , G a4 , and G a3b using the results of [2] and [27], we scan the multi-party computation specification statement by statement. Let (S; t ) be the multi-party computation specification, where S is a statement sequence s 1 ; : : : ; s l among the player set ^ P and where t is the trusted party to be simulated. <p> The protocol to jointly select a random field element (as described above) uses verifiable secret sharing. In the active model with broadcast the protocol generator G a3b can be constructed along the same lines, applying the tools of <ref> [27] </ref>. 3 Substituting players The basic tool for achieving security in non-threshold scenarios is to replace players by subprotocols 8 . <p> In the active model with broadcast, the only basic protocol generator we use is G a3b , the protocol generator of <ref> [27] </ref> with three players that tolerates all single-player adversaries. In this section we show for which adversary structures it is possible to find a substitution strategy such that the adversary structure is tolerated. <p> There are at most 3 2 jAje basic protocols involved, thus the error probability of the basic protocol must be chosen as " 0 " jAj O (1) . Therefore, the size of the field in <ref> [27] </ref> must be increased accordingly. This results in a slightly slower basic protocol. Hence the communication complexity of the resulting pro tocol is in jSj O (log jA) hence slightly greater than polynomial in jAj. The round complexity remains polynomial.
Reference: [28] <author> Santis, A. d., Desmedt, Y., Frankel, Y., and Yung, M. </author> <title> How to share a function securely. </title> <booktitle> In Proc. 26th ACM Symposium on the Theory of Computing (STOC) (1994), </booktitle> <pages> pp. 522-533. </pages>
Reference-contexts: describe protocol constructors which To appear in the Proceedings of the Sixteenth ACM Symposium on Principles of Distributed Computing (PODC), August 1997. for any function generate a protocol for securely computing it, while other approaches are tailored to a particular function like voting (e.g. [10]), auctioning [15], or collective signing <ref> [28] </ref>. The major reason for considering special functions is the potential gain of efficiency compared to a general solution. The communication models differ with respect to whether or not broadcast channels and/or secure communication channels are available, and whether the communication channels are synchronous or asynchronous.
Reference: [29] <author> Yao, A. C. </author> <title> Protocols for secure computations. </title> <booktitle> In Proc. 23rd IEEE Symposium on the Foundations of Computer Science (FOCS) (1982), IEEE, </booktitle> <pages> pp. 160-164. 10 </pages>
Reference-contexts: Nevertheless they want to compute some agreed function of their inputs in a secure way. Security here means maintaining correctness of the output while keeping the players' inputs private. This is the well-known secure multiparty computation problem (e.g. <ref> [29, 21] </ref>). For an excellent overview see [17, 3, 16]. There exists a rich literature on the subject. These approaches can be classified according to a number of criteria that are briefly discussed below. <p> This is the well-known secure multiparty computation problem (e.g. [29, 21]). For an excellent overview see [17, 3, 16]. There exists a rich literature on the subject. These approaches can be classified according to a number of criteria that are briefly discussed below. Some papers (e.g. <ref> [29, 21, 19, 2, 7, 27] </ref>) describe protocol constructors which To appear in the Proceedings of the Sixteenth ACM Symposium on Principles of Distributed Computing (PODC), August 1997. for any function generate a protocol for securely computing it, while other approaches are tailored to a particular function like voting (e.g. [10]),
References-found: 29

