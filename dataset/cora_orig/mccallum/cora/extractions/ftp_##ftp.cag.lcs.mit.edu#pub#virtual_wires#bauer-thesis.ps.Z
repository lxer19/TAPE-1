URL: ftp://ftp.cag.lcs.mit.edu/pub/virtual_wires/bauer-thesis.ps.Z
Refering-URL: http://www.cag.lcs.mit.edu/vwires/papers/index.html
Root-URL: 
Title: The Design of an Efficient Hardware Subroutine Protocol for FPGAs  
Author: by Trevor Joseph Bauer Anant Agarwal 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degrees of Bachelor of Science in Electrical Science and Engineering and Master of Engineering in Electrical Engineering and Computer Science at the  All rights reserved The author hereby grants to MIT permission to reproduce and to distribute copies of this thesis document in whole or in part, and to grant others the right to do so. Signature of Author  Certified by  Thesis Supervisor Accepted by F. R. Morgenthaler Chairman, Department Committee on Graduate Theses  
Note: c Trevor J. Bauer,  
Date: May 1994  1994  May 16, 1994  
Affiliation: MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Agarwal, J. Kubiatowicz, D. Kranz, B.-H. Lim, D. Yeung, G. D'Souza, and M. Parkin. Sparcle: </author> <title> An Evolutionary Processor Design for Multiprocessors. </title> <journal> IEEE Micro, </journal> <volume> 13(3) </volume> <pages> 48-61, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: This group invented and implemented a system through which pin limitations, normally imposed when large netlists are partitioned, can be avoided. Thus, large netlists are simulated on a small number of FPGAs <ref> [1] </ref>. Complete systems which perform this task are marketed by several companies. <p> changes2; output [3:0] chngs; // state names parameter WRITE=0, SORT1=1, SORT2=2, DONE=3; reg [7:0] data0, data1, data2, data3, data4, data5, data6, data7; wire doneN; reg changes1, changes2; reg [3:0] chngs; reg [1:0] state, next_state; // doneN is active (low) if we are in the DONE state nand u1 (doneN, state <ref> [1] </ref>, state [0]); always @( posedge clk ) begin // if weN is active (low) state = WRITE. state = next_state & -weN, weN-; case (state) WRITE: begin // start state: set up for write data0 = datain0 [15:8]; data1 = datain0 [7:0]; data2 = datain1 [15:8]; data3 = datain1 [7:0]; <p> SORT1: begin sort (data0, data1, chngs [0]); sort (data2, data3, chngs <ref> [1] </ref>); sort (data4, data5, chngs [2]); sort (data6, data7, chngs [3]); changes1 = (chngs [0] | chngs [1] | chngs [2] | chngs [3]); if (changes2 | changes1) next_state = SORT2; else next_state = DONE; end // SORT2 corresponds to an offset of 1. <p> SORT1: begin sort (data0, data1, chngs [0]); sort (data2, data3, chngs <ref> [1] </ref>); sort (data4, data5, chngs [2]); sort (data6, data7, chngs [3]); changes1 = (chngs [0] | chngs [1] | chngs [2] | chngs [3]); if (changes2 | changes1) next_state = SORT2; else next_state = DONE; end // SORT2 corresponds to an offset of 1. SORT2: begin sort (data1, data2, chngs [0]); sort (data3, data4, chngs [1]); sort (data5, data6, chngs [2]); sort (data0, data7, chngs [3]); changes2 = <p> [2]); sort (data6, data7, chngs [3]); changes1 = (chngs [0] | chngs <ref> [1] </ref> | chngs [2] | chngs [3]); if (changes2 | changes1) next_state = SORT2; else next_state = DONE; end // SORT2 corresponds to an offset of 1. SORT2: begin sort (data1, data2, chngs [0]); sort (data3, data4, chngs [1]); sort (data5, data6, chngs [2]); sort (data0, data7, chngs [3]); changes2 = (chngs [0] | chngs [1] | chngs [2] | chngs [3]); if (changes2 | changes1) next_state = SORT1; else next_state = DONE; end DONE: begin if (!weN) // This is not really needed because // state = nextstate <p> SORT2: begin sort (data1, data2, chngs [0]); sort (data3, data4, chngs <ref> [1] </ref>); sort (data5, data6, chngs [2]); sort (data0, data7, chngs [3]); changes2 = (chngs [0] | chngs [1] | chngs [2] | chngs [3]); if (changes2 | changes1) next_state = SORT1; else next_state = DONE; end DONE: begin if (!weN) // This is not really needed because // state = nextstate & weN next_state = WRITE; else next_state = DONE; end endcase end task sort; inout [7:0] sort_data1; <p> fopen (OUTPUT_FILE, "w"); int i, tmp; /* read array of data from file */ for (i = 0; i &lt; NUM_ELEMENTS; i++) - fscanf (input_stream, "%d", &tmp); indata [i] = (unsigned char) tmp; - #ifdef USE_HARDWARE_SUBROUTINE reset_board (NUM_ELEMENTS, 1); run_board (indata, NUM_ELEMENTS, outdata, 1); #else innerp (indata, NUM_ELEMENTS); 49 outdata <ref> [1] </ref> = indata [0]; #endif /* write sorted array out to a file */ printf ("The answer is %d."n", outdata [1]); /* tie up lose ends */ fclose (input_stream); fclose (output_stream); - D.2 Inner-Product Software Subroutine void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data [8] <p> NUM_ELEMENTS; i++) - fscanf (input_stream, "%d", &tmp); indata [i] = (unsigned char) tmp; - #ifdef USE_HARDWARE_SUBROUTINE reset_board (NUM_ELEMENTS, 1); run_board (indata, NUM_ELEMENTS, outdata, 1); #else innerp (indata, NUM_ELEMENTS); 49 outdata <ref> [1] </ref> = indata [0]; #endif /* write sorted array out to a file */ printf ("The answer is %d."n", outdata [1]); /* tie up lose ends */ fclose (input_stream); fclose (output_stream); - D.2 Inner-Product Software Subroutine void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data [8] + data [1] * data [9] + data [2] * data [10] + data [3] * data [11] + data <p> [0]; #endif /* write sorted array out to a file */ printf ("The answer is %d."n", outdata <ref> [1] </ref>); /* tie up lose ends */ fclose (input_stream); fclose (output_stream); - D.2 Inner-Product Software Subroutine void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data [8] + data [1] * data [9] + data [2] * data [10] + data [3] * data [11] + data [4] * data [12] + data [5] * data [13] + data [6] * data [14] + data [7] * data [15]); - D.3 Inner-Product Hardware Subroutine module test (weN, dataina0, dataina1, dataina2,
Reference: [2] <author> J. M. Arnold. </author> <title> The splash 2 software environment. </title> <publisher> IEEE, </publisher> <month> July </month> <year> 1993. </year>
Reference-contexts: More closely resembling a true reconfigurable system is the Splash Board [6]. Splash effectively uses FPGAs as a reconfigurable parallel computation resource. Splash 2 (the successor of Splash) is a special purpose parallel processor which primarily uses FPGAs for computation; the microprocessor serves only for support <ref> [2] </ref>. 2.2.3 FPGA Computing/ Adaptable Systems This study is categorized as FPGA computing, specifically hardware subroutines. A great deal of research has been done in the past regarding similar investigations. <p> SORT1: begin sort (data0, data1, chngs [0]); sort (data2, data3, chngs [1]); sort (data4, data5, chngs <ref> [2] </ref>); sort (data6, data7, chngs [3]); changes1 = (chngs [0] | chngs [1] | chngs [2] | chngs [3]); if (changes2 | changes1) next_state = SORT2; else next_state = DONE; end // SORT2 corresponds to an offset of 1. <p> SORT1: begin sort (data0, data1, chngs [0]); sort (data2, data3, chngs [1]); sort (data4, data5, chngs <ref> [2] </ref>); sort (data6, data7, chngs [3]); changes1 = (chngs [0] | chngs [1] | chngs [2] | chngs [3]); if (changes2 | changes1) next_state = SORT2; else next_state = DONE; end // SORT2 corresponds to an offset of 1. SORT2: begin sort (data1, data2, chngs [0]); sort (data3, data4, chngs [1]); sort (data5, data6, chngs [2]); sort (data0, data7, chngs [3]); changes2 = (chngs [0] | <p> [3]); changes1 = (chngs [0] | chngs [1] | chngs <ref> [2] </ref> | chngs [3]); if (changes2 | changes1) next_state = SORT2; else next_state = DONE; end // SORT2 corresponds to an offset of 1. SORT2: begin sort (data1, data2, chngs [0]); sort (data3, data4, chngs [1]); sort (data5, data6, chngs [2]); sort (data0, data7, chngs [3]); changes2 = (chngs [0] | chngs [1] | chngs [2] | chngs [3]); if (changes2 | changes1) next_state = SORT1; else next_state = DONE; end DONE: begin if (!weN) // This is not really needed because // state = nextstate & weN next_state = WRITE; <p> SORT2: begin sort (data1, data2, chngs [0]); sort (data3, data4, chngs [1]); sort (data5, data6, chngs <ref> [2] </ref>); sort (data0, data7, chngs [3]); changes2 = (chngs [0] | chngs [1] | chngs [2] | chngs [3]); if (changes2 | changes1) next_state = SORT1; else next_state = DONE; end DONE: begin if (!weN) // This is not really needed because // state = nextstate & weN next_state = WRITE; else next_state = DONE; end endcase end task sort; inout [7:0] sort_data1; inout [7:0] sort_data2; <p> out to a file */ printf ("The answer is %d."n", outdata [1]); /* tie up lose ends */ fclose (input_stream); fclose (output_stream); - D.2 Inner-Product Software Subroutine void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data [8] + data [1] * data [9] + data <ref> [2] </ref> * data [10] + data [3] * data [11] + data [4] * data [12] + data [5] * data [13] + data [6] * data [14] + data [7] * data [15]); - D.3 Inner-Product Hardware Subroutine module test (weN, dataina0, dataina1, dataina2, dataina3, dataina4, dataina5, dataina6, dataina7, datainb0,
Reference: [3] <author> M. Dahl. </author> <title> An Implementation of the Virtual Wires Interconnect Scheme. </title> <type> Master's thesis, </type> <institution> EECS Department, MIT, </institution> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: They have been successfully utilized for prototyp-ing ASICs, since they have a very short development time and the cost of modifying a design is minimal. They comprise logic emulation systems <ref> [3] </ref> [13] and are sold in commercial packages to ASIC developers for this purpose. Programmable gate arrays have been used as reconfigurable processors and preprocessors in customized computing systems. And they can replace small quantities of simple ASICs. <p> Verilog is then compiled with synthesis tools to a gate level representation suitable for hardware configuration. Currently, these steps must be performed manually. Measures taken to overcome these difficulties are documented in Chapter 4, Methods. 3.2 The Virtual Wires Platform The software designed for the Virtual Wires Emulation System <ref> [3] </ref> conveniently assists in the implementation of algorithms on the FPGA array. Once a routine is designed in verilog, an LSI netlist can be synthesized. The Virtual Wires software incorporates necessary elements of virtual wires, including cell controllers, the shift registers, and the various logic partitions. <p> SORT1: begin sort (data0, data1, chngs [0]); sort (data2, data3, chngs [1]); sort (data4, data5, chngs [2]); sort (data6, data7, chngs <ref> [3] </ref>); changes1 = (chngs [0] | chngs [1] | chngs [2] | chngs [3]); if (changes2 | changes1) next_state = SORT2; else next_state = DONE; end // SORT2 corresponds to an offset of 1. <p> SORT1: begin sort (data0, data1, chngs [0]); sort (data2, data3, chngs [1]); sort (data4, data5, chngs [2]); sort (data6, data7, chngs <ref> [3] </ref>); changes1 = (chngs [0] | chngs [1] | chngs [2] | chngs [3]); if (changes2 | changes1) next_state = SORT2; else next_state = DONE; end // SORT2 corresponds to an offset of 1. SORT2: begin sort (data1, data2, chngs [0]); sort (data3, data4, chngs [1]); sort (data5, data6, chngs [2]); sort (data0, data7, chngs [3]); changes2 = (chngs [0] | chngs [1] | <p> | chngs [1] | chngs [2] | chngs <ref> [3] </ref>); if (changes2 | changes1) next_state = SORT2; else next_state = DONE; end // SORT2 corresponds to an offset of 1. SORT2: begin sort (data1, data2, chngs [0]); sort (data3, data4, chngs [1]); sort (data5, data6, chngs [2]); sort (data0, data7, chngs [3]); changes2 = (chngs [0] | chngs [1] | chngs [2] | chngs [3]); if (changes2 | changes1) next_state = SORT1; else next_state = DONE; end DONE: begin if (!weN) // This is not really needed because // state = nextstate & weN next_state = WRITE; else next_state = DONE; end <p> SORT2: begin sort (data1, data2, chngs [0]); sort (data3, data4, chngs [1]); sort (data5, data6, chngs [2]); sort (data0, data7, chngs <ref> [3] </ref>); changes2 = (chngs [0] | chngs [1] | chngs [2] | chngs [3]); if (changes2 | changes1) next_state = SORT1; else next_state = DONE; end DONE: begin if (!weN) // This is not really needed because // state = nextstate & weN next_state = WRITE; else next_state = DONE; end endcase end task sort; inout [7:0] sort_data1; inout [7:0] sort_data2; 44 inout chng_bit; <p> ("The answer is %d."n", outdata [1]); /* tie up lose ends */ fclose (input_stream); fclose (output_stream); - D.2 Inner-Product Software Subroutine void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data [8] + data [1] * data [9] + data [2] * data [10] + data <ref> [3] </ref> * data [11] + data [4] * data [12] + data [5] * data [13] + data [6] * data [14] + data [7] * data [15]); - D.3 Inner-Product Hardware Subroutine module test (weN, dataina0, dataina1, dataina2, dataina3, dataina4, dataina5, dataina6, dataina7, datainb0, datainb1, datainb2, datainb3, datainb4, datainb5, datainb6,
Reference: [4] <author> A. DeHon. </author> <title> Dpga-coupled microprocessors: </title> <booktitle> Commodity ics for the early 21st century. In IEEE Workshop on FPGAs for Custom Computing Machines, </booktitle> <address> Napa, CA. </address>
Reference-contexts: No constraints demand that FPGAs and the microprocessor (s) remain distinct. Integrated reconfigurable logic arrays may soon become a key component in future microprocessors <ref> [4] </ref>. Once this is achieved, the hardware subroutine will become 35 commonplace, and it will become advantageous to designate smaller and simpler tasks for the FPGA. <p> /* tie up lose ends */ fclose (input_stream); fclose (output_stream); - D.2 Inner-Product Software Subroutine void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data [8] + data [1] * data [9] + data [2] * data [10] + data [3] * data [11] + data <ref> [4] </ref> * data [12] + data [5] * data [13] + data [6] * data [14] + data [7] * data [15]); - D.3 Inner-Product Hardware Subroutine module test (weN, dataina0, dataina1, dataina2, dataina3, dataina4, dataina5, dataina6, dataina7, datainb0, datainb1, datainb2, datainb3, datainb4, datainb5, datainb6, datainb7, doneN, dataout, clk); input [7:0]
Reference: [5] <author> B. Fawcett. </author> <title> Taking Advantage of Reconfigurable Logic, </title> <year> 1993. </year>
Reference-contexts: The reconfigurability of CLBs opens the door to FPGA computing; this research represents one such opportunity. 13 2.2 Existing FPGA Systems FPGAs have been used in a variety of systems. Three categories of research which predominate the field are built-in diagnostics, multi-purpose hardware, and adaptable system design <ref> [5] </ref>. A number of sponsors encourage research and development in each of these areas. IEEE workshops have been held for field-programmable gate arrays, custom computing machines, and programmable logic. In addition, FPGAs have appeared in journals and workshops for computer-aided design and VLSI. <p> One of these, which will be achieved through improved fabrication processes and architectures, is a reduction of the time required for configuration. Currently, if a single Xilinx 4005 FPGA is on the same 18 board as the microprocessor the loading can be achieved in 32ms <ref> [5] </ref>. At 66Mhz this is equivalent to approximately two million clock cycles an expensive task if performed frequently. Perhaps it might be worthwhile to designate a second processor in charge of FPGA configuration. In any case, the overhead required for performing a hardware subroutine will drop as this time decreases. <p> fclose (input_stream); fclose (output_stream); - D.2 Inner-Product Software Subroutine void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data [8] + data [1] * data [9] + data [2] * data [10] + data [3] * data [11] + data [4] * data [12] + data <ref> [5] </ref> * data [13] + data [6] * data [14] + data [7] * data [15]); - D.3 Inner-Product Hardware Subroutine module test (weN, dataina0, dataina1, dataina2, dataina3, dataina4, dataina5, dataina6, dataina7, datainb0, datainb1, datainb2, datainb3, datainb4, datainb5, datainb6, datainb7, doneN, dataout, clk); input [7:0] dataina0, dataina1, dataina2, dataina3, dataina4, dataina5;
Reference: [6] <author> M. Gokhale, W. Holmes, A. Kopser, S. Lucas, R. Minnich, D. Sweeney, and D. Lopresti. </author> <title> Building and using a highly parallel programmable logic array. </title> <journal> Computer, </journal> <volume> 24(1), </volume> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: Although AnyBoard is a rapid-prototyping system used for designing special-purpose boards, a faster, cheaper system similar to the AnyBoard could be practically used as multi-purpose hardware. More closely resembling a true reconfigurable system is the Splash Board <ref> [6] </ref>. Splash effectively uses FPGAs as a reconfigurable parallel computation resource. <p> Inner-Product Software Subroutine void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data [8] + data [1] * data [9] + data [2] * data [10] + data [3] * data [11] + data [4] * data [12] + data [5] * data [13] + data <ref> [6] </ref> * data [14] + data [7] * data [15]); - D.3 Inner-Product Hardware Subroutine module test (weN, dataina0, dataina1, dataina2, dataina3, dataina4, dataina5, dataina6, dataina7, datainb0, datainb1, datainb2, datainb3, datainb4, datainb5, datainb6, datainb7, doneN, dataout, clk); input [7:0] dataina0, dataina1, dataina2, dataina3, dataina4, dataina5; input [7:0] dataina6, dataina7, datainb0, datainb1,
Reference: [7] <author> S. Hanono. </author> <title> LSI and Verilog Serial Interface to FPGA Board. Alewife Systems Memo 39, </title> <institution> MIT Computer Architecture Group, </institution> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: The hardware subroutines are generally small circuits compared with full scale microprocessors; for the algorithms demonstrated herein, a single board proved more than adequate. The FPGA board connects to a Sun SPARC station via a serial port, about one kilobyte/second, interfacing with a Motorola HC11 <ref> [7] </ref>. The serial port is slow, but it successfully controls data input and output between the board and host. The modified virtual wires controller, which enables multiple computation cycles to be run on the board between transfers across the serial interface, improves bandwidth dramatically and reduces the cost of I/O. <p> My first goals included taking relatively simple functions, writing them in verilog, and understanding the procedure for development on the Virtual Wires board. The communications between the workstation and the board were through verilog; that system was designed by Silvina Hanono <ref> [7] </ref>. Once I felt comfortable in this environment, my next goal was to modify the communications to drive the board without the verilog simulator. To run a hardware subroutine, I needed a way to access the board via a C interface. <p> Example code, both C and Verilog, for a bubble-sort algorithm is listed in Appendix B. The subroutine present on the FPGAs can be debugged using tools developed by Silvina Hanono <ref> [7] </ref>. These tools, vw run serial debug and vw run verilog, often proved convenient for tracing inputs and outputs to and from the FPGA board. However, for debugging the internal circuitry within the virtual wires environment and between functional partitions, a new tool would be useful. <p> char * data, int array_size) - data [0]=(data [0] * data [8] + data [1] * data [9] + data [2] * data [10] + data [3] * data [11] + data [4] * data [12] + data [5] * data [13] + data [6] * data [14] + data <ref> [7] </ref> * data [15]); - D.3 Inner-Product Hardware Subroutine module test (weN, dataina0, dataina1, dataina2, dataina3, dataina4, dataina5, dataina6, dataina7, datainb0, datainb1, datainb2, datainb3, datainb4, datainb5, datainb6, datainb7, doneN, dataout, clk); input [7:0] dataina0, dataina1, dataina2, dataina3, dataina4, dataina5; input [7:0] dataina6, dataina7, datainb0, datainb1, datainb2, datainb3; input [7:0] datainb4, datainb5,
Reference: [8] <author> N. Hastie and R. Cliff. </author> <title> The implementation of hardware subroutines on field programmable gate arrays. </title> <booktitle> In IEEE Custom Integrated Circuits Conference, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: At the University of Hawaii, for instance, a Xilinx board was used to execute user programs, either partially or completely [10]. A group of researchers at Plessey Semiconductors investigated potentials for swapping hardware subroutines in and out of FPGAs in the form of Electrically Reconfigurable Arrays <ref> [8] </ref>. The PRISM-II system [14] improved performance of many tasks by "augmenting the functionality of the core processor with new instructions that match the characteristics of targeted applications." 15 Chapter 3 Environment The hardware subroutine platform consists of a set of software utilities and an FPGA board. <p> [1] = indata [0]; #endif /* write sorted array out to a file */ printf ("The answer is %d."n", outdata [1]); /* tie up lose ends */ fclose (input_stream); fclose (output_stream); - D.2 Inner-Product Software Subroutine void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data <ref> [8] </ref> + data [1] * data [9] + data [2] * data [10] + data [3] * data [11] + data [4] * data [12] + data [5] * data [13] + data [6] * data [14] + data [7] * data [15]); - D.3 Inner-Product Hardware Subroutine module test (weN,
Reference: [9] <author> H.-C. Hsieh, W. S. Carter, J. Ja, E. Cheung, S. Schreifels, C. Erickson, P. Freidin, and L. Tinkey. </author> <title> Third-generation architecture boosts speed and density of field-programmable gate arrays. </title> <booktitle> In IEEE Custom Integrated Circuits Conference, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: The nor-gate based field-programmable gate arrays are self-described; they consist of arrays of nor gates with customized routing to implement various logic functions. Xilinx SRAM based FPGAs' fundamental elements are configurable logic blocks (CLBs). Other FPGA elements include input/output blocks (IOBs) and interconnect <ref> [9] </ref>. The CLBs take at least four bits of address input and effectively perform a lookup of a corresponding one bit value. In this way, the CLB serves as a four-input combinatorial logic function. Larger modules are created by routing CLBs together. <p> write sorted array out to a file */ printf ("The answer is %d."n", outdata [1]); /* tie up lose ends */ fclose (input_stream); fclose (output_stream); - D.2 Inner-Product Software Subroutine void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data [8] + data [1] * data <ref> [9] </ref> + data [2] * data [10] + data [3] * data [11] + data [4] * data [12] + data [5] * data [13] + data [6] * data [14] + data [7] * data [15]); - D.3 Inner-Product Hardware Subroutine module test (weN, dataina0, dataina1, dataina2, dataina3, dataina4, dataina5,
Reference: [10] <author> R. H. Jr. and A. </author> <title> Lew. </title> <booktitle> Programming the hawaii parallel computer, </booktitle> <year> 1993. </year>
Reference-contexts: A great deal of research has been done in the past regarding similar investigations. At the University of Hawaii, for instance, a Xilinx board was used to execute user programs, either partially or completely <ref> [10] </ref>. A group of researchers at Plessey Semiconductors investigated potentials for swapping hardware subroutines in and out of FPGAs in the form of Electrically Reconfigurable Arrays [8]. <p> file */ printf ("The answer is %d."n", outdata [1]); /* tie up lose ends */ fclose (input_stream); fclose (output_stream); - D.2 Inner-Product Software Subroutine void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data [8] + data [1] * data [9] + data [2] * data <ref> [10] </ref> + data [3] * data [11] + data [4] * data [12] + data [5] * data [13] + data [6] * data [14] + data [7] * data [15]); - D.3 Inner-Product Hardware Subroutine module test (weN, dataina0, dataina1, dataina2, dataina3, dataina4, dataina5, dataina6, dataina7, datainb0, datainb1, datainb2, datainb3,
Reference: [11] <editor> H. Schmit, L. Arnstein, D. Thomas, and E. Lagnese. </editor> <booktitle> Behavioral synthesis for fpga-based computing. </booktitle>
Reference-contexts: An alternative application for reconfigurable hardware is FPGA computing: utilizing FPGAs to increase performance and functionality in a general computing environment. In the future, computing systems will likely comprise both general-purpose processors and configurable hardware. <ref> [11] </ref> The motivation behind this is two-fold. First, many researchers have noticed that ten percent of written code takes ninety percent of the execution time. Hence, if that ten percent could be executed on an ASIC customized for just that functionality, large performance gains could be realized. <p> Most of this automation will be included in compilers. For instance, a key element needed to maximize the benefit from hardware subroutines is in the identification of the task to be implemented on the configurable system. Researchers have discussed characteristics of such routines <ref> [11] </ref> and compilers could use these traits to identify these appropriate tasks, interpret software descriptions of these routines, and convert them into logic gates for hardware implementation. The software designer identifies some of these routines and is able to make notes to the compiler regarding intelligent decisions. <p> %d."n", outdata [1]); /* tie up lose ends */ fclose (input_stream); fclose (output_stream); - D.2 Inner-Product Software Subroutine void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data [8] + data [1] * data [9] + data [2] * data [10] + data [3] * data <ref> [11] </ref> + data [4] * data [12] + data [5] * data [13] + data [6] * data [14] + data [7] * data [15]); - D.3 Inner-Product Hardware Subroutine module test (weN, dataina0, dataina1, dataina2, dataina3, dataina4, dataina5, dataina6, dataina7, datainb0, datainb1, datainb2, datainb3, datainb4, datainb5, datainb6, datainb7, doneN, dataout,
Reference: [12] <author> D. E. VanDenBout, J. N. Morris, D. Thomae, S. Labrozzi, S. Wingo, and D. Hall-man. Anyboard: </author> <title> An fpga-based, reconfigurable system. </title> <booktitle> IEEE Design and Test of Computers, </booktitle> <pages> pages 21-30, </pages> <month> Sept. </month> <year> 1992. </year> <month> 54 </month>
Reference-contexts: While masked ICs are three times cheaper and contain ten times the array capacity of FPGAs, they lack the flexibility of a multi-purpose hardware system. The AnyBoard reconfigurable hardware system, designed by a group of researchers at North Carolina State University <ref> [12] </ref> is one such project. Although AnyBoard is a rapid-prototyping system used for designing special-purpose boards, a faster, cheaper system similar to the AnyBoard could be practically used as multi-purpose hardware. More closely resembling a true reconfigurable system is the Splash Board [6]. <p> lose ends */ fclose (input_stream); fclose (output_stream); - D.2 Inner-Product Software Subroutine void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data [8] + data [1] * data [9] + data [2] * data [10] + data [3] * data [11] + data [4] * data <ref> [12] </ref> + data [5] * data [13] + data [6] * data [14] + data [7] * data [15]); - D.3 Inner-Product Hardware Subroutine module test (weN, dataina0, dataina1, dataina2, dataina3, dataina4, dataina5, dataina6, dataina7, datainb0, datainb1, datainb2, datainb3, datainb4, datainb5, datainb6, datainb7, doneN, dataout, clk); input [7:0] dataina0, dataina1, dataina2,
Reference: [13] <author> S. Walters. </author> <title> Computer-aided prototyping for ASIC-based systems. </title> <booktitle> IEEE Design and Test of Computers, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: They have been successfully utilized for prototyp-ing ASICs, since they have a very short development time and the cost of modifying a design is minimal. They comprise logic emulation systems [3] <ref> [13] </ref> and are sold in commercial packages to ASIC developers for this purpose. Programmable gate arrays have been used as reconfigurable processors and preprocessors in customized computing systems. And they can replace small quantities of simple ASICs. All of these possibilities and more illustrate the success of field-programmable gate arrays. <p> (output_stream); - D.2 Inner-Product Software Subroutine void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data [8] + data [1] * data [9] + data [2] * data [10] + data [3] * data [11] + data [4] * data [12] + data [5] * data <ref> [13] </ref> + data [6] * data [14] + data [7] * data [15]); - D.3 Inner-Product Hardware Subroutine module test (weN, dataina0, dataina1, dataina2, dataina3, dataina4, dataina5, dataina6, dataina7, datainb0, datainb1, datainb2, datainb3, datainb4, datainb5, datainb6, datainb7, doneN, dataout, clk); input [7:0] dataina0, dataina1, dataina2, dataina3, dataina4, dataina5; input [7:0] dataina6,
Reference: [14] <author> M. Wazlowski, L. Agarwal, T. Lee, A. Smith, E. Lam, P. Athanas, H. Silverman, and S. Ghosh. </author> <booktitle> Prism-ii compiler and architecture, </booktitle> <year> 1993. </year> <month> 55 </month>
Reference-contexts: A group of researchers at Plessey Semiconductors investigated potentials for swapping hardware subroutines in and out of FPGAs in the form of Electrically Reconfigurable Arrays [8]. The PRISM-II system <ref> [14] </ref> improved performance of many tasks by "augmenting the functionality of the core processor with new instructions that match the characteristics of targeted applications." 15 Chapter 3 Environment The hardware subroutine platform consists of a set of software utilities and an FPGA board. <p> void innerp (unsigned char * data, int array_size) - data [0]=(data [0] * data [8] + data [1] * data [9] + data [2] * data [10] + data [3] * data [11] + data [4] * data [12] + data [5] * data [13] + data [6] * data <ref> [14] </ref> + data [7] * data [15]); - D.3 Inner-Product Hardware Subroutine module test (weN, dataina0, dataina1, dataina2, dataina3, dataina4, dataina5, dataina6, dataina7, datainb0, datainb1, datainb2, datainb3, datainb4, datainb5, datainb6, datainb7, doneN, dataout, clk); input [7:0] dataina0, dataina1, dataina2, dataina3, dataina4, dataina5; input [7:0] dataina6, dataina7, datainb0, datainb1, datainb2, datainb3; input
References-found: 14

