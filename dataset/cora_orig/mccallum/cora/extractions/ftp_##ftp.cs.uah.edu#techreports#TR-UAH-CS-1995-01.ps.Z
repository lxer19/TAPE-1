URL: ftp://ftp.cs.uah.edu/techreports/TR-UAH-CS-1995-01.ps.Z
Refering-URL: http://www.cs.uah.edu/~delugach/cs-tech-reports.html
Root-URL: 
Title: An Approach to Objectoriented Program Understanding a long term goal of software developers. The reuse
Author: Letha H. Etzkorn and Carl G. Davis 
Note: 1.0 Introduction The ability of a later software project to benefit from the effort involved in producing software products on a previous project has been  by which software is organized and developed. This research primarily addresses the reuse of  This  
Abstract: An automated tool to assist in the understanding of legacy code can be useful both in the areas of software reuse and software maintenance. Most previous work in this area has concentrated on functionally-oriented code. Whereas objectoriented code has been shown to be inherently more reusable than functionally-oriented code, in many cases the eventual reuse of the objectoriented code was not considered during development. The research described in this paper addresses an approach to the automated understanding of objectoriented code as an aid to the reuse of objectoriented code. Hooper and Chester [10] provide several definitions of software reuse. One of the definitions they provide, quoting Bollinger and Pfleeger, 1990, is "Reuse is the process by which existing software work products (which may include not only source code, but also products such as documentation, designs, test data, tools, and specifications) are carried over and used in a new development effort, preferably with minimal modification." Another of the definitions provided by Hooper and Chester, quoting Biggerstaff and Perlis, 1989 [2], is "Reuse is the reapplication of a variety of kinds of knowledge about one system to another similar system in order to reduce the effort of development and maintenance of that other system." Both above definitions of software research are appropriate within the context of the approach described in this paper. This paper is organized as follows: Section 2.0 describes background research in the area of program understanding. Section 3.0 describes the program understanding approach used by 
Abstract-found: 1
Intro-found: 0
Reference: [1] <author> Basili, </author> <title> V.R., Abd-El-Hafiz, S.K., "Packaging Reusable Components: The Specification of Programs", </title> <institution> CS-TR-2957, UMIA CS-TR-92-97, University of Maryland at College Park, College Park, MD, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: Section 4.0 discusses a prototype tool, called the PATR icia system that is being developed to validate this approach. Section 5.0 describes results gained by use of the PATR icia system, and section 6.0 gives conclusions. 2.0 Background Program understanding approaches are generally divided into three large categories <ref> [1] </ref>. The algorithmic approaches annotate programs with formal specifications. These programs rely on the user to annotate the loops, and provide assistance only in proving the correctness of the annotations. The knowledge-based approaches annotate programs with informal, English text specifications. <p> The knowledge-based approaches annotate programs with informal, English text specifications. The knowledge-based approaches typically require less user interaction than the algorithmic approaches. The transformational approach is similar to the transformational paradigm of automatic program synthesis but with the application direction of the transformation rules reversed <ref> [1] </ref>. Caldiera and Basili [5] use the algorithmic approach to program understanding. Caldiera and Basili's problem domain is the automatic extraction and qualification of reuse candidates (similar to the domain addressed by this research). In their approach, a domain expert analyzes a candidate component.
Reference: [2] <author> Biggerstaff, T.J., and Perlis, A.J., </author> <title> Software Reusability, Vol. II, Concepts and Models , ACM Press, </title> <publisher> Addison-Wesley, </publisher> <address> Reading. Mass., </address> <year> 1989. </year>
Reference-contexts: software work products (which may include not only source code, but also products such as documentation, designs, test data, tools, and specifications) are carried over and used in a new development effort, preferably with minimal modification." Another of the definitions provided by Hooper and Chester, quoting Biggerstaff and Perlis, 1989 <ref> [2] </ref>, is "Reuse is the reapplication of a variety of kinds of knowledge about one system to another similar system in order to reduce the effort of development and maintenance of that other system." Both above definitions of software research are appropriate within the context of the approach described in this
Reference: [3] <author> Biggerstaff, </author> <title> T.J.,"Design Recovery for Maintenance and Reuse", </title> <journal> IEEE Computer, </journal> <volume> Volume 22, Issue 7, </volume> <month> July </month> <year> 1989, </year> <month> pp.36-49.. </month>
Reference-contexts: Then each abstract syntax tree is matched to a low level concept. Higher level concepts are formed by combining low level concepts, and meeting constraints due to control flow and data dependency. The third approach is that taken by Biggerstaff <ref> [3] </ref> [4]. He argues that a parsing oriented approach based on structural patterns of programming language features is necessary, but not sufficient for solving the general concept assignment problem. Parsing approaches return programming-oriented concepts such as searches, sorts, numerical integration. <p> One of the goals of this research is to automate the identification of reusable components as much as possible, and therefore the heuristic, concept-driven approach was chosen. A hybrid method of concept understanding has been employed. Primarily, an approach similar to that of Biggerstaff <ref> [3] </ref> [4] has been followed, in that primarily comments and identifiers have been used to match versus the domain base for the identification of concepts. However, there are several differences between this approach and that of Biggerstaff. First, a natural language parser is applied to header block comments [7].
Reference: [4] <author> Biggerstaff, T.J., Mitbander, B.G, and Webster, D.E, </author> <title> "Program Understanding and the Concept Assignment Problem", </title> <journal> Communications of the ACM, </journal> <volume> Volume 37, Number 5, </volume> <month> May </month> <year> 1994. </year>
Reference-contexts: Then each abstract syntax tree is matched to a low level concept. Higher level concepts are formed by combining low level concepts, and meeting constraints due to control flow and data dependency. The third approach is that taken by Biggerstaff [3] <ref> [4] </ref>. He argues that a parsing oriented approach based on structural patterns of programming language features is necessary, but not sufficient for solving the general concept assignment problem. Parsing approaches return programming-oriented concepts such as searches, sorts, numerical integration. <p> One of the goals of this research is to automate the identification of reusable components as much as possible, and therefore the heuristic, concept-driven approach was chosen. A hybrid method of concept understanding has been employed. Primarily, an approach similar to that of Biggerstaff [3] <ref> [4] </ref> has been followed, in that primarily comments and identifiers have been used to match versus the domain base for the identification of concepts. However, there are several differences between this approach and that of Biggerstaff. First, a natural language parser is applied to header block comments [7].
Reference: [5] <author> Caldiera, G., and Basili, </author> <title> V.R., "Identifying and Qualifying Reusable Software Components", </title> <booktitle> IEEE Computer, </booktitle> <month> Feb. </month> <year> 1991, </year> <month> pp.61-70. </month>
Reference-contexts: The knowledge-based approaches annotate programs with informal, English text specifications. The knowledge-based approaches typically require less user interaction than the algorithmic approaches. The transformational approach is similar to the transformational paradigm of automatic program synthesis but with the application direction of the transformation rules reversed [1]. Caldiera and Basili <ref> [5] </ref> use the algorithmic approach to program understanding. Caldiera and Basili's problem domain is the automatic extraction and qualification of reuse candidates (similar to the domain addressed by this research). In their approach, a domain expert analyzes a candidate component. <p> A heuristic, concept-driven approach to program understanding has been followed. This is different from the Caldiera and Basili approach <ref> [5] </ref>. Caldiera and Basili's tool has a similar purpose to that of the PATR icia system, in that it is intended for the identification and qualification of reusable components; however, their code understanding system took the formal specification approach to program understanding.
Reference: [6] <author> Etzkorn, </author> <title> L.H., "Automated ObjectOriented Reusable Component Identification: An Overview", </title> <booktitle> ACM Mid-Southeast Chapter Fall Conference, </booktitle> <address> Gatlinburg, TN, </address> <month> Nov. </month> <pages> 10-11, </pages> <year> 1994. </year>
Reference-contexts: The interactive slice is more appropriate to maintenance than to reuse components extraction. 4.0 The PATRicia System A prototype tool, named the PATR icia system, for P rogram A nalysis T ool for R euse is under development <ref> [6] </ref> [7] [8]. The portion of the PATR icia system that implements the understanding approach described above is called the CHR i S module, for C onceptual H ierarchy for R euse employing S emantics. PATR icia system. Figure 2 is the level 1 DFD for the PATR icia system. <p> The Metric Analyzer module includes a commercial tool called PCMETRICS from SET Laboratories, Inc. This tool provides a class hierarchy chart and some coupling information for use by the CHR i S module (the understanding portion of the PATR icia system). It also provides some low-level C++ metrics <ref> [6] </ref> used by other portions of the PATR icia system, but that functionality is outside the scope of this paper. The CHR i S module itself employs a C++ parser (from Brown University), and the Sleator and Temperley natural language parser.
Reference: [7] <author> Etzkorn, L.H., and Davis, </author> <title> C.G., "A Documentation-related Approach to ObjectOriented Program Understanding", </title> <booktitle> Proceedings of the IEEE Third Workshop on Program Comprehension, </booktitle> <address> Washington, D.C., </address> <month> Nov. </month> <pages> 14-15, </pages> <year> 1994, </year> <pages> pp. 39-45. </pages>
Reference-contexts: However, there are several differences between this approach and that of Biggerstaff. First, a natural language parser is applied to header block comments <ref> [7] </ref>. Then the grammatical role of a keyword is used along with the keyword itself when matching versus the domain base to identify concepts. <p> The interactive slice is more appropriate to maintenance than to reuse components extraction. 4.0 The PATRicia System A prototype tool, named the PATR icia system, for P rogram A nalysis T ool for R euse is under development [6] <ref> [7] </ref> [8]. The portion of the PATR icia system that implements the understanding approach described above is called the CHR i S module, for C onceptual H ierarchy for R euse employing S emantics. PATR icia system. Figure 2 is the level 1 DFD for the PATR icia system. <p> Figure 4 gives an example of the output of the Sleator and Temperley parser for an example comment sentence. Prior to the choice of this natural language parser an analysis of typical comments was performed <ref> [7] </ref>. The comment types derived from this analysis, and their handling by CHR i S are as follows:: 1) comments are almost always written in the present tense, with either indicative mood or imperative mood. For example: Present tense, indicative mood: This routine reads the data.
Reference: [8] <author> Etzkorn, L.H., and Davis, </author> <title> C.G., "Knowledge-based ObjectOriented Reusable Component Identification", </title> <booktitle> Proceedings of the Eighth Annual Florida AI Research Symposium, </booktitle> <address> Melbourne Beach, FL, </address> <month> April 27-29, </month> <year> 1995, </year> <pages> pp. 97-101. </pages>
Reference-contexts: This understanding approach operates in nearly a top-down manner [7]<ref> [8] </ref>, following the class hierarchy chart, applying understanding first to the base classes, then to derived classes. The class hierarchy chart (with friend methods) in general serves as a "slice" [8]. The term "slice" is a section of code selected to be understood. In interactive tools (such as that of Biggerstaff) a slice is usually a section of code highlighted by the tool's user, and can be varied. <p> The interactive slice is more appropriate to maintenance than to reuse components extraction. 4.0 The PATRicia System A prototype tool, named the PATR icia system, for P rogram A nalysis T ool for R euse is under development [6] [7] <ref> [8] </ref>. The portion of the PATR icia system that implements the understanding approach described above is called the CHR i S module, for C onceptual H ierarchy for R euse employing S emantics. PATR icia system. Figure 2 is the level 1 DFD for the PATR icia system. <p> All keywords in the semantic net are in lower case. Capitalization information, used for heuristics, is extracted either in the FactBuilder or in CLIPS rules. Interior concepts (non-interface nodes) within the semantic net <ref> [8] </ref> have associated English text defining the operation of that concept within the current domain. This text gives the high-level definition of the concept, without as much low-level detail as is found in the code.
Reference: [9] <author> Harandi, M.T., and Ning, J.Q., </author> <title> "Knowledge-Based Program Analysis", </title> <journal> IEEE Software, </journal> <month> January </month> <year> 1990, </year> <month> pp.74-81. </month>
Reference-contexts: The program's graphs are compared versus the plans in the library. Recognition becomes a graph-parsing problem. Associated with each library plan is an English text description of the operation of the plan (the specification). The second approach, typically called the heuristic concept-recognition approach <ref> [9] </ref> [12], contains a knowledge base of events, such as statement, control, inc-counter, dec-counter, bubblesort, etc. The lower level events, called implementation level events, combine to form the higher level events (structure level and function level events). <p> The lower level events, called implementation level events, combine to form the higher level events (structure level and function level events). At the lowest level, an attempt is made to match code statements versus the most primitive events, such as statement, inc-counter, etc. Ning <ref> [9] </ref> [12] used a concept called interval calculus, that primarily works by identifying control areas surrounding an event, to match code statements versus the most primitive events.
Reference: [10] <author> Hooper, J.W., and Chester, R.O. </author> <title> Software Reuse Guidelines and Methods , Plenum Press, </title> <address> New York, </address> <year> 1991. </year>
Reference-contexts: One of the difficulties that tends to hinder software reuse lies in the numerous paradigms by which software is organized and developed. This research primarily addresses the reuse of code developed in the objectoriented paradigm. Hooper and Chester <ref> [10] </ref> provide several definitions of software reuse.
Reference: [11] <author> Kozaczynski, W., Ning, J., Engberts, A., </author> <title> "Program Concept Recognition and Transformation", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Volume 18, Issue 12, </volume> <year> 1992, </year> <pages> p. 1065-1075. </pages>
Reference-contexts: Ning [9] [12] used a concept called interval calculus, that primarily works by identifying control areas surrounding an event, to match code statements versus the most primitive events. Kozaczynski, Ning, and Engberts <ref> [11] </ref> [13] use an approach that is primarily a heuristic concept-recognition approach, but that also employs control flow and data dependency knowledge, in the recognition of the most primitive level events. In this approach, the program is first parsed into abstract syntax trees.
Reference: [12] <author> Ning, J.Q., </author> <title> A Knowledge Based Approach to Automatic Program Analysis, </title> <type> doctoral dissertation, </type> <institution> University of Illinois at Urbana-Champaign, Urbana, Ill., </institution> <year> 1989. </year>
Reference-contexts: The program's graphs are compared versus the plans in the library. Recognition becomes a graph-parsing problem. Associated with each library plan is an English text description of the operation of the plan (the specification). The second approach, typically called the heuristic concept-recognition approach [9] <ref> [12] </ref>, contains a knowledge base of events, such as statement, control, inc-counter, dec-counter, bubblesort, etc. The lower level events, called implementation level events, combine to form the higher level events (structure level and function level events). <p> The lower level events, called implementation level events, combine to form the higher level events (structure level and function level events). At the lowest level, an attempt is made to match code statements versus the most primitive events, such as statement, inc-counter, etc. Ning [9] <ref> [12] </ref> used a concept called interval calculus, that primarily works by identifying control areas surrounding an event, to match code statements versus the most primitive events.
Reference: [13] <author> Ning, J., Engberts, A., and Kozaczynski, W., </author> <title> "Automated Support for Legacy Code Understanding", </title> <journal> Communications of the ACM, </journal> <volume> Volume 37, Number 5, </volume> <month> May </month> <year> 1994. </year>
Reference-contexts: Ning [9] [12] used a concept called interval calculus, that primarily works by identifying control areas surrounding an event, to match code statements versus the most primitive events. Kozaczynski, Ning, and Engberts [11] <ref> [13] </ref> use an approach that is primarily a heuristic concept-recognition approach, but that also employs control flow and data dependency knowledge, in the recognition of the most primitive level events. In this approach, the program is first parsed into abstract syntax trees.
Reference: [14] <author> Rich, C. and Waters, </author> <title> R.C. "The Programmer's Apprentice: A Research Overview", </title> <journal> IEEE Computer, </journal> <volume> Volume 21, Issue 11, </volume> <month> November, </month> <year> 1988,pp.12-25. </year>
Reference: [15] <author> Rich, C. and Wills, L.M. </author> <title> "Recognizing a Program's Design: A Graph-Parsing Approach", </title> <journal> IEEE Software, </journal> <month> Jan. </month> <year> 1990, </year> <pages> pp. 82-89. </pages>
Reference: [16] <author> Sleator, D. and Temperley, D., </author> <title> "Parsing English with a Link Grammar", </title> <institution> Carnegie Mellon School of Computer Science, CMU-CS-91-196, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: Additionally, several flex-generated parsers are used; one to extract keywords and comments from a source code C++ file, one to parse the abstract syntax tree produced by the Brown University C++ parser, and another to parse the output file generated by the Sleator and Temperley natural language parser <ref> [16] </ref>. The Graph Traverser and the Fact Builder (see C++. The knowledge-base (a weighted semantic net) is stored in CLIPS version 6.0 objects. <p> In general, for a good analysis to be made of C++ source code, that source code must be compilable or nearly compilable on a Unix system. The Sleator and Temperley natural language parser <ref> [16] </ref> is a link grammar parser, which has a power similar to that of a context-free grammar. However, most common commentstyle sentences can be parsed with the Sleator and Temperley parser, as well as a large variety of more complicated sentences. <p> The Sleator and Temperley parser handles: noun-verb agreement, questions, imperatives, complex and irregular verbs, many types of nouns, pastor-present participles in noun phrases, commas, a variety of adjective types, prepositions, adverbs, relative clauses, possessives, coordinating conjunctions, and more <ref> [16] </ref>. Figure 4 gives an example of the output of the Sleator and Temperley parser for an example comment sentence. Prior to the choice of this natural language parser an analysis of typical comments was performed [7].
Reference: [17] <author> Watson, M. </author> <title> Portable GUI Development with C++, </title> <publisher> McGraw-Hill, </publisher> <year> 1993. </year>
Reference-contexts: One of the GUI packages analyzed is a GUI package discussed in the book Portable GUI Development with C++ , by Mark Watson (source code available on disk from the author) <ref> [17] </ref>. The implementation described in the book has three separate variations, one for DOS, one for the Macintosh, and one for Unix (using X Windows). The DOS and Unix/X.
Reference: [18] <author> Winograd, T., </author> <title> Language as a Cognitive Process, </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
References-found: 18

