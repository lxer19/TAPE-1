URL: http://www.cs.cornell.edu/Info/People/kreitz/PS-files/96-lics.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/kreitz/Abstracts/96-lics.html
Root-URL: 
Email: kreitz,lau@intellektik.informatik.th-darmstadt.de  ornaghi@hermes.mc.dsi.unimi.it  
Phone: 2  (phone: +49 6151 16 2863 fax: +49 6151 16 5326).  
Title: Logical Foundations for Declarative Object-oriented Programming  
Author: Christoph Kreitz Kung-Kiu Lau and Mario Ornaghi 
Note: The first author is the contact author  The second author is on leave from the University of Manchester, UK, and is supported by the European Union HCM project on Logic Program Synthesis and Transformation, contract no. 93/414.  
Address: Alexanderstr. 10, D-64283 Darmstadt, Germany  Milano, Via Comelico 39/41, Milano, Italy  
Affiliation: 1 Fachgebiet Intellektik, Fachbereich Informatik, Technische Hochschule Darmstadt  Dipartimento di Scienze dell'Informazione Universita' degli studi di  
Abstract: We present a formalism for reasoning about declarative object-oriented programs. Classes are represented as first-order theories that contain logic programs as methods. Inheritance, genericity and related concepts are represented by operations on such theories which preserve the consistency of these theories as well as the correctness of the programs specified by their axioms. Our approach provides a logical basis for the construction of correct and reusable programming systems. Issues: Our main motivation is formal program development, i.e. developing programs that are formally correct wrt their formal specifications. Our goal in this paper is to provide the necessary logical foundations for formal program development in an object-oriented paradigm which has a suitable (declarative) semantics for this purpose. Object-oriented programming is widely used for software development in industry because it is seen to meet the key requirements of modularity, reusability, and reliability. However, conventional object-oriented programming (e.g. [12]) is based on the imperative programming paradigm, and does not have a declarative semantics. This means that formal reasoning about programs is not at all straightforward, since modularity and reusability are characterised at code level. Instead, invariants, pre and postcondi-tions have to be inserted into the code and checked if some level of reliability is to be guaranteed. Declarative object-oriented programming languages have been proposed, by both the functional and logic programming communities. Examples include TOOPL [3], L&O [11], and Prolog++ [15]. These languages, though declarative in their methods, usually lack a suitable semantics for reasoning about formal object-oriented program development. That is, in these languages, classes are theories (with initial semantics) which are assumed to be correct, i.e. they are used as executable specifications. Thus in these languages it is not meaningful to talk about correctness wrt general (non-executable) specifications. Main Results: Our main contribution is to define classes and methods declaratively, such that classes are full first-order theories (with isoinitial semantics), methods are logic programs that are synthesised from their specifications (in classes), and under our chosen (isoinitial) semantics, we can reason about the correctness, and correct reuse of both classes and their programs. Both our classes and programs may be open, i.e. they may have parameters. Correctness of a class is defined as its adequacy, and class reuse corresponds to class composition that preserves adequacy. Correctness of a program is defined wrt a specification: a program is correct if its (initial) model coincides with the interpretation of the specification in the (isoinitial) model of the class. We show that these notions of correctness enable us to characterise correct reuse of both classes and programs via composition. Thus altogether our results provide a basis for developing object-oriented software that is not just reliable or reusable, but in fact formally correct and correctly reusable. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Bertoni, G. Mauri and P. Miglioli. </author> <title> On the power of model theory in specifying abstract data types and in capturing their recursiveness. </title> <note> Fundamenta Informaticae VI(2):127-170, </note> <year> 1983. </year>
Reference-contexts: Definition 3. A closed framework is adequate iff it has a reachable isoinitial model. In the sequel, we will simply say `closed framework' instead of `adequate closed framework'. 4 For each theorem the framework contains its proof. 5 A proof of Theorem 2 can be found in <ref> [1] </ref>. Isoinitial semantics is closely related to initial semantics used in algebraic ADTs [16]. A discussion of these semantics can also be found in [13]. Example 1.
Reference: 2. <author> A. Brogi, P. Mancarella, D. Pedreschi and F. Turini. </author> <title> Modular logic programming. </title> <journal> ACM TOPLAS 16(4) </journal> <pages> 1361-1398, </pages> <year> 1994. </year>
Reference-contexts: Thus our view of object orientation is different from that used in object oriented-logic programming (see e.g. [11, 15]) where the conventional object-oriented notions are imported virtually wholesale at the syntactic level. Our characterisation of modularity and reusability also differs from modular logic programming (see e.g. <ref> [2, 4] </ref>) where composition is not performed in the context of a framework and a notion of correct reusability is missing. The paper is organised as follows. In Section 2, we introduce the background theory together with our notation and terminology.
Reference: 3. <author> K.M. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design, static typing and semantics. </title> <editor> J. </editor> <booktitle> Functional Programming 4(2) </booktitle> <pages> 127-206, </pages> <year> 1994. </year>
Reference: 4. <author> M. Bugliesi, E. Lamma and P. Mello. </author> <title> Modularity in logic programming. </title> <editor> J. </editor> <booktitle> Logic Programming 19,20:443 502, </booktitle> <year> 1994. </year>
Reference-contexts: Thus our view of object orientation is different from that used in object oriented-logic programming (see e.g. [11, 15]) where the conventional object-oriented notions are imported virtually wholesale at the syntactic level. Our characterisation of modularity and reusability also differs from modular logic programming (see e.g. <ref> [2, 4] </ref>) where composition is not performed in the context of a framework and a notion of correct reusability is missing. The paper is organised as follows. In Section 2, we introduce the background theory together with our notation and terminology.
Reference: 5. <author> C.C. Chang and H.J. Keisler. </author> <title> Model Theory. </title> <publisher> North-Holland, </publisher> <year> 1973. </year>
Reference: 6. <author> G. Delzano and M. Martelli. </author> <title> Objects in Forum. </title> <editor> In J. Lloyd, editor, </editor> <booktitle> Proc. 1995 Int. Logic Programming Symp., </booktitle> <pages> pages 115-129, </pages> <publisher> MIT Press 1995. </publisher>
Reference: 7. <author> J.A. Goguen and R.M. Burstall. Institutions: </author> <title> Abstract model theory for specification and programming. </title> <editor> J. </editor> <booktitle> ACM 39(1) </booktitle> <pages> 95-146, </pages> <year> 1992. </year>
Reference-contexts: In this case, the reduct will also be denoted by Ij. It is immediate to extend a morphism : ! to a map : L ! L and the following satisfaction condition (see <ref> [7] </ref>) can be easily proved: Theorem 1.
Reference: 8. <author> K.K. Lau and M. Ornaghi. </author> <title> On specification frameworks and deductive synthesis of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <volume> LNCS 883, </volume> <pages> pages 104-121, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: 9. <author> K.K. Lau, M. Ornaghi and S. A. T arnlund. </author> <title> Steadfast logic programs. </title> <note> Submitted to J. Logic Programming. </note>
Reference-contexts: These programs, however, are not just ordinary programs. They can be open programs that must be correct in all possible instances of F. We call this kind of correctness steadfastness, and a model-theoretic formalisation can be found in <ref> [9] </ref>. We use the notation P : ffi ( to express that the defined relations (ffi) of P depend on the relation parameters and call ffi ( the dependency type of P .
Reference: 10. <author> C. Kreitz, K.K. Lau and M. Ornaghi. </author> <title> Formal reasoning about modules, reuse, and their correctness. </title> <note> Sub mitted to FAPR'96. </note>
Reference-contexts: We say that P is closed if it defines all its predicates. If P is a definite closed logic program, and it terminates for every ground atomic goal A, then the theory T (P ) is an adequate closed framework (see <ref> [10, Theorem 14] </ref>). An adequate open framework, in contrast, axiomatises a class of intended models. <p> More general kinds of formulas and collections evaluating them can be given, and a more general notion of dependency type ( can be defined. Some rules to work on adequacy of frameworks have been introduced in <ref> [10] </ref>, based on the notion of dependency type. In the full paper we will give a short account of such rules, and introduce their use for dealing with termination properties of programs that are more general than strong termination considered in the previous section.
Reference: 11. <author> F.G. McCabe. </author> <title> L& O: Logic and Objects. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: Basically we have raised modularity and reusability to a semantic level. Thus our view of object orientation is different from that used in object oriented-logic programming (see e.g. <ref> [11, 15] </ref>) where the conventional object-oriented notions are imported virtually wholesale at the syntactic level. Our characterisation of modularity and reusability also differs from modular logic programming (see e.g. [2, 4]) where composition is not performed in the context of a framework and a notion of correct reusability is missing.
Reference: 12. <author> B. Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction According to the object-oriented paradigm (e.g. <ref> [12] </ref>) the development of software systems proceeds in two essential stages. First one has to design the general structure of the system in the form of class definitions, relations between classes (i.e. import/export, genericity/instantiation, inheritance), class invariants, and specifications of class features (i.e. objects, functions, and routines).
Reference: 13. <author> P. Miglioli, U. Moscato and M. Ornaghi. </author> <title> Abstract parametric classes and abstract data types defined by classical and constructive logical methods. </title> <journal> J. Symb. Comp. </journal> <volume> 18 </volume> <pages> 41-81, </pages> <year> 1994. </year>
Reference-contexts: Isoinitial semantics is closely related to initial semantics used in algebraic ADTs [16]. A discussion of these semantics can also be found in <ref> [13] </ref>. Example 1.
Reference: 14. <author> D. Miller. </author> <title> A multi-conclusion meta-logic. </title> <booktitle> In Proc. LICS 1994 , pages 272-281, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference: 15. <author> C.D.S. Moss. </author> <title> Prolog++: The Power of Object-Oriented and Logic Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Basically we have raised modularity and reusability to a semantic level. Thus our view of object orientation is different from that used in object oriented-logic programming (see e.g. <ref> [11, 15] </ref>) where the conventional object-oriented notions are imported virtually wholesale at the syntactic level. Our characterisation of modularity and reusability also differs from modular logic programming (see e.g. [2, 4]) where composition is not performed in the context of a framework and a notion of correct reusability is missing.
Reference: 16. <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: In the sequel, we will simply say `closed framework' instead of `adequate closed framework'. 4 For each theorem the framework contains its proof. 5 A proof of Theorem 2 can be found in [1]. Isoinitial semantics is closely related to initial semantics used in algebraic ADTs <ref> [16] </ref>. A discussion of these semantics can also be found in [13]. Example 1.
References-found: 16

