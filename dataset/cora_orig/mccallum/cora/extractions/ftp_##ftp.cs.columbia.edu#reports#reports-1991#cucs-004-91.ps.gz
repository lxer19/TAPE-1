URL: ftp://ftp.cs.columbia.edu/reports/reports-1991/cucs-004-91.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1991.html
Root-URL: http://www.cs.columbia.edu
Title: Adaptive Remote Paging for Mobile Computers  
Author: Bill N. Schilit and Dan Duchamp 
Date: February 1991  
Address: 500 West 120th St. Room 450 New York, N.Y. 10027 TR CUCS-004-91  
Affiliation: Department of Computer Science Columbia University  
Abstract: There is a strong trend toward the production of small "notebook" computers. The small size of portable computers places inherent limits on their storage capacity, making remote paging desirable or necessary. Further, mobile computers can "walk away from" their servers, increasing load on network routing resources and/or breaking network connections altogether. Therefore, it is desirable to allow client-server matchups to be made dynamically and to vary over time, so that a client might always be connected to nearby servers. Accordingly, we have built a self-organizing paging service that adapts to changes in locale and that stores pages in remote memory if possible. We show empirically that there is no performance penalty for using our paging facility instead of a local disk. This suggests that portable computers need neither a hard disk nor an excessive amount of RAM, provided that they will operate in environments in which remote storage is plentiful. These are important facts because both a hard disk and large amounts of RAM are undesirable characteristics for very small portable computers.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: A new kernel foundation for UNIX development. </title> <booktitle> In USENIX Association Summer Conference proceedings, Atlanta 1986. USENIX Association, </booktitle> <year> 1986. </year>
Reference-contexts: By now Mach is well known <ref> [10, 1] </ref>. Nevertheless, in order to provide a self-contained paper, the rest of this section briefly describes the kernel facilities that are important to our work. In Mach, resources are contained within a task which may have several computational threads.
Reference: [2] <author> Douglas Comer and James Griffioen. </author> <title> A new design for distributed systems: the remote memory model. </title> <booktitle> In Proceedings, Usenix Summer Conference, </booktitle> <pages> pages 127-135, </pages> <address> Anaheim, California, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Addressing this problem has proven to require overhead inefficiencies and a good deal of complex code for a relatively uncommon situation. Also, distributed VM systems usually require a static partitioning of the shared address space. One previous work <ref> [2] </ref> suggests the use of remote memory as a "new model of computation." The system described therein exploits a predeclared set of dedicated "remote memory servers," and concentrates on the network protocols necessary for interoperability.
Reference: [3] <author> E. Jul, H. Levy, N. Hutchinson, and A. Black. </author> <title> Fine-grained mobility in the emerald system. </title> <journal> ACM Trans. Computers, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Dynamic binding of servers to clients has been discussed in [4], which is mostly a proposal. Kazar's idea arose, like ours, from the contemplation of operating in a large, highly variable distributed computing environment. A major work that addresses the issue of mobility is the Emerald object-based system <ref> [3] </ref>. This work provides language primitives allowing the programmer to hand-control migration of objects that can be data or processes.
Reference: [4] <author> M. L. Kazar. </author> <title> Workstation operating systems: Invoking remote services. </title> <booktitle> In Proceedings: Workshop on Workstation Operating Systems. IEEE Computer Society Technical Committee on Operating Systems, </booktitle> <month> November </month> <year> 1987. </year> <note> 2 Sources are available by anonymous ftp from internet site not.revealed in directory pub/adaptive-paging. 20 </note>
Reference-contexts: We get a certain (lesser) degree of interoperability from Mach and instead concentrate on resource location and load balancing issues. Comer's work is similar to ours in that the paging protocol has been separated from the file system. Dynamic binding of servers to clients has been discussed in <ref> [4] </ref>, which is mostly a proposal. Kazar's idea arose, like ours, from the contemplation of operating in a large, highly variable distributed computing environment. A major work that addresses the issue of mobility is the Emerald object-based system [3].
Reference: [5] <author> P. Leach, P. H. Levine, B. P. Douros, J. A. Hamilton, D. L. Nelson, and B. L. Stumpf. </author> <title> The architecture of an integrated local network. </title> <journal> IEEE Trans. Selected Areas of Communication, </journal> <volume> SAC-1(5):842-857, </volume> <month> November </month> <year> 1983. </year>
Reference-contexts: So short-lived processes should not be moved because to do so would be inefficient, and long-lived processes should not be moved because they have no need to move. We address a more limited but more tractable problem. 19 Adaptive remote paging might also be viewed as distributed virtual memory <ref> [7, 5] </ref> without the sharing. Certainly the ability to share common pages among several processes is a major advantage, but along with sharing comes the problem of maintaining consistency. Addressing this problem has proven to require overhead inefficiencies and a good deal of complex code for a relatively uncommon situation.
Reference: [6] <author> Samuel J. Le*er, Marchall Kirk McKusick, Michael J. Karels, and John S. Quarterman. </author> <title> The Design and implementation of the 4.3BSD UNIX operating system. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1989. </year>
Reference-contexts: The value is somewhat arbitrary and we have not made tests to tune it. This algorithm is similar to the swapping algorithm used in Berkeley UNIX <ref> [6] </ref>. Once the objects to o*oad have been selected, the paging server requests migration by sending the paging object abdicate request message to the organizer. The organizer can ignore this message. If the request is accepted, the organizer first selects a destination capable of holding the paging object.
Reference: [7] <author> K. Li and P. Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Trans. Computers, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: So short-lived processes should not be moved because to do so would be inefficient, and long-lived processes should not be moved because they have no need to move. We address a more limited but more tractable problem. 19 Adaptive remote paging might also be viewed as distributed virtual memory <ref> [7, 5] </ref> without the sharing. Certainly the ability to share common pages among several processes is a major advantage, but along with sharing comes the problem of maintaining consistency. Addressing this problem has proven to require overhead inefficiencies and a good deal of complex code for a relatively uncommon situation.
Reference: [8] <author> Barton P. Miller Michael L. Powell. </author> <title> Process migration in demos/mp. </title> <booktitle> In Proceedings of the Ninth Symposium on Operating System Principles, </booktitle> <pages> pages 110-119. </pages> <publisher> ACM, </publisher> <year> 1983. </year>
Reference-contexts: Adaptive remote paging might be viewed as a subset of adaptive process placement and migration, a subject on which there is much earlier work <ref> [8, 9, 11] </ref>. However, process placement/migration systems have not had major impact because | at least in Unix-based systems | so many processes are short-lived; furthermore, many long-lived processes are long-lived precisely because they manage (and so must reside near) some data set.
Reference: [9] <author> D. Nichols. </author> <title> Multiprocessing in a Network of Workstations. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon, </institution> <month> February </month> <year> 1990. </year> <note> Available as CMU Technical Report CMU-CS-90-107. </note>
Reference-contexts: Adaptive remote paging might be viewed as a subset of adaptive process placement and migration, a subject on which there is much earlier work <ref> [8, 9, 11] </ref>. However, process placement/migration systems have not had major impact because | at least in Unix-based systems | so many processes are short-lived; furthermore, many long-lived processes are long-lived precisely because they manage (and so must reside near) some data set.
Reference: [10] <author> Richard F. Rashid. </author> <title> Threads of a new system. </title> <journal> Unix Review, </journal> <volume> 4(8) </volume> <pages> 37-49, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: By now Mach is well known <ref> [10, 1] </ref>. Nevertheless, in order to provide a self-contained paper, the rest of this section briefly describes the kernel facilities that are important to our work. In Mach, resources are contained within a task which may have several computational threads.
Reference: [11] <author> Marvin M. Theimer and Keith A. Lantz. </author> <title> Finding idle machines in a workstation-based distributed system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(11) </volume> <pages> 1444-1458, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: Adaptive remote paging might be viewed as a subset of adaptive process placement and migration, a subject on which there is much earlier work <ref> [8, 9, 11] </ref>. However, process placement/migration systems have not had major impact because | at least in Unix-based systems | so many processes are short-lived; furthermore, many long-lived processes are long-lived precisely because they manage (and so must reside near) some data set.
Reference: [12] <author> Brent B. Welch. </author> <title> Naming, state management and user-level extensions in the sprite distributed file system. </title> <type> Phd thesis, </type> <institution> University of California, Berkeley, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: In this way a server maintains a cache that grows and shrinks according to local memory demands, similar to Sprite's variable sized cache <ref> [12] </ref>. 7 The server creates a memory object the size of physical memory and registers with the kernel as the external memory manager for that object. When a (remote) paging object is sent to the server, the page is written both to disk and to the cache.
Reference: [13] <author> Michael Wayne Young. </author> <title> Exporting a user interface to memory management from a communication-oriented operating system. </title> <type> Thesis CMU-CS-89-202, </type> <institution> School of Computer Science, Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> November </month> <year> 1989. </year> <month> 21 </month>
Reference-contexts: Backup ports help implement resilient services by allowing a manager to obtain the service port and restart servers when they crash. A port is often used to represent an object within a server; i.e., as a capability. One protocol employing capabilities is the external memory management interface (EMMI) <ref> [13] </ref>. In this case an unprivileged task 4 provides backing storage for memory objects in response to the kernel's paging requests. The EMMI is show in Figure 2. Memory objects not serviced by a user supplied manager are considered anonymous and sent to Mach's default pager.
References-found: 13

