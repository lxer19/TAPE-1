URL: ftp://ftp.cs.brown.edu/pub/techreports/92/cs92-19.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-92-19.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> B. Alpern, R. Hoover, B. Rosen, P. Sweeney, and F.K. Zadeck, </author> <title> "Incremental Evaluation of Computational Circuits," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1990), </booktitle> <pages> 32-42. </pages>
Reference-contexts: In general, a = O (n) for an attribute grammar of size n. Incremental evaluation of general circuits is studied in <ref> [1] </ref>. The precedence graph for an attribute grammar T is a digraph consisting of a vertex for each attribute x i () and a directed edge from x i () to x j (-) if the value x i () is used in the calculation of x j (-).
Reference: [2] <author> S.W. Bent, D.D. Sleator, and R.E. Tarjan, </author> <title> "Biased Search Trees," </title> <journal> SIAM J. Computing 14 (1985), </journal> <pages> 545-568. </pages>
Reference-contexts: An edge (; -) of T is solid if size () &gt; size ()=2 . If the partition satisfies the size invariant, then every path of T has O (log n) dashed edges. Also, in order to achieve the logarithmic time per dynamic operation, we use biased search trees <ref> [2] </ref> to represent the path-trees. For a node of a solid path we define the node-attribute weight (-) as one plus the sum of the sizes of the subtrees connected to by dashed edges.
Reference: [3] <author> G. M. Beshers and R. H. Campbell, </author> <title> "Maintained and Constructor Attributes," </title> <booktitle> Proc. ACM Symp. on Language Issues in Programming Environments, ACM SIGPLAN Notices (1985), </booktitle> <pages> 34-42. </pages>
Reference: [4] <author> Y.-J. Chiang, F.P. Preparata, and R. Tamassia, </author> <title> "A Unified Approach to Dynamic Point Location, Ray Shooting and Shortest Paths in Planar Maps," </title> <institution> Dept. Computer Science, Brown Univ., </institution> <type> Technical Report CS-92-07, </type> <year> 1992. </year>
Reference-contexts: If node = find (; S 6 ; p), then p is in region III. try to keep the binary space partition balanced [24,27]. With a selection function one can use unbalanced partitions. A specialized version of this technique was introduced in <ref> [4] </ref>.
Reference: [5] <author> Y.-J. Chiang and R. Tamassia, </author> <title> "Dynamic Algorithms in Computational Geometry," </title> <institution> Dept. of Computer Science, Brown Univ., </institution> <type> Technical Report CS-91-24, </type> <year> 1991. </year>
Reference-contexts: 1 Introduction The development of dynamic algorithms and data structures is a challenging area of research that has attracted increasing interest in the last years. While considerable progress has been made in geometric searching problems (see, e.g., the survey paper <ref> [5] </ref>), considerably fewer results exist on the dynamization of graph algorithms. A crucial development in the area of dynamic geometric searching has been the identification of general methods that apply to a large class of problems.
Reference: [6] <author> Y.-J. Chiang and R. Tamassia, </author> <title> "Dynamization of the Trapezoid Method for Planar Point Location," </title> <note> Int. J. of Computational Geometry Applications (to appear). </note>
Reference-contexts: The value n is the total size of the binary space partitions involved in each operation. The trapezoid method for planar point location described in <ref> [6] </ref> is an example of an existing method that can be expressed as a selection function. 4.5 Slicing Floorplan Compaction Linear attribute grammars have immediate application to the problem of compacting slicing floorplans, a layout technique widely used in VLSI (see, e.g., [30]).
Reference: [7] <author> R. F. Cohen, G. Di Battista, R. Tamassia, I.G. Tollis, and P. Bertolazzi, </author> <title> "A Framework for Dynamic Graph Drawing," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1992). </booktitle>
Reference-contexts: A specialized PathFind operator is included to find the minimum cost edge on a path. Edge-ordered trees were presented as the data structure for a fully dynamic algorithm to maintain the minimum or maximum spanning tree of planar graphs. In <ref> [7] </ref>, simplified linear attribute grammars are used to maintain drawings of series-parallel graphs and trees. Queries include location of vertices and edges of the drawing, 28 point location, and window queries.
Reference: [8] <author> R.F. Cohen, S. Sairam, R. Tamassia, and J.S. Vitter, </author> <title> "Dynamic Algorithms for Bounded Tree-Width Graphs," </title> <institution> Brown University, </institution> <type> Manuscript, </type> <year> 1992. </year>
Reference-contexts: Values are scalars taken from a semi-ring S. Operations are the + and fi operators of semi-ring S. The major presented algorithm for dynamic expression trees is fully dynamic algorithms for maximum flow and shortest path in series-parallel digraphs. In <ref> [8] </ref>, linear expression trees are used to present fully dynamic algorithms for a large number of problems on tree-width two graphs, the class of graphs where each biconnected component is a biconnected series-parallel graph.
Reference: [9] <author> R.F. Cohen and R. Tamassia, </author> <title> "Dynamic Expression Trees and their Applications," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1991), </booktitle> <pages> 52-61. </pages>
Reference-contexts: Our contributions can be summarized as follows: * We provide a framework for maintaining attribute systems on trees in a fully dynamic environment. Our technique extends and generalizes the dynamic trees of [28] and the dynamic expression trees of <ref> [9] </ref>. <p> Parent, Expand, and Contract take each O (log n) time, where n is the total size of the trees involved in the operation. 3 Expression Trees 3.1 Linear Expression Trees In this section, we consider the dynamic evaluation of linear expressions, which extends and generalizes the dynamic expression trees of <ref> [9] </ref>. <p> Global updates are only performed on the path from a node to the root. A specialized PathFind operator is included to find the minimum cost edge on a path. Dynamic trees were first presented as an internal data structure in several (sequential) maximum flow algorithms. Dynamic expression trees <ref> [9] </ref> are a restricted form of linear expression trees. Values are scalars taken from a semi-ring S. Operations are the + and fi operators of semi-ring S. The major presented algorithm for dynamic expression trees is fully dynamic algorithms for maximum flow and shortest path in series-parallel digraphs. <p> Queries are performed in O (log m) time, while updates are performed in O (log 2 m) time for a graph with m edges. A number of data structures have been presented which maintain the recursive decomposition of graphs into subgraphs with constant size overlap. SPQ-trees <ref> [9] </ref> and SPQC-trees are used as a fully dynamic data structure to maintain a decomposition of series-parallel digraphs and tree-width two graphs. SPQR-trees [11] are used to maintain the tri-connected components of an initially biconnected graph. FWRT-trees [19] used to maintain the 4-connected components of an initially tri-connected graph.
Reference: [10] <author> G. Di Battista and R. Tamassia, </author> <title> "Incremental Planarity Testing," </title> <booktitle> Proc. 30th IEEE Symp. on Foundations of Computer Science (1989), </booktitle> <pages> 436-441. </pages>
Reference: [11] <author> G. Di Battista and R. Tamassia, </author> <title> "On-Line Graph Algorithms with SPQR-Trees," Automata, </title> <booktitle> Languages and Programming (Proc. 17th ICALP), Lecture Notes in Computer Science 442 (1990), </booktitle> <pages> 598-611. </pages>
Reference-contexts: A number of data structures have been presented which maintain the recursive decomposition of graphs into subgraphs with constant size overlap. SPQ-trees [9] and SPQC-trees are used as a fully dynamic data structure to maintain a decomposition of series-parallel digraphs and tree-width two graphs. SPQR-trees <ref> [11] </ref> are used to maintain the tri-connected components of an initially biconnected graph. FWRT-trees [19] used to maintain the 4-connected components of an initially tri-connected graph. These last two data structures have a specialized PathFind operation to find the closest ancestor of a given type.
Reference: [12] <author> D. Eppstein, G.F. Italiano, R. Tamassia, R.E. Tarjan, J. Westbrook, and M. Yung, </author> <title> "Maintenance of a Minimum Spanning Forest in a Dynamic Plane Graph," </title> <editor> J. </editor> <booktitle> of Algorithms 13 (1992), </booktitle> <pages> 33-54. </pages>
Reference-contexts: SPQR-trees [11] are used to maintain the tri-connected components of an initially biconnected graph. FWRT-trees [19] used to maintain the 4-connected components of an initially tri-connected graph. These last two data structures have a specialized PathFind operation to find the closest ancestor of a given type. Edge-ordered trees <ref> [12] </ref> are ordered, unbounded, rooted trees supporting operations Link , Cut , Expand, Contract, Cycle and Evert . Each node stores a locally updatable cost associated with the edge from to its parent. A specialized PathFind operator is included to find the minimum cost edge on a path.
Reference: [13] <author> G.N. Frederickson, </author> <title> "Data Structures for On-Line Updating of Minimum Spanning Trees, with Applications," </title> <journal> SIAM J. Computing 14 (1985), </journal> <pages> 781-798. </pages>
Reference: [14] <author> G.N. Frederickson, </author> <title> "Ambivalent Data Structures for Dynamic 2-Edge-Connectivity and k Smallest Spanning Trees," </title> <booktitle> Proc. 32th IEEE Symp. on Foundations of Computer Science (1991). </booktitle>
Reference: [15] <author> Z. </author> <title> Galil and G.F. Italiano, "Fully Dynamic Algorithms for Edge-Connectivity Problems," </title> <booktitle> Proc. 23th ACM Symp. on Theory of Computing (1991), </booktitle> <pages> 317-327. </pages>
Reference: [16] <author> Z. </author> <title> Galil and G.F. Italiano, "Maintaining Biconnected Components of Dynamic Planar Graphs," Automata, </title> <booktitle> Languages and Programming (Proc. 18th ICALP), Lecture Notes in Computer Science (1991). </booktitle> <pages> 34 </pages>
Reference: [17] <author> L. G. Jones, </author> <title> "Incremental Compaction of Flat Symbolic IC Layouts," </title> <institution> Department of Computer Science, University of Illinois, Urbana, Illinois, </institution> <type> Technical Report No. </type> <institution> UIUCDCS-R-87-1386, </institution> <year> 1987. </year>
Reference: [18] <author> L. G. Jones and J. Simon, </author> <title> "Hierarchical VLSI Design Systems Based on Attribute Grammars," </title> <booktitle> Proc. 13th ACM Symp. on Principles of Programming Languages (1986), </booktitle> <pages> 58-69. </pages>
Reference-contexts: A binary attribute grammar is an attribute grammar on a binary tree. We consider attribute grammars where the values of each attribute are taken from a semiring S. Attribute grammars [20] are much studied and have applications in areas such as language based editors [3,26], and VLSI design <ref> [18] </ref>. Incremental algorithms for attribute grammars have been presented [17,25] which give a O (a t) running time per operation where a is the number of attributes affected by a change and t is the time to make a single change.
Reference: [19] <author> A. Kanevsky, R. Tamassia, J. Chen, and G. Di Battista, </author> <title> "On-Line Maintenance of the Four-Connected Components of a Graph," </title> <booktitle> Proc. 32th IEEE Symp. on Foundations of Computer Science (1991), </booktitle> <pages> 793-801. </pages>
Reference-contexts: SPQ-trees [9] and SPQC-trees are used as a fully dynamic data structure to maintain a decomposition of series-parallel digraphs and tree-width two graphs. SPQR-trees [11] are used to maintain the tri-connected components of an initially biconnected graph. FWRT-trees <ref> [19] </ref> used to maintain the 4-connected components of an initially tri-connected graph. These last two data structures have a specialized PathFind operation to find the closest ancestor of a given type.
Reference: [20] <author> D. E. Knuth, </author> <title> "Semantics of Context-Free Languages," </title> <booktitle> Mathematical Systems Theory 2 (1968), </booktitle> <pages> 127-145. </pages>
Reference-contexts: We assume, without loss of generality, that the synthesized attributes of precede the inherited attributes of . A binary attribute grammar is an attribute grammar on a binary tree. We consider attribute grammars where the values of each attribute are taken from a semiring S. Attribute grammars <ref> [20] </ref> are much studied and have applications in areas such as language based editors [3,26], and VLSI design [18].
Reference: [21] <author> M. Overmars, </author> <title> "The Design of Dynamic Data Structures," </title> <booktitle> Lecture Notes in Computer Science 156 (1983). </booktitle>
Reference-contexts: A crucial development in the area of dynamic geometric searching has been the identification of general methods that apply to a large class of problems. In particular, the techniques developed by Overmars et al. (summarized in <ref> [21] </ref>) for the class of decomposable search problems constitute a fundamental contribution toward the dynamization of large classes of geometric problems. The availability of such general techniques appears instead to be lacking in the area of dynamic graph algorithms. <p> We also have corresponding secondary values for path attributes, and similarly define P fl () for a path . A decomposable search problem <ref> [21] </ref> on a set D, locates a distinguished element x = (D) with the conditions of given any partition of D into subsets D 0 and D 00 , we can determine in constant time if x is in D 0 or D 00 .
Reference: [22] <author> M.S. Patterson and F.F. Yao, </author> <title> "Optimal Binary Space Partitions for Orthoganal Objects," </title> <booktitle> Proc. 1st ACM-SIAM Symp. on Discrete Algorithms (1990), </booktitle> <pages> 100-106. </pages>
Reference-contexts: E.g. a node corresponds to a trapezoid and to a segment that divides it into two trapezoids (for details see <ref> [22] </ref>). Each leaf of binary space partition T represents a region referred to as region ().
Reference: [23] <author> J.A. La Poutre, </author> <title> "Dynamic Graph Algorithms and Data Structures," </title> <institution> Dept. of Computer Science, University of Utrechet, Utrechet, </institution> <type> Ph.D. Thesis, </type> <year> 1991. </year>
Reference: [24] <author> F.P. Preparata, </author> <title> "A New Approach to Planar Point Location," </title> <journal> SIAM J. Computing 10 (1981), </journal> <pages> 473-483. </pages>
Reference: [25] <author> T.W. Reps, </author> <title> Generating Language-Based Environments, </title> <publisher> The MIT Press, </publisher> <year> 1984. </year>
Reference: [26] <author> T.W. Reps and T. Teitelbaum, </author> <title> The Synthesizer Generator, </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference: [27] <author> C. Schwarz, M. Smid, and J. Snoeyink, </author> <title> "An Optimal Algorithm for the On-line Closest-Pair Problem," </title> <booktitle> Proc. ACM Symp. on Computational Geometry (1992). </booktitle>
Reference: [28] <author> D.D. Sleator and R.E. Tarjan, </author> <title> "A Data Structure for Dynamic Trees," </title> <editor> J. </editor> <booktitle> Computer Systems Sciences 24 (1983), </booktitle> <pages> 362-381. </pages>
Reference-contexts: following fundamental idea: Decompose a graph into subgraphs with limited overlap, and represent such a decomposition by means of a tree so that dynamic operations on the graph are reflected into corresponding dynamic tree operations, which are in turn supported by variations of the link-cut trees of Sleator and Tarjan <ref> [28] </ref>. We associate values, called attributes, with the nodes, paths, and subtrees of our trees. Path attributes form a path attribute system, if they are maintained in constant time under path concatenation. <p> A linear attribute grammar, is an attribute grammar where all dependencies are linear. Our contributions can be summarized as follows: * We provide a framework for maintaining attribute systems on trees in a fully dynamic environment. Our technique extends and generalizes the dynamic trees of <ref> [28] </ref> and the dynamic expression trees of [9]. <p> We introduce the concept of path attribute systems and tree attribute systems which significantly extend and generalize the dynamic trees of <ref> [28] </ref>. We begin by discussing dynamic algorithms on a collection of paths, and then show that trees can be maintained as a collection of paths. 2.1 Path Attribute Systems Paths are directed. <p> This is done with the following operations, derived from dynamic trees <ref> [28] </ref>: * splice (path ) | This operation assumes that is a solid path ending at 6= . Convert the dashed edge leaving to solid and convert the solid edge (if it exists) 13 entering the parent of to dashed. <p> This list includes dynamic trees, dynamic expression trees, and edge ordered trees. In this section, we review these data structures, and existing applications for tree attribute systems, linear expression trees, and linear attribute grammars. Dynamic trees <ref> [28] </ref> are unordered, unbounded, rooted trees supporting operations Link , Cut and Evert . Each node stores a globally updatable cost associated with the edge from to its parent. Global updates are only performed on the path from a node to the root.
Reference: [29] <author> D.D. Sleator and R.E. Tarjan, </author> <title> "Self-Adjusting Binary Search Trees," </title> <editor> J. </editor> <booktitle> ACM 32 (1985), </booktitle> <pages> 652-686. </pages>
Reference-contexts: The value of P () may change only if is on the path from to in B. Therefore, we calculate these values starting at and ending at . This takes O (d ) time where d is the depth of in B. We need the following operation from <ref> [29] </ref> in our implementation of find (; S; q): * splaystep (node ) | For binary tree B with root and node a grandchild of , restructure B such that the relative order of the leaves of B remain fixed, and every node in the subtree rooted at has its depth
Reference: [30] <author> L. Stockmeyer, </author> <title> "Optimal Orientation of Cells in Slicing Floorplan Design," </title> <booktitle> Information and Control 57 (1983), </booktitle> <pages> 91-101. </pages>
Reference-contexts: trapezoid method for planar point location described in [6] is an example of an existing method that can be expressed as a selection function. 4.5 Slicing Floorplan Compaction Linear attribute grammars have immediate application to the problem of compacting slicing floorplans, a layout technique widely used in VLSI (see, e.g., <ref> [30] </ref>). A slicing floorplan is either a rectangle (called basic rectangle), or is the union of two slicing floorplans that share a horizontal side (called horizontal slice) or a vertical side (called vertical slice). <p> The choice of equations depend on if represents a vertical or horizontal slice. while minimizing the area of the slicing floorplan, subject to the above constraints on the height and width of the basic rectangles. (For full details, see <ref> [30] </ref>.) This problem can be solved using a linear attribute grammar T . Leaves of T represent basic rectangles, and internal nodes represent horizontal or vertical slices (see Fig. 9). The reference point of a sub-floorplan is its bottom-left corner.
Reference: [31] <author> J. Westbrook and R.E. Tarjan, </author> <title> "Maintaining Bridge-Connected and Biconnected Components On-Line," </title> <note> Algorithmica (1989 (to appear in Algorithmica)). 35 </note>
References-found: 31

