URL: http://www.cs.bu.edu/techreports/93-003-quadsim.ps.Z
Refering-URL: http://cs-www.bu.edu/techreports/Home.html
Root-URL: 
Email: shaban@cs.bu.edu  
Title: Quadsim Version 2.1 Student Manual  
Author: Marwan Shaban 
Note: Quadsim was inspired and greatly influenced by [Aho 86]. The material in chapter 8 (Intermediate Code Generation) of [Aho 86] should be considered background material for users of Quadsim.  
Address: 111 Cummington Street Boston, MA 02215  
Affiliation: Computer Science Department Boston University  
Date: February 21, 1993  
Pubnum: BU-CS Tech Report 93-003  
Abstract: Quadsim is an intermediate code simulator. It allows you to "run" programs that your compiler generates in intermediate code format. Its user interface is similar to most debuggers in that you can step through your program, instruction by instruction, set breakpoints, examine variable values, and so on. The intermediate code format used by Quadsim is that described in [Aho 86]. If your compiler generates intermediate code in this format, you will be able to take intermediate-code files generated by your compiler, load them into the simulator, and watch them "run." You are provided with functions that hide the internal representation of intermediate code. You can use these functions within your compiler to generate intermediate code files that can be read by the simulator. 
Abstract-found: 1
Intro-found: 1
Reference: [Aho 86] <author> Aho, Alfred V, Ravi Sethi, and Jeffrey D. Ullman: </author> <title> Compilers: Principles, Techniques, and Tools; Reading, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1986. </year> <month> 22 </month>
Reference-contexts: Its user interface is similar to most debuggers in that you can step through your program, instruction by instruction, set breakpoints, examine variable values, and so on. The intermediate code format used by Quadsim is that described in <ref> [Aho 86] </ref>. If your compiler generates intermediate code in this format, you will be able to take intermediate-code files generated by your compiler, load them into the simulator, and watch them "run." You are provided with functions that hide the internal representation of intermediate code. <p> You can use these functions within your compiler to generate intermediate code files that can be read by the simulator. Quadsim was inspired and greatly influenced by <ref> [Aho 86] </ref>. The material in chapter 8 (Intermediate Code Generation) of [Aho 86] should be considered background material for users of Quadsim. 1 Contents 1 Getting Started 4 2 How To Generate Intermediate Code 4 2.1 Using the Intermediate-Code I/O Interface : : : : : : : : : : <p> You can use these functions within your compiler to generate intermediate code files that can be read by the simulator. Quadsim was inspired and greatly influenced by <ref> [Aho 86] </ref>. The material in chapter 8 (Intermediate Code Generation) of [Aho 86] should be considered background material for users of Quadsim. 1 Contents 1 Getting Started 4 2 How To Generate Intermediate Code 4 2.1 Using the Intermediate-Code I/O Interface : : : : : : : : : : : : 4 2.2 Writing Quadruples : : : : : <p> Note that the simulator's symbol handling ability assumes that the language being compiled doesn't allow nested procedures. This is consistent with the language defined by Appendix A of <ref> [Aho 86] </ref>. 2.5 Writing Line Numbers The information in this section is relevant only if you want to propagate line number information through the intermediate code into the simulator, so you can do "source level" simulation of your compiled program. 7 When calling ICWriteLineNumber (), you must pass the line number <p> It is called "qcom-pile". You should add this directory to your search path in order to run the compiler. Alternately, you can use an alias to map the command "qcompile" to include the full path. This compiler translates the subset of pascal found in appendix 1 of <ref> [Aho 86] </ref> with the following exceptions: 1. The grammar presented in appendix 1 of [Aho 86] has a problem in that it does not allow reading from elements of an array. <p> Alternately, you can use an alias to map the command "qcompile" to include the full path. This compiler translates the subset of pascal found in appendix 1 of <ref> [Aho 86] </ref> with the following exceptions: 1. The grammar presented in appendix 1 of [Aho 86] has a problem in that it does not allow reading from elements of an array. In other words, array references cannot be r-values but they can be l-values, so "ARR [1] = 32" is legal, but "A = ARR [1]" is illegal, according to the textbook's grammar. <p> The second function prototype above is illegal because it contains more than one identifier list ("a" and "b" are contained in separate identifier lists). 11 5 Sample Programs Quadsim and the quadsim compiler have been tested using a few programs written in the pascal subset from Appendix 1 of <ref> [Aho 86] </ref>. You can use these tests to test your compiler's correctness. These sample programs are located in "~shaban/quadsim/tests". The sample programs test most aspects of the language including arrays, functions, procedures, expression evaluation, etc. <p> Finally, thanks are due to Professor Wayne Snyder for lending moral and technical support to the simulator project. 12 A Quadruple Reference The following are the currently supported quadruples. Most of these are direct implementations of the suggested three-address statements on page 467 of <ref> [Aho 86] </ref>. The material in chapter 8 (Intermediate Code Generation) of [Aho 86] should be considered background material for users of Quadsim. A.1 Two-operand Instructions These are assignments of the form x := y op z, where op is a binary arithmetic or logical operation. <p> Most of these are direct implementations of the suggested three-address statements on page 467 of <ref> [Aho 86] </ref>. The material in chapter 8 (Intermediate Code Generation) of [Aho 86] should be considered background material for users of Quadsim. A.1 Two-operand Instructions These are assignments of the form x := y op z, where op is a binary arithmetic or logical operation.
References-found: 1

