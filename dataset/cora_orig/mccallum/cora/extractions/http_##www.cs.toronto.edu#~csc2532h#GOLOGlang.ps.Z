URL: http://www.cs.toronto.edu/~csc2532h/GOLOGlang.ps.Z
Refering-URL: http://www.cs.toronto.edu/~csc2532h/
Root-URL: http://www.cs.toronto.edu
Title: GOLOG: A LOGIC PROGRAMMING LANGUAGE FOR DYNAMIC DOMAINS  
Author: HECTOR J. LEVESQUE, RAYMOND REITER, YVES LESP ERANCE FANGZHEN LIN, AND RICHARD B. 
Date: 1994:19, 20:1-679 1  SCHERL 2  
Note: J. LOGIC PROGRAMMING  
Abstract: This paper proposes a new logic programming language called GOLOG whose interpreter automatically maintains an explicit representation of the dynamic world being modeled, on the basis of user supplied axioms about the preconditions and effects of actions and the initial state of the world. This allows programs to reason about the state of the world and consider the effects of various possible courses of action before committing to a particular behavior. The net effect is that programs may be written at a much higher level of abstraction than is usually possible. The language appears well suited for applications in high level control of robots and industrial processes, intelligent software agents, discrete event simulation, etc. It is based on a formal theory of action specified in an extended version of the situation calculus. A prototype implementation in Prolog has been developed. / 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Fahiem Bacchus, Joseph Y. Halpern, and J. Levesque, Hector. </author> <title> Reasoning about noisy sensors in the situation calculus. </title> <editor> In Chris S. Mellish, editor, </editor> <booktitle> Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 1933-1940, </pages> <address> Montreal, August 1995. </address> <publisher> Morgan Kaufmann Publishing. </publisher>
Reference-contexts: Exogenous events also affect the picture as the system may no longer know what the actual history is. In many domains, it is also necessary to deal with sensor noise and "control error" (see <ref> [1] </ref> for some initial results). We are also developing an extended version of the language called CONGOLOG that supports concurrent processes, interrupts, and differing priorities on processes (based on an interleaving semantics for concurrent processes) [12].
Reference: 2. <author> Anthony Bonner and Michael Kifer. </author> <title> An overview of transaction logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 133 </volume> <pages> 205-265, </pages> <month> October </month> <year> 1994. </year> <month> 24 </month>
Reference-contexts: A number of other groups are also developing formalisms for the specification of artificial agents. See [35] for a detailed survey of this research. 5. Transaction logic (Bonner and Kifer <ref> [2] </ref>). This is a new logic for defining complex database transactions, and like GOLOG provides a rich repertoire of operators for defining new transactions in terms of old. These include sequence, nondeterministic choice, conditionals and iteration.
Reference: 3. <author> Michael Dixon. </author> <title> Embedded Computation and the Semantics of Programs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Stanford University, Stanford, </institution> <address> CA, </address> <year> 1991. </year> <note> Also appeared as Xerox PARC Technical Report SSL-91-1. </note>
Reference-contexts: Actions may be parameterized. For example, put (x; y) might stand for the action of putting object x on object y, in 1 A similar view is advanced in Dixon <ref> [3] </ref>. 3 which case do (put (A; B); s) denotes that situation resulting from placing A on B when the world is in situation s. Notice that in the situation calculus, actions are denoted by first order terms, and situations (world histories) are also first order terms. <p> However, unlike such general purpose logic programming languages, GOLOG is designed specifically for specifying agents' behaviors and for modeling dynamic systems. In particular, in GOLOG, actions play a fundamental role. There is a body of literature related to the GOLOG project: 1. Dixon's Amala <ref> [3] </ref>. Amala is a programming language in a conventional imperative style. It is designed after the observation that the semantics of embedded programs should reflect the assumptions about the environment 20 as directly as possible.
Reference: 4. <author> Richard E. Fikes and Nils J. Nilsson. </author> <title> STRIPS: a new approach to the application of theorem proving to problem solving. </title> <journal> Artificial Intelligence, </journal> 2(3/4):189-208, 1971. 
Reference-contexts: However, while GOLOG requires these primitives be formally specified within the language, Amala does not. One consequence of this is that programs in GOLOG can be executed by a theorem prover, but not those in Amala. 2. Classical AI planning work (Green [6] and Fikes and Nilsson <ref> [4] </ref>). Like classical AI planning, GOLOG requires primitives and their effects to be formally specified. The major difference is that GOLOG focuses on high-level programming rather than plan synthesis at run-time. But sketchy plans are allowed; nondeterminism can be used to infer the missing details.
Reference: 5. <author> Robert Goldblatt. </author> <title> Logics of Time and Computation. CSLI Lecture Notes No. 7. Center for the Study of Language and Information, </title> <institution> Stanford University, Stanford, </institution> <address> CA, 2nd. edition, </address> <year> 1987. </year>
Reference-contexts: block is x. n = 0? j ( y)[on (x; y)? ; movetotable (x) ; unstack (y; n 1)] endProc ; % main: create a seven block tower, with A clear at the end. maketower (7) ; :(9x)on (x; A)? Except for procedures, this formalization draws considerably from dynamic logic <ref> [5] </ref>. In effect, it reifies as situations in the object language of the situation calculus, the possible worlds with which the semantics of dynamic logic is defined. For a more technical treatment of this macro approach to complex actions, see Levesque, Lin, and Reiter [14]. 3.2.
Reference: 6. <author> Cordell C. Green. </author> <title> Theorem proving by resolution as a basis for question-answering systems. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> volume 4, </volume> <pages> pages 183-205. </pages> <publisher> American Elsevier, </publisher> <address> New York, </address> <year> 1969. </year>
Reference-contexts: However, while GOLOG requires these primitives be formally specified within the language, Amala does not. One consequence of this is that programs in GOLOG can be executed by a theorem prover, but not those in Amala. 2. Classical AI planning work (Green <ref> [6] </ref> and Fikes and Nilsson [4]). Like classical AI planning, GOLOG requires primitives and their effects to be formally specified. The major difference is that GOLOG focuses on high-level programming rather than plan synthesis at run-time. But sketchy plans are allowed; nondeterminism can be used to infer the missing details.
Reference: 7. <author> Andrew R. Haas. </author> <title> The case for domain-specific frame axioms. In F.M. </title> <editor> Brown, editor, </editor> <booktitle> The Frame Problem in Artificial Intelligence: Proceedings of the 1987 Workshop, </booktitle> <pages> pages 343-348, </pages> <publisher> Lawrence, KA, </publisher> <address> April 1987. </address> <publisher> Morgan Kaufmann Publishing. </publisher>
Reference-contexts: If possible, we also want a parsimonious representation for these frame axioms (because in their simplest form, there are too many of them). 2.4. A Simple Solution to the Frame Problem By appealing to earlier ideas of Haas <ref> [7] </ref>, Schubert [29] and Pednault [21], Reiter [23] proposes a simple solution to the frame problem, which we illustrate with an example.
Reference: 8. <author> Todd G. Kelley, </author> <title> Modeling complex systems in the situation calculus: A case study using the Dagstuhl steam boiler problem. In L.C. </title> <editor> Aiello, J. Doyle and S.C. Shapiro, editors, </editor> <booktitle> Principles of Knowledge Representation and Reasoning: Proceedings of the Fifth International Conference (KR'96), to appear. </booktitle> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Francisco, CA. </address>
Reference-contexts: One can then write axioms that describe the evolution in time of the falling object. Reiter [25] gives a situation calculus account of such natural events whose behaviors are described by known laws of physics. This means that one can write GOLOG simulators of such dynamical systems <ref> [8] </ref>. Moreover, although we have not yet explored this possibility, the GOLOG programmer can now write robot controllers which allow a robot to exploit such naturally occurring exogenous events in its environment. 7.
Reference: 9. <author> Yves Lesperance, Hector J. Levesque, F. Lin, Daniel Marcu, Raymond Reiter, and Richard B. Scherl. </author> <title> A logical approach to high-level robot programming a progress report. In Benjamin Kuipers, editor, Control of the Physical World by Intelligent Agents, </title> <booktitle> Papers from the 1994 AAAI Fall Symposium, </booktitle> <pages> pages 109-119, </pages> <address> New Orleans, LA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: To evaluate our interpreter and the entire GOLOG framework, we have been experimenting with various types of applications. The most advanced involves a robotics application mail delivery in an office environment <ref> [9] </ref>. The high-level controller of the robot programmed in GOLOG is interfaced to an existing robotics package that supports path planning and local navigation. The system currently 19 works in simulation mode; experiments with a real robot have begun in collaboration with the robotics group at the University of Bonn.
Reference: 10. <author> Yves Lesperance, Hector J. Levesque, F. Lin, Daniel Marcu, Raymond Reiter, and Richard B. Scherl. </author> <title> Foundations of a logical approach to agent programming. </title> <booktitle> In Working Notes of the IJCAI-95 Workshop on Agent Theories, Architectures, and Languages, </booktitle> <month> August 20-25 </month> <year> 1995. </year>
Reference-contexts: Finally, work is also in progress on a multi-agent distributed version of CONGOLOG for agent-oriented programming applications, which will support distinct world models for each agent and a library of high-level communication actions <ref> [10] </ref>. Notions like ability, goals, commitments, and rational choice become important in such domains and we are extending our model to deal with them [30].
Reference: 11. <author> Yves Lesperance, Hector J. Levesque, Fangzhen Lin, and Richard B. Scherl. </author> <title> Ability and knowing how in the situation calculus. </title> <note> In preparation, </note> <year> 1995. </year>
Reference-contexts: We have considered several possible solutions to this problem. See <ref> [11, 13] </ref>. 3. Exogenous actions. We have assumed that all events of importance are under the agent's control. That is why, in the elevator example, we did not include a primitive action turnon (n), meaning push call button n.
Reference: 12. <author> Hector J. Levesque. </author> <title> Concurrency in the situation calculus. </title> <note> In preparation, </note> <year> 1996. </year>
Reference-contexts: We are also developing an extended version of the language called CONGOLOG that supports concurrent processes, interrupts, and differing priorities on processes (based on an interleaving semantics for concurrent processes) <ref> [12] </ref>. Techniques for representing and reasoning about continuous processes (e.g., filling a bathtub) are also under investigation [25].
Reference: 13. <author> Hector J. Levesque. </author> <booktitle> What is planning in the presence of sensing? In Proceedings of the Thirteenth National Conference on Artificial Intelligence, </booktitle> <pages> pages 1139-1146, </pages> <address> Portland, Oregon, </address> <month> Aug. </month> <pages> 4-8, </pages> <address> 1996. </address> <publisher> AAAI Press/The MIT Press. </publisher>
Reference-contexts: Situated automata [26]. GOLOG shares with situated automata the same philosophy of designing agents using a high level language, and then compiling the high-level programs into low-level ones that can be immediately executed. In the framework considered here, the low-level programs are simply sequences of primitive actions. In <ref> [13] </ref>, we also consider cases involving sensing (see below) where no such sequence exists, and it is necessary to compile to low-level programs containing loops and conditionals. 4. Shoham's AGENT-0 programming language [31]. <p> We have considered several possible solutions to this problem. See <ref> [11, 13] </ref>. 3. Exogenous actions. We have assumed that all events of importance are under the agent's control. That is why, in the elevator example, we did not include a primitive action turnon (n), meaning push call button n.
Reference: 14. <author> Hector J. Levesque, Fangzhen Lin, and Raymond Reiter. </author> <title> Defining complex actions in the situation calculus. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1996. </year> <note> In preparation. </note>
Reference-contexts: Section 6 discusses the main distinguishing characteristics of the language. We conclude by summarizing the main features of our proposal, discussing its limitations, and outlining ongoing work that seeks to address these. The presentation throughout is informal in nature; in a companion paper <ref> [14] </ref>, we explore the more formal aspects of this work. 2. AN INFORMAL INTRODUCTION TO THE SITUATION CALCULUS To obtain the benefits mentioned in the introduction, it is necessary to explicitly model how the world changes as the result of performing actions. <p> In effect, it reifies as situations in the object language of the situation calculus, the possible worlds with which the semantics of dynamic logic is defined. For a more technical treatment of this macro approach to complex actions, see Levesque, Lin, and Reiter <ref> [14] </ref>. 3.2. Why Macros? Programs and complex actions "macro expand" to (sometimes second order) formulas of the situation calculus; complex behaviors are described by situation calculus formulas. <p> Its interpreter is a general-purpose theorem prover. In its most general form, this must be a theorem prover for second order logic; in practice (see Section 6 below, and Levesque, Lin, and Reiter <ref> [14] </ref>), first order logic is sufficient for most purposes. 2. Like Prolog, GOLOG programs are executed for their side effects, namely, to obtain bindings for the existentially quantified variables of the theorem. 5. IMPLEMENTATION AND EXPERIMENTATION In this section, we discuss an implementation of the GOLOG language in Prolog. <p> The exact correspondence between the two depends on a number of factors, and we do not intend to discuss them here. For a formal statement and proof of correctness of this interpreter, the interested reader should consult the companion paper <ref> [14] </ref>. Given the simplicity of the characterization of the do predicate (in first-order Horn clauses), and the complexity of the formula that results from Do (in second-order logic), a reasonable question to ask is why we even bother with the latter.
Reference: 15. <author> Fangzhen Lin. </author> <title> Embracing causality in specifying the indirect effects of actions. </title> <editor> In Chris S. Mellish, editor, </editor> <booktitle> Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 1933-1940, </pages> <address> Montreal, August 1995. </address> <publisher> Morgan Kaufmann Publishing. </publisher>
Reference-contexts: Such constraints sometimes implicitly contain effect axioms (so-called indirect effects), in which case the above completeness assumption will not be true. The assumption that there are no state constraints in the axiomatization of the domain will be made throughout this paper. In <ref> [17, 15] </ref>, the approach discussed in this section is extended to deal with state constraints, by compiling their effects into the successor state axioms. 2.5.
Reference: 16. <author> Fangzhen Lin and Raymond Reiter. </author> <title> How to progress a database (and why) I. logical foundations. </title> <editor> In Jon Doyle, Erik Sandewall, and Pietro Torasso, editors, </editor> <booktitle> Principles of Knowledge Representation and Reasoning: Proceedings of the Fourth International Conference, </booktitle> <pages> pages 425-436, </pages> <address> Bonn, Germany, 1994. </address> <publisher> Morgan Kauf-mann Publishing. </publisher>
Reference-contexts: Doing this repeatedly with very long sequences of actions can take considerable time. Moreover, the Prolog terms representing situations that are far removed from the initial situation end up being gigantic. However, it is possible in many cases to progress the initial database to handle this (Lin and Reiter <ref> [16, 18] </ref>). The idea is that the interpreter periodically "rolls the initial database forward" in response to the actions generated thus far during 17 FIGURE 5.2. <p> There are several limitations to the version of GOLOG that has been presented here. The implementation only works with completely known initial situations. Adapting GOLOG to work with non-Prolog theories in the initial situation will require some effort (see <ref> [16] </ref> for ideas on this). Handling sensing actions requires the system's knowledge state to be modeled explicitly [28] and complicates the representation and updating of the world model. Exogenous events also affect the picture as the system may no longer know what the actual history is.
Reference: 17. <author> Fangzhen Lin and Raymond Reiter. </author> <title> State constraints revisited. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(5) </volume> <pages> 655-678, </pages> <year> 1994. </year>
Reference-contexts: Such constraints sometimes implicitly contain effect axioms (so-called indirect effects), in which case the above completeness assumption will not be true. The assumption that there are no state constraints in the axiomatization of the domain will be made throughout this paper. In <ref> [17, 15] </ref>, the approach discussed in this section is extended to deal with state constraints, by compiling their effects into the successor state axioms. 2.5. <p> These include unique names axioms for situations, and an induction axiom. Since these play no special role in this paper, we omit them. For details, and for their metamathematical properties, see Lin and Reiter <ref> [17] </ref> and Reiter [24]. 6 3. COMPLEX ACTIONS, PROCEDURES AND GOLOG The previous section outlines a situation calculus-based approach for representing, and reasoning about, simple actions.
Reference: 18. <author> Fangzhen Lin and Raymond Reiter. </author> <title> How to progress a database II: The STRIPS connection. </title> <booktitle> In Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 2001-2007, </pages> <address> Montreal, </address> <month> Aug. </month> <pages> 20-25, </pages> <year> 1995. </year>
Reference-contexts: Doing this repeatedly with very long sequences of actions can take considerable time. Moreover, the Prolog terms representing situations that are far removed from the initial situation end up being gigantic. However, it is possible in many cases to progress the initial database to handle this (Lin and Reiter <ref> [16, 18] </ref>). The idea is that the interpreter periodically "rolls the initial database forward" in response to the actions generated thus far during 17 FIGURE 5.2.
Reference: 19. <author> Zohar Manna and Richard Waldinger. </author> <title> How to clear a block: A theory of plans. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 3 </volume> <pages> 343-377, </pages> <year> 1987. </year> <month> 25 </month>
Reference-contexts: For example, we cannot quantify over complex actions, since these are not objects in the language of the situation calculus. This means, for example, that we cannot synthesize programs using conventional theorem proving techniques, as in Manna and Waldinger <ref> [19] </ref>. In their approach to program synthesis, one would obtain a program satisfying the goal formula Goal as a side effect of proving the following entailment: Axioms j= (9ffi; s):Do (ffi; S 0 ; s) ^ Goal (s): Here, Axioms are those described in Section 2.5.
Reference: 20. <author> John McCarthy and Patrick Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence 4, </booktitle> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, Edinburgh, </publisher> <address> Scotland, </address> <year> 1969. </year>
Reference-contexts: There are a variety of ways of doing this, and we use the language of the situation calculus. 2.1. Intuitive Ontology for the Situation Calculus The situation calculus (McCarthy <ref> [20] </ref>) is a first order language (with, as we shall see later, some second order features) specifically designed for representing dynamically changing worlds. All changes to the world are the result of named actions. <p> The Frame Problem As first observed by McCarthy and Hayes <ref> [20] </ref>, axiomatizing a dynamic world requires more than just action precondition and effect axioms. So-called frame axioms are also necessary. These specify the action invariants of the domain, namely, those fluents which remain unaffected by a given action. <p> Unfortunately, Bonner and Kifer do not address the frame problem for these elementary updates; this task is left to the person specifying the database. 6. The strategies of McCarthy and Hayes <ref> [20] </ref>. This is a surprisingly early proposal for representing complex actions (called strategies) in the situation calculus. McCarthy and Hayes even appeal to an Algol-like language for rep 21 resenting their strategies, and they include a mechanism for returning symbolic execution traces, as sequences of actions, of these strategies.
Reference: 21. <author> Edwin P. D. Pednault. </author> <title> ADL: Exploring the middle ground between STRIPS and the situation calculus. </title> <editor> In R.J. Brachman, H.J. Levesque, and R. Reiter, editors, </editor> <booktitle> Proceedings of the First International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 324-332, </pages> <address> Toronto, ON, May 1989. </address> <publisher> Morgan Kauf-mann Publishing. </publisher>
Reference-contexts: If possible, we also want a parsimonious representation for these frame axioms (because in their simplest form, there are too many of them). 2.4. A Simple Solution to the Frame Problem By appealing to earlier ideas of Haas [7], Schubert [29] and Pednault <ref> [21] </ref>, Reiter [23] proposes a simple solution to the frame problem, which we illustrate with an example. Suppose that (2.1), (2.2), and (2.3) are all the effect axioms for the fluent broken, i.e. they describe all the ways that an action can change the truth value of broken. <p> In such cases, a more general GOLOG interpreter is necessary. Such an interpreter might still make use of Prolog's backchaining mechanism to reduce queries about the current situation to queries about the initial situation. In other words, regression-based query evaluation (Waldinger [34], Pednault <ref> [21] </ref>, Reiter [23]) can be implemented using Prolog. However, answering the regressed queries in the initial situation would require, in general, the full power of a first order theorem prover. 5.2.
Reference: 22. <author> Javier Andres Pinto. </author> <title> Temporal Reasoning in the Situation Calculus. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Toronto, Toronto, </institution> <note> ON, February 1994. Available as technical report KRR-TR-94-1. </note>
Reference-contexts: Continuous processes. It is widely believed that, by virtue of its reliance on discrete situations, the situation calculus cannot represent continuous processes and their evolution in time, like an object falling under the influence of gravity. However, as shown by Pinto <ref> [22] </ref> and also by Ternovskaia [33], one can view a process as a fluent falling (s) which becomes true at the time t that the instantaneous action start f alling (t) occurs, and becomes false at the time t of occurrence of the instantaneous action end f alling (t).
Reference: 23. <author> Raymond Reiter. </author> <title> The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression. </title> <editor> In Vladimir Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <pages> pages 359-380. </pages> <publisher> Academic Press, </publisher> <address> San Diego, CA, </address> <year> 1991. </year>
Reference-contexts: If possible, we also want a parsimonious representation for these frame axioms (because in their simplest form, there are too many of them). 2.4. A Simple Solution to the Frame Problem By appealing to earlier ideas of Haas [7], Schubert [29] and Pednault [21], Reiter <ref> [23] </ref> proposes a simple solution to the frame problem, which we illustrate with an example. Suppose that (2.1), (2.2), and (2.3) are all the effect axioms for the fluent broken, i.e. they describe all the ways that an action can change the truth value of broken. <p> The solution to the frame problem of <ref> [23] </ref> rests on a completeness assumption, which is that the causal axioms (2.6) and (2.7) characterize all the conditions under which action a can lead to a fluent F (~x) becoming true (respectively, false) in the successor situation. <p> Therefore, if action a is possible and F (~x)'s truth value changes from false to true as a result of doing a, then fl + F (~x; a; s) must be true and similarly for a change from true to false. Reiter <ref> [23] </ref> shows how to derive a successor state axiom of the following form from the causal axioms (2.6) and (2.7) and the completeness assumption. <p> In such cases, a more general GOLOG interpreter is necessary. Such an interpreter might still make use of Prolog's backchaining mechanism to reduce queries about the current situation to queries about the initial situation. In other words, regression-based query evaluation (Waldinger [34], Pednault [21], Reiter <ref> [23] </ref>) can be implemented using Prolog. However, answering the regressed queries in the initial situation would require, in general, the full power of a first order theorem prover. 5.2.
Reference: 24. <author> Raymond Reiter. </author> <title> Proving properties of states in the situation calculus. </title> <booktitle> Artificial Intelligence, </booktitle> <pages> pages 337-351, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: These include unique names axioms for situations, and an induction axiom. Since these play no special role in this paper, we omit them. For details, and for their metamathematical properties, see Lin and Reiter [17] and Reiter <ref> [24] </ref>. 6 3. COMPLEX ACTIONS, PROCEDURES AND GOLOG The previous section outlines a situation calculus-based approach for representing, and reasoning about, simple actions.
Reference: 25. <author> Raymond Reiter. </author> <title> Natural actions, concurrency and continuous time in the situation calculus. In L.C. </title> <editor> Aiello, J. Doyle and S.C. Shapiro, editors, </editor> <booktitle> Principles of Knowledge Representation and Reasoning: Proceedings of the Fifth International Conference (KR'96), </booktitle> <year> 1996, </year> <title> to appear. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Francisco, CA. </address>
Reference-contexts: One can then write axioms that describe the evolution in time of the falling object. Reiter <ref> [25] </ref> gives a situation calculus account of such natural events whose behaviors are described by known laws of physics. This means that one can write GOLOG simulators of such dynamical systems [8]. <p> We are also developing an extended version of the language called CONGOLOG that supports concurrent processes, interrupts, and differing priorities on processes (based on an interleaving semantics for concurrent processes) [12]. Techniques for representing and reasoning about continuous processes (e.g., filling a bathtub) are also under investigation <ref> [25] </ref>. Finally, work is also in progress on a multi-agent distributed version of CONGOLOG for agent-oriented programming applications, which will support distinct world models for each agent and a library of high-level communication actions [10].
Reference: 26. <author> Stanley J. Rosenschein and Leslie P. Kaelbling. </author> <title> The synthesis of digital machines with provable epistemic properties. </title> <editor> In Joseph Y. Halpern, editor, </editor> <booktitle> Proceedings of the 1986 Conference on Theoretical Aspects of Reasoning about Knowledge, </booktitle> <pages> pages 83-98. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Monterey, CA, </address> <year> 1986. </year>
Reference-contexts: As an extreme case, the program while :Goal do ( a)[Appropriate (a)?; a] endWhile; repeatedly selects an appropriate action and performs it until some goal is achieved. Finding a legal sequence of actions in this case is simply a reformulation of the planning problem. 3. Situated automata <ref> [26] </ref>. GOLOG shares with situated automata the same philosophy of designing agents using a high level language, and then compiling the high-level programs into low-level ones that can be immediately executed. In the framework considered here, the low-level programs are simply sequences of primitive actions.
Reference: 27. <author> Shane Ruman. </author> <title> Golog as an agent-programming language: Experiments in developing banking applications. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Toronto, Toronto, </institution> <note> ON, 1995. In preparation. </note>
Reference-contexts: The system currently 19 works in simulation mode; experiments with a real robot have begun in collaboration with the robotics group at the University of Bonn. Another application involves tools for home banking <ref> [27] </ref>. In this case, a number of software agents written in GOLOG handle various parts of the banking process (responding to buttons on an ATM terminal, managing the accounts at a bank, monitoring account levels for a user etc.) and communicate over TCP/IP.
Reference: 28. <author> Richard B. Scherl and Hector J. Levesque. </author> <title> The frame problem and knowledge-producing actions. </title> <booktitle> In Proceedings of the Eleventh National Conference on Artificial Intelligence, </booktitle> <pages> pages 689-695, </pages> <address> Washington, DC, July 1993. </address> <publisher> AAAI Press/The MIT Press. </publisher>
Reference-contexts: Sensing and knowledge. When modeling an autonomous agent, it is necessary to consider the agent's perceptual actions, e.g. acts of seeing, hearing, etc. Unlike ordinary actions that affect the environment, perceptual actions affect an agent's mental state, i.e. its state of knowledge. Scherl and Levesque <ref> [28] </ref> provide a situation calculus account of knowledge, and within this setting, show how to solve the frame problem for perceptual actions. 2. Sensing and knowing how. In the presence of sensing actions, the method described above for executing GOLOG program is no longer adequate. <p> The implementation only works with completely known initial situations. Adapting GOLOG to work with non-Prolog theories in the initial situation will require some effort (see [16] for ideas on this). Handling sensing actions requires the system's knowledge state to be modeled explicitly <ref> [28] </ref> and complicates the representation and updating of the world model. Exogenous events also affect the picture as the system may no longer know what the actual history is. In many domains, it is also necessary to deal with sensor noise and "control error" (see [1] for some initial results).
Reference: 29. <author> Len K. Schubert. </author> <title> Monotonic solution to the frame problem in the situation calculus: An efficient method for worlds with fully specified actions. In H.E. </title> <editor> Kyberg, R.P. Loui, and G.N. Carlson, editors, </editor> <booktitle> Knowledge Representation and Defeasible Reasoning, </booktitle> <pages> pages 23-67. </pages> <publisher> Kluwer Academic Press, </publisher> <address> Boston, MA, </address> <year> 1990. </year>
Reference-contexts: If possible, we also want a parsimonious representation for these frame axioms (because in their simplest form, there are too many of them). 2.4. A Simple Solution to the Frame Problem By appealing to earlier ideas of Haas [7], Schubert <ref> [29] </ref> and Pednault [21], Reiter [23] proposes a simple solution to the frame problem, which we illustrate with an example.
Reference: 30. <author> Steven Shapiro, Yves Lesperance, and Hector J. Levesque. </author> <title> Goals and rational action in the situation calculus | a preliminary report. </title> <booktitle> In Working Notes of the AAAI Fall Symposium on Rational Agency: Concepts, Theories, Models, and Applications, </booktitle> <address> Cambridge, MA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Notions like ability, goals, commitments, and rational choice become important in such domains and we are extending our model to deal with them <ref> [30] </ref>.
Reference: 31. <author> Yoav Shoham. </author> <title> Agent-oriented programming. </title> <journal> Artificial Intelligence, </journal> <volume> 60(1) </volume> <pages> 51-92, </pages> <year> 1993. </year>
Reference-contexts: In the framework considered here, the low-level programs are simply sequences of primitive actions. In [13], we also consider cases involving sensing (see below) where no such sequence exists, and it is necessary to compile to low-level programs containing loops and conditionals. 4. Shoham's AGENT-0 programming language <ref> [31] </ref>. This includes a model of commitments and capabilities, and has simple communication acts built-in; its agents all have a generic rule-based architecture; there is also a global clock and all beliefs are about time-stamped propositions.
Reference: 32. <author> Joseph E. Stoy. </author> <title> Denotational Semantics. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: ; s 2 ; ~v i ):Do (ffi i ; s 1 ; s 2 ) oe Do (P i (~v i ); s 1 ; s 2 )] This is the situation calculus definition corresponding to the more usual Scott-Strachey least fixed-point definition in standard programming language semantics (Stoy <ref> [32] </ref>). 3 Examples: 1. Given that down means move an elevator down one floor, define d (n), mean ing move an elevator down n floors. proc d (n) (n = 0)? j d (n 1) ; down endProc 2.
Reference: 33. <author> Eugenia Ternovskaia. </author> <title> Interval situation calculus. </title> <booktitle> In Proc. of ECAI'94 Workshop W5 on Logic and Change, </booktitle> <pages> pages 153-164, </pages> <address> Amsterdam, </address> <month> August 8-12, </month> <year> 1994. </year>
Reference-contexts: Continuous processes. It is widely believed that, by virtue of its reliance on discrete situations, the situation calculus cannot represent continuous processes and their evolution in time, like an object falling under the influence of gravity. However, as shown by Pinto [22] and also by Ternovskaia <ref> [33] </ref>, one can view a process as a fluent falling (s) which becomes true at the time t that the instantaneous action start f alling (t) occurs, and becomes false at the time t of occurrence of the instantaneous action end f alling (t).
Reference: 34. <author> Richard Waldinger. </author> <title> Achieving several goals simultaneously. </title> <editor> In E. Elcock and D. Michie, editors, </editor> <booktitle> Machine Intelligence 8, </booktitle> <pages> pages 94-136. </pages> <publisher> Ellis Horwood, </publisher> <address> Edin-burgh, Scotland, </address> <year> 1977. </year>
Reference-contexts: In such cases, a more general GOLOG interpreter is necessary. Such an interpreter might still make use of Prolog's backchaining mechanism to reduce queries about the current situation to queries about the initial situation. In other words, regression-based query evaluation (Waldinger <ref> [34] </ref>, Pednault [21], Reiter [23]) can be implemented using Prolog. However, answering the regressed queries in the initial situation would require, in general, the full power of a first order theorem prover. 5.2.
Reference: 35. <author> M.J. Wooldridge and N.R. Jennings. </author> <title> Intelligent agents: </title> <journal> Theory and practice. Knowledge Engineering Review, </journal> <volume> 10, </volume> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: A number of other groups are also developing formalisms for the specification of artificial agents. See <ref> [35] </ref> for a detailed survey of this research. 5. Transaction logic (Bonner and Kifer [2]). This is a new logic for defining complex database transactions, and like GOLOG provides a rich repertoire of operators for defining new transactions in terms of old. These include sequence, nondeterministic choice, conditionals and iteration.
References-found: 35

