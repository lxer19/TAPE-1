URL: http://www.eecs.umich.edu/RTCL/adaptware/proposal.ps
Refering-URL: http://www.eecs.umich.edu/RTCL/adaptware/
Root-URL: http://www.cs.umich.edu
Title: A Dissertation Proposal on NEGOTIATION-BASED QOS ADAPTATION IN REAL-TIME SYSTEMS  
Author: by Tarek F. Abdelzaher 
Degree: Thesis Proposal Committee: Professor Kang Shin, Chair Professor Farnam Jahanian Professor Sugih Jamin Professor Kimberly Wasserman  
Address: Ann Arbor, Michigan  
Affiliation: Real-Time Computing Laboratory Department of Electrical Engineering Computer Science The University of Michigan  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D. Seto, J. P. Lehoczky, L. Sha, and K. G. Shin, </author> <title> "On task schedulability in real-time control systems," </title> <booktitle> in IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 13-21, </pages> <address> Washington, DC, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: A client task's QoS level is specified by the parameters of its execution model. For example, for an independent periodic task, these parameters are task period, deadline, and execution time. Period and deadline are negotiable parameters (e.g., 10 the authors of <ref> [1] </ref> articulated on alterability of task periods in real-time control systems using system stability and performance index). Task execution time, on the other hand, depends on the underlying machine speed and thus should not be hardcoded in the client's request.
Reference: [2] <author> T. F. Abdelzaher and K. G. Shin. </author> <title> Optimal Combined task and Message Scheduling in Distributed Real-Time Systems. </title> <journal> submitted to IEEE Transactions on Paralled and Distributed Systems, </journal> <month> October </month> <year> 1995. </year>
Reference-contexts: Approximate analytic analysis shows that, under a fairly reasonable assumptions about the task load, the number of vertices searched before an optimal solution is found is O (n), where n is the system size <ref> [2] </ref>. Our simulation results support this analysis [3]. 16 Since it often suffices in hard real-time systems to find a feasible schedule which satisfies all deadlines as opposed to an optimal one, the algorithm may be terminated after finding a first feasible schedule.
Reference: [3] <author> T. F. Abdelzaher and K. G. Shin, </author> <title> "Optimal combined task and message scheduling in distributed real-time systems," </title> <booktitle> in IEEE Real-Time Systems Symposium, </booktitle> <address> Italy, Pisa, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Approximate analytic analysis shows that, under a fairly reasonable assumptions about the task load, the number of vertices searched before an optimal solution is found is O (n), where n is the system size [2]. Our simulation results support this analysis <ref> [3] </ref>. 16 Since it often suffices in hard real-time systems to find a feasible schedule which satisfies all deadlines as opposed to an optimal one, the algorithm may be terminated after finding a first feasible schedule. <p> Such an analysis requires that the worst-case load/failure conditions be known at design time. For example, the authors of [13] described an optimal schedulability analysis algorithm for uniprocessors, which considers precedence and resource constraints. In [14] and [15] a similar optimal result is derived for multiprocessors, while in <ref> [3] </ref> the result is extended to distributed systems. For some applications, the worst-case load and failure conditions may be difficult to predict accurately at design time.
Reference: [4] <author> D. D. Kandlur, K. G. Shin, and D. Ferrari, </author> <title> "Real-time communication in multi-hop networks," </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> vol. 5, no. 10, </volume> <pages> pp. 1044-1056, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: A real-time channel is used between each pair of communicating tasks, thus bounding queuing delays d queue on each link <ref> [4] </ref>. Messages are considered for scheduling in order of their priorities. For each message, Dijksta's algorithm is used to find the minimum-cost path from source to destination, given the paths taken by higher-priority messages. <p> A mechanism is therefore needed to ensure graceful degradation of system performance when the load or failure hypotheses are violated. On-line admission control has been used to guarantee predictability of services where request patterns are not known in advance. For example, establishment requests of real-time channels <ref> [4] </ref> pass through a form of on-line admission control protocol. The concept has also been applied to resource reservation for dynamically-arriving real-time tasks. To cope with unpredictable environments of some real-time systems, the Spring Kernel [16] uses on-line task admission control to guarantee essential tasks as they arrive.
Reference: [5] <author> M.-I. Chen and K.-J. Lin, </author> <title> "Dynamic priority ceilings: A concurrency control protocol for real-time systems," </title> <journal> Journal of Real Time Systems, </journal> <volume> vol. 2, no. 4, </volume> <pages> pp. 325-346, </pages> <year> 1990. </year>
Reference-contexts: To prevent unbounded (dynamic) priority inversion, a module which blocks others with earlier deadlines inherits the earliest of these deadlines. We call this policy EDF with Deadline Inheritance (EDF-DI). Note that we do not use dynamic priority ceilings <ref> [5] </ref>, because deadlocks cannot occur in our simplified model. In the rest of this paper we will occasionally use the same symbol to denote the module and its priority. 20 4.2.3 Branching Since tasks and messages are scheduled EDF, in order to improve a schedule, deadlines have to be altered.
Reference: [6] <author> W. H. Kohler and K. Steiglitz, </author> <title> "Enumerative and iterative computational approach," </title> <journal> Computer and Job-Shop Scheduling Theory, </journal> <pages> pp. 229-287, </pages> <year> 1976. </year>
Reference-contexts: In what follows, we first describe how sets L, R and M are generated, then prove that the resulting search space always contains a vertex representing an optimal solution. The algorithm will find that solution as long as the bounding function computes a true lower bound <ref> [6] </ref>. To generate a child in set M, the priority of some message is increased to the current priority limit so that the lateness of the latest module at the parent vertex may be reduced. The priority limit is set to 1 (highest priority) at the root. <p> That is, no descendant of V may have a lower performance measure than the computed bound at V <ref> [6] </ref>.
Reference: [7] <author> T. Abdelzaher, A. Shaikh, F. Jahanian, and K. Shin, "RTCAST: </author> <title> Lightweight multicast for real-time process groups," </title> <booktitle> in IEEE Real-Time Technology and Applications Symposium, </booktitle> <address> Boston, Mas-sachusetts, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: in full. 5.1.2 Dynamic Adaptation to Changing Resource Pool Size In order to maintain a consistent view of the distributed resources (machines) available to the a QoS provider at any given time, the processing nodes that belong to the provider run a group membership algorithm which is a derivative of <ref> [7] </ref>. When a new QoS provider is created, a new resource pool is formed. Other machines can join the pool using the subscribe to QoS provider () call which causes the machine on which the call was executed to join the resource pool of the named provider.
Reference: [8] <author> A. Mehra, A. Indiresan, and K. G. Shin, </author> <title> "Structuring communication for quality of service guarantees," </title> <booktitle> in IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 144-154, </pages> <address> Washington, DC, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: This support has not been implemented yet. Currently the communication subsystem architecture on each host is designed to support prioritized, bounded-time message delivery. This architecture has been proposed earlier in literature in the context of implementing real-time channels <ref> [8] </ref>, and is being generalized jointly with the author to become independent of the particular communication paradigm. The protocol stack is implemented in xKernel 3.2 [9]. 5.2.1 Time-bounded Prioritized Communication Support In order for the QoS provider to guarantee task timing constraints intertask communication must occur in bounded time. <p> In the following we present features of CLIPS implementation that ensure proper handling of priorities. The underlying architectural considerations are generalized from <ref> [8] </ref>. Figure 5.2 is a simplified conceptual view of a CLIPS endpoint. Preemptive Scheduling Model The main problem with implementing prioritized resource assignment is to avoid unbounded priority inversion. <p> Preemption cost may be further reduced by amortizing it over several packet transmissions, i.e., allowing preemptions only every N packet transmissions, where N is a design parameter. Thus, to reduce the number of preemptions (and the corresponding overhead) we use the cooperative preemption model suggested in <ref> [8] </ref>. Message Priority Inheritance To support scheduling messages in accordance with message priorities threads that process these messages (message handler threads) must inherit the priority or timing constraints associated with the message being processed. Thus, message handler threads do not have priorities of their own.
Reference: [9] <author> N. C. Hutchinson and L. L. Peterson, </author> <title> "The x-Kernel: An architecture for implementing network protocols," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 17, no. 1, </volume> <pages> pp. 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: This architecture has been proposed earlier in literature in the context of implementing real-time channels [8], and is being generalized jointly with the author to become independent of the particular communication paradigm. The protocol stack is implemented in xKernel 3.2 <ref> [9] </ref>. 5.2.1 Time-bounded Prioritized Communication Support In order for the QoS provider to guarantee task timing constraints intertask communication must occur in bounded time. Furthermore, as suggested in Chapter 4 messages should be prioritized. In contrast, in most existing operating systems messages are processed in FIFO order.
Reference: [10] <author> T. F. Abdelzaher, E. M. Atkins, and K. G. Shin, </author> <title> "QoS negotiation in real-time systems and its application to automated flight control," </title> <booktitle> in IEEE Real-Time Technology and Applications Symposium, </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: The system was used to fly a simulated model of an F-16 fighter aircraft. The experiments and results described in this section, were conducted by an application domain expert. More detail on these experiments are found in <ref> [10] </ref>. Details of the automated aircraft flight problem to which our middleware was applied are provided in Section 6.1. Section 6.2 summarizes the set of tasks, QoS levels, and rewards that describe the application. <p> The key issue is that a schedulable set of degraded tasks was found that satisfies designer's preferences when the original set of QoS levels could no longer be maintained. More complete results are reported in <ref> [10] </ref>. The set of tests reported above is by no means complete or adequate to illustrate the potential and limitations of QoS negotiation and adaptation. However, it does show that the concept can be applied successfully to embedded real-time systems.
Reference: [11] <author> R. Rainey. </author> <title> ACM: The Aerial Combat Simulation for X11, </title> <month> February </month> <year> 1994. </year>
Reference-contexts: The QoS negotiation and adaptation scheme described earlier will allow the system to gracefully degrade performance when enough resources are lost to violate off-line guarantees. In the conducted experiments, a simulated F-16 aircraft flight was controlled. The Aerial Combat 36 (ACM) F-16 flight simulator <ref> [11] </ref> has been used for all flight tests. A control loop was employed to command primary actuators, including the elevator, ailerons, rudder, and throttle, as well as secondary actuators including the afterburner, flaps and speed brake.
Reference: [12] <author> E. M. Atkins. </author> <title> Reasoning About and In Time when Building Plans for Safe, Fully-Automated Aircraft Flight. </title> <type> Ph.D. Thesis Proposal, </type> <month> December </month> <year> 1996. </year>
Reference-contexts: A control loop was employed to command primary actuators, including the elevator, ailerons, rudder, and throttle, as well as secondary actuators including the afterburner, flaps and speed brake. The used flight control laws have been developed in <ref> [12] </ref>. 6.2 Description of Flight Tasks The goals of the simulated mission were to complete the flight around a rectangular pattern (illustrated in Figure 6.2), and to destroy observed enemy targets, if any, using the simulated F-16's onboard radar and missiles.
Reference: [13] <author> J. Xu and D. L. Parnas, </author> <title> "Scheduling processes with release times, deadlines, precedence, and exclusion relations," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. SE-16, no. 3, </volume> <pages> pp. 360-369, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Off-line schedulability analysis is used to verify that the reserved resources are sufficient for meeting all timing constraints. Such an analysis requires that the worst-case load/failure conditions be known at design time. For example, the authors of <ref> [13] </ref> described an optimal schedulability analysis algorithm for uniprocessors, which considers precedence and resource constraints. In [14] and [15] a similar optimal result is derived for multiprocessors, while in [3] the result is extended to distributed systems.
Reference: [14] <author> J. Xu, </author> <title> "Multiprocessor scheduling of processes with release times, deadlines, precedence, and exclusion relations," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 19, no. 2, </volume> <pages> pp. 139-154, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: Such an analysis requires that the worst-case load/failure conditions be known at design time. For example, the authors of [13] described an optimal schedulability analysis algorithm for uniprocessors, which considers precedence and resource constraints. In <ref> [14] </ref> and [15] a similar optimal result is derived for multiprocessors, while in [3] the result is extended to distributed systems. For some applications, the worst-case load and failure conditions may be difficult to predict accurately at design time.
Reference: [15] <author> T. Shepard and M. Gagne, </author> <title> "A pre-run-time scheduling algorithm for hard real-time systems," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 17, no. 7, </volume> <pages> pp. 669-677, </pages> <month> Jul </month> <year> 1991. </year>
Reference-contexts: Such an analysis requires that the worst-case load/failure conditions be known at design time. For example, the authors of [13] described an optimal schedulability analysis algorithm for uniprocessors, which considers precedence and resource constraints. In [14] and <ref> [15] </ref> a similar optimal result is derived for multiprocessors, while in [3] the result is extended to distributed systems. For some applications, the worst-case load and failure conditions may be difficult to predict accurately at design time.
Reference: [16] <author> J. A. Stankovic and K. Ramamritham, </author> <title> "The Spring Kernel: A new paradigm for real-time systems," </title> <journal> IEEE Software, </journal> <pages> pp. 62-72, </pages> <month> May </month> <year> 1991. </year> <month> 48 </month>
Reference-contexts: For example, establishment requests of real-time channels [4] pass through a form of on-line admission control protocol. The concept has also been applied to resource reservation for dynamically-arriving real-time tasks. To cope with unpredictable environments of some real-time systems, the Spring Kernel <ref> [16] </ref> uses on-line task admission control to guarantee essential tasks as they arrive. Tasks which cannot be guaranteed (e.g., because of resource scarcity) are rejected upon their arrival.
Reference: [17] <author> S. Sommer and J. Potter, </author> <title> "Operating system extensions for dynamic real-time applications," </title> <booktitle> in IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 45-50, </pages> <address> Washington, DC, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: A main concern of the Spring approach is to ensure predictability. Thus, run-time guarantees given to the admitted tasks are not revoked even if they result in rejecting subsequently-arriving more "important" tasks competing for the same resources. 42 The Dreams real-time system <ref> [17] </ref> extends the notion of on-line guarantees further to accommodate transient periodic processes. A transient periodic process arrives dynamically and requests periodic service throughout a given interval of time. The process is guaranteed only if each of its invocations in the specified time interval can meet its deadline.
Reference: [18] <author> D. D. Clark, S. Shenker, and L. Zhang, </author> <title> "Supporting real-time applications in an integrated services packet network: Architecture and mechanism," </title> <booktitle> in Proc. of ACM SIGCOMM, </booktitle> <pages> pp. 14-26, </pages> <year> 1992. </year>
Reference-contexts: All best-effort service schemes can be put under this category. An example is packet communication on a token bus. Different applications do not have their own guaranteed bandwidth connections. Instead, packet transmission requests are served in simple priority order. Many real-time kernels such as Alpha <ref> [18] </ref> and Mach [19] support this philosophy for real-time tasks. Instead of using admission control, they adopt a best-effort approach based on task time-value functions or priorities. Under overload conditions, tasks of lower values (or priorities) are denied service in favor of more important tasks.
Reference: [19] <author> H. Tokuda, T. Nakajima, and P. Rao, </author> <title> "Real-time Mach: Towards a predictable real-time system," </title> <booktitle> in Proceedings of the USENIX Mach Workshop, </booktitle> <pages> pp. 73-82, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: All best-effort service schemes can be put under this category. An example is packet communication on a token bus. Different applications do not have their own guaranteed bandwidth connections. Instead, packet transmission requests are served in simple priority order. Many real-time kernels such as Alpha [18] and Mach <ref> [19] </ref> support this philosophy for real-time tasks. Instead of using admission control, they adopt a best-effort approach based on task time-value functions or priorities. Under overload conditions, tasks of lower values (or priorities) are denied service in favor of more important tasks.
Reference: [20] <author> G. Koren and D. Shasha, "D-over: </author> <title> An optimal on-line scheduling algorithm for overloaded real-time systems," </title> <booktitle> in IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 290-299, </pages> <address> Phoenix, Arizona, </address> <month> December </month> <year> 1992. </year>
Reference-contexts: In such systems, a suitable run-time scheduling policy can be used to maximize the total achieved utility/reward. For example, an optimal on-line algorithm for maximizing total utility in overloaded uniprocessor real-time systems is described in <ref> [20] </ref>. The authors of [21] present important results regarding the scheduling policies to maximize real-time task completion count under overload conditions.
Reference: [21] <author> S. K. Baruah, J. Haritsa, and N. Sharma, </author> <title> "On-line scheduling to maximize task completions," </title> <booktitle> in IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 228-236, </pages> <address> San Juan, Puerto Rico, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: In such systems, a suitable run-time scheduling policy can be used to maximize the total achieved utility/reward. For example, an optimal on-line algorithm for maximizing total utility in overloaded uniprocessor real-time systems is described in [20]. The authors of <ref> [21] </ref> present important results regarding the scheduling policies to maximize real-time task completion count under overload conditions.
Reference: [22] <author> M. B. Jones and P. J. Leach, </author> <title> "Modular real-time resource management in the rialto operating system," </title> <type> Technical Report MSR-TR-95-16, </type> <institution> Microsoft Research, Advanced Technology Division, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: The approach is suitable for soft real-time systems. The Rialto operating system <ref> [22] </ref> adopts a similar philosophy. It attempts to dynamically maximize the users' perceived utility of the entire system, rather than the performance of any particular application.
Reference: [23] <author> W. Zhao and K. Ramamritham, </author> <title> "Virtual time CSMA protocols for hard real-time communication," </title> <journal> IEEE Transactions of Software Engineering, </journal> <volume> vol. 13, no. 8, </volume> <pages> pp. 938-952, </pages> <year> 1987. </year>
Reference-contexts: Instead, the allotted portion of the resource to a given party can change in view of subsequent resource requests by other parties. Compromises between giving irrevocable service guarantees to arriving requests, and maximizing the overall system utility have been addressed. Virtual clock based communication schemes <ref> [23] </ref>, for example, essentially delay a request for packet transmission until a virtual arrival time. This is shown 43 to enforce a global priority order (which is a special case of maximizing utility). Recently, a similar approach has been suggested for guaranteeing dynamic real-time tasks.
Reference: [24] <author> A. Hafid, G. Bochmann, and R. Dssouli, </author> <title> "Models for quality of service negotiation in distributed multimedia applications," </title> <booktitle> in Second International Workshop on Protocols for Multimedia Systems, </booktitle> <address> Salzburg, Austria, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Second, it provides a generic means of utilizing application-specific knowledge to control QoS degradation. Such an approach has been used extensively for multimedia systems (typically over Internet). For example, models for QoS negotiation in distributed multimedia systems have been proposed in <ref> [24] </ref> and [25]. In [26] a framework has been described for specifying and negotiating QoS in a multimedia system such that user-perceived system utility is maximized. An architecture based on QoS negotiation, called the QoS Broker [27], has been suggested for the communication subsystem on hosts.
Reference: [25] <author> A. Hafid and R. Dssouli, </author> <title> "A negotiation model for distributed multimedia applications," </title> <booktitle> in First IEEE International Conference on Multimedia Networking, Aizu, </booktitle> <address> Japan, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Second, it provides a generic means of utilizing application-specific knowledge to control QoS degradation. Such an approach has been used extensively for multimedia systems (typically over Internet). For example, models for QoS negotiation in distributed multimedia systems have been proposed in [24] and <ref> [25] </ref>. In [26] a framework has been described for specifying and negotiating QoS in a multimedia system such that user-perceived system utility is maximized. An architecture based on QoS negotiation, called the QoS Broker [27], has been suggested for the communication subsystem on hosts.
Reference: [26] <author> T. Plagemann, K. A. Saethre, and V. Goebel, </author> <title> "Application requirements and QoS negotiation in multimedia systems," </title> <booktitle> in 2nd Workshop on Protocols for Multimedia Systems, </booktitle> <address> Salzburg, Austria, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Second, it provides a generic means of utilizing application-specific knowledge to control QoS degradation. Such an approach has been used extensively for multimedia systems (typically over Internet). For example, models for QoS negotiation in distributed multimedia systems have been proposed in [24] and [25]. In <ref> [26] </ref> a framework has been described for specifying and negotiating QoS in a multimedia system such that user-perceived system utility is maximized. An architecture based on QoS negotiation, called the QoS Broker [27], has been suggested for the communication subsystem on hosts.
Reference: [27] <author> K. Nahrstedt and J. M. Smith, </author> <title> "The qos broker," </title> <journal> IEEE Multimedia, </journal> <volume> vol. 2, no. 1, </volume> <pages> pp. 53-67, </pages> <year> 1995. </year>
Reference-contexts: In [26] a framework has been described for specifying and negotiating QoS in a multimedia system such that user-perceived system utility is maximized. An architecture based on QoS negotiation, called the QoS Broker <ref> [27] </ref>, has been suggested for the communication subsystem on hosts. Simple support for negotiating communication traffic parameters has been incorporated in ATM interface specification.
Reference: [28] <author> D. A. Castanon and D. P. Martin, </author> <title> "Hypothesis testing," </title> <type> Technical report, </type> <institution> Honeywell Technology Center, </institution> <month> February </month> <year> 1996. </year> <month> 49 </month>
Reference-contexts: In addition to the flight control application mentioned in Chapter 6, we consider hypothesis testing <ref> [28] </ref> as a candidate application. The application is used in command and control for radar detection and tracking of multiple objects. It is computationally intensive and, as such, is suitable for demonstrating our service whose main focus is computing resources.
References-found: 28

