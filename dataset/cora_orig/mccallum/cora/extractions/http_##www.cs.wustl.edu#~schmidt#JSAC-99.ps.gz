URL: http://www.cs.wustl.edu/~schmidt/JSAC-99.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/tri-dove.html
Root-URL: 
Email: fgokhale,schmidtg@cs.wustl.edu  
Title: Optimizing a CORBA IIOP Protocol Engine for Minimal Footprint Multimedia Systems  
Author: Aniruddha S. Gokhale and Douglas C. Schmidt 
Keyword: CORBA performance optimizations, minimal footprint ORBs.  
Note: This work was supported in part by NSF grant NCR-9628218.  
Address: St. Louis, MO 63130  
Affiliation: Department of Computer Science Washington University  
Abstract: This paper has been submitted to the IEEE Journal on Selected Areas in Communications special issue on Service Enabling Platforms for Networked Multimedia Systems. Abstract Communication software for hand-held devices must be flexible and efficient to deliver the necessary Quality of Service (QoS) to multimedia applications such as real-time audio and video, video on-demand, electronic mail and fax, and Internet telephony. CORBA Object Request Brokers (ORBs) are an emerging middleware standard targeted for distributed applications. The stringent memory constraints imposed by handheld device hardware necessitates a minimal footprint for ORB-based applications. This paper provides three contributions to developing efficient ORB middleware for hand-held devices. First, we describe protocol implementation optimizations we employed to develop a time- and space-efficient interpretive IIOP protocol engine. Second, we describe IDL compiler optimizations for generating efficient stubs and skeletons that use our IIOP protocol engine. Finally, we empirically compare the performance and memory footprint of interpretive marshaling versus compiled marshaling for a wide range of IDL data types. Our optimizations to the interpretive IIOP protocol engine improve its performance substantially and it is now comparable the performance of compiled marshaling. Moreover, our IDL compiler optimizations yielded stubs and skeletons whose footprint is substantially smaller than those using compiled marshaling. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Comerford, </author> <title> Pocket Computers Ignite OS Battle, </title> <journal> IEEE Spectrum, </journal> <volume> vol. 35, </volume> <pages> pp. 4348, </pages> <month> May </month> <year> 1998. </year>
Reference-contexts: 1 Introduction 1.1 Emerging Trends in Distributed Multime dia Devices Hand-held devices are growing in popularity as wireless technology becomes increasingly sophisticated <ref> [1] </ref>. A wide range of portable devices with multimedia capabilities are now appearing. These include hand-held and palm-top computers, Web-telephones, Web-to-TV set-top-boxes, Web based personal information managers (PIMs), and automotive PCs [2].
Reference: [2] <author> T. Lewis, </author> <title> Information Appliances: </title> <journal> Gadget Netopia, Computer, </journal> <volume> vol. 31, </volume> <pages> pp. 5968, </pages> <month> Jan. </month> <year> 1998. </year>
Reference-contexts: A wide range of portable devices with multimedia capabilities are now appearing. These include hand-held and palm-top computers, Web-telephones, Web-to-TV set-top-boxes, Web based personal information managers (PIMs), and automotive PCs <ref> [2] </ref>. The growing demand for hand-held devices has also increased the need for real-time and embedded operating systems such as VxWorks, Inferno, PalmOS, and Windows CE 2.0. However, these operating systems only provide low-level infrastructure for developing applications and common services for hand-held devices.
Reference: [3] <author> S. Vinoski, </author> <title> CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments, </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 14, </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: CORBA is an emerging OO middleware standard designed to simplify the development of distributed applications. At the heart of CORBA are Object Request Brokers (ORBs). ORBs allow clients to invoke operations on remote objects without concern for where the object resides or what language the object is written in <ref> [3] </ref>. ORBs simplify application software by automating common networking tasks such as object registration, location, and activation; request demultiplexing; framing and error-handling; parameter marshalling and demarshalling; and operation dispatching [4]. <p> TAO is is targeted for applications with deterministic and statistical QoS requirements, as well as best effort requirements. This section outlines the CORBA reference model, its GIOP/IIOP interoperability protocols, SunSoft IIOP, and TAO. 2.1 Overview of CORBA CORBA Object Request Brokers (ORBs) <ref> [3] </ref> allow clients to invoke operations on distributed objects without concern for: * Object location: CORBA objects can be located locally with the client or remotely on a server, without affecting their implementation or use; * Programming language: The languages supported by CORBA include C, C++, Java, Ada95, COBOL, and Smalltalk,
Reference: [4] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.2 ed., </editor> <month> Feb. </month> <year> 1998. </year>
Reference-contexts: ORBs simplify application software by automating common networking tasks such as object registration, location, and activation; request demultiplexing; framing and error-handling; parameter marshalling and demarshalling; and operation dispatching <ref> [4] </ref>. <p> ORB Core: When a client invokes an operation on a servant, the ORB Core is responsible for delivering the request to the servant and returning a response, if any, to the client. For servants executing remotely, a CORBA-compliant <ref> [4] </ref> ORB Core communicates via the Internet Inter-ORB Protocol (IIOP), a version of the General Inter-ORB Protocol (GIOP) which runs atop the TCP transport protocol. An ORB Core is typically implemented as a run-time library linked into client and server applications. <p> Clients making requests need not know whether the server ORB uses static skeletons or dynamic skeletons. Object Adapter: An Object Adapter associates a servant with an ORB, demultiplexes incoming requests to the servant, and dispatches the appropriate operation upcall on that servant. Recent CORBA portability enhancements <ref> [4] </ref> define the Portable Object Adapter (POA), which supports multiple nested POAs per ORB. 2 The OMG is currently standardizing an asynchronous method invocation interface, as well. 3 2.2 Overview of CORBA GIOP and IIOP The CORBA General Inter-ORB Protocol (GIOP) defines an interoperability protocol between potentially heterogeneous ORBs. <p> In addition, the GIOP specification defines a connection management protocol and a set of constraints for message ordering. The most common concrete mapping of GIOP onto the TCP/IP transport protocol is known as the Internet Inter-ORB Protocol (IIOP). The GIOP and IIOP specifications are described further in <ref> [4] </ref> and Appendix A. 2.3 Overview of the SunSoft IIOP Protocol En gine SunSoft IIOP is a protocol engine that implements IIOP version 1.0. <p> In addition, pseudo-objects are typically locality constrained, i.e., they cannot be transferred as parameters to methods of an IDL interface. SunSoft IIOP supports dynamic skeletons via the dynamic skeleton interface (DSI). The DSI is used by applications and ORB bridges <ref> [4] </ref> that have no compile-time knowledge of the interfaces they implement. Thus, the DSI parses incoming requests, unmarshals their parameters, and demultiplexes requests to the appropriate servants. Servers that use the SunSoft DSI mechanism must provide TypeCode information used to interpret incoming requests and demarshal the parameters. <p> In both RPC toolkits and CORBA, this transformation process is performed by client-side stubs and server-side skeletons that are generated by interface definition language (IDL) compilers. IDL compilers translate interfaces written in an IDL (such as Sun RPC XDR [37], DCE NDR, or CORBA CDR <ref> [4] </ref>) to other forms such as a network wire format. A significant amount of research has been devoted to developing efficient stub generators. We cite a few of these and classify them as below.
Reference: [5] <author> G. Forman and J. Zahorhan, </author> <title> The Challenges of Mobile Computing, </title> <journal> IEEE Computer, </journal> <volume> vol. 27, </volume> <pages> pp. 3847, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: However, developing efficient and predictable communication middleware like CORBA for hand-held multimedia applications yields numerous research challenges. Many challenges are related to meeting mobile computing demands <ref> [5, 6] </ref>, such as handling low bandwidth, heterogeneity in the network connections, frequent changes and disruptions in the established connections due to migrating targets, maintaining consistency of data, and dealing with heterogeneous architectures to which these devices can be docked.
Reference: [6] <author> L. Chen and T. Suda, </author> <title> Designing Mobile Computing Systems using Distributed Objects, </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 14, </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: However, developing efficient and predictable communication middleware like CORBA for hand-held multimedia applications yields numerous research challenges. Many challenges are related to meeting mobile computing demands <ref> [5, 6] </ref>, such as handling low bandwidth, heterogeneity in the network connections, frequent changes and disruptions in the established connections due to migrating targets, maintaining consistency of data, and dealing with heterogeneous architectures to which these devices can be docked.
Reference: [7] <author> G. Varghese, </author> <title> Algorithmic Techniques for Efficient Protocol Implementations , in SIGCOMM '96 Tutorial, </title> <publisher> (Stanford, </publisher> <address> CA), </address> <publisher> ACM, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: These restrictions constrain the amount of storage used by these devices. Likewise, storage constraints dictate the size, flexibility, and performance of OO middleware software for hand-held devices. The specific research challenges addressed in this paper focus on supporting performance-sensitive distributed applications over hand-held devices by systematically applying principle-driven optimizations <ref> [7] </ref> that improve ORB performance without unduly increasing ORB memory footprint. <p> Lack of IIOP optimizations: As described in Section 3, SunSoft IIOP yielded relatively poor performance due to excessive marshaling/demarshaling overhead, data copying, and high-levels of function call overhead. Therefore, we applied principle-based optimizations <ref> [7] </ref> that improved its performance considerably [15]. <p> Next, we use Quantify to illustrate the key sources of overhead in SunSoft IIOP. Finally, we describe the benefits applying optimization principles to improve the performance of SunSoft IIOP. The optimizations described in this section are based on the core principles shown in Table 1 for implementing protocols efficiently. <ref> [7] </ref> describes a collection of optimization princi Number Principle 1 Optimizing for the common case 2 Eliminating gratuitous waste 3 Replacing inefficient general-purpose methods with efficient special-purpose ones 4 Precomputing values, if possible 5 Storing redundant state to speed up expensive operations 6 Passing information between layers 7 Optimizing for the
Reference: [8] <author> D. C. Schmidt, D. L. Levine, and S. Mungee, </author> <title> The Design and Performance of Real-Time Object Request Brokers, </title> <journal> Computer Communications, </journal> <volume> vol. 21, </volume> <pages> pp. 294324, </pages> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: The optimizations described in this paper have been incorporated into The ACE ORB (TAO) <ref> [8] </ref>. TAO is a real-time ORB based on SunSoft IIOP, which is a freely available 1 protocol engine that implements version 1.0 of the Internet Inter-ORB Protocol (IIOP). <p> Appendix C examines the run-time behavior of SunSoft IIOP by tracing the path taken by requests used to transmit the sequence of BinStructs shown below: // BinStruct is 32 bytes (including padding). struct BinStruct - short s; char c; long l; octet o; double d; octet pad <ref> [8] </ref> -; // Richly typed data. interface ttcp_throughput - typedef sequence&lt;BinStruct&gt; StructSeq; // similarly for the rest of the types // Methods to send various data type sequences. oneway void sendStructSeq (in StructSeq ts); // similarly for rest of the types -; The performance of SunSoft IIOP for these data types <p> TAO implements many of these missing features and provides several new features such as real-time scheduling and dispatching mechanisms <ref> [8] </ref>. Lack of real-time features: SunSoft IIOP provides no support for real-time features. For instance, it uses a FIFO strategy for scheduling and dispatching client IIOP requests. FIFO strategies can yield unbounded priority inversions when lower priority requests block the execution of higher priority requests [13]. <p> FIFO strategies can yield unbounded priority inversions when lower priority requests block the execution of higher priority requests [13]. TAO is designed carefully to prevent unbounded 5 priority inversions. For instance, it provides a flexible schedul-ing service <ref> [8] </ref> that utilizes QoS information associated with the I/O subsystem [14] to schedule and dispatch requests according to their end-to-end priorities. To enable this, TAO extends SunSoft IIOP to support QoS parameters, as well as to allow separate IIOP connections to run within real-time threads with suitable priorities. <p> Real-time Object Adapter and ORB Core: In addition to associating servants with the ORB and demultiplexing incoming requests to servants, TAO's Object Adapter (OA) implementation dispatches servant operations in accordance with various real-time scheduling strategies such as Rate Monotonic and Maximal Urgency First <ref> [8] </ref>. ORB QoS Interface: TAO's QoS interface is designed to map real-time processing requirements to ORB endsys-tem/network resources. Common real-time processing requirements include end-to-end latency bounds and periodic scheduling deadlines. Common ORB endsystem/network resources include CPU, memory, network connections and storage devices.
Reference: [9] <author> A. Gokhale and D. C. Schmidt, </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks, </title> <booktitle> in Proceedings of SIGCOMM '96, </booktitle> <address> (Stanford, CA), </address> <pages> pp. 306317, </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: For primitive types, the skeleton sizes were comparable. However, the interpreted stubs were roughly 40% of the compiled stubs. 1 See ftp://ftp.omg.org/pub/interop/ for the SunSoft IIOP source code. The optimized version of TAO is now comparable to existing commercial ORBs <ref> [9, 10, 11] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). 1.3 Paper Organization This paper is organized as follows: Section 2 outlines the CORBA reference model, the GIOP/IIOP interoperability protocols, SunSoft <p> Optimizing such soft 7 ware is hard, particularly since seemingly minor mistakes, such as excessive data copying, dynamic allocation, or locking, can reduce performance significantly <ref> [9, 13] </ref>. Therefore, developing high-performance, predictable, and space-efficient ORBs requires an iterative, multi-step process. The first step involves measuring the performance of the system and pinpointing the sources of overhead. The second step involves a careful analysis of these sources of overhead and application of optimizations to remove them. <p> Our optimized implementation of TAO is now competitive with existing commercial ORBs <ref> [9, 11] </ref> using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) [10].
Reference: [10] <author> A. Gokhale and D. C. Schmidt, </author> <title> The Performance of the CORBA Dynamic Invocation Interface and Dynamic Skeleton Interface over High-Speed ATM Networks, </title> <booktitle> in Proceedings of GLOBECOM '96, </booktitle> <address> (London, England), </address> <pages> pp. 5056, </pages> <publisher> IEEE, </publisher> <month> November </month> <year> 1996. </year>
Reference-contexts: For primitive types, the skeleton sizes were comparable. However, the interpreted stubs were roughly 40% of the compiled stubs. 1 See ftp://ftp.omg.org/pub/interop/ for the SunSoft IIOP source code. The optimized version of TAO is now comparable to existing commercial ORBs <ref> [9, 10, 11] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). 1.3 Paper Organization This paper is organized as follows: Section 2 outlines the CORBA reference model, the GIOP/IIOP interoperability protocols, SunSoft <p> Our optimized implementation of TAO is now competitive with existing commercial ORBs [9, 11] using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) <ref> [10] </ref>. The results of our optimizations provide sufficient proof that performance of complex, performance-sensitive distributed software can be improved by a systematic application of principle-driven optimizations. This paper also compares the performance and code size of stubs and skeletons using interpretive and compiled form of marshaling.
Reference: [11] <author> A. Gokhale and D. C. Schmidt, </author> <title> Evaluating Latency and Scalability of CORBA Over High-Speed ATM Networks, </title> <booktitle> in Proceedings of the International Conference on Distributed Computing Systems, </booktitle> <address> (Baltimore, Maryland), </address> <publisher> IEEE, </publisher> <month> May </month> <year> 1997. </year>
Reference-contexts: For primitive types, the skeleton sizes were comparable. However, the interpreted stubs were roughly 40% of the compiled stubs. 1 See ftp://ftp.omg.org/pub/interop/ for the SunSoft IIOP source code. The optimized version of TAO is now comparable to existing commercial ORBs <ref> [9, 10, 11] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). 1.3 Paper Organization This paper is organized as follows: Section 2 outlines the CORBA reference model, the GIOP/IIOP interoperability protocols, SunSoft <p> Our optimized implementation of TAO is now competitive with existing commercial ORBs <ref> [9, 11] </ref> using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) [10].
Reference: [12] <author> E. Eide, K. Frei, B. Ford, J. Lepreau, and G. Lindstrom, </author> <month> Flick: </month>
Reference-contexts: Conversely, skeletons demarshal the packet-level representation back into typed data that is meaningful to an application. An IDL compiler automatically transforms OMG IDL definitions into an application programming language like C++ or Java. IDL compilers eliminate common sources of network programming errors and provide opportunities for automated compiler optimizations <ref> [12] </ref>. Dynamic Invocation Interface (DII): The DII allows a client to access the underlying request transport mechanisms provided by the ORB Core. The DII is useful when an application has no compile-time knowledge of the interface it is accessing. <p> For instance, a sequence of Anys or structs with string fields may have elements with variable sizes. In such cases, this optimization will not apply. For the BinStruct case described in this paper, however, a highly optimizing IDL compiler, such as Flick <ref> [12] </ref> could determine that all sequence elements have identical sizes. It could then generate stub and skeleton code that can eliminate gratuitous waste. <p> As explained in Section 6, we are currently implementing a CORBA IDL compiler [35] that can generate compiled stubs and skeletons. Our goal is to generate efficient stubs and skeletons by extending optimizations provided in USC [36] and Flick <ref> [12] </ref>, which is a flexible, optimizing IDL compiler. Flick uses an innovative scheme where intermediate representations guide the generation of optimized stubs.
References-found: 12

