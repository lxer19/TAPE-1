URL: http://www.cs.jhu.edu/techreps/1998/1998.03.ps
Refering-URL: http://www.cs.jhu.edu/techreps/1998/index.html
Root-URL: http://www.cs.jhu.edu
Email: Email: hongxia@cs.jhu.edu, sullivan@cs.jhu.edu, masson @cs.jhu.edu  
Phone: Phone: (410)-516-8710 Fax: (410)-516-6134  
Title: Certifying Computationally Intensive Tasks Branch-and-Bound Exemplars  
Author: Hongxia Jin Gregory F. Sullivan Gerald M. Masson 
Address: Baltimore, MD 21218  
Affiliation: Computer Science Dept., Johns Hopkins Univ.,  
Abstract: Computationally intensive problems provide a major motivation for developing techniques for certifying answers. The execution of intensive computations can suffer from faults in hardware and errors in software which remain dormant during less intensive computations. We have conducted an investigation of problems which are amenable to the powerful and widely used `branch-and-bound' strategy. This strategy can be used to solve difficult problems such as, the classic Traveling Salesman problem, the Single Knapsack problem, and the Multiple Knapsack problem. We present efficient methods for certifying answers which can be used to substantially raise the confidence in the correctness of results generated by several branch-and-bound exemplar programs. Specifically, we discuss three programs which solve the three problems mentioned above and we indicate how certification trails can productively be applied to help assure the correctness of the program results. When certification trails are used one must create a first, primary computation, and a second, certifier computation. The primary computation generates a certification trail and a supposed answer, and the certifier computation uses this information to certify the correctness of the supposed answer. Several goals are pursued when the certification trail method is applied. First, the primary should not be substantially slower than the original computation which does not generate a certification trail. Second, the primary should not be substantially more complex than the original computation. Third, the certifier computation should be substantially faster and/or simpler than the primary. Our work indicates that very often these goals can be achieved. fl This research was supported by NSF grant CCR-9319945
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anderson, T., and Lee, P., </author> <title> Fault Tolerance: Principle and Practices, </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, NJ, </address> <year> 1981. </year>
Reference: [2] <author> Avizienis, A., and Kelly, J., </author> <title> "Fault tolerance by design diversity: concepts and experiments," </title> <journal> Computer, </journal> <volume> vol. 17, </volume> <pages> pp. 67-80, </pages> <month> Aug., </month> <year> 1984. </year>
Reference: [3] <author> Avizienis, A., </author> <title> "The N-version approach to fault tolerant software," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 11, </volume> <pages> pp. 1491-1501, </pages> <month> Dec., </month> <year> 1985 </year>
Reference: [4] <author> Blum, M., and Kannan, S., </author> <title> "Designing programs that check their work", </title> <booktitle> Proceedings of the 1989 ACM Symposium on Theory of Computing, </booktitle> <pages> pp. 86-97, </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference: [5] <author> Blum, M., and Wasserman, H., </author> <title> "Reflections on the Pentium Division Bug", </title> <journal> IEEE Trans. on Computers, pp. </journal> <volume> 385-393, vol. 45, </volume> <month> April, </month> <year> 1996. </year>
Reference: [6] <author> Chen, L., and Avizienis A., </author> <title> "N-version programming: a fault tolerant approach to reliability of software operation," </title> <booktitle> Digest of the 1978 Fault Tolerant Computing Symposium, </booktitle> <address> pp.3-9, </address> <publisher> IEEE Computer Society Press, </publisher> <year> 1978 </year>
Reference: [7] <author> Craig, R., </author> <title> Personal communication. A C code implementation of a Traveling Salesman Problem algorithm based on a Pascal implementation described in the textbook "Discrete 19 Optimization Algorithms: with Pascal Programs", by Syslo, </title> <editor> M., Deo, N., and Kowalik, J.S., </editor> <publisher> Prentice-Hall, </publisher> <year> 1983. </year>
Reference: [8] <author> Garey, M. R., and Johnson, D. S., </author> <title> Computers and Intractability W. </title> <editor> H. </editor> <publisher> Freeman and Company, </publisher> <address> San Francisco, CA, </address> <year> 1979. </year>
Reference-contexts: Problems whose solutions involve the exploration of a massive search space are often compu-tationally intensive. In this paper, we will discuss programs which solve the Traveling Salesman problem [17][7], the Single Knapsack problem [12], and the Multiple Knapsack problem [18]. These problems are each NP-hard <ref> [8] </ref> and the programs which solve them each use a branch-and-bound strategy to efficiently investigate a large search space and to find an optimal solution. We shall discuss general ideas for certifying the correctness of program results generated by branch-and-bound programs.
Reference: [9] <author> Huang, K.-H., and Abraham, J., </author> <title> "Algorithm-based fault tolerance for matrix operations," </title> <journal> IEEE Trans. on Computers, pp. </journal> <volume> 518-529, vol. C-33, </volume> <month> June, </month> <year> 1984. </year>
Reference: [10] <author> Lee, Y. H. and Shin, K. G., </author> <title> "Design and evaluation of a fault-tolerant multiprocessor using hardware recovery blocks," </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-33, </volume> <pages> pp. 113-124, </pages> <month> Feb. </month> <year> 1984. </year>
Reference: [11] <author> Papadimitriou, C. H. and Steiglitz, K., </author> <title> "Some Complexity Results for the Traveling Salesman Problem", </title> <booktitle> Proceedings of the Eighth ACM Symposium on Theory of Computing, </booktitle> <pages> pp. 1-9, </pages> <publisher> ACM Press, </publisher> <year> 1976. </year>
Reference-contexts: We believe this is a valuable technique worthy of consideration. Another useful possibility is to design and implement an acceptance test [13] or a checker [4][5]. Intriguingly, it has been shown that the problem of checking whether a given tour is an optimal TSP tour is NP-hard <ref> [11] </ref>. Thus, a checker for the TSP problem would likely require exponential time in the worst case. This is not, however, a fatal criticism since TSP itself apparently requires exponential time to solve in the worst case.
Reference: [12] <author> Rifkin, Adam, </author> <title> 0-1 Knapsack Algorithm Solution Example branch-and-bound program used in course Computer Science 138a California Institute of Technology, </title> <note> 1994, http://csvax.cs.caltech.edu/%7Ecs138/138a/examples/knapsack/. </note>
Reference-contexts: Problems whose solutions involve the exploration of a massive search space are often compu-tationally intensive. In this paper, we will discuss programs which solve the Traveling Salesman problem [17][7], the Single Knapsack problem <ref> [12] </ref>, and the Multiple Knapsack problem [18]. These problems are each NP-hard [8] and the programs which solve them each use a branch-and-bound strategy to efficiently investigate a large search space and to find an optimal solution. <p> A branch-and-bound strategy can be used to solve this problem. The original code we based our experiment on was written for a class at the California Institute of Technology <ref> [12] </ref>. The splitting operation takes a subproblem and splits it into exactly two subproblems. In one sub-problem, a chosen element must be in the knapsack, and in the other subproblem the chosen element must not be in the knapsack. The bounding operation is based on an upper-bound calculation.
Reference: [13] <author> Randell, B., </author> <title> "System structure for software fault tolerance," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 1, </volume> <pages> pp. 220-232, </pages> <month> June, </month> <year> 1975. </year>
Reference-contexts: 1 Introduction A variety of techniques have been developed to help detect, and in some cases correct, errors and faults which are manifested during the execution of computer software, e.g., N-version programming [6][2][3], recovery blocks <ref> [13] </ref>, algorithm-based techniques [9][14], checkers [4][5], and certification trails [15][16]. The need for such techniques is particularly acute when com-putationally intensive tasks are performed. Such tasks often thoroughly exercise hardware and software modules, and thus are more likely to produce novel and unanticipated difficulties during execution. <p> We believe this is a valuable technique worthy of consideration. Another useful possibility is to design and implement an acceptance test <ref> [13] </ref> or a checker [4][5]. Intriguingly, it has been shown that the problem of checking whether a given tour is an optimal TSP tour is NP-hard [11]. Thus, a checker for the TSP problem would likely require exponential time in the worst case.
Reference: [14] <author> Roy-Chowdhury, A., and Banerjee, P., </author> <title> "Algorithm-based fault location and recovery for matrix computations on multiprocessor systems," </title> <journal> IEEE Trans. on Computers, pp. </journal> <volume> 1239-1247, vol. 45, </volume> <month> November, </month> <year> 1996. </year>
Reference: [15] <author> Sullivan, G. F., Wilson, D., and Masson, G. M., </author> <title> "Certification of Computational Results", </title> <journal> IEEE Trans. on Computers, pp. </journal> <volume> 833-847, Vol. 44, </volume> <year> 1995. </year>
Reference-contexts: We will not recapitulate a complete discourse on the advantages and disadvantages of this approach, but instead we refer the reader to <ref> [15] </ref> and [16][19]. The main idea behind certification trails is straightforward, yet there are subtleties to their proper definition and use. The idea is to modify the original program to yield a new program called a primary program.
Reference: [16] <author> Sullivan, </author> <title> G.F., and Masson, G.M., "Certification Trails for Data Structures," </title> <booktitle> Digest of the 1991 Fault Tolerant Computing Symposium, </booktitle> <pages> pp. 240-247, </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference: [17] <author> Syslo, M., Deo, N., and Kowalik, J. S., </author> <title> Discrete Optimization Algorithms: with Pascal Programs Prentice-Hall, </title> <address> Englewood Cliffs, NJ, </address> <year> 1983. </year>
Reference: [18] <author> Martello, S., Toth, P., </author> <title> Algorithm 632: "A Program for the 0-1 Multiple Knapsack Problem", </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> Vol 11, No. 2, </volume> <pages> pp 135-140, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: Problems whose solutions involve the exploration of a massive search space are often compu-tationally intensive. In this paper, we will discuss programs which solve the Traveling Salesman problem [17][7], the Single Knapsack problem [12], and the Multiple Knapsack problem <ref> [18] </ref>. These problems are each NP-hard [8] and the programs which solve them each use a branch-and-bound strategy to efficiently investigate a large search space and to find an optimal solution. We shall discuss general ideas for certifying the correctness of program results generated by branch-and-bound programs. <p> Although the certifier must traverse the tree generated by the primary, it does not have to perform the computations necessary to determine the original structure of the tree. The difficulty of determining this structure is well illustrated by the algorithm which solves the Multiple Knapsack problem given in <ref> [18] </ref>. This algorithm computes the solution of a Single Knapsack problem at each search node to determine what its child nodes should be. Recall, the Single Knapsack problem itself is NP-hard. Thus determining the structure of the search tree is rather expensive compared t o simply traversing the tree. 2. <p> The branch-and-bound algorithm that we tested appears in <ref> [18] </ref>. The splitting operation takes a subproblem and yields exactly two subproblems. A knapsack j and item i are chosen, and in one subproblem j must be in knapsack i and in the other subproblem j must not be in knapsack i. <p> TABLE III Size Basic Algorithm Primary Exec Certifier Exec Speedup Percent (Also Generates Trail) (Uses Trail) Savings 25,2 3.1562 3.1877 1.4751 2.134 26.13 15,4 0.2734 0.2742 0.0302 9.053 44.33 Table III contains our results for the Multiple Knapsack Problem. A probability distribution from <ref> [18] </ref> was used to generate inputs. Specifically, test inputs were obtained by independently randomly generating the values w j and p j from a uniform distribution [10,100].
Reference: [19] <author> Wilson, D., Sullivan, G. F., and Masson, G., </author> <title> "Certification Trails and Software Design for Testability", </title> <booktitle> Proceedings of the 1993 International Test Conference, </booktitle> <pages> pp. 200-209, </pages> <publisher> International Test Conference IEEE Computer Society Press, </publisher> <month> October </month> <year> 1993. </year> <month> 20 </month>
References-found: 19

