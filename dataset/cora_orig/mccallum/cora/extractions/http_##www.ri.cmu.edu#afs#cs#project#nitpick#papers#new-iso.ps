URL: http://www.ri.cmu.edu/afs/cs/project/nitpick/papers/new-iso.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/project/nitpick/www/new-iso.html
Root-URL: 
Title: Isomorph-free Model Enumeration: A New Method for Checking Relational Specifications So as fast as you
Author: Daniel Jackson, Somesh Jha and Craig A. Damon 
Degree: Dr. Seuss (1957)  
Note: Submitted for publication  
Date: December 10, 1996  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract-found: 0
Intro-found: 1
Reference: [B+95] <author> S. Bensalem, A. Bouajjani, C. Loiseaux and J. Sifakis. </author> <title> P roperty pre - serving simulations. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> Volume 6, No. 1, </volume> <month> January </month> <year> 1995. </year>
Reference-contexts: An infi nite space of interpretations is reduced to a fi nite space in such a way that establishing a property on the fi nite space suffices. This approach is well developed in the context of model checking <ref> [CGL92, B+95, DGR96] </ref>. In our previous work, we have shown how similar ideas can be applied to relational specifications [Jac94], but it seems that, in practice, it is often hard (or impossible) to fi nd appropriate abstractions.
Reference: [BG94] <author> J. Bowen and M.J.C. Gordon. </author> <title> Z and HOL. Z User W orkshop, </title> <address> Cambridge, England, </address> <year> 1994, </year> <booktitle> Springer -Verlag W orkshops in Computing, </booktitle> <pages> pp. 141167. </pages>
Reference-contexts: Recently, with the development of theorem provers such as PVS [OR+95] that incorporate powerful decision procedures, the analysis of realistic designs has become possible. A number of theorem provers have been developed specifically for Z [Jon92, SM96] or have been applied to it <ref> [BG94, ES94] </ref>; there are also specialized theorem provers for the relational calculus [BH94]. The labour cost of interactive theorem proving is still high enough, however , to rule out its use in everyday software development.
Reference: [BH94] <institution> Rudolf Berghammer and Claudia Hattensperger . Computer-Aided Manipulation of R elational Expr essions and F ormulae Using RALF . Technical Report, Institut fur Informatik und Praktische Mathematik, Christian-Albrechts Universitat Zu Kiel, Kiel, Germany, </institution> <year> 1994. </year>
Reference-contexts: A number of theorem provers have been developed specifically for Z [Jon92, SM96] or have been applied to it [BG94, ES94]; there are also specialized theorem provers for the relational calculus <ref> [BH94] </ref>. The labour cost of interactive theorem proving is still high enough, however , to rule out its use in everyday software development. For safety critical systems or com 34 ponents, on the other hand, especially those involving subtle distributed algorithms, the cost appears to be justified.
Reference: [BJR96] <author> Grady Booch, Ivar Jacobson, James Rumbaugh. </author> <title> The Unified Modelling Language for ObjectOriented Development. Documentation set, ver 37 sion 0.9, Rational Software Corporation, </title> <address> Santa Clare, CA (http://www.rational.com). </address>
Reference-contexts: seems quite natural to most people, which per haps explains the popularity both of Z, a specifi cation language in which relations play a primary role [Spi92, WD96], andin more com - mercial circlesof entity relationship diagrams, originally intended for database design [Che76] but now widely adopted in objectoriented methods <ref> [SM88, R+91, BJR96] </ref>. Writing a relational description of a software system, or some aspect of it, can be worthwhile in itself. Indeed, reports on the application of formal methods invariably note that many errors are found in the act of specification itself, even if no tools are used.
Reference: [Bry92] <author> R. E. Bryant. </author> <title> Symbolic Boolean Manipulation with Ordered Binary Decision Diagrams. </title> <journal> ACM Computing Sur veys, </journal> <volume> vol. 24, no. 3, </volume> <pages> pp. 293318, </pages> <year> 1992. </year>
Reference-contexts: We have experimented [DJJ96] with a version of Nitpick based on Bryants ordered binary decision diagrams (BBDs) <ref> [Bry92] </ref>. Very large boolean formulae can often be represented with small BDDs. Using iterative squaring, closures can be computed reasonably effi ciently.
Reference: [BS92] <editor> Belaid Benhamou and Lakhdar Sais. </editor> <title> Theoretical study of symmetries in propositional calculus and applications. </title> <booktitle> Automated Deduction (CADE-11): Proc. 11th Inter national Confer ence on A utomated Deduction, </booktitle> <address> Saratoga Springs, NY , June 1992. </address> <booktitle> Lecture Notes in Artificial Intelligence, </booktitle> <volume> Vol. 607, </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: F or hard cases, local search tech - niques work surprisingly well [SLM92]. Symmetries involving permutation of boolean variables have been exploited in the analysis of first-order formulae <ref> [BS92, Cra92] </ref>. But as far as we know, ours is the 35 only method to use symmetry in the assignable values themselves. The FINDER tool [Sla94] uses backtracking search to find models of a logic with functions and equality.
Reference: [C+96] <author> E.M. Clarke, R. Enders, T. Filkorn and S. Jha. </author> <title> Exploiting symmetry in temporal logic model checking. </title> <booktitle> in [FMSD96]. </booktitle>
Reference-contexts: A recent journal issue on the topic of symme - try in automatic verifi cation [FMSD96] includes expanded versions of these papers <ref> [C+96, ES96, ID96] </ref> and others. These methods exploit different subsets of the automorphisms of the transition relation. Ip and Dills method [ID96] uses a special construct in the specification language, called a scalarset, to represent an uninterpreted type. <p> During exploration of the state space, the checker not only avoids visiting states that have been previously visited, but also avoids those in the same orbit as that is, equivalent under symmetry to a visited state. The methods of Clarke, Enders, F ilkhorn and Jha <ref> [C+96] </ref>, and of Emerson and Sistla [ES96], accommodate a more general class of automorphism groups, but require the user to specify the group. Moreover, these methods can, to some degree, take advantage of the structure of the property being checked.
Reference: [CFJ93] <author> E.M. Clarke, T. Filkorn and S. Jha. </author> <title> Exploiting symmetry in temporal logic model checking. </title> <booktitle> Fifth Inter national Confer ence on Computer - Aided Verification, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Symmetry in Model Checking Symmetry in the transition relation of a state machine has been exploited in check - ing methods for Petri nets [Sta91], for reachability analysis [ID93], and for temporal logic model checking <ref> [CFJ93, ES93] </ref>. A recent journal issue on the topic of symme - try in automatic verifi cation [FMSD96] includes expanded versions of these papers [C+96, ES96, ID96] and others. These methods exploit different subsets of the automorphisms of the transition relation. <p> The problem can be shown to be harder than graph iso--morphism [Jha96], and in practice an appro ximation is used that sometimes distin - guishes states in the same orbit (but never equates states in distinct orbits). Although our method was inspired by <ref> [CFJ93] </ref>, it actually has little in common with it or [ID93].
Reference: [CGL92] <author> E.M. Clarke, O . Grumberg and D.E. </author> <title> Long. Model Checking and Abstraction. </title> <booktitle> Proc. ACM Symposium of Principles of Programming Languages, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: An infi nite space of interpretations is reduced to a fi nite space in such a way that establishing a property on the fi nite space suffices. This approach is well developed in the context of model checking <ref> [CGL92, B+95, DGR96] </ref>. In our previous work, we have shown how similar ideas can be applied to relational specifications [Jac94], but it seems that, in practice, it is often hard (or impossible) to fi nd appropriate abstractions.
Reference: [Che76] <author> Peter Chen. </author> <title> The entity relationship modeltoward a unifi ed view of data. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> vol. 1, no. 1, </volume> <pages> pp. 9-36, </pages> <year> 1976. </year>
Reference-contexts: Relational modelling, moreover, seems quite natural to most people, which per haps explains the popularity both of Z, a specifi cation language in which relations play a primary role [Spi92, WD96], andin more com - mercial circlesof entity relationship diagrams, originally intended for database design <ref> [Che76] </ref> but now widely adopted in objectoriented methods [SM88, R+91, BJR96]. Writing a relational description of a software system, or some aspect of it, can be worthwhile in itself.
Reference: [Cra92] <author> James Crawford. </author> <title> A theoretical analysis of reasoning by symmetry in first-order logic (extended abstract). </title> <booktitle> AAAI-92 Workshop on Tractable Reasoning, </booktitle> <year> 1992, </year> <pages> pp. 1722. </pages>
Reference-contexts: F or hard cases, local search tech - niques work surprisingly well [SLM92]. Symmetries involving permutation of boolean variables have been exploited in the analysis of first-order formulae <ref> [BS92, Cra92] </ref>. But as far as we know, ours is the 35 only method to use symmetry in the assignable values themselves. The FINDER tool [Sla94] uses backtracking search to find models of a logic with functions and equality.
Reference: [DGR96] <author> D. Dams, O . Grumberg and R . Gerth. </author> <title> Abstract Interpretation of Reactive Systems. </title> <journal> ACM Transactions on Programming L anguages and Systems, </journal> <note> to appear. </note>
Reference-contexts: An infi nite space of interpretations is reduced to a fi nite space in such a way that establishing a property on the fi nite space suffices. This approach is well developed in the context of model checking <ref> [CGL92, B+95, DGR96] </ref>. In our previous work, we have shown how similar ideas can be applied to relational specifications [Jac94], but it seems that, in practice, it is often hard (or impossible) to fi nd appropriate abstractions.
Reference: [DJ96] <author> Craig A. Damon and Daniel Jackson. </author> <title> Effi cient Search as a Means of Executing Specifi cations. </title> <booktitle> Proc. Second Inter national W orkshop on Tools and Algorithms for the Constr uction and Analysis of Systems (TACAS 96), </booktitle> <address> Passau, Germany, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: This short circuiting prunes the interpretation tree further, often by a factor even greater than that achieved by the isomorph elimination method <ref> [DJ96] </ref>. Sections 6 and 7 explain the two observations underlying the method. Section 8 justifies the incremental approach, and Section 9 explains the colouring scheme used to express the symmetries. Section 10 presents a refi nement of the method. <p> The first phase of the analysis is static: 1. The formula is checked for syntax and type errors. 2. An appropriate variable ordering is selected; currently we use an ordering heuristic designed for short-circuiting <ref> [DJ96] </ref>. 3. The most general typing is computed by type inference. <p> Term symmetry can only be effective with a good variable ordering. The smaller the set of relevant variables, the coarser the colouring equivalence. A simple but effective ordering attempts to close as many terms as possible at a given stage. Fortunately, the ordering selected for short-circuiting <ref> [DJ96] </ref> also appears to be reasonable. The refined enumerate function, enumerateR, is shown in Figure 9. <p> We have experimented with a variety of more realistic specifi cations. For these, isomorph elimination alone is rarely sufficient to make checking tractable. With the addition of short circuiting <ref> [DJ96] </ref>, however, we have been able to enumerate interpretations across a tree with 10 20 leaves, obtaining reductions of 15 orders of mag - nitude. Isomorph elimination regularly contributes 6 orders of magnitude, and sometimes more. <p> The Nitpick tool uses an ordering heuristic designed to maximize the reduction by short circuiting <ref> [DJ96] </ref>, which seems to be reasonable for isomorph elimination too. W e do not know whether there is a better ordering that overall will give better reductions overall. Second is the question of representing automorphisms. <p> Nitpicks derived variable analysis [JD95] ensures that when a variable of the poststate of an operation is defined constructively, no search is actually performed; the equation is essentially converted into an assignment statement. Consequently , Nitpick will execute specifications as fast as any simulation tool. And due to short-circuiting <ref> [DJ96] </ref> and isomorph elimination, it can focus on executions that are likely to expose errors. The equivalence classes into which our method partitions the formulas interpretations are revealing subdomains in the jargon of testing theory [WO80].
Reference: [DJJ96] <author> Craig A. Damon, Daniel Jackson and Somesh Jha. </author> <title> Checking Relational Specifi cations with Binary Decision Diagrams. </title> <booktitle> Proc. 4th ACM SIGSOF T Conf. on F oundations of Softwar e Engineering , San Francisco, </booktitle> <address> CA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: We have experimented <ref> [DJJ96] </ref> with a version of Nitpick based on Bryants ordered binary decision diagrams (BBDs) [Bry92]. Very large boolean formulae can often be represented with small BDDs. Using iterative squaring, closures can be computed reasonably effi ciently.
Reference: [DKC89] <author> A.J.J. Dick, P.J. Krause and J. Cozens. </author> <title> Computer-aided transformation of Z into P rolog. Z User W orkshop, </title> <publisher> Oxford, </publisher> <year> 1989, </year> <title> J.E. Nicholls, </title> <booktitle> ed.,Workshops in Computing, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1990, </year> <pages> pp. 7185. </pages>
Reference: [ES93] <author> E. Allen Emerson and A. P rasad Sistla. </author> <title> Symmetry and Model Checking. </title> <booktitle> Fifth Inter national Confer ence on Computer Aided Verification, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Symmetry in Model Checking Symmetry in the transition relation of a state machine has been exploited in check - ing methods for Petri nets [Sta91], for reachability analysis [ID93], and for temporal logic model checking <ref> [CFJ93, ES93] </ref>. A recent journal issue on the topic of symme - try in automatic verifi cation [FMSD96] includes expanded versions of these papers [C+96, ES96, ID96] and others. These methods exploit different subsets of the automorphisms of the transition relation.
Reference: [ES94] <author> Marcin Engel and Jens Ulrik Skakkebaek. </author> <title> Applying PVS to Z . 38 Technical R eport ID/DTU ME 3/1, P roCos P roject, </title> <institution> Department of Computer Science, T echnical University of Denmark, L yngby, Denmark. </institution>
Reference-contexts: Recently, with the development of theorem provers such as PVS [OR+95] that incorporate powerful decision procedures, the analysis of realistic designs has become possible. A number of theorem provers have been developed specifically for Z [Jon92, SM96] or have been applied to it <ref> [BG94, ES94] </ref>; there are also specialized theorem provers for the relational calculus [BH94]. The labour cost of interactive theorem proving is still high enough, however , to rule out its use in everyday software development.
Reference: [ES96] <author> E. Allen Emerson and A. Prasad Sistla. </author> <title> Symmetry and model checking. </title> <booktitle> in [FMSD96]. </booktitle>
Reference-contexts: A recent journal issue on the topic of symme - try in automatic verifi cation [FMSD96] includes expanded versions of these papers <ref> [C+96, ES96, ID96] </ref> and others. These methods exploit different subsets of the automorphisms of the transition relation. Ip and Dills method [ID96] uses a special construct in the specification language, called a scalarset, to represent an uninterpreted type. <p> The methods of Clarke, Enders, F ilkhorn and Jha [C+96], and of Emerson and Sistla <ref> [ES96] </ref>, accommodate a more general class of automorphism groups, but require the user to specify the group. Moreover, these methods can, to some degree, take advantage of the structure of the property being checked.
Reference: [FMSD96] <editor> Formal Methods in System Design, </editor> <title> V olume 9, Numbers 1/2, </title> <publisher> Kluwer Academic Publishers, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: A recent journal issue on the topic of symme - try in automatic verifi cation <ref> [FMSD96] </ref> includes expanded versions of these papers [C+96, ES96, ID96] and others. These methods exploit different subsets of the automorphisms of the transition relation. Ip and Dills method [ID96] uses a special construct in the specification language, called a scalarset, to represent an uninterpreted type.
Reference: [Giv88] <author> Steven Givant. </author> <title> Tarskis development of logic and mathematics based on the calculus of relations. Colloquia Mathematica Societatis Janos Bolyai 54, Algebraic Logic, </title> <address> Budapest, Hungary, </address> <year> 1988. </year>
Reference-contexts: Moreover , it can be shown that if an operator can be defined in terms of first-order predicate calculus, it must be logical; and if not, it seems unlikely that it could be included in a practical specification language anyway. (The notion of logicality is due to T arski <ref> [Tar41, Giv88] </ref>. His calculus is less expressive than fi rst-order logic; it can be shown that although any fi rst-order formula with at most three variables can be expressed, there are trivial formulae with four variables that are not expressible.
Reference: [ID93] <author> C. Ip and D. Dill. </author> <title> Better verifi cation through symmetry . Proc. </title> <booktitle> 11th International Symposium on Computer Har dware Description Languages and their Applications, </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: Symmetry in Model Checking Symmetry in the transition relation of a state machine has been exploited in check - ing methods for Petri nets [Sta91], for reachability analysis <ref> [ID93] </ref>, and for temporal logic model checking [CFJ93, ES93]. A recent journal issue on the topic of symme - try in automatic verifi cation [FMSD96] includes expanded versions of these papers [C+96, ES96, ID96] and others. These methods exploit different subsets of the automorphisms of the transition relation. <p> Although our method was inspired by [CFJ93], it actually has little in common with it or <ref> [ID93] </ref>. These methods are concerned with the equivalence of two states induced by the symmetries of the transition relation to which they belong; ours is concerned with the equivalence of two interpretations, and exploits symmetry dur - ing the construction of an interpretation. <p> Our types, derived from the given types of Z [Spi92], are all uninterpreted, and are thus scalarsets in the jargon of <ref> [ID93] </ref>. Our method requires no orbit test; the only isomorph checking that occurs is limited to the internals of the graph generation subroutine.
Reference: [ID96] <author> C. Norris Ip and David L. Dill. </author> <title> Better verifi cation through symmetry. </title> <booktitle> in [FMSD96]. </booktitle>
Reference-contexts: A recent journal issue on the topic of symme - try in automatic verifi cation [FMSD96] includes expanded versions of these papers <ref> [C+96, ES96, ID96] </ref> and others. These methods exploit different subsets of the automorphisms of the transition relation. Ip and Dills method [ID96] uses a special construct in the specification language, called a scalarset, to represent an uninterpreted type. <p> A recent journal issue on the topic of symme - try in automatic verifi cation [FMSD96] includes expanded versions of these papers [C+96, ES96, ID96] and others. These methods exploit different subsets of the automorphisms of the transition relation. Ip and Dills method <ref> [ID96] </ref> uses a special construct in the specification language, called a scalarset, to represent an uninterpreted type. A specification involving an array of processors, for example, might declare the process identifiers used to index the array as belonging to such a scalarset.
Reference: [Jac94] <author> Daniel Jackson. </author> <title> Abstract model checking of infi nite specifi cations. </title> <booktitle> Proc. Formal Methods Europe , Barcelona, </booktitle> <address> Spain, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: This approach is well developed in the context of model checking [CGL92, B+95, DGR96]. In our previous work, we have shown how similar ideas can be applied to relational specifications <ref> [Jac94] </ref>, but it seems that, in practice, it is often hard (or impossible) to fi nd appropriate abstractions. Simulators Existing simulation tools require the specification to be constructive; suitable subsets of Z [V al91] and VDM [LL91] have been defi ned.
Reference: [Jac96] <author> Daniel Jackson. Nitpick: </author> <title> A Checkable Specifi cation Language. Proc.Workshop on F ormal Methods in Softwar e Practice , San Diego, </title> <address> CA, </address> <month> January </month> <year> 1996. </year>
Reference: [JD95] <author> Daniel Jackson and Craig A. Damon. </author> <title> Semi-Executable Specifications. </title> <institution> Technical R eport CMU-C S-95-216, School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Closer to our approach, there have been attempts to analyze Z specifi cations with a P rolog interpreter [DK C89, WE92], but these do not appear to be practical yet. Nitpicks derived variable analysis <ref> [JD95] </ref> ensures that when a variable of the poststate of an operation is defined constructively, no search is actually performed; the equation is essentially converted into an assignment statement. Consequently , Nitpick will execute specifications as fast as any simulation tool.
Reference: [JD96a] <author> Daniel Jackson and Craig A. Damon. Nitpick: </author> <title> A Checker for Software Specifications (R eference Manual). </title> <institution> Technical R eport CMU-C S-96-109, School of Computer Science, Carnegie Mellon University , Pittsburgh, </institution> <address> PA, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: But for more routine work, checking is more appropriate: most specifi cations are awed, especially early on, and the best service a tool can offer is rapid detection of errors. 2 Nitpick/NP Nitpick is a tool for analyzing relational specifi cations written in NP <ref> [JD96a] </ref>, a notation based on the relational calculus [T ar41, S S93], and roughly a subset of Z [Spi92]. Nitpick provides fully automatic simulation and checking within fi nite bounds.
Reference: [JD96b] <author> Daniel Jackson and Craig A. Damon. </author> <title> Elements of Style: Analyzing a Software Design F eature with a Counterexample Detector . IEEE Transactions on Softwar e Engineering, </title> <journal> July 1996, </journal> <volume> Vol. 22, No. 7, </volume> <pages> pp. 484495. </pages>
Reference-contexts: Although this example is clearly a toy, a realistic specifi cation of telephone switching can be constructed in a similar style [MZ94]. A more interesting application of Nitpick is described in <ref> [JD96b] </ref>. The first line declares a type Phone representing an abstract set of telephones. The system state is declared in the schema Switch; it consists of a single relation variable conns whose interpretation is that (p, q) @ conns when a call from p to q is active.
Reference: [Jha96] <author> Somesh Jha. </author> <title> Symmetry and induction in model checking. </title> <type> Doctoral thesis, </type> <institution> School of Computer Science, Carnegie Mellon University , Pittsburgh, </institution> <address> PA, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: All of these methods involve, explicitly or implicitly , an orbit test: given two states, one must determine whether they fall into the same orbit and can thus be 36 treated as indistinguishable. The problem can be shown to be harder than graph iso--morphism <ref> [Jha96] </ref>, and in practice an appro ximation is used that sometimes distin - guishes states in the same orbit (but never equates states in distinct orbits). Although our method was inspired by [CFJ93], it actually has little in common with it or [ID93].
Reference: [JJD96] <author> Daniel Jackson, Somesh Jha and Craig A. Damon. </author> <title> Faster Checking of Software Specifications by Eliminating Isomorphs. </title> <booktitle> Proc. ACM Symp. on Principles of Programming L anguages, </booktitle> <address> St. P etersburg Beach, FL, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Skipping non-models speeds up the search for models; this is the primary motivation. Skipping models is good for simulation, because it means that the user is not bar - raged with cases that are uninteresting relabellings of cases already seen. Like our previous isomorph elimination method <ref> [JJD96] </ref>, the method exploits the structure of the formula being checked as well as the structure of the enumerated relation values. <p> In model checking, for example, a factor of 10 or 100 is typical, while we often see reductions of 10 5 or more. An earlier version of our isomorph elimination method is described in <ref> [JJD96] </ref>. To avoid the generation of graphs under arbitrary colourings, it introduced explicit bijections called wirings between the sides of one relation and another . This allowed us to generate an entire isomorph-free set of relations just once, and then vary the bijections according to the colouring context.
Reference: [Jon92] <author> R.B. Jones. </author> <title> ICL ProofPower. </title> <journal> British Computer Society Formal Aspects of Computer Science, </journal> <volume> Series 3, 1(1), </volume> <year> 1992, </year> <pages> pp. 1013. </pages>
Reference-contexts: R esearch efforts have therefore focused mainly on syntactic analyses. Recently, with the development of theorem provers such as PVS [OR+95] that incorporate powerful decision procedures, the analysis of realistic designs has become possible. A number of theorem provers have been developed specifically for Z <ref> [Jon92, SM96] </ref> or have been applied to it [BG94, ES94]; there are also specialized theorem provers for the relational calculus [BH94]. The labour cost of interactive theorem proving is still high enough, however , to rule out its use in everyday software development.
Reference: [LL91] <author> Peter Gorm Larsen and P oul Bogh Lassen. </author> <title> An ex ecutable subset of Meta-IV with loose specifi cation. </title> <editor> In S. P rehn, W.J. Toetenel (eds.), </editor> <title> 39 VDM91: F ormal Softwar e Development Methods , V ol. </title> <booktitle> 1, Lecture Notes in Computer Science 551, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Simulators Existing simulation tools require the specification to be constructive; suitable subsets of Z [V al91] and VDM <ref> [LL91] </ref> have been defi ned. Closer to our approach, there have been attempts to analyze Z specifi cations with a P rolog interpreter [DK C89, WE92], but these do not appear to be practical yet.
Reference: [McK81] <author> Brendan D. </author> <title> McKay . P ractical graph isomorphism. </title> <booktitle> Congressus Numerantium 21 (1981), </booktitle> <pages> pp. 499517. </pages>
Reference-contexts: Our current implementation of the iterator (described in Section 11) is not minimal: it overgenerates by about 10%, thus in ating the size of the search. In our previous version of Nitpick, we used a minimal iterator provided by McKay (based on the ideas of <ref> [McK81, McK94, McK96] </ref>). We plan soon to adapt it to the new setting, and expect to see a performance boost. There are many other open questions.
Reference: [McK94] <author> Brendan D. </author> <title> McKay . Nauty User s Guide , version 1.5. </title> <institution> Computer Science Department, Australian National University, </institution> <address> GPO Box 4, ACT 2601, Australia. </address>
Reference-contexts: Our current implementation of the iterator (described in Section 11) is not minimal: it overgenerates by about 10%, thus in ating the size of the search. In our previous version of Nitpick, we used a minimal iterator provided by McKay (based on the ideas of <ref> [McK81, McK94, McK96] </ref>). We plan soon to adapt it to the new setting, and expect to see a performance boost. There are many other open questions.
Reference: [McK96] <author> Brendan D. McKay. </author> <title> Isomorph-free exhaustive generation. </title> <type> Unpublished manuscript. </type> <institution> Computer Science Department, A ustralian National University, </institution> <address> GPO Box 4, ACT 2601, Australia. </address>
Reference-contexts: A minimal gen iterator that never yields a super uous value can be constructed using the techniques described in <ref> [McK96] </ref>. Generating graphs up to isomorphism is a surprisingly difficult problem; in our implementation, it occupies a significant part of the code. 12 Refined Algorithm Term symmetry (Section 10) complicates the algorithm. <p> Our current implementation of the iterator (described in Section 11) is not minimal: it overgenerates by about 10%, thus in ating the size of the search. In our previous version of Nitpick, we used a minimal iterator provided by McKay (based on the ideas of <ref> [McK81, McK94, McK96] </ref>). We plan soon to adapt it to the new setting, and expect to see a performance boost. There are many other open questions.
Reference: [MZ94] <author> Peter Mataga and Pamela Zave. </author> <title> Formal specification of telephone features. </title> <booktitle> Proc. 8th Z Users Meeting, </booktitle> <pages> pp. 2950, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Although this example is clearly a toy, a realistic specifi cation of telephone switching can be constructed in a similar style <ref> [MZ94] </ref>. A more interesting application of Nitpick is described in [JD96b]. The first line declares a type Phone representing an abstract set of telephones.
Reference: [OR+95] <author> Sam Owre, John R ushby, Natarajan Shankar and F riedrich von Henke. </author> <title> F ormal V erification for F ault-Tolerant Architectures: Prolegomena to the Design of PVS. </title> <journal> IEEE Transactions on Softwar e Engineering, </journal> <volume> 21(2), </volume> <month> February </month> <year> 1995, </year> <pages> pp. 107125. </pages>
Reference-contexts: Theorem Provers Small data structures have huge numbers of values. F or this reason, enumerative analysis of software specifi cations has been regarded as infeasible. R esearch efforts have therefore focused mainly on syntactic analyses. Recently, with the development of theorem provers such as PVS <ref> [OR+95] </ref> that incorporate powerful decision procedures, the analysis of realistic designs has become possible. A number of theorem provers have been developed specifically for Z [Jon92, SM96] or have been applied to it [BG94, ES94]; there are also specialized theorem provers for the relational calculus [BH94].
Reference: [R+91] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy and W illiam Lorensen. </author> <title> ObjectOriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: seems quite natural to most people, which per haps explains the popularity both of Z, a specifi cation language in which relations play a primary role [Spi92, WD96], andin more com - mercial circlesof entity relationship diagrams, originally intended for database design [Che76] but now widely adopted in objectoriented methods <ref> [SM88, R+91, BJR96] </ref>. Writing a relational description of a software system, or some aspect of it, can be worthwhile in itself. Indeed, reports on the application of formal methods invariably note that many errors are found in the act of specification itself, even if no tools are used.
Reference: [Sch79] <author> Wolfgang Schoenfeld. </author> <title> An undecidability result for relational algebras. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 44(1), </volume> <month> March </month> <year> 1979. </year>
Reference: [Sla94] <author> John K. Slaney . F inder: </author> <title> F inite Domain Enumerator , System Description. </title> <booktitle> Proc. 12th Inter national Confer ence on A utomated Deduction, Lecture Notes in Artifi cial Intelligence series, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1994, </year> <pages> pp. 798801. </pages>
Reference-contexts: Symmetries involving permutation of boolean variables have been exploited in the analysis of first-order formulae [BS92, Cra92]. But as far as we know, ours is the 35 only method to use symmetry in the assignable values themselves. The FINDER tool <ref> [Sla94] </ref> uses backtracking search to find models of a logic with functions and equality. Its author graciously translated some of our examples into its input language, and was able to obtain very good results.
Reference: [SLM92] <author> Bart Selman, Hector Levesque and David Mitchell. </author> <title> A new method for solving hard satisfi ability problems. </title> <booktitle> Proc. 10th National Confer ence on Ar tificial Intelligence (AAAI-92) , San Jose, </booktitle> <address> CA, </address> <month> July </month> <year> 1992, </year> <pages> pp. 440446. </pages>
Reference-contexts: The satisfi ability problem for boolean formulae has been especially well studied because of its wide applicability , and because, despite being NP -complete, it appears to be easy to solve in practice. F or hard cases, local search tech - niques work surprisingly well <ref> [SLM92] </ref>. Symmetries involving permutation of boolean variables have been exploited in the analysis of first-order formulae [BS92, Cra92]. But as far as we know, ours is the 35 only method to use symmetry in the assignable values themselves.
Reference: [SM88] <author> Sally Shlaer and Stephen Mellor . Objectoriented Systems Analysis: </author> <title> Modeling the World in Data. </title> <publisher> Yourdon Press/Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: seems quite natural to most people, which per haps explains the popularity both of Z, a specifi cation language in which relations play a primary role [Spi92, WD96], andin more com - mercial circlesof entity relationship diagrams, originally intended for database design [Che76] but now widely adopted in objectoriented methods <ref> [SM88, R+91, BJR96] </ref>. Writing a relational description of a software system, or some aspect of it, can be worthwhile in itself. Indeed, reports on the application of formal methods invariably note that many errors are found in the act of specification itself, even if no tools are used.
Reference: [SM96] <author> Mark Saaltink and Irwin Meisels. </author> <title> The Z/EVES R eference Manual (draft). T echnical R eport TR -96-5493-03, </title> <address> OR A Canada, Ottawa, Ontario, Canada, </address> <month> December </month> <year> 1995; </year> <month> revised April </month> <year> 1996, </year> <pages> 104 pp. </pages>
Reference-contexts: R esearch efforts have therefore focused mainly on syntactic analyses. Recently, with the development of theorem provers such as PVS [OR+95] that incorporate powerful decision procedures, the analysis of realistic designs has become possible. A number of theorem provers have been developed specifically for Z <ref> [Jon92, SM96] </ref> or have been applied to it [BG94, ES94]; there are also specialized theorem provers for the relational calculus [BH94]. The labour cost of interactive theorem proving is still high enough, however , to rule out its use in everyday software development.
Reference: [Spi92] <author> J. M. </author> <title> Spivey . The Z Notation: A R eference Manual , Second ed, </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Relational modelling, moreover, seems quite natural to most people, which per haps explains the popularity both of Z, a specifi cation language in which relations play a primary role <ref> [Spi92, WD96] </ref>, andin more com - mercial circlesof entity relationship diagrams, originally intended for database design [Che76] but now widely adopted in objectoriented methods [SM88, R+91, BJR96]. Writing a relational description of a software system, or some aspect of it, can be worthwhile in itself. <p> are awed, especially early on, and the best service a tool can offer is rapid detection of errors. 2 Nitpick/NP Nitpick is a tool for analyzing relational specifi cations written in NP [JD96a], a notation based on the relational calculus [T ar41, S S93], and roughly a subset of Z <ref> [Spi92] </ref>. Nitpick provides fully automatic simulation and checking within fi nite bounds. The user selects a scope that assigns a size to each type in the specifi cation, thereby limiting the sizes of the relations that can be generated. <p> Our notation, NP see Figure 10 for an example is more elaborate, primarily in three respects. First, its concrete syntax is richer . Using a form of Zs schema mechanism <ref> [Spi92] </ref> tailored to the description of abstract state machines as a structuring mechanism, it allows operation and state descriptions to be constructed incrementally, with commonalities factored out. It also distinguishes claims to be checked from the specification proper. Second, NP admits variables of scalar and set type. <p> Our types, derived from the given types of Z <ref> [Spi92] </ref>, are all uninterpreted, and are thus scalarsets in the jargon of [ID93]. Our method requires no orbit test; the only isomorph checking that occurs is limited to the internals of the graph generation subroutine.
Reference: [SS93] <author> Gunther Schmidt and Thomas Strohlein. </author> <title> Relations and Graphs . EATCS Monographs in Theoretical Computer Science, </title> <publisher> Springer - Verlag, </publisher> <year> 1993. </year>
Reference-contexts: More suprisingly, perhaps, the omission of scalars and sets is also insignifi cant. A formula involving scalars and sets can be translated into an equivalent formula involving only relations by the following scheme <ref> [SS93] </ref>.
Reference: [Sta91] <author> P. Starke. </author> <title> R eachability analysis of P etri nets using symmetry . Syst. Anal. Model. </title> <journal> Simul., </journal> <volume> 8 (4/5), </volume> <pages> pp. 293303, </pages> <year> 1991. </year>
Reference-contexts: Symmetry in Model Checking Symmetry in the transition relation of a state machine has been exploited in check - ing methods for Petri nets <ref> [Sta91] </ref>, for reachability analysis [ID93], and for temporal logic model checking [CFJ93, ES93]. A recent journal issue on the topic of symme - try in automatic verifi cation [FMSD96] includes expanded versions of these papers [C+96, ES96, ID96] and others.
Reference: [Tar41] <author> Alfred Tarski. </author> <title> On the calculus of relations. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 40 6 (1941), </volume> <pages> pp. 7389. </pages>
Reference-contexts: Moreover , it can be shown that if an operator can be defined in terms of first-order predicate calculus, it must be logical; and if not, it seems unlikely that it could be included in a practical specification language anyway. (The notion of logicality is due to T arski <ref> [Tar41, Giv88] </ref>. His calculus is less expressive than fi rst-order logic; it can be shown that although any fi rst-order formula with at most three variables can be expressed, there are trivial formulae with four variables that are not expressible.
Reference: [Val91] <author> Samuel H. Valentine. </author> <title> Z -, an ex ecutable subset of Z. In J.E. Nicholls (ed.), Z User W orkshop, </title> <address> York, 1991. </address> <publisher> Springer -Verlag Workshops in Computing, </publisher> <year> 1992. </year>
Reference: [WD96] <author> Jim Woodcock and Jim Davies. </author> <title> Using Z: </title> <booktitle> Specifi cation, R efinement, and Proof . Prentice Hall International Series in Computer Science, </booktitle> <year> 1996. </year>
Reference-contexts: Relational modelling, moreover, seems quite natural to most people, which per haps explains the popularity both of Z, a specifi cation language in which relations play a primary role <ref> [Spi92, WD96] </ref>, andin more com - mercial circlesof entity relationship diagrams, originally intended for database design [Che76] but now widely adopted in objectoriented methods [SM88, R+91, BJR96]. Writing a relational description of a software system, or some aspect of it, can be worthwhile in itself.
Reference: [WE92] <author> M.M. W est and B.M. Eaglestone. </author> <title> Software development: two approaches to animations of Z specifi cations using P rolog. </title> <journal> Software Engineering Journal, </journal> <volume> 7(4), </volume> <pages> pp. 264276, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Simulators Existing simulation tools require the specification to be constructive; suitable subsets of Z [V al91] and VDM [LL91] have been defi ned. Closer to our approach, there have been attempts to analyze Z specifi cations with a P rolog interpreter <ref> [DK C89, WE92] </ref>, but these do not appear to be practical yet. Nitpicks derived variable analysis [JD95] ensures that when a variable of the poststate of an operation is defined constructively, no search is actually performed; the equation is essentially converted into an assignment statement.
Reference: [WO80] <author> E.J. Weyuker and T.J. </author> <title> Ostrand. Theories of program testing and the application of revealing subdomains. </title> <journal> IEEE T rans. on Softwar e Engineering, </journal> <volume> vol. SE-6, </volume> <pages> pp. 236245, </pages> <month> May </month> <year> 1980. </year> , 
Reference-contexts: And due to short-circuiting [DJ96] and isomorph elimination, it can focus on executions that are likely to expose errors. The equivalence classes into which our method partitions the formulas interpretations are revealing subdomains in the jargon of testing theory <ref> [WO80] </ref>. Our method might have some application in testing of code also, although resource boundaries introduce discontinuities in behaviour where many bugs reside. Consequently, an enumeration that is confined to a small scope is unlikely to expose errors.
References-found: 50

