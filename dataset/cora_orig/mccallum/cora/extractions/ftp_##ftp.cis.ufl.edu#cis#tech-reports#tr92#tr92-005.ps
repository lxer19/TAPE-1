URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr92/tr92-005.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr92-abstracts.html
Root-URL: http://www.cis.ufl.edu
Title: Sorting n Numbers On n n Reconfigurable Meshes With Buses*  
Author: Madhusudan Nigam and Sartaj Sahni 
Keyword: 2 Keywords And Phrases Sorting, column sort, rotate sort, reconfigurable mesh with buses.  
Note: This research was supported, in part, by the National Science Foundation under grant MIP-9103379.  
Date: &lt;Revised July 1992&gt;  92-5  
Address: Gainesville, FL 32611  
Affiliation: University of Florida  
Pubnum: Technical Report  
Abstract: We show how column sort [LEIG85] and rotate sort [MARB88] can be implemented on the different reconfigurable mesh with buses (RMB) architectures that have been proposed in the literature. On all of these proposed RMB architectures, we are able to sort n numbers on an n n configuration in O(1) time. For the PARBUS RMB architecture [WANG90ab], our column sort and rotate sort implementations are simpler than the O(1) sorting algorithms developed in [JANG92] and [LIN92]. Furthermore, our sorting algorithms use fewer bus broadcasts. For the RMESH RMB architecture [MILL88abc], our algorithms are the first to sort n numbers on an n n configuration in O(1) time. We also observe that rotate sort can be implemented on N N . . . N k + 1 dimensional RMB architectures so as to sort N k elements in O(1) time. 
Abstract-found: 1
Intro-found: 1
Reference: [BENA91] <author> Y. Ben-Asher, D. Peleg, R. Ramaswami, and A. Schuster, </author> <title> "The power of reconfiguration," </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 13, </volume> <pages> 139-153, </pages> <year> 1991. </year>
Reference-contexts: processor (CAPP) of Weems et al. [WEEM89], the polymorphic torus of Li and Maresca [LI89, MARE89], the reconfigurable mesh with buses (RMESH) of Miller et al. [MILL88abc], the processor array with a reconfigurable bus system (PARBUS) of Wang and Chen [WANG90], and the reconfigurable network (RN) of Ben-Asher et al. <ref> [BENA91] </ref>. The CAPP [WEEM89] and RMESH [MILL88abc] architectures appear to be quite similar. So, we shall describe the RMESH only. In this, we have a bus grid with an n n arrangement of processors at the grid points (see Figure 1 for a 4x4 RMESH ). <p> In a reconfigurable network (RN) <ref> [BENA91] </ref> no restriction is placed on the bus segments that connect pairs of processors or on the relative placement of the processors. I.e., processors may not lie at grid points and a bus segment may join an arbitrary pair of processors. <p> Like the PARBUS and polymorphic torus, each processor has an internal switch that is able to connect together arbitrary subsets of the bus segments that connect to the processor. Ben-asher et al. <ref> [BENA91] </ref> also define a mesh restriction (MRN) of their reconfigurable network . In this, the processor and bus segment arrangement is exactly as for the PARBUS (Figure 4). <p> This sorting problem has been previously studied for all three architectures. n numbers can be sorted in O (1) on a three dimensional n n n - 5 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh RMESH [JENQ91ab], PARBUS [WANG90], and MRN <ref> [BENA91] </ref>. All of these algorithms are based on a count sort [HORO90] and are easily modified to run in the same amount of time on a two dimensional n 2 n computer of the same model. <p> These are not permissible in an RMESH. Their algorithms are, however, directly usable on an n n MRN as the bus connections used are permissible connections for an MRN. Ben-Asher et al. <ref> [BENA91] </ref> describe an O (1) algorithm to sort n numbers on an RN with O (n 1 + ) processors for any, , &gt; 0.
Reference: [HORO90] <author> E. Horowitz and S. Sahni, </author> <title> Fundamentals of data structures in Pascal, Third Edition, </title> <publisher> Computer Science Press, Inc., </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: This sorting problem has been previously studied for all three architectures. n numbers can be sorted in O (1) on a three dimensional n n n - 5 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh RMESH [JENQ91ab], PARBUS [WANG90], and MRN [BENA91]. All of these algorithms are based on a count sort <ref> [HORO90] </ref> and are easily modified to run in the same amount of time on a two dimensional n 2 n computer of the same model. Nakano et al. [NAKA90] have shown how to sort n numbers in O (1) time on an (n log 2 n n) PARBUS.
Reference: [JANG92] <author> J. Jang and V. Prasanna, </author> <title> "An optimal sorting algorithm on reconfigurable meshes", </title> <booktitle> International Parallel Processing Symposium, </booktitle> <year> 1992. </year>
Reference-contexts: If this is done in each processor, then we get, simultaneously, disjoint row and column buses (Figure 5 and 6). If A - 3 - = --N,S,E,W-,f-, then all four bus segments are connected. PARBUS algorithms for a variety of applications can be found in <ref> [MILL91a, WANG90ab, LIN92, JANG92] </ref>. <p> Nakano et al. [NAKA90] have shown how to sort n numbers in O (1) time on an (n log 2 n n) PARBUS. Jang and Prasanna <ref> [JANG92] </ref> and LIN et al. [LIN92] have reduced the number of processors required by an O (1) sort further. They both present O (1) sorting algorithms that work on an n n PARBUS. <p> Since such a PARBUS can be realized using n 2 area, their algorithms achieve the area time squared (AT 2 ) lower bound of W (n 2 ) for sorting n numbers in the VLSI word model [LEIG85]. The algorithm of Jang and Pra-sanna <ref> [JANG92] </ref> is based on Leighton's column sort [LEIG85] while that of LIN et al. [LIN92] is based on selection. Neither is directly adaptable to run on an n n RMESH in O (1) time as the algorithm of [JANG92] requires processors be able to connect their bus segments according to A <p> The algorithm of Jang and Pra-sanna <ref> [JANG92] </ref> is based on Leighton's column sort [LEIG85] while that of LIN et al. [LIN92] is based on selection. Neither is directly adaptable to run on an n n RMESH in O (1) time as the algorithm of [JANG92] requires processors be able to connect their bus segments according to A = - -N,S-, -E,W-- while the algorithm of [LIN92] requires A = --N,S-, -E,W-- and --N,W-, -S, E-- . These are not permissible in an RMESH. <p> The resulting RMB sort algorithms are conceptually simpler than the O (1) PARBUS sorting algorithms of <ref> [JANG92] </ref> and [LIN92]. In addition, our implementations use fewer bus broadcasts than do the algorithms of [JANG92] and [LIN92]. Since the PARBUS implementations use only bus connections permissible in an MRN, our PARBUS algorithms may be directly used on an MRN. <p> The resulting RMB sort algorithms are conceptually simpler than the O (1) PARBUS sorting algorithms of <ref> [JANG92] </ref> and [LIN92]. In addition, our implementations use fewer bus broadcasts than do the algorithms of [JANG92] and [LIN92]. Since the PARBUS implementations use only bus connections permissible in an MRN, our PARBUS algorithms may be directly used on an MRN. For an RMESH, our implementations are the first RMESH algorithms to sort n numbers in O (1) time on an n n configuation. <p> In section 9, we provide a comparision of the two PARBUS sorting algorithms developed here and those of Jang and Prasanna <ref> [JANG92] </ref> and Lin et al. [LIN92]. For the PARBUS model, Leighton's column sort uses the fewest bus broadcasts. However, for the RMESH model, combined sort uses the fewest bus broadcasts. <p> The O (1) PARBUS sorting algorithm of Jang and Prasanna <ref> [JANG92] </ref> is also based on column sort. However, it is far more complex than our adaptation and uses more broadcasts than does the O (1) PARBUS algorithm of Lin et al. [LIN92]. So, we compare our algorithm to that of [LIN92]. This latter algorithm is not based on column sort. <p> Our algorithm is also conceptually simpler than those of <ref> [JANG92] </ref> and [LIN92]. Like the algorithms of [JANG92] and [LIN91], our PARBUS algorithms may be run directly on an n n MRN. The number of broadcasts remains unchanged. - 26 - 10. <p> Our algorithm is also conceptually simpler than those of <ref> [JANG92] </ref> and [LIN92]. Like the algorithms of [JANG92] and [LIN91], our PARBUS algorithms may be run directly on an n n MRN. The number of broadcasts remains unchanged. - 26 - 10. <p> Conclusions We have developed relatively simple algorithms to sort n numbers on reconfigurable n n meshes with buses. For the case of the RMESH, our algorithms are the first to sort in O (1) time. For the PARBUS, our algorithms are simpler than those of <ref> [JANG92] </ref> and [LIN92]. Our PARBUS column sort algorithm is the fastest of our - 27 - algorithms for the PARBUS. It uses fewer broadcasts than does the optimized versions of the selection algorithm of [LIN92]. Our PARBUS algorithms can be run on an MRN with no modifications. <p> It uses fewer broadcasts than does the optimized versions of the selection algorithm of [LIN92]. Our PARBUS algorithms can be run on an MRN with no modifications. Since n n reconfigurable meshes require n 2 area for their layout. Our algorithms (as well as those of <ref> [JANG92] </ref> and [LIN92]) have an area time square product AT 2 of n 2 which is the best one can hope for in view of the lower bound result AT 2 n 2 for the VLSI word model [LEIG85].
Reference: [JENQ91a] <author> J. Jenq and S. Sahni, </author> <title> "Reconfigurable mesh algorithms for image shrinking, expanding, clustering, and template matching," </title> <booktitle> Proceedings 5th International Parallel Processing Symposium, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> 208-215, </pages> <year> 1991. </year>
Reference: [JENQ91b] <author> J. Jenq and S. Sahni, </author> <title> "Reconfigurable mesh algorithms for the Hough transform," </title> <booktitle> Proc. 1991 International Conference on Parallel Processing, </booktitle> <publisher> The Pennsylvania State University Press, </publisher> <pages> 34-41, </pages> <year> 1991. </year>
Reference-contexts: Steps 4-6 implement the count phase of a count sort. This implementation is equivalent to that used in <ref> [JENQ91b] </ref> to sort m elements on an m m m RMESH.
Reference: [JENQ91c] <author> J. Jenq and S. Sahni, </author> <title> "Reconfigurable mesh algorithms for the area and perimeter of image components," </title> <booktitle> Proc. 1991 International Conference on - 28 - Parallel Processing, </booktitle> <publisher> The Pennsylvania State University Press, </publisher> <pages> 280-281, </pages> <year> 1991. </year>
Reference: [KNUT73] <author> D. E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol 3, </volume> <publisher> Addison-Wesley, </publisher> <address> NewYork, </address> <year> 1973. </year>
Reference-contexts: In section 10, we make the observation that using rotate sort, one can sort N k elements, in O (1) time on an N N . . . N k + 1 dimensional RMESH and PARBUS. 2. Column Sort Column sort is a generalization of Batcher's odd-even merge <ref> [KNUT73] </ref> and was proposed by Leighton [LEIG85]. It may be used to sort an r s matrix Q where r 2 (s - 1) 2 and r mod s = 0.
Reference: [LEIG85] <author> T. Leighton, </author> <title> "Tight bounds on the complexity of parallel sorting", </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-34, 4, </volume> <month> April </month> <year> 1985, </year> <pages> 344-354. </pages>
Reference-contexts: Since such a PARBUS can be realized using n 2 area, their algorithms achieve the area time squared (AT 2 ) lower bound of W (n 2 ) for sorting n numbers in the VLSI word model <ref> [LEIG85] </ref>. The algorithm of Jang and Pra-sanna [JANG92] is based on Leighton's column sort [LEIG85] while that of LIN et al. [LIN92] is based on selection. <p> such a PARBUS can be realized using n 2 area, their algorithms achieve the area time squared (AT 2 ) lower bound of W (n 2 ) for sorting n numbers in the VLSI word model <ref> [LEIG85] </ref>. The algorithm of Jang and Pra-sanna [JANG92] is based on Leighton's column sort [LEIG85] while that of LIN et al. [LIN92] is based on selection. <p> Ben-Asher et al. [BENA91] describe an O (1) algorithm to sort n numbers on an RN with O (n 1 + ) processors for any, , &gt; 0. This algorithm is also based on Leighton's column sort <ref> [LEIG85] </ref>. - 6 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh In this paper, we show how Leighton's column sort algorithm [LEIG85] and Mar-berg and Gafni's rotate sort algorithm [MARB88] can be implemented on all three reconfigurble mesh with buses (RMB) architectures so as to sort n numbers in O (1) time on an n n <p> This algorithm is also based on Leighton's column sort <ref> [LEIG85] </ref>. - 6 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh In this paper, we show how Leighton's column sort algorithm [LEIG85] and Mar-berg and Gafni's rotate sort algorithm [MARB88] can be implemented on all three reconfigurble mesh with buses (RMB) architectures so as to sort n numbers in O (1) time on an n n configuration. <p> N k + 1 dimensional RMESH and PARBUS. 2. Column Sort Column sort is a generalization of Batcher's odd-even merge [KNUT73] and was proposed by Leighton <ref> [LEIG85] </ref>. It may be used to sort an r s matrix Q where r 2 (s - 1) 2 and r mod s = 0. The number of elements in Q is n = rs and the sorted sequence is stored in column major order (Figure 9). <p> The number of elements in Q is n = rs and the sorted sequence is stored in column major order (Figure 9). Our presentation of column sort follows that of <ref> [LEIG85] </ref> very closely. - 9 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 27 25 23 21 19 17 15 13 11 9 7 5 3 1 18 5 20 25 12 23 13 22 1 8 19 4 2 (a) Input Q (b) Output Q hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh There are eight steps to column sort. <p> Step 6 is a shift by Q 2 This increases the number of columns by 1 and is shown in Figure 11. Step 8, unshift, is the reverse of this. Leighton <ref> [LEIG85] </ref> has shown that these eight steps are sufficient to sort Q whenever r 2 (s - 1) 2 and r mod s = 0. 3. <p> We can actually reduce the number of broadcasts further by begining with r 1 = n 2/3 and s 1 = n 1/3 . While this does not satisfy the requirement that r 2 (s - 1) 2 , Leighton <ref> [LEIG85] </ref> has shown that column sort works for r and s such that r s (s - 1) provided that the Untranspose of step 4 is replaced by an Undiagonalize step (Figure 17). <p> Our algorithms (as well as those of [JANG92] and [LIN92]) have an area time square product AT 2 of n 2 which is the best one can hope for in view of the lower bound result AT 2 n 2 for the VLSI word model <ref> [LEIG85] </ref>. Using two dimensional meshes with buses, we are able to sort n elements in O (1) time using n 2 processors. Using higher dimensional RMB, one can sort n numbers in O (1) time using fewer processors.
Reference: [LI89a] <author> H. Li and M. Maresca, </author> <title> "Polymorphic-torus architecture for computer vision," </title> <journal> IEEE Trans. on Pattern & Machine Intelligence, </journal> <volume> 11, 3, </volume> <pages> 133-143, </pages> <year> 1989. </year>
Reference: [LI89b] <author> H. Li and M. Maresca, </author> <title> "Polymorphic-torus network", </title> <journal> IEEE Trans. on Computers, C-38, </journal> <volume> 9, </volume> <pages> 1345-1351, </pages> <year> 1989. </year>
Reference: [LIN92] <author> R. Lin, S. Olariu, J. Schwing, and J. Zhang, </author> <title> "A VLSI-optimal constant time Sorting on reconfigurable mesh", </title> <booktitle> Proceedings of Ninth European Workshop on Parallel Computing, </booktitle> <address> Madrid, Spain, </address> <year> 1992. </year>
Reference-contexts: If this is done in each processor, then we get, simultaneously, disjoint row and column buses (Figure 5 and 6). If A - 3 - = --N,S,E,W-,f-, then all four bus segments are connected. PARBUS algorithms for a variety of applications can be found in <ref> [MILL91a, WANG90ab, LIN92, JANG92] </ref>. <p> Nakano et al. [NAKA90] have shown how to sort n numbers in O (1) time on an (n log 2 n n) PARBUS. Jang and Prasanna [JANG92] and LIN et al. <ref> [LIN92] </ref> have reduced the number of processors required by an O (1) sort further. They both present O (1) sorting algorithms that work on an n n PARBUS. <p> The algorithm of Jang and Pra-sanna [JANG92] is based on Leighton's column sort [LEIG85] while that of LIN et al. <ref> [LIN92] </ref> is based on selection. Neither is directly adaptable to run on an n n RMESH in O (1) time as the algorithm of [JANG92] requires processors be able to connect their bus segments according to A = - -N,S-, -E,W-- while the algorithm of [LIN92] requires A = --N,S-, -E,W-- <p> that of LIN et al. <ref> [LIN92] </ref> is based on selection. Neither is directly adaptable to run on an n n RMESH in O (1) time as the algorithm of [JANG92] requires processors be able to connect their bus segments according to A = - -N,S-, -E,W-- while the algorithm of [LIN92] requires A = --N,S-, -E,W-- and --N,W-, -S, E-- . These are not permissible in an RMESH. Their algorithms are, however, directly usable on an n n MRN as the bus connections used are permissible connections for an MRN. <p> The resulting RMB sort algorithms are conceptually simpler than the O (1) PARBUS sorting algorithms of [JANG92] and <ref> [LIN92] </ref>. In addition, our implementations use fewer bus broadcasts than do the algorithms of [JANG92] and [LIN92]. Since the PARBUS implementations use only bus connections permissible in an MRN, our PARBUS algorithms may be directly used on an MRN. <p> The resulting RMB sort algorithms are conceptually simpler than the O (1) PARBUS sorting algorithms of [JANG92] and <ref> [LIN92] </ref>. In addition, our implementations use fewer bus broadcasts than do the algorithms of [JANG92] and [LIN92]. Since the PARBUS implementations use only bus connections permissible in an MRN, our PARBUS algorithms may be directly used on an MRN. For an RMESH, our implementations are the first RMESH algorithms to sort n numbers in O (1) time on an n n configuation. <p> In section 9, we provide a comparision of the two PARBUS sorting algorithms developed here and those of Jang and Prasanna [JANG92] and Lin et al. <ref> [LIN92] </ref>. For the PARBUS model, Leighton's column sort uses the fewest bus broadcasts. However, for the RMESH model, combined sort uses the fewest bus broadcasts. <p> We can, however, sort using fewer than 139 broadcasts on a PARBUS. If we replace the ranking algorithm of [JENQ91ab] that we used in Section 3 by the prefix sum of <ref> [LIN92] </ref> ( i.e., prefix sum N bits on a (N + 1) N PARBUS) then we can sum the S's in a row using two broadcasts. The algorithm of [LIN92] needs to be modified slightly to allow for the fact that we begin with the S values on all columns and <p> If we replace the ranking algorithm of [JENQ91ab] that we used in Section 3 by the prefix sum of <ref> [LIN92] </ref> ( i.e., prefix sum N bits on a (N + 1) N PARBUS) then we can sum the S's in a row using two broadcasts. The algorithm of [LIN92] needs to be modified slightly to allow for the fact that we begin with the S values on all columns and we are summing r 2 S values on a r 2 r 2 PARBUS rather than an (r 2 + 1) r 2 PARBUS. These modifications are straightforward. <p> The D ij 's are used to do the counting previously done by the B ijk 's. To count r 1 = n 2/3 bits using an n 1/3 n 2/3 sub PARBUS, we use the parallel prefix sum algorithm of <ref> [LIN92] </ref> which does this in 12 broadcasts when we begin with bits in all rows of D ij and - 18 - take into account we want only the sum and not the prefix sum. Note that the prefix sum algorithm of [LIN92] is an iterative algorithm that uses modulo M <p> we use the parallel prefix sum algorithm of <ref> [LIN92] </ref> which does this in 12 broadcasts when we begin with bits in all rows of D ij and - 18 - take into account we want only the sum and not the prefix sum. Note that the prefix sum algorithm of [LIN92] is an iterative algorithm that uses modulo M arithmetic to sum N bits on an (M + 1) N PARBUS. For this it uses log M log N hhhhh iterations. <p> The block sort of step 1 is done using submeshes of size n n 3/4 = N 2 N 3/2 = N 2 ( N 3/4 N 3/4 ). On a PARBUS, this is done by ranking - 25 - in n 1/4 n 3/4 as in <ref> [LIN92] </ref> while on an RMESH, this is done using the algorithm to sort a column of Q using an n r 1 submesh (section 3). We omit the details here. The number of broadcasts is 77 for PARBUS and 118 for an RMESH. 9. <p> The O (1) PARBUS sorting algorithm of Jang and Prasanna [JANG92] is also based on column sort. However, it is far more complex than our adaptation and uses more broadcasts than does the O (1) PARBUS algorithm of Lin et al. <ref> [LIN92] </ref>. So, we compare our algorithm to that of [LIN92]. This latter algorithm is not based on column sort. Rather, it is based on a multiple selection algorithm that the authors develop. This multiple selection algorithm is itself a simple modification of a selection algorithm for the PARBUS. <p> However, it is far more complex than our adaptation and uses more broadcasts than does the O (1) PARBUS algorithm of Lin et al. <ref> [LIN92] </ref>. So, we compare our algorithm to that of [LIN92]. This latter algorithm is not based on column sort. Rather, it is based on a multiple selection algorithm that the authors develop. This multiple selection algorithm is itself a simple modification of a selection algorithm for the PARBUS. <p> Each bucket is then sorted using an n n 2/3 sub PARBUS. Lin et al. <ref> [LIN92] </ref> were only concerned with developing a constant time algorithm to sort n numbers on an n n PARBUS. Consequently, they did not attempt to minimize the number of broadcasts needed for a sort. However, we analyzed versions of their algorithms that were optimized by us. <p> Furthermore, even if one were interested only in the selection problem, it would be faster to sort using our PARBUS implementation of Leighton's column sort algorithm and then select the k'th element than to use the optimized version of the PARBUS selection algorithm of <ref> [LIN92] </ref>. Our algorithm is also conceptually simpler than those of [JANG92] and [LIN92]. Like the algorithms of [JANG92] and [LIN91], our PARBUS algorithms may be run directly on an n n MRN. The number of broadcasts remains unchanged. - 26 - 10. <p> only in the selection problem, it would be faster to sort using our PARBUS implementation of Leighton's column sort algorithm and then select the k'th element than to use the optimized version of the PARBUS selection algorithm of <ref> [LIN92] </ref>. Our algorithm is also conceptually simpler than those of [JANG92] and [LIN92]. Like the algorithms of [JANG92] and [LIN91], our PARBUS algorithms may be run directly on an n n MRN. The number of broadcasts remains unchanged. - 26 - 10. <p> Conclusions We have developed relatively simple algorithms to sort n numbers on reconfigurable n n meshes with buses. For the case of the RMESH, our algorithms are the first to sort in O (1) time. For the PARBUS, our algorithms are simpler than those of [JANG92] and <ref> [LIN92] </ref>. Our PARBUS column sort algorithm is the fastest of our - 27 - algorithms for the PARBUS. It uses fewer broadcasts than does the optimized versions of the selection algorithm of [LIN92]. Our PARBUS algorithms can be run on an MRN with no modifications. <p> For the PARBUS, our algorithms are simpler than those of [JANG92] and <ref> [LIN92] </ref>. Our PARBUS column sort algorithm is the fastest of our - 27 - algorithms for the PARBUS. It uses fewer broadcasts than does the optimized versions of the selection algorithm of [LIN92]. Our PARBUS algorithms can be run on an MRN with no modifications. Since n n reconfigurable meshes require n 2 area for their layout. Our algorithms (as well as those of [JANG92] and [LIN92]) have an area time square product AT 2 of n 2 which is the best one <p> It uses fewer broadcasts than does the optimized versions of the selection algorithm of <ref> [LIN92] </ref>. Our PARBUS algorithms can be run on an MRN with no modifications. Since n n reconfigurable meshes require n 2 area for their layout. Our algorithms (as well as those of [JANG92] and [LIN92]) have an area time square product AT 2 of n 2 which is the best one can hope for in view of the lower bound result AT 2 n 2 for the VLSI word model [LEIG85].
Reference: [MARB88] <author> John M. Marberg, and Eli Gafni, </author> <title> "Sorting in Constant Number of Row and Column Phases on a Mesh", </title> <journal> Algorithmica, </journal> <volume> 3, </volume> <year> 1988, </year> <pages> 561-572. </pages>
Reference-contexts: This algorithm is also based on Leighton's column sort [LEIG85]. - 6 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh In this paper, we show how Leighton's column sort algorithm [LEIG85] and Mar-berg and Gafni's rotate sort algorithm <ref> [MARB88] </ref> can be implemented on all three reconfigurble mesh with buses (RMB) architectures so as to sort n numbers in O (1) time on an n n configuration. The resulting RMB sort algorithms are conceptually simpler than the O (1) PARBUS sorting algorithms of [JANG92] and [LIN92]. <p> Its implementation on an RMESH is developed in section 3. In section 4, we show how to implement column sort on a PARBUS. Rotate sort is considered in sections 5 through 7. In section 5 we describe Marberg and Gafni's rotate sort <ref> [MARB88] </ref>. The implementation of rotate sort is obtained in sections 6 and 7 for RMESH and PARBUS architectures, respectively. <p> So, the number of broadcasts in the one level PARBUS column sort algorithms is 59. - 19 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh . . D ir 2 D i1 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 5. Rotate Sort Rotate sort was developed by Marberg and Gafni <ref> [MARB88] </ref> to sort M N numbers on an M N mesh with the standard four neighbor connections. To state their algorithm we need to restate some of the definitions from [MARB88]. Assume that M = 2 s and N = 2 2t where s t. <p> D ir 2 D i1 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 5. Rotate Sort Rotate sort was developed by Marberg and Gafni <ref> [MARB88] </ref> to sort M N numbers on an M N mesh with the standard four neighbor connections. To state their algorithm we need to restate some of the definitions from [MARB88]. Assume that M = 2 s and N = 2 2t where s t. An M N mesh can be tiled in a natural way with tiles of size M N 1/2 . This tiling partitions the mesh into vertical slices (Figure 19 (a)). <p> Rotate sort is comprised of the six steps given in Figure 21. Recall that a vertical slice is an M N 1/2 submesh; a horizontal slice is an N N 1/2 submesh; and a block is a N 1/2 N 1/2 submesh. Marberg and Gafni <ref> [MARB88] </ref> point out that when M = N, step 1 of rotate sort may be replaced by the steps. - 20 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh (b) Horizontal Slices (a) Verticle Slices . . N . . . <p> The correctness of Figure 23 may be established using the results of [SCHER89] and <ref> [MARB88] </ref>. To implement the combined sort on an n n RMESH or n n PARBUS ( n = N 2 elements to be sorted), we note that the column sort of step 3 can be done in the same manner as the column sorts of rotate sort are done. <p> We can use this to sort N l numbers on an N l + 1 processor RMB in O (1) time by regarding the N l numbers as forming an N l - 1 N array. In the terminology of Marberg and Gafni <ref> [MARB88] </ref>, we have an M N array with M = N l - 1 N.
Reference: [MARE89] <author> M. Maresca, and H. Li, </author> <title> "Connection autonomy in SIMD computers: A VLSI implementation", </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 7, </volume> <month> April </month> <year> 1989, </year> <pages> 302-320. </pages>
Reference-contexts: 1. Introduction Several different mesh like architectures with reconfigurable buses have been proposed in the literature. These include the content addressable array processor (CAPP) of Weems et al. [WEEM89], the polymorphic torus of Li and Maresca <ref> [LI89, MARE89] </ref>, the reconfigurable mesh with buses (RMESH) of Miller et al. [MILL88abc], the processor array with a reconfigurable bus system (PARBUS) of Wang and Chen [WANG90], and the reconfigurable network (RN) of Ben-Asher et al. [BENA91]. The CAPP [WEEM89] and RMESH [MILL88abc] architectures appear to be quite similar. <p> PARBUS algorithms for a variety of applications can be found in [MILL91a, WANG90ab, LIN92, JANG92]. Observe that in an RMESH the realizable connections are of the form A = A 1 -, A 1 -N,E,W,S-. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh : Processor : Switch : Link hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh The polymorphic torus architecture <ref> [LI89ab, MARE89] </ref> is identical to the PARBUS except that the rows and columns of the underlying mesh wrap around (Figure 7). In a reconfigurable network (RN) [BENA91] no restriction is placed on the bus segments that connect pairs of processors or on the relative placement of the processors.
Reference: [MILL88a] <author> R. Miller, V. K. Prasanna Kumar, D. Reisis and Q. Stout, </author> <title> "Data movement operations and applications on reconfigurable VLSI arrays", </title> <booktitle> Proceedings of the 1988 International Conference on Parallel Processing, </booktitle> <publisher> The Pennsylvania State University Press, </publisher> <pages> pp 205-208. </pages>
Reference: [MILL88b] <author> R. Miller, V. K. Prasanna Kumar, D. Reisis and Q. Stout, </author> <title> "Meshes with reconfigurable buses", </title> <booktitle> Proceedings 5th MIT Conference On Advanced Research In VLSI, </booktitle> <year> 1988, </year> <pages> pp 163-178. </pages>
Reference: [MILL88c] <author> R. Miller, V. K. Prasanna Kumar, D. Reisis and Q. Stout, </author> <title> "Image computations on reconfigurable VLSI arrays", </title> <booktitle> Proceedings IEEE Conference On Computer Vision And Pattern Recognition, </booktitle> <year> 1988, </year> <pages> pp 925-930. </pages>
Reference: [MILL91a] <author> R. Miller, V. K. Prasanna Kumar, D. Reisis and Q. Stout, </author> <title> "Efficient parallel algorithms for intermediate level vision analysis on the reconfigurable mesh", Parallel Architectures and Algorithms for Image Understanding, - 29 - Viktor k. </title> <editor> Prasanna ed., </editor> <address> 185-207, </address> <publisher> Academic Press, </publisher> <year> 1991 </year>
Reference-contexts: If this is done in each processor, then we get, simultaneously, disjoint row and column buses (Figure 5 and 6). If A - 3 - = --N,S,E,W-,f-, then all four bus segments are connected. PARBUS algorithms for a variety of applications can be found in <ref> [MILL91a, WANG90ab, LIN92, JANG92] </ref>.
Reference: [MILL91b] <author> R. Miller, V. K. Prasanna Kumar, D. Reisis and Q. Stout, </author> <title> "Image processing on reconfigurable meshes", From Pixels to Features II, </title> <editor> H. Burkhardt ed., </editor> <publisher> Elsevier Science Publishing, </publisher> <year> 1991. </year>
Reference: [NAKA90] <author> Koji Nakano, Thoshimits Msuzawa, Nobuki Tokura, </author> <title> "A fast sorting algorithm on a reconfigurable array", </title> <type> Technical Report, COMP 90-69, </type> <year> 1990. </year>
Reference-contexts: All of these algorithms are based on a count sort [HORO90] and are easily modified to run in the same amount of time on a two dimensional n 2 n computer of the same model. Nakano et al. <ref> [NAKA90] </ref> have shown how to sort n numbers in O (1) time on an (n log 2 n n) PARBUS. Jang and Prasanna [JANG92] and LIN et al. [LIN92] have reduced the number of processors required by an O (1) sort further.
Reference: [SCHER89] <author> Issac D. Scherson, Sandeep Sen, and Yiming MA, </author> <title> "Two nearly Optimal Sorting algorithms for Mesh-Connected processor arrays using shear sort," </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 6, </volume> <pages> 151-165, </pages> <year> 1989. </year>
Reference-contexts: In - 7 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 8 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh S N EW N S W E S NN S S N N S EW W E hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh section 8, we propose a sorting algorithm that is a combination of rotate sort and Scher-son et al.'s <ref> [SCHER89] </ref> iterative shear sort. In section 9, we provide a comparision of the two PARBUS sorting algorithms developed here and those of Jang and Prasanna [JANG92] and Lin et al. [LIN92]. For the PARBUS model, Leighton's column sort uses the fewest bus broadcasts. <p> Hence our PARBUS implementation of rotate sort takes 81 broadcasts. Recall that Leighton's column sort could be implemented on a PARBUS using only 59 broadcasts. 8. A Combined Sort We may combine the first three steps of the iterative shear sort algorithm of Scher-son et al. <ref> [SCHER89] </ref> with the last four steps of rotate sort to obtain combined sort of number of elements to sorted is N 2 . hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Step 1: Sort each N 3/4 N 3/4 block; Step 2: Shift the i'th row by (i*N 3/4 ) mod N to the right, 1 i N; <p> The correctness of Figure 23 may be established using the results of <ref> [SCHER89] </ref> and [MARB88].
Reference: [WANG90a] <author> B. Wang and G. Chen, </author> <title> "Constant time algorithms for the transitive closure and some related graph problems on processor arrays with reconfigurable bus systems," </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 1, 4, </volume> <pages> 500-507, </pages> <year> 1990. </year>
Reference: [WANG90b] <author> B. Wang, G. Chen, and F. Lin, </author> <title> "Constant time sorting on a processor array with a reconfigurable bus system," </title> <journal> Info. Proc. Letrs., </journal> <volume> 34, 4, </volume> <pages> 187-190, </pages> <year> 1990. </year>
Reference: [WEEM89] <author> C. C. Weems, S. P. Levitan, A. R. Hanson, E. M. Riseman, J. G. Nash, and D. B. Shu, </author> <title> "The image understanding architecture, </title> " <journal> International Journal of Computer Vision, </journal> <volume> 2, </volume> <pages> 251-282, </pages> <year> 1989. </year>
Reference-contexts: 1. Introduction Several different mesh like architectures with reconfigurable buses have been proposed in the literature. These include the content addressable array processor (CAPP) of Weems et al. <ref> [WEEM89] </ref>, the polymorphic torus of Li and Maresca [LI89, MARE89], the reconfigurable mesh with buses (RMESH) of Miller et al. [MILL88abc], the processor array with a reconfigurable bus system (PARBUS) of Wang and Chen [WANG90], and the reconfigurable network (RN) of Ben-Asher et al. [BENA91]. The CAPP [WEEM89] and RMESH [MILL88abc] <p> Weems et al. <ref> [WEEM89] </ref>, the polymorphic torus of Li and Maresca [LI89, MARE89], the reconfigurable mesh with buses (RMESH) of Miller et al. [MILL88abc], the processor array with a reconfigurable bus system (PARBUS) of Wang and Chen [WANG90], and the reconfigurable network (RN) of Ben-Asher et al. [BENA91]. The CAPP [WEEM89] and RMESH [MILL88abc] architectures appear to be quite similar. So, we shall describe the RMESH only. In this, we have a bus grid with an n n arrangement of processors at the grid points (see Figure 1 for a 4x4 RMESH ).
References-found: 23

