URL: http://www.cs.indiana.edu/l/www/pub/liu/AutoInc-ICFP98.ps.Z
Refering-URL: http://www.cs.indiana.edu/l/www/pub/liu/
Root-URL: http://www.cs.indiana.edu
Email: fyuczhang, liug@cs.indiana.edu  
Title: Automating Derivation of Incremental Programs Automation of CACHET continued to use the Synthesizer Generator [3].
Author: Yuchen Zhang Yanhong A. Liu 
Keyword: Derivation of incremental programs  Applications  
Note: Applicative-order rewrite  This work is supported by a Motorola University Partnership in Research Grant and NSF grant CCR 9711253. Yuchen Zhang is a student recipient of Motorola University Partnerships in Research Grant.  let v2 bino(i 1; j) in  
Address: Bloomington, IN 47405  
Affiliation: Computer Science Department, Indiana University,  
Abstract: Given a program f and an input change operation , an incremental program f 0 computes the value of f(x y) efficiently by making use of the value of f(x). Liu and Teitel-baum proposed a systematic approach [1] for deriving incremental programs written in a first order functional programming language. This work aims to automate the derivation of f 0 from f and based on a semi-automatic implementation CACHET [2]. The derivation of incremental program shares the same underlying principle with finite differencing and a number of other program optimizations. It is crucial for optimizing programs in high-level language. Liu and Teitelbaum's approach has three major components: simplification, replacement using cached results, and introduction of incremental functions. The derivation begins with f (x y). It examines subcomputations recursively in applicative and left-to-right order and applies simplifications and replacements with retrievals from cached results. If a function application can't be replaced by a retrieval, then replace it with an incremental version: if it is an instance of an incremental version alreadyintroduced, then simply replace it; otherwise, introduce a corresponding incremental version for the unfolded application and recursively apply simplifications and replacements on the new function. Liu's semi-automatic implementation has automatic rules for introducing incremental functions, local simplification and replacement, but the entire derivation needs manual invocation of appropriate rules at each step. We implemented three modules corresponding to the three major components of the derivation algorithm. A main module traverses a program in applicative order. To make the automated derivation efficient, transformation rules are grouped according to the program constructs they apply to so as to reduce rule mismatch. There are two kinds of equality reasoning: one for data constructions, the other for arithmatic operation. For the first kind, equality reasoning is based on the relation between a constructor and its corresponding selectors. For the second kind, equality reasoning uses the simplification of arithmatic formula. For example, x + 1 1 = x. Our general algorithm achieves this by grouping constants and organizing variables. We plan to switch to Omega [4] for the second kind of reasoning. Introducing new incremental function involving unfolding is the source of non-termination. We set a bound on the number of incremental versions that can be introduced for a function. Thus, the transformation terminates either when the derivation completes or such bounds are reached. Incremental computation has applications in optimizing compilers, transformational programming, interactive programming environments, etc. The derivation described here allows only the use of the return value of f . However, when f is extended to return also additional information, our derivation will yield a program that uses and maintains all such information. For example, given a binomial coefficient program that returns all the intermediate results of function calls: bino(i; j) where 0 j i = if j = 0 or j = i then &lt; 1 &gt; &lt; 1st(v1) + 1st(v2); v1; v2 &gt; For input change operation : hi 0 ; j 0 i = hi + 1; ji, our automated system produces the following incremental program, which can be used as the body of a repeated computation that forms a dynamic programming solution. The speedup achieved is from exponential time to polynomial time. bino 0 (i; j; r) = if j = 0 or j = i + 1 then &lt; 1 &gt; else if j = i then let v1 = bino 0 (i 1; j 1; &lt; 1 &gt;) in &lt; 1st(v1) + 1; v1; &lt; 1 &gt;> else let v1 = bino 0 (i 1; j 1; 2nd(r)) in let v2 = r in We have applied the system on a number of small examples, including programs for sorting, other list operations, and simple matrix computations. We translated both the original and incremental programs in our subject language to Scheme and compared the running times. The observed speedups confirmed our asymptotic analysis. We plan to further modularize the system and improve the equality reasoning and other analyses used. References [1] Yanhong A. Liu and Tim Teitelbaum. Systematic Derivation of Incremental Programs. Science of Copmuter Programming, 24(1):1-39, Feb. 1995. [2] Yanhong A. Liu. CACHET: An Interactive, Incremental-Attribution-Based Program Transformation System for Deriving Incremental Programs. In Proceedings of the 10th Knowledge-Based Software Engineering Conference. Novem-ber 1995. IEEE Computer Society Press. [3] William Pugh. The Omega Test: A fast and practical integer programming algorithm for dependence analysis. Communications of the ACM (CACM), 31(8), August 1992. [4] The Synthesizer Generator Reference Manual, Release 5.0. GrammaTech, Inc. Ithaca, New York, 1996. else let v1 = bino(i 1; j 1) in
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Yanhong A. Liu and Tim Teitelbaum. </author> <title> Systematic Derivation of Incremental Programs. </title> <journal> Science of Copmuter Programming, </journal> <volume> 24(1) </volume> <pages> 1-39, </pages> <month> Feb. </month> <year> 1995. </year>
Reference: [2] <author> Yanhong A. Liu. CACHET: </author> <title> An Interactive, Incremental-Attribution-Based Program Transformation System for Deriving Incremental Programs. </title> <booktitle> In Proceedings of the 10th Knowledge-Based Software Engineering Conference. Novem-ber 1995. </booktitle> <publisher> IEEE Computer Society Press. </publisher>
Reference: [3] <author> William Pugh. </author> <title> The Omega Test: A fast and practical integer programming algorithm for dependence analysis. </title> <journal> Communications of the ACM (CACM), </journal> <volume> 31(8), </volume> <month> August </month> <year> 1992. </year>
Reference-contexts: Liu's semi-automatic implementation has automatic rules for introducing incremental functions, local simplification and replacement, but the entire derivation needs manual invocation of appropriate rules at each step. Applicative-order rewrite Automation of CACHET continued to use the Synthesizer Generator <ref> [3] </ref>. To automate the derivation, there are three major challenges. First, sequencing the transformation while maintaining derived information at appropriate program points. Second, automating equality reasoning needed for local replacement. Third, ensuring termination. We implemented three modules corresponding to the three major components of the derivation algorithm.
Reference: [4] <institution> The Synthesizer Generator Reference Manual, Release 5.0. GrammaTech, Inc. </institution> <address> Ithaca, New York, </address> <year> 1996. </year>
Reference-contexts: Our fl This work is supported by a Motorola University Partnership in Research Grant and NSF grant CCR 9711253. Yuchen Zhang is a student recipient of Motorola University Partnerships in Research Grant. general algorithm achieves this by grouping constants and organizing variables. We plan to switch to Omega <ref> [4] </ref> for the second kind of reasoning. Introducing new incremental function involving unfolding is the source of non-termination. We set a bound on the number of incremental versions that can be introduced for a function. Thus, the transformation terminates either when the derivation completes or such bounds are reached.
References-found: 4

