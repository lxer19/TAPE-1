URL: http://www.cs.colostate.edu/~ftppub/TechReports/1996/tr96-129.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Email: malaiya@cs.colostate.edu  
Phone: Phone: (970) 491-5792 Fax: (970) 491-2466  
Title: ANTIRANDOM TESTING: GETTING THE MOST OUT OF BLACK-BOX TESTING  
Author: Yashwant K. Malaiya 
Note: This research was supported by a BMDO funded project monitored by ONR  
Web: WWW: http://www.cs.colostate.edu  
Address: Fort Collins, CO 80523  Fort Collins, CO 80523-1873  
Affiliation: Computer Science  Computer Science Dept. Colorado State University  Computer Science Department Colorado State University  
Pubnum: Technical Report  Technical Report CS-96-129  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> B. Beizer, </author> <title> Software Testing Techniques, Second Edition, </title> <publisher> Van Nostrand Reinhold, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Exhaustive testing of software is infeasible except for very small programs <ref> [1, 2] </ref>. Achieving 100% test coverage using a specific measure does not assure that all defects have been found [4, 5]. Obtaining total coverage itself may be hard; 85% branch coverage is often used as a target.
Reference: [2] <author> G. Meyers, </author> <title> Art of Software Testing, </title> <publisher> John Wiley & Sons, </publisher> <year> 1979. </year>
Reference-contexts: 1 Introduction Exhaustive testing of software is infeasible except for very small programs <ref> [1, 2] </ref>. Achieving 100% test coverage using a specific measure does not assure that all defects have been found [4, 5]. Obtaining total coverage itself may be hard; 85% branch coverage is often used as a target.
Reference: [3] <author> Y.K. Malaiya and S. Yang, </author> <title> "The coverage problem for random testing," </title> <booktitle> Proc. Int. Test Conf., </booktitle> <month> Oct. </month> <year> 1984, </year> <pages> pp. 237-242. </pages>
Reference-contexts: Here we consider black-box testing where only the external specifications are used to obtain test suites. No implementation specific information is assumed to be known. Often software testing is termed random <ref> [3, 6, 7] </ref>. By definition, in random testing the values of the inputs in each test are selected randomly, regardless of the previous tests applied. Random testing and its variations have been extensively used and studied for hardware systems.
Reference: [4] <author> Y.K. Malaiya, N. Li, R. Karcich, and B. Skibbe, </author> <title> "The relationship between test coverage and reliability," </title> <booktitle> Proc. </booktitle> <address> ISSRE, </address> <month> Nov. </month> <year> 1994, </year> <pages> pp. 186-195. </pages>
Reference-contexts: 1 Introduction Exhaustive testing of software is infeasible except for very small programs [1, 2]. Achieving 100% test coverage using a specific measure does not assure that all defects have been found <ref> [4, 5] </ref>. Obtaining total coverage itself may be hard; 85% branch coverage is often used as a target. The testing time, often a significant fraction of the overall development time, is always limited.
Reference: [5] <author> W.E. Wong, J.R. Horgan, S. London and A.P. Mathur, </author> <title> "Effect of test set size and block coverage on the fault detection effectiveness," </title> <booktitle> Proc. </booktitle> <address> ISSRE, </address> <month> Nov. </month> <year> 1994, </year> <pages> pp. 230-238. </pages>
Reference-contexts: 1 Introduction Exhaustive testing of software is infeasible except for very small programs [1, 2]. Achieving 100% test coverage using a specific measure does not assure that all defects have been found <ref> [4, 5] </ref>. Obtaining total coverage itself may be hard; 85% branch coverage is often used as a target. The testing time, often a significant fraction of the overall development time, is always limited.
Reference: [6] <author> Y.K. Malaiya, A. von Mayrhauser and P.K. Srimani, </author> <title> "An examination of fault exposure ratio," </title> <journal> IEEE Tans. Software Engineering, </journal> <volume> Vol. 19, No. 11, </volume> <month> Nov. </month> <year> 1993, </year> <pages> pp. 1087-1094. </pages>
Reference-contexts: Here we consider black-box testing where only the external specifications are used to obtain test suites. No implementation specific information is assumed to be known. Often software testing is termed random <ref> [3, 6, 7] </ref>. By definition, in random testing the values of the inputs in each test are selected randomly, regardless of the previous tests applied. Random testing and its variations have been extensively used and studied for hardware systems. <p> Available evidence suggests that random testing may be a reasonable choice for obtaining a moderate degree of confidence; however, it becomes very inefficient when the residual defect density becomes low <ref> [6] </ref>. Random testing does not exploit some information that is available in black-box testing environment. This information consists of the previous tests applied.
Reference: [7] <author> S. Seth, V. Agrawal and H. Farhat, </author> <title> "A statistical theory of digital circuit testability," </title> <journal> IEEE Trans. Comp., </journal> <month> Apr. </month> <year> 1990, </year> <pages> pp. 582-586. </pages>
Reference-contexts: Here we consider black-box testing where only the external specifications are used to obtain test suites. No implementation specific information is assumed to be known. Often software testing is termed random <ref> [3, 6, 7] </ref>. By definition, in random testing the values of the inputs in each test are selected randomly, regardless of the previous tests applied. Random testing and its variations have been extensively used and studied for hardware systems.
Reference: [8] <editor> R.A. DeMillo, R.J. Lipton and F.G. Sayward, </editor> <title> "Hints on test data selection: Help for the practicing programmer," </title> <booktitle> IEEE Computer, </booktitle> <month> Apr. </month> <year> 1978, </year> <pages> pp. 34-41. </pages>
Reference-contexts: This allows binary antirandom sequences to be decoded into actual inputs. fl This research was supported by a BMDO funded project monitored by ONR 1 Test data selection has been regarded as an important part of testing software <ref> [8, 9, 10, 11] </ref>. Researchers have identified valuable guidelines for selecting test data. We can divide the input space into multi-dimensional subdomains such that the software responds to all the points within the same subdomain in a similar way. <p> However, for a general system, guidelines for making optimal choices cannot be offered at this time. Example 11: As a more complete example of checkpoint encoding, let us consider the FIND program by Hoare (Figure 4). Testing of its FORTRAN version was examined by DeMillo et al. <ref> [8] </ref>. It takes as an input an integer array A with size N 1 and an array index F, 1 F N . <p> Notice that all the individual choices have occurred in the first eight vectors, but to apply all possible combinations allowed by the encoding scheme, 2 8 vectors would be needed. It can be seen that the resulting combinations are consistent with the findings and recommendations of DeMillo et al. <ref> [8] </ref>. They suggest use of illegal as well as special values in addition to the usual values. If additional testing time is available, the coding scheme above should be modified to allow a larger number of normal combinations.
Reference: [9] <author> Lee White and Edward Cohen, </author> <title> "A domain strategy for computer program testing," </title> <journal> IEEE Trans. Software Engineering, </journal> <month> May </month> <year> 1980, </year> <pages> pp. 247-257. </pages>
Reference-contexts: This allows binary antirandom sequences to be decoded into actual inputs. fl This research was supported by a BMDO funded project monitored by ONR 1 Test data selection has been regarded as an important part of testing software <ref> [8, 9, 10, 11] </ref>. Researchers have identified valuable guidelines for selecting test data. We can divide the input space into multi-dimensional subdomains such that the software responds to all the points within the same subdomain in a similar way.
Reference: [10] <author> W.E. Howden, </author> <title> "The theory and practice of functional testing," </title> <journal> IEEE Software, </journal> <month> Sept. </month> <year> 1985, </year> <pages> pp. 6-17. </pages>
Reference-contexts: This allows binary antirandom sequences to be decoded into actual inputs. fl This research was supported by a BMDO funded project monitored by ONR 1 Test data selection has been regarded as an important part of testing software <ref> [8, 9, 10, 11] </ref>. Researchers have identified valuable guidelines for selecting test data. We can divide the input space into multi-dimensional subdomains such that the software responds to all the points within the same subdomain in a similar way.
Reference: [11] <author> E.J. Weyuker and B. Jeng, </author> <title> "Analyzing partition testing strategies," </title> <journal> IEEE Trans. Software Engineering, </journal> <month> July </month> <year> 1991, </year> <pages> pp. 702-711. </pages>
Reference-contexts: This allows binary antirandom sequences to be decoded into actual inputs. fl This research was supported by a BMDO funded project monitored by ONR 1 Test data selection has been regarded as an important part of testing software <ref> [8, 9, 10, 11] </ref>. Researchers have identified valuable guidelines for selecting test data. We can divide the input space into multi-dimensional subdomains such that the software responds to all the points within the same subdomain in a similar way. <p> We here propose an encoding approach which will convert the problem to constructing binary antirandom sequences. The approach is based on domain and partition analysis and the concepts of equivalence partitioning, revealing subdomains <ref> [11] </ref> and homogeneous subdomains [19]. The technique partially encodes an input into binary, such that sample points desired can be obtained by automatic translation.
Reference: [12] <author> R. Hamlet and R. Taylor, </author> <title> "Partition testing does not inspire confidence," Proc. 2nd Work. Soft. Testing, Verification and Analysis, </title> <month> July </month> <year> 1988, </year> <pages> pp. 206-215. </pages>
Reference: [13] <author> K.C. Tai, </author> <title> "Condition based software testing strategies," </title> <booktitle> Proc. COMPSAC '90, </booktitle> <month> Oct. </month> <year> 1990, </year> <pages> pp. 564-569. </pages>
Reference-contexts: Also since the program behavior for the different points within such a subdomain is likely to be strongly correlated, testing for just a single internal point in the subdomain may be adequate in many cases. Testing for boolean conditions is discussed in <ref> [13, 14] </ref>. Automated test generation has been considered by some researchers [14, 15]. The problem of reducing the number of tests by limiting the total number of combinations to be considered by using orthogonal arrays is given in [16, 17].
Reference: [14] <author> E. Weyuker, T. Goradia and A. Singh, </author> <title> "Automatically generating test data from a boolean specification," </title> <journal> IEEE Trans. Soft. Eng., </journal> <month> May </month> <year> 1994, </year> <pages> pp. 353-363. </pages>
Reference-contexts: Also since the program behavior for the different points within such a subdomain is likely to be strongly correlated, testing for just a single internal point in the subdomain may be adequate in many cases. Testing for boolean conditions is discussed in <ref> [13, 14] </ref>. Automated test generation has been considered by some researchers [14, 15]. The problem of reducing the number of tests by limiting the total number of combinations to be considered by using orthogonal arrays is given in [16, 17]. <p> Testing for boolean conditions is discussed in [13, 14]. Automated test generation has been considered by some researchers <ref> [14, 15] </ref>. The problem of reducing the number of tests by limiting the total number of combinations to be considered by using orthogonal arrays is given in [16, 17]. This approach, although not considered here, can be used in conjunction with the scheme proposed here.
Reference: [15] <author> A. von Mayrhauser, J. Walls and R. Mraz, </author> <title> "Testing applications using domain based testing and sleuth," </title> <booktitle> Proc. </booktitle> <address> ISSRE, </address> <month> Nov. </month> <year> 1994, </year> <pages> pp. 206-215. </pages>
Reference-contexts: Testing for boolean conditions is discussed in [13, 14]. Automated test generation has been considered by some researchers <ref> [14, 15] </ref>. The problem of reducing the number of tests by limiting the total number of combinations to be considered by using orthogonal arrays is given in [16, 17]. This approach, although not considered here, can be used in conjunction with the scheme proposed here.
Reference: [16] <author> R. Mandl, </author> <title> "Orthogonal Latin square: An application of experiment design to compiler testing," </title> <journal> Comm. ACM, </journal> <month> Oct. </month> <year> 1985, </year> <pages> pp. 1054-1058. </pages>
Reference-contexts: Testing for boolean conditions is discussed in [13, 14]. Automated test generation has been considered by some researchers [14, 15]. The problem of reducing the number of tests by limiting the total number of combinations to be considered by using orthogonal arrays is given in <ref> [16, 17] </ref>. This approach, although not considered here, can be used in conjunction with the scheme proposed here. One major difference between the two approaches is that antirandom testing will test for all input interactions provided sufficient test vectors are applied. It is thus applicable for ultra-high reliability software also.
Reference: [17] <author> D.M. Cohen, S.R. Dalal, A. Kajla and G.C. Patton, </author> <title> "The automatic efficient test generator (AETG) system," </title> <booktitle> Proc. </booktitle> <address> ISSRE, </address> <month> Nov. </month> <year> 1994, </year> <pages> pp. 303-309. </pages>
Reference-contexts: Testing for boolean conditions is discussed in [13, 14]. Automated test generation has been considered by some researchers [14, 15]. The problem of reducing the number of tests by limiting the total number of combinations to be considered by using orthogonal arrays is given in <ref> [16, 17] </ref>. This approach, although not considered here, can be used in conjunction with the scheme proposed here. One major difference between the two approaches is that antirandom testing will test for all input interactions provided sufficient test vectors are applied. It is thus applicable for ultra-high reliability software also.
Reference: [18] <author> W.R. </author> <title> Hamming, "Error detecting and error correcting codes," </title> <journal> Bell Sys. Tech. Journal, </journal> <month> Apr. </month> <year> 1950, </year> <pages> pp. 147-160. </pages>
Reference-contexts: Definition: Distance is a measure of how different two vectors t i and t j are. Here we use two measures of distance defined below. Definition: Hamming Distance (HD) <ref> [18] </ref> is the number of bits in which two binary vectors differ. It is not defined for vectors containing continuous values.
Reference: [19] <author> J.D. Musa, </author> <title> "Operational Profiles in Software Reliability Engineering," </title> <journal> IEEE Software, </journal> <month> March </month> <year> 1993, </year> <pages> pp. 14-32. </pages>
Reference-contexts: We here propose an encoding approach which will convert the problem to constructing binary antirandom sequences. The approach is based on domain and partition analysis and the concepts of equivalence partitioning, revealing subdomains [11] and homogeneous subdomains <ref> [19] </ref>. The technique partially encodes an input into binary, such that sample points desired can be obtained by automatic translation. These sample points, termed checkpoints here, are strategically selected such that they are likely to span most types of variations in the program behavior with respect to each input.
References-found: 19

