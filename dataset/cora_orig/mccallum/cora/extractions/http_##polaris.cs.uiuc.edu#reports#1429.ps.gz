URL: http://polaris.cs.uiuc.edu/reports/1429.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/polaris/rep2.html
Root-URL: http://www.cs.uiuc.edu
Title: Demand-driven, Symbolic Range Propagation  
Author: William Blume Rudolf Eigenmann 
Address: West Lafayette, Indiana  
Affiliation: Hewlett Packard, Cupertino, California Purdue University,  
Abstract: To effectively parallelize real programs, parallelizing compilers need powerful symbolic analysis techniques [13, 6]. In previous work we have introduced an algorithm called range propagation [4] that provides such capabilities. Range propagation has been implemented in Po-laris, a parallelizing Fortran compiler being developed at the University of Illinois [7]. Because the algorithm is relatively expensive and several compilation passes make use of it, we have studied opportunities for increasing its efficiency. In this paper we present an algorithm that provides range analysis on-demand. We have implemented this algorithm in Polaris as well, and have measured its effectiveness.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> H. Abelson, G. J. Sussman, and J. Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> The MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: We compute the control and data ranges separately because control ranges are much cheaper to compute. The top-level function get range for the demand-driven range propagation algorithm is shown in can reuse these results rather than recomputing. This storing and reusing values to avoid recomputation is called memoization <ref> [17, 1] </ref>. The algorithm simply checks whether the range for the given variable and statement already exists in R, computes and stores the range if it does not, then returns the range.
Reference: 2. <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1986. </year>
Reference-contexts: Vertex u is the immediate dominator of vertex v if and only if u strictly dominates v and there is no vertex w such that u strictly dominates w and w strictly dominates v. See Aho, Sethi, and Ullman <ref> [2] </ref> for more details on these definitions. Similar dominance relationships can be defined for the control-flow edges in the program.
Reference: 3. <author> M. Berry, D. Chen, P. Koss, D. Kuck, L. Pointer, S. Lo, Y. Pang, R. Roloff, A. Sameh, E. Clementi, S. Chin, D. Schneider, G. Fox, P. Messina, D. Walker, C. Hsiung, J. Schwarzmeier, K. Lue, S. Orszag, F. Seidl, O. Johnson, G. Swanson, R. Goodrum, and J. Martin. </author> <title> The Perfect Club Benchmarks: Effective Performance Evalution of Supercomputers. </title> <booktitle> Int'l. Journal of Supercomputer Applications, Fall 1989, </booktitle> <volume> 3(3) </volume> <pages> 5-40, </pages> <month> Fall </month> <year> 1989. </year>
Reference-contexts: The code column displays the name of each Fortran code examined. These codes were taken from the Perfect Benchmarks, which is a suite of Fortran 77 programs representing applications in a number of areas in engineering and scientific computing <ref> [3] </ref>. The Number of lines column displays the number of lines in each code after being converted into SSA form. The Computing control ranges and Computing data ranges columns give the total times taken to compute every control and data range respectively in each of the codes.
Reference: 4. <author> William Blume and Rudolf Eigenmann. </author> <title> Symbolic Range Propagation. </title> <booktitle> Proceedings of the 9th International Parallel Processing Symposium, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: After simplifying, d = [1 : 1]. Now, the lower bound of d is an integer greater than zero, and hence x fl y 1 &gt; y. The techniques used to determine the substitution order of variables and to simplify the substituted ranges are described in <ref> [4] </ref>. One issue is that the compiler usually modifies the program between different applications of range propagation, requiring repeated recomputations of the program's ranges. Because of this, a significant fraction of a compiler's execution time can be spent performing range propagation.
Reference: 5. <author> William Blume and Rudolf Eigenmann. </author> <title> The Range Test: A Dependence Test for Symbolic, Non-linear Expressions. </title> <booktitle> Proceedings of Supercomputing '94, </booktitle> <address> Washington D.C., </address> <month> November </month> <year> 1994, </year> <pages> pages 528-537. </pages>
Reference-contexts: On the other hand, range propagation was orignally designed for dependence testing. Our symbolic data dependence test, called the Range Test <ref> [5] </ref>, often needs to compare expressions that are more complicated and dissimilar to each other than the expressions compared for array privatization. Because of this, more constraint information and a more powerful expression comparator is needed to compare such expressions.
Reference: 6. <author> William Blume and Rudolf Eigenmann. </author> <title> An Overview of Symbolic Analysis Techniques Needed for the Effective Parallelization of the Perfect Benchmarks. </title> <booktitle> Proceedings of the 1994 International Conference on Parallel Processing, </booktitle> <address> pages II233 II238, </address> <month> August, </month> <year> 1994. </year> <month> 14 </month>
Reference: 7. <author> William Blume, Rudolf Eigenmann, Keith Faigin, John Grout, Jay Hoeflinger, David Padua, Paul Petersen, Bill Pottenger, Lawrence Rauchwerger, Peng Tu, and Stephen Weatherford. </author> <title> Polaris: Improving the Effectiveness of Parallelizing Compilers. </title> <booktitle> Proceedings of the Seventh Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Ithaca, New York; also: </address> <booktitle> Lecture Notes in Computer Science 892, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pages 141-154, </pages> <month> August </month> <year> 1994. </year>
Reference: 8. <author> William Joseph Blume. </author> <title> Symbolic Analysis Techniques for Effective Automatice Parallelization. </title> <type> PhD thesis, </type> <institution> Univ. of Illinois at Urbana-Champaign, Cntr. for Supercomputing Res. & Dev., </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: The control range of a statement is simply the control range that holds after passing through that statement's immediately dominating control-flow edge, (i.e., icdom (s)). As discussed in <ref> [8] </ref>, this is more efficient but slightly more conservative than intersecting the control ranges of all incoming control flow edges. If the statement does not have an immediately dominating control-flow edge, then its result is the unconstrained range [1 : 1]. <p> It calls the function compute data ranges phase twice in order to compute the ranges of -functions in two phases: the widening phase and the narrowing phase. These two phases are discussed in <ref> [8] </ref>. Briefly, the widening phase applies some conservative operations in order to guarantee termination of the algorithm in loop situations. The narrowing phase follows for regaining some of the accuracy lost by the widening operations. In Section 4.4 we will illustrate this mechanism in an example. <p> The replacement scheme comes at the cost of some inaccuracy. We can regain some of this accuracy by "undoing" the replacement at the end of the range computation. This is further discussed in <ref> [8] </ref>. 4.4 Example 3 By construction of -functions, each argument of a -function corresponds to one of the entering control-flow edges of the -function's basic block. 8 c Assert: n 8 i 1 = n 100 CONTINUE i 2 = (i 1 ; i 4 ) IF (x (i 2 ) <p> Instead, they are deleted from the data-flow graph on the exit of get data range. Any node that uses the data range of a poisoned node is itself poisoned. 6 Performance The time complexities of the algorithms are discussed in <ref> [8] </ref>. In this paper we show that our demand-driven range propagation algorithm is efficient for real programs, even when called many times. All optimizations described in the previous sections have been implemented in these algorithms.
Reference: 9. <author> Franc~ois Bourdoncle. </author> <title> Abstract Debugging of Higher-Order Imperative Languages. </title> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 46-55, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Bourdoncle <ref> [9] </ref> greatly improves the accuracy of the integer range propagation algorithm by Harrison, through the use of abstract interpretation [10]. However, Bour-doncle's algorithm does not generate symbolic ranges.
Reference: 10. <author> Partrick Cousot and Radhia Cousot. </author> <title> Abstract Interpretation: A unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> Proceedings of the 4th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: Range propagation inludes two algorithms that depend on each other: one that can compare expressions and one that can derive upper and lower bounds of variables from the program text. The latter uses abstract interpretation <ref> [10] </ref> for analyzing the program. As an example, suppose the data-dependence test wishes to compare the expression x fl y 1 with y. Upper and lower bound analysis has determined that x = [y : 10] and y = [1 : 1]. <p> Bourdoncle [9] greatly improves the accuracy of the integer range propagation algorithm by Harrison, through the use of abstract interpretation <ref> [10] </ref>. However, Bour-doncle's algorithm does not generate symbolic ranges. Neither Harrison's nor Bourdoncle's algorithms are demand-driven, nor do they use a sparse data-flow representation of a program, such as SSA form or definition-use chains. Cousot and Halbwachs [11] present a different method to compute and propagate constraints through a program.
Reference: 11. <author> Patrick Cousot and Nicolas Halbwachs. </author> <title> Automatic Discovery of Linear Restraints Among Variables of a Program. </title> <booktitle> In Proceedings of the 5th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-97, </pages> <year> 1978. </year>
Reference-contexts: However, Bour-doncle's algorithm does not generate symbolic ranges. Neither Harrison's nor Bourdoncle's algorithms are demand-driven, nor do they use a sparse data-flow representation of a program, such as SSA form or definition-use chains. Cousot and Halbwachs <ref> [11] </ref> present a different method to compute and propagate constraints through a program. In their technique, sets of constraints between variables are represented as a convex polyhedron in the n-space of variable values.
Reference: 12. <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently Computing Static Single Assignment Form and the Control Dependence Graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: An efficient algorithm to translate programs into SSA form is described in <ref> [12] </ref>.
Reference: 13. <author> Mohammad Haghighat and Constantine Polychronopoulos. </author> <title> Symbolic Dependence Analysis for High-Performance Parallelizing Compilers. </title> <booktitle> Parallel and Distributed Computing: Advances in Languages and Compilers for Parallel Processing, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <pages> pages 310-330, </pages> <year> 1991. </year>
Reference: 14. <author> D. Harel. </author> <title> A linear time algorithm for finding dominators in a flow graph and related problems. </title> <booktitle> Proceedings of the 17th ACM Symposium of Theory of Computing, </booktitle> <pages> pages 185-194, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: The function icdom (s) will represent the immediate dominating control-flow edge of the statement s. A linear-time algorithm for computing dominators has been developed by Harel <ref> [14] </ref>. Alternatively, one can approximate the dominating control-flow edges from the statement dominators, which must be computed when translating into SSA form.
Reference: 15. <author> William H. Harrison. </author> <title> Compiler Analysis of the Value Ranges for Variables. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-3(3):243-250, </volume> <month> May </month> <year> 1977. </year>
Reference-contexts: up of only symbolic constants and enclosing loop indices, and one only needs to know the constraints imposed upon these loop indices and symbolic constants to compare or compute the ranges of such expressions. 7 Related work The idea for representing program constraints as ranges was first proposed by Harrison <ref> [15] </ref> for array bounds checking and program verification. Bourdoncle [9] greatly improves the accuracy of the integer range propagation algorithm by Harrison, through the use of abstract interpretation [10]. However, Bour-doncle's algorithm does not generate symbolic ranges.
Reference: 16. <author> Matthew S. Hecht and Jeffrey D. Ullman. </author> <title> A Simple Algorithm for Global Data Flow Analysis Problems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 4(4) </volume> <pages> 519-532, </pages> <month> December </month> <year> 1975. </year>
Reference-contexts: The algorithm quits only when the work list becomes empty. To minimize the number of updates performed upon the graph's nodes, the nodes in work list should be ordered by a topological order of the data-flow graph, ignoring any back-edges, (that is, in rPOSTORDER, as described in <ref> [16] </ref>). The data range (r) of a node x, whose variable's (v) definition contains a -function, is computed by unioning ([) the ranges of the arguments of its -function. The semantics of the union operator is given in Table 1.
Reference: 17. <author> D. Maydan, J. Hennessy, and M. Lam. </author> <title> Efficient and exact data dependence analysis. </title> <booktitle> In SIGPLAN NOTICES: Proceedings of the ACM SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <address> Toronto, Ontario, Canada, </address> <month> June 26-28, </month> <pages> pages 1-14. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: We compute the control and data ranges separately because control ranges are much cheaper to compute. The top-level function get range for the demand-driven range propagation algorithm is shown in can reuse these results rather than recomputing. This storing and reusing values to avoid recomputation is called memoization <ref> [17, 1] </ref>. The algorithm simply checks whether the range for the given variable and statement already exists in R, computes and stores the range if it does not, then returns the range.
Reference: 18. <author> Peng Tu and David Padua. </author> <title> Gated SSA-Based Demand-Driven Symbolic Analysis for Parallelizing Compilers. </title> <booktitle> Proceedings of the 9th ACM International Conference on Supercomputing, </booktitle> <address> Barcelona, Spain, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: Because of this, their algorithm can be much less efficient than ours. Also, their convex hull representation prevents one from creating a demand-driven version of their algorithm that is not overly complex. Tu and Padua <ref> [18] </ref> also present a demand-driven, symbolic expression comparison and constraint propagation technique, based on an extension of SSA called gated SSA form. Their technique compares 13 expressions by repeatedly substituting variables with their constant symbolic values until the two ex-pressions differ by only an integer constant.
Reference: 19. <author> Peng Tu and David Padua. </author> <title> Automatic Array Privatization. </title> <editor> In Utpal BanerjeeDavid Gelern-terAlex NicolauDavid Padua, editor, </editor> <booktitle> Proc. Sixth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Portland, OR. </address> <booktitle> Lecture Notes in Computer Science., </booktitle> <volume> volume 768, </volume> <pages> pages 500-521, </pages> <month> August 12-14, </month> <year> 1993. </year> <title> This article was processed using the L a T E X macro package with LLNCS style 15 </title>
Reference-contexts: The differences between our algorithm and theirs are mainly due to the two different applications. Their algorithm was designed to compare the bounds of array sections for array privatization <ref> [19] </ref>. Because conditional array definitions and uses occur in a significant fraction of important loop nests, flow-sensitive analysis is essential to successfully perform such comparisons. This capability was included in their algorithm.
References-found: 19

