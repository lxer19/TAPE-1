URL: http://www.cs.ucla.edu/~zaniolo/cz/shortoverview.ps
Refering-URL: http://www.cs.ucla.edu/~zaniolo/cz/ZanioloPapers.html
Root-URL: http://www.cs.ucla.edu
Title: Deductive Databases: A short Overview for The Handbook of Data Mining and Knowledge Discovery  
Keyword: Database Languages, Rule Languages, Logic and Databases, Databases and Knowledge Bases, Expressive Power of Query Languages, Recursive Queries, Forward Chaining, Fixpoint Computation, Magic Sets, NonMonotonic Reasoning, Stratified Negation.  
Affiliation: CS Department, UCLA,  
Note: Oxford University Press By: Carlo Zaniolo,  August 1998.  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> S. Abiteboul, R. Hull, and V. Vianu. </author> <booktitle> Foundations of Databases.Addison-Wesley, </booktitle> <address> Reading, MA, </address> <year> 1995. </year>
Reference-contexts: Thus, database query languages must be relational complete, i.e., at least as expressive as these two. Commercial languages, such as SQL, QUEL, and QBE are based on relational calculi and are relationally complete (they also support set aggregates not expressible in relational algebra <ref> [1, 60] </ref>). Now, nonrecursive safe Datalog is equivalent to relational algebra, and its expressive power can be extended by allowing recursion and complex records [53, 1, 60]. Recursion is required to express many useful queries, such as transitive closure [10]. <p> Now, nonrecursive safe Datalog is equivalent to relational algebra, and its expressive power can be extended by allowing recursion and complex records <ref> [53, 1, 60] </ref>. Recursion is required to express many useful queries, such as transitive closure [10]. <p> In fact, programs with stratified negation can express all queries that can be computed in polynomial time in the size of the database <ref> [1] </ref>. This conclusion, however, only holds under the assumption that the underlying universe is totally ordered|as needed, e.g., to compute the count aggregate by enumerating the elements of a set one by one. A better solution is the nondeterministic construct choice that enforces functional dependencies in derived relations [46, 15].
Reference: [2] <author> R. Jr Bayardo, W. Bohrer, R. Brice et al. </author> <title> InfoSleuth: Agent-Based Semantic Integration of Information in Open and Dynamic Environment. </title> <booktitle> In Proceedings of the International ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pp. 195-206, </pages> <year> 1997. </year>
Reference-contexts: Systems and Applications Many interesting applications of deductive databases have been reported, ranging from the rapid prototyping of information systems and scientific databases, to data cleaning and stock market analysis [30, 51, 37]. More recent applications include web-searching [25], integration and mediation of heterogeneous information systems <ref> [32, 2] </ref>, and GUI generation [17]. Deductive database languages support rapid prototyping via rules that express both domain knowledge (either user-encoded or discovered) and database searches; these traits make them well-suited for data mining and knowledge discovery applications [50, 23, 3, 48, 49, 52, 16].
Reference: [3] <author> J. Han, Y. Huang, N. Cercone, and Y. Fu. </author> <title> Intelligent Query Answering by Knowledge Discovery Techniques, </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 8(3) </volume> <pages> 373-390, </pages> <year> 1996. </year>
Reference-contexts: Deductive database languages support rapid prototyping via rules that express both domain knowledge (either user-encoded or discovered) and database searches; these traits make them well-suited for data mining and knowledge discovery applications <ref> [50, 23, 3, 48, 49, 52, 16] </ref>. The main obstacle remains the lack of commercial systems. Indeed, while powerful prototypes are available [11, 36, 54], they have not yet matured into commercial systems. These and other research prototypes are surveyed in [38]. 3
Reference: [4] <author> J. M. Hellerstein, P. J. Haas, and H. J. Wang, </author> <title> "Online Aggregation." </title> <booktitle> In Proceedings of ACM-SIGMOD Conference on Management of Data, </booktitle> <month> May </month> <year> 1997. </year>
Reference-contexts: A better solution is the nondeterministic construct choice that enforces functional dependencies in derived relations [46, 15]. While choice can be defined using negation under stable model semantics, it generates monotonic transformations; thus, it can be freely used in recursive rules [61], along with online aggregates <ref> [4] </ref>, since these can be expressed using choice [61]. In general, aggregates are nonmonotonic and subject to the same restrictions as negation (modulo exceptions [57, 41]).
Reference: [5] <author> H. Aly and Z. M. Ozsoyoglu. </author> <title> Synchronized Counting Method. </title> <booktitle> In Proceedings IEEE International Conference on Data Engineering, </booktitle> <pages> pp. 366-373, </pages> <year> 1989. </year>
Reference-contexts: g (W; a), then this naive specialization approach does work and a left-to-right linear rule transformation method is used instead [31], producing the following program: tc (X; a) g (X; a): More sophisticated methods are needed for more general recursive rules, and many methods have been proposed for different situations <ref> [34, 19, 43, 58, 44, 20, 21, 5, 18] </ref>; the most robust and widely used method is magic sets [7, 9, 42].
Reference: [6] <author> I. Balbin and K. Ramamohanarao. </author> <title> A Generalization of the Differential Approach to Recursive Query Evaluation. </title> <journal> Journal of Logic Programming 4(3) </journal> <pages> 259-262, </pages> <year> 1987. </year>
Reference-contexts: For example, in the transitive closure computation of tc, only the tc produced in the last step need be considered in the following step. Symbolic differentiation techniques are used by the compiler to realize this improvement, yielding the differential fixpoint (a.k.a. seminaive fixpoint) computation <ref> [8, 6, 45] </ref>. The differential fixpoint computes efficiently all pairs of nodes in the closure.
Reference: [7] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. D. Ullman. </author> <title> Magic Sets and Other Strange Ways to Implement Logic Programs. </title> <booktitle> In Proceedings ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pp. 1-15, </pages> <year> 1986. </year>
Reference-contexts: instead [31], producing the following program: tc (X; a) g (X; a): More sophisticated methods are needed for more general recursive rules, and many methods have been proposed for different situations [34, 19, 43, 58, 44, 20, 21, 5, 18]; the most robust and widely used method is magic sets <ref> [7, 9, 42] </ref>. As in the previous examples, a different execution plan is generated for each query|actually, for each template tc bf describing the goal tc (a; X) and all goals where the first argument is bound and the second is free.
Reference: [8] <author> R. Bayer. </author> <title> Query Evaluation and Recursion in Deductive Database Systems. </title> <type> Technical report, </type> <institution> Technical University of Munich, Germany, </institution> <year> 1985. </year>
Reference-contexts: For example, in the transitive closure computation of tc, only the tc produced in the last step need be considered in the following step. Symbolic differentiation techniques are used by the compiler to realize this improvement, yielding the differential fixpoint (a.k.a. seminaive fixpoint) computation <ref> [8, 6, 45] </ref>. The differential fixpoint computes efficiently all pairs of nodes in the closure.
Reference: [9] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the Power of Magic. </title> <booktitle> In Proceedings ACM SIGACT-SIGMOD Symposium on Principles of Database Systems, </booktitle> <pages> pp. 269-283, </pages> <year> 1987. </year>
Reference-contexts: instead [31], producing the following program: tc (X; a) g (X; a): More sophisticated methods are needed for more general recursive rules, and many methods have been proposed for different situations [34, 19, 43, 58, 44, 20, 21, 5, 18]; the most robust and widely used method is magic sets <ref> [7, 9, 42] </ref>. As in the previous examples, a different execution plan is generated for each query|actually, for each template tc bf describing the goal tc (a; X) and all goals where the first argument is bound and the second is free.
Reference: [10] <author> A. Chandra and D. Harel. </author> <title> Computable Queries for Relational Data Bases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2), </volume> <year> 1980. </year>
Reference-contexts: Now, nonrecursive safe Datalog is equivalent to relational algebra, and its expressive power can be extended by allowing recursion and complex records [53, 1, 60]. Recursion is required to express many useful queries, such as transitive closure <ref> [10] </ref>.
Reference: [11] <author> D. Chimenti, R. Gamboa, R. Krishnamurthy, S. Naqvi, S.Tsur and C. Zan-iolo. </author> <title> The LDL System Prototype. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1), </volume> <month> 76-90 </month> <year> (1990). </year> <note> A web demo of LDL++ is available at http://www.cs.ucla.edu/ldl. </note>
Reference-contexts: The rules are treated as program, and thus compiled and executed against the database which contains a time-varying set of facts described by a time-invariant schema. The target for this compilation is code 2 based on relational algebra operators or "get next tuple" kind of operators <ref> [11, 33, 60] </ref>. Sophisticated compilation techniques are used for recursion. The naive fixpoint computation consists of repeated firing of the rules till saturation, using a table to memorize new results without duplicates. This forward-chaining, bottom-up computation is then optimized by minimizing repetitions between steps. <p> The main obstacle remains the lack of commercial systems. Indeed, while powerful prototypes are available <ref> [11, 36, 54] </ref>, they have not yet matured into commercial systems. These and other research prototypes are surveyed in [38]. 3
Reference: [12] <author> E. F. Codd. </author> <title> A Relational Model of Data for Large Shared Data Banks. </title> <journal> Communications of the Association of Computing Machinery 13(6) </journal> <pages> 377-387, </pages> <year> 1970. </year>
Reference-contexts: Introduction Relational databases, which support simple logic-based query languages [13] were proposed in early 70s <ref> [12] </ref>. Initially considered too theoretical and not conducive to efficient implementation or commercial payoff, by mid 80s they had become a stellar success motivating research into more powerful query and data manipulation languages.
Reference: [13] <author> E. F. Codd. </author> <title> Relational Completeness of Database Sublanguages. </title> <editor> In R. Rustin (ed.), </editor> <title> Data Base Systems. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1972. </year> <month> 4 </month>
Reference-contexts: Introduction Relational databases, which support simple logic-based query languages <ref> [13] </ref> were proposed in early 70s [12]. Initially considered too theoretical and not conducive to efficient implementation or commercial payoff, by mid 80s they had become a stellar success motivating research into more powerful query and data manipulation languages. <p> Language Design and Semantics The notion of relational completeness is based on the fact that relational algebra expressions and safe (tuple or domain) relational calculus formulae are equivalent in terms of expressive power <ref> [13] </ref>. Thus, database query languages must be relational complete, i.e., at least as expressive as these two. Commercial languages, such as SQL, QUEL, and QBE are based on relational calculi and are relationally complete (they also support set aggregates not expressible in relational algebra [1, 60]).
Reference: [14] <author> M. Gelfond and V. Lifschitz. </author> <title> The Stable Model Semantics for Logic Program--ming. </title> <booktitle> Proceedigns of Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pp. 1070-1080, </pages> <address> Seattle, WA, </address> <year> 1988. </year>
Reference-contexts: Negation in databases and in knowledge bases is nonmonotonic because negative information is not stored explicitly, rather, it is derived by default [27] under a closed-world assumption [39, 28]. Moreover, the notion of stable models <ref> [14] </ref> that provides a sound declarative semantics for programs with negated goals cannot be used directly as operational semantics because of its exponential complexity [47, 27].
Reference: [15] <author> F. Giannotti, D. Pedreschi, D. Sacca, and C. Zaniolo. </author> <title> Non-Determinism in Deductive Databases. </title> <editor> In C. Delobel, M. Kifer, and Y. Masunaga (eds.), </editor> <booktitle> Proceedings Deductive and Object-Oriented Databases, Second International Conference, DOOD'91, </booktitle> <pages> pp. 129-146, </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: This conclusion, however, only holds under the assumption that the underlying universe is totally ordered|as needed, e.g., to compute the count aggregate by enumerating the elements of a set one by one. A better solution is the nondeterministic construct choice that enforces functional dependencies in derived relations <ref> [46, 15] </ref>. While choice can be defined using negation under stable model semantics, it generates monotonic transformations; thus, it can be freely used in recursive rules [61], along with online aggregates [4], since these can be expressed using choice [61].
Reference: [16] <author> F. Giannotti, G. Manco, M. Nanni, D. Pedreschi, </author> <title> Using Deduction for Intelligent Data Analysis, </title> <type> CNUCE-CNR technical report, </type> <institution> Pisa, Italy, </institution> <year> 1998. </year>
Reference-contexts: Deductive database languages support rapid prototyping via rules that express both domain knowledge (either user-encoded or discovered) and database searches; these traits make them well-suited for data mining and knowledge discovery applications <ref> [50, 23, 3, 48, 49, 52, 16] </ref>. The main obstacle remains the lack of commercial systems. Indeed, while powerful prototypes are available [11, 36, 54], they have not yet matured into commercial systems. These and other research prototypes are surveyed in [38]. 3
Reference: [17] <author> N. Goyal, C. Hoch, R. Krishnamurthy, B. Meckler and M. Suckow. </author> <title> Is GUI programming a database research problem? Proc. </title> <booktitle> Int. ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pp. 517-528, </pages> <year> 1996. </year>
Reference-contexts: More recent applications include web-searching [25], integration and mediation of heterogeneous information systems [32, 2], and GUI generation <ref> [17] </ref>. Deductive database languages support rapid prototyping via rules that express both domain knowledge (either user-encoded or discovered) and database searches; these traits make them well-suited for data mining and knowledge discovery applications [50, 23, 3, 48, 49, 52, 16]. The main obstacle remains the lack of commercial systems.
Reference: [18] <author> S. Greco and C. Zaniolo. </author> <title> Optimization of Linear Logic Programs Using Counting Methods. </title> <booktitle> In Proceedings International Conference on Extending Database Technology, </booktitle> <year> 1992. </year>
Reference-contexts: g (W; a), then this naive specialization approach does work and a left-to-right linear rule transformation method is used instead [31], producing the following program: tc (X; a) g (X; a): More sophisticated methods are needed for more general recursive rules, and many methods have been proposed for different situations <ref> [34, 19, 43, 58, 44, 20, 21, 5, 18] </ref>; the most robust and widely used method is magic sets [7, 9, 42].
Reference: [19] <author> L. Henschen and S. Naqvi. </author> <title> On Compiling Queries in Recursive First-Order Databases. </title> <journal> Journal of the ACM, </journal> <volume> 31(1) </volume> <pages> 47-85, </pages> <year> 1984. </year>
Reference-contexts: g (W; a), then this naive specialization approach does work and a left-to-right linear rule transformation method is used instead [31], producing the following program: tc (X; a) g (X; a): More sophisticated methods are needed for more general recursive rules, and many methods have been proposed for different situations <ref> [34, 19, 43, 58, 44, 20, 21, 5, 18] </ref>; the most robust and widely used method is magic sets [7, 9, 42].
Reference: [20] <author> R. Haddad and J. F. Naughton. </author> <title> Counting Methods for Cyclic Relations. </title> <booktitle> In Proceedings ACM SIGACT-SIGMOD-SIGART Principles of Database Systems, </booktitle> <pages> pp. 333-340, </pages> <year> 1988. </year>
Reference-contexts: g (W; a), then this naive specialization approach does work and a left-to-right linear rule transformation method is used instead [31], producing the following program: tc (X; a) g (X; a): More sophisticated methods are needed for more general recursive rules, and many methods have been proposed for different situations <ref> [34, 19, 43, 58, 44, 20, 21, 5, 18] </ref>; the most robust and widely used method is magic sets [7, 9, 42].
Reference: [21] <author> J. Han. </author> <title> Selection of Processing Strategies for Different Recursive Queries. </title> <booktitle> In Proceedings International Conference on Data and Knowledge Bases, </booktitle> <address> Jerusalem, Israel, </address> <year> 1988. </year>
Reference-contexts: g (W; a), then this naive specialization approach does work and a left-to-right linear rule transformation method is used instead [31], producing the following program: tc (X; a) g (X; a): More sophisticated methods are needed for more general recursive rules, and many methods have been proposed for different situations <ref> [34, 19, 43, 58, 44, 20, 21, 5, 18] </ref>; the most robust and widely used method is magic sets [7, 9, 42].
Reference: [22] <author> D. Kemp, K. Ramamohanarao, and P. Stuckey. </author> <title> ELS Programs and the Efficient Evaluation of Non-Stratified Programs by Transformation to ELS. </title> <booktitle> In Proceedings Int. Conf. on Deductive and Object-Oriented Databases: DOOD95, </booktitle> <pages> pp. 91-108, </pages> <address> Singapore, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Important classes of programs with nonstratified negation where stable models can be computed in polynomial time include locally stratified programs [35], whose well-founded models [56, 40] can be derived by an alternating fixpoint procedure [55], and XY-stratified programs <ref> [59, 22] </ref>. Most Datalog languages also support functors, which are used to (i) store complex objects in the database, and (ii) in recursive rules to process structures of unbound length, as to achieve Turing completeness in the language. Extensions of complex objects are supported in deductive object-oriented databases [24].
Reference: [23] <author> B. Kero, L. Russell, S. Tsur and W.M. Shen, </author> <title> An overview of Data Mining Technologies, DOOD95 Workshop on the Integration of Knowlege Discovery Deductive and Object Oriented Databases, </title> <address> Singapore, </address> <year> 1995. </year>
Reference-contexts: Deductive database languages support rapid prototyping via rules that express both domain knowledge (either user-encoded or discovered) and database searches; these traits make them well-suited for data mining and knowledge discovery applications <ref> [50, 23, 3, 48, 49, 52, 16] </ref>. The main obstacle remains the lack of commercial systems. Indeed, while powerful prototypes are available [11, 36, 54], they have not yet matured into commercial systems. These and other research prototypes are surveyed in [38]. 3
Reference: [24] <author> M. Kifer. </author> <title> Deductive and Object-Oriented Data Languages|A Quest for Integration. </title> <booktitle> Proceedings Int. Conf. on Deductive and Object-Oriented Databases, DOOD'95, </booktitle> <pages> pp. 187-212, </pages> <year> 1995. </year>
Reference-contexts: Most Datalog languages also support functors, which are used to (i) store complex objects in the database, and (ii) in recursive rules to process structures of unbound length, as to achieve Turing completeness in the language. Extensions of complex objects are supported in deductive object-oriented databases <ref> [24] </ref>. Compilation and Optimization Unlike Prolog, deductive databases draw a sharp distinction between facts (extensional information) and rules (intensional information) [28]. The rules are treated as program, and thus compiled and executed against the database which contains a time-varying set of facts described by a time-invariant schema.
Reference: [25] <author> L.V.S. Lakshmanan, F. Sadri, and I. Subramanian. </author> <title> A Declarative Approach to Querying and Retsructuring the World-Wide-Web. </title> <booktitle> Post-ICDE Workshop on Research Issues in Data Engineering (RIDE'96). </booktitle> <address> New Orleans, </address> <month> February </month> <year> 1996. </year> <month> 5 </month>
Reference-contexts: Systems and Applications Many interesting applications of deductive databases have been reported, ranging from the rapid prototyping of information systems and scientific databases, to data cleaning and stock market analysis [30, 51, 37]. More recent applications include web-searching <ref> [25] </ref>, integration and mediation of heterogeneous information systems [32, 2], and GUI generation [17].
Reference: [26] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: Thus T can be first applied to the empty set, and then repeatedly on the result of the last application until no new tc-tuples are generated. The value of tc at this point is equal to the least fixpoint of T and contains the transitive closure of g <ref> [26, 60] </ref>. The great increase in expressive power brought by recursion is not without a price, since the fixpoint semantics and other "natural" semantics no longer hold when negation or other nonmonotonic constructs are used in the program [26, 27]. <p> The great increase in expressive power brought by recursion is not without a price, since the fixpoint semantics and other "natural" semantics no longer hold when negation or other nonmonotonic constructs are used in the program <ref> [26, 27] </ref>. Negation in databases and in knowledge bases is nonmonotonic because negative information is not stored explicitly, rather, it is derived by default [27] under a closed-world assumption [39, 28]. <p> The differential fixpoint computes efficiently all pairs of nodes in the closure. But when only nodes connected to a given node a are of interest (i.e., the query goal is tc (a; W)), then a top-down search, such as Prolog's backward chaining, can be much more efficient <ref> [26] </ref>. Deductive databases address this problem by rule-rewriting methods that transform the original program into one that is specialized for this specific query.
Reference: [27] <author> V. W. Marek and M. Truszczynski. </author> <title> Nonmonotonic Logic. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: The great increase in expressive power brought by recursion is not without a price, since the fixpoint semantics and other "natural" semantics no longer hold when negation or other nonmonotonic constructs are used in the program <ref> [26, 27] </ref>. Negation in databases and in knowledge bases is nonmonotonic because negative information is not stored explicitly, rather, it is derived by default [27] under a closed-world assumption [39, 28]. <p> Negation in databases and in knowledge bases is nonmonotonic because negative information is not stored explicitly, rather, it is derived by default <ref> [27] </ref> under a closed-world assumption [39, 28]. Moreover, the notion of stable models [14] that provides a sound declarative semantics for programs with negated goals cannot be used directly as operational semantics because of its exponential complexity [47, 27]. <p> Moreover, the notion of stable models [14] that provides a sound declarative semantics for programs with negated goals cannot be used directly as operational semantics because of its exponential complexity <ref> [47, 27] </ref>. Therefore, the identification of classes of Datalog programs whose stable models can be computed in polynomial time has been the focus of much research in deductive databases [60].
Reference: [28] <author> J. Minker. </author> <title> Logic and Databases: A 20 Year Retrospective. </title> <editor> In D. Pedreschi and C. Zaniolo (eds.), </editor> <booktitle> Proceedings International Workshop on Logic in Databases (LID'96), </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <pages> pp. 5-52, </pages> <year> 1996. </year>
Reference-contexts: Negation in databases and in knowledge bases is nonmonotonic because negative information is not stored explicitly, rather, it is derived by default [27] under a closed-world assumption <ref> [39, 28] </ref>. Moreover, the notion of stable models [14] that provides a sound declarative semantics for programs with negated goals cannot be used directly as operational semantics because of its exponential complexity [47, 27]. <p> Extensions of complex objects are supported in deductive object-oriented databases [24]. Compilation and Optimization Unlike Prolog, deductive databases draw a sharp distinction between facts (extensional information) and rules (intensional information) <ref> [28] </ref>. The rules are treated as program, and thus compiled and executed against the database which contains a time-varying set of facts described by a time-invariant schema. The target for this compilation is code 2 based on relational algebra operators or "get next tuple" kind of operators [11, 33, 60].
Reference: [29] <author> K. Morris, J. D. Ullman, and A. Van Gelder. </author> <title> Design Overview of the NAIL! System. </title> <booktitle> In Proceedings International Conference on Logic Programming, </booktitle> <pages> pp. 554-568, </pages> <publisher> Springer-Verlag, LNCS 225, </publisher> <address> New York, </address> <year> 1986. </year>
Reference: [30] <author> S. Naqvi and S. Tsur. </author> <title> A Logic Language for Data and Knowledge Bases. </title> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Systems and Applications Many interesting applications of deductive databases have been reported, ranging from the rapid prototyping of information systems and scientific databases, to data cleaning and stock market analysis <ref> [30, 51, 37] </ref>. More recent applications include web-searching [25], integration and mediation of heterogeneous information systems [32, 2], and GUI generation [17].
Reference: [31] <author> J. F. Naughton. </author> <title> Compiling Separable Recursions. </title> <booktitle> In Proceedings ACM International Conference on Management of Data, </booktitle> <pages> pp. 312-319, </pages> <year> 1988. </year>
Reference-contexts: However, if the query goal is g (W; a), then this naive specialization approach does work and a left-to-right linear rule transformation method is used instead <ref> [31] </ref>, producing the following program: tc (X; a) g (X; a): More sophisticated methods are needed for more general recursive rules, and many methods have been proposed for different situations [34, 19, 43, 58, 44, 20, 21, 5, 18]; the most robust and widely used method is magic sets [7, 9,
Reference: [32] <author> Y. Papakonstantinou, H. Garcia-Molina, J.D. Ullman. MedMaker: </author> <title> A Mediation System Based on Declarative Specifications. </title> <booktitle> Proceedings IEEE Int. Conference on Data Engineering, </booktitle> <pages> pp. 132-141, </pages> <year> 1996. </year>
Reference-contexts: Systems and Applications Many interesting applications of deductive databases have been reported, ranging from the rapid prototyping of information systems and scientific databases, to data cleaning and stock market analysis [30, 51, 37]. More recent applications include web-searching [25], integration and mediation of heterogeneous information systems <ref> [32, 2] </ref>, and GUI generation [17]. Deductive database languages support rapid prototyping via rules that express both domain knowledge (either user-encoded or discovered) and database searches; these traits make them well-suited for data mining and knowledge discovery applications [50, 23, 3, 48, 49, 52, 16].
Reference: [33] <author> G. Phipps, M. A. Derr, and K. A. Ross. </author> <title> Glue-Nail!: A Deductive Database System. </title> <booktitle> In Proceedings International ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pp. 308-317, </pages> <year> 1991. </year>
Reference-contexts: The rules are treated as program, and thus compiled and executed against the database which contains a time-varying set of facts described by a time-invariant schema. The target for this compilation is code 2 based on relational algebra operators or "get next tuple" kind of operators <ref> [11, 33, 60] </ref>. Sophisticated compilation techniques are used for recursion. The naive fixpoint computation consists of repeated firing of the rules till saturation, using a table to memorize new results without duplicates. This forward-chaining, bottom-up computation is then optimized by minimizing repetitions between steps. <p> Compilers use these bound/free adornments to select recursive methods and execution orders for rule goals as to ensure safe and optimized executions <ref> [33, 53, 60] </ref>. Systems and Applications Many interesting applications of deductive databases have been reported, ranging from the rapid prototyping of information systems and scientific databases, to data cleaning and stock market analysis [30, 51, 37].
Reference: [34] <author> F. C. N. Pereira and D. H. D. Warren. </author> <title> Parsing as Deduction. </title> <booktitle> In Proceedings Annual Meeting Association for Computational Linguistics, </booktitle> <pages> pp. 137-144, </pages> <year> 1983. </year>
Reference-contexts: g (W; a), then this naive specialization approach does work and a left-to-right linear rule transformation method is used instead [31], producing the following program: tc (X; a) g (X; a): More sophisticated methods are needed for more general recursive rules, and many methods have been proposed for different situations <ref> [34, 19, 43, 58, 44, 20, 21, 5, 18] </ref>; the most robust and widely used method is magic sets [7, 9, 42].
Reference: [35] <author> T. C. Przymusinski. </author> <title> On the Declarative and Procedural Semantics of Stratified Deductive Databases. </title> <editor> In J. W. Minker (ed.), </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pp. 193-216, </pages> <publisher> Morgan Kaufman, </publisher> <address> San Francisco, CA, </address> <year> 1988. </year>
Reference-contexts: The notion of stratified programs (where negation can be used on predicates defined in lower strata, but not on the predicate defined by the same rule) represents a milestone in this effort <ref> [35] </ref>. In fact, programs with stratified negation can express all queries that can be computed in polynomial time in the size of the database [1]. <p> In general, aggregates are nonmonotonic and subject to the same restrictions as negation (modulo exceptions [57, 41]). Important classes of programs with nonstratified negation where stable models can be computed in polynomial time include locally stratified programs <ref> [35] </ref>, whose well-founded models [56, 40] can be derived by an alternating fixpoint procedure [55], and XY-stratified programs [59, 22].
Reference: [36] <author> R. Ramakrishnan, D. Srivastava, S. Sudanshan, and P. Seshadri. </author> <title> Implementation of the CORAL Deductive Database System. </title> <booktitle> In Proceedings of the International ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pp. 167-176, </pages> <year> 1993. </year>
Reference-contexts: The main obstacle remains the lack of commercial systems. Indeed, while powerful prototypes are available <ref> [11, 36, 54] </ref>, they have not yet matured into commercial systems. These and other research prototypes are surveyed in [38]. 3
Reference: [37] <author> R. Ramakrishnan. </author> <title> Applications of Logic Databases. </title> <publisher> Kluwer Academic, Norwell, </publisher> <address> MA, </address> <year> 1995. </year>
Reference-contexts: Systems and Applications Many interesting applications of deductive databases have been reported, ranging from the rapid prototyping of information systems and scientific databases, to data cleaning and stock market analysis <ref> [30, 51, 37] </ref>. More recent applications include web-searching [25], integration and mediation of heterogeneous information systems [32, 2], and GUI generation [17].
Reference: [38] <author> R. Ramakrishnan and J. D. Ullman. </author> <title> A Survey of Research in Deductive Database Systems. </title> <journal> Journal of Logic Programming 23(2) </journal> <pages> 125-149, </pages> <year> 1995. </year>
Reference-contexts: The main obstacle remains the lack of commercial systems. Indeed, while powerful prototypes are available [11, 36, 54], they have not yet matured into commercial systems. These and other research prototypes are surveyed in <ref> [38] </ref>. 3
Reference: [39] <author> R. Reiter. </author> <title> On Closed World Data Bases. </title> <editor> In J. W. Minker and H. Gallaire (eds.), </editor> <booktitle> Logic and Databases, </booktitle> <pages> pp. 55-76, </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year> <month> 6 </month>
Reference-contexts: Negation in databases and in knowledge bases is nonmonotonic because negative information is not stored explicitly, rather, it is derived by default [27] under a closed-world assumption <ref> [39, 28] </ref>. Moreover, the notion of stable models [14] that provides a sound declarative semantics for programs with negated goals cannot be used directly as operational semantics because of its exponential complexity [47, 27].
Reference: [40] <author> K. A. Ross. </author> <title> Modular Stratification and Magic Sets for Datalog Programs with Negation. </title> <journal> Journal of ACM 41(6) </journal> <pages> 1216-1266, </pages> <year> 1994. </year>
Reference-contexts: In general, aggregates are nonmonotonic and subject to the same restrictions as negation (modulo exceptions [57, 41]). Important classes of programs with nonstratified negation where stable models can be computed in polynomial time include locally stratified programs [35], whose well-founded models <ref> [56, 40] </ref> can be derived by an alternating fixpoint procedure [55], and XY-stratified programs [59, 22].
Reference: [41] <author> K. A. Ross and Yehoshua Sagiv, </author> <title> "Monotonic Aggregation in Deductive Database", </title> <journal> JCSS, </journal> <volume> 54(1), </volume> <month> 79-97 </month> <year> (1997) </year>
Reference-contexts: In general, aggregates are nonmonotonic and subject to the same restrictions as negation (modulo exceptions <ref> [57, 41] </ref>). Important classes of programs with nonstratified negation where stable models can be computed in polynomial time include locally stratified programs [35], whose well-founded models [56, 40] can be derived by an alternating fixpoint procedure [55], and XY-stratified programs [59, 22].
Reference: [42] <author> D. Sacca and C. Zaniolo. </author> <title> Implementation of Recursive Queries for a Data Language based on Pure Horn Logic. </title> <booktitle> Proceedings Fourth Int. Conference on Logic Programming, </booktitle> <pages> pp. 104-135, </pages> <publisher> MIT Press, </publisher> <address> Cambridge. </address>
Reference-contexts: instead [31], producing the following program: tc (X; a) g (X; a): More sophisticated methods are needed for more general recursive rules, and many methods have been proposed for different situations [34, 19, 43, 58, 44, 20, 21, 5, 18]; the most robust and widely used method is magic sets <ref> [7, 9, 42] </ref>. As in the previous examples, a different execution plan is generated for each query|actually, for each template tc bf describing the goal tc (a; X) and all goals where the first argument is bound and the second is free.
Reference: [43] <author> D. Sacca and C. Zaniolo. </author> <title> Magic Counting Methods. </title> <booktitle> In Proceedings ACM SIG-MOD International Conference on Management of Data, </booktitle> <pages> pp. 49-59, </pages> <year> 1987. </year>
Reference-contexts: g (W; a), then this naive specialization approach does work and a left-to-right linear rule transformation method is used instead [31], producing the following program: tc (X; a) g (X; a): More sophisticated methods are needed for more general recursive rules, and many methods have been proposed for different situations <ref> [34, 19, 43, 58, 44, 20, 21, 5, 18] </ref>; the most robust and widely used method is magic sets [7, 9, 42].
Reference: [44] <author> D. Sacca and C. Zaniolo. </author> <title> The Generalized Counting Method of Recursive Logic Queries for Databases. </title> <booktitle> Theoretical Computer Science, </booktitle> <pages> pp. 187-220, </pages> <year> 1988. </year>
Reference-contexts: g (W; a), then this naive specialization approach does work and a left-to-right linear rule transformation method is used instead [31], producing the following program: tc (X; a) g (X; a): More sophisticated methods are needed for more general recursive rules, and many methods have been proposed for different situations <ref> [34, 19, 43, 58, 44, 20, 21, 5, 18] </ref>; the most robust and widely used method is magic sets [7, 9, 42].
Reference: [45] <author> D. Sacca and C. Zaniolo. </author> <title> Differential Fixpoint Methods and Stratification of Logic Programs. </title> <booktitle> In Proceedings International Conference on Data and Knowledge Bases, </booktitle> <year> 1988. </year>
Reference-contexts: For example, in the transitive closure computation of tc, only the tc produced in the last step need be considered in the following step. Symbolic differentiation techniques are used by the compiler to realize this improvement, yielding the differential fixpoint (a.k.a. seminaive fixpoint) computation <ref> [8, 6, 45] </ref>. The differential fixpoint computes efficiently all pairs of nodes in the closure.
Reference: [46] <author> D. Sacca and C. Zaniolo. </author> <title> Stable Models and Non-Determinism in Logic Programs with Negation. </title> <booktitle> In Proceedings ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <year> 1990. </year>
Reference-contexts: This conclusion, however, only holds under the assumption that the underlying universe is totally ordered|as needed, e.g., to compute the count aggregate by enumerating the elements of a set one by one. A better solution is the nondeterministic construct choice that enforces functional dependencies in derived relations <ref> [46, 15] </ref>. While choice can be defined using negation under stable model semantics, it generates monotonic transformations; thus, it can be freely used in recursive rules [61], along with online aggregates [4], since these can be expressed using choice [61].
Reference: [47] <author> J. S. Schlipf, </author> <title> A Survey of Complexity and Undecidability Results in Logic Programming, </title> <booktitle> Proc. Workshop on Structural Complexity and Recursion-Theoretic Methods in Logic Programming, </booktitle> <year> 1993, </year> <month> pp.143-164. </month>
Reference-contexts: Moreover, the notion of stable models [14] that provides a sound declarative semantics for programs with negated goals cannot be used directly as operational semantics because of its exponential complexity <ref> [47, 27] </ref>. Therefore, the identification of classes of Datalog programs whose stable models can be computed in polynomial time has been the focus of much research in deductive databases [60].
Reference: [48] <author> W. Shen, K.Ong, B. Mitbander and C. Zaniolo, </author> <title> Metaqueries for Data Mining, Chapter 15 of Advances in Knowledge Discovery and Data Mining, </title> <editor> U. M. Fayyad et al (eds.), </editor> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: Deductive database languages support rapid prototyping via rules that express both domain knowledge (either user-encoded or discovered) and database searches; these traits make them well-suited for data mining and knowledge discovery applications <ref> [50, 23, 3, 48, 49, 52, 16] </ref>. The main obstacle remains the lack of commercial systems. Indeed, while powerful prototypes are available [11, 36, 54], they have not yet matured into commercial systems. These and other research prototypes are surveyed in [38]. 3
Reference: [49] <author> W. M. Shen and Bing Leng. </author> <title> A Metapattern-Based Automated Discovery Loop for Integrated Data Mining. </title> <journal> IEEE Transactions on Data and Knowledge Engineering, </journal> <volume> vol. 8, no. 6, </volume> <pages> pp. 898-910, </pages> <year> 1996. </year>
Reference-contexts: Deductive database languages support rapid prototyping via rules that express both domain knowledge (either user-encoded or discovered) and database searches; these traits make them well-suited for data mining and knowledge discovery applications <ref> [50, 23, 3, 48, 49, 52, 16] </ref>. The main obstacle remains the lack of commercial systems. Indeed, while powerful prototypes are available [11, 36, 54], they have not yet matured into commercial systems. These and other research prototypes are surveyed in [38]. 3
Reference: [50] <author> S. Tsur. </author> <title> Data Dredging. </title> <journal> Data Engineering Bulletin, </journal> <volume> 13(4): </volume> <month> 58-63 </month> <year> (1990) </year>
Reference-contexts: Deductive database languages support rapid prototyping via rules that express both domain knowledge (either user-encoded or discovered) and database searches; these traits make them well-suited for data mining and knowledge discovery applications <ref> [50, 23, 3, 48, 49, 52, 16] </ref>. The main obstacle remains the lack of commercial systems. Indeed, while powerful prototypes are available [11, 36, 54], they have not yet matured into commercial systems. These and other research prototypes are surveyed in [38]. 3
Reference: [51] <author> S. Tsur. </author> <title> Deductive Databases in Action. </title> <booktitle> In Proceedings ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 142-154, </pages> <year> 1991. </year>
Reference-contexts: Systems and Applications Many interesting applications of deductive databases have been reported, ranging from the rapid prototyping of information systems and scientific databases, to data cleaning and stock market analysis <ref> [30, 51, 37] </ref>. More recent applications include web-searching [25], integration and mediation of heterogeneous information systems [32, 2], and GUI generation [17].
Reference: [52] <author> D. Tsur, J. D. Ullman, S. Abiteboul, C. Clifton, R. Motwani, and S. Nestorov. </author> <title> Query Flocks: A Generalization of Association-Rule Mining. </title> <booktitle> Proc. 1998 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pp. 1-12, </pages> <month> June </month> <year> 1998. </year>
Reference-contexts: Deductive database languages support rapid prototyping via rules that express both domain knowledge (either user-encoded or discovered) and database searches; these traits make them well-suited for data mining and knowledge discovery applications <ref> [50, 23, 3, 48, 49, 52, 16] </ref>. The main obstacle remains the lack of commercial systems. Indeed, while powerful prototypes are available [11, 36, 54], they have not yet matured into commercial systems. These and other research prototypes are surveyed in [38]. 3
Reference: [53] <author> J. D. Ullman. </author> <booktitle> Principles of Data and Knowledge-Base Systems, </booktitle> <volume> volume 3. </volume> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1988. </year> <month> 7 </month>
Reference-contexts: A Prolog-like language, called Datalog, became the focus of this research, owing to the kinship of relational calculi and Prolog's Horn clauses <ref> [53, 60] </ref>, and the surge of interest in rule-based languages for expert systems of the mid-80s. <p> Now, nonrecursive safe Datalog is equivalent to relational algebra, and its expressive power can be extended by allowing recursion and complex records <ref> [53, 1, 60] </ref>. Recursion is required to express many useful queries, such as transitive closure [10]. <p> Compilers use these bound/free adornments to select recursive methods and execution orders for rule goals as to ensure safe and optimized executions <ref> [33, 53, 60] </ref>. Systems and Applications Many interesting applications of deductive databases have been reported, ranging from the rapid prototyping of information systems and scientific databases, to data cleaning and stock market analysis [30, 51, 37].
Reference: [54] <author> J. Vaghani, K. Ramamohanarao, D. B. Kemp, et. al. </author> <title> The Aditi Deductive Database System. </title> <journal> The VLDB Journal, </journal> <volume> 3(2), </volume> <pages> pp. </pages> <month> 245-288 </month> <year> (1994). </year>
Reference-contexts: The main obstacle remains the lack of commercial systems. Indeed, while powerful prototypes are available <ref> [11, 36, 54] </ref>, they have not yet matured into commercial systems. These and other research prototypes are surveyed in [38]. 3
Reference: [55] <author> A. Van Gelder. </author> <title> The Alternating Fixpoint of Logic Programming with Negation. </title> <booktitle> In Proceedings ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pp. 1-10, </pages> <year> 1989. </year>
Reference-contexts: Important classes of programs with nonstratified negation where stable models can be computed in polynomial time include locally stratified programs [35], whose well-founded models [56, 40] can be derived by an alternating fixpoint procedure <ref> [55] </ref>, and XY-stratified programs [59, 22]. Most Datalog languages also support functors, which are used to (i) store complex objects in the database, and (ii) in recursive rules to process structures of unbound length, as to achieve Turing completeness in the language.
Reference: [56] <author> A. Van Gelder, K. A. Ross, and J. S. Schlipf. </author> <title> The Well-Founded Semantics for General Logic Programs. </title> <journal> Journal of ACM 38 </journal> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: In general, aggregates are nonmonotonic and subject to the same restrictions as negation (modulo exceptions [57, 41]). Important classes of programs with nonstratified negation where stable models can be computed in polynomial time include locally stratified programs [35], whose well-founded models <ref> [56, 40] </ref> can be derived by an alternating fixpoint procedure [55], and XY-stratified programs [59, 22].
Reference: [57] <author> A. Van Gelder. </author> <booktitle> Foundations of Aggregations in Deductive Databases In Proc. of the Int. Conf. On Deductive and Object-Oriented databases, </booktitle> <year> 1993. </year>
Reference-contexts: In general, aggregates are nonmonotonic and subject to the same restrictions as negation (modulo exceptions <ref> [57, 41] </ref>). Important classes of programs with nonstratified negation where stable models can be computed in polynomial time include locally stratified programs [35], whose well-founded models [56, 40] can be derived by an alternating fixpoint procedure [55], and XY-stratified programs [59, 22].
Reference: [58] <author> L. Vielle. </author> <title> Recursive Axioms in Deductive Databases: The Query-Subquery Approach. </title> <booktitle> In Proceedings International Conference on Expert Database Systems, </booktitle> <pages> pp. 253-268, </pages> <year> 1986. </year>
Reference-contexts: g (W; a), then this naive specialization approach does work and a left-to-right linear rule transformation method is used instead [31], producing the following program: tc (X; a) g (X; a): More sophisticated methods are needed for more general recursive rules, and many methods have been proposed for different situations <ref> [34, 19, 43, 58, 44, 20, 21, 5, 18] </ref>; the most robust and widely used method is magic sets [7, 9, 42].
Reference: [59] <author> C. Zaniolo, N. Arni, and K. Ong. </author> <title> Negation and Aggregates in Recursive Rules: the LDL++ Approach. </title> <booktitle> In Proceedings International Conference on Deductive and Object-Oriented Databases, </booktitle> <address> DOOD'93, </address> <year> 1993. </year>
Reference-contexts: Important classes of programs with nonstratified negation where stable models can be computed in polynomial time include locally stratified programs [35], whose well-founded models [56, 40] can be derived by an alternating fixpoint procedure [55], and XY-stratified programs <ref> [59, 22] </ref>. Most Datalog languages also support functors, which are used to (i) store complex objects in the database, and (ii) in recursive rules to process structures of unbound length, as to achieve Turing completeness in the language. Extensions of complex objects are supported in deductive object-oriented databases [24].
Reference: [60] <author> C. Zaniolo, S. Ceri, C. Faloutsos, R. Snodgrass, V.S. Subrahmanian and R. Zicari, </author> <title> Advanced Database Systems, </title> <publisher> Morgan Kaufmann, </publisher> <year> 1997. </year>
Reference-contexts: A Prolog-like language, called Datalog, became the focus of this research, owing to the kinship of relational calculi and Prolog's Horn clauses <ref> [53, 60] </ref>, and the surge of interest in rule-based languages for expert systems of the mid-80s. <p> Thus, database query languages must be relational complete, i.e., at least as expressive as these two. Commercial languages, such as SQL, QUEL, and QBE are based on relational calculi and are relationally complete (they also support set aggregates not expressible in relational algebra <ref> [1, 60] </ref>). Now, nonrecursive safe Datalog is equivalent to relational algebra, and its expressive power can be extended by allowing recursion and complex records [53, 1, 60]. Recursion is required to express many useful queries, such as transitive closure [10]. <p> Now, nonrecursive safe Datalog is equivalent to relational algebra, and its expressive power can be extended by allowing recursion and complex records <ref> [53, 1, 60] </ref>. Recursion is required to express many useful queries, such as transitive closure [10]. <p> Thus T can be first applied to the empty set, and then repeatedly on the result of the last application until no new tc-tuples are generated. The value of tc at this point is equal to the least fixpoint of T and contains the transitive closure of g <ref> [26, 60] </ref>. The great increase in expressive power brought by recursion is not without a price, since the fixpoint semantics and other "natural" semantics no longer hold when negation or other nonmonotonic constructs are used in the program [26, 27]. <p> Therefore, the identification of classes of Datalog programs whose stable models can be computed in polynomial time has been the focus of much research in deductive databases <ref> [60] </ref>. The notion of stratified programs (where negation can be used on predicates defined in lower strata, but not on the predicate defined by the same rule) represents a milestone in this effort [35]. <p> The rules are treated as program, and thus compiled and executed against the database which contains a time-varying set of facts described by a time-invariant schema. The target for this compilation is code 2 based on relational algebra operators or "get next tuple" kind of operators <ref> [11, 33, 60] </ref>. Sophisticated compilation techniques are used for recursion. The naive fixpoint computation consists of repeated firing of the rules till saturation, using a table to memorize new results without duplicates. This forward-chaining, bottom-up computation is then optimized by minimizing repetitions between steps. <p> Compilers use these bound/free adornments to select recursive methods and execution orders for rule goals as to ensure safe and optimized executions <ref> [33, 53, 60] </ref>. Systems and Applications Many interesting applications of deductive databases have been reported, ranging from the rapid prototyping of information systems and scientific databases, to data cleaning and stock market analysis [30, 51, 37].
Reference: [61] <author> C. Zaniolo and H. </author> <title> Wang Logic-Based User-Defined Aggregates for the Next Generation of Database Systems. In The Logic Programming Paradigm: Current Trends and Future Directions. K.R. </title> <editor> Apt, V. Marek, M. Truszczynski, D.S. Warren (eds.), </editor> <publisher> Springer Verlag, </publisher> <year> 1998. </year> <month> 8 </month>
Reference-contexts: A better solution is the nondeterministic construct choice that enforces functional dependencies in derived relations [46, 15]. While choice can be defined using negation under stable model semantics, it generates monotonic transformations; thus, it can be freely used in recursive rules <ref> [61] </ref>, along with online aggregates [4], since these can be expressed using choice [61]. In general, aggregates are nonmonotonic and subject to the same restrictions as negation (modulo exceptions [57, 41]). <p> While choice can be defined using negation under stable model semantics, it generates monotonic transformations; thus, it can be freely used in recursive rules <ref> [61] </ref>, along with online aggregates [4], since these can be expressed using choice [61]. In general, aggregates are nonmonotonic and subject to the same restrictions as negation (modulo exceptions [57, 41]).
References-found: 61

