URL: http://www.cs.indiana.edu/l/www/pub/pmaciel/TECHREPORT/TR403.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/pub/pmaciel/TECHREPORT/
Root-URL: http://www.cs.indiana.edu
Title: Interactive Rendering of Complex 3D Models in Pipelined Graphics Architectures  
Note: May 23, 1994  
Abstract: Paulo W. C. Maciel Technical Report Department of Computer Science Indiana University, Bloomington 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Akeley. </author> <title> Reality engine graphics. </title> <journal> Computer Graphics, </journal> <pages> pages 109-116, </pages> <year> 1993. </year>
Reference-contexts: The reason these criteria are antagonic is that while an interactive system needs to achieve interactive frame rates of at least than 10 frames per second, realistic-looking models can contain hundreds of millions of polygons, far more than currently available workstations can render in an interactive fashion <ref> [1, 11, 15] </ref>. Current workstations are able to render one million polygons per second. Although this is an impressive number, at an interactive frame rate of 30 frames per second, it leaves us with a maximum of about 30K triangles per scene. <p> Not only state-of-the-art hardware such as the SGI ONYX and RealityEngine <ref> [1] </ref> workstations (and workstations from other vendors such as Sun) use this pipelined architecture but also highly parallel architectures such as PixelFlow [15] use the same pipeline concept. 3.2.1 Pipeline Architecture Assuming future machines will make use of a graphics pipeline we present a generalized rendering system model that for our
Reference: [2] <author> P. K. Allen. </author> <title> A framework for implementing multi-sensor robotic tasks. </title> <booktitle> Proceedings of the Image Understanding Workshop, </booktitle> <volume> 1 </volume> <pages> 392-398, </pages> <month> February </month> <year> 1987. </year>
Reference-contexts: This requires an abstract design for our model hierarchy, i.e. we need to define a collection of abstract classes that are suitable for our particular walk-through application. More specifically, we will design a black-box framework as in <ref> [14, 2] </ref> in which we will specify the main abstractions together with their interfaces which will provide the desired behaviour of our application. Figure 4.1 shows the two main abstractions of our framework.
Reference: [3] <author> D. H. Ballard and C. M. Brown. </author> <title> Computer Vision. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1982. </year>
Reference-contexts: This takes into consideration that objects in the periphery of the field of view are not seen by the eyes with full detail compared to the ones close to the line of sight (See <ref> [3] </ref>). * The object's relative speed with respect to the viewpoint. <p> sections, we describe a possible implementations for 2 of the virtual functions described namely, Draw and Benefit functions that explain the usage of the 'TMBox' and 'RotTM-Square' classes. 4.2.1 A Draw Function Implementation For clusters that represent a single conceptual object and similar to what is done in computer vision <ref> [3] </ref> where objects have to be classified under certain parameters and stored in a database that is used to match seen objects in order to recognize them, given model objects can be stored and indexed by parameters such as shape and symmetry with respect to a main axis.
Reference: [4] <author> M. F. Deering. </author> <title> Making virtual reality more real: Experience with the virtual portal. </title> <booktitle> Graphics Interface, </booktitle> <pages> pages 219-225, </pages> <year> 1993. </year>
Reference-contexts: For the sake of comparison, the IU campus database currently contains 70K polygons (and is unfinished) it represents most of its buildings (some of them just boxes) without limestone details, sidewalks, cars, people, trees 1 and so on. From <ref> [4] </ref> we get the quote: "Initial results show the expected: many industrial virtual reality applications need one to two orders of magnitude of improvement in display performance". This is actually a conservative statement.
Reference: [5] <author> M. F. Deering and S. R. Nelson. Leo: </author> <title> A system for cost effective 3d shaded graphics. </title> <journal> Computer Graphics, </journal> <pages> pages 101,108, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: This mathematical mapping is ideally suited for hardware implementation and many workstations nowadays have this feature implemented in their hardwares. As memory prices go down and cpu power go up, we can expect to see in the near future increases in the number of low cost machines (such as <ref> [5] </ref>) providing hardware textures and for those which already have this capability increasing texture memory size and rendering speeds. 3.2.3 Real-Time Features In order to truly maintain a user-specified frame rate the cpu in which the application is running has to be relatively free of interrupts.
Reference: [6] <author> J. D. Foley, A. van Dam, S. K. Feiner, and J. F. Hughes. </author> <title> Computer Graphics: </title> <booktitle> Principles and Practice. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: This also apply to moving objects since sampling problems <ref> [6] </ref> will alias its image depending on its position from frame to frame. Therefore, objects need to be described at different levels of detail (LOD) to reduce their rendering time. Figure 2.1 shows a book case and a book represented each at 3 LODs. <p> the future in terms of the speed of their components, it seems unlikely that the pipelined architecture of the graphics engine of these machines will cease to exist in the near future since it is based on the conceptual rendering pipeline that is described in any introductory computer graphics book <ref> [6, 24] </ref>.
Reference: [7] <author> T. A. Funkhouser and C. H. Sequin. </author> <title> Adaptive display algorithm for interactive frame rates during visualization of complex virtual environmnets. </title> <journal> Computer Graphics, </journal> <pages> pages 247-254, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Although this strategy reduces the amount of polygons that have to be rendered in a scene, since the selection of LOD is static, the frame time can be arbitrarily large <ref> [7] </ref>, since as the observer moves, many more objects can be visible than the machine hardware can render in real-time. This is static selection mechanism is also not good in situations where lots of objects become visible/larger/slower, like in an aircraft landing situation. <p> To correct the problems caused by static and feedback LOD selection mechanisms, namely, arbitrarily large and non-uniform frame rates, Funkhouser <ref> [7] </ref> presented an algorithm that adjust image quality adaptively to maintain a user specified frame rate based on heuristics that estimate the computational "Cost" of rendering a scene versus its "Benefit" (the "quality" of the picture). <p> Based on the Graphics Library Programming Tools and Techniques [20] document from Silicon Graphics Inc., and similar to what was done in <ref> [7] </ref>, we derive a model of a generalized rendering system that this research is based on. This rendering system is represented as a pipeline with 3 functional stages as shown in figure 3.3. The first stage runs the application program that sends graphics requests to the graphics subsystem. <p> This cost function can be determined empirically by selecting geometric and raster operations and then rendering objects in the model. In <ref> [7] </ref> these functions are defined prior to the walk-through of the environment and computed in real-time. Instead of doing that we build a cost table in a pre-processing phase and just look it up in real-time.
Reference: [8] <author> T. A. Funkhouser, C. H. Sequin, and S. Teller. </author> <title> Management of large amounts of data in interactive building walkthroughs. </title> <journal> Journal, </journal> <pages> pages 11-20, </pages> <year> 1992. </year> <title> Get name of the journal. </title> <type> 43 </type>
Reference-contexts: Examples of this technique can be found in <ref> [8, 16] </ref>. Funkhouser et al.[8], describe a technique for managing large amounts of data during interactive walk-through of an architectural model that uses spatial subdivision, visibility analysis and objects at multiple levels of detail to reduce the number of polygons to render per scene. <p> The last one, represents a regularizing term that amounts to placing on each edge of the mesh a spring of rest length zero and some spring constant. This guarantees the existence of a minimum for the energy function. 2.2.2 LOD Selection In <ref> [8] </ref>, a display database representing objects at different LODs is described. <p> Two methods have been used: One uses geometric interpolation as in Turk [23] and the other uses hardware dependent color blending as described in [19] and used in <ref> [25, 8] </ref>. Both approaches present problems. <p> When this happens, clusters tend to appear and disappear from the scene causing a somewhat annoying switch of representations. While this is a common problem in systems that use LODs <ref> [8] </ref> to represent objects this problem can be eliminated by taking advantage of the temporal coherence that exists from frame to frame. One final issue relates to a limitation of the system that is tied to the hardware in which the program runs.
Reference: [9] <author> E. B. Goldstein. </author> <title> Sensation and Perception. </title> <publisher> Wadsworth Publishing Co., </publisher> <address> Belmont, California, </address> <year> 1980. </year>
Reference-contexts: Nevertheless, if parts of the houses have texture maps then the details of the texture might only be observable on the closer one. A benefit heuristic should also incorporate the fact that if some entity represents a group of objects then according to Gestalt psychology <ref> [9] </ref> the meaning conveyed by that representation may be more then merely the 'addition' of the meanings conveyed by each one of the objects alone, that is, the whole conveys more information then the sum of its parts. This can be exemplified in figure 3.6. <p> Gestalt psychology can give us some insights on this subject. In order to determine how your perception will be given certain stimulus conditions, psychologists came up with rules that they called "laws of organization"(see <ref> [9] </ref>). There are four of them: Simplicity, Similarity, Nearness and Good Continuation. The first one, simplicity, says that every stimulus pattern is seen in such a way that the resulting structure is as simple as possible.
Reference: [10] <author> R. Hall, M. Bussan, P. Georgiades, and D. P. Greenberg. </author> <title> A testbed for architectural modelling. </title> <booktitle> Eurographics' 91, </booktitle> <pages> pages 47-57, 91. </pages>
Reference: [11] <author> C. B. Harrell and F. Fouladi. </author> <title> Graphics rendering architecture for a hight performance desktop workstation. </title> <journal> Computer Graphics, </journal> <pages> pages 93-100, </pages> <year> 1993. </year>
Reference-contexts: The reason these criteria are antagonic is that while an interactive system needs to achieve interactive frame rates of at least than 10 frames per second, realistic-looking models can contain hundreds of millions of polygons, far more than currently available workstations can render in an interactive fashion <ref> [1, 11, 15] </ref>. Current workstations are able to render one million polygons per second. Although this is an impressive number, at an interactive frame rate of 30 frames per second, it leaves us with a maximum of about 30K triangles per scene.
Reference: [12] <author> H. Hopper, T. DeRose, T. Duchamp, J. McDonald, and W. Stuetsle. </author> <title> Surface reconstruction from unorganized points. </title> <journal> Computer Graphics, </journal> <pages> pages 71-78, </pages> <year> 1992. </year>
Reference-contexts: For generation of polygonal representations at different LODs of a real object from sample points obtained from a laser ranger device, Hoppe et al. devised a mesh generation method that can fit a mesh of arbitrary topological type to a set of data points <ref> [12] </ref>, and a mesh optimization method [13] that improves the mesh's fit and reduces its number of faces, recovering sharp edges and corners common in objects such as machine parts.
Reference: [13] <author> H. Hopper, T. DeRose, T. Duchamp, J. McDonald, and W. Stuetsle. </author> <title> Mesh optimization. </title> <journal> Computer Graphics, </journal> <pages> pages 19-26, </pages> <year> 1993. </year>
Reference-contexts: For generation of polygonal representations at different LODs of a real object from sample points obtained from a laser ranger device, Hoppe et al. devised a mesh generation method that can fit a mesh of arbitrary topological type to a set of data points [12], and a mesh optimization method <ref> [13] </ref> that improves the mesh's fit and reduces its number of faces, recovering sharp edges and corners common in objects such as machine parts.
Reference: [14] <author> R. E. Johnson and B. Foote. </author> <title> Designing reuseable classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <month> August </month> <year> 1991. </year>
Reference-contexts: This requires an abstract design for our model hierarchy, i.e. we need to define a collection of abstract classes that are suitable for our particular walk-through application. More specifically, we will design a black-box framework as in <ref> [14, 2] </ref> in which we will specify the main abstractions together with their interfaces which will provide the desired behaviour of our application. Figure 4.1 shows the two main abstractions of our framework.
Reference: [15] <author> S. Molnar, J. Eyles, and J. Poulton. Pixelflow: </author> <title> High-speed rendering using image composition. </title> <journal> Computer Graphics, </journal> <pages> pages 231-240, </pages> <year> 1992. </year>
Reference-contexts: The reason these criteria are antagonic is that while an interactive system needs to achieve interactive frame rates of at least than 10 frames per second, realistic-looking models can contain hundreds of millions of polygons, far more than currently available workstations can render in an interactive fashion <ref> [1, 11, 15] </ref>. Current workstations are able to render one million polygons per second. Although this is an impressive number, at an interactive frame rate of 30 frames per second, it leaves us with a maximum of about 30K triangles per scene. <p> Not only state-of-the-art hardware such as the SGI ONYX and RealityEngine [1] workstations (and workstations from other vendors such as Sun) use this pipelined architecture but also highly parallel architectures such as PixelFlow <ref> [15] </ref> use the same pipeline concept. 3.2.1 Pipeline Architecture Assuming future machines will make use of a graphics pipeline we present a generalized rendering system model that for our purposes, can be applied to a wide variety of graphics workstations.
Reference: [16] <author> M. K. Ned Greene and G. Miller. </author> <title> Hierarchical z-buffer visibility. </title> <journal> Computer Graphics, </journal> <pages> pages 231-238, </pages> <year> 1993. </year>
Reference-contexts: Examples of this technique can be found in <ref> [8, 16] </ref>. Funkhouser et al.[8], describe a technique for managing large amounts of data during interactive walk-through of an architectural model that uses spatial subdivision, visibility analysis and objects at multiple levels of detail to reduce the number of polygons to render per scene.
Reference: [17] <author> H. R. Schiffman. </author> <title> Sensation and Perception an Integrated Approach. </title> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Lines tend to be seen in such a way as to follow the smoothest path as illustrated on figure 3.11. Schifman <ref> [17] </ref> generalizes this law by saying that it is a special case of the general configuration principle that states an organizing tendency that encompasses other characteristics such as common fate, closure and symmetry.
Reference: [18] <author> R. Sedgewick. </author> <title> Algorithms. </title> <publisher> Addison-Wesley Publishing Co., Brown University, </publisher> <year> 1983. </year>
Reference-contexts: This tree search is a little different from what can be found in the literature (see <ref> [18] </ref>) because it does not attempt to find a goal node with a certain property but instead it aims to find a set of nodes that is constrained to a certain property.
Reference: [19] <author> I. </author> <title> Silicon Graphics. Graphics Library Programming Guide, Volumes I and II, </title> <year> 1992. </year>
Reference-contexts: Two methods have been used: One uses geometric interpolation as in Turk [23] and the other uses hardware dependent color blending as described in <ref> [19] </ref> and used in [25, 8]. Both approaches present problems. <p> All programs are implemented in C++ and make GL <ref> [19] </ref> calls to render objects in the scene. The walk-through program also has an X-Motif user interface with buttons, fields and slider to facilitate testing and evaluation of the simulation. The program that builds the model hierarchy opens two windows.
Reference: [20] <author> I. </author> <title> Silicon Graphics. Graphics Library Programming Tools and Techniques, </title> <booktitle> 1992. </booktitle> <pages> 44 </pages>
Reference-contexts: Based on the Graphics Library Programming Tools and Techniques <ref> [20] </ref> document from Silicon Graphics Inc., and similar to what was done in [7], we derive a model of a generalized rendering system that this research is based on. This rendering system is represented as a pipeline with 3 functional stages as shown in figure 3.3.
Reference: [21] <author> I. </author> <title> Silicon Graphics. IRIS Power C User's Guide, </title> <year> 1993. </year>
Reference-contexts: By means of using interprocess communication synchronization primitives like semaphores or by inserting directives (pragmas) for the multi-processing compiler or for tools that analyze and parallelize code such as <ref> [21] </ref>, the program can be easily parallelized and by means of utilities such as those available for the IRIX operating system [22] such as sysmp, systune, runon 1 and others the real-time walk-through program can be locked alone into a relatively interrupt free processor while the work to compute the list
Reference: [22] <author> I. </author> <title> Silicon Graphics. IRIX System Programming Guide, </title> <year> 1993. </year>
Reference-contexts: By means of using interprocess communication synchronization primitives like semaphores or by inserting directives (pragmas) for the multi-processing compiler or for tools that analyze and parallelize code such as [21], the program can be easily parallelized and by means of utilities such as those available for the IRIX operating system <ref> [22] </ref> such as sysmp, systune, runon 1 and others the real-time walk-through program can be locked alone into a relatively interrupt free processor while the work to compute the list of objects to be rendered under the control of this cpu can be divided among the other processors in the system.
Reference: [23] <author> G. Turk. </author> <title> Re-tiling polygonal surfaces. </title> <journal> Computer Graphics, </journal> <pages> pages 55-64, </pages> <year> 1992. </year>
Reference-contexts: In cases like this, an initial mesh has to be formed from the set of random 3D sampled points, and then simplified using mesh simplification techniques. The technique devised by Turk in <ref> [23] </ref>, is appropriate to generate curved surfaces. <p> Incidental to the issue of LOD management is the selection of the method used to switch smoothly from one LOD representation to another in order to prevent "popping" of the object on the screen. Two methods have been used: One uses geometric interpolation as in Turk <ref> [23] </ref> and the other uses hardware dependent color blending as described in [19] and used in [25, 8]. Both approaches present problems.
Reference: [24] <author> A. Watt and M. Watt. </author> <title> Computer Graphics Animation and Rendering Techniques. </title> <publisher> Addison-Wesley, </publisher> <address> first edition, </address> <year> 1992. </year>
Reference-contexts: the future in terms of the speed of their components, it seems unlikely that the pipelined architecture of the graphics engine of these machines will cease to exist in the near future since it is based on the conceptual rendering pipeline that is described in any introductory computer graphics book <ref> [6, 24] </ref>.
Reference: [25] <author> J. K. Yan. </author> <title> Advances in computer-generated imagery for flight simulation. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 5 </volume> <pages> 37-51, </pages> <month> August </month> <year> 1985. </year> <month> 45 </month>
Reference-contexts: This is static selection mechanism is also not good in situations where lots of objects become visible/larger/slower, like in an aircraft landing situation. Commercial flight simulators <ref> [25] </ref> minimize this problem by means of computing a size threshold prior to rendering each frame based on the time needed to render the previous scene in an adaptive fashion. <p> Two methods have been used: One uses geometric interpolation as in Turk [23] and the other uses hardware dependent color blending as described in [19] and used in <ref> [25, 8] </ref>. Both approaches present problems.
References-found: 25

