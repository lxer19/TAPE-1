URL: http://www.cs.pitt.edu/~gupta/research/SE/tosem97.ps
Refering-URL: http://www.cs.pitt.edu/~gupta/research/testing.html
Root-URL: 
Email: fgupta,soffag@cs.pitt.edu  
Title: Hybrid Slicing: Integrating Dynamic Information with Static Analysis  
Author: Rajiv Gupta, Mary Lou Soffa, and John Howard 
Keyword: static slice, dynamic slice, hybrid slice, breakpoint, dynamic call graph.  
Address: Pittsburgh Pittsburgh, PA 15260  
Affiliation: Dept. of Computer Science University of  
Abstract: Program slicing is an effective technique for narrowing the focus of attention to the relevant parts of a program during the debugging process. However, imprecision is a problem in static slices since they are based on all possible executions that reach a given program point rather than the specific execution under which the program is being debugged. Dynamic slices, based on the specific exeuction being debugged, are precise but incur high run time overhead due to the tracing information that is collected during the program's execution. We present a hybrid slicing technique that integrates dynamic information from a specific execution into a static slice analysis. The hybrid slice produced is more precise than the static slice and less costly than the dynamic slice. The technique exploits dynamic information that is readily available during debugging, namely breakpoint information and the dynamic call graph. This information is integrated into a static slicing analysis to more accurately estimate the potential paths taken by the program. The breakpoints and call/return points, used as reference points, divide the execution path into intervals. By associating each statement in the slice with an execution interval, hybrid slicing provides information as to when a statement was encountered during execution. Another attractive feature of our approach is that it allows the user to control the cost of hybrid slicing by limiting the amount of dynamic information used in computing the slice. We implemented the hybrid slicing technique to demonstrate the feasibility of our approach. fl Supported in part by the National Science Foundation Presidential Young Investigator Award CCR-9157371, Grant CCR-9109089 and Grant CCR-9402226 to the University of Pittsburgh. Preliminary version of this paper will appear in the Third Symposium on the Foundations of Software Engineering, October 1995. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Agrawal, </author> <title> "On Slicing Programs with Jump Statements," </title> <booktitle> Proc. SIGPLAN Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 302-312, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Slicing has proven to be a useful tool in the debugging of programs. Static slicing algorithms determine the set of program statements that may affect the computation of the value of a variable at a specified program point <ref> [1, 5, 12, 17, 23] </ref>. However, since static slices are computed under all possible executions of the program that reach a specified point, the generated slices are large and imprecise (for a particular execution), which limits their usefulness in practice.
Reference: [2] <author> H. Agrawal and B. Horgan, </author> <title> "Dynamic Program Slicing," </title> <booktitle> Proc. SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 246-256, </pages> <month> JUNE </month> <year> 1990. </year>
Reference-contexts: Therefore techniques that improve the precision and reduce the size of the static slice are of significant interest. One approach for improving the precision of static slices is to employ dynamic slicing <ref> [2, 9, 14] </ref>. A dynamic slice is constructed for a fixed input (i.e., for a specific program execution) in contrast to a static slice which makes no assumptions about the input. However, the construction of a dynamic slice is expensive since it requires tracing of the program's execution. <p> In order to utilize breakpointing information during PDG slicing, a mapping would have to be provided between various points in the control flow graph and the program dependence graph. Dynamic slicing techniques <ref> [2, 9, 14] </ref> can be used to compute precise slices since accurate control and data flow information can be saved during program execution. Relevant data dependences among statements involving only scalar variables can be accurately determined if the exact program path taken during the execution is known.
Reference: [3] <author> A. Aho, R. Sethi, and J. Ullman, </author> <title> Compiler Principles, Techniques, and Tools, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference: [4] <author> T. Ball and J. R. Larus, </author> <title> "Optimally Profiling and Tracing Programs," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 16, No. 4, </volume> <pages> pages 1319-1360, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: An approach to improve the efficiency of dynamic slicing focuses on the use of static information to reduce the run-time overhead by limiting the amount of tracing that is needed during execution <ref> [16, 6, 9, 4, 19] </ref>. Information about the program is used to determine a subset of program points that should be traced. Although this approach does reduce the tracing effort, the size of traces can still be quite large.
Reference: [5] <author> J-D. Choi and J. Ferrante, </author> <title> "Static Slicing in the Presence of Goto Statements," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 16, No. 4, </volume> <pages> pages 1097-1113, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Slicing has proven to be a useful tool in the debugging of programs. Static slicing algorithms determine the set of program statements that may affect the computation of the value of a variable at a specified program point <ref> [1, 5, 12, 17, 23] </ref>. However, since static slices are computed under all possible executions of the program that reach a specified point, the generated slices are large and imprecise (for a particular execution), which limits their usefulness in practice.
Reference: [6] <author> J-D. Choi, B. Miller, and R. Netzer, </author> <title> "Techniques for Debugging Parallel Programs with Flowback Analysis," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, </volume> <editor> N. </editor> <volume> 4, </volume> <pages> pages 491-530, </pages> <year> 1991. </year>
Reference-contexts: An approach to improve the efficiency of dynamic slicing focuses on the use of static information to reduce the run-time overhead by limiting the amount of tracing that is needed during execution <ref> [16, 6, 9, 4, 19] </ref>. Information about the program is used to determine a subset of program points that should be traced. Although this approach does reduce the tracing effort, the size of traces can still be quite large. <p> In contrast dynamic slicing can also accurately slice programs in presence of pointers and arrays. Other approaches to hybrid slicing have been proposed <ref> [6, 8, 9, 16, 19] </ref>. These approaches use static information to improve the execution time performance of dynamic slicing while maintaining the precision of dynamic slicing. In one approach, dependencies that can be computed statically are computed before dynamic slicing and utilized at run time. <p> Another approach records only a small amount of trace information during program execution. During debugging, these coarse grained traces are supplemented with static information to generate fine-grained traces <ref> [6, 19] </ref>. The notion of a constrained/quasi-static slice is an approach to reduce the size of static slices [22]. An algorithm for computing constrained slices appears in [11].
Reference: [7] <author> K. Cooper, </author> <title> "Analyzing Aliases of Reference Formal Parameters," </title> <booktitle> Proc. of the 12th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 281-290, </pages> <year> 1985. </year>
Reference-contexts: The algorithms continue in this manner, finally finding the subslices given in Figure 9. The hybrid interprocedural algorithm can be extended to include aliases caused by reference parameters and global variables. The computation of the alias sets is performed before slicing begins <ref> [7] </ref>. The alias sets for a procedure are placed on the program nodes for that procedure. As a variable name is propagated in search of its definition, we include in the slice any definition of an alias as well as any definition of the variable itself.
Reference: [8] <author> E. Duesterwald, R. Gupta and M.L. Soffa, </author> <title> "Rigorous Data Flow Testing through Output Influences," </title> <booktitle> Proc. 2nd Irvine Software Symposium, </booktitle> <pages> pages 131-145, </pages> <address> Irvine, CA, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: In contrast dynamic slicing can also accurately slice programs in presence of pointers and arrays. Other approaches to hybrid slicing have been proposed <ref> [6, 8, 9, 16, 19] </ref>. These approaches use static information to improve the execution time performance of dynamic slicing while maintaining the precision of dynamic slicing. In one approach, dependencies that can be computed statically are computed before dynamic slicing and utilized at run time. <p> In one approach, dependencies that can be computed statically are computed before dynamic slicing and utilized at run time. Dependencies involving array elements or pointers that must be computed at run time are computed at execution time and recorded in a trace <ref> [8, 9, 16] </ref>. Another approach records only a small amount of trace information during program execution. During debugging, these coarse grained traces are supplemented with static information to generate fine-grained traces [6, 19]. The notion of a constrained/quasi-static slice is an approach to reduce the size of static slices [22].
Reference: [9] <author> E. Duesterwald, R. Gupta, </author> <title> and M.L. Soffa, "Distributed Slicing and Partial Re-execution for Distributed Programs," </title> <booktitle> Fifth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <publisher> LNCS 757 Springer Verlag, </publisher> <pages> pages 497-511, </pages> <institution> Yale University, </institution> <address> New Haven, Connecticut, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Therefore techniques that improve the precision and reduce the size of the static slice are of significant interest. One approach for improving the precision of static slices is to employ dynamic slicing <ref> [2, 9, 14] </ref>. A dynamic slice is constructed for a fixed input (i.e., for a specific program execution) in contrast to a static slice which makes no assumptions about the input. However, the construction of a dynamic slice is expensive since it requires tracing of the program's execution. <p> An approach to improve the efficiency of dynamic slicing focuses on the use of static information to reduce the run-time overhead by limiting the amount of tracing that is needed during execution <ref> [16, 6, 9, 4, 19] </ref>. Information about the program is used to determine a subset of program points that should be traced. Although this approach does reduce the tracing effort, the size of traces can still be quite large. <p> In order to utilize breakpointing information during PDG slicing, a mapping would have to be provided between various points in the control flow graph and the program dependence graph. Dynamic slicing techniques <ref> [2, 9, 14] </ref> can be used to compute precise slices since accurate control and data flow information can be saved during program execution. Relevant data dependences among statements involving only scalar variables can be accurately determined if the exact program path taken during the execution is known. <p> In contrast dynamic slicing can also accurately slice programs in presence of pointers and arrays. Other approaches to hybrid slicing have been proposed <ref> [6, 8, 9, 16, 19] </ref>. These approaches use static information to improve the execution time performance of dynamic slicing while maintaining the precision of dynamic slicing. In one approach, dependencies that can be computed statically are computed before dynamic slicing and utilized at run time. <p> In one approach, dependencies that can be computed statically are computed before dynamic slicing and utilized at run time. Dependencies involving array elements or pointers that must be computed at run time are computed at execution time and recorded in a trace <ref> [8, 9, 16] </ref>. Another approach records only a small amount of trace information during program execution. During debugging, these coarse grained traces are supplemented with static information to generate fine-grained traces [6, 19]. The notion of a constrained/quasi-static slice is an approach to reduce the size of static slices [22].
Reference: [10] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren, </author> <title> "The Program Dependence Graph and its use in Optimization," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 9, No. 3, </volume> <pages> pages 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: We also found that there is no measurable difference in execution time between computing static slices and hybrid slices. Our technique uses the control flow graph as the program representation. Another representation that has been used in slicing is the program dependence graph <ref> [10, 13] </ref>. The program dependence graph is not directly applicable to the hybrid slicing technique for it represents control dependence and not control flow.
Reference: [11] <author> J. Field, G. Ramalingam, and F. </author> <title> Tip, "Parametric Program Slicing," </title> <booktitle> Proc. ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 379-392, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: During debugging, these coarse grained traces are supplemented with static information to generate fine-grained traces [6, 19]. The notion of a constrained/quasi-static slice is an approach to reduce the size of static slices [22]. An algorithm for computing constrained slices appears in <ref> [11] </ref>. Constraints on input values are provided and, using this information, a static slice is produced that excludes program executions requiring inputs that do not satisfy the given constraints. In contrast, hybrid slicing integrates dynamic information for improving the precision and cost of slicing during debugging.
Reference: [12] <author> R. Gupta and M.L. Soffa, </author> <title> "A Framework for Partial Data Flow Analysis," </title> <booktitle> International Conference on Software Maintenance, </booktitle> <address> Victoria, British Columbia, </address> <pages> pages 4-13, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Slicing has proven to be a useful tool in the debugging of programs. Static slicing algorithms determine the set of program statements that may affect the computation of the value of a variable at a specified program point <ref> [1, 5, 12, 17, 23] </ref>. However, since static slices are computed under all possible executions of the program that reach a specified point, the generated slices are large and imprecise (for a particular execution), which limits their usefulness in practice.
Reference: [13] <author> S. Horwitz, T. Reps, and D. Binkley, </author> <title> "Interprocedural Slicing using Dependence Graphs," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 12, No. 1, </volume> <pages> pages 26-60, </pages> <month> January </month> <year> 1990. </year> <month> 25 </month>
Reference-contexts: We also found that there is no measurable difference in execution time between computing static slices and hybrid slices. Our technique uses the control flow graph as the program representation. Another representation that has been used in slicing is the program dependence graph <ref> [10, 13] </ref>. The program dependence graph is not directly applicable to the hybrid slicing technique for it represents control dependence and not control flow. <p> If static slices are obtained using Weiser's interprocedural slicing technique [23], which does not take into account the calling contexts of the calls, the following slice is computed: f2; 3; 6; 11; 12; 15; 16; 20; 27; 30g. If a static slice is computed using the calling context <ref> [13, 16] </ref>, more precise information can be found. Using the calling context, only the call site related to the call is processed. Thus, statement 6 would not be included as part of the slice, as P 2 in statement 7 is not a possible call site.
Reference: [14] <author> B. Korel and J. Laski, </author> <title> "Dynamic Program Slicing," </title> <journal> Information Processing Letters, </journal> <volume> Vol. 29, </volume> <pages> pages 155-163, </pages> <month> Oct. </month> <year> 1988. </year>
Reference-contexts: Therefore techniques that improve the precision and reduce the size of the static slice are of significant interest. One approach for improving the precision of static slices is to employ dynamic slicing <ref> [2, 9, 14] </ref>. A dynamic slice is constructed for a fixed input (i.e., for a specific program execution) in contrast to a static slice which makes no assumptions about the input. However, the construction of a dynamic slice is expensive since it requires tracing of the program's execution. <p> In order to utilize breakpointing information during PDG slicing, a mapping would have to be provided between various points in the control flow graph and the program dependence graph. Dynamic slicing techniques <ref> [2, 9, 14] </ref> can be used to compute precise slices since accurate control and data flow information can be saved during program execution. Relevant data dependences among statements involving only scalar variables can be accurately determined if the exact program path taken during the execution is known.
Reference: [15] <author> D. Jackson and E.J. Rollins, </author> <title> "A New Model of Program Dependences for Reverse Engineering," </title> <booktitle> Proc. of the Second ACM SIGSOFT Symposium on the Foundations of Software Engineer, pg. </booktitle> <pages> 2-10, </pages> <year> 1994. </year>
Reference-contexts: The usefulness of constrained slicing for understanding legacy codes has been demonstrated in [20]. While constrained slicing is useful for program understanding, hybrid slicing is more appropriate for program debugging. A related operation to slicing is chopping <ref> [15, 21] </ref>, which computes the elements that cause a program point to have an effect on another program point. It thus provides a more focused approach than slicing for determining the effects of a program point on another.
Reference: [16] <author> M. Kamkar, P. Fritzson, and N. Shahmehri, </author> <title> "Three Approaches to Interprocedural Dynamic Slicing," </title> <booktitle> Mi-croprocessing and Microprogramming 38, </booktitle> <pages> pages 625-636, </pages> <year> 1993. </year>
Reference-contexts: An approach to improve the efficiency of dynamic slicing focuses on the use of static information to reduce the run-time overhead by limiting the amount of tracing that is needed during execution <ref> [16, 6, 9, 4, 19] </ref>. Information about the program is used to determine a subset of program points that should be traced. Although this approach does reduce the tracing effort, the size of traces can still be quite large. <p> In contrast dynamic slicing can also accurately slice programs in presence of pointers and arrays. Other approaches to hybrid slicing have been proposed <ref> [6, 8, 9, 16, 19] </ref>. These approaches use static information to improve the execution time performance of dynamic slicing while maintaining the precision of dynamic slicing. In one approach, dependencies that can be computed statically are computed before dynamic slicing and utilized at run time. <p> In one approach, dependencies that can be computed statically are computed before dynamic slicing and utilized at run time. Dependencies involving array elements or pointers that must be computed at run time are computed at execution time and recorded in a trace <ref> [8, 9, 16] </ref>. Another approach records only a small amount of trace information during program execution. During debugging, these coarse grained traces are supplemented with static information to generate fine-grained traces [6, 19]. The notion of a constrained/quasi-static slice is an approach to reduce the size of static slices [22]. <p> If static slices are obtained using Weiser's interprocedural slicing technique [23], which does not take into account the calling contexts of the calls, the following slice is computed: f2; 3; 6; 11; 12; 15; 16; 20; 27; 30g. If a static slice is computed using the calling context <ref> [13, 16] </ref>, more precise information can be found. Using the calling context, only the call site related to the call is processed. Thus, statement 6 would not be included as part of the slice, as P 2 in statement 7 is not a possible call site.
Reference: [17] <author> J.R. Lyle and M. Weiser, </author> <title> "Automatic Program Bug Location by Program Slicing," </title> <booktitle> Proc. Second IEEE Symposium on Computers and Applications, </booktitle> <pages> pages 877-883, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Slicing has proven to be a useful tool in the debugging of programs. Static slicing algorithms determine the set of program statements that may affect the computation of the value of a variable at a specified program point <ref> [1, 5, 12, 17, 23] </ref>. However, since static slices are computed under all possible executions of the program that reach a specified point, the generated slices are large and imprecise (for a particular execution), which limits their usefulness in practice.
Reference: [18] <author> J.R. Lyle, D.R. Wallace, J.R. Graham, K.B. Gallagher, J.P. Poole, and D.W. Binkley, "Unravel: </author> <title> A CASE Tool to Assist Evaluation of High Integrity Software," </title> <type> Technical Report NISTIR-5691, </type> <institution> National Institute of Standards and Technology, </institution> <year> 1995. </year>
Reference-contexts: The data flow sets as before carry either a breakpoint reference or a call/return reference. 4 Implementation We have implemented both the intraprocedural and interprocedural hybrid slicing algorithms to illustrate the feasibility of computing hybrid slices. The implementation incorporates the hybrid slicing algorithms in the Unravel <ref> [18] </ref> static slicing tool. Unravel, developed at the National Institute of Standards and Technology, was designed to assist in the evaluation of software written in ANSI C. We extended the Unravel tool to accept both breakpoint and call-return histories.
Reference: [19] <author> R. Netzer and M. Weaver, </author> <title> "Optimal Tracing and Incremental Reexecution for Debugging Long-Running Programs," </title> <booktitle> Proc. of ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 313-325, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: An approach to improve the efficiency of dynamic slicing focuses on the use of static information to reduce the run-time overhead by limiting the amount of tracing that is needed during execution <ref> [16, 6, 9, 4, 19] </ref>. Information about the program is used to determine a subset of program points that should be traced. Although this approach does reduce the tracing effort, the size of traces can still be quite large. <p> In contrast dynamic slicing can also accurately slice programs in presence of pointers and arrays. Other approaches to hybrid slicing have been proposed <ref> [6, 8, 9, 16, 19] </ref>. These approaches use static information to improve the execution time performance of dynamic slicing while maintaining the precision of dynamic slicing. In one approach, dependencies that can be computed statically are computed before dynamic slicing and utilized at run time. <p> Another approach records only a small amount of trace information during program execution. During debugging, these coarse grained traces are supplemented with static information to generate fine-grained traces <ref> [6, 19] </ref>. The notion of a constrained/quasi-static slice is an approach to reduce the size of static slices [22]. An algorithm for computing constrained slices appears in [11].
Reference: [20] <author> J. Ning, A. Engberts, and W. Kozaczynski, </author> <title> "Automated Support for Legacy Code Understanding," </title> <journal> Communications of the ACM, </journal> <volume> Vol. 37, No. 5, </volume> <pages> pages 50-57, </pages> <year> 1994. </year>
Reference-contexts: In contrast, hybrid slicing integrates dynamic information for improving the precision and cost of slicing during debugging. The usefulness of constrained slicing for understanding legacy codes has been demonstrated in <ref> [20] </ref>. While constrained slicing is useful for program understanding, hybrid slicing is more appropriate for program debugging. A related operation to slicing is chopping [15, 21], which computes the elements that cause a program point to have an effect on another program point.
Reference: [21] <author> T. Reps and G. Rosay, </author> <title> "Precise Interprocedural Chopping," </title> <booktitle> Proc. of the Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 41-52, </pages> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: The usefulness of constrained slicing for understanding legacy codes has been demonstrated in [20]. While constrained slicing is useful for program understanding, hybrid slicing is more appropriate for program debugging. A related operation to slicing is chopping <ref> [15, 21] </ref>, which computes the elements that cause a program point to have an effect on another program point. It thus provides a more focused approach than slicing for determining the effects of a program point on another.
Reference: [22] <author> G.A. Venkatesh, </author> <title> "The Semantic Approach to Program Slicing," </title> <booktitle> Proc. of ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 107-119, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Another approach records only a small amount of trace information during program execution. During debugging, these coarse grained traces are supplemented with static information to generate fine-grained traces [6, 19]. The notion of a constrained/quasi-static slice is an approach to reduce the size of static slices <ref> [22] </ref>. An algorithm for computing constrained slices appears in [11]. Constraints on input values are provided and, using this information, a static slice is produced that excludes program executions requiring inputs that do not satisfy the given constraints.
Reference: [23] <author> M. Weiser, </author> <title> "Program Slicing," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-10, No. 4, </volume> <pages> pages 352-357, </pages> <month> July </month> <year> 1984. </year> <month> 26 </month>
Reference-contexts: 1 Introduction Slicing has proven to be a useful tool in the debugging of programs. Static slicing algorithms determine the set of program statements that may affect the computation of the value of a variable at a specified program point <ref> [1, 5, 12, 17, 23] </ref>. However, since static slices are computed under all possible executions of the program that reach a specified point, the generated slices are large and imprecise (for a particular execution), which limits their usefulness in practice. <p> Consider the example program given in Figure 9, which consists of a main program and four procedures. Assume the call/return history and the slicing criteria of variable d at statement 28 as given in Figure 9. If static slices are obtained using Weiser's interprocedural slicing technique <ref> [23] </ref>, which does not take into account the calling contexts of the calls, the following slice is computed: f2; 3; 6; 11; 12; 15; 16; 20; 27; 30g. If a static slice is computed using the calling context [13, 16], more precise information can be found. <p> For the slicing criteria of d at the start of P 3 , we compute a static slice using an existing static slicing algorithm. For example, let us assume that we use Weiser's interprocedural static slicing algorithm <ref> [23] </ref> which does not consider the calling context. The result of this algorithm would be: SLICE (CR 0 ; CR 6 ) = f2; 3; 6; 11; 12; 15; 16; 20; 27; 30g.
References-found: 23

