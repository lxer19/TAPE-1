URL: http://www.cs.purdue.edu/homes/palsberg/paper/tapos97.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: email: palsberg@cs.purdue.edu.  
Title: Theory and Practice of Object Systems 3(2):75-85, 1997. Class-graph Inference for Adaptive Programs  
Author: Jens Palsberg 
Address: Lafayette, IN 47907, USA;  
Affiliation: Purdue University Jens Palsberg, Dept of Computer Science, Purdue University, W  
Abstract: Software generators can adapt components to changes in the architectures in which the components operate. The idea is to keep the architecture description separate and let the software generator mix it with specifications of each component. Adaptation is done by regeneration: when the architecture changes, the components are regenerated. A software component will usually be written with a particular architecture in mind. This raises the question: how much has it committed to the particular structure of that architecture? To put it in a nutshell: How flexible is a given software component? In this paper we study this question in the setting of Lieberherr's adaptive programming. Lieberherr uses class graphs as the architecture and so-called adaptive programs as the software components. We present a polynomial-time class-graph inference algorithm for adaptive programs. The algorithm builds a representation of the set of class graphs with which a given adaptive program can work. It also decides if the set is non-empty, and if so it computes a particularly simple graph in the solution set. Several toy programs have been processed by a prototype implementation of the algorithm. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ole Agesen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Type inference of Self: Analysis of objects with dynamic and multiple inheritance. </title> <journal> Software - Practice & Experience, </journal> <volume> 25(9) </volume> <pages> 975-995, </pages> <month> September </month> <year> 1995. </year> <note> Preliminary version in Proc. </note> <editor> ECOOP'93, </editor> <booktitle> Seventh European Conference on Object-Oriented Programming, </booktitle> <publisher> Springer-Verlag (LNCS 707), </publisher> <pages> pages 247-267, </pages> <address> Kaiserslautern, Germany, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: The key difference between the first and the last two problems is that in the former case the subclass relationships are known, but in the latter case they are not. All published algorithms on type checking and type inference for object-oriented programs, for example <ref> [5, 6, 15, 20, 18, 19, 1, 14, 7] </ref>, rely on knowing the subclass relationships, and if there is a separate notion of typing and subtyping, then, of course, the algorithms rely on knowing the definition of subtyping.
Reference: [2] <author> Robert Baltzer. </author> <title> Multi-targeted program generators. </title> <note> http://www.isi.edu/software-sciences/multi-gen/multi-gen.html, 1996. </note>
Reference-contexts: In a database, the architecture is the schema, and a software component is a query [3]. When the schema changes, a query need not change but may have to be recompiled. * Software architecture. Baltzer studies multi-targeted program generators <ref> [2] </ref> and states about regeneration: "This will allow these generated components to remain compliant as their architecture evolves and to become reusable assets that can be adapted for use in multiple architectures. <p> eliminating the need to manually revise code generators for each architectural change, this component adaptation technology will remove major cost, expertise, and predictability barriers to the use of synthesis technology in complex systems and place adaptation to an evolving architecture on an equal footing with evolution of the component itself" <ref> [2] </ref>. * Aspect-oriented programming. Kiczales and his coworkers study aspect-oriented programming where the code of several components is woven together by a software generator [10].
Reference: [3] <author> Toby Bloom and Stanley B. Zdonik. </author> <booktitle> Issues in the design of object-oriented database programming languages. In Proc. OOPSLA'87, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 441-451, </pages> <year> 1987. </year>
Reference-contexts: The functionality of such a software generator is illustrated in Figure 1. There are several approaches to software generation in this style, including: * Databases. In a database, the architecture is the schema, and a software component is a query <ref> [3] </ref>. When the schema changes, a query need not change but may have to be recompiled. * Software architecture.
Reference: [4] <author> Kim B. Bruce. </author> <title> Safe type checking in a statically typed object-oriented programming language. </title> <booktitle> In Proc. POPL'93, Twentieth Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285-298, </pages> <year> 1993. </year>
Reference-contexts: Notice that "type = class" and "subtyping = subclassing." In its published form, Lieberherr's adaptive programming [12] is fundamentally based on these design choices. As such, type checking is inherently more restrictive than in some languages where types and classes are separate, for example, Bruce's language TOOPLE <ref> [5, 4] </ref>. It is not clear how to add, say, a function type constructor or an object-type constructor to the adaptive programming framework, and it is not clear if the algorithm presented in this paper could be extended to such a setting.
Reference: [5] <author> Kim B. Bruce, Jon Crabtree, Thomas P. Murtagh, Robert van Gent, Allyn Di-mock, and Robert Muller. </author> <title> Safe and decidable type checking in an object-oriented language. </title> <booktitle> In Proc. OOPSLA'93, ACM SIGPLAN Eighth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 29-46, </pages> <year> 1993. </year>
Reference-contexts: The key difference between the first and the last two problems is that in the former case the subclass relationships are known, but in the latter case they are not. All published algorithms on type checking and type inference for object-oriented programs, for example <ref> [5, 6, 15, 20, 18, 19, 1, 14, 7] </ref>, rely on knowing the subclass relationships, and if there is a separate notion of typing and subtyping, then, of course, the algorithms rely on knowing the definition of subtyping. <p> Notice that "type = class" and "subtyping = subclassing." In its published form, Lieberherr's adaptive programming [12] is fundamentally based on these design choices. As such, type checking is inherently more restrictive than in some languages where types and classes are separate, for example, Bruce's language TOOPLE <ref> [5, 4] </ref>. It is not clear how to add, say, a function type constructor or an object-type constructor to the adaptive programming framework, and it is not clear if the algorithm presented in this paper could be extended to such a setting.
Reference: [6] <author> Jonathan Eifrig, Scott Smith, and Valery Trifonov. </author> <title> Sound polymorphic type inference for objects. </title> <booktitle> In Proc. OOPSLA'95, ACM SIGPLAN Tenth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 169-184, </pages> <year> 1995. </year>
Reference-contexts: The key difference between the first and the last two problems is that in the former case the subclass relationships are known, but in the latter case they are not. All published algorithms on type checking and type inference for object-oriented programs, for example <ref> [5, 6, 15, 20, 18, 19, 1, 14, 7] </ref>, rely on knowing the subclass relationships, and if there is a separate notion of typing and subtyping, then, of course, the algorithms rely on knowing the definition of subtyping.
Reference: [7] <author> Carl Gunter and John Mitchell. </author> <title> Theoretical Aspects of Object-Oriented Programming. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: The key difference between the first and the last two problems is that in the former case the subclass relationships are known, but in the latter case they are not. All published algorithms on type checking and type inference for object-oriented programs, for example <ref> [5, 6, 15, 20, 18, 19, 1, 14, 7] </ref>, rely on knowing the subclass relationships, and if there is a separate notion of typing and subtyping, then, of course, the algorithms rely on knowing the definition of subtyping.
Reference: [8] <author> My Hoang and John C. Mitchell. </author> <title> Lower bounds on type inference with subtypes. </title> <booktitle> In Proc. POPL'95, 22nd Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 176-185, </pages> <year> 1995. </year>
Reference-contexts: We will also allow a substitution ' to be applied to a type T 2 T ; in that case '(T ) = T . Following [19, Ch.4] we define type correctness using constraints. Related definitions of typability for functional programs can be found in <ref> [24, 25, 8, 21, 16, 11] </ref>. The approach can be summarized as follows: 1. Introduce a type variable for each expression in the program, 2. Derive constraints from the program text; the constraints are expressed in terms of the type variables, and 3.
Reference: [9] <author> Neil D. Jones, Carsten K. Gomard, and Peter Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1993. </year>
Reference-contexts: Class-graph inference under the requirement of compatibility remains an open problem. We can view an adaptive program as having the functionality adaptive program : Class Graph fi Input ! Output : The software generator takes an adaptive program and a class graph and does partial evaluation <ref> [9] </ref> to produce an object-oriented program with the functionality object-oriented program : Input ! Output : Can we assign a useful type to an adaptive program? This requires a type for both of the arguments (the class graph and the input), and a type for the result (the output).
Reference: [10] <author> Gregor Kiczales. </author> <note> Aspect-oriented programming. http://www.parc.xerox.com/spl/projects/aop/, 1996. </note>
Reference-contexts: Kiczales and his coworkers study aspect-oriented programming where the code of several components is woven together by a software generator <ref> [10] </ref>. Typically, one of the components provides the basic functionality and the others enhance the behavior in various ways. 2 OPERATION print-nested TRAVERSE [Exp,Comp,Num] WRAPPER Num (@ print value @) * Adaptive programming. Lieberherr's adaptive programming uses class graphs as the architecture [12].
Reference: [11] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient inference of partial types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 49(2) </volume> <pages> 306-324, </pages> <year> 1994. </year> <note> 23 Preliminary version in Proc. </note> <editor> FOCS'92, </editor> <booktitle> 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 363-371, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: We will also allow a substitution ' to be applied to a type T 2 T ; in that case '(T ) = T . Following [19, Ch.4] we define type correctness using constraints. Related definitions of typability for functional programs can be found in <ref> [24, 25, 8, 21, 16, 11] </ref>. The approach can be summarized as follows: 1. Introduce a type variable for each expression in the program, 2. Derive constraints from the program text; the constraints are expressed in terms of the type variables, and 3.
Reference: [12] <author> Karl J. Lieberherr. </author> <title> Adaptive Object-Oriented Software: The Demeter Method with Propagation Patterns. </title> <publisher> PWS Publishing Company, </publisher> <address> Boston, </address> <year> 1996. </year>
Reference-contexts: Typically, one of the components provides the basic functionality and the others enhance the behavior in various ways. 2 OPERATION print-nested TRAVERSE [Exp,Comp,Num] WRAPPER Num (@ print value @) * Adaptive programming. Lieberherr's adaptive programming uses class graphs as the architecture <ref> [12] </ref>. The class graph represents subclass relationships and the types of instance variables. Software components are written in a style that relies as little as possible on the class graph. A software component will usually be written with a particular architecture in mind. <p> How flexible is a given software component? Related questions: With which architectures will the component work? Do two given components have compatible sets of architectures that they can work with? In this paper we study this question in the setting of Lieberherr's adaptive programming <ref> [12] </ref>. We present an algorithm which, when given a component, produces a summary of the architectures that the component can work with, or decides that none exists. The algorithm is in linear time and is simple to implement. <p> The approach to adaptive object-oriented programming taken by Lieberherr and his colleagues <ref> [12, 13] </ref> is to let the class graph be separate rather than having it as an integral part of the program text. Once an actual class graph is given, the adaptive program and the class graph can be compiled to an efficient object-oriented program by a software generator [17, 22]. <p> Notice that "type = class" and "subtyping = subclassing." In its published form, Lieberherr's adaptive programming <ref> [12] </ref> is fundamentally based on these design choices. As such, type checking is inherently more restrictive than in some languages where types and classes are separate, for example, Bruce's language TOOPLE [5, 4]. <p> The program is a hand-translated version of a C ++ program from Lieberherr's book <ref> [12, p.214] </ref>. We have extended it with code that creates a little graph and runs the depth-first traversal, see the body of METHOD Main.Execute . Lieberherr states that the program was written with the class graph in Figure 3 in mind. <p> In each case, the use of traversal specifications relieves the programmer from writing some tedious code, and it makes the program adaptable to changes in the class graph. For example, Lieberherr <ref> [12, pp.217] </ref> shows how to extend the program to do depth-first traversal of graphs with two kinds of edges. To do this, he changes only the class graph, not the adaptive program. 10 3 Type Checking We will now define a notion of type correctness for adaptive programs. <p> If a traversal specification is of the form [A 1 ,A 2 ,...,A n ] then it makes sense to require that each of the generated class graphs contain a path from A 1 via A 2 , etc, to A n . This requirement is called compatibility in <ref> [12, 22] </ref>. Class-graph inference under the requirement of compatibility remains an open problem.
Reference: [13] <author> Karl J. Lieberherr, Ignacio Silva-Lepe, and Cun Xiao. </author> <title> Adaptive object-oriented programming using graph-based customization. </title> <journal> Communications of the ACM, </journal> <volume> 37(5) </volume> <pages> 94-101, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: The approach to adaptive object-oriented programming taken by Lieberherr and his colleagues <ref> [12, 13] </ref> is to let the class graph be separate rather than having it as an integral part of the program text. Once an actual class graph is given, the adaptive program and the class graph can be compiled to an efficient object-oriented program by a software generator [17, 22].
Reference: [14] <author> John C. Mitchell. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 245-285, </pages> <year> 1991. </year>
Reference-contexts: The key difference between the first and the last two problems is that in the former case the subclass relationships are known, but in the latter case they are not. All published algorithms on type checking and type inference for object-oriented programs, for example <ref> [5, 6, 15, 20, 18, 19, 1, 14, 7] </ref>, rely on knowing the subclass relationships, and if there is a separate notion of typing and subtyping, then, of course, the algorithms rely on knowing the definition of subtyping.
Reference: [15] <author> Jens Palsberg. </author> <title> Efficient inference of object types. </title> <journal> Information and Computation, </journal> <volume> 123(2) </volume> <pages> 198-209, </pages> <year> 1995. </year> <note> Preliminary version in Proc. </note> <editor> LICS'94, </editor> <booktitle> Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 186-195, </pages> <address> Paris, France, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: The key difference between the first and the last two problems is that in the former case the subclass relationships are known, but in the latter case they are not. All published algorithms on type checking and type inference for object-oriented programs, for example <ref> [5, 6, 15, 20, 18, 19, 1, 14, 7] </ref>, rely on knowing the subclass relationships, and if there is a separate notion of typing and subtyping, then, of course, the algorithms rely on knowing the definition of subtyping.
Reference: [16] <author> Jens Palsberg and Patrick M. O'Keefe. </author> <title> A type system equivalent to flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(4) </volume> <pages> 576-599, </pages> <month> July </month> <year> 1995. </year> <note> Preliminary version in Proc. </note> <editor> POPL'95, </editor> <booktitle> 22nd Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 367-378, </pages> <address> San Fran-cisco, California, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: We will also allow a substitution ' to be applied to a type T 2 T ; in that case '(T ) = T . Following [19, Ch.4] we define type correctness using constraints. Related definitions of typability for functional programs can be found in <ref> [24, 25, 8, 21, 16, 11] </ref>. The approach can be summarized as follows: 1. Introduce a type variable for each expression in the program, 2. Derive constraints from the program text; the constraints are expressed in terms of the type variables, and 3.
Reference: [17] <author> Jens Palsberg, Boaz Patt-Shamir, and Karl Lieberherr. </author> <title> A new approach to compiling adaptive programs. </title> <booktitle> In Proc. ESOP'96, European Symposium on Programming, </booktitle> <pages> pages 280-295. </pages> <publisher> Springer-Verlag (LNCS 1058), Linkoeping, </publisher> <address> Sweden, </address> <month> April </month> <year> 1996. </year>
Reference-contexts: Once an actual class graph is given, the adaptive program and the class graph can be compiled to an efficient object-oriented program by a software generator <ref> [17, 22] </ref>. Thus, if the adaptive program can remain untouched when the class graph changes, then such a change only entails a recompilation. An adaptive program in the style of Lieberherr uses the constructs of traversal specifications and wrappers. An example program is shown in Figure 2. <p> We use the grammars for BOPL expressions and BOPL types as the basis for creating Adaptive-BOPL. On top of that we put the notions of class graph, object graph, traversal specification, and wrapper from <ref> [17, 22] </ref>, as follows. 2.1 Class graphs and object graphs A class graph is a finite directed graph, where each node is a type, and each edge either represents a subclass relationship or the type of an instance variable. <p> In accordance with many object-oriented languages, we require that the subclass edges form an acyclic relation, that there are no subclass edges to or from Bool or Int, and that there are no subclass edges from Void (these requirements were not present in <ref> [17, 22] </ref>.) Following [17, 22] we also require that only abstract classes can have outgoing subclass edges, and that only concrete classes can have outgoing construction edges. We have imposed these restrictions to make the set up for the class-graph inference problem realistic. <p> In accordance with many object-oriented languages, we require that the subclass edges form an acyclic relation, that there are no subclass edges to or from Bool or Int, and that there are no subclass edges from Void (these requirements were not present in <ref> [17, 22] </ref>.) Following [17, 22] we also require that only abstract classes can have outgoing subclass edges, and that only concrete classes can have outgoing construction edges. We have imposed these restrictions to make the set up for the class-graph inference problem realistic. <p> write a propagation pattern with name Name, traversal specification just [A 1 ], and just one wrapper for A 1 itself, then we can use the syntactic sugar METHOD A 1 .Name (arg 1 : Type 1 ,...,arg k :Type k ) returns Type (@ &lt;BOPL expression&gt; @) 9 Following <ref> [17, 22] </ref>, we assume that the propagation patterns have different names, and that wrappers only can be attached to concrete classes.
Reference: [18] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proc. OOPSLA'91, ACM SIGPLAN Sixth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 146-161, </pages> <address> Phoenix, Ari-zona, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: The key difference between the first and the last two problems is that in the former case the subclass relationships are known, but in the latter case they are not. All published algorithms on type checking and type inference for object-oriented programs, for example <ref> [5, 6, 15, 20, 18, 19, 1, 14, 7] </ref>, rely on knowing the subclass relationships, and if there is a separate notion of typing and subtyping, then, of course, the algorithms rely on knowing the definition of subtyping. <p> The above questions were first addressed by Pedersen in his Master's thesis [23] (I was the advisor of Pedersen). The approach of Pedersen was to use the notion of control-flow analysis of Palsberg and Schwartzbach <ref> [18, 19] </ref> (in [18, 19] this analysis is called "type inference") to generate approximate type information. From this information, he built an approximate solution to the class-graph inference problem. There are cases where the second part of his algorithm must give up and not produce a result. <p> The above questions were first addressed by Pedersen in his Master's thesis [23] (I was the advisor of Pedersen). The approach of Pedersen was to use the notion of control-flow analysis of Palsberg and Schwartzbach <ref> [18, 19] </ref> (in [18, 19] this analysis is called "type inference") to generate approximate type information. From this information, he built an approximate solution to the class-graph inference problem. There are cases where the second part of his algorithm must give up and not produce a result.
Reference: [19] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> John Wiley & Sons, </publisher> <year> 1994. </year>
Reference-contexts: The key difference between the first and the last two problems is that in the former case the subclass relationships are known, but in the latter case they are not. All published algorithms on type checking and type inference for object-oriented programs, for example <ref> [5, 6, 15, 20, 18, 19, 1, 14, 7] </ref>, rely on knowing the subclass relationships, and if there is a separate notion of typing and subtyping, then, of course, the algorithms rely on knowing the definition of subtyping. <p> The above questions were first addressed by Pedersen in his Master's thesis [23] (I was the advisor of Pedersen). The approach of Pedersen was to use the notion of control-flow analysis of Palsberg and Schwartzbach <ref> [18, 19] </ref> (in [18, 19] this analysis is called "type inference") to generate approximate type information. From this information, he built an approximate solution to the class-graph inference problem. There are cases where the second part of his algorithm must give up and not produce a result. <p> The above questions were first addressed by Pedersen in his Master's thesis [23] (I was the advisor of Pedersen). The approach of Pedersen was to use the notion of control-flow analysis of Palsberg and Schwartzbach <ref> [18, 19] </ref> (in [18, 19] this analysis is called "type inference") to generate approximate type information. From this information, he built an approximate solution to the class-graph inference problem. There are cases where the second part of his algorithm must give up and not produce a result. <p> BOPL is the object-oriented language studied by Palsberg and Schwartzbach in <ref> [19] </ref>. In this section we briefly summarize the syntax and semantics of Adaptive-BOPL, following Pedersen [23]. BOPL is a small language with classes, objects, methods, instance variables, assignments, message sends, integers, booleans, self, super, and a few other standard constructs. <p> Let T denote the set of types. We will use the term substitution to mean a mapping from type variables to types. We will also allow a substitution ' to be applied to a type T 2 T ; in that case '(T ) = T . Following <ref> [19, Ch.4] </ref> we define type correctness using constraints. Related definitions of typability for functional programs can be found in [24, 25, 8, 21, 16, 11]. The approach can be summarized as follows: 1. Introduce a type variable for each expression in the program, 2. <p> Given S, given G; 9' : G; ' j= S ? * The typability problem. Given S; 9G; 9' : G; ' j= S ? * The class-graph inference problem. Given S; find all G; 9' : G; ' j= S . Solving the type-checking problem is straightforward <ref> [19] </ref>; solving the two other problems is considered next. 4 Class-graph Inference In this section we present our class-graph inference algorithm. As a non-trivial example, we consider the program in the appendix. As we shall see, our algorithm produces exactly the class graph in Figure 3 from the program.
Reference: [20] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Static typing for object-oriented programming. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 23(1) </volume> <pages> 19-53, </pages> <year> 1994. </year>
Reference-contexts: The key difference between the first and the last two problems is that in the former case the subclass relationships are known, but in the latter case they are not. All published algorithms on type checking and type inference for object-oriented programs, for example <ref> [5, 6, 15, 20, 18, 19, 1, 14, 7] </ref>, rely on knowing the subclass relationships, and if there is a separate notion of typing and subtyping, then, of course, the algorithms rely on knowing the definition of subtyping.
Reference: [21] <author> Jens Palsberg and Scott Smith. </author> <title> Constrained types and their expressiveness. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 18(5) </volume> <pages> 519-527, </pages> <year> 1996. </year>
Reference-contexts: We will also allow a substitution ' to be applied to a type T 2 T ; in that case '(T ) = T . Following [19, Ch.4] we define type correctness using constraints. Related definitions of typability for functional programs can be found in <ref> [24, 25, 8, 21, 16, 11] </ref>. The approach can be summarized as follows: 1. Introduce a type variable for each expression in the program, 2. Derive constraints from the program text; the constraints are expressed in terms of the type variables, and 3.
Reference: [22] <author> Jens Palsberg, Cun Xiao, and Karl Lieberherr. </author> <title> Efficient implementation of adaptive software. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(2) </volume> <pages> 264-292, </pages> <month> March </month> <year> 1995. </year> <month> 24 </month>
Reference-contexts: Once an actual class graph is given, the adaptive program and the class graph can be compiled to an efficient object-oriented program by a software generator <ref> [17, 22] </ref>. Thus, if the adaptive program can remain untouched when the class graph changes, then such a change only entails a recompilation. An adaptive program in the style of Lieberherr uses the constructs of traversal specifications and wrappers. An example program is shown in Figure 2. <p> We use the grammars for BOPL expressions and BOPL types as the basis for creating Adaptive-BOPL. On top of that we put the notions of class graph, object graph, traversal specification, and wrapper from <ref> [17, 22] </ref>, as follows. 2.1 Class graphs and object graphs A class graph is a finite directed graph, where each node is a type, and each edge either represents a subclass relationship or the type of an instance variable. <p> In accordance with many object-oriented languages, we require that the subclass edges form an acyclic relation, that there are no subclass edges to or from Bool or Int, and that there are no subclass edges from Void (these requirements were not present in <ref> [17, 22] </ref>.) Following [17, 22] we also require that only abstract classes can have outgoing subclass edges, and that only concrete classes can have outgoing construction edges. We have imposed these restrictions to make the set up for the class-graph inference problem realistic. <p> In accordance with many object-oriented languages, we require that the subclass edges form an acyclic relation, that there are no subclass edges to or from Bool or Int, and that there are no subclass edges from Void (these requirements were not present in <ref> [17, 22] </ref>.) Following [17, 22] we also require that only abstract classes can have outgoing subclass edges, and that only concrete classes can have outgoing construction edges. We have imposed these restrictions to make the set up for the class-graph inference problem realistic. <p> write a propagation pattern with name Name, traversal specification just [A 1 ], and just one wrapper for A 1 itself, then we can use the syntactic sugar METHOD A 1 .Name (arg 1 : Type 1 ,...,arg k :Type k ) returns Type (@ &lt;BOPL expression&gt; @) 9 Following <ref> [17, 22] </ref>, we assume that the propagation patterns have different names, and that wrappers only can be attached to concrete classes. <p> If a traversal specification is of the form [A 1 ,A 2 ,...,A n ] then it makes sense to require that each of the generated class graphs contain a path from A 1 via A 2 , etc, to A n . This requirement is called compatibility in <ref> [12, 22] </ref>. Class-graph inference under the requirement of compatibility remains an open problem.
Reference: [23] <author> Carsten Pedersen. </author> <title> Generation of class graphs from adaptive programs. </title> <type> Master's thesis, </type> <institution> University of Aarhus, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: Our algorithm can take the combined program and generate the wanted set of class graphs. The above questions were first addressed by Pedersen in his Master's thesis <ref> [23] </ref> (I was the advisor of Pedersen). The approach of Pedersen was to use the notion of control-flow analysis of Palsberg and Schwartzbach [18, 19] (in [18, 19] this analysis is called "type inference") to generate approximate type information. <p> BOPL is the object-oriented language studied by Palsberg and Schwartzbach in [19]. In this section we briefly summarize the syntax and semantics of Adaptive-BOPL, following Pedersen <ref> [23] </ref>. BOPL is a small language with classes, objects, methods, instance variables, assignments, message sends, integers, booleans, self, super, and a few other standard constructs.
Reference: [24] <author> Mitchell Wand. </author> <title> A simple algorithm and proof for type inference. </title> <journal> Fundamentae Informaticae, </journal> <volume> X:115-122, </volume> <year> 1987. </year>
Reference-contexts: We will also allow a substitution ' to be applied to a type T 2 T ; in that case '(T ) = T . Following [19, Ch.4] we define type correctness using constraints. Related definitions of typability for functional programs can be found in <ref> [24, 25, 8, 21, 16, 11] </ref>. The approach can be summarized as follows: 1. Introduce a type variable for each expression in the program, 2. Derive constraints from the program text; the constraints are expressed in terms of the type variables, and 3.
Reference: [25] <author> Mitchell Wand. </author> <title> Type inference for record concatenation and multiple inheritance. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 1-15, </pages> <year> 1991. </year> <month> 25 </month>
Reference-contexts: We will also allow a substitution ' to be applied to a type T 2 T ; in that case '(T ) = T . Following [19, Ch.4] we define type correctness using constraints. Related definitions of typability for functional programs can be found in <ref> [24, 25, 8, 21, 16, 11] </ref>. The approach can be summarized as follows: 1. Introduce a type variable for each expression in the program, 2. Derive constraints from the program text; the constraints are expressed in terms of the type variables, and 3.
References-found: 25

