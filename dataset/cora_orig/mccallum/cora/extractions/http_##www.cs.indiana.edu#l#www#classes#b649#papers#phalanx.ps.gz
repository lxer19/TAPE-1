URL: http://www.cs.indiana.edu/l/www/classes/b649/papers/phalanx.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/classes/b649/project.html
Root-URL: http://www.cs.indiana.edu
Email: fdalia,reiterg@research.att.com  
Title: Secure and Scalable Replication in Phalanx (Extended Abstract)  
Author: Dahlia Malkhi Michael K. Reiter 
Address: Florham Park, NJ, USA  
Affiliation: AT&T Labs Research,  
Abstract: Phalanx is a software system for building a persistent, survivable data repository that supports shared data abstractions (e.g., variables, mutual exclusion) for clients. Phalanx implements data abstractions that ensure useful properties without trusting the servers supporting these abstractions or the clients accessing them, i.e., Phalanx can survive even the arbitrarily malicious corruption of clients and (some number of) servers. At the core of the system are survivable replication techniques that enable efficient scaling to hundreds of Phalanx servers. In this paper we describe the implementation of some of the data abstractions provided by Phalanx, discuss their ability to scale to large systems, and describe an example application. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. J. Anderson. </author> <title> The Eternity Service. </title> <booktitle> In Proceedings of Pragocrypt '96, </booktitle> <year> 1996. </year>
Reference-contexts: A PKI is a prime example of a system that may need both to survive hostile attempts to penetrate it due to the security requirements it embodies, and to scale to worldwide proportions. 2. Robust publishing and dissemination: The Eternity service <ref> [1] </ref> is a proposed service that would enable a client to publish a document so that anyone can retrieve it, but so that nobodyeven the author, or an adversary with the means to mount a military strike against the servicecould eliminate the document from existence or otherwise deny access to it.
Reference: [2] <author> J. Aspnes and M. Herlihy. </author> <title> Fast randomized consensus using shared memory. </title> <journal> Journal of Algorithms, </journal> <volume> 11:441461, </volume> <year> 1990. </year>
Reference-contexts: Phalanx thus employs randomization to ensure that correct clients receive the consensus value with probability one. In the case that clients are presumed to be honest, we employ a randomized protocol based on one due to Aspnes and Her-lihy <ref> [2] </ref>, and for the general case (i.e., when clients can be dishonest), we use our own protocol [21]. In either case, these consensus protocols terminate in a expected number of operations polynomial in the number of clients. With consensus objects in hand, implementing exactly-one mutual exclusion is straightforward. <p> Our implementation of at-most-one mutex objects also share this property. Our implementation of exactly-one mutex objects does not scale as elegantly, because in the consensus object implementations that we employ <ref> [2, 21] </ref>, the amount of work a client must do to obtain the consensus value is a function of the number of clients that have proposed values for it.
Reference: [3] <author> J. K. Bennet, J. B. Carter and W. Zwaenepoel. Munin: </author> <title> Distributed shared memory based on type-specific memory coherence. </title> <booktitle> In Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 168176, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: These can be coarsely categorized as group communication systems (see [25]), distributed transactional systems (e.g., Argus [15], and Thor [18]), and shared-memory emulation systems (e.g., Ivy [17] and Munin <ref> [3] </ref>). Though these systems allow more efficient data access than Phalanx, their simpler access protocols cannot mask the arbitrary corruption of data replicas. Phalanx therefore is constructed using a different approach in order to meet its scalability and survivability goals.
Reference: [4] <author> F. Cristian, H. Aghili, R. Strong, and D. Dolev. </author> <title> Atomic broadcast: From simple message diffusion to Byzantine agreement. </title> <booktitle> Information and Computation 18(1), </booktitle> <pages> pages 158179, </pages> <year> 1995. </year>
Reference: [5] <author> W. Diffie and M. E. Hellman. </author> <title> New directions in cryptography. </title> <journal> IEEE Transactions on Information Theory IT-22(6):644654, </journal> <month> November </month> <year> 1976. </year>
Reference-contexts: For the purposes of this paper, however, we omit these interfaces from further discussion. In our protocols, correct servers never send messages to other servers, and correct clients never send messages to other clients. We assume the existence of trapdoor one-way functions <ref> [5] </ref>, which are sufficient for constructing digital signature schemes.
Reference: [6] <author> E. W. Dijkstra. </author> <title> Solution of a problem in concurrent programming control. </title> <journal> Communications of the ACM 8(9):569, </journal> <month> September </month> <year> 1965. </year>
Reference-contexts: If it receives its own identifier as the consensus value, then it has succeeded in its contention for mutual exclusion. Simpler emulations of exactly-one mutual exclusion objects using shared variables can be achieved using adaptations of Dijkstra's mutual exclusion algorithm <ref> [6] </ref> or Lam-port's bakery algorithm [12] to the case of faulty clients; see [22]. However, the consensus-object-based implementation described here, while somewhat more complex, offers certain advantages in practice.
Reference: [7] <author> M. J. Fischer, N. A. Lynch, and M. S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM 32(2):374382, </journal> <month> April </month> <year> 1985. </year>
Reference-contexts: It is well-known that no protocol satisfying (i) and (ii) can guarantee that clients receive a value in a finite number of steps <ref> [7] </ref>. Phalanx thus employs randomization to ensure that correct clients receive the consensus value with probability one.
Reference: [8] <author> M. Gasser, A. Goldstein, C. Kaufman and B. Lampson. </author> <title> The Digital distributed system security architecture. </title> <booktitle> In Proceedings of the 12th NIST/NCSC National Computer Security Conference, </booktitle> <pages> pages 305 319, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: These functions may include certificate-generating services that create certificates (i.e., bindings associating attributes to public keys) as in [19, 27], revocation services that enable a client to promptly invalidate her certificate as in <ref> [8, 16] </ref>, and directory services that enable a client to locate the most up-to-date certificate for a name or key, such as X.509 directories [10].
Reference: [9] <author> M. P. Herlihy and J. M. Wing. </author> <title> Linearizability: A correctness condition for concurrent objects. </title> <journal> ACM Transactions on Programming Languages and Systems 12(3):463492, </journal> <month> July </month> <year> 1990. </year>
Reference-contexts: To properly present the semantics provided by our protocols and prove their correctness requires extending the standard treatment of concurrent objects in benign failure environment <ref> [14, 9] </ref> to an environment with Byzantine clients, which is beyond our scope here. The interested reader is referred to [22] for a formal treatment of this subject. Due to space limitations, we omit a proof for our protocol here. 3.2.
Reference: [10] <author> International Telegraph and Telephone Consultative Committee (CCITT). </author> <title> The Directory Authentication Framework, </title> <type> Recommendation X.509, </type> <year> 1988. </year>
Reference-contexts: create certificates (i.e., bindings associating attributes to public keys) as in [19, 27], revocation services that enable a client to promptly invalidate her certificate as in [8, 16], and directory services that enable a client to locate the most up-to-date certificate for a name or key, such as X.509 directories <ref> [10] </ref>. A PKI is a prime example of a system that may need both to survive hostile attempts to penetrate it due to the security requirements it embodies, and to scale to worldwide proportions. 2.
Reference: [11] <author> K. P. Kihlstrom, L. E. Moser and P. M. Melliar-Smith. </author> <title> The Se-cureRing protocols for securing group communication. </title> <booktitle> In Proceedings of the 31st Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 317326, </pages> <month> January </month> <year> 1998. </year>
Reference-contexts: In particular, the foremost approach for building a survivable service today is state machine replication [28], in which every (available) server receives, processes, and responds to every client request; some examples of systems implementing this approach are <ref> [29, 26, 11] </ref>. Because every server must reliably receive every request, this approach generally does not scale well. Numerous other approaches that support persistent and/or replicated data in a distributed system with tolerance to only benign (crash) failures are not suitable, either.
Reference: [12] <author> L. Lamport. </author> <title> A new solution of Dijkstra's concurrent programming problem. </title> <journal> Communications of the ACM 17(8):453455, </journal> <month> August </month> <year> 1974. </year>
Reference-contexts: If it receives its own identifier as the consensus value, then it has succeeded in its contention for mutual exclusion. Simpler emulations of exactly-one mutual exclusion objects using shared variables can be achieved using adaptations of Dijkstra's mutual exclusion algorithm [6] or Lam-port's bakery algorithm <ref> [12] </ref> to the case of faulty clients; see [22]. However, the consensus-object-based implementation described here, while somewhat more complex, offers certain advantages in practice.
Reference: [13] <author> L. Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multiprocessor programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):690691, </volume> <year> 1979. </year>
Reference: [14] <author> L. Lamport. </author> <title> On interprocess communication (part II: algorithms). </title> <booktitle> Distributed Computing 1:86101, </booktitle> <year> 1986. </year>
Reference-contexts: One of the purposes of this paper is to describe the implementation of two types of objects implemented at this layer: 1. Shared variables: A shared variable supports read and write operations by clients. For most classes of failure assumptions, we guarantee atomic updates <ref> [14, 22] </ref>, and under the most severe failure scenarios readers, writers, and (a limited number) of servers are all untrustedthen we provide only safe seman tics [14, 22]. 2. Mutual exclusion: A mutual exclusion object grants a right to at most one client out of some number of contending clients. <p> Shared variables: A shared variable supports read and write operations by clients. For most classes of failure assumptions, we guarantee atomic updates <ref> [14, 22] </ref>, and under the most severe failure scenarios readers, writers, and (a limited number) of servers are all untrustedthen we provide only safe seman tics [14, 22]. 2. Mutual exclusion: A mutual exclusion object grants a right to at most one client out of some number of contending clients. Phalanx supports at-most-one mutual exclusion and exactly-one mutual exclusion objects, differing in the conditions which guarantee that some client succeeds in gaining the right. <p> To properly present the semantics provided by our protocols and prove their correctness requires extending the standard treatment of concurrent objects in benign failure environment <ref> [14, 9] </ref> to an environment with Byzantine clients, which is beyond our scope here. The interested reader is referred to [22] for a formal treatment of this subject. Due to space limitations, we omit a proof for our protocol here. 3.2.
Reference: [15] <author> B. Liskov, D. Curtis, P. Johnson, and R. Scheifler. </author> <title> Implementation of Argus. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 111-122, </pages> <year> 1987. </year>
Reference-contexts: Numerous other approaches that support persistent and/or replicated data in a distributed system with tolerance to only benign (crash) failures are not suitable, either. These can be coarsely categorized as group communication systems (see [25]), distributed transactional systems (e.g., Argus <ref> [15] </ref>, and Thor [18]), and shared-memory emulation systems (e.g., Ivy [17] and Munin [3]). Though these systems allow more efficient data access than Phalanx, their simpler access protocols cannot mask the arbitrary corruption of data replicas.
Reference: [16] <author> B. Lampson, M. Abadi, M. Burrows, and E. Wobber. </author> <title> Authentication in distributed systems: </title> <journal> Theory and practice. ACM Transactions on Computer Systems, </journal> <volume> 10(4):265310, </volume> <month> November </month> <year> 1992. </year>
Reference-contexts: These functions may include certificate-generating services that create certificates (i.e., bindings associating attributes to public keys) as in [19, 27], revocation services that enable a client to promptly invalidate her certificate as in <ref> [8, 16] </ref>, and directory services that enable a client to locate the most up-to-date certificate for a name or key, such as X.509 directories [10].
Reference: [17] <author> K. Li and P. Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4):321359, </volume> <month> November </month> <year> 1989. </year>
Reference-contexts: These can be coarsely categorized as group communication systems (see [25]), distributed transactional systems (e.g., Argus [15], and Thor [18]), and shared-memory emulation systems (e.g., Ivy <ref> [17] </ref> and Munin [3]). Though these systems allow more efficient data access than Phalanx, their simpler access protocols cannot mask the arbitrary corruption of data replicas. Phalanx therefore is constructed using a different approach in order to meet its scalability and survivability goals.
Reference: [18] <author> B. Liskov, A. Adya, M. Castro, M. Day, S. Ghemawat, R. Gruber, U. Maheshwari, A. Myers, and L. Shrira. </author> <title> Safe and efficient sharing of persistent objects in Thor. </title> <booktitle> In Proceedings of SIGMOD '96, </booktitle> <pages> pages 318329, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Numerous other approaches that support persistent and/or replicated data in a distributed system with tolerance to only benign (crash) failures are not suitable, either. These can be coarsely categorized as group communication systems (see [25]), distributed transactional systems (e.g., Argus [15], and Thor <ref> [18] </ref>), and shared-memory emulation systems (e.g., Ivy [17] and Munin [3]). Though these systems allow more efficient data access than Phalanx, their simpler access protocols cannot mask the arbitrary corruption of data replicas. Phalanx therefore is constructed using a different approach in order to meet its scalability and survivability goals.
Reference: [19] <author> P. V. McMahon. </author> <title> SESAME V2 public key and authorization extensions to Kerberos. </title> <booktitle> In Proceedings of the 1995 Internet Society Symposium on Network and Distributed System Security, </booktitle> <pages> pages 114131, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: These functions may include certificate-generating services that create certificates (i.e., bindings associating attributes to public keys) as in <ref> [19, 27] </ref>, revocation services that enable a client to promptly invalidate her certificate as in [8, 16], and directory services that enable a client to locate the most up-to-date certificate for a name or key, such as X.509 directories [10].
Reference: [20] <author> D. Malkhi and M. Reiter. </author> <title> Byzantine quorum systems. </title> <journal> Distributed Computing 11(4), </journal> <note> to appear. Preliminary version appears in Proceedings of the 29th ACM Symposium on Theory of Computing, pages 569578, </note> <month> May </month> <year> 1997. </year>
Reference-contexts: Quorums can be surprisingly smalle.g., comprised of only O ( p n) out of a total of n serversand thus client access protocols can efficiently scale to hundreds and possibly even thousands of servers. Quorum systems can be constructed to tolerate failures ranging from benign to fully arbitrary <ref> [20, 23] </ref>, and for either type of failure can provide either strict consistency guarantees or only probabilistic ones [24]. Phalanx allows clients to dynamically tune the quorums they use for their application needs. Quorums are fundamental to Phalanx, and all objects are implemented using quorum-based protocols. <p> There are two different variable implementations that Phalanx supports, namely one that assumes that the writers of a variable are honest (Section 3.1) and (a more expensive) one that makes no assumptions about writers (Section 3.2). These two protocols build upon two similar but weaker protocols in <ref> [20] </ref>. As a practical matter, we note that shared variables can be used to store arbitrary contents, e.g., large files. In the case of large files, though, it may be desirable to read and write only portions of the file rather than the entire contents of such variables. <p> This correct server can then forward the digitally signed update to the reader, enabling it to verify w's digital signature on the value and adopt this value. The class of quorum systems that is required in this case is called a b-dissemination quorum system <ref> [20] </ref>. A b-dissemination quorum system is one that ensures that the intersection of any two chosen quorums contains at least one correct server despite up to b faults. <p> In the case of a dishonest writer, however, this signature is useless, and so we rely instead on correct servers to mask out the forged values of faulty servers. This is achieved by making use of a b-masking quorum system <ref> [20] </ref>, where a quorum system Q is a b-masking quorum system if for every Q 1 ; Q 2 2 Q, jQ 1 "Q 2 j 2b+1. <p> Scalability with growth in the number of servers is primarily dictated by the quorum system used, as quorum systems exist with a wide array of properties <ref> [20, 23, 24] </ref>. For example, there are dissemination constructions whose re silience is b = p 2 and that have quorum sizes as small as O (n 3=4 ) (so, e.g., for n = 1000, quorum size is &lt; 200).
Reference: [21] <author> D. Malkhi and M. Reiter. </author> <title> Survivable consensus objects. </title> <booktitle> In Proceedings of the 17th IEEE Symposium on Reliable Distributed Systems, </booktitle> <month> October </month> <year> 1998. </year>
Reference-contexts: In the case that clients are presumed to be honest, we employ a randomized protocol based on one due to Aspnes and Her-lihy [2], and for the general case (i.e., when clients can be dishonest), we use our own protocol <ref> [21] </ref>. In either case, these consensus protocols terminate in a expected number of operations polynomial in the number of clients. With consensus objects in hand, implementing exactly-one mutual exclusion is straightforward. Each mutual exclusion object is represented by a consensus object. <p> However, the consensus-object-based implementation described here, while somewhat more complex, offers certain advantages in practice. In particular, it enables a Phalanx server to ascertain, based on local data only, which client has succeeded in its contention (see <ref> [21] </ref>), e.g., to enforce access control to guarded objects. Due to the quorum structure of our system, the aforementioned simpler solutions to exactly-one mutual exclusion provide less information to servers and thus less capability for these added features. <p> Our implementation of at-most-one mutex objects also share this property. Our implementation of exactly-one mutex objects does not scale as elegantly, because in the consensus object implementations that we employ <ref> [2, 21] </ref>, the amount of work a client must do to obtain the consensus value is a function of the number of clients that have proposed values for it.
Reference: [22] <author> D. Malkhi, M. Reiter and N. Lynch. </author> <title> A correctness condition for memory shared among Byzantine clients. </title> <note> Submitted for publication. </note>
Reference-contexts: One of the purposes of this paper is to describe the implementation of two types of objects implemented at this layer: 1. Shared variables: A shared variable supports read and write operations by clients. For most classes of failure assumptions, we guarantee atomic updates <ref> [14, 22] </ref>, and under the most severe failure scenarios readers, writers, and (a limited number) of servers are all untrustedthen we provide only safe seman tics [14, 22]. 2. Mutual exclusion: A mutual exclusion object grants a right to at most one client out of some number of contending clients. <p> Shared variables: A shared variable supports read and write operations by clients. For most classes of failure assumptions, we guarantee atomic updates <ref> [14, 22] </ref>, and under the most severe failure scenarios readers, writers, and (a limited number) of servers are all untrustedthen we provide only safe seman tics [14, 22]. 2. Mutual exclusion: A mutual exclusion object grants a right to at most one client out of some number of contending clients. Phalanx supports at-most-one mutual exclusion and exactly-one mutual exclusion objects, differing in the conditions which guarantee that some client succeeds in gaining the right. <p> To properly present the semantics provided by our protocols and prove their correctness requires extending the standard treatment of concurrent objects in benign failure environment [14, 9] to an environment with Byzantine clients, which is beyond our scope here. The interested reader is referred to <ref> [22] </ref> for a formal treatment of this subject. Due to space limitations, we omit a proof for our protocol here. 3.2. Dishonest writers In this section, we address the case that writers may be dishonest. <p> Simpler emulations of exactly-one mutual exclusion objects using shared variables can be achieved using adaptations of Dijkstra's mutual exclusion algorithm [6] or Lam-port's bakery algorithm [12] to the case of faulty clients; see <ref> [22] </ref>. However, the consensus-object-based implementation described here, while somewhat more complex, offers certain advantages in practice. In particular, it enables a Phalanx server to ascertain, based on local data only, which client has succeeded in its contention (see [21]), e.g., to enforce access control to guarded objects.
Reference: [23] <author> D. Malkhi, M. Reiter, and A. Wool. </author> <title> The load and availability of Byzantine quorum systems. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 249257, </pages> <month> August </month> <year> 1997. </year>
Reference-contexts: Quorums can be surprisingly smalle.g., comprised of only O ( p n) out of a total of n serversand thus client access protocols can efficiently scale to hundreds and possibly even thousands of servers. Quorum systems can be constructed to tolerate failures ranging from benign to fully arbitrary <ref> [20, 23] </ref>, and for either type of failure can provide either strict consistency guarantees or only probabilistic ones [24]. Phalanx allows clients to dynamically tune the quorums they use for their application needs. Quorums are fundamental to Phalanx, and all objects are implemented using quorum-based protocols. <p> Scalability with growth in the number of servers is primarily dictated by the quorum system used, as quorum systems exist with a wide array of properties <ref> [20, 23, 24] </ref>. For example, there are dissemination constructions whose re silience is b = p 2 and that have quorum sizes as small as O (n 3=4 ) (so, e.g., for n = 1000, quorum size is &lt; 200).
Reference: [24] <author> D. Malkhi, M. Reiter, A. Wool and R. Wright. </author> <title> Probabilistic quorum systems. </title> <note> Submitted for publication. Preliminary version appears in Proceedings of the 16th ACM Symposium on Principles of Distributed Computing, pages 267273, </note> <month> August </month> <year> 1997. </year>
Reference-contexts: Quorum systems can be constructed to tolerate failures ranging from benign to fully arbitrary [20, 23], and for either type of failure can provide either strict consistency guarantees or only probabilistic ones <ref> [24] </ref>. Phalanx allows clients to dynamically tune the quorums they use for their application needs. Quorums are fundamental to Phalanx, and all objects are implemented using quorum-based protocols. <p> Scalability with growth in the number of servers is primarily dictated by the quorum system used, as quorum systems exist with a wide array of properties <ref> [20, 23, 24] </ref>. For example, there are dissemination constructions whose re silience is b = p 2 and that have quorum sizes as small as O (n 3=4 ) (so, e.g., for n = 1000, quorum size is &lt; 200).
Reference: [25] <author> D. Powell, </author> <title> editor. Group communication. </title> <journal> Communications of the ACM 39(4), </journal> <month> April </month> <year> 1996. </year>
Reference-contexts: Because every server must reliably receive every request, this approach generally does not scale well. Numerous other approaches that support persistent and/or replicated data in a distributed system with tolerance to only benign (crash) failures are not suitable, either. These can be coarsely categorized as group communication systems (see <ref> [25] </ref>), distributed transactional systems (e.g., Argus [15], and Thor [18]), and shared-memory emulation systems (e.g., Ivy [17] and Munin [3]). Though these systems allow more efficient data access than Phalanx, their simpler access protocols cannot mask the arbitrary corruption of data replicas.
Reference: [26] <author> M. K. Reiter. </author> <title> Secure agreement protocols: Reliable and atomic group multicast in Rampart. </title> <booktitle> In Proceedings of the 2nd ACM Conference on Computer and Communications Security, </booktitle> <pages> pages 6880, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: In particular, the foremost approach for building a survivable service today is state machine replication [28], in which every (available) server receives, processes, and responds to every client request; some examples of systems implementing this approach are <ref> [29, 26, 11] </ref>. Because every server must reliably receive every request, this approach generally does not scale well. Numerous other approaches that support persistent and/or replicated data in a distributed system with tolerance to only benign (crash) failures are not suitable, either. <p> To guard against this, an echo protocol is employed in all write operations to guarantee agreement on the written value among the servers. The echo protocol borrows its name and functionality from the echo protocol in Rampart <ref> [26] </ref>. An echo protocol works as follows: To send an update to the servers, a writer first obtains signed echoes for the update from a quorum of servers. It then writes the new value with the attached set of echoes to each server in some quorum.
Reference: [27] <author> M. K. Reiter, M. K. Franklin, J. B. Lacy, and R. N. Wright. </author> <title> The key management service. </title> <journal> Journal of Computer Security 4(4):267 287, </journal> <year> 1996. </year>
Reference-contexts: These functions may include certificate-generating services that create certificates (i.e., bindings associating attributes to public keys) as in <ref> [19, 27] </ref>, revocation services that enable a client to promptly invalidate her certificate as in [8, 16], and directory services that enable a client to locate the most up-to-date certificate for a name or key, such as X.509 directories [10].
Reference: [28] <author> F. B. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys 22(4):299 319, </journal> <month> December </month> <year> 1990. </year>
Reference-contexts: And not surprisingly, known approaches to building fault-tolerant replicated data and shared data abstractions do not suffice for our goals. In particular, the foremost approach for building a survivable service today is state machine replication <ref> [28] </ref>, in which every (available) server receives, processes, and responds to every client request; some examples of systems implementing this approach are [29, 26, 11]. Because every server must reliably receive every request, this approach generally does not scale well.
Reference: [29] <author> S. K. Shrivastava, P. D. Ezhilchelvan, N. A. Speirs, S. Tao, and A. Tully. </author> <title> Principal features of the VOLTAN family of reliable node architectures for distributed systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41(5):542549, </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: In particular, the foremost approach for building a survivable service today is state machine replication [28], in which every (available) server receives, processes, and responds to every client request; some examples of systems implementing this approach are <ref> [29, 26, 11] </ref>. Because every server must reliably receive every request, this approach generally does not scale well. Numerous other approaches that support persistent and/or replicated data in a distributed system with tolerance to only benign (crash) failures are not suitable, either.
References-found: 29

