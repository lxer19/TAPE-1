URL: http://www.cs.rpi.edu/tr/94-12.ps
Refering-URL: http://www.cs.rpi.edu/tr/
Root-URL: http://www.cs.rpi.edu
Title: Automatic Verification of a Class of Symmetric Parallel Programs  
Author: Boleslaw K. Szymanski and Jose M. Vidal 
Keyword: Keyword Codes: C.1.2; C.4; I.6 Keywords: Multiprocessors; Performance of Systems; Simulation and Modeling  
Address: Troy, NY 12180-3590, USA  
Affiliation: Department of Computer Science, Rensselaer Polytechnic Institute,  
Abstract: This paper presents an efficient method of verification of a class of symmetric parallel programs characterized by a limited usage of communication variables. The limitation requires that any process identifier appearing in a condition must be a logical variable bounded by the universal or existential quantifier. Hence, programs in this class are only able to test whether a set of processes in a certain state is empty or not. Our approach to automatic verification is to reduce the verified program to a directed graph. Nodes of this diagraph represent different states of the program. Each edge of the diagraph is labeled with a predicate that must be satisfied if this edge is to be selected by a state transition. We use standard reachability analysis to verify the properties of the program. The efficiency of the approach results from the limitations imposed on the form of the conditions in the verified program. Using this method, we prove that a novel mutual exclusion program enforces mutual exclusion and is deadlock-free. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S.M. </author> <title> German and A.P. Sistala, "Reasoning about Systems with Many Processes," </title> <journal> Journal ACM, </journal> <volume> Vol. 39, No. 3, </volume> <year> 1992, </year> <pages> pp. 675-735. </pages>
Reference: 2. <author> L. Lamport, </author> <title> "The Mutual Exclusion Problem," </title> <journal> Journal ACM, </journal> <volume> Vol. 33, No. 2, </volume> <year> 1986, </year> <pages> pp. 313-326. </pages>
Reference-contexts: Symmetric Parallel Programs with Membership Tests In the following, we consider symmetric parallel programs satisfying the following properties: 1. There is a finite but unlimited number of processes executing the same program. 2. Programs are either reliable or can fail to abortions only <ref> [2] </ref>. 3. All communication variables are uniquely owned; i.e., each communication variable can only be changed by the one process that owns it; however, communication variables can be read by all processes. We will refer to such variables as specific communication variables. 4. <p> For example, for the program in Figure 1, the basic algorithm produced 157 global states, whereas the modified algorithm produced 6211 states (and found the mutual exclusion violation for non-atomic membership tests). Another simple extension of the algorithm enables verification in the presence of abortions. Following Lamport <ref> [2] </ref>, by the process abortion we mean an atomic operation that makes the process (i) stop executing its program at an arbitrary point of execution, (ii) set all its variables to initial values and, (iii) after an unspecified but finite delay, proceed again from the initial state.
Reference: 3. <author> Z. Manna and A. Pnueli, </author> <title> "An Exercise in the Verification of Multi-Process Programs," Beauty is our Business, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991, </year> <pages> pp. 289-301. </pages>
Reference-contexts: However, construction of the proof is not easy; it takes some creativity and effort to come up with the right set of invariants that will lead to a proof. In <ref> [3] </ref>, the same authors use similar machinery to provide temporal logic proof of the novel mutual exclusion program proposed by Szymanski in [6]. This program has interesting properties that allowed us to mechanize its proof of correctness. <p> Synchronized tests access communication variables in the same total order of the owner processes, but the whole test is otherwise a non-atomic operation. It is a simple generalization of the Lemma from <ref> [3] </ref> that synchronized non-atomicity is the weakest limitation on the membership tests necessary for the algorithm shown in Figure 1 to work correctly.
Reference: 4. <author> Z. Manna and A. Pnueli, </author> <title> "Tools and Rules for the Practicing Verifier," </title> <institution> Carnegie Mellon University, Computer Science: A 25th Anniversary Commemorative, ACM Press, </institution> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: The demonstration of their correctness is usually done by informal methods. While such a demonstration might be sufficient for some cases, it is always desirable and sometimes necessary to prove that the program does indeed work in all possible executions. In <ref> [4] </ref>, Manna and Pnueli proposed a system of temporal logic constructs that could be used when proving properties of parallel programs. However, construction of the proof is not easy; it takes some creativity and effort to come up with the right set of invariants that will lead to a proof.
Reference: 5. <author> A. Pnueli and L. Zuck, </author> <title> "Verification of Multiprocess Probabilistic Protocols," </title> <journal> Distributed Computing, </journal> <volume> Vol. 1, No. 1, </volume> <year> 1986, </year> <pages> pp. 53-72. </pages>
Reference: 6. <author> B. K. Szymanski, </author> <title> "Mutual Exclusion Revisited," </title> <booktitle> Proc. Fifth Jerusalem Conference on Information Technology, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1990, </year> <pages> pp. 110-117. </pages>
Reference-contexts: In [3], the same authors use similar machinery to provide temporal logic proof of the novel mutual exclusion program proposed by Szymanski in <ref> [6] </ref>. This program has interesting properties that allowed us to mechanize its proof of correctness. <p> On the other hand, such a test cannot be used to check if the particular process is a member of such a set of processes. As an example of a parallel program satisfying these conditions, we consider the mutual exclusion algorithm from <ref> [6] </ref> given in Figure 1. We assume that there are n executing processes and that the process identifiers are numbered from 0 to n 1 and processes are ordered by their identifiers. The variable pid denotes the identifier of the process executing the given instance of the program. <p> The variable pid denotes the identifier of the process executing the given instance of the program. Properties of this program are discussed elsewhere <ref> [6] </ref>. Below, we outline a methodology for translating such programs into state diagraphs and an algorithm for state reachability that is used to verify the properties of the translated program. As an example, we also show how mutual exclusion enforcement and deadlock freedom can be proved in this manner. 3.
References-found: 6

