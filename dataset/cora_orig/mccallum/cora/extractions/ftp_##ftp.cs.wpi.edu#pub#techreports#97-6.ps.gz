URL: ftp://ftp.cs.wpi.edu/pub/techreports/97-6.ps.gz
Refering-URL: http://cs.wpi.edu/Resources/techreports/index.html
Root-URL: 
Title: A Model for Designing Adaptable Software Components  
Author: by George T. Heineman 
Date: (revised) February 1998  
Pubnum: WPI-CS-TR-97-6  
Abstract: Computer Science Technical Report Series WORCESTER POLYTECHNIC INSTITUTE Computer Science Department 100 Institute Road, Worcester, Massachusetts 01609-2280 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Gregory D. Abowd, Robert Allen, and David Garlan. </author> <title> Formalizing Style to Understand Descriptions of Software Architecture. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 4(4):319 364, </volume> <month> October </month> <year> 1995. </year>
Reference-contexts: Components are active computational entities whose interface defines methods to invoke, events to receive and/or send or complex access protocols <ref> [1] </ref>. An active interface decides whether to take action when a method is called, an event is announced, or a protocol executes. Following the Acme ontology [3], components have ports that represent interaction points between the component and other components in the system. <p> Figure 3a ComponentArbitrator ca = new ComponentArbitrator (); | private void evaluate (Node node) - | // before Evaluate (Node) function | if (arbitrator != null) - Class params [] = ca.paramList ("adapt.spreadsheet.Node"); | Object args [] = new Object <ref> [1] </ref>; try - | args [0] = node; ca.insertCallback (ca.BEFORE, "evaluate", gl, | arbitrator.invokeCallback (BEFORE, "evaluate", args); glueClass.getDeclaredMethod ("beforeEvaluate", params)); | - | ca.insertCallback (ca.AFTER, "evaluate", gl, | // Original Evaluate Function... glueClass.getDeclaredMethod ("afterEvaluate", params)); | catch (NoSuchMethodException nsme) - | if (arbitrator != null) - System.err.println ("Unable to install callbacks."); <p> ca.insertCallback (ca.BEFORE, "evaluate", gl, | arbitrator.invokeCallback (BEFORE, "evaluate", args); glueClass.getDeclaredMethod ("beforeEvaluate", params)); | - | ca.insertCallback (ca.AFTER, "evaluate", gl, | // Original Evaluate Function... glueClass.getDeclaredMethod ("afterEvaluate", params)); | catch (NoSuchMethodException nsme) - | if (arbitrator != null) - System.err.println ("Unable to install callbacks."); | Object args [] = new Object <ref> [1] </ref>; - | args [0] = node; ss.setArbitrator (ca); | arbitrator.invokeCallback (AFTER, "evaluate", args); | - (a) Creating callbacks | (b) Invoking callbacks contains a fragment of code showing (from our Java implementation) how the application-builder sets up before-and after- callback functions for evaluate, from the class glueClass.
Reference: [2] <editor> ACM press. </editor> <booktitle> ACM Reflection '96, </booktitle> <address> San Francisco, CA, </address> <month> April </month> <year> 1996. </year>
Reference-contexts: This particular wrapping approach is heavily dependent upon C++ and adds an extra class/object layer instead of extending the responsibilities of the interface. Active interfaces have similar goals to reflection <ref> [2] </ref>, a design principle whereby a system has a representation of itself that makes it easy to adapt the system to changing environments, and meta-object protocols [19], where an interface allows incremental modification of the behavior and implementation of a component.
Reference: [3] <author> John E. Arnold and Steven S. Popovich. </author> <title> Integrating, Customizing and Extending Environments with a Message-Based Architecture. </title> <type> Technical Report CUCS-008-95, </type> <institution> Columbia University, Department of Computer Science, </institution> <month> September </month> <year> 1994. </year> <note> The research described in this report was conducted at Bull HN Information Systems, </note> <institution> Inc. </institution>
Reference-contexts: Active interfaces provide an alternative to the common "wrapping" approach, whereby an extra layer is written around an object to alter its behavior. ADL compatibility We build upon the large body of work on Architectural Description Languages (ADLs). Thus the component specification language must be compatible with Acme <ref> [3] </ref>, the standard interchange language for architectural descriptions. <p> As an Interface Description Language [23], CSL describes the interface for adaptable components, and is used to define the adaptation policies. As an Architectural Description Language <ref> [3] </ref>, CSL describes the interactions between components and the internal (private) structure of a component. CSL extends Acme [3] to describe the internal structure of a component without revealing its implementation. <p> As an Interface Description Language [23], CSL describes the interface for adaptable components, and is used to define the adaptation policies. As an Architectural Description Language <ref> [3] </ref>, CSL describes the interactions between components and the internal (private) structure of a component. CSL extends Acme [3] to describe the internal structure of a component without revealing its implementation. A benefit of this language-based approach is that the same language used by the designer to describe the interface of their component is used by an application builder when determining how to adapt the component. <p> Components are active computational entities whose interface defines methods to invoke, events to receive and/or send or complex access protocols [1]. An active interface decides whether to take action when a method is called, an event is announced, or a protocol executes. Following the Acme ontology <ref> [3] </ref>, components have ports that represent interaction points between the component and other components in the system. A port is active when there is any communication between the port and its attached connector. <p> An ADL is not intended to capture all details of an application (that is the responsibility of the underlying programming language of the components), but it should provide some structural assistance when adapting components. CSL extends the Acme <ref> [3] </ref> language in significant ways as outlined in this paper. Active interfaces are related to all work that seeks to alter the invocation of a component. From a syntactic point of view, the before- and after- phases are similar to the Lisp advice facility described in [21].
Reference: [4] <author> K. Arnold and J. Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: An end-user adapts a software component to a new environment by writing new code to alter existing functionality. 1.1 Context Our framework for adaptable software components is independent of programming language and software architecture. For this paper, however, we assume that the components are written in Java <ref> [4] </ref> and that applications follow the JavaBeans [16] software component model. A Java Bean is a reusable software component that can be manipulated visually in a design environment, such as the sample Bean Developers Kit (BDK) shipped with the initial release of JavaBeans.
Reference: [5] <author> Don Batory and Sean O'Malley. </author> <title> The Design and Implementation of Hierarchical Software Systems with Reusable Components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(4) </volume> <pages> 355-398, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: There are many issues involved, ranging from how the components and arbitrators communicate, how they resolve differences, and what architecture is suitable for multiple arbitrators. Some existing component-based architectures, for example, place restrictions on the component communication. Batory and O'Malley <ref> [5] </ref> define a hierarchical layering of components, each of which is limited to communicating with the component one higher/lower in the hierarchy. We believe that components should be relatively insulated from the application architecture, and the arbitrator should be in charge of acquiring semantic information.
Reference: [6] <author> Israel Z. Ben-Shaul and Gail E. Kaiser. </author> <title> A Paradigm for Decentralized Process Modeling and its Realization in the OZ Environment. </title> <booktitle> In 16th International Conference on Software Engineering, </booktitle> <pages> pages 179-188, </pages> <address> Sorrento, Italy, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Our previous work with the Programming Systems Laboratory at Columbia University involved constructing a Process Centered Environment, called Oz <ref> [6] </ref>, that supported extended transaction models. As described in [11], we developed an architecture for constructing systems from pre-existing, independently developed software components. The primary difficulty we encountered was forcing components to adapt to fit within a larger application. This is distinct from the architectural mismatch described in [9].
Reference: [7] <author> Michael J. Carey, David J. Dewitt, Goetz Graefe, Favid M. Haight, Joel E. Richardson, Daniel T. Schuh, Eugene J. Shekita, and Scott L. Vandenburg. </author> <title> The EXODUS Extensible DBMS Project: An Overview. </title> <editor> In Stanley B. Zdonik and David Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, chapter 7.3, </booktitle> <pages> pages 474-499. </pages> <publisher> Morgan Kaufman, </publisher> <address> San Mateo CA, </address> <year> 1990. </year>
Reference-contexts: In [12] we re-engineered the active interface within the Exodus storage manager <ref> [7] </ref>, thus allowing Exodus to negotiate with the same component arbitrator to change its behavior. The success of this preliminary work confirms that software components can provide an interface for adaptation. Table 1 describes the size of the Bean components developed for this paper.
Reference: [8] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference-contexts: action Glue4.retValue (int); String getTableValue (int col, int row) - before Glue4.retValue (col); -; component tbR adapts TableBean - code codeR.jar; property int topRow; action Glue5.retValue (int); String getTableValue (int col, int row) - before Glue5.retValue (row); -; single "best" algorithm or implementation (see Template Method pattern for similar justification <ref> [8] </ref>). The component designer could produce multiple components, each one optimized for a different context, but this defeats the purpose of reuse. Alternatively one could pre-package a set of implementations (such as OIA/D [15]), but this continues to limit the possible solutions.
Reference: [9] <author> D. Garlan, R. Allen, and J. Ockerbloom. </author> <title> Architectural Mismatch or Why it's Hard to Build Systems out of Existing Parts. </title> <booktitle> In 17th International Conference on Software Engineering, </booktitle> <pages> pages 179-185, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: As described in [11], we developed an architecture for constructing systems from pre-existing, independently developed software components. The primary difficulty we encountered was forcing components to adapt to fit within a larger application. This is distinct from the architectural mismatch described in <ref> [9] </ref>. As part of this earlier work, we designed an extensible transaction manager component (written in C) with an active interface and a component arbitrator with a special language for tailoring its behavior based upon user-defined scenarios [10, 12].
Reference: [10] <author> George T. Heineman. </author> <title> A Transaction Manager Component Supporting Extended Transaction Models. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: This is distinct from the architectural mismatch described in [9]. As part of this earlier work, we designed an extensible transaction manager component (written in C) with an active interface and a component arbitrator with a special language for tailoring its behavior based upon user-defined scenarios <ref> [10, 12] </ref>. In [12] we re-engineered the active interface within the Exodus storage manager [7], thus allowing Exodus to negotiate with the same component arbitrator to change its behavior. The success of this preliminary work confirms that software components can provide an interface for adaptation.
Reference: [11] <author> George T. Heineman and Gail E. Kaiser. </author> <title> An Architecture for Integrating Concurrency Control into Environment Frameworks. </title> <booktitle> In 17th International Conference on Software Engineering, </booktitle> <pages> pages 305-313, </pages> <address> Seattle, WA, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: Our previous work with the Programming Systems Laboratory at Columbia University involved constructing a Process Centered Environment, called Oz [6], that supported extended transaction models. As described in <ref> [11] </ref>, we developed an architecture for constructing systems from pre-existing, independently developed software components. The primary difficulty we encountered was forcing components to adapt to fit within a larger application. This is distinct from the architectural mismatch described in [9].
Reference: [12] <author> George T. Heineman and Gail E. Kaiser. </author> <title> The CORD approach to Extensible Concurrency Control. </title> <booktitle> In 13th International Conference on Data Engineering, </booktitle> <pages> pages 562-571, </pages> <address> Birmingham, UK, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: The arbitrator then acquires the information and executes actions according to the CSL specification. A CSL specification describes the syntactic interface of a component and all policy decisions that are known to be adaptable. In our previous work <ref> [12] </ref>, which focused on extending concurrency control for databases, we called this a "mediator-based" approach since the arbitrator acted as a mediator between different system components. <p> The policies defined in this language describe situations when the component allow adaptation. Our current implementation has successfully been used to adapt the behavior of a a transaction manager to implement different extended transaction models <ref> [12] </ref>. Returning to our motivating example, the application builder implements adaptation A2 by efficiently filtering the update messages from ss to tb. The specification for app in Figure 6 has a VisibleCells port representing the current region of visible cells. <p> This is distinct from the architectural mismatch described in [9]. As part of this earlier work, we designed an extensible transaction manager component (written in C) with an active interface and a component arbitrator with a special language for tailoring its behavior based upon user-defined scenarios <ref> [10, 12] </ref>. In [12] we re-engineered the active interface within the Exodus storage manager [7], thus allowing Exodus to negotiate with the same component arbitrator to change its behavior. The success of this preliminary work confirms that software components can provide an interface for adaptation. <p> This is distinct from the architectural mismatch described in [9]. As part of this earlier work, we designed an extensible transaction manager component (written in C) with an active interface and a component arbitrator with a special language for tailoring its behavior based upon user-defined scenarios [10, 12]. In <ref> [12] </ref> we re-engineered the active interface within the Exodus storage manager [7], thus allowing Exodus to negotiate with the same component arbitrator to change its behavior. The success of this preliminary work confirms that software components can provide an interface for adaptation.
Reference: [13] <author> Sybase Incorporated. </author> <title> ActiveX Components for Windows Applications, </title> <month> July </month> <year> 1997. </year> <title> Internet site (http://www.visualcomp.com). </title>
Reference-contexts: A review of the literature on component-based software development reveals many types of components, such as calendars and calculators, but increasingly more powerful components are also being developed. Visual Components <ref> [13] </ref> are a collection of ActiveX components for Windows applications, such as spreadsheets, spell checkers, html browsers, and database front-ends. A recent NIST Advanced Technology Program [18] involves sixteen companies pursuing the automated composition of complex large-scale applications from "relatively small" fine-grained components.
Reference: [14] <author> Rushikesh K. Joshi, N. Vivekananda, and D. Janakiram. </author> <title> Message Filters for Object-Oriented Sys--tems. </title> <journal> Software Practice& Experience, </journal> <volume> 27(6) </volume> <pages> 677-699, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: Active interfaces are related to all work that seeks to alter the invocation of a component. From a syntactic point of view, the before- and after- phases are similar to the Lisp advice facility described in [21]. Alternatively, Filter objects <ref> [14] </ref> manipulate and/or disallow messages between objects and act transparently without violating the encapsulation of the target objects. This particular wrapping approach is heavily dependent upon C++ and adds an extra class/object layer instead of extending the responsibilities of the interface.
Reference: [15] <author> Gregor Kiczales, John Lamping, Cristina Lopes, Chris Maeda, Anurag Mendherkar, and Gail Mur-phy. </author> <title> Open Implementation Design Guidelines. </title> <booktitle> In 19th International Conference on Software Engineering, </booktitle> <pages> pages 481-490, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: The component designer could produce multiple components, each one optimized for a different context, but this defeats the purpose of reuse. Alternatively one could pre-package a set of implementations (such as OIA/D <ref> [15] </ref>), but this continues to limit the possible solutions. The arbitrator allows the application builder to adapt the behavior of the component as required and retain the default behavior for most cases. <p> Active interfaces are similar to the wrapping of internal objects in C2 [24] except that they allow user-defined functions to be inserted and they can also affect private methods of the component. Finally, active interfaces are distinct from the pre-packaged implementation strategies of OIA/D from which the client selects <ref> [15] </ref>. OIA/D sketches a solution showing how the client can provide their own implementation strategy, but typically an entire method for a component is replaced.
Reference: [16] <author> Sun Microsystems, Inc. </author> <title> JavaBeans 1.0 API Specification. Internet site (http://www.javasoft.com/beans), December 4, </title> <year> 1996. </year>
Reference-contexts: There will be an increasing problem (perhaps we may call it the software component crisis) in using components constructed by other developers. There may be no way to standardize these heterogeneous components (although consider component models such as JavaBeans <ref> [16] </ref>) and there is no guarantee that an application builder will find a component to exactly match a particular need. <p> For this paper, however, we assume that the components are written in Java [4] and that applications follow the JavaBeans <ref> [16] </ref> software component model. A Java Bean is a reusable software component that can be manipulated visually in a design environment, such as the sample Bean Developers Kit (BDK) shipped with the initial release of JavaBeans.
Reference: [17] <author> Nenad Medvidovic and Richard N. Taylor. </author> <title> A Framework for Classifying and Comparing Arhchitec-tural Description Languages. </title> <booktitle> In Proceedings of the 6th European Software Engineering Conference ESEC '97, </booktitle> <year> 1997. </year>
Reference-contexts: This is the novel addition of our work. Few ADLs support any notion of evolution, and those that do are limited to structural sub-typing <ref> [17] </ref>. An ADL is not intended to capture all details of an application (that is the responsibility of the underlying programming language of the components), but it should provide some structural assistance when adapting components. CSL extends the Acme [3] language in significant ways as outlined in this paper.
Reference: [18] <institution> National Institute of Standards and Technology. ATP Focused Program: </institution> <note> Component-Based Software. Internet publication (http://www.atp.nist.gov/atp/focus/cbs.htm). </note>
Reference-contexts: Visual Components [13] are a collection of ActiveX components for Windows applications, such as spreadsheets, spell checkers, html browsers, and database front-ends. A recent NIST Advanced Technology Program <ref> [18] </ref> involves sixteen companies pursuing the automated composition of complex large-scale applications from "relatively small" fine-grained components. These "Black box" components allow minimal customization and are reusable only if they exactly match a particular need in an application.
Reference: [19] <author> Xerox Parc. </author> <title> Metaobject Protocols. Internet site (http://www.parc.xerox.com/spl/projects/mops). </title>
Reference-contexts: Active interfaces have similar goals to reflection [2], a design principle whereby a system has a representation of itself that makes it easy to adapt the system to changing environments, and meta-object protocols <ref> [19] </ref>, where an interface allows incremental modification of the behavior and implementation of a component. Active interfaces are similar to the wrapping of internal objects in C2 [24] except that they allow user-defined functions to be inserted and they can also affect private methods of the component.
Reference: [20] <author> David L. Parnas. </author> <title> Designing Software for Ease of Extension and Contraction. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 5(6) </volume> <pages> 310-320, </pages> <month> March </month> <year> 1979. </year>
Reference-contexts: Nearly twenty years ago, Parnas observed that software should be designed to be easily extended and contracted <ref> [20] </ref>; the difficulty, of course, lies in foreseeing exactly what features will be adapted. For example, when component C1 interacts with component C2, C1 knows its past history, its future actions, and its usage patterns of C2.
Reference: [21] <author> T. V. Raman. Emacspeak: </author> <title> A Speech-Enabling Interface. </title> <journal> Dr. Jobb's Journal, </journal> <volume> 22(1) </volume> <pages> 18-23, </pages> <month> September </month> <year> 1997. </year>
Reference-contexts: Active interfaces are related to all work that seeks to alter the invocation of a component. From a syntactic point of view, the before- and after- phases are similar to the Lisp advice facility described in <ref> [21] </ref>. Alternatively, Filter objects [14] manipulate and/or disallow messages between objects and act transparently without violating the encapsulation of the target objects. This particular wrapping approach is heavily dependent upon C++ and adds an extra class/object layer instead of extending the responsibilities of the interface.
Reference: [22] <author> Margo I. Seltzer and Christopher Small. </author> <title> Self-monitoring and Self-adapting Operating Systems. </title> <booktitle> In Sixth Workshop on Hot Topics in Operating Systems, </booktitle> <address> Cape Cod, MA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: In C2, the internal wrapped component does not initiate interactions with the DCM, but our framework depends on the component requesting assistance from the arbitrator when making key decisions. The arbitrator is also more powerful than techniques that simply monitor a component's usage. The designers of VINO <ref> [22] </ref>, an extensible operating system, suggest that the operating systems kernel can monitor the usage of its resources and adapt to different workload conditions, but the ways in which the component adapts are all pre-determined, fixed implementations. 5 CONCLUSION 5.1 Past Success There needs to be increased awareness that software components
Reference: [23] <author> R. Snodgrass. </author> <title> The Interface Description Language: Definition and Use. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year>
Reference-contexts: Throughout, we include ADL fragments showing how component specifications are modified to reflect their specifications. 3.1 Component specification language We are developing a Component Specification Language (CSL) as a common means for describing the interface for a component and its adaptations. As an Interface Description Language <ref> [23] </ref>, CSL describes the interface for adaptable components, and is used to define the adaptation policies. As an Architectural Description Language [3], CSL describes the interactions between components and the internal (private) structure of a component.
Reference: [24] <author> Richard Taylor, Nenad Medvidovic, Kenneth Anderson, James Whitehead, </author> <title> and Jason Robbins. </title>
Reference-contexts: Active interfaces are similar to the wrapping of internal objects in C2 <ref> [24] </ref> except that they allow user-defined functions to be inserted and they can also affect private methods of the component. Finally, active interfaces are distinct from the pre-packaged implementation strategies of OIA/D from which the client selects [15]. <p> The arbitrator is a more generalized instance of the Dialog and Constraint Manager (DCM) in the C2 architectural style <ref> [24] </ref>. In C2, the internal wrapped component does not initiate interactions with the DCM, but our framework depends on the component requesting assistance from the arbitrator when making key decisions. The arbitrator is also more powerful than techniques that simply monitor a component's usage.
References-found: 24

