URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/jr-impl.ps
Refering-URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/index.html
Root-URL: http://www.cs.uiuc.edu
Email: fkaming@cs.uiuc.edu  
Title: Language implementation via lightweight embedded program generators (Extended Abstract)  
Author: Sam Kamin 
Address: 1304 W. Springfield Urbana, IL 61801  
Affiliation: Computer Science Dept. University of Illinois at Urbana-Champaign  
Abstract: The interpreter for the functional language JR has been constructed by a unique form of bootstrapping. The entire processor is written in C++, but much of that C++ is produced by program generators. These program generators | a lexer generator, parser generator, etc. | are programmed in JR itself by the method of "lightweight embedding." This project is intended to demonstrate the viability of this method of constructing program generators. Because the method of embedding yields powerful languages at modest cost, we view it as a potentially advantageous approach to the production of program generators, which can in turn yield an entirely new method of achieving code reuse. fl Partially supported by NSF grant CCR 96-19644
Abstract-found: 1
Intro-found: 1
Reference: [Balzer et al. 97] <author> B. Balzer, N. Goldman, D. Wile, </author> <title> Rationale and Support for Domain Specific Languages, </title> <journal> USC/Information Sciences Institute, </journal> <note> available at http://www.isi.edu/software-sciences/dssa/dssls/dssls.html. </note>
Reference-contexts: Yet these facilities are used only for generating Lisp programs. Similarly, the MetaML system [SheardNelson 95] | essentially, type-checked ML macros | is used only to generate ML programs. Program generation as a more routine programming methodology has also been advocated by <ref> [Balzer et al. 97, Bell et al. 94] </ref>. One difference between that work and ours is that our approach requires much less mechanism. In those, program generators are specified in a very high level language from which an automatic translation to low-level form is attempted.
Reference: [Bell et al. 94] <author> J. Bell, F. Bellegarde, J. Hook, R.B. Kieburtz, A. Kotov, J. Lewis, L. McKinney, D.P. Oliva, T. Shear, L. Tong, L. Walton, and T. Zhou, </author> <title> Software design for reliabiity and reuse: A proof-of-concept demonstration, </title> <address> TRI-Ada '94. </address>
Reference-contexts: Yet these facilities are used only for generating Lisp programs. Similarly, the MetaML system [SheardNelson 95] | essentially, type-checked ML macros | is used only to generate ML programs. Program generation as a more routine programming methodology has also been advocated by <ref> [Balzer et al. 97, Bell et al. 94] </ref>. One difference between that work and ours is that our approach requires much less mechanism. In those, program generators are specified in a very high level language from which an automatic translation to low-level form is attempted.
Reference: [Claessen et al. 97] <author> K. Claessen, E. Meijer, T. Vullinghs, </author> <title> Structuring graphical paradigms in Tk-Gofer, </title> <booktitle> Proc. Intl. Conf. on Func. Prog. (ICFP '97), </booktitle> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: The de-velopment of languages for domains as diverse as computer music [Hudak et al. 95], animation [Elliott 97, HudakElliott 97], GUI programming <ref> [Claessen et al. 97] </ref>, and picture-drawing [KaminHyatt 97], have shown the potential for the lightweight embedding approach. However, such applications are somewhat exotic and far removed from ordinary software-engineering concerns.
Reference: [Elliott 97] <author> C. Elliott, </author> <title> Modeling interactive 3D and multimedia animation with an embedded language, </title> <booktitle> Proc. USENIX Conf. on Domain-Specific Languages, </booktitle> <address> Santa Barbara, </address> <month> Oct. </month> <year> 1997, </year> <pages> 285-296. </pages>
Reference-contexts: The de-velopment of languages for domains as diverse as computer music [Hudak et al. 95], animation <ref> [Elliott 97, HudakElliott 97] </ref>, GUI programming [Claessen et al. 97], and picture-drawing [KaminHyatt 97], have shown the potential for the lightweight embedding approach. However, such applications are somewhat exotic and far removed from ordinary software-engineering concerns.
Reference: [HudakElliott 97] <author> C. Elliott, P. Hudak, </author> <title> Functional reactive animation, </title> <booktitle> Proc. Intl. Conf. on Functional Programming, </booktitle> <year> 1997. </year>
Reference-contexts: The de-velopment of languages for domains as diverse as computer music [Hudak et al. 95], animation <ref> [Elliott 97, HudakElliott 97] </ref>, GUI programming [Claessen et al. 97], and picture-drawing [KaminHyatt 97], have shown the potential for the lightweight embedding approach. However, such applications are somewhat exotic and far removed from ordinary software-engineering concerns.
Reference: [FriedmanWandHaynes 92] <author> D.P. Friedman, M. Wand, </author> <title> C.T. Haynes, Essentials of Programming Languages, </title> <publisher> The MIT Press and McGraw-Hill, </publisher> <year> 1992. </year>
Reference-contexts: On the other hand, we do not see this works as bearing much relation to tools for constructing languages "from scratch", such as ELI [Gray et al. 92], the Synthesizer Generator [RepsTeitelbaum 89], and ASF/SDF [VanDeursen et al. 96], or the well-known method of meta-circular interpreters <ref> [FriedmanWandHaynes 92] </ref>. As stated above, those methods of processor construction have little to say about language design.
Reference: [Gelernter et al. 60] <author> Gelernter, H., J. R. Hansen, and C. L. Gerberich, </author> <title> A FORTRAN-Compiled List Processing Language, </title> <journal> Journal of the ACM, </journal> <volume> Vol. 7, No. 2, </volume> <year> 1960, </year> <pages> pp. 87-101. 10 </pages>
Reference-contexts: The advantage of lightweight embedding is that it addresses both parts of our question: it facilitates implementation and helps to produce a high-quality language, both because of what is inherited from the host language. An early example of embedding was the FLPL system of Gelernter <ref> [Gelernter et al. 60] </ref>, an embedding in FORTRAN of list-processing facilities. Both features of embedding were crucial: the ability to rely on Fortran eliminated the need to write a parser, implement a wide variety of language features (I/O, procedures, etc.), and produce a well-engineered language processor.
Reference: [Gray et al. 92] <author> R. W. Gray, V. P. Heuring, S. P. Levi, A. M. Sloane, and W. M. Waite, Eli: </author> <title> A Complete, Flexible Compiler Construction System, </title> <journal> Communications of the ACM, </journal> <volume> 35(2) </volume> <pages> 121-131, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: On the other hand, we do not see this works as bearing much relation to tools for constructing languages "from scratch", such as ELI <ref> [Gray et al. 92] </ref>, the Synthesizer Generator [RepsTeitelbaum 89], and ASF/SDF [VanDeursen et al. 96], or the well-known method of meta-circular interpreters [FriedmanWandHaynes 92]. As stated above, those methods of processor construction have little to say about language design.
Reference: [Hudak 96] <author> P. Hudak, </author> <title> Building domain-specific embedded languages, </title> <booktitle> position paper for Workshop on Software Engineering and Programming Languages, </booktitle> <address> Cambridge, MA, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: It draws particularly from the recent work on embedding and the more classical work on program generation. 2.1 Lightweight embedding How can one easily design and implement a high-quality language for an application domain? This is one of the key issues in the programming languages field. Lightweight embedding <ref> [Hudak 96] </ref> refers to the process of obtaining a new language (the domain-specific language, or DSL) by programming in an existing language (the host language).
Reference: [Hudak et al. 95] <author> Paul Hudak, Tom Makucevich, Syam Gadde, Bo Whong, </author> <title> Haskore music notation: An algebra of music, </title> <journal> J. Func. Prog., </journal> <note> to appear. </note>
Reference-contexts: The de-velopment of languages for domains as diverse as computer music <ref> [Hudak et al. 95] </ref>, animation [Elliott 97, HudakElliott 97], GUI programming [Claessen et al. 97], and picture-drawing [KaminHyatt 97], have shown the potential for the lightweight embedding approach. However, such applications are somewhat exotic and far removed from ordinary software-engineering concerns.
Reference: [KaminHyatt 97] <author> S. Kamin, D. Hyatt, </author> <title> A special-purpose language for picture-drawing, </title> <booktitle> Proc. USENIX Conf. on Domain-Specific Languages, </booktitle> <address> Santa Barbara, </address> <month> Oct. </month> <year> 1997, </year> <pages> 297-310. </pages>
Reference-contexts: The de-velopment of languages for domains as diverse as computer music [Hudak et al. 95], animation [Elliott 97, HudakElliott 97], GUI programming [Claessen et al. 97], and picture-drawing <ref> [KaminHyatt 97] </ref>, have shown the potential for the lightweight embedding approach. However, such applications are somewhat exotic and far removed from ordinary software-engineering concerns. Our program generators are just examples of embedded languages, but they are examples that point the way to the broader application of embedding in "ordinary" programming.
Reference: [Levine et al. 92] <author> John R. Levine, Tony Mason, Doug Brown. </author> <title> Lex & Yacc, 2nd Ed. </title> <publisher> O'Reilly & Associates, </publisher> <year> 1992. </year>
Reference-contexts: As stated above, those methods of processor construction have little to say about language design. Also, although we include in our program generators a lexer generator (analogous to lex <ref> [Levine et al. 92] </ref>), a parser generator (analogous to yacc [Levine et al. 92]), and an abstract syntax generator (analogous to Zephyr [Wang et al. 97]), we see the thrust of this work to be quite different from those efforts. <p> As stated above, those methods of processor construction have little to say about language design. Also, although we include in our program generators a lexer generator (analogous to lex <ref> [Levine et al. 92] </ref>), a parser generator (analogous to yacc [Levine et al. 92]), and an abstract syntax generator (analogous to Zephyr [Wang et al. 97]), we see the thrust of this work to be quite different from those efforts. In particular, those program generators lack a programming capability, which is what the embedding approach provides for free.
Reference: [Paulson 96] <author> L. Paulson, </author> <title> ML for the Working Programmer, </title> <publisher> Cambridge University Press, </publisher> <address> 2nd edition, </address> <year> 1996. </year>
Reference-contexts: In particular, specifications for the translation of AST operators to virtual machine code are given in VMG specifications embedded within a use of this homomorphism generator. Details are given below. The bootstrapping process began by developing these program generators in Standard ML <ref> [Paulson 96] </ref>. When the JR processor was working sufficiently well, they were ported to JR. The processor is now written entirely in JR and C++. 4 Lexing and Parsing We will not dwell on these languages, since many lexer and parser generators have been written.
Reference: [RepsTeitelbaum 89] <author> T. Reps, T. Teitilbaum, </author> <title> Synthesizer Generator Reference Manual, </title> <publisher> Springer-Verlag TELOS, </publisher> <year> 1989. </year>
Reference-contexts: On the other hand, we do not see this works as bearing much relation to tools for constructing languages "from scratch", such as ELI [Gray et al. 92], the Synthesizer Generator <ref> [RepsTeitelbaum 89] </ref>, and ASF/SDF [VanDeursen et al. 96], or the well-known method of meta-circular interpreters [FriedmanWandHaynes 92]. As stated above, those methods of processor construction have little to say about language design.
Reference: [SheardNelson 95] <author> T. Sheard, N. Nelson, </author> <title> Type safe abstractions using program generators, </title> <type> Tech. Report 95-013, </type> <institution> Oregon Graduate Institute, Computer Science Dept., </institution> <year> 1995. </year>
Reference-contexts: The macro facilities of the Lisp family of languages is perhaps the closest work to ours. Yet these facilities are used only for generating Lisp programs. Similarly, the MetaML system <ref> [SheardNelson 95] </ref> | essentially, type-checked ML macros | is used only to generate ML programs. Program generation as a more routine programming methodology has also been advocated by [Balzer et al. 97, Bell et al. 94].
Reference: [Spinellis 93] <author> Diomidis Spinellis, </author> <title> Implementing Haskell: Language implementation as a tool building exercise, </title> <booktitle> Software: Concepts and Tools 14, </booktitle> <year> 1993, </year> <pages> 37-48. </pages>
Reference-contexts: Yet the combination of these ideas does not seem to be so well known, nor to have been heavily exploited. (As a case in point, Spinellis <ref> [Spinellis 93] </ref> describes the construction of a Haskell compiler as an exercise in writing program generators in PERL.) The contribution of this paper is to show how far these ideas can be pushed.
Reference: [VanDeursen et al. 96] <author> A. Van Deursen, J. Heering, and P. Klint (eds.), </author> <title> Language Prototyping. An Algebraic Specification Approach, </title> <booktitle> vol. 5 of AMAST Series in Computing, World Scientific, </booktitle> <address> Singapore, </address> <year> 1996. </year>
Reference-contexts: On the other hand, we do not see this works as bearing much relation to tools for constructing languages "from scratch", such as ELI [Gray et al. 92], the Synthesizer Generator [RepsTeitelbaum 89], and ASF/SDF <ref> [VanDeursen et al. 96] </ref>, or the well-known method of meta-circular interpreters [FriedmanWandHaynes 92]. As stated above, those methods of processor construction have little to say about language design.
Reference: [Wang et al. 97] <author> D. Wang, A. Appel, J. Korn, C. Serra, </author> <title> The Zephyr abstract syntax description language, </title> <booktitle> Proc. USENIX Conf. on Domain-Specific Languages, </booktitle> <address> Santa Barbara, </address> <month> Oct. </month> <year> 1997, </year> <pages> 213-227. </pages>
Reference-contexts: Also, although we include in our program generators a lexer generator (analogous to lex [Levine et al. 92]), a parser generator (analogous to yacc [Levine et al. 92]), and an abstract syntax generator (analogous to Zephyr <ref> [Wang et al. 97] </ref>), we see the thrust of this work to be quite different from those efforts. In particular, those program generators lack a programming capability, which is what the embedding approach provides for free.
References-found: 18

