URL: http://www-cse.ucsd.edu/users/calder/papers/ASPLOS-94.ps.Z
Refering-URL: 
Root-URL: 
Email: fcalder,grunwaldg@cs.colorado.edu  
Title: Reducing Branch Costs via Branch Alignment  
Author: Brad Calder and Dirk Grunwald 
Keyword: Branch Prediction, Profile-based Optimization, Branch Target Buffers, Trace Scheduling.  
Address: Campus Box 430  Boulder, CO 80309-0430 USA  
Affiliation: Department of Computer Science  University of Colorado  
Abstract: Several researchers have proposed algorithms for basic block reordering. We call these branch alignment algorithms. The primary emphasis of these algorithms has been on improving instruction cache locality, and the few studies concerned with branch prediction reported small or minimal improvements. As wide-issue architectures become increasingly popular the importance of reducing branch costs will increase, and branch alignment is one mechanism which can effectively reduce these costs. In this paper, we propose an improved branch alignment algorithm that takes into consideration the architectural cost model and the branch prediction architecture when performing the basic block reordering. We show that branch alignment algorithms can improve a broad range of static and dynamic branch prediction architectures. We also show that a programs performance can be improved by approximately 5% even when using recently proposed, highly accurate branch prediction architectures. The programs are compiled by any existing compiler and then transformed via binary transformations. When implementing these algorithms on a Alpha AXP 21604 up to a 16% reduction in total execution time is achieved. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. A. Abu-Sufah, D. J. Kuck, and D. H. Lawrie. </author> <title> On the performance enhancement of paging systems through program analysis and transformation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-30(5):341-356, </volume> <month> May </month> <year> 1981. </year>
Reference-contexts: Optimization for Memory Hierarchies: Due to the expense of memory on early computers, much early work focused on reducing paging in virtual memory systems. Several researchers explored ways to group related subroutines or basic blocks onto the same virtual memory pages <ref> [1, 8, 11, 13, 10] </ref>. Other researchers extended this work to lower levels of the memory hierarchy, optimizing the performance of instruction caches. McFarling [15] described an algorithm to reduce instruction cache conflicts for a particular class of programs.
Reference: [2] <author> R. Alverson, D. Callahan, D. Cummings, B. Koblenz, A. Porterfield, and B. Smith. </author> <title> The tera computer system. </title> <booktitle> In International Conference on Supercomputing, </booktitle> <pages> pages 1-6, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The LIKELY model assumes that encoded information in the branch instruction indicates whether the branch is likely to be taken or not taken. This branch model is used by several architectures including the Tera <ref> [2] </ref>. The likely/unlikely flag can be set either using compile-time estimates [3] or profile information [9]. We use profile information since it is much more accurate and simple to gather with appropriate tools [23]. Program transformation can help these branch prediction architectures reduce misfetch and misprediction delays.
Reference: [3] <author> T. Ball and J. R. Larus. </author> <title> Branch prediction for free. </title> <booktitle> In 1993 SIGPLAN Conference on Programming Language Design and Implementation. ACM, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: The LIKELY model assumes that encoded information in the branch instruction indicates whether the branch is likely to be taken or not taken. This branch model is used by several architectures including the Tera [2]. The likely/unlikely flag can be set either using compile-time estimates <ref> [3] </ref> or profile information [9]. We use profile information since it is much more accurate and simple to gather with appropriate tools [23]. Program transformation can help these branch prediction architectures reduce misfetch and misprediction delays.
Reference: [4] <author> Brian Bray and M. J. Flynn. </author> <title> Strategies for branch target buffers. </title> <booktitle> In 24th Workshop on Microprogramming and Microarchitecture, </booktitle> <pages> pages 42-49. </pages> <publisher> ACM, ACM, </publisher> <year> 1991. </year>
Reference-contexts: Optimizations for Control Flow: McFarling and Hennessy [17] described a number of methods to reduce branch misprediction and instruction fetch penalties, including profile-driven static branch prediction, delay slots and a form of branch alignment. Their variant of branch alignment only considered if/then/else constructs. Later, Bray and Flynn <ref> [4] </ref> extended the work of McFarling et al while examining various branch target buffer (BTB) architectures. Yet, they also only examined if/then/else constructs. <p> Originally, BTB's were used as a mechanism for branch prediction, effectively predicting the prior behavior of a branch even small BTB's were found to be very effective <ref> [4, 17, 20, 22, 26] </ref>. The Intel Pentium is an example of a current architecture using BTB's - it has a 256-entry BTB organized as a 64 line four-way associative cache. Only branches that are `taken' are entered into the BTB. <p> We described an improved alignment algorithm and also showed that a few branches determine the branch behavior of many common benchmark programs. Our technique addresses a broader class of program structures than [15] and <ref> [4] </ref> and does not require the recompilation needed by Hwu and Chang [18] or Pettis and Hansen [21]. We have shown how a simple object code transformation, taking no more than a few minutes to run, even for very large programs, can improve a programs performance.
Reference: [5] <author> Brad Calder and Dirk Grunwald. </author> <title> Fast & accurate instruction fetch and branch prediction. </title> <booktitle> In 21st Annual Annual International Symposium on Computer Architecture, SIGARCH Newsletter. ACM, </booktitle> <month> April </month> <year> 1994. </year>
Reference-contexts: Some architectures use branch delay slots or other mechanisms <ref> [5, 7, 17] </ref> to avoid this penalty. In this paper we assume the fall-through instruction is fetched while a branch is decoded (except for the branch target buffer architecture). Thus, `taken' branches always incur a misfetch penalty. We modeled three static branch prediction architectures and two dynamic prediction architectures. <p> Each BTB entry contains a 2-bit saturating up-down counter used to predict the destination for conditional branches. The BTB in our simulations hold entries for conditional branches, unconditional branches, indirect jumps, procedure calls and returns <ref> [5, 26] </ref>. 4 Branch Alignment Algorithms We implemented the branch alignment algorithm suggested by Pet-tis and Hansen [21]. We did not implement the algorithms of McFarling and Hennessy or Bray and Flynn, because they only examine `if/then/else' constructs.
Reference: [6] <author> Brad Calder, Dirk Grunwald, and Benjamin Zorn. </author> <title> Quantifying behavioral differences between C and C++ programs. </title> <type> Technical Report CU-CS-698, </type> <institution> University of Colorado-Boulder, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: We selected these programs because we found that the SPEC92 suite did not typify the behavior seen in large programs or C++ programs <ref> [6] </ref>.
Reference: [7] <author> David R. Ditzel and Hubert R. McLellan. </author> <title> Branch folding in the CRISP microprocessor: Reducing branch delay to zero. </title> <booktitle> In 14th Annual Annual International Symposium on Computer Architecture, SIGARCH Newsletter, </booktitle> <pages> pages 2-9. </pages> <publisher> ACM, ACM, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: Some architectures use branch delay slots or other mechanisms <ref> [5, 7, 17] </ref> to avoid this penalty. In this paper we assume the fall-through instruction is fetched while a branch is decoded (except for the branch target buffer architecture). Thus, `taken' branches always incur a misfetch penalty. We modeled three static branch prediction architectures and two dynamic prediction architectures.
Reference: [8] <author> Domenico Ferrari. </author> <title> Improving locality by critical working sets. </title> <journal> Communications of the ACM, </journal> <volume> 17(11) </volume> <pages> 614-620, </pages> <year> 1974. </year>
Reference-contexts: Optimization for Memory Hierarchies: Due to the expense of memory on early computers, much early work focused on reducing paging in virtual memory systems. Several researchers explored ways to group related subroutines or basic blocks onto the same virtual memory pages <ref> [1, 8, 11, 13, 10] </ref>. Other researchers extended this work to lower levels of the memory hierarchy, optimizing the performance of instruction caches. McFarling [15] described an algorithm to reduce instruction cache conflicts for a particular class of programs.
Reference: [9] <author> J. A. Fisher and S. M. Freudenberger. </author> <title> Predicting conditional branch directions from previous runs of a program. </title> <booktitle> In Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 85-95, </pages> <address> Boston, Mass., </address> <month> October </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: The LIKELY model assumes that encoded information in the branch instruction indicates whether the branch is likely to be taken or not taken. This branch model is used by several architectures including the Tera [2]. The likely/unlikely flag can be set either using compile-time estimates [3] or profile information <ref> [9] </ref>. We use profile information since it is much more accurate and simple to gather with appropriate tools [23]. Program transformation can help these branch prediction architectures reduce misfetch and misprediction delays.
Reference: [10] <author> S. J. </author> <title> Hartley. Compile-time program restructuring in multipro-grammed virtual memory systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(11) </volume> <pages> 1640-1644, </pages> <year> 1988. </year>
Reference-contexts: Optimization for Memory Hierarchies: Due to the expense of memory on early computers, much early work focused on reducing paging in virtual memory systems. Several researchers explored ways to group related subroutines or basic blocks onto the same virtual memory pages <ref> [1, 8, 11, 13, 10] </ref>. Other researchers extended this work to lower levels of the memory hierarchy, optimizing the performance of instruction caches. McFarling [15] described an algorithm to reduce instruction cache conflicts for a particular class of programs.
Reference: [11] <author> D. Hatfield and J. Gerald. </author> <title> Program restructuring for virtual memory. </title> <journal> IBM Systems Journal, </journal> <volume> 10(3) </volume> <pages> 168-192, </pages> <year> 1971. </year>
Reference-contexts: Optimization for Memory Hierarchies: Due to the expense of memory on early computers, much early work focused on reducing paging in virtual memory systems. Several researchers explored ways to group related subroutines or basic blocks onto the same virtual memory pages <ref> [1, 8, 11, 13, 10] </ref>. Other researchers extended this work to lower levels of the memory hierarchy, optimizing the performance of instruction caches. McFarling [15] described an algorithm to reduce instruction cache conflicts for a particular class of programs.
Reference: [12] <author> David R. Kaeli and Philip G. Emma. </author> <title> Branch history table prediction of moving target branches due to subroutine returns. </title> <booktitle> In 18th Annual International Symposium of Computer Architecture, </booktitle> <pages> pages 34-42. </pages> <publisher> ACM, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: Since the BTB architecture tries to predict all types of branches, taken branches (procedure calls, unconditional jumps, and taken conditional branches) found in the BTB do not necessarily cause misfetch penalties. In all of our static and dynamic architecture simulations we simulated a 32-entry return stack <ref> [12] </ref>, which is very accurate at predicting the destination for return instructions. In order to evaluate the performance of the different alignments and architectures, we add the BEP to the number of instructions executed in the aligned program and divide by the number of instructions executed in the original program.
Reference: [13] <author> Brian Kernighan. </author> <title> Optimal sequential partitions of graphs. </title> <journal> Journal of the ACM, </journal> <volume> 18(1) </volume> <pages> 34-40, </pages> <year> 1971. </year>
Reference-contexts: Optimization for Memory Hierarchies: Due to the expense of memory on early computers, much early work focused on reducing paging in virtual memory systems. Several researchers explored ways to group related subroutines or basic blocks onto the same virtual memory pages <ref> [1, 8, 11, 13, 10] </ref>. Other researchers extended this work to lower levels of the memory hierarchy, optimizing the performance of instruction caches. McFarling [15] described an algorithm to reduce instruction cache conflicts for a particular class of programs.
Reference: [14] <author> Johnny K. F. Lee and Alan Jay Smith. </author> <title> Branch prediction strategies and branch target buffer design. </title> <journal> IEEE Computer, </journal> <volume> 21(7) </volume> <pages> 6-22, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: If a branch address appears in the BTB, the stored address is used to fetch future instructions. Otherwise, the fall-through address is used. For each BTB entry, the Pentium also uses a two-bit saturating counter to predict the direction of a conditional branch <ref> [14] </ref>. Conditional branches can be predicted using much simpler mechanisms, but these methods do nothing for misfetch penalties. A pattern history table PHT eliminates the site and target addresses from the table and the table only predicts the direction for conditional branches.
Reference: [15] <author> Scott McFarling. </author> <title> Program optimization for instruction caches. </title> <booktitle> In 3rd International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 183-191. </pages> <publisher> ACM, </publisher> <year> 1988. </year>
Reference-contexts: Several researchers explored ways to group related subroutines or basic blocks onto the same virtual memory pages [1, 8, 11, 13, 10]. Other researchers extended this work to lower levels of the memory hierarchy, optimizing the performance of instruction caches. McFarling <ref> [15] </ref> described an algorithm to reduce instruction cache conflicts for a particular class of programs. Hwu and Chang [18] describe a more general and more effective technique using compile time analysis in the IMPACT-I compiler system. Using profile-based transformations, the IMPACT-I compiler inlines subroutines and performs trace analysis. <p> We described an improved alignment algorithm and also showed that a few branches determine the branch behavior of many common benchmark programs. Our technique addresses a broader class of program structures than <ref> [15] </ref> and [4] and does not require the recompilation needed by Hwu and Chang [18] or Pettis and Hansen [21]. We have shown how a simple object code transformation, taking no more than a few minutes to run, even for very large programs, can improve a programs performance.
Reference: [16] <author> Scott McFarling. </author> <title> Combining branch predictors. </title> <address> TN 36, DEC-WRL, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: This value is used as an index into the 4096-entry pattern history table, providing contextual information about particular patterns of branches. We simulated two PHTs, a direct mapped PHT and the degenerate two-level correlation PHT using a variant that McFarling <ref> [16] </ref> found to be the most accurate. This method performs an exclusive-or of the branch address with the global history register and uses this as an index into the PHT. Both of the PHTs we simulated contained 4096 2-bit saturating up-down counters, for a total of 1KBytes of storage.
Reference: [17] <author> Scott McFarling and John Hennessy. </author> <title> Reducing the cost of branches. </title> <booktitle> In 13th Annual International Symposium of Computer Architecture, </booktitle> <pages> pages 396-403. </pages> <publisher> ACM, </publisher> <year> 1986. </year>
Reference-contexts: Following this, global analysis arranges functions to reduce inter-function cache conflicts. Similar transformations were applied by Pettis and Hansen [21] for programs on the HP PA-RISC. Optimizations for Control Flow: McFarling and Hennessy <ref> [17] </ref> described a number of methods to reduce branch misprediction and instruction fetch penalties, including profile-driven static branch prediction, delay slots and a form of branch alignment. Their variant of branch alignment only considered if/then/else constructs. <p> Some architectures use branch delay slots or other mechanisms <ref> [5, 7, 17] </ref> to avoid this penalty. In this paper we assume the fall-through instruction is fetched while a branch is decoded (except for the branch target buffer architecture). Thus, `taken' branches always incur a misfetch penalty. We modeled three static branch prediction architectures and two dynamic prediction architectures. <p> Originally, BTB's were used as a mechanism for branch prediction, effectively predicting the prior behavior of a branch even small BTB's were found to be very effective <ref> [4, 17, 20, 22, 26] </ref>. The Intel Pentium is an example of a current architecture using BTB's - it has a 256-entry BTB organized as a 64 line four-way associative cache. Only branches that are `taken' are entered into the BTB.
Reference: [18] <author> Wen mei W. Hwu and Pohua P. Chang. </author> <title> Achieving high instruction cache performance with an optimizing compiler. </title> <booktitle> In 16th Annual International Symposium of Computer Architecture, </booktitle> <pages> pages 242-251. </pages> <publisher> ACM, ACM, </publisher> <year> 1989. </year>
Reference-contexts: Other researchers extended this work to lower levels of the memory hierarchy, optimizing the performance of instruction caches. McFarling [15] described an algorithm to reduce instruction cache conflicts for a particular class of programs. Hwu and Chang <ref> [18] </ref> describe a more general and more effective technique using compile time analysis in the IMPACT-I compiler system. Using profile-based transformations, the IMPACT-I compiler inlines subroutines and performs trace analysis. <p> Yet, they also only examined if/then/else constructs. Yeh et al [26] commented that with trace scheduling, taken branches could only be reduced from 62% of the executed conditional branches to 50% of executed conditional branches. The earlier study by Hwu and Chang <ref> [18] </ref> showed a 58% fall-through rate after branch alignment. The papers by McFarling and Hen-nessy, Bray and Flynn, and Pettis and Hansen did not report the change in the percentage of taken branches. The branch alignment reordering algorithm proposed by Hwu et al is more general than McFarling's and Bray's. <p> We described an improved alignment algorithm and also showed that a few branches determine the branch behavior of many common benchmark programs. Our technique addresses a broader class of program structures than [15] and [4] and does not require the recompilation needed by Hwu and Chang <ref> [18] </ref> or Pettis and Hansen [21]. We have shown how a simple object code transformation, taking no more than a few minutes to run, even for very large programs, can improve a programs performance.
Reference: [19] <author> S.-T. Pan, K. So, and J. T. Rahmeh. </author> <title> Improving the accuracy of dynamic branch prediction using branch correlation. </title> <booktitle> In Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 76-84, </pages> <address> Boston, Mass., </address> <month> October </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: A pattern history table PHT eliminates the site and target addresses from the table and the table only predicts the direction for conditional branches. These designs use the branch site address as an index into a table of prediction bits. More recently Pan et al <ref> [19] </ref> and Yeh and Patt [27] investigated branch-correlation or two-level branch prediction mechanisms. Although there are a number of variants, these mechanisms generally combine the history of several recent branches to predict the outcome of a branch. The simplest example is the degenerate method of Pan et al.
Reference: [20] <author> Chris Perleberg and Alan Jay Smith. </author> <title> Branch target buffer design and optimization. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 42(4) </volume> <pages> 396-412, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Originally, BTB's were used as a mechanism for branch prediction, effectively predicting the prior behavior of a branch even small BTB's were found to be very effective <ref> [4, 17, 20, 22, 26] </ref>. The Intel Pentium is an example of a current architecture using BTB's - it has a 256-entry BTB organized as a 64 line four-way associative cache. Only branches that are `taken' are entered into the BTB.
Reference: [21] <author> Karl Pettis and Robert C. Hansen. </author> <title> Profile guided code positioning. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 16-27. </pages> <publisher> ACM, ACM, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: For each subroutine, instructions are packed using the most frequently executed traces, moving infrequently executed traces to the end of the function. Following this, global analysis arranges functions to reduce inter-function cache conflicts. Similar transformations were applied by Pettis and Hansen <ref> [21] </ref> for programs on the HP PA-RISC. Optimizations for Control Flow: McFarling and Hennessy [17] described a number of methods to reduce branch misprediction and instruction fetch penalties, including profile-driven static branch prediction, delay slots and a form of branch alignment. Their variant of branch alignment only considered if/then/else constructs. <p> Hwu and Chang examined all basic blocks, rearranging them to achieve a better branch alignment. They were able to handle branches that do not form an if/then/else structure. The work by Pettis and Hansen <ref> [21] </ref> describes a greedy algorithm for branch alignment which is similar to Hwu and Chang's since they look at all basic blocks. The Pettis and Hansen greedy algorithm is more general than the Hwu and Chang algorithm, and performs better in terms of reducing the cost of branches. <p> The BTB in our simulations hold entries for conditional branches, unconditional branches, indirect jumps, procedure calls and returns [5, 26]. 4 Branch Alignment Algorithms We implemented the branch alignment algorithm suggested by Pet-tis and Hansen <ref> [21] </ref>. We did not implement the algorithms of McFarling and Hennessy or Bray and Flynn, because they only examine `if/then/else' constructs. <p> All other edges are given a weight of zero and are not considered when applying branch alignment. Thus, we ignore indirect branches, procedure returns and subroutine calls. In this section we discuss three branch alignment algorithms. Greedy: Pettis and Hansen <ref> [21] </ref> proposed two heuristics to align branches. We only describe their bottom-up (`greedy') algorithm, since it has better performance. The Greedy algorithm was directed towards the BT/FNT architecture, and did not consider the implications of different branch architectures. In the terminology of [21], a chain is a contiguous sequence of basic <p> Greedy: Pettis and Hansen <ref> [21] </ref> proposed two heuristics to align branches. We only describe their bottom-up (`greedy') algorithm, since it has better performance. The Greedy algorithm was directed towards the BT/FNT architecture, and did not consider the implications of different branch architectures. In the terminology of [21], a chain is a contiguous sequence of basic blocks threaded by `head' and `tail' pointers. The first basic block in each chain has a null head pointer and the last basic block in each chain has a null tail pointer. The algorithm aligns each procedure in turn. <p> One algorithm laid out chains for a procedure starting with the highest executed chain continuing down to the lowest executed chain. The other algorithm laid out chains using the BT/FNT model described in <ref> [21] </ref>. We implemented both chain layouts in OM and found that the algorithms that laid the chains out from highest executed to lowest executed performed slightly better than the one that laid out chains using the BT/FNT model. <p> Our technique addresses a broader class of program structures than [15] and [4] and does not require the recompilation needed by Hwu and Chang [18] or Pettis and Hansen <ref> [21] </ref>. We have shown how a simple object code transformation, taking no more than a few minutes to run, even for very large programs, can improve a programs performance.
Reference: [22] <author> J. E. Smith. </author> <title> A study of branch prediction strategies. </title> <booktitle> In 8th Annual International Symposium of Computer Architecture. ACM, </booktitle> <year> 1981. </year>
Reference-contexts: Originally, BTB's were used as a mechanism for branch prediction, effectively predicting the prior behavior of a branch even small BTB's were found to be very effective <ref> [4, 17, 20, 22, 26] </ref>. The Intel Pentium is an example of a current architecture using BTB's - it has a 256-entry BTB organized as a 64 line four-way associative cache. Only branches that are `taken' are entered into the BTB.
Reference: [23] <author> Amitabh Srivastava and Alan Eustace. </author> <title> Atom: A system for building customized program analysis tools. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation. ACM, </booktitle> <year> 1994. </year>
Reference-contexts: This branch model is used by several architectures including the Tera [2]. The likely/unlikely flag can be set either using compile-time estimates [3] or profile information [9]. We use profile information since it is much more accurate and simple to gather with appropriate tools <ref> [23] </ref>. Program transformation can help these branch prediction architectures reduce misfetch and misprediction delays. In the FALL-THROUGH architecture, the fall-through path should be executed most frequently, both to reduce misfetch and improve prediction. <p> The implementation illustrates that these techniques have practical value. During the simulation study, we instrumented the programs from the SPEC92 benchmark suite and other programs, including object-oriented programs written in C++. We used ATOM <ref> [23] </ref> to instrument the programs. Due to the structure of ATOM, we did not need to record traces and could trace very long-running programs. The programs were compiled on a DEC 3000-400 using the Alpha AXP-21064 processor using either the DEC C compiler or DEC C++ compiler.
Reference: [24] <author> Amitabh Srivastava and David W. Wall. </author> <title> A practical system for in-termodule code optimizations at link-time. </title> <journal> Journal of Programming Languages, </journal> <month> March </month> <year> 1993. </year>
Reference-contexts: Initially, we simulated several different branch architectures using trace driven simulation. Later, we implemented the different branch alignment algorithms using the OM <ref> [24, 25] </ref> system for link-time code transformation. The simulations provide more detailed insight on why branch alignment is useful on the different branch architectures. The implementation illustrates that these techniques have practical value.
Reference: [25] <author> Amitabh Srivastava and David W. Wall. </author> <title> Link-time optimizations of address calculation on a 64-bit architecture. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation. ACM, </booktitle> <year> 1994. </year>
Reference-contexts: Initially, we simulated several different branch architectures using trace driven simulation. Later, we implemented the different branch alignment algorithms using the OM <ref> [24, 25] </ref> system for link-time code transformation. The simulations provide more detailed insight on why branch alignment is useful on the different branch architectures. The implementation illustrates that these techniques have practical value. <p> We scaled the execution time for each program by the time for the original program. The programs were compiled as previously described but not linked. We then used OM to link the resulting object files and standard libraries using OM-full as described in <ref> [25] </ref>. Therefore, the Original program execution times shown in Figure 4 use the standard OM link time optimizations. We then modified OM to produce the desired branch alignments and used this to link the programs.
Reference: [26] <author> Tse-Yu Yeh and Yale N. Patt. </author> <title> A comprehensive instruction fetch mechanism for a processor supporting speculative execution. </title> <booktitle> In 25th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 129-139, </pages> <address> Portland, Or, </address> <month> December </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: Their variant of branch alignment only considered if/then/else constructs. Later, Bray and Flynn [4] extended the work of McFarling et al while examining various branch target buffer (BTB) architectures. Yet, they also only examined if/then/else constructs. Yeh et al <ref> [26] </ref> commented that with trace scheduling, taken branches could only be reduced from 62% of the executed conditional branches to 50% of executed conditional branches. The earlier study by Hwu and Chang [18] showed a 58% fall-through rate after branch alignment. <p> Originally, BTB's were used as a mechanism for branch prediction, effectively predicting the prior behavior of a branch even small BTB's were found to be very effective <ref> [4, 17, 20, 22, 26] </ref>. The Intel Pentium is an example of a current architecture using BTB's - it has a 256-entry BTB organized as a 64 line four-way associative cache. Only branches that are `taken' are entered into the BTB. <p> Each BTB entry contains a 2-bit saturating up-down counter used to predict the destination for conditional branches. The BTB in our simulations hold entries for conditional branches, unconditional branches, indirect jumps, procedure calls and returns <ref> [5, 26] </ref>. 4 Branch Alignment Algorithms We implemented the branch alignment algorithm suggested by Pet-tis and Hansen [21]. We did not implement the algorithms of McFarling and Hennessy or Bray and Flynn, because they only examine `if/then/else' constructs.
Reference: [27] <author> Tse-Yu Yeh and Yale N. Patt. </author> <title> A comparison of dynamic branch predictors that use two levels of branch history. </title> <booktitle> In 20th Annual International Symposium of Computer Architecture, </booktitle> <pages> pages 257-266, </pages> <address> San Diego, CA, </address> <month> May </month> <year> 1993. </year> <note> ACM. </note>
Reference-contexts: These designs use the branch site address as an index into a table of prediction bits. More recently Pan et al [19] and Yeh and Patt <ref> [27] </ref> investigated branch-correlation or two-level branch prediction mechanisms. Although there are a number of variants, these mechanisms generally combine the history of several recent branches to predict the outcome of a branch. The simplest example is the degenerate method of Pan et al.
References-found: 27

