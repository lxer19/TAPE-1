URL: http://www.ri.cmu.edu/afs/cs/user/nch/ftp/set-constraints.ps.Z
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/nch/ftp/
Root-URL: 
Title: A Decision Procedure for a Class of Set Constraints  
Author: Nevin Heintze and Joxan Jaffar 
Address: Pittsburgh, PA 15213  PO Box 218, Yorktown Heights, NY 10598  
Affiliation: School of Computer Science Carnegie Mellon University  2 IBM Thomas J. Watson Research Center,  
Date: February 14, 1991  
Pubnum: CMU-CS-91-110  
Abstract: A preliminary version of this paper appears in the Proceedings, 5 th IEEE Symposium on LICS. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. Ackermann, </author> <title> "Solvable Cases of the Decision Problem", </title> <booktitle> Studies in Logic and Foundations of Mathematics, </booktitle> <publisher> North-Holland, </publisher> <year> 1962. </year>
Reference-contexts: Set based reasoning can be expressed in the predicate calculus by regarding a unary predicate as the set of values on which it is true. There are decidability results which deal with cases where the symbols are unary; see <ref> [1] </ref> for example. (These results were in fact shown for the second-order calculus.) Rabin [8], using the second-order theory of k successors and a standard interpretation, showed that the sets definable are recursive, and furthermore, he showed that there are algorithms to decide questions such as emptiness and containment.
Reference: [2] <author> J. Doner, </author> <title> "Tree Acceptors and Some of their Applications", </title> <journal> Journal of Computer and System Sciences 4, </journal> <pages> pp 406 - 451, </pages> <year> 1970. </year>
Reference-contexts: Moreover a term grammar can be viewed as a description of a non-deterministic finite tree automata and vice-versa. Hence there are algorithms for combining term grammars over the boolean and projection operations, and for testing emptyness and containment (see [10], <ref> [2] </ref>; also see [3] for a survey of relevant results). <p> The next transformation deals with eliminating intersection symbols. We note that given two term grammars, we can construct a third grammar whose language is the intersection of the first two [10] <ref> [2] </ref>. We cannot, however, use this result to eliminate occurrences of the intersection symbol and reduce a set expression grammar into a term grammar.
Reference: [3] <author> F. Gecseg and M. Steinby, </author> <title> "Tree Automata", </title> <publisher> Akademiai Kiado, </publisher> <address> Budapest, </address> <year> 1984. </year>
Reference-contexts: Moreover a term grammar can be viewed as a description of a non-deterministic finite tree automata and vice-versa. Hence there are algorithms for combining term grammars over the boolean and projection operations, and for testing emptyness and containment (see [10], [2]; also see <ref> [3] </ref> for a survey of relevant results). This means that, given a representation of an interpretation I in the form of a term grammar, standard algorithms from the literature can be used to check whether a given set constraint, sexp 1 sexp 2 , is true in I. <p> L, it follows that the sets definable as the least model of definite set constraints are exactly those definable by regular term grammars. 2 In what follows, we may abbreviate =G)? by ? =) whenever there is only one grammar G in context. 3 In terms of later definitions (e.g. <ref> [3] </ref>), these automata are the frontier-to-root tree automata. 5 3 Set Expression Grammars We now define a class of grammars, generalizing term grammars, intended to provide a representation of an interpretation which is more explicit than the conjunction of set constraints at hand, but not necessarily as explicit as a term
Reference: [4] <author> N. Heintze and J. Jaffar, </author> <title> "A Finite Presentation Theorem for Approximating Logic Programs", </title> <type> IBM technical report RC 16089 (# 71415), </type> <month> August </month> <year> 1990, </year> <pages> 66 pp. </pages> <note> (An abstract of this paper appears in Proc. </note> <month> ACM-POPL-90, </month> <pages> pp. 197-209.) </pages>
Reference-contexts: Mishra [7], in his framework for type inference in logic programs, used set constraints to model a superset of the success set of a program. 2 Though a full decision procedure was not presented, algorithms for subcases were investigated. Heintze and Jaffar <ref> [4] </ref> used set constraints to obtain a recursive and accurate approximation of the meaning of a logic program. <p> The representations used in these papers are equivalent to term grammars. If, on the other hand, C does not contain any projection symbols (but may contain intersection), then a simplification algorithm contained in <ref> [4] </ref> solves the problem for lm C . Once again, the explicit representation used there is the same as a term grammar. However, these results cannot be combined to deal with the case where C may contain both kinds of symbols because of the interaction between intersection and projection.
Reference: [5] <editor> N.D. Jones and S.S. Muchnick, </editor> <title> "Flow Analysis and Optimization of LISP-like Structures", </title> <booktitle> Proceedings 6 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp 244 - 256, </pages> <year> 1979. </year>
Reference-contexts: Set constraints can then be used to impose relationships between the set variables so that any model of these constraints defines a superset of the actual run-time values. In summary, set constraints provide a methodology of program approximation which ignores dependencies between variables. Reynolds [9] and Jones and Muchnick <ref> [5] </ref>, for example, considered functional programs and used a class of set constraints whose satisfiability is guaranteed. The focus of these works was to provide an explicit representation of the model defined by the constraints. <p> In case C does not contain any intersection or projection symbols, then C itself is an explicit representation of lm C . In case C does not contain any intersection symbols (but may contain projection symbols), early work by Reynolds [9], and later by Jones and Muchnick <ref> [5] </ref>, gave algorithms for the explicit representation of lm C . The representations used in these papers are equivalent to term grammars.
Reference: [6] <author> R. McNaughton, </author> <title> "Parenthesis Grammars", </title> <journal> Journal of the ACM 14(3), </journal> <pages> pp 490 - 500, </pages> <year> 1967. </year>
Reference-contexts: We note that a term grammar is essentially a parenthesis grammars <ref> [6] </ref>. The class of languages definable by term grammars is exactly the class accepted by tree automata 3 . Moreover a term grammar can be viewed as a description of a non-deterministic finite tree automata and vice-versa.
Reference: [7] <author> P. Mishra, </author> <title> "Toward a Theory of Types in PROLOG", </title> <booktitle> Proceedings 1 st IEEE Symposium on Logic Programming, Atlantic City, </booktitle> <pages> pp 289 - 298, </pages> <year> 1984. </year>
Reference-contexts: Reynolds [9] and Jones and Muchnick [5], for example, considered functional programs and used a class of set constraints whose satisfiability is guaranteed. The focus of these works was to provide an explicit representation of the model defined by the constraints. Mishra <ref> [7] </ref>, in his framework for type inference in logic programs, used set constraints to model a superset of the success set of a program. 2 Though a full decision procedure was not presented, algorithms for subcases were investigated.
Reference: [8] <author> M.O. Rabin, </author> <title> "Decidability of Second-order Theories and Automata on Infinite Trees", </title> <journal> Transactions of the American Math. Society 141, </journal> <pages> pp 1 - 35, </pages> <year> 1969. </year>
Reference-contexts: There are decidability results which deal with cases where the symbols are unary; see [1] for example. (These results were in fact shown for the second-order calculus.) Rabin <ref> [8] </ref>, using the second-order theory of k successors and a standard interpretation, showed that the sets definable are recursive, and furthermore, he showed that there are algorithms to decide questions such as emptiness and containment.
Reference: [9] <author> J.C. Reynolds, </author> <title> "Automatic Computation of Data Set Definitions", </title> <booktitle> Information Processing 68, </booktitle> <publisher> North-Holland, </publisher> <pages> pp 456 - 461, </pages> <year> 1969. </year>
Reference-contexts: Set constraints can then be used to impose relationships between the set variables so that any model of these constraints defines a superset of the actual run-time values. In summary, set constraints provide a methodology of program approximation which ignores dependencies between variables. Reynolds <ref> [9] </ref> and Jones and Muchnick [5], for example, considered functional programs and used a class of set constraints whose satisfiability is guaranteed. The focus of these works was to provide an explicit representation of the model defined by the constraints. <p> In case C does not contain any intersection or projection symbols, then C itself is an explicit representation of lm C . In case C does not contain any intersection symbols (but may contain projection symbols), early work by Reynolds <ref> [9] </ref>, and later by Jones and Muchnick [5], gave algorithms for the explicit representation of lm C . The representations used in these papers are equivalent to term grammars.
Reference: [10] <author> J.W. Thatcher and J.B. Wright, </author> <title> "Generalized Finite Automata with an Application to a Decision Problem of Second-order Logic", </title> <booktitle> Mathematical Systems Theory 2, </booktitle> <pages> pp 57 - 82, </pages> <year> 1968. </year> <month> 38 </month>
Reference-contexts: Moreover a term grammar can be viewed as a description of a non-deterministic finite tree automata and vice-versa. Hence there are algorithms for combining term grammars over the boolean and projection operations, and for testing emptyness and containment (see <ref> [10] </ref>, [2]; also see [3] for a survey of relevant results). <p> The next transformation deals with eliminating intersection symbols. We note that given two term grammars, we can construct a third grammar whose language is the intersection of the first two <ref> [10] </ref> [2]. We cannot, however, use this result to eliminate occurrences of the intersection symbol and reduce a set expression grammar into a term grammar.
References-found: 10

