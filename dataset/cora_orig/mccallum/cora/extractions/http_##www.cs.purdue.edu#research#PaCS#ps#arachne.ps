URL: http://www.cs.purdue.edu/research/PaCS/ps/arachne.ps
Refering-URL: http://www.cs.purdue.edu/research/PaCS/arachne.html
Root-URL: http://www.cs.purdue.edu
Title: ARACHNE: A COMPILER-BASED PORTABLE THREADS ARCHITECTURE SUPPORTING MIGRATION ON HETEROGENEOUS NETWORKED SYSTEMS  
Degree: A Thesis Submitted to the Faculty of Purdue University by Bozhidar Dimitrov Dimitrov In Partial Fulfillment of the Requirements for the Degree of Master of Science  
Date: May 1996  
Abstract-found: 0
Intro-found: 1
Reference: <institution> 58 BIBLIOGRAPHY </institution>
Reference: [ASU86] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: In addition, a compiler may perform a number of optimization passes on the intermediate representation and the final code. We encourage the reader to consult <ref> [ASU86] </ref> for a concise discussion of compiler techniques. It is possible to write a preprocessor in a similar manner, but it may seem overkill to develop a front-end, a back-end and an intermediate representation.
Reference: [Com84] <author> Douglas Comer. </author> <title> Operating System Design, the Xinu Approach, </title> <booktitle> chapter 3, </booktitle> <pages> pages 41-53. </pages> <publisher> Prentice-Hall, </publisher> <year> 1984. </year>
Reference-contexts: The transition marked scheduler occurs when the current thread executes a primitive that results in a context switch. 5.1.4 Queue Manipulation Arachne's algorithm for scheduling threads is quite efficient. By improving upon an idea used by Comer in the Xinu operating system <ref> [Com84] </ref>, Arachne achieves constant time list insertion and deletion. In Xinu, the current process does not appear on any queue, while all other processes reside in some queue at all times.
Reference: [DS80] <author> E. Dijikstra and B. P. Scholten. </author> <title> Termination Detection for Difusing Computations. </title> <journal> Information Processing Letters, </journal> <volume> 11(1) </volume> <pages> 1-4, </pages> <year> 1980. </year>
Reference-contexts: The difficulty with detecting termination conditions is that all processes may be idle, but there may exist messages in transit; once received, such messages may potentially reactivate a process. Typical termination algorithms <ref> [DS80] </ref> assume certain network topologies, while Ariadne and Arachne are capable of correctly handling any topology. In Arachne, each process is either active or inactive.
Reference: [FL91] <author> C. N. Fischer and R. J. LeBlanc, Jr. </author> <title> Crafting a Compiler with C. </title> <address> Ben-jamin/Cummings, </address> <year> 1991. </year>
Reference-contexts: Yacc requires Backus-Naur-like descriptions of grammar productions and a list of actions to perform when a reduction occurs. While generating a parser, yacc analyzes the given grammar and reports all ambiguities and conflicts. A description of how scanners and parsers are written in C can be found in <ref> [FL91] </ref>. 18 4.2 Writing a Preprocessor A preprocessor is simpler than a compiler. In general, a compiler converts syntactically correct high-level language programs into equivalent programs written in a low-level language or machine code. A preprocessor's output language is typically the same as that of the input.
Reference: [IEE95] <author> IEEE. </author> <title> Information Technology|Portable Operating System Interface (POSIX)|Part 1: System Application Program Interface (API) [C Language]. </title> <address> Std. 1003.1c-1995, </address> <year> 1995. </year>
Reference-contexts: Basically, migration is accomplished by copying the local machine stack to some remote machine and then restarting the computation. Examples of such systems are Ariadne [MR96] and Pthreads <ref> [IEE95, Mue92] </ref>. Because the contents of a machine stack are meaningless across hardware platforms, some help is needed in interpreting the sequence of binary digits.
Reference: [MKR95] <author> E. Mascarenhas, F. Knop, and V. Rego. ParaSol: </author> <title> A Multi-threaded System for Parallel Simulation Based on Mobile Threads. </title> <booktitle> In Proceedings of the Winter Simulation Conference, </booktitle> <pages> pages 690-697, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: In its present form, Arachne can serve as the underlying (threads) layer for distributed simulation systems (such as Parasol <ref> [MKR95] </ref>) or as a stand-alone environment for distributed computation (such as Ari-adne [MR95]). Ythreads [San94] was a first venture into heterogeneous migration and was mainly developed to test the feasibility of the concept. Arachne is an entirely new threads system, based on our experiences with Ythreads.
Reference: [MR95] <author> E. Mascarenhas and V. Rego. </author> <title> Migrant Threads on Process Farms: Parallel Programming with Ariadne. </title> <type> Technical Report TR 95-081, </type> <institution> Department of Computer Sciences, Purdue University, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: In its present form, Arachne can serve as the underlying (threads) layer for distributed simulation systems (such as Parasol [MKR95]) or as a stand-alone environment for distributed computation (such as Ari-adne <ref> [MR95] </ref>). Ythreads [San94] was a first venture into heterogeneous migration and was mainly developed to test the feasibility of the concept. Arachne is an entirely new threads system, based on our experiences with Ythreads. Indeed, besides having more powerful features, it is easy-to-use, more efficient and much more flexible.
Reference: [MR96] <author> E. Mascarenhas and V. Rego. Ariadne: </author> <title> Architecture of a Portable Threads System Supporting Thread Migration. </title> <journal> Software Practice and Experience, </journal> <volume> 26(3) </volume> <pages> 327-357, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: Basically, migration is accomplished by copying the local machine stack to some remote machine and then restarting the computation. Examples of such systems are Ariadne <ref> [MR96] </ref> and Pthreads [IEE95, Mue92]. Because the contents of a machine stack are meaningless across hardware platforms, some help is needed in interpreting the sequence of binary digits. <p> compiler to the different architectures, the authors found 60% longer times for migrating and subsequently invoking a function through code generated by their compiler as compared to the original Emerald compiler. 1.3 Features of Arachne Arachne is meant to outgrow and replace Ariadne, a system which provides only homogeneous migration <ref> [MR96] </ref>. In its present form, Arachne can serve as the underlying (threads) layer for distributed simulation systems (such as Parasol [MKR95]) or as a stand-alone environment for distributed computation (such as Ari-adne [MR95]). <p> Only then does the scheduler search for the highest priority thread. So if the "new" thread has higher priority than all others, it will become the next current thread. 5.5 Distributed Termination Arachne implements Ariadne's termination algorithm because of its high efficiency and small network load <ref> [MR96] </ref>. The difficulty with detecting termination conditions is that all processes may be idle, but there may exist messages in transit; once received, such messages may potentially reactivate a process. Typical termination algorithms [DS80] assume certain network topologies, while Ariadne and Arachne are capable of correctly handling any topology. <p> Where applicable, we compared results with SunOS 5.3 multi-threads (Sun-MT) and with the Ariadne threads system. The performance results for Sun-MT and Ariadne are those reported in <ref> [MR96] </ref>. Every test was designed to execute enough operations so that its total run-time is longer than 60 seconds. All results are averaged over ten test-runs and indicate the run-time of a single operation. We used the UNIX command clock (3C) to measure run-times.
Reference: [MS90] <author> B. Malloy and M. Soffa. </author> <title> Conversion of Simulation Processes to Pascal Constructs. </title> <journal> Software: Practice and Experience, </journal> 202(2) 191-207, February 1990. 
Reference-contexts: At the very least, we need information about the types of the data stored on the stack, and one obvious way of obtaining it is using a compiler or a code preprocessor. The underlying idea behind Arachne is based on work done by Malloy and Soffa in <ref> [MS90] </ref>. By augmenting the recursive language Pascal with some Simula control structures, the authors defined the language SimCal. They then developed a preprocessor that accepts SimCal input and produces Pascal output.
Reference: [Mue92] <author> Frank Mueller. </author> <title> Implementing POSIX Threads under UNIX: Description of Work in Progress. </title> <booktitle> In Proceedings of the Second Software Engineering Research Forum, </booktitle> <pages> pages 253-261, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Basically, migration is accomplished by copying the local machine stack to some remote machine and then restarting the computation. Examples of such systems are Ariadne [MR96] and Pthreads <ref> [IEE95, Mue92] </ref>. Because the contents of a machine stack are meaningless across hardware platforms, some help is needed in interpreting the sequence of binary digits.
Reference: [Ros] <author> J. A. Roskind. cpp5.y: </author> <title> Yacc-compatible input file defining a C++ grammar. </title> <journal> ftp://ics.uci.edu:/pub/gnu/c++grammar2.0.tar.Z, e-mail: jar@net-scape.com. </journal> <volume> 59 </volume>
Reference-contexts: So it was with great relief that we found the publicly available C and C++ grammars that James Roskind has written. In his distribution file are included lex and yacc files for ANSI C and C++ <ref> [Ros90a, Ros] </ref> and an improved version of byacc, Berkeley's parser generator [Ros90b]. Roskind's improvement of byacc is extremely helpful because it allows the program to graphically display all reductions as they are performed.
Reference: [Ros90a] <author> J. A. Roskind. cpp5.l: </author> <title> Flex input file defining a C++ lexical analyzer. </title> <journal> ftp://ics.uci.edu:/pub/gnu/c++grammar2.0.tar.Z, e-mail: </journal> <volume> jar@net-scape.com, </volume> <pages> 1989-1990. </pages>
Reference-contexts: So it was with great relief that we found the publicly available C and C++ grammars that James Roskind has written. In his distribution file are included lex and yacc files for ANSI C and C++ <ref> [Ros90a, Ros] </ref> and an improved version of byacc, Berkeley's parser generator [Ros90b]. Roskind's improvement of byacc is extremely helpful because it allows the program to graphically display all reductions as they are performed.
Reference: [Ros90b] <author> J. A. Roskind. skelgrph.c: </author> <title> Modified source file from the Berkeley yacc distribution. </title> <journal> ftp://ics.uci.edu:/pub/gnu/byacc1.8.tar.Z, e-mail: </journal> <volume> jar@net-scape.com, </volume> <pages> 1989-1990. </pages>
Reference-contexts: So it was with great relief that we found the publicly available C and C++ grammars that James Roskind has written. In his distribution file are included lex and yacc files for ANSI C and C++ [Ros90a, Ros] and an improved version of byacc, Berkeley's parser generator <ref> [Ros90b] </ref>. Roskind's improvement of byacc is extremely helpful because it allows the program to graphically display all reductions as they are performed. The Roskind C++ grammar is free of precedence and associativity rules, and for a grammar of this size, it is very readable.
Reference: [San94] <author> Janche Sang. </author> <title> Thread Migration On Heterogeneous Systems via Compile-Time Transformations. </title> <booktitle> In Proceedings of the International Conference on Parallel and Distributed Systems - ICPADS, </booktitle> <pages> pages 634-639, </pages> <year> 1994. </year>
Reference-contexts: Since these "suspension" points are well-known, the process of building the record, inserting the labels and incrementing state is fully automated. 3 In a project called Ythreads, Sang extended the above idea to facilitate heterogeneous migration <ref> [San94] </ref>. Since the state of a function is described as a global struct and the types of all data fields are known, it is possible to generate a platform-independent representation of that state, migrate it, and restart the computation on a different machine 1 . <p> In its present form, Arachne can serve as the underlying (threads) layer for distributed simulation systems (such as Parasol [MKR95]) or as a stand-alone environment for distributed computation (such as Ari-adne [MR95]). Ythreads <ref> [San94] </ref> was a first venture into heterogeneous migration and was mainly developed to test the feasibility of the concept. Arachne is an entirely new threads system, based on our experiences with Ythreads. Indeed, besides having more powerful features, it is easy-to-use, more efficient and much more flexible.
Reference: [SGDM94] <author> V. Sunderam, G. Geist, J. Dongarra, and R. Manchek. </author> <title> The PVM Concurrent Computing System: Evolution, Experiences, and Trends. </title> <journal> Parallel Computing, </journal> <volume> 20(4) </volume> <pages> 531-545, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: 1. INTRODUCTION Arachne is a user-level threads package capable of migrating computations across heterogeneous machine architectures. In its current version, Arachne uses the Parallel Virtual Machine environment (PVM) <ref> [SGDM94] </ref> for all network-layer operations, but with small changes it can be adapted to other distributed-networking environments. <p> These functions make calls to the underlying network library, and in the current version of Arachne, this library is PVM <ref> [SGDM94] </ref>. it is worth pointing out that the pointer to the current activation record, cur ar-&gt;ar is of type void *, and it has to be type-cast appropriately before any data can be accessed. int f_pack (ar_p act_rec) - struct f_ar *ar = (struct f_ar *)(act_rec-&gt;ar); (ar-&gt;state)++; if (pvm_pkshort (&(ar-&gt;state), 1,

References-found: 16

