URL: http://www.cs.columbia.edu/~kar/pubsk/invariant.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Email: junr@cs.columbia.edu  kar@cs.columbia.edu  
Title: Reusing Invariants: A New Strategy for Correlated Queries  
Author: Jun Rao Kenneth A. Ross 
Affiliation: Department of Computer Science Columbia University  Department of Computer Science Columbia University  
Abstract: Correlated queries are very common and important in decision support systems. Traditional nested iteration evaluation methods for such queries can be very time consuming. When they apply, query rewriting techniques have been shown to be much more efficient. But query rewriting is not always possible. When query rewriting does not apply, can we do something better than the traditional nested iteration methods? In this paper, we propose a new invariant technique to evaluate correlated queries efficiently. The basic idea is to recognize the part of the subquery that is not related to the outer references and cache the result of that part after its first execution. Later, we can reuse the result and combine it with the result of the rest of the subquery that is changing for each iteration. Our technique applies to arbitrary correlated subqueries. This paper introduces algorithms to recognize the invariant part of a data flow tree, and to restructure the evaluation plan to reuse the stored intermediate result. We also propose an efficient method to teach an existing join optimizer to understand the invariant feature and thus allow it to be able to generate better join plans in the new context. Some other related optimization techniques are also discussed. The proposed techniques were implemented within three months on an existing real commercial database system. We also experimentally evaluate our proposed technique. Our evaluation indicates that, when query rewriting is not possible, the invariant technique is significantly better than the traditional nested iteration method. Even when query rewriting applies, the invariant tech fl The implementation of the techniques in this paper was performed while the author was working at Sybase IQ, Burlington, MA. y Research at Columbia University was supported by a David and Lucile Packard Foundation Fellowship in Science and Engineering, by a Sloan Foundation Fellowship, by grants CDA-96-25374, and by an NSF Young Investigator award. Part of the work was performed while the author was visiting Sybase IQ, Burlington, MA. nique is sometimes better than the query rewriting technique. Our conclusion is that the invariant technique should be considered as one of the alternatives in evaluating correlated queries since it fills the gap left by rewriting techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [Bel96] <author> Randy Bello. </author> <title> Invariant subplans in dataflow. Sybase IQ Internal Engineering Document, </title> <year> 1996. </year>
Reference-contexts: The conclusion we have reached is that the rewriting technique is not always going to win. Our technique also works when the outer reference takes the form of host variables (variables coming from the client program), or bind variables (variables generated internally) <ref> [Bel96] </ref>. Without loss of generality, we will talk about only outer references in this paper. We'd also like to point out that our technique differs from the traditional memoization method [Mic68], which only helps when there are duplicates in the outer references. <p> The optimizer should understand the advantage of both techniques and be able to make the correct choice. Acknowledgments The basic idea of marking the invariant nodes in a data flow tree and replaying the content in a storage element was originally proposed in Sybase IQ <ref> [Bel96] </ref>. Roger MacNicol, manager of the database engine group in Sybase IQ, gave a lot of help both in implementation and validating the usefulness of the technique.
Reference: [CD85] <author> Hong-Tai Chou and David J. Dewitt. </author> <title> An evaluation of buffer management strategies for relational database systems. </title> <booktitle> In Proceedings of the 11th VLDB Conference, </booktitle> <pages> pages 127-141, </pages> <year> 1985. </year>
Reference-contexts: From our experimental results, we can see that even if a relation is used only once in a query, sharing the partitioning work among different levels of joins and group-bys can sometimes be helpful. A buffer management strategy has been introduced in <ref> [CD85] </ref>, which takes into account the way tables will be accessed when allocating buffers to them. We believe, with the help of this strategy and some appropriate clustering, a lot of the thrashing in our invariant evaluation method (for datasets larger than memory) can be avoided.
Reference: [Cha97] <author> Damianos Chatziantoniou. </author> <title> Optimization of Complex Aggregate Queries in Relational Databases. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Columbia University, </institution> <year> 1997. </year>
Reference-contexts: When the retrieving cost (RCost) is too high, the optimizer will decide not to cache the invariant result. In this case, NLI reduces to NL. So NLI will never perform worse than NL. 7 Related Work In <ref> [Cha97, CR97] </ref>, techniques of how to evaluate complex queries involving joins and group-bys efficiently have been proposed. The authors introduced a class of queries called "group queries".
Reference: [CR97] <author> Damianos Chatziantoniou and Kenneth A. Ross. </author> <title> Groupwise processing of relational queries. </title> <booktitle> In Proceedings of the 23th VLDB Conference, </booktitle> <pages> pages 476-485, </pages> <year> 1997. </year>
Reference-contexts: When the retrieving cost (RCost) is too high, the optimizer will decide not to cache the invariant result. In this case, NLI reduces to NL. So NLI will never perform worse than NL. 7 Related Work In <ref> [Cha97, CR97] </ref>, techniques of how to evaluate complex queries involving joins and group-bys efficiently have been proposed. The authors introduced a class of queries called "group queries".
Reference: [Day87] <author> Umeshwar Dayal. </author> <title> Of nests and trees: A unified approach to processing queries that contain nested subqueries, aggregates and quantifiers. </title> <booktitle> In Proceedings of the 13th VLDB Conference, </booktitle> <pages> pages 197-208, </pages> <year> 1987. </year>
Reference-contexts: As we have seen, the rewritten queries usually involve views being shared. Techniques for multiple query optimization on an intra-query (as opposed to inter-query) basis are desirable to improve the performance of the rewritten queries. Other query rewriting related work has been done in <ref> [Kim82, Day87, GW87, PHH92] </ref>. A comparison of the performance among these techniques can be found in [SPL96]. 8 Conclusion In this paper, we first discussed various ways of evaluating a correlated query.
Reference: [Gra94] <author> Goetz Graefe. Volcano, </author> <title> an extensible and parallel query evaluation system. </title> <journal> IEEE Transactions on knowledge and data engin-nering, </journal> <volume> 6(6) </volume> <pages> 934-944, </pages> <year> 1994. </year>
Reference-contexts: Our invariant technique is useful whether there are duplicates or not, although we can get additional benefit from memoization when there are duplicates in the outer references. We will base our discussion on the Volcano style query execution engine <ref> [Gra94] </ref>, in which each query plan is a tree of operators. All operators are implemented as iterators and support a simple open-next-close interface, where open () does most of the preparation work, next () fetches the rows one by one and close () cleans up everything.
Reference: [GW87] <author> Richard A. Ganski and Harry K.T. Wong. </author> <title> Optimization of nested sql queries revisited. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <pages> pages 23-33, </pages> <year> 1987. </year>
Reference-contexts: As we have seen, the rewritten queries usually involve views being shared. Techniques for multiple query optimization on an intra-query (as opposed to inter-query) basis are desirable to improve the performance of the rewritten queries. Other query rewriting related work has been done in <ref> [Kim82, Day87, GW87, PHH92] </ref>. A comparison of the performance among these techniques can be found in [SPL96]. 8 Conclusion In this paper, we first discussed various ways of evaluating a correlated query.
Reference: [Hel94] <author> Joseph M. Hellerstein. </author> <title> Practical predicate placement. </title> <booktitle> In Proceedings of the ACM SIG-MOD Conference, </booktitle> <pages> pages 325-335, </pages> <year> 1994. </year>
Reference-contexts: Many access plan strategies for complex decision support queries exploit the physical ordering of data provided by indexes or sorting. A recent paper [SSM96] introduced techniques of pushing down sorts in joins, reducing the number of sorting columns and detecting whether sorting can be avoided. Predicate migration <ref> [Hel94] </ref> considers whether an expensive predicate should be applied before or after a join. Similarly, group-by push-down [YL95] considers whether a group-by should be performed before a join. The above techniques are orthogonal to the invariant technique.
Reference: [HHW97] <author> Joseph M. Hellerstein, Peter J. Haas, and Helen J. Wang. </author> <title> Online aggregation. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <pages> pages 171-182, </pages> <year> 1997. </year>
Reference-contexts: Similar ideas have been proposed in other different applications <ref> [JM96, HHW97] </ref>. To summarize our experiments, we have the following conclusion. The invariant technique helps when query rewriting is not applicable. As RAM becomes cheaper, more complex queries (possibly involving new CPU intensive operations) will fit into memory.
Reference: [HN96] <author> Joseph M. Hellerstein and Jeffrey F. Naughton. </author> <title> Query execution techniques for caching expensive methods. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <pages> pages 423-433, </pages> <year> 1996. </year>
Reference-contexts: If the outer reference don't exist, we insert the values of the outer references and the corresponding subquery result into the hash table. If the probe succeeds, we can reuse the cached result instead of reexecuting the subquery. Recently, a new hybrid cache method has been suggested in <ref> [HN96] </ref> to avoid hash table thrashing. The second approach, described in [SAC + 79], is to presort all the rows from the outer query block on the outer references before executing the subquery. Then in the subquery node, we simply cache the result of the last execution of the subquery. <p> In cases when there are duplicates in outer references and the outer references are not the primary ordering keys specified in the query, we can still use the above method, but we use the alternative hashing method (or hybrid cache <ref> [HN96] </ref>) to avoid the reexecution of the subquery on repeated outer reference values. Similar ideas have been proposed in other different applications [JM96, HHW97]. To summarize our experiments, we have the following conclusion. The invariant technique helps when query rewriting is not applicable.
Reference: [JM96] <author> Roberto J. Bayardo Jr. and Daniel P. Mi-ranker. </author> <title> Processing queries for first few answers. </title> <booktitle> In Proceedings of the Fifth International Conference on Information and Knowledge Management, </booktitle> <pages> pages 45-52, </pages> <year> 1996. </year>
Reference-contexts: Similar ideas have been proposed in other different applications <ref> [JM96, HHW97] </ref>. To summarize our experiments, we have the following conclusion. The invariant technique helps when query rewriting is not applicable. As RAM becomes cheaper, more complex queries (possibly involving new CPU intensive operations) will fit into memory.
Reference: [Kim82] <author> Won Kim. </author> <title> On optimizing an sql-like nested query. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(3) </volume> <pages> 443-469, </pages> <year> 1982. </year>
Reference-contexts: For example, correlated queries with nested predicate using a noninclusion operator (NOT IN) are almost impossible to rewrite unless new types of operators are introduced as specified in <ref> [Kim82] </ref>. Another example is that an OUTER JOIN may be introduced in some query rewriting transformations. But this may not be desirable for systems that don't support OUTER JOIN directly. <p> As we have seen, the rewritten queries usually involve views being shared. Techniques for multiple query optimization on an intra-query (as opposed to inter-query) basis are desirable to improve the performance of the rewritten queries. Other query rewriting related work has been done in <ref> [Kim82, Day87, GW87, PHH92] </ref>. A comparison of the performance among these techniques can be found in [SPL96]. 8 Conclusion In this paper, we first discussed various ways of evaluating a correlated query.
Reference: [Lea96] <author> Dan Leary. </author> <title> Dataflow operators feature specification. Sybase IQ Internal Engineering Document, </title> <year> 1996. </year>
Reference-contexts: We describe related work in Section 7 and conclude in Section 8. 2 Finding the Invariant Subplan The Volcano execution engine didn't cover the implementation of a subquery. Here we choose Sybase IQ's approach <ref> [Lea96] </ref>. 1 We assume that a subquery will be implemented through a subquery node (operator) in a data flow tree. The left child of the subquery node corresponds to the outer query block while the right child corresponds to the inner query block, i.e., the subquery.
Reference: [Mic68] <author> Donald Michie. </author> <title> "memo" functions and machine learning. </title> <journal> Nature, </journal> <volume> 218 </volume> <pages> 19-22, </pages> <year> 1968. </year>
Reference-contexts: Without loss of generality, we will talk about only outer references in this paper. We'd also like to point out that our technique differs from the traditional memoization method <ref> [Mic68] </ref>, which only helps when there are duplicates in the outer references. Our invariant technique is useful whether there are duplicates or not, although we can get additional benefit from memoization when there are duplicates in the outer references. <p> So we are guaranteed that the final join plan is the best plan we can choose. There is another possible optimization technique that is orthogonal to the invariant optimization. We can avoid invoking the subquery on duplicate outer reference values by using the subquery memoization technique <ref> [Mic68] </ref>, which has already been implemented in several commercial systems [Syb97a, Syb97b]. There are two possible ways to do that. The first is to build a main-memory hash table on the subquery node.
Reference: [OL90] <author> Kiyoshi Ono and Guy M. Lohman. </author> <title> Measuring the complexity of join enumeration in query optimization. </title> <booktitle> In Proceedings of the 16th VLDB Conference, </booktitle> <pages> pages 314-325, </pages> <year> 1990. </year>
Reference-contexts: Techniques of pushing down sorts in joins have been proposed in [SSM96]. Unfortunately, the process of pushing down sort-ahead orders increases the complexity of join enumeration <ref> [OL90] </ref>, possibly by a factor of O (n 2 ) for n sort-ahead orders. This may become a problem when n is large. To summarize, at scale factor 1, data can fit into memory and the query is CPU cost dominated.
Reference: [OQ97] <author> Patrick O'Neil and Dallan Quas. </author> <title> Improved query performance with variant indexes. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <pages> pages 38-49, </pages> <year> 1997. </year>
Reference-contexts: Each column has a fast projection index, which is a compressed list of column values in TID order. Every key column has a high non-group index, which consists of a traditional B + tree and a Bit-Sliced index described in <ref> [OQ97] </ref>. There is also a high non-group index on ps availqty. Other columns in the local selection predicates have low fast indexes on them. A low fast index is basically a Bitmap index ([OQ97]).
Reference: [Pau97] <author> Glenn Paulley, </author> <year> 1997. </year> <type> personal communication. </type>
Reference-contexts: But this may not be desirable for systems that don't support OUTER JOIN directly. We enumerate several types of queries that have no existing ways (without introducing new operators) of being rewritten in Appendix A. Based on an estimation from the Sybase SQL Anywhere group <ref> [Pau97] </ref>, around 40% of real world correlated queries can not be rewritten. The queries for which query rewriting fails usually involve very complex subqueries, which can be very time-consuming if executed in the traditional nested iteration fashion.
Reference: [PHH92] <author> Hamid Pirahesh, Joseph M. Hellerstein, and Waqar Hasan. </author> <title> Extensible/rule based query rewrite optimization in startburst. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <pages> pages 39-38, </pages> <year> 1992. </year>
Reference-contexts: This is especially true when the number of iterations of the subquery is large. One problem with the rewriting strategy is that query decorrelation is not always possible and in some cases, although possible, may not be efficient. As pointed out in <ref> [PHH92] </ref>, "queries that contain non-existential or non-Boolean factor subqueries, set operators, aggregates, or user-defined extension operators (e.g., OUTER JOIN)" do not get rewritten. <p> As we have seen, the rewritten queries usually involve views being shared. Techniques for multiple query optimization on an intra-query (as opposed to inter-query) basis are desirable to improve the performance of the rewritten queries. Other query rewriting related work has been done in <ref> [Kim82, Day87, GW87, PHH92] </ref>. A comparison of the performance among these techniques can be found in [SPL96]. 8 Conclusion In this paper, we first discussed various ways of evaluating a correlated query.
Reference: [SAC + 79] <author> Patricia G. Selinger, Morton M. Astrahan, Donald D. Chamberlin, Raymond A. Lorie, and Thomsa G. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <pages> pages 23-34, </pages> <year> 1979. </year>
Reference-contexts: If the probe succeeds, we can reuse the cached result instead of reexecuting the subquery. Recently, a new hybrid cache method has been suggested in [HN96] to avoid hash table thrashing. The second approach, described in <ref> [SAC + 79] </ref>, is to presort all the rows from the outer query block on the outer references before executing the subquery. Then in the subquery node, we simply cache the result of the last execution of the subquery. <p> Potentially, the optimizer can choose an indexed join for node 10 in the QR plan and make it as good as NLI. But this is very challenging since the optimizer has to include all the join columns and group-by columns as "interesting orders" <ref> [SAC + 79] </ref> (possibly from different query blocks). Techniques of pushing down sorts in joins have been proposed in [SSM96]. Unfortunately, the process of pushing down sort-ahead orders increases the complexity of join enumeration [OL90], possibly by a factor of O (n 2 ) for n sort-ahead orders.
Reference: [Sel88] <author> Timos K. Sellis. </author> <title> Multiple-query optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(1) </volume> <pages> 23-52, </pages> <year> 1988. </year>
Reference-contexts: We need to take this into account given (a) less than 6,000 values (b) the whole picture the fact that deciding whether to materialize common views/subexpressions could be difficult <ref> [Sel88] </ref>. To verify our analysis above, we did another experiment using Query 2. The corresponding rewritten query can be derived in a similar fashion, but without introducing a group-by clause. The test was done at scale factor 1 and the result is shown in Figure 10. <p> The multi-query optimization problem is to optimize a collection of queries so as to minimize their total cost. The basic approach is to reduce the overall query execution cost by sharing intermediate results. Heuristic algorithms have been introduced in <ref> [Sel88, SG90] </ref>. As we have seen, the rewritten queries usually involve views being shared. Techniques for multiple query optimization on an intra-query (as opposed to inter-query) basis are desirable to improve the performance of the rewritten queries. Other query rewriting related work has been done in [Kim82, Day87, GW87, PHH92].
Reference: [SG90] <author> Timos K. Sellis and Subrata Ghosh. </author> <title> On the multiple-query optimization problem. </title> <journal> IEEE Transactions on knowledge and data engin-nering, </journal> <volume> 2(2) </volume> <pages> 262-266, </pages> <year> 1990. </year>
Reference-contexts: The multi-query optimization problem is to optimize a collection of queries so as to minimize their total cost. The basic approach is to reduce the overall query execution cost by sharing intermediate results. Heuristic algorithms have been introduced in <ref> [Sel88, SG90] </ref>. As we have seen, the rewritten queries usually involve views being shared. Techniques for multiple query optimization on an intra-query (as opposed to inter-query) basis are desirable to improve the performance of the rewritten queries. Other query rewriting related work has been done in [Kim82, Day87, GW87, PHH92].
Reference: [SPL96] <author> Praveen Seshadri, Hamid Pirahesh, and T.Y.Cliff Leung. </author> <title> Complex query decorrela-tion. </title> <booktitle> In Proc. IEEE Int'l Conf. on Data Eng., </booktitle> <pages> pages 450-458, </pages> <year> 1996. </year>
Reference-contexts: To overcome this problem, query decorrelation has been studied and proposed as a better solution. The basic idea is to rewrite a correlated query in such a way that outer references no longer exist. In <ref> [SPL96] </ref>, the authors proposed a technique that will extract all the distinct values of outer references and materialize all the possible results from the subquery. Later, the materialized results are joined with the outer query block on the outer reference values. <p> As pointed out in [PHH92], "queries that contain non-existential or non-Boolean factor subqueries, set operators, aggregates, or user-defined extension operators (e.g., OUTER JOIN)" do not get rewritten. Although it is shown in later work ( <ref> [SPL96] </ref>) that some of the queries including aggregates can be decorrelated, there are still many queries which we don't want to rewrite for either semantic or implementation reasons. <p> In this section, we compare the performance of the original nested iteration implementation (without considering invariants), our invariant technique, and query rewriting. We call them NL, NLI and QR respectively. We use the query rewriting technique introduced in <ref> [SPL96] </ref> since it gives better performance than other rewriting techniques in most cases. The machine we used was a dedicated Ultra Sparc II machine (200MHz and 128M of RAM), running SunOS Release 5.5.1. <p> Techniques for multiple query optimization on an intra-query (as opposed to inter-query) basis are desirable to improve the performance of the rewritten queries. Other query rewriting related work has been done in [Kim82, Day87, GW87, PHH92]. A comparison of the performance among these techniques can be found in <ref> [SPL96] </ref>. 8 Conclusion In this paper, we first discussed various ways of evaluating a correlated query. We then presented the technique of caching and reusing invariants and showed how to incorporate the invariant feature into a join optimizer smoothly. We also introduced other optimization methods to improve our invariant technique.
Reference: [SSM96] <author> David Simmen, Eugene Shekita, and Timothy Malkemus. </author> <title> Fundamental techniques for order optimization. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <pages> pages 57-67, </pages> <year> 1996. </year>
Reference-contexts: But this is very challenging since the optimizer has to include all the join columns and group-by columns as "interesting orders" [SAC + 79] (possibly from different query blocks). Techniques of pushing down sorts in joins have been proposed in <ref> [SSM96] </ref>. Unfortunately, the process of pushing down sort-ahead orders increases the complexity of join enumeration [OL90], possibly by a factor of O (n 2 ) for n sort-ahead orders. This may become a problem when n is large. <p> The details are left to future work. Many access plan strategies for complex decision support queries exploit the physical ordering of data provided by indexes or sorting. A recent paper <ref> [SSM96] </ref> introduced techniques of pushing down sorts in joins, reducing the number of sorting columns and detecting whether sorting can be avoided. Predicate migration [Hel94] considers whether an expensive predicate should be applied before or after a join.
Reference: [Syb97a] <author> Sybase Corporation. </author> <title> Adaptive Server Enterprise 11.5, </title> <year> 1997. </year>
Reference-contexts: There is another possible optimization technique that is orthogonal to the invariant optimization. We can avoid invoking the subquery on duplicate outer reference values by using the subquery memoization technique [Mic68], which has already been implemented in several commercial systems <ref> [Syb97a, Syb97b] </ref>. There are two possible ways to do that. The first is to build a main-memory hash table on the subquery node. Every time we evaluate a subquery, we first probe the hash table based on the values of the outer references for that iteration.
Reference: [Syb97b] <institution> Sybase Corporation. Sybase IQ 11.2.1, </institution> <year> 1997. </year>
Reference-contexts: Most relational database systems have analogous operator-based execution engines. We'll call this type of query engine a data flow engine and the execution plan a data flow tree. We implemented the invariant optimization technique on Sybase IQ's <ref> [Syb97b] </ref> data flow engine and join optimizer. It took only 3 man-months to have our technique seamlessly incorporated into the existing system. The technique will be present in an upcoming commercial version of Sybase IQ. <p> There is another possible optimization technique that is orthogonal to the invariant optimization. We can avoid invoking the subquery on duplicate outer reference values by using the subquery memoization technique [Mic68], which has already been implemented in several commercial systems <ref> [Syb97a, Syb97b] </ref>. There are two possible ways to do that. The first is to build a main-memory hash table on the subquery node. Every time we evaluate a subquery, we first probe the hash table based on the values of the outer references for that iteration.
Reference: [TPC95] <editor> Tpc-d benchmark standard specification (revision 1.0). </editor> <month> May </month> <year> 1995. </year>
Reference-contexts: Correlated queries are very important because: a) decision support systems tend to use them heavily to express complex requests, and b) correlated queries are often automatically generated by many application generators that translate queries from their native languages into standard SQL. In the TPC-D decision support benchmark <ref> [TPC95] </ref>, there are three correlated queries among the seventeen queries. Traditionally, the processing of correlated queries is usually done in a nested iteration fashion. All the rows from the outer query block are fetched one by one. <p> The machine we used was a dedicated Ultra Sparc II machine (200MHz and 128M of RAM), running SunOS Release 5.5.1. One disk was used to hold the databases, another for Sybase IQ's binaries, and a third was used for paging. The experiments were run on TPC-D <ref> [TPC95] </ref> databases at scale factor 1 and 10 with size of 1GB and 10 GB respectively 7 . We used 7 To save space, we populated only those tables needed in our experiment. the improved Sybase IQ version 11.2.1 for all the tests (with invariant techniques turned on and off). <p> The impact of memory size will be discussed below. We will base our discussion on the following two queries and their variations. Query 1: This is a TPC-D <ref> [TPC95] </ref> query that lists those suppliers that offer the desired type and size of parts in a particular region at the minimum cost. select s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment from part, supplier, partsupp, nation, region where p_partkey = ps_partkey and s_suppkey = ps_suppkey and p_size = 15 and
Reference: [YL95] <author> Weipeng P. Yan and Per-Ake Larson. </author> <title> Eager aggregation and lazy aggregation. </title> <booktitle> In Proceedings of the 21th VLDB Conference, </booktitle> <pages> pages 345-357, </pages> <year> 1995. </year>
Reference-contexts: A recent paper [SSM96] introduced techniques of pushing down sorts in joins, reducing the number of sorting columns and detecting whether sorting can be avoided. Predicate migration [Hel94] considers whether an expensive predicate should be applied before or after a join. Similarly, group-by push-down <ref> [YL95] </ref> considers whether a group-by should be performed before a join. The above techniques are orthogonal to the invariant technique. If they are applied in separate phases independently by the query optimizer, the best plan may be missed.
References-found: 27

