URL: http://ftp.eecs.umich.edu/people/yenmin/cse-tr-171-93.ps
Refering-URL: http://ftp.eecs.umich.edu/people/yenmin/
Root-URL: http://www.eecs.umich.edu
Email: yenmin@eecs.umich.edu ravi@eecs.umich.edu  
Title: Cicero: A Protocol Construction Language  
Author: Yen-Min Huang and Chinya V. Ravishankar 
Address: Ann Arbor, MI. 48109  
Affiliation: Electrical Engineering and Computer Science Department The University of Michigan,  
Abstract: Implementing efficient communication protocols is an important yet difficult task in building distributed systems. New protocols are often useful, but hard to implement well. The task will be even more challenging in the future, since we expect that more advanced communication functionality will be moved from applications into protocol implementation to reduce application development effort. This trend can be seen from the recent enhancements of RPC to include semantics for supporting group communication, transactions, fault-tolerance, and so on. Protocol developers will be challenged to provide correct and efficient protocol implementations that manage numerous concurrent I/O channels, and to increase protocol throughput to meet real-time requirements. These requirements demand better language support to facilitate precise control of multiple-thread interactions, and aggressive exploitation of parallelism in protocol execution, but without complicating the protocol verification process. This paper describes Cicero, a set of language constructs that are designed to meet these challenges. Cicero facilitates both sequential and parallel protocol implementation, especially for those above the transport-layer. It extends existing programming languages to support event-driven execution. A feature of Cicero is the use of event patterns [1] to control synchrony, asynchrony, and concurrency in protocol execution, which helps programmers build robust protocol implementations. Event-pattern driven execution also enables implementors to exploit parallelism of varying grains in protocol execution. Event patterns can also be translated into other formal models, so that existing verification techniques may be used. Our prototype implementation indicates that the total overhead imposed by event patterns is acceptable, and accounts for less than 5% of the overall latency for protocols above the transport layer. Examples are also provided to illustrate the usage of Cicero. fl This work was partly supported by the Consortium for International Earth Sciences Information Networking
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. V Ravishankar and R. Finkel. </author> <title> Linguistic Support for Dataflow. </title> <type> Technical Report CSE-TR-14-89, </type> <institution> Dept. of EECS, The University of Michigan, Ann Arbor, Michigan, </institution> <year> 1989. </year>
Reference-contexts: However, a simple event-driven model alone is not enough because complex relationships which often exist between events must be expressed in a structured way. To describe complex relationships between events, we have borrowed the notion of event patterns from POST <ref> [1] </ref>. Event patterns use event combinators to recursively describe relationships between events. Cicero uses the three event combinators "^", ",", and "", to express synchronous, asynchronous, and sequential relationships between events respectively. Event-pattern semantics can be classified into two types: active pattern semantics [1, 20] and passive pattern semantics [19]. <p> Event patterns use event combinators to recursively describe relationships between events. Cicero uses the three event combinators "^", ",", and "", to express synchronous, asynchronous, and sequential relationships between events respectively. Event-pattern semantics can be classified into two types: active pattern semantics <ref> [1, 20] </ref> and passive pattern semantics [19]. Event patterns in Cicero have active pattern semantics. They behave like safeguards, locally guaranteeing the relationships between events, rather than passively detecting these relationships. <p> The most novel aspect of Cicero is its approach to the integration of existing notions and abstractions to fulfill its design goals. Cicero integrates the following ideas: * Active Pattern Matching: The semantics of active pattern matching are borrowed from POST <ref> [1] </ref>. However, the design goal and context between POST and Cicero is quite different. While POST is designed as a general pattern-driven dataflow language, Cicero is designed as a language veneer for protocol construction. <p> Also, this separation allows Cicero to adopt additional programming abstractions for protocol implementation, including the object-based abstraction provided in [14]. Currently, the Cicero library is designed for implementing protocols above the transport-layer, such as RPC. * Restricted Dataflow Execution Model: The dataflow model [21] is well-known, and many languages <ref> [1, 26] </ref> and machines [27, 28] have been designed based on it. Instead of describing data-dependency or data-access disciplines, Cicero uses the dataflow model to describe event-driven execution, allowing programmers to explore parallelism in different granularities by changing the amount of computation in the associated actions. <p> CC_get_next_send_msg (handle [0]); 14 cond (CC_msg_type (v_msg) == DATA): 15 CC_send_udef_msg (handle [0],v_msg); 16 emit send_video; 17 (CC_msg_type (v_msg) == SYNC): 18 CC_send_ctrl_msg (handle [0],SYNC); 19 emit video_sync; 20 (CC_msg_type (v_msg) == END): emit video_end; 21 otherwise: emit Return:(val=E_MSGTP); 22 end; 24 25 when (send_audio~): 26 a_msg = CC_get_next_send_msg (handle <ref> [1] </ref>); 27 cond (CC_msg_type (a_msg) != DATA): 28 CC_send_udef_msg (handle [1],a_msg); 29 emit send_audio; 30 (CC_msg_type (a_msg) == SYNC): 31 CC_send_ctrl_msg (handle [1],SYNC); 32 emit audio_sync; 33 (CC_msg_type (a_msg) == END): emit audio_end; 34 otherwise: emit Return:(val=E_MSGTP); 35 end; 37 38 when (video_sync ^ audio_sync): /* adjust for synchronization */ 39 <p> 33 (CC_msg_type (a_msg) == END): emit audio_end; 34 otherwise: emit Return:(val=E_MSGTP); 35 end; 37 38 when (video_sync ^ audio_sync): /* adjust for synchronization */ 39 emit send_video; emit send_audio; /* continue sending data */ 40 end; 42 when (video_end ^ audio_end): /* done */ 43 CC_free_sendmsg (handle [0]); CC_free_sendmsg (handle <ref> [1] </ref>); 44 emit Return:(val=OK); 45 end; 35
Reference: [2] <author> K. S. Yap, P. Jalote, and S. Tripathi. </author> <title> Fault Tolerant Remote Procedure Call. </title> <booktitle> In Proc. of 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 48-54, </pages> <address> San Jose, CA, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: We envision that in the future, more advanced functionality will be moved from applications to protocol implementation to reduce the effort of developing applications. This trend can be seen from the recent development of RPC to include semantics for supporting group communication, transactions, fault-tolerance, etc <ref> [2, 3, 4] </ref>. As new distributed group/multi-media applications continue to emerge, protocol developers will be challenged to provide correct and efficient protocol implementations that manage numerous concurrent I/O channels, and to increase the protocol throughput to meet realtime requirements.
Reference: [3] <author> B. Liskov and R. Scheifler. </author> <title> Guardians and Actions: Linguistic Support for Robust, Distributed Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 381-404, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: We envision that in the future, more advanced functionality will be moved from applications to protocol implementation to reduce the effort of developing applications. This trend can be seen from the recent development of RPC to include semantics for supporting group communication, transactions, fault-tolerance, etc <ref> [2, 3, 4] </ref>. As new distributed group/multi-media applications continue to emerge, protocol developers will be challenged to provide correct and efficient protocol implementations that manage numerous concurrent I/O channels, and to increase the protocol throughput to meet realtime requirements.
Reference: [4] <author> L. Zahn, T. H. Dineen, P. J. Leach, E. A. Martin, N. W. Mishkin, J. N. Pato, and G. L. Wyant. </author> <title> Network Computing Architecture. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1990. </year>
Reference-contexts: We envision that in the future, more advanced functionality will be moved from applications to protocol implementation to reduce the effort of developing applications. This trend can be seen from the recent development of RPC to include semantics for supporting group communication, transactions, fault-tolerance, etc <ref> [2, 3, 4] </ref>. As new distributed group/multi-media applications continue to emerge, protocol developers will be challenged to provide correct and efficient protocol implementations that manage numerous concurrent I/O channels, and to increase the protocol throughput to meet realtime requirements.
Reference: [5] <author> H. J. Burkhardt, H. Eckert, and A. Giessler. </author> <title> Testing of Protocol Implementations A Systematic Approach to Derivation of Test Sequences from Global Protocol Specifications. </title> <editor> In M. Diaz, editor, </editor> <title> Protocol Specification, Testing and Verification V (IFIP/WG 6.1), </title> <address> Amster-dam, The Netherlands, </address> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference-contexts: This paper describes Cicero, a set of language constructs, that are designed to meet these challenges. Cicero is designed to facilitate hybrid protocol implementation strategies. Protocols can either be implemented by hand or be synthesized from specifications. Implementing protocols by hand requires thorough testing and debugging to assure correctness <ref> [5, 6] </ref>. While the performance of such implementations is usually good because software developers can tune performance, testing and debugging can be time consuming, especially for complex protocols. The alternative approach is to generate protocol implementations from protocol specifications, or to interpret specifications directly [7, 8, 9, 10, 11, 12].
Reference: [6] <author> J. Favreau and Jr. R. J. Linn. </author> <title> Automatic Generation of Test Scenario Skeletons from Protocol Specifications Written in Estelle. </title> <editor> In B. Sarikaya and G. v. Bochmann, editors, </editor> <title> Protocol Specification, Testing and Verification VI (IFIP/WG 6.1), </title> <address> Amsterdam, The Netherlands, </address> <publisher> North-Holland, </publisher> <year> 1987. </year>
Reference-contexts: This paper describes Cicero, a set of language constructs, that are designed to meet these challenges. Cicero is designed to facilitate hybrid protocol implementation strategies. Protocols can either be implemented by hand or be synthesized from specifications. Implementing protocols by hand requires thorough testing and debugging to assure correctness <ref> [5, 6] </ref>. While the performance of such implementations is usually good because software developers can tune performance, testing and debugging can be time consuming, especially for complex protocols. The alternative approach is to generate protocol implementations from protocol specifications, or to interpret specifications directly [7, 8, 9, 10, 11, 12].
Reference: [7] <author> T. P. Blumer and D. S. Sidhu. </author> <title> Mechanical Verification and Automatic Implementation of Communication Protocol. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(8) </volume> <pages> 827-843, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: While the performance of such implementations is usually good because software developers can tune performance, testing and debugging can be time consuming, especially for complex protocols. The alternative approach is to generate protocol implementations from protocol specifications, or to interpret specifications directly <ref> [7, 8, 9, 10, 11, 12] </ref>. This approach offers programmers help from tools to construct correct protocol implementations. However, the portions of a protocol implementation that can be generated depend on the environment and the specification language used, and the efficiency of generated code is also a concern [13, 14].
Reference: [8] <author> G. v. Bochmann, G. Gerbert, and J. M. Serre. </author> <title> Semiautomatic Implementation of Communication Protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(9) </volume> <pages> 989-999, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: While the performance of such implementations is usually good because software developers can tune performance, testing and debugging can be time consuming, especially for complex protocols. The alternative approach is to generate protocol implementations from protocol specifications, or to interpret specifications directly <ref> [7, 8, 9, 10, 11, 12] </ref>. This approach offers programmers help from tools to construct correct protocol implementations. However, the portions of a protocol implementation that can be generated depend on the environment and the specification language used, and the efficiency of generated code is also a concern [13, 14].
Reference: [9] <author> J. P. Briand, M. C. Fehri, L. Logrippo, and A. Obaid. </author> <title> Executing LOTOS Specifications. </title> <editor> In B. Sarikaya and G. v. Bochmann, editors, </editor> <title> Protocol Specification, Testing and Verification VI (IFIP/WG 6.1), </title> <address> Amsterdam, The Netherlands, </address> <publisher> North-Holland, </publisher> <year> 1987. </year> <month> 36 </month>
Reference-contexts: While the performance of such implementations is usually good because software developers can tune performance, testing and debugging can be time consuming, especially for complex protocols. The alternative approach is to generate protocol implementations from protocol specifications, or to interpret specifications directly <ref> [7, 8, 9, 10, 11, 12] </ref>. This approach offers programmers help from tools to construct correct protocol implementations. However, the portions of a protocol implementation that can be generated depend on the environment and the specification language used, and the efficiency of generated code is also a concern [13, 14].
Reference: [10] <author> J. P. Ansart, P. D. Amer, V. Chari, J. F. Lenotre, L. Lumbroso, E. Mariani, and E. Mattera. </author> <title> Software Tools for Estelle. </title> <editor> In B. Sarikaya and G. v. Bochmann, editors, </editor> <title> Protocol Specification, Testing and Verification VI (IFIP/WG 6.1), </title> <address> Amsterdam, The Netherlands, </address> <publisher> North-Holland, </publisher> <year> 1987. </year>
Reference-contexts: While the performance of such implementations is usually good because software developers can tune performance, testing and debugging can be time consuming, especially for complex protocols. The alternative approach is to generate protocol implementations from protocol specifications, or to interpret specifications directly <ref> [7, 8, 9, 10, 11, 12] </ref>. This approach offers programmers help from tools to construct correct protocol implementations. However, the portions of a protocol implementation that can be generated depend on the environment and the specification language used, and the efficiency of generated code is also a concern [13, 14]. <p> Much research has been conducted in automatically generating protocol implementations from these FDTs <ref> [10, 11, 12, 30] </ref>. However, the protocol implementations generated by these means are generally in the 7 form of skeletons which must be filled in by programmer code [14]. Also, the efficiency of generated code is a concern [13].
Reference: [11] <author> S. T. Vuong, A. C. Lau, and R. I. Chan. </author> <title> Semiautomatic Implementation of Protocols Using an Estelle-C Compiler. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(3) </volume> <pages> 384-393, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: While the performance of such implementations is usually good because software developers can tune performance, testing and debugging can be time consuming, especially for complex protocols. The alternative approach is to generate protocol implementations from protocol specifications, or to interpret specifications directly <ref> [7, 8, 9, 10, 11, 12] </ref>. This approach offers programmers help from tools to construct correct protocol implementations. However, the portions of a protocol implementation that can be generated depend on the environment and the specification language used, and the efficiency of generated code is also a concern [13, 14]. <p> Much research has been conducted in automatically generating protocol implementations from these FDTs <ref> [10, 11, 12, 30] </ref>. However, the protocol implementations generated by these means are generally in the 7 form of skeletons which must be filled in by programmer code [14]. Also, the efficiency of generated code is a concern [13].
Reference: [12] <author> G. Albertengo, S. Forno, and A. Fumagalli. TOP/PDT: </author> <title> A Toolkit for Development of Communication Protocols. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 8(9) </volume> <pages> 1763-1770, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: While the performance of such implementations is usually good because software developers can tune performance, testing and debugging can be time consuming, especially for complex protocols. The alternative approach is to generate protocol implementations from protocol specifications, or to interpret specifications directly <ref> [7, 8, 9, 10, 11, 12] </ref>. This approach offers programmers help from tools to construct correct protocol implementations. However, the portions of a protocol implementation that can be generated depend on the environment and the specification language used, and the efficiency of generated code is also a concern [13, 14]. <p> Much research has been conducted in automatically generating protocol implementations from these FDTs <ref> [10, 11, 12, 30] </ref>. However, the protocol implementations generated by these means are generally in the 7 form of skeletons which must be filled in by programmer code [14]. Also, the efficiency of generated code is a concern [13].
Reference: [13] <author> L. Svobodova. </author> <title> Implementing OSI Systems. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 7(7) </volume> <pages> 1115-1130, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: This approach offers programmers help from tools to construct correct protocol implementations. However, the portions of a protocol implementation that can be generated depend on the environment and the specification language used, and the efficiency of generated code is also a concern <ref> [13, 14] </ref>. In addition, programmers must learn the specification languages before they can take advantage of such tools. The performance of generated implementations may need tuning because the assumptions and the implementation decisions made by a specification compiler may not be optimal for all environments. <p> However, the protocol implementations generated by these means are generally in the 7 form of skeletons which must be filled in by programmer code [14]. Also, the efficiency of generated code is a concern <ref> [13] </ref>. Cicero is designed as an executable specification language to allow programmers to have direct control over generated code, and requires no additional patching to the generated code. 4 Cicero Concepts The Cicero language model is based on the notions of events, event instances, and event patterns.
Reference: [14] <author> M. B. Abbott and L. L. Peterson. </author> <title> A Language-Based Approach to Protocol Implementation. </title> <journal> IEEE/ACM Transactions on Netorking, </journal> <volume> 1(1) </volume> <pages> 4-19, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: This approach offers programmers help from tools to construct correct protocol implementations. However, the portions of a protocol implementation that can be generated depend on the environment and the specification language used, and the efficiency of generated code is also a concern <ref> [13, 14] </ref>. In addition, programmers must learn the specification languages before they can take advantage of such tools. The performance of generated implementations may need tuning because the assumptions and the implementation decisions made by a specification compiler may not be optimal for all environments. <p> This is necessary in practice because remote communication must often deal with the additional problem of partial failures, and the resilience of failure can vary greatly across protocols. Also, this separation allows Cicero to adopt additional programming abstractions for protocol implementation, including the object-based abstraction provided in <ref> [14] </ref>. Currently, the Cicero library is designed for implementing protocols above the transport-layer, such as RPC. * Restricted Dataflow Execution Model: The dataflow model [21] is well-known, and many languages [1, 26] and machines [27, 28] have been designed based on it. <p> Much research has been conducted in automatically generating protocol implementations from these FDTs [10, 11, 12, 30]. However, the protocol implementations generated by these means are generally in the 7 form of skeletons which must be filled in by programmer code <ref> [14] </ref>. Also, the efficiency of generated code is a concern [13].
Reference: [15] <author> ISO. </author> <title> Information Processing Systems Open System Interconnection - LOTOS A Formal Description Technique Based on the Temperal Ordering of Observational Behavior, </title> <year> 1985. </year>
Reference-contexts: A natural abstraction for this purpose is an event-driven paradigm, where a protocol is viewed as a machine reacting to internal/external events or messages <ref> [15, 16, 17, 18, 19] </ref>. However, a simple event-driven model alone is not enough because complex relationships which often exist between events must be expressed in a structured way. To describe complex relationships between events, we have borrowed the notion of event patterns from POST [1]. <p> The dataflow model also provides the formalism to allow Cicero to be translated to/from other protocol specification model (e.g. Petri nets [22]), so that existing tools may be used to facilitate constructing protocols. * Executable Specifications: Several Formal Description Techniques (FDT), like LOTOS <ref> [15] </ref>, Estelle [16], and SDL [29], have been developed to specify protocol behavior formally. Much research has been conducted in automatically generating protocol implementations from these FDTs [10, 11, 12, 30].
Reference: [16] <author> ISO. </author> <title> Information Processing Systems Open System Interconnection - Estelle (Formal Description Technique Based on an Extended State Transition Model) , 1987. </title>
Reference-contexts: A natural abstraction for this purpose is an event-driven paradigm, where a protocol is viewed as a machine reacting to internal/external events or messages <ref> [15, 16, 17, 18, 19] </ref>. However, a simple event-driven model alone is not enough because complex relationships which often exist between events must be expressed in a structured way. To describe complex relationships between events, we have borrowed the notion of event patterns from POST [1]. <p> The dataflow model also provides the formalism to allow Cicero to be translated to/from other protocol specification model (e.g. Petri nets [22]), so that existing tools may be used to facilitate constructing protocols. * Executable Specifications: Several Formal Description Techniques (FDT), like LOTOS [15], Estelle <ref> [16] </ref>, and SDL [29], have been developed to specify protocol behavior formally. Much research has been conducted in automatically generating protocol implementations from these FDTs [10, 11, 12, 30].
Reference: [17] <author> G. Berry and G. Gonthier. </author> <title> The Synchronous Programming Language ESTEREL: Design, Semantics, Implementation. </title> <type> Technical Report 842, </type> <institution> INRIA, </institution> <year> 1988. </year>
Reference-contexts: A natural abstraction for this purpose is an event-driven paradigm, where a protocol is viewed as a machine reacting to internal/external events or messages <ref> [15, 16, 17, 18, 19] </ref>. However, a simple event-driven model alone is not enough because complex relationships which often exist between events must be expressed in a structured way. To describe complex relationships between events, we have borrowed the notion of event patterns from POST [1]. <p> They behave like safeguards, locally guaranteeing the relationships between events, rather than passively detecting these relationships. In other words, our event patterns ensure specified relationships between events before performing actions, rather than detecting some relationships between events and then performing actions as in many other event-driven languages <ref> [17, 19] </ref>. For example, in Cicero, the event pattern (a b) is used to sequence the delivery of event a and b. The sequence of delivery is enforced locally even if event b actually occurs first. <p> Active pattern matching can alleviate this difficulty by fixing the symptoms directly. * Event-Driven Abstraction: Our event-driven model is derived from the notion of event flows in ESTEREL <ref> [17] </ref>. However, we have extended the simple event-driven model to include event patterns, allowing 6 programmers to express complex relationships between events for controlling the execu-tion. The Actor model [18] is another well-known model for concurrent computation in distributed systems.
Reference: [18] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: A natural abstraction for this purpose is an event-driven paradigm, where a protocol is viewed as a machine reacting to internal/external events or messages <ref> [15, 16, 17, 18, 19] </ref>. However, a simple event-driven model alone is not enough because complex relationships which often exist between events must be expressed in a structured way. To describe complex relationships between events, we have borrowed the notion of event patterns from POST [1]. <p> However, we have extended the simple event-driven model to include event patterns, allowing 6 programmers to express complex relationships between events for controlling the execu-tion. The Actor model <ref> [18] </ref> is another well-known model for concurrent computation in distributed systems. In Actor, as in Cicero, no ordering is defined for unrelated events.
Reference: [19] <author> W. Hseush and G. E. Kaiser. </author> <title> Modeling Concurrency in Parallel Debugging. </title> <booktitle> In Proc. of 2nd ACM SIGLPAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 11-20, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: A natural abstraction for this purpose is an event-driven paradigm, where a protocol is viewed as a machine reacting to internal/external events or messages <ref> [15, 16, 17, 18, 19] </ref>. However, a simple event-driven model alone is not enough because complex relationships which often exist between events must be expressed in a structured way. To describe complex relationships between events, we have borrowed the notion of event patterns from POST [1]. <p> Event patterns use event combinators to recursively describe relationships between events. Cicero uses the three event combinators "^", ",", and "", to express synchronous, asynchronous, and sequential relationships between events respectively. Event-pattern semantics can be classified into two types: active pattern semantics [1, 20] and passive pattern semantics <ref> [19] </ref>. Event patterns in Cicero have active pattern semantics. They behave like safeguards, locally guaranteeing the relationships between events, rather than passively detecting these relationships. <p> They behave like safeguards, locally guaranteeing the relationships between events, rather than passively detecting these relationships. In other words, our event patterns ensure specified relationships between events before performing actions, rather than detecting some relationships between events and then performing actions as in many other event-driven languages <ref> [17, 19] </ref>. For example, in Cicero, the event pattern (a b) is used to sequence the delivery of event a and b. The sequence of delivery is enforced locally even if event b actually occurs first. <p> While POST is designed as a general pattern-driven dataflow language, Cicero is designed as a language veneer for protocol construction. Although the semantics of our event patterns are reminiscent of those of path expressions [20] and data path expression <ref> [19] </ref>, the usage and semantics of our event patterns expressions are very different from theirs. <p> For example, an event pattern can indicate that some target code be triggered only when both event e1 and e2 occur. Such constraints cannot easily be expressed by path expressions alone. Data path expressions have been used for detecting incorrect behavior in concurrent programs <ref> [19] </ref>, and provide passive pattern-matching semantics. While passive pattern semantics are useful for debugging purposes, it may not be easy to locate the causes from the detected symptoms.
Reference: [20] <author> R. H. Campbell and A. N. Habermann. </author> <title> The Specification of Process Synchronization by Path Expression. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> volume 16, </volume> <pages> pages 89-102, </pages> <address> New York, 1974. </address> <publisher> Springer-Verlag. </publisher> <pages> 37 </pages>
Reference-contexts: Event patterns use event combinators to recursively describe relationships between events. Cicero uses the three event combinators "^", ",", and "", to express synchronous, asynchronous, and sequential relationships between events respectively. Event-pattern semantics can be classified into two types: active pattern semantics <ref> [1, 20] </ref> and passive pattern semantics [19]. Event patterns in Cicero have active pattern semantics. They behave like safeguards, locally guaranteeing the relationships between events, rather than passively detecting these relationships. <p> However, the design goal and context between POST and Cicero is quite different. While POST is designed as a general pattern-driven dataflow language, Cicero is designed as a language veneer for protocol construction. Although the semantics of our event patterns are reminiscent of those of path expressions <ref> [20] </ref> and data path expression [19], the usage and semantics of our event patterns expressions are very different from theirs.
Reference: [21] <author> R. M. Karp and R. E. Miller. </author> <title> Properties of a Model for Parallel Computation: Determinacy, Termination, Queueing. </title> <journal> SIAM Journal of App. Math, </journal> <pages> pages 1390-1411, </pages> <month> November </month> <year> 1966. </year>
Reference-contexts: We have found that a restricted dataflow model <ref> [21] </ref> can help us exploit parallelism in protocol execution, and can model our event-driven style of execution faithfully. An obvious analogy can be drawn between events and data tokens in a restricted dataflow model, where token arrival serves as a mechanism for triggering/firing actions. <p> Also, this separation allows Cicero to adopt additional programming abstractions for protocol implementation, including the object-based abstraction provided in [14]. Currently, the Cicero library is designed for implementing protocols above the transport-layer, such as RPC. * Restricted Dataflow Execution Model: The dataflow model <ref> [21] </ref> is well-known, and many languages [1, 26] and machines [27, 28] have been designed based on it.
Reference: [22] <author> K. M. Kavi, B. P. Buckles, and U. N. Bhat. </author> <title> Isomorphism Between Petri nets and Dataflow Graphs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(10) </volume> <pages> 1127-1134, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: By changing the code granularity with patterns, we can change the granularity of parallelism exploited in Cicero. This capability is useful because it allows programmers to experiment with different granularities in tuning performance. Using the dataflow model also has other advantages. First, it is mathematically well-defined <ref> [22] </ref> and well-understood. Second, it can be translated to/from other formal models (e.g. Petri nets [22]), making it possible to use existing protocol verification methods/tools, and easier to construct tools for generating protocol implementations from existing protocol specifications. <p> This capability is useful because it allows programmers to experiment with different granularities in tuning performance. Using the dataflow model also has other advantages. First, it is mathematically well-defined <ref> [22] </ref> and well-understood. Second, it can be translated to/from other formal models (e.g. Petri nets [22]), making it possible to use existing protocol verification methods/tools, and easier to construct tools for generating protocol implementations from existing protocol specifications. These capabilities can further automate protocol implementation and improve the quality of implementation. <p> The dataflow model also provides the formalism to allow Cicero to be translated to/from other protocol specification model (e.g. Petri nets <ref> [22] </ref>), so that existing tools may be used to facilitate constructing protocols. * Executable Specifications: Several Formal Description Techniques (FDT), like LOTOS [15], Estelle [16], and SDL [29], have been developed to specify protocol behavior formally. <p> To illustrate, we will describe the translation between Petri nets and event patterns. The translations between Petri nets and Cicero are based on the translation developed in <ref> [22] </ref> for proving isomorphism between Petri nets and dataflow graphs. 8.1 Translation From Petri Nets Translation from Petri nets to event patterns (when constructs) can be easily done as follows. First, each arc in the Petri net is given a unique name, corresponding to an atom in an event pattern. <p> The details of the translation will not be presented here because they are quite involved, and can be found elsewhere <ref> [22, 32] </ref>.
Reference: [23] <author> Y. Huang and C. V. Ravishankar. </author> <title> Accommodating RPC Heterogeneities in Large Heterogeneous Distributed Environments. </title> <booktitle> In Proc. of the 26th Hawaii International Conference on System Sciences (HICSS-26), </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: This approach allows developers to customize Cicero for implementing different classes of protocols. For example, we have used Cicero to construct heterogeneous RPC mechanisms to facilitate the interconnection between the client and server programs speaking different RPC protocols <ref> [23] </ref>. <p> Currently, we use Cicero to describe different RPC protocol implementations, so that gateway agents may be synthesized to interconnect the client and server programs using different RPC protocols <ref> [23] </ref>. Appendix A Formal Description of Event Pattern Semantics This section describes event pattern semantics formally. Event pattern semantics described here are from the perspective of individual when construct, which operates on its own copy of instances.
Reference: [24] <author> S. Sechrest. </author> <title> An Introductory 4.3BSD Interprocess Communication Tutorial. Unix Pogram-mer's Manual Supplementary Documents 1, </title> <address> 1:PS1:7-1 - PS1:-25, </address> <year> 1986. </year>
Reference-contexts: However, we globally order the instances of the same event to facilitate the coordination among multiple threads. * Separation of Local and Remote Communication Mechanisms: In the past, much work has been done on integrating local and remote communication into one abstraction. BSD sockets <ref> [24] </ref> and remote procedure calls (RPC) [25] are well-known examples. However, Cicero provides different communication mechanisms for local and remote communication, because it is designed for protocol construction, and not for general distributed computing.
Reference: [25] <author> A. P. Birrell and B. J. Nelson. </author> <title> Implementing Remote Procedure Call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: BSD sockets [24] and remote procedure calls (RPC) <ref> [25] </ref> are well-known examples. However, Cicero provides different communication mechanisms for local and remote communication, because it is designed for protocol construction, and not for general distributed computing.
Reference: [26] <author> W. W. Wadge and E. A. Ashcroft. </author> <title> Lucid, the Dataflow Programming Language. </title> <publisher> Academic Press U.K., </publisher> <year> 1985. </year>
Reference-contexts: Also, this separation allows Cicero to adopt additional programming abstractions for protocol implementation, including the object-based abstraction provided in [14]. Currently, the Cicero library is designed for implementing protocols above the transport-layer, such as RPC. * Restricted Dataflow Execution Model: The dataflow model [21] is well-known, and many languages <ref> [1, 26] </ref> and machines [27, 28] have been designed based on it. Instead of describing data-dependency or data-access disciplines, Cicero uses the dataflow model to describe event-driven execution, allowing programmers to explore parallelism in different granularities by changing the amount of computation in the associated actions.
Reference: [27] <author> W. W. Hwu and Y. Patt. HPSm, </author> <title> a High Performance Restricted Data Flow Architecture having Minimal Functionality. </title> <booktitle> In The 13th International Symposium on Computer Architecture Conference Proceedings, </booktitle> <pages> pages 297-306, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Currently, the Cicero library is designed for implementing protocols above the transport-layer, such as RPC. * Restricted Dataflow Execution Model: The dataflow model [21] is well-known, and many languages [1, 26] and machines <ref> [27, 28] </ref> have been designed based on it. Instead of describing data-dependency or data-access disciplines, Cicero uses the dataflow model to describe event-driven execution, allowing programmers to explore parallelism in different granularities by changing the amount of computation in the associated actions.
Reference: [28] <author> M. Johnson. </author> <title> Superscalar Microprocessor Design. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1991. </year>
Reference-contexts: Currently, the Cicero library is designed for implementing protocols above the transport-layer, such as RPC. * Restricted Dataflow Execution Model: The dataflow model [21] is well-known, and many languages [1, 26] and machines <ref> [27, 28] </ref> have been designed based on it. Instead of describing data-dependency or data-access disciplines, Cicero uses the dataflow model to describe event-driven execution, allowing programmers to explore parallelism in different granularities by changing the amount of computation in the associated actions.
Reference: [29] <author> CCITT. </author> <title> Specification and Description Language Recommendation Z.100 , 1986. </title>
Reference-contexts: The dataflow model also provides the formalism to allow Cicero to be translated to/from other protocol specification model (e.g. Petri nets [22]), so that existing tools may be used to facilitate constructing protocols. * Executable Specifications: Several Formal Description Techniques (FDT), like LOTOS [15], Estelle [16], and SDL <ref> [29] </ref>, have been developed to specify protocol behavior formally. Much research has been conducted in automatically generating protocol implementations from these FDTs [10, 11, 12, 30].
Reference: [30] <author> A. Valenzano, R. Sisto, and L. Ciminiera. </author> <title> Rapid Prototyping of Protocols from LOTOS Specification. </title> <journal> Software Practice and Experience, </journal> <volume> 23(1) </volume> <pages> 31-54, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Much research has been conducted in automatically generating protocol implementations from these FDTs <ref> [10, 11, 12, 30] </ref>. However, the protocol implementations generated by these means are generally in the 7 form of skeletons which must be filled in by programmer code [14]. Also, the efficiency of generated code is a concern [13].
Reference: [31] <author> J. L. Peterson. </author> <title> Petri nets. </title> <journal> ACM Computing Surveys, </journal> <volume> 9(3) </volume> <pages> 224-252, </pages> <month> September </month> <year> 1977. </year>
Reference-contexts: We have not explored such issues. 8.2 Translations To Petri Nets Translation from Cicero constructs to Petri nets is accomplished by translating each construct into a special class of Petri nets called free-choice Petri nets <ref> [31] </ref>, and then interconnecting them. The details of the translation will not be presented here because they are quite involved, and can be found elsewhere [22, 32].
Reference: [32] <author> Y. Huang and C. V. Ravishankar. Cicero: </author> <title> A Protocol Construction Language. </title> <type> Technical Report CSE-TR-171-93, </type> <institution> Dept. of EECS, The University of Michigan, Ann Arbor, Michigan, </institution> <year> 1993. </year>
Reference-contexts: The details of the translation will not be presented here because they are quite involved, and can be found elsewhere <ref> [22, 32] </ref>.
Reference: [33] <author> M. E. Lesk and E. Schmidt. </author> <title> Lex A Lexical Analyzer Generator. In UNIX Programmer's Supplementary Documents, </title> <journal> Vol. </journal> <volume> 1, </volume> <year> 1986. </year>
Reference-contexts: The Cicero compiler is implemented using UNIX lex <ref> [33] </ref> and yacc [34]. Because the implementation of the compiler front-end is standard, we will focus on its runtime library. Each when construct is compiled to a procedure and executed as a thread.
Reference: [34] <author> S. C. Johnson. </author> <title> Yacc: Yet Another Compiler-Compiler. In UNIX Programmer's Supplementary Documents, </title> <journal> Vol. </journal> <volume> 1, </volume> <year> 1986. </year> <month> 38 </month>
Reference-contexts: The Cicero compiler is implemented using UNIX lex [33] and yacc <ref> [34] </ref>. Because the implementation of the compiler front-end is standard, we will focus on its runtime library. Each when construct is compiled to a procedure and executed as a thread.
Reference: [35] <author> Sun Microsystems. </author> <title> Programming Utilities and Libraries, </title> <month> March </month> <year> 1990. </year>
Reference-contexts: the 1 For example, assertions about network behavior and escape components are often needed. 22 Overhead Type NOLWP Unix CThread SUNLWP Instance Emission 0.03ms 0.13ms 0.19ms Pattern Execution 0.02ms 0.04ms 0.05ms Total 0.05ms 0.17ms 0.24ms Table 3: Cicero Runtime Overhead runtime library supports interfaces to four thread packages, SUN LWP <ref> [35] </ref>, Brown Threads [36], UNIX Cthreads [37], and Mach Cthreads [38]. If no thread package is available, the Cicero runtime can still operate by calling the when constructs in the task queue in order within the dispatch routine.
Reference: [36] <author> Thomas W. Doeppner. </author> <title> A Threads Tutorial. </title> <type> Technical Report CS-87-06, </type> <institution> Department of Computer Science, Brown University, </institution> <month> March, </month> <year> 1987. </year>
Reference-contexts: example, assertions about network behavior and escape components are often needed. 22 Overhead Type NOLWP Unix CThread SUNLWP Instance Emission 0.03ms 0.13ms 0.19ms Pattern Execution 0.02ms 0.04ms 0.05ms Total 0.05ms 0.17ms 0.24ms Table 3: Cicero Runtime Overhead runtime library supports interfaces to four thread packages, SUN LWP [35], Brown Threads <ref> [36] </ref>, UNIX Cthreads [37], and Mach Cthreads [38]. If no thread package is available, the Cicero runtime can still operate by calling the when constructs in the task queue in order within the dispatch routine.
Reference: [37] <author> K. Schwan, H. Forbes, A. Gheith, B. Mukherjee, and Y. Samiotakis. </author> <title> A CThread Library for Multiprocessors. </title> <type> Technical Report GIT-ICS-91/02, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <year> 1991. </year>
Reference-contexts: network behavior and escape components are often needed. 22 Overhead Type NOLWP Unix CThread SUNLWP Instance Emission 0.03ms 0.13ms 0.19ms Pattern Execution 0.02ms 0.04ms 0.05ms Total 0.05ms 0.17ms 0.24ms Table 3: Cicero Runtime Overhead runtime library supports interfaces to four thread packages, SUN LWP [35], Brown Threads [36], UNIX Cthreads <ref> [37] </ref>, and Mach Cthreads [38]. If no thread package is available, the Cicero runtime can still operate by calling the when constructs in the task queue in order within the dispatch routine. In the runtime library, this case is encapsulated by a special thread package interface called NOLWP.
Reference: [38] <author> E. C. Cooper and R. P. Draves. </author> <title> C Threads. </title> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <month> July </month> <year> 1987. </year>
Reference-contexts: components are often needed. 22 Overhead Type NOLWP Unix CThread SUNLWP Instance Emission 0.03ms 0.13ms 0.19ms Pattern Execution 0.02ms 0.04ms 0.05ms Total 0.05ms 0.17ms 0.24ms Table 3: Cicero Runtime Overhead runtime library supports interfaces to four thread packages, SUN LWP [35], Brown Threads [36], UNIX Cthreads [37], and Mach Cthreads <ref> [38] </ref>. If no thread package is available, the Cicero runtime can still operate by calling the when constructs in the task queue in order within the dispatch routine. In the runtime library, this case is encapsulated by a special thread package interface called NOLWP.
Reference: [39] <author> Didier Le Gall. </author> <title> MPEG: A Video Compression Standard for Multimedia Applications. </title> <journal> Communications of the ACM, </journal> <volume> 34(4):46 - 58, </volume> <year> 1991. </year> <month> 39 </month>
Reference-contexts: The video and audio streams are stored at separate files, and are sent through separate channels. The stored video is encoded using the MPEG standard <ref> [39] </ref>, which is based on a scheme to predict motion from frame to frame in the temporal direction. Frame prediction in MPEG is based upon intra frames (still images) in the video. To facilitate parallel MPEG decoding, additional indices are built to locate these frames.
References-found: 39

