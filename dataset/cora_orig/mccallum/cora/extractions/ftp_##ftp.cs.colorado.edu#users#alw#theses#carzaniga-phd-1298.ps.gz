URL: ftp://ftp.cs.colorado.edu/users/alw/theses/carzaniga-phd-1298.ps.gz
Refering-URL: http://www.cs.colorado.edu/users/alw/AvailableTheses.html
Root-URL: http://www.cs.colorado.edu
Title: Architectures for an Event Notification Service Scalable to Wide-area Networks  
Author: Prof. Alfonso Fuggetta Co-Advisors: Prof. Alexander L. Wolf Prof. David S. Rosenblum Prof. Carlo Ghezzi 
Degree: DOTTORATO DI RICERCA IN  PhD Thesis of: Antonio Carzaniga Advisor:  Supervisor of the Ph.D. Program:  
Affiliation: POLITECNICO DI MILANO  INGEGNERIA INFORMATICA E AUTOMATICA  X ciclo  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. Ahn and P. B. Danzig. </author> <title> Speedup vs. Simulation Granularity. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 4(5):743757, </volume> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: A complete simulation is just not feasible because of the immense amount of data and interactions that are involved at different levels of granularity. According to an estimate by Ahn and Danzig <ref> [1] </ref>, five minutes of activity on a network the size of today's Internet would require gigabytes of real memory and months of computations on 100 MIPS uniprocessors.
Reference: [2] <author> R. L. Bagrodia, K. M. Chandy, and J. Misra. </author> <title> A Message-Based Approach to Discrete-Event Simulation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(6):654665, </volume> <month> June </month> <year> 1987. </year>
Reference-contexts: In particular, as pointed out by Paxson in [61], the idea of shifting the focus from a packet-level simulation to a simulation of an application-level model seems to be a very promising and motivates even more the approach we take in SIENA. 5.1 Simulator We implemented a message-based discrete-event simulator <ref> [2, 3] </ref>. In this class of simulators, physical processes are realized with logical processes and the interaction among physical processes is modeled with the exchange of messages between the corresponding logical processes 1 . A logical process is defined simply by an object in the host programming language.
Reference: [3] <author> R. L. Bargodia and W.-T. Liao. Maise: </author> <title> A language for the design of efficient discrete-event simulation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(4), </volume> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: In particular, as pointed out by Paxson in [61], the idea of shifting the focus from a packet-level simulation to a simulation of an application-level model seems to be a very promising and motivates even more the approach we take in SIENA. 5.1 Simulator We implemented a message-based discrete-event simulator <ref> [2, 3] </ref>. In this class of simulators, physical processes are realized with logical processes and the interaction among physical processes is modeled with the exchange of messages between the corresponding logical processes 1 . A logical process is defined simply by an object in the host programming language.
Reference: [4] <author> N. S. Bargouti and B. Krishnamurthy. </author> <title> Using Event Contexts and Matching Constraints to Monitor Spftware Processes Effectively. </title> <booktitle> In Proceedings of the 17th International Conference on Software Engineering, </booktitle> <address> Seattle WA, U.S.A., </address> <month> May </month> <year> 1995. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: These systems realize their functionality by performing some actions in response to events, possibly using the information associated with the stimulating events. Examples of reactive systems are integrated development environments [64, 38, 11, 33], work-flow and process analysis systems <ref> [16, 4] </ref>, graphical user interfaces [59], network management systems [65], software deployment systems [32] and security monitors [36, 56, 75]. There are two major motivations for designing applications as reactive systems. First, some applications are reactive by their nature.
Reference: [5] <author> T. Barners-Lee. </author> <title> Universal Resource Identifiers in WWW, A Unifying Syntax for the Expression of Names and Addresses of Objects on the Network as used in the World-Wide Web. Internet Requests For Comments (RFC) 1630, </title> <month> June </month> <year> 1994. </year>
Reference-contexts: In general, an object has exactly one identifier and one or more handlers. Also, while the identifier remains bound to an object, handlers may change during the existence of the object. SIENA adopts the generic URI <ref> [5] </ref> form for both its naming and handling scheme. Also in SIENA, every object has exactly one URI that serves the functions of identifier and handler (X j X h ).
Reference: [6] <author> D. Barrett, L. Clarke, P. Tarr, and A. Wise. </author> <title> A Framework for Event-Based Software Integration. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5(4):378421, </volume> <month> Oct. </month> <year> 1996. </year>
Reference: [7] <author> R. Bellman. </author> <title> Dynamic Programming. </title> <publisher> Princeton University Press, Princeton, </publisher> <year> 1957. </year>
Reference-contexts: To compute this map, the current implementation of generic peer-to-peer SIENA servers uses a simplified version of the distance-vector algorithm (also known as Ford-Fulkerson or Bellmann-Ford algorithm <ref> [29, 7] </ref>). The server maintains a table T R that associates a source server s to a peer server nexthop (s) and a distance distance (s).
Reference: [8] <author> D. Bertsekas and R. Gallager. </author> <title> Data Networks. </title> <address> PrenticeHall, Englewood Cliffs, New Jersey, </address> <year> 1987. </year>
Reference-contexts: What we need to solve here coincides with the well known problem of routing in a datagram network (see <ref> [8] </ref>). In SIENA, we use the classic reverse path forwarding technique [20].
Reference: [9] <author> O. Burkart. </author> <title> Automatic verification of sequential infinite-state processes, </title> <booktitle> volume 1354 of Lecture Notes in Computer Science. </booktitle> <address> SpringerVerlag, New York, </address> <year> 1997. </year> <title> 96 Conclusions and Future Work </title>
Reference-contexts: Unfortunately, while model checking techniques for finite state systems are well-established and several automatic tools are available, the case of infinite states is still a research subject and only a few results are available in some restricted cases <ref> [9, 10] </ref>. The approach we followed for SIENA is based on a simulation environment. In the initial development phase, we used this simulation environment to verify and validate the algorithms.
Reference: [10] <author> O. Burkart and B. Steffen. </author> <title> Model Checking the Full Modal Mu-Calculus for Infinite Sequential Processes. </title> <editor> In P. Degano, R. Gorrieri, and A. Marchetti-Spaccamela, editors, </editor> <booktitle> Automata, Languages and Programming, Proceedings of 24 th International Colloquium ICALP '97, number 1256 in Lecture Notes in Computer Science, </booktitle> <pages> pages 419429, </pages> <address> Bologna, Italy, July 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Unfortunately, while model checking techniques for finite state systems are well-established and several automatic tools are available, the case of infinite states is still a research subject and only a few results are available in some restricted cases <ref> [9, 10] </ref>. The approach we followed for SIENA is based on a simulation environment. In the initial development phase, we used this simulation environment to verify and validate the algorithms.
Reference: [11] <author> M. R. Cagan. </author> <title> The HP SoftBench environment: an architecture for a new generation of software tools. </title> <journal> Hewlett-Packard Journal: technical information from the laboratories of Hewlett-Packard Company, </journal> <volume> 41(3):3647, </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: These systems realize their functionality by performing some actions in response to events, possibly using the information associated with the stimulating events. Examples of reactive systems are integrated development environments <ref> [64, 38, 11, 33] </ref>, work-flow and process analysis systems [16, 4], graphical user interfaces [59], network management systems [65], software deployment systems [32] and security monitors [36, 56, 75]. There are two major motivations for designing applications as reactive systems. First, some applications are reactive by their nature. <p> Nonetheless, these systems provide valuable insights as far as the type of service that they offer. Message-based integrated environments The idea of integrating different components by means of messages is first realized by Field [64]. Field, together with other commercial products including 8 Background and New Challenges HP SoftBench <ref> [11] </ref>, DEC FUSE [33], and Sun ToolTalk [38], implements an environment in which several software development tools can cooperate by exchanging messages.
Reference: [12] <author> A. Carzaniga, E. Di Nitto, D. S. Rosenblum, and A. L. Wolf. </author> <title> Issues in Supporting Event-based Architectural Styles. </title> <booktitle> In 3 rd International Software Architecture Workshop, </booktitle> <address> Orlando FL, U.S.A., </address> <month> Nov. </month> <year> 1998. </year>
Reference-contexts: The main shortcoming of all of these technologies is that they are specific to some application domain and not flexible enough to be usable as a generic and open infrastructure for integrating event-based applications (see <ref> [66, 12] </ref>). In summary, we see two main challenges in the area of event-based infrastructures, that SIENA proposes to address: * scalability: this is the ability to provide an event service across a whole wide-area network.
Reference: [13] <author> S. Ceri and J. Widom. </author> <title> Active Database Systems: Triggers and Rules for Advanced Database Processing. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, </address> <year> 1996. </year>
Reference-contexts: Examples of attributes are modification Related technology 9 time and permissions for files and directories, load and number of users for hosts, login time for users, etc. A different class of systems that are conceptually equivalent to event-action systems are active databases <ref> [13] </ref>. In active databases, primitive events are operations on database objects. Event-action rules are also called triggers. Events can be combined and correlated in the left part of the trigger. A trigger can also impose additional conditions (or guard) to be evaluated once the requested sequence of events has occurred.
Reference: [14] <author> D. Clark. </author> <title> Policy Routing in Internet Protocols. Internet Requests For Comments (RFC) 1102, </title> <month> May </month> <year> 1989. </year>
Reference-contexts: This assumption significantly reduces the variable space thus simplifying the set of scenarios that we will cover, and it is also very reasonable since it reflects the structure of domains that characterizes the Internet <ref> [14] </ref>. The scenarios we are simulating at this time include only homogeneous event service topologies.
Reference: [15] <author> D. Clark and e. a. Joseph Pasquale. </author> <title> Strategic Directions in Networks and Telecommunications. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(4):679690, </volume> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: In accordance to many standardization efforts that have been proposed recently (e.g., [58]), and according to strategic plans and research in network technology <ref> [15] </ref>, we envision a unified event service implemented as a common middle-ware to support the event-based interaction among software components.
Reference: [16] <author> J. E. Cook and A. L. Wolf. </author> <title> Discovering Models of Software Processes from Event-Based Data. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 7(3):191230, </volume> <month> July </month> <year> 1998. </year>
Reference-contexts: These systems realize their functionality by performing some actions in response to events, possibly using the information associated with the stimulating events. Examples of reactive systems are integrated development environments [64, 38, 11, 33], work-flow and process analysis systems <ref> [16, 4] </ref>, graphical user interfaces [59], network management systems [65], software deployment systems [32] and security monitors [36, 56, 75]. There are two major motivations for designing applications as reactive systems. First, some applications are reactive by their nature.
Reference: [17] <author> D. H. Crocker. </author> <title> Standard for the Format of ARPA Internet Text Messages. Internet Requests For Comments (RFC) 822, </title> <month> Aug. </month> <year> 1982. </year> <note> STD 11. </note>
Reference-contexts: It poses less problems of encoding Comments on the semantics of the event service 43 data and it is also the most open one because it requires a simpler common representation (e.g., the standard for Internet electronic mail messages <ref> [17] </ref> could be used), that is therefore more portable on heterogeneous platforms. Optimizations would well be possible given the semantics of the operators that the event service defines.
Reference: [18] <author> G. Cugola, E. Di Nitto, and A. Fuggetta. </author> <title> Exploiting an Event-based Infrastructure to Develop Complex Distributed Systems. </title> <booktitle> In Proceedings of the 20th International Conference on Software Engineering (ICSE 98), </booktitle> <address> Kyoto, Japan, </address> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: Among them we find JEDI <ref> [18] </ref>, Elvin [68], TIBCO's TIB/Rendezvous TM [73], Keryx [81, 40], and iBus [69]. To our knowledge, except perhaps for TIB/Rendezvous, no one of these systems has been actually deployed and used on a significant number of sites across the boundaries of a local-area network. <p> This implies that a subscription might define a set of event notifications, and two subscriptions might specify two overlapping sets of notifications. This in turn means that one event may match any number of subscriptions. JEDI <ref> [18] </ref> and TIB/Rendezvous [74], as well as the USENET News system, adopt a subject-based subscription mechanism. In both TIB/Rendezvous and JEDI, the subject is a list of strings 2 over which it is possible to specify filters based on a limited form of regular expressions.
Reference: [19] <author> G. Cugola, E. Di Nitto, and A. Fuggetta. </author> <title> The JEDI event-based infrastructure and its application to the development of the OPSS WFMS. </title> <type> Technical report, </type> <institution> CEFRIEL, Milano, Italy, </institution> <month> Sept. </month> <year> 1998. </year>
Reference-contexts: In other words, we classify the expressiveness of the event service by the expressiveness of its subscriptions that in turn depends on the structure of notifications. This criterion follows the classification framework defined in <ref> [19] </ref>. Frameworks for distributed event-based interaction There is a class of infrastructures that we discuss here that do not realize an event service, although they are publicized as such. <p> This approach has been adopted by JEDI <ref> [19] </ref> that exports the functions shown in Table 3.4 4 : move out (URI orig) move in (URI orig, URI final) Table 3.4: Mobility support functions. With move out, an object declares that it intends to move from its original identity/location orig.
Reference: [20] <author> Y. K. Dalal and R. M. Metcalfe. </author> <title> Reverse path forwarding of broadcast packets. </title> <journal> Communications of the ACM, </journal> <volume> 21(12):10401048, </volume> <month> Dec. </month> <year> 1978. </year>
Reference-contexts: The realization of this process depends upon the underlying topology of servers. Clearly the solution is trivial in the case of acyclic topologies (i.e., hierarchical and acyclic peer-to-peer), but it requires additional data structures and protocols for the generic graph topology <ref> [20] </ref>. <p> What we need to solve here coincides with the well known problem of routing in a datagram network (see [8]). In SIENA, we use the classic reverse path forwarding technique <ref> [20] </ref>.
Reference: [21] <author> S. E. Deering. </author> <title> Host Extensions for IP Multicasting. Internet Requests For Comments (RFC) 1584, </title> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: The IP multicast infrastructure realizes routing to multiple destinations on the Internet. The model established by Deering [22] extends IP addresses with group addresses. These are particular IP numbers that correspond to host groups <ref> [21] </ref>. A host group addresses a set of hosts, possibly sparse over different subnets.
Reference: [22] <author> S. E. Deering. </author> <title> Multicast Routing in a Datagram Internetwork. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> Dec. </month> <year> 1991. </year> <month> 97 </month>
Reference-contexts: The limited expressiveness of the USENET news system may results in unnecessary transfers of entire groups of messages. The service is scalable but still quite heavyweight, in fact the time frame of news propagation ranges from hours to days. IP Multicast IP multicast <ref> [22] </ref> is a network-level infrastructure that extends the Internet protocol in order to realize an efficient one-to-many communication service. IP multicast is an extension to the usual unicast routing mechanism realized over the Internet. The network that realizes this extension is also referred to as MBone. <p> The IP multicast infrastructure realizes routing to multiple destinations on the Internet. The model established by Deering <ref> [22] </ref> extends IP addresses with group addresses. These are particular IP numbers that correspond to host groups [21]. A host group addresses a set of hosts, possibly sparse over different subnets.
Reference: [23] <author> S. E. Deering and D. R. Cheriton. </author> <title> Multicast Routing in Datagram Networks and Extended LANS. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(2):85111, </volume> <month> May </month> <year> 1990. </year>
Reference-contexts: Since any number of hosts can join a host group, datagrams addressed to that group must be dispatched to different points on the network. This is realized with special multicast routing protocol. Several of these protocols have been proposed with different degrees of scalability <ref> [23, 24, 55, 77] </ref>. These protocols use the membership information set up by IGMP.
Reference: [24] <author> S. E. Deering, D. Estrin, D. Farinacci, V. Jacobson, C. Liu, and L. Wei. </author> <title> The PIM Architecture for Wide-Area Multicast Routing. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 4(2):153162, </volume> <month> Apr. </month> <year> 1996. </year>
Reference-contexts: Since any number of hosts can join a host group, datagrams addressed to that group must be dispatched to different points on the network. This is realized with special multicast routing protocol. Several of these protocols have been proposed with different degrees of scalability <ref> [23, 24, 55, 77] </ref>. These protocols use the membership information set up by IGMP.
Reference: [25] <author> M. B. Doar. </author> <title> A Better Model for Generating Test Networks. </title> <booktitle> In Proceedings of Globecom '96, </booktitle> <month> Nov. </month> <year> 1996. </year>
Reference-contexts: To compile realistic network topologies that approximate the behavior of real wide-area networks, we used a generator of random network graphs that implements the Transit-Stub model [82] (other models for random network graphs are Waxman's non-hierarchical graphs [78], and Tiers <ref> [25] </ref>. A discussion on these models can be found in [83]). Although we experimented networks of 500 up to 1000 nodes, the bulk of simulations we present here were performed on a graph of 100 nodes.
Reference: [26] <author> J. Farley. </author> <title> Java Distributed Computing. The Java Series. </title> <publisher> O'Reilly & Associates Inc., </publisher> <year> 1997. </year>
Reference-contexts: The listener interface defines a method called notify that will be called by the event generator whenever an event occurs. This framework of classes allows a distributed interaction because both event generators and event listeners are remote objects and their interaction is handled by means of RMI calls <ref> [70, 26] </ref>. The notification model adopted by the Java Distributed Event Specification is very versatile. In fact notifications are Java objects implementing the Remo-teEvent. The filtering capability is instead rather limited. Event notifications have an event id of type long.
Reference: [27] <author> W. Fenner. </author> <title> Internet Group Management Protocol, Version 2. Internet Requests For Comments (RFC) 2236, </title> <month> Nov. </month> <year> 1997. </year>
Reference-contexts: IP datagrams that are addressed to a host group are routed to every host that belongs to the group. Hosts can join or leave a group at any time 12 Background and New Challenges using a special group membership protocol <ref> [27] </ref>. IP multicast per se is at the same level as IP, thus it is a connectionless best-effort (unreliable) service. A reliable transport layer can be implemented on top of IP multicast [47, 79].
Reference: [28] <author> C. Fidge. </author> <title> Fundamentals of distributed system observation. </title> <journal> IEEE Software, </journal> <volume> 13(6):7784, </volume> <month> Nov. </month> <year> 1996. </year>
Reference-contexts: In SIENA we assume that the event service is able to examine events in the right time order. Ordering events with respect to time is a classical problem in distributed systems [45] for which there exist well known algorithms (see <ref> [28, 63] </ref>). In practice, this assumption requires that the event service buffer notifications and shuffle them in the correct temporal sequence within a finite time.
Reference: [29] <author> L. R. Ford and D. R. Fulkerson. </author> <title> Flows in Networks. </title> <publisher> Princeton University Press, Princeton, </publisher> <year> 1963. </year>
Reference-contexts: To compute this map, the current implementation of generic peer-to-peer SIENA servers uses a simplified version of the distance-vector algorithm (also known as Ford-Fulkerson or Bellmann-Ford algorithm <ref> [29, 7] </ref>). The server maintains a table T R that associates a source server s to a peer server nexthop (s) and a distance distance (s).
Reference: [30] <author> A. Fuggetta, G. P. Picco, and G. Vigna. </author> <title> Undestanding code mobility. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 24(5):342361, </volume> <month> May </month> <year> 1998. </year>
Reference-contexts: Recently, research in code mobility has produced a number of languages and systems that make the network a complete computation infrastructure in which components can move from one site to the other even during their execution <ref> [30] </ref>. It is desirable that an event service support the integration of such mobile objects as well as the conventional steady objects. The fact that an object can move affects the event service because that object might change its location while maintaining its identity.
Reference: [31] <institution> Georgia Institute of Technology. College of Computing. Georgia Tech Internet Topology Models (GT-ITM). </institution> <note> http://www.cc.gatech.edu/projects/gtitm. </note>
Reference-contexts: using the Stanford GraphBase format [42] which we then translate into AT&T's dot format [43] for the subsequent processing. defines the architecture to be used in this scenario while the objects and 2 We used the Georgia Tech Internet Topology Models (GT-ITM), a publicly available package for generating random graphs <ref> [31] </ref> 3 Actually, in order to automate the simulation process, we used a description file parametrized with CPP macros Simulation Results 81 meta-params topology random simulation trace import into database message table per-scenario statistics topology generator scenario generator bare topology per-scenario statistics import into database first stage queries view queries data
Reference: [32] <author> R. S. Hall, D. Heimbigner, A. van der Hoek, and A. L. Wolf. </author> <title> An Architecture for Post-Development Configuration Management in a Wide-Area Network. </title> <booktitle> In Proceedings of the 17 th International Conference on Distributed Computing Systems, </booktitle> <address> Baltimore MD, U.S.A., </address> <month> May </month> <year> 1997. </year>
Reference-contexts: Examples of reactive systems are integrated development environments [64, 38, 11, 33], work-flow and process analysis systems [16, 4], graphical user interfaces [59], network management systems [65], software deployment systems <ref> [32] </ref> and security monitors [36, 56, 75]. There are two major motivations for designing applications as reactive systems. First, some applications are reactive by their nature. Typically, the ones that involve the direct interaction of human agents are characterized by an asynchronous input of relatively small pieces of data. <p> For example, work-flow systems can be federated for companies that have multiple distributed branches or even across corporate boundaries, or else software deployment systems can connect software producers and consumers through the Internet <ref> [32] </ref>.
Reference: [33] <author> R. O. Hart and G. Lupton. </author> <month> DEC FUSE: </month> <title> Building a graphical software development environment from UNIX tools. </title> <institution> Digital Technical Journal of Digital Equipment Corporation, 7(2):519, </institution> <month> Spring </month> <year> 1995. </year>
Reference-contexts: These systems realize their functionality by performing some actions in response to events, possibly using the information associated with the stimulating events. Examples of reactive systems are integrated development environments <ref> [64, 38, 11, 33] </ref>, work-flow and process analysis systems [16, 4], graphical user interfaces [59], network management systems [65], software deployment systems [32] and security monitors [36, 56, 75]. There are two major motivations for designing applications as reactive systems. First, some applications are reactive by their nature. <p> Message-based integrated environments The idea of integrating different components by means of messages is first realized by Field [64]. Field, together with other commercial products including 8 Background and New Challenges HP SoftBench [11], DEC FUSE <ref> [33] </ref>, and Sun ToolTalk [38], implements an environment in which several software development tools can cooperate by exchanging messages.
Reference: [34] <author> C. Hedrick. </author> <title> Routing Information Protocol. Internet Requests For Comments (RFC) 1058, </title> <month> June </month> <year> 1988. </year>
Reference-contexts: Note that in SIENA the routing information is piggy-backed on normal service requests. A logically alternative approach is taken on the Internet where routing information is exchanged among routers by means of a special routing information protocol (RIP <ref> [34] </ref>). RIP uses the same class of distance-vector algorithms. 4.3 Pattern observation So far we have seen how simple subscriptions and simple notifications are handled by event servers. A major functionality introduced with SIENA is the distributed monitoring of patterns of notifications according to compound subscriptions.
Reference: [35] <author> P. Huang, D. Estrin, and J. Heidemann. </author> <title> Enabling Large-Scale Simulations: Selective Abstraction Approach to The Study of Multicast Protocols. </title> <booktitle> In Proceedings of the 6 th International Symposium on Modeling Analysis and Simulation of Computer and Telecommunications Systems (MASCOTS98), </booktitle> <pages> pages 241248, </pages> <address> Montreal, Canada, </address> <month> July </month> <year> 1998. </year> <title> 98 Conclusions and Future Work </title>
Reference-contexts: Specifically, the simulator implements the network model that considers only the end-to-end characteristics of a link hiding the underlying packet switched network. This abstraction greatly simplifies the simulation without introducing a significant distortion in the global results <ref> [35] </ref>. The SIENA simulator is written in C++ and most of its data structures are realized by means of the Standard Template Library (STL) [57]. Processes are objects of a sub-class of a process class that defines three virtual methods: initialize, process, and terminate.
Reference: [36] <author> K. Ilgun, R. Kemmerer, and P. Porras. </author> <title> State Transition Analysis: A Rule-Based Intrusion Detection System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(3), </volume> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: Examples of reactive systems are integrated development environments [64, 38, 11, 33], work-flow and process analysis systems [16, 4], graphical user interfaces [59], network management systems [65], software deployment systems [32] and security monitors <ref> [36, 56, 75] </ref>. There are two major motivations for designing applications as reactive systems. First, some applications are reactive by their nature. Typically, the ones that involve the direct interaction of human agents are characterized by an asynchronous input of relatively small pieces of data.
Reference: [37] <author> D. B. Johnson and C. Perkins. </author> <title> Mobility Support in IPv6. </title> <type> Internet Draft, </type> <month> Nov. </month> <year> 1997. </year> <title> Mobile IP Working Group. </title>
Reference-contexts: There are at least three different approaches to support mobility: transparent this is the case of objects addressed by URIs that hide their location and their mobility. Such URIs use network-level mechanisms to transparently manage mobility or intermittent connectivity of objects (see <ref> [62, 37] </ref>). In this case, the objects is treated exactly like every other steady object. native here the event service uses only steady URIs that also contain information about their location (examples are the mailto and http sche-mas), but it implements internal mobility mechanisms possibly exported through new interface functions.
Reference: [38] <author> A. M. Julienne and B. Holtz. </author> <title> ToolTalk and open protocols, inter-application communication. </title> <address> PrenticeHall, Englewood Cliffs, New Jersey, </address> <year> 1994. </year>
Reference-contexts: These systems realize their functionality by performing some actions in response to events, possibly using the information associated with the stimulating events. Examples of reactive systems are integrated development environments <ref> [64, 38, 11, 33] </ref>, work-flow and process analysis systems [16, 4], graphical user interfaces [59], network management systems [65], software deployment systems [32] and security monitors [36, 56, 75]. There are two major motivations for designing applications as reactive systems. First, some applications are reactive by their nature. <p> Numerous technologies that realize an event service have been developed and effectively used for quite a long time, examples are Field [64], SUN ToolTalk <ref> [38] </ref>, and Yeast [44]. However, most of them are targeted towards single computers or at most local-area networks, and it is very clear that they can not be simply adapted to scale to the Internet. <p> Message-based integrated environments The idea of integrating different components by means of messages is first realized by Field [64]. Field, together with other commercial products including 8 Background and New Challenges HP SoftBench [11], DEC FUSE [33], and Sun ToolTalk <ref> [38] </ref>, implements an environment in which several software development tools can cooperate by exchanging messages.
Reference: [39] <author> B. Kantor and P. Lapsley. </author> <title> Network News Transfer Protocol A Proposed Standard for the Stream-Based Transmission of News. Internet Requests For Comments (RFC) 977, </title> <month> Feb. </month> <year> 1986. </year>
Reference-contexts: In general, this is not true for the information exchanged in event notification services. USENET News The USENET News system with its main protocol NNTP <ref> [39] </ref> is perhaps the best example of a scalable user-level many-to-many communication facility. Related technology 11 USENET News messages are modeled after e-mail messages, yet they provide additional information (headers) that can be used by NNTP commands to direct their distribution.
Reference: [40] <author> Keryx WEB page. </author> <note> http://keryxsoft.hpl.hp.com, 1997. </note>
Reference-contexts: Among them we find JEDI [18], Elvin [68], TIBCO's TIB/Rendezvous TM [73], Keryx <ref> [81, 40] </ref>, and iBus [69]. To our knowledge, except perhaps for TIB/Rendezvous, no one of these systems has been actually deployed and used on a significant number of sites across the boundaries of a local-area network.
Reference: [41] <institution> Kerysoft, Hewlett Packard. </institution> <note> Keryx Version 1.0a Release Notes and Documentation, 1997. http://keryxsoft.hpl.hp.com/keryx-1.0a/html/index.html. </note>
Reference-contexts: Examples of systems that provide this kind of subscription language are, Yeast [44], GEM [49] (these two are not distributed though), Elvin [68], Keryx <ref> [41] </ref> and SIENA itself. 2.2 New challenges for Event-based technologies 2.2.1 Discussion and principles From the survey of systems that we have gone through, we can distill a set of fundamental principles and a set of features that we believe are essential in understanding problems and solutions in the context of
Reference: [42] <author> D. Knuth. </author> <title> The Stanford GraphBase: A Platform for Combinatorial Computing. </title> <address> AddisonWesley, Reading, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: The two staring points are the topology meta-parameters and the scenario parameters. The topology meta-parameters are the input parameters for the topology generator 2 . These parameters are specific of the generation method (see [83] for details). The topology generator tool produces a graph using the Stanford GraphBase format <ref> [42] </ref> which we then translate into AT&T's dot format [43] for the subsequent processing. defines the architecture to be used in this scenario while the objects and 2 We used the Georgia Tech Internet Topology Models (GT-ITM), a publicly available package for generating random graphs [31] 3 Actually, in order to
Reference: [43] <author> E. Koutsofios and S. C. </author> <title> North. Drawing Graphs with dot. </title> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill NJ, U.S.A., </address> <month> October </month> <year> 1993. </year>
Reference-contexts: The topology meta-parameters are the input parameters for the topology generator 2 . These parameters are specific of the generation method (see [83] for details). The topology generator tool produces a graph using the Stanford GraphBase format [42] which we then translate into AT&T's dot format <ref> [43] </ref> for the subsequent processing. defines the architecture to be used in this scenario while the objects and 2 We used the Georgia Tech Internet Topology Models (GT-ITM), a publicly available package for generating random graphs [31] 3 Actually, in order to automate the simulation process, we used a description file
Reference: [44] <author> B. Krishnamurthy and D. S. Rosenblum. Yeast: </author> <title> A General Purpose Event-Action System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(10):845857, </volume> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: Numerous technologies that realize an event service have been developed and effectively used for quite a long time, examples are Field [64], SUN ToolTalk [38], and Yeast <ref> [44] </ref>. However, most of them are targeted towards single computers or at most local-area networks, and it is very clear that they can not be simply adapted to scale to the Internet. In fact, extending the support of an event service to a wide-area network creates new challenges and tradeoffs. <p> However, domain of event notifications and subscriptions is usually very limited. Tools can generate a fixed set of messages and in some cases (e.g., in DEC FUSE), this set of messages is statically mapped into a set of call-back procedures that are hardwired within the tool. Event-action systems Yeast <ref> [44] </ref> is an event-action system. Yeast allows the definitions of rules (or specifications) that have the general form (event-pattern do action). Unlike message-based integrated environments, Yeast is very similar to a general-purpose event service. <p> Moreover, if the notification model adopts a type system, exposing the structure of notifications makes their type system visible too, thus, allowing more expressive and readable filters as well as enabling some consistency checking. Examples of systems that provide this kind of subscription language are, Yeast <ref> [44] </ref>, GEM [49] (these two are not distributed though), Elvin [68], Keryx [41] and SIENA itself. 2.2 New challenges for Event-based technologies 2.2.1 Discussion and principles From the survey of systems that we have gone through, we can distill a set of fundamental principles and a set of features that we
Reference: [45] <author> L. Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7):558565, </volume> <month> July </month> <year> 1978. </year>
Reference-contexts: In SIENA we assume that the event service is able to examine events in the right time order. Ordering events with respect to time is a classical problem in distributed systems <ref> [45] </ref> for which there exist well known algorithms (see [28, 63]). In practice, this assumption requires that the event service buffer notifications and shuffle them in the correct temporal sequence within a finite time.
Reference: [46] <author> J. Levine. </author> <title> An Algorithm to Synchronize the Time of a Computer to Universal Time. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 3(1):4250, </volume> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: interest notif 1 notif 1 notif 2 notif 2 sub 1. the existence of a global clock used to time-stamp notifications, 2. an upper bound for the network latency and the network diameter, and 3. sufficiently big communication buffers The availability of high-resolution GPS services and extremely accurate synchronization protocols <ref> [46] </ref> together with the Internet Network Time Protocol [51, 50] make the first assumption very reasonable for most practical applications. Instead, the latter requirements can pose serious engineering tradeoffs.
Reference: [47] <author> J. C. Lin and S. Paul. RMTP: </author> <title> A Reliable Multicast Transport Protocol. </title> <booktitle> In Proceedings of the IEEE INFOCOM '96, </booktitle> <pages> pages 14141424, </pages> <address> San Framcisco CA, U.S.A., </address> <month> Apr. </month> <year> 1996. </year>
Reference-contexts: IP multicast per se is at the same level as IP, thus it is a connectionless best-effort (unreliable) service. A reliable transport layer can be implemented on top of IP multicast <ref> [47, 79] </ref>. We consider the IP multicast infrastructure and its routing algorithms to be the most important technology related to the SIENA event service.
Reference: [48] <author> S. Maffeis. iBus: </author> <title> The Java Intranet Software Bus. </title> <type> Technical report, </type> <institution> Soft-Wired AG, </institution> <address> Zurich, Switzerland, </address> <month> Feb. </month> <year> 1997. </year>
Reference-contexts: Channel-based event services are functionally identical to a reliable multicast with a one-to-one mapping between channels and multicast addresses, in fact iBus, a channel-based event service, uses a transport mechanism based on IP multicast <ref> [48] </ref> (in which the mapping is the identity function). There is no interplay between two different channels and in most of the system, it is not clear how channels can be publicized. In addition to iBus, the CORBA Event Service [58] adopts a channel based architecture.
Reference: [49] <author> M. Mansouri-Samani and M. Sloman. </author> <title> GEM A Generalized Event Monitoring Language for Distributed Systems. </title> <journal> IEE/IOP/BCS Distributed Systems Engineering Journal, </journal> <volume> 4(2):96108, </volume> <month> June </month> <year> 1997. </year>
Reference-contexts: Moreover, if the notification model adopts a type system, exposing the structure of notifications makes their type system visible too, thus, allowing more expressive and readable filters as well as enabling some consistency checking. Examples of systems that provide this kind of subscription language are, Yeast [44], GEM <ref> [49] </ref> (these two are not distributed though), Elvin [68], Keryx [41] and SIENA itself. 2.2 New challenges for Event-based technologies 2.2.1 Discussion and principles From the survey of systems that we have gone through, we can distill a set of fundamental principles and a set of features that we believe are <p> For example, in GEM <ref> [49] </ref> An event is a happening of interest, which occurs instantaneously at a specific time. Another definition given by [67] characterizes an event as the instantaneous effect of the (normal or abnormal) termination of an invocation of an operation on an object.
Reference: [50] <author> D. L. Mills. </author> <title> Network Time Protocol (Version 3) Specification, Implementation and Analysis. Internet Requests For Comments (RFC) 1305, </title> <month> Mar. </month> <year> 1992. </year> <month> 99 </month>
Reference-contexts: 2 sub 1. the existence of a global clock used to time-stamp notifications, 2. an upper bound for the network latency and the network diameter, and 3. sufficiently big communication buffers The availability of high-resolution GPS services and extremely accurate synchronization protocols [46] together with the Internet Network Time Protocol <ref> [51, 50] </ref> make the first assumption very reasonable for most practical applications. Instead, the latter requirements can pose serious engineering tradeoffs.
Reference: [51] <author> D. L. Mills. </author> <title> Improved Algorithms for Synchronizing Computer Network Clocks. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 3(3):245254, </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: 2 sub 1. the existence of a global clock used to time-stamp notifications, 2. an upper bound for the network latency and the network diameter, and 3. sufficiently big communication buffers The availability of high-resolution GPS services and extremely accurate synchronization protocols [46] together with the Internet Network Time Protocol <ref> [51, 50] </ref> make the first assumption very reasonable for most practical applications. Instead, the latter requirements can pose serious engineering tradeoffs.
Reference: [52] <author> J. Misra. </author> <title> Distributed Discrete-Event Simulation. </title> <journal> ACM Computing Surveys, </journal> <volume> 18(1):3965, </volume> <month> Mar. </month> <year> 1986. </year>
Reference-contexts: Instead, the term has the semantics defined in discrete-event simulation literature (for a survey on this topic, see <ref> [52] </ref>).
Reference: [53] <author> P. Mockapetris. </author> <title> Domain Names Concepts And Facilities. Internet Requests For Comments (RFC) 1034, </title> <month> Nov. </month> <year> 1987. </year>
Reference-contexts: Thus, even if none of them is really designed to realize an event notification service, it might be worthwhile to borrow their ideas vis-a-vis scalability. Domain Name Service Domain Name Service (DNS <ref> [54, 53] </ref>) maps symbolic host or domain names into IP addresses. The current implementation of DNS has proved to be extremely scalable especially considering the recent explosion of domains caused by the commercial exploitation of the Internet. DNS is realized with a distributed architecture.
Reference: [54] <author> P. Mockapetris. </author> <title> Domain Names Implementation And Specification. Internet Requests For Comments (RFC) 1035, </title> <month> Nov. </month> <year> 1987. </year>
Reference-contexts: Thus, even if none of them is really designed to realize an event notification service, it might be worthwhile to borrow their ideas vis-a-vis scalability. Domain Name Service Domain Name Service (DNS <ref> [54, 53] </ref>) maps symbolic host or domain names into IP addresses. The current implementation of DNS has proved to be extremely scalable especially considering the recent explosion of domains caused by the commercial exploitation of the Internet. DNS is realized with a distributed architecture.
Reference: [55] <author> J. Moy. </author> <title> Multicast Extensions to OSPF. Internet Requests For Comments (RFC) 1075, </title> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: Since any number of hosts can join a host group, datagrams addressed to that group must be dispatched to different points on the network. This is realized with special multicast routing protocol. Several of these protocols have been proposed with different degrees of scalability <ref> [23, 24, 55, 77] </ref>. These protocols use the membership information set up by IGMP.
Reference: [56] <author> B. Mukherjee, L. Heberlein, and K. Levitt. </author> <title> Network Intrusion Detection. </title> <journal> IEEE Network, </journal> <pages> pages 2641, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Examples of reactive systems are integrated development environments [64, 38, 11, 33], work-flow and process analysis systems [16, 4], graphical user interfaces [59], network management systems [65], software deployment systems [32] and security monitors <ref> [36, 56, 75] </ref>. There are two major motivations for designing applications as reactive systems. First, some applications are reactive by their nature. Typically, the ones that involve the direct interaction of human agents are characterized by an asynchronous input of relatively small pieces of data.
Reference: [57] <author> D. R. Musser and A. Saini. </author> <title> STL tutorial and Reference Guide. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1996. </year>
Reference-contexts: This abstraction greatly simplifies the simulation without introducing a significant distortion in the global results [35]. The SIENA simulator is written in C++ and most of its data structures are realized by means of the Standard Template Library (STL) <ref> [57] </ref>. Processes are objects of a sub-class of a process class that defines three virtual methods: initialize, process, and terminate. Every process objects has a reference to the site on which it executes. A clock variable holds the current time of the physical system.
Reference: [58] <institution> Object Management Group. </institution> <month> CORBAservices: </month> <title> Common Object Service Specification. </title> <type> Technical report, </type> <institution> Object Management Group, </institution> <month> July </month> <year> 1998. </year>
Reference-contexts: In accordance to many standardization efforts that have been proposed recently (e.g., <ref> [58] </ref>), and according to strategic plans and research in network technology [15], we envision a unified event service implemented as a common middle-ware to support the event-based interaction among software components. <p> There is no interplay between two different channels and in most of the system, it is not clear how channels can be publicized. In addition to iBus, the CORBA Event Service <ref> [58] </ref> adopts a channel based architecture. Subject-based subscription Some systems extend the concept of channel with a more flexible addressing mechanism that is often referred to as subject-based addressing. In this case, event notifications contain a well-known attribute the subject that determines their address.
Reference: [59] <editor> OSF, editor. </editor> <title> OSF/Motif Programmers Guide. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, 5 edition, </address> <year> 1991. </year>
Reference-contexts: These systems realize their functionality by performing some actions in response to events, possibly using the information associated with the stimulating events. Examples of reactive systems are integrated development environments [64, 38, 11, 33], work-flow and process analysis systems [16, 4], graphical user interfaces <ref> [59] </ref>, network management systems [65], software deployment systems [32] and security monitors [36, 56, 75]. There are two major motivations for designing applications as reactive systems. First, some applications are reactive by their nature.
Reference: [60] <author> V. Paxson. </author> <title> End-to-End Routing Behavior in the Internet. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 5(5):601615, </volume> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: Latency is measured in time units, bandwidth 1 is measured in time units per bit, and cost is measured in money units. Links are assumed symmetrical, i.e, latency (s 1 ; s 2 ) = latency (s 2 ; s 1 ). An analysis performed by Paxson <ref> [60] </ref> shows that although the end-to-end behavior of the Internet has become less predictable, anomalies are still at an acceptable level and, what is particularly important for our assumptions, the majority of routing paths is stable for long periods of time and the reliability of the measure increases significantly when we
Reference: [61] <author> V. Paxson. </author> <title> Why We Don't Know How to Simulate the Internet. </title> <booktitle> In Proceedings of the 1997 Winter Simulation Conference, </booktitle> <address> Atlanta GA, U.S.A., </address> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: In general, it is good to design an event service that is independent of any particular protocol and thus can speak many different ones; * openness: wide area networks change continuously in an unpredictable way (see <ref> [61] </ref>), thus, the event service should be able to accommodate extensions and somehow evolve together with the network; 18 Background and New Challenges * de-centralized architecture and control: the Internet is characterized by many separate domains managed by different authorities. <p> The biggest difficulty becomes the choice of the right models that would allow us to simplify the simulation without loosing much in the way of accuracy. In particular, as pointed out by Paxson in <ref> [61] </ref>, the idea of shifting the focus from a packet-level simulation to a simulation of an application-level model seems to be a very promising and motivates even more the approach we take in SIENA. 5.1 Simulator We implemented a message-based discrete-event simulator [2, 3].
Reference: [62] <author> C. Perkins. </author> <title> IP Mobility Support. Internet Requests For Comments (RFC) 2002, </title> <month> October </month> <year> 1996. </year> <title> Standards Track. </title>
Reference-contexts: There are at least three different approaches to support mobility: transparent this is the case of objects addressed by URIs that hide their location and their mobility. Such URIs use network-level mechanisms to transparently manage mobility or intermittent connectivity of objects (see <ref> [62, 37] </ref>). In this case, the objects is treated exactly like every other steady object. native here the event service uses only steady URIs that also contain information about their location (examples are the mailto and http sche-mas), but it implements internal mobility mechanisms possibly exported through new interface functions.
Reference: [63] <author> M. Raynal, A. Schiper, and S. Toueg. </author> <title> The causal ordering abstraction and a simple way to implement it. </title> <journal> Information Processing Letters, </journal> <volume> 39(6):343350, </volume> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: In SIENA we assume that the event service is able to examine events in the right time order. Ordering events with respect to time is a classical problem in distributed systems [45] for which there exist well known algorithms (see <ref> [28, 63] </ref>). In practice, this assumption requires that the event service buffer notifications and shuffle them in the correct temporal sequence within a finite time.
Reference: [64] <author> S. Reiss. </author> <title> Connecting Tools Using Message Passing in the Field Environment. </title> <journal> IEEE Software, </journal> <pages> pages 5766, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: These systems realize their functionality by performing some actions in response to events, possibly using the information associated with the stimulating events. Examples of reactive systems are integrated development environments <ref> [64, 38, 11, 33] </ref>, work-flow and process analysis systems [16, 4], graphical user interfaces [59], network management systems [65], software deployment systems [32] and security monitors [36, 56, 75]. There are two major motivations for designing applications as reactive systems. First, some applications are reactive by their nature. <p> Numerous technologies that realize an event service have been developed and effectively used for quite a long time, examples are Field <ref> [64] </ref>, SUN ToolTalk [38], and Yeast [44]. However, most of them are targeted towards single computers or at most local-area networks, and it is very clear that they can not be simply adapted to scale to the Internet. <p> Nonetheless, these systems provide valuable insights as far as the type of service that they offer. Message-based integrated environments The idea of integrating different components by means of messages is first realized by Field <ref> [64] </ref>. Field, together with other commercial products including 8 Background and New Challenges HP SoftBench [11], DEC FUSE [33], and Sun ToolTalk [38], implements an environment in which several software development tools can cooperate by exchanging messages.
Reference: [65] <author> M. T. Rose. </author> <title> The Simple Book. </title> <address> PrenticeHall, Englewood Cliffs, New Jersey, </address> <year> 1991. </year> <title> 100 Conclusions and Future Work </title>
Reference-contexts: These systems realize their functionality by performing some actions in response to events, possibly using the information associated with the stimulating events. Examples of reactive systems are integrated development environments [64, 38, 11, 33], work-flow and process analysis systems [16, 4], graphical user interfaces [59], network management systems <ref> [65] </ref>, software deployment systems [32] and security monitors [36, 56, 75]. There are two major motivations for designing applications as reactive systems. First, some applications are reactive by their nature.
Reference: [66] <author> D. R. Rosenblum, A. L. Wolf, and A. Carzaniga. </author> <title> Critical Considerations and Designs for Internet-Scale, Event-Based Compositional Architectures. </title> <booktitle> In Workshop on Compositional Software Architectures, </booktitle> <address> Monterey CA, U.S.A., </address> <month> Jan. </month> <year> 1998. </year>
Reference-contexts: The main shortcoming of all of these technologies is that they are specific to some application domain and not flexible enough to be usable as a generic and open infrastructure for integrating event-based applications (see <ref> [66, 12] </ref>). In summary, we see two main challenges in the area of event-based infrastructures, that SIENA proposes to address: * scalability: this is the ability to provide an event service across a whole wide-area network.
Reference: [67] <author> D. S. Rosenblum and A. L. Wolf. </author> <title> A Design Framework for Internet-Scale Event Observation and Notification. </title> <booktitle> In Proceedings of the Sixth European Software Engineering Conference, </booktitle> <address> Zurich, Switzerland, Sept. 1997. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: The terms that we used here refer to the conceptual framework posed by Rosenblum and Wolf in <ref> [67] </ref>. Note that at this point we ignore most of the issues discussed in that framework, in fact we have not even mentioned what an event is or what it means to combine events. <p> Conceptual framework The first step in analyzing event services is to identify and model the entities that partake in the event-based interaction. A conceptual framework defines terms and roles for these entities. The models proposed in <ref> [67] </ref> offer the guidelines for this task. We will adopt some of these models and terms and we will develop a conceptual framework for SIENA in Section 3.1. <p> the interface functions exported by SIENA, and the semantics of SIENA, i.e., its behavior in response to various combination of calls to the interface functions. 3.1 Basic principles The terms used in this thesis, in particular the terms notification, object of interest, and interested party, follow the framework proposed in <ref> [67] </ref>. Since we are modeling software systems that are distributed over a computer network, we need some abstractions for software components, network nodes, communication, and in general we have to model the interaction between components. <p> For example, in GEM [49] An event is a happening of interest, which occurs instantaneously at a specific time. Another definition given by <ref> [67] </ref> characterizes an event as the instantaneous effect of the (normal or abnormal) termination of an invocation of an operation on an object.
Reference: [68] <author> B. Segall and D. Arnold. </author> <title> Elvin has left the building: A publish/subscribe notification service with quencing. </title> <booktitle> In Proceedings of AUUG97, </booktitle> <month> July </month> <year> 1998. </year>
Reference-contexts: Among them we find JEDI [18], Elvin <ref> [68] </ref>, TIBCO's TIB/Rendezvous TM [73], Keryx [81, 40], and iBus [69]. To our knowledge, except perhaps for TIB/Rendezvous, no one of these systems has been actually deployed and used on a significant number of sites across the boundaries of a local-area network. <p> Examples of systems that provide this kind of subscription language are, Yeast [44], GEM [49] (these two are not distributed though), Elvin <ref> [68] </ref>, Keryx [41] and SIENA itself. 2.2 New challenges for Event-based technologies 2.2.1 Discussion and principles From the survey of systems that we have gone through, we can distill a set of fundamental principles and a set of features that we believe are essential in understanding problems and solutions in the
Reference: [69] <institution> SoftWired AG, Zurich, Switzerland. </institution> <note> iBus Programmer's Manual, Nov. 1998. http://www.softwired.ch/ibus.htm. </note>
Reference-contexts: Among them we find JEDI [18], Elvin [68], TIBCO's TIB/Rendezvous TM [73], Keryx [81, 40], and iBus <ref> [69] </ref>. To our knowledge, except perhaps for TIB/Rendezvous, no one of these systems has been actually deployed and used on a significant number of sites across the boundaries of a local-area network.
Reference: [70] <institution> Sun Microsystems, Inc., Mountain View CA, U.S.A. Remote Method Invocation Specification, </institution> <year> 1997. </year>
Reference-contexts: The listener interface defines a method called notify that will be called by the event generator whenever an event occurs. This framework of classes allows a distributed interaction because both event generators and event listeners are remote objects and their interaction is handled by means of RMI calls <ref> [70, 26] </ref>. The notification model adopted by the Java Distributed Event Specification is very versatile. In fact notifications are Java objects implementing the Remo-teEvent. The filtering capability is instead rather limited. Event notifications have an event id of type long.
Reference: [71] <author> Sun Microsystems, Inc., </author> <title> Mountain View CA, U.S.A. Java Distributed Event Specification, </title> <year> 1998. </year>
Reference-contexts: These infrastructures are frameworks, typically frameworks of virtual classes (or interfaces) in an object oriented language, that support an event-based interaction among software components. The most significant example is the Java TM Distributed Event Specification <ref> [71] </ref>. This framework defines the Java interfaces of roles such as event generators, event listener, and event notifications. Typically, an event generator exports a register method that allows event listeners to declare their interest in the events emitted by the event generator.
Reference: [72] <institution> Sun Microsystems, Inc., Mountain View CA, U.S.A. JavaBeans 1.01 Specification, </institution> <year> 1998. </year>
Reference-contexts: As a result, an event service is often confused with specific applications (e.g., a bulletin board) or application domains (e.g., human-computer interaction), or design frameworks (e.g., standard interfaces or naming conventions like JavaBeans TM <ref> [72] </ref>), or else, because an event service provides and uses some sort of communication facility, it is compared to other general purpose but radically different communication mechanisms such as point-to-point messaging systems. As a first step in this work, we intend to identify the basic principles underlying event-based technologies.
Reference: [73] <author> TIBCO Inc. </author> <title> Rendezvous Information Bus. </title> <note> http://www.rv.tibco.com/rvwhitepaper.html, 1996. </note>
Reference-contexts: Some technologies address issues related to wide-area services. Among them we can find new technologies such as TIB/Rendezvous TM <ref> [73] </ref> that specifically provide an event service, but also more mature technologies such as the USENET news infrastructure, IP multicasting, the Domain Name Service (DNS), that, although not explicitly targeted at this problem domain, represent potential or partial solutions to the problem of scalability. <p> Among them we find JEDI [18], Elvin [68], TIBCO's TIB/Rendezvous TM <ref> [73] </ref>, Keryx [81, 40], and iBus [69]. To our knowledge, except perhaps for TIB/Rendezvous, no one of these systems has been actually deployed and used on a significant number of sites across the boundaries of a local-area network.
Reference: [74] <institution> TIBCO Inc., </institution> <address> Palo Alto CA, U.S.A. </address> <month> TIBR+: </month> <title> a WAN Router for Global Data Distribution, </title> <year> 1996. </year>
Reference-contexts: This implies that a subscription might define a set of event notifications, and two subscriptions might specify two overlapping sets of notifications. This in turn means that one event may match any number of subscriptions. JEDI [18] and TIB/Rendezvous <ref> [74] </ref>, as well as the USENET News system, adopt a subject-based subscription mechanism. In both TIB/Rendezvous and JEDI, the subject is a list of strings 2 over which it is possible to specify filters based on a limited form of regular expressions.
Reference: [75] <author> G. Vigna and R. Kemmerer. NetSTAT: </author> <title> A Network-based Intrusion Detection Approach. </title> <booktitle> In Proceedings of the 14 th Annual Computer Security Application Conference, </booktitle> <address> Scottsdale AZ, U.S.A., </address> <month> Dec. </month> <year> 1998. </year>
Reference-contexts: Examples of reactive systems are integrated development environments [64, 38, 11, 33], work-flow and process analysis systems [16, 4], graphical user interfaces [59], network management systems [65], software deployment systems [32] and security monitors <ref> [36, 56, 75] </ref>. There are two major motivations for designing applications as reactive systems. First, some applications are reactive by their nature. Typically, the ones that involve the direct interaction of human agents are characterized by an asynchronous input of relatively small pieces of data.
Reference: [76] <institution> The VINT ProjectUC Berkeley, LBL, USC/ISI, </institution> <note> and Xerox PARC. ns v2 Notes and Documentation, </note> <month> Nov. </month> <year> 1997. </year>
Reference-contexts: In addition to these basic abstractions, the simulator of SIENA implements a network model with sites and links that mimics the real communication infrastructure. We preferred a custom simulator to a general purpose one like ns-2 <ref> [76] </ref> because it gives us more freedom in the implementation of the components to simulate and in abstracting away details of the network model. Specifically, the simulator implements the network model that considers only the end-to-end characteristics of a link hiding the underlying packet switched network.
Reference: [77] <author> D. Waitzman, C. Partridge, and S. E. Deering. </author> <title> Distance Vector Multicast Routing Protocol. Internet Requests For Comments (RFC), </title> <month> Nov. </month> <year> 1988. </year>
Reference-contexts: Since any number of hosts can join a host group, datagrams addressed to that group must be dispatched to different points on the network. This is realized with special multicast routing protocol. Several of these protocols have been proposed with different degrees of scalability <ref> [23, 24, 55, 77] </ref>. These protocols use the membership information set up by IGMP.
Reference: [78] <author> B. M. Waxman. </author> <title> Routing of Multipoint Connections. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 6(9):16171622, </volume> <year> 1988. </year>
Reference-contexts: To compile realistic network topologies that approximate the behavior of real wide-area networks, we used a generator of random network graphs that implements the Transit-Stub model [82] (other models for random network graphs are Waxman's non-hierarchical graphs <ref> [78] </ref>, and Tiers [25]. A discussion on these models can be found in [83]). Although we experimented networks of 500 up to 1000 nodes, the bulk of simulations we present here were performed on a graph of 100 nodes.
Reference: [79] <author> B. Whetten, T. Montgomery, and S. Kaplan. </author> <title> A High Performance, Totally Ordered Multicast Protocol. </title> <editor> In K. Birman, F. Mattern, and A. Schiper, editors, </editor> <booktitle> Theory and Practice in Distributed Systems, number 938 in Lecture Notes in Computer Science. </booktitle> <address> SpringerVerlag, New York, </address> <year> 1995. </year> <month> 101 </month>
Reference-contexts: IP multicast per se is at the same level as IP, thus it is a connectionless best-effort (unreliable) service. A reliable transport layer can be implemented on top of IP multicast <ref> [47, 79] </ref>. We consider the IP multicast infrastructure and its routing algorithms to be the most important technology related to the SIENA event service.
Reference: [80] <institution> Workshop on Internet Scale Event Notification (WISEN). </institution> <note> http://www.ics.uci.edu/IRUS/wisen/wisen.html, July 1314 1998. </note>
Reference-contexts: industry, academia, and various organizations, in the direction of supporting an event service over wide-area networks. 6 Background and New Challenges The other main problem with evaluating technologies related to event-based systems is that this field lacks a widely accepted characterization of the problem as well as a common vocabulary <ref> [80] </ref>.
Reference: [81] <author> M. Wray and R. Hawkes. </author> <title> Distributed Virtual Environments and VRML: an Event-based Architecture. </title> <booktitle> In Proceedings of the Seventh International WWW Conference (WWW7), Brisbane, </booktitle> <address> Australia, </address> <year> 1998. </year>
Reference-contexts: Among them we find JEDI [18], Elvin [68], TIBCO's TIB/Rendezvous TM [73], Keryx <ref> [81, 40] </ref>, and iBus [69]. To our knowledge, except perhaps for TIB/Rendezvous, no one of these systems has been actually deployed and used on a significant number of sites across the boundaries of a local-area network.
Reference: [82] <author> E. W. Zegura, K. L. Calvert, and S. Bhattacharjee. </author> <title> How to Model an Inter-network. </title> <booktitle> In Proceedings of IEEE INFOCOM '96, </booktitle> <address> San Framcisco CA, U.S.A., </address> <month> Apr. </month> <year> 1996. </year>
Reference-contexts: To compile realistic network topologies that approximate the behavior of real wide-area networks, we used a generator of random network graphs that implements the Transit-Stub model <ref> [82] </ref> (other models for random network graphs are Waxman's non-hierarchical graphs [78], and Tiers [25]. A discussion on these models can be found in [83]). Although we experimented networks of 500 up to 1000 nodes, the bulk of simulations we present here were performed on a graph of 100 nodes.
Reference: [83] <author> E. W. Zegura, K. L. Calvert, and M. J. Donahoo. </author> <title> A Quantitative Comparison of Graph-based Models for Internet Topology. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 5(6), </volume> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: A discussion on these models can be found in <ref> [83] </ref>). Although we experimented networks of 500 up to 1000 nodes, the bulk of simulations we present here were performed on a graph of 100 nodes. <p> The two staring points are the topology meta-parameters and the scenario parameters. The topology meta-parameters are the input parameters for the topology generator 2 . These parameters are specific of the generation method (see <ref> [83] </ref> for details).
References-found: 83

