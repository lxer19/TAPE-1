URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/abscomp.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Phone: 2  
Title: An Abstract Account of Composition  
Author: Martin Abadi and Stephan Merz 
Address: 130 Lytton Avenue, Palo Alto, CA 94301, U.S.A.  Arcisstr. 21, 80290 Munchen, Germany  
Affiliation: 1 Digital Equipment Corporation, Systems Research Center,  Institut fur Informatik, Technische Universitat Munchen,  
Abstract: We present a logic of specifications of reactive systems. The logic is independent of particular computational models, but it captures common patterns of reasoning with assumption-commitment specifications. We use the logic for deriving proof rules for TLA and CTL fl specifications. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Martin Abadi and Leslie Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: In the realm of sequential programs, for example, the requirements are postconditions and the assumptions are preconditions. In the broader realm of reactive systems, which we consider in this paper, there are several forms of assumption-commitment specifications <ref> [17, 11, 18, 1, 2, 19, 6, 22, 7, 12] </ref>. An assumption-commitment specification for a component of a reactive system consists of a formula A, which expresses assumptions about the environment, and a formula C, which expresses the requirements that an implementation of the component has to meet. <p> In the previous work on TLA, the composition of specifications is their con junction, and refinement is implication. The assumption-commitment specifica tion with assumption A and commitment C is either A . C or A + . C. When A . C is chosen <ref> [1, 5] </ref>, semantic conditions guarantee the equivalence of A . C and A . C; therefore, we consider only A + . C. In [2] there is a rule for proving that a conjunction of specifications, each of the form A i + .
Reference: 2. <author> Martin Abadi and Leslie Lamport. </author> <title> Conjoining specifications. </title> <type> Research Report 118, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1993. </year> <note> To appear in ACM Transactions on Programming Languages and Systems. </note>
Reference-contexts: In the realm of sequential programs, for example, the requirements are postconditions and the assumptions are preconditions. In the broader realm of reactive systems, which we consider in this paper, there are several forms of assumption-commitment specifications <ref> [17, 11, 18, 1, 2, 19, 6, 22, 7, 12] </ref>. An assumption-commitment specification for a component of a reactive system consists of a formula A, which expresses assumptions about the environment, and a formula C, which expresses the requirements that an implementation of the component has to meet. <p> For concreteness we emphasize a particular linear-time temporal logic, TLA [16]. Using the tools of section 2, we reproduce part of the previous work on assumption-commitment specifications in TLA <ref> [2] </ref>. Formulas of linear-time temporal logics are normally interpreted over infinite sequences oe = hs 0 ; s 1 ; : : :i of states. A formula is valid if it is holds of all sequences of states. <p> C or A + . C. When A . C is chosen [1, 5], semantic conditions guarantee the equivalence of A . C and A . C; therefore, we consider only A + . C. In <ref> [2] </ref> there is a rule for proving that a conjunction of specifications, each of the form A i + . C i , implies another specification A + . C. The following result is a variation of that rule, restricted to safety properties: Theorem 4. <p> C C (A) . ( i2I C (C i ) . C (C)) C C A ^ (A i . C i ) ) (A . C)) Theorem 5 yields a rule for composing specifications quite similar to that of Abadi and Lamport <ref> [2] </ref>. That work also develops techniques for establishing the hypotheses of the rule, for example techniques for proving formulas of the form C (A) + V i2I C (C i ) . C (C)). Those techniques rely on TLA-specific ideas, outside the scope of our abstract logic.
Reference: 3. <author> Martin Abadi and Stephan Merz. </author> <title> On TLA as a logic. </title> <editor> In Manfred Broy, editor, </editor> <booktitle> Deductive Program Design, NATO ASI Series. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: A formula F is a safety property if F holds of an infinite sequence whenever it holds of all its finite prefixes. The connective ^ and ) are the usual, classical ones; several interesting, additional connectives are definable in TLA <ref> [3] </ref>: - C (F ) holds of a sequence oe iff F holds of all finite prefixes of oe. - F . G holds of oe iff, for all (finite or infinite) prefixes ae of oe, if F holds of ae then so does G.
Reference: 4. <author> Martin Abadi and Gordon Plotkin. </author> <title> A logical view of composition and refinement. </title> <booktitle> In Proceedings of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 323-332. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: In particular, existential quantification corresponds to hiding, which we have largely ignored. However, a general logical treatment of hiding may well be possible, and quite desirable. (Such a treatment was once started but not completed <ref> [4] </ref>.)
Reference: 5. <author> Martin Abadi and Gordon Plotkin. </author> <title> A logical view of composition. </title> <journal> Theoretical Computer Science, </journal> <volume> 114(1) </volume> <pages> 3-30, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Using the abstract logic, we derive proof rules for concrete specification methods. However, we do not attempt to capture every aspect of these specification methods; we focus on simple, basic results with broad applicability. Our logic borrows from that of Abadi and Plotkin <ref> [5] </ref>. In particular, we take the idea of using intuitionistic reasoning for assumption-commitment specifications. However, for the sake of simplicity and generality, we do not adopt some non-standard constructs of that logic (for example, "constrains at most"). <p> In the previous work on TLA, the composition of specifications is their con junction, and refinement is implication. The assumption-commitment specifica tion with assumption A and commitment C is either A . C or A + . C. When A . C is chosen <ref> [1, 5] </ref>, semantic conditions guarantee the equivalence of A . C and A . C; therefore, we consider only A + . C. In [2] there is a rule for proving that a conjunction of specifications, each of the form A i + .
Reference: 6. <author> Manfred Broy. </author> <title> A functional rephrasing of the assumption/commitment specifica-tion style. </title> <type> SFB-Bericht 342/10/94, </type> <institution> TUM-I9417, Techn. Univ. Munchen, Munich, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: In the realm of sequential programs, for example, the requirements are postconditions and the assumptions are preconditions. In the broader realm of reactive systems, which we consider in this paper, there are several forms of assumption-commitment specifications <ref> [17, 11, 18, 1, 2, 19, 6, 22, 7, 12] </ref>. An assumption-commitment specification for a component of a reactive system consists of a formula A, which expresses assumptions about the environment, and a formula C, which expresses the requirements that an implementation of the component has to meet. <p> Both of the applications described in detail in this paper are for temporal logics. However, our approach is not intrinsically limited to temporal logics: we have also used it on specifications of stream-processing functions <ref> [6, 19] </ref>. An assumption-commitment specification for a stream-processing function gives a property of the result of the function under assumptions about the inputs of the functions. Inductive reasoning arises when the function is defined as a fixpoint.
Reference: 7. <author> Antonio Cau and Pierre Collette. </author> <title> Parallel composition of assumption-commitment specifications: a unifying approach for shared variable and distributed message passing concurrency. </title> <journal> Acta Informatica, </journal> <note> 1995. To appear. </note>
Reference-contexts: In the realm of sequential programs, for example, the requirements are postconditions and the assumptions are preconditions. In the broader realm of reactive systems, which we consider in this paper, there are several forms of assumption-commitment specifications <ref> [17, 11, 18, 1, 2, 19, 6, 22, 7, 12] </ref>. An assumption-commitment specification for a component of a reactive system consists of a formula A, which expresses assumptions about the environment, and a formula C, which expresses the requirements that an implementation of the component has to meet. <p> However, for the sake of simplicity and generality, we do not adopt some non-standard constructs of that logic (for example, "constrains at most"). Cau, Collette, and Xu have given another interesting, unifying perspective on rules for composition <ref> [22, 7] </ref>. Their work treats abstract rules semantically; concurrent processes, with either shared variables or message passing, are then embedded in a common semantic structure based on labelled sequences. This structure could provide a model for our logic (much like the model of section 3).
Reference: 8. <author> E. Allen Emerson. </author> <title> Temporal and modal logic. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pages 997-1071. </pages> <publisher> Elsevier Science Publishers B.V., </publisher> <year> 1990. </year>
Reference-contexts: This approach enables us to consider non-linear well-founded structures, for example in the context of branching-time logics. The next section introduces our abstract logic. Sections 3 and 4 apply the logic to justify rules for TLA [16] and for CTL fl <ref> [8] </ref>. Section 5, in conclusion, discusses the results. 2 A logic of specifications Our logic of specifications is a propositional intuitionistic logic. We use the standard connectives ^ and !. In addition, we introduce a new connective, + !; this connective will be useful in treating assumption-commitment specifications. <p> We treat branching-time logics in the next section. 4 Composition in CTL fl Next we apply the logic of section 2 to assumption-commitment specifications in the branching-time temporal logic CTL fl <ref> [8] </ref>. This application is somewhat more tentative than that of section 3, in part because of the expressiveness of CTL fl , which allows many different styles of assumption-commitment specifications.
Reference: 9. <author> Orna Grumberg and David E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: In branching-time temporal logics, the composition of modules does not in general implement the conjunction of the specifications of the modules. The application of our theorems as composition rules will therefore require additional arguments. This complication is not unique to our work; several authors <ref> [13, 9] </ref> have advocated restricting commitments to the fragment 8CTL fl in order to ensure that specifications are preserved by composition.
Reference: 10. <author> Alfred Horn. </author> <title> Logic with truth values in a linearly ordered Heyting algebra. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 34(3) </volume> <pages> 395-408, </pages> <month> September </month> <year> 1969. </year>
Reference-contexts: for example: ((P 1 ! P 2 ) ! Q) ^ ((P 2 ! P 1 ) ! Q) ! Q This formula is a disjunction-free version of the traditional formula (P 1 ! P 2 ) _ (P 2 ! P 1 ), which expresses a kind of linearity <ref> [10] </ref>. In the previous work on TLA, the composition of specifications is their con junction, and refinement is implication. The assumption-commitment specifica tion with assumption A and commitment C is either A . C or A + . C. When A .
Reference: 11. <author> Cliff B. Jones. </author> <title> Tentative steps toward a development method for interfering programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(4) </volume> <pages> 596-619, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: In the realm of sequential programs, for example, the requirements are postconditions and the assumptions are preconditions. In the broader realm of reactive systems, which we consider in this paper, there are several forms of assumption-commitment specifications <ref> [17, 11, 18, 1, 2, 19, 6, 22, 7, 12] </ref>. An assumption-commitment specification for a component of a reactive system consists of a formula A, which expresses assumptions about the environment, and a formula C, which expresses the requirements that an implementation of the component has to meet.
Reference: 12. <author> Bengt Jonsson and Yih-Kuen Tsay. </author> <title> Assumption/guarantee specifications in linear-time temporal logic. </title> <booktitle> In Proceedings of TAPSOFT '95, Lecture Notes in Computer Science, </booktitle> <address> Berlin, May 1995. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In the realm of sequential programs, for example, the requirements are postconditions and the assumptions are preconditions. In the broader realm of reactive systems, which we consider in this paper, there are several forms of assumption-commitment specifications <ref> [17, 11, 18, 1, 2, 19, 6, 22, 7, 12] </ref>. An assumption-commitment specification for a component of a reactive system consists of a formula A, which expresses assumptions about the environment, and a formula C, which expresses the requirements that an implementation of the component has to meet.
Reference: 13. <author> Bernhard Josko. </author> <title> Verifying the correctness of AADL modules using model checking. </title> <editor> In J. W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </title> <booktitle> volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 386-400. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference-contexts: In branching-time temporal logics, the composition of modules does not in general implement the conjunction of the specifications of the modules. The application of our theorems as composition rules will therefore require additional arguments. This complication is not unique to our work; several authors <ref> [13, 9] </ref> have advocated restricting commitments to the fragment 8CTL fl in order to ensure that specifications are preserved by composition. <p> The application of our theorems as composition rules will therefore require additional arguments. This complication is not unique to our work; several authors [13, 9] have advocated restricting commitments to the fragment 8CTL fl in order to ensure that specifications are preserved by composition. Josko <ref> [13, 14] </ref> has suggested representing an assumption-commitment specifi-cation as a pair (A; C) where A is a linear-time formula and C is a branching-time formula; Vardi [21] has studied the complexity of model-checking for specifications of this form.
Reference: 14. <author> Bernhard Josko. </author> <title> Modular specification and verification of reactive systems. </title> <institution> Ha-bilitationsschrift, Univ. Oldenburg, Fachbereich Informatik, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: The application of our theorems as composition rules will therefore require additional arguments. This complication is not unique to our work; several authors [13, 9] have advocated restricting commitments to the fragment 8CTL fl in order to ensure that specifications are preserved by composition. Josko <ref> [13, 14] </ref> has suggested representing an assumption-commitment specifi-cation as a pair (A; C) where A is a linear-time formula and C is a branching-time formula; Vardi [21] has studied the complexity of model-checking for specifications of this form. <p> Instead of Josko's (A; C), we can write (8A) + . C, which is similar but logically stronger. The similarity between (A; C) and (8A) + . C is even closer under the substantial hypotheses of Josko's rules for dealing with mutual dependencies <ref> [14] </ref>. 5 Conclusion We have studied specifications in a general logical framework. We then inferred concrete proof rules for composing specifications from general logical facts. We believe that this approach explains some of the principles that underly the rules and helps in comparing rules.
Reference: 15. <author> Leslie Lamport. </author> <title> What good is temporal logic? In R. </title> <editor> E. A. Mason, editor, </editor> <booktitle> Information Processing 83: Proceedings of the IFIP 9th World Congress, </booktitle> <pages> pages 657-668, </pages> <address> Paris, </address> <month> September </month> <year> 1983. </year> <title> IFIP, </title> <publisher> North-Holland. </publisher>
Reference: 16. <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: We resort to semantic reasoning about computations only in applications to partic-ular formalisms. This approach enables us to consider non-linear well-founded structures, for example in the context of branching-time logics. The next section introduces our abstract logic. Sections 3 and 4 apply the logic to justify rules for TLA <ref> [16] </ref> and for CTL fl [8]. Section 5, in conclusion, discusses the results. 2 A logic of specifications Our logic of specifications is a propositional intuitionistic logic. We use the standard connectives ^ and !. <p> Despite its circular flavor, it is sound because of the distinction between ! and + 3 Composition in TLA In our first application of the general logic, we consider specifications written in linear-time temporal logics. For concreteness we emphasize a particular linear-time temporal logic, TLA <ref> [16] </ref>. Using the tools of section 2, we reproduce part of the previous work on assumption-commitment specifications in TLA [2]. Formulas of linear-time temporal logics are normally interpreted over infinite sequences oe = hs 0 ; s 1 ; : : :i of states.
Reference: 17. <author> Jayadev Misra and K. Mani Chandy. </author> <title> Proofs of networks of processes. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 7(4) </volume> <pages> 417-426, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: In the realm of sequential programs, for example, the requirements are postconditions and the assumptions are preconditions. In the broader realm of reactive systems, which we consider in this paper, there are several forms of assumption-commitment specifications <ref> [17, 11, 18, 1, 2, 19, 6, 22, 7, 12] </ref>. An assumption-commitment specification for a component of a reactive system consists of a formula A, which expresses assumptions about the environment, and a formula C, which expresses the requirements that an implementation of the component has to meet.
Reference: 18. <author> Amir Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. </title> <editor> In Krzysztof R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, NATO ASI Series, </booktitle> <pages> pages 123-144. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1984. </year>
Reference-contexts: In the realm of sequential programs, for example, the requirements are postconditions and the assumptions are preconditions. In the broader realm of reactive systems, which we consider in this paper, there are several forms of assumption-commitment specifications <ref> [17, 11, 18, 1, 2, 19, 6, 22, 7, 12] </ref>. An assumption-commitment specification for a component of a reactive system consists of a formula A, which expresses assumptions about the environment, and a formula C, which expresses the requirements that an implementation of the component has to meet.
Reference: 19. <author> Ketil Stolen, Frank Dederichs, and Rainer Weber. </author> <title> Assumption/commitment rules for networks of asynchronously communicating agents. </title> <type> SFB-Bericht 342/2/93, </type> <institution> TUM-I9303, Techn. Univ. Munchen, Munich, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: In the realm of sequential programs, for example, the requirements are postconditions and the assumptions are preconditions. In the broader realm of reactive systems, which we consider in this paper, there are several forms of assumption-commitment specifications <ref> [17, 11, 18, 1, 2, 19, 6, 22, 7, 12] </ref>. An assumption-commitment specification for a component of a reactive system consists of a formula A, which expresses assumptions about the environment, and a formula C, which expresses the requirements that an implementation of the component has to meet. <p> Both of the applications described in detail in this paper are for temporal logics. However, our approach is not intrinsically limited to temporal logics: we have also used it on specifications of stream-processing functions <ref> [6, 19] </ref>. An assumption-commitment specification for a stream-processing function gives a property of the result of the function under assumptions about the inputs of the functions. Inductive reasoning arises when the function is defined as a fixpoint. <p> Inductive reasoning arises when the function is defined as a fixpoint. We can represent that reasoning in our abstract logic, and thus prove variants of the proof rules of Stolen et al. <ref> [19] </ref>. We omit the details, which are long and perhaps not so natural. Our exposition has been confined to the propositional level; we did not address the interplay of quantification and composition. In particular, existential quantification corresponds to hiding, which we have largely ignored.
Reference: 20. <author> A. S. Troelstra and D. van Dalen. </author> <title> Constructivism in Mathematics: An Introduction, volume 1. </title> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1988. </year>
Reference-contexts: We define oe &lt; o as oe v o and o 6v oe. A set S is downward closed if o 2 S and oe v o imply that oe 2 S. We take as the set of worlds of a Kripke frame <ref> [20, p.77] </ref>, whose accessibility relation is the inverse of v (that is, o is accessible from oe iff o v oe). Since this accessibility relation is reflexive and transitive, we obtain a Kripke model of propositional intuitionistic logic.
Reference: 21. <author> Moshe Vardi. </author> <title> On the complexity of modular model checking. </title> <booktitle> In Proceedings of the Tenth Symposium on Logic in Computer Science. IEEE, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Josko [13, 14] has suggested representing an assumption-commitment specifi-cation as a pair (A; C) where A is a linear-time formula and C is a branching-time formula; Vardi <ref> [21] </ref> has studied the complexity of model-checking for specifications of this form. With Josko's definitions, a tree M satisfies a specification (A; C) with assumption A and commitment C iff M 0 j= C where M 0 is the sub-tree of M that consists of those paths that satisfy A.
Reference: 22. <author> Qiwen Xu, Antonio Cau, and Pierre Collette. </author> <title> On unifying assumption-commitment style proof rules for concurrency. </title> <editor> In Bengt Jonsson and Joachim Parrow, editors, </editor> <booktitle> Proceedings of the Fifth International Conference on Concurrency Theory (CONCUR '94), volume 836 of Lecture Notes in Computer Science, </booktitle> <pages> pages 267-282, </pages> <address> Berlin, 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In the realm of sequential programs, for example, the requirements are postconditions and the assumptions are preconditions. In the broader realm of reactive systems, which we consider in this paper, there are several forms of assumption-commitment specifications <ref> [17, 11, 18, 1, 2, 19, 6, 22, 7, 12] </ref>. An assumption-commitment specification for a component of a reactive system consists of a formula A, which expresses assumptions about the environment, and a formula C, which expresses the requirements that an implementation of the component has to meet. <p> However, for the sake of simplicity and generality, we do not adopt some non-standard constructs of that logic (for example, "constrains at most"). Cau, Collette, and Xu have given another interesting, unifying perspective on rules for composition <ref> [22, 7] </ref>. Their work treats abstract rules semantically; concurrent processes, with either shared variables or message passing, are then embedded in a common semantic structure based on labelled sequences. This structure could provide a model for our logic (much like the model of section 3).
References-found: 22

