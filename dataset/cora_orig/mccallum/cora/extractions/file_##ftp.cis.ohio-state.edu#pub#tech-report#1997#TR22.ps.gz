URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1997/TR22.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Title: Stepwise Design of Tolerances in Barrier Computations  
Author: Sandeep S. Kulkarni Anish Arora 
Keyword: multitolerance; detectable and undetectable faults; stepwise design; concurrent systems.  
Address: Columbus, Ohio 43210 USA  
Affiliation: Department of Computer and Information Science 1 The Ohio State University  
Abstract: We design in a stepwise manner a multitolerant computation for synchronizing the phases of concurrent processes. The tolerances of the computation enable processes to (i) compute all phases correctly in the presence of faults that corrupt process state in a detectable manner, and (ii) compute only a minimum possible number of phases incorrectly before resuming correct computation in the presence of faults that corrupt process state in an undetectable manner. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. W. Dijkstra. </author> <title> Self-stabilizing systems in spite of distributed control. </title> <journal> Communications of the ACM, </journal> <volume> 17(11), </volume> <year> 1974. </year>
Reference-contexts: A few comments about the problem are in order. The problem requires not only that each possible corruption of state be tolerated |which would require only the property of stabilizing fault-tolerance <ref> [1] </ref>| but also that each corruption be tolerated in a manner that is proportional to the extent and type of that corruption. Thus, a solution to this problem offers multiple levels of fault-tolerance, a notion which we abbreviate as multitolerance [2].
Reference: [2] <author> A. Arora and S. S. Kulkarni. Multitolerance. </author> <type> Technical Report OSU-CISRC TR37, </type> <institution> Ohio State University, </institution> <year> 1996. </year>
Reference-contexts: Thus, a solution to this problem offers multiple levels of fault-tolerance, a notion which we abbreviate as multitolerance <ref> [2] </ref>. The fault model is general, in that it collectively abstracts various classes of concrete faults. For instance, it readily abstracts faults whose effects are transient, such as hazards, corruption, loss, reordering, and duplication of messages; incorrect initializations; processor restarts; and performance and timing violations. <p> In conclusion, our solution illustrates the stepwise design of tolerance properties. We have presented formal methods for the stepwise design of multitolerant programs elsewhere <ref> [2] </ref>.
Reference: [3] <author> J. Couvreur, N. Francez, and M. Gouda. </author> <title> Asynchronous unison. </title> <booktitle> Proceedings of the Twelveth International Conference on Distributed Computing Systems, </booktitle> <address> Tokyo, </address> <year> 1992. </year>
Reference-contexts: It also abstracts faults whose effects are permanent or intermittent, provided auxiliary state variables are considered. Finally, the process model is also general. In particular, it extends a variety of other process models, including asynchronous clock unison <ref> [3] </ref>, phase synchronization [4], and atomic commitment [5] (see Section 6 for a detailed discussion). A significant amount of work has already addressed the fault-tolerance of each of these models.
Reference: [4] <author> J. Misra. </author> <title> Phase synchronization. </title> <journal> Information Processing Letters, </journal> <volume> 38 </volume> <pages> 101-105, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: It also abstracts faults whose effects are permanent or intermittent, provided auxiliary state variables are considered. Finally, the process model is also general. In particular, it extends a variety of other process models, including asynchronous clock unison [3], phase synchronization <ref> [4] </ref>, and atomic commitment [5] (see Section 6 for a detailed discussion). A significant amount of work has already addressed the fault-tolerance of each of these models.
Reference: [5] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems, chapter 7. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: It also abstracts faults whose effects are permanent or intermittent, provided auxiliary state variables are considered. Finally, the process model is also general. In particular, it extends a variety of other process models, including asynchronous clock unison [3], phase synchronization [4], and atomic commitment <ref> [5] </ref> (see Section 6 for a detailed discussion). A significant amount of work has already addressed the fault-tolerance of each of these models.
Reference: [6] <author> S. S. Kulkarni and A. Arora. </author> <title> Multitolerance in distributed reset. </title> <type> Technical Report OSU-CISRC TR13, </type> <institution> Ohio State University, </institution> <year> 1996. </year> <note> Submitted to Chicago Journal of Theoretical Computer Science, Special Issue on Self-Stabilization. </note>
Reference-contexts: non-faulty processes to continue to satisfy the specification of barrier synchronization in the presence of fail-stop faults, we may ensure that the spanning tree is (re)constructed and that a root process completes a diffusing computation only after all processes participate in that diffusing computation. (The interested reader is referred to <ref> [6] </ref> for the details of this approach.) Also, using Schneider's approach [7] to implement processors that behave like fail-stop processors with high probability, our program can be extended to tolerate Byzantine faults with high probability. 10 6.2 Low Atomicity In program OB, actions have high atomicity, in the sense that they
Reference: [7] <author> F. B. Schneider. </author> <title> Byzantine generals in action: Implementing fail-stop processors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(2) </volume> <pages> 145-154, </pages> <year> 1984. </year>
Reference-contexts: in the presence of fail-stop faults, we may ensure that the spanning tree is (re)constructed and that a root process completes a diffusing computation only after all processes participate in that diffusing computation. (The interested reader is referred to [6] for the details of this approach.) Also, using Schneider's approach <ref> [7] </ref> to implement processors that behave like fail-stop processors with high probability, our program can be extended to tolerate Byzantine faults with high probability. 10 6.2 Low Atomicity In program OB, actions have high atomicity, in the sense that they instantaneously access the state of several processes.
Reference: [8] <author> A. Arora and S. S. Kulkarni. </author> <title> Designing masking fault-tolerance via nonmasking fault-tolerance. </title> <booktitle> Proceedings of the Fourteenth Symposium on Reliable Distributed Systems, Bad Neuenahr, </booktitle> <volume> 14 </volume> <pages> 174-185, </pages> <year> 1995. </year> <note> Submitted to IEEE Transactions on Software Engineering. 12 </note>
Reference-contexts: After the root process completes its diffusing computation, j has an ancestor whose state is not corrupted. Hence, j eventually corrects its state. Other properties of the solution. Programs OB, M B, and DB are masking tolerant to detectable faults <ref> [8] </ref>, since they continue to satisfy the specification when detectable faults occur. They are nonmasking tolerant to undetectable faults, since they eventually resatisfy the specification when undetectable faults stop. They have low space-complexity.
References-found: 8

