URL: http://www.cs.pitt.edu/~moir/Papers/anderson-ramamurthy-moir-jeffay-rtdb96.ps
Refering-URL: http://www.cs.pitt.edu/~moir/papers.html
Root-URL: 
Title: Lock-Free Transactions for Real-Time Systems  
Author: James H. Anderson, Srikanth Ramamurthy, Mark Moir, and Kevin Jeffay 
Address: Chapel Hill  
Affiliation: Department of Computer Science, University of North Carolina at  
Abstract: We show that previous algorithmic and scheduling work concerning the use of lock-free objects in hard real-time systems can be extended to support real-time transactions on memory-resident data. Using our approach, transactions are not susceptible to priority inversion or deadlock, do not require complicated mechanisms for data-logging or for rolling back aborted transactions, and are implemented as library routines that require no special kernel support. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Audsley, A. Burns, M. Richardson, and A. Wellings, </author> <title> "Hard Real-Time Scheduling: The Deadline Monotonic Approach", </title> <booktitle> Proceedings of the 8th IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <address> Oxford, UK, </address> <year> 1992, </year> <pages> pp. 127-132. </pages>
Reference-contexts: In comparing the above condition to the DM condition for independent tasks given in <ref> [1] </ref>, we see that our condition essentially requires that the computation time of each task be "dilated" by the time it takes for one lock-free loop iteration. We now turn our attention to the EDF scheme. <p> dirty [i] := false else oldval [nw]; newval [nw] := ptrs [i]; ptrs [i] fi; touch [i]; nw := false; nw + 1 od; 13: if MWCAS (nw, addrlist, oldval, newval) then for i := 0 to dirtycnt 1 do copy [i] := oldlst [i]:addr od; return fi 6 "MEM <ref> [1] </ref> := MEM [10]", the programmer would write "Write (1; Read (10))". In Figure 5, BANK is a B-word shared variable.
Reference: [2] <author> J. Anderson and M. Moir, </author> <title> "Universal Constructions for Multi-Object Operations", </title> <booktitle> Proceedings of the 14th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1995, </year> <pages> pp. 184-193. </pages>
Reference-contexts: To enable such implementations to be used in real-time uniprocessor systems, Ramamurthy, Moir, and Ander-son present two implementations of an object that supports Read and CAS. (LL/SC can be implemented using Read and CAS in constant time <ref> [2] </ref>.) These implementations, which are summarized in the following theorems, use read/write and memory-to-memory Move instructions, respectively. Although Move is rare in multiprocessors, it is widely available on uniprocessors. <p> We assume that transactions are invoked by a collection of prioritized tasks executing on the same processor. Our implementation is mostly based on the universal lock-free constructions of large objects and multiple objects by Anderson and Moir <ref> [2, 3] </ref>. In contrast to conventional schemes for concurrency control, when lock-free algorithms are used, transactions are executed as if they do not access any shared data | i.e., such transactions can be viewed as being independent.
Reference: [3] <author> J. Anderson and M. Moir, </author> <title> "Universal Constructions for Large Objects", </title> <booktitle> Proceedings of the Ninth International Workshop on Distributed Algorithms, Lecture Notes in Computer Science 972, </booktitle> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1995, </year> <pages> pp. 168-182. </pages>
Reference-contexts: We assume that transactions are invoked by a collection of prioritized tasks executing on the same processor. Our implementation is mostly based on the universal lock-free constructions of large objects and multiple objects by Anderson and Moir <ref> [2, 3] </ref>. In contrast to conventional schemes for concurrency control, when lock-free algorithms are used, transactions are executed as if they do not access any shared data | i.e., such transactions can be viewed as being independent. <p> One possible criticism of our implementation is that the MWCAS primitive is not supported by the hardware in most systems. However, Anderson and Moir have shown that MWCAS can be implemented using the single-word CAS primitive in general asynchronous systems <ref> [3] </ref>. Furthermore, because real-time systems only allow a subset of the transaction interleavings in asynchronous systems, these constructions can be simplified for real-time systems using techniques similar to those presented in Section 2.2. In our lock-free construction, all data is stored in a single array.
Reference: [4] <author> J. Anderson, S. Ramamurthy, and K. </author> <title> Jeffay "Real-Time Computing with Lock-Free Shared Objects", </title> <booktitle> Proceedings of the 16th IEEE Real-Time Systems Symposium, </booktitle> <year> 1995, </year> <pages> pp. 28-37. </pages>
Reference-contexts: In particular, repeated interferences can cause a given operation to take an arbitrarily long time to complete. Fortunately, such interferences can be bounded by scheduling tasks appropriately <ref> [4] </ref>. As explained in the next section, the key to scheduling such tasks is to allow enough spare processor time to accommodate the failed object updates that can occur over any interval. <p> Nonetheless, Anderson, Ramamurthy, and Jeffay have shown that if tasks on a uniprocessor are scheduled appropriately, then such loops are indeed bounded <ref> [4] </ref>. We now explain intuitively why such bounds exist. For the sake of explanation, let us call an iteration of a retry loop a successful update if it successfully completes, and a failed update otherwise. <p> Using this information, it is possible to determine a bound on the number of failed updates in that interval. A set of tasks that share lock-free objects is schedulable if there is enough free processor time to accommodate the failed 2 updates that can occur over any interval. In <ref> [4] </ref>, scheduling conditions are established for deadline-monotonic (DM) [9] and earliest-deadline-first (EDF) [10] priority assignments. (The rate-monotonic (RM) [10] priority scheme is also considered, but the corresponding scheduling condition is a special case of that presented for the DM case.) In order to state these conditions, we must first define some
Reference: [5] <author> M. Herlihy, </author> <title> "Wait-Free Synchronization", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, No. 1, </volume> <year> 1991, </year> <pages> pp. 124-149. </pages>
Reference-contexts: The fact that many lock-free object implementations are based on strong synchronization primitives is no accident. Herlihy has shown that such strong primitives are, in general, necessary for these implementations <ref> [5] </ref>. Herlihy's results are based upon a categorization of objects by "consensus number". An object has consensus number N if it can be used to solve N -process consensus, but not (N + 1)- process consensus, in a wait-free 2 manner. <p> the reads and writes have consensus number 1 for such systems.) Theorem 3: Consensus can be implemented with constant time and space using reads and writes on a hard 4 real-time uniprocessor system. 2 Given an implementation of consensus objects, any shared object can be implemented in a lock-free manner <ref> [5] </ref>. However, such implementations usually entail high overhead. More practical lock-free implementations are based on universal primitives such as CAS and load-linked/store-conditional (LL/SC)[6].
Reference: [6] <author> M. Herlihy, </author> <title> "A Methodology for Implementing Highly Concurrent Data Objects", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 15, No. 5, </volume> <year> 1993, </year> <pages> pp. 745-770. </pages>
Reference: [7] <author> J. Huang, J. Stankovic, K. Ramamritham, and D. Towsley, </author> <title> "Experimental Evaluation of Real-Time Optimistic Concurrency Control Schemes", </title> <booktitle> Proceedings of the Seventeenth International Conference on Very Large Databases, </booktitle> <year> 1991, </year> <pages> pp. 35-46. </pages>
Reference-contexts: Army Research Office, grant number DAAH04-95-1-0323. The third author was also supported by a UNC Alumni Fellowship. The fourth author was supported by grants from Intel and IBM. tion phase or write phase) must be executed as critical sections <ref> [7, 8] </ref>. Priority inversion is often dealt with through the use of priority inheritance protocols or priority ceiling protocols [14].
Reference: [8] <author> H. Kung and J. Robinson, </author> <title> "On Optimistic Methods for Concurrency Control", </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 6, No. 2, </volume> <year> 1981, </year> <pages> pp. 213-226. </pages>
Reference-contexts: Army Research Office, grant number DAAH04-95-1-0323. The third author was also supported by a UNC Alumni Fellowship. The fourth author was supported by grants from Intel and IBM. tion phase or write phase) must be executed as critical sections <ref> [7, 8] </ref>. Priority inversion is often dealt with through the use of priority inheritance protocols or priority ceiling protocols [14].
Reference: [9] <author> J. Leung and J. Whitehead, </author> <title> "On the Complexity of Fixed-Priority Scheduling of Periodic, Real-Time Tasks", </title> <journal> Performance Evaluation, </journal> <volume> Vol. 2, No. 4, </volume> <year> 1982, </year> <pages> pp. 237-250. </pages>
Reference-contexts: A set of tasks that share lock-free objects is schedulable if there is enough free processor time to accommodate the failed 2 updates that can occur over any interval. In [4], scheduling conditions are established for deadline-monotonic (DM) <ref> [9] </ref> and earliest-deadline-first (EDF) [10] priority assignments. (The rate-monotonic (RM) [10] priority scheme is also considered, but the corresponding scheduling condition is a special case of that presented for the DM case.) In order to state these conditions, we must first define some notation.
Reference: [10] <author> C. Liu and J. Layland, </author> <title> "Scheduling Algorithms for multiprogramming in a Hard Real-Time Environment", </title> <journal> Journal of the ACM , Vol. </journal> <volume> 30, No. 1, </volume> <year> 1973, </year> <pages> pp. 46-61. </pages>
Reference-contexts: A set of tasks that share lock-free objects is schedulable if there is enough free processor time to accommodate the failed 2 updates that can occur over any interval. In [4], scheduling conditions are established for deadline-monotonic (DM) [9] and earliest-deadline-first (EDF) <ref> [10] </ref> priority assignments. (The rate-monotonic (RM) [10] priority scheme is also considered, but the corresponding scheduling condition is a special case of that presented for the DM case.) In order to state these conditions, we must first define some notation. <p> A set of tasks that share lock-free objects is schedulable if there is enough free processor time to accommodate the failed 2 updates that can occur over any interval. In [4], scheduling conditions are established for deadline-monotonic (DM) [9] and earliest-deadline-first (EDF) <ref> [10] </ref> priority assignments. (The rate-monotonic (RM) [10] priority scheme is also considered, but the corresponding scheduling condition is a special case of that presented for the DM case.) In order to state these conditions, we must first define some notation. <p> As in the case of DM scheduling, this condition extends the corresponding condition for independent tasks <ref> [10] </ref> by requiring that the computation time of each task be dilated by the time it takes for one lock-free loop iteration. The results presented above suggest a general strategy for determining the schedulability of tasks that share lock-free objects. <p> false else oldval [nw]; newval [nw] := ptrs [i]; ptrs [i] fi; touch [i]; nw := false; nw + 1 od; 13: if MWCAS (nw, addrlist, oldval, newval) then for i := 0 to dirtycnt 1 do copy [i] := oldlst [i]:addr od; return fi 6 "MEM [1] := MEM <ref> [10] </ref>", the programmer would write "Write (1; Read (10))". In Figure 5, BANK is a B-word shared variable.
Reference: [11] <author> H. Massalin, </author> <title> Synthesis: An Efficient Implementation of Fundamental Operating System Services, </title> <type> Ph.D. Dissertation, </type> <institution> Columbia University, </institution> <year> 1992. </year>
Reference-contexts: Figure 1 depicts an example of a lock-free operation | an en-queue taken from a shared queue implementation given in <ref> [11] </ref>. In this example, an enqueue is performed by trying to thread an item onto the tail of the queue using a two-word compare-and-swap (CAS2) instruction. 1 This threading is attempted repeatedly until it succeeds. Note that the queue is never actually "locked".
Reference: [12] <author> A. Mok, </author> <title> Fundamental Design Problems of Distributed Systems for the Hard Real-Time Environment , Ph.D. </title> <type> Thesis, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: Assumption (i) is common to all priority-driven scheduling policies. Assumption (ii) holds for most common policies, including RM, DM, and EDF scheduling. The only common scheduling policy that we know of that violates assumption (ii) is least-laxity-first (LLF) scheduling <ref> [12] </ref>. The collapse of Herlihy's hierarchy for hard real-time uniprocessor systems is established in [13] by giving a wait-free (and hence lock-free) algorithm that solves the consensus problem in such systems using only reads and writes. This algorithm is shown in Figure 4.
Reference: [13] <author> S. Ramamurthy, M. Moir, and J. Anderson, </author> <title> "Real-Time Object Sharing with Minimal System Support", </title> <booktitle> Proceedings of the 15th Annual ACM Symposium on Principles of Distributed Computing , to appear. </booktitle>
Reference-contexts: Although Herlihy's hierarchy is of fundamental importance for truly asynchronous systems, Rama-murthy, Moir, and Anderson recently showed that, for uniprocessor-based real-time systems, Herlihy's hierarchy collapses, i.e., reads and writes can be used to implement any lock-free object <ref> [13] </ref>. The basis for this result is the realization that certain task interleavings cannot occur within real-time systems. <p> Requiring an object implementation to correctly deal with this interleaving is therefore pointless, because it cannot arise in practice. The distinction between traditional asynchronous systems, to which Herlihy's work is directed, and hard real-time systems is illustrated in Figure 3. The results of <ref> [13] </ref> are based upon an execution shared var Fin, Prp : valtype [ ? private var v : valtype initially Fin = ? ^ Prp = ? procedure decide (val : valtype) returns valtype 1 : if Fin = ? then 2 : if Prp = ? then 3 : Prp <p> Assumption (ii) holds for most common policies, including RM, DM, and EDF scheduling. The only common scheduling policy that we know of that violates assumption (ii) is least-laxity-first (LLF) scheduling [12]. The collapse of Herlihy's hierarchy for hard real-time uniprocessor systems is established in <ref> [13] </ref> by giving a wait-free (and hence lock-free) algorithm that solves the consensus problem in such systems using only reads and writes. This algorithm is shown in Figure 4. In this algorithm, each task chooses a decision value by invoking the procedure decide.
Reference: [14] <author> L. Sha, R. Rajkumar, S. Son, and C. Chang, </author> <title> "A Real-Time Locking Protocol", </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 40, No. 7, </volume> <year> 1991, </year> <pages> pp. 793-800. 8 </pages>
Reference-contexts: The fourth author was supported by grants from Intel and IBM. tion phase or write phase) must be executed as critical sections [7, 8]. Priority inversion is often dealt with through the use of priority inheritance protocols or priority ceiling protocols <ref> [14] </ref>. These protocols dynamically adjust transaction priorities to ensure that a transaction within a critical section executes at a priority that is sufficiently high to bound the duration of any priority inversion.
References-found: 14

