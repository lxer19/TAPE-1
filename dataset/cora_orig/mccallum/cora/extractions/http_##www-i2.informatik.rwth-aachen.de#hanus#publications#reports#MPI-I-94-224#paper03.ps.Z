URL: http://www-i2.informatik.rwth-aachen.de/hanus/publications/reports/MPI-I-94-224/paper03.ps.Z
Refering-URL: http://www.informatik.uni-trier.de/~ley/db/conf/iclp/iclp94-w8.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: marriott@cs.monash.edu.au  pjs@cs.mu.oz.au  
Title: Semantics of Constraint Logic Programs with Optimization  
Author: Kim Marriott Peter J. Stuckey 
Keyword: Categories and Subject Descriptors: D.1.6 Logic Programming; F.4.1 Logic Programming; G.1.6 Constrained Optimization. General Terms: Languages, Theory Additional Key Words and Phrases: constraint logic program, semantics.  
Address: Clayton 3168, Australia  Parkville 3052, Australia  
Affiliation: Department of Computer Science Monash University  Department of Computer Science University of Melbourne  
Abstract: Many applications of constraint logic programming (CLP) languages require not only testing if a set of constraints is satisfiable, but also finding the optimal solution which satisfies them. Unfortunately, the standard declarative semantics for CLP languages does not consider optimization but only constraint satisfaction. Here we give a model theoretic semantics for optimization which is a simple extension of the standard semantics and a corresponding operational semantics which may be efficiently implemented.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Chan, D. </author> <title> An extension of constructive negation and its application in coroutining. Procs. </title> <booktitle> North American Conf. on Logic Programming 89 (Cleveland, </booktitle> <month> October </month> <year> 1989) </year> <month> 477-493. </month>
Reference: [2] <author> Clark, K. </author> <title> Negation as failure. Logic and Databases. </title> <editor> Gallaire H. and Minker J. (Eds.) </editor> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978, </year> <pages> 293-322. </pages>
Reference-contexts: The Clark completion <ref> [2] </ref> captures the reasonable assumption that the predicate is fully defined by the clauses in the program and so an "if-and-only-if" definition of the predicate can be obtained by combining these.
Reference: [3] <author> Dincbas, M., van Hentenryck, P., Simonis, H., Aggoun, A., Graf, T., and Berthier, F. </author> <title> The constraint logic programming language CHIP. </title> <booktitle> Proceedings of the International Conference on Fifth Generation Computer Systems FGCS-88 (Tokyo, </booktitle> <address> Japan, </address> <month> December </month> <year> 1988) </year> <month> 693-702. </month>
Reference-contexts: Pure constraint logic programming languages only provide for testing constraint satisfaction, however, many applications desire an optimal solution. For this reason, although the standard semantics of CLP languages [8] does not include optimization operators, some existing CLP languages provide ad hoc non-logical optimization <ref> [3] </ref> and in other languages, optimization may be obtained using meta-level facilities [7]. We address the problem of giving a simple declarative semantics for optimization which has a corresponding operational semantics that allows efficient implementation. <p> Existing constraint logic programming languages are ideally suited to answering satisfaction questions, this being the core of their operational behavior. However solving optimization problems with a CLP language is more problematic. Because of the importance of optimization some languages like CHIP <ref> [3] </ref> provide an ad hoc optimization facility which destroys the underlying declarative semantics. <p> Using the current best optimum to prune the search space is related to the operational semantics of optimization in 2LP [16] and CHIP's minimize (G,M) predicate <ref> [3] </ref>. Our proofs are based on expressing optimization in terms of negation. We emphasize that although negation is used to formalize optimization, the replacement of minimization with negation does not lead to an operationally feasible approach to minimization using safe SLDNF.
Reference: [4] <author> Fages, F. </author> <title> On the semantics of optimization predicates in CLP languages. Presented as a position paper at First Workshop on Principles and Practice of Constraint Programming. </title> <address> Newport, Rhode Island, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: Other research has considered building an interactive querying facility above the CLP program, which allows optimization queries [15]. However, in this setting optimization is not part of the language but rather sits on top of it. We have recently been made aware of work by Fages <ref> [4] </ref>. He has independently suggested a number of related operational semantics for optimization in CLP languages. He also provides a declarative semantics based on a translation of minimization to negation, similar to mt .
Reference: [5] <author> Ganguly, S., Greco, S., and Zaniolo, C. </author> <title> Minimum and maximum predicates in logic programming. </title> <booktitle> Proceedings of the Tenth Principles of Databases Symposium (Denver, </booktitle> <month> June </month> <year> 1991) </year> <month> 154-163. </month>
Reference-contexts: A similar translation is used in <ref> [5] </ref>. 2 Example 5.2 Consider the following program p (Y) :- min (fXg, g (X), X, f (X), Y). The goal p (Y ) has the unique answer Y = f (0). <p> Unfortunately few implementations of constructive negation exist and in general they have severe efficiency problems. For this reason the operational semantics we give is quite different to (and more efficient than) the usual operational semantics for constructive negation. Deductive database researchers have studied aggregation, in particular minimization <ref> [5] </ref>. For exam-ple their goal groupby (p (X,Y), [X], T = min (Y)) corresponds in intent to the minimization subgoal min (Y ; p (X ; Y ); Y ; Y ; T ).
Reference: [6] <author> Gorlick, M.M., Kesselman, C.F., Marotta, D.A., and Parker, </author> <title> D.S. Mockingbird: a logical methodology for testing. </title> <note> Journal of Logic Programming 8 (1990) 95-119. </note>
Reference-contexts: Constraints provide a powerful and natural programming paradigm, in which the objects of computation are not explicitly constructed but rather they are implicitly defined using constraints. Applications for constraint logic programming languages have been in many diverse areas. They include electrical circuit analysis [18], synthesis and diagnosis <ref> [6] </ref>, options trading and financial planning [13]. Other applications are in traditional operations research problems, such as cutting stock and scheduling. Pure constraint logic programming languages only provide for testing constraint satisfaction, however, many applications desire an optimal solution.
Reference: [7] <author> Heintze, N.C., Michaylov, S., Stuckey, P.J. and Yap, R. </author> <booktitle> On meta-programming in CLP(R). Proc. North American Conference on Logic Programming (Cleveland, </booktitle> <month> October </month> <year> 1989) </year> <month> 52-68. </month>
Reference-contexts: For this reason, although the standard semantics of CLP languages [8] does not include optimization operators, some existing CLP languages provide ad hoc non-logical optimization [3] and in other languages, optimization may be obtained using meta-level facilities <ref> [7] </ref>. We address the problem of giving a simple declarative semantics for optimization which has a corresponding operational semantics that allows efficient implementation. Our main contribution is a model theoretic and operational semantics for optimization in CLP languages which is a simple extension of the usual semantics. <p> This returns the answer constraint MaxWealth = 20, MaxStock = 99. For this reason, some existing CLP languages e.g. CHIP, provide ad hoc non-logical optimization and in other languages, optimization may be obtained using meta-level facilities <ref> [7] </ref>. In both cases the advantages of the simple declarative semantics of the CLP language are lost. We wish to provide language facilities for asking for optimal solutions which admit an efficient implementation, but also have a simple declarative semantics.
Reference: [8] <author> Jaffar, J. and Lassez, J.-L. </author> <title> Constraint logic programming. </title> <booktitle> Proc. Fourteenth Ann. ACM Symp. Principles of Programming Languages (San Francisco, </booktitle> <address> California, </address> <year> 1987) </year> <month> 111-119. </month>
Reference-contexts: 1 Introduction One of the most promising innovations in recent programming language design is the amalgamation of constraint programming and logic programming <ref> [8] </ref>. Constraints provide a powerful and natural programming paradigm, in which the objects of computation are not explicitly constructed but rather they are implicitly defined using constraints. Applications for constraint logic programming languages have been in many diverse areas. <p> Other applications are in traditional operations research problems, such as cutting stock and scheduling. Pure constraint logic programming languages only provide for testing constraint satisfaction, however, many applications desire an optimal solution. For this reason, although the standard semantics of CLP languages <ref> [8] </ref> does not include optimization operators, some existing CLP languages provide ad hoc non-logical optimization [3] and in other languages, optimization may be obtained using meta-level facilities [7]. We address the problem of giving a simple declarative semantics for optimization which has a corresponding operational semantics that allows efficient implementation.
Reference: [9] <author> Jaffar, J., Michaylov, S., Stuckey, P., and Yap, R. </author> <title> The CLP(R) language and system. </title> <booktitle> ACM Transactions on Programming Languages and Systems 14 (1992) 339-395. </booktitle>
Reference-contexts: The compiler is for the language CLP (R) <ref> [9, 10] </ref> in which constraints are linear arithmetic equations and inequalities. Adding optimization is useful as it means that linear programming problems from operations research can be naturally expressed as simple programs. There are three features to note about this implementation.
Reference: [10] <author> Jaffar, J., Michaylov, S., Stuckey, P., and Yap, R. </author> <title> An abstract machine for CLP(R). </title> <booktitle> Proc ACM SIGPLAN Conf. on Programming Language Design and Implementation (San Francisco, </booktitle> <month> June </month> <year> 1992) </year> <month> 128-139. </month>
Reference-contexts: The compiler is for the language CLP (R) <ref> [9, 10] </ref> in which constraints are linear arithmetic equations and inequalities. Adding optimization is useful as it means that linear programming problems from operations research can be naturally expressed as simple programs. There are three features to note about this implementation.
Reference: [11] <author> Kleene, </author> <title> S.C. Introduction to Metamathematics. </title> <publisher> North-Holland, </publisher> <year> 1952. </year>
Reference-contexts: Let th (A) be the theory of A, that is all first order sentences true in A. Then comp (P ; A) is P fl ^ th (A). 2 Note we assume Kleene's strong three valued interpretation <ref> [11] </ref> of the connectives, except for $ which is given Lukasiewicz's interpretation, that is x $ y is true iff x and y have the same truth value (including both undefined), and false otherwise.
Reference: [12] <author> Kunen, K. </author> <title> Negation in logic programming. </title> <note> Journal of Logic Programming 4 (1987) 289-308. </note>
Reference-contexts: ) we obtain Y = f (M ) ^ M 0 ^ :(0 &lt; M ) $ M = 0 ^ Y = f (0) as expected. 2 The usual declarative semantics of a logic program with negation is given by the three valued models of the program's Clark completion <ref> [12] </ref>. The Clark completion [2] captures the reasonable assumption that the predicate is fully defined by the clauses in the program and so an "if-and-only-if" definition of the predicate can be obtained by combining these. <p> These restrictions improve efficiency, and in practice are not severe, resembling those used in most Prolog implementations. Of course, the implementation is still sound. 7 Related Work The declarative semantics is based on completion semantics developed for negation by Kunen <ref> [12] </ref> for logic programs, and extended to constraint logic programs by Stuckey [19]. Our operational semantics is related to that proposed by Naish [17] for negation and aggregation, in that optimization subgoals must delay until their global variables have a fixed value.
Reference: [13] <author> Lassez, C., McAloon, K., and Yap, R. </author> <title> Constraint logic programming and options trading. </title> <booktitle> IEEE Expert 2 (1987) 42-50. </booktitle>
Reference-contexts: Applications for constraint logic programming languages have been in many diverse areas. They include electrical circuit analysis [18], synthesis and diagnosis [6], options trading and financial planning <ref> [13] </ref>. Other applications are in traditional operations research problems, such as cutting stock and scheduling. Pure constraint logic programming languages only provide for testing constraint satisfaction, however, many applications desire an optimal solution. <p> However, CSPs, contrary to their name, often include an optimization component. Not only must the answer satisfy the required constraints, it should also be the best such answer. Consider the following CLP (R) program for determining the values of stock options (adapted from <ref> [13] </ref>). A "call" is a contract to allow the holder the option to buy a stock at some exercise price (X ) at some later date if desired.
Reference: [14] <author> Lloyd, J.W. </author> <booktitle> Foundations of Logic Programming (2nd Ed.) </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference: [15] <author> Maher, M.J. and Stuckey, P.J. </author> <title> Expanding query power in constraint logic programming. Procs. </title> <booktitle> North American Conf. on Logic Programming 89 (Cleveland, </booktitle> <month> October </month> <year> 1989) </year> <month> 20-36. </month>
Reference-contexts: Although apparently related, we cannot make use of their results in our setting because of the bottom-up operational paradigm used in deductive databases. Other research has considered building an interactive querying facility above the CLP program, which allows optimization queries <ref> [15] </ref>. However, in this setting optimization is not part of the language but rather sits on top of it. We have recently been made aware of work by Fages [4]. He has independently suggested a number of related operational semantics for optimization in CLP languages.
Reference: [16] <author> McAloon, K. and Tretkoff, C. 2LP: </author> <title> A logic programming and linear programming system. </title> <institution> Brooklyn College of CUNY, CIS department, </institution> <type> Technical Report No. </type> <pages> 1989-21, </pages> <year> 1989. </year>
Reference-contexts: Our operational semantics is related to that proposed by Naish [17] for negation and aggregation, in that optimization subgoals must delay until their global variables have a fixed value. Using the current best optimum to prune the search space is related to the operational semantics of optimization in 2LP <ref> [16] </ref> and CHIP's minimize (G,M) predicate [3]. Our proofs are based on expressing optimization in terms of negation. We emphasize that although negation is used to formalize optimization, the replacement of minimization with negation does not lead to an operationally feasible approach to minimization using safe SLDNF.
Reference: [17] <author> Naish, L. </author> <title> Negation and Control in Prolog. </title> <booktitle> Lecture Notes in Computer Science 238. </booktitle> <publisher> Springer Verlag, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: Of course, the implementation is still sound. 7 Related Work The declarative semantics is based on completion semantics developed for negation by Kunen [12] for logic programs, and extended to constraint logic programs by Stuckey [19]. Our operational semantics is related to that proposed by Naish <ref> [17] </ref> for negation and aggregation, in that optimization subgoals must delay until their global variables have a fixed value. Using the current best optimum to prune the search space is related to the operational semantics of optimization in 2LP [16] and CHIP's minimize (G,M) predicate [3].
Reference: [18] <author> Simonis, H. and Dincbas, M. </author> <title> Using an extended Prolog for digital circuit design. </title> <booktitle> IEEE International Workshop on AI Applications to CAD Systems for Electronics (Munich, </booktitle> <month> October </month> <year> 1987) </year> <month> 165-188. </month>
Reference-contexts: Constraints provide a powerful and natural programming paradigm, in which the objects of computation are not explicitly constructed but rather they are implicitly defined using constraints. Applications for constraint logic programming languages have been in many diverse areas. They include electrical circuit analysis <ref> [18] </ref>, synthesis and diagnosis [6], options trading and financial planning [13]. Other applications are in traditional operations research problems, such as cutting stock and scheduling. Pure constraint logic programming languages only provide for testing constraint satisfaction, however, many applications desire an optimal solution.
Reference: [19] <author> Stuckey, P.J. </author> <title> Constructive negation for constraint logic programming. Procs. </title> <booktitle> Fifth IEEE Logic in Computer Science Symposium (Amsterdam, </booktitle> <year> 1991) </year> <month> 328-341. </month>
Reference-contexts: A goal which succeeds has the truth value true, a goal which fails is has the truth value false, and a goal which does not terminate has the truth value undefined . Following <ref> [19] </ref> we extend these notions to constraint logic programs. Definition 5.3 The completion, comp (P ; A), of a program P over domain A is defined as follows. <p> If we use constructive negation to implement optimization then completeness with respect to the three-valued consequences of comp (mt (P ); A) is immediate <ref> [19] </ref>. However, even in the case of goals which do not flounder, no such completeness result holds for the more efficient operational semantics considered here. There are two problems. The first problem arises because completeness of finite failure requires the use of a "fair" selection rule. <p> ; : : : n such that A j= $ 1 _ _ n , and (b) if comp (cmt (P ); A) j= : ~ 9cmt ( ^ G) then every (fair) derivation for G is finitely failed. 2 Proof: (Sketch) The proof relies on results from constructive negation <ref> [19] </ref> which show comp (cmt (P ); A) j= ~ 8cmt ( ^ G ) iff using constructive negation the goal cmt ( ^ G ) is totally successful, i.e. has answer constraints 1 ; : : : ; n such that A j= $ 1 _ _ n and comp <p> Of course, the implementation is still sound. 7 Related Work The declarative semantics is based on completion semantics developed for negation by Kunen [12] for logic programs, and extended to constraint logic programs by Stuckey <ref> [19] </ref>. Our operational semantics is related to that proposed by Naish [17] for negation and aggregation, in that optimization subgoals must delay until their global variables have a fixed value. <p> He also provides a declarative semantics based on a translation of minimization to negation, similar to mt . He does not give explicit soundness or completeness results for these operational semantics, but he seems to suggest that soundness and completeness follows immediately from results in constructive negation <ref> [19] </ref>. However our need for the more complex translation, cmt, suggests that completeness is more difficult to prove.
References-found: 19

