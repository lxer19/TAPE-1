URL: http://www.arlut.utexas.edu/~warshaw/papers/Sigmod98.ps
Refering-URL: 
Root-URL: 
Email: warshaw, miranker- @cs.utexas.edu  
Phone: Telephone: 512-835-3840 Fax: 512-835-3100  
Title: Paper Id 86 Rule-Based Query Optimization, Revisited  
Author: Lane B. Warshaw Daniel P. Miranker 
Note: This research is partially funded by DARPA, contract number: F30602-96-2-0226 and the Applied Research Laboratories, University of Texas, Internal Research and Development Program  
Address: Taylor Hall 2.124 Austin, TX 78712-1188  
Affiliation: Department of Computer Sciences and The Applied Research Laboratories The University of Texas at Austin  
Abstract: We present an overview and initial performance assessment of a rule-based query optimizer written in VenusDB. VenusDB is an active-database rule language embedded in C++. Following the developments in extensible database query optimizers, first in rule-based form followed by optimizers written as objectoriented programs, the VenusDB optimizer avails the advantages of both. To date, development of rule-based query optimizers have included the definition and implementation of custom rule languages. Thus, extensibility required detailed understanding and often further development of the underlying search mechanism of the rule system. Object- oriented query optimizers appear to have achieved their goals with respect to a clear organization and encapsulation of an optimizers elements. They do not, however, provide for the concise, declarative expression of domain specific heuristics. Our experience demonstrates that a rule-based query optimizer developed in VenusDB can be well structured, flexible, and demonstrate good performance. We compare a relational optimizer developed with Volcano and a functionally identical optimizer developed with VenusDB. The results demonstrate comparable performance on small queries with few joins, while the VenusDB optimizer scales better and outperforms Volcano on larger join- arity queries. Since we did not have to develop a specialized rule language or consider application specific programming constructs, the source code for the optimizer is small and straightforward, about one-third the size. Similar code comparisons with an object-based optimizer, the VenusDB optimizer reveals similar benefit. 
Abstract-found: 1
Intro-found: 0
Reference: [SOL87] <author> E. Soloway, J. Bachant, K. Jensen, </author> <title> Assessing the Maintainability of XCON-in-RIME: Coping with the Problems of a VERY Large Rule-Base. </title> <booktitle> Association for Artificial Intelligence, Proceedings of the National Conference on Artificial Intelligence (AAAI-87), </booktitle> <month> August </month> <year> 1987. </year>
Reference-contexts: There are results in the subareas of AI on planning and general purpose problem solving demonstrating that a small number of rule-based design patterns may be used as the starting to point to encode virtually all forms of search <ref> [SOL87, LAI87, LAI83, GAM95] </ref>. Our aim is to take this one more step and develop components enabling a plug and play approach to different search techniques.
Reference: [BAS79] <author> V.Basili, R. W. Reiter, Jr. </author> <title> Evaluating Automatable Measures of Software Development. </title> <booktitle> In Proceedings on Workshop on Quantitative Software Models, </booktitle> <month> October </month> <year> 1979, </year> <pages> 107-116. </pages>
Reference-contexts: We quantify three systems, optimizers developed in Opt++, Volcano, and VenusDB respectively [GRM93, KAB94]. First, we calculated the total lines of code. This metric gives evidence of a systems overall complexity <ref> [BAS79] </ref>. Next, we computed McCabes cyclomatic complexity. Cyclomatic complexity measures the number of possible paths through a program which is indicative of control flow complexity [MCC76]. As a brief description, the cyclomatic complexity of a simple sequential procedure with no branches receives a rating of 1.
Reference: [BAY96] <author> R. Bayardo, </author> <title> D.P. Miranker, "Processing Queries for the First-Few Answers." </title> <booktitle> Proceedings of the 5th Conference of Information and Knowledge Management, </booktitle> <month> November </month> <year> 1996, </year> <pages> 45-52. </pages>
Reference-contexts: We then ran the optimizers on 12 sets of 100 randomly generated queries. Each set targeted queries from one to twelve joins respectively. We tabulated optimizer execution time and estimated plan cost. The random queries were generated using the query generator described in <ref> [BAY96] </ref> for very large data sets. The generator produces both queries and statistics concerning data distributions. Rather than purely random query graphs, the generator is concerned with producing queries consistent with those seen in real applications. We set the generators parameters, b and p, to 1.5 and 0.1.
Reference: [BRG94] <editor> J.C. Browne, et. al. </editor> <title> A New Approach to Modularity in Rule-Based Programming. </title> <booktitle> In Proceedings of the 6th International Conference on Tools with Artificial Intelligence, </booktitle> <publisher> IEEE Press, </publisher> <year> 1994, </year> <pages> 18-25. </pages>
Reference-contexts: Thus, OO benefits seen in the optimizers developed by [OZM96, KAB94] with respect to the representation of operator trees can be exploited identically. A wellstructured (modular) rule environment that allows a user to assert some procedurally inspired control over the execution while maintaining fixed-point semantics <ref> [BRG94] </ref>. The addition of the event qualification in the condition-action rules which enables further structuring of the search, but not as an ad-hoc mechanism.
Reference: [CHM88] <author> K.M. Chandy, J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1985. </year>
Reference-contexts: Control remains within a Venus module until fixed point is reached <ref> [CHM88] </ref>. Modules may be listed in the action of a rule and can be nested arbitrarily deep. If a rule fires and its action lists module calls, then the rules within the nested modules must achieve fixed point before the action of the rule commits.
Reference: [DID95] <author> D. Das, D. Batory. Prairie: </author> <title> A Rule Specification Framework for Query Optimizers. </title> <booktitle> In Proceedings of the 11th International Conference on Data Engineering, </booktitle> <pages> 201-210, </pages> <address> Taipei, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: 1.0 INTRODUCTION The ability to express a query optimizer concisely and extensibly has been an ongoing goal of experimental database research. The first generation of this research comprised a number of rule-based query optimizers <ref> [GRD87, GRM93, DID95, PHH92] </ref>. Rule-based representation is attractive since it closes the semantic gap between the specification of an optimizer and its implementation. By virtue of a declarative specification, it follows that rule-based optimizers are much easier to extend than their predecessors. <p> Execution continues in this manner, bouncing back and forth between nested module calls until the state of fixed point is reached in the Optimize module. 4.0 The Query Optimizer The three basic parts of a query optimizer consists of the cost model, search space, and search strategy <ref> [DID95] </ref>. <p> Besides availability and reputation, we had in-house expertise due to a development effort layering in a new front-end <ref> [DID95] </ref> 2 Both relational optimizers contain two T-rules, and two I-rules, and the algebraic operators of scan, sort and We did not similarly execute the performance analysis of an objectoriented optimizer since they are shown to be equivalent to Volcano in [KAB94]. 0 10 20 30 40 50 Joins 100 Queryis
Reference: [GAM95] <author> E. Gamma, R.Helm, R. Johnson, J. Vlissides, </author> <title> Design Patterns, Elements of Reusable ObjectOriented Software. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading Massachusetts, </address> <year> 1995. </year>
Reference-contexts: At this juncture we have written a number of query optimizers using VenusDB. A general organization is emerging as well as substantially overlapping code segments from which we expect to define a library of design patterns from which an extensible set of search strategies may be refined <ref> [GAM95] </ref>. In this paper we describe the core organizational elements and report in detail on an optimizer we developed that is operationally equivalent to the sample relational optimizer provided with the Volcano distribution. <p> There are results in the subareas of AI on planning and general purpose problem solving demonstrating that a small number of rule-based design patterns may be used as the starting to point to encode virtually all forms of search <ref> [SOL87, LAI87, LAI83, GAM95] </ref>. Our aim is to take this one more step and develop components enabling a plug and play approach to different search techniques.
Reference: [GRD87] <author> G. Graefe, D. J. Dewitt. </author> <title> The EXODUS Optimizer Generator. </title> <booktitle> In Proceedings 1987 ACM SIGMOD International Conference on Management of Data, </booktitle> <address> San Francisco, </address> <month> May </month> <year> 1987. </year> <pages> 387-394. </pages>
Reference-contexts: 1.0 INTRODUCTION The ability to express a query optimizer concisely and extensibly has been an ongoing goal of experimental database research. The first generation of this research comprised a number of rule-based query optimizers <ref> [GRD87, GRM93, DID95, PHH92] </ref>. Rule-based representation is attractive since it closes the semantic gap between the specification of an optimizer and its implementation. By virtue of a declarative specification, it follows that rule-based optimizers are much easier to extend than their predecessors.
Reference: [GRM93] <author> G. Graefe, W. McKenna. </author> <title> The Volcano Optimizer Generator: Extensibility and Efficient Search. </title> <booktitle> In Proceeding of the 12th International Conference on Data Engineering, </booktitle> <year> 1993, </year> <pages> 209-218. </pages>
Reference-contexts: 1.0 INTRODUCTION The ability to express a query optimizer concisely and extensibly has been an ongoing goal of experimental database research. The first generation of this research comprised a number of rule-based query optimizers <ref> [GRD87, GRM93, DID95, PHH92] </ref>. Rule-based representation is attractive since it closes the semantic gap between the specification of an optimizer and its implementation. By virtue of a declarative specification, it follows that rule-based optimizers are much easier to extend than their predecessors. <p> Our aim is to take this one more step and develop components enabling a plug and play approach to different search techniques. Our experimental implementations to date encompass top-down depth-first hill climbing, System R style bottom-up and a hybrid strategy of Volcano, (coined transformative search by <ref> [GRM93, KAB94] </ref>). We have converged, so far, to an architecture where algebraic transforms and implementation assignments are each encapsulated in rule modules whose definitions are nearly independent of search strategy. The structure of those patterns as they materialize in Venus is becoming more obvious. <p> We simply could not align the two implementations close enough to instrument for this result. 6.0 Quantitative Measurements Quantitative software metrics are an objective measure used to analyze the complexity and life cycle cost of a system. We quantify three systems, optimizers developed in Opt++, Volcano, and VenusDB respectively <ref> [GRM93, KAB94] </ref>. First, we calculated the total lines of code. This metric gives evidence of a systems overall complexity [BAS79]. Next, we computed McCabes cyclomatic complexity. Cyclomatic complexity measures the number of possible paths through a program which is indicative of control flow complexity [MCC76].
Reference: [LAI83] <author> J. E. Laird. </author> <title> Universal Subgoaling, </title> <type> Ph.D. dissertation, </type> <institution> Carnegie-Mellon University, </institution> <year> 1983. </year>
Reference-contexts: There are results in the subareas of AI on planning and general purpose problem solving demonstrating that a small number of rule-based design patterns may be used as the starting to point to encode virtually all forms of search <ref> [SOL87, LAI87, LAI83, GAM95] </ref>. Our aim is to take this one more step and develop components enabling a plug and play approach to different search techniques.
Reference: [LAI87] <author> J.E. Laird, A. Newell, </author> <title> and P.S. Rosenbloom, SOAR: An Architecture for General Intelligence. </title> <booktitle> Artificial Intelligence, </booktitle> <publisher> Elsevier Science Publishers B.V. North-Holland, </publisher> <year> 1987, </year> <pages> 1-64. </pages>
Reference-contexts: There are results in the subareas of AI on planning and general purpose problem solving demonstrating that a small number of rule-based design patterns may be used as the starting to point to encode virtually all forms of search <ref> [SOL87, LAI87, LAI83, GAM95] </ref>. Our aim is to take this one more step and develop components enabling a plug and play approach to different search techniques.
Reference: [MCC76] <author> T. McCabe, </author> <title> A Complexity Measure. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> December </month> <year> 1976, </year> <pages> 308-320. </pages>
Reference-contexts: First, we calculated the total lines of code. This metric gives evidence of a systems overall complexity [BAS79]. Next, we computed McCabes cyclomatic complexity. Cyclomatic complexity measures the number of possible paths through a program which is indicative of control flow complexity <ref> [MCC76] </ref>. As a brief description, the cyclomatic complexity of a simple sequential procedure with no branches receives a rating of 1. Code is considered unmanageable if it is rated 11 or higher. Cyclomatic complexity was developed in the context of Fortran and C.
Reference: [MCD93] <author> J. McDermott. </author> <title> R1(XCON) at age 12: Lessons for an elmentary school achiver. </title> <journal> Arrtificial Intelligenc, </journal> <volume> (59):1993, </volume> <pages> 241-247. </pages>
Reference-contexts: When the paradigm has been strictly enforced by a rule language, program developers often introduce additional conditions, coined secret-messages, to force sequencing. This has been shown to result in poor quality code <ref> [MCD93] </ref>. Thus, despite fixed point semantics, Venus includes several clearly procedural constructs. Such constructs are admitted to the language only if there is a clear need and an obvious macro-like expansion into an equivalent, (if not slow and cumbersome), nondeterministic program. The most critical of these procedural constructs is priorities.
Reference: [KAB94] <author> N. Kabra, D. J. Dewitt. </author> <title> Opt++: An ObjectOriented Implementation for Extensible Database Query Optimization. </title> <note> Unpublished paper located in the SHORE papers home page, http://www.cs.wisc.edu/shore/shore.papers.html. </note>
Reference-contexts: Consequently, rule-based optimizers have been successful in providing environments friendly to extending the search space by easily adding new transformation rules, but they do not allow for extensibility in other dimensions, often fixing the search strategies [OZM96]. Subsequent developers have moved to object oriented technologies <ref> [KAB94, OZM96] </ref>. These systems boast a well-encapsulated and structured environment by defining the query representation and cost model as first class objects and procedures respectively. Hence, defining new database operators often only involves deriving a class from the designated super-class and specializing its methods. <p> VenusDB is an active database extension of Venus. Unique features of VenusDB that suggested revisiting the issue of rule-based query optimizers include, Embeddability in C++ and thus embeddability in database systems. VenusDB data definition language is precisely C++. Thus, OO benefits seen in the optimizers developed by <ref> [OZM96, KAB94] </ref> with respect to the representation of operator trees can be exploited identically. A wellstructured (modular) rule environment that allows a user to assert some procedurally inspired control over the execution while maintaining fixed-point semantics [BRG94]. <p> The evaluation of optimization times and plans returned by the VenusDB optimizer compares quite favorably to its Volcano counterpart. In fact, while returning similar plans, the VenusDB optimizer actually executes faster on large queries. Given the success of OO optimizers, we also compare to Opt++ <ref> [KAB94] </ref>. Since that system itself has been shown to perform comparably to Volcano, our comparisons are limited to organizational aspects. <p> These definitions closely resemble the object oriented operator tree definitions developed in other extensible query optimizers <ref> [KAB94, OZM95] </ref>. A base class, called TREE_NODE, contains the C++ virtual methods and data needed to define the nodes descriptor, the logical and/or physical description of the node. Derived algebraic operators must specialize these method calls in a manner relevant to the operator. <p> Our aim is to take this one more step and develop components enabling a plug and play approach to different search techniques. Our experimental implementations to date encompass top-down depth-first hill climbing, System R style bottom-up and a hybrid strategy of Volcano, (coined transformative search by <ref> [GRM93, KAB94] </ref>). We have converged, so far, to an architecture where algebraic transforms and implementation assignments are each encapsulated in rule modules whose definitions are nearly independent of search strategy. The structure of those patterns as they materialize in Venus is becoming more obvious. <p> to a development effort layering in a new front-end [DID95] 2 Both relational optimizers contain two T-rules, and two I-rules, and the algebraic operators of scan, sort and We did not similarly execute the performance analysis of an objectoriented optimizer since they are shown to be equivalent to Volcano in <ref> [KAB94] </ref>. 0 10 20 30 40 50 Joins 100 Queryis per data point T i m Venus Volcano 1 100 10000 100000 1E+07 1E+09 1E+11 1E+13 1E+15 1E+17 1E+19 1E+21 1E+23 1E+25 1E+27 1 2 3 4 5 6 7 8 9 10 11 12 Joins 100 Queries per data point <p> We simply could not align the two implementations close enough to instrument for this result. 6.0 Quantitative Measurements Quantitative software metrics are an objective measure used to analyze the complexity and life cycle cost of a system. We quantify three systems, optimizers developed in Opt++, Volcano, and VenusDB respectively <ref> [GRM93, KAB94] </ref>. First, we calculated the total lines of code. This metric gives evidence of a systems overall complexity [BAS79]. Next, we computed McCabes cyclomatic complexity. Cyclomatic complexity measures the number of possible paths through a program which is indicative of control flow complexity [MCC76]. <p> Because of its availability, we chose the Opt++ optimizer developed for the SHORE project <ref> [KAB94] </ref>. The example Opt++ distribution is modeled for a basic object- oriented database. For this reason, we implemented an equivalent optimizer within VenusDB by extending the optimizer described in the previous sections. The sample Opt++ optimizer contains 9,007 lines of code, while the VenusDB equivalent contains 5,333 lines, roughly half.
Reference: [MIR90] <author> D.P. Miranker, D.Brant, B.J. Lofaso Jr., and D. Gadbois. </author> <title> On the Performance of Lazy Matching in Production Systems. </title> <booktitle> In Proceedings of the 1990 National Conference on Artificial Intelligence, AAAI, </booktitle> <month> July </month> <year> 1990, </year> <pages> 685-692. </pages>
Reference-contexts: An irony is that much of this performance gain is precisely due to the introduction of relational query optimization techniques in rule execution engines <ref> [OBE95, MIR90, WAN92] </ref>. At this juncture we have written a number of query optimizers using VenusDB.
Reference: [OBE95] <author> L Obermeyer, D.P. Miranker, D. </author> <title> Brant. Selective Indexing Speeds Production Systems. </title> <booktitle> In Proceedings of the 7th International Conference on Tools with Artificial Intelligence, 1995. </booktitle> - <volume> 15 - 12/03/97 </volume>
Reference-contexts: An irony is that much of this performance gain is precisely due to the introduction of relational query optimization techniques in rule execution engines <ref> [OBE95, MIR90, WAN92] </ref>. At this juncture we have written a number of query optimizers using VenusDB.
Reference: [OBE96] <author> L. Obermeyer, </author> <title> D.P. Miranker, An Overview of the VenusDB Active Multidatabase System. </title> <booktitle> In the Proceedings of of the International Symposium on Cooperative Database Systems for Advanced Applications. </booktitle> <address> Kyoto, Japan, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: A universally quantified cursor is represented by a "*" within the square brackets. VenusDB is an extension of Venus such that an event clause has been added to the declaration section. In effect, this introduces refinements concerning the more focussed execution behavior of active-database ECA (event, condition, action) rules <ref> [OBE96] </ref>. The event clause is used to define precisely which events trigger a reevaluation of the rule, and is typical of other active-database rule languages. If an event is not specified, the specification defaults to all events and results in behavior equivalent to Venus. <p> The other difference between Venus and VenusDB is an API facility for mapping Venuss main-memory containers to tables or extents in databases. We have previously reported on an application developed by exploiting a heterogeneous integration of VenusDB with multiple databases <ref> [OBE96] </ref>. A rule condition is a C++ boolean expression. C++ functions and method calls can be executed from within the rule condition provided they return a boolean value and execute side effect free.
Reference: [OBE97] <author> L. Obermeyer, </author> <title> D.P. Miranker. Evaluating Triggers Using Decision Trees. </title> <note> To appear in CIKM 97, </note> <institution> Las Vegas, Nevada, </institution> <month> November </month> <year> 1997. </year>
Reference-contexts: C++ statements and function calls can be made modifying data elements without any explicit notification to the rule system. The Venus compiler, either directly or with the help of the target databases trigger mechanism, produces an optimal trigger filter <ref> [OBE97] </ref>. 3.2 Modularity and Semantics The entire action of a Venus rule is defined to be a single atomic transition in a statespace (a transaction), and rules fire by a fair nondeterministic policy. Control remains within a Venus module until fixed point is reached [CHM88].
Reference: [OZM96] <author> M. Tamer zsu, Adriana Munoz, Duana Szafron. </author> <title> An Extensible Query Optimizer for an Objectbase Management System. </title> <booktitle> In Proceedings of the 4th International Conference on Information and Knowledge Management, </booktitle> <year> 1995, </year> <pages> 188-196. </pages>
Reference-contexts: Consequently, rule-based optimizers have been successful in providing environments friendly to extending the search space by easily adding new transformation rules, but they do not allow for extensibility in other dimensions, often fixing the search strategies <ref> [OZM96] </ref>. Subsequent developers have moved to object oriented technologies [KAB94, OZM96]. These systems boast a well-encapsulated and structured environment by defining the query representation and cost model as first class objects and procedures respectively. <p> Consequently, rule-based optimizers have been successful in providing environments friendly to extending the search space by easily adding new transformation rules, but they do not allow for extensibility in other dimensions, often fixing the search strategies [OZM96]. Subsequent developers have moved to object oriented technologies <ref> [KAB94, OZM96] </ref>. These systems boast a well-encapsulated and structured environment by defining the query representation and cost model as first class objects and procedures respectively. Hence, defining new database operators often only involves deriving a class from the designated super-class and specializing its methods. <p> VenusDB is an active database extension of Venus. Unique features of VenusDB that suggested revisiting the issue of rule-based query optimizers include, Embeddability in C++ and thus embeddability in database systems. VenusDB data definition language is precisely C++. Thus, OO benefits seen in the optimizers developed by <ref> [OZM96, KAB94] </ref> with respect to the representation of operator trees can be exploited identically. A wellstructured (modular) rule environment that allows a user to assert some procedurally inspired control over the execution while maintaining fixed-point semantics [BRG94].
Reference: [PAC94] <editor> Pachet, F. ed. </editor> <title> Proceedings of the OOPSLA'94 Workshop on Embedded ObjectOriented Production Systems (EOOPS), </title> <type> Technical Report LAFORIA 94/24. </type> <institution> Laboratoire Formes et Intelligence Artifcielle, Institut Blaise Pascal. </institution> <month> Dec. </month> <year> 1994. </year>
Reference: [PHH92] <author> H. Pirahesh, J. M. Hellerstein, and W. Hasan. </author> <title> Extensible/Rule Based Query Rewrite Optimization in Starburst. </title> <booktitle> In Proceedings of the 1992 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> 39-48, </pages> <address> San Diego, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: 1.0 INTRODUCTION The ability to express a query optimizer concisely and extensibly has been an ongoing goal of experimental database research. The first generation of this research comprised a number of rule-based query optimizers <ref> [GRD87, GRM93, DID95, PHH92] </ref>. Rule-based representation is attractive since it closes the semantic gap between the specification of an optimizer and its implementation. By virtue of a declarative specification, it follows that rule-based optimizers are much easier to extend than their predecessors.
Reference: [SES97] <author> P.Sesshadri, M. Livny and R.Ramakrishnan. </author> <title> The Case for Enhanced Abstract Data Types Praveen Seshadri, </title> <booktitle> VLDB 97. </booktitle>
Reference-contexts: We develop quantitative software metrics that supports this claim. The need for extensibility and modification of search strategies has been magnified by the extension of relational database management systems into arbitrary data-types <ref> [SES97] </ref>. Given this renewed need and a number of developments in rule-based execution, we have developed the hypothesis that effective query We agree with those findings. - 3 - 12/03/97 optimizers may be built using a general-purpose rule language, VenusDB. VenusDB is an active database extension of Venus.
Reference: [STO92] <author> M. Stonebraker. </author> <title> The Integration of Rule Systems and Database Systems. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <pages> 415-423, </pages> <month> October </month> <year> 1992. </year>
Reference: [WAN92] <author> Y-W Wang and E. Hanson. </author> <title> A Performance Comparison of the Rete and TREAT Algorithms for Testing Database Rule Conditions. </title> <booktitle> In Proceedings of the Eighth International Conference on Data Engineering, </booktitle> <year> 1992. </year>
Reference-contexts: An irony is that much of this performance gain is precisely due to the introduction of relational query optimization techniques in rule execution engines <ref> [OBE95, MIR90, WAN92] </ref>. At this juncture we have written a number of query optimizers using VenusDB.
Reference: [WAR96] <author> L.B. Warshaw, D. P. Miranker. </author> <title> A Case Study of Venus and a Declarative Bases for Rule Modules. </title> <booktitle> In Proceedings of the 5th Conference on Information and Knowledge Management, </booktitle> <month> November </month> <year> 1996. </year>
Reference-contexts: For this reason, we decided only to analyze procedures with a rating greater than 1, effectively factoring out well designed constructs while focusing on the more complex. Relating cyclomatic complexity to the rule-based paradigm, - 12 - 12/03/97 we developed a simple procedural model of rule execution <ref> [WAR96] </ref>. 6.1 Volcano Comparison The Volcano rule optimizer was implemented using 12,524 lines of code, of which 10,238 lines were used to define the operator tree, the rule search engine component, and the optimizer search strategy. 2,286 lines are unique to the individual relational optimizer.
References-found: 25

