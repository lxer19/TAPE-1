URL: ftp://ftp.cse.ogi.edu/pub/pacsoft/papers/defunctionalize.ps
Refering-URL: http://www.cse.ogi.edu/PacSoft/projects/SDRR/p_tools.html
Root-URL: http://www.cse.ogi.edu
Title: Defunctionalization of Typed Programs  
Author: Jeffrey M. Bell and James Hook 
Date: February 6, 1994  
Affiliation: Oregon Graduate Institute of Science Technology  
Abstract: In a 1972 paper, Reynolds outlined a method for removing higher-order functions from a functional language program by representing functional values as data and interpreting the representations as needed. This transformation is known as defunctionalization. This paper describes a defunctionalization algorithm extended to operate over a significant portion of core Standard ML syntax. The algorithm addresses issues not addressed in Reynolds's presentation or subsequent examples. The most significant extension is that the algorithm operates on a statically typed language. The algorithm also addresses issues such as a method for representing function values as ML datatype values, function values "shared" by more than one higher-order function, local declarations, and expressions with multiple alternates (such as case expressions). We have implemented the algorithm as a critical part of a larger program transformation system. 
Abstract-found: 1
Intro-found: 1
Reference: [Bel94] <author> Jeffrey M. Bell. </author> <title> An implementation of Reynold's defunctionalization method for a modern functional language. </title> <type> Master's thesis, </type> <institution> Oregon Graduate Institute of Science & Technology, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: The implementation currently works with Hops that are Hofs, but only if they are monomorphic. A full description of the implementation, including other minor restrictions on program input, the extension to let declarations, and the treatment of polymorphic higher-order functions can be found in <ref> [Bel94] </ref>. 6 Summary We have outlined an algorithm for eliminating higher-order functions from a typed functional language. The algorithm is an extension of Reynolds's defunctionalization method. This research addresses features of functional programming languages not explicitly addressed in Reynolds's paper or other references.
Reference: [BH93] <author> Fran~coise Bellegarde and James Hook. </author> <title> Monads, indexes, and transformations. </title> <booktitle> In TAP-SOFT '93: Theory and Practice of Software Development, volume 668 of LNCS, </booktitle> <pages> pages 314-327. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> A page was omitted from the proceedings, it may be obtained via ftp from ftp.cse.ogi.edu in the file pub/pacsoft/papers/tapsoft.dvi. </note>
Reference-contexts: Bellegarde and Hook use the data structures calculated by defunctionalization as the basis for a series of program transformations that rewrite a higher-order, monad-based definition of de Bruijn substitution into the standard, efficient first-order implementation using arithmetic operations for index manipulation <ref> [BH93] </ref>. In that derivation the form of defunctionalization presented here reveals that natural numbers can encode the higher-order function values. It is not clear how this could have been accomplished with an untyped closure analysis. <p> It is not clear how this could have been accomplished with an untyped closure analysis. Firstify , the implementation of this defunctionalization algorithm, has been used together with Schism [Con92], to automatically perform the specialization and defunctionalization transformations presented in Bellegarde and Hook <ref> [BH93] </ref>. 1.2 Hof Elimination via Specialization Chin and Darlington [CD93] have developed a Hof elimination algorithm based on fold/unfold rules that uses specialization. The following example demonstrates the algorithm. The program below contains a Hof called map, which applies a function to each argument in a list.
Reference: [BJ82] <author> Dines Bjtrner and Cliff B. Jones. </author> <booktitle> Formal Specification and Software Development, </booktitle> <pages> pages 277-280. </pages> <publisher> Prentice-Hall, </publisher> <year> 1982. </year>
Reference-contexts: Thus, this research focuses on Hofs with function-valued parameters. We will call such a parameter a Hop (for "higher-order parameter"). Reynolds presents defunctionalization via a specific example. This is also true in other presentations of the method <ref> [BJ82, Sch85a, Sch85b, Sch88, Wan85] </ref>. Thus there are many details left out of these presentations, and there are theoretical issues not addressed in the presentations.
Reference: [Bon90] <author> A. Bondorf. </author> <title> Automatic autoprojectin of higher order recursive equations. </title> <editor> In N. Jones, editor, </editor> <booktitle> ESOP '90, volume 432 of LNCS, </booktitle> <pages> pages 70-87. </pages> <publisher> Springer-Verlag, </publisher> <month> May </month> <year> 1990. </year> <month> 9 </month>
Reference-contexts: Theoretical issues include polymorphic Hofs, local declarations, and function values contained in data structures. Reynolds's defunctionalization is the basis for Sestoft's closure analysis, which is used for glob-alization [Ses89], control-flow analysis [Shi88, Shi91] and binding-time analysis <ref> [Bon90] </ref>. The fundamental difference between our approach and closure analysis is that we construct first-order datatypes that characterize exactly the structure of each higher-order value, whereas closure analysis has one large, implicitly recursive type allowing arbitrary structures to be represented. Characterizing the structure of higher-order values exactly facilitates subsequent transformations.
Reference: [CD93] <author> Wei-Ngan Chin and John Darlington. </author> <title> Higher-order removal: A modular approach. Un--published work, </title> <year> 1993. </year>
Reference-contexts: Defunctionalization [Rey72], firstification [Nel91], and higher-order removal <ref> [CD93] </ref> are methods for eliminating higher-order functions from a program, while preserving the semantics of the program. It is desirable to eliminate higher-order functions from a program because some program transformations which improve program efficiency can only be performed on first-order programs (i.e. functional programs without higher-order functions). <p> Firstify , the implementation of this defunctionalization algorithm, has been used together with Schism [Con92], to automatically perform the specialization and defunctionalization transformations presented in Bellegarde and Hook [BH93]. 1.2 Hof Elimination via Specialization Chin and Darlington <ref> [CD93] </ref> have developed a Hof elimination algorithm based on fold/unfold rules that uses specialization. The following example demonstrates the algorithm. The program below contains a Hof called map, which applies a function to each argument in a list. <p> However, a defunctionalized program is only pseudo first-order <ref> [CD93] </ref> because it still mimics the runtime characteristics of the original higher-order program. Chin and Darlington's method produces more efficient implementations. <p> Firstify operates on Standard ML programs which meet the following criteria: * All functions are uncurried such that each function has only one argument (possibly a tuple) and all function call sites are fully uncurried. This criterion can be met via the A transfor mation of Chin and Darlington <ref> [CD93] </ref>. * The program contains no let declarations. This criterion can be met by lambda lifting [Joh85]. The algorithm has been extended to let declarations, but this is not currently reflected in the implementation. * The only lambda abstractions occur as Hops.
Reference: [Con92] <author> Charles Consel. </author> <title> The Schism Manual, version 2.0. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1992. </year>
Reference-contexts: In that derivation the form of defunctionalization presented here reveals that natural numbers can encode the higher-order function values. It is not clear how this could have been accomplished with an untyped closure analysis. Firstify , the implementation of this defunctionalization algorithm, has been used together with Schism <ref> [Con92] </ref>, to automatically perform the specialization and defunctionalization transformations presented in Bellegarde and Hook [BH93]. 1.2 Hof Elimination via Specialization Chin and Darlington [CD93] have developed a Hof elimination algorithm based on fold/unfold rules that uses specialization. The following example demonstrates the algorithm.
Reference: [HKS92] <author> James Hook, Richard Kieburtz, and Tim Sheard. </author> <title> Generating programs by reflection. </title> <type> Technical Report 92-015, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: For an example of a Hop that is not variable-only, consider the definition of the map with policy function introduced by Hook, Kieburtz and Sheard <ref> [HKS92] </ref>: fun map with policy Z f (Var x) = Var (f x) j map with policy Z f (Abs t) = Abs (map with policy Z (Z f ) t) j map with policy Z f (App (t; t 0 )) = App ( map with policy Z f t;
Reference: [Joh85] <author> Thomas Johnsson. </author> <title> Lambda lifting: Transforming programs to recursive equations. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 201 </volume> <pages> 190-203, </pages> <year> 1985. </year>
Reference-contexts: This criterion can be met via the A transfor mation of Chin and Darlington [CD93]. * The program contains no let declarations. This criterion can be met by lambda lifting <ref> [Joh85] </ref>. The algorithm has been extended to let declarations, but this is not currently reflected in the implementation. * The only lambda abstractions occur as Hops. This criterion can be met by lambda lifting and the A transformation of Chin and Darlington. * No functions are contained in datatype values.
Reference: [Nel91] <author> George C. Nelan. Firstification. </author> <type> PhD thesis, </type> <institution> Arizona State University, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: 1 Introduction 1.1 Higher-Order Functions and Their Elimination Higher-order functions (Hofs) are either 1. functions with arguments that are themselves functions 2. functions that return function values Map functions are common examples of Hofs of the first sort, and curried functions are examples of the second sort. Defunctionalization [Rey72], firstification <ref> [Nel91] </ref>, and higher-order removal [CD93] are methods for eliminating higher-order functions from a program, while preserving the semantics of the program.
Reference: [Rey72] <author> John C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proceedings of the 25th ACM National Conference, </booktitle> <pages> pages 717-740. </pages> <publisher> ACM, </publisher> <year> 1972. </year>
Reference-contexts: 1 Introduction 1.1 Higher-Order Functions and Their Elimination Higher-order functions (Hofs) are either 1. functions with arguments that are themselves functions 2. functions that return function values Map functions are common examples of Hofs of the first sort, and curried functions are examples of the second sort. Defunctionalization <ref> [Rey72] </ref>, firstification [Nel91], and higher-order removal [CD93] are methods for eliminating higher-order functions from a program, while preserving the semantics of the program. <p> In the recursive call in the Abs case, the second Hop is not variable-only, and so specialization fails to give a first order program. 1.3 Reynolds's Defunctionalization Method Reynolds outlined a more general method for eliminating higher-order functions known as defunc-tionalization <ref> [Rey72] </ref>. The key to this method is representing Hops as data values. When Hops are transformed into data values, higher-order functions become first order, since they no longer have functions as arguments.
Reference: [Sch85a] <author> David A. Schmidt. </author> <title> Detecting global variables in denotational specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(2) </volume> <pages> 299-310, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Thus, this research focuses on Hofs with function-valued parameters. We will call such a parameter a Hop (for "higher-order parameter"). Reynolds presents defunctionalization via a specific example. This is also true in other presentations of the method <ref> [BJ82, Sch85a, Sch85b, Sch88, Wan85] </ref>. Thus there are many details left out of these presentations, and there are theoretical issues not addressed in the presentations.
Reference: [Sch85b] <author> David A. Schmidt. </author> <title> An implementation from a direct semantics definition. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 217 </volume> <pages> 222-235, </pages> <year> 1985. </year>
Reference-contexts: Thus, this research focuses on Hofs with function-valued parameters. We will call such a parameter a Hop (for "higher-order parameter"). Reynolds presents defunctionalization via a specific example. This is also true in other presentations of the method <ref> [BJ82, Sch85a, Sch85b, Sch88, Wan85] </ref>. Thus there are many details left out of these presentations, and there are theoretical issues not addressed in the presentations.
Reference: [Sch88] <author> David A. Schmidt. </author> <title> Detecting stack-based environments in denotational definitions. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 11(2) </volume> <pages> 107-131, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Thus, this research focuses on Hofs with function-valued parameters. We will call such a parameter a Hop (for "higher-order parameter"). Reynolds presents defunctionalization via a specific example. This is also true in other presentations of the method <ref> [BJ82, Sch85a, Sch85b, Sch88, Wan85] </ref>. Thus there are many details left out of these presentations, and there are theoretical issues not addressed in the presentations.
Reference: [Ses89] <author> Peter Sestoft. </author> <title> Replacing function parameters by global variables. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 39-53. </pages> <publisher> ACM Press, </publisher> <month> September </month> <year> 1989. </year>
Reference-contexts: Theoretical issues include polymorphic Hofs, local declarations, and function values contained in data structures. Reynolds's defunctionalization is the basis for Sestoft's closure analysis, which is used for glob-alization <ref> [Ses89] </ref>, control-flow analysis [Shi88, Shi91] and binding-time analysis [Bon90]. The fundamental difference between our approach and closure analysis is that we construct first-order datatypes that characterize exactly the structure of each higher-order value, whereas closure analysis has one large, implicitly recursive type allowing arbitrary structures to be represented.
Reference: [Shi88] <author> Olin Shivers. </author> <title> Control-flow analysis in Scheme. </title> <booktitle> In Proc. of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 164-174. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: Theoretical issues include polymorphic Hofs, local declarations, and function values contained in data structures. Reynolds's defunctionalization is the basis for Sestoft's closure analysis, which is used for glob-alization [Ses89], control-flow analysis <ref> [Shi88, Shi91] </ref> and binding-time analysis [Bon90]. The fundamental difference between our approach and closure analysis is that we construct first-order datatypes that characterize exactly the structure of each higher-order value, whereas closure analysis has one large, implicitly recursive type allowing arbitrary structures to be represented.
Reference: [Shi91] <author> Olin Shivers. </author> <title> The semantics of Scheme control-flow analysis. </title> <booktitle> In Proc. of the Symp. on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 190-198. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: Theoretical issues include polymorphic Hofs, local declarations, and function values contained in data structures. Reynolds's defunctionalization is the basis for Sestoft's closure analysis, which is used for glob-alization [Ses89], control-flow analysis <ref> [Shi88, Shi91] </ref> and binding-time analysis [Bon90]. The fundamental difference between our approach and closure analysis is that we construct first-order datatypes that characterize exactly the structure of each higher-order value, whereas closure analysis has one large, implicitly recursive type allowing arbitrary structures to be represented.
Reference: [Wan85] <author> Mitchell Wand. </author> <title> From interpreter to compiler: A representational derivation. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 217 </volume> <pages> 306-324, </pages> <year> 1985. </year> <month> 10 </month>
Reference-contexts: Thus, this research focuses on Hofs with function-valued parameters. We will call such a parameter a Hop (for "higher-order parameter"). Reynolds presents defunctionalization via a specific example. This is also true in other presentations of the method <ref> [BJ82, Sch85a, Sch85b, Sch88, Wan85] </ref>. Thus there are many details left out of these presentations, and there are theoretical issues not addressed in the presentations.
References-found: 17

