URL: http://www.cs.indiana.edu/database/Coral/coraloverview.ps
Refering-URL: http://www.cs.indiana.edu/database/Coral/Coral.html
Root-URL: http://www.cs.indiana.edu
Email: fraghu,divesh,praveen,sudarshag@cs.wisc.edu.  
Title: An Overview of CORAL  
Author: Raghu Ramakrishnan Praveen Seshadri Divesh Srivastava S. Sudarshan 
Address: WI 53706, U.S.A.  
Affiliation: Computer Sciences Department, University of Wisconsin-Madison,  
Abstract-found: 0
Intro-found: 1
Reference: [BR87] <author> Catriel Beeri and Raghu Ramakrishnan. </author> <title> On the power of Magic. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: Magic Templates rewriting could potentially generate several different adorned forms of each predicate, corresponding to the sets of arguments that are bound on different "calls" to the predicate. (See <ref> [BR87] </ref> for more details on adornments.) The user can specify that only certain adornments are allowed for a predicate. If no adornment is specified for a predicate it is assumed that all adornments are allowed for the predicate. The syntax for specifying allowed adornments is shown in Figure 2.
Reference: [CDRS86] <author> Michael Carey, David DeWitt, Joel Richardson, and Eugene Shekita. </author> <title> Object and file management in the EXODUS extensible database system. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1986. </year>
Reference-contexts: then compiling the main program as well as the modules, and finally, incrementally loading all the .o files. (Thus, modules can still be incrementally compiled and then loaded.) 1.3 Current Status The current prototype of CORAL is optimized primarily for main-memory execution, but is interfaced with the EXODUS storage manager <ref> [CDRS86] </ref> to provide access to data that is stored on disk. The CORAL system is in the public domain, and a copy of the software can be obtained by contacting the authors.
Reference: [CGK + 90] <author> D. Chimenti, R. Gamboa, R. Krishnamurthy, S. Naqvi, S. Tsur, and C. Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 76-90, </pages> <year> 1990. </year>
Reference: [GGZ92] <author> Sumit Ganguly, Sergio Greco, and Carlo Zaniolo. </author> <title> Greedy by choice. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <year> 1992. </year>
Reference-contexts: Ganguly et al. <ref> [GGZ92] </ref> present another formulation of Prim's 16 The CORAL system no longer supports the choice syntax used in this section.
Reference: [Got74] <author> E. Goto. </author> <title> Monocopy and associative algorithms in an extended lisp. </title> <type> Technical Report 74-03, </type> <institution> Information Science Laboratory, Univ. of Tokyo, </institution> <address> Tokyo, Japan, </address> <month> May </month> <year> 1974. </year>
Reference-contexts: The user would be well advised to make the `==' operator efficient, especially for types that allow large objects. For instance, a user who defines a type similar to terms built out of function symbols would be well advised to implement some form of hash-consing <ref> [Got74, SG76] </ref> on objects of the type, and maintain the hash-cons value along with the object for quick equality checks. This optimization is entirely transparent to the CORAL system.
Reference: [GPSZ91] <author> Fosca Giannotti, Dino Pedreschi, Domenico Sacca, and Carlo Zaniolo. </author> <title> Non-determinism in deductive databases. </title> <editor> In C. Delobel, M. Kifer, and Y. Masunaga, editors, </editor> <booktitle> Proceedings of the Second International Conference on Deductive and Object-Oriented Databases DOOD'91, </booktitle> <address> Munich, Germany, 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We have therefore chosen to support the choice syntax as well. We note that the CORAL version of choice also differs from the version proposed by Giannotti et al. <ref> [GPSZ91] </ref>. The choice construct of [GPSZ91] is different in two ways: (1) The choice can be specified on literals in the rule body, and not just the head literal, and (2) They require that each application of a rule with a choice 17 must be followed by an iteration of the <p> We have therefore chosen to support the choice syntax as well. We note that the CORAL version of choice also differs from the version proposed by Giannotti et al. <ref> [GPSZ91] </ref>. The choice construct of [GPSZ91] is different in two ways: (1) The choice can be specified on literals in the rule body, and not just the head literal, and (2) They require that each application of a rule with a choice 17 must be followed by an iteration of the non-choice rules.
Reference: [GZG92] <author> Sergio Greco, Carlo Zaniolo, and Sumit Ganguly. </author> <title> Greedy by choice. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <year> 1992. </year>
Reference-contexts: However, we believe there are many applications where an arbitrary choice needs to be made for efficiency, and will not affect the answer. In addition to the example above, we find many examples of such choices made in graph algorithms such as depth-first search etc. Greco et al. <ref> [GZG92] </ref> illustrate the utility of local choice in a variety of "greedy" algorithms. Default: No choices are made unless explicitly specified by the user. Interactions: If used in conjunction with Existential Query Optimization or Factoring, choice must be specified on the rewritten program since arities of the predicates could change.
Reference: [KdMS90] <author> G. Kiernan, C. de Maindreville, and E. Simon. </author> <title> Making deductive database a practical technology: a step forward. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <year> 1990. </year> <month> 27 </month>
Reference-contexts: Modules with run-time semantics are also available in several production rule systems (for example, RDL1 <ref> [KdMS90] </ref>). 15 Future Directions A number of issues require further work. These include constraint manipulation, disk-resident data, new data types and operations, user interfaces, inheritance and object orientation. 16 Acknowledgements We would like to acknowledge the contributions of the following people to the CORAL system.
Reference: [KRS90] <author> D. Kemp, K. Ramamohanarao, and Z. Somogyi. Right-, </author> <title> left-, and multi-linear rule transformations that maintain context information. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <pages> pages 380-391, </pages> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference: [Llo87] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: It is well known that the least fixpoint and least model semantics are equivalent for the case of Horn clause logic programs <ref> [Llo87] </ref>. Rules with negative body literals and/or set-grouping in the head are discussed in Sections 4 and 5. 2.3 Arithmetic Operations CORAL provides built-in predicates for equality (=), plus (+), minus (-), times (*), division (/), absolute value (abs), power (pow) and modulus (mod) with the usual meaning.
Reference: [MPR90] <author> Inderpal S. Mumick, Hamid Pirahesh, and Raghu Ramakrishnan. </author> <title> Duplicates and aggregates in deductive databases. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1990. </year>
Reference: [MUVG86] <author> Katherine Morris, Jeffrey D. Ullman, and Allen Van Gelder. </author> <title> Design overview of the NAIL! system. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming, </booktitle> <year> 1986. </year>
Reference: [NRSU89a] <author> Jeffrey F. Naughton, Raghu Ramakrishnan, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Argument reduction through factoring. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Databases, </booktitle> <pages> pages 173-182, </pages> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1989. </year>
Reference: [NRSU89b] <author> Jeffrey F. Naughton, Raghu Ramakrishnan, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Efficient evaluation of right-, left-, and multi-linear rules. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 235-242, </pages> <address> Portland, Oregon, </address> <month> May </month> <year> 1989. </year>
Reference: [NT89] <author> Shamim Naqvi and Shalom Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <booktitle> Principles of Computer Science. </booktitle> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference: [PDR91] <author> Geoffrey Phipps, Marcia A. Derr, and Kenneth A. Ross. </author> <title> Glue-NAIL!: A deductive database system. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 308-317, </pages> <year> 1991. </year>
Reference: [Ram88] <author> Raghu Ramakrishnan. </author> <title> Magic Templates: A spellbinding approach to logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference: [RBK88] <author> Raghu Ramakrishnan, Catriel Beeri, and Ravi Krishnamurthy. </author> <title> Optimizing existential Datalog queries. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 89-102, </pages> <address> Austin, Texas, </address> <month> March </month> <year> 1988. </year>
Reference: [RBSS90] <author> Raghu Ramakrishnan, Per Bothner, Divesh Srivastava, and S. Sudarshan. </author> <title> CORAL: A database programming language. </title> <editor> In Jan Chomicki, editor, </editor> <booktitle> Proceedings of the NACLP `90 Workshop on Deductive Databases, </booktitle> <month> October </month> <year> 1990. </year> <note> Available as Report TR-CS-90-14, </note> <institution> Department of Computing and Information Sciences, Kansas State University. </institution>
Reference-contexts: Indeed, extended C++ code can be used to define predicates, and relations computed through logical rules can be manipulated in extended C++ code, if this is desired. 1 The CORAL project was initiated in 88-89 | under the name Conlog | and an initial overview was presented in <ref> [RBSS90] </ref>. CORAL stands for "COntrol, Relations And Logic". 1 The CORAL design was guided by the following observations: 1. As Kowalski suggested, logic and control are distinct aspects of a program, especially a Horn clause based logic program, and combining them judiciously leads to elegant and efficient programs. 2. <p> Interactions: Pattern form indices only supported on main-memory relations. Indices can be specified on EDB, IDB and persistent relations. 10.2.3 The Choice Operator CORAL provides a version of the choice operator of LDL, but with altogether different semantics <ref> [RBSS90] </ref>. 16 The following example illustrates the use of the choice operator in CORAL.
Reference: [Ros90] <author> Kenneth Ross. </author> <title> Modular Stratification and Magic Sets for DATALOG programs with negation. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 161-171, </pages> <year> 1990. </year>
Reference-contexts: The intuition behind the modular stratification restriction is outlined in the previous paragraph. Henceforth, we will omit the additional qualifiers and simply refer to the above as the class of modularly stratified programs. The following example from <ref> [Ros90] </ref> illustrates the use of modularly stratified negation in a program. Suppose we have a complex mechanism constructed out of a number of components that may themselves be constructed from smaller components. Let the component-of relationship be expressed in the relation part.
Reference: [RSS92a] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Controlling the search in bottom-up evaluation. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <year> 1992. </year>
Reference-contexts: However, the part relation is acyclic, and hence the working status of a component is defined negatively in terms of subcomponents, but not negatively in terms of itself. CORAL provides an evaluation mechanism called Ordered Search <ref> [RSS92a] </ref> that evaluates programs with left-to-right modularly stratified negation efficiently. 5 5 Declarative Language Features: Sets and Multisets Sets and multisets are encountered in CORAL in two distinct forms. First, every relation in CORAL is a set of tuples by default. <p> Ordered Search: Ordered Search is an evaluation mechanism that orders the use of generated subgoals in a program. We do not present full details of Ordered Search here, but refer the reader to <ref> [RSS92a] </ref>. <p> The comparison to the implementation of recursive aggregates in EKS-V1 is very similar to the comparison presented in <ref> [RSS92a] </ref> between Ordered Search and Ross' technique for evaluating modularly stratified programs with negation. In summary, Ordered Search is asymptotically more efficient for programs computing only ground facts. Default: Materialization is used by default, unless the module contains set-grouping or negation. In this case, the default strategy is Ordered Search.
Reference: [RSS92b] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> CORAL: Control, Relations and Logic. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1992. </year>
Reference: [RSS92c] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Efficient bottom-up evaluation of logic programs. </title> <editor> In J. Vandewalle, editor, </editor> <booktitle> The State of the Art in Computer Systems and Software Engineering. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year>
Reference-contexts: This issue is discussed in the next section. 10 Controlling the Evaluation of Declarative Modules Several optimization techniques have been proposed for evaluating declarative modules. Although details are beyond the scope of this paper | <ref> [RSS92c] </ref>) provides an overview of these techniques | we list those that are supported in CORAL and indicate how the user can choose from these techniques to tailor execution.
Reference: [RSSS93] <author> Raghu Ramakrishnan, Praveen Seshadri, Divesh Srivastava, and S. Sudarshan. </author> <title> The CORAL Manual: A tutorial introduction to CORAL. </title> <type> Manuscript., </type> <year> 1993. </year> <month> 28 </month>
Reference-contexts: The CORAL system is in the public domain, and a copy of the software can be obtained by contacting the authors. In addition to this overview, there is a tutorial introduction <ref> [RSSS93] </ref> as well as an on-line help facility. 1.4 A Guide to the Rest of this Overview We begin by presenting some basic definitions for the reader who is unfamiliar with logic programming and deductive database terminology in Section 2. <p> However, the number of copies of an element is significant. Finally, CORAL also supports array terms, implemented using the extensibility features of the system. For more on arrays, see the tutorial introduction <ref> [RSSS93] </ref>. An atom or atomic literal or just literal consists of a predicate/relation name, with a tuple of arguments. Examples are edge (1; 2) and ancestor (X; Y ). <p> This class of programs is discussed in the CORAL tutorial <ref> [RSSS93] </ref>, and in [SSR93]. 5.3 Operations on Multisets The following important restriction in CORAL allows for efficient implementation: A multiset term is restricted to be ground and to match only another (identical) ground multiset term or a variable. <p> More general use of updates requires the use of (extended) C++ code or pipelined modules with embedded commands. (The latter technique is discussed in the tutorial introduction <ref> [RSSS93] </ref>.) Although the semantics of using this operation is in general non-deterministic, there are several classes of programs for which the semantics is deterministic. <p> The CORAL-C++ interface is discussed further in the CORAL tutorial document <ref> [RSSS93] </ref>. 11.1 Embedding CORAL Commands In addition to the interface routines described above, any commands that can be typed in at the CORAL prompt can be embedded in C++ code. In particular, these include set-oriented insert, delete and update commands. The set of CORAL commands is described in the tutorial [RSSS93], <p> <ref> [RSSS93] </ref>. 11.1 Embedding CORAL Commands In addition to the interface routines described above, any commands that can be typed in at the CORAL prompt can be embedded in C++ code. In particular, these include set-oriented insert, delete and update commands. The set of CORAL commands is described in the tutorial [RSSS93], and we refer the reader to this document for details. 12 Extensibility in CORAL The implementation of the declarative language of CORAL is designed to be extensible, i.e., the user can add new types to the system, and can add new implementations of relations and indices, without modifying or recompiling
Reference: [SG76] <author> M. Sassa and E. Goto. </author> <title> A hashing method for fast set operations. </title> <journal> Information Processing Letters, </journal> <volume> 5(4) </volume> <pages> 31-34, </pages> <month> June </month> <year> 1976. </year>
Reference-contexts: The user would be well advised to make the `==' operator efficient, especially for types that allow large objects. For instance, a user who defines a type similar to terms built out of function symbols would be well advised to implement some form of hash-consing <ref> [Got74, SG76] </ref> on objects of the type, and maintain the hash-cons value along with the object for quick equality checks. This optimization is entirely transparent to the CORAL system.
Reference: [SR91] <author> S. Sudarshan and Raghu Ramakrishnan. </author> <title> Aggregation and relevance in deductive databases. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Databases, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: This further reduces the cost of 20 evaluation of a single source shortest path problem from a worst case of O (E V ) to O (E log (V )) 18 (<ref> [SR91] </ref>). This illustrates the importance of aggregate selections and prioritizing the use of facts in a bottom-up evaluation. [SR91] describes a technique to generate such aggregate selections automatically, but aggregate selections could also be specified by the user. We note that the choice annotation is just a special case of an aggregate selection, in which any is used as the aggregation operator.
Reference: [SSR93] <author> S. Sudarshan, Divesh Srivastava, and Raghu Ramakrishnan. </author> <title> Extending the well-founded and valid semantics for aggregation. </title> <note> Submitted for Publication, </note> <year> 1993. </year>
Reference-contexts: This class of programs is discussed in the CORAL tutorial [RSSS93], and in <ref> [SSR93] </ref>. 5.3 Operations on Multisets The following important restriction in CORAL allows for efficient implementation: A multiset term is restricted to be ground and to match only another (identical) ground multiset term or a variable.
Reference: [SSRN91] <author> S. Sudarshan, Divesh Srivastava, Raghu Ramakrishnan, and Jeff Naughton. </author> <title> Space optimization in the bottom-up evaluation of logic programs. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <year> 1991. </year>
Reference-contexts: For a detailed discussion of when facts can be discarded during a bottom-up evaluation, see <ref> [SSRN91] </ref>. The delete operation can thus also be viewed as an annotation of the program to say when facts can be discarded. (Any CORAL commands, including updates, can also be included in rule bodies, but with no guarantee as to execution order, this is not very useful for materialized modules.
Reference: [STZ92] <author> Oded Shmueli, Shalom Tsur, and Carlo Zaniolo. </author> <title> Compilation of set terms in the logic data language (LDL). </title> <journal> Journal of Logic Programming, </journal> 12(1&2):89-120, 1992. 
Reference-contexts: Note that a team containing a single member who is an engineer, a pilot and a doctor would qualify as an ok team. This program is a translation into CORAL of an LDL program from <ref> [STZ92] </ref>; the semantics of the original LDL program required that a team contain at most three members. The addition of count (S; C); C 3 to the body of the rule ensures this. The member predicate is very powerful.
Reference: [VBKL90] <author> L. Vieille, P. Bayer, V. Kuchenhoff, and A. Lefebvre. EKS-V1, </author> <title> a short overview. </title> <booktitle> In AAAI-90 Workshop on Knowledge Base Management Systems, </booktitle> <year> 1990. </year>
Reference: [VRK + 90] <author> Jayen Vaghani, Kotagiri Ramamohanarao, David Kemp, Zoltan Somogyi, and Peter Stuckey. </author> <title> The Aditi deductive database system. </title> <booktitle> In Proceedings of the NACLP'90 Workshop on Deductive Database Systems, </booktitle> <year> 1990. </year> <month> 29 </month>
References-found: 31

