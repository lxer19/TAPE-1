URL: ftp://ftp.cs.man.ac.uk/pub/fac/FACj_7E_pp111-155.ps.Z
Refering-URL: http://www.cs.man.ac.uk/fmethods/facj/e-papers/index.html
Root-URL: http://www.cs.man.ac.uk
Title: of Computing MetateM: An Imperative Approach to Temporal Logic Programming  
Author: H. Barringer M. Fisher D. Gabbay G. Gough and R. Owens 
Keyword: Modal and temporal logics; Reactive systems; Specification; Verification; synthesis; Mechanical verification; Prototyping, Rule-based systems; Non-procedural languages; Logic programming.  
Address: Manchester, Manchester  Manchester  London  London  
Affiliation: 1 Department of Computer Science, University of  Department of Computing, Manchester Metropolitan University,  Department of Computing, Imperial College of Science, Technology and Medicine,  Lehman Brothers Ltd.,  
Note: Formal Aspects of Computing (1995) 7(E): 111-154 c 1995 BCS Formal Aspects  
Email: fhoward,grahamg@cs.man.ac.uk  M.Fisher@doc.mmu.ac.uk  dg@doc.ic.ac.uk  rowens@lehman.com  
Phone: 2  3  4  
Abstract: In this paper a new methodology for the use of temporal logic as an executable imperative language is developed. This work is descended from that presented by Moszkowski [Mos86] and Gabbay [Gab87b, Gab87a] and provides a concrete framework, called MetateM, for executing temporal logics. The approach is illustrated by the development of an execution mechanism for both a propositional temporal logic and a restricted first order temporal logic, together with an outline of implementation strategies and applications. 
Abstract-found: 1
Intro-found: 1
Reference: [All84] <author> Allen, J.F.: </author> <title> Towards a general theory of action and time. </title> <journal> Artificial Intelligence, </journal> <volume> 23(2) </volume> <pages> 123-154, </pages> <year> 1984. </year>
Reference-contexts: These are ITL, developed by Moszkowski for the purpose of modelling digital circuits [Mos83], and Allen's Interval Algebra, developed in order to provide a formal foundation for temporal representation and temporal planning, particularly in AI <ref> [All84] </ref>. Tempura [Mos86, HaM87, Hal87] is an executable temporal logic based upon the forward chaining execution of ITL. In this sense it was the precursor of the MetateM family of languages and provides a simpler and more tractable alternative to these approaches. <p> It provides a powerful system in which a range of applications can be implemented and verified. Hrycej [Hry88, Hry93] describes a completely different Temporal Prolog from Gabbay's (see above), which is based upon interval temporal logic. He extends Prolog using a form of Allen's interval temporal logic <ref> [All84] </ref> and applies it to temporal knowledge representation and temporal planning problems. In addition to the basic Prolog execution mechanism, such a system requires a constraint solver for temporal constraints (not unlike constraint logic programming [JaL87]), though this itself might be implemented in Prolog.
Reference: [AbM89] <author> Abadi, M. and Manna, Z.: </author> <title> Temporal Logic Programming. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 8: </volume> <pages> 277-295, </pages> <year> 1989. </year>
Reference-contexts: Executing Discrete Temporal Logics The main alternative to the imperative reading of discrete temporal logics described in this paper, is to execute such logics using the logic programming paradigm. A form of temporal logic programming, called templog, was defined by Abadi and Manna <ref> [AbM89] </ref> and has subsequently been studied in order to establish it's expressive power and completeness properties [Bau89, Bau92]. A related approach is based upon the temporal extension of intensional logic programming, and is called Chronolog [OrW92b, OrW92a].
Reference: [Bau89] <author> Baudinet, M.: </author> <title> Temporal Logic Programming is Complete and Expressive. </title> <booktitle> In POPL16, </booktitle> <address> Austin, Texas, </address> <month> January </month> <year> 1989. </year> <note> ACM. </note>
Reference-contexts: A form of temporal logic programming, called templog, was defined by Abadi and Manna [AbM89] and has subsequently been studied in order to establish it's expressive power and completeness properties <ref> [Bau89, Bau92] </ref>. A related approach is based upon the temporal extension of intensional logic programming, and is called Chronolog [OrW92b, OrW92a]. Temporal Prolog [Gab91] provides an alternative (to templog) extension of the logic programming paradigm to discrete temporal logics.
Reference: [Bau92] <author> Baudinet, M.: </author> <title> A Simple Proof of the Completeness of Temporal Logic Programming. </title> <editor> In L Fari~nas del Cerro and M. Penttonen, editors, </editor> <title> Intensional Logics for Programming. </title> <publisher> Oxford University Press, </publisher> <year> 1992. </year> <type> 152 H. </type> <institution> Barringer et. al. </institution>
Reference-contexts: A form of temporal logic programming, called templog, was defined by Abadi and Manna [AbM89] and has subsequently been studied in order to establish it's expressive power and completeness properties <ref> [Bau89, Bau92] </ref>. A related approach is based upon the temporal extension of intensional logic programming, and is called Chronolog [OrW92b, OrW92a]. Temporal Prolog [Gab91] provides an alternative (to templog) extension of the logic programming paradigm to discrete temporal logics.
Reference: [BFG89a] <author> Barringer, H., Fisher, M., Gabbay, D., Gough, G., and Owens, R.: </author> <title> MetateM: A Framework for Programming in Temporal Logic. </title> <booktitle> In Proceedings of REX Workshop on Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, Mook, </booktitle> <address> Netherlands, </address> <month> June </month> <year> 1989. </year> <booktitle> (Published in Lecture Notes in Computer Science, </booktitle> <volume> volume 430, </volume> <publisher> Springer Verlag). </publisher>
Reference-contexts: A larger MetateM application is presented in x6, while x7 concludes the paper by reporting on the development of the interpreter, recent extensions to the approach and the authors' current work. This paper is a revised and extended version of <ref> [BFG89a] </ref>, incorporating elements of [BFG91], [FiO92] and [FFO93]. 1.1. Motivation We distinguish several alternative readings or views of logic: declarative, procedural and imperative. The declarative view is the traditional one, manifesting itself both syntactically and semantically. Syntactically, a logical system is taken as being characterised by its set of theorems.
Reference: [BFG89b] <author> Barringer, H., Fisher, M., and Gough, G.: </author> <title> Fair SMG and Linear Time Model Checking. In Proceedings of Workshop on Automatic Verification Methods for Finite State Systems, </title> <address> Grenoble, France, </address> <month> June </month> <year> 1989. </year> <booktitle> (Published in Lecture Notes in Computer Science, </booktitle> <volume> volume 407, </volume> <publisher> Springer-Verlag). </publisher>
Reference-contexts: It means that algorithms can be constructed to determine the validity, or otherwise, of any given PML formula. Thus, for programs whose semantics can be represented by a propositional temporal formula, this result provides an automatic verification method for temporal logic specifications (see, for example, <ref> [LPZ85, BFG89b] </ref>). As we shall see, the decidability of PML is also of importance for "execution". The following Separation Theorem, due to Gabbay in 1980, provides an initial foundation for the MetateM approach. Theorem 2.2.
Reference: [BFG91] <author> Barringer, H., Fisher, M., Gabbay, D. and Hunter, A.: </author> <title> Meta-Reasoning in Executable Temporal Logic. </title> <editor> In J. Allen, R. Fikes, and E. Sandewall, editors, </editor> <booktitle> Proceedings of the International Conference on Principles of Knowledge Representation and Reasoning (KR), </booktitle> <address> Cambridge, Massachusetts, April 1991. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: In x4 a limited first-order temporal logic is introduced and its execution mechanism is described, while x5 provides a brief introduction to the meta-level extensions of the basic system (further details of which can be found in <ref> [BFG91] </ref>). A larger MetateM application is presented in x6, while x7 concludes the paper by reporting on the development of the interpreter, recent extensions to the approach and the authors' current work. This paper is a revised and extended version of [BFG89a], incorporating elements of [BFG91], [FiO92] and [FFO93]. 1.1. <p> which can be found in <ref> [BFG91] </ref>). A larger MetateM application is presented in x6, while x7 concludes the paper by reporting on the development of the interpreter, recent extensions to the approach and the authors' current work. This paper is a revised and extended version of [BFG89a], incorporating elements of [BFG91], [FiO92] and [FFO93]. 1.1. Motivation We distinguish several alternative readings or views of logic: declarative, procedural and imperative. The declarative view is the traditional one, manifesting itself both syntactically and semantically. Syntactically, a logical system is taken as being characterised by its set of theorems. <p> As there is commitment of A (c), carried over from the previous state, A (c) is here set to true and no commitments are carried forward. 5. Meta-Programming in MetateM A further aspect of MetateM is its meta-programming capability. This is developed in more detail in <ref> [BFG91] </ref>, but we here provide a flavour of the approach. 5.1. A Basic Meta-Interpreter for MetateM Consider the simple meta-interpreter for MetateM outlined in Fig. 14. This has been defined by two rules in the appropriate `past implies present and future' rule form. <p> In this section we will briefly consider a possible definition of a basic execute predicate, which is used to execute basic temporal formulae (further details can be found in <ref> [BFG91] </ref>, along with the syntax and semantics of Meta-MetateM-Logic in which the rules below are presented). We will give the basic formulae constraining the execute predicate, which will be used execute basic temporal formulae. This, in turn calls other predicates, such as do, which actually affect the execution.
Reference: [BaG88] <author> Barringer, H. and Gabbay, D.: </author> <title> Executing temporal logic: Review and prospects (Extended Abstract). </title> <booktitle> In Proceedings of Concurrency '88, </booktitle> <year> 1988. </year>
Reference-contexts: Concurrency Although our work on MetateM had shown its utility in the development of a variety of sequential deductive systems, the need for an extended version of MetateM exhibiting concurrency was apparent. Thus, Concurrent MetateM was developed, providing an operational model for concurrently executing, independent MetateM processes <ref> [BaG88, FiB91, Fis93, Fis94] </ref>. These independent processes execute their own MetateM specifications, and are able to communicate with each other through asynchronous broadcast message-passing. The processes themselves are completely autonomous, having control not only over their own execution, but also over their interaction with the environment.
Reference: [Brz95] <author> Brzoska, C.: </author> <title> Temporal Logic Programming with Metric and Past Operators. </title> <editor> In M. Fisher and R. Owens, editors, </editor> <title> Executable Modal and Temproal Logics, </title> <booktitle> volume 897 of Lecture Notes in Artificial Intelligence. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Hiedelberg, Germany, </address> <year> 1995. </year>
Reference-contexts: A related approach is based upon the temporal extension of intensional logic programming, and is called Chronolog [OrW92b, OrW92a]. Temporal Prolog [Gab91] provides an alternative (to templog) extension of the logic programming paradigm to discrete temporal logics. Brzoska <ref> [Brz95] </ref> presents an extension to temporal logic programming of the templog form, incorporating not only past-time operators, but also metric temporal operators.
Reference: [ClE82] <author> Clarke, E.M. and Emerson, </author> <title> E.A.: Using Branching Time Temporal Logic to Syn-thesise Synchronisation Skeletons. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 2 </volume> <pages> 241-266, </pages> <year> 1982. </year>
Reference-contexts: Tang [Tan89], rather than providing an extension of Prolog that incorporates a form of temporal logic, extends the verification method for temporal logic to incorporate logic programming. In particular, the states of a model checker for CTL (a branching-time temporal logic <ref> [ClE82] </ref>) are extended with Prolog like statements. 1.3.2. Interval Temporal Logics Two different forms of interval temporal logics form the basis for programming languages.
Reference: [FiB91] <author> Fisher, M. and Barringer, H.: </author> <title> Concurrent MetateM Processes | A Language for Distributed AI. </title> <booktitle> In Proceedings of the European Simulation Multiconference, </booktitle> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Concurrency Although our work on MetateM had shown its utility in the development of a variety of sequential deductive systems, the need for an extended version of MetateM exhibiting concurrency was apparent. Thus, Concurrent MetateM was developed, providing an operational model for concurrently executing, independent MetateM processes <ref> [BaG88, FiB91, Fis93, Fis94] </ref>. These independent processes execute their own MetateM specifications, and are able to communicate with each other through asynchronous broadcast message-passing. The processes themselves are completely autonomous, having control not only over their own execution, but also over their interaction with the environment.
Reference: [FFO93] <author> Finger, M., Fisher, M. and Owens, R.: </author> <title> MetateM at Work: Modelling Reactive Systems Using Executable Temporal Logic. </title> <booktitle> In Sixth International Conference on Industrial and Engineering Applications of Artificial Intelligence and Expert Systems (IEA/AIE-93), </booktitle> <address> Edinburgh, U.K., June 1993. </address> <publisher> Gordon and Breach Publishers. </publisher>
Reference-contexts: A larger MetateM application is presented in x6, while x7 concludes the paper by reporting on the development of the interpreter, recent extensions to the approach and the authors' current work. This paper is a revised and extended version of [BFG89a], incorporating elements of [BFG91], [FiO92] and <ref> [FFO93] </ref>. 1.1. Motivation We distinguish several alternative readings or views of logic: declarative, procedural and imperative. The declarative view is the traditional one, manifesting itself both syntactically and semantically. Syntactically, a logical system is taken as being characterised by its set of theorems. <p> MetateM for Real MetateM has been applied in a variety of areas such as reactive system simulation, temporal databases, and the modeling of large `real-life' deductive systems <ref> [FFO93, FMO91, ToM90] </ref>. In addition, both program transformation techniques [FiN92] and synthesis algorithms [Noe91] have been developed for MetateM. <p> In addition, both program transformation techniques [FiN92] and synthesis algorithms [Noe91] have been developed for MetateM. To provide a glimpse of how MetateM rules are used in such applications, we will give a brief outline of selected rules used in the simulation of a railway network (adapted from <ref> [FFO93] </ref>). The particular problem here is to model trains moving along lines between stations. We wish to represent such a system as a temporal specification and then, using MetateM, simulate its activity in a variety of different scenarios (configurations of track, initial placement of trains, etc). <p> Along with the initial stations for each train, global information on the type of station and on the direction of a particular train is available. The rules given below relate to simple `blocking' stations (for more details, see <ref> [FFO93] </ref>). * Train entering a station: bcddefff stationT ype (Station; block) ^ entering (T rain; Station; left) 2 signal (Station; lef t; red) ^ inside (T rain; Station) 3 MetateM: An Imperative Approach to Temporal Logic Programming 149 * Train stopped at red light: bcddefff 2 6 6 stationT ype (Station; <p> Due to the MetateM execution mechanism, this permission will be provided as soon as possible. For more details of this application together with a comparison of its representation in Concurrent MetateM, see <ref> [FFO93] </ref>. 150 H. Barringer et. al. Fig. 16. Screen-dump from the `Trains' program. 7. Conclusions and Recent Developments 7.1. <p> Not surprisingly, Concurrent MetateM has been shown to be useful in a variety of applications, particularly those involving reactive systems and Distributed Artificial Intelligence (DAI) <ref> [FFO93, Fis93, FiW93] </ref>. Concurrent MetateM is not a direct extension of MetateM but, although it both restricts the general MetateM model and extends the potential for concurrency, it is still based upon the imperative reading of temporal logic. 7.3.
Reference: [Fis92] <author> Fisher, M.: </author> <title> A Normal Form for First-Order Temporal Formulae. </title> <booktitle> In Proceedings of Eleventh International Conference on Automated Deduction (CADE), </booktitle> <address> Saratoga Springs, New York, </address> <month> June </month> <year> 1992. </year> <booktitle> (Published in Lecture Notes in Computer Science, </booktitle> <volume> volume 607, </volume> <publisher> Springer-Verlag). </publisher>
Reference-contexts: Screen-dump from the `Trains' program. 7. Conclusions and Recent Developments 7.1. Implementations Initial interpreters for MetateM were developed by both Michael Fisher and Richard Owens; this work is reported in more detail in [FiO92], and incorporates the execution of temporal formulae, but based upon a normal form, called SNF <ref> [Fis92] </ref>, rather than arbitrary formulae. The use of this normal form both simplifies the execution mechanism and obviates the need for a separation theorem for the logic (as renaming can be used to transform arbitrary formulae into SNF).
Reference: [Fis93] <author> Fisher, M.: </author> <title> Concurrent MetateM | A Language for Modeling Reactive Systems. </title> <booktitle> In Parallel Architectures and Languages, Europe (PARLE), </booktitle> <address> Munich, Germany, June 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Concurrency Although our work on MetateM had shown its utility in the development of a variety of sequential deductive systems, the need for an extended version of MetateM exhibiting concurrency was apparent. Thus, Concurrent MetateM was developed, providing an operational model for concurrently executing, independent MetateM processes <ref> [BaG88, FiB91, Fis93, Fis94] </ref>. These independent processes execute their own MetateM specifications, and are able to communicate with each other through asynchronous broadcast message-passing. The processes themselves are completely autonomous, having control not only over their own execution, but also over their interaction with the environment. <p> Not surprisingly, Concurrent MetateM has been shown to be useful in a variety of applications, particularly those involving reactive systems and Distributed Artificial Intelligence (DAI) <ref> [FFO93, Fis93, FiW93] </ref>. Concurrent MetateM is not a direct extension of MetateM but, although it both restricts the general MetateM model and extends the potential for concurrency, it is still based upon the imperative reading of temporal logic. 7.3.
Reference: [Fis94] <author> Fisher, M.: </author> <title> A Survey of Concurrent MetateM | The Language and its Applications. </title> <booktitle> In First International Conference on Temporal Logic (ICTL), </booktitle> <address> Bonn, Germany, </address> <month> July </month> <year> 1994. </year> <booktitle> (Published in Lecture Notes in Computer Science, </booktitle> <volume> volume 827, </volume> <publisher> Springer-Verlag). </publisher>
Reference-contexts: Concurrency Although our work on MetateM had shown its utility in the development of a variety of sequential deductive systems, the need for an extended version of MetateM exhibiting concurrency was apparent. Thus, Concurrent MetateM was developed, providing an operational model for concurrently executing, independent MetateM processes <ref> [BaG88, FiB91, Fis93, Fis94] </ref>. These independent processes execute their own MetateM specifications, and are able to communicate with each other through asynchronous broadcast message-passing. The processes themselves are completely autonomous, having control not only over their own execution, but also over their interaction with the environment.
Reference: [FKT86] <author> Fujita, M., Kono, S., Tanaka, T. and Moto-oka, T.: Tokio: </author> <title> Logic Programming Language based on Temporal Logic and its compilation into Prolog. </title> <booktitle> In 3rd International Conference on Logic Programming, </booktitle> <address> London, </address> <month> July </month> <year> 1986. </year> <booktitle> (Published in Lecture Notes in Computer Science, </booktitle> <volume> volume 225, </volume> <publisher> Springer-Verlag). </publisher>
Reference-contexts: Tempura [Mos86, HaM87, Hal87] is an executable temporal logic based upon the forward chaining execution of ITL. In this sense it was the precursor of the MetateM family of languages and provides a simpler and more tractable alternative to these approaches. Tokio <ref> [FKT86] </ref> is a logic programming language based on the extension of Prolog with ITL formulae. It provides a powerful system in which a range of applications can be implemented and verified.
Reference: [FMO91] <author> Finger, M., McBrien, P. and Owens, R.: </author> <title> Databases and Executable Temporal Logic. </title> <booktitle> In Proceedings of the ESPRIT Conference, </booktitle> <month> November </month> <year> 1991. </year>
Reference-contexts: MetateM for Real MetateM has been applied in a variety of areas such as reactive system simulation, temporal databases, and the modeling of large `real-life' deductive systems <ref> [FFO93, FMO91, ToM90] </ref>. In addition, both program transformation techniques [FiN92] and synthesis algorithms [Noe91] have been developed for MetateM.
Reference: [FiN92] <author> Fisher, M. and Noel, P.: </author> <title> Transformation and Synthesis in MetateM Part I: Propositional MetateM. </title> <type> Technical Report UMCS-92-2-1, </type> <institution> Department of Computer Science, University of Manchester, </institution> <address> Oxford Road, Manchester M13 9PL, U.K., </address> <month> February </month> <year> 1992. </year>
Reference-contexts: MetateM for Real MetateM has been applied in a variety of areas such as reactive system simulation, temporal databases, and the modeling of large `real-life' deductive systems [FFO93, FMO91, ToM90]. In addition, both program transformation techniques <ref> [FiN92] </ref> and synthesis algorithms [Noe91] have been developed for MetateM. To provide a glimpse of how MetateM rules are used in such applications, we will give a brief outline of selected rules used in the simulation of a railway network (adapted from [FFO93]). <p> Synthesis of MetateM Programs One of the main performance problems with MetateM programs is when a large amount of backtracking occurs. Thus, just as in logic programming where synthesis procedures have been developed in order to reduce non-determinism, semiautomatic temporal synthesis procedures have been investigated for MetateM programs <ref> [Noe91, FiN92] </ref>. Initial results for propositional MetateM programs are promising and further work is planned towards the reduction of non-determinism in full first-order MetateM programs. 8.
Reference: [FiO92] <author> Fisher, M. and Owens, R.: </author> <title> From the Past to the Future: Executing Temporal Logic Programs. </title> <booktitle> In Proceedings of Logic Programming and Automated Reasoning (LPAR), </booktitle> <address> St. Petersberg, Russia, </address> <month> July </month> <year> 1992. </year> <booktitle> (Published in Lecture Notes in Computer Science, </booktitle> <volume> volume 624, </volume> <publisher> Springer-Verlag). </publisher>
Reference-contexts: A larger MetateM application is presented in x6, while x7 concludes the paper by reporting on the development of the interpreter, recent extensions to the approach and the authors' current work. This paper is a revised and extended version of [BFG89a], incorporating elements of [BFG91], <ref> [FiO92] </ref> and [FFO93]. 1.1. Motivation We distinguish several alternative readings or views of logic: declarative, procedural and imperative. The declarative view is the traditional one, manifesting itself both syntactically and semantically. Syntactically, a logical system is taken as being characterised by its set of theorems. <p> For example, all moments have fork AL and fork AR true, but the first two moments have eaten A false. The first few steps of a trace produced by a prototype MetateM interpreter <ref> [FiO92] </ref> are given in Figure 6. In the first step, the interpreter sets fork AL true but fork AR false. Since both forks have not been held by the philosopher for the last two moments, eaten A must be made false and the satisfaction of eaten A must be postponed. <p> As mentioned previously this critical condition can be detected in a number of ways. The prototype <ref> [FiO92] </ref> uses a loop check mechanism described in x3.4. Again, these are precisely the cases when there is no extension to oe h that will yield a model for . Note that 1 above is the computation induction step. Lemma 3.2. <p> Barringer et. al. Fig. 16. Screen-dump from the `Trains' program. 7. Conclusions and Recent Developments 7.1. Implementations Initial interpreters for MetateM were developed by both Michael Fisher and Richard Owens; this work is reported in more detail in <ref> [FiO92] </ref>, and incorporates the execution of temporal formulae, but based upon a normal form, called SNF [Fis92], rather than arbitrary formulae.
Reference: [Fru95] <author> Fruhwirth, T.: </author> <title> Temporal Logic and Annotated Constraint Logic Programming. </title> <editor> In M. Fisher and R. Owens, editors, </editor> <title> Executable Modal and Temproal Logics, </title> <booktitle> volume 897 of Lecture Notes in Artificial Intelligence. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Hiedelberg, Germany, </address> <year> 1995. </year>
Reference-contexts: In addition to the basic Prolog execution mechanism, such a system requires a constraint solver for temporal constraints (not unlike constraint logic programming [JaL87]), though this itself might be implemented in Prolog. Fruhwirth <ref> [Fru95] </ref> outlines another method for implementing interval temporal logics as an extension to logic programming, this time by defining a temporal 118 H. Barringer et. al.
Reference: [FiW93] <author> Fisher, M. and Wooldridge, M.: </author> <title> Executable Temporal Logic for Distributed A.I. </title> <booktitle> In Twelfth International Workshop on Distributed A.I., </booktitle> <address> Hidden Valley Resort, Pennsylvania, </address> <month> May </month> <year> 1993. </year> <title> MetateM: An Imperative Approach to Temporal Logic Programming 153 </title>
Reference-contexts: Not surprisingly, Concurrent MetateM has been shown to be useful in a variety of applications, particularly those involving reactive systems and Distributed Artificial Intelligence (DAI) <ref> [FFO93, Fis93, FiW93] </ref>. Concurrent MetateM is not a direct extension of MetateM but, although it both restricts the general MetateM model and extends the potential for concurrency, it is still based upon the imperative reading of temporal logic. 7.3.
Reference: [Gab87a] <author> Gabbay, D.: </author> <title> Declarative Past and Imperative Future: Executable Temporal Logic for Interactive Systems. </title> <editor> In B. Banieqbal, H. Barringer, and A. Pnueli, editors, </editor> <booktitle> Proceedings of Colloquium on Temporal Logic in Specification, </booktitle> <pages> pages 402-450, </pages> <address> Altrincham, U.K., </address> <year> 1987. </year> <booktitle> (Published in Lecture Notes in Computer Science, </booktitle> <volume> volume 398, </volume> <publisher> Springer-Verlag). </publisher>
Reference-contexts: 1. Introduction The purpose of this paper is twofold: 1. to further develop the methodology of temporal logic as an executable imperative language, presented by Moszkowski [Mos86] and Gabbay <ref> [Gab87b, Gab87a] </ref>; Correspondence and offprint requests to: Michael Fisher, Department of Computing, Manch ester Metropolitan University, Chester Street, Manchester M1 5GD, UK. 112 H. <p> In spite of this, there has been no conceptual methodological recognition of the imperative paradigm in the community, nor has there been a systematic attempt to develop and bring this paradigm forward as a new and powerful logical approach in computing. The logic USF, defined by Gabbay <ref> [Gab87a] </ref>, was a first attempt at promoting the imperative view as a methodology. In this paper, we present a more refined language based on this imperative view of temporal logic. 1.2. <p> logics (we assume we have a fully expressive set of connectives) to rewrite the specification ' in the form ^ (' i ) i 2 ) where ' i is a pure past formula, i 1 is a boolean expression of atoms and i 2 is a pure future formula <ref> [Gab87a] </ref>. As we have seen above, there may be various ways of separating the original formula '. The exact rewrite formulation requires an understanding of the application area. This is where the ingenuity of the programmer is needed. <p> Proof: See <ref> [Gab87a] </ref>, for example. From the above result, it follows that: Theorem 2.3.
Reference: [Gab87b] <author> Gabbay, D.: </author> <title> Modal and Temporal Logic Programming. </title> <booktitle> In Colloquium on Temporal Logic: Circulated Papers. </booktitle> <institution> Department of Computer Science, Manchester, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: 1. Introduction The purpose of this paper is twofold: 1. to further develop the methodology of temporal logic as an executable imperative language, presented by Moszkowski [Mos86] and Gabbay <ref> [Gab87b, Gab87a] </ref>; Correspondence and offprint requests to: Michael Fisher, Department of Computing, Manch ester Metropolitan University, Chester Street, Manchester M1 5GD, UK. 112 H.
Reference: [Gab91] <author> Gabbay, D.: </author> <title> Modal and Temporal Logic II (A Temporal Prolog Machine). </title> <editor> In T. Dodd, R. Owens, and S. Torrance, editors, </editor> <booktitle> Logic Programming|Expanding the Horizon. </booktitle> <publisher> Intellect Books Ltd, </publisher> <year> 1991. </year>
Reference-contexts: A related approach is based upon the temporal extension of intensional logic programming, and is called Chronolog [OrW92b, OrW92a]. Temporal Prolog <ref> [Gab91] </ref> provides an alternative (to templog) extension of the logic programming paradigm to discrete temporal logics. Brzoska [Brz95] presents an extension to temporal logic programming of the templog form, incorporating not only past-time operators, but also metric temporal operators.
Reference: [Gou84] <author> Gough, G.D.: </author> <title> Decision Procedures for Temporal Logic. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Manchester, </institution> <month> October </month> <year> 1984. </year>
Reference-contexts: Other temporal definitions. The definition of validity is as in classical logic. Definition 2.3. A formula ' is said to be valid, j= ', if and only if it is validated by all models oe. Theorem 2.1. Validity in PML is decidable. Proof: See <ref> [Gou84] </ref>, for example. This decidability result is important. It means that algorithms can be constructed to determine the validity, or otherwise, of any given PML formula.
Reference: [Hal87] <author> Hale, R.: </author> <title> Temporal Logic Programming. </title> <editor> In A. Galton, editor, </editor> <booktitle> Temporal Logics and their Applications, chapter 3, </booktitle> <pages> pages 91-119. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <month> December </month> <year> 1987. </year>
Reference-contexts: These are ITL, developed by Moszkowski for the purpose of modelling digital circuits [Mos83], and Allen's Interval Algebra, developed in order to provide a formal foundation for temporal representation and temporal planning, particularly in AI [All84]. Tempura <ref> [Mos86, HaM87, Hal87] </ref> is an executable temporal logic based upon the forward chaining execution of ITL. In this sense it was the precursor of the MetateM family of languages and provides a simpler and more tractable alternative to these approaches.
Reference: [HaM87] <author> Hale, R. and Moszkowski, B.: </author> <title> Parallel programming in temporal logic. </title> <booktitle> In Parallel Architectures and Languages Europe (PARLE), </booktitle> <address> Eindhoven, The Netherlands, </address> <month> June </month> <year> 1987. </year> <booktitle> (Published as Lecture Notes in Computer Science, </booktitle> <volume> volume 259, </volume> <publisher> Springer Verlag, Berlin.). </publisher>
Reference-contexts: These are ITL, developed by Moszkowski for the purpose of modelling digital circuits [Mos83], and Allen's Interval Algebra, developed in order to provide a formal foundation for temporal representation and temporal planning, particularly in AI [All84]. Tempura <ref> [Mos86, HaM87, Hal87] </ref> is an executable temporal logic based upon the forward chaining execution of ITL. In this sense it was the precursor of the MetateM family of languages and provides a simpler and more tractable alternative to these approaches.
Reference: [Hry88] <author> Hrycej, T.: </author> <title> Temporal Prolog. </title> <editor> In Yves Kodratoff, editor, </editor> <booktitle> Proceedings of the Eu-ropean Conference on Artificial Intelligence, </booktitle> <pages> pages 296-301. </pages> <publisher> Pitman Publishing, </publisher> <month> August </month> <year> 1988. </year>
Reference-contexts: Tokio [FKT86] is a logic programming language based on the extension of Prolog with ITL formulae. It provides a powerful system in which a range of applications can be implemented and verified. Hrycej <ref> [Hry88, Hry93] </ref> describes a completely different Temporal Prolog from Gabbay's (see above), which is based upon interval temporal logic. He extends Prolog using a form of Allen's interval temporal logic [All84] and applies it to temporal knowledge representation and temporal planning problems.
Reference: [Hry93] <author> Hrycej, T.: </author> <title> A temporal extension of Prolog. </title> <journal> The Journal of Logic Programming, </journal> <volume> 15(1 </volume> & 2):113-145, January 1993. 
Reference-contexts: Tokio [FKT86] is a logic programming language based on the extension of Prolog with ITL formulae. It provides a powerful system in which a range of applications can be implemented and verified. Hrycej <ref> [Hry88, Hry93] </ref> describes a completely different Temporal Prolog from Gabbay's (see above), which is based upon interval temporal logic. He extends Prolog using a form of Allen's interval temporal logic [All84] and applies it to temporal knowledge representation and temporal planning problems.
Reference: [JaL87] <author> Jaffir, J. and Lassez, J.-L.: </author> <title> Constraint Logic Programming. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 111-119, </pages> <address> Munich, West Germany, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: He extends Prolog using a form of Allen's interval temporal logic [All84] and applies it to temporal knowledge representation and temporal planning problems. In addition to the basic Prolog execution mechanism, such a system requires a constraint solver for temporal constraints (not unlike constraint logic programming <ref> [JaL87] </ref>), though this itself might be implemented in Prolog. Fruhwirth [Fru95] outlines another method for implementing interval temporal logics as an extension to logic programming, this time by defining a temporal 118 H. Barringer et. al.
Reference: [LiP85] <author> Lichtenstein, O. and Pnueli, A.: </author> <title> Checking that Finite State Concurrent Programs Satisfy their Linear Specification. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on the Principles of Programming Languages, </booktitle> <address> New Orleans, Louisiana, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: A coarse bound can be given by the number of different states that appear in the semantic tableau for the program formula, f . This bound is 2 5jfj where jf j is the length of the formula f <ref> [LiP85] </ref>. (Note that such a bound can not be established where arbitrary environment interaction occurs.) It can be shown that the execution mechanism described in x3.5 satisfies any satisfiable eventuality within such a fixed number of states. 3 Note that the satisfiability directed choice of binding described above would not help
Reference: [LPZ85] <author> Lichtenstein, O., Pnueli, A. and Zuck, L.: </author> <title> The Glory of the Past. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 193 </volume> <pages> 196-218, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: It means that algorithms can be constructed to determine the validity, or otherwise, of any given PML formula. Thus, for programs whose semantics can be represented by a propositional temporal formula, this result provides an automatic verification method for temporal logic specifications (see, for example, <ref> [LPZ85, BFG89b] </ref>). As we shall see, the decidability of PML is also of importance for "execution". The following Separation Theorem, due to Gabbay in 1980, provides an initial foundation for the MetateM approach. Theorem 2.2.
Reference: [Mer95] <author> Merz, S.: </author> <title> Efficiently Executable Temporal Logic Programs. </title> <editor> In M. Fisher and R. Owens, editors, </editor> <title> Executable Modal and Temproal Logics, </title> <booktitle> volume 897 of Lecture Notes in Artificial Intelligence. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Hiedelberg, Germany, </address> <year> 1995. </year>
Reference-contexts: He gives the correctness of the logic programming system in his framework and shows how it can be translated into a constraint logic programming system over an appropriate algebra. Merz <ref> [Mer95] </ref> discusses the issues involved in the tradeoff between efficiency and expressiveness in the execution of temporal formulae. In particular, he defines a class of temporal logic formulae, which is both sufficiently abstract to support high-level descriptions of algorithms and, yet, whose model construction problem is tractable.
Reference: [Mos83] <author> Moszkowski, B.: </author> <title> Reasoning about digital circuits. </title> <type> Technical report, </type> <institution> Stanford University, </institution> <month> July </month> <year> 1983. </year>
Reference-contexts: Interval Temporal Logics Two different forms of interval temporal logics form the basis for programming languages. These are ITL, developed by Moszkowski for the purpose of modelling digital circuits <ref> [Mos83] </ref>, and Allen's Interval Algebra, developed in order to provide a formal foundation for temporal representation and temporal planning, particularly in AI [All84]. Tempura [Mos86, HaM87, Hal87] is an executable temporal logic based upon the forward chaining execution of ITL.
Reference: [Mos86] <author> Moszkowski, B.: </author> <title> Executing Temporal Logic Programs. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, U.K., </address> <year> 1986. </year>
Reference-contexts: 1. Introduction The purpose of this paper is twofold: 1. to further develop the methodology of temporal logic as an executable imperative language, presented by Moszkowski <ref> [Mos86] </ref> and Gabbay [Gab87b, Gab87a]; Correspondence and offprint requests to: Michael Fisher, Department of Computing, Manch ester Metropolitan University, Chester Street, Manchester M1 5GD, UK. 112 H. <p> These are ITL, developed by Moszkowski for the purpose of modelling digital circuits [Mos83], and Allen's Interval Algebra, developed in order to provide a formal foundation for temporal representation and temporal planning, particularly in AI [All84]. Tempura <ref> [Mos86, HaM87, Hal87] </ref> is an executable temporal logic based upon the forward chaining execution of ITL. In this sense it was the precursor of the MetateM family of languages and provides a simpler and more tractable alternative to these approaches.
Reference: [MaW84] <author> Manna, Z. and Wolper, P.: </author> <title> Synthesis of communicating processes from temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(1), </volume> <month> January </month> <year> 1984. </year>
Reference-contexts: Related Work The study of temporal and modal logics in the formal development of reactive systems has, in the main, been concentrated on techniques for specification and verification. On a related theme, there have been investigations into the synthesis of programs from temporal logic based specifications, for example <ref> [MaW84] </ref> and more recently [PnR89a, PnR89b]. The direct execution of temporal logic itself has been studied by a variety of researchers over the past decade.
Reference: [Noe91] <author> Noel, </author> <title> P.A.: A Method for the Determinisation of Propositional Temporal Formulae. </title> <editor> In T. Clement and K. Lau, editors, </editor> <booktitle> Proceedings of Workshop on Logic Program Synthesis and Transformation (LOPSTR), </booktitle> <address> Manchester, U.K., July 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: MetateM for Real MetateM has been applied in a variety of areas such as reactive system simulation, temporal databases, and the modeling of large `real-life' deductive systems [FFO93, FMO91, ToM90]. In addition, both program transformation techniques [FiN92] and synthesis algorithms <ref> [Noe91] </ref> have been developed for MetateM. To provide a glimpse of how MetateM rules are used in such applications, we will give a brief outline of selected rules used in the simulation of a railway network (adapted from [FFO93]). <p> Synthesis of MetateM Programs One of the main performance problems with MetateM programs is when a large amount of backtracking occurs. Thus, just as in logic programming where synthesis procedures have been developed in order to reduce non-determinism, semiautomatic temporal synthesis procedures have been investigated for MetateM programs <ref> [Noe91, FiN92] </ref>. Initial results for propositional MetateM programs are promising and further work is planned towards the reduction of non-determinism in full first-order MetateM programs. 8.
Reference: [OrW92a] <author> Orgun, M. and Wadge, W.: </author> <title> Theory and Practice of Temporal Logic Programming. </title> <editor> In L Fari~nas del Cerro and M. Penttonen, editors, </editor> <title> Intensional Logics for Programming. </title> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: A form of temporal logic programming, called templog, was defined by Abadi and Manna [AbM89] and has subsequently been studied in order to establish it's expressive power and completeness properties [Bau89, Bau92]. A related approach is based upon the temporal extension of intensional logic programming, and is called Chronolog <ref> [OrW92b, OrW92a] </ref>. Temporal Prolog [Gab91] provides an alternative (to templog) extension of the logic programming paradigm to discrete temporal logics. Brzoska [Brz95] presents an extension to temporal logic programming of the templog form, incorporating not only past-time operators, but also metric temporal operators.
Reference: [OrW92b] <author> Orgun, M.A. and Wadge, </author> <title> W.W.: Towards a unified theory of intensional logic programming. </title> <journal> The Journal of Logic Programming, </journal> <volume> 13(1, 2, 3 and </volume> 4):413-440, 1992. 
Reference-contexts: A form of temporal logic programming, called templog, was defined by Abadi and Manna [AbM89] and has subsequently been studied in order to establish it's expressive power and completeness properties [Bau89, Bau92]. A related approach is based upon the temporal extension of intensional logic programming, and is called Chronolog <ref> [OrW92b, OrW92a] </ref>. Temporal Prolog [Gab91] provides an alternative (to templog) extension of the logic programming paradigm to discrete temporal logics. Brzoska [Brz95] presents an extension to temporal logic programming of the templog form, incorporating not only past-time operators, but also metric temporal operators.
Reference: [PnR89a] <author> Pnueli, A. and Rosner, R.: </author> <title> On the Synthesis of a Reactive Module. </title> <booktitle> In Proceedings of the 16th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 179-190, </pages> <year> 1989. </year>
Reference-contexts: On a related theme, there have been investigations into the synthesis of programs from temporal logic based specifications, for example [MaW84] and more recently <ref> [PnR89a, PnR89b] </ref>. The direct execution of temporal logic itself has been studied by a variety of researchers over the past decade.
Reference: [PnR89b] <author> Pnueli, A. and Rosner, R.: </author> <title> On the Synthesis of an Asynchronous Reactive Module. </title> <booktitle> In Proceedings of the 16th International Colloquium on Automata, Languages and Programs, </booktitle> <year> 1989. </year> <type> 154 H. </type> <institution> Barringer et. al. </institution>
Reference-contexts: On a related theme, there have been investigations into the synthesis of programs from temporal logic based specifications, for example [MaW84] and more recently <ref> [PnR89a, PnR89b] </ref>. The direct execution of temporal logic itself has been studied by a variety of researchers over the past decade.
Reference: [Tan89] <author> Tang, T.G.: </author> <title> Temporal Logic CTL + Prolog. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5 </volume> <pages> 49-65, </pages> <year> 1989. </year>
Reference-contexts: Merz [Mer95] discusses the issues involved in the tradeoff between efficiency and expressiveness in the execution of temporal formulae. In particular, he defines a class of temporal logic formulae, which is both sufficiently abstract to support high-level descriptions of algorithms and, yet, whose model construction problem is tractable. Tang <ref> [Tan89] </ref>, rather than providing an extension of Prolog that incorporates a form of temporal logic, extends the verification method for temporal logic to incorporate logic programming. In particular, the states of a model checker for CTL (a branching-time temporal logic [ClE82]) are extended with Prolog like statements. 1.3.2.
Reference: [ToM90] <author> Torsun, </author> <title> I.S. and Manning, K.J.: Execution and Application of Temporal Modal Logic. </title> <type> Internal Report, </type> <institution> Department of Computing, University of Bradford, U.K., </institution> <year> 1990. </year> <title> (Part of the Alvey final report on the Logic Database Demonstrator Project). </title> <note> Received July 1994 Accepted in revised form June 1995 by D. J. Cooke </note>
Reference-contexts: MetateM for Real MetateM has been applied in a variety of areas such as reactive system simulation, temporal databases, and the modeling of large `real-life' deductive systems <ref> [FFO93, FMO91, ToM90] </ref>. In addition, both program transformation techniques [FiN92] and synthesis algorithms [Noe91] have been developed for MetateM.
References-found: 43

