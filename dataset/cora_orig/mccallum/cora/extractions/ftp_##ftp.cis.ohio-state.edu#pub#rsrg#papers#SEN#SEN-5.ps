URL: ftp://ftp.cis.ohio-state.edu/pub/rsrg/papers/SEN/SEN-5.ps
Refering-URL: http://www.cis.ohio-state.edu/~weide/rsrg/bib-overview.html
Root-URL: 
Title: Part V: Annotated Bibliography of RESOLVE Research References An Approach for Constructing Reusable Software Components
Author: Stephen H. Edwards [Edwards ] Edwards, S., 
Web: URL is: http://www.cis.ohio-state.edu/hypertext/rsrg/RSRG.html  
Date: 19, 4 (OCT. 1994), 64-67.  
Note: SOFTWARE ENGINEERING NOTES  More information on RESOLVE, including access to these and other documents and a demonstration component archive, is available through WorldWide Web. The  IDA paper P-2378, Institute for Defense Analyses, Alexandria, VA, Sept. 1990. Available from NTIS (phone: 703-487-4650), access number AD-A233 662.  
Abstract: This brief annotated bibliography describes a select subset of the RESOLVE literature, focusing on the most accessible references for the interested reader who would like to learn more about RESOLVE. A more complete bibliography of RESOLVE papers is available by anonymous FTP from host ftp.cis.ohio-state.edu in the file pub/rsrg/RESOLVE-refs.txt. Most of the papers in this list that are not published in journals or major conference proceedings can be ordered from the National Technical Information Service (NTIS) or from University Microfilms (UMI), as noted, or are available electronically. PostScript versions of all Ohio State University technical reports listed (mostly preprints of papers to appear and recent Ph.D. dissertations) are available by anonymous FTP from ftp.cis.ohio-state.edu in the directory pub/tech-report. Documents available at this location are marked in the bibliography with [OSU-FTP]. Similarly, many of the papers appearing in the various Workshops on Software Reuse (WISRs) are available by anonymous FTP. These files can be found at the WISR archive maintained at the University of Maine, host gandalf.umcs.maine.edu, in the directory pub/WISR. Documents available at this location are marked with [WISR-FTP]. This report discusses reusable software in Ada. It concentrates on many of the technical problems involved in designing software components, and introduces what amounts to an early version of the RESOLVE/Ada discipline [Hollingsworth 92b]. It also contains a significant number of Ada code examples. 
Abstract-found: 1
Intro-found: 0
Reference: [Edwards 90] <author> Edwards, S., </author> <title> An Approach for Constructing Reusable Software Components in Ada, </title> <type> IDA paper P-2378, </type> <institution> Institute for Defense Analyses, </institution> <address> Alexandria, VA, </address> <month> Sept. </month> <year> 1990. </year> <title> Available from NTIS (phone: 703-487-4650), access number AD-A233 662. This report discusses reusable software in Ada. It concentrates on many of the technical problems involved in designing software components, and introduces what amounts to an early version of the RESOLVE/Ada discipline [Hollingsworth 92b]. It also contains a significant number of Ada code examples. </title> <type> 2 </type>
Reference: [Edwards 93a] <author> Edwards, S.H., </author> <title> Inheritance: One Mechanism, Many Conflicting Uses, </title> <booktitle> Proc. 6th Ann. Workshop on Software Reuse, </booktitle> <editor> L. Latour, ed., </editor> <month> Nov. </month> <year> 1993. </year> <title> [WISR-FTP]. This position paper argues that most objectoriented languages inappropriately define inheritance as a (single) programming mechanism, although it is used for many diverse conceptual purposes. Conflicts between different uses of inheritance lead to many of the problems associated with it. Separating out the various uses for inheritance by using distinct language mechanisms is one approach to eliminating these conflicts and the difficulties they bring. </title>
Reference: [Edwards 93b] <author> Edwards, S.H., </author> <title> Common Interface Models for Reusable Software, </title> <journal> Intl. J. of Software Eng. and Knowledge Eng. </journal> <volume> 3, </volume> <month> 2 (June </month> <year> 1993), </year> <month> 193-206. </month> <title> This article presents an informal, natural language description of the notion of an abstraction over several families of components, here called a common interface model (CIM). CIMs can be used to capture common patterns that recur across many modules, for both programmatic and human uses. This notion is similar to the more formal notion of theories in OBJ, but there are some critical differences. </title>
Reference: [Edwards 94] <author> Edwards, S.H., </author> <title> A Formal Model of Software Subsystems. </title> <type> Ph.D. </type> <institution> diss., Dept. of Comp. and Inf. Sci., Ohio State Univ., Columbus, </institution> <month> Dec. </month> <year> 1994, </year> <title> to appear. This dissertation presents a mathematically formal, language-independent model of software components that captures many intuitive notions about reusable software parts that practitioners have observed through experience. This model is compared with the languagespecific models embodied in OBJ, RESOLVE, Eiffel, and Standard ML, as well as the 3C model. The RESOLVE formal semantics is now based on this model. </title>
Reference: [Ernst 91] <author> Ernst, G.W., Hookway, R.J., Menegay, J.A., and Ogden, W.F., </author> <title> Modular Verification of Ada Generics, </title> <journal> Comp. Lang. </journal> <volume> 16, </volume> <month> 3/4 </month> <year> (1991), </year> <month> 259-280. </month> <title> This paper describes the foundation that is necessary to verify that a generic component is correct, once and for all, without knowing how it is instantiated. It concentrates on the expressiveness issues that make this a tough technical problem. </title> <type> 3 </type>
Reference: [Ernst 94] <author> Ernst, G.W., Hookway, R.J., and Ogden, W.F., </author> <title> Modular Verification of Data Abstractions with Shared Realizations, </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 20, </volume> <month> 4 (Apr. </month> <year> 1994), </year> <month> 288-307. </month> <title> This paper gives a method for modularly specifying and verifying data abstractions where multiple abstract objects share a common implementation-level data structure. Such implementations allow for very efficient use of memory or other resources, but complicate modular verification. The paper also discusses the model that serves as the basis for RESOLVEs formal semantics. </title>

Reference: [Harms 91] <author> Harms, D.E., and Weide, B.W., </author> <title> Copying and Swapping: Influences on the Design of Reusable Software Components, </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 17, </volume> <month> 5 (May </month> <year> 1991), </year> <month> 424-435. </month> <title> This paper discusses many of the fundamental RESOLVE ideas, including the method of modeling program types by mathematical types; the difficulties with assignment as the built-in data movement operator; and the benefits of basing designs on swapping, especially for generic ADTs. </title>
Reference: [Heym 94a] <author> Heym, W.D., Long, T.J., Ogden, W.F., and Weide, B.W., </author> <title> Mathematical Foundations and Notation of RESOLVE. </title> <institution> OSU-CISRC-8/94-TR45, Dept. of Comp. and Inf. Sci., Ohio State Univ., Columbus, </institution> <month> Aug. </month> <year> 1994. </year> <title> [OSU-FTP]. This paper discusses the logical foundations and teminology of RESOLVE, the built-in RESOLVE notation for writing mathematics, and the RESOLVE mechanisms that support description of mathematics that has no built-in notation. It is intended to serve primarily as a reference document. </title> <type> 4 </type>
Reference: [Heym 94b] <author> Heym, W.D., </author> <title> Computer Program Verification: Improvements for Human Reasoning. </title> <type> Ph.D. </type> <institution> diss., Dept. of Comp. and Inf. Sci., Ohio State Univ., Columbus, </institution> <month> Dec. </month> <year> 1994, </year> <note> to appear. This dissertation formalizes, </note> <editor> in a direct, </editor> <title> natural way, the informal pattern of reasoning generally used with programs written in modular, imperative languages such as RESOLVE. The formal semantics provides a solid basis against which to check the soundness and (relative) completeness of a formal proof system (in this case, the indexed method; see [Krone 88] for another method). </title>
Reference: [Hollingsworth 92a] <author> Hollingsworth, J.E., and Weide, B.W., </author> <title> Engineering Unbounded Reusable Ada Generics, </title> <booktitle> Proc 10th Ann. Natl. Conf. on Ada Tech., </booktitle> <address> ANCOST, </address> <publisher> Inc., </publisher> <month> Feb. </month> <year> 1992, </year> <month> 82-97. </month> <title> This paper introduces one of the RESOLVE abstractions that replaces pointers and shows how to use it. It also explains several implementation options for the abstraction and their relative advantages, and provides some Ada code examples. </title>

Reference: [Krone 88] <author> Krone, J., </author> <title> The Role of Verification in Software Reusability. </title> <type> Ph.D. </type> <institution> diss., Dept. of Comp. and Inf. Sci., Ohio State Univ., Columbus, </institution> <month> Aug. </month> <year> 1988. </year> <title> Available from UMI (phone: 800-521-0600). This work describes the verification rules that form the basis for RESOLVEs original syntax-driven verification procedure. In addition to basic rules for straight-line code and procedure calls, the rules cover conceptual modules, realization modules, and module instantiation. An example of a proof of total correctness for a complete component that is layered on top of another component is given. </title> <type> 5 </type>
Reference: [Krone 93] <author> Krone, J., and Sitaraman, M., </author> <title> On Modularity and Tightness of Real-Time Verification, Real-Time Newsletter 9, </title> <booktitle> 1/2 (Spring/Summer 1993), </booktitle> <pages> 109-115. </pages> <booktitle> Also in Proc. 10th IEEE Workshop on Real-Time Operating Systems and Software, IEEE, </booktitle> <month> May </month> <year> 1993. </year> <title> This paper discusses several problems arising from attempts to modularly verify tight execution-time bounds, and the importance of this objective for software components used in real-time applications. </title>
Reference: [Muralidharan 90] <author> Muralidharan, S., and Weide, B.W., </author> <title> Should Data Abstraction Be Violated to Enhance Software Reuse?, </title> <booktitle> Proc. 8th Ann. Natl. Conf. on Ada Tech., </booktitle> <address> ANCOST, </address> <publisher> Inc., </publisher> <month> Mar. </month> <year> 1990, </year> <month> 515-524. </month> <title> This paper discusses some problems involved in using a hypothetical code inheritance construct of Ada, showing why it does not effectively support reuse. Some Ada code examples are included, which reflect an early RESOLVE/Ada style. </title>
Reference: [Parrish 91] <author> Parrish, A., and Zweben, S.H. </author> <title> Analysis and Refinement of Software Test Data Adequacy Properties, </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 17, </volume> <month> 6 (June </month> <year> 1991), </year> <month> 565-581. </month> <title> This paper discusses component-based software testing from the standpoint of test data adequacy. </title>
Reference: [Sitaraman 92a] <author> Sitaraman, M., </author> <title> A Class of Mechanisms to Facilitate Multiple Implementations of a Specification, </title> <booktitle> Proc. 1992 Intl. Conf. on Comp. Lang., IEEE, </booktitle> <month> Apr. </month> <year> 1992, </year> <month> 182-191. </month> <title> The paper motivates the need for, and ramifications of, language features supporting multiple implementations of the same abstract specification. A class of mechanisms (not supported in current languages) to independently name, reference, and parameterize specifications and implementations are identified as essential to facilitate development and use of multiple implementations. </title> <type> 6 </type>
Reference: [Sitaraman 92b] <author> Sitaraman, M. </author> <title> Performance-Parameterized Reusable Software Components, </title> <journal> Intl. J. of Software Eng. and Knowledge Eng. </journal> <volume> 2, </volume> <month> 4 (Oct. </month> <year> 1992), </year> <month> 567-587. </month> <title> This article describes how components can be parameterized by the lower-level abstractions they depend on, in order to provide greater performance flexibility and escape the combinatorial explosion problem that arises when these alternatives are not parameterized. By parameterizing components so that any appropriate lower-level constituent components can be simply plugged in, inexpensive and flexible performance tuning is provided to a client without requiring any form of component source code modification, recompilation, </title> <address> or reverification. </address>
Reference: [Sitaraman 92c] <author> Sitaraman, M., </author> <title> A Uniform Treatment of Reusability of Software Engineering Assets, </title> <booktitle> Proc. 5th Ann. Workshop on Software Reuse, </booktitle> <editor> L. Latour, ed., </editor> <month> Oct. </month> <year> 1992. </year> <title> [WISR-FTP]. The paper enhances the 3C model with constraints, which contain nonfunctional specifications (e.g., performance constraints). It explains the applicability of the 4C model to all software lifecycle artifacts from requirements documents to code components. </title>
Reference: [Sitaraman 93] <author> Sitaraman, M., Welch, </author> <title> L.R., and Harms, D.E., On Specification of Reusable Software Components, </title> <journal> Intl. J. of Software Eng. and Knowledge Eng. </journal> <volume> 3, </volume> <month> 2 (June </month> <year> 1993), </year> <month> 207-229. </month> <title> This article provides an overview of RESOLVE from a specification perspective, comparing it to Z and Larch. It explains why component specifications must be formal yet understandable, as well as abstract and implementation-independent. Each specification also must make it possible to demonstrate the correctness of an implementation of the specification and permit formal reasoning about its behavior in a client program. </title>
Reference: [Sitaraman 94] <author> Sitaraman, M., </author> <title> On Tight Performance Specification of Object-Oriented Software Components, </title> <booktitle> Proc. 1994 Intl. Conf. on Software Reuse, IEEE, </booktitle> <month> Nov. </month> <year> 1994, </year> <title> to appear. This paper points out why specification of performance should appear not with an abstract components functional specification or with a concrete components implementation, but in an implementation-related module that lies between them. One of the reasons for this conclusion is an expressiveness problem: Performance specifications may need to involve intermediate mathematical models to permit expression of tight performance specifications while preserving information hiding. </title> <type> 7 </type>
Reference: [Weide 91] <author> Weide, B.W., Ogden, W.F., and Zweben, S.H. </author> <title> Reusable Software Components, </title> <booktitle> in Advances in Computers, </booktitle> <volume> vol. 33, </volume> <editor> M.C. Yovits, ed., </editor> <publisher> Academic Press, </publisher> <year> 1991, </year> <month> 1-65. </month> <title> This book chapter provides an overview of the software engineering approach used in RESOLVE. It describes the general model of software structure and the related 3C model, several basic concept design principles, and some simple examples; and briefly compares the RESOLVE approach to component engineering with those used frequently in Ada, C++, and Eiffel. </title>
Reference: [Weide 92] <author> Weide, B.W., and Hollingsworth, </author> <title> J.E., Scalability of Reuse Technology to Large Systems Requires Local Certifiability, </title> <booktitle> Proc. 5th Ann. Workshop on Software Reuse, </booktitle> <editor> L. Latour, ed., </editor> <month> Oct. </month> <year> 1992. </year> <title> [WISR-FTP]. This position paper explains why software components must be certified once upon entry into a component library, and not once per use, if the most important benefits of reuse are to be achieved; that it, it argues for the importance of local certifiability to reuse. </title>
Reference: [Weide 93] <author> Weide, B.W., Heym, W.D., and Ogden, W.F., </author> <title> Procedure Calls and Local Certifiability of Component Correctness, </title> <booktitle> Proc. 6th Ann. Workshop on Software Reuse, </booktitle> <editor> L. Latour, ed., </editor> <month> Nov. </month> <year> 1993. </year> <title> [WISR-FTP]. This position paper discusses how common practices involving procedure calls (e.g., in Ada and C++) thwart modular reasoning about component behavior. It also discusses previous approaches to dealing with these problems at a formal level, and argues that call-by-swapping as a parameter-passing mechanism eliminates the difficulties. </title>
Reference: [Weide 94a] <author> Weide, B.W., and Hollingsworth, </author> <title> J.E., On Local Certifiability of Software Components. </title> <institution> OSU-CISRC-1/94-TR04, Dept. of Comp. and Inf. Sci., Ohio State Univ., Columbus, </institution> <month> Jan. </month> <year> 1994. </year> <title> [OSU-FTP]. This report discusses probably the most fundamental objective of the RESOLVE approach: to be able to reason about the behavior of component-built programs in a modular fashion. It is easy reading for someone not familiar with RESOLVE, and it is a good place to start if you are interested in the RESOLVE approach to verification. </title> <type> 8 </type>

Reference: [Weide 94c] <author> Weide, B.W., Ogden, W.F., and Sitaraman, M., </author> <title> Recasting Algorithms to Encourage Reuse, </title> <booktitle> IEEE Software 11, </booktitle> <address> 5 (Sept. </address> <year> 1994). </year> <title> This paper describes a technique for extending objectoriented component design by recasting algorithms as objects (called machines), thereby improving both functional and performance flexibility. It is written for an audience unfamiliar with RESOLVE, but the examples are nontrivial: a novel sorting component and a component to find minimum spanning forests in graphs. </title>
Reference: [Zweben 92] <author> Zweben, S.H., Heym, W.D., and Kimmich, J., </author> <title> Systematic Testing of Data Abstractions Based on Software Specifications, J. of Software Testing, Verification and Reliability 1, 4 (1992), 39-55. This paper shows how to adapt conventional white-box strategies to test components specified in a RESOLVE-like manner. The strategy then becomes specification-based, rather than code-based. Theoretical and empirical evaluations of this approach are discussed. </title>
Reference: [Zweben 94] <author> Zweben, S.H., Edwards, S.H., Weide, B.W., and Hollingsworth, </author> <title> J.E., The Effects of Layering and Encapsulation on Software Development Cost and Quality, </title> <institution> OSU-CISRC-4/94-TR21, Dept. of Comp. and Inf. Sci., Ohio State Univ., Columbus, </institution> <month> Apr. </month> <year> 1994. </year> <title> [OSU-FTP]. Submitted for publication; currently in revision. This report discusses three controlled experiments designed to gather empirical evidence supporting the practice of layering newly written code on top of earlier encapsulated components, rather than simply adding code to old modules. The results of the experiments support the contention that layering significantly reduces the effort required to build new components. </title>
References-found: 26

