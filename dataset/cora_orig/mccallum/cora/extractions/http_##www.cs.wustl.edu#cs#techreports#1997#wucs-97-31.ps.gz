URL: http://www.cs.wustl.edu/cs/techreports/1997/wucs-97-31.ps.gz
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: 
Email: fharrison,levine,schmidtg@cs.wustl.edu  
Title: The Design and Performance of a Real-time CORBA Event Service  
Author: Timothy H. Harrison, David L. Levine, and Douglas C. Schmidt 
Date: December 2, 1997  
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science, Washington University  
Abstract: This paper will appear in the Proceedings of the OOPSLA '97 conference, Atlanta, Georgia, October, 1997. It is available from the Washington University, St. Louis, Department of Computer Science, as Technical Report #WUCS-97-31. Abstract The CORBA Event Service provides a flexible model for asynchronous communication among objects. However, the standard CORBA Event Service specification lacks important features required by real-time applications. For instance, operational flight programs for fighter aircraft have complex real-time processing requirements. This paper describes the design and performance of an object-oriented, real-time implementation of the CORBA Event Service that is designed to meet these requirements. This paper makes three contributions to the design and performance measurement of object-oriented real-time systems. First, it illustrates how to extend the CORBA Event Service so that it is suitable for real-time systems. These extensions support periodic rate-based event processing and efficient event filtering and correlation. Second, it describes how to develop object-oriented event dispatching and scheduling mechanisms that can provide real-time guarantees. Finally, the paper presents benchmarks that demonstrate the performance tradeoffs of alternative concurrent dispatching mechanisms for real-time Event Services. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> References </institution>
Reference: [1] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.0 ed., </editor> <month> July </month> <year> 1995. </year>
Reference-contexts: However, many real-time application domains (such as avionics, telecommunications, process control, and distributed interactive simulation) can benefit from flexible and open distributed object computing architectures, such as those defined in the CORBA specification <ref> [1] </ref>. 1.1 Overview of CORBA CORBA is a distributed object computing middleware standard being defined by the Object Management Group (OMG).
Reference: [2] <author> S. Vinoski, </author> <title> "CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments," </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 14, </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: OMG Reference Model architecture <ref> [2] </ref>: At the heart of the OMG Reference Model is the Object Request Broker (ORB).
Reference: [3] <author> D. C. Schmidt, A. Gokhale, T. Harrison, and G. Parulkar, </author> <title> "A High-Performance Endsystem Architecture for Real-time CORBA," </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 14, </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: ORBs allow clients to invoke operations on target object implementations without concern for where the object resides, what language the object is written in, the OS/hardware platform, or the type of communication protocols and networks used to interconnect distributed objects <ref> [3] </ref>. This paper focuses on the CORBA Event Service, which is defined within the CORBA Object Services (COS) component in Figure 1. The COS specification [4] presents architectural models and interfaces that factor 1 out common services for developing distributed applications. <p> To alleviate the limitations with the standard COS Event Service, we have developed a Real-time Event Service (RT Event Service) as part of the TAO project <ref> [3] </ref> at Washington University. TAO is a real-time ORB endsys-tem that provides end-to-end quality of service guarantees to applications by vertically integrating CORBA middle-ware with OS I/O subsystems, communication protocols, and network interfaces. Figure 2 illustrates the key architectural components in TAO and their relationship to the real-time Event Service. <p> Our approach is based on emerging distributed object computing standards (i.e., CORBA) we focus on the design and performance of various strategies for implementing QoS in real-time ORBs <ref> [3] </ref>. The QuO project at BBN [18] has defined a model for communicating changes in QoS characteristics between applications, middleware, and the underlying endsystems and network. <p> Chief among these missing features include real-time event dispatching and scheduling, periodic event processing, and centralized event filtering and correlations. To resolve these limitations, we have developed a Real-time Event Service (RT Event Service) as part of the TAO project <ref> [3] </ref>. TAO's RT Event Service ex tends the COS Event Service specification to satisfy the quality of service (QoS) needs of real-time applications in domains like avionics, telecommunications, and process control. <p> The current design of the Dispatching Module is motivated largely from need to support a single host, real-time event propagation mechanism. To allow all CORBA applications to utilize the ORB's real-time scheduling and dispatching features, we are integrating the role of the Dispatching Module into TAO's Real-time Object Adapter <ref> [3] </ref>. However, this paper focuses on an implementation that integrates real-time dispatching into TAO's Real-time Event Service. 4.1.2 Scheduling Enforcement The real-time scheduling for the version of TAO's Event Channel described in this paper is performed off-line. Therefore, no mechanisms for enforcing component behavior are provided.
Reference: [4] <institution> Object Management Group, </institution> <month> CORBAServices: </month> <title> Common Object Services Specification, </title> <note> Revised Edition, </note> <editor> 95-3-31 ed., </editor> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: This paper focuses on the CORBA Event Service, which is defined within the CORBA Object Services (COS) component in Figure 1. The COS specification <ref> [4] </ref> presents architectural models and interfaces that factor 1 out common services for developing distributed applications. Many distributed applications exchange asynchronous requests using event-based execution models [5]. To support these common use-cases, the CORBA Event Service defines supplier and consumer participants.
Reference: [5] <author> R. Rajkumar, M. Gagliardi, and L. Sha, </author> <title> "The Real-Time Publisher/Subscriber Inter-Process Communication Model for Distributed Real-Time Systems: </title> <booktitle> Design and Implementation," in First IEEE Real-Time Technology and Applications Symposium, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: The COS specification [4] presents architectural models and interfaces that factor 1 out common services for developing distributed applications. Many distributed applications exchange asynchronous requests using event-based execution models <ref> [5] </ref>. To support these common use-cases, the CORBA Event Service defines supplier and consumer participants. Suppliers generate events and consumers process events received from suppliers. In addition, the CORBA Event Service defines an Event Channel, which is a mediator [6] that propagates events to consumers on behalf of suppliers. <p> SunSoft [19] describes techniques for optimizing the performance of CORBA Event Service implementations. As with QuO, their focus also was not on guaranteeing CPU processing for events with hard real-time deadlines. Rajkumar, et al., describe a real-time publisher/subscriber prototype developed at CMU SEI <ref> [5] </ref>. Their Publisher/Subscriber model is functionally similar to the COS Event Service, though it uses real-time threads to prevent priority inversion within the communication framework.
Reference: [6] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Many distributed applications exchange asynchronous requests using event-based execution models [5]. To support these common use-cases, the CORBA Event Service defines supplier and consumer participants. Suppliers generate events and consumers process events received from suppliers. In addition, the CORBA Event Service defines an Event Channel, which is a mediator <ref> [6] </ref> that propagates events to consumers on behalf of suppliers. The OMG Event Service model simplifies application software by allowing decoupled suppliers and consumers, asynchronous event delivery, and distributed group communication [7]. In theory, this model seems to address many common needs of event-based, real-time applications. <p> Sensor Proxies push I/O events to the channel without having to know which I/O Facades depend on the data. The benefit of using the Event Channel is that Sensor Proxies are unaffected when I/O Facades are added or removed. This architectural decoupling is described concisely by the Observer pattern <ref> [6] </ref>. Another benefit of an Event Channel-based architecture is that an I/O Facade need not know which Sensor Proxies supply its data.
Reference: [7] <author> S. Maffeis, </author> <title> "Adding Group Communication and Fault-Tolerance to CORBA," </title> <booktitle> in Proceedings of the Confer 19 ence on Object-Oriented Technologies, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: In addition, the CORBA Event Service defines an Event Channel, which is a mediator [6] that propagates events to consumers on behalf of suppliers. The OMG Event Service model simplifies application software by allowing decoupled suppliers and consumers, asynchronous event delivery, and distributed group communication <ref> [7] </ref>. In theory, this model seems to address many common needs of event-based, real-time applications. In practice, however, the standard CORBA Event Service specification lacks other important features required by real-time applications such as real-time event dispatching and scheduling, periodic event processing, and efficient event filtering and correlation mechanisms.
Reference: [8] <author> C. Liu and J. Layland, </author> <title> "Scheduling Algorithms for Multiprogramming in a Hard-Real-Time Environment," </title> <journal> JACM, </journal> <volume> vol. 20, </volume> <pages> pp. 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: Figure 2 illustrates the key architectural components in TAO and their relationship to the real-time Event Service. TAO's RT Event Service augments the CORBA Event Service model by providing source-based and type-based filtering, event correlations, and real-time dispatching. To facilitate real-time scheduling (e.g., rate monotonic <ref> [8] </ref>), TAO's RT Event Channels can be configured to support various strategies for priority-based event dispatching and preemption. This functionality is implemented for High-Performance, Real-time CORBA. using a real-time dispatching mechanism that coordinates with a system-wide real-time Scheduling Service. <p> Windows NT also provides real-time threads, though it lacks certain features required for hard real-time systems [9]. 1.2 Related Work Conventional approaches to quality of service (QoS) enforcement have typically adopted existing solutions from the domain of real-time scheduling, <ref> [8] </ref>, fair queuing in network routers [10], or OS support for continuous media applications [11]. In addition, there have been efforts to implement new concurrency mechanisms for real-time processing (such as the real-time threads of Mach [12] and real-time CPU scheduling priorities of Solaris [13]). <p> Once Task Interdependency Compilation is complete, the Off-line Scheduler assigns priorities to each object op eration. The implementation of the Event Service described in this paper utilizes a rate monotonic scheduling (RMS) policy <ref> [8, 26] </ref>. Therefore, priorities are assigned based on task rates, i.e., higher priorities are assigned to threads with faster rates.
Reference: [9] <author> M. Timmerman and J.-C. Monfret, </author> <title> "Windows NT as Real-Time OS?," Real-Time Magazine, </title> <note> 2Q 1997. http://www.realtime-info.be/encyc/magazine/97q2/- winntasrtos.htm. </note>
Reference-contexts: TAO's RT Event Service runs on real-time OS platforms (e.g., VxWorks and Solaris 2.x) that provide real-time scheduling guarantees to application threads. Windows NT also provides real-time threads, though it lacks certain features required for hard real-time systems <ref> [9] </ref>. 1.2 Related Work Conventional approaches to quality of service (QoS) enforcement have typically adopted existing solutions from the domain of real-time scheduling, [8], fair queuing in network routers [10], or OS support for continuous media applications [11].
Reference: [10] <author> L. Zhang, "VirtualClock: </author> <title> A New Traffic Control Algorithm for Packet Switched Networks," </title> <booktitle> in Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), </booktitle> <address> (Philadelphia, PA), </address> <pages> pp. 19-29, </pages> <publisher> ACM, </publisher> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Windows NT also provides real-time threads, though it lacks certain features required for hard real-time systems [9]. 1.2 Related Work Conventional approaches to quality of service (QoS) enforcement have typically adopted existing solutions from the domain of real-time scheduling, [8], fair queuing in network routers <ref> [10] </ref>, or OS support for continuous media applications [11]. In addition, there have been efforts to implement new concurrency mechanisms for real-time processing (such as the real-time threads of Mach [12] and real-time CPU scheduling priorities of Solaris [13]).
Reference: [11] <author> G. Coulson, G. Blair, J.-B. Stefani, F. Horn, and L. </author> <title> Hazard, "Supporting the Real-time Requirements of Continuous Media in Open Distributed Processing," </title> <booktitle> Computer Networks and ISDN Systems, </booktitle> <pages> pp. 1231-1246, </pages> <year> 1995. </year>
Reference-contexts: provides real-time threads, though it lacks certain features required for hard real-time systems [9]. 1.2 Related Work Conventional approaches to quality of service (QoS) enforcement have typically adopted existing solutions from the domain of real-time scheduling, [8], fair queuing in network routers [10], or OS support for continuous media applications <ref> [11] </ref>. In addition, there have been efforts to implement new concurrency mechanisms for real-time processing (such as the real-time threads of Mach [12] and real-time CPU scheduling priorities of Solaris [13]).
Reference: [12] <author> H. Tokuda, T. Nakajima, and P. Rao, </author> <title> "Real-Time Mach: Towards Predictable Real-time Systems," </title> <booktitle> in USENIX Mach Workshop, USENIX, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: In addition, there have been efforts to implement new concurrency mechanisms for real-time processing (such as the real-time threads of Mach <ref> [12] </ref> and real-time CPU scheduling priorities of Solaris [13]). However, QoS research at the network and OS layers has not necessarily addressed key requirements and usage characteristics of distributed object computing mid-dleware.
Reference: [13] <author> S. Khanna and et. al., </author> <title> "Realtime Scheduling in SunOS 5.0," </title> <booktitle> in Proceedings of the USENIX Winter Conference, </booktitle> <pages> pp. 375-390, </pages> <publisher> USENIX Association, </publisher> <year> 1992. </year>
Reference-contexts: In addition, there have been efforts to implement new concurrency mechanisms for real-time processing (such as the real-time threads of Mach [12] and real-time CPU scheduling priorities of Solaris <ref> [13] </ref>). However, QoS research at the network and OS layers has not necessarily addressed key requirements and usage characteristics of distributed object computing mid-dleware. For instance, research on QoS for network infrastructure has focused largely on policies for allocating bandwidth on a per-connection basis. <p> Furthermore, there was no other significant activity on the workstation during testing. All tests were run in the So-laris real-time scheduling class, so they had the highest software priority (but below hardware interrupts) <ref> [13] </ref>. With the single-threaded Event Channel, we measured a best-case supplier-to-consumer latency of ~90 secs. "Best-case" refers to a single supplier and single consumer registered with Event Channel. The supplier received a timeout every 250 milliseconds and then sent a times-tamped event to the consumer.
Reference: [14] <institution> Object Management Group, Notification Service Request For Proposal, OMG Document telecom/97-01-03 ed., </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: Unfortunately, since the CORBA Event Service specification does not address issues critical for real-time applications, these implementations are not acceptable solutions for many domains. The OMG has issued a request for proposals (RFP) on a new Notification Service <ref> [14] </ref> that has generated several responses [15].
Reference: [15] <institution> Object Management Group Telecommunications Domain Task Force, "Notification Service RFP (Telecom RFP3)," </institution> <year> 1997. </year>
Reference-contexts: Unfortunately, since the CORBA Event Service specification does not address issues critical for real-time applications, these implementations are not acceptable solutions for many domains. The OMG has issued a request for proposals (RFP) on a new Notification Service [14] that has generated several responses <ref> [15] </ref>. The RFP specifies that a proposed Notification Service must be a superset of the COS Event Service with interfaces for the following features: event filtering, event delivery semantics (e.g., at least once, at most once, etc.), security, event channel federations, and event delivery QoS.
Reference: [16] <author> D. C. Schmidt and S. Vinoski, </author> <title> "Object Interconnections: Overcoming Drawbacks in the OMG Events Service," </title> <journal> C++ Report, </journal> <volume> vol. 9, </volume> <month> July-August </month> <year> 1997. </year>
Reference-contexts: The organizations contributing to this effort have done some excellent work in addressing many of the shortcomings of the CORBA Event Service <ref> [16] </ref>. However, the OMG RFP documents do not address the implementation issues related to the Notification Service. Although there has been research on formalisms for real-time objects [17], relatively little published research on the design and performance of real-time OO systems exists.
Reference: [17] <author> I. Satoh and M. Tokoro, </author> <title> "Time and Asynchrony in Interactions among Distributed Real-Time Objects," </title> <booktitle> in Proceedings of 9th European Conference on Object-Oriented Programming, </booktitle> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: The organizations contributing to this effort have done some excellent work in addressing many of the shortcomings of the CORBA Event Service [16]. However, the OMG RFP documents do not address the implementation issues related to the Notification Service. Although there has been research on formalisms for real-time objects <ref> [17] </ref>, relatively little published research on the design and performance of real-time OO systems exists. Our approach is based on emerging distributed object computing standards (i.e., CORBA) we focus on the design and performance of various strategies for implementing QoS in real-time ORBs [3].
Reference: [18] <author> J. A. Zinky, D. E. Bakken, and R. Schantz, </author> <title> "Architectural Support for Quality of Service for CORBA Objects," </title> <journal> Theory and Practice of Object Systems, </journal> <volume> vol. 3, no. 1, </volume> <year> 1997. </year>
Reference-contexts: Our approach is based on emerging distributed object computing standards (i.e., CORBA) we focus on the design and performance of various strategies for implementing QoS in real-time ORBs [3]. The QuO project at BBN <ref> [18] </ref> has defined a model for communicating changes in QoS characteristics between applications, middleware, and the underlying endsystems and network. The QuO architecture differs from our work on RT Event Channels, however, since QuO does not provide hard real-time guarantees of ORB endsystem CPU scheduling.
Reference: [19] <author> Y. Aahlad, B. Martin, M. Marathe, and C. Lee, </author> <title> "Asynchronous Notification Among Distributed Objects," </title> <booktitle> in Proceedings of the 2 nd Conference on Object-Oriented Technologies and Systems, </booktitle> <institution> (Toronto, Canada), USENIX, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: The QuO architecture differs from our work on RT Event Channels, however, since QuO does not provide hard real-time guarantees of ORB endsystem CPU scheduling. SunSoft <ref> [19] </ref> describes techniques for optimizing the performance of CORBA Event Service implementations. As with QuO, their focus also was not on guaranteeing CPU processing for events with hard real-time deadlines. Rajkumar, et al., describe a real-time publisher/subscriber prototype developed at CMU SEI [5].
Reference: [20] <author> A. Gokhale and D. C. Schmidt, </author> <title> "The Performance of the CORBA Dynamic Invocation Interface and Dynamic Skeleton Interface over High-Speed ATM Networks," </title> <booktitle> in Proceedings of GLOBECOM '96, </booktitle> <address> (London, England), </address> <pages> pp. 50-56, </pages> <publisher> IEEE, </publisher> <month> November </month> <year> 1996. </year>
Reference-contexts: Moreover, standard oneway invocations might not implement reliable delivery and deferred synchronous invocations require the use of the CORBA Dynamic Invocation Interface (DII), which yields excessive overhead for most real-time applications <ref> [20] </ref>. The Event Service is a CORBA Object Service that is designed to alleviate some of the restrictions with standard CORBA invocation models. In particular, the COS 3 Event Service supports asynchronous message delivery and allows one or more suppliers to send messages to one or more consumers.
Reference: [21] <author> D. C. Schmidt, </author> <title> "ACE: an Object-Oriented Framework for Developing Distributed Applications," </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Massachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: These administration objects make it possible to connect and disconnect consumers and suppliers to the channel. Internally, the channel is comprised of several processing modules based on the ACE Streams framework <ref> [21] </ref>. As described below, each module encapsulates independent tasks of the channel. * Consumer Proxy Module: The interface to the Consumer Proxy Module is identical to ConsumerAdmin interface defined in the COS Event Service CosEventChannelAdmin module. It provides factory methods for creating objects that support the ProxyPushSupplier interface. <p> TAO's Real-time Scheduling Service architecture was submitted as a response to the OMG Real-time Special Interest Group Request for Information on Real-time CORBA [22]. The current implementation of TAO's Real-time Event Service is written in C++ using components from the ACE framework <ref> [21] </ref>. ACE is a widely used communication framework that contains a rich set of high-performance components. These components automate common communication software tasks such as connection establishment, event demultiplexing and event handler dispatching, message routing, dynamic configuration of services, and flexible concurrency control for network services.
Reference: [22] <author> D. C. Schmidt, D. L. Levine, and T. H. Harrison, </author> <title> "An ORB Endsystem Architecture for Hard Real-Time Scheduling," </title> <month> Feb. </month> <year> 1997. </year> <note> Submitted to OMG in response to RFI ORBOS/96-09-02. </note>
Reference-contexts: Adding filtering to the Event Channel requires a well-defined type system for events. Although the complete schema for this type system is beyond the scope of this paper, it includes source ID, type, data, and timestamp fields (the schema is fully described in <ref> [22] </ref>). The RT Event Channel uses the event type system in the following ways: 1. Supplier-based filtering Not all consumers that connect to an Event Channel are interested in the same events. In this case, consumers only register for events generated by certain suppliers. <p> In addition, our results illustrate that it is feasible to apply CORBA Object Services to develop real-time systems. TAO's Real-time Scheduling Service architecture was submitted as a response to the OMG Real-time Special Interest Group Request for Information on Real-time CORBA <ref> [22] </ref>. The current implementation of TAO's Real-time Event Service is written in C++ using components from the ACE framework [21]. ACE is a widely used communication framework that contains a rich set of high-performance components.
Reference: [23] <author> R. E. Barkley and T. P. Lee, </author> <title> "A Heap-Based Callout Implementation to Meet Real-Time Needs," </title> <booktitle> in Proceedings of the USENIX Summer Conference, </booktitle> <pages> pp. 213-222, </pages> <publisher> USENIX Association, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: When a consumer registers for a timeout, the Priority Timers Proxy cooperates with the Run-time Scheduler to ensure that timeouts are dispatched according to the priority of their corresponding consumer. The Priority Timers Proxy uses a heap-based callout queue <ref> [23] </ref>. Therefore, in the average and worst case, the time required to schedule, cancel, and expire a timer is O (log N) (where N is the total number of timers). The timer mechanism preallocates all its memory, which eliminates the need for dynamic memory allocation at run-time.
Reference: [24] <author> J.-B. Stefani, </author> <title> "Requirements for a real-time ORB," </title> <type> tech. rep., ReTINA, </type> <year> 1996. </year>
Reference-contexts: In these contexts, it may be unacceptable to completely terminate a running Event Channel when a scheduling or concurrency policy is updated. In general, therefore, an RT Event Channel framework must support dynamic reconfiguration of policies without interruption while continuing to service communication operations <ref> [24] </ref>. Basing TAO's RT Event Channel on the ACE Streams framework supports both static and dynamic (re)configuration. 4 An Object-Oriented Framework for Real-time Event Service Dispatching and Scheduling Applications and middleware components using a real-time Event Service have deterministic and statistical deadlines.
Reference: [25] <author> R. Gopalakrishnan and G. Parulkar, </author> <title> "Bringing Real-time Scheduling Theory and Practice Closer for Multimedia Computing," </title> <booktitle> in SIGMETRICS Conference, </booktitle> <address> (Philadel-phia, PA), </address> <publisher> ACM, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: This requires that consumers cooperatively preempt themselves when a higher priority consumer becomes runnable. This model of "deferred preemption" is based on a Real-time Upcall (RTU) concurrency mechanism <ref> [25] </ref>. The primary benefit of the RTU model is its ability to reduce the context switching, synchronization, and data movement overhead incurred by preemptive multi-threading implementations. However, preemption is delayed to the extent that consumers check to see if they must preempt themselves. <p> An important metric for evaluating the performance 14 of the RT Event Service is the schedulable bound. The schedulable bound of a real-time schedule is the maximum resource utilization possible without deadlines being missed <ref> [25] </ref>. Likewise, the schedulable bound of the RT Event Service is the maximum CPU utilization that supplier and consumers can achieve without missing deadlines. For TAO's Real-time Scheduling Service to guarantee the schedulability of a system (i.e., all tasks meet their deadlines), high priority tasks must preempt lower priority tasks.
Reference: [26] <author> M. H. Klein, T. Ralya, B. Pollak, R. Obenza, and M. G. Harbour, </author> <title> A Practitioner's Handbook for Real-Time Analysis: Guide to Rate Monotonic Analysis for Real-Time Systems. </title> <publisher> Norwell, </publisher> <address> Massachusetts: </address> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Once Task Interdependency Compilation is complete, the Off-line Scheduler assigns priorities to each object op eration. The implementation of the Event Service described in this paper utilizes a rate monotonic scheduling (RMS) policy <ref> [8, 26] </ref>. Therefore, priorities are assigned based on task rates, i.e., higher priorities are assigned to threads with faster rates.
Reference: [27] <author> S. Porat, D. Bernstein, Y. Fedorov, J. Rodrigue, and E. Yahav, </author> <title> "Compiler Optimization of C++ Virtual Function Calls," </title> <booktitle> in Proceedings of the 2 nd Conference on Object-Oriented Technologies and Systems, </booktitle> <institution> (Toronto, Canada), USENIX, </institution> <month> June </month> <year> 1996. </year> <month> 20 </month>
Reference-contexts: Our experience has been that this is not an impediment to real-time system performance, though we avoid virtual methods where not needed. Furthermore, modern compilers implement strategies for replacing indirect virtual method calls with direct non-virtual calls <ref> [27] </ref>. The results for the IRIX C++ and Microsoft VC++ compilers indicate well-optimized virtual method calls. 6.2 The Cost of Polymorphism Polymorphism facilitates run-time changes in object behavior. Real-time systems often require predictable behavior of all components.
References-found: 28

