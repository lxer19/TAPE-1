URL: ftp://ftp.fas.sfu.ca/pub/cs/han/dood/qnjn.ps
Refering-URL: http://fas.sfu.ca/cs/research/groups/DB/sections/publication/dood/dood.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fhan, lingliu, tlug@cs.sfu.ca  
Title: Evaluation of Declarative N-Queens Recursion: A Deductive Database Approach  
Author: Jiawei Han, Ling Liu and Tong Lu 
Keyword: Declarative programming, logic programming, deductive database, search, constraint-based process ing, query evaluation, implementation techniques.  
Address: Burnaby, B.C., Canada V5A 1S6  
Affiliation: School of Computing Science Simon Fraser University  
Abstract: Can we evaluate a logic program declaratively? That is, can a logic program be evaluated correctly and efficiently, independent of query modes and rule/predicate ordering, finding a complete set of answers, and terminating properly? The answer could be "yes", at least for a good subclass of logic programs, based on our investigation and experimentation using a deductive database approach. In this paper, an n-queens problem, a classical logic program, is used as a running example to demonstrate the methodology. Our analysis shows that binding analysis and constraint exploration are two essential issues in the realization of declarative logic programming. The limitations of our methodology are also discussed in the paper. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proc. 5th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> Cambridge, MA, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: However, these methodologies enforce strong restrictions on the ordering of the predicates/rules in a given program, which is not declarative programming in a rigorous sense. Efficient implementations of deductive database programs have been studied extensively in recent deductive database research <ref> [1, 2, 3, 6, 10, 22] </ref>. <p> Efficient implementations of deductive database programs have been studied extensively in recent deductive database research [1, 2, 3, 6, 10, 22]. Besides algorithms for evaluation of function-free Datalog programs, such as partial transitive closure algorithms [11], Magic Sets and Counting <ref> [1] </ref>, etc., other interesting techniques have also been developed for evaluation of logic programs involving relatively sophisticated functions and queries [4, 23, 22, 6, 16]. fl The work was supported in part by the Natural Sciences and Engineering Research Council of Canada under the grant OPG-3723 and a research grant from <p> select (X; [XjXs]; Xs): (1.9) select (X; [Y jY s]; [Y jZs]) select (X; Y s; Zs): (1.10) Q 1 Q 3 2 An example chessboard for the n-queens recursion is shown in Fig. 2, where N = 4, and the positions of the four queens correspond to "nqueens (4; <ref> [2; 4; 1; 3] </ref>)", since the queen at the first row, Q 1 , is located at the position 2, that at the second row, Q 2 , is located at the position 4, etc. <p> As a result, the method generates efficient query evaluation plans for reasonable query bindings, such as "? nqueens (4; Qs)", "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)", "? nqueens (N; [3; X; Y; 2])", but returns a warning without evaluation for unsafe queries, such as "? nqueens (N; [2jL])". 2 The paper is organized as follows. In Section 2, the compilation and normalization of nested linear recursions are introduced. <p> Example 3.2 The evaluation of query, "?nqueens (4; Qs)", is examined in detail based on the adorned program of Example 3.1. First, chain-split evaluation on range (1; 4; M N s) derives M N s = <ref> [1; 2; 3; 4] </ref>. <p> Thus, we have the result. The chain-following evaluation should be performed on the predicate queens (<ref> [1; 2; 3; 4] </ref>; []; Qs). The evaluation process is presented iteration by iteration. For the first iteration, select (Q; [1; 2; 3; 4]; U 1 ) derives the pairs of Q and U 1 values as: (Q, U 1 ): f (1, [2,3,4]), (2, [1,3,4]), (3, [1,2,4]), (4, [1,2,3])g. <p> Every generated Q passes the test "not attack (Q; [])" and the iteration generates a table of inputs for the second iteration, queens (U 1 ; S 1 ; Qs), as: (U 1 , S 1 ): f ([2,3,4], <ref> [1] </ref>), ([1,3,4], [2]), ([1,2,4], [3]), ([1,2,3], [4])g. Similarly, the second iteration generates a table of inputs for the third iteration. Taking the first tuple: queens ([2; 3; 4]; [1]; Qs) as an example, select (Q; [2; 3; 4]; U 1 ) derives the pairs of Q and U 1 values as: <p> inputs for the second iteration, queens (U 1 ; S 1 ; Qs), as: (U 1 , S 1 ): f ([2,3,4], <ref> [1] </ref>), ([1,3,4], [2]), ([1,2,4], [3]), ([1,2,3], [4])g. Similarly, the second iteration generates a table of inputs for the third iteration. Taking the first tuple: queens ([2; 3; 4]; [1]; Qs) as an example, select (Q; [2; 3; 4]; U 1 ) derives the pairs of Q and U 1 values as: (Q, U 1 ): f (2, [3,4]), (3, [2,4]), (4, [2,3])g. Notice that Q = 2 cannot pass the test "not attack (2; [1])". <p> queens ([2; 3; 4]; <ref> [1] </ref>; Qs) as an example, select (Q; [2; 3; 4]; U 1 ) derives the pairs of Q and U 1 values as: (Q, U 1 ): f (2, [3,4]), (3, [2,4]), (4, [2,3])g. Notice that Q = 2 cannot pass the test "not attack (2; [1])". It generates a table of inputs queens (U 1 ; S 1 ; Qs) for the third iteration as follows: (U 1 , S 1 ): f ([2,4], [3,1]), ([2,3], [4,1])g. <p> The process continues until the input set U for queens becomes empty, and the final answer set to the query is Qs = f <ref> [2, 4, 1, 3] </ref>, [3, 1, 4, 2]g. 2 4 Different Evaluation Plans for Different Query Bindings Different query bindings lead to different query evaluation plans, which is still determined by the analysis of binding propagation, finite evaluability, termination and evaluation efficiency. <p> The process continues until the input set U for queens becomes empty, and the final answer set to the query is Qs = f [2, 4, 1, 3], <ref> [3, 1, 4, 2] </ref>g. 2 4 Different Evaluation Plans for Different Query Bindings Different query bindings lead to different query evaluation plans, which is still determined by the analysis of binding propagation, finite evaluability, termination and evaluation efficiency. An analysis of nqueens fb (N; Qs) is illustrated in Example 4.1. <p> An analysis of nqueens fb (N; Qs) is illustrated in Example 4.1. Example 4.1 Query analysis and evaluation of nqueens fb (N; Qs), such as "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)" is presented as follows. Notice that the binding propagations for nqueens fb , shown in the adorned program Fig. 5, which is a completely different program from that of nqueens bf , are determined automatically by query analysis. <p> The selection between the two orderings, if both lead to finite programs, may be further based on the evaluation efficiency. The analysis of the binding propagation in the remaining program is similar to that in Example 3.1. The evaluation of the adorned logic program for the query "?nqueens (N; <ref> [2; 4; 1; 3] </ref>)" is performed as follows. First, the binding propagation leads to the evaluation of queens fbb (N s; []; [2; 4; 1; 3]), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. <p> The evaluation of the adorned logic program for the query "?nqueens (N; <ref> [2; 4; 1; 3] </ref>)" is performed as follows. First, the binding propagation leads to the evaluation of queens fbb (N s; []; [2; 4; 1; 3]), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; <p> First, the binding propagation leads to the evaluation of queens fbb (N s; []; <ref> [2; 4; 1; 3] </ref>), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. <p> the binding propagation leads to the evaluation of queens fbb (N s; []; <ref> [2; 4; 1; 3] </ref>), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; <p> of queens fbb (N s; []; <ref> [2; 4; 1; 3] </ref>), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; <p> The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = <ref> [4; 1; 3] </ref> and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; <p> as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = <ref> [4; 1; 3] </ref> and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. <p> ([]; <ref> [2; 4; 1; 3] </ref>; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. <p> 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = <ref> [4; 1; 3] </ref> and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. <p> The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = <ref> [1; 3] </ref> and U = f [2; 4]; [4; 2]g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and <p> 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = <ref> [1; 3] </ref> and U = f [2; 4]; [4; 2]g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. <p> <ref> [2; 4; 1; 3] </ref>); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. <p> [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = <ref> [1; 3] </ref> and U = f [2; 4]; [4; 2]g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. <p> The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f <ref> [1; 2; 4] </ref>; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. <p> The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; <ref> [1; 4; 2] </ref>; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. <p> The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; <ref> [2; 1; 4] </ref>; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. <p> proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; <ref> [2; 4; 1] </ref>; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; <ref> [4; 1; 2] </ref>; [4; 2; 1]g. Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; <ref> [4; 2; 1] </ref>g. Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; <ref> [2; 4; 1; 3] </ref>) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f <ref> [1; 2; 3; 4] </ref>, [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], <ref> [1; 2; 4; 3] </ref>, : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , <ref> [4; 3; 2; 1] </ref>g. <p> After the derivation of the set of N s in (4.1), the evaluation of range bfb (1; N; N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; <ref> [1; 2; 3; 4] </ref>) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M <p> in (4.1), the evaluation of range bfb (1; N; N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; <ref> [1; 2; 3; 4] </ref>) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 <p> N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; <ref> [1; 2; 3; 4] </ref>) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons <p> The derived N = 4 is then used to validate the last predicate in (4.11) to (4.9). Therefore, N = 4 is an answer to the query. One can easily verify that any other derived list of N s, such as N s = <ref> [4; 3; 2; 1] </ref>, cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; [3; 2; 1]; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot <p> Therefore, N = 4 is an answer to the query. One can easily verify that any other derived list of N s, such as N s = <ref> [4; 3; 2; 1] </ref>, cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; [3; 2; 1]; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to <p> Therefore, N = 4 is an answer to the query. One can easily verify that any other derived list of N s, such as N s = [4; 3; 2; 1], cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; <ref> [3; 2; 1] </ref>; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. <p> One can easily verify that any other derived list of N s, such as N s = <ref> [4; 3; 2; 1] </ref>, cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; [3; 2; 1]; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. 2 Finally, we <p> This is because, range (1; N; [4; 3; 2; 1]) cons (4; <ref> [3; 2; 1] </ref>; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. 2 Finally, we examine the evaluation of the nqueens program containing only uninstantiated or <p> This is because, range (1; N; [4; 3; 2; 1]) cons (4; <ref> [3; 2; 1] </ref>; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. 2 Finally, we examine the evaluation of the nqueens program containing only uninstantiated or partially instantiated variables. <p> This is because, range (1; N; [4; 3; 2; 1]) cons (4; <ref> [3; 2; 1] </ref>; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. 2 Finally, we examine the evaluation of the nqueens program containing only uninstantiated or partially instantiated variables. <p> A query, "? sort (Original List; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 5.2 A query "?nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" of Example 4.1 may be expected to generate only one answer "N = 8". <p> our analysis of Example 4.1, the intermediate result set N s generated from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the <p> from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = [1; 2; 3; 4; 5; 6; 7; 8]" to "N s = <ref> [8; 7; 6; 5; 4; 3; 2; 1] </ref>". <p> range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since based on the definition of the recursion "range (1; N; N s)", N s must be <p> (U ) pushed in) confines the possible generated list for the first argument of queens at each iteration to be mono inc list only, which reduces substantially the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 9 The analysis of Example 5.2 shows that some logic programs, initially designed by programmers with the program execution in one direction in mind, such as select fbf <p> The following two queries are used in the examination: Q 1 : "? queens (4; Qs)", and Q 2 : "? nqueens (N; <ref> [3; 1; 4; 2] </ref>)". The following two logic programs are used in the examination: P 1 : the program presented in Fig. 4, and P 2 : the program presented in Fig. 5.
Reference: [2] <author> F. Bancilhon and R. Ramakrishnan. </author> <title> An amateur's introduction to recursive query processing strategies. </title> <booktitle> In Proc. 1986 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pages 16-52, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: However, these methodologies enforce strong restrictions on the ordering of the predicates/rules in a given program, which is not declarative programming in a rigorous sense. Efficient implementations of deductive database programs have been studied extensively in recent deductive database research <ref> [1, 2, 3, 6, 10, 22] </ref>. <p> select (X; [XjXs]; Xs): (1.9) select (X; [Y jY s]; [Y jZs]) select (X; Y s; Zs): (1.10) Q 1 Q 3 2 An example chessboard for the n-queens recursion is shown in Fig. 2, where N = 4, and the positions of the four queens correspond to "nqueens (4; <ref> [2; 4; 1; 3] </ref>)", since the queen at the first row, Q 1 , is located at the position 2, that at the second row, Q 2 , is located at the position 4, etc. <p> As a result, the method generates efficient query evaluation plans for reasonable query bindings, such as "? nqueens (4; Qs)", "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)", "? nqueens (N; [3; X; Y; 2])", but returns a warning without evaluation for unsafe queries, such as "? nqueens (N; [2jL])". 2 The paper is organized as follows. In Section 2, the compilation and normalization of nested linear recursions are introduced. <p> As a result, the method generates efficient query evaluation plans for reasonable query bindings, such as "? nqueens (4; Qs)", "? nqueens (N; [2; 4; 1; 3])", "? nqueens (N; <ref> [3; X; Y; 2] </ref>)", but returns a warning without evaluation for unsafe queries, such as "? nqueens (N; [2jL])". 2 The paper is organized as follows. In Section 2, the compilation and normalization of nested linear recursions are introduced. <p> The predicate evaluation order is strongly influenced by this analysis. Example 3.1 Suppose the binding pattern <ref> [2, 22] </ref> in the recursion nqueens (N; Qs) is bf, which indicates that the first argument is bound and the second one is free, such as "? nqueens (4; Qs)". The propagation of the bf binding in the recursion is as follows. <p> Example 3.2 The evaluation of query, "?nqueens (4; Qs)", is examined in detail based on the adorned program of Example 3.1. First, chain-split evaluation on range (1; 4; M N s) derives M N s = <ref> [1; 2; 3; 4] </ref>. <p> Thus, we have the result. The chain-following evaluation should be performed on the predicate queens (<ref> [1; 2; 3; 4] </ref>; []; Qs). The evaluation process is presented iteration by iteration. For the first iteration, select (Q; [1; 2; 3; 4]; U 1 ) derives the pairs of Q and U 1 values as: (Q, U 1 ): f (1, [2,3,4]), (2, [1,3,4]), (3, [1,2,4]), (4, [1,2,3])g. <p> Every generated Q passes the test "not attack (Q; [])" and the iteration generates a table of inputs for the second iteration, queens (U 1 ; S 1 ; Qs), as: (U 1 , S 1 ): f ([2,3,4], [1]), ([1,3,4], <ref> [2] </ref>), ([1,2,4], [3]), ([1,2,3], [4])g. Similarly, the second iteration generates a table of inputs for the third iteration. <p> Similarly, the second iteration generates a table of inputs for the third iteration. Taking the first tuple: queens (<ref> [2; 3; 4] </ref>; [1]; Qs) as an example, select (Q; [2; 3; 4]; U 1 ) derives the pairs of Q and U 1 values as: (Q, U 1 ): f (2, [3,4]), (3, [2,4]), (4, [2,3])g. Notice that Q = 2 cannot pass the test "not attack (2; [1])". <p> The process continues until the input set U for queens becomes empty, and the final answer set to the query is Qs = f <ref> [2, 4, 1, 3] </ref>, [3, 1, 4, 2]g. 2 4 Different Evaluation Plans for Different Query Bindings Different query bindings lead to different query evaluation plans, which is still determined by the analysis of binding propagation, finite evaluability, termination and evaluation efficiency. <p> The process continues until the input set U for queens becomes empty, and the final answer set to the query is Qs = f [2, 4, 1, 3], <ref> [3, 1, 4, 2] </ref>g. 2 4 Different Evaluation Plans for Different Query Bindings Different query bindings lead to different query evaluation plans, which is still determined by the analysis of binding propagation, finite evaluability, termination and evaluation efficiency. An analysis of nqueens fb (N; Qs) is illustrated in Example 4.1. <p> An analysis of nqueens fb (N; Qs) is illustrated in Example 4.1. Example 4.1 Query analysis and evaluation of nqueens fb (N; Qs), such as "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)" is presented as follows. Notice that the binding propagations for nqueens fb , shown in the adorned program Fig. 5, which is a completely different program from that of nqueens bf , are determined automatically by query analysis. <p> The selection between the two orderings, if both lead to finite programs, may be further based on the evaluation efficiency. The analysis of the binding propagation in the remaining program is similar to that in Example 3.1. The evaluation of the adorned logic program for the query "?nqueens (N; <ref> [2; 4; 1; 3] </ref>)" is performed as follows. First, the binding propagation leads to the evaluation of queens fbb (N s; []; [2; 4; 1; 3]), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. <p> The evaluation of the adorned logic program for the query "?nqueens (N; <ref> [2; 4; 1; 3] </ref>)" is performed as follows. First, the binding propagation leads to the evaluation of queens fbb (N s; []; [2; 4; 1; 3]), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; <p> First, the binding propagation leads to the evaluation of queens fbb (N s; []; <ref> [2; 4; 1; 3] </ref>), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. <p> the binding propagation leads to the evaluation of queens fbb (N s; []; <ref> [2; 4; 1; 3] </ref>), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; <p> of queens fbb (N s; []; <ref> [2; 4; 1; 3] </ref>), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; <p> iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = <ref> [2] </ref>. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. <p> ([]; <ref> [2; 4; 1; 3] </ref>; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. <p> The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f <ref> [2; 4] </ref>; [4; 2]g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; <p> The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; <ref> [4; 2] </ref>g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; <p> follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f <ref> [2; 4] </ref>; [4; 2]g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; <p> ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; <ref> [4; 2] </ref>g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; <p> <ref> [2; 4; 1; 3] </ref>); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. <p> The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f <ref> [1; 2; 4] </ref>; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. <p> The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; <ref> [1; 4; 2] </ref>; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. <p> The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; <ref> [2; 1; 4] </ref>; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. <p> proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; <ref> [2; 4; 1] </ref>; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; <ref> [4; 1; 2] </ref>; [4; 2; 1]g. Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; <ref> [4; 2; 1] </ref>g. Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; <ref> [2; 4; 1; 3] </ref>) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f <ref> [1; 2; 3; 4] </ref>, [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], <ref> [1; 2; 4; 3] </ref>, : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , <ref> [4; 3; 2; 1] </ref>g. <p> After the derivation of the set of N s in (4.1), the evaluation of range bfb (1; N; N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; <ref> [1; 2; 3; 4] </ref>) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M <p> in (4.1), the evaluation of range bfb (1; N; N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; <ref> [1; 2; 3; 4] </ref>) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 <p> bfb (1; N; N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; [1; 2; 3; 4]) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; <ref> [2; 3; 4] </ref>; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; <p> N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; <ref> [1; 2; 3; 4] </ref>) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons <p> N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; [1; 2; 3; 4]) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; <ref> [2; 3; 4] </ref>; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; <p> The process of the evaluation of range bfb (1; N; [1; 2; 3; 4]) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; <ref> [2; 3; 4] </ref>; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) <p> bfb (1; N; [1; 2; 3; 4]) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; <ref> [2; 3; 4] </ref>; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; []; [4]): <p> The derived N = 4 is then used to validate the last predicate in (4.11) to (4.9). Therefore, N = 4 is an answer to the query. One can easily verify that any other derived list of N s, such as N s = <ref> [4; 3; 2; 1] </ref>, cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; [3; 2; 1]; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot <p> Therefore, N = 4 is an answer to the query. One can easily verify that any other derived list of N s, such as N s = <ref> [4; 3; 2; 1] </ref>, cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; [3; 2; 1]; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to <p> Therefore, N = 4 is an answer to the query. One can easily verify that any other derived list of N s, such as N s = [4; 3; 2; 1], cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; <ref> [3; 2; 1] </ref>; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. <p> One can easily verify that any other derived list of N s, such as N s = <ref> [4; 3; 2; 1] </ref>, cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; [3; 2; 1]; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. 2 Finally, we <p> This is because, range (1; N; [4; 3; 2; 1]) cons (4; <ref> [3; 2; 1] </ref>; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. 2 Finally, we examine the evaluation of the nqueens program containing only uninstantiated or <p> This is because, range (1; N; [4; 3; 2; 1]) cons (4; <ref> [3; 2; 1] </ref>; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. 2 Finally, we examine the evaluation of the nqueens program containing only uninstantiated or partially instantiated variables. <p> This is because, range (1; N; [4; 3; 2; 1]) cons (4; <ref> [3; 2; 1] </ref>; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. 2 Finally, we examine the evaluation of the nqueens program containing only uninstantiated or partially instantiated variables. <p> Example 4.3 For the query "? nqueens (N; <ref> [3; X; Y; 2] </ref>)", if the binding analysis similar to that in Example 4.2 were performed on the two predicates queens and range without further analysis, it would have concluded that the program is unsafe for query evaluation. <p> With the above two properties on length available, it is straightforward to derive "N = 4" from the fact that "length (<ref> [3; X; Y; 2] </ref>) = 4". Thus, the query is equivalent to "? nqueens (4; [3; X; Y; 2])" which can be analyzed and evaluated in a way similar to Example 3.1. 2 5 Further reduction of search space by inter-recursion constraint analysis The declarative evaluation of a logic program is based on the methodology of finding all the answers to a query. <p> A query, "? sort (Original List; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 5.2 A query "?nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" of Example 4.1 may be expected to generate only one answer "N = 8". <p> our analysis of Example 4.1, the intermediate result set N s generated from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the <p> from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = [1; 2; 3; 4; 5; 6; 7; 8]" to "N s = <ref> [8; 7; 6; 5; 4; 3; 2; 1] </ref>". <p> range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since based on the definition of the recursion "range (1; N; N s)", N s must be <p> (U ) pushed in) confines the possible generated list for the first argument of queens at each iteration to be mono inc list only, which reduces substantially the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 9 The analysis of Example 5.2 shows that some logic programs, initially designed by programmers with the program execution in one direction in mind, such as select fbf <p> Termination of the evaluation implies that the evaluation of a recursion is performed in a finite number of iterations (with a complete set of answers derived). Since there exists a finite least-fixed point for a function-free recursion, a function-free recursion terminates by bottom-up evaluation <ref> [2] </ref>. However, since a functional recursion may not have a finite least-fixed point in general, more detailed constraint analysis is necessary in order to determine its termination condition. <p> The following two queries are used in the examination: Q 1 : "? queens (4; Qs)", and Q 2 : "? nqueens (N; <ref> [3; 1; 4; 2] </ref>)". The following two logic programs are used in the examination: P 1 : the program presented in Fig. 4, and P 2 : the program presented in Fig. 5.
Reference: [3] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of magic. </title> <booktitle> In Proc. 6th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, CA, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: However, these methodologies enforce strong restrictions on the ordering of the predicates/rules in a given program, which is not declarative programming in a rigorous sense. Efficient implementations of deductive database programs have been studied extensively in recent deductive database research <ref> [1, 2, 3, 6, 10, 22] </ref>. <p> select (X; [XjXs]; Xs): (1.9) select (X; [Y jY s]; [Y jZs]) select (X; Y s; Zs): (1.10) Q 1 Q 3 2 An example chessboard for the n-queens recursion is shown in Fig. 2, where N = 4, and the positions of the four queens correspond to "nqueens (4; <ref> [2; 4; 1; 3] </ref>)", since the queen at the first row, Q 1 , is located at the position 2, that at the second row, Q 2 , is located at the position 4, etc. <p> As a result, the method generates efficient query evaluation plans for reasonable query bindings, such as "? nqueens (4; Qs)", "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)", "? nqueens (N; [3; X; Y; 2])", but returns a warning without evaluation for unsafe queries, such as "? nqueens (N; [2jL])". 2 The paper is organized as follows. In Section 2, the compilation and normalization of nested linear recursions are introduced. <p> As a result, the method generates efficient query evaluation plans for reasonable query bindings, such as "? nqueens (4; Qs)", "? nqueens (N; [2; 4; 1; 3])", "? nqueens (N; <ref> [3; X; Y; 2] </ref>)", but returns a warning without evaluation for unsafe queries, such as "? nqueens (N; [2jL])". 2 The paper is organized as follows. In Section 2, the compilation and normalization of nested linear recursions are introduced. <p> Example 3.2 The evaluation of query, "?nqueens (4; Qs)", is examined in detail based on the adorned program of Example 3.1. First, chain-split evaluation on range (1; 4; M N s) derives M N s = <ref> [1; 2; 3; 4] </ref>. <p> Thus, we have the result. The chain-following evaluation should be performed on the predicate queens (<ref> [1; 2; 3; 4] </ref>; []; Qs). The evaluation process is presented iteration by iteration. For the first iteration, select (Q; [1; 2; 3; 4]; U 1 ) derives the pairs of Q and U 1 values as: (Q, U 1 ): f (1, [2,3,4]), (2, [1,3,4]), (3, [1,2,4]), (4, [1,2,3])g. <p> Every generated Q passes the test "not attack (Q; [])" and the iteration generates a table of inputs for the second iteration, queens (U 1 ; S 1 ; Qs), as: (U 1 , S 1 ): f ([2,3,4], [1]), ([1,3,4], [2]), ([1,2,4], <ref> [3] </ref>), ([1,2,3], [4])g. Similarly, the second iteration generates a table of inputs for the third iteration. <p> Similarly, the second iteration generates a table of inputs for the third iteration. Taking the first tuple: queens (<ref> [2; 3; 4] </ref>; [1]; Qs) as an example, select (Q; [2; 3; 4]; U 1 ) derives the pairs of Q and U 1 values as: (Q, U 1 ): f (2, [3,4]), (3, [2,4]), (4, [2,3])g. Notice that Q = 2 cannot pass the test "not attack (2; [1])". <p> The process continues until the input set U for queens becomes empty, and the final answer set to the query is Qs = f <ref> [2, 4, 1, 3] </ref>, [3, 1, 4, 2]g. 2 4 Different Evaluation Plans for Different Query Bindings Different query bindings lead to different query evaluation plans, which is still determined by the analysis of binding propagation, finite evaluability, termination and evaluation efficiency. <p> The process continues until the input set U for queens becomes empty, and the final answer set to the query is Qs = f [2, 4, 1, 3], <ref> [3, 1, 4, 2] </ref>g. 2 4 Different Evaluation Plans for Different Query Bindings Different query bindings lead to different query evaluation plans, which is still determined by the analysis of binding propagation, finite evaluability, termination and evaluation efficiency. An analysis of nqueens fb (N; Qs) is illustrated in Example 4.1. <p> An analysis of nqueens fb (N; Qs) is illustrated in Example 4.1. Example 4.1 Query analysis and evaluation of nqueens fb (N; Qs), such as "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)" is presented as follows. Notice that the binding propagations for nqueens fb , shown in the adorned program Fig. 5, which is a completely different program from that of nqueens bf , are determined automatically by query analysis. <p> The selection between the two orderings, if both lead to finite programs, may be further based on the evaluation efficiency. The analysis of the binding propagation in the remaining program is similar to that in Example 3.1. The evaluation of the adorned logic program for the query "?nqueens (N; <ref> [2; 4; 1; 3] </ref>)" is performed as follows. First, the binding propagation leads to the evaluation of queens fbb (N s; []; [2; 4; 1; 3]), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. <p> The evaluation of the adorned logic program for the query "?nqueens (N; <ref> [2; 4; 1; 3] </ref>)" is performed as follows. First, the binding propagation leads to the evaluation of queens fbb (N s; []; [2; 4; 1; 3]), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; <p> First, the binding propagation leads to the evaluation of queens fbb (N s; []; <ref> [2; 4; 1; 3] </ref>), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. <p> the binding propagation leads to the evaluation of queens fbb (N s; []; <ref> [2; 4; 1; 3] </ref>), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; <p> of queens fbb (N s; []; <ref> [2; 4; 1; 3] </ref>), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; <p> The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = <ref> [4; 1; 3] </ref> and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; <p> as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = <ref> [4; 1; 3] </ref> and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. <p> ([]; <ref> [2; 4; 1; 3] </ref>; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. <p> 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = <ref> [4; 1; 3] </ref> and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. <p> The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = <ref> [1; 3] </ref> and U = f [2; 4]; [4; 2]g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and <p> 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = <ref> [1; 3] </ref> and U = f [2; 4]; [4; 2]g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. <p> <ref> [2; 4; 1; 3] </ref>); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. <p> [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = <ref> [1; 3] </ref> and U = f [2; 4]; [4; 2]g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. <p> The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = <ref> [3] </ref> and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; <ref> [2; 4; 1; 3] </ref>) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f <ref> [1; 2; 3; 4] </ref>, [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], <ref> [1; 2; 4; 3] </ref>, : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , <ref> [4; 3; 2; 1] </ref>g. <p> After the derivation of the set of N s in (4.1), the evaluation of range bfb (1; N; N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; <ref> [1; 2; 3; 4] </ref>) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M <p> in (4.1), the evaluation of range bfb (1; N; N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; <ref> [1; 2; 3; 4] </ref>) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 <p> bfb (1; N; N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; [1; 2; 3; 4]) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; <ref> [2; 3; 4] </ref>; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; <p> N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; <ref> [1; 2; 3; 4] </ref>) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons <p> N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; [1; 2; 3; 4]) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; <ref> [2; 3; 4] </ref>; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; <p> The process of the evaluation of range bfb (1; N; [1; 2; 3; 4]) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; <ref> [2; 3; 4] </ref>; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) <p> of range bfb (1; N; [1; 2; 3; 4]) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; <ref> [3; 4] </ref>; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; <p> bfb (1; N; [1; 2; 3; 4]) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; <ref> [2; 3; 4] </ref>; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; []; [4]): <p> (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; <ref> [3; 4] </ref>; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; []; [4]): (4.12) Notice that each range bfb except the last one, range <p> 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; <ref> [3; 4] </ref>; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; []; [4]): (4.12) Notice that each range bfb except the last one, range (4; N; [4]) in (4.12), matches only (4.7), The <p> 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; <ref> [3; 4] </ref>; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; []; [4]): (4.12) Notice that each range bfb except the last one, range (4; N; [4]) in (4.12), matches only (4.7), The last one, in (4.12), matches <p> The derived N = 4 is then used to validate the last predicate in (4.11) to (4.9). Therefore, N = 4 is an answer to the query. One can easily verify that any other derived list of N s, such as N s = <ref> [4; 3; 2; 1] </ref>, cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; [3; 2; 1]; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot <p> Therefore, N = 4 is an answer to the query. One can easily verify that any other derived list of N s, such as N s = <ref> [4; 3; 2; 1] </ref>, cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; [3; 2; 1]; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to <p> Therefore, N = 4 is an answer to the query. One can easily verify that any other derived list of N s, such as N s = [4; 3; 2; 1], cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; <ref> [3; 2; 1] </ref>; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. <p> One can easily verify that any other derived list of N s, such as N s = <ref> [4; 3; 2; 1] </ref>, cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; [3; 2; 1]; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. 2 Finally, we <p> This is because, range (1; N; [4; 3; 2; 1]) cons (4; <ref> [3; 2; 1] </ref>; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. 2 Finally, we examine the evaluation of the nqueens program containing only uninstantiated or <p> This is because, range (1; N; [4; 3; 2; 1]) cons (4; <ref> [3; 2; 1] </ref>; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. 2 Finally, we examine the evaluation of the nqueens program containing only uninstantiated or partially instantiated variables. <p> This is because, range (1; N; [4; 3; 2; 1]) cons (4; <ref> [3; 2; 1] </ref>; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. 2 Finally, we examine the evaluation of the nqueens program containing only uninstantiated or partially instantiated variables. <p> Example 4.3 For the query "? nqueens (N; <ref> [3; X; Y; 2] </ref>)", if the binding analysis similar to that in Example 4.2 were performed on the two predicates queens and range without further analysis, it would have concluded that the program is unsafe for query evaluation. <p> With the above two properties on length available, it is straightforward to derive "N = 4" from the fact that "length (<ref> [3; X; Y; 2] </ref>) = 4". Thus, the query is equivalent to "? nqueens (4; [3; X; Y; 2])" which can be analyzed and evaluated in a way similar to Example 3.1. 2 5 Further reduction of search space by inter-recursion constraint analysis The declarative evaluation of a logic program is based on the methodology of finding all the answers to a query. <p> A query, "? sort (Original List; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 5.2 A query "?nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" of Example 4.1 may be expected to generate only one answer "N = 8". <p> our analysis of Example 4.1, the intermediate result set N s generated from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the <p> from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = [1; 2; 3; 4; 5; 6; 7; 8]" to "N s = <ref> [8; 7; 6; 5; 4; 3; 2; 1] </ref>". <p> range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since based on the definition of the recursion "range (1; N; N s)", N s must be <p> (U ) pushed in) confines the possible generated list for the first argument of queens at each iteration to be mono inc list only, which reduces substantially the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 9 The analysis of Example 5.2 shows that some logic programs, initially designed by programmers with the program execution in one direction in mind, such as select fbf <p> The following two queries are used in the examination: Q 1 : "? queens (4; Qs)", and Q 2 : "? nqueens (N; <ref> [3; 1; 4; 2] </ref>)". The following two logic programs are used in the examination: P 1 : the program presented in Fig. 4, and P 2 : the program presented in Fig. 5.
Reference: [4] <author> D. Chimenti, R. Gamboa, R. Krishnamurthy, S. Naqvi, S. Tsur, and C. Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 2 </volume> <pages> 76-90, </pages> <year> 1990. </year> <month> 15 </month>
Reference-contexts: Besides algorithms for evaluation of function-free Datalog programs, such as partial transitive closure algorithms [11], Magic Sets and Counting [1], etc., other interesting techniques have also been developed for evaluation of logic programs involving relatively sophisticated functions and queries <ref> [4, 23, 22, 6, 16] </ref>. fl The work was supported in part by the Natural Sciences and Engineering Research Council of Canada under the grant OPG-3723 and a research grant from the Centre for Systems Science of Simon Fraser University. <p> select (X; [XjXs]; Xs): (1.9) select (X; [Y jY s]; [Y jZs]) select (X; Y s; Zs): (1.10) Q 1 Q 3 2 An example chessboard for the n-queens recursion is shown in Fig. 2, where N = 4, and the positions of the four queens correspond to "nqueens (4; <ref> [2; 4; 1; 3] </ref>)", since the queen at the first row, Q 1 , is located at the position 2, that at the second row, Q 2 , is located at the position 4, etc. <p> As a result, the method generates efficient query evaluation plans for reasonable query bindings, such as "? nqueens (4; Qs)", "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)", "? nqueens (N; [3; X; Y; 2])", but returns a warning without evaluation for unsafe queries, such as "? nqueens (N; [2jL])". 2 The paper is organized as follows. In Section 2, the compilation and normalization of nested linear recursions are introduced. <p> Example 3.2 The evaluation of query, "?nqueens (4; Qs)", is examined in detail based on the adorned program of Example 3.1. First, chain-split evaluation on range (1; 4; M N s) derives M N s = <ref> [1; 2; 3; 4] </ref>. <p> range (3; 4; N s 2 ) generates "range (4; 4; N s 3 ), cons (3; N s 3 ; N s 2 )", and finally, (iv) at the fourth iteration, range (4; 4; N s 3 ) matches only the exit rule and produces N s 3 = <ref> [4] </ref>. Thus, we have the result. The chain-following evaluation should be performed on the predicate queens ([1; 2; 3; 4]; []; Qs). The evaluation process is presented iteration by iteration. <p> Thus, we have the result. The chain-following evaluation should be performed on the predicate queens (<ref> [1; 2; 3; 4] </ref>; []; Qs). The evaluation process is presented iteration by iteration. For the first iteration, select (Q; [1; 2; 3; 4]; U 1 ) derives the pairs of Q and U 1 values as: (Q, U 1 ): f (1, [2,3,4]), (2, [1,3,4]), (3, [1,2,4]), (4, [1,2,3])g. <p> Similarly, the second iteration generates a table of inputs for the third iteration. Taking the first tuple: queens (<ref> [2; 3; 4] </ref>; [1]; Qs) as an example, select (Q; [2; 3; 4]; U 1 ) derives the pairs of Q and U 1 values as: (Q, U 1 ): f (2, [3,4]), (3, [2,4]), (4, [2,3])g. Notice that Q = 2 cannot pass the test "not attack (2; [1])". <p> The process continues until the input set U for queens becomes empty, and the final answer set to the query is Qs = f <ref> [2, 4, 1, 3] </ref>, [3, 1, 4, 2]g. 2 4 Different Evaluation Plans for Different Query Bindings Different query bindings lead to different query evaluation plans, which is still determined by the analysis of binding propagation, finite evaluability, termination and evaluation efficiency. <p> The process continues until the input set U for queens becomes empty, and the final answer set to the query is Qs = f [2, 4, 1, 3], <ref> [3, 1, 4, 2] </ref>g. 2 4 Different Evaluation Plans for Different Query Bindings Different query bindings lead to different query evaluation plans, which is still determined by the analysis of binding propagation, finite evaluability, termination and evaluation efficiency. An analysis of nqueens fb (N; Qs) is illustrated in Example 4.1. <p> An analysis of nqueens fb (N; Qs) is illustrated in Example 4.1. Example 4.1 Query analysis and evaluation of nqueens fb (N; Qs), such as "? nqueens (N; <ref> [2; 4; 1; 3] </ref>)" is presented as follows. Notice that the binding propagations for nqueens fb , shown in the adorned program Fig. 5, which is a completely different program from that of nqueens bf , are determined automatically by query analysis. <p> The selection between the two orderings, if both lead to finite programs, may be further based on the evaluation efficiency. The analysis of the binding propagation in the remaining program is similar to that in Example 3.1. The evaluation of the adorned logic program for the query "?nqueens (N; <ref> [2; 4; 1; 3] </ref>)" is performed as follows. First, the binding propagation leads to the evaluation of queens fbb (N s; []; [2; 4; 1; 3]), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. <p> The evaluation of the adorned logic program for the query "?nqueens (N; <ref> [2; 4; 1; 3] </ref>)" is performed as follows. First, the binding propagation leads to the evaluation of queens fbb (N s; []; [2; 4; 1; 3]), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; <p> First, the binding propagation leads to the evaluation of queens fbb (N s; []; <ref> [2; 4; 1; 3] </ref>), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. <p> the binding propagation leads to the evaluation of queens fbb (N s; []; <ref> [2; 4; 1; 3] </ref>), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; <p> of queens fbb (N s; []; <ref> [2; 4; 1; 3] </ref>), which should be evaluated in the first-exit-then-chain order according to our binding propagation analysis. The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; <p> The first iteration in the evaluation of the recursive rule proceeds as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = <ref> [4; 1; 3] </ref> and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; <p> as follows, queens ([]; [2; 4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = <ref> [4; 1; 3] </ref> and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. <p> ([]; <ref> [2; 4; 1; 3] </ref>; [2; 4; 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = [4; 1; 3] and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. <p> 1; 3]); cons (Q; S; [2; 4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 2, S = <ref> [4; 1; 3] </ref> and U = [2]. The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. <p> The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f <ref> [2; 4] </ref>; [4; 2]g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; <p> The second iteration proceeds as follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; <ref> [4; 2] </ref>g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; <p> follows, queens ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f <ref> [2; 4] </ref>; [4; 2]g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; <p> ([2]; [4; 1; 3]; [2; 4; 1; 3]); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; <ref> [4; 2] </ref>g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; <p> <ref> [2; 4; 1; 3] </ref>); cons (Q; S; [4; 1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 4, S = [1; 3] and U = f [2; 4]; [4; 2]g. The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. <p> The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f <ref> [1; 2; 4] </ref>; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. <p> The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; <ref> [1; 4; 2] </ref>; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. <p> The third iteration proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; <ref> [2; 1; 4] </ref>; [2; 4; 1]; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. <p> proceeds as follows, queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; <ref> [2; 4; 1] </ref>; [4; 1; 2]; [4; 2; 1]g. Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> queens (f [2; 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; <ref> [4; 1; 2] </ref>; [4; 2; 1]g. Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> 4]; [4; 2]g; [1; 3]; [2; 4; 1; 3]); cons (Q; S; [1; 3]); not attack (Q; S); select (Q; U; []): This leads to Q = 1, S = [3] and U = f [1; 2; 4]; [1; 4; 2]; [2; 1; 4]; [2; 4; 1]; [4; 1; 2]; <ref> [4; 2; 1] </ref>g. Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; <ref> [2; 4; 1; 3] </ref>) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f <ref> [1; 2; 3; 4] </ref>, [1; 2; 4; 3], : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], <ref> [1; 2; 4; 3] </ref>, : : : , [4; 3; 2; 1]g. <p> Similarly for the fourth iteration. The result of the evaluation of queens (N s; []; [2; 4; 1; 3]) is N s = f [1; 2; 3; 4], [1; 2; 4; 3], : : : , <ref> [4; 3; 2; 1] </ref>g. <p> After the derivation of the set of N s in (4.1), the evaluation of range bfb (1; N; N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; <ref> [1; 2; 3; 4] </ref>) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M <p> in (4.1), the evaluation of range bfb (1; N; N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; <ref> [1; 2; 3; 4] </ref>) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 <p> bfb (1; N; N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; [1; 2; 3; 4]) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; <ref> [2; 3; 4] </ref>; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; <p> N s) proceeds in the order indicated in (4.7), which derives N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; <ref> [1; 2; 3; 4] </ref>) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons <p> N = 4, the only answer to the query. 7 The process of the evaluation of range bfb (1; N; [1; 2; 3; 4]) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; <ref> [2; 3; 4] </ref>; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; <p> The process of the evaluation of range bfb (1; N; [1; 2; 3; 4]) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; <ref> [2; 3; 4] </ref>; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) <p> of range bfb (1; N; [1; 2; 3; 4]) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; <ref> [3; 4] </ref>; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; <p> bfb (1; N; [1; 2; 3; 4]) is demonstrated below. range (1; N; [1; 2; 3; 4]) cons (1; <ref> [2; 3; 4] </ref>; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; []; [4]): <p> (1; N; [1; 2; 3; 4]) cons (1; [2; 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; <ref> [3; 4] </ref>; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; []; [4]): (4.12) Notice that each range bfb except the last one, range <p> 3; 4]; [1; 2; 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; <ref> [3; 4] </ref>; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; []; [4]): (4.12) Notice that each range bfb except the last one, range (4; N; [4]) in (4.12), matches only (4.7), The <p> 3; 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; <ref> [4] </ref>; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; []; [4]): (4.12) Notice that each range bfb except the last one, range (4; N; [4]) in (4.12), matches only (4.7), The last one, in (4.12), <p> 4]); M 1 = 2; range (2; N; [2; 3; 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; <ref> [3; 4] </ref>; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; [4]; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; []; [4]): (4.12) Notice that each range bfb except the last one, range (4; N; [4]) in (4.12), matches only (4.7), The last one, in (4.12), matches <p> 4]); 1 &lt; N: (4.9) range (2; N; [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; <ref> [4] </ref>; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; []; [4]): (4.12) Notice that each range bfb except the last one, range (4; N; [4]) in (4.12), matches only (4.7), The last one, in (4.12), matches only (4.8) and derives N = 4. <p> [2; 3; 4]) cons (2; [3; 4]; [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; <ref> [4] </ref>; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; []; [4]): (4.12) Notice that each range bfb except the last one, range (4; N; [4]) in (4.12), matches only (4.7), The last one, in (4.12), matches only (4.8) and derives N = 4. <p> [2; 3; 4]); M 0 1 = 3; range (3; N; [3; 4]); 2 &lt; N: (4.10) range (3; N; [3; 4]) cons (3; <ref> [4] </ref>; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; []; [4]): (4.12) Notice that each range bfb except the last one, range (4; N; [4]) in (4.12), matches only (4.7), The last one, in (4.12), matches only (4.8) and derives N = 4. The derived N = 4 is then used to validate the last predicate in (4.11) to (4.9). <p> &lt; N: (4.10) range (3; N; [3; 4]) cons (3; <ref> [4] </ref>; [3; 4]); M 00 1 = 4; range (4; N; [4]); 3 &lt; N: (4.11) range (4; N; [4]) 4 = N; cons (4; []; [4]): (4.12) Notice that each range bfb except the last one, range (4; N; [4]) in (4.12), matches only (4.7), The last one, in (4.12), matches only (4.8) and derives N = 4. The derived N = 4 is then used to validate the last predicate in (4.11) to (4.9). Therefore, N = 4 is an answer to the query. <p> The derived N = 4 is then used to validate the last predicate in (4.11) to (4.9). Therefore, N = 4 is an answer to the query. One can easily verify that any other derived list of N s, such as N s = <ref> [4; 3; 2; 1] </ref>, cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; [3; 2; 1]; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot <p> Therefore, N = 4 is an answer to the query. One can easily verify that any other derived list of N s, such as N s = <ref> [4; 3; 2; 1] </ref>, cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; [3; 2; 1]; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to <p> One can easily verify that any other derived list of N s, such as N s = <ref> [4; 3; 2; 1] </ref>, cannot derive a valid N . This is because, range (1; N; [4; 3; 2; 1]) cons (4; [3; 2; 1]; [4; 3; 2; 1]); M 1 = 5; range (5; N; [3; 2; 1]); 1 &lt; N: (4.13) whereas range (5; N; [3; 2; 1]) cannot derive anything for "cons (5; N s; [3; 2; 1])" and thus cannot proceed further to derive any answer to the query. 2 Finally, we <p> A query, "? sort (Original List; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 5.2 A query "?nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" of Example 4.1 may be expected to generate only one answer "N = 8". <p> our analysis of Example 4.1, the intermediate result set N s generated from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the <p> from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = [1; 2; 3; 4; 5; 6; 7; 8]" to "N s = <ref> [8; 7; 6; 5; 4; 3; 2; 1] </ref>". <p> range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since based on the definition of the recursion "range (1; N; N s)", N s must be <p> (U ) pushed in) confines the possible generated list for the first argument of queens at each iteration to be mono inc list only, which reduces substantially the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 9 The analysis of Example 5.2 shows that some logic programs, initially designed by programmers with the program execution in one direction in mind, such as select fbf <p> Recent studies on deductive databases have developed a bottom-up query evaluation method, such as the Magic Sets method and its variations, for efficient evaluation of recursions <ref> [22, 4, 23, 16] </ref>. The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. <p> The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. Several deductive database system prototypes, such as LDL <ref> [4] </ref>, ADITI [23], NAIL! [22], CORAL [16], etc. are constructed based on this approach. <p> The following two queries are used in the examination: Q 1 : "? queens (4; Qs)", and Q 2 : "? nqueens (N; <ref> [3; 1; 4; 2] </ref>)". The following two logic programs are used in the examination: P 1 : the program presented in Fig. 4, and P 2 : the program presented in Fig. 5.
Reference: [5] <author> J. Gasching. </author> <title> Performance measurements and analysis of certain search algorithms. </title> <type> In PhD thesis, </type> <institution> Carnegie-Mellon University, Dept. of Computer Science, </institution> <month> May </month> <year> 1979. </year>
Reference-contexts: Example 1.1 A typical n-queens Prolog program (adapted from [19]), but treated as a purely declarative logic program, is presented in Fig. 1. The recursion is adopted in this study because it is a classical example for studying search methods <ref> [5, 20] </ref>, and it can be elegantly defined by a nested linear recursion (see Section 2). nqueens (N; Qs) range (1; N; N s); queens (N s; []; Qs): (1.1) range (M; N; [M jN s]) M &lt; N; M 1 is M + 1; range (M 1 ; N; N <p> A query, "? sort (Original List; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 5.2 A query "?nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" of Example 4.1 may be expected to generate only one answer "N = 8". <p> our analysis of Example 4.1, the intermediate result set N s generated from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the <p> from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = [1; 2; 3; 4; 5; 6; 7; 8]" to "N s = <ref> [8; 7; 6; 5; 4; 3; 2; 1] </ref>". <p> range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since based on the definition of the recursion "range (1; N; N s)", N s must be <p> (U ) pushed in) confines the possible generated list for the first argument of queens at each iteration to be mono inc list only, which reduces substantially the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 9 The analysis of Example 5.2 shows that some logic programs, initially designed by programmers with the program execution in one direction in mind, such as select fbf
Reference: [6] <author> J. Han. </author> <title> Compilation-based list processing in deductive databases. </title> <editor> In A. Pirotte, C. Delobel, and G. Gottlob, editors, </editor> <booktitle> Extending Database Technology - EDBT'92 [Lecture Notes in Computer Science 580], </booktitle> <pages> pages 104-119. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: However, these methodologies enforce strong restrictions on the ordering of the predicates/rules in a given program, which is not declarative programming in a rigorous sense. Efficient implementations of deductive database programs have been studied extensively in recent deductive database research <ref> [1, 2, 3, 6, 10, 22] </ref>. <p> Besides algorithms for evaluation of function-free Datalog programs, such as partial transitive closure algorithms [11], Magic Sets and Counting [1], etc., other interesting techniques have also been developed for evaluation of logic programs involving relatively sophisticated functions and queries <ref> [4, 23, 22, 6, 16] </ref>. fl The work was supported in part by the Natural Sciences and Engineering Research Council of Canada under the grant OPG-3723 and a research grant from the Centre for Systems Science of Simon Fraser University. <p> The LogicBase system, including the examples described here, can be tested on-line with the URL: http://db.cs.sfu.ca/LogicBase. 1 In our previous study on the implementations of deductive database programs, a compilation and chain-based query evaluation method <ref> [6] </ref> has been developed which compiles a recursion into a normalized recursion (or chain form) when possible, performs query analysis based on the input query and the compiled recursion, generates a query processing plan and executes it using chain-following, chain-split, and constraint-based query evaluation techniques [6]. <p> and chain-based query evaluation method <ref> [6] </ref> has been developed which compiles a recursion into a normalized recursion (or chain form) when possible, performs query analysis based on the input query and the compiled recursion, generates a query processing plan and executes it using chain-following, chain-split, and constraint-based query evaluation techniques [6]. The method has been applied to the compilation and evaluation of linear recursions with list and arithmetic functions [8]. <p> The compilation of such a recursion is performed by first transforming it into a function-free recursion using a function-predicate transformation <ref> [6] </ref>, then treating every lower level IDB predicate as an EDB predicate and normalizing the recursions at every level [9]. Example 2.1 The n-queens program of Fig. 1 is normalized to Fig. 3. <p> Finally, termination analysis can be performed on each compiled recursion based on the monotonicity behavior of the variables in the recursive predicate and the available bindings <ref> [6] </ref>. For example, the recursion range bbf terminates, as shown below. <p> Similarly, the remaining recursions with the given bindings terminate as well. 2 3.2 Generation of query evaluation plans The binding propagation analysis determines not only the predicate evaluation order but also the appropriate query evaluation schemes. For example, the adorned program of Example 3.1 indicates that chain-split evaluation <ref> [6] </ref> should be performed on range bbf (M; N; M N s) because one compiled chain "M &lt; N; M 1 = M + 1; cons (M; N s; M N s)" must be split into two "M &lt; N; M 1 = M + 1" and "cons (M; N s; <p> Similarly, chain-split evaluation should be performed on select fbf (X; Y Y s; Y Zs), chain-following evaluation <ref> [6] </ref> on queens bbf (U; S; Qs), and existence-checking evaluation [6] on attk bbb (X; N; Y Y s). Example 3.2 The evaluation of query, "?nqueens (4; Qs)", is examined in detail based on the adorned program of Example 3.1. <p> Similarly, chain-split evaluation should be performed on select fbf (X; Y Y s; Y Zs), chain-following evaluation <ref> [6] </ref> on queens bbf (U; S; Qs), and existence-checking evaluation [6] on attk bbb (X; N; Y Y s). Example 3.2 The evaluation of query, "?nqueens (4; Qs)", is examined in detail based on the adorned program of Example 3.1. First, chain-split evaluation on range (1; 4; M N s) derives M N s = [1; 2; 3; 4]. <p> A query, "? sort (Original List; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 5.2 A query "?nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" of Example 4.1 may be expected to generate only one answer "N = 8". <p> our analysis of Example 4.1, the intermediate result set N s generated from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the <p> from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = [1; 2; 3; 4; 5; 6; 7; 8]" to "N s = <ref> [8; 7; 6; 5; 4; 3; 2; 1] </ref>". <p> range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since based on the definition of the recursion "range (1; N; N s)", N s must be <p> (U ) pushed in) confines the possible generated list for the first argument of queens at each iteration to be mono inc list only, which reduces substantially the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 9 The analysis of Example 5.2 shows that some logic programs, initially designed by programmers with the program execution in one direction in mind, such as select fbf
Reference: [7] <author> J. Han. </author> <title> Constraint-based query evaluation in deductive databases. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 6 </volume> <pages> 96-107, </pages> <year> 1994. </year>
Reference-contexts: By normalization, the chain-predicate (s) of each recursion and their variable connections are made explicit, as shown below. The recursion range (M; N; M N s) is a single chain recursion <ref> [7] </ref> with the variables M and M N s in the head predicate connecting to the corresponding variables M 1 and N s respectively in the recursive predicate in the 3 nqueens (N; Qs) range (1; N; N s); queens (N s; []; Qs): (2.1) range (M; N; M N s) <p> A query, "? sort (Original List; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 5.2 A query "?nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" of Example 4.1 may be expected to generate only one answer "N = 8". <p> our analysis of Example 4.1, the intermediate result set N s generated from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the <p> from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = [1; 2; 3; 4; 5; 6; 7; 8]" to "N s = <ref> [8; 7; 6; 5; 4; 3; 2; 1] </ref>". <p> range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since based on the definition of the recursion "range (1; N; N s)", N s must be <p> (U ) pushed in) confines the possible generated list for the first argument of queens at each iteration to be mono inc list only, which reduces substantially the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 9 The analysis of Example 5.2 shows that some logic programs, initially designed by programmers with the program execution in one direction in mind, such as select fbf <p> The chain-based query evaluation method is based on the compilation of each recursion in the program into a highly regular chain form on which systematic query analysis can be performed to determine the termination of a program and generate efficient query evaluation plans. Based on the studies in <ref> [7, 9] </ref>, linear and nested linear recursions can be compiled into highly regular chain forms. Some nonlinear recursions can be compiled into chain or pseudo-chain forms (a pseudo-chain form is similar to the chain form except each chain element also grows with certain regularity).
Reference: [8] <author> J. Han, L. Liu, and Z. Xie. LogicBase: </author> <title> A system prototype for deductive query evaluation. </title> <booktitle> In Proc. 1993 ILPS Workshop on Programming with Logic Databases, </booktitle> <pages> pages 146-160, </pages> <address> Vancouver, Canada, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: The method has been applied to the compilation and evaluation of linear recursions with list and arithmetic functions <ref> [8] </ref>. In this study, the chain-based evaluation technique is further extended to nested linear recursions, with the development of a method for compilation, query analysis and constraint pushing in multiple level recursions. The method is illustrated by the query analysis on the n-queens recursion defined in Example 1.1. <p> A query, "? sort (Original List; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> It is nontrivial to reduce the intermediate search space in such programs. Example 5.2 A query "?nqueens (N; <ref> [2; 5; 7; 1; 3; 8; 6; 4] </ref>)" of Example 4.1 may be expected to generate only one answer "N = 8". <p> our analysis of Example 4.1, the intermediate result set N s generated from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the <p> from queens fbb (N s; []; Qs), which is to be fed into range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = [1; 2; 3; 4; 5; 6; 7; 8]" to "N s = <ref> [8; 7; 6; 5; 4; 3; 2; 1] </ref>". <p> range bfb (1; N; N s) in equation (4.1), will consist of a number of 8! = 40,320 (intermediate) answers, ranging from "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" to "N s = [8; 7; 6; 5; 4; 3; 2; 1]". Obviously, only "N s = [1; 2; 3; 4; 5; 6; 7; 8]" will be useful at generating "N = 8" and all the others will be tossed away during the execution of "range bfb (1; N; N s)" since based on the definition of the recursion "range (1; N; N s)", N s must be <p> (U ) pushed in) confines the possible generated list for the first argument of queens at each iteration to be mono inc list only, which reduces substantially the size of intermediate relations to be generated in the execution of queens ffb and will generate only one list: "N s = <ref> [1; 2; 3; 4; 5; 6; 7; 8] </ref>" after the execution of queens ffb (compared to 40,320 lists of N s otherwise). 2 9 The analysis of Example 5.2 shows that some logic programs, initially designed by programmers with the program execution in one direction in mind, such as select fbf <p> For example, the queens and select recursions of Fig. 3 can be compiled into the chain forms as shown in Fig. 7, by treating the lower level IDB predicates as EDB ones. Such a compilation process, studied in [9] and implemented in <ref> [8] </ref>, greatly facilitates chain-based query analysis and evaluation for linear and nested linear recursions. Query and constraint analysis is performed when a query is posed to the system. <p> computes more information in the semi-naive evaluation than that strictly required by the query, and thus involves more computation. * The chain-based evaluation method can evaluate queries in different modes and programs with different predicate/rule ordering and thus can evaluate all the four combinations based on our analysis and experimentation <ref> [8] </ref>.
Reference: [9] <author> J. Han and K. Zeng. </author> <title> Automatic generation of compiled forms for linear recursions. </title> <journal> Information Systems, </journal> <volume> 17 </volume> <pages> 299-322, </pages> <year> 1992. </year>
Reference-contexts: The compilation of such a recursion is performed by first transforming it into a function-free recursion using a function-predicate transformation [6], then treating every lower level IDB predicate as an EDB predicate and normalizing the recursions at every level <ref> [9] </ref>. Example 2.1 The n-queens program of Fig. 1 is normalized to Fig. 3. Notice that cons (M; N s; M N s) is a built-in list construction predicate indicating M N s = [M jN s]. <p> A query, "? sort (Original List; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers. <p> For example, the queens and select recursions of Fig. 3 can be compiled into the chain forms as shown in Fig. 7, by treating the lower level IDB predicates as EDB ones. Such a compilation process, studied in <ref> [9] </ref> and implemented in [8], greatly facilitates chain-based query analysis and evaluation for linear and nested linear recursions. Query and constraint analysis is performed when a query is posed to the system. <p> The chain-based query evaluation method is based on the compilation of each recursion in the program into a highly regular chain form on which systematic query analysis can be performed to determine the termination of a program and generate efficient query evaluation plans. Based on the studies in <ref> [7, 9] </ref>, linear and nested linear recursions can be compiled into highly regular chain forms. Some nonlinear recursions can be compiled into chain or pseudo-chain forms (a pseudo-chain form is similar to the chain form except each chain element also grows with certain regularity). <p> Second, it evaluates a program declaratively (i.e., in order-independent and query-mode independent fashion), and thus requires sophisticated query analysis and query optimization techniques. The limitation of the chain-based query evaluation technique is that the compilation method is confined to the recursions that can be compiled into highly regular forms <ref> [9] </ref>. In contrast, the Magic Sets method is applicable to general function-free recursions. However, the chain-based evaluation method facilitates quantitative analysis of 13 compiled recursions and, therefore, can reduce search space more accurately than the Magic Sets method.
Reference: [10] <author> L. J. Henschen and S. Naqvi. </author> <title> On compiling queries in recursive first-order databases. </title> <journal> J. ACM, </journal> <volume> 31 </volume> <pages> 47-85, </pages> <year> 1984. </year>
Reference-contexts: However, these methodologies enforce strong restrictions on the ordering of the predicates/rules in a given program, which is not declarative programming in a rigorous sense. Efficient implementations of deductive database programs have been studied extensively in recent deductive database research <ref> [1, 2, 3, 6, 10, 22] </ref>. <p> A query, "? sort (Original List; <ref> [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] </ref>", will generate 10! = 3,628,800 answers (more than 3 million answers). The program will not terminate until it generates all the answers.
Reference: [11] <author> B. Jiang. </author> <title> A suitable algorithm for computing partial transitive closures. </title> <booktitle> In Proc. 6th Int. Conf. Data Engineering, </booktitle> <pages> pages 264-271, </pages> <address> Los Angeles, CA, </address> <month> February </month> <year> 1990. </year>
Reference-contexts: Efficient implementations of deductive database programs have been studied extensively in recent deductive database research [1, 2, 3, 6, 10, 22]. Besides algorithms for evaluation of function-free Datalog programs, such as partial transitive closure algorithms <ref> [11] </ref>, Magic Sets and Counting [1], etc., other interesting techniques have also been developed for evaluation of logic programs involving relatively sophisticated functions and queries [4, 23, 22, 6, 16]. fl The work was supported in part by the Natural Sciences and Engineering Research Council of Canada under the grant OPG-3723
Reference: [12] <author> R. E. Korf. </author> <title> Linear-space best-first search: Summary of results. </title> <booktitle> In Proc. 10th National Conf. on AI, AAAI-92, </booktitle> <pages> pages 533-538, </pages> <address> San Jose, CA, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: Similar comments can be applied to the EKS-V1 system [25] which adopts the query-subquery evaluation approach. The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction <ref> [14, 18, 12, 26, 21] </ref>. Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [14, 18]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought [12, 26, 21]. <p> Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [14, 18]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought <ref> [12, 26, 21] </ref>. Our chain-based evaluation approach is different from those studies in two aspects. First, it finds all the answers instead of a few (sub)optimal ones to a query.
Reference: [13] <author> H. F. Korth and A. Silberschatz. </author> <title> Database System Concepts, </title> <publisher> 2ed. McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: A relational database query, specified either in SQL, relational calculus, or relational algebra, can be evaluated declaratively and efficiently in relational database systems <ref> [13, 22] </ref>. The goal of the deductive database research [17] is to integrate logic programming and database technologies and extend declarative programming to a more general class of logic programs beyond relational ones.
Reference: [14] <author> A. K. Mackworth. </author> <title> Constraint satisfaction. </title> <editor> In S. Shapiro, editor, </editor> <booktitle> Encyclopedia of Artificial Intelligence, </booktitle> <pages> pages 285-293. </pages> <publisher> John Wiley and Sons, Inc., </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Similar comments can be applied to the EKS-V1 system [25] which adopts the query-subquery evaluation approach. The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction <ref> [14, 18, 12, 26, 21] </ref>. Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [14, 18]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought [12, 26, 21]. <p> The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction [14, 18, 12, 26, 21]. Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction <ref> [14, 18] </ref>. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought [12, 26, 21]. Our chain-based evaluation approach is different from those studies in two aspects.
Reference: [15] <author> M. J. Maher and P. J. Stuckey. </author> <title> Expanding query power in constraint logic programming languages. </title> <booktitle> In Proc. 1989 North American Conf. Logic Programming, </booktitle> <pages> pages 20-36, </pages> <address> Cleveland, OH, </address> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: In this study, a typical logic program, an n-queens recursion, is taken as an example to investigate the methodologies of declarative evaluation of logic programs. The n-queens recursion is a classical example in the study of logic programming, constraint satisfaction and search methodologies <ref> [19, 24, 15] </ref>. However, these methodologies enforce strong restrictions on the ordering of the predicates/rules in a given program, which is not declarative programming in a rigorous sense. Efficient implementations of deductive database programs have been studied extensively in recent deductive database research [1, 2, 3, 6, 10, 22]. <p> Obviously, this is quite different from the implementations of Prolog [19] which perform no systematic rule compilation and query analysis, and therefore, cannot judge termination, enforce sophisticated constraints, determine appropriate rule/predicate ordering, nor derive efficient query evaluation plans. Recent studies on constraint logic programming, such as <ref> [24, 15] </ref>, enforce more constraints than Prolog but still confine the program evaluation ordering mainly to those given by programmers. 12 7.1 Applicable domains of the methodology An interesting question is how far this chain-based evaluation methodology can be pushed forward towards declarative programming in general logic programs.
Reference: [16] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Coral control, relations and logic. </title> <booktitle> In Proc. 18th Int. Conf. Very Large Data Bases, </booktitle> <pages> pages 547-559., </pages> <address> Vancouver, Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Besides algorithms for evaluation of function-free Datalog programs, such as partial transitive closure algorithms [11], Magic Sets and Counting [1], etc., other interesting techniques have also been developed for evaluation of logic programs involving relatively sophisticated functions and queries <ref> [4, 23, 22, 6, 16] </ref>. fl The work was supported in part by the Natural Sciences and Engineering Research Council of Canada under the grant OPG-3723 and a research grant from the Centre for Systems Science of Simon Fraser University. <p> Recent studies on deductive databases have developed a bottom-up query evaluation method, such as the Magic Sets method and its variations, for efficient evaluation of recursions <ref> [22, 4, 23, 16] </ref>. The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. <p> The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. Several deductive database system prototypes, such as LDL [4], ADITI [23], NAIL! [22], CORAL <ref> [16] </ref>, etc. are constructed based on this approach. <p> For example, the Magic Sets method cannot evaluate the nqueens recursion in predicate order-independent and query-mode independent fashion <ref> [16] </ref>. Similar comments can be applied to the EKS-V1 system [25] which adopts the query-subquery evaluation approach. The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction [14, 18, 12, 26, 21]. <p> Prolog execution, we assume that the complete set of answers of Q 2 are found by forced backtracking. * The magic sets method can only perform limited re-ordering of predicates in functional logic programs and can only evaluate Q 1 on P 1 correctly, to the best of our knowledge <ref> [16] </ref>. Moreover, the method requires two rounds of computation: the derivation of magic sets and the bottom-up evaluation.
Reference: [17] <author> R. Ramakrishnan and J. D. Ullman. </author> <title> A survey of research on deductive database systems. </title> <journal> In Journal of Logic Programming, </journal> <note> (to appear), </note> <year> 1993. </year>
Reference-contexts: A relational database query, specified either in SQL, relational calculus, or relational algebra, can be evaluated declaratively and efficiently in relational database systems [13, 22]. The goal of the deductive database research <ref> [17] </ref> is to integrate logic programming and database technologies and extend declarative programming to a more general class of logic programs beyond relational ones. In this study, a typical logic program, an n-queens recursion, is taken as an example to investigate the methodologies of declarative evaluation of logic programs.
Reference: [18] <author> J.M. Siskind and D. A. McAllester. </author> <title> Nondeterministic lisp as a substrate for constraint logic programming. </title> <booktitle> In Proc. 11th National Conf. on AI, AAAI-93, </booktitle> <pages> pages 133-138, </pages> <address> Washington, D.C., </address> <month> July </month> <year> 1993. </year>
Reference-contexts: Similar comments can be applied to the EKS-V1 system [25] which adopts the query-subquery evaluation approach. The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction <ref> [14, 18, 12, 26, 21] </ref>. Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [14, 18]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought [12, 26, 21]. <p> The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction [14, 18, 12, 26, 21]. Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction <ref> [14, 18] </ref>. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought [12, 26, 21]. Our chain-based evaluation approach is different from those studies in two aspects.
Reference: [19] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: In this study, a typical logic program, an n-queens recursion, is taken as an example to investigate the methodologies of declarative evaluation of logic programs. The n-queens recursion is a classical example in the study of logic programming, constraint satisfaction and search methodologies <ref> [19, 24, 15] </ref>. However, these methodologies enforce strong restrictions on the ordering of the predicates/rules in a given program, which is not declarative programming in a rigorous sense. Efficient implementations of deductive database programs have been studied extensively in recent deductive database research [1, 2, 3, 6, 10, 22]. <p> The method is illustrated by the query analysis on the n-queens recursion defined in Example 1.1. Example 1.1 A typical n-queens Prolog program (adapted from <ref> [19] </ref>), but treated as a purely declarative logic program, is presented in Fig. 1. <p> For example, the constraint pushing using the property of mono inc list will reduce the number of intermediate nodes to be generated in the execution of a permutation sort program <ref> [19] </ref> from O (n!) to O (n 2 ). 6 Outline of Principles behind the Evaluation of the Nqueens Recursion The step-by-step analysis of the nqueens recursion in the previous sections presented an organized picture on compilation, query and constraint analysis, and evaluation of a typical nested linear recursion. <p> Moreover, it derives the complete set of answers and terminates properly. Obviously, this is quite different from the implementations of Prolog <ref> [19] </ref> which perform no systematic rule compilation and query analysis, and therefore, cannot judge termination, enforce sophisticated constraints, determine appropriate rule/predicate ordering, nor derive efficient query evaluation plans.
Reference: [20] <author> H. S. Stone and J. M. Stone. </author> <title> Efficient search techniques an empirical study of the n-queens problem. </title> <journal> IBM J. Res. Develop., </journal> <volume> 31 </volume> <pages> 464-474, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Example 1.1 A typical n-queens Prolog program (adapted from [19]), but treated as a purely declarative logic program, is presented in Fig. 1. The recursion is adopted in this study because it is a classical example for studying search methods <ref> [5, 20] </ref>, and it can be elegantly defined by a nested linear recursion (see Section 2). nqueens (N; Qs) range (1; N; N s); queens (N s; []; Qs): (1.1) range (M; N; [M jN s]) M &lt; N; M 1 is M + 1; range (M 1 ; N; N
Reference: [21] <author> L. A. Taylor and R. E. Korf. </author> <title> Pruning duplicate nodes in depth-first search. </title> <booktitle> In Proc. 11th National Conf. on AI, AAAI-93, </booktitle> <pages> pages 756-761, </pages> <address> Washington, D.C., </address> <month> July </month> <year> 1993. </year>
Reference-contexts: Similar comments can be applied to the EKS-V1 system [25] which adopts the query-subquery evaluation approach. The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction <ref> [14, 18, 12, 26, 21] </ref>. Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [14, 18]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought [12, 26, 21]. <p> Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [14, 18]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought <ref> [12, 26, 21] </ref>. Our chain-based evaluation approach is different from those studies in two aspects. First, it finds all the answers instead of a few (sub)optimal ones to a query.
Reference: [22] <author> J. D. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> Vol. 2. </volume> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: A relational database query, specified either in SQL, relational calculus, or relational algebra, can be evaluated declaratively and efficiently in relational database systems <ref> [13, 22] </ref>. The goal of the deductive database research [17] is to integrate logic programming and database technologies and extend declarative programming to a more general class of logic programs beyond relational ones. <p> However, these methodologies enforce strong restrictions on the ordering of the predicates/rules in a given program, which is not declarative programming in a rigorous sense. Efficient implementations of deductive database programs have been studied extensively in recent deductive database research <ref> [1, 2, 3, 6, 10, 22] </ref>. <p> Besides algorithms for evaluation of function-free Datalog programs, such as partial transitive closure algorithms [11], Magic Sets and Counting [1], etc., other interesting techniques have also been developed for evaluation of logic programs involving relatively sophisticated functions and queries <ref> [4, 23, 22, 6, 16] </ref>. fl The work was supported in part by the Natural Sciences and Engineering Research Council of Canada under the grant OPG-3723 and a research grant from the Centre for Systems Science of Simon Fraser University. <p> In Section 7, the strength and limitations of our method are analyzed and compared with other approaches. Our discussion is summarized in Section 8. 2 Compilation of Recursive Logic Programs As a preliminary exploration of the methodology, our study is confined to Horn-clause logic programs with stratified negation <ref> [22] </ref>. Such logic programs are treated as a deductive database consisting of (i) an extensional database (EDB) (a set of predicates defined by variable-free facts), (ii) an intensional database (IDB) (a set of predicates defined by deduction rules specified in Horn-clauses), and (iii) a set of integrity constraints (ICs). <p> The motivation of such analyses is to characterize the behavior of a recursion and facilitate the selection of an appropriate evaluation order and the generation of efficient evaluation plans. Binding propagation analysis determines the bound-free (i.e., bf) adornments <ref> [22] </ref> for each variable in the rule based on the query information, the finite evaluability of a predicate, the termination of an (iterative) evaluation, and the evaluation efficiency. <p> The predicate evaluation order is strongly influenced by this analysis. Example 3.1 Suppose the binding pattern <ref> [2, 22] </ref> in the recursion nqueens (N; Qs) is bf, which indicates that the first argument is bound and the second one is free, such as "? nqueens (4; Qs)". The propagation of the bf binding in the recursion is as follows. <p> Recent studies on deductive databases have developed a bottom-up query evaluation method, such as the Magic Sets method and its variations, for efficient evaluation of recursions <ref> [22, 4, 23, 16] </ref>. The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. <p> The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. Several deductive database system prototypes, such as LDL [4], ADITI [23], NAIL! <ref> [22] </ref>, CORAL [16], etc. are constructed based on this approach.
Reference: [23] <author> J. Vaghani, K. Ramamohanarao, D. Kemp, Z. Somogyi, and P. Stuckey. </author> <title> An introduction to the ADITI deductive database system. </title> <journal> Australian Computer Journal, </journal> <volume> 23 </volume> <pages> 37-52, </pages> <year> 1991. </year>
Reference-contexts: Besides algorithms for evaluation of function-free Datalog programs, such as partial transitive closure algorithms [11], Magic Sets and Counting [1], etc., other interesting techniques have also been developed for evaluation of logic programs involving relatively sophisticated functions and queries <ref> [4, 23, 22, 6, 16] </ref>. fl The work was supported in part by the Natural Sciences and Engineering Research Council of Canada under the grant OPG-3723 and a research grant from the Centre for Systems Science of Simon Fraser University. <p> Recent studies on deductive databases have developed a bottom-up query evaluation method, such as the Magic Sets method and its variations, for efficient evaluation of recursions <ref> [22, 4, 23, 16] </ref>. The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. <p> The method applies set-oriented processing, confines its search to the portion of the database relevant to a query, and evaluates order-independent and query mode-independent function-free logic programs completely and correctly. Several deductive database system prototypes, such as LDL [4], ADITI <ref> [23] </ref>, NAIL! [22], CORAL [16], etc. are constructed based on this approach.
Reference: [24] <author> P. van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: In this study, a typical logic program, an n-queens recursion, is taken as an example to investigate the methodologies of declarative evaluation of logic programs. The n-queens recursion is a classical example in the study of logic programming, constraint satisfaction and search methodologies <ref> [19, 24, 15] </ref>. However, these methodologies enforce strong restrictions on the ordering of the predicates/rules in a given program, which is not declarative programming in a rigorous sense. Efficient implementations of deductive database programs have been studied extensively in recent deductive database research [1, 2, 3, 6, 10, 22]. <p> Obviously, this is quite different from the implementations of Prolog [19] which perform no systematic rule compilation and query analysis, and therefore, cannot judge termination, enforce sophisticated constraints, determine appropriate rule/predicate ordering, nor derive efficient query evaluation plans. Recent studies on constraint logic programming, such as <ref> [24, 15] </ref>, enforce more constraints than Prolog but still confine the program evaluation ordering mainly to those given by programmers. 12 7.1 Applicable domains of the methodology An interesting question is how far this chain-based evaluation methodology can be pushed forward towards declarative programming in general logic programs.
Reference: [25] <author> L. Vieille, P. Bayer, V. Kuchenhoff, and A. Lefebvre. EKS-V1, </author> <title> a short overview. </title> <booktitle> In AAAI-90 Workshop on Knowledge Base Management Systems, </booktitle> <address> Boston, MA, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: For example, the Magic Sets method cannot evaluate the nqueens recursion in predicate order-independent and query-mode independent fashion [16]. Similar comments can be applied to the EKS-V1 system <ref> [25] </ref> which adopts the query-subquery evaluation approach. The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction [14, 18, 12, 26, 21].
Reference: [26] <author> W. Zhang and R. E. Korf. </author> <title> Depth-first vs. best-first search: New results. </title> <booktitle> In Proc. 11th National Conf. on AI, AAAI-93, </booktitle> <pages> pages 769-775, </pages> <address> Washington, D.C., </address> <month> July </month> <year> 1993. </year> <month> 16 </month>
Reference-contexts: Similar comments can be applied to the EKS-V1 system [25] which adopts the query-subquery evaluation approach. The evaluation of the n-queens program or other similar programs has also been studied extensively from the point of view of search and constraint satisfaction <ref> [14, 18, 12, 26, 21] </ref>. Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [14, 18]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought [12, 26, 21]. <p> Unification operation in the kernel of logic programming can also be viewed as constraint satisfaction [14, 18]. Much effort has been exercised to improve the classical heuristic search strategies, where an optimal node is to be sought <ref> [12, 26, 21] </ref>. Our chain-based evaluation approach is different from those studies in two aspects. First, it finds all the answers instead of a few (sub)optimal ones to a query.
References-found: 26

