URL: http://http.cs.berkeley.edu/~asah/papers/other/classics/role-distrib-state.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/classics/index.html
Root-URL: http://www.cs.berkeley.edu
Title: The Role of Distributed State  
Author: John K. Ousterhout 
Address: Berkeley, CA 94720  
Affiliation: Computer Science Division Electrical Engineering and Computer Sciences University of California  
Abstract: Distributed state offers the potential for improving the performance, coherency, and reliability of distributed systems. Unfortunately, distributed state also introduces consistency problems, crash sensitivity, time and space overheads, and complexity; these problems make it difficult to achieve the potential benefits. This paper describes the advantages and disadvantages of distributed state, and presents the NFS and Sprite file systems as examples of different tradeoffs. It does not appear possible to achieve all the advantages of distributed state and also avoid all the problems; rather, system designers must make compromises based on the needs of their individual environments. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bartlett, J. </author> <title> ``A NonStop Kernel.'' </title> <booktitle> Proceedings of the 8th Symposium on Operating Systems Principles, Operating Systems Review, </booktitle> <volume> Vol. 15, No. 5, </volume> <month> December, </month> <year> 1981, </year> <pages> pp. 22-29. </pages>
Reference-contexts: In fact, NFS servers cannot keep track of this information: there are no ``open'' or ``close'' requests to indicate when clients start and stop using files. NFS clients do keep distributed state, however. This state includes the following: <ref> [1] </ref> File identifiers, returned by the lookup request and used in other requests, such as read. [2] File data, returned by read operations and cached on clients to eliminate server requests if the information is re-used. [3] File attributes, returned by lookup and other requests. [4] Name translations (results of recent <p> The protocol between clients and servers is definitely not stateless in Sprite; we call it ``stateful'' for lack of a better term. Three additional pieces of distributed state are kept in Sprite: <ref> [1] </ref> Servers keep information in their main memories about which workstations are reading or writing which files.
Reference: [2] <author> Birrell, Andrew D., et al. ``Grapevine: </author> <title> An Exercise in Distributed Computing.'' </title> <journal> Communications of the ACM, </journal> <volume> Vol. 25, No. 4, </volume> <month> April </month> <year> 1982, </year> <pages> pp. 260-274. </pages>
Reference-contexts: Another example is the Grapevine mail system, where it can take several minutes for certain changes in configuration (such as the addition of a new user) to become visible everywhere in the system <ref> [2] </ref>. <p> NFS clients do keep distributed state, however. This state includes the following: [1] File identifiers, returned by the lookup request and used in other requests, such as read. <ref> [2] </ref> File data, returned by read operations and cached on clients to eliminate server requests if the information is re-used. [3] File attributes, returned by lookup and other requests. [4] Name translations (results of recent calls to lookup), cached on clients in order to bypass future calls to lookup for the <p> Three additional pieces of distributed state are kept in Sprite: [1] Servers keep information in their main memories about which workstations are reading or writing which files. This requires clients to notify servers whenever files are opened or closed, but allows the servers to enforce consistency as described below. <ref> [2] </ref> Servers retain modified file blocks in their main memories, and do not write that information back to disk until it has aged for thirty seconds. [3] Clients also retain modified file blocks in their main memories; they do not pass new information back to servers until it has aged for
Reference: [3] <author> Borg, A., et al. </author> <title> ``Fault Tolerance Under UNIX.'' </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 7, No. 1, </volume> <month> February </month> <year> 1989, </year> <pages> pp. 1-24. </pages>
Reference-contexts: NFS clients do keep distributed state, however. This state includes the following: [1] File identifiers, returned by the lookup request and used in other requests, such as read. [2] File data, returned by read operations and cached on clients to eliminate server requests if the information is re-used. <ref> [3] </ref> File attributes, returned by lookup and other requests. [4] Name translations (results of recent calls to lookup), cached on clients in order to bypass future calls to lookup for the same fileIds and names. <p> This requires clients to notify servers whenever files are opened or closed, but allows the servers to enforce consistency as described below. [2] Servers retain modified file blocks in their main memories, and do not write that information back to disk until it has aged for thirty seconds. <ref> [3] </ref> Clients also retain modified file blocks in their main memories; they do not pass new information back to servers until it has aged for thirty seconds or until the - 10 - The Role of Distributed State February 19, 1990 information is needed by some other client.
Reference: [4] <author> Guralnik, D., </author> <title> Editor in Chief. Webster's New World Dictionary, Second College Edition, </title> <publisher> Simon & Schuster, </publisher> <year> 1982. </year>
Reference-contexts: 1. Introduction Webster's New World Dictionary defines state as ``a set of circumstances or attributes characterizing a person or thing at a given time'' <ref> [4] </ref>. State plays a fundamental role in all computer systems. One way of characterizing computation is as a set of operations applied to an initial state in order to produce some (presumably more interesting) final state. <p> This state includes the following: [1] File identifiers, returned by the lookup request and used in other requests, such as read. [2] File data, returned by read operations and cached on clients to eliminate server requests if the information is re-used. [3] File attributes, returned by lookup and other requests. <ref> [4] </ref> Name translations (results of recent calls to lookup), cached on clients in order to bypass future calls to lookup for the same fileIds and names.
Reference: [5] <author> Howard, J., et al. </author> <title> ``Scale and Performance in a Distributed File System.'' </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 6, No. 1, </volume> <month> February </month> <year> 1988, </year> <pages> pp. 51-81. </pages>
Reference-contexts: by contacting a file server to see if a cached copy of a file contains the most recent version), or some party must keep track of the distributed copies and notify each owner of a copy when the state changes (for example, the file servers in AFS perform this function <ref> [5] </ref>). If replicated copies are to be kept up-to-date then each update must be reflected in each of the copies. This overhead can make replicated updates substantially more expensive than non-replicated ones. <p> A performance comparison of the NFS and Sprite file systems on a modified version of the Andrew benchmark devised by M. Satyanarayanan <ref> [5] </ref>. The ``Sprite'' column gives the elapsed time for a diskless client to complete the benchmark when both the client and server machines were running Sprite. <p> It would be possible to extend the Sprite mechanism so that clients cache naming information and need not contact the servers on every open or close; the Andrew file system already implements such a mechanism <ref> [5] </ref>. However, such a mechanism would add to the distributed state, thereby increasing the complexity of clients and servers (particularly because the cached naming information would have to be kept consistent).
Reference: [6] <author> Lampson, B. </author> <title> ``Hints for Computer System Design.'' </title> <booktitle> Proceedings of the 10th Symposium on Operating Systems Principles, Operating Systems Review, </booktitle> <volume> Vol. 17, No. 5, </volume> <month> December, </month> <year> 1985, </year> <pages> pp. 33-48. </pages>
Reference-contexts: In these cases, there is no need to update all the copies when one changes. If an attempt is made to use stale information, its staleness will be noticed and a fresh copy of the information can be fetched. As pointed out by Lampson <ref> [6] </ref>, the name-to-address map is an example of this approach. Suppose that there is a change in the address corresponding to a given name.
Reference: [7] <author> Nelson, M. </author> <title> Physical Memory Management in a Network Operating System. </title> <type> Ph.D. Dissertation, technical report UCB/CSD 88/471, </type> <institution> Computer Science Division, University of California at Berkeley, </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: On identical hardware configurations, the benchmark ran 45% to 110% slower under UNIX/NFS than under Sprite. Mike Nelson's dissertation shows that most of the performance difference is due to the difference in writing policy between the two systems <ref> [7] </ref>. 5.2. Disadvantages of Sprite Unfortunately, the stateful approach used in Sprite has disadvantages as well as advantages. The paragraphs below discuss four problems we had to face in Sprite: complexity, recovery, performance, and space overhead. First, Sprite's file system is more complex than NFS.
Reference: [8] <author> Nelson, M., Welch, B., and Ousterhout, J. </author> <title> ``Caching in the Sprite Network File System.'' </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 6, No. 1, </volume> <month> February </month> <year> 1988, </year> <pages> pp. 134-154. </pages>
Reference-contexts: For example, in the Sprite system if a file is being modified by one workstation while being read by another workstation, then neither is allowed to cache the file; all read and write operations are passed through to the server and applied to its single copy of the file <ref> [8] </ref>. In Locus, it is possible for a file to be replicated on different disks attached to different servers [12]. If the file is modified, the changes are applied initially to a single copy of the file and then propagated to the other copies.
Reference: [9] <author> Ousterhout, J., et al. </author> <title> ``A Trace-Driven Analysis of the UNIX 4.2 BSD File System.'' </title> <booktitle> Proceedings of the Tenth Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1985, </year> <pages> pp. 15-24. </pages>
Reference-contexts: Write-through-on-close has two unpleasant consequences. First, it delays the closing process until the data is written to disk. Second, it results in unnecessary load on the server and the disk. Many files are deleted or overwritten shortly after they are created <ref> [9] </ref>; if new data were retained for a while on the client before transmitting it to the server, much of the new data would be deleted and would never need to be transferred to the server or disk at all.
Reference: [10] <author> Ousterhout, J., et al. </author> <title> ``The Sprite Network Operating System.'' </title> <journal> IEEE Computer, </journal> <volume> Vol. 21, No. 2, </volume> <month> February </month> <year> 1988, </year> <pages> pp. 23-36. </pages>
Reference: [11] <author> Ousterhout, J. </author> <title> ``Why Aren't Operating Systems Getting Faster as Fast as Hardware?'' Technical note TN-11, </title> <institution> DEC Western Research Laboratory, </institution> <month> October </month> <year> 1989. </year> - <title> 16 - The Role of Distributed State February 19, </title> <year> 1990 </year>
Reference-contexts: The ``Slowdown'' column indicates how much slower NFS was than Sprite. In each case the server machine was the same type as the client machine. See <ref> [11] </ref> for details of the benchmarking. network indicate that only about 50% of newly written data is ever returned to the file server [15]. Table I compares the performance of Sprite and UNIX/NFS for a file-intensive benchmark.
Reference: [12] <author> Popek, G. and Walker, B., eds. </author> <title> The LOCUS Distributed System Architecture. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: In Locus, it is possible for a file to be replicated on different disks attached to different servers <ref> [12] </ref>. If the file is modified, the changes are applied initially to a single copy of the file and then propagated to the other copies. During the propagation period all accesses to the file are directed to the one up-to-date copy. Tolerate inconsistency. <p> In NFS there is not enough replicated state to permit access to a server's files while it is down, and this is a disadvantage (which, by the way, is shared by almost all network file systems; the best-known counter-example is Locus <ref> [12] </ref>). But NFS has the important property of allowing client machines to survive server crashes without rebooting; the crash results only in delay, not in loss of state. Another advantage of the NFS protocol is its simplicity, which stems directly from the stateless nature of the protocol.
Reference: [13] <author> Sandberg, R., et al. </author> <title> ``Design and Implementation of the Sun Network Filesystem.'' </title> <booktitle> Proceedings of the USENIX 1985 Summer Conference, </booktitle> <month> June </month> <year> 1985, </year> <pages> pp. 119-130. </pages>
Reference-contexts: NFS is a commercial product; it was originally developed by Sun Microsystems but it has become a de facto standard supported by almost all workstation vendors <ref> [13] </ref>. The Sprite file system was developed in a research project at the University of California at Berkeley [8,10].
Reference: [14] <author> Satyanarayanan, M., et al. Coda: </author> <title> A Highly Available File System for a Distributed Workstation Environment. </title> <type> Technical report CMU-CS-89-165, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> July </month> <year> 1989. </year>
Reference: [15] <author> Welch, B. </author> <title> Naming, State Management, and User-Level Extensions in the Sprite Distributed File System. </title> <type> Ph.D. Dissertation, </type> <institution> University of California at Berke-ley, </institution> <year> 1990. </year> <month> - 17 </month> - 
Reference-contexts: The ``Slowdown'' column indicates how much slower NFS was than Sprite. In each case the server machine was the same type as the client machine. See [11] for details of the benchmarking. network indicate that only about 50% of newly written data is ever returned to the file server <ref> [15] </ref>. Table I compares the performance of Sprite and UNIX/NFS for a file-intensive benchmark. On identical hardware configurations, the benchmark ran 45% to 110% slower under UNIX/NFS than under Sprite.
References-found: 15

