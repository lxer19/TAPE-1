URL: http://www.cs.columbia.edu/mcl/papers/path-lookup.ps.gz
Refering-URL: http://www.cs.columbia.edu/mcl/publication.html
Root-URL: http://www.cs.columbia.edu
Title: Optimistic Lookup of Whole NFS Paths in a Single Operation  
Author: Dan Duchamp 
Affiliation: Columbia University  
Abstract: VFS lookup code examines and translates path names one component at a time, checking for special cases such as mount points and symlinks. VFS calls the NFS lookup operation as necessary. NFS employs caching to reduce the number of lookup operations that go to the server. However, when part or all of a path is not cached, NFS lookup operations go back to the server. Although NFS's caching is effective, component-by-component translation of an uncached path is inefficient, enough so that lookup is typically the operation most commonly processed by servers. We study the effect of augmenting the VFS lookup algorithm and the NFS protocol so that a client can ask a server to translate an entire path in a single operation. The preconditions for a successful request are usually but not always satisfied, so the algorithm is optimistic. This small change can deliver substantial improvements in client latency and server load. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. R. Cheriton and T. P. Mann. </author> <title> Decentralizing a Global Naming Service for Improved Performance and Fault Tolerance. </title> <journal> ACM Trans. Computer Systems, </journal> <volume> 7(2) </volume> <pages> 147-183, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: However, the notion of looking up and caching whole or partial paths has been proposed before for new file system designs <ref> [9, 1] </ref>. In 1986 Welch and Ousterhout described "prefix tables" [9]. Prefix tables are useful in an environment where a shared global hierarchy of files is partitioned into "domains," which are spread across servers. <p> In these cases, the client must check its prefix table to learn which server to send the remainder of the path to. In summary, prefix tables is an elegant idea but one targeted for a significantly different and easier model of file system definition and use. In <ref> [1] </ref>, Cheriton and Mann describe a naming system that is scalable enough to encompass the world and general enough to name many types of objects (not just files | processes, windows, network connections, etc.) Since the features that draw most of their design attention are those that permit scaling to enormous
Reference: [2] <author> C. G. Gray and D. R. Cheriton. Leases: </author> <title> An Efficient Fault-Tolerant Mechanism for Distributed File Cache Consistency. </title> <booktitle> In Proc. Twelfth ACM Symp. Operating Systems Principles, </booktitle> <pages> pages 202-210, </pages> <month> Decem-ber </month> <year> 1989. </year>
Reference-contexts: NQNFS differs from Spritely NFS in that the latter requires the server to keep state indicating the cache status of files at clients; however, NQNFS borrows the "lease" idea from Gray and Cheriton <ref> [2] </ref> in order to avoid the need for servers to keep state across failures. In NQNFS, a client is allowed to cache a file for a specified period of time.
Reference: [3] <author> R. Macklem. </author> <title> Not Quite NFS, Soft Cache Consistency for NFS. </title> <booktitle> In Proc. 1994 Winter USENIX, </booktitle> <pages> pages 261-278, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: The ideas in Spritely NFS were used in modified form in "NQNFS" <ref> [3] </ref> which is a second protocol available from the NFS implementation of 4.4BSD.
Reference: [4] <author> M. N. Nelson, B. B. Welch, and J. K. Ouster-hout. </author> <title> Caching in the Sprite Network File System. </title> <journal> ACM Trans. Computer Systems, </journal> <volume> 6(1) </volume> <pages> 134-154, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: One early experiment is "Spritely NFS" [6], in which a callback scheme similar to that in Sprite <ref> [4] </ref> was added to NFS with the intention of providing strict cache consistency and improving performance by eliminating the overhead of refreshing the attribute cache with getattr.
Reference: [5] <author> J. Pendry and N. Williams. </author> <title> Amd The 4.4 BSD Automounter. </title> <institution> Imperial College of Science, Technology, and Medicine, </institution> <address> London, 5.3 alpha edition, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: The high number of null operations is attributable to our use of the Amd automounter <ref> [5] </ref>; Amd periodically "pings" every mounted file system, and NFS null is the ping operation. While the high number of null operations can thus be dismissed as site-specific, the dominance of getattr and lookup is typical for most NFS installations | as the operation mix in nhfsstone indicates.
Reference: [6] <author> V. Srinivasan and J. C. Mogul. Spritely NFS: </author> <title> Implementation and Performance of Cache-Consistency Protocols. </title> <type> Research report 89/5, </type> <institution> DEC Western Research Lab, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Most such interest has focused on getattr, although in most experiments the motivation has not been simply to reduce the frequency of getattr but rather to improve the consistency guarantee provided to the client by an NFS server. One early experiment is "Spritely NFS" <ref> [6] </ref>, in which a callback scheme similar to that in Sprite [4] was added to NFS with the intention of providing strict cache consistency and improving performance by eliminating the overhead of refreshing the attribute cache with getattr.
Reference: [7] <author> Sun Microsystems, Inc. NFS: </author> <title> Network File System Protocol Specification. </title> <type> RFC 1094, </type> <institution> IETF Network Working Group, </institution> <month> March </month> <year> 1989. </year>
Reference-contexts: An additional reason why the VFS lookup algorithm proceeds component-by-component is that the NFS protocol has been designed not to contain pathname syntax in the protocol because of the desirability of keeping operating system dependent detail out of the protocol specification <ref> [7] </ref>. Since NFS and UFS are the major file systems below the VFS layer, VFS algorithms have been designed to cater to their constraints. 2.1 Overview The design of the VFS lookup algorithm is sensible, since every component must be checked for the special cases.
Reference: [8] <author> Sun Microsystems, Inc. NFS: </author> <title> Network File System Version 3 Protocol Specification. </title> <address> June 25, </address> <year> 1993. </year> <note> Available from gatekeeper.dec.com: /pub/standards/nfs/nfsv3.ps.Z </note>
Reference-contexts: The only recovery action a server must take is to wait until such time as all of its leases must have expired. Neither of these systems addresses the issue of reducing lookups. More recently, the specification for version 3 of NFS <ref> [8] </ref> included, among its many changes, the requirement to return attributes as a side effect of every appropriate NFS operation. The intention is to reduce the number of separate getattr operations that must be invoked in order to verify attribute cache consistency.
Reference: [9] <author> B. Welch and J. Ousterhout. </author> <title> Prefix Tables: A Simple Mechanism for Locating Files in a Distributed System. </title> <booktitle> In Sixth Intl. Conf. Distributed Computing Systems, </booktitle> <pages> pages 184-189, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: However, the notion of looking up and caching whole or partial paths has been proposed before for new file system designs <ref> [9, 1] </ref>. In 1986 Welch and Ousterhout described "prefix tables" [9]. Prefix tables are useful in an environment where a shared global hierarchy of files is partitioned into "domains," which are spread across servers. <p> However, the notion of looking up and caching whole or partial paths has been proposed before for new file system designs [9, 1]. In 1986 Welch and Ousterhout described "prefix tables" <ref> [9] </ref>. Prefix tables are useful in an environment where a shared global hierarchy of files is partitioned into "domains," which are spread across servers. Each client maintains a prefix table that maps file name prefixes to the servers on which the associated domains reside.
Reference: [10] <author> E. Zadok and D. Duchamp. </author> <title> Discovery and Hot Replacement of Replicated Read-Only File Systems, with Application to Mobile Computing In Proc. </title> <booktitle> 1993 Summer USENIX, </booktitle> <pages> pages 69-85, </pages> <month> June </month> <year> 1993. </year> <title> Dan Duchamp is an Associate Professor of Computer Science at Columbia University. His current research interest is the various issues in mobile computing. For his initial efforts in this area, he has been named an Office of Naval Research Young Investigator. Mail address: </title> <institution> Computer Science Department, Columbia University, </institution> <address> 500 West 120th Street, New York, NY 10027. </address> <publisher> Email address: djd@cs.columbia.edu. </publisher>
Reference-contexts: Second, to avoid race conditions: after initiating an I/O to access /etc/mtab the kernel would continue; the kernel's next operation might be another that access or manipulates /etc/mtab. Finally, as part of earlier work <ref> [10] </ref>, we had already written some code to store mount point names in struct vfs. 2.2.3 Dot-dot Dot-dot must be handled with care similar to that for mount points.
References-found: 10

