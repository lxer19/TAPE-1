URL: ftp://ftp.cs.umd.edu/pub/papers/TRs/3124.ps.Z
Refering-URL: http://www.cs.umd.edu/projects/hermes/publications/abstracts/papers_akbii.html
Root-URL: 
Email: sibel@cs.umd.edu  vs@cs.umd.edu  
Title: AMALGAMATING KNOWLEDGE BASES, II: DISTRIBUTED MEDIATORS  
Author: SIBEL ADALI and V.S. SUBRAHMANIAN 
Keyword: heterogeneous databases, distributed computing, mediators, software integration, computational logic.  
Note: This work was supported by the Army Research Office under grant number DAAL-03-92-G-0225, and by ARPA/Rome Labs contract F30602-93-C-0241 (ARPA Order Nr. A716).  
Date: Received January 19, 1994 Revised September 15, 1994  
Address: College Park, Maryland 20742.  College Park, Maryland 20742.  
Affiliation: Department of Computer Science, Institute for Advanced Computer Studies, Institute for Systems Research, University of Maryland,  Department of Computer Science, Institute for Advanced Computer Studies, Institute for Systems Research, University of Maryland,  
Abstract: Integrating knowledge from multiple sources is an important aspect of automated reasoning systems. In [23], we presented a uniform declarative and operational framework, based on annotated logics, for amalgamating multiple knowledge bases and data structures (e.g. relational, object-oriented, spatial, and temporal structures) when these knowledge bases (possibly) contain inconsistencies, uncertainties, and non-monotonic modes of negation. We showed that annotated logics may be used, with some modifications, to mediate between different knowledge bases. The multiple knowledge bases are amalgamated by embedding the individual knowledge bases into a lattice. In this paper, we describe how, given a network of sites where the different databases reside, it is possible to define a distributed semantics for amalgamated knowledge bases. More importantly, we study how the mediator may be distributed across multiple sites so that when certain conditions are satisfied, network failures do not affect the end results of queries that a user may pose. We specify different ways of distributing the mediator to protect against different types of network link failures and develop alternative soundness and completeness results. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Adal and V.S. Subrahmanian. </author> <title> (1993) Amalgamating Knowledge Bases, III: Algorithms, Data Structures and Query Processing, </title> <institution> Univ. of Maryland CS-TR-3124, </institution> <month> Aug. </month> <year> 1993. </year> <note> Submitted for journal publication. </note>
Reference-contexts: The organization of the paper is as follows: in Section 2, we outline the basic ideas underlying our mediated framework <ref> [17, 23, 1] </ref>. In Section 3, we present a motivating example that will be used throughout the paper to illustrate the formal definitions. Section 4 explains the syntax and semantics of mediatory knowledge bases this is merely a straightforward combination of [23, 17]. <p> In this paper, we are going to use the truth value lattice (U N C; ) which is the set of all functions from R + to <ref> [0; 1] </ref> where R + denotes the set of nonnegative reals. The ordering on U N C is defined as follows: f 1 f 2 iff for all r 2 R + , f 1 (r) f 2 (r) where is the usual less-than-or-equal-to ordering on the reals. <p> The information stored in databases DB 1 and DB 2 for robots r1 and r2 is given below: DB 1 : max weight capability (r1; 100) : <ref> [1; R + ] </ref> max temperature handling (r1; 65) : [1; R + ] max distance between arms (r1; 20) : [1; R + ] max speed (r1; vertical; 1) : [1; R + ] max speed (r1; horizontal; 2) : [1; R + ] DB 2 : max weight capability <p> The information stored in databases DB 1 and DB 2 for robots r1 and r2 is given below: DB 1 : max weight capability (r1; 100) : <ref> [1; R + ] </ref> max temperature handling (r1; 65) : [1; R + ] max distance between arms (r1; 20) : [1; R + ] max speed (r1; vertical; 1) : [1; R + ] max speed (r1; horizontal; 2) : [1; R + ] DB 2 : max weight capability (r2; 50) : [1; R + ] max temperature handling <p> The information stored in databases DB 1 and DB 2 for robots r1 and r2 is given below: DB 1 : max weight capability (r1; 100) : <ref> [1; R + ] </ref> max temperature handling (r1; 65) : [1; R + ] max distance between arms (r1; 20) : [1; R + ] max speed (r1; vertical; 1) : [1; R + ] max speed (r1; horizontal; 2) : [1; R + ] DB 2 : max weight capability (r2; 50) : [1; R + ] max temperature handling (r2; 90) : [1; R + ] 7 max distance between <p> DB 2 for robots r1 and r2 is given below: DB 1 : max weight capability (r1; 100) : <ref> [1; R + ] </ref> max temperature handling (r1; 65) : [1; R + ] max distance between arms (r1; 20) : [1; R + ] max speed (r1; vertical; 1) : [1; R + ] max speed (r1; horizontal; 2) : [1; R + ] DB 2 : max weight capability (r2; 50) : [1; R + ] max temperature handling (r2; 90) : [1; R + ] 7 max distance between arms (r2; 50) : [1; R + ] max speed <p> DB 1 : max weight capability (r1; 100) : <ref> [1; R + ] </ref> max temperature handling (r1; 65) : [1; R + ] max distance between arms (r1; 20) : [1; R + ] max speed (r1; vertical; 1) : [1; R + ] max speed (r1; horizontal; 2) : [1; R + ] DB 2 : max weight capability (r2; 50) : [1; R + ] max temperature handling (r2; 90) : [1; R + ] 7 max distance between arms (r2; 50) : [1; R + ] max speed (r2; vertical; 2) : [1; R + ] max speed <p> max temperature handling (r1; 65) : <ref> [1; R + ] </ref> max distance between arms (r1; 20) : [1; R + ] max speed (r1; vertical; 1) : [1; R + ] max speed (r1; horizontal; 2) : [1; R + ] DB 2 : max weight capability (r2; 50) : [1; R + ] max temperature handling (r2; 90) : [1; R + ] 7 max distance between arms (r2; 50) : [1; R + ] max speed (r2; vertical; 2) : [1; R + ] max speed (r2; horizontal; 0:5) : [1; R + ] Site 3: Databases DB 3 <p> max distance between arms (r1; 20) : <ref> [1; R + ] </ref> max speed (r1; vertical; 1) : [1; R + ] max speed (r1; horizontal; 2) : [1; R + ] DB 2 : max weight capability (r2; 50) : [1; R + ] max temperature handling (r2; 90) : [1; R + ] 7 max distance between arms (r2; 50) : [1; R + ] max speed (r2; vertical; 2) : [1; R + ] max speed (r2; horizontal; 0:5) : [1; R + ] Site 3: Databases DB 3 ,DB 4 and DB 5 contain sensor information about the <p> speed (r1; vertical; 1) : <ref> [1; R + ] </ref> max speed (r1; horizontal; 2) : [1; R + ] DB 2 : max weight capability (r2; 50) : [1; R + ] max temperature handling (r2; 90) : [1; R + ] 7 max distance between arms (r2; 50) : [1; R + ] max speed (r2; vertical; 2) : [1; R + ] max speed (r2; horizontal; 0:5) : [1; R + ] Site 3: Databases DB 3 ,DB 4 and DB 5 contain sensor information about the temperature of the objects. <p> speed (r1; horizontal; 2) : <ref> [1; R + ] </ref> DB 2 : max weight capability (r2; 50) : [1; R + ] max temperature handling (r2; 90) : [1; R + ] 7 max distance between arms (r2; 50) : [1; R + ] max speed (r2; vertical; 2) : [1; R + ] max speed (r2; horizontal; 0:5) : [1; R + ] Site 3: Databases DB 3 ,DB 4 and DB 5 contain sensor information about the temperature of the objects. <p> 2 : max weight capability (r2; 50) : <ref> [1; R + ] </ref> max temperature handling (r2; 90) : [1; R + ] 7 max distance between arms (r2; 50) : [1; R + ] max speed (r2; vertical; 2) : [1; R + ] max speed (r2; horizontal; 0:5) : [1; R + ] Site 3: Databases DB 3 ,DB 4 and DB 5 contain sensor information about the temperature of the objects. <p> For this part of the robot example, we will assume that the sensors have completed recording information for the time points between 0 and 6 and the databases DB 3 ,DB 4 and DB 5 contain the following information: DB 3 : temperature (a; 45) : <ref> [1; f0g] </ref> temperature (b; 60) : [1; f0g] temperature (c; 30) : [1; f0g] temperature (d; 70) : [1; f0g] temperature (e; 43) : [1; f0g] temperature (f; 55) : [1; f0g] DB 4 : temperature (a; 45) : [1; f5g] temperature (b; 65) : [1; f5g] temperature (c; 40) : <p> part of the robot example, we will assume that the sensors have completed recording information for the time points between 0 and 6 and the databases DB 3 ,DB 4 and DB 5 contain the following information: DB 3 : temperature (a; 45) : <ref> [1; f0g] </ref> temperature (b; 60) : [1; f0g] temperature (c; 30) : [1; f0g] temperature (d; 70) : [1; f0g] temperature (e; 43) : [1; f0g] temperature (f; 55) : [1; f0g] DB 4 : temperature (a; 45) : [1; f5g] temperature (b; 65) : [1; f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : <p> will assume that the sensors have completed recording information for the time points between 0 and 6 and the databases DB 3 ,DB 4 and DB 5 contain the following information: DB 3 : temperature (a; 45) : <ref> [1; f0g] </ref> temperature (b; 60) : [1; f0g] temperature (c; 30) : [1; f0g] temperature (d; 70) : [1; f0g] temperature (e; 43) : [1; f0g] temperature (f; 55) : [1; f0g] DB 4 : temperature (a; 45) : [1; f5g] temperature (b; 65) : [1; f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : <p> completed recording information for the time points between 0 and 6 and the databases DB 3 ,DB 4 and DB 5 contain the following information: DB 3 : temperature (a; 45) : <ref> [1; f0g] </ref> temperature (b; 60) : [1; f0g] temperature (c; 30) : [1; f0g] temperature (d; 70) : [1; f0g] temperature (e; 43) : [1; f0g] temperature (f; 55) : [1; f0g] DB 4 : temperature (a; 45) : [1; f5g] temperature (b; 65) : [1; f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : <p> points between 0 and 6 and the databases DB 3 ,DB 4 and DB 5 contain the following information: DB 3 : temperature (a; 45) : <ref> [1; f0g] </ref> temperature (b; 60) : [1; f0g] temperature (c; 30) : [1; f0g] temperature (d; 70) : [1; f0g] temperature (e; 43) : [1; f0g] temperature (f; 55) : [1; f0g] DB 4 : temperature (a; 45) : [1; f5g] temperature (b; 65) : [1; f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : [1; f5g] DB 5 : temperature <p> the databases DB 3 ,DB 4 and DB 5 contain the following information: DB 3 : temperature (a; 45) : <ref> [1; f0g] </ref> temperature (b; 60) : [1; f0g] temperature (c; 30) : [1; f0g] temperature (d; 70) : [1; f0g] temperature (e; 43) : [1; f0g] temperature (f; 55) : [1; f0g] DB 4 : temperature (a; 45) : [1; f5g] temperature (b; 65) : [1; f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : [1; f5g] DB 5 : temperature (a; 45) : [1; f6g] temperature <p> contain the following information: DB 3 : temperature (a; 45) : [1; f0g] temperature (b; 60) : [1; f0g] temperature (c; 30) : [1; f0g] temperature (d; 70) : [1; f0g] temperature (e; 43) : [1; f0g] temperature (f; 55) : [1; f0g] DB 4 : temperature (a; 45) : <ref> [1; f5g] </ref> temperature (b; 65) : [1; f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : [1; f5g] DB 5 : temperature (a; 45) : [1; f6g] temperature (b; 75) : [1; f6g] temperature (c; 45) : <p> : temperature (a; 45) : [1; f0g] temperature (b; 60) : [1; f0g] temperature (c; 30) : [1; f0g] temperature (d; 70) : [1; f0g] temperature (e; 43) : [1; f0g] temperature (f; 55) : [1; f0g] DB 4 : temperature (a; 45) : <ref> [1; f5g] </ref> temperature (b; 65) : [1; f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : [1; f5g] DB 5 : temperature (a; 45) : [1; f6g] temperature (b; 75) : [1; f6g] temperature (c; 45) : [1; f6g] temperature (d; 65) : <p> f0g] temperature (b; 60) : [1; f0g] temperature (c; 30) : [1; f0g] temperature (d; 70) : [1; f0g] temperature (e; 43) : [1; f0g] temperature (f; 55) : [1; f0g] DB 4 : temperature (a; 45) : <ref> [1; f5g] </ref> temperature (b; 65) : [1; f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : [1; f5g] DB 5 : temperature (a; 45) : [1; f6g] temperature (b; 75) : [1; f6g] temperature (c; 45) : [1; f6g] temperature (d; 65) : [1; f6g] temperature (e; 50) : <p> f0g] temperature (c; 30) : [1; f0g] temperature (d; 70) : [1; f0g] temperature (e; 43) : [1; f0g] temperature (f; 55) : [1; f0g] DB 4 : temperature (a; 45) : <ref> [1; f5g] </ref> temperature (b; 65) : [1; f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : [1; f5g] DB 5 : temperature (a; 45) : [1; f6g] temperature (b; 75) : [1; f6g] temperature (c; 45) : [1; f6g] temperature (d; 65) : [1; f6g] temperature (e; 50) : [1; f6g] temperature (f; 58) : <p> f0g] temperature (d; 70) : [1; f0g] temperature (e; 43) : [1; f0g] temperature (f; 55) : [1; f0g] DB 4 : temperature (a; 45) : <ref> [1; f5g] </ref> temperature (b; 65) : [1; f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : [1; f5g] DB 5 : temperature (a; 45) : [1; f6g] temperature (b; 75) : [1; f6g] temperature (c; 45) : [1; f6g] temperature (d; 65) : [1; f6g] temperature (e; 50) : [1; f6g] temperature (f; 58) : [1; f6g] The above clauses can <p> f0g] temperature (e; 43) : [1; f0g] temperature (f; 55) : [1; f0g] DB 4 : temperature (a; 45) : <ref> [1; f5g] </ref> temperature (b; 65) : [1; f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : [1; f5g] DB 5 : temperature (a; 45) : [1; f6g] temperature (b; 75) : [1; f6g] temperature (c; 45) : [1; f6g] temperature (d; 65) : [1; f6g] temperature (e; 50) : [1; f6g] temperature (f; 58) : [1; f6g] The above clauses can be read as follows: The atom <p> 55) : [1; f0g] DB 4 : temperature (a; 45) : [1; f5g] temperature (b; 65) : [1; f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : [1; f5g] DB 5 : temperature (a; 45) : <ref> [1; f6g] </ref> temperature (b; 75) : [1; f6g] temperature (c; 45) : [1; f6g] temperature (d; 65) : [1; f6g] temperature (e; 50) : [1; f6g] temperature (f; 58) : [1; f6g] The above clauses can be read as follows: The atom temperature (a; 45) : [1; f6g] means that the <p> : temperature (a; 45) : [1; f5g] temperature (b; 65) : [1; f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : [1; f5g] DB 5 : temperature (a; 45) : <ref> [1; f6g] </ref> temperature (b; 75) : [1; f6g] temperature (c; 45) : [1; f6g] temperature (d; 65) : [1; f6g] temperature (e; 50) : [1; f6g] temperature (f; 58) : [1; f6g] The above clauses can be read as follows: The atom temperature (a; 45) : [1; f6g] means that the truth value of temperature (a; 45) <p> f5g] temperature (b; 65) : [1; f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : [1; f5g] DB 5 : temperature (a; 45) : <ref> [1; f6g] </ref> temperature (b; 75) : [1; f6g] temperature (c; 45) : [1; f6g] temperature (d; 65) : [1; f6g] temperature (e; 50) : [1; f6g] temperature (f; 58) : [1; f6g] The above clauses can be read as follows: The atom temperature (a; 45) : [1; f6g] means that the truth value of temperature (a; 45) is at least 1 at time <p> f5g] temperature (c; 40) : [1; f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : [1; f5g] DB 5 : temperature (a; 45) : <ref> [1; f6g] </ref> temperature (b; 75) : [1; f6g] temperature (c; 45) : [1; f6g] temperature (d; 65) : [1; f6g] temperature (e; 50) : [1; f6g] temperature (f; 58) : [1; f6g] The above clauses can be read as follows: The atom temperature (a; 45) : [1; f6g] means that the truth value of temperature (a; 45) is at least 1 at time 6. <p> f5g] temperature (d; 65) : [1; f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : [1; f5g] DB 5 : temperature (a; 45) : <ref> [1; f6g] </ref> temperature (b; 75) : [1; f6g] temperature (c; 45) : [1; f6g] temperature (d; 65) : [1; f6g] temperature (e; 50) : [1; f6g] temperature (f; 58) : [1; f6g] The above clauses can be read as follows: The atom temperature (a; 45) : [1; f6g] means that the truth value of temperature (a; 45) is at least 1 at time 6. <p> f5g] temperature (e; 45) : [1; f5g] temperature (f; 55) : [1; f5g] DB 5 : temperature (a; 45) : <ref> [1; f6g] </ref> temperature (b; 75) : [1; f6g] temperature (c; 45) : [1; f6g] temperature (d; 65) : [1; f6g] temperature (e; 50) : [1; f6g] temperature (f; 58) : [1; f6g] The above clauses can be read as follows: The atom temperature (a; 45) : [1; f6g] means that the truth value of temperature (a; 45) is at least 1 at time 6. <p> temperature (a; 45) : <ref> [1; f6g] </ref> temperature (b; 75) : [1; f6g] temperature (c; 45) : [1; f6g] temperature (d; 65) : [1; f6g] temperature (e; 50) : [1; f6g] temperature (f; 58) : [1; f6g] The above clauses can be read as follows: The atom temperature (a; 45) : [1; f6g] means that the truth value of temperature (a; 45) is at least 1 at time 6. Similarly, the atom max weight capability (r2; 50) : [1; R + ] means that the truth value of max weight capability (r2; 50) is at least 1 at all time points. <p> Similarly, the atom max weight capability (r2; 50) : <ref> [1; R + ] </ref> means that the truth value of max weight capability (r2; 50) is at least 1 at all time points. The language used to integrate data coming from the above sources will be described in the following section. <p> For example, the following clause is stored at Site 2. can lift (r1; Obj) : [fmg;1; fV t g] weight (Obj; W 1 ) & W W 1 & width (Obj; D 1 ) & D D 1 k max distance between arms (r1; D) : <ref> [f1g; 1; R + ] </ref> & max weight capability (r1; W ) : [f1g; 1; R + ] & max temperature handling (r1; T ) : [f1g; 1; R + ] & temperature (Obj; T 1 ) : [fmg; 0:9; fV t g] & T 1 T: 9 In this example, <p> 2. can lift (r1; Obj) : [fmg;1; fV t g] weight (Obj; W 1 ) & W W 1 & width (Obj; D 1 ) & D D 1 k max distance between arms (r1; D) : <ref> [f1g; 1; R + ] </ref> & max weight capability (r1; W ) : [f1g; 1; R + ] & max temperature handling (r1; T ) : [f1g; 1; R + ] & temperature (Obj; T 1 ) : [fmg; 0:9; fV t g] & T 1 T: 9 In this example, the relational database is used to evaluate "weight" and "width" relations, and the <p> 1 ) & W W 1 & width (Obj; D 1 ) & D D 1 k max distance between arms (r1; D) : <ref> [f1g; 1; R + ] </ref> & max weight capability (r1; W ) : [f1g; 1; R + ] & max temperature handling (r1; T ) : [f1g; 1; R + ] & temperature (Obj; T 1 ) : [fmg; 0:9; fV t g] & T 1 T: 9 In this example, the relational database is used to evaluate "weight" and "width" relations, and the real number constraint domain is used to evaluate the constraints "W W 1 <p> An atom A : [D; ; t] is said to be ground annotated iff D f1; : : :; n; mg, 2 <ref> [0; 1] </ref> and t 2 2 R + Definition 3 (M-interpretation) An M-interpretation I is a mapping from the Her-brand Base B L , of the base language, to the set of functions f : f1; : : : ; n; mg ! (U N C; ). <p> The amalgamation transform of a deductive database DB i is obtained by adding the annotation fig to all the atoms that occur in DB i . Hence the clause p : <ref> [1; f1g] </ref> q : [0:5; f1; 2g] in database DB 3 will be replaced by the clause p : [f3g; 1; f1g] q : [f3g; 0:5; f1; 2g] in the amalgamation transform of DB 3 . Definition 7 Suppose Q is a mediatory knowledge base. <p> Hence the clause p : [1; f1g] q : [0:5; f1; 2g] in database DB 3 will be replaced by the clause p : <ref> [f3g; 1; f1g] </ref> q : [f3g; 0:5; f1; 2g] in the amalgamation transform of DB 3 . Definition 7 Suppose Q is a mediatory knowledge base. <p> In this way subsumption is a more general concept. Example 6 Recall the robot example given in section 3 and the appendix. We now define a suitable query strategy function f Ask for this example. For all 2 <ref> [0; 1] </ref> and t 2 2 R + and for all the ground instances of the following atoms, the value of f Ask is given as follows: ("REL"2 fmax temperature handling (X; Y ); max distance between arms (X; Y ); max speed (X; Y; Z)g) f Ask (v 1 ; <p> Dubois, Lang and Prade [7], also suggest that formulas in knowledge bases can be annotated with, for each source, a lower bound of a degree of certainty associated with that source. The spirit behind their approach is similar to ours, though interest is restricted to the <ref> [0; 1] </ref> lattice, the stable and well-founded semantics are not addressed, and amalgamation theorems are not studied. However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. The authors have extended their work to accommodate time in [6]. <p> The spirit behind their approach is similar to ours, though interest is restricted to the <ref> [0; 1] </ref> lattice, the stable and well-founded semantics are not addressed, and amalgamation theorems are not studied. However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. The authors have extended their work to accommodate time in [6]. <p> In addition, this paper also addresses conditions under which this distributed semantics is robust, i.e. continues to behave appropriately even if some links in the network "go down." 8. Conclusions In [23, 17], we provided a formal declarative semantics for integrating multiple databases. Concurrently with this paper, <ref> [1] </ref>, provides a formal operational procedure that is interruptable (and will give approximate answers when interrupted) and that caches previous computations so as to eliminate redundant computations. This formal theory is now leading to an application for missile siting by the US Army Corps of Engineers [3]. <p> This formal theory is now leading to an application for missile siting by the US Army Corps of Engineers [3]. In this paper, we have extended the theory of mediators developed in <ref> [23, 17, 1, 3] </ref> to the case when the databases being mediated between are stored at different nodes in a network (such as a LAN or the Internet).
Reference: [2] <author> R. Agrawal, R. Cochrane and B. Lindsay. </author> <title> (1991) On Maintaining Priorities in a Production Rule System, </title> <booktitle> Proc. </booktitle> <address> VLDB-91, pps 479-487. </address>
Reference-contexts: Hence, [0:5; f1; 3g] <ref> [0:7; f1; 2; 3g] </ref>, but [0:5; f1; 3g] and [0:6; f1; 2g] are incomparable. GAPs work with annotated atoms of the form A : where A is an atom (defined in the usual way) and is an expression whose value evaluates to a member of the truth value lattice.
Reference: [3] <author> J. Benton and V.S. Subrahmanian. </author> <title> (1993) Hybrid Knowledge Bases for Missile Siting Problems, </title> <booktitle> accepted for publication in 1994 Intl. Conf. on Artificial Intelligence Applications, </booktitle> <publisher> IEEE Press. </publisher>
Reference-contexts: This formal theory is now leading to an application for missile siting by the US Army Corps of Engineers <ref> [3] </ref>. In this paper, we have extended the theory of mediators developed in [23, 17, 1, 3] to the case when the databases being mediated between are stored at different nodes in a network (such as a LAN or the Internet). <p> This formal theory is now leading to an application for missile siting by the US Army Corps of Engineers [3]. In this paper, we have extended the theory of mediators developed in <ref> [23, 17, 1, 3] </ref> to the case when the databases being mediated between are stored at different nodes in a network (such as a LAN or the Internet).
Reference: [4] <author> Y. Breitbart, H. Garcia-Molina and A. Silberschatz. </author> <title> (1992) Overview of Mul tidatabase Transaction Management, </title> <journal> VLDB Journal, </journal> <volume> 2, </volume> <pages> pps 181-239. </pages>
Reference: [5] <author> D. Dubois, J. Lang and H. Prade. </author> <title> (1991) Towards Possibilistic Logic Pro gramming, </title> <booktitle> Proc. 1991 Intl. Conf. on Logic Programming, </booktitle> <editor> ed. K. Furukawa, </editor> <address> pps 581-595, </address> <publisher> MIT Press. </publisher>
Reference: [6] <author> D. Dubois, J. Lang and H. Prade. </author> <title> (1991) Timed Possibilistic Logic, </title> <journal> Funda menta Informaticae, </journal> <volume> Vol. XV, No. </volume> <pages> 3-4, pps 211-234. </pages>
Reference-contexts: However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. The authors have extended their work to accommodate time in <ref> [6] </ref>. Previous Work of Authors: This paper forms part of a long-term project on developing a formal theoretical foundation, as well as algorithms, implementations, and applications of mediated information systems.
Reference: [7] <author> D. Dubois, J. Lang and H. Prade. </author> <title> (1992) Dealing with Multi-Source Infor mation in Possibilistic Logic, </title> <booktitle> Proc. 10th European Conf. on Artificial Intelligence, </booktitle> <publisher> Wiley. </publisher>
Reference-contexts: Reasoning with temporal mismatches has been studied by Jajodia and Wiederhold and their colleagues [28, 25]. This work complements ours and it would be interesting, in future work, to see how these ideas can be expressed in our framework. Dubois, Lang and Prade <ref> [7] </ref>, also suggest that formulas in knowledge bases can be annotated with, for each source, a lower bound of a degree of certainty associated with that source.
Reference: [8] <author> R. Fagin, J.D. Ullman, and M.Y. Vardi. </author> <title> (1983) On the Semantics of Updates in Databases, </title> <booktitle> Proc. ACM SIGACT/SIGMOD Symposium on Principles of Database Systems, </booktitle> <address> pps 352-365. </address>
Reference: [9] <author> R. Fagin, G. Kuper, J. Ullman, and M. Vardi. </author> <title> (1986) Updating Logical Databases, </title> <booktitle> In Advances in Computing Research, </booktitle> <volume> volume 3, </volume> <pages> pages 1-18, </pages> <year> 1986. </year>
Reference: [10] <author> J. Grant, W. Litwin, N. Roussopoulos and T. Sellis. </author> <title> (1991) An Algebra and Calculus for Relational Multidatabase Systems, </title> <booktitle> Proc. First International 32 Workshop on Interoperability in Multidatabase Systems, </booktitle> <publisher> IEEE Computer Society Press (1991) 118-124. </publisher>
Reference-contexts: A great deal of work has been done in multidatabase systems and interoperable database systems <ref> [10, 24, 29] </ref>. However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. <p> However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. The work of Grant et. al. <ref> [10] </ref> is an exception: the authors develop a calculus and an algebra for integrating information from multiple databases. This calculus extends the standard relational calculus. Further work specialized to handle inter-operability of multi-databases is critically needed.
Reference: [11] <author> R. Hahnle. </author> <title> (1990) Towards an Efficient Tableau Rules for Multiple-Valued Logics, </title> <booktitle> Proc. Workshop on Computer Science Logic, </booktitle> <address> pps 248-260, </address> <publisher> Springer. </publisher>
Reference: [12] <author> R. Hahnle. </author> <title> (1990) Uniform Notation Tableau Rules for Multiple-Valued Logics, </title> <booktitle> Proc. 1991 IEEE Intl. Symp. on Multiple Valued Logic, </booktitle> <address> pps 26-29. </address>
Reference: [13] <author> W. Kim and J. Seo. </author> <title> (1991) Classifying Schematic and Data Heterogeneity in Multidatabase Systems, </title> <booktitle> IEEE Computer, </booktitle> <month> Dec. </month> <year> 1991. </year>
Reference: [14] <author> M. Kifer and V.S. Subrahmanian. </author> <title> (1989) Theory of Generalized Annotated Logic Programming and its Applications, </title> <journal> Journal of Logic Programming, </journal> <volume> 12, 4, </volume> <pages> pps 335-368, </pages> <year> 1992. </year> <title> Preliminary version in: </title> <booktitle> Proc. 1989 North American Conf. on Logic Programming, </booktitle> <publisher> MIT Press. </publisher>
Reference-contexts: These papers, together with [17], uses the framework of "generalized annotated program" (GAPs for short) framework proposed in <ref> [14] </ref> to integrate information from deductive databases together with information from nonlogical databases such as relational databases, auxiliary data structures and numerical constraints. The GAP framework assumes that we have a set, T , of truth values 1 that forms a complete lattice under an ordering .
Reference: [15] <author> R. Krishnamurthy, W. Litwin and W. Kent. </author> <title> (1991) Language Features for Interoperability of Databases with Schematic Discrepancies, </title> <booktitle> Proc. ACM SIG-MOD 1991. </booktitle>
Reference: [16] <author> A. Lefebvre, P. Bernus and R. Topor. </author> <title> (1992) Querying Heterogeneous Databases: A Case Study, </title> <type> draft manuscript. </type>
Reference: [17] <author> J. Lu, A. Nerode, </author> <title> and V.S. Subrahmanian. (1993) Hybrid Knowledge Bases, </title> <institution> Univ. of Maryland CS-TR-3037. </institution> <note> Submitted for journal publication. </note>
Reference-contexts: 1. Introduction Integrating knowledge from multiple sources is an important aspect of automated reasoning systems. In previous work <ref> [23, 17] </ref>, we presented a unifying language for integrating data/knowledge expressed across different data structures and representation paradigms, when time and uncertainty were present. The semantics of the resulting mediatory language was studied. <p> The organization of the paper is as follows: in Section 2, we outline the basic ideas underlying our mediated framework <ref> [17, 23, 1] </ref>. In Section 3, we present a motivating example that will be used throughout the paper to illustrate the formal definitions. Section 4 explains the syntax and semantics of mediatory knowledge bases this is merely a straightforward combination of [23, 17]. <p> In Section 3, we present a motivating example that will be used throughout the paper to illustrate the formal definitions. Section 4 explains the syntax and semantics of mediatory knowledge bases this is merely a straightforward combination of <ref> [23, 17] </ref>. Section 5 defines the semantics of a distributed mediated system. In Section 6, we show how it is possible to distribute the mediator across the network so that the resulting semantics is identical to the 2 non-distributed semantics. <p> An Overview of the Syntax of Hybrid and Amalgamated Knowledge Bases This paper is the second in a series of papers [23] developing the theory and practice of integrating information with the help of a "mediator". These papers, together with <ref> [17] </ref>, uses the framework of "generalized annotated program" (GAPs for short) framework proposed in [14] to integrate information from deductive databases together with information from nonlogical databases such as relational databases, auxiliary data structures and numerical constraints. <p> An annotated clause over this extended lattice is of the form A : B 1 : 1 & : : : & B k : k 1 It was shown in <ref> [23, 17] </ref> that the hybrid and amalgamated knowledge base framework can be easily extended to any complete truth value lattice. 3 where A; B 1 ; : : :; B k are atoms, and ; 1 ; : : : ; k are truth values of the form [D; ; t] <p> The language used to integrate data coming from the above sources will be described in the following section. We will then use this language to specify how the sites may draw conclusions in the presence of conflicting information. 8 4. Mediatory Knowledge Bases A constraint domain <ref> [17] </ref> is a triple = (D; F; R) where D is a nonempty set, F is a set of functions (including higher order functions) on D, and R is a set of relations on D. <p> Intuitively, the elements of D represent the data-objects we wish to reason about, the elements of F are the functions that can be applied to these data objects, and the elements of R are relationships that exist between these data objects. In <ref> [17] </ref>, we showed how various heterogeneous data structures (including spatial, relational, object-oriented, etc.) can be viewed as constraint domains. As an example, consider point quadtrees [20] with nodes having an INFO field and X and Y fields representing coordinates. <p> The operator T Q is defined for this purpose. This way, the truth values of all possible D-terms are established. The following theorem follows directly from the properties of the fixpoint operators proved in <ref> [23, 17] </ref>. 2 j &gt; ffi j is true in any M-interpretation I iff the constraint ffi j is true in domain j . 11 Theorem 1 Suppose Q is any mediatory knowledge base. <p> Manna [18]), and hence, we will consider this least fixpoint of F N to be the meaning of the distributed network of databases. We will subsequently show (cf. Lemmas 2 and 1) that this least fixpoint is a generalization of the semantics for amalgamating knowledge bases proposed in <ref> [23, 17] </ref>. Those semantics have a clearly defined model-theoretic basis. Defining a model-theoretic basis for a network of databases is related to database updates because messages received by a database from another database needs to be assimilated and can be viewed as an update. <p> The F N operator defined on the distributed network is a straightforward generalization of the A Q operator defined in [23] as well as the T DB operator defined in <ref> [17] </ref>. Lemma 1 Suppose N = (fvg; ;) is a network consisting of just one site, and supposeD= fDB; 1 ; : : : ; m g are the databases located at this site, where DB is a deductive database and i is a non-logical database for 1 i m. <p> distributed interpretation I ] such that I ] = ((I v ); ;), if F N (I ] ) = ((I 2 v ); M sg) then I 2 v = T DB (I v ) where T DB is the fixpoint operator defined for the hybrid knowledge bases in <ref> [17] </ref> applied for Q v . Proof. Let I ] = ((I v ); ;) and Q v be given as above. Suppose F N (I ] ) = ((I 2 v ); M sg). <p> This definition of T Q v is identical to the definition of T DB given in <ref> [17] </ref>, hence I 2 v = T DB (I v ). 2 The following lemma is proved along analogous lines. <p> In [23], Subrahmanian proposed a formal logical framework for integrating multiple knowledge bases, and showed that this framework could be used to represent and manipulate certain forms of time and uncertainty, as well as nonmonotonicity. Subsequently, Nerode and Subrahma-nian <ref> [17] </ref> proposed the notion of a hybrid knowledge base where inter-operating with auxiliary data structures and constraint domains was also accomplished. Adal and Subrahmanian developed this logical framework further, giving a set of data structures and algorithms that could be interrupted in the middle of a computation (if necessary). <p> This paper uses the same logical framework described in the above works, with one major difference. In reality, databases are likely to be located at different sites on a network (such as a LAN or the Internet). Hence, though the mediator-based framework in <ref> [23, 17] </ref> specifies the declarative result of such a logic computation, it does not specify a distributed realization of this declarative semantics. This is what has been accomplished in this paper. <p> This is what has been accomplished in this paper. In addition, this paper also addresses conditions under which this distributed semantics is robust, i.e. continues to behave appropriately even if some links in the network "go down." 8. Conclusions In <ref> [23, 17] </ref>, we provided a formal declarative semantics for integrating multiple databases. Concurrently with this paper, [1], provides a formal operational procedure that is interruptable (and will give approximate answers when interrupted) and that caches previous computations so as to eliminate redundant computations. <p> This formal theory is now leading to an application for missile siting by the US Army Corps of Engineers [3]. In this paper, we have extended the theory of mediators developed in <ref> [23, 17, 1, 3] </ref> to the case when the databases being mediated between are stored at different nodes in a network (such as a LAN or the Internet).
Reference: [18] <author> Z. Manna. </author> <title> Mathematical Theory of Computation, </title> <publisher> Prentice-Hall. </publisher>
Reference-contexts: The semantics of programs (both imperative and logical) have long been characterized by the least fixpoints of associated operators (cf. Manna <ref> [18] </ref>), and hence, we will consider this least fixpoint of F N to be the meaning of the distributed network of databases. We will subsequently show (cf. Lemmas 2 and 1) that this least fixpoint is a generalization of the semantics for amalgamating knowledge bases proposed in [23, 17].
Reference: [19] <author> N. Murray and E. Rosenthal. </author> <title> (1993) Signed Formulas: A Liftable Meta-Logic for Multiple Valued Logics, </title> <booktitle> Proc. </booktitle> <address> ISMIS-1993, </address> <publisher> Springer Verlag. </publisher>
Reference: [20] <author> H. Samet. </author> <title> (1989) The Design and Analysis of Spatial Data Structures, </title> <publisher> Addison-Wesley. </publisher>
Reference-contexts: The layout of the workspace for this example is given in figure 3. and the corresponding spatial information is stored in a data structure. There are many data structures that can be used to represent spatial data. As an example, a point quadtree (cf. Samet <ref> [20] </ref>) reflecting the spatial information about the workspace is given in figure 3.. <p> In [17], we showed how various heterogeneous data structures (including spatial, relational, object-oriented, etc.) can be viewed as constraint domains. As an example, consider point quadtrees <ref> [20] </ref> with nodes having an INFO field and X and Y fields representing coordinates. Let D be the set of all quadtrees that can be constructed using nodes having this type.
Reference: [21] <author> A. Sheth and J. Larson. </author> <title> (1990) Federated Database Systems for Managing Dis tributed, Heterogeneous and Autonomous Databases, </title> <journal> ACM Computing Surveys, </journal> <volume> 22, 3, </volume> <pages> pp 183-236. </pages>
Reference: [22] <author> A. Silberschatz, M. Stonebraker and J. D. Ullman. </author> <title> (1991) Database Systems: Achievements and Opportunities, </title> <journal> Comm. of the ACM, </journal> <volume> 34, 10, </volume> <pages> pps 110-120. </pages>
Reference: [23] <author> V.S. Subrahmanian. </author> <title> (1994) Amalgamating Knowledge Bases, </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 19, 2, </volume> <pages> pps 291-331. </pages>
Reference-contexts: 1. Introduction Integrating knowledge from multiple sources is an important aspect of automated reasoning systems. In previous work <ref> [23, 17] </ref>, we presented a unifying language for integrating data/knowledge expressed across different data structures and representation paradigms, when time and uncertainty were present. The semantics of the resulting mediatory language was studied. <p> The organization of the paper is as follows: in Section 2, we outline the basic ideas underlying our mediated framework <ref> [17, 23, 1] </ref>. In Section 3, we present a motivating example that will be used throughout the paper to illustrate the formal definitions. Section 4 explains the syntax and semantics of mediatory knowledge bases this is merely a straightforward combination of [23, 17]. <p> In Section 3, we present a motivating example that will be used throughout the paper to illustrate the formal definitions. Section 4 explains the syntax and semantics of mediatory knowledge bases this is merely a straightforward combination of <ref> [23, 17] </ref>. Section 5 defines the semantics of a distributed mediated system. In Section 6, we show how it is possible to distribute the mediator across the network so that the resulting semantics is identical to the 2 non-distributed semantics. <p> We also develop methods (under certain conditions) to distribute the mediator so that link failures do not affect the resulting semantics. 2. An Overview of the Syntax of Hybrid and Amalgamated Knowledge Bases This paper is the second in a series of papers <ref> [23] </ref> developing the theory and practice of integrating information with the help of a "mediator". <p> An annotated clause over this extended lattice is of the form A : B 1 : 1 & : : : & B k : k 1 It was shown in <ref> [23, 17] </ref> that the hybrid and amalgamated knowledge base framework can be easily extended to any complete truth value lattice. 3 where A; B 1 ; : : :; B k are atoms, and ; 1 ; : : : ; k are truth values of the form [D; ; t] <p> The operator T Q is defined for this purpose. This way, the truth values of all possible D-terms are established. The following theorem follows directly from the properties of the fixpoint operators proved in <ref> [23, 17] </ref>. 2 j &gt; ffi j is true in any M-interpretation I iff the constraint ffi j is true in domain j . 11 Theorem 1 Suppose Q is any mediatory knowledge base. <p> Manna [18]), and hence, we will consider this least fixpoint of F N to be the meaning of the distributed network of databases. We will subsequently show (cf. Lemmas 2 and 1) that this least fixpoint is a generalization of the semantics for amalgamating knowledge bases proposed in <ref> [23, 17] </ref>. Those semantics have a clearly defined model-theoretic basis. Defining a model-theoretic basis for a network of databases is related to database updates because messages received by a database from another database needs to be assimilated and can be viewed as an update. <p> The F N operator defined on the distributed network is a straightforward generalization of the A Q operator defined in <ref> [23] </ref> as well as the T DB operator defined in [17]. <p> distributed interpretation I ] such that I ] = ((I v ); ;), if F N (I ] ) = ((I 2 v ); M sg) then I 2 v = A Q (I v ) where A Q is the fixpoint operator defined for the amalgamated knowledge bases in <ref> [23] </ref>. 2 As we have seen so far in this section, when a set of databases is distributed across a network, the inferences made by the system depend on several factors these are: * the network N = (V; E), 19 * the databases fDB 1 ; : : : ; <p> Consider ` = 1; 2. It is easy to see that the first component of the above union when ` = 1 is a subset of the first component when ` = 2 because of the monotonicity of T Q ` v i proved in <ref> [23] </ref> and because Q 1 v i Q 2 v i . The same observation holds for the second component of the union. The part of the constraint messages do not depend on `, hence it is identical. This completes the proof that M sg 1 M sg 2 . <p> The authors have extended their work to accommodate time in [6]. Previous Work of Authors: This paper forms part of a long-term project on developing a formal theoretical foundation, as well as algorithms, implementations, and applications of mediated information systems. In <ref> [23] </ref>, Subrahmanian proposed a formal logical framework for integrating multiple knowledge bases, and showed that this framework could be used to represent and manipulate certain forms of time and uncertainty, as well as nonmonotonicity. <p> This paper uses the same logical framework described in the above works, with one major difference. In reality, databases are likely to be located at different sites on a network (such as a LAN or the Internet). Hence, though the mediator-based framework in <ref> [23, 17] </ref> specifies the declarative result of such a logic computation, it does not specify a distributed realization of this declarative semantics. This is what has been accomplished in this paper. <p> This is what has been accomplished in this paper. In addition, this paper also addresses conditions under which this distributed semantics is robust, i.e. continues to behave appropriately even if some links in the network "go down." 8. Conclusions In <ref> [23, 17] </ref>, we provided a formal declarative semantics for integrating multiple databases. Concurrently with this paper, [1], provides a formal operational procedure that is interruptable (and will give approximate answers when interrupted) and that caches previous computations so as to eliminate redundant computations. <p> This formal theory is now leading to an application for missile siting by the US Army Corps of Engineers [3]. In this paper, we have extended the theory of mediators developed in <ref> [23, 17, 1, 3] </ref> to the case when the databases being mediated between are stored at different nodes in a network (such as a LAN or the Internet).
Reference: [24] <author> W.K. Whang, S. B. Navathe and S. Chakravarthy. </author> <title> (1991) Logic-Based Ap proach for Realizing a Federated Information System, </title> <booktitle> Proc. First International Workshop on Interoperability in Multidatabase Systems, </booktitle> <publisher> IEEE Computer Society Press (1991) 92-100. </publisher> <pages> 33 </pages>
Reference-contexts: A great deal of work has been done in multidatabase systems and interoperable database systems <ref> [10, 24, 29] </ref>. However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. <p> Zi-cari et. al [29] describe how interoperability may be achieved between a rule-based system (deductive DB) and an object-oriented database using special import/export primitives. No formal theory is developed in [29]. Perhaps closer to our goal is that of Whang et. al. <ref> [24] </ref> who argue that Prolog is a suitable framework for 30 schema integration. In fact, the approach of Whang et. al. is in the same spirit as that of metalogic programming discussed earlier.
Reference: [25] <author> G. Wiederhold, S. Jajodia, and W. Litwin. </author> <title> Dealing with granularity of time in temporal databases. </title> <booktitle> In Proc. 3rd Nordic Conf. on Advanced Information Systems Engineering, Lecture Notes in Computer Science, </booktitle> <volume> Vol. 498, </volume> <editor> (R. Anderson et al. eds.), </editor> <publisher> Springer-Verlag, </publisher> <year> 1991, </year> <pages> pages 124-140. </pages>
Reference-contexts: Whang et. al. do not give a formal semantics for multi-databases containing inconsistency and/or uncertainty and/or non-monotonicity and/or temporal information. Reasoning with temporal mismatches has been studied by Jajodia and Wiederhold and their colleagues <ref> [28, 25] </ref>. This work complements ours and it would be interesting, in future work, to see how these ideas can be expressed in our framework.
Reference: [26] <author> G. Wiederhold. </author> <booktitle> (1992) Mediators in the Architecture of Future Information Systems, IEEE Computer, </booktitle> <month> March </month> <year> 1992, </year> <month> pps 38-49. </month>
Reference-contexts: Fortunately, this algorithm needs to be executed only once, when the mediator is being distributed (though incremental modifications may need to be performed when new nodes and/or databases are added to DMS). 7. Related Work The idea of mediators and distributed mediators is due to Gio Wiederhold <ref> [26, 27] </ref> who proposed that a program, called a mediator, should be used to inter-operate between multiple representations of knowledge and data, both in distributed, as well as in centralized environments. A great deal of work has been done in multidatabase systems and interoperable database systems [10, 24, 29].
Reference: [27] <author> G. Wiederhold. </author> <title> (1993) Intelligent Integration of Information, </title> <booktitle> Proc. 1993 ACM SIGMOD Conf. on Management of Data, </booktitle> <address> pps 434-437. </address>
Reference-contexts: Fortunately, this algorithm needs to be executed only once, when the mediator is being distributed (though incremental modifications may need to be performed when new nodes and/or databases are added to DMS). 7. Related Work The idea of mediators and distributed mediators is due to Gio Wiederhold <ref> [26, 27] </ref> who proposed that a program, called a mediator, should be used to inter-operate between multiple representations of knowledge and data, both in distributed, as well as in centralized environments. A great deal of work has been done in multidatabase systems and interoperable database systems [10, 24, 29].
Reference: [28] <author> G Wiederhold, S. Jajodia, and W. Litwin. </author> <title> Integrating temporal data in a heterogeneous environment. In Temporal Databases. </title> <address> Benjamin/Cummings, </address> <month> Jan </month> <year> 1993. </year>
Reference-contexts: Whang et. al. do not give a formal semantics for multi-databases containing inconsistency and/or uncertainty and/or non-monotonicity and/or temporal information. Reasoning with temporal mismatches has been studied by Jajodia and Wiederhold and their colleagues <ref> [28, 25] </ref>. This work complements ours and it would be interesting, in future work, to see how these ideas can be expressed in our framework.
Reference: [29] <author> R. Zicari, S. Ceri, and L. Tanca. </author> <title> (1991) Interoperability between a Rule-Based Database Language and an Object-Oriented Language, </title> <booktitle> Proc. First International Workshop on Interoperability in Multidatabase Systems, </booktitle> <publisher> IEEE Computer Society Press (1991) 125-135. </publisher>
Reference-contexts: A great deal of work has been done in multidatabase systems and interoperable database systems <ref> [10, 24, 29] </ref>. However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. <p> This calculus extends the standard relational calculus. Further work specialized to handle inter-operability of multi-databases is critically needed. However, our paper addresses a different topic that of integrating multiple deductive databases containing (possibly) inconsistencies, uncertainty, non-monotonic negation, and possibly even temporal information. Zi-cari et. al <ref> [29] </ref> describe how interoperability may be achieved between a rule-based system (deductive DB) and an object-oriented database using special import/export primitives. No formal theory is developed in [29]. <p> Zi-cari et. al <ref> [29] </ref> describe how interoperability may be achieved between a rule-based system (deductive DB) and an object-oriented database using special import/export primitives. No formal theory is developed in [29]. Perhaps closer to our goal is that of Whang et. al. [24] who argue that Prolog is a suitable framework for 30 schema integration. In fact, the approach of Whang et. al. is in the same spirit as that of metalogic programming discussed earlier.
References-found: 29

