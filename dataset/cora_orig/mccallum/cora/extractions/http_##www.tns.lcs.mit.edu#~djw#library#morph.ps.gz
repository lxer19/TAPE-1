URL: http://www.tns.lcs.mit.edu/~djw/library/morph.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/
Root-URL: 
Title: A Language-Based Approach to Protocol Implementation  
Author: Mark B. Abbott and Larry L. Peterson 
Date: September 23, 1993  
Abstract: Morpheus is a special-purpose programming language that facilitates the efficient implementation of communication protocols. Protocols are divided into three categories, called shapes, so that they can inherit code and data structures based on their category; the programmer implements a particular protocol by refining the inherited structure. Morpheus optimization techniques reduce per-layer overhead on time-critical operations to a few assembler instructions even though the protocol stack is not determined until runtime. This supports divide-and-conquer simplification of the programming task by minimizing the penalty for decomposing complex protocols into combinations of simpler protocols.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. B. Abbott and L. L. Peterson. </author> <title> Automated integration of communication protocol layers. </title> <type> Technical Report 92-25, </type> <institution> Department of Computer Science, University of Arizona, </institution> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: The work described in this paper is just a part of a larger effort to address both latency and bandwidth in the context of a more powerful programming environment. Our approach to bandwidth optimization is described in <ref> [1] </ref>. Although end-to-end throughput is generally considered to be the more important performance issue in high-speed networking, minimizing latency is still a critical goal.
Reference: [2] <author> D. D. Clark. </author> <title> Modularity and efficiency in protocol implementation. Request for Comments 817, </title> <institution> MIT Laboratory for Computer Science, Computer Systems and Communications Group, </institution> <month> July </month> <year> 1982. </year>
Reference-contexts: The constraints imposed by Morpheus take the form of strategies and techniques carefully selected from among those exposed by collective experience with networks <ref> [2, 11, 18] </ref>, plus a novel constraint (shape) introduced in this paper. Stated another way, there are two motivations for the constraints imposed by Morpheus. First, they enforce a good design discipline. It has been argued that the development of a new engineering discipline often happens in two phases [9].
Reference: [3] <author> D. D. Clark, V. Jacobson, J. Romkey, and H. Salwen. </author> <title> An analysis of TCP processing overhead. </title> <journal> IEEE Communications Magazine, </journal> <volume> 27(6) </volume> <pages> 23-29, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Our approach to bandwidth optimization is described in [1]. Although end-to-end throughput is generally considered to be the more important performance issue in high-speed networking, minimizing latency is still a critical goal. Considerable effort has been expended optimizing the latency of TCP/IP <ref> [3] </ref>, obtaining both a significant performance benefit, and evidence bearing on the claim that TCP/IP latency need not be a performance bottleneck.
Reference: [4] <author> K. D. Cooper. </author> <title> Interprocedural Data Flow Analysis in a Programming Environment. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> April </month> <year> 1983. </year>
Reference-contexts: This reduces the number of instructions executed for each clone. More importantly, it eliminates the memory accessesdisproportionately costly on a RISC machinethat would otherwise be necessary to read these constants. This technique is a variation on procedure cloning <ref> [4] </ref>. A procedure can be cloned to partition calls to it based on interprocedural constants information, or more generally, the solution to any forward interprocedural data-flow problem [8].
Reference: [5] <author> K. D. Cooper, M. W. Hall, and L. Torczon. </author> <title> An experiment with inline substitution. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 21(6) </volume> <pages> 581-601, </pages> <month> June 91. 26 </month>
Reference-contexts: This would require keeping one uncloned version of each send procedure to operate on any OverSessions that weren't allocated their own clones. Increased object code size due to inlining (not cloning) seems to have little effect on caching and virtual memory. <ref> [5] </ref> found no obvious evidence of either thrashing or instruction cache overflow, and cited previous reports of similar results.
Reference: [6] <author> O.-J. Dahl and K. Nygaard. </author> <title> Simulaan Algol-based simulation language. </title> <journal> Communications of the ACM, </journal> <volume> 9(9) </volume> <pages> 671-678, </pages> <month> Sept. </month> <year> 1966. </year>
Reference-contexts: Morpheus uses a generalization of the method combination technique used in Simula <ref> [6] </ref>. In Simula, the keyword inner is used in a superclass operation definition to indicate that subclass code for this operation should be executed (like a subroutine or macro) at this point in the superclass code.
Reference: [7] <author> D. C. Feldmeier. </author> <title> Multiplexing issues in communication system design. </title> <booktitle> In Proceedings of the SIG-COMM '90 Symposium, </booktitle> <year> 1990. </year>
Reference-contexts: This reflects the growing recognition of the penalties for logical multiplexing <ref> [7, 16] </ref>: * When streams are merged, they can't be distinguished for purposes of quality of service. * Multiplexing and demultiplexing at multiple layers hurts performance by duplicating effort. * Multiplexing is a barrier to the propagation of flow and congestion control information between protocol layers. <p> This encourages large, complex protocols that comprise multiple functionalities. A second reason is that existing protocols were designed before the current acknowledgement of the drawbacks of logical multiplexing <ref> [7, 16] </ref>; hence many existing protocols include logical multiplexing among their functions, even though they need not. 3.4 Flow Control Controlling the flow of messages between protocol peers is a familiar problem. For example, many protocols use window- or rate-based algorithms.
Reference: [8] <author> M. W. Hall. </author> <title> Managing Interprocedural Optimization. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: This technique is a variation on procedure cloning [4]. A procedure can be cloned to partition calls to it based on interprocedural constants information, or more generally, the solution to any forward interprocedural data-flow problem <ref> [8] </ref>. Instead of a single procedure that must satisfy all calls, each clone is specialized to more efficiently handle its subset of the calls. <p> The increase in code space can be bounded by simply ceasing cloning once a code space threshold has been reached, as proposed in <ref> [8] </ref>. This would require keeping one uncloned version of each send procedure to operate on any OverSessions that weren't allocated their own clones.
Reference: [9] <author> G. J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: Stated another way, there are two motivations for the constraints imposed by Morpheus. First, they enforce a good design discipline. It has been argued that the development of a new engineering discipline often happens in two phases <ref> [9] </ref>. In the first phase, the capabilities of tools are expanded to cope with the growing set of problems.
Reference: [10] <author> B. L. Horn. </author> <title> An introduction to object oriented programming, inheritance and method combination. </title> <type> Technical Report CMU-CS-87-127, </type> <institution> Computer Science Department, Carnegie Mellon University, </institution> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: The general problem of integrating superclass behavior with subclass behavior is known as the method combination problem <ref> [10] </ref>. The Morpheus case is much simpler than the general case because a subclass in Morpheus inherits from a single superclass, the superclass does not inherit any behavior, the superclass is never instantiated directly (it is in this sense an abstract class), and the programmer cannot define completely new classes.
Reference: [11] <author> N. C. Hutchinson and L. L. Peterson. </author> <title> The x-kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: The constraints imposed by Morpheus take the form of strategies and techniques carefully selected from among those exposed by collective experience with networks <ref> [2, 11, 18] </ref>, plus a novel constraint (shape) introduced in this paper. Stated another way, there are two motivations for the constraints imposed by Morpheus. First, they enforce a good design discipline. It has been argued that the development of a new engineering discipline often happens in two phases [9]. <p> In the best case, the operating system provides explicit support for implementing protocols. For example, the x-kernel provides a uniform protocol interface and a protocol support library <ref> [11] </ref>. At the other extreme, network software is automatically derived from a protocol specification expressed using a Formal Description Technique (FDT) such as Estelle, LOTOS, or SDL [17]. In its current state, however, this technology has not lived up to its promise. <p> The x-kernel was used as the standard for comparison because we could obtain timing measurements for the x-kernel's UDP on the same processor (Decstation 5000/200), and because the x-kernel is known to support high performance protocol implementations <ref> [11] </ref>. UDP was used as the basis for comparison because, while fairly simple, it qualifies as a real protocol, and because it has a clear Morpheus equivalent.
Reference: [12] <author> G. Kane. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: Second, it discusses the optimization techniques available to the Morpheus compiler. While no Morpheus compiler has as yet been constructed, we document the effectiveness of these techniques with hand-coded optimizations in assembler language for the MIPS R3000 architecture <ref> [12] </ref>. 2 2 Background Morpheus was not designed in a vacuum. It reflects our understanding of network software based on experience building tools to support the rapid implementation of efficient protocols.
Reference: [13] <author> S. W. O'Malley and L. L. Peterson. </author> <title> A dynamic network architecture. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(2) </volume> <pages> 110-143, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: While we are interested in providing the same communication services (semantics) as are available in today's networks, we do so without regard for the exact form (syntax) of today's protocols. In particular, Morpheus supports a dynamic network architecture, such as the one described in <ref> [13] </ref>. This architecture has two key characteristics: * There are many, very simple protocols. * Protocols are selected and combined at runtime. These characteristics have ramifications that are apparent in the design of Morpheus. Consider the following two biases. <p> For example, IP performs multiplexing, routing, and fragmentation/reassembly. In Morpheus these functions would be implemented as three distinct protocols: a multiplexor, a router, and a worker, respectively. It is not surprising that existing protocols violate the shape constraint. One reason is the belief, refuted in this paper and <ref> [13] </ref>, that efficiency requires that there be very few layers in a protocol stack. This encourages large, complex protocols that comprise multiple functionalities.
Reference: [14] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The Synthesis kernel. </title> <journal> Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <month> winter </month> <year> 1988. </year>
Reference-contexts: The Synthesis kernel <ref> [14] </ref> achieves exceptional performance using a similar technique. However, in contrast to Synthesis, which generates customized kernel code, Morpheus generates customized versions of protocol operations that are written by Morpheus programmers. Morpheus' cloning has time and space costs.
Reference: [15] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: It should be made clear that Morpheus is object-oriented only with respect to the built-in protocol abstractions; the Morpheus programmer cannot define completely new classes. Also note that Morpheus' benefits could not be duplicated by adding pre-defined classes to a general object-oriented language such as C++ <ref> [15] </ref> since it would lack the knowledge of common patterns of protocol operation invocation that Morpheus exploits to optimize. Also, a general purpose language could not manage alignment and byte order considerations for message headers.
Reference: [16] <author> D. L. Tennenhouse. </author> <title> Layered multiplexing considered harmful. </title> <booktitle> In Proceedings of the 1st International Workshop on High-Speed Networks, </booktitle> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: This reflects the growing recognition of the penalties for logical multiplexing <ref> [7, 16] </ref>: * When streams are merged, they can't be distinguished for purposes of quality of service. * Multiplexing and demultiplexing at multiple layers hurts performance by duplicating effort. * Multiplexing is a barrier to the propagation of flow and congestion control information between protocol layers. <p> This encourages large, complex protocols that comprise multiple functionalities. A second reason is that existing protocols were designed before the current acknowledgement of the drawbacks of logical multiplexing <ref> [7, 16] </ref>; hence many existing protocols include logical multiplexing among their functions, even though they need not. 3.4 Flow Control Controlling the flow of messages between protocol peers is a familiar problem. For example, many protocols use window- or rate-based algorithms.
Reference: [17] <author> G. v. Bochmann. </author> <title> Usage of protocol development tools: The results of a survey. In Protocol Specification, Testing, and Verification, </title> <booktitle> VII, </booktitle> <year> 1987. </year>
Reference-contexts: For example, the x-kernel provides a uniform protocol interface and a protocol support library [11]. At the other extreme, network software is automatically derived from a protocol specification expressed using a Formal Description Technique (FDT) such as Estelle, LOTOS, or SDL <ref> [17] </ref>. In its current state, however, this technology has not lived up to its promise. Instead of expressing a protocol in purely abstract terms, protocols are specified in relatively implementation-oriented FDTs, and the software generated is generally in the form of a skeleton which must be completed with programmer code.
Reference: [18] <author> R. W. Watson and S. A. Mamrak. </author> <title> Gaining efficiency in transport services by appropriate design and implementation choices. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(2) </volume> <pages> 97-120, </pages> <month> May </month> <year> 1987. </year> <month> 27 </month>
Reference-contexts: The constraints imposed by Morpheus take the form of strategies and techniques carefully selected from among those exposed by collective experience with networks <ref> [2, 11, 18] </ref>, plus a novel constraint (shape) introduced in this paper. Stated another way, there are two motivations for the constraints imposed by Morpheus. First, they enforce a good design discipline. It has been argued that the development of a new engineering discipline often happens in two phases [9].
References-found: 18

