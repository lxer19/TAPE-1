URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/westbrook/cell.ps.Z
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/westbrook/
Root-URL: http://www.cs.yale.edu
Title: Cellular Embeddings and Network Flow  
Author: Jeffery Westbrook 
Abstract: This paper presents an algorithm for network flow that uses the graph decomposition introduced by Frederickson, called a hammock decomposition, to achieve improved running times on sparse graphs. The algorithm achieves linear running time on graphs with sufficiently good cellular embedding prop erties.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. K. Ahuja, J. B. Orlin, and R. E. Tarjan. </author> <title> Improved time bounds for the maximum flow problem. </title> <journal> J. ACM, </journal> <volume> 37(2) </volume> <pages> 213-223, </pages> <year> 1990. </year>
Reference-contexts: There have been a number of recent results that improve the running time of Goldberg and Tarjan's preflow/push algorithm, such as <ref> [1] </ref>[2][3][9][11]. The excess scaling algorithm of [1] runs in time O (mn + n 2 p logU), where U is the largest arc capacity. The randomized algorithm of [3] runs in time O (mn + n 2 log 3 n) with high probability.
Reference: [2] <author> N. Alon. </author> <title> Generating pseudo-random permutations and maximum flow algorithms. </title> <journal> Inf. Process. Lett., </journal> <year> 1990. </year>
Reference: [3] <author> J. Cheriyan, T. Hagerup, and K. Mehlhorn. </author> <title> Can a maximum flow be computed in o(mn) time? In Int. </title> <booktitle> Colloq. on Automata, Languages, and Programming (ICALP 90), </booktitle> <year> 1990. </year>
Reference-contexts: There have been a number of recent results that improve the running time of Goldberg and Tarjan's preflow/push algorithm, such as [1][2]<ref> [3] </ref>[9][11]. The excess scaling algorithm of [1] runs in time O (mn + n 2 p logU), where U is the largest arc capacity. The randomized algorithm of [3] runs in time O (mn + n 2 log 3 n) with high probability. The deterministic algorithms of [11] and [8] run in time O (nm log m=n log n n) + n 2 log 2+* n) for any constant *.
Reference: [4] <author> L. R. Ford and D. R. Fulkerson. </author> <title> Maximal flow through a network. </title> <journal> Canadian Journal of Mathematics, </journal> <volume> 8 </volume> <pages> 399-404, </pages> <year> 1956. </year>
Reference-contexts: In addition, we use their result to show that the residual capacity of an residual edge can be computed in O (1) time. The algorithm of Miller and Naor is based on the relationship between a planar graph and its topological dual. Ford and Fulkerson <ref> [4] </ref> observed that for a planar network, a cycle in geometric dual graph generates a cut in the network, and the minimum weight st-cut is given by the minimum weight simple cycle in the dual that separates s from t.
Reference: [5] <author> L. R. Ford and D. R. Fulkerson. </author> <title> Flows in Networks. </title> <publisher> Princeton University Press, </publisher> <address> Princeton, NJ, </address> <year> 1962. </year>
Reference-contexts: Then apply the basic theorems of network flow to G 0 . See, for example, the discussion in <ref> [5] </ref> on graphs with multiple sources and sinks. Lemma 1 Let h be a hammock, C = (X; X) a cut of G (h), and f h a feasible flow for the supplies and demands s i ; i 2 [1::4].
Reference: [6] <author> G. N. Frederickson. </author> <title> Using cellular embeddings in solving all-pairs shortest paths problems. </title> <booktitle> In Proc. 30th Symp. on Foundations of Computer Science, </booktitle> <pages> pages 448-453, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Computation of the maximum flow in a network is a classical problem in combinatorial optimization. Let G = (V; A) be a network, and let n = jV j and m = jAj. In <ref> [6] </ref> Frederickson introduced the hammock decomposition of a graph. Based on a particular cellular embedding of G, the hammock decomposition partitions a graph into a collection of outerplanar subgraphs. <p> Such a path is called an augmenting path. 3 Hammocks Let G = (V; A) be a directed graph, with m = jAj and n = jV j. A hammock decomposition of G <ref> [6] </ref> partitions G into a collection of outerplanar subgraphs, called major hammocks, and a collection of single edges, called minor hammocks. Let h denote a hammock. Each major hammock h has four vertices of attachment, denoted A (h). <p> The crosscap number of a surface is the number of Mobius strips attached to a surface.) See <ref> [6] </ref> for more information. Frederickson also shows that if G can be embedded on a surface of genus g such that all vertices are covered by p faces, then the hammock number ~fl (G) is O (g + p). <p> Replace them by a single edge (u; v) with capacity cap (e 1 ) + cap (e 2 ). This procedure can be implemented in O (jhj) time and space using basic data structures (See, e.g., <ref> [6] </ref>.) As each operation is applied, a record is created, so that the sequence of operations can be undone.
Reference: [7] <author> A. V. Goldberg and R. E. Tarjan. </author> <title> A new approach to the maximum flow problem. </title> <journal> J. ACM, </journal> <volume> 35 </volume> <pages> 921-940, </pages> <year> 1988. </year>
Reference-contexts: This can be effectively regarded as replacing the hammock by a complete directed graph on the attachment vertices. A modified version of the Goldberg-Tarjan preflow-push algorithm <ref> [7] </ref> is run to produce a flow on the reduced graph. Lastly, the flow on the reduced graph is expanded to a flow on the full graph. The preprocessing and postprocessing of hammocks requires O (m + n) time. There are several difficulties in implementing this approach. <p> This improves on all known network flow algorithms when ~fl = o (n). When ~fl = (n), CELL runs in time O (m + n + n~fl log (n 2 =~fl)), which is never worse than the algorithm of Goldberg and Tarjan <ref> [7] </ref>. There have been a number of recent results that improve the running time of Goldberg and Tarjan's preflow/push algorithm, such as [1][2][3][9][11]. The excess scaling algorithm of [1] runs in time O (mn + n 2 p logU), where U is the largest arc capacity. <p> These are undirected edges of unbounded capacity. The flow value on edge (u; h), u 2 A (h), indicates the net amount of outflow (or inflow) being routed into or out of the hammock through u. 4.2 Preflow-Push on the Reduced Graph The generic Goldberg-Tarjan preflow-push algorithm <ref> [7] </ref> begins with a preflow on graph G and turns it into a flow using a sequence of operations called "pushes." It uses a labeling d : V ! [0::2n 1] to help push flow in the right direction. <p> Proof: If the algorithm terminates, then no node has excess. Extend the reduced preflow to a full preflow. Still no vertex has excess, since all hammock vertices satisfy the conservation of flow condition. Extend the reduced labeling to a valid full labeling. By Theorem 3.4 of <ref> [7] </ref>, a preflow with a valid labeling such that no vertex has excess is a maximum flow. 2 8 Selection Rules and Running Time We now give rules for selecting active vertices, eligible edges, and push values. To make the algorithm efficient, care is needed in choosing these rules. <p> Proof: By Lemmas 9 and 10, the preflow and labels in G R can be extended to a preflow and valid labeling in G. By Lemma 3.5 of <ref> [7] </ref>, in a valid preflow the source is reachable in the residual graph from any vertex with positive excess. <p> Proof: The time spent in preprocessing and postprocessing is O (m + n). By the above discussion, the time spent in relabeling and saturating pushes is O (~fln R ). Goldberg and Tarjan analyze the FIFO vertex selection rule and maximum push value rule, and show in <ref> [7] </ref> Lemmas 4.3 and Corollary 4.4, that the number of non-saturating pushes is O (n 3 ), independent of the edge selection rule.
Reference: [8] <author> V. King, S. Rao, and R. Tarjan. </author> <title> A faster deterministic maximum flow algorithm. Improved version of an algorithm that appeared in Proc. </title> <booktitle> 3rd ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <year> 1992, </year> <pages> 157-164. </pages>
Reference-contexts: The excess scaling algorithm of [1] runs in time O (mn + n 2 p logU), where U is the largest arc capacity. The randomized algorithm of [3] runs in time O (mn + n 2 log 3 n) with high probability. The deterministic algorithms of [11] and <ref> [8] </ref> run in time O (nm log m=n log n n) + n 2 log 2+* n) for any constant *.
Reference: [9] <author> V. King, S. Rao, and R. Tarjan. </author> <title> A faster deterministic maximum flow algorithm. </title> <booktitle> In Proc. 3rd ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 157-164, </pages> <year> 1992. </year>
Reference: [10] <author> G. L. Miller and J. S. Naor. </author> <title> Flow in planar graphs with multiple sources and sinks. </title> <booktitle> In Proc. 30th IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 112-117, </pages> <year> 1989. </year> <note> To appear, SIAM J. Comput. </note>
Reference-contexts: At the conclusion of this processing, s and t are attachment vertices and the number of hammocks has increased by O (1). The processing can easily be done in time O (m + n). 6 Flows in Planar Networks Miller and Naor <ref> [10] </ref> give an algorithm to compute the flow function in a planar graph given a set of fixed supplies and demands at various nodes. The running time of this algorithm is O (n 1:5 ) on an arbitrary planar graph.
Reference: [11] <author> S. Phillips and J. Westbrook. </author> <title> On-line load balancing and network flow. </title> <booktitle> In Proc. 1993 Symp. on Theory of Computing, </booktitle> <pages> pages 402-411, </pages> <month> Apr. </month> <year> 1993. </year>
Reference-contexts: algorithm, such as [1][2][3][9]<ref> [11] </ref>. The excess scaling algorithm of [1] runs in time O (mn + n 2 p logU), where U is the largest arc capacity. The randomized algorithm of [3] runs in time O (mn + n 2 log 3 n) with high probability. The deterministic algorithms of [11] and [8] run in time O (nm log m=n log n n) + n 2 log 2+* n) for any constant *.
Reference: [12] <author> D. D. Sleator and R. E. Tarjan. </author> <title> A data structure for dynamic trees. </title> <journal> J. Comput. System Sci., </journal> <volume> 26 </volume> <pages> 362-391, </pages> <year> 1983. </year>
Reference-contexts: This improves on all known network flow algorithms when ~fl = o (n) 2 3 , and is linear for ~fl = o (n 1 The Goldberg-Tarjan algorithm achieves its best running time, O (mn log (n 2 =m)), through the use of dynamic trees <ref> [12] </ref>. We show how to modify dynamic trees so that they can be used to compute the flow in the reduced graph.
Reference: [13] <author> D. D. Sleator and R. E. Tarjan. </author> <title> Self-adjusting binary search trees. </title> <journal> J. ACM, </journal> <volume> 32 </volume> <pages> 652-686, </pages> <year> 1985. </year>
Reference-contexts: Their analysis is valid for CELL. 2 9 Use of Dynamic Trees The dynamic tree data structure of Sleator and Tarjan <ref> [13] </ref> maintains a forest of rooted trees in which each vertex v has an associated real-valued cost, cost (v), under sequence of operations described in Figure 3. All operations can be performed in O (log n) amortized time per operation. <p> To handle type-one configurations, a modified version of the data structure must be developed. We examine the details of the dynamic tree data structure, which we sketch below. The splay-tree implementation of dynamic trees <ref> [13] </ref> represents the tree by partitioning the vertices into a collection of paths that go up the tree.
References-found: 13

