URL: http://www-cad.eecs.berkeley.edu/HomePages/rajeev/publications/psdir/iwls95_tech_report.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/rajeev/publications/publications.html
Root-URL: http://www.cs.berkeley.edu
Title: Efficient Formal Design Verification: Data Structure Algorithms  
Author: Rajeev K. Ranjan Adnan Aziz Robert K. Brayton Bernard Plessier Carl Pixley 
Note: Supported by Motorola Grant Supported by SRC 93-DC-008  
Address: MD OE321  Berkeley 6501 Wm Cannon Drive West Berkeley, CA 94720 Austin, TX 78735  
Affiliation: Department of Electrical Engg. and Computer Sc. Motorola Inc.,  University of California at  
Abstract: We describe a data structure and a set of BDD based algorithms for efficient formal design verification. We argue that hardware designs should be translated into an intermediate hierarchical netlist of combinational tables and sequential elements, and internally represented by a flattened network of gates and latches, akin to that in SIS [32]. We establish that the core computation in BDD based formal design verification is forming the image and pre-image of sets of states under the transition relation characterizing the design. To make this step efficient, we address BDD variable ordering, use of partitioned transition relations, use of clustering, use of don't cares, and redundant latch removal. Many of these techniques have been studied in the past. We provide a complete integrated set of modified algorithms and give references and comparisons with previous work. We report experimental results on a series of seven industrial examples containing from 28 to 172 binary valued latches. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aziz, F. Balarin, S.-T. Cheng, R. Hojati, T. Kam, S. C. Krishnan, R. K. Ranjan, T. R. Shiple, V. Singhal, S. Tasiran, H.-Y. Wang, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. HSIS: </author> <title> A BDD-Based Environment for Formal Verification. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 454-459, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: The theory behind this approach has been investigated over the last three decades, but only in the last five years have practical tools begun to emerge. Though it overcomes many of the drawbacks of simulation <ref> [1] </ref>, it is currently limited to relatively small designs. We seek to improve the efficiency of verification so that larger designs can be verified. A detailed survey of the various verification methods can be found in [22]. <p> The wide acceptance of SIS as a framework for developing new applications suggests that our data structure may have similar applicability. This approach has the advantage over the one used in the initial version of HSIS <ref> [1] </ref> in that the number of variables initially needed to build the BDDs representing the system is drastically reduced; only the present state, next state, and primary input variables are needed. <p> This is part of a second generation BDD based tool (HSIS) for both logic synthesis and formal design verification using either model checking or language containment. The input is an enhanced version of Verilog which is compiled to a hierarchical netlist <ref> [1] </ref>. This is determinized and read into a network of latches and gates.
Reference: [2] <author> A. Aziz, T. R. Shiple, V. Singhal, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Formula-Dependent Equivalence for Compositional CTL Model Checking. </title> <booktitle> In Computer Aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 324-337. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Indeed, the computational complexity of this problem is known to be PSPACE-complete [3]. The complexity introduced by concurrent interaction is popularly referred to as the state explosion problem. The quest for heuristic solutions to this problem constitutes the forefront of research in formal verification <ref> [2, 9, 13, 15, 21] </ref>. Binary Decision Diagrams (BDDs) [7] are canonical representations of Boolean functions on which Boolean operations can be performed efficiently. Furthermore, they can compactly represent a wide variety of commonly encountered functions. <p> Other data structures like GBDDs, XBDDs, ZBDDs [25] might be useful in these cases. There are also a wide class of heuristics for coping with state explosion that are orthogonal to the approaches we have taken, such as property specific reductions <ref> [2] </ref>, abstractions [21], and conservative approximations to reached state sets [13]. We believe these techniques can be conveniently developed in our framework and then tested and compared on realistic examples. 6 Acknowledgements We gratefully acknowledge the supported provided by grants from Motorola and SRC.
Reference: [3] <author> A. Aziz, V. Singhal, and R. K. Brayton. </author> <title> Verifying Interacting Finite State Machines: Complexity Issues. </title> <type> Technical Report UCB/ERL M93/68, </type> <institution> Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: Hence algorithms that directly manipulate states will have time and space complexity that is exponential in the size of the system description. Indeed, the computational complexity of this problem is known to be PSPACE-complete <ref> [3] </ref>. The complexity introduced by concurrent interaction is popularly referred to as the state explosion problem. The quest for heuristic solutions to this problem constitutes the forefront of research in formal verification [2, 9, 13, 15, 21].
Reference: [4] <author> A. Aziz, S. Tasiran, and R. K. Brayton. </author> <title> BDD Variable Ordering for Interacting Finite State Machines. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <address> San Diago, CA, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Given a logic function, the problem of finding the ordering that leads to a minimum sized BDD for the function is algorithmically intractable. Hence we need to apply some heuristics <ref> [4, 26, 33] </ref>. In the dynamic reordering scheme [31], the BDD package automatically reorders variables to minimize the total number of BDD nodes. Starting with a good heuristic ordering leads to better results. <p> These parameters can be chosen at the prompt and can be changed dynamically in the course of computation. 4.1.1 Results and Discussion In our framework, we provide options for using ordering heuristics given in <ref> [4] </ref> and [33]. For our experiments we chose the heuristic in [4] as it was shown to outperform the other. To demonstrate the effectiveness of dynamic ordering where the initial ordering is either random or based on a good heuristic, we performed some experiments. <p> These parameters can be chosen at the prompt and can be changed dynamically in the course of computation. 4.1.1 Results and Discussion In our framework, we provide options for using ordering heuristics given in <ref> [4] </ref> and [33]. For our experiments we chose the heuristic in [4] as it was shown to outperform the other. To demonstrate the effectiveness of dynamic ordering where the initial ordering is either random or based on a good heuristic, we performed some experiments.
Reference: [5] <author> I. Beer, S. Ben-David, D. Geist, R. Gewirtzman, and M. Yoeli. </author> <title> Methodology and system for practical formal verification of reactive hardware. </title> <booktitle> In Computer Aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 182-193. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: However, our approach is orthogonal to Lin's. After minimizing the transition relation using this approach, we can still apply Lin's method to possibly remove more latches and get a further reduction in BDD size after computing the set of reachable states. Beer et al. <ref> [5] </ref> mentioned a constant-elimination technique to reduce the number of inputs and memory elements; however no algorithm is proposed to detect such cases. 5 Conclusion and Future Work We described a data structure and a series of algorithms for efficient formal design verification using BDD's.
Reference: [6] <author> M. C. Browne, E. M. Clarke, and O. Grumberg. </author> <title> Characterizing Kripke Structures in Temporal Logic. </title> <type> Technical Report CMU-CS-87-104, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <year> 1987. </year>
Reference-contexts: It can be shown that the determinized design yields a Kripke structure that is bisimilar <ref> [6] </ref> to that of the original design, and can be safely used in place of the original. This determinization can be done automatically.
Reference: [7] <author> R. Bryant. </author> <title> Graph-based Algorithms for Boolean Function Manipulation. </title> <journal> IEEE Trans. Comput., </journal> <volume> C-35:677-691, </volume> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: The complexity introduced by concurrent interaction is popularly referred to as the state explosion problem. The quest for heuristic solutions to this problem constitutes the forefront of research in formal verification [2, 9, 13, 15, 21]. Binary Decision Diagrams (BDDs) <ref> [7] </ref> are canonical representations of Boolean functions on which Boolean operations can be performed efficiently. Furthermore, they can compactly represent a wide variety of commonly encountered functions.
Reference: [8] <author> J. R. Burch, E. M. Clarke, and D. E. </author> <title> Long. Representing Circuits More Efficiently in Symbolic Model Checking. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: If there are K clusters C 1 ; C 2 ; C k of latches, then the image computation can be equivalently written as, Image (A (~x)) = 9 ~x; ~u [ A (~x) i=K Y T C i ] (9) where T C i = Q In <ref> [8] </ref>, Burch also proposed the use of clustered transition relations to represent circuits more efficiently. Latches were grouped together to form clusters but no automatic way to form clusters was given. <p> This range computation is performed using a balanced binary tree leaves correspond to terms and variables at nodes of the tree that do not appear in the support of nodes elsewhere are existentially quantified. They reported better performance than [15]. Burch <ref> [8] </ref> criticized this approach on the grounds that generalized co-factor may introduce new variables in the supports of the terms, which delays the ability to quantify out variables. Heuristically, this would lead to larger BDD size of the intermediate product terms. <p> Thus the space requirement and the efficiency of image and pre-image computations become dependent on the order in which these clusters are processed. In <ref> [8] </ref>, an ordering scheme of 12 the partitioned transition relation is proposed and is based on the semantics of the underlying model. However, this requires detailed understanding of the semantics of the model and hence is not easily automated.
Reference: [9] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, and D. L. Dill. </author> <title> Sequential Circuit Verification Using Symbolic Model Checking. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Indeed, the computational complexity of this problem is known to be PSPACE-complete [3]. The complexity introduced by concurrent interaction is popularly referred to as the state explosion problem. The quest for heuristic solutions to this problem constitutes the forefront of research in formal verification <ref> [2, 9, 13, 15, 21] </ref>. Binary Decision Diagrams (BDDs) [7] are canonical representations of Boolean functions on which Boolean operations can be performed efficiently. Furthermore, they can compactly represent a wide variety of commonly encountered functions. <p> Furthermore, they can compactly represent a wide variety of commonly encountered functions. Transition relations and sets of states can be represented using BDDs of their characteristic functions, which can be used for efficient fixed-point computations <ref> [9, 15, 30] </ref>. BDDs are now extensively used for both design and implementation verification of hardware systems and many non-trivial design examples have been verified using BDDs [11, 29]. Still, there are many instances of medium sized circuits that cannot be verified using existing BDD techniques. <p> Same as case C in Table 2. Case D: Time to perform reachability with saved ordering file (in secs) Table 3: Results showing effectiveness of using saved ordering files. Monolithic Transition Relation: The transition relation of the system is represented by a single BDD <ref> [9] </ref> which is the conjunction of the transition relations of the individual latches. As the circuit complexity grows, the size of the transition relation usually explodes. Hence this approach becomes infeasible for large, complex circuits. <p> We make the following observations: setting higher limits obviously leads to fewer clusters but the total number of BDD nodes taken by the clusters becomes bigger. From Equation <ref> [9] </ref>, we observe that the image computation is performed by taking the product of transition relations of clusters sequentially (we will refer to them as sequential iterations). The time taken in forming this product is a function of number of clusters as well as the cluster sizes.
Reference: [10] <author> G. Cabodi and P. Camurati. </author> <title> Exploiting Cofactoring for Efficient FSM Symbolic Traversal Based on the Transition Relation. </title> <booktitle> In Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pages 299-313, </pages> <month> Oct. </month> <year> 1993. </year> <month> 18 </month>
Reference-contexts: These netlists can be internally represented by a SIS [32] like data structure, on which a large body of BDD techniques developed in SIS, for operations like sequential equivalence and optimization e.g. <ref> [10, 26, 30, 33] </ref>, can be applied. This data structure also provides a common and somewhat familiar software development environment for developers wanting to write their own applications. <p> Other BDD based techniques which look promising include the exists-cofactor of <ref> [10] </ref>, and the implicitly conjoined invariants of [24]. We plan to experiment with them since it should be relatively easy with the data structure proposed in this paper to implement these methods.
Reference: [11] <author> B. Chen, M. Yamazaki, and M. Fujita. </author> <title> Bug Identification of a Real Chip Design by Symbolic Model Checking. </title> <booktitle> In Proc. European Conf. on Design Automation, </booktitle> <address> Paris, France, </address> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: BDDs are now extensively used for both design and implementation verification of hardware systems and many non-trivial design examples have been verified using BDDs <ref> [11, 29] </ref>. Still, there are many instances of medium sized circuits that cannot be verified using existing BDD techniques.
Reference: [12] <author> S. T. Cheng. </author> <title> Compiling Verilog into Automata. </title> <type> Technical Report UCB/ERL M94/37, </type> <institution> Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: In Section 4 we provide a partial survey of state-of-the-art BDD techniques and present our contributions. 5 3 Data Structure Designers typically specify systems in a high level language which supports constructs like integer arithmetic, multi-valued variables, array structures etc. (e.g. SMV [29] or enhanced Verilog <ref> [12] </ref>). The description of the system often contains non-determinism typically introduced when some part of the design is abstracted by hiding details. Non-determinism also comes into play while modeling the behavior of the environment. Our approach to non-determinism is to add new unconstrained inputs.
Reference: [13] <author> H. Cho, G. D. Hachtel, E. Macii, B. Plessier, and F. Somenzi. </author> <title> Algorithms for Approximate FSM Traversal. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 25-30, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Indeed, the computational complexity of this problem is known to be PSPACE-complete [3]. The complexity introduced by concurrent interaction is popularly referred to as the state explosion problem. The quest for heuristic solutions to this problem constitutes the forefront of research in formal verification <ref> [2, 9, 13, 15, 21] </ref>. Binary Decision Diagrams (BDDs) [7] are canonical representations of Boolean functions on which Boolean operations can be performed efficiently. Furthermore, they can compactly represent a wide variety of commonly encountered functions. <p> Assignments to the latches in component C i not corresponding to the above states can never be attained in any environment <ref> [13] </ref>. 14 For components that are too small, this approach fails to give any improvement since typically all states are reached in the component; for components that are too large, the fixed point computation fails. We provide a routine which computes A i 1 for a given C i . <p> There are also a wide class of heuristics for coping with state explosion that are orthogonal to the approaches we have taken, such as property specific reductions [2], abstractions [21], and conservative approximations to reached state sets <ref> [13] </ref>. We believe these techniques can be conveniently developed in our framework and then tested and compared on realistic examples. 6 Acknowledgements We gratefully acknowledge the supported provided by grants from Motorola and SRC.
Reference: [14] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: In both cases the underlying design is characterized by a Kripke structure <ref> [14] </ref>. Definition 5 A Kripke structure K is a triple (S; T; L), where S is a finite set of states, T S fi S is the transition relation, and L : AP ! 2 S is the labelling function mapping atomic propositions (AP) to sets of states.
Reference: [15] <author> O. Coudert and J. C. Madre. </author> <title> A Unified Framework for the Formal Verification of Sequential Circuits. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 126-129, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: Verification tools that manipulate state-based systems explicitly are limited by the size of the state space (Mur [16]). However, most real designs consist of a set of interacting components leading to the problem of state explosion. In the context of implementation verification, Coudert and Madre <ref> [15] </ref> pioneered the use of BDDs to implicitly manipulate the product state space. Since then, the use of BDDs has been extended to manipulate transition systems in the area of design verification (SMV [29]). <p> Indeed, the computational complexity of this problem is known to be PSPACE-complete [3]. The complexity introduced by concurrent interaction is popularly referred to as the state explosion problem. The quest for heuristic solutions to this problem constitutes the forefront of research in formal verification <ref> [2, 9, 13, 15, 21] </ref>. Binary Decision Diagrams (BDDs) [7] are canonical representations of Boolean functions on which Boolean operations can be performed efficiently. Furthermore, they can compactly represent a wide variety of commonly encountered functions. <p> Furthermore, they can compactly represent a wide variety of commonly encountered functions. Transition relations and sets of states can be represented using BDDs of their characteristic functions, which can be used for efficient fixed-point computations <ref> [9, 15, 30] </ref>. BDDs are now extensively used for both design and implementation verification of hardware systems and many non-trivial design examples have been verified using BDDs [11, 29]. Still, there are many instances of medium sized circuits that cannot be verified using existing BDD techniques. <p> Although we do not pursue it in this paper, the fact that we have a next state function instead of a relation also allows experimentation with the method proposed in <ref> [15] </ref>. 4 Algorithms In this section we present various BDD based algorithms to efficiently perform the core verification computations. In Section 4.1, techniques are discussed to achieve good BDD variable orderings. Section 4.2 presents the use of clustered transition relations. <p> As the circuit complexity grows, the size of the transition relation usually explodes. Hence this approach becomes infeasible for large, complex circuits. Partitioned Transition Relation: A vector of transition relations is used <ref> [15, 33] </ref>; each element of the vector represents the next state relation for a latch. Coudert [15] proposed reducing image computations to range computations by exploiting the property of the constrain operator; the range computation is performed by recursive co-factoring. Efficiency comes from caching intermediate results and exploiting disjoint support. <p> As the circuit complexity grows, the size of the transition relation usually explodes. Hence this approach becomes infeasible for large, complex circuits. Partitioned Transition Relation: A vector of transition relations is used [15, 33]; each element of the vector represents the next state relation for a latch. Coudert <ref> [15] </ref> proposed reducing image computations to range computations by exploiting the property of the constrain operator; the range computation is performed by recursive co-factoring. Efficiency comes from caching intermediate results and exploiting disjoint support. Touati [33] suggested a similar approach based on forming the product as a balanced binary tree. <p> as, Image (A (~x)) = 9 ~x k ; ~u k ( T k (~x; ~u; ~y k ) ^ (9~x k1 ; ~u k1 T k1 (~x; ~u; ~y k1 ) ^ ^ (9~x 1 ; ~u 1 T 1 (~x; ~u; ~y 1 ) ^ A (~x)))) Coudert <ref> [15] </ref> proposed the recursive image computation. <p> This range computation is performed using a balanced binary tree leaves correspond to terms and variables at nodes of the tree that do not appear in the support of nodes elsewhere are existentially quantified. They reported better performance than <ref> [15] </ref>. Burch [8] criticized this approach on the grounds that generalized co-factor may introduce new variables in the supports of the terms, which delays the ability to quantify out variables. Heuristically, this would lead to larger BDD size of the intermediate product terms. <p> Coudert <ref> [15] </ref> observed that any set of states between A i and A i n A i1 can be used in place of A i in Equation 10 while preserving the result for A i+1 .
Reference: [16] <author> D. L. Dill, A. J. Drexler, A. J. Hu, and C. H. Yang. </author> <title> Protocol Verification as a Hardware Design Aid. </title> <booktitle> In Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pages 522-525, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: In MC, the properties are specified using temporal logic, and model checking is applied to the system specification to verify these properties [17]. Verification tools that manipulate state-based systems explicitly are limited by the size of the state space (Mur <ref> [16] </ref>). However, most real designs consist of a set of interacting components leading to the problem of state explosion. In the context of implementation verification, Coudert and Madre [15] pioneered the use of BDDs to implicitly manipulate the product state space.
Reference: [17] <author> E. A. Emerson. </author> <title> Temporal and Modal Logic. </title> <editor> In J. van Leeuwen, editor, </editor> <title> Formal Models and Semantics, </title> <booktitle> volume B of Handbook of Theoretical Computer Science, </booktitle> <pages> pages 996-1072. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: The verification problem is equivalent to verifying that the language of the system is contained in the language of the properties (COSPAN [23]). In MC, the properties are specified using temporal logic, and model checking is applied to the system specification to verify these properties <ref> [17] </ref>. Verification tools that manipulate state-based systems explicitly are limited by the size of the state space (Mur [16]). However, most real designs consist of a set of interacting components leading to the problem of state explosion. <p> A pictorial representation of a Kripke structure is given in Figure 1. In the CTL model checking paradigm <ref> [17] </ref>, properties are expressed as formulas from an inductively defined syntax. Truth of the formulae is interpreted over states in Kripke structures; determining the truth value of a formula over a state in the structure is referred to as model checking and can be algorithmically performed using fixed point calculations. <p> Truth of the formulae is interpreted over states in Kripke structures; determining the truth value of a formula over a state in the structure is referred to as model checking and can be algorithmically performed using fixed point calculations. Precise syntax and semantics are given in <ref> [17] </ref>. As an example, state s 0 in the Kripke structure of s 1 is labelled by a and b, and there is a path from s 0 to s 1 , namely s 0 ! s 2 ! s 3 ! s 5 ! s 1 .
Reference: [18] <author> E. A. Emerson and C. L. Lei. </author> <title> Modalities for Model Checking: Branching Time Strikes Back. </title> <booktitle> In Proc. ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-96, </pages> <year> 1985. </year>
Reference-contexts: In simple terms, verification consists of finding a path in a Kripke structure which starts at the initial state and leads to a fair cycle i.e. a cycle which includes at least one state from a designated subset of fair states F <ref> [18] </ref>. Conceptually, 4 this check may be performed by first finding the set of states F fl which reach a fair cycle.
Reference: [19] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability. </title> <editor> W. H. </editor> <publisher> Freeman and Co., </publisher> <year> 1979. </year>
Reference-contexts: Hence the K new variables along with the assignment can be guessed; the resultant table can be checked in polynomial time. NP-hardness We use a reduction from graph coloring <ref> [19] </ref>. Let G = (V = fv 0 ; v 1 ; : : : ; v n1 g; E) be a graph and K n be a positive integer. Suppose k = dlog 2 ne.
Reference: [20] <author> D. Geist and I. Beer. </author> <title> Efficient model checking by automated ordering of transition relation partitions. </title> <booktitle> In Computer Aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 52-71. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In [8], an ordering scheme of 12 the partitioned transition relation is proposed and is based on the semantics of the underlying model. However, this requires detailed understanding of the semantics of the model and hence is not easily automated. Geist et al. <ref> [20] </ref> give a simple automated way to order the relations when each relation consists of the next state function of a single latch. <p> In our framework these weights can be interactively varied. We performed a series of experiments to find a good combination of these weights. 4.3.2 Results and Discussion Table 5 compares the performance (CPU time in seconds) of our ordering heuristic with the heuristics proposed in <ref> [20, 33] </ref>. Specifically we report the time taken in the reached state computation. The weights chosen after some experimentation in our heuristic were W 1 = 2; W 2 = 1; W 3 = 1; W 4 = 1. <p> Specifically we report the time taken in the reached state computation. The weights chosen after some experimentation in our heuristic were W 1 = 2; W 2 = 1; W 3 = 1; W 4 = 1. Various Heuristics Example [33] <ref> [20] </ref> Proposed BIU 305 326 315 Every 6087 5857 5788 2MDLC 176 244 179 BDLC* 140 191 144 BDLC space out 3023 2231 Gigamax 4.8 7.4 4.8 sbc 116 135 118 Table 5: Comparison of CPU time (in seconds) for different cluster ordering heuristics. <p> The above results indicate that the proposed approach always outperforms that in <ref> [20] </ref>. Improvements up to 25% were achieved. Although in some examples (BIU, BDLC*, 2MDLC, sbc) Touati's heuristic [33] performs marginally better than ours, on BDLC, Touati's approach ran out of memory. 4.4 Don't Cares Don't care points arise naturally in the context of BDD based formal verification.
Reference: [21] <author> S. Graf. </author> <title> Verification of a Distributed Cache Memory by Using Abstractions. </title> <booktitle> In Computer Aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 207-219. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Indeed, the computational complexity of this problem is known to be PSPACE-complete [3]. The complexity introduced by concurrent interaction is popularly referred to as the state explosion problem. The quest for heuristic solutions to this problem constitutes the forefront of research in formal verification <ref> [2, 9, 13, 15, 21] </ref>. Binary Decision Diagrams (BDDs) [7] are canonical representations of Boolean functions on which Boolean operations can be performed efficiently. Furthermore, they can compactly represent a wide variety of commonly encountered functions. <p> Other data structures like GBDDs, XBDDs, ZBDDs [25] might be useful in these cases. There are also a wide class of heuristics for coping with state explosion that are orthogonal to the approaches we have taken, such as property specific reductions [2], abstractions <ref> [21] </ref>, and conservative approximations to reached state sets [13]. We believe these techniques can be conveniently developed in our framework and then tested and compared on realistic examples. 6 Acknowledgements We gratefully acknowledge the supported provided by grants from Motorola and SRC.
Reference: [22] <author> A. Gupta. </author> <title> Formal Hardware Verification Methods: A Survey. </title> <booktitle> In Formal Methods in System Design, </booktitle> <pages> pages 151-238. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Though it overcomes many of the drawbacks of simulation [1], it is currently limited to relatively small designs. We seek to improve the efficiency of verification so that larger designs can be verified. A detailed survey of the various verification methods can be found in <ref> [22] </ref>. The first to be used in design verification was theorem proving, which usually requires extensive interaction with human experts. Language containment (LC) and model checking (MC) are two recent automated approaches for verifying properties of designs described by state transition systems.
Reference: [23] <author> Z. Har'El and R. P. Kurshan. </author> <title> Software for Analytical Development of Communication Protocols. </title> <journal> AT&T Technical Journal, </journal> <pages> pages 45-59, </pages> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: In LC, the system and the properties are both specified as !-automata. The verification problem is equivalent to verifying that the language of the system is contained in the language of the properties (COSPAN <ref> [23] </ref>). In MC, the properties are specified using temporal logic, and model checking is applied to the system specification to verify these properties [17]. Verification tools that manipulate state-based systems explicitly are limited by the size of the state space (Mur [16]). <p> Verification consists of checking whether all design behavior is acceptable i.e. checking L D L P , which in turn is equivalent to checking that L D " L P is empty. Kurshan <ref> [23] </ref> observed that for certain classes of properties (namely deterministic L-automata) the set L P is efficiently computable.
Reference: [24] <author> A. J. Hu, G. York, and D. L. Dill. </author> <title> New Techniques for Efficient Verification with Implicitly Conjoined BDD's. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 276-282, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Other BDD based techniques which look promising include the exists-cofactor of [10], and the implicitly conjoined invariants of <ref> [24] </ref>. We plan to experiment with them since it should be relatively easy with the data structure proposed in this paper to implement these methods. Certain limitations of BDD based formal design verification can not be solved by the techniques described in this work.
Reference: [25] <author> S.-W. Jeong, B. Plessier, G. D. Hachtel, and F. Somenzi. </author> <title> Extended BDD's: Trading off Canonicity for Structure in Verification Algorithms. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <year> 1991. </year>
Reference-contexts: with the sequential synthesis tool SIS will immediately see the similarity with the SIS or BLIF representation of sequential logic circuits. 7 We chose such a data structure because it allows easy access to the wide range of BDD applications written for SIS, such as variable ordering and reachability analysis <ref> [25, 26, 33] </ref>. The wide acceptance of SIS as a framework for developing new applications suggests that our data structure may have similar applicability. <p> Certain limitations of BDD based formal design verification can not be solved by the techniques described in this work. For example, the size of the reached set may be large under any variable ordering. Other data structures like GBDDs, XBDDs, ZBDDs <ref> [25] </ref> might be useful in these cases. There are also a wide class of heuristics for coping with state explosion that are orthogonal to the approaches we have taken, such as property specific reductions [2], abstractions [21], and conservative approximations to reached state sets [13].
Reference: [26] <author> S.-W. Jeong, B. Plessier, G. D. Hachtel, and F. Somenzi. </author> <title> Variable Ordering for FSM Traversal. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <year> 1991. </year>
Reference-contexts: These netlists can be internally represented by a SIS [32] like data structure, on which a large body of BDD techniques developed in SIS, for operations like sequential equivalence and optimization e.g. <ref> [10, 26, 30, 33] </ref>, can be applied. This data structure also provides a common and somewhat familiar software development environment for developers wanting to write their own applications. <p> with the sequential synthesis tool SIS will immediately see the similarity with the SIS or BLIF representation of sequential logic circuits. 7 We chose such a data structure because it allows easy access to the wide range of BDD applications written for SIS, such as variable ordering and reachability analysis <ref> [25, 26, 33] </ref>. The wide acceptance of SIS as a framework for developing new applications suggests that our data structure may have similar applicability. <p> Given a logic function, the problem of finding the ordering that leads to a minimum sized BDD for the function is algorithmically intractable. Hence we need to apply some heuristics <ref> [4, 26, 33] </ref>. In the dynamic reordering scheme [31], the BDD package automatically reorders variables to minimize the total number of BDD nodes. Starting with a good heuristic ordering leads to better results.
Reference: [27] <author> B. Lin. </author> <title> Synthesis of VLSI Design with Symbolic Techniques. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1991. </year>
Reference-contexts: In the retiming approach, the reset values of the latches must be identical for either of them to be removed. This analysis can be done very easily. A similar approach was proposed by Lin <ref> [27] </ref> who describes an algorithm to remove a maximal set of state variables without affecting the uniqueness of reachable states. The problem with this approach is that we need to pre-compute the set of reachable states.
Reference: [28] <author> B. Lockyear and C. Ebeling. </author> <title> Optimal Retiming of Level-Clocked Circuits Using Symmetric Clock Schedules. </title> <journal> In IEEE Trans. Comput.-Aided Design Integrated Circuits, </journal> <pages> pages 1097-1109, </pages> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: These variables are not considered for further BDD manipulations. Latch Removal by Retiming: Retiming rearranges the storage elements in a circuit to reduce its cycle time or to reduce the number of storage elements, without changing its functionality <ref> [28] </ref>. We use retiming to reduce the number of storage elements. A simple example to demonstrate this is shown in Figure 4 (a). Note that, the x a x a inputs of these 2 latches are fed by the same combinational logic.
Reference: [29] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: In the context of implementation verification, Coudert and Madre [15] pioneered the use of BDDs to implicitly manipulate the product state space. Since then, the use of BDDs has been extended to manipulate transition systems in the area of design verification (SMV <ref> [29] </ref>). In this paper we describe a data structure and a set of algorithms for efficient BDD based formal design verification. We argue that hardware designs can (and should) be mapped into netlists of deterministic (possibly multi-valued) gates and latches. <p> BDDs are now extensively used for both design and implementation verification of hardware systems and many non-trivial design examples have been verified using BDDs <ref> [11, 29] </ref>. Still, there are many instances of medium sized circuits that cannot be verified using existing BDD techniques. <p> In Section 4 we provide a partial survey of state-of-the-art BDD techniques and present our contributions. 5 3 Data Structure Designers typically specify systems in a high level language which supports constructs like integer arithmetic, multi-valued variables, array structures etc. (e.g. SMV <ref> [29] </ref> or enhanced Verilog [12]). The description of the system often contains non-determinism typically introduced when some part of the design is abstracted by hiding details. Non-determinism also comes into play while modeling the behavior of the environment. Our approach to non-determinism is to add new unconstrained inputs. <p> The first parameter, the base value, is the total number of nodes 8 Example # Latches # Gates Description sbc 28 927 ISCAS'89 sequential benchmark (a snooping bus controller). Gigamax 45 994 Cache coherency protocol description for hardware implementation of Gigamax distributed multiprocessor <ref> [29] </ref>. Abstracted Byte Data Link Controller (BDLC); BDLC* Manages the transmit-receive protocol between microprocessor 144 4775 and a serial bus. Contains the abstract description of BIT module. Part of a commercial chip.
Reference: [30] <author> C. Pixley. </author> <title> A Computational Theory and Implementation of Sequential Hardware Equivalence. </title> <editor> In E. M. Clarke and R. P. Kurshan, editors, </editor> <booktitle> Proc. of the Workshop on Computer-Aided Verification, volume 3 of DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <pages> pages 293-320. </pages> <publisher> American Mathematical Society, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: These netlists can be internally represented by a SIS [32] like data structure, on which a large body of BDD techniques developed in SIS, for operations like sequential equivalence and optimization e.g. <ref> [10, 26, 30, 33] </ref>, can be applied. This data structure also provides a common and somewhat familiar software development environment for developers wanting to write their own applications. <p> Furthermore, they can compactly represent a wide variety of commonly encountered functions. Transition relations and sets of states can be represented using BDDs of their characteristic functions, which can be used for efficient fixed-point computations <ref> [9, 15, 30] </ref>. BDDs are now extensively used for both design and implementation verification of hardware systems and many non-trivial design examples have been verified using BDDs [11, 29]. Still, there are many instances of medium sized circuits that cannot be verified using existing BDD techniques.
Reference: [31] <author> R. Rudell. </author> <title> Dynamic Variable Ordering for Binary Decision Diagrams. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 42-47, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Given a logic function, the problem of finding the ordering that leads to a minimum sized BDD for the function is algorithmically intractable. Hence we need to apply some heuristics [4, 26, 33]. In the dynamic reordering scheme <ref> [31] </ref>, the BDD package automatically reorders variables to minimize the total number of BDD nodes. Starting with a good heuristic ordering leads to better results.
Reference: [32] <author> E. M. Sentovich, K. J. Singh, C. Moon, H. Savoj, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Sequential Circuit Design Using Synthesis and Optimization. </title> <booktitle> In Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pages 328-333, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: At early stages of the design process, descriptions often contain non-determinism which can be equivalently viewed as coming from unconstrained external inputs. These netlists can be internally represented by a SIS <ref> [32] </ref> like data structure, on which a large body of BDD techniques developed in SIS, for operations like sequential equivalence and optimization e.g. [10, 26, 30, 33], can be applied.
Reference: [33] <author> H. Touati, H. Savoj, B. Lin, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Implicit State Enumeration of Finite State Machines using BDD's. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 130-133, </pages> <month> Nov. </month> <year> 1990. </year> <month> 19 </month>
Reference-contexts: These netlists can be internally represented by a SIS [32] like data structure, on which a large body of BDD techniques developed in SIS, for operations like sequential equivalence and optimization e.g. <ref> [10, 26, 30, 33] </ref>, can be applied. This data structure also provides a common and somewhat familiar software development environment for developers wanting to write their own applications. <p> with the sequential synthesis tool SIS will immediately see the similarity with the SIS or BLIF representation of sequential logic circuits. 7 We chose such a data structure because it allows easy access to the wide range of BDD applications written for SIS, such as variable ordering and reachability analysis <ref> [25, 26, 33] </ref>. The wide acceptance of SIS as a framework for developing new applications suggests that our data structure may have similar applicability. <p> Given a logic function, the problem of finding the ordering that leads to a minimum sized BDD for the function is algorithmically intractable. Hence we need to apply some heuristics <ref> [4, 26, 33] </ref>. In the dynamic reordering scheme [31], the BDD package automatically reorders variables to minimize the total number of BDD nodes. Starting with a good heuristic ordering leads to better results. <p> These parameters can be chosen at the prompt and can be changed dynamically in the course of computation. 4.1.1 Results and Discussion In our framework, we provide options for using ordering heuristics given in [4] and <ref> [33] </ref>. For our experiments we chose the heuristic in [4] as it was shown to outperform the other. To demonstrate the effectiveness of dynamic ordering where the initial ordering is either random or based on a good heuristic, we performed some experiments. <p> As the circuit complexity grows, the size of the transition relation usually explodes. Hence this approach becomes infeasible for large, complex circuits. Partitioned Transition Relation: A vector of transition relations is used <ref> [15, 33] </ref>; each element of the vector represents the next state relation for a latch. Coudert [15] proposed reducing image computations to range computations by exploiting the property of the constrain operator; the range computation is performed by recursive co-factoring. Efficiency comes from caching intermediate results and exploiting disjoint support. <p> Coudert [15] proposed reducing image computations to range computations by exploiting the property of the constrain operator; the range computation is performed by recursive co-factoring. Efficiency comes from caching intermediate results and exploiting disjoint support. Touati <ref> [33] </ref> suggested a similar approach based on forming the product as a balanced binary tree. Image computation or pre-image computation is carried out iteratively using transition relations for individual latches. Reasoning heuristically, as the number of latches in the system grows, the computation time increases. <p> Touati <ref> [33] </ref> computes the image of a set of states by exploiting the property of the generalized cofactor in converting the image computation into range computation given by 9 ~x; ~u i=k Y T i A (~x) (~x; ~u; ~y i ) where T i A (~x) denotes the generalized cofactor of <p> In our framework these weights can be interactively varied. We performed a series of experiments to find a good combination of these weights. 4.3.2 Results and Discussion Table 5 compares the performance (CPU time in seconds) of our ordering heuristic with the heuristics proposed in <ref> [20, 33] </ref>. Specifically we report the time taken in the reached state computation. The weights chosen after some experimentation in our heuristic were W 1 = 2; W 2 = 1; W 3 = 1; W 4 = 1. <p> Specifically we report the time taken in the reached state computation. The weights chosen after some experimentation in our heuristic were W 1 = 2; W 2 = 1; W 3 = 1; W 4 = 1. Various Heuristics Example <ref> [33] </ref> [20] Proposed BIU 305 326 315 Every 6087 5857 5788 2MDLC 176 244 179 BDLC* 140 191 144 BDLC space out 3023 2231 Gigamax 4.8 7.4 4.8 sbc 116 135 118 Table 5: Comparison of CPU time (in seconds) for different cluster ordering heuristics. <p> The above results indicate that the proposed approach always outperforms that in [20]. Improvements up to 25% were achieved. Although in some examples (BIU, BDLC*, 2MDLC, sbc) Touati's heuristic <ref> [33] </ref> performs marginally better than ours, on BDLC, Touati's approach ran out of memory. 4.4 Don't Cares Don't care points arise naturally in the context of BDD based formal verification.
References-found: 33

