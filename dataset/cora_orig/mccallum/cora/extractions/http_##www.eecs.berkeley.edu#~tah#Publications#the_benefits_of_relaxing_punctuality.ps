URL: http://www.eecs.berkeley.edu/~tah/Publications/the_benefits_of_relaxing_punctuality.ps
Refering-URL: http://www.eecs.berkeley.edu/~tah/Publications/the_benefits_of_relaxing_punctuality.html
Root-URL: 
Email: Email: alur@research.att.com  Email: tomas@almaden.ibm.com  Email: tah@cs.cornell.edu  
Title: The Benefits of Relaxing Punctuality  
Author: Rajeev Alur Tomas Feder Thomas A. Henzinger 
Keyword: temporal logic, verification, real time.  
Address: Murray Hill, NJ 07974  San Jose, CA 95120  Ithaca, NY 14853  
Affiliation: AT&T Bell Laboratories  IBM Almaden Research Center  Computer Science Department, Cornell University  
Abstract: The most natural, compositional, way of modeling real-time systems uses a dense domain for time. The satisfiability of timing constraints that are capable of expressing punctuality in this model, however, is known to be undecidable. We introduce a temporal language that can constrain the time difference between events only with finite, yet arbitrary, precision and show the resulting logic to be EXPSPACE-complete. This result allows us to develop an algorithm for the verification of timing properties of real-time systems with a dense semantics. 1 A preliminary version of this paper appeared in the Proceedings of the Tenth Annual ACM Symposium on 
Abstract-found: 1
Intro-found: 1
Reference: [ACD93] <author> R. Alur, C. Courcoubetis, and D.L. Dill. </author> <title> Model checking in dense real time. </title> <journal> Information and Computation, </journal> <volume> 104(1) </volume> <pages> 2-34, </pages> <year> 1993. </year>
Reference-contexts: Most of these approaches are situated at either extreme of the trade-off between realistic modeling of time and feasible verification of timing properties. Typically, they either use a continuous model of time at the expense of decidability <ref> [Koy90, Lew90, ACD93, AD94] </ref>, or they sacrifice continuity to obtain decision procedures [JM86, EMSS90, HLP90, Ost90, AH93, AH94] (for a discussion of this trade-off, see [AH92]). This paper shows how a slight relaxation of the notion of punctuality allows us to combine the best of both worlds. <p> In the discrete-time case, the untimed model-checking algorithms can 27 be extended to real-time logics using a special tick transition [EMSS90, AH93, AH94]. In the continuous-time case, model-checking algorithms are known for branching-time specifications of timed automata <ref> [ACD93] </ref>. We present the first model-checking algorithm for a linear-time logic with a continuous-time semantics, by comparing Mitl-specifications against system descriptions given as timed automata. We model a real-time system by a timed automaton A and write the requirements specification as a formula of Mitl.
Reference: [AD94] <author> R. Alur and D.L. Dill. </author> <title> A theory of timed automata. </title> <journal> Theoretical Computer Science, </journal> <volume> 126 </volume> <pages> 183-235, </pages> <year> 1994. </year>
Reference-contexts: Most of these approaches are situated at either extreme of the trade-off between realistic modeling of time and feasible verification of timing properties. Typically, they either use a continuous model of time at the expense of decidability <ref> [Koy90, Lew90, ACD93, AD94] </ref>, or they sacrifice continuity to obtain decision procedures [JM86, EMSS90, HLP90, Ost90, AH93, AH94] (for a discussion of this trade-off, see [AH92]). This paper shows how a slight relaxation of the notion of punctuality allows us to combine the best of both worlds. <p> The complexity is PSPACE for the fragment of Mitl that employs only time intervals of the form [a; 1), (a; 1), [0; b), and [0; b]. Properties of timed state sequences can, alternatively, be defined by timed automata <ref> [AD94] </ref>. While the emptiness problem for timed automata is solvable, they are not closed under complement. Mitl identifies a fragment of the properties definable by timed automata that is closed under all boolean operations. <p> This is because the role of the formula 3 =1 in the undecidability argument for Mitl = can be replaced by the formula false 1 U 1 . 3 Timed Automata We use a variant of timed automata as defined in <ref> [AD94] </ref> to model (finite-state) real-time systems. Timed automata generalize nondeterministic finite automata over infinite strings. <p> (13; 15)) ! (fqg; [15; 20)) ! (;; [20; 40)) ! (fqg; [40; 1)): All timed state sequences that are accepted by A 2 satisfy the Mitl-formula 2 &lt;40 (p ! 2 [2;5) q) ^ 2 40 q: 3.2 Checking emptiness The emptiness problem for timed automata is solved in <ref> [AD94] </ref>. The algorithm given there can be adapted in a straightforward way to our variant of timed automata. We only sketch the basic idea behind the construction, and refer to [AD94] for the details. Consider the timed automaton A = (V; V 0 ; ff; X; fi; E). <p> ! 2 [2;5) q) ^ 2 40 q: 3.2 Checking emptiness The emptiness problem for timed automata is solved in <ref> [AD94] </ref>. The algorithm given there can be adapted in a straightforward way to our variant of timed automata. We only sketch the basic idea behind the construction, and refer to [AD94] for the details. Consider the timed automaton A = (V; V 0 ; ff; X; fi; E). <p> The 13 description of each vertex requires space logarithmic in jV j, polynomial in jXj, and polynomial in the encoding of the largest constant. It follows that the emptiness problem for timed automata is in PSPACE. The PSPACE-hardness follows from the corresponding result proved in <ref> [AD94] </ref>. Theorem 3.6 The emptiness problem for timed automata is PSPACE-complete. 3.3 Parallel composition For describing real-time systems it is useful to describe individual system components separately. Timed automata that describe system components can be put together using the following product construction. <p> By L (B) we denote the set of timed state sequences accepted by B. 2 The algorithm for checking the emptiness of timed automata can be extended to handle fairness conditions in the standard way <ref> [AD94] </ref>. In particular, it can be decided in PSPACE whether or not a given fair timed automaton accepts any timed state sequence. <p> The emptiness of L (B fl ) can be checked nondeterministically by repeated testing that 26 there is an edge between two vertices of region graph for B fl , while only a constant number of vertices needs to be stored <ref> [AD94] </ref>.
Reference: [AH92] <author> R. Alur and T.A. Henzinger. </author> <title> Logics and models of real time: a survey. </title> <editor> In J.W. de Bakker, K. Huizing, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Real Time: </title> <booktitle> Theory in Practice, Lecture Notes in Computer Science 600, </booktitle> <pages> pages 74-106. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Typically, they either use a continuous model of time at the expense of decidability [Koy90, Lew90, ACD93, AD94], or they sacrifice continuity to obtain decision procedures [JM86, EMSS90, HLP90, Ost90, AH93, AH94] (for a discussion of this trade-off, see <ref> [AH92] </ref>). This paper shows how a slight relaxation of the notion of punctuality allows us to combine the best of both worlds. We use a linear or trace semantics for reactive systems.
Reference: [AH93] <author> R. Alur and T.A. Henzinger. </author> <title> Real-time logics: complexity and expressiveness. </title> <journal> Information and Computation, </journal> <volume> 104(1) </volume> <pages> 35-77, </pages> <year> 1993. </year>
Reference-contexts: Most of these approaches are situated at either extreme of the trade-off between realistic modeling of time and feasible verification of timing properties. Typically, they either use a continuous model of time at the expense of decidability [Koy90, Lew90, ACD93, AD94], or they sacrifice continuity to obtain decision procedures <ref> [JM86, EMSS90, HLP90, Ost90, AH93, AH94] </ref> (for a discussion of this trade-off, see [AH92]). This paper shows how a slight relaxation of the notion of punctuality allows us to combine the best of both worlds. We use a linear or trace semantics for reactive systems. <p> We have shown that several interesting real-time logics are decidable under this weaker, digital-clock, interpretation <ref> [AH93, AH94] </ref>. In this paper we pursue an alternative, syntactic, concession. Instead of digitizing the meaning of a sentence, we prohibit timing constraints that predict the time difference between two states with infinite accuracy. <p> A standard way of introducing real time into the syntax of temporal languages constrains the temporal operators with time intervals <ref> [EMSS90, Koy90, AH93] </ref>. <p> It follows that Mitl = is not recursively axiomatizable. The undecidability result depends on the denseness of the time domain. If the formulas of Mitl = are interpreted over a discrete time domain, the resulting logic Mtl has a decidable satisfiability problem <ref> [AH93] </ref>. Theorem 2.18 The satisfiability problem for Mitl = is 1 1 -complete. Proof. <p> Proof. We prove 1 1 -hardness by reduction from the problem of deciding whether a given nondeterministic 2-counter machine M has a recurring computation (i.e., a computation in which a specified state repeats infinitely often), which is 1 1 -hard [HPS83]. In <ref> [AH93] </ref>, it is shown how to construct a formula of the discrete-time logic Mtl such that is satisfiable over dense-time models iff M has a recurring computation. The construction, with trivial modifications, applies to Mitl = . <p> Moreover, the algorithm also implies an upper bound of EXPSPACE for deciding Mitl. A matching lower bound of EXPSPACE for Mitl can be obtained along the lines of the proof that the discrete-time logic Mtl is EXPSPACE-hard <ref> [AH93] </ref>. Theorem 4.13 The satisfiability problem for Mitl is EXPSPACE-complete. <p> In the discrete-time case, the untimed model-checking algorithms can 27 be extended to real-time logics using a special tick transition <ref> [EMSS90, AH93, AH94] </ref>. In the continuous-time case, model-checking algorithms are known for branching-time specifications of timed automata [ACD93]. We present the first model-checking algorithm for a linear-time logic with a continuous-time semantics, by comparing Mitl-specifications against system descriptions given as timed automata. <p> Thus, in the general case the move to real time adds an exponential. This blow-up seems, however, unavoidable for formalisms for quantitative reasoning about time; it occurs already in the simplest, discrete-time, case of synchronous systems that proceed at the rate of one transition per time unit <ref> [EMSS90, AH93, AH94] </ref>. Acknowledgment. We wish to thank an anonymous referee for pointing out the PSPACE- fragment of Section 4.5. 28
Reference: [AH94] <author> R. Alur and T.A. Henzinger. </author> <title> A really temporal logic. </title> <journal> Journal of the ACM, </journal> <volume> 41(1):181204, </volume> <year> 1994. </year>
Reference-contexts: Most of these approaches are situated at either extreme of the trade-off between realistic modeling of time and feasible verification of timing properties. Typically, they either use a continuous model of time at the expense of decidability [Koy90, Lew90, ACD93, AD94], or they sacrifice continuity to obtain decision procedures <ref> [JM86, EMSS90, HLP90, Ost90, AH93, AH94] </ref> (for a discussion of this trade-off, see [AH92]). This paper shows how a slight relaxation of the notion of punctuality allows us to combine the best of both worlds. We use a linear or trace semantics for reactive systems. <p> We represent the possible behaviors of a real-time system by such timed state sequences, each of which defines a function from the nonnegative reals to the system states. Alas, even the satisfiability of a very simple class of real-time properties turns out to be undecidable in this model <ref> [AH94] </ref>. An inspection of the undecidability proof shows that the only timing constraints required are of the form 2 (p ! 3 =5 q); (y) predicting that every p-state is followed by a q-state precisely 5 time units later. <p> We have shown that several interesting real-time logics are decidable under this weaker, digital-clock, interpretation <ref> [AH93, AH94] </ref>. In this paper we pursue an alternative, syntactic, concession. Instead of digitizing the meaning of a sentence, we prohibit timing constraints that predict the time difference between two states with infinite accuracy. <p> This requirement can be expressed in temporal logics that admit explicit references to time through variables (say, in the style of the discrete-time logic Tptl of <ref> [AH94] </ref>). This extension, however, leads again to undecidability over a dense time domain. <p> In the discrete-time case, the untimed model-checking algorithms can 27 be extended to real-time logics using a special tick transition <ref> [EMSS90, AH93, AH94] </ref>. In the continuous-time case, model-checking algorithms are known for branching-time specifications of timed automata [ACD93]. We present the first model-checking algorithm for a linear-time logic with a continuous-time semantics, by comparing Mitl-specifications against system descriptions given as timed automata. <p> Thus, in the general case the move to real time adds an exponential. This blow-up seems, however, unavoidable for formalisms for quantitative reasoning about time; it occurs already in the simplest, discrete-time, case of synchronous systems that proceed at the rate of one transition per time unit <ref> [EMSS90, AH93, AH94] </ref>. Acknowledgment. We wish to thank an anonymous referee for pointing out the PSPACE- fragment of Section 4.5. 28
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state con-current systems using temporal-logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: In the untimed case, the system is modeled by its state-transition graph, and the specification may be presented either as a branching-time formula <ref> [CES86] </ref> or as a linear- time formula [LP85, SC85]. In the discrete-time case, the untimed model-checking algorithms can 27 be extended to real-time logics using a special tick transition [EMSS90, AH93, AH94]. In the continuous-time case, model-checking algorithms are known for branching-time specifications of timed automata [ACD93].
Reference: [EMSS90] <author> E.A. Emerson, A.K. Mok, A.P. Sistla, and J. Srinivasan. </author> <title> Quantitative temporal reason-ing. In R.P. Kurshan and E.M. </title> <editor> Clarke, editors, </editor> <booktitle> CAV 90: Computer-aided Verification, Lecture Notes in Computer Science 531, </booktitle> <pages> pages 136-145. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Most of these approaches are situated at either extreme of the trade-off between realistic modeling of time and feasible verification of timing properties. Typically, they either use a continuous model of time at the expense of decidability [Koy90, Lew90, ACD93, AD94], or they sacrifice continuity to obtain decision procedures <ref> [JM86, EMSS90, HLP90, Ost90, AH93, AH94] </ref> (for a discussion of this trade-off, see [AH92]). This paper shows how a slight relaxation of the notion of punctuality allows us to combine the best of both worlds. We use a linear or trace semantics for reactive systems. <p> A standard way of introducing real time into the syntax of temporal languages constrains the temporal operators with time intervals <ref> [EMSS90, Koy90, AH93] </ref>. <p> The PSPACE-hardness of Mitl 0;1 follows from the PSPACE-hardness of propositional temporal logic with until [SC85]. 2 Thus, the complexity of Mitl decreases from EXPSPACE to PSPACE if we prohibit bounded intervals with nonzero left end-points. This phenomenon has been observed also by <ref> [EMSS90] </ref> for discrete-time logics. 5 Mitl-based Real-time Verification Model checking is a powerful and well-established technique for the automatic verification of finite- state systems; it compares a temporal-logic specification of a system against a state-transition description of the system. <p> In the discrete-time case, the untimed model-checking algorithms can 27 be extended to real-time logics using a special tick transition <ref> [EMSS90, AH93, AH94] </ref>. In the continuous-time case, model-checking algorithms are known for branching-time specifications of timed automata [ACD93]. We present the first model-checking algorithm for a linear-time logic with a continuous-time semantics, by comparing Mitl-specifications against system descriptions given as timed automata. <p> Thus, in the general case the move to real time adds an exponential. This blow-up seems, however, unavoidable for formalisms for quantitative reasoning about time; it occurs already in the simplest, discrete-time, case of synchronous systems that proceed at the rate of one transition per time unit <ref> [EMSS90, AH93, AH94] </ref>. Acknowledgment. We wish to thank an anonymous referee for pointing out the PSPACE- fragment of Section 4.5. 28
Reference: [HLP90] <author> E. Harel, O. Lichtenstein, and A. Pnueli. </author> <title> Explicit-clock temporal logic. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 402-413. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference-contexts: Most of these approaches are situated at either extreme of the trade-off between realistic modeling of time and feasible verification of timing properties. Typically, they either use a continuous model of time at the expense of decidability [Koy90, Lew90, ACD93, AD94], or they sacrifice continuity to obtain decision procedures <ref> [JM86, EMSS90, HLP90, Ost90, AH93, AH94] </ref> (for a discussion of this trade-off, see [AH92]). This paper shows how a slight relaxation of the notion of punctuality allows us to combine the best of both worlds. We use a linear or trace semantics for reactive systems.
Reference: [HNSY94] <author> T.A. Henzinger, X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> Symbolic model checking for real-time systems. </title> <journal> Information and Computation, </journal> <volume> 111(2) </volume> <pages> 193-244, </pages> <year> 1994. </year>
Reference-contexts: That view can be modeled by pairing state sequences with sequences of closed intervals <ref> [HNSY94] </ref>.
Reference: [HPS83] <author> D. Harel, A. Pnueli, and J. Stavi. </author> <title> Propositional dynamic logic of regular programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 26(2) </volume> <pages> 222-243, </pages> <year> 1983. </year>
Reference-contexts: Proof. We prove 1 1 -hardness by reduction from the problem of deciding whether a given nondeterministic 2-counter machine M has a recurring computation (i.e., a computation in which a specified state repeats infinitely often), which is 1 1 -hard <ref> [HPS83] </ref>. In [AH93], it is shown how to construct a formula of the discrete-time logic Mtl such that is satisfiable over dense-time models iff M has a recurring computation. The construction, with trivial modifications, applies to Mitl = .
Reference: [JM86] <author> F. Jahanian and A.K. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(9):890-904, </volume> <year> 1986. </year>
Reference-contexts: Most of these approaches are situated at either extreme of the trade-off between realistic modeling of time and feasible verification of timing properties. Typically, they either use a continuous model of time at the expense of decidability [Koy90, Lew90, ACD93, AD94], or they sacrifice continuity to obtain decision procedures <ref> [JM86, EMSS90, HLP90, Ost90, AH93, AH94] </ref> (for a discussion of this trade-off, see [AH92]). This paper shows how a slight relaxation of the notion of punctuality allows us to combine the best of both worlds. We use a linear or trace semantics for reactive systems.
Reference: [Koy90] <author> R. Koymans. </author> <title> Specifying real-time properties with metric temporal logic. </title> <booktitle> Real-time Systems, </booktitle> <volume> 2(4) </volume> <pages> 255-299, </pages> <year> 1990. </year>
Reference-contexts: Most of these approaches are situated at either extreme of the trade-off between realistic modeling of time and feasible verification of timing properties. Typically, they either use a continuous model of time at the expense of decidability <ref> [Koy90, Lew90, ACD93, AD94] </ref>, or they sacrifice continuity to obtain decision procedures [JM86, EMSS90, HLP90, Ost90, AH93, AH94] (for a discussion of this trade-off, see [AH92]). This paper shows how a slight relaxation of the notion of punctuality allows us to combine the best of both worlds. <p> A standard way of introducing real time into the syntax of temporal languages constrains the temporal operators with time intervals <ref> [EMSS90, Koy90, AH93] </ref>. <p> 5 time units, or at time 5 the time-out event q happens." This requirement is expressed by the Mitl-formula 2 0 ((p ^ 2 (0;5) :p) ! (2 (0;5) :q ^ 3 (0;5] q)): Additional examples of real-time requirements that are specifiable using time-constrained temporal operators can be found in <ref> [Koy90] </ref>. 5 2.3.5 Model refinement All timed state sequences obey the so-called finite-variability condition: between any two points in time there are only finitely many state changes. This assumption is adequate for modeling discrete systems.
Reference: [Lew90] <author> H.R. Lewis. </author> <title> A logic of concrete time intervals. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 380-389. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference-contexts: Most of these approaches are situated at either extreme of the trade-off between realistic modeling of time and feasible verification of timing properties. Typically, they either use a continuous model of time at the expense of decidability <ref> [Koy90, Lew90, ACD93, AD94] </ref>, or they sacrifice continuity to obtain decision procedures [JM86, EMSS90, HLP90, Ost90, AH93, AH94] (for a discussion of this trade-off, see [AH92]). This paper shows how a slight relaxation of the notion of punctuality allows us to combine the best of both worlds.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite-state concurrent programs satisfy their linear specification. </title> <booktitle> In Proceedings of the 12th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107. </pages> <publisher> ACM Press, </publisher> <year> 1985. </year>
Reference-contexts: In the untimed case, the system is modeled by its state-transition graph, and the specification may be presented either as a branching-time formula [CES86] or as a linear- time formula <ref> [LP85, SC85] </ref>. In the discrete-time case, the untimed model-checking algorithms can 27 be extended to real-time logics using a special tick transition [EMSS90, AH93, AH94]. In the continuous-time case, model-checking algorithms are known for branching-time specifications of timed automata [ACD93].
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <month> 29 </month>
Reference-contexts: We usually suppress the interval (0; 1) as a subscript. Thus the Mitl-operators 3, 2, and U coincide with the conventional unconstrained strict eventually, strict always, and strict until 4 operators of linear temporal logic <ref> [MP92] </ref>. <p> Note that the unconstrained version 1 W 2 of the unless operator of Mitl differs slightly from the conventional strict unless operator <ref> [MP92] </ref>, which can be defined as 1 W ( 1 ^ 2 ). We can apply the definition of the constrained unless operator to move negations through constrained until operators. <p> Thus the transitions in E simulate the joint execution of the two component automata. 2 3.4 Fairness requirements When verifying reactive systems, we are generally interested only in properties of the fair executions <ref> [MP92] </ref>. For example, for a system with two processes, we may wish to consider only those behaviors in which each process executes infinitely often. While concrete timing can usually replace abstract fairness, we need to consider fair timed automata for solving the satisfiability problem for Mitl.
Reference: [Ost90] <author> J.S. Ostroff. </author> <title> Temporal Logic of Real-time Systems. </title> <publisher> Research Studies Press, </publisher> <year> 1990. </year>
Reference-contexts: Most of these approaches are situated at either extreme of the trade-off between realistic modeling of time and feasible verification of timing properties. Typically, they either use a continuous model of time at the expense of decidability [Koy90, Lew90, ACD93, AD94], or they sacrifice continuity to obtain decision procedures <ref> [JM86, EMSS90, HLP90, Ost90, AH93, AH94] </ref> (for a discussion of this trade-off, see [AH92]). This paper shows how a slight relaxation of the notion of punctuality allows us to combine the best of both worlds. We use a linear or trace semantics for reactive systems.
Reference: [Rog67] <author> H. Rogers, Jr. </author> <title> Theory of Recursive Functions and Effective Computability. </title> <publisher> McGraw-Hill Book Company, </publisher> <year> 1967. </year>
Reference-contexts: is the extension of Mitl that admits singular intervals as subscripts of the until operator. 2 We show that the satisfiability problem for Mitl = is complete for the complexity class 1 1 , which is situated in the analytical hierarchy strictly above all recursively enumerable sets (see, for example, <ref> [Rog67] </ref>). It follows that Mitl = is not recursively axiomatizable. The undecidability result depends on the denseness of the time domain. If the formulas of Mitl = are interpreted over a discrete time domain, the resulting logic Mtl has a decidable satisfiability problem [AH93].
Reference: [SC85] <author> A.P. Sistla and E.M. Clarke. </author> <title> The complexity of propositional linear temporal logics. </title> <journal> Journal of the ACM, </journal> <volume> 32(3) </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference-contexts: The PSPACE upper bound follows, as before, by the observation that the search in the region graph can be performed without explicitly constructing the automaton B fl . The PSPACE-hardness of Mitl 0;1 follows from the PSPACE-hardness of propositional temporal logic with until <ref> [SC85] </ref>. 2 Thus, the complexity of Mitl decreases from EXPSPACE to PSPACE if we prohibit bounded intervals with nonzero left end-points. <p> In the untimed case, the system is modeled by its state-transition graph, and the specification may be presented either as a branching-time formula [CES86] or as a linear- time formula <ref> [LP85, SC85] </ref>. In the discrete-time case, the untimed model-checking algorithms can 27 be extended to real-time logics using a special tick transition [EMSS90, AH93, AH94]. In the continuous-time case, model-checking algorithms are known for branching-time specifications of timed automata [ACD93].
Reference: [Tho90] <author> W. Thomas. </author> <title> Automata on infinite objects. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> volume B, </volume> <pages> pages 133-191. </pages> <publisher> Elsevier Science Publishers (North-Holland), </publisher> <year> 1990. </year> <month> 30 </month>
Reference-contexts: Timed automata generalize nondeterministic finite automata over infinite strings. While !-automata accept infinite state sequences (see, for example, <ref> [Tho90] </ref>), timed automata are additionally constrained by timing requirements and accept timed state sequences. 3.1 Definition of timed automata A timed automaton operates with finite control|a finite set of control locations and a finite set of real-valued clocks.
References-found: 19

