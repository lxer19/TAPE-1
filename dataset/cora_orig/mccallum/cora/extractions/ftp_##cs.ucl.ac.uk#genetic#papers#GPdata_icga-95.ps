URL: ftp://cs.ucl.ac.uk/genetic/papers/GPdata_icga-95.ps
Refering-URL: http://www.cs.bham.ac.uk/~wbl/biblio/gp-bibliography.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email W.Langdon@cs.ucl.ac.uk  
Title: Evolving Data Structures with Genetic Programming them, Pareto selection, "good software engineering practice" and partitioning
Author: William B. Langdon 
Note: ADFs, "pass by reference" when calling  
Address: Gower Street, London, WC1E 6BT, UK  
Affiliation: Computer Science Dept. University College London,  
Abstract: It is established good software engineering practice to ensure that programs use memory via abstract data structures such as stacks, queues and lists. These provide an interface between the program and memory, freeing the program of memory management details which are left to the data structures to implement. The main result presented herein is that GP can automatically generate stacks and queues. Typically abstract data structures support multiple operations, such as put and get. We show that GP can simultaneously evolve all the operations of a data structure by implementing each such operation with its own independent program tree. That is, the chromosome consists of a fixed number of independent program trees. Moreover, crossover only mixes genetic material of program trees that implement the same operation. Program trees interact with each other only via shared memory and shared "Automatically Defined Functions" (ADFs). 
Abstract-found: 1
Intro-found: 1
Reference: [AHU87] <author> A V Aho, J E Hopcroft, and J D Ullman. </author> <title> Data Structures and Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Partitioning the genetic population into "demes" appears to mitigate against premature convergence (Section 3.7.4). 2 EVOLVING A STACK 2.1 PROBLEM STATEMENT Our definition of a stack is given in Table 1. Whilst based upon Aho et al <ref> [AHU87] </ref>, it has been simplified by removing the checks for stack underflow or overflow and "pop" returns the current top of the stack as well as removing it. <p> Section 3.7 shows that such primitives need not be given but can be evolved by the GP whilst it solves the queue problem, however considerably more trial solutions needed to be tested. 3.1 PROBLEM STATEMENT Our definition of a queue is again based upon that given by Aho et al <ref> [AHU87] </ref>. As with the stack there are five operations: makenull, front, dequeue, enqueue and empty. We simplify the problem as before, so the queue problem is very close to the stack with the replacement of front for top, dequeue for pop and en-queue for push.
Reference: [Col92] <author> Robert J. Collins. </author> <title> Studies in Artificial Evolution. </title> <type> PhD thesis, </type> <institution> Artificial Life Laboratory, Department of Computer Science, UCLA, </institution> <year> 1992. </year>
Reference-contexts: Each grid point contains a single individual and is the center of a 3 fi 3 square deme <ref> [Col92] </ref>. When a new individual is created, its parent (s) are selected from the same deme as the individual it replaces. Tournament selection is used, as before, however the four candidates are chosen (at random with reselec-tion) from the same deme rather than from the whole population.
Reference: [Gol89] <author> David E. Goldberg. </author> <title> Genetic Algorithms in Search Optimization and Machine Learning. </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The ADF adf1 continues to return the value as before. 3.7.2 Pareto Fitness Comparison There was some evidence that the fitness function favored evolution of one operation (empty) above the others. Various ways of weighting the fitness where considered, but Pareto optimality <ref> [Gol89, page 197] </ref> offered a way of comparing programs without introducing an arbitrary means of combining all their operations into a single fitness. Therefore it was decided to use Pareto fitness rather than explore increasingly complex fitness scoring schemes.
Reference: [Koz92] <author> John R. Koza. </author> <title> Genetic Programming: On the Programming of Computers by Natural Selection. </title> <publisher> MIT press, </publisher> <year> 1992. </year>
Reference-contexts: We anticipate that if evolutionary computation is to solve many difficult problems it must adopt a structured approach, particularly in its use of memory. We demonstrate how GP can automatically generate two abstract data structures, stacks and queues. The GA we use is based on Koza's GP <ref> [Koz92] </ref>, but each individual within the population comprises several program trees, one for each operation (see Figures 2 and 3). These trees are independent, with crossover occurring only between like trees. Each interacts with the others via shared memory or shared "Automatically Defined Functions" ADF [Koz94]. <p> The trees of the other types are copied without modification from the first parent to the offspring. The remaining tree is created by crossover between the trees of the chosen type in each parent in the normal GP way <ref> [Koz92] </ref>. The new tree has the same root as the first parent. Each mating produces a single offspring, most of whose genetic material comes from only one of its parents. <p> From P (M; i) the number of runs required to obtain at least one stack can be calculated. Using the formula in <ref> [Koz92, page 194] </ref>, estimating P (1000; 14) at 4=60 (i.e. 4 successes in 60 trials) and requiring the chance of not finding any stacks to be less than 1% gives 67 runs.
Reference: [Koz94] <author> John R. Koza. </author> <title> Genetic Programming II Automatic Discovery of Reusable Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge Massachusetts, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: These trees are independent, with crossover occurring only between like trees. Each interacts with the others via shared memory or shared "Automatically Defined Functions" ADF <ref> [Koz94] </ref>. We show it is possible for this GA to simultaneously evolve multiple co-operating but independent functions. In the following sections we describe our experiments which show that both an integer stack (Section 2) and a First-In First-Out (FIFO) integer queue (Section 3) can be evolved. <p> Crossing like trees with like trees is similar to the crossover operator used by Koza in most of his experiments involving ADFs <ref> [Koz94] </ref>. GP creates each tree from terminals (leafs) and functions (branch nodes). Collectively these are called primitives. Initially, for simplicity, the same primitives were available to each tree. However "good software engineering practice" suggests a number of rules that might help the GP. <p> All storage, i.e. the indexed memory and aux, is initialized to zero before each test sequence is started. Nb. no information about the program's internal be-haviour is used. 2.5 PARAMETERS The parameters used where those those established by Koza <ref> [Koz94, page 655] </ref> except GP-QUICK [Sin94] uses: a steady state GA; a single offspring per crossover. The default tournament size of 4 appears to give sufficient selection pressure, however the default program size limit was increased five fold, to 250, in order to allow ready growth of all five trees.
Reference: [Sin94] <author> Andy Singleton. </author> <title> Genetic Programming with C++. </title> <journal> BYTE, </journal> <month> February </month> <year> 1994. </year>
Reference-contexts: All storage, i.e. the indexed memory and aux, is initialized to zero before each test sequence is started. Nb. no information about the program's internal be-haviour is used. 2.5 PARAMETERS The parameters used where those those established by Koza [Koz94, page 655] except GP-QUICK <ref> [Sin94] </ref> uses: a steady state GA; a single offspring per crossover. The default tournament size of 4 appears to give sufficient selection pressure, however the default program size limit was increased five fold, to 250, in order to allow ready growth of all five trees.
Reference: [Tel94a] <author> Astro Teller. </author> <title> The evolution of mental models. </title> <editor> In Kenneth E. Kinnear, Jr., editor, </editor> <booktitle> Advances in Genetic Programming, chapter 9. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 INTRODUCTION Recent work by Teller <ref> [Tel94a] </ref> shows genetic programming can automatically create programs which explicitly use memory. He has shown that inclusion of read and write primitives can make the GP language Turing complete, i.e. any conventional program can be written in the language [Tel94b]. <p> They are based on Teller's <ref> [Tel94a] </ref>, however access to memory outside the range -31: : : 31 aborts the program. An aborted program fails the current test and is not tested further but keeps its current score.
Reference: [Tel94b] <author> Astro Teller. </author> <title> Turing completeness in the language of genetic programming with indexed memory. </title> <booktitle> IEEE World Congress on Computational Intelligence, </booktitle> <year> 1994. </year>
Reference-contexts: 1 INTRODUCTION Recent work by Teller [Tel94a] shows genetic programming can automatically create programs which explicitly use memory. He has shown that inclusion of read and write primitives can make the GP language Turing complete, i.e. any conventional program can be written in the language <ref> [Tel94b] </ref>. However it is still an open problem as to which subclass of programs can be effectively evolved. Human programmers have long recognised, that in addition to Turing completeness, programming languages should encourage programs to be structured.
References-found: 8

