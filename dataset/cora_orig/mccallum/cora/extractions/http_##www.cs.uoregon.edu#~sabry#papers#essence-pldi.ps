URL: http://www.cs.uoregon.edu/~sabry/papers/essence-pldi.ps
Refering-URL: http://www.cs.uoregon.edu/~sabry/papers/index.html
Root-URL: http://www.cs.uoregon.edu
Title: The Essence of Compiling with Continuations  
Author: Cormac Flanagan Amr Sabry Bruce F. Duba Matthias Felleisen 
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: In order to simplify the compilation process, many compilers for higher-order languages use the continuation-passing style (CPS) transformation in a first phase to generate an intermediate representation of the source program. The salient aspect of this intermediate form is that all procedures take an argument that represents the rest of the computation (the "continuation"). Since the nave CPS transformation considerably increases the size of programs, CPS compilers perform reductions to produce a more compact intermediate representation. Although often implemented as a part of the CPS transformation, this step is conceptually a second phase. Finally, code generators for typical CPS compilers treat continuations specially in order to optimize the interpretation of continuation parameters. A thorough analysis of the abstract machine for CPS terms shows that the actions of the code generator invert the nave CPS translation step. Put differently, the combined effect of the three phases is equivalent to a source-to-source transformation that simulates the compaction phase. Thus, fully developed CPS compilers do not need to employ the CPS transformation but can achieve the same results with a simple source-level transformation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aho, A., Sethi, R., and Ullman, J. Compilers|Principles, </author> <title> Techniques, and Tools. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1985. </year>
Reference-contexts: The semantics of the language is a partial function from programs to answers. A program is a term with no free variables and an answer is a member of the syntactic category of constants. Following conventional tradition <ref> [1] </ref>, we specify the operational semantics of Core Scheme with an abstract machine.
Reference: [2] <author> Appel, A. </author> <title> Compiling with Continuations. </title> <publisher> Cam-bridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Compiling with Continuations A number of prominent compilers for applicative higher-order programming languages use the language of fl Supported in part by NSF grants CCR 89-17022 and CCR 91-22518 and Texas ATP grant 91-003604014. 0 continuation-passing style (CPS) terms as their intermediate representation for programs <ref> [2, 14, 18, 19] </ref>. This strategy apparently offers two major advantages. <p> Translated into practice, a compiler can perform more transformations on the intermediate language than on the source language [2:4-5]. Second, the language of CPS terms is basically a stylized assembly language, for which it is easy to generate actual assembly programs for different machines <ref> [2, 13, 20] </ref>. In short, the CPS transformation provides an organizational principle that simplifies the construction of compilers. <p> The function F [12] in Figure 3 is the basis of CPS transformations used in various compilers <ref> [2, 14, 19] </ref>. It uses special -expressions or continuations to encode the rest of the computation, thus shifting the burden of main taining control information from the abstract machine to the code. The notation (x: ) marks the admin istrative -expressions introduced by the CPS transfor mation. <p> The rest of our technical development can be adapted mutatis mutandis. W ::= c j x j (kx 1 : : : x n :P ) (values) Indeed, this language is typical of the intermediate representation used by CPS compilers <ref> [2, 14, 19] </ref>. Nave CPS Compilers The abstract machine that characterizes the code generator of a nave CPS compiler is the C cps E machine. <p> This "optimization" eliminates "some of the register shu*ing" [19:94] during the evaluation of the term. Appel <ref> [2] </ref> achieves the same effect without modifying the CPS transformation by letting the variables k 1 and k 2 share the same register during the procedure call. <p> For example, CPS compilers can transform the non-tail call (W (x:kx) W 1 : : : W n ) to the tail-recursive call (W k W 1 : : : W n ) using an -reduction on the continuation <ref> [2] </ref>.
Reference: [3] <author> Barendregt, H. </author> <title> The Lambda Calculus: Its Syntax and Semantics, revised ed. </title> <booktitle> Studies in Logic and the Foundations of Mathematics 103. </booktitle> <publisher> North-Holland, </publisher> <year> 1984. </year>
Reference: [4] <author> Boehm, H.-J., and Demers, A. </author> <title> Implementing Russel. </title> <booktitle> In Proceedings of the ACM SIG-PLAN 1986 Symposium on Compiler Construction (1986), </booktitle> <volume> vol. 21(7), </volume> <booktitle> Sigplan Notices, </booktitle> <pages> pp. 186-195. </pages>
Reference-contexts: We base our argument on a formal development of the abstract machine for the intermediate code of a CPS-based compiler. The development shows that this machine is 1 Personal communication: H. Boehm (also <ref> [4] </ref>), K. Dybvig, R. Hieb (April 92).
Reference: [5] <author> Bondorf, A. </author> <title> Improving binding times without explicit CPS-conversion. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming (1992), </booktitle> <pages> pp. 1-10. </pages>
Reference-contexts: Every other optimization on CPS terms that corresponds to a sequence of fi-reductions is also expressible on A-normal form terms [17]. The A-reductions also expose optimization opportunities by merging code segments across block declarations and conditionals. In particular, partial evaluators rely on the A-reductions to improve their specialization phase <ref> [5] </ref>. For example, the addition operation and the constant 0 are apparently unrelated in the following term: (add1 (let (x (f 5)) 0)) The A-normalization phase produces: (let (x (f 5)) (add1 0)), which specializes to (let (x (f 5)) 1).
Reference: [6] <author> Clinger, W. </author> <title> The Scheme 311 compiler: An exercise in denotational semantics. </title> <booktitle> In Proceedings of the 1984 ACM Conference on Lisp and Functional Programming (1984), </booktitle> <pages> pp. 356-364. </pages>
Reference-contexts: The partial function ffi abstracts the semantics of the primitive operations. The CEK machine provides a model for designing direct compilers <ref> [6, 11, 15] </ref>. A compiler based on the CEK machine implements an efficient representation for en vironments, e.g., displays, and for continuations, e.g., a stack. 3 The machine code produced by such a compiler 3 The machine also characterizes compilers for first-order languages, e.g., Fortran.
Reference: [7] <author> Danvy, O. </author> <title> Back to direct style. </title> <booktitle> In Proceedings of the 4th European Symposium on Programming (Rennes, 1992), Lecture Notes in Computer Science, </booktitle> <volume> 582, </volume> <publisher> Springer Verlag, </publisher> <pages> pp. 130-150. </pages>
Reference-contexts: Undoing CPS The crucial insight is that the elimination of the redundant information from the C cps EK machine corresponds to an inverse CPS transformation <ref> [7, 17] </ref> on the intermediate code. The function U in Figure 6 realizes such an inverse [17]. The in verse transformation formalizes our intuition about the redundancies in the C cps EK machine. It eliminates the variable k from return instructions as well as the parameter k from procedures.
Reference: [8] <author> Danvy, O. </author> <title> Three steps for the CPS transformation. </title> <type> Tech. Rep. </type> <institution> CIS-92-2, Kansas State University, </institution> <year> 1992. </year>
Reference-contexts: The definition of the A-reductions refers to the concept of evaluation contexts. An evaluation context is a term with a "hole" (denoted by [ ]) in the place of one subterm. The location of the hole points to the next 6 Danvy <ref> [8] </ref> and Weise [21] also recognize that the compaction of CPS terms can be expressed in the source language, but do not explore this topic systematically.

Reference: [10] <author> Felleisen, M., and Friedman, D. </author> <title> Control operators, the SECD-machine, and the -calculus. </title> <booktitle> In Formal Description of Programming Concepts III (Amsterdam, </booktitle> <year> 1986), </year> <editor> M. Wirsing, Ed., </editor> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <pages> pp. 193-217. </pages>
Reference-contexts: A program is a term with no free variables and an answer is a member of the syntactic category of constants. Following conventional tradition [1], we specify the operational semantics of Core Scheme with an abstract machine. The machine we use, the CEK machine <ref> [10] </ref>, has three components: a control string C, an environment E that includes bindings for all free variables in C, and a continuation K that represents the "rest of the computation". The CEK machine changes state according to the transition function in Figure 2.
Reference: [11] <author> Fessenden, C., Clinger, W., Friedman, D. P., and Haynes, C. T. </author> <note> Scheme 311 version 4 reference manual. Computer Science Technical Report 137, </note> <institution> Indiana University, Bloomington, Indi-ana, </institution> <month> Feb. </month> <year> 1983. </year>
Reference-contexts: The partial function ffi abstracts the semantics of the primitive operations. The CEK machine provides a model for designing direct compilers <ref> [6, 11, 15] </ref>. A compiler based on the CEK machine implements an efficient representation for en vironments, e.g., displays, and for continuations, e.g., a stack. 3 The machine code produced by such a compiler 3 The machine also characterizes compilers for first-order languages, e.g., Fortran.
Reference: [12] <author> Fischer, M. </author> <title> Lambda calculus schemata. </title> <booktitle> In Proceedings of the ACM Conference on Proving Assertions About Programs (1972), </booktitle> <volume> vol. 7(1), </volume> <booktitle> Sigplan Notices, </booktitle> <pages> pp. 104-109. </pages>
Reference-contexts: The function F <ref> [12] </ref> in Figure 3 is the basis of CPS transformations used in various compilers [2, 14, 19]. It uses special -expressions or continuations to encode the rest of the computation, thus shifting the burden of main taining control information from the abstract machine to the code.
Reference: [13] <author> Kelsey, R., and Hudak, P. </author> <title> Realistic compilation by program transformation. </title> <booktitle> In Conference Record of the 16th Annual ACM Symposium on Principles of Programming Languages (Austin, </booktitle> <address> TX, </address> <month> Jan. </month> <year> 1989), </year> <pages> pp. 281-292. </pages>
Reference-contexts: Translated into practice, a compiler can perform more transformations on the intermediate language than on the source language [2:4-5]. Second, the language of CPS terms is basically a stylized assembly language, for which it is easy to generate actual assembly programs for different machines <ref> [2, 13, 20] </ref>. In short, the CPS transformation provides an organizational principle that simplifies the construction of compilers.
Reference: [14] <author> Kranz, D., Kelsey, R., Rees, J., Hudak, P., Philbin, J., and Adams, N. </author> <title> Orbit: An optimizing compiler for Scheme. </title> <booktitle> In Proceedings of the ACM SIGPLAN 1986 Symposium on Compiler Construction (1986), </booktitle> <volume> vol. 21(7), </volume> <booktitle> Sigplan Notices, </booktitle> <pages> pp. 219-233. </pages>
Reference-contexts: 1 Compiling with Continuations A number of prominent compilers for applicative higher-order programming languages use the language of fl Supported in part by NSF grants CCR 89-17022 and CCR 91-22518 and Texas ATP grant 91-003604014. 0 continuation-passing style (CPS) terms as their intermediate representation for programs <ref> [2, 14, 18, 19] </ref>. This strategy apparently offers two major advantages. <p> The function F [12] in Figure 3 is the basis of CPS transformations used in various compilers <ref> [2, 14, 19] </ref>. It uses special -expressions or continuations to encode the rest of the computation, thus shifting the burden of main taining control information from the abstract machine to the code. The notation (x: ) marks the admin istrative -expressions introduced by the CPS transfor mation. <p> The rest of our technical development can be adapted mutatis mutandis. W ::= c j x j (kx 1 : : : x n :P ) (values) Indeed, this language is typical of the intermediate representation used by CPS compilers <ref> [2, 14, 19] </ref>. Nave CPS Compilers The abstract machine that characterizes the code generator of a nave CPS compiler is the C cps E machine. <p> Yet, realistic CPS compilers "mark" the continuation closure as a special closure. For example, Shivers partitions procedures and continuations in order to improve the data flow analysis of CPS programs [18:sec 3.8.3]. Also, in both Orbit <ref> [14] </ref> and Rabbit [19], the allocation strategy of a closure changes if the closure is a continuation. Similarly, Appel [2:114-124] describes various techniques for closure allocation that treat the continuation closure in a special way.
Reference: [15] <author> Leroy, X. </author> <title> The Zinc experiment: An economical implementation of the ML language. </title> <type> Tech. Rep. 117, </type> <institution> INRIA, </institution> <year> 1990. </year>
Reference-contexts: The partial function ffi abstracts the semantics of the primitive operations. The CEK machine provides a model for designing direct compilers <ref> [6, 11, 15] </ref>. A compiler based on the CEK machine implements an efficient representation for en vironments, e.g., displays, and for continuations, e.g., a stack. 3 The machine code produced by such a compiler 3 The machine also characterizes compilers for first-order languages, e.g., Fortran. <p> Indeed, most direct compilers use transformations similar to the A-reductions on an ad hoc and incomplete basis. It is therefore natural to modify such compilers to perform a complete A-normalization phase, and analyze the effects. We have conducted such an experiment with the non-optimizing, direct compiler CAML Light <ref> [15] </ref>. This compiler translates ML programs into bytecode via a -calculus based intermediate language, and then interprets this bytecode.
Reference: [16] <author> Plotkin, G. </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <booktitle> Theoretical Computer Science 1 (1975), </booktitle> <pages> 125-159. </pages>
Reference-contexts: This strategy apparently offers two major advantages. First, Plotkin <ref> [16] </ref> showed that the -value calculus based on the fi-value rule is an operational semantics for the source language, that the conventional full -calculus is a semantics for the intermediate language, and, most importantly, that the -calculus proves more equations between CPS terms than the v -calculus does between corresponding terms
Reference: [17] <author> Sabry, A., and Felleisen, M. </author> <title> Reasoning about programs in continuation-passing style. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming (1992), </booktitle> <pages> pp. </pages> <month> 288-298. </month> <type> Technical Report 92-180, </type> <institution> Rice University. </institution>
Reference-contexts: To gain a better understanding of the role that the CPS transformation plays in the compilation process, we recently studied the precise connection between the v -calculus for source terms and the -calculus for CPS terms. The result of this research <ref> [17] </ref> was an extended v -calculus that precisely corresponds to the -calculus of the intermediate CPS language and that is still semantically sound for the source language. <p> [[M 1 ]] t 1 : (F [[M n ]] t n :(O 0 k t 1 : : : t n ))) [[x]] = x its optimality, and how it can be combined with F , we refer the reader to Danvy and Filinski [9] and Sabry and Felleisen <ref> [17] </ref>. <p> the administrative redexes in our previous example produces the following fi-normal form term: cps (N ) = (+ 0 (t 1 : (let (x 1) (f (t 2 : (+ 0 k t 1 t 2 )) x ))) The reduction fi is strongly-normalizing on the language of CPS terms <ref> [17] </ref>. Hence, the simplification phase of a CPS compiler can remove all fi-redexes from the output of the translation F . 4 After the simplification phase, we no longer need to distinguish between regular and administrative -expressions, and use the notation (: ) for both classes of -expression. <p> With this convention, the language of fi-normal forms, CPS (CS ), is the following <ref> [17] </ref>: P ::= (k W ) (return) j (let (x W ) P ) (bind ) j (if0 W P 1 P 2 ) (branch) j (W k W 1 : : : W n ) (tail call ) j (W (x:P ) W 1 : : : W n ) <p> Undoing CPS The crucial insight is that the elimination of the redundant information from the C cps EK machine corresponds to an inverse CPS transformation <ref> [7, 17] </ref> on the intermediate code. The function U in Figure 6 realizes such an inverse [17]. The in verse transformation formalizes our intuition about the redundancies in the C cps EK machine. It eliminates the variable k from return instructions as well as the parameter k from procedures. <p> Undoing CPS The crucial insight is that the elimination of the redundant information from the C cps EK machine corresponds to an inverse CPS transformation [7, 17] on the intermediate code. The function U in Figure 6 realizes such an inverse <ref> [17] </ref>. The in verse transformation formalizes our intuition about the redundancies in the C cps EK machine. It eliminates the variable k from return instructions as well as the parameter k from procedures. <p> The identification of the translation A requires a theorem relating fi-reductions on CPS terms to reductions on the source language. This correspondence of reductions was the subject of our previous paper <ref> [17] </ref>. The resulting set of source reductions, the A-reductions, is in Figure 7. 6 Since the A-reductions are strongly normalizing, we can characterize the translation A as any function that applies the A-reductions to a source term until it reaches a normal form [17:Theorem 6.4]. <p> Theorem 5.3 (Commutativity Theorem) Let S 2 State c : S 7! (n) c S 0 if and only if M (S) 7! (n) M (S 0 ). 6 (n) ? 7! a M (S) M (S 0 ) Proof: The inverse CPS transformations U is bijec tive <ref> [17] </ref>. Hence by structural induction, the functions M, R, V and K are also bijective. The proof proceeds by case analysis on the transition rules. <p> For example, CPS compilers can transform the non-tail call (W (x:kx) W 1 : : : W n ) to the tail-recursive call (W k W 1 : : : W n ) using an -reduction on the continuation [2]. An identical transformation <ref> [17] </ref> on the language of A-normal forms is the reduction fi id : (let (x (V V 1 : : : V n )) x) ! (V V 1 : : : V n ); where V; V 1 ; : : : ; V n are the A-normal forms corresponding <p> Every other optimization on CPS terms that corresponds to a sequence of fi-reductions is also expressible on A-normal form terms <ref> [17] </ref>. The A-reductions also expose optimization opportunities by merging code segments across block declarations and conditionals. In particular, partial evaluators rely on the A-reductions to improve their specialization phase [5].
Reference: [18] <author> Shivers, O. </author> <title> Control-Flow Analysis of Higher-Order Languages or Taming Lambda. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1991. </year>
Reference-contexts: 1 Compiling with Continuations A number of prominent compilers for applicative higher-order programming languages use the language of fl Supported in part by NSF grants CCR 89-17022 and CCR 91-22518 and Texas ATP grant 91-003604014. 0 continuation-passing style (CPS) terms as their intermediate representation for programs <ref> [2, 14, 18, 19] </ref>. This strategy apparently offers two major advantages.
Reference: [19] <author> Steele, G. L. RABBIT: </author> <title> A compiler for Scheme. MIT AI Memo 474, </title> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, Mass., </address> <month> May </month> <year> 1978. </year>
Reference-contexts: 1 Compiling with Continuations A number of prominent compilers for applicative higher-order programming languages use the language of fl Supported in part by NSF grants CCR 89-17022 and CCR 91-22518 and Texas ATP grant 91-003604014. 0 continuation-passing style (CPS) terms as their intermediate representation for programs <ref> [2, 14, 18, 19] </ref>. This strategy apparently offers two major advantages. <p> The function F [12] in Figure 3 is the basis of CPS transformations used in various compilers <ref> [2, 14, 19] </ref>. It uses special -expressions or continuations to encode the rest of the computation, thus shifting the burden of main taining control information from the abstract machine to the code. The notation (x: ) marks the admin istrative -expressions introduced by the CPS transfor mation. <p> The rest of our technical development can be adapted mutatis mutandis. W ::= c j x j (kx 1 : : : x n :P ) (values) Indeed, this language is typical of the intermediate representation used by CPS compilers <ref> [2, 14, 19] </ref>. Nave CPS Compilers The abstract machine that characterizes the code generator of a nave CPS compiler is the C cps E machine. <p> Yet, realistic CPS compilers "mark" the continuation closure as a special closure. For example, Shivers partitions procedures and continuations in order to improve the data flow analysis of CPS programs [18:sec 3.8.3]. Also, in both Orbit [14] and Rabbit <ref> [19] </ref>, the allocation strategy of a closure changes if the closure is a continuation. Similarly, Appel [2:114-124] describes various techniques for closure allocation that treat the continuation closure in a special way. <p> In order to reflect these changes in the machine, we tag continuation closures with a special marker "ar" that describes them as activation records. Second, the CPS representation of any user-defined procedure receives a continuation argument. However, Steele <ref> [19] </ref> modifies the CPS transformation with a "continuation variable hack" [19:94] that recognizes instances of CPS terms like ((k 1 :P ) k 2 : : :) and trans Page 4 Semantics: Let P 2 CPS (CS), eval n (P ) = c if hP; ;[k := hcl x; (k x);
Reference: [20] <author> Wand, M. </author> <title> Correctness of procedure representations in higher-order assembly language. </title> <booktitle> In Proceedings of the 1991 Conference on the Mathematical Foundations of Programing Semantics (1992), </booktitle> <editor> S. Brookes, Ed., </editor> <volume> vol. </volume> <booktitle> 598 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pp. 294-311. </pages>
Reference-contexts: Translated into practice, a compiler can perform more transformations on the intermediate language than on the source language [2:4-5]. Second, the language of CPS terms is basically a stylized assembly language, for which it is easy to generate actual assembly programs for different machines <ref> [2, 13, 20] </ref>. In short, the CPS transformation provides an organizational principle that simplifies the construction of compilers.
Reference: [21] <author> Weise, D. </author> <title> Advanced compiling techniques. </title> <institution> Course Notes at Stanford University, </institution> <year> 1990. </year> <pages> Page 11 </pages>
Reference-contexts: The definition of the A-reductions refers to the concept of evaluation contexts. An evaluation context is a term with a "hole" (denoted by [ ]) in the place of one subterm. The location of the hole points to the next 6 Danvy [8] and Weise <ref> [21] </ref> also recognize that the compaction of CPS terms can be expressed in the source language, but do not explore this topic systematically.
References-found: 20

