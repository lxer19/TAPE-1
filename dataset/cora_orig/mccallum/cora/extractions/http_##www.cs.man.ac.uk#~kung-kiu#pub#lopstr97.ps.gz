URL: http://www.cs.man.ac.uk/~kung-kiu/pub/lopstr97.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: e-mail: pf@cs.bilkent.edu.tr  e-mail: kung-kiu@cs.man.ac.uk  e-mail: ornaghi@dsi.unimi.it  
Phone: 2  3  
Title: On Correct Program Schemas  
Author: Pierre Flener, Kung-Kiu Lau and Mario Ornaghi 
Address: 06533 Bilkent, Ankara, Turkey  Manchester, Manchester M13 9PL, United Kingdom  Milano, Via Comelico 39/41, Milano, Italy  
Affiliation: 1 Department of Computer Science Bilkent University,  Department of Computer Science University of  Dipartimento di Scienze dell'Informazione Universita' degli studi di  
Abstract: We present our work on the representation and correctness of program schemas, in the context of logic program synthesis. Whereas most researchers represent schemas purely syntactically as higher-order expressions, we shall express a schema as an open first-order theory that axiomatises a problem domain, called a specification framework, containing an open program that represents the template of the schema. We will show that using our approach we can define a meaningful notion of correctness for schemas, viz. that correct program schemas can be expressed as parametric specification frameworks containing templates that are steadfast, i.e. programs that are always correct provided their open relations are computed correctly. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> D. Barker-Plummer. </author> <title> Cliche Programming in Prolog. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proc. </booktitle> <volume> META 90, </volume> <pages> pages 246-256, </pages> <year> 1992. </year>
Reference: 2. <author> E. Chasseur and Y. Deville. </author> <title> Logic program schemas, semi-unification and constraints. This volume. </title>
Reference: 3. <author> N. Dershowitz. </author> <title> The Evolution of Programs. </title> <publisher> Birkhauser, </publisher> <year> 1983. </year>
Reference: 4. <author> Y. Deville and J. Burnay. </author> <title> Generalization and program schemata: A step towards computer-aided construction of logic programs. </title> <editor> In E.L. Lusk and R.A. Overbeek, editors, </editor> <booktitle> Proc. </booktitle> <pages> NACLP'89 , pages 409-425. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference: 5. <author> Y. Deville. </author> <title> Logic Programming: Systematic Program Development. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: P r is steadfast in F () if it is steadfast in every instance F [G] for a closed framework G. This is similar to Deville's notion of `correctness in a set of specifications' <ref> [5, p.76] </ref>, except that his specifications and programs are not set within frameworks.
Reference: 6. <author> P. Flener. </author> <title> Logic Program Synthesis from Incomplete Information. </title> <publisher> Kluwer, </publisher> <year> 1995. </year>
Reference-contexts: An overview of schemas and their applications can be found in <ref> [6] </ref>. In this paper, we present our work on two aspects of schemas: representation and correctness, in the context of logic program synthesis. <p> So there is no need to invent a new (or higher-order) schema language, at least in a first approximation (but see <ref> [6] </ref>). Formally we define a program schema as follows: Definition 8. (Program Schemas) A (program) schema for a relation r is an open framework S () containing a program P r for r. P r is called the template of S ().
Reference: 7. <author> P. Flener and Y. Deville. </author> <title> Logic program transformation through generalization schemata. </title> <editor> In M. Proietti, editor, </editor> <booktitle> Proc. </booktitle> <pages> LOPSTR'95 , pages 171-173. </pages> <publisher> LNCS 1048, Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Such schemas could also be seen as first-order schemas, in the mathematical sense, namely designating an infinite set of programs that have the form of the schema. The reason why some declare them as higher-order is that they have applications in mind, such as schema-guided program transformation <ref> [7, 28, 11] </ref>, where some form of higher-order matching between actual programs and schemas is convenient to establish applicability of the starting schema of a schematic transformation. Second, Manna [21] advocates first-order schemas, where actual programs are obtained via an interpretation of the (relations and functions of the) schema.
Reference: 8. <author> P. Flener and K.-K. Lau. </author> <title> Program Schemas as Steadfast Programs and their Usage in Deductive Synthesis. </title> <type> Tech Rep BU-CEIS-9705, </type> <institution> Bilkent University, Ankara, Turkey, </institution> <year> 1997. </year>
Reference-contexts: This is thus the "base case" of synthesis, and requires a formalisation of the process of re-use (see [9] for details). Let us illustrate these ideas on the divide-and-conquer schema. In <ref> [8] </ref>, we design the following strategy for it: 1. Select an induction parameter among x and y (such that it is of an inductively defined sort). Suppose, without loss of generality, that x is se lected. 2. Select (or construct) a well-founded order over the sort of the induction parameter.
Reference: 9. <author> P. Flener, K.-K. Lau, and M. Ornaghi, </author> <title> Correct-schema-guided Synthesis of Steadfast Programs, </title> <booktitle> Proc. 12th IEEE International Automated Software Engineering Conference, </booktitle> <pages> pages 153-160, </pages> <publisher> IEEE Computer Society, </publisher> <year> 1997. </year>
Reference-contexts: We do not discuss this issue here. "more open" programs thus have more "guiding power," especially considering the specifications for their open relations. In <ref> [9] </ref>, we discuss the synthesis of steadfast programs guided by correct schemas. To conclude this paper, in this section we briefly outline the main ideas. Much of the program synthesis process can be pre-computed at the level of "completely open" schemas. <p> Problem reduction stops when a "sufficiently simple" problem is reached, i.e. a specification that "reduces to" another specification for which a program is known and can thus be re-used. This is thus the "base case" of synthesis, and requires a formalisation of the process of re-use (see <ref> [9] </ref> for details). Let us illustrate these ideas on the divide-and-conquer schema. In [8], we design the following strategy for it: 1. Select an induction parameter among x and y (such that it is of an inductively defined sort). Suppose, without loss of generality, that x is se lected. 2. <p> In <ref> [9] </ref>, we synthesise the following extension of the divide-and-conquer tem- plate by using the strategy outlined above: sort (L; S) primitive (L); solve (L; S) sort (L; S) :primitive (L); part (L; h; A; B); sort (A; C); sort (B; D); compose (h; C; D; S) primitive (L) L = nil
Reference: 10. <author> T.S. Gegg-Harrison. </author> <title> Representing logic program schemata in -Prolog. </title> <editor> In L. Sterling, editor, </editor> <booktitle> Proc. </booktitle> <pages> ICLP'95 , pages 467-481. </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: The conditional specification of part can be found in Example 7. 2.4 Program Schemas For representing schemas <ref> [1-6, 10, 14, 16, 21-23, 25-28] </ref>, there are essentially two approaches, depending on the intended schema manipulations. First, most researchers represent their schemas as higher-order expressions, sometimes augmented by extra-logical annotations and features, so that actual programs are obtained by applying higher-order substitutions to the schema.
Reference: 11. <author> T.S. Gegg-Harrison. </author> <title> Extensible Logic Program Schemata. </title> <editor> In J. Gallagher, editor, </editor> <booktitle> Proc. LOPSTR'96, </booktitle> <volume> LNCS 1207, </volume> <pages> pages 256-274, </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Such schemas could also be seen as first-order schemas, in the mathematical sense, namely designating an infinite set of programs that have the form of the schema. The reason why some declare them as higher-order is that they have applications in mind, such as schema-guided program transformation <ref> [7, 28, 11] </ref>, where some form of higher-order matching between actual programs and schemas is convenient to establish applicability of the starting schema of a schematic transformation. Second, Manna [21] advocates first-order schemas, where actual programs are obtained via an interpretation of the (relations and functions of the) schema.
Reference: 12. <author> J.A. Goguen, J.W. Thatcher, and E. Wagner. </author> <title> An initial algebra approach to specification, correctness and implementation. </title> <editor> In R. Yeh, editor, </editor> <booktitle> Current Trends in Programming Methodology, </booktitle> <pages> IV , pages 80-149. </pages> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference: 13. <author> J.A. Goguen and J. Meseguer. </author> <title> Unifying functional, object-oriented and relational programming with logical semantics. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: The freeness axioms for the pre-defined sorts are imported and new axioms are added to define the (new) functions and relations on T . The syntax of a framework F is thus similar to that used in algebraic abstract data types (e.g. <ref> [13, 29, 24] </ref>). However, whilst an algebraic abstract data type is an initial model ([12, 15]) of its specification, the intended model of F is an isoinitial model. Of course, a framework may have no intended (i.e. reachable isoinitial) model.
Reference: 14. <author> A. Hamfelt and J. Fischer-Nilsson. </author> <title> Inductive metalogic programming. </title> <editor> In S. Wro-bel, editor, </editor> <booktitle> Proc. </booktitle> <pages> ILP'94 , pages 85-96. </pages> <address> GMD-Studien Nr. 237, Sankt Augustin, Germany, </address> <year> 1994. </year>
Reference-contexts: The conditional specification of part can be found in Example 7. 2.4 Program Schemas For representing schemas <ref> [1-6, 10, 14, 16, 21-23, 25-28] </ref>, there are essentially two approaches, depending on the intended schema manipulations. First, most researchers represent their schemas as higher-order expressions, sometimes augmented by extra-logical annotations and features, so that actual programs are obtained by applying higher-order substitutions to the schema.
Reference: 15. <author> W. Hodges. </author> <title> Logical features of Horn clauses. In D.M. </title> <editor> Gabbay, C.J. Hogger, and J.A. Robinson, editors, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming, Volume 1: Logical Foundations, </booktitle> <pages> pages 449-503, </pages> <publisher> Oxford University Press, </publisher> <year> 1993. </year>
Reference: 16. <author> A.-L. Johansson. </author> <title> Interactive program derivation using program schemata and incrementally generated strategies. </title> <editor> In Y. Deville, editor, </editor> <booktitle> Proc. </booktitle> <pages> LOPSTR'93 , pages 100-112. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The conditional specification of part can be found in Example 7. 2.4 Program Schemas For representing schemas <ref> [1-6, 10, 14, 16, 21-23, 25-28] </ref>, there are essentially two approaches, depending on the intended schema manipulations. First, most researchers represent their schemas as higher-order expressions, sometimes augmented by extra-logical annotations and features, so that actual programs are obtained by applying higher-order substitutions to the schema.
Reference: 17. <author> K.-K. Lau and M. Ornaghi. </author> <title> Forms of logic specifications: A preliminary study. </title> <editor> In J. Gallagher, editor, </editor> <booktitle> Proc. LOPSTR'96, </booktitle> <pages> pages 295-312, </pages> <publisher> LNCS 1207, Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: We say that S ffi is strict if it defines just one expansion; it is non-strict if it defines more than one expansion. A more detailed discussion and classification of specifications can be found in <ref> [17] </ref>.
Reference: 18. <author> K.-K. Lau, M. Ornaghi, and S.- A. </author> <title> Tarnlund. The halting problem for deductive synthesis of logic programs. </title> <editor> In P. van Hentenryck, editor, </editor> <booktitle> Proc. </booktitle> <pages> ICLP'94 , pages 665-683. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference: 19. <author> K.-K. Lau, M. Ornaghi, and S.- A. </author> <title> Tarnlund. Steadfast logic programs. </title> <journal> J. Logic Programming, </journal> <note> submitted. </note>
Reference-contexts: A divide-and-conquer schema. 3 Correct Schemas A model-theoretic definition of correctness of open programs in a framework, called steadfastness, is given in <ref> [19] </ref>. Here, we give a less abstract, but more conventional definition. In this paper, for simplicity, we only give definitions and results that work for definite programs. Nevertheless they extend to normal programs, under suitable termination assumptions. <p> See <ref> [19] </ref>. We have to prove that F [(9) ` T r . Let us try to prove the first clause.
Reference: 20. <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1987. </year>
Reference-contexts: (we will omit the most external 8 quantifiers): Specification Framework NAT ; sorts: N at; functions: 0 : ! N at; s : N at ! N at; axioms: c-axs (0; s); x + 0 = x; x fl 0 = 0; c-axs (0; s) contains Clark's Equality Theory (see <ref> [20] </ref>) for the constructors 0 and s, and the related (first-order) induction schema H (0) ^ (8i : H (i) ! H (s (i)) ! 8x : H (x), where H stands for any formula of the language, i.e. the schema represents an infinite set of first-order axioms. <p> ! nocc (a; b L) = nocc (a; L) + 1; :a = b ! nocc (a; b L) = nocc (a; L); p-axioms: x y ^ y x $ x = y; x y ^ y z ! x z; where c-axs (nil; ) contains Clark's Equality Theory (see <ref> [20] </ref>) for the list constructors and nil, and the first-order induction schema H (nil)^(8a; J : H (J ) ! H (a J )) ! 8L : H (L); the function nocc (a; L) gives the number of occurrences of a in L, and elemi (L; i; a) means a occurs
Reference: 21. <author> Z. Manna. </author> <title> Mathematical Theory of Computation. </title> <publisher> McGraw-Hill, </publisher> <year> 1974. </year>
Reference-contexts: The reason why some declare them as higher-order is that they have applications in mind, such as schema-guided program transformation [7, 28, 11], where some form of higher-order matching between actual programs and schemas is convenient to establish applicability of the starting schema of a schematic transformation. Second, Manna <ref> [21] </ref> advocates first-order schemas, where actual programs are obtained via an interpretation of the (relations and functions of the) schema.
Reference: 22. <author> E. Marakakis and J.P. Gallagher. </author> <title> Schema-based top-down design of logic programs using abstract data types. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. </booktitle> <pages> LOP-STR/META'94 , pages 138-153, </pages> <publisher> LNCS 883, Springer-Verlag, </publisher> <year> 1994. </year>
Reference: 23. <author> J. Richardson and N. Fuchs. </author> <title> Development of correct transformational schemata for Prolog programs. This volume. </title>
Reference: 24. <author> D. Sannella and A. Tarlecki. </author> <title> Essential concepts of algebraic specification and program development. </title> <booktitle> Formal Aspects of Computer Science, </booktitle> <publisher> forthcoming. </publisher>
Reference-contexts: The freeness axioms for the pre-defined sorts are imported and new axioms are added to define the (new) functions and relations on T . The syntax of a framework F is thus similar to that used in algebraic abstract data types (e.g. <ref> [13, 29, 24] </ref>). However, whilst an algebraic abstract data type is an initial model ([12, 15]) of its specification, the intended model of F is an isoinitial model. Of course, a framework may have no intended (i.e. reachable isoinitial) model.
Reference: 25. <author> D.R. Smith. </author> <title> Top-down synthesis of divide-and-conquer algorithms. </title> <booktitle> Artificial Intelligence 27(1) </booktitle> <pages> 43-96, </pages> <year> 1985. </year>
Reference-contexts: Most definitions of schemas, with the laudable exception of the one by Smith <ref> [25, 26] </ref>, reduce this concept to what we here call the template. Such definitions are thus merely syntactic, providing only a pattern of place-holders, with no concern about the semantics of the template, the semantics of the programs it covers, or the interactions between these place-holders. <p> The above abduction process proves the following theorem: Theorem 1. (Correctness of the divide-and-conquer schema) The schema DC in Example 5, with the addition of the termination requirement (7), is correct, i.e. it contains a steadfast template. This theorem is related to the one given by Smith <ref> [25] </ref> for a divide-and-conquer schema in functional programming. The innovations here are that we use specification frameworks and that we can thus also consider open programs. Moreover, we could also prove total correctness (and not just partial correctness as we have done here), because we are in a relational setting. <p> An arbitrary instantiation (through program extension), according to the informal semantics of the template, of one (or several) of its open relations may then provide a "jump-start", as the set of equations may then become solvable. This leads us to the notion of synthesis strategy (cf. Smith's work <ref> [25] </ref>), as a pre-computed (finite) sequence of synthesis steps, for a given schema. A strategy has two phases, stating (i) which parameter (s) to arbitrarily instantiate first (by re-use), and (ii) which specifications to "set up" next, based on a pre-computed propagation of these instantiation (s). <p> Once correct programs have been synthesised from these new specifications (using the synthesiser all over again, of course), they can be composed into a correct program for the original specified relation, according to the template. There can be several strategies for a given schema (e.g., Smith <ref> [25] </ref> gives three strategies for a divide-and-conquer schema), depending on which parameter (s) are instantiated first (e.g., decompose first, or compose first, or both at the same time). <p> These aspects of schema-guided synthesis are our new contribution. Our work is very strongly influenced by Smith's pioneering work <ref> [25] </ref> in functional programming in the early 1980s. This is, in our opinion, inevitable, as this approach seems to be the only structured approach to synthesis.
Reference: 26. <author> D.R. Smith. KIDS: </author> <title> A semiautomatic program development system. </title> <journal> IEEE Trans. Software Engineering 16(9) </journal> <pages> 1024-1043, </pages> <year> 1990. </year>
Reference-contexts: Most definitions of schemas, with the laudable exception of the one by Smith <ref> [25, 26] </ref>, reduce this concept to what we here call the template. Such definitions are thus merely syntactic, providing only a pattern of place-holders, with no concern about the semantics of the template, the semantics of the programs it covers, or the interactions between these place-holders.
Reference: 27. <author> L.S. Sterling and M. Kirschenbaum. </author> <title> Applying techniques to skeletons. </title> <editor> In J.- M. Jacquet, editor, </editor> <booktitle> Constructing Logic Programs, </booktitle> <pages> pages 127-140. </pages> <publisher> John Wiley, </publisher> <year> 1993. </year>
Reference: 28. <author> W.W. Vasconcelos and N.E. Fuchs. </author> <title> An opportunistic approach for logic program analysis and optimisation using enhanced schema-based transformations. </title> <editor> In M. Proietti, editor, </editor> <booktitle> Proc. </booktitle> <pages> LOPSTR'95 , pages 174-188. </pages> <publisher> LNCS 1048, Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Such schemas could also be seen as first-order schemas, in the mathematical sense, namely designating an infinite set of programs that have the form of the schema. The reason why some declare them as higher-order is that they have applications in mind, such as schema-guided program transformation <ref> [7, 28, 11] </ref>, where some form of higher-order matching between actual programs and schemas is convenient to establish applicability of the starting schema of a schematic transformation. Second, Manna [21] advocates first-order schemas, where actual programs are obtained via an interpretation of the (relations and functions of the) schema.
Reference: 29. <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: The freeness axioms for the pre-defined sorts are imported and new axioms are added to define the (new) functions and relations on T . The syntax of a framework F is thus similar to that used in algebraic abstract data types (e.g. <ref> [13, 29, 24] </ref>). However, whilst an algebraic abstract data type is an initial model ([12, 15]) of its specification, the intended model of F is an isoinitial model. Of course, a framework may have no intended (i.e. reachable isoinitial) model.
References-found: 29

