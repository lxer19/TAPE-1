URL: http://www.cs.wisc.edu/wpis/papers/pepm95a.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Semantic Foundations of Binding-Time Analysis for Imperative Programs  
Author: Manuvir Das, Thomas Reps, and Pascal Van Hentenryck 
Affiliation: 1: University of Wisconsin-Madison; 2: Brown University  
Abstract: This paper examines the role of dependence analysis in defining binding-time analyses (BTAs) for imperative programs and in establishing that such BTAs are safe. In particular, we are concerned with characterizing safety conditions under which a program specializer that uses the results of a BTA is guaranteed to terminate. Our safety conditions are formalized via semantic characterizations of the statements in a program along two dimensions: static versus dynamic, and finite versus infinite. This permits us to give a semantic definition of static-infinite computation, a concept that has not been previously formalized. To illustrate the concepts, we present three different BTAs for an imperative language; we show that two of them are safe in the absence of static-infinite computations. In developing these notions, we make use of program representation graphs, which are a program representation similar to the dependence graphs used in parallelizing and vectorizing compilers. In operational terms, our BTAs are related to the operation of program slicing, which can be implemented using such graphs. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Alpern, B., Wegman, M.N., and Zadeck, F.K., </author> <title> Detecting equality of variables in programs, pp. </title> <booktitle> 1-11 in Conference Record of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1988). </address>
Reference-contexts: The value-sequence semantics is defined in terms of the program's program representation graph (PRG) [16], which is a form of the program dependence graph used in vectorizing and parallelizing compilers [3] extended with some of the features of static single-assignment form <ref> [1] </ref>. Rather than treating each program point as a state-to-state transformer, the value-sequence semantics treats each program point as a value-sequence transformer that takes (possibly infinite) argument sequences from dependence predecessors to a (possibly infinite) output sequence, which represents the sequence of values computed at that point during program execution.
Reference: 2. <author> Denning, D.E. and Denning, P.J., </author> <title> Certification of programs for secure information flow, </title> <journal> Commun. of the ACM 20(7) pp. </journal> <month> 504-513 (July </month> <year> 1977). </year>
Reference-contexts: Control dependences were introduced by Denning and Denning to formalize the notion of information flow in programs in the context of computer-security issues <ref> [2] </ref>.
Reference: 3. <author> Ferrante, J., Ottenstein, K., and Warren, J., </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 9(3) pp. </pages> <month> 319-349 (July </month> <year> 1987). </year>
Reference-contexts: The value-sequence semantics is defined in terms of the program's program representation graph (PRG) [16], which is a form of the program dependence graph used in vectorizing and parallelizing compilers <ref> [3] </ref> extended with some of the features of static single-assignment form [1]. <p> V (G) includes a unique Entry vertex, zero or more Initialize vertices, and vertices that represent the statements and predicates of the program. E (G) consists of data and control dependence edges defined in the usual manner <ref> [3] </ref>, 1 except that in cases where multiple definitions of a variable reach the same use, V (G) is augmented with f vertices that "mediate" between the different definition points. <p> Control dependences were introduced by Denning and Denning to formalize the notion of information flow in programs in the context of computer-security issues [2]. Since then, they have played a fundamental role in vectorizing and parallelizing compilers (for instance, see <ref> [3] </ref>.) The possibility of using control dependences during binding-time analysis was hinted at by Jones in a remark about indirect dependences caused by predicates of conditional statements [6, pp. 260], but this direction was not pursued.
Reference: 4. <author> Holst, C.K., </author> <title> Finiteness analysis, pp. </title> <booktitle> 473-495 in Functional Programming and Computer Architecture, Fifth ACM Conference, </booktitle> <address> (Cambridge, MA, </address> <month> Aug. </month> <pages> 26-30, </pages> <year> 1991), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 523, </volume> <editor> ed. J.Hughes,Springer-Verlag, </editor> <address> New York, NY (1991). </address>
Reference-contexts: Although this problem has been addressed via the termination analyses of Holst <ref> [4] </ref> and Jones et al. [7, Chapter 14], the methods developed are targeted for data domains that are bounded (i.e., data domains for which there is an ordering on values such that, for each value v, there is a finite number of values less than v). <p> However, his analysis loses some precision as a result. Furthermore, he omits any discussion of termination by assuming that the program terminates for all inputs, which is a stronger restriction than absence of static-infinite computation, the condition required for the results of our analyses to be used safely. In <ref> [4] </ref>, Holst uses the notion of in-situ increasing and decreasing parameters to argue about termination of specialization, and hence eliminates the need for any finiteness condition on programs.
Reference: 5. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 12(1) pp. </pages> <month> 26-60 (January </month> <year> 1990). </year>
Reference-contexts: All three BTAs can be viewed operationally as variants of operations for program slicing [15] and consequently can be performed as straightforward (and efficient) reachability operations on the PRG. 5.1. The Strong-Staticness BTA A forward program slice <ref> [5] </ref> from vertex v in the PRG marks all vertices in the PRG that can be reached through dependence edges from v. Operationally, the Strong-Staticness BTA consists of marking with D all vertices in the forward program slice from the set of read vertices in the PRG.
Reference: 6. <author> Jones, </author> <title> N.D., Automatic program specialization: A reexamination from basic principles, pp. 225-282 in Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation, </booktitle> <address> (Gammel Avernaes, Denmark, </address> <month> 18-24 October, </month> <year> 1987), </year> <editor> ed. D. Bjo| rner, A.P. Ershov, </editor> <address> N.D. Jones,North-Holland, New York, NY (1988). </address>
Reference-contexts: 1. Introduction This paper explores the role of dependence analysis in defining binding-time analyses (BTAs) for the two-phase, off-line specialization of imperative programs <ref> [6] </ref> and in establishing that such BTAs are safe. The motivation for this work stems from a well-known danger that arises in such program specializers, namely that the binding-time information obtained in the first phase may cause the second phase of specialization to fall into an infinite loop. <p> The motivation for this work stems from a well-known danger that arises in such program specializers, namely that the binding-time information obtained in the first phase may cause the second phase of specialization to fall into an infinite loop. This problem is illustrated by the following example, adapted from <ref> [6, pp. 265-266] </ref> (see also [13, pp. 501-502], [9, pp. 337], and [7, pp. 299]): P 1 : read (x 1 ); x 2 := 0; w : while ( x 1 0 ) do u: x 1 := x 1 - 1; od At program point v, variable x 1 <p> Authors' addresses: Computer Sciences Department, University of Wisconsin-Madison, 1210 West Dayton St., Madison, WI 53706; Computer Sciences Department, Brown University, 115 Waterman St., Providence, RI 02906. Electronic mail: -manuvir, reps-@cs.wisc.edu, pvh@cs.brown.edu. congruent divisions in the terminology of <ref> [6] </ref>. The BTAs given by Jones, Sestoft, and Mogensen would label x 2 static. <p> Since then, they have played a fundamental role in vectorizing and parallelizing compilers (for instance, see [3].) The possibility of using control dependences during binding-time analysis was hinted at by Jones in a remark about indirect dependences caused by predicates of conditional statements <ref> [6, pp. 260] </ref>, but this direction was not pursued. In [7], Jones et al. informally present the notions of oblivious and weakly oblivious programs (in contrast with unoblivious programs), a distinction based on whether a program involves tests on dynamic data. <p> With the value-sequence semantics, we identify program points as being static or dynamic, whereas state-oriented semantics have been used to identify which variables are static/dynamic at program points (cf. <ref> [6] </ref>). As we have shown, the value-sequence approach provides a clean way to formalize the notions needed to characterize safety conditions for BTAs, namely, static, dynamic, finite, and infinite. We are not aware of any antecedents of the value-sequence approach in the partial-evaluation literature.
Reference: 7. <author> Jones, N.D., Gomard, C.K., and Sestoft, P., </author> <title> Partial Evaluation and Automatic Program Generation, </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, NJ (1993). </address>
Reference-contexts: This problem is illustrated by the following example, adapted from [6, pp. 265-266] (see also [13, pp. 501-502], [9, pp. 337], and <ref> [7, pp. 299] </ref>): P 1 : read (x 1 ); x 2 := 0; w : while ( x 1 0 ) do u: x 1 := x 1 - 1; od At program point v, variable x 1 should clearly be classified as dynamic; the issue is whether x 2 <p> Although this problem has been addressed via the termination analyses of Holst [4] and Jones et al. <ref> [7, Chapter 14] </ref>, the methods developed are targeted for data domains that are bounded (i.e., data domains for which there is an ordering on values such that, for each value v, there is a finite number of values less than v). <p> This is one indication that some central aspect of the problem has been overlooked. Jones calls the process of classifying a variable occurrence (such as x 2 at v) as dynamic when congruence would allow it to be classified as static a form of generalization <ref> [7] </ref>. Our work takes a different approach: rather than focusing on intensional concepts, such as congruence, we introduce semantic (i.e., extensional) definitions for concepts such as staticness, dynamicness, finiteness, and infiniteness. <p> Note that Definitions 3.1 and 3.2 permit vertices that produce infinitely many different values to be considered static. A third, more general, form of static behaviour that does involve boundedness conditions is bounded static variation <ref> [7, pp. 300] </ref>). <p> Definition 4.1. PRG G is static-infinite iff the following holds: Static (G) Finite (G) . ` In contrast with Jones et al. who give an intensional definition of an infinite static loop as a loop not involving any dynamic tests <ref> [7, pp. 118] </ref>, Definition 4.1 is an extensional definition. Given this formal notion of static-infinite computation, we can now define the notions of safety and conditional safety for binding-time analyses. 4.2. <p> In <ref> [7] </ref>, Jones et al. informally present the notions of oblivious and weakly oblivious programs (in contrast with unoblivious programs), a distinction based on whether a program involves tests on dynamic data.
Reference: 8. <author> Meyer, U., </author> <title> Techniques for partial evaluation of imperative languages, </title> <booktitle> Proceedings of the SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM 91), </booktitle> <address> (New Haven, CT, </address> <month> June 17-19, </month> <year> 1991), </year> <journal> ACM SIGPLAN Notices 26(9) pp. </journal> <month> 94-105 (September </month> <year> 1991). </year>
Reference-contexts: In the context of imperative programs, Meyer presents an approach that uses dynamic annotations rather than a separate BTA phase in order to obtain more efficient residual programs <ref> [8] </ref>. However, his analysis loses some precision as a result. Furthermore, he omits any discussion of termination by assuming that the program terminates for all inputs, which is a stronger restriction than absence of static-infinite computation, the condition required for the results of our analyses to be used safely.
Reference: 9. <author> Mogensen, T., </author> <title> Partially static structures in a self-applicable partial evaluator, pp. 325-347 in Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation, </booktitle> <address> (Gammel Avernaes, Denmark, </address> <month> 18-24 October, </month> <year> 1987), </year> <editor> ed. D. Bjo| rner, A.P. Ershov, </editor> <address> N.D. Jones,North-Holland, New York, NY (1988). </address>
Reference-contexts: This problem is illustrated by the following example, adapted from [6, pp. 265-266] (see also [13, pp. 501-502], <ref> [9, pp. 337] </ref>, and [7, pp. 299]): P 1 : read (x 1 ); x 2 := 0; w : while ( x 1 0 ) do u: x 1 := x 1 - 1; od At program point v, variable x 1 should clearly be classified as dynamic; the issue
Reference: 10. <author> Ottenstein, K.J. and Ottenstein, L.M., </author> <title> The program dependence graph in a software development environment, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> Apr. </month> <pages> 23-25, </pages> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 177-184 (May </month> <year> 1984). </year>
Reference: 11. <author> Ramalingam, G. and Reps, T., </author> <title> Semantics of program representation graphs, </title> <institution> TR-900, Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (December 1989). </note>
Reference-contexts: Furthermore, control dependences that do not affect the actual values computed at the point of dependence can be ignored when tracing dynamic behaviour (see the Weak-Staticness and Bounded-Variation BTAs). g The notion of a static computation and other related concepts can be formalized using a value-sequence-oriented semantics for a program <ref> [11] </ref>, rather than a state-oriented semantics. The value-sequence semantics is defined in terms of the program's program representation graph (PRG) [16], which is a form of the program dependence graph used in vectorizing and parallelizing compilers [3] extended with some of the features of static single-assignment form [1]. <p> Thus, every vertex is a function from its input sequences (the output sequences of its dependence predecessors) to its output sequence. Full details of the semantics of PRGs can be found in <ref> [11] </ref>; in this section, we summarize the relevant concepts. Formally, the PRG semantics is defined in terms of the semantic domains given below: Val = Booleans + Integers + Reals + . . . <p> semantics has been shown to be a prefix of the value sequence associated with the program point in the PRG semantics. (Roughly, value sequences transmitted along dependence edges can bypass non-terminating loops.) For inputs on which the program terminates normally, it has been shown that the two sequences are identical <ref> [11] </ref>. As we show in Section 3, the value-sequence approach provides a clean way to formalize the notions needed to characterize safety conditions for BTAs, namely, static, dynamic, finite, and infinite behaviours. 3.
Reference: 12. <author> Schmidt, D., </author> <title> Denotational Semantics, </title> <publisher> Allyn and Bacon, Inc., </publisher> <address> Boston, MA (1986). </address>
Reference-contexts: Sequence is the domain of value sequences described in <ref> [12, pp. 252-266] </ref>, members of which are partially ordered as follows: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh = read ( x 1 ) x 2 := 0 0 x 2 := enter x 2 := ( x 2 ) while x 1 := x 1 - 1 v : x 2 := x 2 + 1
Reference: 13. <author> Sestoft, P., </author> <title> Automatic call unfolding in a partial evaluator, pp. 485-506 in Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation, </booktitle> <address> (Gammel Avernaes, Denmark, </address> <month> 18-24 October, </month> <year> 1987), </year> <editor> ed. D. Bjo| rner, A.P. Ershov, </editor> <address> N.D. Jones,North-Holland, New York, NY (1988). </address>
Reference-contexts: This problem is illustrated by the following example, adapted from [6, pp. 265-266] (see also <ref> [13, pp. 501-502] </ref>, [9, pp. 337], and [7, pp. 299]): P 1 : read (x 1 ); x 2 := 0; w : while ( x 1 0 ) do u: x 1 := x 1 - 1; od At program point v, variable x 1 should clearly be classified as
Reference: 14. <author> Wand, M., </author> <title> Specifying the correctness of binding-time analysis, pp. </title> <booktitle> 137-143 in Conference Record of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Charleston, SC, </address> <month> January 10-13, </month> <year> 1993), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1993). </address>
Reference-contexts: However he deals with data types (lists) that cannot decrease in an unbounded manner as our data types of interest (integers, reals) can. Wand presents a correctness criterion for BTA-based partial evaluation of terms in the pure l-calculus <ref> [14] </ref>. However, it is not clear to us whether the safety issue that we have examined in the present paper arises in the context of Wand's work. A second novelty of our work is the use of a value-sequence-oriented semantics for imperative programs instead of a state-oriented semantics.
Reference: 15. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference-contexts: We use the framework developed in the previous sections to prove the conditional safety of these analyses. All three BTAs can be viewed operationally as variants of operations for program slicing <ref> [15] </ref> and consequently can be performed as straightforward (and efficient) reachability operations on the PRG. 5.1. The Strong-Staticness BTA A forward program slice [5] from vertex v in the PRG marks all vertices in the PRG that can be reached through dependence edges from v.
Reference: 16. <author> Yang, W., Horwitz, S., and Reps, T., </author> <title> A program integration algorithm that accommodates semantics-preserving transformations, </title> <journal> ACM Trans. Software Engineering and Methodology 1(3) pp. </journal> <month> 310-354 (July </month> <year> 1992). </year>
Reference-contexts: The value-sequence semantics is defined in terms of the program's program representation graph (PRG) <ref> [16] </ref>, which is a form of the program dependence graph used in vectorizing and parallelizing compilers [3] extended with some of the features of static single-assignment form [1].
References-found: 16

