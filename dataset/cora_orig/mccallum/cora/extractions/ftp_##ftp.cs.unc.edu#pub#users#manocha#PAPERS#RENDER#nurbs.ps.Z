URL: ftp://ftp.cs.unc.edu/pub/users/manocha/PAPERS/RENDER/nurbs.ps.Z
Refering-URL: http://www.cs.unc.edu/~geom/RENDER/surfacepapers.html
Root-URL: http://www.cs.unc.edu
Email: fkumar,manocha,lastrag@cs.unc.edu  
Title: Interactive Graphics) Interactive Display of Large-Scale NURBS Models  
Author: Subodh Kumar Dinesh Manocha Anselmo Lastra 
Address: Chapel Hill NC 27599  
Affiliation: Department of Computer Science University of North Carolina  
Note: (To appear in the proceedings of the 1995 Symposium on 3D  
Abstract: We present serial and parallel algorithms for interactive rendering of large scale and complex NURBS models on current graphics systems. The algorithms tessellate the NURBS surfaces into triangles and render them using triangle rendering engines. The main characteristics of the algorithms are handling of arbitrary surface topologies, the exploitation of spatial and temporal coherence, optimal polygonization, and back-patch culling. Polygonization anomalies like cracks and angularities are avoided as well. We analyze a number of issues in parallelization of these techniques, as well. The algorithms work well in practice and are able to display models consisting of thousands of surfaces at interactive frame rates. on the highly parallel graphics system, Pixel-Planes 5. 
Abstract-found: 1
Intro-found: 1
Reference: [AES91] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> Tessellation of curved surfaces under highly varying transformations. </title> <booktitle> Proceedings of Eurographics'91, </booktitle> <pages> pages 385-97, </pages> <year> 1991. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, only algorithms based on polygo-nization are capable of real time display. Different methods have been proposed for polygonization <ref> [AES93, ea89, Luk93, SC88, SL87, FK90, RHD89, Roc87, AES91, FMM86] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. [RHD89] have proposed a real time algorithm for trimmed surfaces. <p> Furthermore, the operations used on trimming curves are relatively expensive and affects the performance of the overall algorithm. Some techniques to improve the tessellation and their computations are presented in <ref> [FMM86, AES91, AES93] </ref>. The algorithm presented in this paper has considerable improvements over these algorithms. Organization: The rest of the paper is organized in the following manner. In Section 2 we analyze the problem of computing polygonal approximations to surface models and give an overview of our approach. <p> On such models the uniform tessellation may supersample the surface. The performance of uniform tessellation algorithms is a direct function of the step sizes. 4.1 Uniform Subdivision There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. There are two main criteria for computing bounds for step sizes: size criterion and deviation criterion. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in the object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters <ref> [LR81, FMM86, AES91] </ref>. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds, and the step size as a function of these bounds [Roc87, RHD89]. We start with the size criterion for bound computations. <p> They are used to compute the step sizes as a function of the viewing parameters as shown in [FMM86, AES93]. An algorithm for computation of bounds based on the size criterion has been highlighted in <ref> [AES91] </ref>. However, the derivation of bounds in [AES91] is inaccurate and for a given T OL, our bounds are tighter. We illustrate the derivation on a Bezier curve (it is applied in a similar manner to the surfaces). <p> They are used to compute the step sizes as a function of the viewing parameters as shown in [FMM86, AES93]. An algorithm for computation of bounds based on the size criterion has been highlighted in <ref> [AES91] </ref>. However, the derivation of bounds in [AES91] is inaccurate and for a given T OL, our bounds are tighter. We illustrate the derivation on a Bezier curve (it is applied in a similar manner to the surfaces). Given a rational curve C (t) = (x (t); y (t); z (t); w (t). <p> as (R i1 ; R i2 ; : : : ; R in ) for all 1 i m and take the maximum of n 0 0 v is computed in a similar manner. 4.4 Comparison of Methods We empirically compared our bound with those of Rock-wood [Roc87] and Abi-Ezzi/Shirman <ref> [AES91] </ref>. These comparisons were performed over a number of models and we computed the averages of the number of polygons generated. The average has been taken over seven models and the number of patches varied from 72 to 5354. <p> The degrees of the models were between two and three in u as well as v. For the same tolerance, our bounds result in about 33% fewer triangles than [Roc87] and about 20% fewer than <ref> [AES91] </ref>. Fig. 4 compares the wireframes and shaded images of a pencil using the three methods. 4.5 Frame to Frame Coherence Typically, there is not much change in the position of the model in the object space between successive frames. As 5 Our Algorithm [Roc87] [AES91] 1 1.43 1.22 Table 1: <p> and about 20% fewer than <ref> [AES91] </ref>. Fig. 4 compares the wireframes and shaded images of a pencil using the three methods. 4.5 Frame to Frame Coherence Typically, there is not much change in the position of the model in the object space between successive frames. As 5 Our Algorithm [Roc87] [AES91] 1 1.43 1.22 Table 1: Relative comparison of the number of triangles generated for a given tolerance a result, the bounds for tessellation do not change much between successive frames. In almost all cases the change in n u and n v is small if not zero.
Reference: [AES93] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> The scaling behavior of viewing transformations. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 13(3) </volume> <pages> 48-54, </pages> <year> 1993. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, only algorithms based on polygo-nization are capable of real time display. Different methods have been proposed for polygonization <ref> [AES93, ea89, Luk93, SC88, SL87, FK90, RHD89, Roc87, AES91, FMM86] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. [RHD89] have proposed a real time algorithm for trimmed surfaces. <p> Furthermore, the operations used on trimming curves are relatively expensive and affects the performance of the overall algorithm. Some techniques to improve the tessellation and their computations are presented in <ref> [FMM86, AES91, AES93] </ref>. The algorithm presented in this paper has considerable improvements over these algorithms. Organization: The rest of the paper is organized in the following manner. In Section 2 we analyze the problem of computing polygonal approximations to surface models and give an overview of our approach. <p> They are used to compute the step sizes as a function of the viewing parameters as shown in <ref> [FMM86, AES93] </ref>. An algorithm for computation of bounds based on the size criterion has been highlighted in [AES91]. However, the derivation of bounds in [AES91] is inaccurate and for a given T OL, our bounds are tighter. <p> Given these bounds in the object space, we compute the step size in the screen space as a function of the viewing transformations. These bounds are invariant to rigid body transformations like rotations and translations. They vary with the perspective transformation matrix as shown in <ref> [AES93] </ref>. 4.3 Curvature Bounds For small values of T OL the size criterion bounds, derived above, work very well. In case the surface area is small and (a) Undersampling (b) Curvature Estimation curvature is high, they may undersample the surface.
Reference: [Ake93] <author> K. Akeley. </author> <title> Reality engine graphics. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 109-1116, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Current graphics systems have reached the capability of rendering millions of transformed, shaded and z-buffered polygons per second <ref> [Ake93, Fea89] </ref>. However in many applications involving CAD/CAM, virtual reality, animation and visualization the object models are described in terms of non-uniform rational B-spline (NURBS) surfaces. This class includes Bezier surfaces and other rational parametric surfaces like tensor product and triangular patches. <p> Currently, we are able to render model consisting of seven to eight hundred Bezier patches at 12 16 frames a second. 6.1 Parallel Implementation Pixel-Planes 5 [Fea89] uses extensive parallelism to increase rendering performance. This has become the practice in high-performance graphics accelerators <ref> [Ake93] </ref>. Figure 4 presents a block diagram of the Pixel-Planes 5 system. Front-end geometry processing, such as transformation, clipping, and setup for rasterization, is performed on theGraph-ics Processors (GPs) which contain Intel i860 RISC microprocessors running at 40 MHz, 8 MB of main memory, and communications hardware.
Reference: [Baj90] <author> C.L. Bajaj. </author> <title> Rational hypersurface display. </title> <booktitle> In Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 117-27, </pages> <address> Snowbird, UT, </address> <year> 1990. </year>
Reference: [Ban92] <author> D.C. </author> <title> Banks. Interactive manipulation and display of two-dimensional surfaces in four-dimensional space. </title> <booktitle> In Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 197-207, </pages> <year> 1992. </year>
Reference-contexts: These routines may generate arbitrary geometry in immediate mode for the rendering engine to display. This feature has been used successfully for problems which require close coupling between computation and the generation of geometry <ref> [Ban92] </ref> [TRC + 93]. The tessellation algorithm is implemented as a set of user functions running on the graphics processors. Load balancing is achieved by distributing the individual patches to the GPs in round-robbin order.
Reference: [Cat74] <author> E. Catmull. </author> <title> A subdivision algorithm for computer display of curved surfaces. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1974. </year>
Reference-contexts: On parallel graphics systems, the algorithm minimizes communication between processors, and load balances the work. Previous Work: Curved surface rendering has been an active topic of research for more than two decades. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Cla79, Kaj82, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, only algorithms based on polygo-nization are capable of real time display.
Reference: [Che93] <author> F. Cheng. </author> <title> Computation techniques on nurb surfaces. </title> <booktitle> In SIAM Conference on Geometric Design, </booktitle> <address> Tempe, AZ, </address> <year> 1993. </year>
Reference: [Cla79] <author> J. H. Clark. </author> <title> A fast algorithm for rendering parametric surfaces. </title> <booktitle> Proceedings of ACM Siggraph, </booktitle> <pages> pages 289-99, </pages> <year> 1979. </year>
Reference-contexts: On parallel graphics systems, the algorithm minimizes communication between processors, and load balances the work. Previous Work: Curved surface rendering has been an active topic of research for more than two decades. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Cla79, Kaj82, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, only algorithms based on polygo-nization are capable of real time display.
Reference: [DN93] <author> M.F. Deering and S.R. Nelson. Leo: </author> <title> A system for cost effective 3d shaded graphics. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 101-108, </pages> <year> 1993. </year>
Reference: [ea89] <author> T. Derose et. al. Apex: </author> <title> two architectures for generating parametric curves and surfaces. </title> <journal> The Visual Computer, </journal> <volume> 5 </volume> <pages> 264-276, </pages> <year> 1989. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, only algorithms based on polygo-nization are capable of real time display. Different methods have been proposed for polygonization <ref> [AES93, ea89, Luk93, SC88, SL87, FK90, RHD89, Roc87, AES91, FMM86] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. [RHD89] have proposed a real time algorithm for trimmed surfaces.
Reference: [ea91] <author> R. Bedichek et. al. </author> <title> Rapid low-cost display of spline surfaces. </title> <booktitle> In Proceedings of advanced re-serach in VLSI, </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference: [EGT90] <author> D. Ellsworth, H. Goods, and B. Tebbs. </author> <title> Distributing display lists on a multicomputer. In Symposium on Interactive 3D Graphics, </title> <address> Snow-bird, UT, </address> <year> 1990. </year>
Reference-contexts: Load balancing is achieved by distributing the individual patches to the GPs in round-robbin order. We have found this technique of distributing by primitive to be the best way to maintain good load balancing <ref> [EGT90] </ref>. The algorithm does not require any inter-processor communication during execution. This property not only improves the parallel speedup, but also will make it easier to port the code to another multiprocessor machine.
Reference: [Far90] <author> G. Farin. </author> <title> Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide. </title> <publisher> Academic Press Inc., </publisher> <year> 1990. </year> <month> 8 </month>
Reference-contexts: This is based on intersection determination, coving and tiling and visible cell determination. 2.1 Background Given a NURBS model, we use knot insertion to decompose them into a series of Bezier patches <ref> [Far90] </ref>. In the process, we insert the minimum number of knots as a function of the knot sequence of the original surface and its order. Closely spaced knots, with tolerance less than 2 fi 10 5 are coerced to the same value before knot insertion. <p> A Bezier surface, defined in homogeneous coordinates as F (u; v) = (X (u; v); Y (u; v); Z (u; v); W (u; v)), is specified by a mesh of control points. Furthermore, the entire surface is contained in the convex polytope of the control points <ref> [Far90] </ref>. Let us denote this convex polytope as P F .
Reference: [Fea89] <author> H. Fuchs and J. Poulton et. al. </author> <title> Pixel-planes 5: A heterogeneous multiprocessor graphics system using processor-enhanced memories. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 79-88, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Current graphics systems have reached the capability of rendering millions of transformed, shaded and z-buffered polygons per second <ref> [Ake93, Fea89] </ref>. However in many applications involving CAD/CAM, virtual reality, animation and visualization the object models are described in terms of non-uniform rational B-spline (NURBS) surfaces. This class includes Bezier surfaces and other rational parametric surfaces like tensor product and triangular patches. <p> We have been able to display many complex models in real time using our algorithm. In particular, our current implementation on the SGI-VGX (RS3000) can display about five hundred surfaces and on Pixel-planes 5, <ref> [Fea89] </ref> about ten thousand surfaces at interactive frame rates (about 12 15 frames a second). On parallel graphics systems, the algorithm minimizes communication between processors, and load balances the work. Previous Work: Curved surface rendering has been an active topic of research for more than two decades. <p> Currently, we are able to render model consisting of seven to eight hundred Bezier patches at 12 16 frames a second. 6.1 Parallel Implementation Pixel-Planes 5 <ref> [Fea89] </ref> uses extensive parallelism to increase rendering performance. This has become the practice in high-performance graphics accelerators [Ake93]. Figure 4 presents a block diagram of the Pixel-Planes 5 system. <p> Polygon rasterization, and shading is performed on renderer boards which contain arrays of 128 by 128 1-bit processors with local memory <ref> [Fea89] </ref> and an instruction sequencer. The processing units are connected by a 160 million word per second ring communications network. Since we have access to the graphics processors of Pixel Planes 5, a parallel implementation of the tessellation algorithm seemed natural.
Reference: [FK90] <author> D.R. Forsey and V. Klassen. </author> <title> An adaptive subdivision algorithm for crack prevention in the display of parametric surfaces. </title> <booktitle> Proceedings of Graphics Interface, </booktitle> <pages> pages 1-8, </pages> <year> 1990. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, only algorithms based on polygo-nization are capable of real time display. Different methods have been proposed for polygonization <ref> [AES93, ea89, Luk93, SC88, SL87, FK90, RHD89, Roc87, AES91, FMM86] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. [RHD89] have proposed a real time algorithm for trimmed surfaces.
Reference: [FMM86] <author> D. Filip, R. Magedson, and R. Markot. </author> <title> Surface algorithms using bounds on derivatives. </title> <journal> CAGD, </journal> <volume> 3 </volume> <pages> 295-311, </pages> <year> 1986. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, only algorithms based on polygo-nization are capable of real time display. Different methods have been proposed for polygonization <ref> [AES93, ea89, Luk93, SC88, SL87, FK90, RHD89, Roc87, AES91, FMM86] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. [RHD89] have proposed a real time algorithm for trimmed surfaces. <p> Furthermore, the operations used on trimming curves are relatively expensive and affects the performance of the overall algorithm. Some techniques to improve the tessellation and their computations are presented in <ref> [FMM86, AES91, AES93] </ref>. The algorithm presented in this paper has considerable improvements over these algorithms. Organization: The rest of the paper is organized in the following manner. In Section 2 we analyze the problem of computing polygonal approximations to surface models and give an overview of our approach. <p> On such models the uniform tessellation may supersample the surface. The performance of uniform tessellation algorithms is a direct function of the step sizes. 4.1 Uniform Subdivision There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. There are two main criteria for computing bounds for step sizes: size criterion and deviation criterion. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in the object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters <ref> [LR81, FMM86, AES91] </ref>. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds, and the step size as a function of these bounds [Roc87, RHD89]. We start with the size criterion for bound computations. <p> They are used to compute the step sizes as a function of the viewing parameters as shown in <ref> [FMM86, AES93] </ref>. An algorithm for computation of bounds based on the size criterion has been highlighted in [AES91]. However, the derivation of bounds in [AES91] is inaccurate and for a given T OL, our bounds are tighter. <p> These techniques worked very well on our models. 4.6 Crack Prevention Since the bound for required tessellation for each patch is evaluated independently, we may mandate different tessellations on two adjacent patches. This can result in cracks in the rendered image. To address this issue <ref> [FMM86, RHD89] </ref> suggested that the amount of tessellation at the boundary be based solely on the boundary curve, and a strip of coving triangles be generated at the boundary.
Reference: [Kaj82] <author> J. Kajiya. </author> <title> Ray tracing parametric patches. </title> <journal> Computer Graphics, </journal> <volume> 16(3) </volume> <pages> 245-254, </pages> <year> 1982. </year>
Reference-contexts: On parallel graphics systems, the algorithm minimizes communication between processors, and load balances the work. Previous Work: Curved surface rendering has been an active topic of research for more than two decades. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Cla79, Kaj82, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, only algorithms based on polygo-nization are capable of real time display.
Reference: [KM94] <author> S. Kumar and D. Manocha. </author> <title> Efficient display of trimmed nurbs models. </title> <type> Technical Report TR94-008, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <year> 1994. </year>
Reference-contexts: The trimmed surfaces are rendered by computing the visible portions of the domain. This involves computing the intersection of the curve with the domain subdivision, coving and tiling and triangulation. Due to space limitations we are not presenting the details in this paper and they are given in <ref> [KM94] </ref>. The basic idea of this algorithm is to treat the trimmed curve as patch boundaries. For untrimmed surfaces, we described an algorithm to partition the domain into rectangles in the interior of the patch and triangles at the boundary.
Reference: [LC93] <author> W.L. Luken and Fuhua Cheng. </author> <title> Rendering trimmed nurb surfaces. </title> <institution> Computer science research report 18669(81711), IBM Research Division, </institution> <year> 1993. </year>
Reference: [LCWB80] <author> J.M. Lane, L.C. Carpenter, J. T. Whitted, and J.F. </author> <title> Blinn. Scan line methods for displaying parametrically defined surfaces. </title> <journal> Communications of ACM, </journal> <volume> 23(1) </volume> <pages> 23-34, </pages> <year> 1980. </year>
Reference-contexts: On parallel graphics systems, the algorithm minimizes communication between processors, and load balances the work. Previous Work: Curved surface rendering has been an active topic of research for more than two decades. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Cla79, Kaj82, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, only algorithms based on polygo-nization are capable of real time display.
Reference: [LR81] <author> J.M. Lane and R.F. Riesenfeld. </author> <title> Bounds on polynomials. </title> <journal> BIT, </journal> <volume> 2 </volume> <pages> 112-117, </pages> <year> 1981. </year>
Reference-contexts: On such models the uniform tessellation may supersample the surface. The performance of uniform tessellation algorithms is a direct function of the step sizes. 4.1 Uniform Subdivision There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. There are two main criteria for computing bounds for step sizes: size criterion and deviation criterion. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in the object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters <ref> [LR81, FMM86, AES91] </ref>. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds, and the step size as a function of these bounds [Roc87, RHD89]. We start with the size criterion for bound computations. <p> All these computations are part of a preprocessing stage. Similarly, the maximum of f x (0; v) corresponds to computing the roots of f x v (0; v) = 0, which can be computed using root-finders or subdivision properties of Bezier curves <ref> [LR81] </ref>. Based on the solutions of these equations, we compute the maximum values of f x (u; v) in the domain [0; 1]fi [0; 1]. Let the maximum value be at [u x ; v x ].
Reference: [Luk93] <institution> W.L. Luken. Tessellation of trimmed nurb surfaces. Computer science research report 19322(84059), IBM Research Division, </institution> <year> 1993. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, only algorithms based on polygo-nization are capable of real time display. Different methods have been proposed for polygonization <ref> [AES93, ea89, Luk93, SC88, SL87, FK90, RHD89, Roc87, AES91, FMM86] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. [RHD89] have proposed a real time algorithm for trimmed surfaces.
Reference: [MD92] <author> D. Manocha and J. Demmel. </author> <title> Algorithms for intersecting parametric and algebraic curves. </title> <booktitle> In Graphics Interface '92, </booktitle> <pages> pages 232-241, </pages> <year> 1992. </year>
Reference-contexts: Thus the problem of computing the maximum derivative vector reduces to computing zeros of polynomial equations. In fact, it geometrically corresponds to curve intersection <ref> [MD92, Sed89] </ref>. In the first case, the two curves are algebraic plane curves, given as: u = 0; v = 0: The degrees of these curves are (3m 2; 3n) in (u; v) for the first curve and (3m; 3n 2) in (u; v) for the second curve. <p> This is rather high. However, we are able to compute accurate solutions in double precision arithmetic using the algorithm highlighted in <ref> [MD92] </ref>. In particular, it reduces the problem to computing eigenvalues of a matrix. Good implementations of eigenvalues are available as part of numerical libraries like EISPACK and LAPACK. The resulting algorithms are fast, accurate and need no initial guess to the solutions. <p> This query reduces to an inversion problem: given a point P and a curve C, find the parameter value t such that C (t) = P . We solve it using techniques from elimination theory <ref> [MD92] </ref>. For each patch boundary we now know the two sets of representations of the same curves: we store one of them (chosen arbitrarily) with both the patches. To calculate the bounds on the curves and tessellate them we use this stored representation.
Reference: [Nas93] <author> R. Nash. </author> <title> Silicon Graphics, </title> <type> Personal Communication, </type> <year> 1993. </year>
Reference-contexts: The Pixel-Planes implementation is fully parallel, using the maximum number of available processors. The performance of the algorithm on the SGI Onyx is shown in Table 2. The images were rendered with Gouraud shading. The standard SGI-GL implementation is based on the algorithm presented in <ref> [RHD89, Nas93] </ref> and has a microcoded geometry engine implementation for surface evaluations. Although it is difficult to compare two different algorithms and implementations (for example, the design constraints may be different), we performed the following experiments using identical sets of viewing parameters.
Reference: [RHD89] <author> A. Rockwood, K. Heaton, and T. Davis. </author> <title> Real-time rendering of trimmed surfaces. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 107-17, </pages> <year> 1989. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, only algorithms based on polygo-nization are capable of real time display. Different methods have been proposed for polygonization <ref> [AES93, ea89, Luk93, SC88, SL87, FK90, RHD89, Roc87, AES91, FMM86] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. [RHD89] have proposed a real time algorithm for trimmed surfaces. <p> As a result, only algorithms based on polygo-nization are capable of real time display. Different methods have been proposed for polygonization [AES93, ea89, Luk93, SC88, SL87, FK90, RHD89, Roc87, AES91, FMM86]. These are based on adaptive or uniform subdivision of NURBS surfaces. <ref> [RHD89] </ref> have proposed a real time algorithm for trimmed surfaces. However the bounds used for tessellating the Bezier surfaces are loose for rational surfaces and in some cases even undersample the surface. Furthermore, the operations used on trimming curves are relatively expensive and affects the performance of the overall algorithm. <p> The step size is computed as a function of these bounds and viewing parameters [LR81, FMM86, AES91]. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds, and the step size as a function of these bounds <ref> [Roc87, RHD89] </ref>. We start with the size criterion for bound computations. To avoid undersampling highly curved surfaces with low areas, we use an additional estimate based on the geometry of the control points. <p> These techniques worked very well on our models. 4.6 Crack Prevention Since the bound for required tessellation for each patch is evaluated independently, we may mandate different tessellations on two adjacent patches. This can result in cracks in the rendered image. To address this issue <ref> [FMM86, RHD89] </ref> suggested that the amount of tessellation at the boundary be based solely on the boundary curve, and a strip of coving triangles be generated at the boundary. <p> In case c i is intersected by a trim curve, we triangulate the non-trimmed region of c i . Since most trim curves are fairly smooth, in the general case, the algorithm performs well in practice and coving and tiling is no longer the bottleneck, as it is in <ref> [RHD89] </ref>. Furthermore we do not need to break up the trimmed curves into monotonic segments, as is the case in [RHD89]. 6 Implementation and performance We have implemented our algorithm on a Silicon Graphics (SGI) R3000 with a VGX graphics accelerator, a SGI Onyx with a RealityEngine 2, and on the <p> Since most trim curves are fairly smooth, in the general case, the algorithm performs well in practice and coving and tiling is no longer the bottleneck, as it is in <ref> [RHD89] </ref>. Furthermore we do not need to break up the trimmed curves into monotonic segments, as is the case in [RHD89]. 6 Implementation and performance We have implemented our algorithm on a Silicon Graphics (SGI) R3000 with a VGX graphics accelerator, a SGI Onyx with a RealityEngine 2, and on the Pixel-Planes 5 system. <p> The Pixel-Planes implementation is fully parallel, using the maximum number of available processors. The performance of the algorithm on the SGI Onyx is shown in Table 2. The images were rendered with Gouraud shading. The standard SGI-GL implementation is based on the algorithm presented in <ref> [RHD89, Nas93] </ref> and has a microcoded geometry engine implementation for surface evaluations. Although it is difficult to compare two different algorithms and implementations (for example, the design constraints may be different), we performed the following experiments using identical sets of viewing parameters.
Reference: [Roc87] <author> A. Rockwood. </author> <title> A generalized scanning technique for display of parametrically defined surface. </title> <journal> IEEE Computer Graphics and Applications, </journal> <pages> pages 15-26, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, only algorithms based on polygo-nization are capable of real time display. Different methods have been proposed for polygonization <ref> [AES93, ea89, Luk93, SC88, SL87, FK90, RHD89, Roc87, AES91, FMM86] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. [RHD89] have proposed a real time algorithm for trimmed surfaces. <p> On such models the uniform tessellation may supersample the surface. The performance of uniform tessellation algorithms is a direct function of the step sizes. 4.1 Uniform Subdivision There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. There are two main criteria for computing bounds for step sizes: size criterion and deviation criterion. <p> The step size is computed as a function of these bounds and viewing parameters [LR81, FMM86, AES91]. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds, and the step size as a function of these bounds <ref> [Roc87, RHD89] </ref>. We start with the size criterion for bound computations. To avoid undersampling highly curved surfaces with low areas, we use an additional estimate based on the geometry of the control points. <p> Let T OL be the user specified tolerance in screen space. The step sizes along the u and v directions are given as <ref> [Roc87] </ref>: n u = m max (k W ij R ij W i+1;j R i+1;j k)=(T OL fl min (W ij )) for (1 i m, 1 j n). In practice these bounds are good for polynomial surfaces only, when W ij = 1. <p> Bezier curves defined as (R i1 ; R i2 ; : : : ; R in ) for all 1 i m and take the maximum of n 0 0 v is computed in a similar manner. 4.4 Comparison of Methods We empirically compared our bound with those of Rock-wood <ref> [Roc87] </ref> and Abi-Ezzi/Shirman [AES91]. These comparisons were performed over a number of models and we computed the averages of the number of polygons generated. The average has been taken over seven models and the number of patches varied from 72 to 5354. <p> The average has been taken over seven models and the number of patches varied from 72 to 5354. The degrees of the models were between two and three in u as well as v. For the same tolerance, our bounds result in about 33% fewer triangles than <ref> [Roc87] </ref> and about 20% fewer than [AES91]. Fig. 4 compares the wireframes and shaded images of a pencil using the three methods. 4.5 Frame to Frame Coherence Typically, there is not much change in the position of the model in the object space between successive frames. As 5 Our Algorithm [Roc87] <p> <ref> [Roc87] </ref> and about 20% fewer than [AES91]. Fig. 4 compares the wireframes and shaded images of a pencil using the three methods. 4.5 Frame to Frame Coherence Typically, there is not much change in the position of the model in the object space between successive frames. As 5 Our Algorithm [Roc87] [AES91] 1 1.43 1.22 Table 1: Relative comparison of the number of triangles generated for a given tolerance a result, the bounds for tessellation do not change much between successive frames. In almost all cases the change in n u and n v is small if not zero.
Reference: [SC88] <author> M. Shantz and S. Chang. </author> <title> Rendering trimmed nurbs with adaptive forward differencing. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 189-198, </pages> <year> 1988. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, only algorithms based on polygo-nization are capable of real time display. Different methods have been proposed for polygonization <ref> [AES93, ea89, Luk93, SC88, SL87, FK90, RHD89, Roc87, AES91, FMM86] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. [RHD89] have proposed a real time algorithm for trimmed surfaces.
Reference: [Sed89] <author> T.W. </author> <title> Sederberg. Algorithms for algebraic curve intersection. </title> <booktitle> Computer-Aided Design, </booktitle> <volume> 21(9) </volume> <pages> 547-555, </pages> <year> 1989. </year>
Reference-contexts: Thus the problem of computing the maximum derivative vector reduces to computing zeros of polynomial equations. In fact, it geometrically corresponds to curve intersection <ref> [MD92, Sed89] </ref>. In the first case, the two curves are algebraic plane curves, given as: u = 0; v = 0: The degrees of these curves are (3m 2; 3n) in (u; v) for the first curve and (3m; 3n 2) in (u; v) for the second curve.
Reference: [SL87] <author> M. Shantz and S. Lien. </author> <title> Shading bicubic patches. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 189-196, </pages> <year> 1987. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, only algorithms based on polygo-nization are capable of real time display. Different methods have been proposed for polygonization <ref> [AES93, ea89, Luk93, SC88, SL87, FK90, RHD89, Roc87, AES91, FMM86] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. [RHD89] have proposed a real time algorithm for trimmed surfaces.
Reference: [TRC + 93] <author> R. M. Taylor, W. Robinett, V.L. Chii, F. Brooks, and W. Wright. </author> <title> The nanomanipulator: A virtual-reality interface for a scanning tunneling microscope. </title> <booktitle> In ACM SIGGRAPH, </booktitle> <pages> pages 127-134, </pages> <year> 1993. </year> <pages> 10 11 12 13 </pages>
Reference-contexts: These routines may generate arbitrary geometry in immediate mode for the rendering engine to display. This feature has been used successfully for problems which require close coupling between computation and the generation of geometry [Ban92] <ref> [TRC + 93] </ref>. The tessellation algorithm is implemented as a set of user functions running on the graphics processors. Load balancing is achieved by distributing the individual patches to the GPs in round-robbin order.
References-found: 30

