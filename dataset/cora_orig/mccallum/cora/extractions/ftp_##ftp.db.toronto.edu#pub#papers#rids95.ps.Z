URL: ftp://ftp.db.toronto.edu/pub/papers/rids95.ps.Z
Refering-URL: http://karna.cs.umd.edu:3264/people/godfrey/cites.html
Root-URL: 
Phone: 2  3  
Title: Constant Propagation Versus Join Reordering in Datalog  
Author: Mariano P. Consens Alberto O. Mendelzon Dimitra Vista and Peter T. Wood ? 
Address: Waterloo, Waterloo, Canada N2L 3G1  Toronto, Toronto, Canada M5S 1A1  Rondebosch 7700, South Africa  
Affiliation: 1 Dep. of Computer Science, Univ. of  Computer Systems Research Institute, Univ. of  Dep. of Computer Science, Univ. of Cape Town,  
Abstract: Constant propagation and join reordering are two standard optimization techniques used for Datalog programs. These techniques have typically been studied independently of one another. However, in order to achieve constant propagation it is sometimes necessary to impose a certain join ordering on a given program. In the worst case this ordering may result in efficiencies which overcome the benefit of constant propagation. Thus the goal of constant propagation should not necessarily be pursued to the exclusion of all else. We study this problem in the context of GraphLog, a visual language whose queries are graphical notations which are translated into Datalog. We study two translation schemes from GraphLog to Datalog, one which always achieves constant propagation and another which does not. We show that each translation can significantly outperform the other. We demonstrate this by both measuring execution times using actual application data, and by providing analytical formulae to explain the trade-off between constant propagation and join reordering.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> F. Bancilhon and R. Ramakrishnan. </author> <title> An Amateur's Introduction to Recursive Query Processing Strategies. </title> <booktitle> In SIGMOD, </booktitle> <pages> pages 16-52, </pages> <year> 1986. </year>
Reference-contexts: We explore this in the next section. 4 Performance Analysis Previous results on comparing performance costs induced by different evaluation strategies or optimization methods seem to suggest that an overriding factor is the presence or absence of constants in the query <ref> [1, 8] </ref>. In this section, we demonstrate both analytically and experimentally that the choice of which translation is preferable is not guided by the presence or absence of constants. It is guided only by the shape of the graph, that is, the join selectivity of the relations involved.
Reference: 2. <author> C. Beeri and R. Ramakrishnan. </author> <title> On the Power of Magic. </title> <booktitle> In PODS, </booktitle> <pages> pages 269-283, </pages> <year> 1987. </year>
Reference-contexts: For program P 1 from the closure translation, we simply substitute object for ClassX in the query clause and apply the magic sets transformation <ref> [2] </ref>. <p> GraphLog users are allowed to label nodes with (single) constants. The closure translation of such a query to Datalog will result in a program containing a single constant in the query goal, whereupon the rewriting techniques such as magic sets <ref> [2] </ref>, factoring [11] and context rewriting [10] become applicable. We assume that readers are familiar with each of these. CORAL provides an annotation for controlling evaluation called @factoring. This applies the context rewriting transformation of [10].
Reference: 3. <author> M.P. Consens. </author> <title> Creating and Filtering Structural Data Visualizations using Hygraph Patterns. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Toronto, </institution> <month> February </month> <year> 1994. </year> <note> (Available as Technical Report CSRI-302). </note>
Reference-contexts: Section 3 and 4 presents both experimental and analytical comparisons between the two methods. Since for the purposes of this paper we do not require a number of features of GraphLog, we simplify the following description accordingly. For a complete description of the language, the reader is referred to <ref> [3] </ref>. In GraphLog, a term is either a constant or a variable (once again, more general terms are in fact allowed). <p> ordering and constant propagation, provide the principal explanations for the performance results presented in the following two sections. 3 Application-Based Performance Comparisons In this section we describe the differences in performance stemming from the two different translations in an application of performance tuning during software development (described in detail in <ref> [3, 6] </ref>). In this setting, we regard the code as a set of functions that call each other. The code is partitioned into sections, which are load modules. Each section consists of a set of functions and a set of overlay areas that are arranged in series in memory.
Reference: 4. <author> M.P. Consens, F.Ch. Eigler, M.Z. Hasan, A.O. Mendelzon, E.G. Noik, A.G. Ryman, and D. </author> <title> Vista. Architecture and Applications of the Hy + Visualization System. </title> <journal> IBM Systems Journal, </journal> <volume> 33(3) </volume> <pages> 458-476, </pages> <year> 1994. </year>
Reference-contexts: We restrict our attention to a class of queries which correspond to path computations on graph databases as specified by regular expressions. These are the queries which can be computed by the Hy + database visualization system developed at the University of Toronto <ref> [4] </ref>. We show that, if we insist on propagating constants to EDB relations, then certain join orderings are precluded. One of these orderings may be more efficient than that imposed by constant propagation. We provide cost formulas and heuristics to guide a choice among the alternative strategies. Example 1.
Reference: 5. <author> M.P. Consens and A.O. Mendelzon. </author> <title> GraphLog: A Visual Formalism for Real Life Recursion. </title> <booktitle> In PODS, </booktitle> <pages> pages 404-416, </pages> <year> 1990. </year>
Reference-contexts: The query comes from the fact that related is the final state of M . The above two translations from regular expressions to Datalog are implemented in the GraphLog query language <ref> [5, 7] </ref> provided by the Hy + system. We call the former the closure translation, because it computes closures of EDB or IDB relations, and the latter the nfa translation. Datalog programs are passed by Hy + to the CORAL deductive database system for evaluation [12].
Reference: 6. <author> M.P. Consens, A.O. Mendelzon, and A. Ryman. </author> <title> Visualizing and Querying Software Structures. </title> <booktitle> In ICSE '92, </booktitle> <pages> pages 138-156, </pages> <year> 1992. </year>
Reference-contexts: ordering and constant propagation, provide the principal explanations for the performance results presented in the following two sections. 3 Application-Based Performance Comparisons In this section we describe the differences in performance stemming from the two different translations in an application of performance tuning during software development (described in detail in <ref> [3, 6] </ref>). In this setting, we regard the code as a set of functions that call each other. The code is partitioned into sections, which are load modules. Each section consists of a set of functions and a set of overlay areas that are arranged in series in memory.
Reference: 7. <author> M.P. Consens, A.O. Mendelzon, and D. </author> <title> Vista. Deductive Database Support for Data Visualization. </title> <booktitle> In EDBT, </booktitle> <pages> pages 45-58, </pages> <year> 1994. </year>
Reference-contexts: The query comes from the fact that related is the final state of M . The above two translations from regular expressions to Datalog are implemented in the GraphLog query language <ref> [5, 7] </ref> provided by the Hy + system. We call the former the closure translation, because it computes closures of EDB or IDB relations, and the latter the nfa translation. Datalog programs are passed by Hy + to the CORAL deductive database system for evaluation [12].
Reference: 8. <author> J. Han and H. Lu. </author> <title> Some Performance Results on Recursive Query Processing in Relational Database Systems. </title> <booktitle> In ICDE, </booktitle> <pages> pages 533-539, </pages> <year> 1986. </year>
Reference-contexts: We explore this in the next section. 4 Performance Analysis Previous results on comparing performance costs induced by different evaluation strategies or optimization methods seem to suggest that an overriding factor is the presence or absence of constants in the query <ref> [1, 8] </ref>. In this section, we demonstrate both analytically and experimentally that the choice of which translation is preferable is not guided by the presence or absence of constants. It is guided only by the shape of the graph, that is, the join selectivity of the relations involved.
Reference: 9. <author> J.E. Hopcroft and J.D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: We assume the reader is familiar with the definition of a nondeterministic finite automaton <ref> [9] </ref>. Given NFA M , the language L (M ) accepted by M is the set of all strings accepted by M . We assume that we are given a single edge from a GraphLog query. The edge is labelled with an arbitrary regular expression R. <p> The details of the translation from regular expression R to program P are as follows: 1. Construct an NFA M which accepts the language L (R), as described, for example, in <ref> [9] </ref>. 2.
Reference: 10. <author> D. Kemp, K. Ramamohanarao, and Z. Somogyi. Right-, </author> <title> Left-, and Multi-Linear Rule Transformations that Maintain Context Information. </title> <booktitle> In VLDB, </booktitle> <pages> pages 380-391, </pages> <year> 1990. </year>
Reference-contexts: GraphLog users are allowed to label nodes with (single) constants. The closure translation of such a query to Datalog will result in a program containing a single constant in the query goal, whereupon the rewriting techniques such as magic sets [2], factoring [11] and context rewriting <ref> [10] </ref> become applicable. We assume that readers are familiar with each of these. CORAL provides an annotation for controlling evaluation called @factoring. This applies the context rewriting transformation of [10]. <p> a single constant in the query goal, whereupon the rewriting techniques such as magic sets [2], factoring [11] and context rewriting <ref> [10] </ref> become applicable. We assume that readers are familiar with each of these. CORAL provides an annotation for controlling evaluation called @factoring. This applies the context rewriting transformation of [10]. We will use the term factoring in the same way as in [11] to mean the reduction in the number of arguments in recursive predicates. Context rewriting does not do this, so to avoid confusion we will refer to the CORAL annotation as context rewriting.
Reference: 11. <author> J.F. Naughton, R. Ramakrishnan, Y. Sagiv, and J.D. Ullman. </author> <title> Argument Reduction by Factoring. </title> <booktitle> In VLDB, </booktitle> <pages> pages 173-182, </pages> <year> 1989. </year>
Reference-contexts: Now assume that we are interested only in those classes related to the particular class called object. One crucial difference between the two translations is that the nfa translation admits the propagation of constants to base relations using the technique of factoring <ref> [11] </ref>, while the closure translation does not. For program P 1 from the closure translation, we simply substitute object for ClassX in the query clause and apply the magic sets transformation [2]. <p> GraphLog users are allowed to label nodes with (single) constants. The closure translation of such a query to Datalog will result in a program containing a single constant in the query goal, whereupon the rewriting techniques such as magic sets [2], factoring <ref> [11] </ref> and context rewriting [10] become applicable. We assume that readers are familiar with each of these. CORAL provides an annotation for controlling evaluation called @factoring. This applies the context rewriting transformation of [10]. We will use the term factoring in the same way as in [11] to mean the reduction <p> magic sets [2], factoring <ref> [11] </ref> and context rewriting [10] become applicable. We assume that readers are familiar with each of these. CORAL provides an annotation for controlling evaluation called @factoring. This applies the context rewriting transformation of [10]. We will use the term factoring in the same way as in [11] to mean the reduction in the number of arguments in recursive predicates. Context rewriting does not do this, so to avoid confusion we will refer to the CORAL annotation as context rewriting. There are at least two limitations of context rewriting. <p> There are at least two limitations of context rewriting. Firstly, it is not applicable to all programs generated from GraphLog queries. Secondly, context rewriting may be an order of magnitude less efficient than a true factoring transformation. The original factoring transformation applies to a very restricted class of programs <ref> [11] </ref>. However, it was shown in [13, 14] that the factoring transformation can be applied to any program generated by an alternative translation from (single-edge) GraphLog queries to Datalog. <p> This difference can override the benefit of constant propagation, thereby making it undesirable in some circumstances. Recently it has been shown that the original factoring translation of <ref> [11] </ref> can be correctly applied to closure programs [15]. In addition, after further optimizations, a closure program generated from regular expression R is transformed into precisely the program generated by the nfa translation for R [15].
Reference: 12. <author> R. Ramakrishnan, D. Srivastava, S. Sudarshan, and P. Seshadri. </author> <title> Implementation of the CORAL Deductive Database System. </title> <booktitle> In SIGMOD, </booktitle> <pages> pages 167-176, </pages> <year> 1993. </year>
Reference-contexts: We call the former the closure translation, because it computes closures of EDB or IDB relations, and the latter the nfa translation. Datalog programs are passed by Hy + to the CORAL deductive database system for evaluation <ref> [12] </ref>. Which translation should be adopted is one of the issues explored in this paper. Consider the bottom-up evaluation of P 1 . <p> By increasing the size of these relations, the performance differential can be made arbitrarily large. One reason for the relatively large difference in performance in the absence of constants is that CORAL uses ordered search for the evaluation of negated subgoals <ref> [12] </ref>. This also precludes the use of context rewriting when constants are present. cpu time in seconds and are averaged over a number of runs on a lightly loaded Sun Sparc10).
Reference: 13. <author> D. Vista and P.T. Wood. </author> <title> Efficient Evaluation of Visual Queries Using Deductive Databases. </title> <editor> In R. Ramakrishnan, editor, </editor> <booktitle> Applications of Logic Databases, </booktitle> <pages> pages 143-161. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1995. </year>
Reference-contexts: Firstly, it is not applicable to all programs generated from GraphLog queries. Secondly, context rewriting may be an order of magnitude less efficient than a true factoring transformation. The original factoring transformation applies to a very restricted class of programs [11]. However, it was shown in <ref> [13, 14] </ref> that the factoring transformation can be applied to any program generated by an alternative translation from (single-edge) GraphLog queries to Datalog. <p> However, it was shown in [13, 14] that the factoring transformation can be applied to any program generated by an alternative translation from (single-edge) GraphLog queries to Datalog. A simplified version of this translation is presented below; for a complete version, the reader is referred to <ref> [13] </ref>. 2.2 The NFA Translation Rather than a translation based on the structure of the regular expression R in the GraphLog query, in this subsection we describe a translation based on a nondeterministic finite automaton (NFA) constructed from R.
Reference: 14. <author> P.T. Wood. </author> <title> Factoring Augmented Regular Chain Programs. </title> <booktitle> In VLDB, </booktitle> <pages> pages 255-263, </pages> <year> 1990. </year>
Reference-contexts: Firstly, it is not applicable to all programs generated from GraphLog queries. Secondly, context rewriting may be an order of magnitude less efficient than a true factoring transformation. The original factoring transformation applies to a very restricted class of programs [11]. However, it was shown in <ref> [13, 14] </ref> that the factoring transformation can be applied to any program generated by an alternative translation from (single-edge) GraphLog queries to Datalog.
Reference: 15. <author> P.T. Wood. </author> <title> Magic Factoring of Closure Programs. </title> <booktitle> In PODS, </booktitle> <pages> pages 174-183, </pages> <year> 1995. </year>
Reference-contexts: This difference can override the benefit of constant propagation, thereby making it undesirable in some circumstances. Recently it has been shown that the original factoring translation of [11] can be correctly applied to closure programs <ref> [15] </ref>. In addition, after further optimizations, a closure program generated from regular expression R is transformed into precisely the program generated by the nfa translation for R [15]. The results of the present paper indicate, however, that this transformation may not always be desirable. <p> Recently it has been shown that the original factoring translation of [11] can be correctly applied to closure programs <ref> [15] </ref>. In addition, after further optimizations, a closure program generated from regular expression R is transformed into precisely the program generated by the nfa translation for R [15]. The results of the present paper indicate, however, that this transformation may not always be desirable.
References-found: 15

