URL: http://www.cs.tamu.edu/faculty/vaidya/papers/fault-tolerance/spdp96.ps.Z
Refering-URL: http://www.cs.tamu.edu/faculty/vaidya/Vaidya-ftc.html
Root-URL: http://www.cs.tamu.edu
Email: E-mail: vaidya@cs.tamu.edu  
Title: On Staggered Checkpointing  
Author: Nitin H. Vaidya 
Address: College Station, TX 77843-3112  
Affiliation: Department of Computer Science Texas A&M University  
Abstract: A consistent checkpointing algorithm saves a consistent view of a distributed application's state on stable storage. The traditional consistent checkpoint-ing algorithms require different processes to save their state at about the same time. This causes contention for the stable storage, potentially resulting in large overheads. Staggering the checkpoints taken by various processes can reduce checkpoint overhead [10]. This paper presents a simple approach to arbitrarily stagger the checkpoints. Our approach requires that the processes take consistent logical checkpoints, as compared to consistent physical checkpoints enforced by existing algorithms. Experimental results on nCube-2 are presented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. M. Chandy and L. Lamport, </author> <title> "Distributed snapshots: Determining global states in distributed systems," </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> vol. 3, </volume> <pages> pp. 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: 1 Introduction Applications executed on a large number of processors, either in a distributed environment, or on multicomputers such as nCube, are subject to processor failures. Consistent checkpointing is a commonly used technique to prevent complete loss of computation upon a failure <ref> [1, 3, 5, 9, 10] </ref>. A consistent check-pointing algorithm saves a consistent view of a distributed application's state on a stable storage. The loss of computation upon a failure is bounded by taking consistent checkpoints with adequate frequency. <p> The degree of staggering with Plank's algorithm (based on the Chandy-Lamport algorithm <ref> [1] </ref>) is completely dependent on the application's communication pattern. In contrast, our algorithm allows arbitrary staggering of the checkpoints, independent of the application. Plank [10] also presents another approach for staggering checkpoints, that is applicable to wormhole routed networks. This algorithm also does not permit arbitrary/controlled staggering. <p> The anti-messages can possibly be formed by the application itself, or they may consist of a copy of the (old) process state modified by the message (sim ilar to copy-on-write [8]). 4 Chandy-Lamport Algorithm <ref> [1] </ref> Chandy and Lamport [1] presented an algorithm for taking a consistent checkpoint of a distributed system. Assume that the processes communicate with each other using unidirectional communication channels; a bidirectional channel can be modeled as two unidirectional channels. <p> The anti-messages can possibly be formed by the application itself, or they may consist of a copy of the (old) process state modified by the message (sim ilar to copy-on-write [8]). 4 Chandy-Lamport Algorithm <ref> [1] </ref> Chandy and Lamport [1] presented an algorithm for taking a consistent checkpoint of a distributed system. Assume that the processes communicate with each other using unidirectional communication channels; a bidirectional channel can be modeled as two unidirectional channels. <p> Assume that the processes communicate with each other using unidirectional communication channels; a bidirectional channel can be modeled as two unidirectional channels. For simplicity, we assume that the communication graph is fully connected. 2 The algorithm presented next is essentially identical to Chandy-Lamport <ref> [1, 10] </ref> and assumes that a certain process (named P 0 ) is designated as the checkpoint coordinator. <p> Proof of correctness: The correctness follows directly from the proof of correctness for the Chandy-Lamport algorithm <ref> [1] </ref>. 6 Performance Evaluation We implemented the proposed algorithm STAGGER and the Chandy-Lamport/Plank scheme (abbreviated as CL/P) on a nCube-2 multicomputer. It should be noted that performance of each scheme is closely dependent on the underlying hardware and behavior of the application program.
Reference: [2] <author> C. J. Date, </author> <title> An Introduction to Database Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: The notion of an anti-message here is similar to that used in time warp mechanism [4] or that of UNDO records <ref> [2] </ref> in database systems. Anti-message M fl corresponding to a message M can be used to undo the state change caused by message M. and t 2 .
Reference: [3] <author> E. N. Elnozahy, D. B. Johnson, and W. Zwaenepoel, </author> <title> "The performance of consistent checkpointing," </title> <booktitle> in Symposium on Reliable Distributed Systems, </booktitle> <year> 1992. </year>
Reference-contexts: 1 Introduction Applications executed on a large number of processors, either in a distributed environment, or on multicomputers such as nCube, are subject to processor failures. Consistent checkpointing is a commonly used technique to prevent complete loss of computation upon a failure <ref> [1, 3, 5, 9, 10] </ref>. A consistent check-pointing algorithm saves a consistent view of a distributed application's state on a stable storage. The loss of computation upon a failure is bounded by taking consistent checkpoints with adequate frequency.
Reference: [4] <author> D. Jefferson, </author> <title> "Virtual time," </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> vol. 3, </volume> <pages> pp. 404-425, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: For each relevant message (whose effect must be undone), an anti-message is 1 The term logging is used to mean "saving on the stable storage". logical checkpoint saved on the stable storage. The notion of an anti-message here is similar to that used in time warp mechanism <ref> [4] </ref> or that of UNDO records [2] in database systems. Anti-message M fl corresponding to a message M can be used to undo the state change caused by message M. and t 2 .
Reference: [5] <author> D. B. Johnson, </author> <title> Distributed System Fault Tolerance Using Message Logging and Checkpointing. </title> <type> PhD thesis, </type> <institution> Computer Science, Rice University, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Applications executed on a large number of processors, either in a distributed environment, or on multicomputers such as nCube, are subject to processor failures. Consistent checkpointing is a commonly used technique to prevent complete loss of computation upon a failure <ref> [1, 3, 5, 9, 10] </ref>. A consistent check-pointing algorithm saves a consistent view of a distributed application's state on a stable storage. The loss of computation upon a failure is bounded by taking consistent checkpoints with adequate frequency. <p> This recovery line is used to recover from the failure. Their goal is to determine the "latest" consistent recovery line using the information saved on the stable storage. Message logging and independent checkpointing schemes, such as <ref> [5] </ref>, also, effectively, determine a recovery line consisting of consistent logical checkpoints after a failure occurs. In these schemes, during failure-free operation each process is allowed to independently take checkpoints and log messages. On the other hand, our scheme coordinates logical checkpoints before a failure occurs. <p> One consequence of this is that our scheme does not log all messages; only those messages which make the logical checkpoints consistent are logged. 3 A Logical Checkpoint A process is said to be deterministic if its state depends only on its initial state and the messages delivered to it <ref> [5, 11] </ref>. A deterministic process can take two types of checkpoints: a physical checkpoint or a logical checkpoint. A process is said to have taken a physical checkpoint at some time t 1 , if the process state at time t 1 is saved on the stable storage.
Reference: [6] <author> D. B. Johnson, </author> <title> "Efficient transparent optimistic rollback recovery for distributed application programs," </title> <booktitle> in Symposium on Reliable Distributed Systems, </booktitle> <pages> pp. 86-95, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Thus, each process will take checkpoint, and the algorithm 3 Johnson <ref> [6] </ref> suggested a scheme where each process uses a similar heuristic to decide whether to log messages or not. will make progress, even if the processes are not com-municating with each other.
Reference: [7] <author> S. Kaul, </author> <title> "Evaluation of consistent logical checkpoint-ing." M.S. </title> <type> Thesis, </type> <institution> Dept. of Computer Science, Texas A&M University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: To achieve this we partition the processes into clusters, the number of clusters being identical to the number of stable storages. Each cluster is associated with a unique stable storage; processes within a cluster access only the associated stable storage <ref> [7] </ref>. The algorithm STAGGER, modified to use multiple stable storages, differs from the original STAGGER algorithm only in the first phase (i.e., staggered check-pointing phase). We illustrate the modified staggered checkpointing phase with an example. Consider a system consisting of 6 processes, and 2 stable storages.
Reference: [8] <author> K. Li, J. F. Naughton, and J. S. Plank, </author> <title> "Low-latency, concurrent checkpointing for parallel programs," </title> <journal> IEEE Trans. Par. Distr. Syst., </journal> <volume> vol. 5, </volume> <pages> pp. 874-879, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: The anti-messages can possibly be formed by the application itself, or they may consist of a copy of the (old) process state modified by the message (sim ilar to copy-on-write <ref> [8] </ref>). 4 Chandy-Lamport Algorithm [1] Chandy and Lamport [1] presented an algorithm for taking a consistent checkpoint of a distributed system. Assume that the processes communicate with each other using unidirectional communication channels; a bidirectional channel can be modeled as two unidirectional channels.
Reference: [9] <author> J. Long, B. Janssens, and W. K. Fuchs, </author> <title> "An evolutionary approach to concurrent checkpointing," </title> <note> manuscript submitted for publication, </note> <year> 1994. </year>
Reference-contexts: 1 Introduction Applications executed on a large number of processors, either in a distributed environment, or on multicomputers such as nCube, are subject to processor failures. Consistent checkpointing is a commonly used technique to prevent complete loss of computation upon a failure <ref> [1, 3, 5, 9, 10] </ref>. A consistent check-pointing algorithm saves a consistent view of a distributed application's state on a stable storage. The loss of computation upon a failure is bounded by taking consistent checkpoints with adequate frequency. <p> In contrast, our algorithm allows arbitrary staggering of the checkpoints, independent of the application. Plank [10] also presents another approach for staggering checkpoints, that is applicable to wormhole routed networks. This algorithm also does not permit arbitrary/controlled staggering. Long et al. <ref> [9] </ref> discuss an evolutionary checkpoint ing approach, that is similar to logical checkpoint--ing. Our algorithm staggers the checkpoints, while the scheme in [9] does not allow staggering. [9] also assumes synchronized communication and an upper bound on communication delays; no such assumptions are made in the proposed scheme. <p> Plank [10] also presents another approach for staggering checkpoints, that is applicable to wormhole routed networks. This algorithm also does not permit arbitrary/controlled staggering. Long et al. <ref> [9] </ref> discuss an evolutionary checkpoint ing approach, that is similar to logical checkpoint--ing. Our algorithm staggers the checkpoints, while the scheme in [9] does not allow staggering. [9] also assumes synchronized communication and an upper bound on communication delays; no such assumptions are made in the proposed scheme. Wang et al. [13] introduced the term logical checkpoint. <p> This algorithm also does not permit arbitrary/controlled staggering. Long et al. <ref> [9] </ref> discuss an evolutionary checkpoint ing approach, that is similar to logical checkpoint--ing. Our algorithm staggers the checkpoints, while the scheme in [9] does not allow staggering. [9] also assumes synchronized communication and an upper bound on communication delays; no such assumptions are made in the proposed scheme. Wang et al. [13] introduced the term logical checkpoint. They present an algorithm to determine a recovery line consisting of consistent logical checkpoints, after a failure occurs. <p> The incremental checkpoint is taken by logging 1 the changes made to process state between time t 0 and t 1 . We summarize this approach as: physical checkpoint + incremental checkpoint = logical checkpoint The evolutionary checkpointing scheme by Long et al. <ref> [9] </ref> takes checkpoints similar to above procedure, although they do not use the term logical checkpoint. Approach 3: The above two approaches take a physical checkpoint prior to the desired logical checkpoint, followed by logging of additional information (either messages or incremental state change).
Reference: [10] <author> J. S. Plank, </author> <title> Efficient Checkpointing on MIMD Architectures. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Princeton University, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Applications executed on a large number of processors, either in a distributed environment, or on multicomputers such as nCube, are subject to processor failures. Consistent checkpointing is a commonly used technique to prevent complete loss of computation upon a failure <ref> [1, 3, 5, 9, 10] </ref>. A consistent check-pointing algorithm saves a consistent view of a distributed application's state on a stable storage. The loss of computation upon a failure is bounded by taking consistent checkpoints with adequate frequency. <p> The loss of computation upon a failure is bounded by taking consistent checkpoints with adequate frequency. The traditional consistent checkpointing algorithms require different application processes to save their state at about the same time. This causes contention for the stable storage, potentially resulting in significant performance degradation <ref> [10] </ref>. Staggering the checkpoints taken by various processes can reduce the fl This research is supported in part by National Science Foundation grant MIP-9502563 and Texas Advanced Technology Program grant 009741-052-C. overhead of consistent checkpointing by reducing stable storage contention. Some techniques for staggering the checkpoints have been previously proposed [10], <p> <ref> [10] </ref>. Staggering the checkpoints taken by various processes can reduce the fl This research is supported in part by National Science Foundation grant MIP-9502563 and Texas Advanced Technology Program grant 009741-052-C. overhead of consistent checkpointing by reducing stable storage contention. Some techniques for staggering the checkpoints have been previously proposed [10], however, these techniques result in "limited" staggering in that not all processes' checkpoints can be staggered. Ideally, one would like to stagger the checkpoints arbitrarily. If processors are able to make an "in-memory" copy of entire process state, then checkpoint staggering is trivial. <p> Our approach requires that the processes take consistent logical checkpoints, as compared to consistent physical checkpoints enforced by existing algorithms for staggering. The paper discusses the proposed approach and presents experimental results on nCube-2 multicomputer. 2 Related Work Plank <ref> [10] </ref> was the first to observe that stable storage contention can be serious problem for consistent checkpointing, and suggested checkpoint staggering as a solution. The degree of staggering with Plank's algorithm (based on the Chandy-Lamport algorithm [1]) is completely dependent on the application's communication pattern. <p> The degree of staggering with Plank's algorithm (based on the Chandy-Lamport algorithm [1]) is completely dependent on the application's communication pattern. In contrast, our algorithm allows arbitrary staggering of the checkpoints, independent of the application. Plank <ref> [10] </ref> also presents another approach for staggering checkpoints, that is applicable to wormhole routed networks. This algorithm also does not permit arbitrary/controlled staggering. Long et al. [9] discuss an evolutionary checkpoint ing approach, that is similar to logical checkpoint--ing. <p> Assume that the processes communicate with each other using unidirectional communication channels; a bidirectional channel can be modeled as two unidirectional channels. For simplicity, we assume that the communication graph is fully connected. 2 The algorithm presented next is essentially identical to Chandy-Lamport <ref> [1, 10] </ref> and assumes that a certain process (named P 0 ) is designated as the checkpoint coordinator. <p> Q takes a checkpoint. Q records the state of channel c as being empty. end else Q records the state of channel c as the sequence of messages received along c, after Q had taken a checkpoint and before Q received the marker along c. 4.1 Plank's Staggering Scheme <ref> [10] </ref> Plank [10] suggested that the processes should send markers after taking their checkpoints, rather than before taking the checkpoint (unlike the algorithm above). This simple modification introduces some staggering of checkpoints. However, not all checkpoints can be staggered. <p> Q records the state of channel c as being empty. end else Q records the state of channel c as the sequence of messages received along c, after Q had taken a checkpoint and before Q received the marker along c. 4.1 Plank's Staggering Scheme <ref> [10] </ref> Plank [10] suggested that the processes should send markers after taking their checkpoints, rather than before taking the checkpoint (unlike the algorithm above). This simple modification introduces some staggering of checkpoints. However, not all checkpoints can be staggered. In our experiments, we use the Chandy-Lamport algorithm that incorporates Plank's modification. <p> In the rest of this paper, this modified algorithm will be referred to as Chandy-Lamport/Plank algorithm, or CL/P for brevity. 2 Note that Chandy-Lamport algorithm is applicable to strongly connected graphs. Our algorithm can also be generalized to strongly connected graphs. Observations: Plank <ref> [10] </ref> observed that his stag-gering schemes work better than the original "non-staggered" algorithm when (i) degree of synchronization amongst the processes is relatively small, and (ii) the message volume is relatively small. 5 Staggered Consistent Checkpointing The extent of checkpoint staggering using CL/P algorithm is dependent on the application's communication pattern, <p> We will return to the issue of using asynchronous markers later in Section 7. The application used for evaluation is a synthetic program, named sync-loop, similar to a program used by Plank <ref> [10] </ref>. The pseudo-code for the program is presented below. sync-loop (iter, size, M) - state = malloc (size); // create state initialize (state); repeat (iter) times - perform M floating-point multiplications; synchronize with all other processes; - Process state size (and checkpoint size) is controlled by the size parameter. <p> As seen from Figure 7, the checkpoint overhead for STAGGER remains constant independent of the dimension, as synchronization is very infrequent. On the other hand, the overhead for CL/P increases with the dimension. Impact of message size on performance: Plank <ref> [10] </ref> observed that his staggered checkpointing schemes log more messages than non-staggered checkpointing schemes. Therefore, his schemes do not perform well compared to non-staggering schemes, when message sizes are large. <p> Which markers (if any) are sent asynchronously can affect performance of STAGGER and CL/P algorithms significantly. As noted previously, in our implementation, markers sent by process 0 are asynchronous, other markers are synchronous. One variation on Plank's scheme <ref> [10] </ref> for applications with infrequent synchronization (communication) is as follows: Ensure that the marker sent by process i to process j is asynchronous if and only if j = i + 1 (modulo number of processes).
Reference: [11] <author> R. E. Strom and S. A. Yemini, </author> <title> "Optimistic recovery: An asynchronous approach to fault-tolerance in distributed systems," </title> <booktitle> 14 th Int. Symp. Fault-Tolerant Comp., </booktitle> <pages> pp. 374-379, </pages> <year> 1984. </year>
Reference-contexts: One consequence of this is that our scheme does not log all messages; only those messages which make the logical checkpoints consistent are logged. 3 A Logical Checkpoint A process is said to be deterministic if its state depends only on its initial state and the messages delivered to it <ref> [5, 11] </ref>. A deterministic process can take two types of checkpoints: a physical checkpoint or a logical checkpoint. A process is said to have taken a physical checkpoint at some time t 1 , if the process state at time t 1 is saved on the stable storage.
Reference: [12] <author> N. H. Vaidya, </author> <title> "Consistent logical checkpointing," </title> <type> Tech. Rep. 94-051, </type> <institution> Computer Science Department, Texas A&M University, College Station, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: On the other hand, the proposed algorithm can stagger the checkpoints in any manner desired. Many variations are possible, depending on which checkpoints are desired to be staggered <ref> [12] </ref>. As an illustration, we assume that the objective is to stagger all checkpoints, i.e., no two checkpoints should overlap in time. Later, we will illustrate a situation where some overlap in checkpoint-ing is desired.
Reference: [13] <author> Y. M. Wang, Y. Huang, and W. K. Fuchs, </author> <title> "Progressive retry for software error recovery in distributed systems," </title> <booktitle> in 23 rd Int. Symp. Fault-Tolerant Comp., </booktitle> <pages> pp. 138-144, </pages> <year> 1993. </year>
Reference-contexts: Our algorithm staggers the checkpoints, while the scheme in [9] does not allow staggering. [9] also assumes synchronized communication and an upper bound on communication delays; no such assumptions are made in the proposed scheme. Wang et al. <ref> [13] </ref> introduced the term logical checkpoint. They present an algorithm to determine a recovery line consisting of consistent logical checkpoints, after a failure occurs. This recovery line is used to recover from the failure. <p> (on stable storage) all messages delivered to the process between time t 0 and t 1 . (For each message, the message log contains the receive sequence number for the message as well checkpoint as the entire message.) This approach is essentially identical to that presented by Wang et al. <ref> [13] </ref>. takes a physical checkpoint at time t 0 . Messages M1, M2 and M3 are delivered to process P by time t 1 . To establish a logical checkpoint of process P at time t 1 , messages M1, M2 and M3 are logged on the stable storage.
References-found: 13

