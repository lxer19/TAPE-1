URL: http://www.cs.cornell.edu/Info/People/praveen/papers/seq.sigmod94.ps.Z
Refering-URL: http://www.cs.cornell.edu/Info/People/praveen/papers.html
Root-URL: http://www.cs.brown.edu/
Email: fpraveen,miron,raghug@cs.wisc.edu.  
Title: Sequence Query Processing  
Author: Praveen Seshadri Miron Livny Raghu Ramakrishnan 
Address: WI 53706, U.S.A.  
Affiliation: Computer Sciences Department, University of Wisconsin-Madison,  
Abstract: Many applications require the ability to manipulate sequences of data. We motivate the importance of sequence query processing, and present a framework for the optimization of sequence queries based on several novel techniques. These include query transformations, optimizations that utilize meta-data, and caching of intermediate results. We present a bottom-up algorithm that generates an efficient query evaluation plan based on cost estimates. This work also identifies a number of directions in which future research can be directed. 
Abstract-found: 1
Intro-found: 1
Reference: [BR91] <author> Catriel Beeri and Raghu Ramakrishnan. </author> <title> On the power of Magic. </title> <journal> Journal of Logic Programming, </journal> 10(3&4):255-300, 1991. 
Reference-contexts: Transformations like the bidirectional propagation of span information are not common in relational systems. The magic rewriting optimization <ref> [BR91] </ref> and predicate pushdown which propagates selection predicates into sub-queries come close to the spirit of this kind of optimization.
Reference: [CC87] <author> James Clifford and Albert Croker. </author> <title> The historical data model and algebra based on lifespans. </title> <booktitle> In 11 Proceedings of the International Conference on Data Engineering, </booktitle> <pages> pages 528-537, </pages> <year> 1987. </year>
Reference-contexts: We refer the reader to [Soo91] for a bibliography of recent work. Most of the research has concentrated on temporal models and languages <ref> [Gad86, CC87, SS88, NA89, WD92, Sno87] </ref>. Much of this research has focused on extending existing data models to support temporal data, or extending existing query languages to allow temporal queries to be expressed. Typically, the relational (OO) model is extended by associating a "times-tamp" with each tuple (object).
Reference: [Day87] <author> Umeshwar Dayal. </author> <title> Of nests and trees: A unified approach to processing queries that contain nested sub-queries, aggregates and quantifiers. </title> <booktitle> In Proceedings of ACM SIGMOD '87 International Conference on Management of Data, </booktitle> <address> San Francisco, CA, </address> <pages> pages 23-33, </pages> <year> 1987. </year>
Reference-contexts: Such a feature could be added to our model. However, it can no longer be evaluated with a stream access using the techniques described here. The problems raised by correlation are very similar to the issues raised by correlated SQL queries that have been extensively studied <ref> [SPL, Day87, GW87, Kim82] </ref>. Using the model of sequence groupings though, it is possible to declaratively represent such queries.
Reference: [EWK90] <author> Ramez Elmasri, Gene Wuu, and Yeung-Joon Kim. </author> <title> The time index : An access structure for temporal data. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(V LDB), </booktitle> <pages> pages 1-12, </pages> <year> 1990. </year>
Reference-contexts: Finally, we have not addressed physical storage and access structure issues, and there have been a number of specialized access structures proposed for temporal data that are of relevance (eg. <ref> [EWK90, LS89, RS87] </ref>). 7 Conclusion We have presented a framework and an algorithm for optimizing sequence queries. Many of our optimization techniques rely upon the sequentiality of the data and query, and have no counterparts in the domain of relational databases.
Reference: [Gad86] <author> S.K. Gadia. </author> <title> Towards a multihomogenous model for a temporal database. </title> <booktitle> In Proceedings of the International Conference on Data Engineering, </booktitle> <pages> pages 390-397, </pages> <year> 1986. </year>
Reference-contexts: We refer the reader to [Soo91] for a bibliography of recent work. Most of the research has concentrated on temporal models and languages <ref> [Gad86, CC87, SS88, NA89, WD92, Sno87] </ref>. Much of this research has focused on extending existing data models to support temporal data, or extending existing query languages to allow temporal queries to be expressed. Typically, the relational (OO) model is extended by associating a "times-tamp" with each tuple (object).
Reference: [GHK92] <author> Sumit Ganguly, Waqar Hasan, and Ravi Krishna-murthy. </author> <title> Query optimization for parallel execution. </title> <booktitle> In Proceedings of ACM SIGMOD '92 International Conference on Management of Data, </booktitle> <address> San Diego, CA, </address> <pages> pages 9-18, </pages> <year> 1992. </year>
Reference-contexts: the block have been joined and there are two access plans generated corresponding to the cheapest ways of accessing the output sequence in stream and in probed modes. 4.1.4 Algorithmic Analysis The Selinger algorithm has been extensively studied and is known to generate the class of "left-deep tree" join plans. <ref> [GHK92] </ref> contains a detailed analysis of this algorithm. Our optimization algorithm too explores the class of left-deep query trees within each block. The entire query evaluation plan however is not restricted to be a left-deep tree because the graph may be bushy across query blocks.
Reference: [GJS92] <author> N.H Gehani, H.V. Jagadish, and O. Shmueli. </author> <title> Composite event specification in active databases: Model and implementation. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <pages> pages 327-338, </pages> <year> 1992. </year>
Reference-contexts: execution mon fl The work of Praveen Seshadri was supported by IBM Research Grant 93-F153900-000 y The work of Raghu Ramakrishnan was supported by a Packard Foundation Fellowship in Science and Engineering, a PYI Award with matching grants from DEC, Tandem and Xerox, and NSF grant IRI-9011563. itors, trigger mechanisms <ref> [GJS92] </ref>, and list processing systems [Ric92]. Example 1.1 Consider the following motivating example. A weather monitoring system records information about various meteorological phenomena. There is a se-quentiality in the occurrence of these phenomena; the various meteorological events are sequenced by the time at which they are recorded. <p> Definition 3.3 The effective scope of an operator over an input sequence IS is a function Ef f Scope IS such that for all positions i, Scope IS (i) Ef f Scope IS (i). 2 7 In certain domains in which input data records arrive dynamically (eg. <ref> [GJS92] </ref>), it is important to optimize the cost of processing each arriving input record. 8 The actual physical organization of a sequence can vary. <p> Our approach to sequences presented in this paper takes a strongly "positional" view of sequences, as opposed to the models mentioned above. In this aspect, it has been influenced by the model of Time Sequences in [SS87, SK86] Research into sequence data in contexts other than temporal data include <ref> [GJS92] </ref>, [Ric92], and [SP90]. [GJS92] presents techniques for expressing and evaluating pattern-match queries over a sequence of events. [Ric92] presents a model and operators for manipulating lists in a database. <p> In this aspect, it has been influenced by the model of Time Sequences in [SS87, SK86] Research into sequence data in contexts other than temporal data include <ref> [GJS92] </ref>, [Ric92], and [SP90]. [GJS92] presents techniques for expressing and evaluating pattern-match queries over a sequence of events. [Ric92] presents a model and operators for manipulating lists in a database.
Reference: [GS89a] <author> Himawan Gunadhi and Arie Segev. </author> <title> Event-join optimization in temporal relational databases. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Databases (VLDB), </booktitle> <address> Amsterdam, Netherlands, </address> <year> 1989. </year>
Reference-contexts: The "timestamp" represents the positions in time at which the tuple (object) was "true". The associated query language is extended with predicates that access the "timestamp" of the tuples (objects). There has been some work on query optimization based on such models <ref> [GS89a, LM93, NG93] </ref>. For instance [GS91, LM93] propose efficient stream access techniques of processing various types of temporal "joins", and [GS89b] proposes an optimization framework for temporal data based on such techniques.
Reference: [GS89b] <author> Himawan Gunadhi and Arie Segev. </author> <title> A framework for query optimization in temporal databases. </title> <booktitle> In Fifth International Conference on Statistical and Scientific Database Management Systems, </booktitle> <year> 1989. </year>
Reference-contexts: The associated query language is extended with predicates that access the "timestamp" of the tuples (objects). There has been some work on query optimization based on such models [GS89a, LM93, NG93]. For instance [GS91, LM93] propose efficient stream access techniques of processing various types of temporal "joins", and <ref> [GS89b] </ref> proposes an optimization framework for temporal data based on such techniques. Our approach to sequences presented in this paper takes a strongly "positional" view of sequences, as opposed to the models mentioned above. <p> Some of the optimization techniques used in this paper are similar to other proposals in the literature. For instance, our concept of operator caches is similar to the notion of "working-memory" in [LM93, SP90]. <ref> [GS89b] </ref> argues like we do that the kind of statistical information that needs to be maintained in a temporal database is significantly different from that maintained by relational systems. Transformations like the bidirectional propagation of span information are not common in relational systems.
Reference: [GS91] <author> Himawan Gunadhi and Arie Segev. </author> <title> Query processing algorithms for temporal intersection joins. </title> <booktitle> In Proceedings of the International Conference on Data Engineering, </booktitle> <year> 1991. </year>
Reference-contexts: The "timestamp" represents the positions in time at which the tuple (object) was "true". The associated query language is extended with predicates that access the "timestamp" of the tuples (objects). There has been some work on query optimization based on such models [GS89a, LM93, NG93]. For instance <ref> [GS91, LM93] </ref> propose efficient stream access techniques of processing various types of temporal "joins", and [GS89b] proposes an optimization framework for temporal data based on such techniques. Our approach to sequences presented in this paper takes a strongly "positional" view of sequences, as opposed to the models mentioned above.
Reference: [GW87] <author> Richard A. Ganski and Harry K.T. Wong. </author> <title> Optimization of nested sql queries revisited. </title> <booktitle> In Proceedings of ACM SIGMOD '87 International Conference on Management of Data, </booktitle> <address> San Francisco, CA, </address> <pages> pages 23-33, </pages> <year> 1987. </year>
Reference-contexts: Such a feature could be added to our model. However, it can no longer be evaluated with a stream access using the techniques described here. The problems raised by correlation are very similar to the issues raised by correlated SQL queries that have been extensively studied <ref> [SPL, Day87, GW87, Kim82] </ref>. Using the model of sequence groupings though, it is possible to declaratively represent such queries.
Reference: [JCG + 92] <author> C.S. Jensen, J. Clifford, S.K. Gadia, A. Segev, and R.T. Snodgrass. </author> <title> A glossary of temporal database concepts. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 21(3), </volume> <month> sep </month> <year> 1992. </year>
Reference-contexts: The knowledge of these relationships leads to operators that can "collapse" or "expand" a sequence from one ordering domain to another. For instance, this would allow a daily sequence to be treated as a weekly sequence so that a weekly average could be computed. Multiple Orderings: In bitemporal databases <ref> [JCG + 92] </ref>, a set of records is typically associated with transaction time as well as valid time orderings. In general, it is useful to be able to associate multiple orderings with the same set of records.
Reference: [Kim82] <author> W. Kim. </author> <title> On optimizing an sql-like nested query. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7, </volume> <month> Septem-ber </month> <year> 1982. </year>
Reference-contexts: Such a feature could be added to our model. However, it can no longer be evaluated with a stream access using the techniques described here. The problems raised by correlation are very similar to the issues raised by correlated SQL queries that have been extensively studied <ref> [SPL, Day87, GW87, Kim82] </ref>. Using the model of sequence groupings though, it is possible to declaratively represent such queries.
Reference: [LM93] <author> Cliff T.Y. Leung and Richard R. Muntz. </author> <title> Temporal Databases, Theory, Design and Implementation, </title> <type> chapter 14. </type> <institution> Benjamin/Cummings, </institution> <year> 1993. </year>
Reference-contexts: New operators are required that are based on the view of a sequence as a collection of records, each associated with a set of positions. The new operators include overlap-join, contain-join and precede-join <ref> [LM93] </ref>, as well as typical relational operators like cross-product that operate on the records. Ordering Domains: Instead of assuming that positions are integers, the existence of explicit ordering domains can be introduced. <p> The "timestamp" represents the positions in time at which the tuple (object) was "true". The associated query language is extended with predicates that access the "timestamp" of the tuples (objects). There has been some work on query optimization based on such models <ref> [GS89a, LM93, NG93] </ref>. For instance [GS91, LM93] propose efficient stream access techniques of processing various types of temporal "joins", and [GS89b] proposes an optimization framework for temporal data based on such techniques. <p> The "timestamp" represents the positions in time at which the tuple (object) was "true". The associated query language is extended with predicates that access the "timestamp" of the tuples (objects). There has been some work on query optimization based on such models [GS89a, LM93, NG93]. For instance <ref> [GS91, LM93] </ref> propose efficient stream access techniques of processing various types of temporal "joins", and [GS89b] proposes an optimization framework for temporal data based on such techniques. Our approach to sequences presented in this paper takes a strongly "positional" view of sequences, as opposed to the models mentioned above. <p> Some of the optimization techniques used in this paper are similar to other proposals in the literature. For instance, our concept of operator caches is similar to the notion of "working-memory" in <ref> [LM93, SP90] </ref>. [GS89b] argues like we do that the kind of statistical information that needs to be maintained in a temporal database is significantly different from that maintained by relational systems. Transformations like the bidirectional propagation of span information are not common in relational systems.
Reference: [LS89] <author> David Lomet and Betty Salzberg. </author> <title> Access methods for multiversion data. </title> <booktitle> In Proceedings of ACM SIG-MOD International COnference on Management of Data, </booktitle> <pages> pages 315-324, </pages> <year> 1989. </year>
Reference-contexts: Finally, we have not addressed physical storage and access structure issues, and there have been a number of specialized access structures proposed for temporal data that are of relevance (eg. <ref> [EWK90, LS89, RS87] </ref>). 7 Conclusion We have presented a framework and an algorithm for optimizing sequence queries. Many of our optimization techniques rely upon the sequentiality of the data and query, and have no counterparts in the domain of relational databases.
Reference: [NA89] <author> S.B. Navathe and R. Ahmed. </author> <title> A temporal relational model and a query language. </title> <journal> Information Sciences, </journal> <volume> 49 </volume> <pages> 147-175, </pages> <year> 1989. </year>
Reference-contexts: We refer the reader to [Soo91] for a bibliography of recent work. Most of the research has concentrated on temporal models and languages <ref> [Gad86, CC87, SS88, NA89, WD92, Sno87] </ref>. Much of this research has focused on extending existing data models to support temporal data, or extending existing query languages to allow temporal queries to be expressed. Typically, the relational (OO) model is extended by associating a "times-tamp" with each tuple (object).
Reference: [NG93] <author> Sunil S. Nair and Shashi K. Gadia. </author> <title> Algebraic optimization in a relational model for temporal databases. </title> <editor> In Richard Snodgrass, editor, </editor> <booktitle> Proceedings of the International Workshop on an Infrastructure for Temporal Databases, </booktitle> <pages> pages 390-397, </pages> <address> Arlington, Texas, </address> <year> 1993. </year>
Reference-contexts: The "timestamp" represents the positions in time at which the tuple (object) was "true". The associated query language is extended with predicates that access the "timestamp" of the tuples (objects). There has been some work on query optimization based on such models <ref> [GS89a, LM93, NG93] </ref>. For instance [GS91, LM93] propose efficient stream access techniques of processing various types of temporal "joins", and [GS89b] proposes an optimization framework for temporal data based on such techniques.
Reference: [Ric92] <author> Joel Richardson. </author> <title> Supporting lists in a data model. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: of Praveen Seshadri was supported by IBM Research Grant 93-F153900-000 y The work of Raghu Ramakrishnan was supported by a Packard Foundation Fellowship in Science and Engineering, a PYI Award with matching grants from DEC, Tandem and Xerox, and NSF grant IRI-9011563. itors, trigger mechanisms [GJS92], and list processing systems <ref> [Ric92] </ref>. Example 1.1 Consider the following motivating example. A weather monitoring system records information about various meteorological phenomena. There is a se-quentiality in the occurrence of these phenomena; the various meteorological events are sequenced by the time at which they are recorded. <p> In this aspect, it has been influenced by the model of Time Sequences in [SS87, SK86] Research into sequence data in contexts other than temporal data include [GJS92], <ref> [Ric92] </ref>, and [SP90]. [GJS92] presents techniques for expressing and evaluating pattern-match queries over a sequence of events. [Ric92] presents a model and operators for manipulating lists in a database. <p> In this aspect, it has been influenced by the model of Time Sequences in [SS87, SK86] Research into sequence data in contexts other than temporal data include [GJS92], <ref> [Ric92] </ref>, and [SP90]. [GJS92] presents techniques for expressing and evaluating pattern-match queries over a sequence of events. [Ric92] presents a model and operators for manipulating lists in a database.
Reference: [RS87] <author> Doron Rotem and Arie Segev. </author> <title> Physical organization of temporal data. </title> <booktitle> In Proceedings of the International Conference on Data Engineering, </booktitle> <pages> pages 547-553, </pages> <year> 1987. </year>
Reference-contexts: Finally, we have not addressed physical storage and access structure issues, and there have been a number of specialized access structures proposed for temporal data that are of relevance (eg. <ref> [EWK90, LS89, RS87] </ref>). 7 Conclusion We have presented a framework and an algorithm for optimizing sequence queries. Many of our optimization techniques rely upon the sequentiality of the data and query, and have no counterparts in the domain of relational databases.
Reference: [SK86] <author> Arie Shoshani and Kyoji Kawagoe. </author> <title> Temporal data management. </title> <booktitle> In Proceedings of the Twelfth International Conference on Very Large Databases (VLDB), </booktitle> <address> Kyoto, Japan, </address> <pages> pages 79-88, </pages> <year> 1986. </year>
Reference-contexts: Section 4 integrates the various optimizations into the framework of a single optimization algorithm. For base sequences, the following kinds of meta-information may be available in the underlying physical sequence representation 3 : 3 These are similar to the properties associated with a Time Sequence in <ref> [SS87, SK86] </ref> Sequence Span Density IBM 200 .. 500 0.95 HP 1 .. 750 1.0 Table 1: Example Sequence Data * A start and end position that determine the valid range or span of the sequence. <p> Our approach to sequences presented in this paper takes a strongly "positional" view of sequences, as opposed to the models mentioned above. In this aspect, it has been influenced by the model of Time Sequences in <ref> [SS87, SK86] </ref> Research into sequence data in contexts other than temporal data include [GJS92], [Ric92], and [SP90]. [GJS92] presents techniques for expressing and evaluating pattern-match queries over a sequence of events. [Ric92] presents a model and operators for manipulating lists in a database.
Reference: [SLR] <author> Praveen Seshadri, Miron Livny, and Raghu Ramakr-ishnan. Seq: </author> <title> A framework for sequence databases. </title> <note> Submitted for publication. </note>
Reference-contexts: The key to such optimization is the sequentiality of the data and the query. 2 Sequence Model In this paper, we use a simple model of sequences and a set of query operators. A more comprehensive model of sequences is under development <ref> [SLR] </ref>. A record schema R is defined as R = &lt; A 1 :T 1 , ... , A N :T N &gt; for some finite N. Each of the T i s are indivisible atomic types of fixed size, and each A i is a named attribute. <p> We are currently extending the model to capture a much broader class of sequence databases <ref> [SLR] </ref>. In this section, we briefly describe some of the directions in which the model is being extended, and the corresponding extensions needed to the optimization framework. <p> While our paper does not directly cover such issues, the broader model that we are currently developing <ref> [SLR] </ref> does cover some of these aspects of sequence query processing. [SP90] studies stream processing techniques using a logic language as the underlying data engine. While the emphasis was not on a cost-based query optimization for sequence queries in the database context, the emphasis on stream processing is similar.
Reference: [SMALP79] <author> Patricia G. Selinger, D. Chamberlin M. Astrahan, Raymond Lorie, and T. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proceedings of ACM SIGMOD '79 International Conference on Management of Data, </booktitle> <pages> pages 23-34, </pages> <year> 1979. </year>
Reference-contexts: A conventional relational query optimizer as described in <ref> [SMALP79] </ref> would probably generate the following query evaluation plan. For every Volcano tuple in the outer query, the sub-query would be invoked to find the time of the most recent earthquake. Each such access to the subquery involves an aggregate over the entire Earthquake relation. <p> the root of the graph is reached, the most efficient stream access query evaluation plan for the entire query is selected. 4.1 Plan Generation Algorithm The approach taken to generate a plan for each block is similar in spirit to the plan generation algorithm for SQL query blocks described in <ref> [SMALP79] </ref>, which we will refer to as the Selinger algorithm. A brief explanation of the Selinger algorithm is in order.
Reference: [Sno87] <author> Richard Snodgrass. </author> <title> The temporal query language tquel. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 247-298, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: We refer the reader to [Soo91] for a bibliography of recent work. Most of the research has concentrated on temporal models and languages <ref> [Gad86, CC87, SS88, NA89, WD92, Sno87] </ref>. Much of this research has focused on extending existing data models to support temporal data, or extending existing query languages to allow temporal queries to be expressed. Typically, the relational (OO) model is extended by associating a "times-tamp" with each tuple (object).
Reference: [Soo91] <author> Michael D. Soo. </author> <title> Bibliography on temporal databases. </title> <journal> ACM SIGMOD Record, </journal> <volume> 20(1) </volume> <pages> 14-23, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: We refer the reader to <ref> [Soo91] </ref> for a bibliography of recent work. Most of the research has concentrated on temporal models and languages [Gad86, CC87, SS88, NA89, WD92, Sno87].
Reference: [SP90] <author> D. Stott Parker. </author> <title> Stream Data Analysis in Prolog, chapter 8. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In this aspect, it has been influenced by the model of Time Sequences in [SS87, SK86] Research into sequence data in contexts other than temporal data include [GJS92], [Ric92], and <ref> [SP90] </ref>. [GJS92] presents techniques for expressing and evaluating pattern-match queries over a sequence of events. [Ric92] presents a model and operators for manipulating lists in a database. <p> While our paper does not directly cover such issues, the broader model that we are currently developing [SLR] does cover some of these aspects of sequence query processing. <ref> [SP90] </ref> studies stream processing techniques using a logic language as the underlying data engine. While the emphasis was not on a cost-based query optimization for sequence queries in the database context, the emphasis on stream processing is similar. <p> Some of the optimization techniques used in this paper are similar to other proposals in the literature. For instance, our concept of operator caches is similar to the notion of "working-memory" in <ref> [LM93, SP90] </ref>. [GS89b] argues like we do that the kind of statistical information that needs to be maintained in a temporal database is significantly different from that maintained by relational systems. Transformations like the bidirectional propagation of span information are not common in relational systems.
Reference: [SPL] <author> Praveen Seshadri, Hamid Pirahesh, and Cliff Leung. </author> <title> Decorrelating complex queries. </title> <note> Submitted for Publication. </note>
Reference-contexts: Such a feature could be added to our model. However, it can no longer be evaluated with a stream access using the techniques described here. The problems raised by correlation are very similar to the issues raised by correlated SQL queries that have been extensively studied <ref> [SPL, Day87, GW87, Kim82] </ref>. Using the model of sequence groupings though, it is possible to declaratively represent such queries.
Reference: [SS87] <author> Arie Segev and Arie Shoshani. </author> <title> Logical modelling of temporal data. </title> <booktitle> In Proceedings of ACM SIGMOD '87 International Conference on Management of Data, </booktitle> <address> San Francisco, CA, </address> <pages> pages 454-466, </pages> <year> 1987. </year>
Reference-contexts: Section 4 integrates the various optimizations into the framework of a single optimization algorithm. For base sequences, the following kinds of meta-information may be available in the underlying physical sequence representation 3 : 3 These are similar to the properties associated with a Time Sequence in <ref> [SS87, SK86] </ref> Sequence Span Density IBM 200 .. 500 0.95 HP 1 .. 750 1.0 Table 1: Example Sequence Data * A start and end position that determine the valid range or span of the sequence. <p> Our approach to sequences presented in this paper takes a strongly "positional" view of sequences, as opposed to the models mentioned above. In this aspect, it has been influenced by the model of Time Sequences in <ref> [SS87, SK86] </ref> Research into sequence data in contexts other than temporal data include [GJS92], [Ric92], and [SP90]. [GJS92] presents techniques for expressing and evaluating pattern-match queries over a sequence of events. [Ric92] presents a model and operators for manipulating lists in a database.
Reference: [SS88] <author> Arie Segev and Arie Shoshani. </author> <title> The representation of a temporal data model in the relational environment. </title> <booktitle> In Proceedings of the 4th Conference on Statistical and Scientific Database Management, </booktitle> <pages> pages 39-61, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: We refer the reader to [Soo91] for a bibliography of recent work. Most of the research has concentrated on temporal models and languages <ref> [Gad86, CC87, SS88, NA89, WD92, Sno87] </ref>. Much of this research has focused on extending existing data models to support temporal data, or extending existing query languages to allow temporal queries to be expressed. Typically, the relational (OO) model is extended by associating a "times-tamp" with each tuple (object).
Reference: [WD92] <author> Gene Wuu and Umeshwar Dayal. </author> <title> A uniform model for temporal object-oriented databases. </title> <booktitle> In Proceedings of the International Conference on Data Engineering, </booktitle> <year> 1992. </year> <month> 12 </month>
Reference-contexts: We refer the reader to [Soo91] for a bibliography of recent work. Most of the research has concentrated on temporal models and languages <ref> [Gad86, CC87, SS88, NA89, WD92, Sno87] </ref>. Much of this research has focused on extending existing data models to support temporal data, or extending existing query languages to allow temporal queries to be expressed. Typically, the relational (OO) model is extended by associating a "times-tamp" with each tuple (object).
References-found: 29

