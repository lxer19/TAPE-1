URL: ftp://ftp.cs.brown.edu/pub/techreports/95/cs95-06.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-95-06.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> L Bergman, H. Fuchs, E. Grant, and S. Spach. </author> <title> Image rendering by adaptive refinement. </title> <booktitle> Computer Graphics (SIGGRAPH '86 Proceedings), </booktitle> <volume> 20(4) </volume> <pages> 29-37, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: In addition, some display technologies, particularly CRT designs, refresh their pixels sequentially in effect, they update pixels a frame at a time, therefore disabling truly frameless rendering anyhow. 2.2 Adaptive Refinement Practically frameless rendering is also an adaptive refinement <ref> [1] </ref> technique. As such, it is limited because for static images it converges on the final rendering in only four iterations (although Section 6 shows how to extend it to possibly use nine or sixteen iterations).
Reference: [2] <author> Gary Bishop, Henry Fuchs, Leonard McMillan, and Ellen J. Scher Zagier. </author> <title> Frameless rendering: Double buffering considered harmful. </title> <editor> In Andrew Glassner, editor, </editor> <booktitle> Proceedings of SIGGRAPH '94 (Orlando, </booktitle> <address> Florida, </address> <month> July 24-29, </month> <year> 1994), </year> <booktitle> Computer Graphics Proceedings, Annual Conference Series, </booktitle> <pages> pages 175-176. </pages> <publisher> ACM SIGGRAPH, ACM Press, </publisher> <month> July </month> <year> 1994. </year> <note> ISBN 0-89791-667-0. </note>
Reference-contexts: In addition, the technique produces an approximate motion blur at no additional cost. However, it also affects image quality (see Figure 1). We call this new technique practically frameless rendering. It applies ideas from frameless rendering <ref> [2] </ref> to scan-conversion renderers, thus making frameless rendering practical. Nonetheless, our new technique maintains discrete frames, i.e., strictly speaking it is not frameless. 1.1 Benefits and Drawbacks Practically frameless rendering has many advantages. Most notably, it sharply increases frame-rate (see Section 4). <p> Section 5 explores several variations of the new algorithm. Finally, in Section 6 we discuss our contribution as well as possible future work. 2 Related Work 2.1 Frameless Rendering Frameless rendering <ref> [2] </ref> proposes to shorten overall lag by banishing double-buffering. To avoid display artifacts such as image tearing, the authors propose a randomized sampling scheme to update individual pixels.
Reference: [3] <author> Bay-Wei Chang and David Ungar. </author> <title> Animation: From cartoons to the user interface. </title> <booktitle> UIST Proceedings, </booktitle> <pages> pages 45-55, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Ultimately, user studies must ensure that we are not comparing apples to oranges. Our new rendering technique also introduces visual artifacts (see to scenes is in general desirable [15] <ref> [3] </ref>, it used to be reserved for non-interactive tasks because motion blur algorithms historically incur high overhead. Real-time algorithms for use in interactive 3D applications are only a recent development [15] [11]. While those motion blur algorithms induce only a small overhead, rendering without blur is nonetheless faster. <p> Since practically frameless rendering applies equally to 2D rendering, 2D user interfaces in particular benefit from the produced motion blur and image fades <ref> [3] </ref>. While previous work already implements these ideas [3], practically frameless rendering provides these effects for free, i.e., the programmer need not explicitly specify them. 1.2 Overview The remainder of this paper is structured as follows. <p> Since practically frameless rendering applies equally to 2D rendering, 2D user interfaces in particular benefit from the produced motion blur and image fades <ref> [3] </ref>. While previous work already implements these ideas [3], practically frameless rendering provides these effects for free, i.e., the programmer need not explicitly specify them. 1.2 Overview The remainder of this paper is structured as follows. Section 2 relates practically frameless rendering to previous work in frame-less rendering, adaptive refinement, and motion blur.
Reference: [4] <author> Robert L. Cook, Thomas Porter, and Loren Carpenter. </author> <title> Distributed ray tracing. </title> <booktitle> Computer Graphics (SIGGRAPH '84 Proceedings), </booktitle> <volume> 18(3) </volume> <pages> 137-145, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Motion blurring techniques roughly fall into three classes: non-real-time, 2D, and real-time 3D solutions. First, non-real-time solutions <ref> [4] </ref> [5] create beautiful images of motion blur. However, their excessive use of compute time disqualifies their use in interactive applications. Since practically frameless rendering strictly applies to highly interactive applications, the respective visual results are incomparable.
Reference: [5] <author> Mark A. Z. Dippe and Erling Henry Wold. </author> <title> Antialiasing through stochastic sampling. </title> <booktitle> Computer Graphics (SIG-GRAPH '85 Proceedings), </booktitle> <volume> 19(3) </volume> <pages> 69-78, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: Motion blurring techniques roughly fall into three classes: non-real-time, 2D, and real-time 3D solutions. First, non-real-time solutions [4] <ref> [5] </ref> create beautiful images of motion blur. However, their excessive use of compute time disqualifies their use in interactive applications. Since practically frameless rendering strictly applies to highly interactive applications, the respective visual results are incomparable. <p> Since each sample each uses one fourth of the display's pixels, all samples have the same weight. Therefore, we emulate a temporal box-filter <ref> [5] </ref>. Other temporal filters, for example, ramp filters, generally produce visually more pleasing results. To experiment with different temporal filters, we change the original implementation of practically frameless rendering.
Reference: [6] <author> Paul Haeberli and Kurt Akeley. </author> <title> The accumulation buffer: Hardware support for high-quality rendering. </title> <booktitle> Computer Graphics (SIGGRAPH '90 Proceedings), </booktitle> <volume> 24(4) </volume> <pages> 309-318, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Thus, their implementation usually cannot take advantage of today's high-performance rendering architectures and therefore, they are also inapplicable in highly interactive settings. Again, we thus feel that the visual results are incomparable. Third and last, real-time 3D solutions [15] <ref> [6] </ref> are fast enough for the highly interactive domain where practically frameless rendering applies. The quality of the blur generated by practically frameless rendering is inferior to those techniques (in particular for fast moving objects, see Figure 2).
Reference: [7] <author> Richard Held and Nathaniel Durlach. Telepresence, </author> <title> time delay and adaptation. </title> <editor> In Stephen R. Ellis, editor, </editor> <title> Pictorial Communication in Virtual and Real Environments, </title> <note> chapter 14. </note> <author> Taylor and Francis, </author> <year> 1991. </year>
Reference-contexts: Nonetheless, our new technique maintains discrete frames, i.e., strictly speaking it is not frameless. 1.1 Benefits and Drawbacks Practically frameless rendering has many advantages. Most notably, it sharply increases frame-rate (see Section 4). The increased frame-rate in turn reduces end-to-end lag [14], thus making applications more usable <ref> [7] </ref> [10]. More important, increasing frame-rate in head-mounted displays beyond a certain threshold (typically around 10 frames per second) boosts user performance dramatically for certain tasks [10]. fl Box 1910, Department of Computer Science, Brown University, Providence, RI 02912. Phone: (401) 863-7600, email: fmmw|bcz|tsmg@cs.brown.edu.
Reference: [8] <author> Steven W. Hiatt, </author> <title> editor. Graphics Library Programming Guide Document Number 007-1210-060. Silicon Graphics, </title> <publisher> Inc., </publisher> <address> Mountain View, CA, </address> <year> 1992. </year>
Reference-contexts: In addition, our performance tests described in Section 4 confirm these numbers. 4 Software Implementations and Performance Since we cannot directly modify our hardware renderers, we implement the frame-buffer-to-display mapping shown in Figure 3 in software. We describe two such implementations. The first uses the rectcopy and stenciling features <ref> [8] </ref> of the SGI RealityEngine2. The second one alters a high-performance software z-buffer to produce images at different resolutions. 4.1 RealityEngine2 Implementation The following three steps implement practically frameless rendering on our SGI Onyx with a RealityEngine2.
Reference: [9] <author> J. Korein and N. Badler. </author> <title> Temporal anti-aliasing in computer generated animation. </title> <booktitle> Computer Graphics (SIGGRAPH '83 Proceedings), </booktitle> <volume> 17(3) </volume> <pages> 377-388, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: First, non-real-time solutions [4] [5] create beautiful images of motion blur. However, their excessive use of compute time disqualifies their use in interactive applications. Since practically frameless rendering strictly applies to highly interactive applications, the respective visual results are incomparable. Second, while 2D solutions <ref> [9] </ref> [11] are more efficient than the non-real-time solutions, they usually rely on direct access to the 2D image bitmap. Thus, their implementation usually cannot take advantage of today's high-performance rendering architectures and therefore, they are also inapplicable in highly interactive settings.
Reference: [10] <author> Andrew Liu, Gregory Tharp, Lloyd French, Stephen Lai, and Lawrence Stark. </author> <title> Some of what one needs to know about using head-mounted displays to improve teleoperator performance. </title> <journal> IEEE Transactions on Robotics and Automation, </journal> <volume> 9(5) </volume> <pages> 638-648, </pages> <year> 1993. </year>
Reference-contexts: Nonetheless, our new technique maintains discrete frames, i.e., strictly speaking it is not frameless. 1.1 Benefits and Drawbacks Practically frameless rendering has many advantages. Most notably, it sharply increases frame-rate (see Section 4). The increased frame-rate in turn reduces end-to-end lag [14], thus making applications more usable [7] <ref> [10] </ref>. More important, increasing frame-rate in head-mounted displays beyond a certain threshold (typically around 10 frames per second) boosts user performance dramatically for certain tasks [10]. fl Box 1910, Department of Computer Science, Brown University, Providence, RI 02912. Phone: (401) 863-7600, email: fmmw|bcz|tsmg@cs.brown.edu. <p> Most notably, it sharply increases frame-rate (see Section 4). The increased frame-rate in turn reduces end-to-end lag [14], thus making applications more usable [7] <ref> [10] </ref>. More important, increasing frame-rate in head-mounted displays beyond a certain threshold (typically around 10 frames per second) boosts user performance dramatically for certain tasks [10]. fl Box 1910, Department of Computer Science, Brown University, Providence, RI 02912. Phone: (401) 863-7600, email: fmmw|bcz|tsmg@cs.brown.edu.
Reference: [11] <editor> Nelson Max. Polygon-based post-process motion blur. </editor> <booktitle> The Visual Computer, </booktitle> <volume> 6(6) </volume> <pages> 308-314, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Our new rendering technique also introduces visual artifacts (see to scenes is in general desirable [15] [3], it used to be reserved for non-interactive tasks because motion blur algorithms historically incur high overhead. Real-time algorithms for use in interactive 3D applications are only a recent development [15] <ref> [11] </ref>. While those motion blur algorithms induce only a small overhead, rendering without blur is nonetheless faster. In contrast, practically frameless rendering generates motion blur while boosting performance at the same time. <p> First, non-real-time solutions [4] [5] create beautiful images of motion blur. However, their excessive use of compute time disqualifies their use in interactive applications. Since practically frameless rendering strictly applies to highly interactive applications, the respective visual results are incomparable. Second, while 2D solutions [9] <ref> [11] </ref> are more efficient than the non-real-time solutions, they usually rely on direct access to the 2D image bitmap. Thus, their implementation usually cannot take advantage of today's high-performance rendering architectures and therefore, they are also inapplicable in highly interactive settings.
Reference: [12] <author> John Rohlf and James Helman. IRIS performer: </author> <title> A high performance multiprocessing toolkit for real-time 3d graphics. </title> <editor> In Andrew Glassner, editor, </editor> <booktitle> Proceedings of SIGGRAPH '94 (Or-lando, </booktitle> <address> Florida, </address> <month> July 24-29, </month> <year> 1994), </year> <booktitle> Computer Graphics Proceedings, Annual Conference Series, </booktitle> <pages> pages 381-394. </pages> <publisher> ACM SIGGRAPH, ACM Press, </publisher> <month> July </month> <year> 1994. </year> <note> ISBN 0-89791-667-0. </note>
Reference-contexts: Previous techniques must simulate such a fade either by morphing object shapes or by simultaneously rendering the object semi-transparently both at the lower level of detail as well as at the higher one <ref> [12] </ref>; thus, previous techniques always incur extra overhead when switching levels of detail whereas practically frameless rendering does not. Since practically frameless rendering applies equally to 2D rendering, 2D user interfaces in particular benefit from the produced motion blur and image fades [3].
Reference: [13] <author> Andrei State, Jonathan McAllister, Ulrich Neumann, Hong Chen, Tim J. Cullip, David T. Chen, and Henry Fuchs. </author> <title> Interactive volume visualization on a heterogeneous message-passing multicomputer. </title> <booktitle> In 1995 Symposium on Interactive 3D Graphics, </booktitle> <year> 1995. </year> <note> To be published. </note>
Reference-contexts: To avoid display artifacts such as image tearing, the authors propose a randomized sampling scheme to update individual pixels. Such a scheme integrates well with ray-tracers <ref> [13] </ref>, but makes frameless rendering inapplicable to current polygon renderers, i.e., useless for today's high-performance rendering architectures. In contrast, practically frameless rendering takes advantage of spatial coherency and thus specifically applies to scan-converting z-buffer engines.
Reference: [14] <author> Matthias M. Wloka. </author> <title> Lag in multiprocessor virtual reality. Presence, </title> <type> 4(1), </type> <year> 1994. </year>
Reference-contexts: Nonetheless, our new technique maintains discrete frames, i.e., strictly speaking it is not frameless. 1.1 Benefits and Drawbacks Practically frameless rendering has many advantages. Most notably, it sharply increases frame-rate (see Section 4). The increased frame-rate in turn reduces end-to-end lag <ref> [14] </ref>, thus making applications more usable [7] [10]. More important, increasing frame-rate in head-mounted displays beyond a certain threshold (typically around 10 frames per second) boosts user performance dramatically for certain tasks [10]. fl Box 1910, Department of Computer Science, Brown University, Providence, RI 02912. Phone: (401) 863-7600, email: fmmw|bcz|tsmg@cs.brown.edu.
Reference: [15] <author> Matthias M. Wloka and Robert C. Zeleznik. </author> <title> Interactive real-time motion blur. </title> <editor> In Michael Gigante, editor, </editor> <title> Insight through Computer Graphics: </title> <booktitle> Proceedings of CGI'94, </booktitle> <pages> page 83. </pages> <publisher> World Scientific, </publisher> <year> 1994. </year> <title> Abstracts Picture Room Picture Campus Picture Cube Picture Txplane Picture Teapot Picture </title>
Reference-contexts: Ultimately, user studies must ensure that we are not comparing apples to oranges. Our new rendering technique also introduces visual artifacts (see to scenes is in general desirable <ref> [15] </ref> [3], it used to be reserved for non-interactive tasks because motion blur algorithms historically incur high overhead. Real-time algorithms for use in interactive 3D applications are only a recent development [15] [11]. While those motion blur algorithms induce only a small overhead, rendering without blur is nonetheless faster. <p> Our new rendering technique also introduces visual artifacts (see to scenes is in general desirable <ref> [15] </ref> [3], it used to be reserved for non-interactive tasks because motion blur algorithms historically incur high overhead. Real-time algorithms for use in interactive 3D applications are only a recent development [15] [11]. While those motion blur algorithms induce only a small overhead, rendering without blur is nonetheless faster. In contrast, practically frameless rendering generates motion blur while boosting performance at the same time. <p> Thus, their implementation usually cannot take advantage of today's high-performance rendering architectures and therefore, they are also inapplicable in highly interactive settings. Again, we thus feel that the visual results are incomparable. Third and last, real-time 3D solutions <ref> [15] </ref> [6] are fast enough for the highly interactive domain where practically frameless rendering applies. The quality of the blur generated by practically frameless rendering is inferior to those techniques (in particular for fast moving objects, see Figure 2).
References-found: 15

