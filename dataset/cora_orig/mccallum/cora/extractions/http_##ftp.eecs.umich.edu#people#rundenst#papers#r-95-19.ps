URL: http://ftp.eecs.umich.edu/people/rundenst/papers/r-95-19.ps
Refering-URL: http://ftp.eecs.umich.edu/people/rundenst/papers/
Root-URL: http://www.eecs.umich.edu
Email: e-mail: ygra@eecs.umich.edu, rundenst@eecs.umich.edu  
Title: Towards Supporting Hard Schema Changes in TSE  
Author: Young-Gook Ra and Elke A. Rundensteiner 
Address: Ann Arbor, MI 48109-2122  
Affiliation: Dept. of Elec. Eng. and Computer Science, Software Systems Research Lab. The University of Michigan,  
Abstract: Simulating schema evolution using views offers many advantages over the direct modification of the schema. However, this view approach towards transparent schema evolution has not yet been implemented. One reason for this may be that views can't simulate capacity-augmenting schema changes due to the inherent limitation of view mechanisms that do not augment the underlying schema. One potential solution for this problem is to develop capacity-augmenting view support. However, existing OO view mechanisms do currently not support this capacity-augmenting feature. This paper thus proposes an alternative, more practical, solution to this problem. This solution is neither confined to object-preserving schema changes nor requires capacity-augmenting views. Note that our proposed solution is the first to also support hard changes such as converting values into an object, splitting two classes vertically, etc., in a transparent fashion. We demonstrate the feasibility of our solution by presenting general algorithms for hard schema changes as well as primitive ones. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Banerjee, W. Kim, H. J. Kim, and H. F. Ko-rth. </author> <title> Semantics and impl. of schema evolution in OODBs. </title> <booktitle> SIGMOD, </booktitle> <pages> pp. 311-322, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Schema evolution has been recognized as a very important functionality of OODBs required by many advanced engineering and scientific applications <ref> [1, 7, 12, 4, 13] </ref>. In spite of schema evolution support provided by most OODBs, schema updates on shared databases remain problematic. This is because in a shared-user environment, a desired schema change is likely to impact other programs. <p> In fact, we show that our TSE approach can transparently achieve complex schema changes that cause drastic changes to the schema and require major restructuring of the underlying object instances. Such changes have been called hard changes by W. Kim <ref> [1] </ref>, in contrast to the soft changes currently supported by OODBs. Previous schema evolution work that we are aware of has focused on support for soft changes. <p> When the clause "type extent to query" is present, the values of object identifiers are updated. 4 Hard Schema Change Operators 4.1 Introduction The taxonomy of base schema evolution operators first introduced by Banerjee et al. <ref> [1] </ref> for Orion has been adopted in most other schema evolution research and commercial OODBs [11, 3, 7]. To demonstrate the feasibility of TSE, it is thus important to show that our approach can realize this set of schema change operations in a transparent fashion.
Reference: [2] <author> E. Bertino. </author> <title> A view mechanism for OODBs. </title> <booktitle> EDBT, </booktitle> <pages> pp. 136-151, </pages> <year> 1992. </year>
Reference-contexts: In addition, updates on instances of a version are not propagated to the instances (duplicates representing the same object) of another version though sometimes explicit propagating operations can be provided. The use of view mechanisms to achieve schema evolution has also been advocated by other researchers <ref> [12, 10, 2] </ref>, however previous works have neither carried out a full development of such technology nor built a working system. In our earlier work of TSE [8], we explored the use of capacity-augmenting view mechanisms. In this paper, we propose an alternative more practical solution. <p> They indicate that certain schema evolutions can't be simulated using views because they are capacity-augmenting. However, such schema evolution operations tend to be important for changing database requirements this is a problem that we address in this paper. Bertino <ref> [2] </ref> indicates that view mechanisms, if capacity-augmenting, can be utilized to simulate schema evolution. But, her work is focused on individual classes rather than whole schemas. Zdonik et al. [11] keep different versions of each type, and objects of different versions can be accessed via exception handlers.
Reference: [3] <author> H. J. Kim. </author> <title> Issues in OODB. </title> <type> PhD thesis, </type> <institution> Univ. of Texas at Austin, </institution> <year> 1988. </year>
Reference-contexts: This proposed approach is currently being realized in the Transparent Schema Evolution (TSE) [8] system, which is being built using the MultiView system [9, 6] and the Gemstone OODB. This feature of transparency is partially supported in some schema version systems <ref> [4, 3] </ref>, because old schemas are maintained with their own instances. However, unlike this work, our TSE tool allows users to perform schema modifications within the context of a customized user's view schema. <p> the clause "type extent to query" is present, the values of object identifiers are updated. 4 Hard Schema Change Operators 4.1 Introduction The taxonomy of base schema evolution operators first introduced by Banerjee et al. [1] for Orion has been adopted in most other schema evolution research and commercial OODBs <ref> [11, 3, 7] </ref>. To demonstrate the feasibility of TSE, it is thus important to show that our approach can realize this set of schema change operations in a transparent fashion. In addition to handling transparently these primitive (soft) schema evolution operators, TSE also supports several complex operators called hard changes. <p> Every instance object of an old schema version can be copied and converted to become an instance of the new version. Thus, object instances are not truly shared among the different schema versions, and back propagation of updates to old versions are not allowed. Kim et al. <ref> [3] </ref> propose the versioning of individual classes instead of the entire schema. This gives flexibility to the user in constructing many schemas from class versions, but it also results in the overhead of figuring out whether a given schema is consistent.
Reference: [4] <author> W. Kim and H. Chou. </author> <title> Versions of schema for OODBs. </title> <booktitle> 14th VLDB, </booktitle> <pages> pp. 148-159, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Schema evolution has been recognized as a very important functionality of OODBs required by many advanced engineering and scientific applications <ref> [1, 7, 12, 4, 13] </ref>. In spite of schema evolution support provided by most OODBs, schema updates on shared databases remain problematic. This is because in a shared-user environment, a desired schema change is likely to impact other programs. <p> This proposed approach is currently being realized in the Transparent Schema Evolution (TSE) [8] system, which is being built using the MultiView system [9, 6] and the Gemstone OODB. This feature of transparency is partially supported in some schema version systems <ref> [4, 3] </ref>, because old schemas are maintained with their own instances. However, unlike this work, our TSE tool allows users to perform schema modifications within the context of a customized user's view schema. <p> Zdonik et al. [11] keep different versions of each type, and objects of different versions can be accessed via exception handlers. However, it is both labor-intensive as well as difficult to provide semantically meaningful exception handlers. The schema version mechanism proposed for Orion <ref> [4] </ref> keeps versions of the whole schema hierarchy instead of the individual classes or types. Every instance object of an old schema version can be copied and converted to become an instance of the new version.
Reference: [5] <author> H. A. Kuno, Y. G. Ra, and E. A. Rundensteiner. </author> <title> The object-slicing technique: A flexible object rep. and its evaluation. </title> <type> Tech. Rep. </type> <institution> CSE-TR-241-95, Univ. of Mich., </institution> <year> 1995. </year>
Reference-contexts: In contrast to prior work, our revised TSE approach is neither confined to soft (or capacity-preserving) schema changes nor requires a view mechanism that supports capacity-augmenting virtual classes [8]. Our experiments have shown that the later is hard to achieve in an efficient manner <ref> [5] </ref>; and in fact, no commercial OODB system currently supports such features 1 . For this reason, we found it important to explore an alternative solution to this problem that does not rely on such powerful view support. <p> This problem can be solved by providing a capacity-augmenting view mechanism, as we explored in our earlier work of TSE [8]. However, our experimental evaluation has shown that capacity-augmenting views are hard to implement in an efficient manner <ref> [5] </ref>. For this reason, we now propose 2 The capacity of a schema is defined as a set of possible states of the database under the schema.
Reference: [6] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Materialized Object-Oriented Views in MultiView. </title> <booktitle> RIDE Workshop, </booktitle> <pages> pp. 78-85, </pages> <month> March, </month> <year> 1995. </year>
Reference-contexts: This proposed approach is currently being realized in the Transparent Schema Evolution (TSE) [8] system, which is being built using the MultiView system <ref> [9, 6] </ref> and the Gemstone OODB. This feature of transparency is partially supported in some schema version systems [4, 3], because old schemas are maintained with their own instances. <p> We have chosen to implement the TSE approach on top of the MultiView system <ref> [9, 6] </ref>. Unlike most other OO view mechanisms, MultiView creates a complete view schema rather than just deriving individual virtual classes and supports automatic classification. Since TSE is built using MultiView, we utilize Mul-tiView's view definition language, an object algebra [9], for the virtual class generation task of TSE.
Reference: [7] <author> S. Monk and I. Sommerville. </author> <title> Schema evolution in OODBs using class versioning. </title> <booktitle> SIGMOD RECORD, </booktitle> <volume> VOL. 22, NO.3, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Schema evolution has been recognized as a very important functionality of OODBs required by many advanced engineering and scientific applications <ref> [1, 7, 12, 4, 13] </ref>. In spite of schema evolution support provided by most OODBs, schema updates on shared databases remain problematic. This is because in a shared-user environment, a desired schema change is likely to impact other programs. <p> the clause "type extent to query" is present, the values of object identifiers are updated. 4 Hard Schema Change Operators 4.1 Introduction The taxonomy of base schema evolution operators first introduced by Banerjee et al. [1] for Orion has been adopted in most other schema evolution research and commercial OODBs <ref> [11, 3, 7] </ref>. To demonstrate the feasibility of TSE, it is thus important to show that our approach can realize this set of schema change operations in a transparent fashion. In addition to handling transparently these primitive (soft) schema evolution operators, TSE also supports several complex operators called hard changes. <p> Kim et al. [3] propose the versioning of individual classes instead of the entire schema. This gives flexibility to the user in constructing many schemas from class versions, but it also results in the overhead of figuring out whether a given schema is consistent. The class versioning approach CLOSQL <ref> [7] </ref> provides update/backdate functions for each attribute which converts the instances from the format in which the instance is stored to the format that an application program expects. <p> We have demonstrated the feasibility of our TSE approach, without requiring capacity-augmenting view technology, on a comprehensive set of schema evolution operators, i.e., those soft ones typically supported by OODBs <ref> [11, 7, 13] </ref> as well as hard changes that require more extensive instance restructuring. Examples are partitioning a class vertically, that requires all instances of the class are also partitioned into new instances.
Reference: [8] <author> Y. G. Ra and E. A. Rundensteiner. </author> <title> A transparent object-oriented schema change approach using view schema evolution. </title> <booktitle> ICDE, </booktitle> <pages> pp. 165-172, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Also thanks to industrial sponsors, including Intel, AT&T, and IBM. while the old one is maintained by the system to assure the continued functioning of other application programs. This proposed approach is currently being realized in the Transparent Schema Evolution (TSE) <ref> [8] </ref> system, which is being built using the MultiView system [9, 6] and the Gemstone OODB. This feature of transparency is partially supported in some schema version systems [4, 3], because old schemas are maintained with their own instances. <p> The use of view mechanisms to achieve schema evolution has also been advocated by other researchers [12, 10, 2], however previous works have neither carried out a full development of such technology nor built a working system. In our earlier work of TSE <ref> [8] </ref>, we explored the use of capacity-augmenting view mechanisms. In this paper, we propose an alternative more practical solution. In contrast to prior work, our revised TSE approach is neither confined to soft (or capacity-preserving) schema changes nor requires a view mechanism that supports capacity-augmenting virtual classes [8]. <p> work of TSE <ref> [8] </ref>, we explored the use of capacity-augmenting view mechanisms. In this paper, we propose an alternative more practical solution. In contrast to prior work, our revised TSE approach is neither confined to soft (or capacity-preserving) schema changes nor requires a view mechanism that supports capacity-augmenting virtual classes [8]. Our experiments have shown that the later is hard to achieve in an efficient manner [5]; and in fact, no commercial OODB system currently supports such features 1 . <p> In short, the work presented in this paper is 1 As far as we know, the only exception is MultiView prototype developed in the University of Michigan in an on-going NSF-funded research project. a significant extension of our previous research <ref> [8] </ref>, which (1) only addressed soft changes and (2) assumed the availability of a capacity-augmenting view mechanism. <p> This problem can be solved by providing a capacity-augmenting view mechanism, as we explored in our earlier work of TSE <ref> [8] </ref>. However, our experimental evaluation has shown that capacity-augmenting views are hard to implement in an efficient manner [5]. For this reason, we now propose 2 The capacity of a schema is defined as a set of possible states of the database under the schema.
Reference: [9] <author> E. A. Rundensteiner. </author> <title> MultiView: A methodology for supporting multiple views in OODBs. </title> <booktitle> 18th VLDB, </booktitle> <pages> pp. 187-198, </pages> <year> 1992. </year>
Reference-contexts: This proposed approach is currently being realized in the Transparent Schema Evolution (TSE) [8] system, which is being built using the MultiView system <ref> [9, 6] </ref> and the Gemstone OODB. This feature of transparency is partially supported in some schema version systems [4, 3], because old schemas are maintained with their own instances. <p> We have chosen to implement the TSE approach on top of the MultiView system <ref> [9, 6] </ref>. Unlike most other OO view mechanisms, MultiView creates a complete view schema rather than just deriving individual virtual classes and supports automatic classification. Since TSE is built using MultiView, we utilize Mul-tiView's view definition language, an object algebra [9], for the virtual class generation task of TSE. <p> Unlike most other OO view mechanisms, MultiView creates a complete view schema rather than just deriving individual virtual classes and supports automatic classification. Since TSE is built using MultiView, we utilize Mul-tiView's view definition language, an object algebra <ref> [9] </ref>, for the virtual class generation task of TSE. We have chosen OQL as the object-generating query language because it is a standard proposed by ODMG, interoperates with main host programming languages, and provides various language features to generate mutable objects as well as literal ones.
Reference: [10] <author> C. Souza dos Santos, S. Abiteboul, and C. Delo-bel. </author> <title> Virtual schemas and bases. </title> <address> EDBT, </address> <year> 1994. </year>
Reference-contexts: In addition, updates on instances of a version are not propagated to the instances (duplicates representing the same object) of another version though sometimes explicit propagating operations can be provided. The use of view mechanisms to achieve schema evolution has also been advocated by other researchers <ref> [12, 10, 2] </ref>, however previous works have neither carried out a full development of such technology nor built a working system. In our earlier work of TSE [8], we explored the use of capacity-augmenting view mechanisms. In this paper, we propose an alternative more practical solution.
Reference: [11] <author> A. H. Skarra and S. B. Zdonik. </author> <title> The management of changing types in an OODBs. </title> <booktitle> 1st OOPSLA, </booktitle> <pages> pp. 483-494, </pages> <year> 1986. </year>
Reference-contexts: the clause "type extent to query" is present, the values of object identifiers are updated. 4 Hard Schema Change Operators 4.1 Introduction The taxonomy of base schema evolution operators first introduced by Banerjee et al. [1] for Orion has been adopted in most other schema evolution research and commercial OODBs <ref> [11, 3, 7] </ref>. To demonstrate the feasibility of TSE, it is thus important to show that our approach can realize this set of schema change operations in a transparent fashion. In addition to handling transparently these primitive (soft) schema evolution operators, TSE also supports several complex operators called hard changes. <p> Bertino [2] indicates that view mechanisms, if capacity-augmenting, can be utilized to simulate schema evolution. But, her work is focused on individual classes rather than whole schemas. Zdonik et al. <ref> [11] </ref> keep different versions of each type, and objects of different versions can be accessed via exception handlers. However, it is both labor-intensive as well as difficult to provide semantically meaningful exception handlers. <p> We have demonstrated the feasibility of our TSE approach, without requiring capacity-augmenting view technology, on a comprehensive set of schema evolution operators, i.e., those soft ones typically supported by OODBs <ref> [11, 7, 13] </ref> as well as hard changes that require more extensive instance restructuring. Examples are partitioning a class vertically, that requires all instances of the class are also partitioned into new instances.
Reference: [12] <author> M. Tresch and M. H. Scholl. </author> <title> Schema transformation without database reorganization. </title> <booktitle> SIGMOD RECORD, </booktitle> <pages> pp. 21-27, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Schema evolution has been recognized as a very important functionality of OODBs required by many advanced engineering and scientific applications <ref> [1, 7, 12, 4, 13] </ref>. In spite of schema evolution support provided by most OODBs, schema updates on shared databases remain problematic. This is because in a shared-user environment, a desired schema change is likely to impact other programs. <p> In addition, updates on instances of a version are not propagated to the instances (duplicates representing the same object) of another version though sometimes explicit propagating operations can be provided. The use of view mechanisms to achieve schema evolution has also been advocated by other researchers <ref> [12, 10, 2] </ref>, however previous works have neither carried out a full development of such technology nor built a working system. In our earlier work of TSE [8], we explored the use of capacity-augmenting view mechanisms. In this paper, we propose an alternative more practical solution. <p> is constructed by first deleting unnecessary attributes as follows: delete attribute temp from Of f iceInf o; delete attribute temp from HomeInf o; and by incorporating Of f iceInf o and HomeInf o into the new view schema instead of P ersonInf o as in Fig. 6. 5 Related Research <ref> [12] </ref> also advocates views as a suitable mechanism for simulating schema evolution. They indicate that certain schema evolutions can't be simulated using views because they are capacity-augmenting. However, such schema evolution operations tend to be important for changing database requirements this is a problem that we address in this paper.
Reference: [13] <author> R. Zicari. </author> <title> A framework for O 2 schema updates. </title> <booktitle> 7th ICDE, </booktitle> <pages> pp. 146-182, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Schema evolution has been recognized as a very important functionality of OODBs required by many advanced engineering and scientific applications <ref> [1, 7, 12, 4, 13] </ref>. In spite of schema evolution support provided by most OODBs, schema updates on shared databases remain problematic. This is because in a shared-user environment, a desired schema change is likely to impact other programs. <p> We have demonstrated the feasibility of our TSE approach, without requiring capacity-augmenting view technology, on a comprehensive set of schema evolution operators, i.e., those soft ones typically supported by OODBs <ref> [11, 7, 13] </ref> as well as hard changes that require more extensive instance restructuring. Examples are partitioning a class vertically, that requires all instances of the class are also partitioned into new instances.
References-found: 13

