URL: http://www.cs.cornell.edu/Info/People/crary/papers/orei.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/crary/papers/
Root-URL: 
Title: Simple, Efficient Object Encoding using Intersection Types  
Author: Karl Crary 
Date: April 23, 1998  
Affiliation: Cornell University  
Abstract: I present a type-theoretic encoding of objects that interprets method dispatch by self-application (i.e., method functions are applied to the objects containing them) but still validates the expected subtyping relationships. The naive typing of self-application fails to validate the expected subtyping relationships because it is too permissive and allows application to similarly typed objects that are not self. This new encoding solves this problem by constraining methods to be applied only to self using existential and intersection types. Using this typing, I give a full account of objects including self types and method update. I also present another application of this object encoding to fully abstract, closure-passing closure conversion. The typing constructs used in this encoding appear to be quite rich, but they may be axiomatized in a novel, restricted fashion that is metatheoretically simple.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Luca Cardelli. </author> <title> A theory of primitive objects: Untyped and first-order systems. </title> <booktitle> In Theoretical Aspects of Computer Software, volume 789 of Lecture Notes in Computer Science, </booktitle> <pages> pages 296-320. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: Section 3 formalizes the encoding by presenting an object calculus and a translation that implements those 2 objects with underlying type-theoretic constructs. The object calculus I present has considerable expressive power; for example, it supports a very natural encoding of the object calculus of Abadi and Cardelli <ref> [1, 2] </ref>. The underlying type theory makes explicit that certain operations (such as folding or unfolding recursive types) have no run-time effect, making it more straightforward to evaluate efficiency claims. <p> We would like a mechanism to hide the details of method update from the programmer. An Object Calculus As has been argued by Abadi and Cardelli <ref> [1, 2] </ref>, object calculi provide a useful level of abstraction for object-oriented programming. In particular, the object calculus I now introduce provides such a mechanism for hiding method update from the programmer. <p> This object calculus is very similar in expressive power to Abadi and Cardelli's first-order calculus of primitive objects Ob 1&lt;: <ref> [1, 2] </ref>. The difference is that in Ob 1&lt;: all methods are updatable; explicit update methods are not required as in F C +obj .
Reference: [2] <author> Martn Abadi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Section 3 formalizes the encoding by presenting an object calculus and a translation that implements those 2 objects with underlying type-theoretic constructs. The object calculus I present has considerable expressive power; for example, it supports a very natural encoding of the object calculus of Abadi and Cardelli <ref> [1, 2] </ref>. The underlying type theory makes explicit that certain operations (such as folding or unfolding recursive types) have no run-time effect, making it more straightforward to evaluate efficiency claims. <p> We would like a mechanism to hide the details of method update from the programmer. An Object Calculus As has been argued by Abadi and Cardelli <ref> [1, 2] </ref>, object calculi provide a useful level of abstraction for object-oriented programming. In particular, the object calculus I now introduce provides such a mechanism for hiding method update from the programmer. <p> This object calculus is very similar in expressive power to Abadi and Cardelli's first-order calculus of primitive objects Ob 1&lt;: <ref> [1, 2] </ref>. The difference is that in Ob 1&lt;: all methods are updatable; explicit update methods are not required as in F C +obj .
Reference: [3] <author> Martn Abadi, Luca Cardelli, and Ramesh Viswanathan. </author> <title> An interpretation of objects and object types. </title> <booktitle> In Twenty-Third ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 296-409, </pages> <address> St. Petersburg, Florida, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Although each of these proposals supports basic functionality for object-oriented programming, none provide the full flexibility of the self-application semantics. For example, none allow methods to be updated once objects have been constructed. To solve this problem, Abadi, Cardelli and Viswanathan devised an alternative interpretation <ref> [3] </ref>, which retains the expressiveness of the self-application semantics. Their interpretation views objects as a record containing methods and a self field. The type of the self field is hidden, as in the existential interpretations, but is constrained to be a subtype of the full object's type. <p> Thus, Ob 1&lt;: may be encoded in F C +obj by a translation that adds explicit update methods (as in the object interpretation of Abadi, et al. <ref> [3] </ref>). 3 3.2 Translation I am now ready to describe the encoding of objects in F C . <p> However, like OE, the ORE encoding leaves the structure of the state unspecified. Next is the (ORBE) encoding of Abadi, Cardelli and Viswanathan <ref> [3] </ref>, which additional commits that an object's state will be another object of the same type. (In practice the state is actually the same object, but the type leaves open the possibility it might be different.) Finally, OREI fits in as the most specific of the group; the type specifies that
Reference: [4] <author> Val Breazu-Tannen, Thierry Coquand, Carl A. Gunter, and Andre Scedrov. </author> <title> Inheritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 172-221, </pages> <year> 1991. </year>
Reference-contexts: In an implementation where types may have different representations than their supertypes and therefore subsumption must involve the application of a coercion <ref> [4, 10] </ref>, these costs are unavoidable. Methods expect their self parameter to supply the original object, not the result after some number of coercions, and consequently that original object must be retained. <p> This is important because it ensures there is no run-time effect of subsumption. In contrast, a calculus where supertypes may have different representations requires the expense of passing and applying coercion functions at run-time <ref> [4, 10] </ref> (or the even greater expense of run-time type checking and coercion). The main impact of this design decision is a restricted rule for record subtyping: permuted records are not considered identical, and record subtyping respects extension only on the right.
Reference: [5] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design, static typing and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 127-206, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: This difficulty has led to several different proposals for type-theoretic encodings of objects. Recursive record interpretations [8, 9, 7] perform applications to self at the time objects are constructed, 1 instead of at method invocation, resulting in records of methods where self is hardcoded. In exis-tential interpretations <ref> [5, 24, 15] </ref>, the self argument provides some hidden state of an object, but no access to methods; access to self methods is again settled before before object construction. Although each of these proposals supports basic functionality for object-oriented programming, none provide the full flexibility of the self-application semantics. <p> Their encoding views objects as pairs of state and methods, where the structure of the state is completely unspecified. Functional update methods return only the state, which must be paired again with the methods by the caller to produce a new object. Next is the (ORE) encoding of Bruce <ref> [5] </ref>. The ORE encoding is like the OE encoding except that the repacking of new state with methods to form objects is performed by the method, rather than the caller. However, like OE, the ORE encoding leaves the structure of the state unspecified.
Reference: [6] <author> Kim B. Bruce, Luca Cardelli, and Benjamin C. Pierce. </author> <title> Comparing object encodings. </title> <booktitle> In Theoretical Aspects of Computer Software, Sendai, </booktitle> <address> Japan, </address> <month> September </month> <year> 1997. </year>
Reference-contexts: as: O = 9ff: ff ^ f` 1 : ff ! t 1 ; : : : ; ` n : ff ! t n g I will refer to this encoding as the OEI encoding, for "objects using existential and intersection types," following the terminology of Bruce et al. <ref> [6] </ref>. In the remainder of this section, I will explore the expressiveness of this encoding by showing how it deals with various issues in object-oriented programming. <p> The OREI encoding may be understood as occupying a far end of the spectrum of abstraction-oriented object encodings examined by Bruce et al. <ref> [6] </ref>. On the end opposite OREI is the purely existential (OE) encoding of Pierce, Turner, and Hoffman [24, 15]. Their encoding views objects as pairs of state and methods, where the structure of the state is completely unspecified.
Reference: [7] <author> Peter Canning, William Cook, Walter Hill, John Mitchell, and Walter Olthoff. </author> <title> F-bounded quantification for object-oriented programming. </title> <booktitle> In Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: This difficulty has led to several different proposals for type-theoretic encodings of objects. Recursive record interpretations <ref> [8, 9, 7] </ref> perform applications to self at the time objects are constructed, 1 instead of at method invocation, resulting in records of methods where self is hardcoded.
Reference: [8] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 138-164, </pages> <year> 1988. </year>
Reference-contexts: This difficulty has led to several different proposals for type-theoretic encodings of objects. Recursive record interpretations <ref> [8, 9, 7] </ref> perform applications to self at the time objects are constructed, 1 instead of at method invocation, resulting in records of methods where self is hardcoded.
Reference: [9] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Seventeenth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <address> San Francisco, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: This difficulty has led to several different proposals for type-theoretic encodings of objects. Recursive record interpretations <ref> [8, 9, 7] </ref> perform applications to self at the time objects are constructed, 1 instead of at method invocation, resulting in records of methods where self is hardcoded.
Reference: [10] <author> Karl Crary. </author> <title> Foundations for the implementation of higher-order subtyping. </title> <booktitle> In 1997 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 125-135, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: In an implementation where types may have different representations than their supertypes and therefore subsumption must involve the application of a coercion <ref> [4, 10] </ref>, these costs are unavoidable. Methods expect their self parameter to supply the original object, not the result after some number of coercions, and consequently that original object must be retained. <p> This is important because it ensures there is no run-time effect of subsumption. In contrast, a calculus where supertypes may have different representations requires the expense of passing and applying coercion functions at run-time <ref> [4, 10] </ref> (or the even greater expense of run-time type checking and coercion). The main impact of this design decision is a restricted rule for record subtyping: permuted records are not considered identical, and record subtyping respects extension only on the right.
Reference: [11] <author> Karl Crary, Stephanie Weirich, and Greg Morrisett. </author> <title> Intensional polymorphism in type-erasure semantics. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1998. </year>
Reference-contexts: This is desirable not only because it makes more efficient the object encoding of this paper, but also because it avoids hidden costs of passing run-time type information in general and it considerably simplifies polymorphic closure conversion [21]. However, it complicates support for run-time type analysis <ref> [11] </ref>, which is required for some advanced 8 ` t i t 0 i (for 1 i m) ` t i type (for m &lt; i n) ` f` 1 : t 1 ; : : : ; ` n : t n g f` 1 : t 0 m g
Reference: [12] <author> Allyn Dimock, Robert Muller, Franklyn Turbak, and J. B. Wells. </author> <title> Strongly typed flow-directed representation transformations. </title> <booktitle> In 1997 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 11-24, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: The problem with recursive types discussed above is then 2 Dimock et al. <ref> [12] </ref> make use of a similar idea by defining intersections to be products where the components are required to be identical when types are erased. 7 types t ::= ff j int j t 1 ! t 2 j f` 1 : t 1 ; : : : ; ` n
Reference: [13] <author> Jean-Yves Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination de coupures dans l'analyse et la theorie des types. </title> <editor> In J. E. Fenstad, editor, </editor> <booktitle> Proceedings of the Second Scandinavian Logic Symposium, </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland Publishing Co., </publisher> <year> 1971. </year> <month> 16 </month>
Reference-contexts: This technique follows naturally from the close connection between closures and objects. Some comparisons with other object encodings and concluding remarks appear in Section 5. In the interest of brevity, this paper assumes basic familiarity with the Girard-Reynolds polymorphic lambda calculus <ref> [13, 25] </ref> and subtyping, with recursive types, and with existential types for data abstraction [18]. Some familiarity with the other object encodings discussed above will also be helpful, but is not required.
Reference: [14] <author> Robert Harper and Greg Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty--Second ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 130-141, </pages> <address> San Francisco, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: type ` fold [ff:t ] : t [ff:t =ff] ) ff:t ` ff:t type ` unfold [ff:t ] : ff:t ) t [ff:t =ff] ` e : t ` t t 0 ` c : t 1 ) t 2 ` t 0 2 1 ) t 0 implementation techniques <ref> [14, 19, 27, 20, 26] </ref>. The typing rules of F C are given in Appendix A and consist of four judgements. The usual judgements for type well-formedness, subtyping and typing of terms are written ` t type; ` t 1 t 2 ; and ` e : t .
Reference: [15] <author> Martin Hofmann and Benjamin Pierce. </author> <title> A unifying type-theoretic framework for objects. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(4) </volume> <pages> 593-635, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: This difficulty has led to several different proposals for type-theoretic encodings of objects. Recursive record interpretations [8, 9, 7] perform applications to self at the time objects are constructed, 1 instead of at method invocation, resulting in records of methods where self is hardcoded. In exis-tential interpretations <ref> [5, 24, 15] </ref>, the self argument provides some hidden state of an object, but no access to methods; access to self methods is again settled before before object construction. Although each of these proposals supports basic functionality for object-oriented programming, none provide the full flexibility of the self-application semantics. <p> The OREI encoding may be understood as occupying a far end of the spectrum of abstraction-oriented object encodings examined by Bruce et al. [6]. On the end opposite OREI is the purely existential (OE) encoding of Pierce, Turner, and Hoffman <ref> [24, 15] </ref>. Their encoding views objects as pairs of state and methods, where the structure of the state is completely unspecified. Functional update methods return only the state, which must be paired again with the methods by the caller to produce a new object.
Reference: [16] <author> Samuel Kamin. </author> <title> Inheritance in Smalltalk-80: A denotational definition. </title> <booktitle> In Fifteenth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 80-87, </pages> <address> San Diego, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: Second, a type-preserving compiler must implement object features in terms of more basic, typed primitives. To satisfy both these needs, an type-theoretic object encoding must be faithful to the intended semantics (static and dynamic) of the object system, and must also be computationally efficient. The self-application semantics <ref> [16] </ref> provides a reasonable explanation of the operational behavior of objects whose methods have access to self. In the self-application semantics, method invocation is performed by extracting the desired method from an object and then applying that method to the entire object as well as the method's arguments.
Reference: [17] <author> Yasuhiko Minamide, Greg Morrisett, and Robert Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Twenty-Third ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 271-283, </pages> <address> St. Petersburg, Florida, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Some familiarity with the other object encodings discussed above will also be helpful, but is not required. Section 4 contains a brief review of the idea of closure conversion and typing mechanisms for it <ref> [17, 21] </ref>; some prior familiarity may be helpful there as well. 2 Informal Development We begin by examining what makes the naive typing for self-application fail. By way of example, consider the object types Point and ColorPoint shown below. <p> Suppose f has type t 1 ! t 2 , then the type of f 's closure would be 9ff: fcode : (t 1 fi ff) ! t 2 ; env : ffg <ref> [17] </ref>, where ff is the type of the environment. The abstraction of the environment's type is made abstract serves two important purposes.
Reference: [18] <author> John C. Mitchell and Gordon D. Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Some comparisons with other object encodings and concluding remarks appear in Section 5. In the interest of brevity, this paper assumes basic familiarity with the Girard-Reynolds polymorphic lambda calculus [13, 25] and subtyping, with recursive types, and with existential types for data abstraction <ref> [18] </ref>. Some familiarity with the other object encodings discussed above will also be helpful, but is not required. <p> Intersection types are typically associated with their import in subtyping systems, but that import is removed by the F C calculus. What remains in F C (and what is used by the OREI encoding) is the import of intersection types for controlled information hiding. Existential types are used <ref> [18] </ref> to hide type information by replacing the information to be hidden with an existentially quantified type variable, but this sort of hiding is all-or-nothing. Using existential types alone, data can be given an abstract view, but cannot be given multiple abstract views without making copies.
Reference: [19] <author> Greg Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, School of Computer Science, Pittsburgh, Pennsylvania, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: type ` fold [ff:t ] : t [ff:t =ff] ) ff:t ` ff:t type ` unfold [ff:t ] : ff:t ) t [ff:t =ff] ` e : t ` t t 0 ` c : t 1 ) t 2 ` t 0 2 1 ) t 0 implementation techniques <ref> [14, 19, 27, 20, 26] </ref>. The typing rules of F C are given in Appendix A and consist of four judgements. The usual judgements for type well-formedness, subtyping and typing of terms are written ` t type; ` t 1 t 2 ; and ` e : t .
Reference: [20] <author> Greg Morrisett and Robert Harper. </author> <title> Semantics of memory management for polymorphic languages. </title> <editor> In A. D. Gordon and A. M. Pitts, editors, </editor> <title> Higher Order Operational Techniques in Semantics. </title> <publisher> Cambridge University Press, </publisher> <year> 1997. </year>
Reference-contexts: type ` fold [ff:t ] : t [ff:t =ff] ) ff:t ` ff:t type ` unfold [ff:t ] : ff:t ) t [ff:t =ff] ` e : t ` t t 0 ` c : t 1 ) t 2 ` t 0 2 1 ) t 0 implementation techniques <ref> [14, 19, 27, 20, 26] </ref>. The typing rules of F C are given in Appendix A and consist of four judgements. The usual judgements for type well-formedness, subtyping and typing of terms are written ` t type; ` t 1 t 2 ; and ` e : t .
Reference: [21] <author> Greg Morrisett, David Walker, Karl Crary, and Neal Glew. </author> <title> From System F to typed assembly language. </title> <booktitle> In Twenty-Fifth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 85-97, </pages> <address> San Diego, </address> <month> January </month> <year> 1998. </year> <note> Extended version published as Cornell University technical report TR97-1651. </note>
Reference-contexts: Some familiarity with the other object encodings discussed above will also be helpful, but is not required. Section 4 contains a brief review of the idea of closure conversion and typing mechanisms for it <ref> [17, 21] </ref>; some prior familiarity may be helpful there as well. 2 Informal Development We begin by examining what makes the naive typing for self-application fail. By way of example, consider the object types Point and ColorPoint shown below. <p> This is desirable not only because it makes more efficient the object encoding of this paper, but also because it avoids hidden costs of passing run-time type information in general and it considerably simplifies polymorphic closure conversion <ref> [21] </ref>. <p> In contrast, if the environment's type were made transparent, the environment could be analyzed or a new environment could be synthesized for the code. Full abstraction in compilation is not only of theoretical interest; in systems where programmers may write code in lower-level intermediate languages <ref> [21] </ref>, it is desirable that abstraction properties in the source language be protected in the lower-level intermediate languages as well. Although the above type for closures is fully abstract, it is not efficient for recursive functions.
Reference: [22] <author> Benjamin Pierce. </author> <type> Personal communication, </type> <year> 1998. </year>
Reference-contexts: This rule is natural according to the intuitive semantics of the recursive type, but it makes type checking considerably more difficult and it restricts the possible models of the type theory <ref> [22] </ref>.
Reference: [23] <author> Benjamin C. Pierce. </author> <title> Programming with Intersection Types and Bounded Polymorphism. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, School of Computer Science, Pittsburgh, Pennsylvania, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: For example, intersection types are a critical part of my object encoding. On their own, intersection types are fairly innocuous, but combining them with them with bounded quantification leads to serious difficulties for type checking and semantics <ref> [23] </ref>. I do not use bounded quantification in this paper, but there are many good reasons to want to include it in a practical object system.
Reference: [24] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: This difficulty has led to several different proposals for type-theoretic encodings of objects. Recursive record interpretations [8, 9, 7] perform applications to self at the time objects are constructed, 1 instead of at method invocation, resulting in records of methods where self is hardcoded. In exis-tential interpretations <ref> [5, 24, 15] </ref>, the self argument provides some hidden state of an object, but no access to methods; access to self methods is again settled before before object construction. Although each of these proposals supports basic functionality for object-oriented programming, none provide the full flexibility of the self-application semantics. <p> The simpler, environment-passing style of closures discussed at the start of this section (with type 9ff: fcode : (t 1 fi ff) ! t 2 ; env : ffg) also corresponds to an object with a single code method, but using the existential object encoding of Pierce and Turner <ref> [24] </ref> instead. 5 Conclusions and Comparisons The OREI encoding is the first type-theoretic object encoding to use the efficient self-application semantics to explain objects' operational behavior and also to give objects types that justify the intended subtyping relationships. <p> The OREI encoding may be understood as occupying a far end of the spectrum of abstraction-oriented object encodings examined by Bruce et al. [6]. On the end opposite OREI is the purely existential (OE) encoding of Pierce, Turner, and Hoffman <ref> [24, 15] </ref>. Their encoding views objects as pairs of state and methods, where the structure of the state is completely unspecified. Functional update methods return only the state, which must be paired again with the methods by the caller to produce a new object.
Reference: [25] <author> John C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Programming Symposium, volume 19 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408-425, </pages> <year> 1974. </year>
Reference-contexts: This technique follows naturally from the close connection between closures and objects. Some comparisons with other object encodings and concluding remarks appear in Section 5. In the interest of brevity, this paper assumes basic familiarity with the Girard-Reynolds polymorphic lambda calculus <ref> [13, 25] </ref> and subtyping, with recursive types, and with existential types for data abstraction [18]. Some familiarity with the other object encodings discussed above will also be helpful, but is not required.
Reference: [26] <author> Zhong Shao. </author> <title> Flexible representation analysis. </title> <booktitle> In 1997 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 85-98, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: type ` fold [ff:t ] : t [ff:t =ff] ) ff:t ` ff:t type ` unfold [ff:t ] : ff:t ) t [ff:t =ff] ` e : t ` t t 0 ` c : t 1 ) t 2 ` t 0 2 1 ) t 0 implementation techniques <ref> [14, 19, 27, 20, 26] </ref>. The typing rules of F C are given in Appendix A and consist of four judgements. The usual judgements for type well-formedness, subtyping and typing of terms are written ` t type; ` t 1 t 2 ; and ` e : t .
Reference: [27] <author> Andrew Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year> <month> 17 </month>
Reference-contexts: type ` fold [ff:t ] : t [ff:t =ff] ) ff:t ` ff:t type ` unfold [ff:t ] : ff:t ) t [ff:t =ff] ` e : t ` t t 0 ` c : t 1 ) t 2 ` t 0 2 1 ) t 0 implementation techniques <ref> [14, 19, 27, 20, 26] </ref>. The typing rules of F C are given in Appendix A and consist of four judgements. The usual judgements for type well-formedness, subtyping and typing of terms are written ` t type; ` t 1 t 2 ; and ` e : t .
References-found: 27

