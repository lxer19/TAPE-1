URL: http://www.cs.washington.edu/homes/notkin/pubs/cg_paper.ps
Refering-URL: http://www.cs.washington.edu/homes/notkin/pubs/icse18-cg.html
Root-URL: 
Abstract: Copyright 1996 IEEE. Published in the Proceed--ings of the 18th International Conference on Software Engineering (ICSE-18), March 25-29, 1996, Berlin, Germany. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works, must be obtained from the IEEE. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F.E. Allen. </author> <title> Interprocedural Data Flow Analysis. </title> <booktitle> In Proceedings Information Processing 74 (Software), </booktitle> <pages> pages 398-402. </pages> <publisher> North-Holland, </publisher> <month> August </month> <year> 1974. </year>
Reference-contexts: In practice, tools that compute call graphs that fall into different parts of this spectrum. Compilers place one set of requirements on call graphs. 2 The most conspicuous requirement is that 1 Call graphs are sometimes treated not as relations but as multigraphs <ref> [1, 2, 4, 6, 7, 12, 15] </ref>. 2 Call graphs have been used for interprocedural analysis and optimization for over two decades [1]. Early results constrained the programs for which call graphs could be computed. Ryder loosened some of these restrictions, considering limited forms of procedure parameters [17]. <p> Compilers place one set of requirements on call graphs. 2 The most conspicuous requirement is that 1 Call graphs are sometimes treated not as relations but as multigraphs [1, 2, 4, 6, 7, 12, 15]. 2 Call graphs have been used for interprocedural analysis and optimization for over two decades <ref> [1] </ref>. Early results constrained the programs for which call graphs could be computed. Ryder loosened some of these restrictions, considering limited forms of procedure parameters [17]. <p> Determining the algorithms used by inspecting the source of the tools is extremely difficult, since the algorithmic code is neither small nor isolated within the source. A search of the literature is not sufficient either: While many interprocedural data-flow problems are based on a call multigraph <ref> [1, 2, 6, 7, 15] </ref> or a relation between pairs of procedures indicating possible call sequences [3], few authors discuss how it is constructed from the source program [4, p. 484]. Inferring some algorithmic aspects, however, is feasible.
Reference: [2] <author> J.P. Banning. </author> <title> An Efficient Way to Find the Side Effects of Procedure Calls and the Aliases of Variables. </title> <booktitle> In Conference Record of the 6th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 29-41. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1979. </year>
Reference-contexts: In practice, tools that compute call graphs that fall into different parts of this spectrum. Compilers place one set of requirements on call graphs. 2 The most conspicuous requirement is that 1 Call graphs are sometimes treated not as relations but as multigraphs <ref> [1, 2, 4, 6, 7, 12, 15] </ref>. 2 Call graphs have been used for interprocedural analysis and optimization for over two decades [1]. Early results constrained the programs for which call graphs could be computed. Ryder loosened some of these restrictions, considering limited forms of procedure parameters [17]. <p> Determining the algorithms used by inspecting the source of the tools is extremely difficult, since the algorithmic code is neither small nor isolated within the source. A search of the literature is not sufficient either: While many interprocedural data-flow problems are based on a call multigraph <ref> [1, 2, 6, 7, 15] </ref> or a relation between pairs of procedures indicating possible call sequences [3], few authors discuss how it is constructed from the source program [4, p. 484]. Inferring some algorithmic aspects, however, is feasible.
Reference: [3] <author> J.M. Barth. </author> <title> A Practical Interprocedural Data Flow Analysis Algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 21(9) </volume> <pages> 724-736, </pages> <month> September </month> <year> 1978. </year>
Reference-contexts: A search of the literature is not sufficient either: While many interprocedural data-flow problems are based on a call multigraph [1, 2, 6, 7, 15] or a relation between pairs of procedures indicating possible call sequences <ref> [3] </ref>, few authors discuss how it is constructed from the source program [4, p. 484]. Inferring some algorithmic aspects, however, is feasible. Simple tests can be used, for instance, to determine whether or not tools try to handle function pointers.
Reference: [4] <author> D. Callahan, A. Carle, M.W. Hall, and K. Kennedy. </author> <title> Constructing the Procedure Call Multigraph. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-16(4):483-487, </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: In practice, tools that compute call graphs that fall into different parts of this spectrum. Compilers place one set of requirements on call graphs. 2 The most conspicuous requirement is that 1 Call graphs are sometimes treated not as relations but as multigraphs <ref> [1, 2, 4, 6, 7, 12, 15] </ref>. 2 Call graphs have been used for interprocedural analysis and optimization for over two decades [1]. Early results constrained the programs for which call graphs could be computed. Ryder loosened some of these restrictions, considering limited forms of procedure parameters [17]. <p> Early results constrained the programs for which call graphs could be computed. Ryder loosened some of these restrictions, considering limited forms of procedure parameters [17]. Callahan et al. extended Ry-der's work to handle recursion <ref> [4] </ref>, while Hall and Kennedy increased the ability to handle some assignments to procedure variables [8]. <p> A search of the literature is not sufficient either: While many interprocedural data-flow problems are based on a call multigraph [1, 2, 6, 7, 15] or a relation between pairs of procedures indicating possible call sequences [3], few authors discuss how it is constructed from the source program <ref> [4, p. 484] </ref>. Inferring some algorithmic aspects, however, is feasible. Simple tests can be used, for instance, to determine whether or not tools try to handle function pointers.
Reference: [5] <author> Y.-F. Chen, M.Y. Nishimoto, and C.V. Ramamoor-thy. </author> <title> The C Information Abstraction System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-16(3):325-334, </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: The five call graph extractors used in the study were: * CIA, the C Information Abstraction System <ref> [5] </ref>, * rigiparse, a front-end to the Rigi reverse engineer ing system [14], * the Field programming environment [16], * cflow, a tool distributed with most Unix systems, and * mkfunctmap, a Perl script developed by James Hoagland.
Reference: [6] <author> K. Cooper and K. Kennedy. </author> <title> Efficient Computation of Flow Insensitive Interprocedural Summary Information. </title> <booktitle> In Proceedings of the ACM SIGPLAN '84 Symposium on Compiler Construction, </booktitle> <pages> pages 247-258. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1984. </year>
Reference-contexts: In practice, tools that compute call graphs that fall into different parts of this spectrum. Compilers place one set of requirements on call graphs. 2 The most conspicuous requirement is that 1 Call graphs are sometimes treated not as relations but as multigraphs <ref> [1, 2, 4, 6, 7, 12, 15] </ref>. 2 Call graphs have been used for interprocedural analysis and optimization for over two decades [1]. Early results constrained the programs for which call graphs could be computed. Ryder loosened some of these restrictions, considering limited forms of procedure parameters [17]. <p> Determining the algorithms used by inspecting the source of the tools is extremely difficult, since the algorithmic code is neither small nor isolated within the source. A search of the literature is not sufficient either: While many interprocedural data-flow problems are based on a call multigraph <ref> [1, 2, 6, 7, 15] </ref> or a relation between pairs of procedures indicating possible call sequences [3], few authors discuss how it is constructed from the source program [4, p. 484]. Inferring some algorithmic aspects, however, is feasible.
Reference: [7] <author> K. Cooper, K. Kennedy, and L. Torczon. </author> <title> Interpro-cedural Optimization: Eliminating Unnecessary Recompilation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 58-67. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: In practice, tools that compute call graphs that fall into different parts of this spectrum. Compilers place one set of requirements on call graphs. 2 The most conspicuous requirement is that 1 Call graphs are sometimes treated not as relations but as multigraphs <ref> [1, 2, 4, 6, 7, 12, 15] </ref>. 2 Call graphs have been used for interprocedural analysis and optimization for over two decades [1]. Early results constrained the programs for which call graphs could be computed. Ryder loosened some of these restrictions, considering limited forms of procedure parameters [17]. <p> Determining the algorithms used by inspecting the source of the tools is extremely difficult, since the algorithmic code is neither small nor isolated within the source. A search of the literature is not sufficient either: While many interprocedural data-flow problems are based on a call multigraph <ref> [1, 2, 6, 7, 15] </ref> or a relation between pairs of procedures indicating possible call sequences [3], few authors discuss how it is constructed from the source program [4, p. 484]. Inferring some algorithmic aspects, however, is feasible.
Reference: [8] <author> M.W. Hall and K. Kennedy. </author> <title> Efficient Call Graph Analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(3) </volume> <pages> 227-242, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Early results constrained the programs for which call graphs could be computed. Ryder loosened some of these restrictions, considering limited forms of procedure parameters [17]. Callahan et al. extended Ry-der's work to handle recursion [4], while Hall and Kennedy increased the ability to handle some assignments to procedure variables <ref> [8] </ref>. Lakhotia further extended this work to handle additional kinds of assignments to procedure parameters [12]. their call graphs must be conservative: a call can be omitted only if it can never occur in any execution of the program.
Reference: [9] <author> L. Hatton and A. Roberts. </author> <title> How Accurate is Scientific Software? IEEE Transactions on Software Engineering, </title> <address> SE-20(10):785-797, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: For example, a tool developer must determine how to handle dynamic binding. Although this paper only considers one kind of information, call graphs, many of the observations about 5 Unexpectedly inconsistent computations from long-lived, widely available, and broadly used programs have been documented in seismic data processing as well <ref> [9] </ref>. design decisions apply to extractors of other kinds of information|such as inheritance structures, file dependences, references to global variables, etc.|as well. Acknowledgments We wish to thank the authors of all the call graph extractor tools used in the study for making their tools available to us.
Reference: [10] <author> S.C. Johnson. </author> <title> Yacc|Yet Another Compiler Compiler. </title> <type> Technical Report Computing Science Technical Report 32, </type> <institution> AT&T Bell Laboratories, </institution> <year> 1975. </year>
Reference-contexts: Each software system was compiled to determine the include paths and defines necessary to produce a working executable. For each software system, we then applied each of the five tools to extract a list of the calls between C functions from the C, Yacc <ref> [10] </ref>, and Lex [13] source code comprising the system. Scripts were run on the output produced by the tools to transform the extracted calls list to the form: (function1;function2) where function1 calls function2.
Reference: [11] <author> B.W. Kernighan and D.M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> 2nd edition, </address> <year> 1988. </year>
Reference-contexts: graph extractors. * Based on a qualitative analysis of the results, it sketches a design space for call graph extractors. * It considers the impact of this design space on practitioners, tool developers, and researchers. 2 Empirical Study We gathered five tools that each extract a call graph from C <ref> [11] </ref> source code, applied the extractors to three target software systems, and analyzed the results both quantitatively and qualitatively.
Reference: [12] <author> A. Lakhotia. </author> <title> Constructing Call Multigraphs using Dependence Graphs. </title> <booktitle> In Conference Record of the 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 273-284. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1993. </year>
Reference-contexts: In practice, tools that compute call graphs that fall into different parts of this spectrum. Compilers place one set of requirements on call graphs. 2 The most conspicuous requirement is that 1 Call graphs are sometimes treated not as relations but as multigraphs <ref> [1, 2, 4, 6, 7, 12, 15] </ref>. 2 Call graphs have been used for interprocedural analysis and optimization for over two decades [1]. Early results constrained the programs for which call graphs could be computed. Ryder loosened some of these restrictions, considering limited forms of procedure parameters [17]. <p> Callahan et al. extended Ry-der's work to handle recursion [4], while Hall and Kennedy increased the ability to handle some assignments to procedure variables [8]. Lakhotia further extended this work to handle additional kinds of assignments to procedure parameters <ref> [12] </ref>. their call graphs must be conservative: a call can be omitted only if it can never occur in any execution of the program. Without this requirement, a compiler might apply an optimization that does not preserve the semantics of the source program.
Reference: [13] <author> M.E. Lesk. </author> <title> Lex|A Lexical Analyzer Generator. </title> <type> Technical Report Computing Science Technical Report 39, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, N.J., </address> <year> 1975. </year>
Reference-contexts: Each software system was compiled to determine the include paths and defines necessary to produce a working executable. For each software system, we then applied each of the five tools to extract a list of the calls between C functions from the C, Yacc [10], and Lex <ref> [13] </ref> source code comprising the system. Scripts were run on the output produced by the tools to transform the extracted calls list to the form: (function1;function2) where function1 calls function2.
Reference: [14] <author> H.A. Muller and K. Klashinsky. </author> <title> Rigi|A System for Programming-in-the-large. </title> <booktitle> In Proceedings of the 10th International Conference on Software Engineering, </booktitle> <pages> pages 80-86. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> April </month> <year> 1989. </year>
Reference-contexts: The five call graph extractors used in the study were: * CIA, the C Information Abstraction System [5], * rigiparse, a front-end to the Rigi reverse engineer ing system <ref> [14] </ref>, * the Field programming environment [16], * cflow, a tool distributed with most Unix systems, and * mkfunctmap, a Perl script developed by James Hoagland.
Reference: [15] <author> E. Myers. </author> <title> A Precise Inter-procedural Data Flow Algorithm. </title> <booktitle> In Conference Record of the 8th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219-230. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1981. </year>
Reference-contexts: In practice, tools that compute call graphs that fall into different parts of this spectrum. Compilers place one set of requirements on call graphs. 2 The most conspicuous requirement is that 1 Call graphs are sometimes treated not as relations but as multigraphs <ref> [1, 2, 4, 6, 7, 12, 15] </ref>. 2 Call graphs have been used for interprocedural analysis and optimization for over two decades [1]. Early results constrained the programs for which call graphs could be computed. Ryder loosened some of these restrictions, considering limited forms of procedure parameters [17]. <p> Determining the algorithms used by inspecting the source of the tools is extremely difficult, since the algorithmic code is neither small nor isolated within the source. A search of the literature is not sufficient either: While many interprocedural data-flow problems are based on a call multigraph <ref> [1, 2, 6, 7, 15] </ref> or a relation between pairs of procedures indicating possible call sequences [3], few authors discuss how it is constructed from the source program [4, p. 484]. Inferring some algorithmic aspects, however, is feasible.
Reference: [16] <author> S.P. Reiss. </author> <title> The Field Programming Environment: </title>
Reference-contexts: The five call graph extractors used in the study were: * CIA, the C Information Abstraction System [5], * rigiparse, a front-end to the Rigi reverse engineer ing system [14], * the Field programming environment <ref> [16] </ref>, * cflow, a tool distributed with most Unix systems, and * mkfunctmap, a Perl script developed by James Hoagland.
References-found: 16

