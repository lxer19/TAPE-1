URL: http://www.cse.psu.edu/~catuscia/papers/Infiniti/infiniti.ps.gz
Refering-URL: http://www.cse.psu.edu/~catuscia/publications.html
Root-URL: http://www.cse.psu.edu
Title: Nondeterminism and infinite computations in constraint programming  
Author: Frank S. de Boer Alessandra Di Pierro and Catuscia Palamidessi 
Note: Contents  
Abstract: We investigate the semantics of concurrent constraint programming and of various sublanguages, with particular emphasis on nondeterminism and infinite behavior. The aim is to find out what is the minimal structure which a domain must have in order to capture these two aspects. We show that a notion of observables, obtained by the upward-closure of the results of computations, is relatively easy to model even in presence of synchronization. On the contrary modeling the exact set of results is problematic, even for the simple sublanguage of constraint logic programming. We show that most of the standard topological techniques fail in capturing this more precise notion of observables. The analysis of these failed attempts leads us to consider a categorical approach. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt, H. Blair, and A. Walker. </author> <title> Towards a Theory of Declarative Knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year>
Reference-contexts: 1 ; : : : t n ) = f (u 1 ; : : : ; u n )g v ft 1 = u 1 ; : : : t n = u n g, 6. if f is a function symbol of arity n, then for i 2 <ref> [1; n] </ref>, ft i = u i g v ff (t 1 ; : : : t n ) = f (u 1 ; : : : ; u n )g, 7. if f and g are distinct function symbols of arity m and n respectively, then, for every set E <p> This local information is externally seen as 9 x d, that is, 9 x d v c 7 R1 htell (c); di ! hstop; c t di R2 h i=1 ask (c i ) ! A i ; di ! hA j ; di j 2 <ref> [1; n] </ref> and c j v d hA; ci ! hA 0 ; c 0 i hB k A; ci ! hB k A 0 ; c 0 i hA; 9 x c t di ! hB; 9 x c t d 0 i x A; ci ! h9 d 0 <p> Definition 4.2 The restricted-choice ccp is the sub-language of ccp in which every guarded choice construct P n i=1 ask (c i ) ! A i , both in the agents and in the body of declarations, satisfies either (i) 8i; j 2 <ref> [1; n] </ref>: c i = c j (local choice), or (ii) 8i; j 2 [1; n]: i 6= j ) c i t c j = false (mutually exclusive choice). <p> sub-language of ccp in which every guarded choice construct P n i=1 ask (c i ) ! A i , both in the agents and in the body of declarations, satisfies either (i) 8i; j 2 <ref> [1; n] </ref>: c i = c j (local choice), or (ii) 8i; j 2 [1; n]: i 6= j ) c i t c j = false (mutually exclusive choice). The denotational model we are going to describe is inspired by the semantical framework introduced in [29] for deterministic ccp, the sublanguage of ccp with guarded statements but no choice construct. <p> Concerning the agent [[ P n i=1 ask (c i ) ! A i ]], its quiescent points are all those stores d for which the agent suspends immediately, i.e. d 2 T n i=1 * c i , plus those stores d which activate a branch i 2 <ref> [1; n] </ref>, i.e. c i v d, and which are quiescent points for A i , i.e. d 2 [[A i ]]. For the parallel operator we have that d is a quiescent point of A k B iff it is a quiescent point of both A and B. <p> Proof By structural induction on A. A = stop. Obvious. A = tell (c). Obvious. A = =1 ask (c ) ! A . Assume c 2 F (Quie fin )(A). Then either c 2 T n i=1 * c i or there exists i 2 <ref> [1; n] </ref> such that c 2 * c i " F (Quie fin )(A i ), i.e. c i v c and c 2 F (Quie fin )(A i ). In the first case hA; ci deadlocks and therefore c is a resting point. <p> A = tell (c). Immediate since c 2 F " 1 (A). A = =1 ask (c ) ! A . If hA; ci deadlocks then c 2 T n i=1 * c i and therefore c 2 F " 1 (A). Otherwise, there exists i 2 <ref> [1; n] </ref> such that c i v c, hA; ci ! hA i ; ci is the first step of , and c 2 Quie fin (A i ).
Reference: [2] <author> J.W. de Bakker and J.I. </author> <title> Zucker Processes and the denotational semantics of concurrency. </title> <journal> Information and Control, </journal> <volume> volume 54, </volume> <pages> pages 70-120, </pages> <year> 1982. </year>
Reference-contexts: These sets are Egli-Milner equivalent. Instead of looking for an appropriate ordering we could try to define the limit in terms of an appropriate metrics on sets of constraints (for the general metric approach to the semantics of concurrent programming languages see <ref> [2] </ref>). However the example given below clearly shows that this approach does not work either.
Reference: [3] <author> F.S. de Boer, J.N. Kok, C. Palamidessi, and J.J.M.M. Rutten. </author> <title> Semantic models for Concurrent Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 86(1), </volume> <pages> 3-33, </pages> <year> 1991. </year>
Reference-contexts: On such domains there are well established techniques which allow to treat infinite computations, and they can be fruitfully applied also in the case of concurrent logic programming and concurrent constraint programming, see for instance <ref> [3] </ref>, which is based on metric spaces. In various sublanguages of ccp, however, the domain of denotations for finite computations is very abstract: sets of constraints.
Reference: [4] <author> F.S. de Boer, J.N. Kok, C. Palamidessi, and J.J.M.M. Rutten. </author> <title> A paradigm for asynchronous communication and its application to concurrent constraint programming. In Logic Programming Languages: Constraints, Functions, and Objects, </title> <booktitle> Series in Logic Programming, </booktitle> <pages> pages 82-114. </pages> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The following example of Herbrand constraint system is taken from <ref> [4] </ref>. Consider an alphabet containg the variable symbols x and y, and constant symbols a and b.
Reference: [5] <author> F.S. de Boer, M. Gabbrielli, E. Marchiori, and C. Palamidessi. </author> <title> Proving Concurrent Constraint Programs Correct. </title> <booktitle> In Proc. Eighteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1993. </year>
Reference-contexts: The significance of this notion relies on the "declarative flavour" of ccp: In the so-called declarative interpretation, a set of ccp declarations is regarded as a logical theory (see <ref> [5] </ref>): the parallel operator is interpreted as conjunction, the choice as disjunction, the hiding operator as existential quantifier, tell (c) as c, ask (c) ! A as a form of implication, and p (x) :- B as the logical equivalence of p (x) and B.
Reference: [6] <author> F.S. de Boer and C. Palamidessi. </author> <title> A fully abstract model for concurrent constraint programming. </title> <editor> In S. Abramsky and T.S.E. Maibaum, editors, </editor> <booktitle> Proc. of TAPSOFT/CAAP, volume 493 of Lecture Notes in Computer Science, </booktitle> <pages> pages 296-319. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [7] <author> F.S. de Boer and C. Palamidessi. </author> <title> On the semantics of concurrent constraint programming. </title> <booktitle> Invited paper in Proc. of ALPUK 92, Workshops in Computing, </booktitle> <pages> pages 145-173, </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In other words, they are relative to a particular path along the constraint system. These two approaches are of course equivalent because they are both fully abstract; for the exact correspondence between them see <ref> [7] </ref>. Both the above mentioned approaches do not capture the infinite observables. However there is in literature a standard solution to extend domains based on traces (or on analogous structures) so to make it possible to capture the infinite behavior. This is the well known metric approach ([2]).
Reference: [8] <author> K.L. Clark. </author> <title> Predicate logic as a computational formalism. Res. </title> <type> Report DOC 79/59, </type> <institution> Imperial College, Dept. of Computing, </institution> <address> London, </address> <year> 1979. </year>
Reference: [9] <author> M. van Emden and R. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference: [10] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative modeling of the operational behavior of logic languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year> <month> 32 </month>
Reference: [11] <author> M. Falaschi, M. Gabbrielli, K. Marriott, and C. Palamidessi. </author> <title> Confluence and Concurrent Constraint Programming. </title> <type> Technical Report, </type> <institution> Dipartimento di Informatica, Universita di Pisa, Pisa. </institution> <year> 1994. </year>
Reference-contexts: Besides deterministic ccp one can consider other restrictions of ccp. For instance one might want to maintain the possibility of having alternative results, but in a way which is independent from the process scheduling. Such language, called confluent ccp, has been proposed in <ref> [11] </ref> mainly as an intermediate language for the static analysis of ccp programs by means of abstract interpretation techniques. This language is interesting in itself because it is much more expressive than deterministic ccp. <p> As a consequence, we can reasonably assume that an agent which is enabled will be eventually executed. Formally this assumption is described in terms of certain fairness requirements on the computations. 9 In order to define fair computations, we introduce the notions of enabled and active agents, following <ref> [11] </ref>. Intuitively, the active agent is the unique "primitive" sub-agent actually reduced by a particular transition. Note that a transition is derived from the rules via a proof tree which has at the top one and only one instance of one of the axioms R1, R2, or R3. <p> For restricted-choice ccp a solution has been proposed in <ref> [11] </ref>. The idea is to consider the denotation of a process as set of sets of quiescient points. Intuitively the inner set represents the activity of the process along one branch.
Reference: [12] <author> W.G. Golson. </author> <title> Toward a declarative semantics for infinite objects in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 5 </volume> <pages> 151-164, </pages> <year> 1988. </year>
Reference-contexts: Differences among these approaches depend on the kind of completion techniques applied on the underlying data structure, mainly based on partial orderings or metrics. However all these works have not been able to reach a full correspondence with the operational semantics. In the partial ordering completion of <ref> [12] </ref> only minimal answers are characterized. Furthermore the construction only works for clauses which contain at least one global variable.
Reference: [13] <editor> L. Henkin, J.D. Monk, and A. Tarski. Cylindric Algebras (Part I). </editor> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference-contexts: All the other axioms are axioms or theorems in <ref> [13] </ref>; note however that a cylindric constraint system in general is not a cylindric algebra. In fact, a cylindric algebra is based on a Boolean algebra, whereas the structure (Con; t; u; true; false), u denoting the greatest lower bound (glb), is not necessarily a Boolean algebra. <p> The main reasons are that t and u in general do not distribute, and that the complement of a constraint does not necessarily exists. As a consequence, some of the properties of cylindrification and diagonal elements which hold in <ref> [13] </ref>, are not valid here. <p> Furthermore one of the specific laws of cylindrification, 9 x false = false (Axiom C 1 in <ref> [13] </ref>), is not present here. This axiom for instance would allow us to derive 9 x c t 9 y d = false iff 9 y c t 9 x d = false (Theorem 1.2.15 in [13]). <p> the specific laws of cylindrification, 9 x false = false (Axiom C 1 in <ref> [13] </ref>), is not present here. This axiom for instance would allow us to derive 9 x c t 9 y d = false iff 9 y c t 9 x d = false (Theorem 1.2.15 in [13]). One might want to enrich the theory of cylindric constraint systems with (some of) these laws, so to restrict the possible interpretations of 9 x and d xy .
Reference: [14] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119, </pages> <year> 1987. </year>
Reference-contexts: In other words, the operations can only modify the store by adding further constraints. In this sense they have a pure declarative nature. Constraint programming has been succesfully combined with another declarative paradigm, the language of logic programming ([9, 19]), thus giving raise to constraint logic programming (clp, <ref> [14, 15] </ref>). Essentially, clp extends logic programming in that it generalises the concept of a binding on a synctactical domain of data (the Herbrand universe), to an element of a domain described by a logical theory (constraint system). <p> A different approach, based on adding to the program some suitable clauses containing indefinite terms, and then applying a least fixpoint construction, has been developed in [18]. However, also in this case the full correspondence is not achieved. For the sake of completeness we cite here also <ref> [14] </ref>, in which infinite computations have been studied from a declarative point of view, with the purpose of establishing a distinction between infinite successes and infinite failures. An infinite computation is "successful" whenever all partial results of the computation allow the same solution (hence the limit result has a solution). <p> O (A)true. 8 The notion of observables was actually a bit different from O fin , but the difference is unessential here. 9 Actually in the original definition of clp the choice is not blind as in Table 4: in <ref> [14] </ref> the choice is driven by the requirement that the immediate tell actions of the selected branch will not bring to an inconsistent store. However this condition is only motivated by efficiency reasons, and the only consequence it has on the observables is that it eliminates the false result.
Reference: [15] <author> J. Jaffar and M.J. </author> <title> Maher Constraint Logic Programming: </title> <type> A survey Technical report, </type> <institution> IBM Thomas J. Watson Research Center, </institution> <address> Yorktown Heights, NY. </address> <year> 1994. </year> <note> To appear in a special issue of the Journal of Logic Programming. </note>
Reference-contexts: In other words, the operations can only modify the store by adding further constraints. In this sense they have a pure declarative nature. Constraint programming has been succesfully combined with another declarative paradigm, the language of logic programming ([9, 19]), thus giving raise to constraint logic programming (clp, <ref> [14, 15] </ref>). Essentially, clp extends logic programming in that it generalises the concept of a binding on a synctactical domain of data (the Herbrand universe), to an element of a domain described by a logical theory (constraint system).
Reference: [16] <author> R. Jagadeesan, V.A. Saraswat, and V. Shanbhogue. </author> <title> Angelic non-determinism in concurrent constraint programming. </title> <type> Technical report, </type> <institution> Xerox Park, </institution> <year> 1991. </year>
Reference-contexts: The denotational model we are going to describe is inspired by the semantical framework introduced in [29] for deterministic ccp, the sublanguage of ccp with guarded statements but no choice construct. This framework has been successively extended in <ref> [16] </ref> and [20] so to treat angelic ccp, where local choice is allowed 7 . <p> We come back to this point in Example 4.12. We use a different domain from the one choosen in <ref> [16, 20] </ref>, which does not present the above described problem. Actually our construction would be still valid for structurally confluent ccp ([11]), a language which is operationally characterized by the property that every subagent is confluent, and which is therefore a super-language of restricted-choice ccp. <p> be expressed in terms of the set of its fixponts ~ f A = fC j f A (C) = Cg; in fact, from these three properties it follows that f A (C) = fC 0 j C C 0 and C 0 2 ~ f A g: 7 In <ref> [16, 20] </ref> angelic ccp is not presented as local-choice ccp, since the operational semantics describes global choice instead. <p> But, as the authors themselves point out, their operational semantics does not reflect the intended model, and from the denotational semantics and the correspondence with the observables it appears clear that the intended language amounts exactly to local-choice ccp. Note that the observables in <ref> [16, 20] </ref> are defined differently, but it is possible to prove that they are equivalent to our notion O uc . <p> All the other equations hold also for the quiescent points of full ccp. It is interesting to note that the equation of the choice construct can be derived from the semantic equations of angelic ccp as described in <ref> [16] </ref> by transforming the mutually-exclusive choices into parallel processes as 13 described before. The equations in Table 2 fix the interpretation of all the operators which can occur in an agent, but do not identify an unique [[]]. This is a well known phenomenon due to recursion. <p> Therefore we have F ( T T i I i )(p (x)) = ffalseg. On the other hand true 2 99 x F (I i )(p (x)) = F (I i )(9 x p (x)) for every i, therefore true 2 T To overcome this problem, <ref> [16] </ref> suggests to restrict to interpretations which map agents into Scott-compact sets. A set C Con is Scott-compact iff for every set D Con 0 , which is a covering for C, i.e.
Reference: [17] <author> D.J. Lehmann. </author> <title> Categories for Fixed-point Semantics. </title> <type> PhD thesis, </type> <institution> Hebrew University of Jerusalem, </institution> <year> 1976. </year>
Reference: [18] <author> G. Levi and C. Palamidessi. </author> <title> Contributions to the semantics of logic perpetual processes. </title> <journal> Acta Informatica, </journal> <volume> 25(6) </volume> <pages> 691-711, </pages> <year> 1988. </year>
Reference-contexts: Hence a limit element obtained in the fixpoint construction might be unobtainable operationally. A different approach, based on adding to the program some suitable clauses containing indefinite terms, and then applying a least fixpoint construction, has been developed in <ref> [18] </ref>. However, also in this case the full correspondence is not achieved. For the sake of completeness we cite here also [14], in which infinite computations have been studied from a declarative point of view, with the purpose of establishing a distinction between infinite successes and infinite failures.
Reference: [19] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: In particular we aim at distinguishing the problems connected to the treatment of these two aspects from the problems related to synchronization, which as stated before requires anyway sequences-like structures. 1 The language investigated in <ref> [22, 19] </ref> is pure logic programming, hence constraints are equalities over the Herbrand universe, and solutions are syntactical unifiers. 2 T P # ! is the limit of the decreasing sequence B; T P (B); T 2 P (B); : : : where B is the Herbrand base (the top element
Reference: [20] <author> M. Z. Kwiatkowska. </author> <title> Infinite Behavior and Fairness in Concurrent Constraint Programming. </title> <editor> In J. W. de Bakker, W. P.de Roever, and G. Rozenberg, editors, </editor> <booktitle> Semantics: Foundations and Applications, volume 666 of Lecture Notes in Computer Science, </booktitle> <pages> pages 348-383, </pages> <address> Beekbergen The Netherlands, </address> <month> June </month> <year> 1992. </year> <title> REX Workshop, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: The denotational model we are going to describe is inspired by the semantical framework introduced in [29] for deterministic ccp, the sublanguage of ccp with guarded statements but no choice construct. This framework has been successively extended in [16] and <ref> [20] </ref> so to treat angelic ccp, where local choice is allowed 7 . <p> We come back to this point in Example 4.12. We use a different domain from the one choosen in <ref> [16, 20] </ref>, which does not present the above described problem. Actually our construction would be still valid for structurally confluent ccp ([11]), a language which is operationally characterized by the property that every subagent is confluent, and which is therefore a super-language of restricted-choice ccp. <p> be expressed in terms of the set of its fixponts ~ f A = fC j f A (C) = Cg; in fact, from these three properties it follows that f A (C) = fC 0 j C C 0 and C 0 2 ~ f A g: 7 In <ref> [16, 20] </ref> angelic ccp is not presented as local-choice ccp, since the operational semantics describes global choice instead. <p> But, as the authors themselves point out, their operational semantics does not reflect the intended model, and from the denotational semantics and the correspondence with the observables it appears clear that the intended language amounts exactly to local-choice ccp. Note that the observables in <ref> [16, 20] </ref> are defined differently, but it is possible to prove that they are equivalent to our notion O uc .
Reference: [21] <author> M. J. Maher. </author> <title> Logic semantics for a class of committed-choice programs. </title> <editor> In Jean-Louis Lassez, editor, </editor> <booktitle> Proc. of the Fourth International Conference on Logic Programming, Series in Logic Programming, </booktitle> <pages> pages 858-876, </pages> <address> Melbourne, 1987. </address> <publisher> The MIT Press. </publisher>
Reference: [22] <author> M.A. Nait Abdallah. </author> <title> On the interpretation of infinite computations in logic programming. </title> <editor> In J. Paredaens, editor, </editor> <booktitle> Proc. of Automata, Languages and Programming, </booktitle> <volume> volume 172, </volume> <pages> pages 374-381. </pages> <publisher> Springer Verlag, </publisher> <year> 1984. </year>
Reference-contexts: In particular we aim at distinguishing the problems connected to the treatment of these two aspects from the problems related to synchronization, which as stated before requires anyway sequences-like structures. 1 The language investigated in <ref> [22, 19] </ref> is pure logic programming, hence constraints are equalities over the Herbrand universe, and solutions are syntactical unifiers. 2 T P # ! is the limit of the decreasing sequence B; T P (B); T 2 P (B); : : : where B is the Herbrand base (the top element
Reference: [23] <author> S. Nystrom and B. Jonsson. </author> <title> Indeterminate concurrent constraint programming: A fixpoint semantics for non-terminating computations. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proc. International Symposium on Logic Programming'93, </booktitle> <pages> pages 335-352. </pages> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: These two models have been shown to be fully abstract wrt the results of finite computations (and therefore equivalent). Another approach, based on application of category theory on top of the reactive sequences, and capturing also infinite computations, has been developed in <ref> [23] </ref>. Of course, restrictions on the basic paradigm allow the construction of simpler denotational models. <p> In this way the activity of a process corresponds semantically to a contraction, which always has a fixpoint. The problem of this approach is that in general it is not fully abstract. Recently <ref> [23] </ref> has shown that a fully abstract model for ccp can be obtained by using categorical techniques. More specifically, [23] applies the Lehmann's powerdomain construction ([17]) over the basic domain of reactive sequences. <p> The problem of this approach is that in general it is not fully abstract. Recently <ref> [23] </ref> has shown that a fully abstract model for ccp can be obtained by using categorical techniques. More specifically, [23] applies the Lehmann's powerdomain construction ([17]) over the basic domain of reactive sequences. <p> Concerning the second problem (combination of nondeterminism and infinite behavior), the point is that it is difficult to find the appropriate domain structure in which to define an operator characterizing the limits of infinite computations, unless we encode also the history of the computation as it is done in <ref> [23] </ref>. In the work of [23] however it is not clear whether the (reactive) sequences are necessary only to deal with synchronization or they play a role also wrt the infinite behavior. <p> (combination of nondeterminism and infinite behavior), the point is that it is difficult to find the appropriate domain structure in which to define an operator characterizing the limits of infinite computations, unless we encode also the history of the computation as it is done in <ref> [23] </ref>. In the work of [23] however it is not clear whether the (reactive) sequences are necessary only to deal with synchronization or they play a role also wrt the infinite behavior. <p> Encoding in some way the links among constraints belonging to the same branch could bring to the solution of our problem. A way to do so is to consider an appropriate category. The idea, inspired by the work of <ref> [23] </ref>, is to consider objects X; Y; : : : which are (multi)sets of constraints and morphisms f : X ! Y which are relations f X fi Y such that hc; di 2 f iff c v d, and such that each element of Y is in relation with (at
Reference: [24] <author> B.C. Pierce. </author> <title> Basic Category Theory for Computer Scientists. </title> <booktitle> Foundations of Computing Series, </booktitle> <year> 1991. </year>
Reference-contexts: For more details see for instance <ref> [24] </ref>.
Reference: [25] <author> G. Plotkin. </author> <title> A structured approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1981. </year>
Reference: [26] <author> G. Plotkin. </author> <title> Domains. </title> <institution> Department of Computer Science, University of Edimburgh, </institution> <year> 1992. </year> <booktitle> Post-graduate lecture notes in advanced domain theory (incorporating the 'Pisa notes' 1981). </booktitle>
Reference-contexts: These sets are Smyth equivalent. One could try other relations, like the Hoare preordering or the Egli-Milner preordering (see for example <ref> [26] </ref>). The latter is the most refined, as it corresponds to the intersection of the other two. However, next example shows that also the Egli-Milner preordering is not suitable for our purposes. Example 5.7 (Egli-Milner preordering) Let c v d.
Reference: [27] <author> V.A.Saraswat. </author> <title> Concurrent Constraint Programming. </title> <type> PhD thesis, </type> <address> Carnegie-Mellon University.1989. </address> <booktitle> In ACM distinguished dissertation series. </booktitle> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The intuition was to define synchronization in terms of a rule which enables a computation step when the store entails a given constraint. This idea was the precursor of the ask primitive of concurrent constraint programming (ccp, <ref> [27, 28, 29] </ref>), which can be considered one of the most elegant proposals in this field. The computational model of ccp can be summarized as follows: All processes share a common store, which consists of all the constraints established until that moment. <p> in the theory of cylindric algebras but also in the theory of cylindric constraint systems. 4 Except for one result in Section 4.1 relative to mutually-exclusive choice, for which we need to assume that 9 x false = false. 6 3 The language ccp Concurrent constraint programming was proposed in <ref> [27] </ref> and then refined in [28, 29]. We follow here the definition of [29]. Assume given a cylindric constraint system C on a set of variables Var .
Reference: [28] <author> V.A. Saraswat and M. Rinard. </author> <title> Concurrent constraint programming. </title> <booktitle> In Proc. Seventeenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <address> New York, </address> <year> 1990. </year>
Reference-contexts: The intuition was to define synchronization in terms of a rule which enables a computation step when the store entails a given constraint. This idea was the precursor of the ask primitive of concurrent constraint programming (ccp, <ref> [27, 28, 29] </ref>), which can be considered one of the most elegant proposals in this field. The computational model of ccp can be summarized as follows: All processes share a common store, which consists of all the constraints established until that moment. <p> It can be shown that T P # ! is the complement of the set of finite failures. 3 2 Constraint Systems We adopt the approach of <ref> [28] </ref>, which defines the notion of constraint system along the lines of Scott's information systems ([30]). Intuitively, an information system consists of a set of elements each of which represents some "consistent information", and an entailment relation ` which establishes which elements can be derived from which other ones. <p> Intuitively, an information system consists of a set of elements each of which represents some "consistent information", and an entailment relation ` which establishes which elements can be derived from which other ones. In the view of <ref> [28] </ref>, a constraint system is the same kind of structure, the only difference is the presence of an additional element representing inconsistency. <p> The term "constraint" refers to the fact that the elements of a constraint system usually involve variables, i.e. they establish bounds to the range of values that such variables can assume. Following <ref> [28] </ref>, we regard a constraint system as a complete algebraic lattice in which the ordering v is the reverse of the the entailment relation (c v d means that d contains "more information" than c). <p> The top element false represents inconsistency, the bottom element true is the empty constraint, and the least upper bound (lub) t represents the join of information, i.e. the logical and. We refer to <ref> [28] </ref> for more details about the construction of such a structure. <p> = ag fy = ag fx = yg fy = bg fx = bg x = a; oe ae y = b x = b; oe ae y = b false 2.1 Cylindric Constraint Systems In order to model hiding of local variables and parameter passing in constraint programming, in <ref> [28] </ref> the notion of constraint system is enriched with cylindrification operators and diagonal elements, concepts borrowed from the theory of cylindric algebras (Henkin, Monk and Tarski,[13]). <p> Figure 2 represents the part of the cylindric constraint system in which x (and only x) is free. For simplicity we have indicated a set ft = ug by t = u. The laws of cylindric constraint systems given above have been proposed in <ref> [28] </ref>. <p> algebras but also in the theory of cylindric constraint systems. 4 Except for one result in Section 4.1 relative to mutually-exclusive choice, for which we need to assume that 9 x false = false. 6 3 The language ccp Concurrent constraint programming was proposed in [27] and then refined in <ref> [28, 29] </ref>. We follow here the definition of [29]. Assume given a cylindric constraint system C on a set of variables Var .
Reference: [29] <author> V.A. Saraswat, M. Rinard, and P. Panangaden. </author> <title> Semantics foundations of concurrent constraint programming. </title> <booktitle> In Proc. Eighteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <address> New York, </address> <year> 1991. </year>
Reference-contexts: The intuition was to define synchronization in terms of a rule which enables a computation step when the store entails a given constraint. This idea was the precursor of the ask primitive of concurrent constraint programming (ccp, <ref> [27, 28, 29] </ref>), which can be considered one of the most elegant proposals in this field. The computational model of ccp can be summarized as follows: All processes share a common store, which consists of all the constraints established until that moment. <p> For instance deterministic ccp has the property that the (finite and infinite) results computed by an agent A starting from an arbitrary store can be retrieved from the quiescent points of A, and on the basis of this observation in <ref> [29] </ref> a very simple denotational semantics has been developed based on Scott's closure operators. The quiescent points of an agent actually have a compositional characterization also in the case of confluent ccp, 2 but they only allow to retrieve the upward-closure of the results, not the results themselves. <p> algebras but also in the theory of cylindric constraint systems. 4 Except for one result in Section 4.1 relative to mutually-exclusive choice, for which we need to assume that 9 x false = false. 6 3 The language ccp Concurrent constraint programming was proposed in [27] and then refined in <ref> [28, 29] </ref>. We follow here the definition of [29]. Assume given a cylindric constraint system C on a set of variables Var . <p> We follow here the definition of <ref> [29] </ref>. Assume given a cylindric constraint system C on a set of variables Var . <p> Furthermore, name clashes between the formal parameter and occurrences of y in the agent must be avoided. The solution proposed in <ref> [29] </ref> is the following: if the body of p (y) is A, then the call p (x) is replaced by x y A, which stands for 9 d xff ff 9 y A, where ff is a variable which is assumed not to occur free in the declarations and in the <p> The denotational model we are going to describe is inspired by the semantical framework introduced in <ref> [29] </ref> for deterministic ccp, the sublanguage of ccp with guarded statements but no choice construct. This framework has been successively extended in [16] and [20] so to treat angelic ccp, where local choice is allowed 7 .
Reference: [30] <author> D. Scott. </author> <title> Domains for denotational semantics. </title> <booktitle> In Proc. of ICALP, </booktitle> <year> 1982. </year> <month> 33 </month>
Reference: [31] <author> E. Shapiro. </author> <title> The family of concurrent logic programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3):412--510, </volume> <year> 1989. </year>
Reference-contexts: There have been several attempts to define mechanisms for concurrency within the logical paradigm, in order to mantain the declarative nature of the language (for a survey see <ref> [31] </ref>), but the first successful proposal was the work of Maher ([21]) in the context of clp. The intuition was to define synchronization in terms of a rule which enables a computation step when the store entails a given constraint.
Reference: [32] <author> M.B. Smyth. </author> <title> Powerdomains. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 16 </volume> <pages> 23-36, </pages> <year> 1978. </year> <month> 34 </month>
References-found: 32

