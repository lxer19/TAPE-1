URL: ftp://ftp.cs.washington.edu/tr/1994/01/UW-CSE-94-01-04.PS.Z
Refering-URL: http://www.cs.washington.edu/research/arch/sim-par-ip.html
Root-URL: 
Title: A Parallel Trace-driven Simulator: Implementation and Performance  
Author: Xiaohan Qin and Jean-Loup Baer 
Date: September 8, 1994  
Address: Seattle, Wa, 98195  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington  
Abstract: The simulation of parallel architectures requires an enormous amount of CPU cycles and, in the case of trace-driven simulation, of disk storage. In this paper, we consider the evaluation of the memory hierarchy of multiprocessor systems via parallel trace-driven simulation. We refine Lin et al.[10] original algorithm, whose main characteristic is to insert the shared references from every trace in all other traces, by reducing the amount of communication between simulation processes. We have implemented our algorithm on a KSR-1. Results of our experiments on traces of four applications and three different cache coherence protocols show that parallel trace-driven simulation yields significant speedups over its sequential counter-part. The communication overhead is not substantial compared to the dominant overhead due to the processing of replicated inserted references. We also investigate filtering techniques for multiprocessor traces. We show how to filter -in parallel- private and shared references. Our technique generates filtered traces for various block sizes in a single pass. As expected, the simulation of filtered traces is much faster but parallel simulation of filtered traces is not as effective since the ratio of unfiltered shared to private references is now much larger. fl This work was supported in part by NSF Grants CCR-91-01541 and CCR-91-23308
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> James Archibald and Jean-Loup Baer. </author> <title> "Cache Coherence Protocols: Evaluation Using a Multiprocessor Simulation Model". </title> <journal> ACM Transactions on Computer Systems, Vol.4, </journal> <volume> No.4, </volume> <month> November </month> <year> 1986, </year> <month> pp273-298 </month>
Reference-contexts: a message to the simulation process whose input trace contains the corresponding shared reference; endcase update the status of cache i ; endwhile endparalleldo 4 3 The Communication Problem In order to test the viability of parallel trace-driven simulation, we looked at three cache coherence protocols, Berkeley, Illinois and Firely <ref> [1] </ref>. They are interesting because the number of synchronization points increase with each protocol (see Table 1).
Reference: [2] <author> Luis Barriga and Rassul Ayani. </author> <title> "Parallel Cache Simulation on Multiprocessor Workstations". </title> <booktitle> 1993 International Conference on Parallel Processing, </booktitle> <address> I171-I174 </address>
Reference-contexts: We consider only simulation with real traces as input since the generation of synthetic traces does not appear to offer any speed advantage in a multiprocessor environment <ref> [2] </ref> with the drawbacks of having to choose the system and application parameters to characterize the resource demands of a certain workload. Our experiments will be based on real traces collected on the Sequent multiprocessor system using MPTrace [6]. <p> It is well-known that trace-driven simulation is I/O intensive <ref> [2] </ref>. For parallel trace-driven simulation, it would be most efficient if concurrent simulation processes could read their own input traces in parallel. Unfortunately, for most parallel systems, parallel I/O, i.e., I/O at each node of the system, is not available.
Reference: [3] <author> Eric A. Brewer, Chrysanthos N.Dellarocas, Adrian Colbrook and William E.Weihl. "PROTEUS: </author> <title> A High-Performance Parallel-Architecture Simulator". </title> <type> Technical Report MIT/LCS/TR-516, </type> <institution> Laboratory for Computer Science, MIT </institution>
Reference-contexts: Moreover, an additional motivation is that the functioning of the target system exhibits natural parallelism: instructions from distinct simulated processors may be issued and carried out independently and concurrently. State of the art simulators of parallel architectures such as Proteus <ref> [3] </ref> and Tango [8] run on single processor workstations. Recently execution-driven parallel simulators for parallel architectures [12, 4] have been implemented on specific parallel architectures (the TMI CM-5 and BBN Butterfly respectively). The challenge in these parallel simulators is to have effective means to simulate the communication among processors.
Reference: [4] <author> Eugene D. Brooks III, Timothy S. Axelrod, Gregory A. Darmohray. </author> " <title> The Cerberus Multiprocessor Simulator" </title>
Reference-contexts: State of the art simulators of parallel architectures such as Proteus [3] and Tango [8] run on single processor workstations. Recently execution-driven parallel simulators for parallel architectures <ref> [12, 4] </ref> have been implemented on specific parallel architectures (the TMI CM-5 and BBN Butterfly respectively). The challenge in these parallel simulators is to have effective means to simulate the communication among processors.
Reference: [5] <author> David Chaiken, Craig Fields, Kiyoshi Kurihara and Anant Agarwal. </author> <title> "Directory-Based Cache Coherence in Large-Scale Multiprocessors". </title> <booktitle> Computer, </booktitle> <month> June </month> <year> 1990 </year>
Reference-contexts: In this paper, we consider the evaluation of the memory hierarchy of multiprocessor systems via parallel trace-driven simulation. Trace-driven simulation can be used to simulate the effect of various cache coherence protocols, cache configurations and organizations, and can also take into account the network topology and its parameters <ref> [5] </ref>. We consider only simulation with real traces as input since the generation of synthetic traces does not appear to offer any speed advantage in a multiprocessor environment [2] with the drawbacks of having to choose the system and application parameters to characterize the resource demands of a certain workload.
Reference: [6] <author> S.J. Eggers, D.R. Keppel, E.J. Koldinger and H.M. Levy. </author> <title> "Techniques for Efficient Inline Tracing on a Shared-Memory Multiprocessor". </title> <booktitle> 1990 ACM Sigmetrics conference on Measurement and Modeling of Computer Systems, </booktitle> <address> pp37-47, </address> <year> 1990 </year>
Reference-contexts: Our experiments will be based on real traces collected on the Sequent multiprocessor system using MPTrace <ref> [6] </ref>. The remainder of the paper is organized as follows: In Section 2 we present the basic idea of the parallel trace-driven simulation [10]. In Section 3 we describe how the communication problem was handled in the original algorithm and our techniques to reduce the amount of unnecessary communication.
Reference: [7] <author> S.J. Eggers, E.J. Koldinger and H.M. Levy. </author> <title> "On the Validity of Trace-Driven Simulation for Multiprocessors". </title> <booktitle> The Proceedings of International Symposium on Computer Architecture, </booktitle> <year> 1991, </year> <note> pp244-253 16 </note>
Reference: [8] <author> H.Davis, S. Goldschmidt and J.L. Hennessy. </author> <title> "Multiprocessor simulation and tracing using Tango". </title> <booktitle> Proceedings of the 1991 International Conference on Parallel Processing, </booktitle> <volume> Vol. I, pp.99-107, </volume> <year> 1991 </year>
Reference-contexts: Moreover, an additional motivation is that the functioning of the target system exhibits natural parallelism: instructions from distinct simulated processors may be issued and carried out independently and concurrently. State of the art simulators of parallel architectures such as Proteus [3] and Tango <ref> [8] </ref> run on single processor workstations. Recently execution-driven parallel simulators for parallel architectures [12, 4] have been implemented on specific parallel architectures (the TMI CM-5 and BBN Butterfly respectively). The challenge in these parallel simulators is to have effective means to simulate the communication among processors.
Reference: [9] <institution> Kendall Square Research. "Technical Summary". </institution> <year> 1992 </year>
Reference-contexts: The simulation process can then proceed as in the algorithm given in Section 3. 4.3 The Communication Cost on Shared Memory Cache Coherent Ar chitectures Our parallel trace-driven simulator has been implemented on KSR-1 a shared memory architecture with coherent caches <ref> [9] </ref>. Each simulation process is on a different KSR-1 node (processor + cache). Communication between the simulation processes is through sender/receiver message queues (see Figure 1) located in the sender's memory.
Reference: [10] <author> Yi-Bing Lin, Edward D. Lazowska, Jean-Loup Baer. </author> <title> "Parallel Trace-Driven Simulation of Multiprocessor Cache Performance: Algorithms and Analysis". Progress in Simulation, Vol.1 No.1, </title> <publisher> Ablex Publishing, </publisher> <address> pp44-80, </address> <year> 1989 </year>
Reference-contexts: Our experiments will be based on real traces collected on the Sequent multiprocessor system using MPTrace [6]. The remainder of the paper is organized as follows: In Section 2 we present the basic idea of the parallel trace-driven simulation <ref> [10] </ref>. In Section 3 we describe how the communication problem was handled in the original algorithm and our techniques to reduce the amount of unnecessary communication. In Section 4 we discuss implementation issues. <p> In the multiprocessor traces, memory references can be divided into two types: private references and shared references with only the shared references having potential effects on the status of other processors' caches. The basic idea of the parallel simulation <ref> [10] </ref> is to preprocess the input traces so that the shared references of each input trace are inserted into all the other input trace files. Then the preprocessed input trace files for each simulated processor can be read in and simulated concurrently. <p> They are interesting because the number of synchronization points increase with each protocol (see Table 1). According to Table 1, there is no need for any kind of communication for the Berkeley protocol (see <ref> [10] </ref> for a proof) since each cache simulation process can always decide its status based on its own local information. The parallel simulation processes of the Berkeley protocol can run independently and therefore the parallel simulation of this protocol represents the best case, communication-wise.
Reference: [11] <author> T.R. Puzak. </author> <title> "Analysis of Cache Replacement Algorithms". </title> <type> Ph.D Thesis, </type> <institution> University of Massachusetts. </institution>
Reference-contexts: Reducing the length of the traces will reduce both simulation compute and I/O times and storage space on disk. A number of filtering techniques have been proposed to compact single processor traces <ref> [11, 14] </ref>. Wang and Baer [15] extended trace reduction to multiprocessor traces. The basic idea behind trace reduction is to make use of the cache inclusion property.
Reference: [12] <author> Steven Reinhardt, Mark Hill and James Larus. </author> " <title> The Wisconsin Wind Tunnel: Virtual Prototyping of Parallel Computers". </title> <booktitle> 1993 ACM Sigmetrics Conference on Measurement and Modeling of Computer Systems, </booktitle> <address> pp48-60, </address> <year> 1993 </year>
Reference-contexts: State of the art simulators of parallel architectures such as Proteus [3] and Tango [8] run on single processor workstations. Recently execution-driven parallel simulators for parallel architectures <ref> [12, 4] </ref> have been implemented on specific parallel architectures (the TMI CM-5 and BBN Butterfly respectively). The challenge in these parallel simulators is to have effective means to simulate the communication among processors.
Reference: [13] <author> Jaswinder Pal Singh, Wolf Dietrich Weber and Anoop Gupta. </author> <title> "SPLASH: Stanford Parallel Applications for Shared-Memory". Computer Architecture News, </title> <address> Vol.20, No.1, pp5-44, </address> <month> March </month> <year> 1992 </year>
Reference-contexts: Among the four applications, the first three are in the Splash benchmark suite <ref> [13] </ref>. Water is a scientific application which simulates the evolution of a system of water molecules in the liquid state. Locus is a commercial quality VLSI standard cell router. Mp3d solves problem in rarefied fluid flow simulation.
Reference: [14] <author> A. J. Smith. </author> <title> "Two Methods for the Efficient Analysis of Memory Address Trace Data". </title> <journal> IEEE Transactions on Software Engineering, Vol.3, No.1, </journal> <volume> pp94-101, </volume> <year> 1977 </year>
Reference-contexts: Reducing the length of the traces will reduce both simulation compute and I/O times and storage space on disk. A number of filtering techniques have been proposed to compact single processor traces <ref> [11, 14] </ref>. Wang and Baer [15] extended trace reduction to multiprocessor traces. The basic idea behind trace reduction is to make use of the cache inclusion property.
Reference: [15] <author> Wen-Hann Wang and Jean-Loup Baer. </author> <title> "Efficient Trace-Driven Simulation Methods for Cache Performance Analysis". </title> <journal> ACM Transactions on Computer System, Vol.9, </journal> <volume> No. 3, </volume> <pages> pp 222-241, </pages> <month> August </month> <year> 1991 </year> <month> 17 </month>
Reference-contexts: Reducing the length of the traces will reduce both simulation compute and I/O times and storage space on disk. A number of filtering techniques have been proposed to compact single processor traces [11, 14]. Wang and Baer <ref> [15] </ref> extended trace reduction to multiprocessor traces. The basic idea behind trace reduction is to make use of the cache inclusion property. <p> This means that we need to produce and save reduced traces for every possible block size under study. It is not unlikely that the space savings gained from the trace reduction would be erased by the need to save every filtered trace. Wang and Baer <ref> [15] </ref> advocate generating universal reduced traces by collecting the superset of misses that occur on every cache filter with different block sizes. We describe now a methodology for obtaining such universal reduced traces.
References-found: 15

