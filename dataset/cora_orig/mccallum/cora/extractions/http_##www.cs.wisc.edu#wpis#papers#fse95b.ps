URL: http://www.cs.wisc.edu/wpis/papers/fse95b.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Title: Precise Interprocedural Chopping  
Author: Thomas Reps and Genevieve Rosay 
Keyword: CR Categories and Subject Descriptors: D.2.2 [Software Engineering]: Tools and Techniques programmer workbench; D.2.6 [Software Engineering]: Programming Environments; D.2.7 [Software Engineering]: Distribution and Maintenance enhancement, restructuring; E.1 [Data Structures] graphs General Terms: Algorithms, Performance Additional Key Words and Phrases: program dependence graph, program slicing, program chopping, debugging, interprocedural analysis, graph reachability, realizable path  
Affiliation: University of Wisconsin  
Abstract: Jackson and Rollins introduced a related operation, called program chopping, which is a kind of filtered slice: Chopping answers questions of the form What are all the program elements v that serve to transmit effects from a given source element s to a given target element t? However, Jackson and Rollins define only a limited form of chopping: Among other restrictions, they impose the restriction that s and t be in the same procedure. This paper solves the unrestricted interprocedural chopping problem, as well as a variety of other useful variants of interprocedural chopping. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Agrawal, H., </author> <title> On slicing programs with jump statements, </title> <booktitle> Proceedings of the ACM SIGPLAN 94 Conference on Programming Language Design and Implementation, </booktitle> <address> (Orlando, FL, </address> <month> June 22-24, </month> <year> 1994), </year> <journal> ACM SIGPLAN Notices 29(6) pp. </journal> <month> 302-312 (June </month> <year> 1994). </year>
Reference-contexts: Thus, the first step is to find all such vertices w: In Proc. of the 3 rd ACM Symp. on Foundations of Software Engineering ((Washington, DC, Oct. 10-13, 1995). hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedSameLevelChop (s, t) returns vertex set begin <ref> [1] </ref> return f m (- s -) b m (- t -) end function SameLevelChop (s, t) returns vertex set declare S: vertex set WorkList: set of summary edges begin [1] S := TruncatedSameLevelChop (s, t) [2] WorkList := - (x, y) SummaryEdges | x, y S - [3] return SameLevelChopAux <p> Foundations of Software Engineering ((Washington, DC, Oct. 10-13, 1995). hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedSameLevelChop (s, t) returns vertex set begin <ref> [1] </ref> return f m (- s -) b m (- t -) end function SameLevelChop (s, t) returns vertex set declare S: vertex set WorkList: set of summary edges begin [1] S := TruncatedSameLevelChop (s, t) [2] WorkList := - (x, y) SummaryEdges | x, y S - [3] return SameLevelChopAux (S, WorkList) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function SameLevelChopAux (Answer, WorkList) returns vertex set parameters Answer: vertex set WorkList: set of summary edges declare S: vertex set begin [4] Remove all marks on <p> (v, w) [12] S := TruncatedSameLevelChop (v, w) [13] Answer := Answer S [14] WorkList := WorkList - (x, y) SummaryEdges | x, y S - [15] fi [17] od [18] return Answer end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedChop (s, t) returns vertex set declare W, VR, VL: vertex sets begin <ref> [1] </ref> W := f unbr (- s -) b unbl (- t -) [2] VR := f unbr (- s -) b unbr (W) [3] VL := f unbl (W) b unbl (- t -) [4] return VR VL end function Chop (s, t) returns vertex set declare W, VR, VL: <p> unbl (- t -) [2] VR := f unbr (- s -) b unbr (W) [3] VL := f unbl (W) b unbl (- t -) [4] return VR VL end function Chop (s, t) returns vertex set declare W, VR, VL: vertex sets WorkList: set of summary edges begin <ref> [1] </ref> /* Perform a TruncatedChop */ [2] W := f unbr (- s -) b unbl (- t -) [3] VR := f unbr (- s -) b unbr (W) [4] VL := f unbl (W) b unbl (- t -) [5] /* Invoke SameLevelChopAux with all summary edges on [6] <p> c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh <ref> [1] </ref> W := f unbr (- s -) b unbl (- t -) In other words, W = - w | s fi unbr * w fi unbl * t -. <p> There are two key ideas behind the improved method: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function SameLevelChopAux (Answer, WorkList) returns vertex set parameters Answer: vertex set WorkList: set of summary edges begin <ref> [1] </ref> Remove all marks on -formal-in, enter-/formal-out pairs [2] Set all b-candidates, b-actual-out, and f-candidates sets to null [3] while WorkList do [4] Select and remove a summary edge (v, w) from WorkList [5] let v = the formal-in or enter vertex that corresponds to v and [6] w = the
Reference: 2. <author> Ball, T. and Horwitz, S., </author> <title> Slicing programs with arbitrary control flow, pp. </title> <booktitle> 206-222 in Proceedings of the First International Workshop on Automated and Algorithmic Debugging, </booktitle> <address> (Linko .. ping, Sweden, </address> <month> May </month> <year> 1993), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 749, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1993). </address>
Reference-contexts: Oct. 10-13, 1995). hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedSameLevelChop (s, t) returns vertex set begin [1] return f m (- s -) b m (- t -) end function SameLevelChop (s, t) returns vertex set declare S: vertex set WorkList: set of summary edges begin [1] S := TruncatedSameLevelChop (s, t) <ref> [2] </ref> WorkList := - (x, y) SummaryEdges | x, y S - [3] return SameLevelChopAux (S, WorkList) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function SameLevelChopAux (Answer, WorkList) returns vertex set parameters Answer: vertex set WorkList: set of summary edges declare S: vertex set begin [4] Remove all marks on -formal-in, enter-/formal-out pairs [5] while WorkList <p> [14] WorkList := WorkList - (x, y) SummaryEdges | x, y S - [15] fi [17] od [18] return Answer end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedChop (s, t) returns vertex set declare W, VR, VL: vertex sets begin [1] W := f unbr (- s -) b unbl (- t -) <ref> [2] </ref> VR := f unbr (- s -) b unbr (W) [3] VL := f unbl (W) b unbl (- t -) [4] return VR VL end function Chop (s, t) returns vertex set declare W, VR, VL: vertex sets WorkList: set of summary edges begin [1] /* Perform a TruncatedChop <p> := f unbr (- s -) b unbr (W) [3] VL := f unbl (W) b unbl (- t -) [4] return VR VL end function Chop (s, t) returns vertex set declare W, VR, VL: vertex sets WorkList: set of summary edges begin [1] /* Perform a TruncatedChop */ <ref> [2] </ref> W := f unbr (- s -) b unbl (- t -) [3] VR := f unbr (- s -) b unbr (W) [4] VL := f unbl (W) b unbl (- t -) [5] /* Invoke SameLevelChopAux with all summary edges on [6] * unbalanced-right paths from s to <p> The next step is to use W find the v's that appear in (): <ref> [2] </ref> VR := f unbr (- s -) b unbr (W) [3] VL := f unbl (W) b unbl (- t -) That is, VR = - v | $ w W such that s fi unbr * v fi unbr * w - and VL = - v | $ <p> There are two key ideas behind the improved method: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function SameLevelChopAux (Answer, WorkList) returns vertex set parameters Answer: vertex set WorkList: set of summary edges begin [1] Remove all marks on -formal-in, enter-/formal-out pairs <ref> [2] </ref> Set all b-candidates, b-actual-out, and f-candidates sets to null [3] while WorkList do [4] Select and remove a summary edge (v, w) from WorkList [5] let v = the formal-in or enter vertex that corresponds to v and [6] w = the formal-out vertex that corresponds to actual-out w [7]
Reference: 3. <author> Bannerjee, U., </author> <title> Speedup of ordinary programs, </title> <type> Ph.D. dissertation and Tech. Rep. </type> <address> R-79-989, Dept. </address> <booktitle> of Computer In Proc. of the 3 rd ACM Symp. on Foundations of Software Engineering ((Washington, </booktitle> <address> DC, </address> <month> Oct. </month> <pages> 10-13, </pages> <year> 1995). </year> <institution> Science, University of Illinois, Urbana, </institution> <address> IL (October 1979). </address>
Reference-contexts: set begin [1] return f m (- s -) b m (- t -) end function SameLevelChop (s, t) returns vertex set declare S: vertex set WorkList: set of summary edges begin [1] S := TruncatedSameLevelChop (s, t) [2] WorkList := - (x, y) SummaryEdges | x, y S - <ref> [3] </ref> return SameLevelChopAux (S, WorkList) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function SameLevelChopAux (Answer, WorkList) returns vertex set parameters Answer: vertex set WorkList: set of summary edges declare S: vertex set begin [4] Remove all marks on -formal-in, enter-/formal-out pairs [5] while WorkList do [6] Select and remove a summary edge (v, w) from WorkList <p> S - [15] fi [17] od [18] return Answer end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedChop (s, t) returns vertex set declare W, VR, VL: vertex sets begin [1] W := f unbr (- s -) b unbl (- t -) [2] VR := f unbr (- s -) b unbr (W) <ref> [3] </ref> VL := f unbl (W) b unbl (- t -) [4] return VR VL end function Chop (s, t) returns vertex set declare W, VR, VL: vertex sets WorkList: set of summary edges begin [1] /* Perform a TruncatedChop */ [2] W := f unbr (- s -) b unbl <p> unbl (W) b unbl (- t -) [4] return VR VL end function Chop (s, t) returns vertex set declare W, VR, VL: vertex sets WorkList: set of summary edges begin [1] /* Perform a TruncatedChop */ [2] W := f unbr (- s -) b unbl (- t -) <ref> [3] </ref> VR := f unbr (- s -) b unbr (W) [4] VL := f unbl (W) b unbl (- t -) [5] /* Invoke SameLevelChopAux with all summary edges on [6] * unbalanced-right paths from s to W or unbalanced-left [7] * paths from W to t */ [8] WorkList <p> The next step is to use W find the v's that appear in (): [2] VR := f unbr (- s -) b unbr (W) <ref> [3] </ref> VL := f unbl (W) b unbl (- t -) That is, VR = - v | $ w W such that s fi unbr * v fi unbr * w - and VL = - v | $ w W such that w fi unbl * v fi unbl <p> There are two key ideas behind the improved method: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function SameLevelChopAux (Answer, WorkList) returns vertex set parameters Answer: vertex set WorkList: set of summary edges begin [1] Remove all marks on -formal-in, enter-/formal-out pairs [2] Set all b-candidates, b-actual-out, and f-candidates sets to null <ref> [3] </ref> while WorkList do [4] Select and remove a summary edge (v, w) from WorkList [5] let v = the formal-in or enter vertex that corresponds to v and [6] w = the formal-out vertex that corresponds to actual-out w [7] in [8] if (v, w) is unmarked then [9] Mark
Reference: 4. <author> Bates, S. and Horwitz, S., </author> <title> Incremental program testing using program dependence graphs, pp. </title> <booktitle> 384-396 in Conference Record of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Charleston, SC, </address> <month> January 10-13, </month> <year> 1993), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1993). </address>
Reference-contexts: To prevent SameLevelChopAux from ever invoking TruncatedSameLevelChop more than once on a given pair of -formal-in, enter-/formal-out vertices, each -formal-in, enter-/formal-out pair taken out of the work-list is marked, and only unmarked pairs cause new calls on Trun-catedSameLevelChop to be performed (see lines <ref> [4] </ref>, [10], [11], and [12]). Bounds on the running times of the different chopping algorithms can be expressed in terms of the following parameters: iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii P The number of procedures in the program. CSites p The number of call sites in procedure p. <p> of summary edges begin [1] S := TruncatedSameLevelChop (s, t) [2] WorkList := - (x, y) SummaryEdges | x, y S - [3] return SameLevelChopAux (S, WorkList) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function SameLevelChopAux (Answer, WorkList) returns vertex set parameters Answer: vertex set WorkList: set of summary edges declare S: vertex set begin <ref> [4] </ref> Remove all marks on -formal-in, enter-/formal-out pairs [5] while WorkList do [6] Select and remove a summary edge (v, w) from WorkList [7] let v = the formal-in or enter vertex that corresponds to v and [8] w = the formal-out vertex that corresponds to actual-out w [9] in [10] <p> iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedChop (s, t) returns vertex set declare W, VR, VL: vertex sets begin [1] W := f unbr (- s -) b unbl (- t -) [2] VR := f unbr (- s -) b unbr (W) [3] VL := f unbl (W) b unbl (- t -) <ref> [4] </ref> return VR VL end function Chop (s, t) returns vertex set declare W, VR, VL: vertex sets WorkList: set of summary edges begin [1] /* Perform a TruncatedChop */ [2] W := f unbr (- s -) b unbl (- t -) [3] VR := f unbr (- s -) <p> end function Chop (s, t) returns vertex set declare W, VR, VL: vertex sets WorkList: set of summary edges begin [1] /* Perform a TruncatedChop */ [2] W := f unbr (- s -) b unbl (- t -) [3] VR := f unbr (- s -) b unbr (W) <ref> [4] </ref> VL := f unbl (W) b unbl (- t -) [5] /* Invoke SameLevelChopAux with all summary edges on [6] * unbalanced-right paths from s to W or unbalanced-left [7] * paths from W to t */ [8] WorkList := - (x, y) SummaryEdges | x, y VR - [9] <p> There are two key ideas behind the improved method: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function SameLevelChopAux (Answer, WorkList) returns vertex set parameters Answer: vertex set WorkList: set of summary edges begin [1] Remove all marks on -formal-in, enter-/formal-out pairs [2] Set all b-candidates, b-actual-out, and f-candidates sets to null [3] while WorkList do <ref> [4] </ref> Select and remove a summary edge (v, w) from WorkList [5] let v = the formal-in or enter vertex that corresponds to v and [6] w = the formal-out vertex that corresponds to actual-out w [7] in [8] if (v, w) is unmarked then [9] Mark (v, w) [10] if
Reference: 5. <author> Binkley, D., </author> <title> Using semantic differencing to reduce the cost of regression testing, </title> <booktitle> Proceedings of the 1992 Conference on Software Maintenance (Orlando, </booktitle> <address> Florida, </address> <month> November 9-12, </month> <year> 1992), </year> <pages> pp. </pages> <month> 41-50 </month> <year> (1992). </year>
Reference-contexts: (s, t) [2] WorkList := - (x, y) SummaryEdges | x, y S - [3] return SameLevelChopAux (S, WorkList) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function SameLevelChopAux (Answer, WorkList) returns vertex set parameters Answer: vertex set WorkList: set of summary edges declare S: vertex set begin [4] Remove all marks on -formal-in, enter-/formal-out pairs <ref> [5] </ref> while WorkList do [6] Select and remove a summary edge (v, w) from WorkList [7] let v = the formal-in or enter vertex that corresponds to v and [8] w = the formal-out vertex that corresponds to actual-out w [9] in [10] if (v, w) is unmarked then [11] Mark <p> VL: vertex sets WorkList: set of summary edges begin [1] /* Perform a TruncatedChop */ [2] W := f unbr (- s -) b unbl (- t -) [3] VR := f unbr (- s -) b unbr (W) [4] VL := f unbl (W) b unbl (- t -) <ref> [5] </ref> /* Invoke SameLevelChopAux with all summary edges on [6] * unbalanced-right paths from s to W or unbalanced-left [7] * paths from W to t */ [8] WorkList := - (x, y) SummaryEdges | x, y VR - [9] - (x, y) SummaryEdges | x, y VL - [10] return <p> function SameLevelChopAux (Answer, WorkList) returns vertex set parameters Answer: vertex set WorkList: set of summary edges begin [1] Remove all marks on -formal-in, enter-/formal-out pairs [2] Set all b-candidates, b-actual-out, and f-candidates sets to null [3] while WorkList do [4] Select and remove a summary edge (v, w) from WorkList <ref> [5] </ref> let v = the formal-in or enter vertex that corresponds to v and [6] w = the formal-out vertex that corresponds to actual-out w [7] in [8] if (v, w) is unmarked then [9] Mark (v, w) [10] if b-candidates (w) = null then [11] b-candidates (w) = b m
Reference: 6. <author> Chase, D.R., Wegman, M., and Zadeck, F.K., </author> <title> Analysis of pointers and structures, </title> <booktitle> Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <address> (White Plains, NY, </address> <month> June 20-22, </month> <year> 1990), </year> <journal> ACM SIGPLAN Notices 25(6) pp. </journal> <month> 296-310 (June </month> <year> 1990). </year>
Reference-contexts: := - (x, y) SummaryEdges | x, y S - [3] return SameLevelChopAux (S, WorkList) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function SameLevelChopAux (Answer, WorkList) returns vertex set parameters Answer: vertex set WorkList: set of summary edges declare S: vertex set begin [4] Remove all marks on -formal-in, enter-/formal-out pairs [5] while WorkList do <ref> [6] </ref> Select and remove a summary edge (v, w) from WorkList [7] let v = the formal-in or enter vertex that corresponds to v and [8] w = the formal-out vertex that corresponds to actual-out w [9] in [10] if (v, w) is unmarked then [11] Mark (v, w) [12] S <p> [1] /* Perform a TruncatedChop */ [2] W := f unbr (- s -) b unbl (- t -) [3] VR := f unbr (- s -) b unbr (W) [4] VL := f unbl (W) b unbl (- t -) [5] /* Invoke SameLevelChopAux with all summary edges on <ref> [6] </ref> * unbalanced-right paths from s to W or unbalanced-left [7] * paths from W to t */ [8] WorkList := - (x, y) SummaryEdges | x, y VR - [9] - (x, y) SummaryEdges | x, y VL - [10] return SameLevelChopAux (VR VL, WorkList) end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c <p> summary edges begin [1] Remove all marks on -formal-in, enter-/formal-out pairs [2] Set all b-candidates, b-actual-out, and f-candidates sets to null [3] while WorkList do [4] Select and remove a summary edge (v, w) from WorkList [5] let v = the formal-in or enter vertex that corresponds to v and <ref> [6] </ref> w = the formal-out vertex that corresponds to actual-out w [7] in [8] if (v, w) is unmarked then [9] Mark (v, w) [10] if b-candidates (w) = null then [11] b-candidates (w) = b m (w) [12] b-actual-out (w) = b m (w) ActualOutVertices [13] fi [14] if f-candidates
Reference: 7. <author> Choi, J.-D. and Ferrante, J., </author> <title> Static slicing in the presence of GOTO statements, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 16(4) pp. </pages> <month> 1097-1113 (July </month> <year> 1994). </year>
Reference-contexts: return SameLevelChopAux (S, WorkList) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function SameLevelChopAux (Answer, WorkList) returns vertex set parameters Answer: vertex set WorkList: set of summary edges declare S: vertex set begin [4] Remove all marks on -formal-in, enter-/formal-out pairs [5] while WorkList do [6] Select and remove a summary edge (v, w) from WorkList <ref> [7] </ref> let v = the formal-in or enter vertex that corresponds to v and [8] w = the formal-out vertex that corresponds to actual-out w [9] in [10] if (v, w) is unmarked then [11] Mark (v, w) [12] S := TruncatedSameLevelChop (v, w) [13] Answer := Answer S [14] WorkList <p> unbr (- s -) b unbl (- t -) [3] VR := f unbr (- s -) b unbr (W) [4] VL := f unbl (W) b unbl (- t -) [5] /* Invoke SameLevelChopAux with all summary edges on [6] * unbalanced-right paths from s to W or unbalanced-left <ref> [7] </ref> * paths from W to t */ [8] WorkList := - (x, y) SummaryEdges | x, y VR - [9] - (x, y) SummaryEdges | x, y VL - [10] return SameLevelChopAux (VR VL, WorkList) end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c <p> [2] Set all b-candidates, b-actual-out, and f-candidates sets to null [3] while WorkList do [4] Select and remove a summary edge (v, w) from WorkList [5] let v = the formal-in or enter vertex that corresponds to v and [6] w = the formal-out vertex that corresponds to actual-out w <ref> [7] </ref> in [8] if (v, w) is unmarked then [9] Mark (v, w) [10] if b-candidates (w) = null then [11] b-candidates (w) = b m (w) [12] b-actual-out (w) = b m (w) ActualOutVertices [13] fi [14] if f-candidates (v) = null then [15] f-candidates (v) = f m (v)
Reference: 8. <author> Ferrante, J., Ottenstein, K., and Warren, J., </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 9(3) pp. </pages> <month> 319-349 (July </month> <year> 1987). </year>
Reference-contexts: Answer: vertex set WorkList: set of summary edges declare S: vertex set begin [4] Remove all marks on -formal-in, enter-/formal-out pairs [5] while WorkList do [6] Select and remove a summary edge (v, w) from WorkList [7] let v = the formal-in or enter vertex that corresponds to v and <ref> [8] </ref> w = the formal-out vertex that corresponds to actual-out w [9] in [10] if (v, w) is unmarked then [11] Mark (v, w) [12] S := TruncatedSameLevelChop (v, w) [13] Answer := Answer S [14] WorkList := WorkList - (x, y) SummaryEdges | x, y S - [15] fi [17] <p> -) [3] VR := f unbr (- s -) b unbr (W) [4] VL := f unbl (W) b unbl (- t -) [5] /* Invoke SameLevelChopAux with all summary edges on [6] * unbalanced-right paths from s to W or unbalanced-left [7] * paths from W to t */ <ref> [8] </ref> WorkList := - (x, y) SummaryEdges | x, y VR - [9] - (x, y) SummaryEdges | x, y VL - [10] return SameLevelChopAux (VR VL, WorkList) end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c <p> all b-candidates, b-actual-out, and f-candidates sets to null [3] while WorkList do [4] Select and remove a summary edge (v, w) from WorkList [5] let v = the formal-in or enter vertex that corresponds to v and [6] w = the formal-out vertex that corresponds to actual-out w [7] in <ref> [8] </ref> if (v, w) is unmarked then [9] Mark (v, w) [10] if b-candidates (w) = null then [11] b-candidates (w) = b m (w) [12] b-actual-out (w) = b m (w) ActualOutVertices [13] fi [14] if f-candidates (v) = null then [15] f-candidates (v) = f m (v) [16] fi
Reference: 9. <author> Gallagher, K.B. and Lyle, J.R., </author> <title> Using program slicing in software maintenance, </title> <journal> IEEE Transactions on Software Engineering 17(8) pp. </journal> <month> 751-761 (August </month> <year> 1991). </year>
Reference-contexts: set begin [4] Remove all marks on -formal-in, enter-/formal-out pairs [5] while WorkList do [6] Select and remove a summary edge (v, w) from WorkList [7] let v = the formal-in or enter vertex that corresponds to v and [8] w = the formal-out vertex that corresponds to actual-out w <ref> [9] </ref> in [10] if (v, w) is unmarked then [11] Mark (v, w) [12] S := TruncatedSameLevelChop (v, w) [13] Answer := Answer S [14] WorkList := WorkList - (x, y) SummaryEdges | x, y S - [15] fi [17] od [18] return Answer end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedChop (s, t) <p> [4] VL := f unbl (W) b unbl (- t -) [5] /* Invoke SameLevelChopAux with all summary edges on [6] * unbalanced-right paths from s to W or unbalanced-left [7] * paths from W to t */ [8] WorkList := - (x, y) SummaryEdges | x, y VR - <ref> [9] </ref> - (x, y) SummaryEdges | x, y VL - [10] return SameLevelChopAux (VR VL, WorkList) end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c <p> null [3] while WorkList do [4] Select and remove a summary edge (v, w) from WorkList [5] let v = the formal-in or enter vertex that corresponds to v and [6] w = the formal-out vertex that corresponds to actual-out w [7] in [8] if (v, w) is unmarked then <ref> [9] </ref> Mark (v, w) [10] if b-candidates (w) = null then [11] b-candidates (w) = b m (w) [12] b-actual-out (w) = b m (w) ActualOutVertices [13] fi [14] if f-candidates (v) = null then [15] f-candidates (v) = f m (v) [16] fi [17] for each x b-candidates (w) do <p> An invariant of the loop on lines [3]-[26] of Figure 7 is that for each summary edge (v, w) selected from the work-list, v and w are both known to be in the answer set. Consequently, at line <ref> [9] </ref>, vertices v and w are both known to be in the answer set. The purpose of lines [10]-[16] is to generate sets of candidate vertices (b m (w) and f m (v)) that may eventually end up in the final answer set.
Reference: 10. <author> Goff, G., Kennedy, K., and Tseng, C.-W., </author> <title> Practical dependence testing, </title> <booktitle> Proceedings of the ACM SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <address> (Toronto, Ontario, </address> <month> June 26-28, </month> <year> 1991), </year> <journal> ACM SIG-PLAN Notices 26(6) pp. </journal> <month> 15-29 (June </month> <year> 1991). </year>
Reference-contexts: To prevent SameLevelChopAux from ever invoking TruncatedSameLevelChop more than once on a given pair of -formal-in, enter-/formal-out vertices, each -formal-in, enter-/formal-out pair taken out of the work-list is marked, and only unmarked pairs cause new calls on Trun-catedSameLevelChop to be performed (see lines [4], <ref> [10] </ref>, [11], and [12]). Bounds on the running times of the different chopping algorithms can be expressed in terms of the following parameters: iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii P The number of procedures in the program. CSites p The number of call sites in procedure p. <p> [4] Remove all marks on -formal-in, enter-/formal-out pairs [5] while WorkList do [6] Select and remove a summary edge (v, w) from WorkList [7] let v = the formal-in or enter vertex that corresponds to v and [8] w = the formal-out vertex that corresponds to actual-out w [9] in <ref> [10] </ref> if (v, w) is unmarked then [11] Mark (v, w) [12] S := TruncatedSameLevelChop (v, w) [13] Answer := Answer S [14] WorkList := WorkList - (x, y) SummaryEdges | x, y S - [15] fi [17] od [18] return Answer end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedChop (s, t) returns vertex <p> -) [5] /* Invoke SameLevelChopAux with all summary edges on [6] * unbalanced-right paths from s to W or unbalanced-left [7] * paths from W to t */ [8] WorkList := - (x, y) SummaryEdges | x, y VR - [9] - (x, y) SummaryEdges | x, y VL - <ref> [10] </ref> return SameLevelChopAux (VR VL, WorkList) end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c <p> do [4] Select and remove a summary edge (v, w) from WorkList [5] let v = the formal-in or enter vertex that corresponds to v and [6] w = the formal-out vertex that corresponds to actual-out w [7] in [8] if (v, w) is unmarked then [9] Mark (v, w) <ref> [10] </ref> if b-candidates (w) = null then [11] b-candidates (w) = b m (w) [12] b-actual-out (w) = b m (w) ActualOutVertices [13] fi [14] if f-candidates (v) = null then [15] f-candidates (v) = f m (v) [16] fi [17] for each x b-candidates (w) do [18] if x f-candidates <p> These results are saved and reused on subsequent iterations of the loop. (Lines <ref> [10] </ref> and [14] test to see whether the candidate sets already exist.) As with the version of SameLevelChopAux given in Figure 6, because a summary edge (x, y) indicates that a same-level realizable path from x to y exists in the SDG, the main loop looks for summary edges (x, y)
Reference: 11. <author> Horwitz, S., Pfeiffer, P., and Reps, T., </author> <title> Dependence analysis for pointer variables, </title> <booktitle> Proceedings of the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <address> (Portland, OR, </address> <month> June 21-23, </month> <year> 1989), </year> <journal> ACM SIG-PLAN Notices 24(7) pp. </journal> <month> 28-40 (July </month> <year> 1989). </year>
Reference-contexts: To prevent SameLevelChopAux from ever invoking TruncatedSameLevelChop more than once on a given pair of -formal-in, enter-/formal-out vertices, each -formal-in, enter-/formal-out pair taken out of the work-list is marked, and only unmarked pairs cause new calls on Trun-catedSameLevelChop to be performed (see lines [4], [10], <ref> [11] </ref>, and [12]). Bounds on the running times of the different chopping algorithms can be expressed in terms of the following parameters: iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii P The number of procedures in the program. CSites p The number of call sites in procedure p. <p> pairs [5] while WorkList do [6] Select and remove a summary edge (v, w) from WorkList [7] let v = the formal-in or enter vertex that corresponds to v and [8] w = the formal-out vertex that corresponds to actual-out w [9] in [10] if (v, w) is unmarked then <ref> [11] </ref> Mark (v, w) [12] S := TruncatedSameLevelChop (v, w) [13] Answer := Answer S [14] WorkList := WorkList - (x, y) SummaryEdges | x, y S - [15] fi [17] od [18] return Answer end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedChop (s, t) returns vertex set declare W, VR, VL: vertex sets <p> edge (v, w) from WorkList [5] let v = the formal-in or enter vertex that corresponds to v and [6] w = the formal-out vertex that corresponds to actual-out w [7] in [8] if (v, w) is unmarked then [9] Mark (v, w) [10] if b-candidates (w) = null then <ref> [11] </ref> b-candidates (w) = b m (w) [12] b-actual-out (w) = b m (w) ActualOutVertices [13] fi [14] if f-candidates (v) = null then [15] f-candidates (v) = f m (v) [16] fi [17] for each x b-candidates (w) do [18] if x f-candidates (v) then [19] Answer := Answer -
Reference: 12. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 11(3) pp. </pages> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: To prevent SameLevelChopAux from ever invoking TruncatedSameLevelChop more than once on a given pair of -formal-in, enter-/formal-out vertices, each -formal-in, enter-/formal-out pair taken out of the work-list is marked, and only unmarked pairs cause new calls on Trun-catedSameLevelChop to be performed (see lines [4], [10], [11], and <ref> [12] </ref>). Bounds on the running times of the different chopping algorithms can be expressed in terms of the following parameters: iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii P The number of procedures in the program. CSites p The number of call sites in procedure p. MaxSites The maximum number of call sites in any procedure. <p> do [6] Select and remove a summary edge (v, w) from WorkList [7] let v = the formal-in or enter vertex that corresponds to v and [8] w = the formal-out vertex that corresponds to actual-out w [9] in [10] if (v, w) is unmarked then [11] Mark (v, w) <ref> [12] </ref> S := TruncatedSameLevelChop (v, w) [13] Answer := Answer S [14] WorkList := WorkList - (x, y) SummaryEdges | x, y S - [15] fi [17] od [18] return Answer end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedChop (s, t) returns vertex set declare W, VR, VL: vertex sets begin [1] W := <p> v = the formal-in or enter vertex that corresponds to v and [6] w = the formal-out vertex that corresponds to actual-out w [7] in [8] if (v, w) is unmarked then [9] Mark (v, w) [10] if b-candidates (w) = null then [11] b-candidates (w) = b m (w) <ref> [12] </ref> b-actual-out (w) = b m (w) ActualOutVertices [13] fi [14] if f-candidates (v) = null then [15] f-candidates (v) = f m (v) [16] fi [17] for each x b-candidates (w) do [18] if x f-candidates (v) then [19] Answer := Answer - x - [20] Remove x from b-candidates
Reference: 13. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 12(1) pp. </pages> <month> 26-60 (January </month> <year> 1990). </year>
Reference-contexts: Several different terms have been used for these paths, including valid paths, feasible paths, and realizable paths. 2 As defined in <ref> [13] </ref>, procedure dependence graphs include four kinds of dependence edges: control, loop-independent flow, loop-carried flow, and def-order. However, for chopping the distinction between loop-independent and loop-carried flow edges is irrelevant, and def-order edges are not used. <p> A variety of other studies have investigated how to build dependence graphs for various features and constructs found in real-world programming languages. For example, previous work has addressed arrays [3,32,21,10,24,25], reference parameters <ref> [13] </ref>, pointers [18,11,6], and nonstructured control flow [2,7,1]. (Our C chopping tool incorporates several of these techniques.) ` 2.2. Realizable Paths The concept of a realizable path is formalized via the following definition: Definition 2.1 (Realizable Paths). <p> t T such that v fi unbr * t - b unbl (T) = df - v | $ t T such that v fi unbl * t - Operations f unbr , f unbl , b unbr , and b unbr correspond to the individual slicing passes defined in <ref> [13] </ref>. 3 All six operations can be implemented by simple reachability computations (for example, by depth-first search) on an SDG augmented with summary edges: (i) The operation f m (S) can be implemented as a reacha bility algorithm as follows: Starting at members of S, the depth-first search traverses control-dependence edges, <p> summary edge (v, w) from WorkList [7] let v = the formal-in or enter vertex that corresponds to v and [8] w = the formal-out vertex that corresponds to actual-out w [9] in [10] if (v, w) is unmarked then [11] Mark (v, w) [12] S := TruncatedSameLevelChop (v, w) <ref> [13] </ref> Answer := Answer S [14] WorkList := WorkList - (x, y) SummaryEdges | x, y S - [15] fi [17] od [18] return Answer end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedChop (s, t) returns vertex set declare W, VR, VL: vertex sets begin [1] W := f unbr (- s -) b <p> corresponds to v and [6] w = the formal-out vertex that corresponds to actual-out w [7] in [8] if (v, w) is unmarked then [9] Mark (v, w) [10] if b-candidates (w) = null then [11] b-candidates (w) = b m (w) [12] b-actual-out (w) = b m (w) ActualOutVertices <ref> [13] </ref> fi [14] if f-candidates (v) = null then [15] f-candidates (v) = f m (v) [16] fi [17] for each x b-candidates (w) do [18] if x f-candidates (v) then [19] Answer := Answer - x - [20] Remove x from b-candidates (w) [21] if x (ActualInVertices CallVertices) then [22] <p> Conclusions In this paper, we have used the SDG representation introduced by Horwitz et al. <ref> [13] </ref> to formulate and solve four varieties of interprocedural chopping. (We also rely on the improved method for determining an SDG's summary hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 4 The cost of finding the set of summary edges is O ((P E Params) + (CSites Params 3 )).
Reference: 14. <author> Horwitz, S., </author> <title> Identifying the semantic and textual differences between two versions of a program, </title> <booktitle> Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <address> (White Plains, NY, </address> <month> June 20-22, </month> <year> 1990), </year> <journal> ACM SIGPLAN Notices 25(6) pp. </journal> <month> 234-245 (June </month> <year> 1990). </year>
Reference-contexts: WorkList [7] let v = the formal-in or enter vertex that corresponds to v and [8] w = the formal-out vertex that corresponds to actual-out w [9] in [10] if (v, w) is unmarked then [11] Mark (v, w) [12] S := TruncatedSameLevelChop (v, w) [13] Answer := Answer S <ref> [14] </ref> WorkList := WorkList - (x, y) SummaryEdges | x, y S - [15] fi [17] od [18] return Answer end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedChop (s, t) returns vertex set declare W, VR, VL: vertex sets begin [1] W := f unbr (- s -) b unbl (- t -) [2] <p> v and [6] w = the formal-out vertex that corresponds to actual-out w [7] in [8] if (v, w) is unmarked then [9] Mark (v, w) [10] if b-candidates (w) = null then [11] b-candidates (w) = b m (w) [12] b-actual-out (w) = b m (w) ActualOutVertices [13] fi <ref> [14] </ref> if f-candidates (v) = null then [15] f-candidates (v) = f m (v) [16] fi [17] for each x b-candidates (w) do [18] if x f-candidates (v) then [19] Answer := Answer - x - [20] Remove x from b-candidates (w) [21] if x (ActualInVertices CallVertices) then [22] for each <p> These results are saved and reused on subsequent iterations of the loop. (Lines [10] and <ref> [14] </ref> test to see whether the candidate sets already exist.) As with the version of SameLevelChopAux given in Figure 6, because a summary edge (x, y) indicates that a same-level realizable path from x to y exists in the SDG, the main loop looks for summary edges (x, y) such that
Reference: 15. <author> Jackson, D. and Rollins, E.J., </author> <title> A new model of program dependences for reverse engineering, </title> <booktitle> SIGSOFT 94: Proceedings of the Second ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <address> (New Orleans, LA, </address> <month> December 7-9, </month> <year> 1994), </year> <booktitle> ACM SIGSOFT Software Engineering Notes 19 pp. </booktitle> <month> 2-10 (December </month> <year> 1994). </year>
Reference-contexts: Authors' address: Computer Sciences Department, Univ. of Wisconsin, 1210 W. Dayton St., Madison, WI 53706. Electronic mail: -reps,rosay-@cs.wisc.edu. 1995 ACM and merging [19,12,14,9,5,4,22,20]. Jackson and Rollins introduced a related operation, called program chopping <ref> [15] </ref>, which can be thought of as a kind of filtered slice: Chopping answers questions of the form What are all the program elements v that serve to transmit effects from a given source element s to a given target element t? Compared to slicing, chopping provides a more focused way <p> v and [8] w = the formal-out vertex that corresponds to actual-out w [9] in [10] if (v, w) is unmarked then [11] Mark (v, w) [12] S := TruncatedSameLevelChop (v, w) [13] Answer := Answer S [14] WorkList := WorkList - (x, y) SummaryEdges | x, y S - <ref> [15] </ref> fi [17] od [18] return Answer end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedChop (s, t) returns vertex set declare W, VR, VL: vertex sets begin [1] W := f unbr (- s -) b unbl (- t -) [2] VR := f unbr (- s -) b unbr (W) [3] VL := <p> vertex that corresponds to actual-out w [7] in [8] if (v, w) is unmarked then [9] Mark (v, w) [10] if b-candidates (w) = null then [11] b-candidates (w) = b m (w) [12] b-actual-out (w) = b m (w) ActualOutVertices [13] fi [14] if f-candidates (v) = null then <ref> [15] </ref> f-candidates (v) = f m (v) [16] fi [17] for each x b-candidates (w) do [18] if x f-candidates (v) then [19] Answer := Answer - x - [20] Remove x from b-candidates (w) [21] if x (ActualInVertices CallVertices) then [22] for each y such that (x, y) SummaryEdges and <p> the step of determining the summary edges only has to be performed once, when the first chop is performed. edges that was described by Reps et al. [28].) These chopping problems generalize the restricted version of interpro-cedural chopping studied by Jackson and Rollins (i.e., the truncated same-level interprocedural chopping problem) <ref> [15] </ref>. Truncated same-level chopping of C programs has been implemented by Jackson and Rollins in their ChopShop system. <p> c c c c c c c c c c c c c c c c c c c Jackson and Rollins refer to chopping as . . . a generalization of slicing [in which] most slicing notions, such as backward and forward slicing, are easily expressed as special cases <ref> [15] </ref>. Although strictly speaking, this is true for example, a forward interprocedural slice with respect to vertex s is a (multi-target) chop with respect to source s and a target-set consisting of all vertices of the SDGthis gives a misleading impression that chopping somehow subsumes slicing.
Reference: 16. <author> Kuck, D.J., Kuhn, R.H., Leasure, B., Padua, D.A., and Wolfe, M., </author> <title> Dependence graphs and compiler optimizations, pp. </title> <booktitle> 207-218 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Wil-liamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1981). </address>
Reference-contexts: in [8] if (v, w) is unmarked then [9] Mark (v, w) [10] if b-candidates (w) = null then [11] b-candidates (w) = b m (w) [12] b-actual-out (w) = b m (w) ActualOutVertices [13] fi [14] if f-candidates (v) = null then [15] f-candidates (v) = f m (v) <ref> [16] </ref> fi [17] for each x b-candidates (w) do [18] if x f-candidates (v) then [19] Answer := Answer - x - [20] Remove x from b-candidates (w) [21] if x (ActualInVertices CallVertices) then [22] for each y such that (x, y) SummaryEdges and y b-actual-out (w) do [23] WorkList :=
Reference: 17. <author> Landi, W. and Ryder, B.G., </author> <title> Pointer-induced aliasing: A problem classification, pp. </title> <booktitle> 93-103 in Conference Record of the Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Orlando, FL, </address> <month> January </month> <year> 1991), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1991). </address>
Reference-contexts: [8] w = the formal-out vertex that corresponds to actual-out w [9] in [10] if (v, w) is unmarked then [11] Mark (v, w) [12] S := TruncatedSameLevelChop (v, w) [13] Answer := Answer S [14] WorkList := WorkList - (x, y) SummaryEdges | x, y S - [15] fi <ref> [17] </ref> od [18] return Answer end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedChop (s, t) returns vertex set declare W, VR, VL: vertex sets begin [1] W := f unbr (- s -) b unbl (- t -) [2] VR := f unbr (- s -) b unbr (W) [3] VL := f unbl <p> if (v, w) is unmarked then [9] Mark (v, w) [10] if b-candidates (w) = null then [11] b-candidates (w) = b m (w) [12] b-actual-out (w) = b m (w) ActualOutVertices [13] fi [14] if f-candidates (v) = null then [15] f-candidates (v) = f m (v) [16] fi <ref> [17] </ref> for each x b-candidates (w) do [18] if x f-candidates (v) then [19] Answer := Answer - x - [20] Remove x from b-candidates (w) [21] if x (ActualInVertices CallVertices) then [22] for each y such that (x, y) SummaryEdges and y b-actual-out (w) do [23] WorkList := WorkList -
Reference: 18. <author> Larus, J.R. and Hilfinger, </author> <title> P.N., Detecting conflicts between structure accesses, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 21-34 (July </month> <year> 1988). </year>
Reference-contexts: = the formal-out vertex that corresponds to actual-out w [9] in [10] if (v, w) is unmarked then [11] Mark (v, w) [12] S := TruncatedSameLevelChop (v, w) [13] Answer := Answer S [14] WorkList := WorkList - (x, y) SummaryEdges | x, y S - [15] fi [17] od <ref> [18] </ref> return Answer end iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii function TruncatedChop (s, t) returns vertex set declare W, VR, VL: vertex sets begin [1] W := f unbr (- s -) b unbl (- t -) [2] VR := f unbr (- s -) b unbr (W) [3] VL := f unbl (W) b <p> Mark (v, w) [10] if b-candidates (w) = null then [11] b-candidates (w) = b m (w) [12] b-actual-out (w) = b m (w) ActualOutVertices [13] fi [14] if f-candidates (v) = null then [15] f-candidates (v) = f m (v) [16] fi [17] for each x b-candidates (w) do <ref> [18] </ref> if x f-candidates (v) then [19] Answer := Answer - x - [20] Remove x from b-candidates (w) [21] if x (ActualInVertices CallVertices) then [22] for each y such that (x, y) SummaryEdges and y b-actual-out (w) do [23] WorkList := WorkList - (x, y) - [24] od fi fi
Reference: 19. <author> Lyle, J. and Weiser, M., </author> <title> Experiments on slicing-based debugging tools, </title> <booktitle> in Proceedings of the First Conference on Empirical Studies of Programming, </booktitle> <address> (June 1986), </address> <publisher> Ablex Publishing Co. </publisher> <year> (1986). </year>
Reference-contexts: (w) = null then [11] b-candidates (w) = b m (w) [12] b-actual-out (w) = b m (w) ActualOutVertices [13] fi [14] if f-candidates (v) = null then [15] f-candidates (v) = f m (v) [16] fi [17] for each x b-candidates (w) do [18] if x f-candidates (v) then <ref> [19] </ref> Answer := Answer - x - [20] Remove x from b-candidates (w) [21] if x (ActualInVertices CallVertices) then [22] for each y such that (x, y) SummaryEdges and y b-actual-out (w) do [23] WorkList := WorkList - (x, y) - [24] od fi fi [26] od [27] return Answer end <p> work--list for subsequent processing. (See lines [21]-[24] of Figure 7.) The reason why this method yields an asymptotic improvement in the running time of SameLevelChopAux is as follows: A vertex x is removed from b-candidates (w) whenever it is placed in Answer (see lines <ref> [19] </ref>-[20]). For a given x, line [19] may be executed at most Params timesthat is, at most once for each formal-out vertex of the PDG that contains x. This saves a factor of Params in the bound on the function's asymptotic running time: If line [20] were not performed, then line [19] could be executed up to <p> For a given x, line <ref> [19] </ref> may be executed at most Params timesthat is, at most once for each formal-out vertex of the PDG that contains x. This saves a factor of Params in the bound on the function's asymptotic running time: If line [20] were not performed, then line [19] could be executed up to Params 2 timesonce for each -formal-in, enter-/formal-out pair. The cost of the improved SameLevelChopAux is dominated by the cost of creating the candidate sets in lines [10]-[16] and the cost of adding summary edges to the work-list in lines [21]-[24].
Reference: 20. <author> Markosian, L., Newcomb, P., Brand, R., Burson, S., and Kitzmiller, T., </author> <title> Using an enabling technology, </title> <journal> Commun. of the ACM 37(5) pp. </journal> <month> 58-70 (May </month> <year> 1994). </year>
Reference-contexts: = b m (w) [12] b-actual-out (w) = b m (w) ActualOutVertices [13] fi [14] if f-candidates (v) = null then [15] f-candidates (v) = f m (v) [16] fi [17] for each x b-candidates (w) do [18] if x f-candidates (v) then [19] Answer := Answer - x - <ref> [20] </ref> Remove x from b-candidates (w) [21] if x (ActualInVertices CallVertices) then [22] for each y such that (x, y) SummaryEdges and y b-actual-out (w) do [23] WorkList := WorkList - (x, y) - [24] od fi fi [26] od [27] return Answer end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh (i) For a given vertex x <p> placed in Answer (see lines [19]-<ref> [20] </ref>). For a given x, line [19] may be executed at most Params timesthat is, at most once for each formal-out vertex of the PDG that contains x. This saves a factor of Params in the bound on the function's asymptotic running time: If line [20] were not performed, then line [19] could be executed up to Params 2 timesonce for each -formal-in, enter-/formal-out pair.
Reference: 21. <author> Maydan, D.E., Hennessy, J.L., and Lam, </author> <title> M.S., Efficient and exact data dependence analysis, </title> <booktitle> Proceedings of the ACM SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <address> (Toronto, Ontario, </address> <month> June 26-28, </month> <year> 1991), </year> <journal> ACM SIGPLAN Notices 26(6) pp. </journal> <month> 1-14 (June </month> <year> 1991). </year>
Reference-contexts: (w) = b m (w) ActualOutVertices [13] fi [14] if f-candidates (v) = null then [15] f-candidates (v) = f m (v) [16] fi [17] for each x b-candidates (w) do [18] if x f-candidates (v) then [19] Answer := Answer - x - [20] Remove x from b-candidates (w) <ref> [21] </ref> if x (ActualInVertices CallVertices) then [22] for each y such that (x, y) SummaryEdges and y b-actual-out (w) do [23] WorkList := WorkList - (x, y) - [24] od fi fi [26] od [27] return Answer end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh (i) For a given vertex x of the SDG to be in <p> To determine which summary edges should be added to the work-list, for each of the CSites p Params actual-in or call vertices x in some PDG p, line <ref> [21] </ref> may be executed at most Params times (once for each actual-out vertex of p). Because x may have at most Params outgoing summary edges, the total cost of lines [21]-[24] is bounded by O ( p Procedures S Params CSites p Params 2 ) = O (CSites Params 3 ).
Reference: 22. <author> Ning, J.Q., Engberts, A., and Kozaczynski, W., </author> <title> Automated support for legacy code understanding, </title> <journal> Commun. of the ACM 37(5) pp. </journal> <month> 50-57 (May </month> <year> 1994). </year>
Reference-contexts: [13] fi [14] if f-candidates (v) = null then [15] f-candidates (v) = f m (v) [16] fi [17] for each x b-candidates (w) do [18] if x f-candidates (v) then [19] Answer := Answer - x - [20] Remove x from b-candidates (w) [21] if x (ActualInVertices CallVertices) then <ref> [22] </ref> for each y such that (x, y) SummaryEdges and y b-actual-out (w) do [23] WorkList := WorkList - (x, y) - [24] od fi fi [26] od [27] return Answer end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh (i) For a given vertex x of the SDG to be in the answer set, we need only
Reference: 23. <author> Ottenstein, K.J. and Ottenstein, L.M., </author> <title> The program dependence graph in a software development environment, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> Apr. </month> <pages> 23-25, </pages> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 177-184 (May </month> <year> 1984). </year>
Reference-contexts: slicing, for example, Ottenstein and Ottenstein showed that slices can be obtained by solving a reachability problem on the program dependence graph (PDG): To perform a slice with respect to PDG vertex v, find all PDG vertices from which there is a path to v along control-dependence and/or flow-dependence edges <ref> [23] </ref>. In other words, (backward) slicing is a single-target reachability problem on the PDG. The related problem of forward slicing is a single-source reachability problem on the PDG. Chopping corresponds to a single-source/single-target reachability problem. <p> m (v) [16] fi [17] for each x b-candidates (w) do [18] if x f-candidates (v) then [19] Answer := Answer - x - [20] Remove x from b-candidates (w) [21] if x (ActualInVertices CallVertices) then [22] for each y such that (x, y) SummaryEdges and y b-actual-out (w) do <ref> [23] </ref> WorkList := WorkList - (x, y) - [24] od fi fi [26] od [27] return Answer end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh (i) For a given vertex x of the SDG to be in the answer set, we need only find one -formal-in, enter-/formal-out pair (v , w) such that x b m (w),
Reference: 24. <author> Pugh, W., </author> <title> The omega test: a fast and practical integer programming algorithm for dependence analysis, </title> <booktitle> in Supercomputing 1991, </booktitle> <month> (November </month> <year> 1991). </year>
Reference-contexts: b-candidates (w) do [18] if x f-candidates (v) then [19] Answer := Answer - x - [20] Remove x from b-candidates (w) [21] if x (ActualInVertices CallVertices) then [22] for each y such that (x, y) SummaryEdges and y b-actual-out (w) do [23] WorkList := WorkList - (x, y) - <ref> [24] </ref> od fi fi [26] od [27] return Answer end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh (i) For a given vertex x of the SDG to be in the answer set, we need only find one -formal-in, enter-/formal-out pair (v , w) such that x b m (w), x f m (v ), and both v
Reference: 25. <author> Pugh, W. and Wonnacott, D., </author> <title> Eliminating false data dependences using the omega test, </title> <booktitle> Proceedings of the ACM SIG-PLAN 92 Conference on Programming Language Design and Implementation, </booktitle> <address> (San Francisco, CA, </address> <month> June 17-19, </month> <year> 1992), </year> <journal> ACM SIGPLAN Notices 27(7) pp. </journal> <month> 140-151 (July </month> <year> 1992). </year>
Reference: 26. <author> Reps, T., </author> <title> Demonstration of a prototype tool for program integration, </title> <institution> TR-819, Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (January 1989). </note>
Reference-contexts: if x f-candidates (v) then [19] Answer := Answer - x - [20] Remove x from b-candidates (w) [21] if x (ActualInVertices CallVertices) then [22] for each y such that (x, y) SummaryEdges and y b-actual-out (w) do [23] WorkList := WorkList - (x, y) - [24] od fi fi <ref> [26] </ref> od [27] return Answer end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh (i) For a given vertex x of the SDG to be in the answer set, we need only find one -formal-in, enter-/formal-out pair (v , w) such that x b m (w), x f m (v ), and both v and w are in <p> the algorithms from Section 3 (including the efficient version of SameLevel-ChopAux given in Figure 7) to create a tool that allows one to chop C programs via any of the four interprocedural-chopping operations defined in Section 2.3. (The implementation is based on an offshoot of the Wisconsin Program Integration System <ref> [26] </ref> that has been retargeted to operate on C programs.) Our limited experience with chopping is in agreement with what is predicted by the asymptotic bounds on running times listed in the table given above. g Truncated unrestricted chopping is not substantially more expensive to perform than interprocedural slicing.
Reference: 27. <author> Reps, T., Sagiv, M., and Horwitz, S., </author> <title> Interprocedural dataflow analysis via graph reachability, </title> <type> TR 94-14, </type> <institution> Datalo-gisk Institut, University of Copenhagen, Copenhagen, </institution> <month> Den-mark (April </month> <year> 1994). </year> <note> (Available on the World Wide Web at ftp://ftp.diku.dk/diku/semantics/papers/D-215.ps.Z.) </note>
Reference-contexts: Note that this step only has to be performed once, when the first slice or chop is performed. Alternatively, the summary edges can be determined on demand, which allows some of the cost to be spread out over a sequence of slices and chops <ref> [27] </ref>. ` Function TruncatedSameLevelChop traverses edges and summary edges of only a single procedure, and the amount of work performed is linear in the number of edges traversed. <p> f-candidates (v) then [19] Answer := Answer - x - [20] Remove x from b-candidates (w) [21] if x (ActualInVertices CallVertices) then [22] for each y such that (x, y) SummaryEdges and y b-actual-out (w) do [23] WorkList := WorkList - (x, y) - [24] od fi fi [26] od <ref> [27] </ref> return Answer end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh (i) For a given vertex x of the SDG to be in the answer set, we need only find one -formal-in, enter-/formal-out pair (v , w) such that x b m (w), x f m (v ), and both v and w are in the answer
Reference: 28. <author> Reps, T., Horwitz, S., Sagiv, M., and Rosay, G., </author> <title> Speeding up slicing, </title> <booktitle> SIGSOFT 94: Proceedings of the Second ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <address> (New Orleans, LA, </address> <month> December 7-9, </month> <year> 1994), </year> <booktitle> ACM SIGSOFT Software Engineering Notes 19(5) pp. </booktitle> <month> 11-20 (December </month> <year> 1994). </year>
Reference-contexts: That approach would be imprecise for the same reason that transitive closure leads to imprecise inter-procedural slicing and chopping, namely that not all paths in the SDG are realizable paths. An efficient method for determining the set of all actual-in-to-actual-out summary edges is given in <ref> [28] </ref>. Example. The actual-in-to-actual-out summary edges for the running example are shown in Figure 2. ` 3.2. Following Matched, Unbalanced-Right, and Unbalanced-Left Paths Once all summary edges have been found, it is an easy matter to follow matched, unbalanced-right, and unbalanced-left paths in the SDG. <p> In analyzing the costs of the chopping algorithms, we will assume that the SDG's summary edges have already been determined. This can be performed in time O ((P E Params) + (CSites Params 3 )) <ref> [28] </ref>. Note that this step only has to be performed once, when the first slice or chop is performed. <p> However, as stated earlier, the step of determining the summary edges only has to be performed once, when the first chop is performed. edges that was described by Reps et al. <ref> [28] </ref>.) These chopping problems generalize the restricted version of interpro-cedural chopping studied by Jackson and Rollins (i.e., the truncated same-level interprocedural chopping problem) [15]. Truncated same-level chopping of C programs has been implemented by Jackson and Rollins in their ChopShop system.
Reference: 29. <author> Reps, T., Horwitz, S., and Sagiv, M., </author> <title> Precise interpro-cedural dataflow analysis via graph reachability, pp. </title> <booktitle> 49-61 in Conference Record of the Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Fran-cisco, CA, </address> <month> Jan. </month> <pages> 23-25, </pages> <address> 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference: 30. <author> Sharir, M. and Pnueli, A., </author> <title> Two approaches to interpro-cedural data flow analysis, pp. 189-233 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones,Prentice-Hall, </editor> <address> Englewood Cliffs, NJ (1981). </address>
Reference: 31. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference-contexts: 1. Introduction The slice of a program with respect to program-point p and variable x consists of all statements and predicates of the program that might affect the value of x at point p. This concept, originally discussed by Mark Weiser in <ref> [31] </ref>, allows one to isolate individual computation threads within a program.
Reference: 32. <author> Wolfe, M.J., </author> <title> Optimizing supercompilers for supercomputers, </title> <type> Ph.D. dissertation and Tech. Rep. </type> <institution> R-82-1105, Dept. of Computer Science, University of Illinois, Urbana, </institution> <address> IL (October 1982). </address> <booktitle> In Proc. of the 3 rd ACM Symp. on Foundations of Software Engineering ((Washington, </booktitle> <address> DC, </address> <month> Oct. </month> <pages> 10-13, </pages> <year> 1995). </year>
References-found: 32

