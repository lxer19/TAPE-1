URL: ftp://ftp.cs.brown.edu/pub/techreports/91/cs91-30.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-91-30.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [BARR81] <author> Al Barr, </author> <title> "Superquadrics and Angle-Preserving Transformations," </title> <journal> IEEE Computer Graphics and Applications, </journal> <month> January </month> <year> 1981, </year> <pages> pp. 11-23. </pages>
Reference-contexts: A chop that specifies the parameters of a superquadric surface also takes a list of three numbers (intuitively, there is one parameter each for the "shape" of the longitude curves, the "shape" of the latitude curves, and the radius of the central hole <ref> [BARR81] </ref>. This list does not represent a vector, but instead three individual values.
Reference: [GRIM91] <author> Cindy Grimm and Mitch Henrion, </author> <title> "Description of the flesh Language," Computer Graphics Group internal documentation, </title> <institution> Brown University, Providence, RI, </institution> <month> July </month> <year> 1991. </year> <note> Online: /pro/uga/doc/new scefo. </note>
Reference-contexts: The following documents will provide the necessary background knowledge: * "An Object-Oriented Framework for the Integration of Interactive Animation Techniques" by Robert C. Zeleznik et al [ZELE91] presents a high-level description of the system's goals and architecture. * "Description of the flesh Language" by Cindy Grimm and Mitch Henrion <ref> [GRIM91] </ref> describes the scripting language that instructs uga to produce an animation. An understanding of how a user specifies an animation is essential in order to understand how the uga system produces that animation. <p> A chop can cause an object to change classes, so the semantics of an object's chops may be determined by other chops associated with that object. A time-parameterized model can be represented completely by an ordinary text file. This file contains statements in the flesh scripting language <ref> [GRIM91] </ref>. These statements name the objects in the model, and describe the chops associated with each of those objects. 2.1.1 The Database The uga system is designed to assist application programs in the construction and display of time-parameterized models. <p> the data remains unchanged. 20 Overview depardieu : rep 0 = cube translate 0 = [-1, -2, -3] 10 = [ 1, 2, 3] /* The camera class is called "leika". */ fellini : rep 0 = leika orient 5 = [[10, 10, 10], depardieu.translate, [0, 1, 0]] ; manual <ref> [GRIM91] </ref>, the translate attribute of an object can be considered to be the same as its "position" (in an intuitive sense). The technical differences are not important for this example. The process of inquiring data is illustrated graphically in Figure 2.5 (page 19). <p> The expression can be a binary operation on two VALUitems, a unary operation on one VALUitem, or a function taking one or more VALUitem as arguments. The operations and functions supported are those needed for the values of chops in flesh scripts (see the flesh manual <ref> [GRIM91] </ref> for details). 4. A VALU_list is a list of VALUitems. <p> The imp package currently supports four basic interpolation methods: Discrete, Linear, Integrate and Quaternion. For more information on the semantics of these methods, see the flesh manual <ref> [GRIM91] </ref>. Note the absence of spline interpolation methods. The imp package currently does not support spline interpolation as this kind of interpolation can be achieved by using path objects (see Section 5.2, Paths, page 91). <p> To be able to use path objects for other object's trajectories over time, all path objects can export an orient attribute. For details about the syntax of this functionality refer to the flesh manual <ref> [GRIM91] </ref>. 5.3 Revolves Revolve objects are solids traced out by a path revolved around an axis. Therefore, part of the state of a revolve object is a set_path chop that references a path object. <p> They are the latitudinal and longitudinal resolutions. The latitudinal resolution of the revolve object determines how many degrees apart each revolve profile will be. It is specified by a flesh change operator of the revolve object (refer to the flesh manual <ref> [GRIM91] </ref>). The longitudinal resolution of the revolve object is taken to be the same as the resolution of the passed in path. As with other objects, the resolution is only used for polygonally based computations. For more information on revolve objects see the flesh manual [GRIM91]. 94 Examples of Interesting Object <p> (refer to the flesh manual <ref> [GRIM91] </ref>). The longitudinal resolution of the revolve object is taken to be the same as the resolution of the passed in path. As with other objects, the resolution is only used for polygonally based computations. For more information on revolve objects see the flesh manual [GRIM91]. 94 Examples of Interesting Object Classes 5.4 CSG Objects A CSG (constructive solid geometry) model is represented in uga as a single object. The CSG object class is implemented by the ccsg ("class of csg objects") package.
Reference: [HUAN91a] <author> Nate Huang, </author> <title> "A Guide to trip," Computer Graphics Group internal documentation, </title> <institution> Brown University, Providence, RI, </institution> <month> July </month> <year> 1991. </year> <note> Online: /pro/uga/doc/trip. </note>
Reference-contexts: The focus is on the software packages that form the heart of uga. These packages are described in detail, i.e., specifics of data structures and routines are given. Some of the software packages of uga have been described in other documents <ref> [HUAN91a, WLOK90] </ref>. The main difference between those other documents and this document is in scope. <p> A TRIPobject is an instance of this data type. The details of this package are not important for this document and are given elsewhere <ref> [HUAN91a] </ref>. 18 Overview The state package keeps track of the inquiry methods. A client obtains the method used to inquire a particular kind of data from a particular object by calling the STATEsetup_method () routine.
Reference: [HUAN91b] <author> Nate Huang, </author> <title> "Writing a New Object Class in UGA," Computer Graphics Group internal documentation, </title> <institution> Brown University, Providence, RI, </institution> <month> July </month> <year> 1991. </year> <note> Online: /pro/uga/doc/oc. </note>
Reference: [PRES88] <author> William H. Press, Brian P. Flannery, Saul A. Teukolsky, William T. Vetterling, </author> <title> Numerical Recipes in C, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1988. </year>
Reference-contexts: This integration must be performed numerically because the closed-form function for the ball's acceleration is not known (we only know specific accelerations at a few specific sample times). The simplest form of numerical integration uses Euler's method <ref> [PRES88] </ref>. Euler's method approximates the integral of a function over an interval of parameter values as the sum of the functions value at many parameter values along that interval.
Reference: [STRA91] <author> Paul S. Strauss, Michael J. Natkin, Nate Huang, </author> <title> "The Programming Environment for the Brown Computer Graphics Group," Computer Graphics Group internal documentation, </title> <institution> Brown University, Providence, RI, </institution> <month> July </month> <year> 1991. </year> <note> Online: /pro/uga/doc/standards. </note>
Reference-contexts: New terms are typeset in italics when first mentioned. Software package names are typeset as package. Function names, data structure names and flesh language fragments are typeset as item_name. A simple naming convention is used for all function and data structure names <ref> [STRA91] </ref>. The name of the function or data structure is always preceded by the capitalized name of the package that owns it.
Reference: [WLOK90] <author> Matthias M. Wloka, </author> <title> "A Guide to cap," Computer Graphics Group internal documentation, </title> <institution> Brown University, Providence, RI, </institution> <month> July </month> <year> 1990. </year> <note> Online: /pro/uga/doc/cap. 106 BIBLIOGRAPHY </note>
Reference-contexts: The focus is on the software packages that form the heart of uga. These packages are described in detail, i.e., specifics of data structures and routines are given. Some of the software packages of uga have been described in other documents <ref> [HUAN91a, WLOK90] </ref>. The main difference between those other documents and this document is in scope. <p> Since path objects are based on the cap package (see the cap package description <ref> [WLOK90] </ref>), a wide variety of parameters is provided so that controlling the shape of the path becomes easy. To be able to use path objects for other object's trajectories over time, all path objects can export an orient attribute. <p> Therefore, part of the state of a revolve object is a set_path chop that references a path object. Once again, note that only a special characteristic of the path object is imported into the revolve object (namely a data structure called a CAPpath <ref> [WLOK90] </ref>), so a revolve object is not an aggregate object. The paths that are revolved can be either two or three dimensional. If the path is three dimensional, then a rotational projection about the axis of revolution is performed to convert the path into two dimensions.
Reference: [ZELE91] <author> Robert C. Zeleznik, D. Brookshire Conner, Matthias M. Wloka, Daniel G. Aliaga, Nathan T. Huang, Philip M. Hubbard, Brian Knep, Henry Kaufman, John F. Hughes and Andries van Dam, </author> <title> "An Object-Oriented Framework for the Integration of Interactive Animation Techniques," </title> <booktitle> Proceedings of SIGGRAPH '91 (Las Vegas, </booktitle> <address> Nevada, July 29-August 2, </address> <year> 1991). </year> <booktitle> In Computer Graphics, </booktitle> <month> July </month> <year> 1991, </year> <booktitle> ACM SIGGRAPH, </booktitle> <address> New York. </address> <note> Online: /pro/graphics/papers/siggraph91. </note>
Reference-contexts: need to learn about uga to maintain and extend the existing code; * people who are interested in building a system similar to uga from scratch. 6 Introduction This document specifically will not be: * a high-level description of uga (this description has already been given by Zeleznik et al. <ref> [ZELE91] </ref>); * a collection of UNIX man pages that describe every routine in the system; * a programmers "how-to" guide that gives step-by-step instructions for exploiting the extensibility built into the system (a few such guides are mentioned in the bibliography); * a description of how to produce animations with the <p> The following documents will provide the necessary background knowledge: * "An Object-Oriented Framework for the Integration of Interactive Animation Techniques" by Robert C. Zeleznik et al <ref> [ZELE91] </ref> presents a high-level description of the system's goals and architecture. * "Description of the flesh Language" by Cindy Grimm and Mitch Henrion [GRIM91] describes the scripting language that instructs uga to produce an animation. <p> These models are groups of entities whose structure and properties are allowed to change over time, usually for the purpose of creating a visual effect. The basic design of the uga system has already been described by Zeleznik et al. <ref> [ZELE91] </ref>; this section will summarize that description. The entities in time-parameterized models are objects. There are several broad categories of objects. Geometric objects represent entities with a physical appearance, e.g., a ball, a building, a human figure. <p> Another important chop method handles a parent chop. When an object has a parent chop, it becomes the extension of some other prototype object. All the chops associated with the prototype now also affect the extension. More details of this idea are described by Zeleznik et al. <ref> [ZELE91] </ref>. The parent chop method for the class X is the routine Xparent_chop (). When it is called during an inquiry of some data from the extension object, the routine inquires that same data from the prototype object.
References-found: 8

