URL: http://www.cs.rice.edu/~andras/ECAI/bertsch.ps
Refering-URL: http://www.cs.rice.edu/~andras/ECAI/bertsch.html
Root-URL: 
Email: bertsch@lpi.ruhr-uni-bochum.de markjan@let.rug.nl  
Title: An innovative finite-state concept for recognition and parsing of context-free languages 1  
Author: Eberhard Bertsch Mark-Jan Nederhof 
Address: Germany The Netherlands  
Affiliation: Ruhr University, Bochum University of Groningen  
Abstract: We recall the notion of regular closure of classes of languages. We present two important results. The first one is that all languages which are in the regular closure of the class of deterministic (context-free) languages can be recognized in linear time. This is a non-trivial result, since this closure contains many inherently ambiguous languages. The second one is that the class of deterministic languages is contained in the closure of the class of deterministic languages with the prefix property, or stated in an equivalent way, all LR(k) languages are in the regular closure of the class of LR(0) languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman, </author> <title> `Time and tape complexity of pushdown automaton languages', </title> <journal> Information and Control, </journal> <volume> 13, </volume> <pages> 186-206, </pages> <year> (1968). </year>
Reference-contexts: Such 4-tuples are henceforth called items. The items are computed by a dynamic programming algorithm based on work from <ref> [1, 7, 4, 8] </ref>. It can be proved [1, 7] that Algorithm 1 in Figure 3 eventually adds an item (X; j; Y; i) to U if and only if (X; a j+1 a i ) j= + (XY; *). <p> Such 4-tuples are henceforth called items. The items are computed by a dynamic programming algorithm based on work from [1, 7, 4, 8]. It can be proved <ref> [1, 7] </ref> that Algorithm 1 in Figure 3 eventually adds an item (X; j; Y; i) to U if and only if (X; a j+1 a i ) j= + (XY; *).
Reference: [2] <author> J. Berstel, </author> <title> Transductions and Context-Free Languages, </title> <publisher> B.G. Teubner, Stuttgart, </publisher> <year> 1979. </year>
Reference-contexts: 2 A, and a sequence of strings v 1 ; : : : ; v m 2 fl such that * b 1 b m 2 L (F ), * v k 2 L (A k ), for 1 k m, and 3 This notion was called rational closure in <ref> [2] </ref>. FS concept for recognition of CF languages 2 E. Bertsch and M.J. Nederhof x ffifl *fi ? x q f q s A 2 The set of all strings recognized by automaton M is called the language accepted by M, denoted L (M).
Reference: [3] <author> E. Bertsch, </author> <title> `An asymptotically optimal algorithm for non-correcting LL(1) error recovery', </title> <type> Bericht Nr. 176, </type> <institution> Fakultat fur Mathematik, </institution> <address> Ruhr-Universitat Bochum, </address> <month> (April </month> <year> 1994). </year>
Reference-contexts: 1 INTRODUCTION In a series of recent articles <ref> [3, 9] </ref>, the authors have studied recognition and parsing of context-free languages by means of previously unknown simulations of nondeterministic techniques. The motivation for this work came from error detection problems, and as a matter of fact an open problem of long standing could be solved in that area.
Reference: [4] <author> S. Billot and B. Lang, </author> <title> `The structure of shared forests in ambiguous parsing', </title> <booktitle> in 27th Annual Meeting of the Association for Computational Linguistics, Proceedings of the Conference, </booktitle> <pages> pp. 143-151, </pages> <address> Vancouver, British Columbia, Canada, </address> <month> (June </month> <year> 1989). </year>
Reference-contexts: Such 4-tuples are henceforth called items. The items are computed by a dynamic programming algorithm based on work from <ref> [1, 7, 4, 8] </ref>. It can be proved [1, 7] that Algorithm 1 in Figure 3 eventually adds an item (X; j; Y; i) to U if and only if (X; a j+1 a i ) j= + (XY; *). <p> The next step is to investigate how the recog nition algorithms can be extended to be parsing algorithms. The approach to tabular context-free parsing in <ref> [7, 4] </ref> is to start with pushdown transducers. A pushdown transducer can be seen as a PDA of which the transitions produce certain output symbols when they are applied.
Reference: [5] <author> J.E. Hopcroft and J.D. Ullman, </author> <title> Introduction to Automata Theory, Languages, and Computation, </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: In compiler design, the deterministic languages are better known as LR (k) languages, and the prefix-free deterministic languages as LR (0) languages <ref> [5] </ref>. A prefix-free DPDA is in normal form if, for all input v, (X initial ; v) ` fl (ffiX; *), with X 2 F , implies ffi = *, and furthermore F is a singleton fX final g. Any prefix-free DPDA can be put into normal form. <p> It is well-established that L is not a deterministic language <ref> [5, Example 10.1] </ref>. However, it is the union of two languages L 1 and L 2 , which are by themselves deterministic. Therefore, L is accepted by a meta-deterministic automaton M which uses two DPDAs A 1 and A 2 , accepting L 1 and L 2 , respectively.
Reference: [6] <author> D.E. Knuth, J.H. Morris, Jr., and V.R. Pratt, </author> <title> `Fast pattern matching in strings', </title> <journal> SIAM Journal on Computing, </journal> <volume> 6(2), </volume> <pages> 323-350, </pages> <year> (1977). </year>
Reference-contexts: S is the start symbol of the grammar. (For on-line processing similar considerations apply.) In this way, we may produce a context-free grammar reflecting the structure of the input string, without deteriorating the time complexity of the recognition algorithm. 8 GENERALIZED PATTERN MATCHING In <ref> [6] </ref> the following problem is treated. Given are a finite set of input symbols , an input string a 1 a n 2 fl and a pattern b 1 b m 2 fl . <p> FS concept for recognition of CF languages 8 E. Bertsch and M.J. Nederhof The time demand can then be shown to be O (n m), which is, of course, O (n) if n is taken as sole parameter. This is in contrast to the algorithm in <ref> [6] </ref>, which provides a complexity of O (n+m). This seems a stronger result if time complexity is the only matter of consideration. From a broader perspective however, one finds that our approach allows a larger class of problems to be solved.
Reference: [7] <author> B. Lang, </author> <title> `Deterministic techniques for efficient non-deterministic parsers', </title> <booktitle> in Automata, Languages and Programming, 2nd Colloquium, volume 14 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 255-269, </pages> <address> Saarbrucken, (1974). </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Such 4-tuples are henceforth called items. The items are computed by a dynamic programming algorithm based on work from <ref> [1, 7, 4, 8] </ref>. It can be proved [1, 7] that Algorithm 1 in Figure 3 eventually adds an item (X; j; Y; i) to U if and only if (X; a j+1 a i ) j= + (XY; *). <p> Such 4-tuples are henceforth called items. The items are computed by a dynamic programming algorithm based on work from [1, 7, 4, 8]. It can be proved <ref> [1, 7] </ref> that Algorithm 1 in Figure 3 eventually adds an item (X; j; Y; i) to U if and only if (X; a j+1 a i ) j= + (XY; *). <p> The next step is to investigate how the recog nition algorithms can be extended to be parsing algorithms. The approach to tabular context-free parsing in <ref> [7, 4] </ref> is to start with pushdown transducers. A pushdown transducer can be seen as a PDA of which the transitions produce certain output symbols when they are applied.
Reference: [8] <author> M.J. Nederhof, </author> <title> Linguistic Parsing and Program Transformations, </title> <type> Ph.D. dissertation, </type> <institution> University of Nijmegen, </institution> <year> 1994. </year>
Reference-contexts: Such 4-tuples are henceforth called items. The items are computed by a dynamic programming algorithm based on work from <ref> [1, 7, 4, 8] </ref>. It can be proved [1, 7] that Algorithm 1 in Figure 3 eventually adds an item (X; j; Y; i) to U if and only if (X; a j+1 a i ) j= + (XY; *).
Reference: [9] <author> M.J. Nederhof and E. Bertsch, </author> <title> `Linear-time suffix parsing for deterministic languages', </title> <journal> Journal of the ACM, </journal> <volume> 43, </volume> <year> (1996). </year> <note> To appear. FS concept for recognition of CF languages 9 E. Bertsch and M.J. Nederhof </note>
Reference-contexts: 1 INTRODUCTION In a series of recent articles <ref> [3, 9] </ref>, the authors have studied recognition and parsing of context-free languages by means of previously unknown simulations of nondeterministic techniques. The motivation for this work came from error detection problems, and as a matter of fact an open problem of long standing could be solved in that area.
References-found: 9

