URL: http://www.cs.iastate.edu/tech-reports/TR96-16.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Formal Semantics for Structured Analysis Style Data Flow Diagram Specification Languages Keywords: structured analysis, data
Author: Gary T. Leavens, Tim Wahls, and Albert L. Baker Gary T. Leavens, Tim Wahls, and Albert L. Baker, 
Degree: All rights reserved.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: Submitted for publication. Copyright c  
Date: December 1996  1996.  
Pubnum: TR #96-16  
Abstract: 1993 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications | languages, methodologies, tools; D.2.2 [Software Engineering] Tools and Techniques | structured analysis, data flow diagrams, D.2.10 [Software Engineering] Design | methodologies, representation; D.3.1 [Programming Languages] Formal Definitions and Theory | semantics, syntax; F.3.2 [Logics and Meanings of Programs] Specifying and Verifying and Reasoning about Programs | specification techniques; F.3.2 [Logics and Meanings of Programs] Semantics of Programming Languages | operational semantics. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Tom DeMarco. </author> <title> Structured Analysis and System Specification. </title> <publisher> Yourdon , Inc., </publisher> <address> Engle-wood Cliffs, New Jersey, </address> <year> 1978. </year>
Reference-contexts: 1 Introduction An approach to the development of software systems which has enjoyed wide-spread use in the software engineering community is Structured Analysis (SA) <ref> [1] </ref> [2] [3] [4]. Within SA one specifies a data model using an Entity-Relationship Diagram (ERD) and a data dictionary, and the process by a Data Flow Diagram (DFD) [5]. Because DFDs are widely-used [6], many tools support their development. <p> In our model, the types of values can be arbitrary abstract data types (ADTs), including stacks, B-trees, etc., of arbitrary complexity. 2.2 What Kinds of Flows to Model? In SA, DeMarco <ref> [1] </ref> and others (e.g., [24]) make a distinction between "discrete" and "continuous" flows. Some authors seem to consider continuous flows as continuous in the sense of calculus (i.e., real-valued, differentiable). DeMarco and Ward seem to think of them as continuously existing (i.e., like a shared variable) even when read. <p> of type Signal, where Signal is a type that has only one element. (One could also use a persistent flow and a two-element type to indicate that the signal is "on" or "off".) 2.3 How Should Stores be Modeled? In traditional SA, a store is a passive holder of data <ref> [1] </ref> [25], much like a file in data processing. Multiple bubbles can access a single store for both reading and writing, but the store itself does not transform data. <p> Our formal model is also more expressive, in that it can easily describe the semantics of dynamic behavior, including bubbles firing concurrently with themselves, which allows a formal treatment of refinement. 29 7.3.1 De Marco and Yourdon DFDs used in traditional structured analysis <ref> [1] </ref> [25, page 15] have a very informal flavor and some features that are not directly present in our models. For example, De Marco has graphical notations on flows for "conjunction" (*) and "disjunction" () that are not a part of our formal model of the syntax of DFDs. <p> Our formal model can express control flows in a variety of ways; for example, by using a persistent flow that transmits boolean values, or by using a consumable flow that transmits values of a one-element type (a signal). De Marco's DFDs feature converging and diverging flows <ref> [1] </ref>. However, their semantics is ambiguous. A converging flow may mean either that: * there are several flows which all have their sinks in the same bubble, or * several "elementary packets of data" are to be joined "to form a complex packet" (such as a tuple) [25, page 16].
Reference: [2] <author> C. Gane and E. Sarson. </author> <title> Structured Systems Analysis: tools and techniques. </title> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference-contexts: 1 Introduction An approach to the development of software systems which has enjoyed wide-spread use in the software engineering community is Structured Analysis (SA) [1] <ref> [2] </ref> [3] [4]. Within SA one specifies a data model using an Entity-Relationship Diagram (ERD) and a data dictionary, and the process by a Data Flow Diagram (DFD) [5]. Because DFDs are widely-used [6], many tools support their development.
Reference: [3] <author> Paul T. Ward and Stephen J. Mellor. </author> <title> Structured Development for Real-Time Systems, volume 1: Introduction and Tools. </title> <publisher> Yourdon, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1985. </year>
Reference-contexts: 1 Introduction An approach to the development of software systems which has enjoyed wide-spread use in the software engineering community is Structured Analysis (SA) [1] [2] <ref> [3] </ref> [4]. Within SA one specifies a data model using an Entity-Relationship Diagram (ERD) and a data dictionary, and the process by a Data Flow Diagram (DFD) [5]. Because DFDs are widely-used [6], many tools support their development. <p> This two-step firing rule allows the modeling of concurrent firing of bubbles and time delays. (However, we do not model real-time aspects of time delays, as in <ref> [3] </ref> [19] [20].) To see why a two-step firing rule is necessary, suppose that bubbles were able to read their inputs and compute and write their outputs in one atomic step. <p> As part of the IPTES project, Elmstrtm and others [19] [20] described a semantics for SA/RT DFDs <ref> [3] </ref> augmented with VDM-SL P-specs. This semantics uses high-level timed Petri nets (HLTPNs) [32]. HLTPNs are similar to colored Petri nets, but because they include timing information on transitions, they can adequately model the dynamic behavior of a DFD.
Reference: [4] <author> Edward Yourdon. </author> <title> Modern Structured Analysis. </title> <publisher> Yourdon Press computing series. Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction An approach to the development of software systems which has enjoyed wide-spread use in the software engineering community is Structured Analysis (SA) [1] [2] [3] <ref> [4] </ref>. Within SA one specifies a data model using an Entity-Relationship Diagram (ERD) and a data dictionary, and the process by a Data Flow Diagram (DFD) [5]. Because DFDs are widely-used [6], many tools support their development. <p> For example, De Marco has graphical notations on flows for "conjunction" (*) and "disjunction" () that are not a part of our formal model of the syntax of DFDs. Similarly, Yourdon makes graphical distinctions between "data" and "control" flows <ref> [4] </ref> [25, pages 27-28]. However, our formal model can encode this kind of information in a general way.
Reference: [5] <author> R. B. </author> <title> France. A predicative basis for structured analysis specification tools. </title> <journal> Information and Software Technology, </journal> <volume> 35(2) </volume> <pages> 67-77, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: Within SA one specifies a data model using an Entity-Relationship Diagram (ERD) and a data dictionary, and the process by a Data Flow Diagram (DFD) <ref> [5] </ref>. Because DFDs are widely-used [6], many tools support their development. <p> For example, Wing and Zaremski [17] augment SA specifications (especially the data dictionary), with specifications in the Larch Shared Language [18]. Several researchers have used VDM specifications to augment the data dictionary and to specify the behavior of bubbles [9] [19] [20] [21]. As another example, France <ref> [5] </ref> [22], has specified the types in a data dictionary using Z notation, and has used Z to augment the specifications of data stores and global state invariants. These extensions are relevant, because they indicate that there is a desire for integration of DFDs and formal methods. <p> In addition to the modeling of dynamic behavior, we believe that the following aspects of our semantics are interesting in the sense of finding a smaller theoretical core for DFDs. 1. DFD terminators (external entities) have a specified behavior, which is unusual (although found in <ref> [5] </ref>); however, if no constraints on the terminators are desired, then the specification can simply permit arbitrary behaviors. 2. DFD stores, which are often seen as abstractions for files, can be modeled using only data flows that hold a single (possibly compound) value. <p> However, he ignores stores in his sketch of the operational semantics of DFDs. Coleman does not treat a bubble firing concurrently with itself. 7.3.10 France In the two works [43] <ref> [5] </ref> that we discuss below, France describes variants of DFDs, specification notations, and their semantics. <p> That is, there is no way to specify a bubble that may be refined into a system of bubbles that may process inputs in different orders. We permit such refinements by allowing a bubble to fire concurrently with itself [46]. A Predicative Basis for SA Specification Tools In <ref> [5] </ref> France gives a different formalization of the semantics of DFDs, this one geared towards composition and decomposition of DFDs. In this work France uses a variant of DFDs he calls PDFDs, along with ERDs, and data dictionaries with ADT specifications. His PDFDs include terminators (external entities), as do ours. <p> In this work France uses a variant of DFDs he calls PDFDs, along with ERDs, and data dictionaries with ADT specifications. His PDFDs include terminators (external entities), as do ours. In <ref> [5] </ref>, the behavior of a bubble is specified with an input/output predicate, which can be represented in our model as the functions that tell what a bubble produces and consumes. However, his language is not able to express conditions on when a bubble is enabled.
Reference: [6] <author> Jorgen P. Bansler and Keld Bodker. </author> <title> A reappraisal of structured analysis: Design in an organizational context. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 11(2) </volume> <pages> 165-193, </pages> <year> 1993. </year>
Reference-contexts: Within SA one specifies a data model using an Entity-Relationship Diagram (ERD) and a data dictionary, and the process by a Data Flow Diagram (DFD) [5]. Because DFDs are widely-used <ref> [6] </ref>, many tools support their development.
Reference: [7] <author> A. H. M. ter Hofstdede and T. P. van der Weide. </author> <title> Formalization of tehniques: chopping down the methodology jungle. </title> <journal> Information and Software Technology, </journal> <volume> 34(1) </volume> <pages> 57-65, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: In addition, DFDs are not even intended to capture the dynamic behavior of a software process. Various researchers have proposed ways to use SA techniques either as a first step towards extracting a formal specification, or by augmenting SA techniques with the goal of making them more precise <ref> [7] </ref>. For example, Fraser, Kumar, and Vaishnavi [8] and Larsen, et al. [9] extract a VDM [10] [11] specification from a DFD and a data dictionary. As another example, Semmens and Allen [12] extract a Z [13] [14] [15] specification from an application's ERD and DFD. <p> This precise use of DFDs would certainly come after the imprecise, informal use, but one should not have to completely change notations in order to formally describe systems. Instead, we look forward to an integration of informal and formal specifications spanning a wide range of needs <ref> [7] </ref> [16] [22]. The advantage of formal and precise DFD specifications would be that the work done in requirements analysis would not have to be thrown away when more precision is required.
Reference: [8] <author> M. D. Fraser, K. Kumar, and V. K. Vaishnavi. </author> <title> Informal and foraml requirements specification languages: Bridging the gap. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(5) </volume> <pages> 454-466, </pages> <month> May </month> <year> 1991. </year> <month> 37 </month>
Reference-contexts: Various researchers have proposed ways to use SA techniques either as a first step towards extracting a formal specification, or by augmenting SA techniques with the goal of making them more precise [7]. For example, Fraser, Kumar, and Vaishnavi <ref> [8] </ref> and Larsen, et al. [9] extract a VDM [10] [11] specification from a DFD and a data dictionary. As another example, Semmens and Allen [12] extract a Z [13] [14] [15] specification from an application's ERD and DFD. See [16] for a survey that includes other such examples.
Reference: [9] <author> Peter Gorm Larsen, Jan van Katwijk, Nico Plat, Kees Pronk, and Hans Toetenel. SVDM: </author> <title> An integrated combination of SA and VDM. In Methods Integration Conference. </title> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1991. </year>
Reference-contexts: Various researchers have proposed ways to use SA techniques either as a first step towards extracting a formal specification, or by augmenting SA techniques with the goal of making them more precise [7]. For example, Fraser, Kumar, and Vaishnavi [8] and Larsen, et al. <ref> [9] </ref> extract a VDM [10] [11] specification from a DFD and a data dictionary. As another example, Semmens and Allen [12] extract a Z [13] [14] [15] specification from an application's ERD and DFD. See [16] for a survey that includes other such examples. <p> For example, Wing and Zaremski [17] augment SA specifications (especially the data dictionary), with specifications in the Larch Shared Language [18]. Several researchers have used VDM specifications to augment the data dictionary and to specify the behavior of bubbles <ref> [9] </ref> [19] [20] [21]. As another example, France [5] [22], has specified the types in a data dictionary using Z notation, and has used Z to augment the specifications of data stores and global state invariants.
Reference: [10] <author> Dines Bjorner and Cliff B. Jones. </author> <title> Formal Specification and Software Development. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> London, </address> <year> 1982. </year>
Reference-contexts: Various researchers have proposed ways to use SA techniques either as a first step towards extracting a formal specification, or by augmenting SA techniques with the goal of making them more precise [7]. For example, Fraser, Kumar, and Vaishnavi [8] and Larsen, et al. [9] extract a VDM <ref> [10] </ref> [11] specification from a DFD and a data dictionary. As another example, Semmens and Allen [12] extract a Z [13] [14] [15] specification from an application's ERD and DFD. See [16] for a survey that includes other such examples.
Reference: [11] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: Various researchers have proposed ways to use SA techniques either as a first step towards extracting a formal specification, or by augmenting SA techniques with the goal of making them more precise [7]. For example, Fraser, Kumar, and Vaishnavi [8] and Larsen, et al. [9] extract a VDM [10] <ref> [11] </ref> specification from a DFD and a data dictionary. As another example, Semmens and Allen [12] extract a Z [13] [14] [15] specification from an application's ERD and DFD. See [16] for a survey that includes other such examples.
Reference: [12] <author> L. Semmens and P. Allen. </author> <title> Using Yourdon and Z: An approach to formal specification. In Z User Workshop. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: For example, Fraser, Kumar, and Vaishnavi [8] and Larsen, et al. [9] extract a VDM [10] [11] specification from a DFD and a data dictionary. As another example, Semmens and Allen <ref> [12] </ref> extract a Z [13] [14] [15] specification from an application's ERD and DFD. See [16] for a survey that includes other such examples. For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques.
Reference: [13] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: For example, Fraser, Kumar, and Vaishnavi [8] and Larsen, et al. [9] extract a VDM [10] [11] specification from a DFD and a data dictionary. As another example, Semmens and Allen [12] extract a Z <ref> [13] </ref> [14] [15] specification from an application's ERD and DFD. See [16] for a survey that includes other such examples. For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques.
Reference: [14] <author> J. Michael Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: For example, Fraser, Kumar, and Vaishnavi [8] and Larsen, et al. [9] extract a VDM [10] [11] specification from a DFD and a data dictionary. As another example, Semmens and Allen [12] extract a Z [13] <ref> [14] </ref> [15] specification from an application's ERD and DFD. See [16] for a survey that includes other such examples. For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques.
Reference: [15] <author> J. Spivey. </author> <title> An introduction to Z and formal specifications. </title> <journal> Software Engineering Journal, </journal> <month> January </month> <year> 1989. </year>
Reference-contexts: For example, Fraser, Kumar, and Vaishnavi [8] and Larsen, et al. [9] extract a VDM [10] [11] specification from a DFD and a data dictionary. As another example, Semmens and Allen [12] extract a Z [13] [14] <ref> [15] </ref> specification from an application's ERD and DFD. See [16] for a survey that includes other such examples. For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques.
Reference: [16] <author> Robert B. France and Maria M. Larrondo-Petrie. </author> <title> From structured analysis to formal specifications: State of the theory. </title> <booktitle> In Proceedings of the ACM Computer Science Conference, </booktitle> <address> Phoenix, AZ, </address> <pages> pages 249-256. </pages> <publisher> ACM, </publisher> <month> Mar </month> <year> 1994. </year>
Reference-contexts: For example, Fraser, Kumar, and Vaishnavi [8] and Larsen, et al. [9] extract a VDM [10] [11] specification from a DFD and a data dictionary. As another example, Semmens and Allen [12] extract a Z [13] [14] [15] specification from an application's ERD and DFD. See <ref> [16] </ref> for a survey that includes other such examples. For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques. For example, Wing and Zaremski [17] augment SA specifications (especially the data dictionary), with specifications in the Larch Shared Language [18]. <p> This precise use of DFDs would certainly come after the imprecise, informal use, but one should not have to completely change notations in order to formally describe systems. Instead, we look forward to an integration of informal and formal specifications spanning a wide range of needs [7] <ref> [16] </ref> [22]. The advantage of formal and precise DFD specifications would be that the work done in requirements analysis would not have to be thrown away when more precision is required.
Reference: [17] <author> Jeannette M. Wing and Amy Moormann Zaremski. </author> <title> Unintrusive ways to integrate formal specifications in practice. </title> <editor> In S. Prehn and W. J. Toetenel, editors, </editor> <booktitle> VDM '91 Formal Software Development Methods 4th International Symposium of VDM Europe Noordwijkerhout, The Netherlands, Volume 1: Conference Contributions, volume 551 of Lecture Notes in Computer Science, </booktitle> <pages> pages 545-569. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> October </month> <year> 1991. </year>
Reference-contexts: See [16] for a survey that includes other such examples. For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques. For example, Wing and Zaremski <ref> [17] </ref> augment SA specifications (especially the data dictionary), with specifications in the Larch Shared Language [18]. Several researchers have used VDM specifications to augment the data dictionary and to specify the behavior of bubbles [9] [19] [20] [21].
Reference: [18] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: See [16] for a survey that includes other such examples. For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques. For example, Wing and Zaremski [17] augment SA specifications (especially the data dictionary), with specifications in the Larch Shared Language <ref> [18] </ref>. Several researchers have used VDM specifications to augment the data dictionary and to specify the behavior of bubbles [9] [19] [20] [21].
Reference: [19] <author> Rene Elmstrtm, Raino Lintulampi, and Mauro Pezze. </author> <title> Giving semantics to SA/RT by means of High-Level Timed Petri Nets. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 5 </volume> <pages> 249-271, </pages> <year> 1993. </year>
Reference-contexts: For example, Wing and Zaremski [17] augment SA specifications (especially the data dictionary), with specifications in the Larch Shared Language [18]. Several researchers have used VDM specifications to augment the data dictionary and to specify the behavior of bubbles [9] <ref> [19] </ref> [20] [21]. As another example, France [5] [22], has specified the types in a data dictionary using Z notation, and has used Z to augment the specifications of data stores and global state invariants. <p> other words, the type system used in an extended DFD specification language, and not that used in our semantics, is the only thing that would impose a limit on the kind of stores that can be specified. 2.4 What Should the Initial Value be for a Flow? Some authors (e.g., <ref> [19] </ref> [20]) use a formal model in which each flow in a DFD starts off empty (i.e., is uninitialized). <p> This two-step firing rule allows the modeling of concurrent firing of bubbles and time delays. (However, we do not model real-time aspects of time delays, as in [3] <ref> [19] </ref> [20].) To see why a two-step firing rule is necessary, suppose that bubbles were able to read their inputs and compute and write their outputs in one atomic step. <p> As described in Section 2.6, we use scenarios to resolve this shortcoming in the same manner as Brock and Ackerman use scenarios to resolve this shortcoming for data flow networks [26]. 7.3.7 Elmstrtm, et al. As part of the IPTES project, Elmstrtm and others <ref> [19] </ref> [20] described a semantics for SA/RT DFDs [3] augmented with VDM-SL P-specs. This semantics uses high-level timed Petri nets (HLTPNs) [32]. HLTPNs are similar to colored Petri nets, but because they include timing information on transitions, they can adequately model the dynamic behavior of a DFD. <p> It would also make the model unsuitable as a general translation target for extended DFD specification languages. A larger difference is that, in <ref> [19] </ref> [20], Elmstrtm, et al. do not handle hierarchical DFDs and refinement. Thus they do not deal with the possibility of bubbles firing concurrently with themselves. 32 The semantics given in [19] [20] is not as direct as our semantics, because a DFD specification is first translated into a HLTPN, and <p> A larger difference is that, in <ref> [19] </ref> [20], Elmstrtm, et al. do not handle hierarchical DFDs and refinement. Thus they do not deal with the possibility of bubbles firing concurrently with themselves. 32 The semantics given in [19] [20] is not as direct as our semantics, because a DFD specification is first translated into a HLTPN, and then the semantics of HLTPNs is given separately.
Reference: [20] <author> Rene Elmstrtm, Poul Btgh Lassen, and Michael Andersen. </author> <title> An executable subset of VDM-SL in an SA/RT framework. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 5 </volume> <pages> 197-211, </pages> <year> 1993. </year>
Reference-contexts: For example, Wing and Zaremski [17] augment SA specifications (especially the data dictionary), with specifications in the Larch Shared Language [18]. Several researchers have used VDM specifications to augment the data dictionary and to specify the behavior of bubbles [9] [19] <ref> [20] </ref> [21]. As another example, France [5] [22], has specified the types in a data dictionary using Z notation, and has used Z to augment the specifications of data stores and global state invariants. <p> words, the type system used in an extended DFD specification language, and not that used in our semantics, is the only thing that would impose a limit on the kind of stores that can be specified. 2.4 What Should the Initial Value be for a Flow? Some authors (e.g., [19] <ref> [20] </ref>) use a formal model in which each flow in a DFD starts off empty (i.e., is uninitialized). However, if one considers a specification language where users can specify initial values for all flows, such a default makes it more difficult to translate that specification language into the formal model. <p> This two-step firing rule allows the modeling of concurrent firing of bubbles and time delays. (However, we do not model real-time aspects of time delays, as in [3] [19] <ref> [20] </ref>.) To see why a two-step firing rule is necessary, suppose that bubbles were able to read their inputs and compute and write their outputs in one atomic step. <p> As described in Section 2.6, we use scenarios to resolve this shortcoming in the same manner as Brock and Ackerman use scenarios to resolve this shortcoming for data flow networks [26]. 7.3.7 Elmstrtm, et al. As part of the IPTES project, Elmstrtm and others [19] <ref> [20] </ref> described a semantics for SA/RT DFDs [3] augmented with VDM-SL P-specs. This semantics uses high-level timed Petri nets (HLTPNs) [32]. HLTPNs are similar to colored Petri nets, but because they include timing information on transitions, they can adequately model the dynamic behavior of a DFD. <p> It would also make the model unsuitable as a general translation target for extended DFD specification languages. A larger difference is that, in [19] <ref> [20] </ref>, Elmstrtm, et al. do not handle hierarchical DFDs and refinement. Thus they do not deal with the possibility of bubbles firing concurrently with themselves. 32 The semantics given in [19] [20] is not as direct as our semantics, because a DFD specification is first translated into a HLTPN, and then <p> A larger difference is that, in [19] <ref> [20] </ref>, Elmstrtm, et al. do not handle hierarchical DFDs and refinement. Thus they do not deal with the possibility of bubbles firing concurrently with themselves. 32 The semantics given in [19] [20] is not as direct as our semantics, because a DFD specification is first translated into a HLTPN, and then the semantics of HLTPNs is given separately.
Reference: [21] <author> Peter Gorm Larsen, Nico Plat, and Hans Toetenel. </author> <title> A formal semantics of data flow diagrams. </title> <journal> Formal aspects of Computing, </journal> <volume> 6(6) </volume> <pages> 586-606, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: For example, Wing and Zaremski [17] augment SA specifications (especially the data dictionary), with specifications in the Larch Shared Language [18]. Several researchers have used VDM specifications to augment the data dictionary and to specify the behavior of bubbles [9] [19] [20] <ref> [21] </ref>. As another example, France [5] [22], has specified the types in a data dictionary using Z notation, and has used Z to augment the specifications of data stores and global state invariants. <p> This is most evident in their presentation of P-specs, which are given in VDM-SL, instead of using a general semantic model. 7.3.8 Larsen, Plat, and Toetenel Larsen, Plat, and Toetenel have given a formal semantics of DFDs by translation into VDM-SL <ref> [21] </ref>. In this work, the DFDs are augmented by VDM-SL P-Specs (mini-specifications), and the translation produces either an implicit style VDM-SL specification, or an explicit one (which can be executed). Again, this semantics is not as direct as our semantics.
Reference: [22] <author> Robert B. France and Maria M. Larrondo-Petrie. </author> <title> A two-dimensional view of integrated formal and informal specifications techniques. </title> <editor> In Jonathan P. Bowen and Michael G. Hinchey, editors, </editor> <title> ZUM '95: The Z Formal Specification Notation, </title> <booktitle> 9th International Conference of Z Users, Limerick, Ireland, volume 967 of Lecture Notes in Computer Science, </booktitle> <pages> pages 434-448. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1995. </year> <month> 38 </month>
Reference-contexts: For example, Wing and Zaremski [17] augment SA specifications (especially the data dictionary), with specifications in the Larch Shared Language [18]. Several researchers have used VDM specifications to augment the data dictionary and to specify the behavior of bubbles [9] [19] [20] [21]. As another example, France [5] <ref> [22] </ref>, has specified the types in a data dictionary using Z notation, and has used Z to augment the specifications of data stores and global state invariants. These extensions are relevant, because they indicate that there is a desire for integration of DFDs and formal methods. <p> This precise use of DFDs would certainly come after the imprecise, informal use, but one should not have to completely change notations in order to formally describe systems. Instead, we look forward to an integration of informal and formal specifications spanning a wide range of needs [7] [16] <ref> [22] </ref>. The advantage of formal and precise DFD specifications would be that the work done in requirements analysis would not have to be thrown away when more precision is required.
Reference: [23] <author> Tim Wahls, Albert L. Baker, and Gary T. Leavens. </author> <title> An executable semantics for a for-malized data flow diagram specification language. </title> <type> Technical Report 93-27, </type> <institution> Department of Computer Science, Iowa State University, 226 Atanasoff Hall, Ames, Iowa 50011, </institution> <month> November </month> <year> 1993. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu or by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Due to space considerations, we will not give the details of an extended DFD specification language (some preliminary ideas are, however, found in <ref> [23] </ref>), or a translation from such 2 a language into our semantic model. What we offer instead is the definition of the target of such a translation (the semantic model itself).
Reference: [24] <author> Paul T. Ward. </author> <title> The transformation schema: An extension of the data flow diagram to represent control and timing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(2), </volume> <month> February </month> <year> 1986. </year>
Reference-contexts: In our model, the types of values can be arbitrary abstract data types (ADTs), including stacks, B-trees, etc., of arbitrary complexity. 2.2 What Kinds of Flows to Model? In SA, DeMarco [1] and others (e.g., <ref> [24] </ref>) make a distinction between "discrete" and "continuous" flows. Some authors seem to consider continuous flows as continuous in the sense of calculus (i.e., real-valued, differentiable). DeMarco and Ward seem to think of them as continuously existing (i.e., like a shared variable) even when read. <p> Again our model does not suffer from the ambiguity inherent in De Marco's DFDs. Ward, in <ref> [24] </ref> gives notation to disambiguate these two senses of converging and diverging flows, but leaves the process by which tupling and splitting of data is achieved implicit. Similarly, our model can represent "dialogue flows" by two separate flows. <p> This permits abstract execution of a higher-level bubble, and a comparison with the behavior of the sub-DFD. 7.3.2 Ward Ward <ref> [24] </ref> distinguishes discrete from continuous data flows; that is between discrete and analog data, which he defines as "a set of values defined continuously over a time interval" 30 [24, page 199]. Hatley and Pirbhai have a similar notion of continuity [35] [25, Section 5.3.2]. <p> This permits abstract execution of a higher-level bubble, and a comparison with the behavior of the sub-DFD. 7.3.2 Ward Ward [24] distinguishes discrete from continuous data flows; that is between discrete and analog data, which he defines as "a set of values defined continuously over a time interval" 30 <ref> [24, page 199] </ref>. Hatley and Pirbhai have a similar notion of continuity [35] [25, Section 5.3.2]. Since such data can only be modeled in a computer by discrete data, there seems to be no good reason to model this distinction. <p> Hatley and Pirbhai have a similar notion of continuity [35] [25, Section 5.3.2]. Since such data can only be modeled in a computer by discrete data, there seems to be no good reason to model this distinction. Instead, we have adopted Ward's semantics for continuous flows as shared variables <ref> [24, page 203] </ref> as a feature of flows in our model. This feature of flows is orthogonal to the type of data on the flow. This is the distinction between consumable and persistent flows [25, Section 5.3.4]. The traditional view of stores is that they represent files [24, page 199]. <p> This feature of flows is orthogonal to the type of data on the flow. This is the distinction between consumable and persistent flows [25, Section 5.3.4]. The traditional view of stores is that they represent files <ref> [24, page 199] </ref>. Our model allows stores to have any type, including the type of a file. Ward also includes in his extension of DFDs something called a "buffer", which is highly ambiguous. He says that a "buffer is an abstraction on a stack or a queue" [24, page 200]. <p> Our model allows stores to have any type, including the type of a file. Ward also includes in his extension of DFDs something called a "buffer", which is highly ambiguous. He says that a "buffer is an abstraction on a stack or a queue" <ref> [24, page 200] </ref>. Stacks and (LIFO) queues certainly have different behavior, but both can be modeled in our semantics. Ward gives a semantics of DFDs based "loosely on the execution of a Petri net" [24, pages 203-205]. However, his semantics are somewhat informal and ambiguous. <p> He says that a "buffer is an abstraction on a stack or a queue" [24, page 200]. Stacks and (LIFO) queues certainly have different behavior, but both can be modeled in our semantics. Ward gives a semantics of DFDs based "loosely on the execution of a Petri net" <ref> [24, pages 203-205] </ref>. However, his semantics are somewhat informal and ambiguous. For example, he does not clear up the ambiguity in the potential behavior of buffers.
Reference: [25] <author> David L. Coleman. </author> <title> Formalized structured analysis specifications. </title> <type> PhD thesis, </type> <institution> Iowa State University, Ames, Iowa, </institution> <month> 50011, </month> <year> 1991. </year>
Reference-contexts: On the other hand, the difference between a shared variable and a queue is fundamental, and needs to be directly supported by the formal model. Hence our formal model supports this distinction. However, to avoid confusion, we use different terminology <ref> [25] </ref>. Flows labeled with a single arrowhead are called consumable flows; these can be considered to be unbounded FIFO queues. Flows labeled with a double arrowhead are called persistent flows; these can be considered to be shared variables. <p> type Signal, where Signal is a type that has only one element. (One could also use a persistent flow and a two-element type to indicate that the signal is "on" or "off".) 2.3 How Should Stores be Modeled? In traditional SA, a store is a passive holder of data [1] <ref> [25] </ref>, much like a file in data processing. Multiple bubbles can access a single store for both reading and writing, but the store itself does not transform data. <p> Multiple bubbles can access a single store for both reading and writing, but the store itself does not transform data. Since persistent flows in our model act like shared variables, following a suggestion by Coleman <ref> [25, Figure 8.2] </ref> we keep the set of modeling concepts small by modeling stores as persistent flows. <p> Neither the flow name nor the type alone are sufficient to uniquely identify a flow in our example; having both pieces of information eliminates a common source of ambiguity <ref> [25] </ref>. 2 2 Some extended DFD specification languages may permit flows with the same name and type to appear in multiple places in a DFD; this does not cause a problem for the formal model of flows, in which the source and target bubbles also help identify it. 10 Mail ' <p> In a persistent flow, the shared variable that the flow represents can be written by each bubble at the source of the flow, and read by each target bubble <ref> [25] </ref>. Reading from a persistent flow does not change the information in the flow. In the formal model of our example, the only persistent flows go from bubbles to themselves, because they are used to model local stores. <p> Our formal model is also more expressive, in that it can easily describe the semantics of dynamic behavior, including bubbles firing concurrently with themselves, which allows a formal treatment of refinement. 29 7.3.1 De Marco and Yourdon DFDs used in traditional structured analysis [1] <ref> [25, page 15] </ref> have a very informal flavor and some features that are not directly present in our models. For example, De Marco has graphical notations on flows for "conjunction" (*) and "disjunction" () that are not a part of our formal model of the syntax of DFDs. <p> For example, De Marco has graphical notations on flows for "conjunction" (*) and "disjunction" () that are not a part of our formal model of the syntax of DFDs. Similarly, Yourdon makes graphical distinctions between "data" and "control" flows [4] <ref> [25, pages 27-28] </ref>. However, our formal model can encode this kind of information in a general way. <p> However, their semantics is ambiguous. A converging flow may mean either that: * there are several flows which all have their sinks in the same bubble, or * several "elementary packets of data" are to be joined "to form a complex packet" (such as a tuple) <ref> [25, page 16] </ref>. In our model one can express the first by having several separate flows, with a flow having several sources as in Section 2.3. <p> Hatley and Pirbhai have a similar notion of continuity [35] <ref> [25, Section 5.3.2] </ref>. Since such data can only be modeled in a computer by discrete data, there seems to be no good reason to model this distinction. Instead, we have adopted Ward's semantics for continuous flows as shared variables [24, page 203] as a feature of flows in our model. <p> Instead, we have adopted Ward's semantics for continuous flows as shared variables [24, page 203] as a feature of flows in our model. This feature of flows is orthogonal to the type of data on the flow. This is the distinction between consumable and persistent flows <ref> [25, Section 5.3.4] </ref>. The traditional view of stores is that they represent files [24, page 199]. Our model allows stores to have any type, including the type of a file. Ward also includes in his extension of DFDs something called a "buffer", which is highly ambiguous. <p> Also, since they are only interested in one extended DFD specification language, they do not give as general a translation target as our semantics. 7.3.9 Coleman The static semantics of SA specifications (including notational issues) are treated in a dissertation by Coleman <ref> [25] </ref>. <p> Coleman describes a notation for P-specs based on first-order logic <ref> [25, Chapter 7] </ref>, which inspired parts of our model; his notation could be translated into our model. <p> Coleman describes a notation for P-specs based on first-order logic [25, Chapter 7], which inspired parts of our model; his notation could be translated into our model. Coleman also describes how one could give an operational semantics of SA specifications <ref> [25, Section 9.2] </ref> using what amounts to colored Petri nets (values are used instead of Ward's tokens) and first-order logical assertions for the transition firing rules. As described above in the section on colored Petri nets, however, such a semantics is inadequate for modeling the dynamic behavior of DFDs. <p> As described above in the section on colored Petri nets, however, such a semantics is inadequate for modeling the dynamic behavior of DFDs. Nevertheless, our model is derived from his initial work. Coleman also gives several different possible models of stores, one of which <ref> [25, Figure 8.2] </ref> is the one we adopt. However, he ignores stores in his sketch of the operational semantics of DFDs.
Reference: [26] <author> J. Dean Brock and William B. Ackerman. </author> <title> Scenarios: A model of non-determinate computation. </title> <editor> In J. Diaz and I. Ramos, editors, </editor> <booktitle> Formalization of Programming Concepts, volume 107 of Lecture Notes in Computer Science, </booktitle> <pages> pages 252-259. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: Following <ref> [26] </ref>, a scenario of a DFD is a pair consisting of a sequence of values presented to the DFD as inputs (i.e., on the flows coming from the external inputs) and an associated output sequence of values (i.e., on the flows into the external outputs), augmented with a partial order on <p> Suppose one wants to specify a bubble, at the lowest level 1 In this simple example, the partial order on values in a scenario may appear to be unnecessary. However, Brock and Ackerman <ref> [26] </ref> have shown that two "network computations" with the same history relation (scenario set minus the partial order) can not always be substituted for each other in a larger network computation without changing the history relation of that larger computation. <p> can be characterized with scenarios, although the simple graphical representation for scenarios used thus far is no longer sufficient. 27 The following algorithm for constructing scenario sets from configuration sequences is simplified and adapted for DFDs from Brock and Ackerman's algorithm for constructing the scenario set of a network computation <ref> [26] </ref>. The simplification results from the fact that Brock and Ackerman's algorithm finds all possible scenarios for a network computation, while the algorithm presented here finds only the scenarios arising from a given configuration sequence. Additionally, this algorithm deals only with finite configuration sequences. <p> As described in Section 2.6, we use scenarios to resolve this shortcoming in the same manner as Brock and Ackerman use scenarios to resolve this shortcoming for data flow networks <ref> [26] </ref>. 7.3.7 Elmstrtm, et al. As part of the IPTES project, Elmstrtm and others [19] [20] described a semantics for SA/RT DFDs [3] augmented with VDM-SL P-specs. This semantics uses high-level timed Petri nets (HLTPNs) [32].
Reference: [27] <author> J. L. Peterson. </author> <title> Petri nets. </title> <journal> ACM Computing Surveys, </journal> <volume> 9(3) </volume> <pages> 221-252, </pages> <month> September </month> <year> 1977. </year>
Reference-contexts: Our model of the execution of a DFD consists of bubble computations and information moving from one bubble to another along the flows. A configuration is a snapshot of such an execution, taken at certain well-defined points; it is similar to a marking of a Petri net <ref> [27] </ref>. A configuration records the information that bubble has read from its input flows (if any), and the information present on each flow. The formal model of configurations, the set , is summarized in Table 5, and will be explained below.
Reference: [28] <author> A. Church. </author> <title> The Calculi of Lambda Conversion, </title> <booktitle> volume 6 of Annals of Mathematics Studies. </booktitle> <publisher> Princeton University Press, </publisher> <address> Princeton, N.J., </address> <year> 1941. </year> <title> Reprinted by Klaus Reprint Corp., </title> <address> New York in 1965. </address>
Reference-contexts: A persistent flow must be mapped to a se 5 The notation f : e denotes a function that takes an argument, and returns the value of the expression e with the argument substituted for f <ref> [28] </ref> [29]. 17 fs e (f ) = &gt; &gt; &gt; &lt; hcdbi if f = f custs hardbi if f = f c-a-data hhii if f = f log hi otherwise, ardb 2 TypeMeaning e (Acct-DB), and hi 2 TypeMeaning e (Money-and-Acct-List). quence of length zero or one; when the
Reference: [29] <author> David A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, Inc., </publisher> <address> Boston, Mass., </address> <year> 1986. </year>
Reference-contexts: A persistent flow must be mapped to a se 5 The notation f : e denotes a function that takes an argument, and returns the value of the expression e with the argument substituted for f [28] <ref> [29] </ref>. 17 fs e (f ) = &gt; &gt; &gt; &lt; hcdbi if f = f custs hardbi if f = f c-a-data hhii if f = f log hi otherwise, ardb 2 TypeMeaning e (Acct-DB), and hi 2 TypeMeaning e (Money-and-Acct-List). quence of length zero or one; when the sequence
Reference: [30] <author> Matthew Hennessy. </author> <title> The Semantics of Programming Languages: an Elementary Introduction using Structural Operational Semantics. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: Each rule (technically an axiom) consists of a transition between configurations and several side conditions. The side conditions are located to the right of the transition, and follow the word "where". The side conditions must hold for the transition to take place <ref> [30] </ref>. 25 (fs; r) ! (fs 0 ; r 0 ) where Enabled (b)(fsj Inputs (b) ; r (b)) = true; fset 2 Consume (b)(fsj Inputs (b) ); r 0 = (b 0 : if b 6= b 0 then r (b 0 ) else Enq (r (b); f : if <p> One might wish to abstract away from the sequences of configurations, in order to focus on the "answer" returned by a DFD. Indeed, this is often done in the semantics of programming languages given in Plotkin's structural style [31] <ref> [30] </ref>. To do this, one would identify a set of terminal configurations, from which no transitions are possible. However, such an attempt seems of little value for DFDs, because the sources may always be able to fire, as in our example.
Reference: [31] <author> G. D. Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5 </volume> <pages> 223-255, </pages> <year> 1977. </year>
Reference-contexts: One might wish to abstract away from the sequences of configurations, in order to focus on the "answer" returned by a DFD. Indeed, this is often done in the semantics of programming languages given in Plotkin's structural style <ref> [31] </ref> [30]. To do this, one would identify a set of terminal configurations, from which no transitions are possible. However, such an attempt seems of little value for DFDs, because the sources may always be able to fire, as in our example.
Reference: [32] <author> Miguel Felder, Carlo Ghezzi, and Mauro Pezze. </author> <title> High-Level Timed Petri Nets as a kernel for executable specifications. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 5 </volume> <pages> 235-248, </pages> <year> 1993. </year>
Reference-contexts: Our motivation for this work is to describe a translation target for extended DFD specification languages, and thus we have sought to produce a general and useful formal model. Aside from the work on high level timed Petri nets (HLTPNs) <ref> [32] </ref>, we know of no other work with similar goals. The main distinction between our formal models and HLTPNs is that our models have a more direct correspondence to DFDs. HLTPNs have timing information associated with them, and so are permit timing analysis that is impossible with our models. <p> As part of the IPTES project, Elmstrtm and others [19] [20] described a semantics for SA/RT DFDs [3] augmented with VDM-SL P-specs. This semantics uses high-level timed Petri nets (HLTPNs) <ref> [32] </ref>. HLTPNs are similar to colored Petri nets, but because they include timing information on transitions, they can adequately model the dynamic behavior of a DFD.
Reference: [33] <author> Peter Huber, Kurt Jensen, and Robert M. Shapiro. </author> <title> Hierarchies in Coloured Petri Nets. </title> <editor> In G. Rosenberg, editor, </editor> <booktitle> Advances in Petra nets 1990, volume 483 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: The only aspect of hierarchical DFDs that is not handled by our semantics is that the transition rules for configurations do not take the hierarchy into account (as in the semantics of hierarchical colored petri nets <ref> [33] </ref> [34]). However, by not doing so, we do not define the semantics of a higher-level bubble by a sub-DFD, but rather permit both the higher-level bubble and its sub-DFD to be given a behavioral specification. <p> however, their semantics also ignores the values on the flows, and so cannot describe the full behavior of a DFD. 7.3.5 Colored Petri Nets One can imagine giving a fuller account of the dynamic behavior of DFDs by extending Ward and Tse and Pong's approach with colored Petri nets [39] <ref> [33] </ref>. (The different "colors" on tokens can stand for different values being passed in a DFD.) However, because the firing rules of Petri nets are atomic, each bubble in a DFD would have to be either modeled by a complex Petri net, or the semantics of a bubble's firing would be
Reference: [34] <author> Soren Christensen and Leif Obel Jepsen. </author> <title> Modelling and simulation of a network management system using Hierarchical Coloured Petri Nets (extended version). </title> <type> Technical Report DAIMI PB 349, </type> <institution> Computer Science Department, Aarhus University, </institution> <month> Apr </month> <year> 1991. </year>
Reference-contexts: The only aspect of hierarchical DFDs that is not handled by our semantics is that the transition rules for configurations do not take the hierarchy into account (as in the semantics of hierarchical colored petri nets [33] <ref> [34] </ref>). However, by not doing so, we do not define the semantics of a higher-level bubble by a sub-DFD, but rather permit both the higher-level bubble and its sub-DFD to be given a behavioral specification.
Reference: [35] <author> D. J. Hatley and I. Pirbhai. </author> <title> Strategies for Real-Time System Specification. </title> <publisher> Dorset House, </publisher> <address> New York, N.Y., </address> <year> 1987. </year>
Reference-contexts: Hatley and Pirbhai have a similar notion of continuity <ref> [35] </ref> [25, Section 5.3.2]. Since such data can only be modeled in a computer by discrete data, there seems to be no good reason to model this distinction.
Reference: [36] <author> T. H. Tse and L. Pong. </author> <title> Towards a formal foundation for Demarco data flow diagrams. </title> <journal> The Computer Journal, </journal> <volume> 32(1) </volume> <pages> 1-12, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Our semantics can be regarded as a cleaned-up version of this idea. 7.3.3 Tse and Pong Tse and Pong recognize that: "Transitions and places of Petri nets correspond, respectively, to processes and data flows of DFDs" <ref> [36, page 1] </ref>. They also give an algebraic model of DFDs. However, their semantics using Petri nets also ignores the values on the flows and so cannot describe the full behavior of a DFD.
Reference: [37] <author> T. H. Tse. </author> <title> A Unifying Framework for Structured Analysis and Design Models, </title> <booktitle> volume 11 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge Univerity Press, </publisher> <address> New York, N.Y., </address> <year> 1991. </year> <month> 39 </month>
Reference-contexts: They also give an algebraic model of DFDs. However, their semantics using Petri nets also ignores the values on the flows and so cannot describe the full behavior of a DFD. Tse's work <ref> [37] </ref> only deals with the syntax of DFDs, not their semantics. 7.3.4 Bruza and van der Weide Bruza and van der Weide [38] give a semantics of DFDs in terms of extended Petri nets and path expressions. Like Tse and Pong, they model flows by places, and bubbles by transitions.
Reference: [38] <author> P. D. Bruza and Th. P. van der Weide. </author> <title> The semantics of data flow diagrams. </title> <editor> In N. Prakash, editor, </editor> <booktitle> Proceedings of the International Conference on Management of Data, </booktitle> <address> Hyderabad, India, </address> <year> 1989. </year> <month> ftp://ftp.cs.kun.nl/pub/SoftwEng.InfSyst/articles/ProcSem1.ps.Z. </month>
Reference-contexts: However, their semantics using Petri nets also ignores the values on the flows and so cannot describe the full behavior of a DFD. Tse's work [37] only deals with the syntax of DFDs, not their semantics. 7.3.4 Bruza and van der Weide Bruza and van der Weide <ref> [38] </ref> give a semantics of DFDs in terms of extended Petri nets and path expressions. Like Tse and Pong, they model flows by places, and bubbles by transitions. They point out that the DFD notation is ambiguous and needs extra specification annotations to be unambiguous.
Reference: [39] <author> Kurt Jensen. </author> <title> Coloured Petri Nets: A high level language for system analysis and design. </title> <editor> In G. Rozenberg, editor, </editor> <booktitle> Advances in Petri Nets 1990, volume 483 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> Also a technical report from the CS Dept, </note> <institution> Aarhus University, DAIMI PB-338, </institution> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: Pong, however, their semantics also ignores the values on the flows, and so cannot describe the full behavior of a DFD. 7.3.5 Colored Petri Nets One can imagine giving a fuller account of the dynamic behavior of DFDs by extending Ward and Tse and Pong's approach with colored Petri nets <ref> [39] </ref> [33]. (The different "colors" on tokens can stand for different values being passed in a DFD.) However, because the firing rules of Petri nets are atomic, each bubble in a DFD would have to be either modeled by a complex Petri net, or the semantics of a bubble's firing would
Reference: [40] <author> G. Kahn. </author> <title> The semantics of a simple language for parallel programming. </title> <editor> In J. L. Rosenfeld, editor, </editor> <booktitle> Information Processing '74: Proceedings of the IFIP Congress, </booktitle> <pages> pages 471-475. </pages> <publisher> North-Holland, </publisher> <address> New York, N.Y., </address> <year> 1974. </year>
Reference-contexts: This work has produced both denotational semantics, such as Kahn's foundational work <ref> [40] </ref> and that of Staples and Nguyen [41], and operational semantics, such as that of Panangaden and Shanbhogue [42], for data flow networks. Any of these semantics that supports nondeterminism (Kahn's does not) could be used as a translation target for DFDs, but the translation would present significant difficulties.
Reference: [41] <author> John Staples and V. L. Nguyen. </author> <title> A fixpoint semantics for nondeterministic data flow. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 411-444, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: This work has produced both denotational semantics, such as Kahn's foundational work [40] and that of Staples and Nguyen <ref> [41] </ref>, and operational semantics, such as that of Panangaden and Shanbhogue [42], for data flow networks. Any of these semantics that supports nondeterminism (Kahn's does not) could be used as a translation target for DFDs, but the translation would present significant difficulties.
Reference: [42] <author> Prakash Panangaden and Vasant Shanbhogue. </author> <title> The expressive power of indeterminate dataflow primitives. </title> <journal> Information and Computation, </journal> <volume> 98(1) </volume> <pages> 99-131, </pages> <year> 1992. </year>
Reference-contexts: This work has produced both denotational semantics, such as Kahn's foundational work [40] and that of Staples and Nguyen [41], and operational semantics, such as that of Panangaden and Shanbhogue <ref> [42] </ref>, for data flow networks. Any of these semantics that supports nondeterminism (Kahn's does not) could be used as a translation target for DFDs, but the translation would present significant difficulties.
Reference: [43] <author> Robert B. </author> <title> France. Semantically extended data flow diagrams: A formal specification tool. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(4) </volume> <pages> 329-346, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Coleman also gives several different possible models of stores, one of which [25, Figure 8.2] is the one we adopt. However, he ignores stores in his sketch of the operational semantics of DFDs. Coleman does not treat a bubble firing concurrently with itself. 7.3.10 France In the two works <ref> [43] </ref> [5] that we discuss below, France describes variants of DFDs, specification notations, and their semantics. <p> In summary, the major difference is that France presents specific specification notations 33 and their semantics, while we have explored what kinds of semantics for extended DFD specification are sensible, with a special focus on modeling the dynamic behavior of DFDs. Semantically Extended DFDs In <ref> [43] </ref> France works with DFDs that have several additional features, and he also gives a formal semantics. France's "queued flows" are what we call consumable flows, and his "variables" are our persistent flows. <p> The main difference in the formal framework is that France's semantics use transition systems to model all parts of a DFD, not just the firing rules. This gives the semantics a nicely compositional flavor, and allows an easy treatment of hierarchical DFDs <ref> [43, page 333] </ref>. France gives an explicit notation for P-specs, which could be given an alternative semantics using our model. All of his additional graphical conventions for DFDs can be translated into our model in ways similar to those discussed above for other related work. <p> For example, each bubble must have an output flow (page 330) and nested loops are not allowed inside infinite loops in his P-spec statement language (page 337). France treats stores the same as he treats other parts of a DFD, as ASTSs <ref> [43, pages 336-337] </ref>; hence his stores need more description than necessary in our model, where stores are modeled as persistent flows. <p> France's model does not allow bubbles to fire concurrently with themselves because each bubble has only one copy of its variables <ref> [43, pages 344-345] </ref>. Firing in a DFD is apparently an atomic step, since "outputs are solely dependent on current inputs" [43, page 342]. <p> France's model does not allow bubbles to fire concurrently with themselves because each bubble has only one copy of its variables [43, pages 344-345]. Firing in a DFD is apparently an atomic step, since "outputs are solely dependent on current inputs" <ref> [43, page 342] </ref>. Although France's language for writing P-specs does include explicit statements that allow for parallel processing within a bubble, his conditions on such parallel processing [43, page 341] require that statements executed in parallel cannot interact. <p> Firing in a DFD is apparently an atomic step, since "outputs are solely dependent on current inputs" [43, page 342]. Although France's language for writing P-specs does include explicit statements that allow for parallel processing within a bubble, his conditions on such parallel processing <ref> [43, page 341] </ref> require that statements executed in parallel cannot interact. Thus the parallelism allowed within a bubble's firing cannot be observed from the outside; from the outside a bubble appears to transform inputs to outputs in an atomic step. <p> Since the refined bubbles fire in atomic steps, the refinement cannot process inputs in a different order than the refined bubble, as noted in the I/O consistency condition <ref> [43, pages 342-343] </ref>. Although this is an advantage in that 34 it simplifies the proof that a refinement correctly implements the refined bubble, it is less expressive as a foundation for specification languages, because it prohibits some refinements.
Reference: [44] <author> E. Astesiano and G. Reggio. </author> <title> SMoLCS driven concurrent calculi. </title> <editor> In Hartmut Ehrig et al., editors, TAPSOFT'87, </editor> <booktitle> Proceedings of the International Joint Conference on Theory and Practice of Software Development, Pisa, Italy, Volume 1, volume 245 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: Our model is arguably simpler in that both of his types of bubbles and flows can be translated into ours. France's operational semantics of extended DFDs use a framework similar to ours: algebraic state transition systems (ASTSs) <ref> [44] </ref> [45]. The main difference in the formal framework is that France's semantics use transition systems to model all parts of a DFD, not just the firing rules. This gives the semantics a nicely compositional flavor, and allows an easy treatment of hierarchical DFDs [43, page 333].
Reference: [45] <author> Edigio Astesiano. </author> <title> Inductive and operational semantics. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts, IFIP State-of-the-Art Reports, </booktitle> <pages> pages 51-136. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: Our model is arguably simpler in that both of his types of bubbles and flows can be translated into ours. France's operational semantics of extended DFDs use a framework similar to ours: algebraic state transition systems (ASTSs) [44] <ref> [45] </ref>. The main difference in the formal framework is that France's semantics use transition systems to model all parts of a DFD, not just the firing rules. This gives the semantics a nicely compositional flavor, and allows an easy treatment of hierarchical DFDs [43, page 333].
Reference: [46] <author> Kari Ann Lyle. </author> <title> Refinement in data flow diagrams. </title> <type> Master's thesis, </type> <institution> Iowa State University, Ames, Iowa 50011, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: That is, there is no way to specify a bubble that may be refined into a system of bubbles that may process inputs in different orders. We permit such refinements by allowing a bubble to fire concurrently with itself <ref> [46] </ref>. A Predicative Basis for SA Specification Tools In [5] France gives a different formalization of the semantics of DFDs, this one geared towards composition and decomposition of DFDs. In this work France uses a variant of DFDs he calls PDFDs, along with ERDs, and data dictionaries with ADT specifications.
Reference: [47] <author> David Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8(3) </volume> <pages> 231-274, </pages> <month> June </month> <year> 1987. </year> <month> 40 </month>
Reference-contexts: the PDFD semantics, France's notion of the correctness of a decomposition is too restrictive for a semantics of DFDs that is concerned with dynamic behavior, as described in Section 2.6 above. 7.3.11 Harel's Statecharts While they are not intended as a semantic foundation for SA-style DFD specification languages, Harel's statecharts <ref> [47] </ref> are also a visual specification notation that allows for concurrent execution, and could be taken as an alternative translation target for DFD specification languages.
References-found: 47

