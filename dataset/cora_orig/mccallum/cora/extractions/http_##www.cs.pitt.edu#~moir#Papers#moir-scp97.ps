URL: http://www.cs.pitt.edu/~moir/Papers/moir-scp97.ps
Refering-URL: http://www.cs.pitt.edu/~moir/papers.html
Root-URL: 
Title: Fast, Long-Lived Renaming Improved and Simplified  
Author: Mark Moir 
Date: November 1996; revised April 1997.  
Abstract: In the long-lived M-renaming problem, N processes repeatedly acquire and release names ranging over f0; :::; M 1g, where M &lt; N. It is assumed that at most k M processes concurrently request or hold names. Efficient solutions to the long-lived renaming problem can be used to improve the performance of applications in which processes repeatedly perform computations whose time complexity depends on the size of the name space containing the processes that participate concurrently. In this paper, we consider wait-free solutions to the long-lived M -renaming problem that use only read and write instructions in an asynchronous, shared-memory multiprocessor. A solution to long-lived renaming is fast if the time complexity of acquiring and releasing a name once is independent of N . We present a new fast, long-lived (k(k + 1)=2)-renaming algorithm that significantly improves upon the time and space complexity of similar previous algorithms, while providing a much simpler solution. We also show that fast, long-lived (2k 1)-renaming can be implemented with reads and writes. This result is optimal with respect to the size of the name space.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Anderson and M. Moir, </author> <title> "Using Local-Spin k-Exclusion Algorithms to Improve Wait-Free Object Implementations", </title> <note> to appear in Distributed Computing. Preliminary version appeared in Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing, </note> <month> August </month> <year> 1994, </year> <pages> pp. 141-150. </pages>
Reference-contexts: This is the essence of an approach suggested by Anderson and Moir for implementing scalable and resilient shared objects <ref> [1] </ref>. Because the time complexity of the computations discussed above is often dependent on the size of the name space containing the participating processes, renaming to a smaller name space can result in better overall time complexity.
Reference: [2] <author> H. Attiya, A. Bar-Noy, D. Dolev, D. Koller, D. Peleg, and R. Reischuk, </author> <title> "Achievable Cases in an Asynchronous Environment", </title> <booktitle> Proceedings of the 28th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1987, </year> <pages> pp. 337-346. </pages>
Reference-contexts: 1 Introduction In the one-time M renaming problem <ref> [2, 3, 4, 11] </ref>, each of a set of k processes with distinct identifiers ranging over f0; :::; N 1g is required to choose a distinct name ranging over f0; :::; M 1g, where M &lt; N . <p> The long-lived M renaming problem <ref> [2, 5, 6, 11] </ref> is a generalisation of one-time renaming in which N processes repeatedly acquire and release names from f0; :::; M 1g. It is assumed that at most k processes concurrently request or hold names, and it is required that no two processes hold the same name concurrently.
Reference: [3] <author> A. Bar-Noy and D. Dolev, </author> <title> "Shared Memory versus Message-Passing in an Asynchronous Distributed Environment", </title> <booktitle> Proceedings of the 8th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1989, </year> <pages> pp. 307-318. </pages>
Reference-contexts: 1 Introduction In the one-time M renaming problem <ref> [2, 3, 4, 11] </ref>, each of a set of k processes with distinct identifiers ranging over f0; :::; N 1g is required to choose a distinct name ranging over f0; :::; M 1g, where M &lt; N .
Reference: [4] <author> E. Borowsky and E. Gafni, </author> <title> "Immediate Atomic Snapshots and Fast Renaming", </title> <booktitle> Proceedings of the 12th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1993, </year> <pages> pp. 41-50. </pages>
Reference-contexts: 1 Introduction In the one-time M renaming problem <ref> [2, 3, 4, 11] </ref>, each of a set of k processes with distinct identifiers ranging over f0; :::; N 1g is required to choose a distinct name ranging over f0; :::; M 1g, where M &lt; N .
Reference: [5] <author> H. Buhrman, J. Garay, J. Hoepman, and M. Moir, </author> <title> "Long-Lived Renaming Made Fast", </title> <booktitle> Proceedings of the 14th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1995, </year> <pages> pp. 194-203. </pages>
Reference-contexts: The long-lived M renaming problem <ref> [2, 5, 6, 11] </ref> is a generalisation of one-time renaming in which N processes repeatedly acquire and release names from f0; :::; M 1g. It is assumed that at most k processes concurrently request or hold names, and it is required that no two processes hold the same name concurrently. <p> fast, long-lived renaming algorithms depend on strong synchronisation primitives such as test-and-set. (They also present a non-fast, long-lived renaming algorithm, referred to hereafter as the Moir-Anderson algorithm, that uses only reads and writes.) Later, Buhrman et al. showed that fast, long-lived renaming using only read and write operations is possible <ref> [5] </ref>. Such algorithms are more portable and more widely applicable than algorithms that rely on special synchronisation primitives. Unfortunately, however, the long-lived renaming solution of Buhrman et al. is quite complicated. <p> These results resolve questions left open by Buhrman et al. and by Moir and Anderson <ref> [5, 11] </ref>. Our new long-lived (k (k +1)=2)-renaming algorithm improves on the space and time complexity of the Buhrman et al. algorithm, and is also significantly simpler, as evidenced by the fact that we present full assertional proofs. <p> [11] k (k + 1)=2 fi (k) fi (k 2 ) Yes No Moir & Anderson [11] 2k 1 fi (k 4 ) fi (k 4 ) Yes No Moir & Anderson [11] k (k + 1)=2 fi (N k) fi (N k 2 ) No Yes Buhrman et al. <ref> [5] </ref> 3 k fi (k) fi (3 k ) Yes Yes Buhrman et al. [5] 72k 2 fi (k log k) fi (k 4 ) Yes Yes Buhrman et al. [5] k (k + 1)=2 fi (k 3 ) fi (k 4 min (3 k ; N )) Yes Yes Theorem <p> & Anderson [11] 2k 1 fi (k 4 ) fi (k 4 ) Yes No Moir & Anderson [11] k (k + 1)=2 fi (N k) fi (N k 2 ) No Yes Buhrman et al. <ref> [5] </ref> 3 k fi (k) fi (3 k ) Yes Yes Buhrman et al. [5] 72k 2 fi (k log k) fi (k 4 ) Yes Yes Buhrman et al. [5] k (k + 1)=2 fi (k 3 ) fi (k 4 min (3 k ; N )) Yes Yes Theorem 1 k (k + 1)=2 fi (k 2 ) fi (k 3 ) Yes <p> & Anderson [11] k (k + 1)=2 fi (N k) fi (N k 2 ) No Yes Buhrman et al. <ref> [5] </ref> 3 k fi (k) fi (3 k ) Yes Yes Buhrman et al. [5] 72k 2 fi (k log k) fi (k 4 ) Yes Yes Buhrman et al. [5] k (k + 1)=2 fi (k 3 ) fi (k 4 min (3 k ; N )) Yes Yes Theorem 1 k (k + 1)=2 fi (k 2 ) fi (k 3 ) Yes Yes Theorem 2 2k 1 fi (k 4 ) fi (k 4 ) Yes Yes Table <p> We also show that fast, long-lived (2k 1)-renaming can be implemented with reads and writes. This algorithm is optimal with respect to the size of the name space. This resolves questions left open by Buhrman et al. and by Moir and Anderson <ref> [5, 11] </ref>. While our long-lived (2k 1)-renaming algorithm is technically "fast" it still has quite high time complexity. It would be interesting to see if this can be improved upon by a more direct solution, as combining renaming algorithms tends to result in high time complexity.
Reference: [6] <author> J. Burns and G. Peterson, </author> <title> "The Ambiguity of Choosing", </title> <booktitle> Proceedings of the Eighth Annual ACM Symposium on Principles of Distributed Computing, ACM, </booktitle> <address> New York, </address> <month> August </month> <year> 1989, </year> <pages> pp. 145-157. </pages>
Reference-contexts: The long-lived M renaming problem <ref> [2, 5, 6, 11] </ref> is a generalisation of one-time renaming in which N processes repeatedly acquire and release names from f0; :::; M 1g. It is assumed that at most k processes concurrently request or hold names, and it is required that no two processes hold the same name concurrently. <p> We are therefore motivated to seek renaming protocols whose destination name spaces are as small as possible. Wait-free, long-lived renaming was first solved for shared-memory systems by Burns and Peterson <ref> [6] </ref>. In fact, Burns and Peterson solved a more general problem, which they called `-assignment. An `-assignment protocol not only assigns names to processes, but also forces some processes to wait if too many request names concurrently. <p> Furthermore, the space requirements are (k 5 ) and, in some cases, are exponential in k. In this paper, we present a new read/write algorithm for fast, long-lived (k (k + 1)=2)-renaming and we also observe that this algorithm can be combined with that of Burns and Peterson <ref> [6] </ref> to achieve a fast, read/write solution to long-lived (2k 1)-renaming. Burns and Peterson [6] and Herlihy and Shavit [9] have both shown that long-lived M -renaming cannot be solved in a wait-free manner using atomic reads and writes unless M 2k 1. 1 Thus, our second result is optimal with <p> In this paper, we present a new read/write algorithm for fast, long-lived (k (k + 1)=2)-renaming and we also observe that this algorithm can be combined with that of Burns and Peterson <ref> [6] </ref> to achieve a fast, read/write solution to long-lived (2k 1)-renaming. Burns and Peterson [6] and Herlihy and Shavit [9] have both shown that long-lived M -renaming cannot be solved in a wait-free manner using atomic reads and writes unless M 2k 1. 1 Thus, our second result is optimal with respect to the size of the name space. <p> However, as shown in Table 1, these algorithms rename to substantially larger name spaces than our algorithm does. As discussed earlier, it is desirable to achieve as small a name space as possible.) 1 These results are given in Theorem 3.2 of <ref> [6] </ref> and Corollary 7.9 of [9], respectively. The result of Herlihy and Shavit is stronger because it also applies to one-time renaming, while the result of Burns and Peterson applies only to long-lived renaming. 2 Reference M Time Complexity Space Complexity Fast? Long-Lived? Burns & Peterson [6] 2k 1 fi (N <p> in Theorem 3.2 of <ref> [6] </ref> and Corollary 7.9 of [9], respectively. The result of Herlihy and Shavit is stronger because it also applies to one-time renaming, while the result of Burns and Peterson applies only to long-lived renaming. 2 Reference M Time Complexity Space Complexity Fast? Long-Lived? Burns & Peterson [6] 2k 1 fi (N k 2 ) fi (N 2 ) No Yes Moir & Anderson [11] k (k + 1)=2 fi (k) fi (k 2 ) Yes No Moir & Anderson [11] 2k 1 fi (k 4 ) fi (k 4 ) Yes No Moir & Anderson [11] k <p> With ` = 2k 1, the algorithm of Burns and Peterson can tolerate up to k 1 failures. Also, their algorithm is lockout-free <ref> [6] </ref>. This means that, provided at most k 1 processes are faulty, any process that takes infinitely many steps acquires a name infinitely often.
Reference: [7] <author> K. Chandy and J. Misra, </author> <title> Parallel Program Design: A Foundation, </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: We prove a program correct by proving that its correctness conditions hold in all histories that start from a state that satisfies the initial conditions of the program. Proof Methods: When reasoning about programs, we define safety properties using invariant assertions <ref> [7] </ref>. A state assertion 2 is an invariant iff it holds in each state of every history. To prove that an assertion I is an invariant, we either show that I is implied by previously proved invariants, or prove by induction that I holds in every state of every history.
Reference: [8] <author> C. A. R. Hoare, </author> <title> "An Axiomatic Basis for Computer Programming", </title> <journal> Communications of the ACM 12, </journal> <month> October </month> <year> 1969, </year> <pages> pp. </pages> <month> 576-580,583. </month>
Reference-contexts: Symbols in parentheses have the same binding power. We occasionally use parentheses to override these binding rules. We sometimes use Hoare triples <ref> [8] </ref> to denote the effects of a statement execution.
Reference: [9] <author> M. Herlihy and N. Shavit, </author> <title> "The Topological Structure of Asynchronous Computability", </title> <type> Technical Report CS-96-03, </type> <institution> Brown University, </institution> <year> 1996. </year>
Reference-contexts: Burns and Peterson [6] and Herlihy and Shavit <ref> [9] </ref> have both shown that long-lived M -renaming cannot be solved in a wait-free manner using atomic reads and writes unless M 2k 1. 1 Thus, our second result is optimal with respect to the size of the name space. <p> However, as shown in Table 1, these algorithms rename to substantially larger name spaces than our algorithm does. As discussed earlier, it is desirable to achieve as small a name space as possible.) 1 These results are given in Theorem 3.2 of [6] and Corollary 7.9 of <ref> [9] </ref>, respectively.
Reference: [10] <author> L. Lamport, </author> <title> "A Fast Mutual Exclusion Algorithm", </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 5, No. 1, </volume> <month> February </month> <year> 1987, </year> <pages> pp. 1-11. 16 </pages>
Reference-contexts: The basic structure of this building block is the same as for the non-fast Moir-Anderson algorithm. Pseudocode that illustrates this structure is shown in Figure 2. The building blocks are based on a "resettable" version of Lamport's fast mutual exclusion technique <ref> [10] </ref>. To access a building block, a process p first writes its own identifier into a shared variable X, and then reads a shared variable Y . If Y is "set", then p moves right in the grid. Otherwise, p sets the Y -variable and then checks X.
Reference: [11] <author> M. Moir and J. Anderson, </author> <title> "Wait-Free Algorithms for Fast, Long-Lived Renaming", </title> <booktitle> Science of Computer Programming 25 (1995), </booktitle> <pages> pp. 1-39. </pages> <note> A preliminary version appeared in Proceedings of the 8th International Workshop on Distributed Algorithms, </note> <month> September, </month> <year> 1994, </year> <pages> pp. 141-155. </pages>
Reference-contexts: 1 Introduction In the one-time M renaming problem <ref> [2, 3, 4, 11] </ref>, each of a set of k processes with distinct identifiers ranging over f0; :::; N 1g is required to choose a distinct name ranging over f0; :::; M 1g, where M &lt; N . <p> The long-lived M renaming problem <ref> [2, 5, 6, 11] </ref> is a generalisation of one-time renaming in which N processes repeatedly acquire and release names from f0; :::; M 1g. It is assumed that at most k processes concurrently request or hold names, and it is required that no two processes hold the same name concurrently. <p> Thus, it suffers from the same problem that long-lived renaming is intended to overcome. Recently, Moir and Anderson suggested that a renaming algorithm be called fast if its time complexity is independent of N <ref> [11] </ref>. They presented fast solutions for both one-time and long-lived renaming. <p> These results resolve questions left open by Buhrman et al. and by Moir and Anderson <ref> [5, 11] </ref>. Our new long-lived (k (k +1)=2)-renaming algorithm improves on the space and time complexity of the Buhrman et al. algorithm, and is also significantly simpler, as evidenced by the fact that we present full assertional proofs. <p> Our new long-lived (k (k +1)=2)-renaming algorithm improves on the space and time complexity of the Buhrman et al. algorithm, and is also significantly simpler, as evidenced by the fact that we present full assertional proofs. Our long-lived (k (k + 1)=2)-renaming algorithm is similar to the Moir-Anderson algorithm <ref> [11] </ref> in that it consists of a grid of building blocks. However, we use a novel technique to make each building block fast. <p> is stronger because it also applies to one-time renaming, while the result of Burns and Peterson applies only to long-lived renaming. 2 Reference M Time Complexity Space Complexity Fast? Long-Lived? Burns & Peterson [6] 2k 1 fi (N k 2 ) fi (N 2 ) No Yes Moir & Anderson <ref> [11] </ref> k (k + 1)=2 fi (k) fi (k 2 ) Yes No Moir & Anderson [11] 2k 1 fi (k 4 ) fi (k 4 ) Yes No Moir & Anderson [11] k (k + 1)=2 fi (N k) fi (N k 2 ) No Yes Buhrman et al. [5] <p> applies only to long-lived renaming. 2 Reference M Time Complexity Space Complexity Fast? Long-Lived? Burns & Peterson [6] 2k 1 fi (N k 2 ) fi (N 2 ) No Yes Moir & Anderson <ref> [11] </ref> k (k + 1)=2 fi (k) fi (k 2 ) Yes No Moir & Anderson [11] 2k 1 fi (k 4 ) fi (k 4 ) Yes No Moir & Anderson [11] k (k + 1)=2 fi (N k) fi (N k 2 ) No Yes Buhrman et al. [5] 3 k fi (k) fi (3 k ) Yes Yes Buhrman et al. [5] 72k 2 <p> Peterson [6] 2k 1 fi (N k 2 ) fi (N 2 ) No Yes Moir & Anderson <ref> [11] </ref> k (k + 1)=2 fi (k) fi (k 2 ) Yes No Moir & Anderson [11] 2k 1 fi (k 4 ) fi (k 4 ) Yes No Moir & Anderson [11] k (k + 1)=2 fi (N k) fi (N k 2 ) No Yes Buhrman et al. [5] 3 k fi (k) fi (3 k ) Yes Yes Buhrman et al. [5] 72k 2 fi (k log k) fi (k 4 ) Yes Yes Buhrman et al. [5] k (k <p> We measure the time complexity of our algorithms in terms of the worst-case number of steps taken to acquire and release a name once. 3 The Algorithm We now present our algorithm for fast (k (k + 1)=2)-renaming. Like the Moir-Anderson algorithm <ref> [11] </ref>, this algorithm is based on the upper-left triangle of a "grid" of building blocks; this arrangement is shown in a process p starts at the top-left corner of the grid and accesses the building block there. <p> By the definition of EN , the antecedent implies EN (p; p:i; p:j). Therefore :EN (q; p:i; p:j) holds, which implies that the consequent holds. 2 The following claims are proved in <ref> [11] </ref>. <p> We also show that fast, long-lived (2k 1)-renaming can be implemented with reads and writes. This algorithm is optimal with respect to the size of the name space. This resolves questions left open by Buhrman et al. and by Moir and Anderson <ref> [5, 11] </ref>. While our long-lived (2k 1)-renaming algorithm is technically "fast" it still has quite high time complexity. It would be interesting to see if this can be improved upon by a more direct solution, as combining renaming algorithms tends to result in high time complexity.
Reference: [12] <author> G. Peterson, </author> <type> personal communication, </type> <month> November </month> <year> 1995. </year> <month> 17 </month>
Reference-contexts: Burns and Peterson use k to denote the maximum number of faulty processes, while we use k to denote the maximum number of processes that concurrently request or hold names.) In this case, the worst-case time complexity of acquiring and releasing a name once is fi (N k 2 ) <ref> [12] </ref>. Because processes access our k (k + 1)=2-renaming algorithm before accessing that of Burns and Peterson, the original name space size (i.e., N ) for the algorithm of Burns and Peterson is k (k + 1)=2.
References-found: 12

