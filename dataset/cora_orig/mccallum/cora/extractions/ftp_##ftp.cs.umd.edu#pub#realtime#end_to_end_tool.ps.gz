URL: ftp://ftp.cs.umd.edu/pub/realtime/end_to_end_tool.ps.gz
Refering-URL: http://www.cs.umd.edu/projects/TimeWare/TimeWare-index-no-abs.html
Root-URL: 
Email: frich,dikangg@cs.umd.edu sshong@engr.sgi.com manas@cs.concordia.ca  
Title: End-to-End Design of Real-Time Systems  
Author: Richard Gerber, Dong-in Kang Seongsoo Hong Manas Saksena 
Note: This research is supported in part by ONR grant N00014-94-10228, NSF grant CCR-9209333, and NSF Young Investigator Award CCR-9357850.  
Date: June 15, 1995  
Address: 2011 N. Shoreline Blvd.  College Park, MD 20742 Mountain View, CA 94039 Montreal, Quebec H3G 1M8, Canada  
Affiliation: Dept. of Computer Science Silicon Graphics Inc. Dept. of Computer Science University of Maryland  Concordia University  
Abstract: This chapter presents a comprehensive design methodology for guaranteeing end-to-end requirements of real-time systems. Applications are structured as a set of process components connected by asynchronous channels, in which the endpoints are the system's external inputs and outputs. Timing constraints are then postulated between these inputs and outputs; they express properties such as end-to-end propagation delay, temporal input-sampling correlation, and allowable separation times between updated output values. The automated design method works as follows: First new tasks are created to correlate related inputs, and an optimization algorithm, whose objective is to minimize CPU utilization, transforms the end-to-end requirements into a set of intermediate rate constraints on the tasks. If the algorithm fails, a restructuring tool attempts to eliminate bottlenecks by transforming the application, which is then re-submitted into the assignment algorithm. The final result is a schedulable set of fully periodic tasks, which collaboratively maintain the end-to-end constraints. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, C. Courcoubetis, and D. Dill. </author> <title> Model-checking for real-time systems. </title> <booktitle> In Proc. of IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1990. </year>
Reference: [2] <author> N. Audsley, A. Burns, M. Richardson, and A. Wellings. </author> <title> Hard real-time scheduling: The deadline-monotonic approach. </title> <booktitle> In Proceedings of IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 133-137, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Thus the space of feasible solutions can be simplified, which in turn reduces the constraint-solver's work. Second, priority-based scheduling has recently been shown to support all of the ATG's 8 Application Structure. End-to-end Constraints. Task Libraries. inherent timing requirements: pre-period deadlines <ref> [2] </ref>, precedence constrained sub-tasks [9], and offsets [16]. A good overview to static priority scheduling may be found in [5]. 2.4 Overview of the Solution Our solution is carried out in a four-step process, as shown in Figure 4.
Reference: [3] <author> N. Audsley, A. Burns, M. Richardson, and A. Wellings. </author> <title> Data consistency in hard real-time systems. </title> <type> Technical Report YCS 203 (1993), </type> <institution> Department of Computer Science, University of York, </institution> <address> England, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Related Work. This research was, in large part, inspired by the real-time transaction model proposed by Burns et. al. in <ref> [3] </ref>. While the model was formulated to express database applications, it can easily incorporate variants of our freshness and correlation constraints. In the analogue to freshness, a persistent object has "absolute consistency within t" when it corresponds to real-world samples taken within maximum drift of t.
Reference: [4] <author> G. Berry, S. Moisan, and J. Rigault. ESTEREL: </author> <title> Towards a synchronous and semantically sound high level language for real time applications. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 30-37. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1983. </year>
Reference-contexts: Moreover, we note that our timing constraints define a system driven by time and output requirements. This is in contrast to reactive paradigms such as ESTEREL <ref> [4] </ref>, which are input-driven. Analogous to the "conceptually infinite buffering" assumptions, the rate assignment algorithm assumes that the external inputs are always fresh and available. The derived input-sampling rates then determine the true requirements on input-availability.
Reference: [5] <author> A. Burns. </author> <title> Preemptive priority based scheduling: An appropriate engineering approach. </title> <editor> In S. Son, editor, </editor> <booktitle> Principles of Real-Time Systems. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: The problem of scheduling a set of periodic real-time tasks on a single CPU has been studied for many years. Such a task set can be dispatched by a calendar-based, non-preemptive schedule (e.g., [18, 19, 20]), or by a preemptive, static-priority scheme (e.g., <ref> [5, 13, 15, 17] </ref>). For the most part our results are independent of any particular scheduling strategy, and can be used in concert with either non-preemptive or preemptive dispatching. However, in the sequel we frequently assume an underlying static-priority architecture. This is for two reasons. <p> Second, priority-based scheduling has recently been shown to support all of the ATG's 8 Application Structure. End-to-end Constraints. Task Libraries. inherent timing requirements: pre-period deadlines [2], precedence constrained sub-tasks [9], and offsets [16]. A good overview to static priority scheduling may be found in <ref> [5] </ref>. 2.4 Overview of the Solution Our solution is carried out in a four-step process, as shown in Figure 4. In Step 1, the intermediate constraints C are derived, which postulates the periods, deadlines and offsets as free variables.
Reference: [6] <author> G. Dantzig and B. Eaves. </author> <title> Fourier-Motzkin Elimination and its Dual. </title> <journal> Journal of Combinatorial Theory (A), </journal> <volume> 14 </volume> <pages> 288-297, </pages> <year> 1973. </year>
Reference-contexts: Hence, a new instantiation for the periods must be obtained a process that continues until either a solution is found, or all possible values for the T i 's are exhausted. 4.1 Elimination of Offset and Deadline Variables We use an extension of Fourier variable elimination <ref> [6] </ref> to simplify our system of constraints.
Reference: [7] <author> R. Gerber and S. Hong. </author> <title> Semantics-based compiler transformations for enhanced schedulabil-ity. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 232-242. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1993. </year>
Reference-contexts: Also, we can harness finer-grained compiler transformations such as program slicing to help transform tasks into read-compute-write-compute phases, which will even further enhance schedulability. We have used this approach in a real-time compiler tool <ref> [7] </ref>, and there is reason to believe that its use would be even more effective here. We are also streamlining our search algorithm, by incorporating scheduling-specific decisions into the constraint solver. We believe that when used properly, such policy-specific strategies will help significantly in pruning the search space.
Reference: [8] <author> R. Gerber, S. Hong, and M. Saksena. </author> <title> Guaranteeing end-to-end timing constraints by calibrating intermediate processes. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 192-203. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1994. </year> <note> Also to appear in IEEE Transactions on Software Engineering. </note>
Reference-contexts: Fortunately, harmonicity requirements play a significant roll to reduce the search effort, since we need to look at only those period values that are integral multiples of certain base periods. In <ref> [8] </ref> we presented a graph-theoretic algorithm which is capable of finding a feasible solution relying on backward and forward traversal of a task graph. Here we sketch the idea behind the algorithm; interested readers should consult [8] for the technical details. <p> In <ref> [8] </ref> we presented a graph-theoretic algorithm which is capable of finding a feasible solution relying on backward and forward traversal of a task graph. Here we sketch the idea behind the algorithm; interested readers should consult [8] for the technical details. To sum up, the algorithm has the following properties. (1) Period assignment is done in topological order.
Reference: [9] <author> M. Harbour, M. Klein, and J. Lehoczky. </author> <title> Fixed Priority Scheduling of Periodic Tasks with Varying Execution Priority. </title> <booktitle> In Proceedings, IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 116-128, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Thus the space of feasible solutions can be simplified, which in turn reduces the constraint-solver's work. Second, priority-based scheduling has recently been shown to support all of the ATG's 8 Application Structure. End-to-end Constraints. Task Libraries. inherent timing requirements: pre-period deadlines [2], precedence constrained sub-tasks <ref> [9] </ref>, and offsets [16]. A good overview to static priority scheduling may be found in [5]. 2.4 Overview of the Solution Our solution is carried out in a four-step process, as shown in Figure 4.
Reference: [10] <author> F. Jahanian and A. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(9) </volume> <pages> 890-904, </pages> <month> September </month> <year> 1986. </year> <month> 29 </month>
Reference-contexts: Schedulability: There is a scheduling algorithm which can efficiently maintain the intermediate constraints C, and preserve feasibility. 7 In the problem we address, the three issues cannot be decoupled. Correctness, for example, is often treated as verification problem using a logic such as RTL <ref> [10] </ref>. Certainly, given the ATG we could formulate E in RTL and query whether the constraint set is satisfiable. However, a "yes" answer would give us little insight into finding a good choice for C which must, after all, be simple enough to schedule.
Reference: [11] <author> K. Jeffay. </author> <title> The real-time producer/consumer paradigm: A paradigm for the construction of efficient, predictable real-time systems. </title> <booktitle> In ACM/SIGAPP Symposium on Applied Computing, </booktitle> <pages> pages 796-804. </pages> <publisher> ACM Press, </publisher> <month> February </month> <year> 1983. </year>
Reference-contexts: We also present a period assignment problem which is optimal though quite expensive in the worst case. This work was also influenced by Jeffay's "real-time producer/consumer model" <ref> [11] </ref>, which possesses a task-graph structure similar to ours.
Reference: [12] <author> M. Klein, J. Lehoczky, and R. Rajkumar. </author> <title> Rate-monotonic analysis for real-time industrial computing. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 24-33, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Klein et. al. surveys the current engineering practice used in developing industrial real-time systems <ref> [12] </ref>. As is stressed, the intermediate constraints should be primarily a function of the end-to-end constraints, but should, if possible, take into account sound real-time scheduling techniques. At this point, however, the "state-of-the-art" is the practice of trial and error, as guided by engineering experience.
Reference: [13] <author> C. Liu and J. Layland. </author> <title> Scheduling algorithm for multiprogramming in a hard real-time environment. </title> <journal> Journal of the ACM, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: The problem of scheduling a set of periodic real-time tasks on a single CPU has been studied for many years. Such a task set can be dispatched by a calendar-based, non-preemptive schedule (e.g., [18, 19, 20]), or by a preemptive, static-priority scheme (e.g., <ref> [5, 13, 15, 17] </ref>). For the most part our results are independent of any particular scheduling strategy, and can be used in concert with either non-preemptive or preemptive dispatching. However, in the sequel we frequently assume an underlying static-priority architecture. This is for two reasons.
Reference: [14] <author> J. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison Wesley, </publisher> <year> 1994. </year>
Reference: [15] <author> L. Sha, R. Rajkumar, and J. Lehoczky. </author> <title> Priority inheritance protocols: An approach to real-time synchronization. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 39 </volume> <pages> 1175-1185, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The problem of scheduling a set of periodic real-time tasks on a single CPU has been studied for many years. Such a task set can be dispatched by a calendar-based, non-preemptive schedule (e.g., [18, 19, 20]), or by a preemptive, static-priority scheme (e.g., <ref> [5, 13, 15, 17] </ref>). For the most part our results are independent of any particular scheduling strategy, and can be used in concert with either non-preemptive or preemptive dispatching. However, in the sequel we frequently assume an underlying static-priority architecture. This is for two reasons.
Reference: [16] <author> K. Tindell. </author> <title> Using offset information to analyse static priority pre-emptively scheduled task sets. </title> <type> Technical Report YCS 182 (1992), </type> <institution> Department of Computer Science, University of York, </institution> <address> England, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Thus the space of feasible solutions can be simplified, which in turn reduces the constraint-solver's work. Second, priority-based scheduling has recently been shown to support all of the ATG's 8 Application Structure. End-to-end Constraints. Task Libraries. inherent timing requirements: pre-period deadlines [2], precedence constrained sub-tasks [9], and offsets <ref> [16] </ref>. A good overview to static priority scheduling may be found in [5]. 2.4 Overview of the Solution Our solution is carried out in a four-step process, as shown in Figure 4.
Reference: [17] <author> K. Tindell, A. Burns, and A. Wellings. </author> <title> An extendible approach for analysing fixed priority hard real-time tasks. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 6(2) </volume> <pages> 133-152, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: The problem of scheduling a set of periodic real-time tasks on a single CPU has been studied for many years. Such a task set can be dispatched by a calendar-based, non-preemptive schedule (e.g., [18, 19, 20]), or by a preemptive, static-priority scheme (e.g., <ref> [5, 13, 15, 17] </ref>). For the most part our results are independent of any particular scheduling strategy, and can be used in concert with either non-preemptive or preemptive dispatching. However, in the sequel we frequently assume an underlying static-priority architecture. This is for two reasons.
Reference: [18] <author> J. Xu and D. Parnas. </author> <title> Scheduling processes with release times, deadlines, precedence and exclusion relations. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 360-369, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: The problem of scheduling a set of periodic real-time tasks on a single CPU has been studied for many years. Such a task set can be dispatched by a calendar-based, non-preemptive schedule (e.g., <ref> [18, 19, 20] </ref>), or by a preemptive, static-priority scheme (e.g., [5, 13, 15, 17]). For the most part our results are independent of any particular scheduling strategy, and can be used in concert with either non-preemptive or preemptive dispatching. However, in the sequel we frequently assume an underlying static-priority architecture.
Reference: [19] <author> X. Yuan, M. Saksena, and A. Agrawala. </author> <title> A Decomposition Approach to Real-Time Scheduling. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 6(1), </volume> <year> 1994. </year>
Reference-contexts: The problem of scheduling a set of periodic real-time tasks on a single CPU has been studied for many years. Such a task set can be dispatched by a calendar-based, non-preemptive schedule (e.g., <ref> [18, 19, 20] </ref>), or by a preemptive, static-priority scheme (e.g., [5, 13, 15, 17]). For the most part our results are independent of any particular scheduling strategy, and can be used in concert with either non-preemptive or preemptive dispatching. However, in the sequel we frequently assume an underlying static-priority architecture.
Reference: [20] <author> W. Zhao, K. Ramamritham, and J. Stankovic. </author> <title> Scheduling Tasks with Resource requirements in a Hard Real-Time System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(5):564-577, </volume> <month> May </month> <year> 1987. </year> <month> 30 </month>
Reference-contexts: The problem of scheduling a set of periodic real-time tasks on a single CPU has been studied for many years. Such a task set can be dispatched by a calendar-based, non-preemptive schedule (e.g., <ref> [18, 19, 20] </ref>), or by a preemptive, static-priority scheme (e.g., [5, 13, 15, 17]). For the most part our results are independent of any particular scheduling strategy, and can be used in concert with either non-preemptive or preemptive dispatching. However, in the sequel we frequently assume an underlying static-priority architecture.
References-found: 20

