URL: http://www.cs.umr.edu/techreports/96-06.ps
Refering-URL: http://www.cs.umr.edu/techreports/
Root-URL: 
Title: Efficient String Matching Algorithms on Reconfigurable Mesh Architectures  
Author: H. C. Lee and F. Ercal 
Keyword: string matching, approximate string matching, reconfigurable mesh architecture, parallel algorithms  
Address: Rolla, MO 65401  
Affiliation: Department of Computer Science University of Missouri-Rolla  
Abstract: String matching problem received much attention over the years due to its importance in various applications such as text/file comparison, DNA sequencing, search engines, and spelling correction. Especially with the introduction of search engines dealing with tremendous amount of textual information presented on the world wide web and the research on DNA sequencing, this problem deserves special attention and any algorithmic or hardware improvements to speed up the process will benefit these important applications. In this paper, we present three algorithms for string matching on reconfigurable mesh architectures. Given a text T of length n and a pattern P of length m, the first algorithm finds the exact matching between T and P in O(1) time on a 2-dimensional RMESH of size (nm+1)fim. The second algorithm finds the approximate matching between T and P in O(k) time on a 2D RMESH, where k is the maximum edit distance between T and P. The third algorithm allows only the replacement operation in the calculation of the edit distance and finds an approximate matching between T and P in constant-time on a 3D RMESH. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. E. Knuth, J. H. J. Morris, and V. R. Pratt, </author> <title> "Fast pattern matching in strings," </title> <journal> SIAM Journal on Computing, </journal> <volume> vol. 6(2), </volume> <pages> pp. 323-350, </pages> <month> June </month> <year> 1977. </year>
Reference-contexts: 1 Introduction The exact string matching is the problem of detecting the occurrence of a particular substring P, called a pattern, in another string T, called the text. It most commonly arises in text processing and pattern recognition. The well-known Knuth-Morris-Pratt algorithm <ref> [1] </ref> has a time complexity of O (n + m). Boyer and Moore [2] developed an algorithm that exhibits better performance in practice when the pattern length is relatively long [3].
Reference: [2] <author> R. S. Boyer and J. S. Moore, </author> <title> "A fast string searching algorithm," </title> <journal> Communications of the ACM, </journal> <volume> vol. </volume> <month> 20(10), </month> <pages> pp. 762-772, </pages> <month> October </month> <year> 1977. </year>
Reference-contexts: It most commonly arises in text processing and pattern recognition. The well-known Knuth-Morris-Pratt algorithm [1] has a time complexity of O (n + m). Boyer and Moore <ref> [2] </ref> developed an algorithm that exhibits better performance in practice when the pattern length is relatively long [3]. The k-differences approximate string matching problem is to find the occurrences of substrings on a text string T whose edit distance from a pattern string P is less than k.
Reference: [3] <author> S. Baase, </author> <title> Computer Algorithms; Introduction to Design and Analysis. </title> <publisher> Addison-Wesley, </publisher> <editor> 2nd ed., </editor> <year> 1988. </year>
Reference-contexts: It most commonly arises in text processing and pattern recognition. The well-known Knuth-Morris-Pratt algorithm [1] has a time complexity of O (n + m). Boyer and Moore [2] developed an algorithm that exhibits better performance in practice when the pattern length is relatively long <ref> [3] </ref>. The k-differences approximate string matching problem is to find the occurrences of substrings on a text string T whose edit distance from a pattern string P is less than k.
Reference: [4] <author> S. B. Needleman and C. D. Wunsch, </author> <title> "A general method applicable to the search for similarities in the amino acid sequences of two proteins," </title> <journal> Journal of Mol. Bio., </journal> <volume> vol. 48, </volume> <pages> pp. 444-453, </pages> <year> 1970. </year>
Reference-contexts: A dynamic programming algorithm for computing the edit distance between two strings was first developed by Needleman and Wunsch <ref> [4] </ref> and variations were then independently developed by many researchers. Sankoff and Kruskal's book [5] provides references to related work and describes the variations of the dynamic programming algorithms.
Reference: [5] <author> D. Sankoff and J. B. K. (Eds.), </author> <title> Time Warp, String Edits, and Macro molecules: The Theory and Practice of Sequence Comparison. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: A dynamic programming algorithm for computing the edit distance between two strings was first developed by Needleman and Wunsch [4] and variations were then independently developed by many researchers. Sankoff and Kruskal's book <ref> [5] </ref> provides references to related work and describes the variations of the dynamic programming algorithms. The sequential dynamic programming algorithm requires time and space complexity of O (mn) where m is the length of the pattern and n is the length of the text.
Reference: [6] <author> E. Ukkonen, </author> <title> "On approximate string matching," </title> <booktitle> in Proceedings Int. Conf. Found. Com-put. Theory, Lecture Notes in Computer Science, </booktitle> <volume> vol. 158, </volume> <pages> pp. 487-495, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin/New York, </address> <year> 1983. </year>
Reference-contexts: The sequential dynamic programming algorithm requires time and space complexity of O (mn) where m is the length of the pattern and n is the length of the text. A sequential algorithm of complexity O (nk) that derived from Ukkonen's work <ref> [6] </ref> was developed by Landau and Vishkin [7]. They also designed an O (log (m)+k) parallel algorithm using n processors. However, Galil and Park [8] pointed out that their algorithm uses suffix trees which required O (log n) time for construction on n processors [9]. <p> To achieve speedup without first constructing the suffix trees, Jiang and Wright [10] designed an O (k) parallel algorithm using the priority CRCW-PRAM parallel model. Their algorithm was based on a variation of Ukkonen's algorithm <ref> [6, 7] </ref>. In this paper, we first describe the reconfigurable mesh architecture (RMESH) model used for solving various string matching problems (Section 1.1). Then, section 2.1 presents an O (1) time algorithm for exact string matching between a text T and a pattern P using a 2-dimensional RMESH architecture. <p> The algorithm to find the approximate matching between strings T and P is presented in Section 2.2. This algorithm is an efficient adaptation of Ukkonen's algorithm <ref> [6] </ref> to reconfigurable mesh architectures and it has a time complexity of O (k) on a 2-D RMESH, where k is the maximum edit distance between T and P. <p> The advantage of this algorithm is that it is suitable for parallel implementation. It is originally due to Ukkonen <ref> [6] </ref>. Based on the same algorithm, Landau and Vishkin [7] presented an O ((logm) + k) time algorithm on the CRCW-PRAM model and Jiang and Wright [10] developed several algorithms to solve the approximate string matching problem in O (k) time on CRCW-PRAM model.
Reference: [7] <author> G. M. Landau and U. Vishkin, </author> <title> "Fast parallel and serial approximate string matching," </title> <journal> Journal of Algorithms, </journal> <volume> vol. 10, </volume> <pages> pp. 157-169, </pages> <year> 1989. </year>
Reference-contexts: The sequential dynamic programming algorithm requires time and space complexity of O (mn) where m is the length of the pattern and n is the length of the text. A sequential algorithm of complexity O (nk) that derived from Ukkonen's work [6] was developed by Landau and Vishkin <ref> [7] </ref>. They also designed an O (log (m)+k) parallel algorithm using n processors. However, Galil and Park [8] pointed out that their algorithm uses suffix trees which required O (log n) time for construction on n processors [9]. <p> To achieve speedup without first constructing the suffix trees, Jiang and Wright [10] designed an O (k) parallel algorithm using the priority CRCW-PRAM parallel model. Their algorithm was based on a variation of Ukkonen's algorithm <ref> [6, 7] </ref>. In this paper, we first describe the reconfigurable mesh architecture (RMESH) model used for solving various string matching problems (Section 1.1). Then, section 2.1 presents an O (1) time algorithm for exact string matching between a text T and a pattern P using a 2-dimensional RMESH architecture. <p> The advantage of this algorithm is that it is suitable for parallel implementation. It is originally due to Ukkonen [6]. Based on the same algorithm, Landau and Vishkin <ref> [7] </ref> presented an O ((logm) + k) time algorithm on the CRCW-PRAM model and Jiang and Wright [10] developed several algorithms to solve the approximate string matching problem in O (k) time on CRCW-PRAM model. Code for this algorithm is given below.
Reference: [8] <author> Z. Galil and K. Park, </author> <title> "An improved algorithm for approximate string matching," </title> <journal> SIAM J. Comput., </journal> <volume> vol. 19(6), </volume> <pages> pp. 989-999, </pages> <year> 1990. </year>
Reference-contexts: A sequential algorithm of complexity O (nk) that derived from Ukkonen's work [6] was developed by Landau and Vishkin [7]. They also designed an O (log (m)+k) parallel algorithm using n processors. However, Galil and Park <ref> [8] </ref> pointed out that their algorithm uses suffix trees which required O (log n) time for construction on n processors [9]. To achieve speedup without first constructing the suffix trees, Jiang and Wright [10] designed an O (k) parallel algorithm using the priority CRCW-PRAM parallel model.
Reference: [9] <author> A. Apostolico, C. Iliopoulos, G. M. Landau, B. Schieber, and U. Vishkin, </author> <title> "Parallel construction of a suffix tree with applications," </title> <journal> Algorithmica, </journal> <volume> vol. 3, </volume> <pages> pp. 347-365, </pages> <year> 1988. </year>
Reference-contexts: They also designed an O (log (m)+k) parallel algorithm using n processors. However, Galil and Park [8] pointed out that their algorithm uses suffix trees which required O (log n) time for construction on n processors <ref> [9] </ref>. To achieve speedup without first constructing the suffix trees, Jiang and Wright [10] designed an O (k) parallel algorithm using the priority CRCW-PRAM parallel model. Their algorithm was based on a variation of Ukkonen's algorithm [6, 7].
Reference: [10] <author> Y. Jiang and A. H. Wright, </author> <title> "O(k) parallel algorithms for approximate string matching," </title> <booktitle> Neural, Parallel and Scientific Computations, </booktitle> <volume> vol. 1, </volume> <pages> pp. 443-452, </pages> <year> 1993. </year>
Reference-contexts: They also designed an O (log (m)+k) parallel algorithm using n processors. However, Galil and Park [8] pointed out that their algorithm uses suffix trees which required O (log n) time for construction on n processors [9]. To achieve speedup without first constructing the suffix trees, Jiang and Wright <ref> [10] </ref> designed an O (k) parallel algorithm using the priority CRCW-PRAM parallel model. Their algorithm was based on a variation of Ukkonen's algorithm [6, 7]. In this paper, we first describe the reconfigurable mesh architecture (RMESH) model used for solving various string matching problems (Section 1.1). <p> The advantage of this algorithm is that it is suitable for parallel implementation. It is originally due to Ukkonen [6]. Based on the same algorithm, Landau and Vishkin [7] presented an O ((logm) + k) time algorithm on the CRCW-PRAM model and Jiang and Wright <ref> [10] </ref> developed several algorithms to solve the approximate string matching problem in O (k) time on CRCW-PRAM model. Code for this algorithm is given below.
Reference: [11] <author> F. Ercal and H. C. Lee, </author> <title> "Constant-time reconfigurable mesh algorithms for maze routing," </title> <type> Technical Report CSC 96-05, </type> <note> University of Missouri-Rolla (also submitted to JPDC), </note> <year> 1996. </year>
Reference-contexts: This algorithm runs in O (1) time on a 3-dimensional RMESH architecture. 1.1 RMESH Model There are various but similar reconfigurable mesh (RMESH) architectures proposed in the literature. First two algorithms proposed in this paper use a 2D RMESH model <ref> [11] </ref> while the third algorithm requires a 3D RMESH. Some important features of this model are as follows: 1. A 3D RMESH is an NfiNfiN array of PEs connected in a standard mesh topology. <p> This algorithm runs in O (1) time on a 3-D RMESH. As a final note, we state that the RMESH model described in section 1.1 is directional <ref> [11] </ref> and provides more power than needed. A simpler model would be sufficient to run the proposed algorithms without increasing the reported time complexities. 11
Reference: [12] <author> H. Park, H. J. Kim, and V. K. Prasanna, </author> <title> "An o(1) time optimal algorithm for multiplying matrices on reconfigurable mesh," </title> <journal> Information Processing Letters, </journal> <volume> vol. 47, </volume> <pages> pp. 109-113, </pages> <year> 1993. </year>
Reference-contexts: initially, all input/output ports are disabled *g * Steps 1-3: Steps 1-3 of Algorithm 2.1 (Exact String Matching Algorithm) * Step 4: Each P i;j executes: if p j = t i+j then c=0 else c=1 * Step 5:[Count the number of 1's on each row] It is proved in <ref> [12] </ref> that, counting the number of 1's in a 0/1 sequence of length m can be performed in O (1) time on m fi log 2 m reconfigurable mesh (Lemma 2). <p> Otherwise, report that the search is not successful. Steps 1-3 are same as those in Algorithm 2.1 and can be executed in O (1) time. Since the counting operation in Step 5 and the minimum operation in Step 6 can both be performed in O (1) time <ref> [12, 13] </ref>, the overall time complexity of this algorithm is O (1).
Reference: [13] <author> R. Miller, V. K. Prasanna-Kumar, D. I. Reisis, and Q. F. Stout, </author> <title> "Parallel computations on reconfigurable meshes," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 42(6), </volume> <pages> pp. 678-692, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Call this number mc and store it along with the processor id in P E 0;0 . A minimum-finding-algorithm with O (1) complexity can be used for this purpose (e.g. the algorithm in section III of <ref> [13] </ref>). * Step 7: If the minimum count, mc k, then P E 0;0 reports success: "there is a match between P and T with at most k mismatches". Otherwise, report that the search is not successful. <p> Otherwise, report that the search is not successful. Steps 1-3 are same as those in Algorithm 2.1 and can be executed in O (1) time. Since the counting operation in Step 5 and the minimum operation in Step 6 can both be performed in O (1) time <ref> [12, 13] </ref>, the overall time complexity of this algorithm is O (1).
Reference: [14] <author> M. Nigam and S. Sahni, </author> <title> "Sorting n numbers on n fi n reconfigurable meshes with buses," </title> <type> in Technical Report 92-5, </type> <institution> University of Florida, </institution> <year> 1992. </year>
Reference-contexts: There are a number of papers which present algorithms to sort N numbers in O (1) time using an N 2 RMESH <ref> [14, 15, 16] </ref>. 10 3 Conclusions In recent years, the researchers have shown interest in designing efficient algorithms for RMESH architectures because they offer the needed efficiency and flexibility in interprocessor communications by allowing the network topology to change dynamically as required by the algorithm.
Reference: [15] <author> J. W. Jang and V. K. Prasanna, </author> <title> "An optimal sorting algorithm on reconfigurable mesh," </title> <booktitle> in Proceedings. Sixth International Parallel Processing Symposium, </booktitle> <pages> pp. 130-7, </pages> <year> 1992. </year>
Reference-contexts: There are a number of papers which present algorithms to sort N numbers in O (1) time using an N 2 RMESH <ref> [14, 15, 16] </ref>. 10 3 Conclusions In recent years, the researchers have shown interest in designing efficient algorithms for RMESH architectures because they offer the needed efficiency and flexibility in interprocessor communications by allowing the network topology to change dynamically as required by the algorithm.
Reference: [16] <author> S. Olariu, J. L. Schwing, and J. Zhang, </author> <title> "Integer sorting in o(1) time on an n fi n reconfigurable mesh," </title> <booktitle> in Eleventh Annual International Phoenix Conference on Computers and Communications, </booktitle> <pages> pp. 480-4, </pages> <year> 1992. </year> <month> 12 </month>
Reference-contexts: There are a number of papers which present algorithms to sort N numbers in O (1) time using an N 2 RMESH <ref> [14, 15, 16] </ref>. 10 3 Conclusions In recent years, the researchers have shown interest in designing efficient algorithms for RMESH architectures because they offer the needed efficiency and flexibility in interprocessor communications by allowing the network topology to change dynamically as required by the algorithm.
References-found: 16

