URL: http://www.daimi.aau.dk/~mis/pascal.ps
Refering-URL: http://www.daimi.aau.dk/~mis/papers.html
Root-URL: http://www.daimi.aau.dk
Email: fhougaard,mis,hosaskg@daimi.aau.dk  
Title: Type Inference of Turbo Pascal  
Author: Ole I. Hougaard, Michael I. Schwartzbach, Hosein Askari 
Keyword: imperative languages, type inference.  
Address: 8000 Aarhus C, Denmark  
Affiliation: Computer Science Department Aarhus University  
Note: BRICS  
Abstract: Type inference is generally thought of as being an exclusive property of the functional programming paradigm. We argue that such a feature may be of significant benefit for also standard imperative languages. We present a working tool (available by WWW) providing these benefits for a full version of Turbo Pas-cal. It has the form of a preprocessor that analyzes programs in which the type annotations are only partial or even absent. The resulting program has full type annotations, will be accepted by the standard Turbo Pascal compiler, and has polymorphic use of procedures resolved by means of code expansion. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-520, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: An enumeration type can now be treated as any other type. One of the acclaimed features of ML and other functional languages is that of polymorphism <ref> [1] </ref>. In a language with polymorphic procedures and functions, you can use the same function or procedure on arguments of different types. An often used example of this is the polymorphic length function. The polymorphic length function has type ff list ! Integer.
Reference: [2] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programming. </title> <booktitle> In 9th ACM conf. on Principels Of Programming Languages, </booktitle> <year> 1982. </year>
Reference-contexts: This technique was used by Mil-ner for type inference of ML in [5]. The above technique allowed type variables to stand for any type. By using type variables in this manner we can represent the set of all possible types for a parse tree node (see <ref> [2] </ref>). Thus the success of this approach relies on said representation and the fact that we could compute the representation of the solutions to the constraint o 1 = o 2 ! ff.
Reference: [3] <author> C.A.R. Hoare. </author> <title> Recursive data structures. </title> <journal> International Journal of Computer and Information Sciences, </journal> <volume> 4:2:105-132, </volume> <year> 1975. </year>
Reference-contexts: However, some of the attractive features of e.g. ML are not necessarily exclusive properties of the functional programming paradigm. For example, heap-allocated recursive data types could equally well be incorporated into a Pascal-like language <ref> [3] </ref>. In this paper we focus on another often cited advantage of modern functional languages, viz. automatic type inference, and we argue that such a feature may be of significant methodological benefit for also traditional imperative languages. We present an algorithm that allows type inference of general Pascal programs.
Reference: [4] <author> Harry G. Mairson. </author> <title> Decidability of ML typing is complete for deterministic exponential time. </title> <booktitle> In Seventeenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 382-401. </pages> <publisher> ACM Press, </publisher> <month> Jan-uary </month> <year> 1990. </year>
Reference-contexts: In ML there are similar problems with types of exponential size <ref> [4] </ref>. In both cases it can be argued that the examples are highly artificial and that we will not encounter this behavior in practice. A fully implemented prototype of the Turbo Pascal tool can be found at http://www.daimi.aau.dk/~hougaard/itp.
Reference: [5] <author> Robin Milner. </author> <title> A theory of type polymor-phism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17:348 - 375, </volume> <year> 1978. </year>
Reference-contexts: solver that is necessary for a Pascal type system; and we describe a 2 concrete tool that has been built as a prepro-cessor for a version of Turbo Pascal. 2 Techniques for Type Inference Type inference algorithms have been suggested for a number of different type systems and programming languages <ref> [5, 9, 6, 7, 8] </ref>. Although these algorithms are very different and highly specialized, they all fall into one of these two categories: They either use direct inference of types from the types of subex-pressions, or they use constraint-based techniques. <p> Unification finds a most general instantiation of type variables, so that the two types become equal. The type of (e 1 e 2 ) is simply the instantiation that the unification algorithm finds for ff. This technique was used by Mil-ner for type inference of ML in <ref> [5] </ref>. The above technique allowed type variables to stand for any type. By using type variables in this manner we can represent the set of all possible types for a parse tree node (see [2]).
Reference: [6] <author> Jens Palsberg. </author> <title> Efficient inference of object types. </title> <booktitle> In 9th Logic in Computer Science, </booktitle> <pages> pages 186-195. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> July </month> <year> 1994. </year>
Reference-contexts: solver that is necessary for a Pascal type system; and we describe a 2 concrete tool that has been built as a prepro-cessor for a version of Turbo Pascal. 2 Techniques for Type Inference Type inference algorithms have been suggested for a number of different type systems and programming languages <ref> [5, 9, 6, 7, 8] </ref>. Although these algorithms are very different and highly specialized, they all fall into one of these two categories: They either use direct inference of types from the types of subex-pressions, or they use constraint-based techniques.
Reference: [7] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In 6th Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 146-161. </pages> <booktitle> ACM SIGPLAN, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: solver that is necessary for a Pascal type system; and we describe a 2 concrete tool that has been built as a prepro-cessor for a version of Turbo Pascal. 2 Techniques for Type Inference Type inference algorithms have been suggested for a number of different type systems and programming languages <ref> [5, 9, 6, 7, 8] </ref>. Although these algorithms are very different and highly specialized, they all fall into one of these two categories: They either use direct inference of types from the types of subex-pressions, or they use constraint-based techniques.
Reference: [8] <author> Michael I. Schwartzbach. </author> <title> Type inference with inequalities. </title> <booktitle> In Proceedings of TAPSOFT'91. </booktitle> <publisher> LNCS 493, Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: solver that is necessary for a Pascal type system; and we describe a 2 concrete tool that has been built as a prepro-cessor for a version of Turbo Pascal. 2 Techniques for Type Inference Type inference algorithms have been suggested for a number of different type systems and programming languages <ref> [5, 9, 6, 7, 8] </ref>. Although these algorithms are very different and highly specialized, they all fall into one of these two categories: They either use direct inference of types from the types of subex-pressions, or they use constraint-based techniques.
Reference: [9] <author> M. Wand. </author> <title> A simple algorithm and proof for type inference. </title> <journal> Fundamentae Infor-maticae, </journal> <volume> X:115 - 122, </volume> <year> 1987. </year> <month> 14 </month>
Reference-contexts: solver that is necessary for a Pascal type system; and we describe a 2 concrete tool that has been built as a prepro-cessor for a version of Turbo Pascal. 2 Techniques for Type Inference Type inference algorithms have been suggested for a number of different type systems and programming languages <ref> [5, 9, 6, 7, 8] </ref>. Although these algorithms are very different and highly specialized, they all fall into one of these two categories: They either use direct inference of types from the types of subex-pressions, or they use constraint-based techniques. <p> Now we have reduced the problem of type inference to that of finding a solution to a set of constraints. In the case of ML we can again solve the constraints by a single application of the unification algorithm. Wand <ref> [9] </ref> has used this technique for type inference of the simply typed -calculus (ML without polymorphic let). In Pascal we use this constraint technique.
References-found: 9

