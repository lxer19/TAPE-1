URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3870/3870.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: fbultan,rich,pughg@cs.umd.edu  
Author: Bultan, Richard Gerber and William Pugh 
Address: College Park, MD 20742, USA  
Affiliation: Department of Computer Science University of Maryland,  
Note: Tevfik  
Abstract: Model Checking Concurrent Systems with Unbounded Integer Variables: Symbolic Representations, Approximations and Experimental Results fly Abstract Model checking is a powerful technique for analyzing large, finite-state systems. In an infinite-state system, however, many basic properties are undecidable. In this paper, we present a new symbolic model checker which conservatively evaluates safety and liveness properties on infinite-state programs. We use Presburger formulas to symbolically encode a program's transition system, as well as its model-checking computations. All fixpoint calculations are executed symbolically, and their convergence is guaranteed by using approximation techniques. We demonstrate the promise of this technology on some well-known infinite-state concurrency problems.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, C. Courcoubetis, N. Halbwachs, T. A. Henzinger, P. H. Ho, X. Nicollin, A. Olivero, J. Sifakis, S. Yovine. </author> <title> The algorithmic analysis of hybrid systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 138(1) </volume> <pages> 3-34, </pages> <year> 1995. </year>
Reference-contexts: Our approximation techniques are based on approximating the fixpoint computations instead of approximating the program as a whole using abstractions. It is possible to use both of these techniques together. Finally, our encoding of program states is similar to that used by Alur et al. in verifying hybrid systems <ref> [1, 2] </ref>. A hybrid system is a discrete control automaton, which interacts with continuously changing, external parameters.
Reference: [2] <author> R. Alur, T. A. Henzinger, and P. Ho. </author> <title> Automatic symbolic verification of embedded systems. </title> <journal> IEEE Transactions on Software Engineering 22(3), </journal> <month> March </month> <year> 1996. </year>
Reference-contexts: Our approximation techniques are based on approximating the fixpoint computations instead of approximating the program as a whole using abstractions. It is possible to use both of these techniques together. Finally, our encoding of program states is similar to that used by Alur et al. in verifying hybrid systems <ref> [1, 2] </ref>. A hybrid system is a discrete control automaton, which interacts with continuously changing, external parameters.
Reference: [3] <author> G. R. Andrews. </author> <title> Concurrent Programming, </title> <booktitle> Principles and Practice. 1991, </booktitle> <publisher> The Ben jamin/Cummings Publishing Company. </publisher>
Reference-contexts: In this paper we demonstrate our model checker's effectiveness on some classical infinite-state programs taken from the concurrency literature <ref> [3, 30] </ref>. While relatively small, they possess some interesting subtleties, especially in the tricky way their infinite-state variables influence control flow. A summary of our approach is shown in Figure 1, and it depicts how we structure the three main phases: translation, partitioning and analysis. <p> 2 = T 2 ^ b 0 = 0 8 Example Concurrent Programs In this section we will present several example concurrent programs and discuss how we analyzed them using our symbolic model checker. 8.1 Bakery Algorithm Consider the concurrent program shown in Figure 11, which implements the bakery algorithm <ref> [3] </ref> to achieve mutual exclusion between two processes. Here the control points for each process are denoted T; W; C, which stand for thinking, waiting or in critical section, respectively. <p> The inner (83) and outer (93) fixpoint computations converged in 9 and 1 iterations, respectively (with a total computation time of 7.64 seconds). 8.2 Ticket Algorithm In Figure 12, we present the ticket algorithm <ref> [3] </ref>. In particular, note its similarity to the bakery algorithm. The difference is that the value of the next available ticket is stored in the global variable t, while another global variable s holds the highest ticket value served thus far.
Reference: [4] <author> A. Arnold. </author> <title> Finite Transition Systems: Semantics of Communicating Systems. </title> <address> New Jersey, 1994, </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: Table 1: Semantics of our temporal logic. transition relation X to be total. Rather, the semantics is defined using maximal paths <ref> [4] </ref> (as opposed to infinite paths). A maximal path is one which is either infinite, or ends with a state that has no successors.
Reference: [5] <author> R. E. Bryant. </author> <title> Symbolic Boolean manipulation with ordered binary-decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Several reasons for this success are: (1) the development of powerful techniques such as model-checking (e.g., [6, 8]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., <ref> [5, 6, 25] </ref>); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., [7, 10, 18]).
Reference: [6] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. H. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proc. of the 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year> <month> 34 </month>
Reference-contexts: 1 Introduction In recent years, there has been a surge of progress in the area of automated analysis for finite state systems. Several reasons for this success are: (1) the development of powerful techniques such as model-checking (e.g., <ref> [6, 8] </ref>), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [5, 6, 25]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., [7, <p> Several reasons for this success are: (1) the development of powerful techniques such as model-checking (e.g., [6, 8]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., <ref> [5, 6, 25] </ref>); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., [7, 10, 18]). <p> In any computer system variables are eventually mapped to finite representations. Thus, it might be argued that integer variables can be given a finite range, and programs can then be analyzed as finite-state machines for example, using BDD's <ref> [6, 25] </ref>. For several reasons, however, this may not always be the best way to proceed. First, mapping integer variables and operations to their binary implementations may lead to highly inefficient static analysis.
Reference: [7] <author> T. Bultan, J. Fischer, and R. Gerber. </author> <title> Compositional verification by model checking for counter examples. </title> <booktitle> In Proc. of ACM Sigsoft ISSTA'96, </booktitle> <pages> pages 224-238, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: [6, 8]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [5, 6, 25]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., <ref> [7, 10, 18] </ref>). But when transition systems are not restricted to be finite, most of these techniques are no longer applicable, as they inherently depend on all underlying types being bounded. Also, general safety and liveness properties become undecidable for infinite transition systems.
Reference: [8] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> (April </month> <year> 1986). </year>
Reference-contexts: 1 Introduction In recent years, there has been a surge of progress in the area of automated analysis for finite state systems. Several reasons for this success are: (1) the development of powerful techniques such as model-checking (e.g., <ref> [6, 8] </ref>), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [5, 6, 25]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., [7, <p> The Omega library uses extensions of Fourier variable elimination to solve integer programming problems, along with a set of transformation functions and heuristics to help convert real-valued approximations into discrete-valued solutions. Temporal Properties. We use the temporal logic called Computation Tree Logic (CTL) <ref> [8] </ref> to specify properties of programs. Four CTL operators form the basis of our logic: quantified-next state operators 9fl and 8fl, and quantified-until operators 9U and 8U . <p> A path (s 0 ; s 1 ; s 2 ; : : :) is a finite or infinite sequence of states, such that for each successive pair of states (s i ; s i+1 ) 2 X. Unlike Clarke et al. <ref> [8] </ref>, we do not require the 8 s j= f iff L (s; f) = True, where f 2 SF s j= :f iff s 6j= f s j= f _ g iff s j= f or s j= g s 0 j= 9 fl f iff for some maximal path
Reference: [9] <author> E. M. Clarke, O. Grumberg, D. E. </author> <title> Long Model checking and abstraction. </title> <booktitle> In Proc. of the 18th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <year> 1992. </year>
Reference-contexts: Then, we present a variety of different example programs, and show how the various methods performed on them. Finally, we conclude with some discussion on our results. 2 Related Work Other methods have been proposed to deal with infinite-state concurrent programs, and we note some of them here. In <ref> [9] </ref>, Clarke et al. present a conservative model checking technique, by producing a finite abstraction of the program (e.g., via a congruence relation modulo a suitable integer), and then checking the property of interest on the abstraction.
Reference: [10] <author> E. M. Clarke, D. E. Long, and K. L. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In Proc. of the 4th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 464-475, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: [6, 8]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [5, 6, 25]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., <ref> [7, 10, 18] </ref>). But when transition systems are not restricted to be finite, most of these techniques are no longer applicable, as they inherently depend on all underlying types being bounded. Also, general safety and liveness properties become undecidable for infinite transition systems.
Reference: [11] <author> D. C. Cooper. </author> <title> Programs for mechanical program verification. </title> <booktitle> In Machine Intelligence 6, </booktitle> <editor> B. Meltzer and D. Michie, editors, </editor> <address> pages 43-59, New York, 1971, </address> <publisher> American Elsevier. </publisher>
Reference-contexts: Then the local proofs can be checked for cooperation [15]. Although this method has the benefit of incrementally proving correctness (as opposed to generating all possible interleavings), it relies on users to come up with the correct assertions. Our work has some historical antecedents. Cooper <ref> [11] </ref> developed a technique which encodes transition relations as sets of Presburger formulas, and then converts queries about a program's properties to validity checks in Presburger arithmetic. The decision procedure used by Cooper was computationally very expensive which made the validity checks intractable.
Reference: [12] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proc. 4th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1977. </year>
Reference-contexts: We have found it more beneficial to use model checking as our primary technology, and use a Presburger solver for some subservient set-theoretic computations. Our work was also influenced by known techniques from abstract interpretation <ref> [12, 13] </ref>; specif ically, we use some approximation methods first developed for that domain. Most reachability properties can be formulated as least fixpoints over sets of a program's states; if the state space is infinite, these fixpoints may not be computable. <p> Thus the fixpoint of the ^ Q i 's is an upper approximation to the least fixpoint of the Q i 's. To generate the ^ Q i 's, we currently adopt a method developed by Cousot and Cousot, within the framework of abstract interpretation <ref> [12] </ref>. That is, we define an operator called widening, or "5", which majorizes the union computation as follows: For any pair of sets P; P 0 , P _ P 0 P 5 P 0 .
Reference: [13] <author> P. Cousot and N. Halbwachs. </author> <title> Automatic discovery of linear restraints among variables of a program. </title> <booktitle> In Proceedings of the 5th Annual ACM Symposium on Principles of Programming Languages, 1978, </booktitle> <publisher> ACM Press. </publisher>
Reference-contexts: Two of the methods use a generalized form of "widening" technique discussed in <ref> [13] </ref> for abstract interpretation. We demonstrate how the approximate methods work together (with minimal user intervention); i.e., how our driver program integrates lower and upper bounds for sub-formulas, and then derives a conservative result for the high-level goal. <p> We have found it more beneficial to use model checking as our primary technology, and use a Presburger solver for some subservient set-theoretic computations. Our work was also influenced by known techniques from abstract interpretation <ref> [12, 13] </ref>; specif ically, we use some approximation methods first developed for that domain. Most reachability properties can be formulated as least fixpoints over sets of a program's states; if the state space is infinite, these fixpoints may not be computable. <p> Our goal is to find a widening operator which (1) yields a suitable (i.e., reasonably tight) upper bound for union, and (2) forces the ^ Q i sequences to converge. In defining our widening operator, we generalized a technique used by Cousot and Halbwachs in <ref> [13] </ref>. The idea is to "guess" the direction of growth in the model-checker's Q i iterates, and to extend the successive iterates in these directions. Cousot and Halbwachs' widening operator b 5 does this for convex polyhedra - i.e., regions formed by a conjunction of affine constraints.
Reference: [14] <author> R. Cridlig. </author> <title> Semantic analysis of concurrent ML by abstract model-checking. </title> <booktitle> In Proceedings of INFINITY International workshop on Infinite State Systems, </booktitle> <pages> pages 71-86, </pages> <year> 1996, </year> <type> Technical Report MIP-9614, </type> <institution> University of Passau. </institution>
Reference-contexts: One abstraction over estimates the behavior of the program and used for computing universal properties. Another abstraction underestimates the behavior of the program and is used for computing existential prop erties. Together they can be used to conservatively approximate any mu-calculus property. Similar methods are also used in <ref> [14, 27] </ref> where an approximation for a temporal formula expressed in mu calculus is computed using lower or upper approximations of its subformulas. Our approximation techniques are based on approximating the fixpoint computations instead of approximating the program as a whole using abstractions.
Reference: [15] <author> L. K. Dillon. </author> <title> Using symbolic execution for verification of Ada tasking programs. </title> <journal> ACM Trans actions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 643-669, </pages> <month> (October </month> <year> 1990). </year>
Reference-contexts: There may be cases where abstraction methods can vastly reduce the state space without achieving a finite representation. In these cases our model checker can be used on the infinite abstract models. Another approach is to use symbolic execution technique <ref> [15, 19] </ref>, which symbolically generates 4 a program's execution paths. In practice, this method may end up generating an infinite number of nodes, and thus never terminate. This limitation can be overcome by having the user specify assertions about a process's behavior, which can be verified locally. <p> In practice, this method may end up generating an infinite number of nodes, and thus never terminate. This limitation can be overcome by having the user specify assertions about a process's behavior, which can be verified locally. Then the local proofs can be checked for cooperation <ref> [15] </ref>. Although this method has the benefit of incrementally proving correctness (as opposed to generating all possible interleavings), it relies on users to come up with the correct assertions. Our work has some historical antecedents.
Reference: [16] <author> J. Dingel, and T. Filkorn. </author> <title> Model checking for infinite state systems using data abstraction, assumption-commitment style reasoning and theorem proving. </title> <booktitle> Proceedings of CAV'95, LNCS 939, </booktitle> <year> 1995. </year>
Reference-contexts: In [9], Clarke et al. present a conservative model checking technique, by producing a finite abstraction of the program (e.g., via a congruence relation modulo a suitable integer), and then checking the property of interest on the abstraction. In <ref> [16] </ref>, Dingel and Filkorn extend this method using "assumption-commitment" style reasoning and theorem proving. While these techniques require the user to find the appropriate abstractions and hence are not completely automatable we see them as being orthogonal to our approach.
Reference: [17] <author> M. J. Fischer and M. O. Rabin. </author> <title> Super-Exponential Complexity of Presburger Arithmetic. </title> <booktitle> SIAM-AMS Proceedings, </booktitle> <volume> Volume 7, </volume> <pages> pages 27-41, </pages> <year> 1974. </year>
Reference-contexts: In general, the worst-case time bound for determining validity in Presburger arithmetic is prohibitive, with a deterministic upper bound of 2 2 2 pn (for some constant p &gt; 1) [26], and a nondeterministic lower bound of 2 2 cn (for some constant c &gt; 0) <ref> [17] </ref>, where n denotes the length of the formula. Yet we have found that the Omega library [21, 28] is quite efficient at solving the problems that arise in our analysis, which typically possess a small number of constraints, and do not contain multiple levels of alternating quantifiers.
Reference: [18] <author> P. Godefroid. </author> <title> Partial-order methods for the verification of concurrent systems: An approach to the state-explosion problem. </title> <type> Ph.D. Thesis, </type> <institution> Universite De Liege, </institution> <year> 1994. </year>
Reference-contexts: [6, 8]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [5, 6, 25]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., <ref> [7, 10, 18] </ref>). But when transition systems are not restricted to be finite, most of these techniques are no longer applicable, as they inherently depend on all underlying types being bounded. Also, general safety and liveness properties become undecidable for infinite transition systems.
Reference: [19] <author> S. L. Hantler and J. C. King. </author> <title> An Introduction to proving the correctness of programs. </title> <journal> ACM Computing Surveys 8(3) </journal> <pages> 331-353, </pages> <month> (September </month> <year> 1976). </year> <month> 35 </month>
Reference-contexts: There may be cases where abstraction methods can vastly reduce the state space without achieving a finite representation. In these cases our model checker can be used on the infinite abstract models. Another approach is to use symbolic execution technique <ref> [15, 19] </ref>, which symbolically generates 4 a program's execution paths. In practice, this method may end up generating an infinite number of nodes, and thus never terminate. This limitation can be overcome by having the user specify assertions about a process's behavior, which can be verified locally.
Reference: [20] <author> P. Kelb, D. Dams, and R. Gerth. </author> <title> Practical symbolic model checking of the full -calculus using compositional abstractions. </title> <type> Technical Report 95-31, </type> <institution> Department of Computer Science, Eindhoven University of Technology, </institution> <year> 1995. </year>
Reference-contexts: Since our basic temporal operators require similar computations, we were able to successfully use this method in conjunction with the Omega library. Our recursive approximation technique for temporal properties with nested temporal operators is similar to the one used by Kelb et al. in <ref> [20] </ref>. In [20] a temporal property expressed in mu calculus is computed conservatively using two abstractions of the same program. One abstraction over estimates the behavior of the program and used for computing universal properties. <p> Since our basic temporal operators require similar computations, we were able to successfully use this method in conjunction with the Omega library. Our recursive approximation technique for temporal properties with nested temporal operators is similar to the one used by Kelb et al. in <ref> [20] </ref>. In [20] a temporal property expressed in mu calculus is computed conservatively using two abstractions of the same program. One abstraction over estimates the behavior of the program and used for computing universal properties. Another abstraction underestimates the behavior of the program and is used for computing existential prop erties.
Reference: [21] <author> W. Kelly, V. Maslov, W. Pugh, E. Rosser, T. Shpeisman and D. Wonnacott. </author> <title> The Omega Li brary (version 1.00) interface guide. </title> <note> Available at &lt;http://www.cs.umd.edu/projects/omega&gt;. </note>
Reference-contexts: as an extended abstract in the Proceedings of the 9th Conference on Computer Aided Verification (CAV '97). y This work was supported in part by ONR grant N00014-94-10228, NSF CCR-9619808 and a Packard Fellowship. 1 * Efficiently manipulating these formulas (via a fast Presburger solver called the Omega li brary <ref> [21, 28] </ref>) to derive truth sets of temporal logic formulas and their fixpoint computations. * Using conservative approximation techniques in analysis of infinite state programs, which guarantee convergence by allowing false negatives. In any computer system variables are eventually mapped to finite representations. <p> Yet we have found that the Omega library <ref> [21, 28] </ref> is quite efficient at solving the problems that arise in our analysis, which typically possess a small number of constraints, and do not contain multiple levels of alternating quantifiers. <p> = 0 ^ q 2 = 0 Note that if we have had used the DNF event partitioning first (from Figure 3), we would have produced a finer partitioning with more classes. 5 Symbolic Model-Checker After generating our symbolic representations in terms of Presburger formulas, we use the Omega library <ref> [21] </ref> to help symbolically compute the truth sets for the temporal properties at hand.
Reference: [22] <author> W. Kelly, and W. Pugh. </author> <title> Using affine closure to find legal reordering transformations. </title> <journal> Inter national Journal of Parallel Programming, </journal> <year> 1995. </year>
Reference-contexts: The Omega library includes a large collection of object classes to efficiently manipulate Presburger for mulas; to date it has mainly been used in high-performance compilers, specifically for dependence analysis, program transformations, and detecting redundant synchronization <ref> [22, 28, 29] </ref>. The particular Omega functions we use are shown in Figure 6. These functions take symbolic represen tations of sets or relations as inputs (i.e., a Presburger formula representing a set or a relation), and return the symbolic form of a set or a relation as output. <p> In other words, we could compute 93f and RS in a single step. In general, though, constructing transitive closure of a Presburger relation is not computable. However, akin to our state-based techniques, there are approximation techniques for obtaining upper and lower bounds for X fl <ref> [22, 23] </ref>. In turn, these can be used to compute our desired lower and upper bounds for RS and 93f .
Reference: [23] <author> W. Kelly, W. Pugh, E. Rosser and T. Shpeisman. </author> <title> Transitive closure of infinite graphs and its applications. </title> <booktitle> In Eight Annual Workshop on Programming Languages and Compilers for Parallel Computing, </booktitle> <address> Columbus, OH, </address> <month> August </month> <year> 1995. </year> <type> Technical Report CS-TR-3457, </type> <institution> UMIACS TR-95-48, Department of Computer Science, University of Maryland, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: In other words, we could compute 93f and RS in a single step. In general, though, constructing transitive closure of a Presburger relation is not computable. However, akin to our state-based techniques, there are approximation techniques for obtaining upper and lower bounds for X fl <ref> [22, 23] </ref>. In turn, these can be used to compute our desired lower and upper bounds for RS and 93f .
Reference: [24] <author> D. Kozen. </author> <title> Results on the propositional -Calculus, </title> <booktitle> Theoretical Computer Science 27 </booktitle> <pages> 333-354, </pages> <year> (1983). </year>
Reference: [25] <author> K. L. McMillan. </author> <title> Symbolic model checking. </title> <address> Massachusetts, 1993, </address> <publisher> Kluwer Academic Publishers. </publisher>
Reference-contexts: Several reasons for this success are: (1) the development of powerful techniques such as model-checking (e.g., [6, 8]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., <ref> [5, 6, 25] </ref>); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., [7, 10, 18]). <p> In any computer system variables are eventually mapped to finite representations. Thus, it might be argued that integer variables can be given a finite range, and programs can then be analyzed as finite-state machines for example, using BDD's <ref> [6, 25] </ref>. For several reasons, however, this may not always be the best way to proceed. First, mapping integer variables and operations to their binary implementations may lead to highly inefficient static analysis. <p> As for the techniques, all of the "top-level" techniques we report are at least conservative, and several are exact. Some programs can, in fact, be quickly verified using exact symbolic model checking algorithms, similar to those presented in <ref> [25] </ref> for BDDs. In our domain, the analogue of a CTL "atomic proposition" is postulated over the Presburger logic, and is propagated through 3 the program as such. <p> Since F f 1 9Uf 2 and F f 1 8Uf 2 are both monotonic, and since we start the sequence with ;, these sequences are non-decreasing. When these monotonically increasing sequences reach a fixpoint, we know that it is the least fixpoint <ref> [25] </ref>. These methods lead directly to the model checking procedure shown in Figure 7 (subformulas are computed recursively).
Reference: [26] <author> D. C. Oppen. </author> <title> A 2 2 2 pn upper bound on the complexity of Presburger arithmetic. </title> <journal> Journal of Computer and System Sciences 16 </journal> <pages> 323-332, </pages> <year> (1978). </year>
Reference-contexts: In general, the worst-case time bound for determining validity in Presburger arithmetic is prohibitive, with a deterministic upper bound of 2 2 2 pn (for some constant p &gt; 1) <ref> [26] </ref>, and a nondeterministic lower bound of 2 2 cn (for some constant c &gt; 0) [17], where n denotes the length of the formula.
Reference: [27] <author> A. Pardo and G. D. Hachtel. </author> <title> Automatic Abstraction Techniques for Propositional -calculus Model Checking. </title> <booktitle> Proceedings of CAV '97, </booktitle> <publisher> LNCS 1254, Orna Grumberg, ed., </publisher> <pages> pages 12-23, </pages> <year> 1997. </year>
Reference-contexts: One abstraction over estimates the behavior of the program and used for computing universal properties. Another abstraction underestimates the behavior of the program and is used for computing existential prop erties. Together they can be used to conservatively approximate any mu-calculus property. Similar methods are also used in <ref> [14, 27] </ref> where an approximation for a temporal formula expressed in mu calculus is computed using lower or upper approximations of its subformulas. Our approximation techniques are based on approximating the fixpoint computations instead of approximating the program as a whole using abstractions.
Reference: [28] <author> W. Pugh. </author> <title> The Omega test: a fast and practical integer programming algorithm for dependence analysis. </title> <journal> Communications of the ACM, </journal> <volume> 8 </volume> <pages> 102-104, </pages> <month> (August </month> <year> 1992). </year>
Reference-contexts: as an extended abstract in the Proceedings of the 9th Conference on Computer Aided Verification (CAV '97). y This work was supported in part by ONR grant N00014-94-10228, NSF CCR-9619808 and a Packard Fellowship. 1 * Efficiently manipulating these formulas (via a fast Presburger solver called the Omega li brary <ref> [21, 28] </ref>) to derive truth sets of temporal logic formulas and their fixpoint computations. * Using conservative approximation techniques in analysis of infinite state programs, which guarantee convergence by allowing false negatives. In any computer system variables are eventually mapped to finite representations. <p> Yet we have found that the Omega library <ref> [21, 28] </ref> is quite efficient at solving the problems that arise in our analysis, which typically possess a small number of constraints, and do not contain multiple levels of alternating quantifiers. <p> The Omega library includes a large collection of object classes to efficiently manipulate Presburger for mulas; to date it has mainly been used in high-performance compilers, specifically for dependence analysis, program transformations, and detecting redundant synchronization <ref> [22, 28, 29] </ref>. The particular Omega functions we use are shown in Figure 6. These functions take symbolic represen tations of sets or relations as inputs (i.e., a Presburger formula representing a set or a relation), and return the symbolic form of a set or a relation as output.
Reference: [29] <author> W. Pugh and D. Wonnacott. </author> <title> Static analysis of upper and lower bounds on dependences and parallelism. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(3) </volume> <pages> 1248-1278, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: The Omega library includes a large collection of object classes to efficiently manipulate Presburger for mulas; to date it has mainly been used in high-performance compilers, specifically for dependence analysis, program transformations, and detecting redundant synchronization <ref> [22, 28, 29] </ref>. The particular Omega functions we use are shown in Figure 6. These functions take symbolic represen tations of sets or relations as inputs (i.e., a Presburger formula representing a set or a relation), and return the symbolic form of a set or a relation as output.
Reference: [30] <author> A. Udaya Shankar. </author> <title> An introduction to assertional reasoning for concurrent systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(3) </volume> <pages> 225-262, </pages> <month> (September </month> <year> 1993). </year> <month> 36 </month>
Reference-contexts: In this paper we demonstrate our model checker's effectiveness on some classical infinite-state programs taken from the concurrency literature <ref> [3, 30] </ref>. While relatively small, they possess some interesting subtleties, especially in the tricky way their infinite-state variables influence control flow. A summary of our approach is shown in Figure 1, and it depicts how we structure the three main phases: translation, partitioning and analysis. <p> For example, checking to see if there exists an integer solution to a set of linear constraints is NP-hard, while the analogous real-valued problem can be solved in polynomial time. 3 Programs and Properties We use the event-action language from <ref> [30] </ref> as our syntax for concurrent programs, with a semantics defined in terms of infinite transition systems. <p> concurrent program C = (V; I ; E) is represented by (1) a finite set of data and control variables V ; (2) an initial condition I , which specifies the starting states of the program; and (3) a finite set of events E, where each event is considered atomic <ref> [30] </ref>. The state of a program is determined by the values of its data and control variables. We assume that the domain of each variable is a countable set. <p> + When the state space of the ticket algorithm was restricted to this set the exact analyzer was able to prove both the mutual exclusion and the starvation freedom properties of the ticket algorithm. 8.3 Producer-Consumer In Figure 13, we present a bounded-buffer producer-consumer problem adapted from an example in <ref> [30] </ref>. This program implements an instance of the problem with two producers and two consumers. We wish to prove that 82 (0 p 1 + p 2 (c 1 + c 2 ) s) holds, i.e., that the bounded buffer properties are satisfied.
References-found: 30

