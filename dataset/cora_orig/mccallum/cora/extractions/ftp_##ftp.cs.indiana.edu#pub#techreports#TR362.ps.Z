URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR362.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Title: Language Extension via First-class Interpreters  
Author: John Wiseman Simmons II Stanley Jefferson Daniel P. Friedman 
Date: September 29, 1992  
Affiliation: Indiana University Computer Science Department  
Pubnum: Technical Report #362  
Abstract: Refci is an extensible reflective language based on the reflective tower model. The Refci interpreter procedures are reifiable, first-class objects, and user programs can directly modify the interpreter by extending them. This allows user code to be run directly as part of, and at the level of, the interpreter. By installing a modified or extended interpreter, user programs can modularly extend the language and implement debugging aids. We present the extensible first-class interpreter and give examples of its use. Examples include stepping, breakpoints, and interrupts. We show how the reflective tower, modeled by the metacontinuation, maintains the proper level of interpretation when running an interpreter containing both system code and user code.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bawden, A. </author> <title> Reification without evaluation. </title> <booktitle> Proceedings of the ACM Conference on LISP and Functional Programming (1988). </booktitle>
Reference-contexts: The prelim allows the addition of actions to be performed during interpretation before the dispatch takes place. The extensible first-class interpreter we present provides a unified, coherent, and general language extension method, which includes the capabilities of reflection and of the Lisp hooks, as well as of Bawden's Stepper <ref> [1] </ref>. It allows the user to access, extend, and modify the state of the interpreter with a single mechanism. Once modified by the user, the interpreter contains both system code and user code. The system code is run directly, while the user code must be interpreted by the system.
Reference: [2] <editor> Clinger, W., and Rees, J., </editor> <title> "Revised 4 report on the algorithmic language Scheme," </title> <booktitle> Lisp Pointers 4 :3, </booktitle> <pages> pp. 1-55, </pages> <year> 1991. </year> <note> Also available as a technical report from Indiana University, </note> <institution> MIT, and the University of Oregon. </institution> <address> REFERENCES 16 </address>
Reference-contexts: Our language, called Refci, is derived from Blond [4, 5, 11, 12]. It is implemented in Scheme <ref> [2, 7] </ref> and has Scheme-like syntax. There are only three forms of expression: constant, variable, and application (with an arbitrary number of arguments). Primitive procedures are included as subrs.
Reference: [3] <institution> Common Lisp Object System Specification X3J13 Document 88-002R. </institution> <note> SIGPLAN Notices (September 1988). </note>
Reference: [4] <author> Danvy, O., and Malmkjr, K. </author> <title> Aspects of computational reflection in a programming language. </title> <note> Extended abstract (1988). </note>
Reference-contexts: As soon as the extra level begins interpreting default interpreter code rather than user code, it can become virtual again. The system shifts down by pushing the extra level's continuation back onto the metacontinuation, and the interpreter again begins directly interpreting user code. The Brown [8, 15] and Blond <ref> [4, 5, 11, 12] </ref> languages are also based on the metacontinuation model. They are designed to allow a clean description in denotational semantics. Our work retains the metacontinuation representation of the reflective tower, but alters the way the user accesses the tower's levels. <p> Our language, called Refci, is derived from Blond <ref> [4, 5, 11, 12] </ref>. It is implemented in Scheme [2, 7] and has Scheme-like syntax. There are only three forms of expression: constant, variable, and application (with an arbitrary number of arguments). Primitive procedures are included as subrs.
Reference: [5] <author> Danvy, O., and Malmkjr, K. </author> <title> Intensions and Extensions in a Reflective Tower. </title> <booktitle> ACM Conference on Lisp and Functional Programming (1988) 327-341. [6] des Rivieres, </booktitle> <editor> J., and Smith, B. </editor> <booktitle> The Implementation of Procedurally Reflective Languages. Proceedings of the Symposium on Lisp and Functional Programming, ACM (August 1984) 331-347. </booktitle>
Reference-contexts: As soon as the extra level begins interpreting default interpreter code rather than user code, it can become virtual again. The system shifts down by pushing the extra level's continuation back onto the metacontinuation, and the interpreter again begins directly interpreting user code. The Brown [8, 15] and Blond <ref> [4, 5, 11, 12] </ref> languages are also based on the metacontinuation model. They are designed to allow a clean description in denotational semantics. Our work retains the metacontinuation representation of the reflective tower, but alters the way the user accesses the tower's levels. <p> Our language, called Refci, is derived from Blond <ref> [4, 5, 11, 12] </ref>. It is implemented in Scheme [2, 7] and has Scheme-like syntax. There are only three forms of expression: constant, variable, and application (with an arbitrary number of arguments). Primitive procedures are included as subrs.
Reference: [7] <author> Dybvig, K. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall (1987). </publisher>
Reference-contexts: Our language, called Refci, is derived from Blond [4, 5, 11, 12]. It is implemented in Scheme <ref> [2, 7] </ref> and has Scheme-like syntax. There are only three forms of expression: constant, variable, and application (with an arbitrary number of arguments). Primitive procedures are included as subrs.
Reference: [8] <author> Friedman, D., and Wand, M. </author> <title> Reification: reflection without metaphysics. </title> <booktitle> Proceedings of the Symposium on Lisp and Functional Programming ACM (August 1984) 348-355. </booktitle>
Reference-contexts: As soon as the extra level begins interpreting default interpreter code rather than user code, it can become virtual again. The system shifts down by pushing the extra level's continuation back onto the metacontinuation, and the interpreter again begins directly interpreting user code. The Brown <ref> [8, 15] </ref> and Blond [4, 5, 11, 12] languages are also based on the metacontinuation model. They are designed to allow a clean description in denotational semantics. Our work retains the metacontinuation representation of the reflective tower, but alters the way the user accesses the tower's levels.
Reference: [9] <author> Keene, S. </author> <title> Object-oriented programming in Common Lisp: A programmer's guide to CLOS. </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA (1989). </address>
Reference: [10] <editor> Maes, Pattie. </editor> <title> Computational reflection. </title> <type> Technical Report 87 2, </type> <institution> Artificial Intelligence Laboratory, Vrije Universiteit Brussel. </institution>
Reference-contexts: The user can access the interpreter and install a modified version in the system. All access to the tower can be mediated through these modified interpreters. Pattie Maes <ref> [10] </ref> presents an object-oriented reflective language 3-KRS. In 3-KRS, programs as well as data are represented as objects. The computational information about an object is stored in its meta-object. This system uses a metacircular interpreter in direct style. The interpreter is divided among the default meta-objects.
Reference: [11] <author> Malmkjr, K. </author> <title> On some semantic issues in the reflective tower. </title> <booktitle> Fifth Conference on Mathematical Foundations of Programming Semantics. Springer-Verlag, Lecture Notes in Computer Science 442 (1990). </booktitle>
Reference-contexts: As soon as the extra level begins interpreting default interpreter code rather than user code, it can become virtual again. The system shifts down by pushing the extra level's continuation back onto the metacontinuation, and the interpreter again begins directly interpreting user code. The Brown [8, 15] and Blond <ref> [4, 5, 11, 12] </ref> languages are also based on the metacontinuation model. They are designed to allow a clean description in denotational semantics. Our work retains the metacontinuation representation of the reflective tower, but alters the way the user accesses the tower's levels. <p> Our language, called Refci, is derived from Blond <ref> [4, 5, 11, 12] </ref>. It is implemented in Scheme [2, 7] and has Scheme-like syntax. There are only three forms of expression: constant, variable, and application (with an arbitrary number of arguments). Primitive procedures are included as subrs.
Reference: [12] <author> Malmkjr, K. </author> <title> A Blond Primer. </title> <note> DIKU Research Report 88/21 (September 12, </note> <year> 1988). </year>
Reference-contexts: As soon as the extra level begins interpreting default interpreter code rather than user code, it can become virtual again. The system shifts down by pushing the extra level's continuation back onto the metacontinuation, and the interpreter again begins directly interpreting user code. The Brown [8, 15] and Blond <ref> [4, 5, 11, 12] </ref> languages are also based on the metacontinuation model. They are designed to allow a clean description in denotational semantics. Our work retains the metacontinuation representation of the reflective tower, but alters the way the user accesses the tower's levels. <p> Our language, called Refci, is derived from Blond <ref> [4, 5, 11, 12] </ref>. It is implemented in Scheme [2, 7] and has Scheme-like syntax. There are only three forms of expression: constant, variable, and application (with an arbitrary number of arguments). Primitive procedures are included as subrs.
Reference: [13] <author> Smith, B. </author> <title> Reflection and semantics in a procedural language. </title> <month> MIT/LCS/TR-272 </month> <year> (1982). </year>
Reference-contexts: In the limit, we can envision an infinite reflective tower of interpreters, each interpreting the code of the one below, and the one at the bottom interpreting the user's code. The seminal work on computational reflection is Brian Smith's thesis <ref> [6, 13] </ref>. Smith proposes a semantically rationalized dialect of Lisp as a basis for a reflective implementation. The result of this development is the reflective dialect 3-Lisp.
Reference: [14] <author> Symbolics Lisp Manual, </author> <title> Vol. 4: Program Development Utilities. Symbolics, </title> <publisher> Inc. </publisher> <month> (August </month> <year> 1986). </year>
Reference-contexts: Some programming languages, such as Lisp, allow the user to extend the language by defining new special forms. Dialects of Lisp frequently provide the user with ad hoc methods to change the mechanism of evaluation and procedure application. In Symbolics Zeta Lisp <ref> [14] </ref>, for example, these facilities are provided by evalhook and applyhook. These methods, however, do not permit the user to gain access to the full state of the computation, represented by the current expression, environment, and continuation.
Reference: [15] <author> Wand, M., and Friedman, D. </author> <title> The mystery of the tower revealed: A non-reflective description of the reflective tower. </title> <booktitle> Lisp and Symbolic Computation 1, </booktitle> <month> 1 (June </month> <year> 1988) </year> <month> 11-38. </month>
Reference-contexts: As soon as the extra level begins interpreting default interpreter code rather than user code, it can become virtual again. The system shifts down by pushing the extra level's continuation back onto the metacontinuation, and the interpreter again begins directly interpreting user code. The Brown <ref> [8, 15] </ref> and Blond [4, 5, 11, 12] languages are also based on the metacontinuation model. They are designed to allow a clean description in denotational semantics. Our work retains the metacontinuation representation of the reflective tower, but alters the way the user accesses the tower's levels.
References-found: 14

