URL: http://www.aic.nrl.navy.mil/papers/1993/AIC-93-031.ps.Z
Refering-URL: http://www.aic.nrl.navy.mil/~aha/pub-details.html
Root-URL: 
Phone: 5514,  8800,  3  4  
Title: Inverting Implication with Small Training Sets  
Author: David W. Aha Stephane Lapointe Charles X. Ling and Stan Matwin 
Address: Code  DC 20375 USA 2 DREV, P.O. Box  Courcelette, Quebec, G0A 1R0 Canada  Ontario, London, Canada  Ottawa, Ontario Canada  
Affiliation: 1 Navy Center for Applied Research in Artificial Intelligence,  Naval Research Laboratory, Washington,  Defence Research Establishment Valcartier,  Department of Computer Science, University of Western  Department of Computer Science, University of  
Abstract: We present an algorithm for inducing recursive clauses using inverse implication (rather than inverse resolution) as the underlying generalization method. Our approach applies to a class of logic programs similar to the class of primitive recursive functions. Induction is performed using a small number of positive examples that need not be along the same resolution path. Our algorithm, implemented in a system named CRUSTACEAN, locates matched lists of generating terms that determine the pattern of decomposition exhibited in the (target) recursive clause. Our theoretical analysis defines the class of logic programs for which our approach is complete, described in terms characteristic of other ILP approaches. Our current implementation is considerably faster than previously reported. We present evidence demonstrating that, given randomly selected inputs, increasing the number of positive examples increases accuracy and reduces the number of outputs. We relate our approach to similar recent work on inducing recursive clauses.
Abstract-found: 1
Intro-found: 1
Reference: <author> Aha, D. W., Ling, C. X., Matwin, S., & Lapointe, S. </author> <year> (1993). </year> <title> Learning singly-recursive relations from small datasets. </title> <booktitle> In Proceedings of the IJCAI-93 Workshop on Inductive Logic Programming. </booktitle> <address> Chambery, France: </address> <note> Unpublished. </note>
Reference-contexts: The current version of CRUSTACEAN has been significantly optimized compared to the version first reported in <ref> (Aha, Ling, Matwin, & Lapointe, 1993) </ref>. We describe some of these optimizations in Sect. 3. Section 4 of this paper describes a theoretical characterization of CRUSTACEAN's abilities, Sect. 5 summarizes empirical results, and Sect. 6 relates our contributions to other work on inverse implication.
Reference: <author> Cohen, W. </author> <year> (1993). </year> <title> Pac-learning a restricted class of recursive logic programs. </title> <booktitle> In Proceedings of the Third International Workshop on Inductive Logic Programming (pp. </booktitle> <pages> 73-86). </pages> <institution> Bled, Slovenia: J. Stefan Institute. </institution>
Reference: <author> De Raedt, L. </author> <year> (1992). </year> <title> Interactive theory revision: An inductive logic programming approach. </title> <publisher> London: Academic Press. </publisher>
Reference: <author> Idestam-Almquist, P. </author> <year> (1993). </year> <title> Recursive anti-unification. </title> <booktitle> In Proceedings of the Third International Workshop on Inductive Logic Programming (pp. </booktitle> <pages> 241-254). </pages> <institution> Bled, Slovenia: J. Stefan Institute. </institution>
Reference: <author> Lapointe, S., Ling, X. C., & Matwin, S. </author> <year> (1993). </year> <title> Constructive inductive logic programming. </title> <booktitle> In Proceedings of the Thirteenth International Joint Conference on Artificial Intelligence. </booktitle> <address> Chambery, France: </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: First, recursion is the basic technique in logic programming, where iteration is achieved by recursion. Second, important classes of functions (e.g., primitive recursive functions) are defined recursively. Third, as we have pointed out in an earlier paper <ref> (Lapointe, Ling, & Matwin, 1993) </ref>, constructive learning in the inductive logic programming (ILP) context requires the ability to learn recursive relations. <p> The current version of CRUSTACEAN has been significantly optimized compared to the version first reported in <ref> (Aha, Ling, Matwin, & Lapointe, 1993) </ref>. We describe some of these optimizations in Sect. 3. Section 4 of this paper describes a theoretical characterization of CRUSTACEAN's abilities, Sect. 5 summarizes empirical results, and Sect. 6 relates our contributions to other work on inverse implication.
Reference: <author> Lapointe, S., & Matwin, S. </author> <year> (1992). </year> <title> Sub-unification: A tool for efficient induction of recursive programs. </title> <booktitle> In Proceedings of the Ninth International Conference on Machine Learning (pp. </booktitle> <pages> 273-281). </pages> <address> Aberdeen, Scotland: </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Methods based on -subsumption typically (e.g., in a classroom environment) require tens of training instances to induce some of the functions mentioned above. This paper describes CRUSTACEAN, a system that generalizes the inverse implication approach first applied in LOPSTER <ref> (Lapointe & Matwin, 1992) </ref>. CRUSTACEAN relaxes one of the limiting assumptions of LOPSTER, which required that training instances belong to the same chain of recursive calls. By removing this assumption, much less user's knowledge of the recursive relation is required than was required by LOPSTER. <p> We begin by describing some of the basic concepts underlying our approach in Sect. 2. 2 Basic Concepts There are three notions, underlying our approach. These notions were first introduced, in a slightly different form, in LOPSTER <ref> (Lapointe & Matwin, 1992) </ref>. They are useful for building tools that can then be used to hypothesize the recursive concept definition from the structure of terms of n 2 examples of that concept. These notions are (1) subterms, (2) embedding terms, and (3) generating terms. <p> are randomly selected, which tests CRUSTACEAN's robustness. 5.1 Evaluation with Manually Selected Inputs We conducted ten experiments with CRUSTACEAN to investigate its ability to induce relations when given positive examples not on the same inverse resolution chain. 8 The relations used in the experiments were previously used to test LOPSTER <ref> (Lapointe & Matwin, 1992) </ref>. However, the positive examples used here were modified so as to not be on the same inverse resolution path. 9 The positive examples, negative examples, and target relation for each experiment are summarized in Table 2.
Reference: <author> Ling, X. C. </author> <year> (1991). </year> <title> Inductive learning from good examples. </title> <booktitle> In Proceedings of the Twelvth International Conference on Artificial Intelligence (pp. </booktitle> <pages> 751-756). </pages> <address> Sydney, Australia: </address> <publisher> Morgan Kaufmann. </publisher>
Reference: <author> Muggleton, S. </author> <year> (1992). </year> <title> Inverting implication. </title> <booktitle> In Proceedings of the First Euro-pean Workshop on Inductive Logic Programming. </booktitle> <address> Vienna, Austria: </address> <note> Unpublished. </note>
Reference-contexts: Since the -subsumption notion of generality is only incomplete for self-recursive clauses (i.e., for expressing generality relations between different powers or roots of a clause) <ref> (Muggleton, 1992) </ref>, no output is more general under -subsumption than any other output, although one might be more general than another under implication (e.g., as when the first recursive clause is a root of the second). Example 2. <p> CRUSTACEAN produces purely recursive logic programs, syntactically similar to primitive recursive functions. We have also characterized the class of functions for which CRUSTACEAN is complete; CRUSTACEAN will produce the least general logic programs and their corresponding n th roots <ref> (Muggleton, 1992) </ref> with respect to the the class of considered logic programs. We believe that our approach is a practical method for inducing recursive clauses.
Reference: <author> Muggleton, S., & Buntine, W. </author> <year> (1988). </year> <title> Machine invention of first order predicates by inverting resolution. </title> <booktitle> In Proceedings of the Fifth International Conference on Machine Learning (pp. </booktitle> <pages> 339-352). </pages> <address> Ann Arbor, MI: </address> <publisher> Morgan Kauf-mann. </publisher>
Reference: <author> Muggleton, S., & Feng, C. </author> <year> (1990). </year> <title> Efficient induction of logic programs. </title> <booktitle> Proceedings of the First International Workshop on Algorithmic Learning Theory (pp. </booktitle> <pages> 368-381). </pages> <address> Tokyo, Japan: </address> <booktitle> Japanese Society for Artificial Intelligence. </booktitle>
Reference-contexts: It is generally believed that the -subsumption mechanism is the main source of difficulty in inducing recursive clauses in popular ILP systems (e.g., FOIL (Quinlan, 1991) and Golem <ref> (Muggleton & Feng, 1990) </ref>). Several authors have initiated work on ILP systems that are not founded on -subsumption. <p> Similarly, arguments in B 2 are subterms of P 2 . Therefore, to infer the recursive clause R and the base clause B, CRUSTACEAN computes, for all the training examples, all the subterms. The base clause is then induced from the least general generalization (lgg) <ref> (Muggleton & Feng, 1990) </ref> of these subterms. The resulting embedding terms must contain the same generating term since the same recursive clause R is used in the proofs of the positive examples (i.e., except for those positive examples that are instantiations of the base clause). <p> In this case, the lists match. Step 4.1 then computes the matching lists' base clause from their subterms, which are shown below for this example. First example: (a,c) Second example: (b,x) A potential base clause is induced from these subterms by computing the least general generalization <ref> (Muggleton & Feng, 1990) </ref> of each argument. This match thus yields last of (A,B) as a potential base clause. Step 4.2 discards potential base clauses that resolve with any of the negative examples.
Reference: <author> Quinlan, J. R. </author> <year> (1991). </year> <title> Determinate literals in inductive logic programming. </title> <booktitle> In Proceedings of the Twelvth International Joint Conference on Artificial Intelligence (pp. </booktitle> <pages> 746-750). </pages> <address> Sydney, Australia: </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: It is generally believed that the -subsumption mechanism is the main source of difficulty in inducing recursive clauses in popular ILP systems (e.g., FOIL <ref> (Quinlan, 1991) </ref> and Golem (Muggleton & Feng, 1990)). Several authors have initiated work on ILP systems that are not founded on -subsumption.
Reference: <author> Robinson, J. A. </author> <year> (1965). </year> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 12, </volume> <pages> 23-41. </pages>
Reference: <author> Rouveirol, C., & Puget, J. F. </author> <year> (1990). </year> <title> Beyond inversion of resolution. </title> <booktitle> In Proceedings of the Seventh International Conference on Machine Learning (pp. </booktitle> <pages> 122-130). </pages> <note> Austin, TX: </note> <author> Morgan Kaufmann. </author> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: We believe that our approach is a practical method for inducing recursive clauses. The class of functions for which it is applicable is larger than it may seem at first glance since, unlike some other systems (e.g., IRES <ref> (Rouveirol, Puget 1990) </ref>), the literals are unflattened. When selecting the input examples, the user does not need to know the base clause, which is required by LOPSTER, or the recursive clause, which is required by practically all approaches based on - subsumption. Only a small number of examples are required.
References-found: 13

