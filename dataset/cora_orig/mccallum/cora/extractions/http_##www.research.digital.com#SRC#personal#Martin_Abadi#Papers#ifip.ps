URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/ifip.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Title: Decomposing Specifications of Concurrent Systems  
Author: Martin Abadi and Leslie Lamport 
Keyword: Keyword Codes: D.2.4, F.3.1 Keywords: Theory, Verification  
Address: 130 Lytton Avenue, Palo Alto, CA 94301, U.S.A.  
Affiliation: Systems Research Center, Digital Equipment Corporation  
Abstract: We introduce a simple method for specifying individual components of a concurrent system. The specification of the system is the conjunction of its components' specifications. We show how to prove properties of the system by reasoning about its components. Our approach is useful in substantial verification problems. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Martin Abadi and Leslie Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Under reasonable assumptions, such a refinement mapping exists when M l ) 999 999 x : c M is valid <ref> [1] </ref>. Composing two systems means constructing a universe in which they are both running. <p> Formally, this means that the closure of Init ^2 [N ] v ^L should be Init ^ 2 [N ] v . A pair of properties (P; L) is called machine closed iff C (P ^ L) equals P <ref> [1] </ref>. (We often say informally that P ^ L is machine closed.) Proposition 1 below, which is proved in [2], shows that we can use fairness properties to write machine-closed specifications.
Reference: 2. <author> Martin Abadi and Leslie Lamport. </author> <title> An old-fashioned recipe for real time. </title> <type> Research Report 91, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1992. </year> <title> An earlier version, without proofs, </title> <booktitle> appeared in [10, </booktitle> <pages> pages 1-27]. </pages>
Reference-contexts: A pair of properties (P; L) is called machine closed iff C (P ^ L) equals P [1]. (We often say informally that P ^ L is machine closed.) Proposition 1 below, which is proved in <ref> [2] </ref>, shows that we can use fairness properties to write machine-closed specifications.
Reference: 3. <author> Martin Abadi and Leslie Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <month> January </month> <year> 1993. </year>
Reference: 4. <author> Martin Abadi and Leslie Lamport. </author> <title> Conjoining specifications. </title> <note> To appear as an SRC Research Report, </note> <year> 1993. </year>
Reference-contexts: Our discussion is informal, because we wish to show that these issues are fundamental, not artifacts of a particular programming language or formalism. Section 3 covers the formal preliminaries, Section 4 investigates a method of writing specifications of components, and Section 5 gives the Decomposition Theorem. Proofs appear in <ref> [4] </ref>. 2. An Informal Overview A complete system is one that is self-contained; it may be observed, but it does not interact with the observer. A program is a complete system, provided we model inputs as being generated nondeterministically by the program itself.
Reference: 5. <author> Martin Abadi and Gordon Plotkin. </author> <title> A logical view of composition and refinement. </title> <journal> Theoretical Computer Science, </journal> <volume> 114(1) </volume> <pages> 3-30, </pages> <month> June </month> <year> 1993. </year>
Reference: 6. <author> S. Abramsky and R. Jagadeesan. </author> <title> Games and full completeness for multiplicative linear logic. </title> <type> Technical Report DoC 92/24, </type> <institution> Department of Computing, Imperial College of Science, Technology, and Medicine, </institution> <year> 1992. </year> <month> 14 </month>
Reference: 7. <author> Bowen Alpern and Fred B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21(4) </volume> <pages> 181-185, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: For convenience, we say that the empty sequence h i satisfies every formula. A safety property is a formula that is satisfied by an infinite behavior oe iff it is satisfied by every prefix of oe <ref> [7] </ref>. For any predicate Init , action N , and state function v, the formula Init ^ 2 [N ] v is a safety property.
Reference: 8. <author> Christian Berthet and Eduard Cerny. </author> <title> An algebraic model for asynchronous circuits verification. </title> <journal> IEEE Transactions On Computers, </journal> <volume> 37(7) </volume> <pages> 835-847, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: The general treatment of fairness and hiding distinguishes our approach from earlier ones for modular reasoning [3,5,9,15,16,18,19]. Moreover, this previous work is mainly concerned with composition of assumption/guarantee specifications, while our rules are crafted to facilitate decomposition of complete systems. An exception is the work of Berthet and Cerny <ref> [8] </ref>, who used decomposition in proving safety properties for finite-state automata. We have used our Decomposition Theorem with no difficulty on a few toy examples. However, we believe that its biggest payoff will be for systems that are too complex to verify easily by hand.
Reference: 9. <author> Pierre Collette. </author> <title> Application of the composition principle to Unity-like specifications. </title> <editor> In M.-C. Gaudel and J.-P. Jouannaud, editors, TAPSOFT'93: </editor> <booktitle> Theory and Practice of Software Development, volume 668 of Lecture Notes in Computer Science, </booktitle> <pages> pages 230-242, </pages> <address> Berlin, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference: 10. <editor> J. W. de Bakker, C. Huizing, W. P. de Roever, and G. Rozenberg, editors. </editor> <booktitle> Real-Time: Theory in Practice, volume 600 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year> <title> Proceedings of a REX Real-Time Workshop, held in The Nether-lands in June, </title> <year> 1991. </year>
Reference: 11. <author> R. P. Kurshan and Leslie Lamport. </author> <title> Verification of a multiplier: 64 bits and beyond. In Costas Courcoubetis, editor, Computer-Aided Verification, </title> <booktitle> volume 697 of Lecture Notes in Computer Science, </booktitle> <pages> pages 166-179, </pages> <address> Berlin, </address> <month> June </month> <year> 1993. </year> <title> Springer-Verlag. </title> <booktitle> Proceedings of the Fifth International Conference, </booktitle> <address> CAV'93. </address>
Reference-contexts: It reduces the verification of a complex, low-level system to proving properties of a higher-level specification and properties of one low-level component at a time. Decomposing proofs in this way allows us to apply decision procedures to verifications that hitherto required completely hand-guided proofs <ref> [11] </ref>. In the next section, we examine the issues that arise in decomposition. Our discussion is informal, because we wish to show that these issues are fundamental, not artifacts of a particular programming language or formalism. <p> The General Decomposition Theorem has been applied to the verification of an induc tively defined multiplier circuit <ref> [11] </ref>. 13 It can be shown that both versions of our decomposition theorem provide complete rules for verifying that one composition implies another. However, this result is of no significance. <p> This approach is currently being pursued in one substantial example: the mechanical verification of a multiplier circuit using a combination of TLA reasoning and mechanical verification with COSPAN <ref> [11] </ref>. Because it eliminates reasoning about the complete low-level system, the Decomposition Theorem is the key to this division of labor.
Reference: 12. <author> Leslie Lamport. </author> <title> What good is temporal logic? In R. </title> <editor> E. A. Mason, editor, </editor> <booktitle> Information Processing 83: Proceedings of the IFIP 9th World Congress, </booktitle> <pages> pages 657-668, </pages> <address> Paris, </address> <month> September </month> <year> 1983. </year> <title> IFIP, </title> <publisher> North-Holland. </publisher>
Reference-contexts: The idea of representing concurrent programs and their specifications as formulas in a temporal logic was first proposed by Pnueli [17]. It was later observed that, if specifications allow "stuttering" steps that leave the state unchanged, then S l ) S h asserts that S l implements S h <ref> [12] </ref>. Hence, proving that a lower-level specification implements a higher-level one was reduced to proving a formula in the logic.
Reference: 13. <author> Leslie Lamport. </author> <title> A simple approach to specifying concurrent systems. </title> <journal> Communications of the ACM, </journal> <volume> 32(1) </volume> <pages> 32-45, </pages> <month> January </month> <year> 1989. </year>
Reference: 14. <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <type> Research Report 79, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> December </month> <year> 1991. </year> <note> To appear in Transactions on Programming Languages and Systems. </note>
Reference-contexts: It does not require a conventional programming language for describing systems. We find it most convenient to regard programs and circuit descriptions as low-level specifications, and to represent them in the same logic used for higher-level specifications. The logic we use is TLA, the Temporal Logic of Actions <ref> [14] </ref>. We do not discuss here the important problem of translating from a low-level TLA specification to an implementation in a conventional language. The idea of representing concurrent programs and their specifications as formulas in a temporal logic was first proposed by Pnueli [17]. <p> The formula M l ) M is proved by applying a handful of simple rules <ref> [14] </ref>.
Reference: 15. <author> Jayadev Misra and K. Mani Chandy. </author> <title> Proofs of networks of processes. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-7(4):417-426, </volume> <month> July </month> <year> 1981. </year>
Reference: 16. <author> Paritosh K. Pandya and Mathai Joseph. </author> <title> P-A logic|a compositional proof system for distributed programs. </title> <journal> Distributed Computing, </journal> <volume> 5(1) </volume> <pages> 37-54, </pages> <year> 1991. </year>
Reference: 17. <author> Amir Pnueli. </author> <title> The temporal semantics of concurrent programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 45-80, </pages> <year> 1981. </year>
Reference-contexts: We do not discuss here the important problem of translating from a low-level TLA specification to an implementation in a conventional language. The idea of representing concurrent programs and their specifications as formulas in a temporal logic was first proposed by Pnueli <ref> [17] </ref>. It was later observed that, if specifications allow "stuttering" steps that leave the state unchanged, then S l ) S h asserts that S l implements S h [12]. Hence, proving that a lower-level specification implements a higher-level one was reduced to proving a formula in the logic.
Reference: 18. <author> Amir Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. </title> <editor> In Krzysztof R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, NATO ASI Series, </booktitle> <pages> pages 123-144. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1984. </year>
Reference: 19. <author> Eugene W. Stark. </author> <title> A proof technique for rely/guarantee properties. </title> <editor> In S. N. Ma-heshwari, editor, </editor> <booktitle> Foundations of Software Technology and Theoretical Computer Science, volume 206 of Lecture Notes in Computer Science, </booktitle> <pages> pages 369-391, </pages> <address> Berlin, 1985. </address> <publisher> Springer-Verlag. </publisher>
Reference: 20. <author> Pamela Zave and Michael Jackson. </author> <note> Conjunction as composition. Submitted for publication, </note> <month> June </month> <year> 1992. </year>
References-found: 20

