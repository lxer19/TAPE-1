URL: http://www.cis.ohio-state.edu/~neelam/papers/df.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~neelam/papers/research.html
Root-URL: 
Email: e-mail: neelam@cis.ohio-state.edu  
Phone: Tel: (614) 292 1444;  
Title: Documenting Framework Behavior  
Author: Neelam Soundarajan 
Keyword: Categories: D.1.5 [Object-oriented programming], D.2.1 [Requirements/Specifications]. General Terms: Design, Documentation Additional Key Words and Phrases: Specifying object oriented framework behavior, Invariants over traces of method calls.  
Address: Columbus, OH 43210, USA.  
Affiliation: Computer and Information Science Ohio State University,  
Abstract: Object-Oriented frameworks must be equipped with appropriate documentation; otherwise application developers will be forced to go through the code of the framework they are using in order to see how to use it, thereby minimizing the advantages of frameworks. We point out the need for a new approach to the specification of the behavior of frameworks, outline a possible approach, and briefly consider how an application developer can combine a framework specification of the type proposed with appropriate information about the code he supplies to arrive at a specification of his particular application. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R.H. Campbell and N. Islam. </author> <title> A technique for documenting the framework of an object-oriented system. </title> <booktitle> Computing Systems, </booktitle> <address> 6:363389, </address> <year> 1993. </year>
Reference-contexts: Here we expect to use ideas that have worked in compositional systems for reasoning about distributed programs, see for example [8, 11], since these also use traces similar to the one that our framework specification uses. We conclude by relating our approach with some earlier work. Campbell and Islam <ref> [1] </ref> consider the documentation of frameworks; they focus on what might be called structural questions, such as identifying which objects are related to which other objects in the system, specifying constraints on (instances of) which classes may be combined with (instances of) which other classes, etc., whereas our focus has been <p> For complete documentation we must however deal with both types of questions, and we plan to investigate ways to extend our approach to deal with the type of questions that <ref> [1] </ref> considers. Helm et al [4] introduce the notion of contracts to capture important aspects of the interactions between objects in a system. A contract imposes conditions on what calls to certain (virtual) methods must do and under what conditions, whereas we do not impose such constraints.
Reference: [2] <author> M.E. Fayad and D.C. Schmidt. </author> <title> Special issue on object oriented application frameworks. </title> <journal> CACM, </journal> <volume> 40, </volume> <month> October </month> <year> 1997. </year>
Reference-contexts: 1. Motivation Object-Oriented Frameworks can dramatically reduce the time and effort needed to develop complete applications, with the application developer just providing code for the virtual methods 1 <ref> [2] </ref>. But unless the framework is equipped with appropriate documentation, the application developer will be forced to go through its code in order to see how to use it, thereby substantially negating the advantages of frameworks.
Reference: [3] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design patterns: Elements of reusable OO software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Nevertheless, we believe it would be useful to allow some key constraints to be imposed, and we plan to investigate ways to do so in our approach. Pal [9] argues that the design guidelines provided by specific design patterns <ref> [3] </ref> should be imposed by the system as requirements on the developer rather than being just guidelines, in the same manner that an OO language requires an application developer using a framework to stay within the structure imposed by the framework.
Reference: [4] <author> R. Helm, I. Holland, and D. Gangopadhyay. </author> <title> Contracts: Specifying behavioral compositions in object-oriented systems. </title> <booktitle> In OOPSLA-ECOOP, </booktitle> <pages> pages 169180, </pages> <year> 1990. </year>
Reference-contexts: For complete documentation we must however deal with both types of questions, and we plan to investigate ways to extend our approach to deal with the type of questions that [1] considers. Helm et al <ref> [4] </ref> introduce the notion of contracts to capture important aspects of the interactions between objects in a system. A contract imposes conditions on what calls to certain (virtual) methods must do and under what conditions, whereas we do not impose such constraints. <p> It is also not clear, in the system of <ref> [4] </ref>, how to combine the specific behaviors implemented by the virtual functions as defined in a specific application with the specification of the framework to obtain the behavior of the complete application.
Reference: [5] <author> C. Horstmann. </author> <title> Mastering Object-Oriented Design in C++. </title> <publisher> Wiley, </publisher> <year> 1995. </year>
Reference-contexts: that all our virtual functions are pure. 4 If for some A i we did not have any concrete classes, we would have another framework rather than an application but one that would be more concrete than F. 5 Standard frameworks, at least simple ones, such as the diagramEditor of <ref> [5] </ref> fit this model quite well, with some minor changes such as in the names of classes. 2 virtual function invocations and, in the invariant I F , the relation between the behavior of F and that implemented by the virtual functions.
Reference: [6] <author> B. Liskov and J. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM TOPLAS, </journal> <volume> 16:18111841, </volume> <year> 1994. </year>
Reference-contexts: But unless the framework is equipped with appropriate documentation, the application developer will be forced to go through its code in order to see how to use it, thereby substantially negating the advantages of frameworks. Standard approaches such as those of <ref> [6, 7] </ref> that are used for specifying the behavior of `normal' OO programs are not well suited for documenting the behavior of frameworks. The problem is that these approaches tend to downplay the contribution of virtual functions to overall system behavior.
Reference: [7] <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: But unless the framework is equipped with appropriate documentation, the application developer will be forced to go through its code in order to see how to use it, thereby substantially negating the advantages of frameworks. Standard approaches such as those of <ref> [6, 7] </ref> that are used for specifying the behavior of `normal' OO programs are not well suited for documenting the behavior of frameworks. The problem is that these approaches tend to downplay the contribution of virtual functions to overall system behavior.
Reference: [8] <author> J. Misra and K. Chandy. </author> <title> Proofs of networks of processes. </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> 7:417426, </volume> <year> 1981. </year>
Reference-contexts: Finally, we need to deal with the question of how to compose the specifications of two frameworks to obtain the specification of the composed framework. Here we expect to use ideas that have worked in compositional systems for reasoning about distributed programs, see for example <ref> [8, 11] </ref>, since these also use traces similar to the one that our framework specification uses. We conclude by relating our approach with some earlier work.
Reference: [9] <author> P. Pal. </author> <title> Law governed support for realizing design patterns. </title> <booktitle> In Proc. of TOOLS 17, </booktitle> <pages> pages 2534, </pages> <year> 1995. </year>
Reference-contexts: Nevertheless, we believe it would be useful to allow some key constraints to be imposed, and we plan to investigate ways to do so in our approach. Pal <ref> [9] </ref> argues that the design guidelines provided by specific design patterns [3] should be imposed by the system as requirements on the developer rather than being just guidelines, in the same manner that an OO language requires an application developer using a framework to stay within the structure imposed by the
Reference: [10] <author> N. Soundarajan. </author> <title> Understanding frameworks, </title> <type> technical report, </type> <note> available at www.cis. ohio-state.edu/~neelam, </note> <year> 1997. </year>
Reference-contexts: Much work remains to be done to make our approach usable for realistic frameworks. First we need to apply our approach to some simple frameworks, and applications developed using them, to see how difficult the task is in practice; for a first attempt at this, see <ref> [10] </ref>. Second, we must generalize the model to allow more realistic frameworks; we believe that the the basic ideas will generalize easily although the specification of more complex frameworks will inevitably be more complex than those of frameworks that fit the simple model described here.
Reference: [11] <author> N. Soundarajan. </author> <title> Axiomatic semantics of csp. </title> <journal> ACM TOPLAS, </journal> <volume> 6:647662, </volume> <year> 1984. </year>
Reference-contexts: Finally, we need to deal with the question of how to compose the specifications of two frameworks to obtain the specification of the composed framework. Here we expect to use ideas that have worked in compositional systems for reasoning about distributed programs, see for example <ref> [8, 11] </ref>, since these also use traces similar to the one that our framework specification uses. We conclude by relating our approach with some earlier work.
Reference: [12] <author> N. Soundarajan and S. Fridella. </author> <title> Inheriting and modifying behavior. </title> <editor> In Meyer Ege, Singh, editor, </editor> <booktitle> Proceedings of TOOLS '97, </booktitle> <pages> pages 148163. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1997. </year>
Reference-contexts: first introduce a simple model of frameworks: A framework F consists of a concrete 3 1 For concreteness we use C++ terminology but the approach is not language specific; further, we use the terms `method' and `function' interchangeably. 2 For ways of dealing with limited versions of this problem see <ref> [13, 12] </ref>. 3 A class is concrete if it has no virtual functions, abstract if it has one or more pure virtual functions; for simplicity 1 controller class C, zero or more other concrete classes C 1 ; : : : ; C m , and one or more abstract classes
Reference: [13] <author> R. Stata and J.V. Guttag. </author> <title> Modular reasoning in the presence of subclassing. </title> <booktitle> In OOPSLA, pages 200214. </booktitle> <publisher> ACM Press, </publisher> <year> 1995. </year> <month> 4 </month>
Reference-contexts: first introduce a simple model of frameworks: A framework F consists of a concrete 3 1 For concreteness we use C++ terminology but the approach is not language specific; further, we use the terms `method' and `function' interchangeably. 2 For ways of dealing with limited versions of this problem see <ref> [13, 12] </ref>. 3 A class is concrete if it has no virtual functions, abstract if it has one or more pure virtual functions; for simplicity 1 controller class C, zero or more other concrete classes C 1 ; : : : ; C m , and one or more abstract classes
References-found: 13

