URL: ftp://ftp.cis.ohio-state.edu/pub/anish/papers/ft-syn-podc.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~anish/pub.html
Root-URL: 
Email: anish@cis.ohio-state.edu  attie@fiu.edu  emerson@cs.utexas.edu  
Title: Synthesis of Fault-Tolerant Concurrent Programs (Extended Abstract)  
Author: Anish ARORA Paul C. ATTIE E. Allen EMERSON 
Address: Austin  
Affiliation: Department of Computer Science The Ohio State University  School of Computer Science Florida International University  Department of Computer Sciences The University of Texas at  
Abstract: Methods for mechanically synthesizing concurrent programs from temporal logic specifications obviate the need to manually construct a program and compose a proof of its correctness [EC82, MW84, PR89, PR89b, AM94]. A serious drawback of extant synthesis methods, however, is that they produce concurrent programs for models of computation that are often unrealistic. In particular, these methods assume completely fault-free operation, i.e., the programs they produce are fault-intolerant. In this paper, we show how to mechanically synthesize fault-tolerant concurrent programs for various fault classes. We illustrate our method by synthesizing fault-tolerant solutions to the mutual exclusion and barrier synchronization problems. 
Abstract-found: 1
Intro-found: 1
Reference: [AE98] <author> P.C. Attie and E.A. Emerson, </author> <title> "Synthesis of concurrent systems with many similar processes," </title> <journal> ACM TOPLAS, </journal> <volume> 20(1): </volume> <month> 51-115 </month> <year> (1998). </year>
Reference-contexts: One potential difficulty with our method is the state explosion problem|the number of states in a structure usually increases exponentially with the number of processes, thereby restricting the applicability of synthesis methods based on state enumeration to small systems. In <ref> [AE98] </ref>, a method is proposed of overcoming the state explosion problem by considering the interaction of processes pairwise. The exponentially large global product of all the processes in the system is never constructed. <p> Using the synthesis method given here instead of the [EC82] method, we can construct these "two-process structures," which will now incorporate fault-tolerant behavior. We then plan to extend the synthesis method of <ref> [AE98] </ref> to take these structures as input and produce fault tolerant programs of arbitrary size. We plan to integrate our method with the synthesis method of [AE96] for synthesizing atomic read/write programs.
Reference: [AE96] <author> P.C. Attie and E.A. Emerson, </author> <title> "Synthesis of concurrent systems for an atomic read / atomic write model of computation (extended abstract)," </title> <booktitle> Proc. 15'th ACM PODC, </booktitle> <address> Philadelphia, </address> <month> May </month> <year> 1996, </year> <pages> 111-120. </pages>
Reference-contexts: We then plan to extend the synthesis method of [AE98] to take these structures as input and produce fault tolerant programs of arbitrary size. We plan to integrate our method with the synthesis method of <ref> [AE96] </ref> for synthesizing atomic read/write programs. A possible approach is to first synthesize the fault-tolerant program, and then use the [AE96] method to refine it to an atomic read/write program. We are also currently extending our method to deal with byzantine failure. <p> We plan to integrate our method with the synthesis method of <ref> [AE96] </ref> for synthesizing atomic read/write programs. A possible approach is to first synthesize the fault-tolerant program, and then use the [AE96] method to refine it to an atomic read/write program. We are also currently extending our method to deal with byzantine failure.
Reference: [AG93] <author> A. Arora and M. G. Gouda, </author> <title> "Closure and convergence: a foundation of fault-tolerant computing," </title> <journal> IEEE TSE, </journal> <month> 19(11): 1015-1027 </month> <year> (1993). </year>
Reference-contexts: Towards developing a uniform and general method for fault-tolerant concurrent program synthesis that accommodates these various categories of faults, we recall a uniform and general representation of faults (cf. <ref> [AG93] </ref>). In this representation, faults are modeled as actions (guarded commands) whose execution perturbs the program state. Consider for example a fault that corrupts the state of a wire. <p> This assumption must be made by any method that guarantees fail-safe tolerance only.) Just as our representation of faults is general enough to capture extant fault-classes, our definition of tolerance properties is general enough to capture the fault-tolerance requirements of extant computing systems. (The interested reader is referred to <ref> [AG93] </ref> for a detailed discussion of how these tolerance properties suffice for fault-tolerance in distributed systems, networks, circuits, database management, etc.) To mention but a few examples, systems based on consensus, agreement, voting, or commitment require masking tolerance|or at least failsafe tolerance|whereas those based on reset, checkpointing/recovery, or exception handling typically <p> Also shown is the process P 1 extracted from the model (again P 2 is omitted and can be obtained from P 1 by interchanging process indices 1 and 2). Note that the tolerance of the extracted program is a special case of non-masking, namely self-stabilizing <ref> [AG93] </ref>.
Reference: [AG94] <author> A. Arora and M. G. Gouda, </author> <title> "Distributed reset," </title> <journal> IEEE TOC , 43(9): </journal> <month> 1026-1038 </month> <year> (1994). </year>
Reference: [AK98] <author> A. Arora and S. Kulkarni, </author> <title> "Component based design of multitolerance," </title> <journal> IEEE TSE 24(1): </journal> <pages> 63-78. </pages>
Reference-contexts: program may reach arbitrary global states [JV96]; thus, general state failures effectively corrupt global state in an undetectable, correctable, and transient manner. 2.4 Fault-Tolerance Properties A tolerance property that a concurrent program satisfies in the presence of a class of faults may be categorized as masking, nonmasking, or fail-safe tolerance <ref> [AK98] </ref>. Intuitively, this classification is based upon how the problem specification is met in the presence of faults. Let P be a concurrent program that satisfies a problem specification spec = initspec ^ AG (globalspec) and let F be a set of fault actions.
Reference: [AM94] <author> A. Anuchitanukul and Z. Manna, </author> <title> "Realizability and synthesis of reactive modules," </title> <booktitle> CAV 94, </booktitle> <publisher> Springer LNCS 818, </publisher> <pages> 156-169. </pages>
Reference-contexts: The environment however, cannot modify the internal state of the module, and so this framework cannot model faults. The synthesis method of <ref> [AM94] </ref> overcomes this limitation; the environment and module take turns in selecting the next global state, according to some schedule.
Reference: [Dij76] <author> E.W. Dijkstra, </author> <title> A discipline of programming, </title> <publisher> Prentice-Hall Inc., </publisher> <year> 1976. </year>
Reference-contexts: each process P i is a directed graph where each node is labeled by a unique name (s i ), and each arc is labeled with an action B ! A consisting of an enabling condition (i.e., guard) B and corresponding statement A to be performed (i.e., a guarded command <ref> [Dij76] </ref>).
Reference: [Em81] <author> E.A. Emerson, </author> <title> "Branching time temporal logic and the design of correct concurrent programs," </title> <publisher> Ph. </publisher> <address> D. </address> <institution> dissertation, Division of Applied Sciences, Harvard University, </institution> <year> 1981. </year>
Reference-contexts: The successor labeled with g certifies that the eventuality AFg is fulfilled, while the successor labeled with AXAFg propagates AFg. On the other hand, AGg g ^ AXAGg, and so AGg generates only one successor, labeled with both g and AXAGg. The reader is referred to <ref> [Em81, EC82] </ref> for full details, where it is shown that this tree-construction process terminates. The final set of frontier nodes of the tree is taken to be the AND-node successors of d, and is denoted Blocks (d).
Reference: [EC82] <author> E.A. Emerson and E.M. Clarke, </author> <title> "Using branching time temporal logic to synthesize synchronization skeletons," </title> <booktitle> Science of Computer Programming 2 (1982) 241-266. </booktitle>
Reference-contexts: 1 Introduction Methods for synthesizing concurrent programs from temporal logic specifications based on the use of a decision procedure for testing temporal satisfiability have been proposed by Emerson and Clarke <ref> [EC82] </ref> and Manna and Wolper [MW84]. An important advantage of these synthesis methods is that they obviate the need to manually compose a program and manually construct a proof of its correctness. One only has to formulate a precise problem specification; the synthesis method then mechanically constructs a correct solution. <p> This approach suggests a two-stage synthesis method, where an intolerant program is synthesized in the first stage (based on the method of <ref> [EC82] </ref>) and then transformed in the second stage so that its behavior in the presence of faults is as desired. The first stage applies the method of [EC82] to obtain a model for the problem specification (from which an intolerant program could be synthesized). <p> This approach suggests a two-stage synthesis method, where an intolerant program is synthesized in the first stage (based on the method of <ref> [EC82] </ref>) and then transformed in the second stage so that its behavior in the presence of faults is as desired. The first stage applies the method of [EC82] to obtain a model for the problem specification (from which an intolerant program could be synthesized). The second stage models the presence of faults by adding fault-transitions to this model. These fault-transitions result in new, previously unreachable, states being added. <p> The second stage models the presence of faults by adding fault-transitions to this model. These fault-transitions result in new, previously unreachable, states being added. We synthesize recovery-transitions from these perturbed states by applying the <ref> [EC82] </ref> synthesis method in each such state to generate the recovery transitions from that state. Our method has the same order of complexity as the [EC82] synthesis method, i.e., exponential time in the size of the problem description. <p> These fault-transitions result in new, previously unreachable, states being added. We synthesize recovery-transitions from these perturbed states by applying the <ref> [EC82] </ref> synthesis method in each such state to generate the recovery transitions from that state. Our method has the same order of complexity as the [EC82] synthesis method, i.e., exponential time in the size of the problem description. We illustrate our method by synthesizing fault-tolerant solutions for the mutual exclusion and barrier synchronization problems. <p> The paper is organized as follows. Section 2 defines the model of computation, the specification language, and the fault models and fault-tolerance properties that we consider. It also provides an overview of the <ref> [EC82] </ref> synthesis method. Section 3 formally defines the synthesis problem for fault-tolerant concurrent programs. Section 4 presents our synthesis method, along with correctness results. Section 5 presents two examples: mutual exclusion and barrier synchronization, along with an illustration of an impossibility result. Section 6 discusses related work. <p> This is essential, since only propositional temporal logics enjoy the finite model property, which is the underlying basis of the synthesis method of <ref> [EC82] </ref> that this paper builds upon. We assume, in the sequel, that specifications are expressed in the form initspec^AG (globalspec), where initspec contains only atomic propositions and boolean operators. initspec specifies the initial state, and globalspec specifies correctness properties that are required to hold at all reachable states. <p> tolerance properties suffice for fault-tolerance in distributed systems, networks, circuits, database management, etc.) To mention but a few examples, systems based on consensus, agreement, voting, or commitment require masking tolerance|or at least failsafe tolerance|whereas those based on reset, checkpointing/recovery, or exception handling typically require nonmasking tolerance. 2.5 Overview of the <ref> [EC82] </ref> Synthesis Method The section summarizes the synthesis method of [EC82], upon which we build. This method constructs a tableau, which is a finite directed bipartite AND-OR graph. <p> database management, etc.) To mention but a few examples, systems based on consensus, agreement, voting, or commitment require masking tolerance|or at least failsafe tolerance|whereas those based on reset, checkpointing/recovery, or exception handling typically require nonmasking tolerance. 2.5 Overview of the <ref> [EC82] </ref> Synthesis Method The section summarizes the synthesis method of [EC82], upon which we build. This method constructs a tableau, which is a finite directed bipartite AND-OR graph. <p> The successor labeled with g certifies that the eventuality AFg is fulfilled, while the successor labeled with AXAFg propagates AFg. On the other hand, AGg g ^ AXAGg, and so AGg generates only one successor, labeled with both g and AXAGg. The reader is referred to <ref> [Em81, EC82] </ref> for full details, where it is shown that this tree-construction process terminates. The final set of frontier nodes of the tree is taken to be the AND-node successors of d, and is denoted Blocks (d). <p> These AND-node successors can be regarded as embodying all of the different ways in which the (conjunction of the) formulae in the label of d can be satisfied. The <ref> [EC82] </ref> method starts with a single OR-node labeled with the program specification, and repeatedly constructs successors of "frontier" nodes until there is no more change. <p> synthesize a concurrent program that (1) satisfies initspec ^ AG (globalspec) in the absence of faults, and (2) satisfies AG (couplingspec) in the presence of faults, and (3) is TOL-tolerant to F for initspec ^ AG (globalspec). 4 The Synthesis Method We first apply the tableau generation step of the <ref> [EC82] </ref> method outlined above to generate the tableau for g = initspec ^ AG (globalspec) ^ AG (couplingspec). We then repeatedly apply the fault actions to the tableau, thereby generating perturbed states and fault-transitions. The perturbed states thus generated will have no successors in the tableau. <p> We then repeatedly apply the fault actions to the tableau, thereby generating perturbed states and fault-transitions. The perturbed states thus generated will have no successors in the tableau. For a given perturbed state d, we generate successors for d by considering d to be an OR-node and applying the <ref> [EC82] </ref> tableau-generation step outlined above, taking d to be the "root." If during this process a state is generated that has an identical label to an already occurring state, then the two states are identified. <p> This process must eventually terminate, as the number of possible perturbed states is finite. Finally, we apply a set of modified 6 deletion rules. From the resulting tableau, a model can be extracted by "unraveling," as in the <ref> [EC82] </ref> method, except that for every AND-node in a FRAG, we add all the perturbed states directly reached by executing a single fault-action. Finally, we extract the fault-tolerant program by projecting onto the individual process indices. procedure for expanding perturbed states. 6 To take fault-transitions into account. 1. <p> Finally, we extract the fault-tolerant program by projecting onto the individual process indices. procedure for expanding perturbed states. 6 To take fault-transitions into account. 1. Apply the tableau-based CTL decision procedure of <ref> [EC82] </ref> to the CTL formula g = initspec ^ AG (globalspec) ^ AG (couplingspec). Let T 0 = (d 0 ; V 0 D ; A 0 DC ; L 0 ) be the resulting tableau. Mark all nodes in V 0 C ; V 0 D as expanded. 2. <p> Otherwise, let T F be the result of applying the deletion rules to T N and then removing all unreachable nodes. Extract a model M F from T F as follows. (a) For each AND-node c in T F i. Construct FRAG [c] as in <ref> [EC82] </ref>, i.e., ignore all fault-transitions. ii. FRAG F [c] := FRAG [c] [ FaultTrans (F ,TOL,V ), where V is the set of AND-nodes in FRAG [c]. (b) Construct M F = (s 0 ; S; R; R F ; L) as in [EC82] but use FRAG F 's instead of <p> Construct FRAG [c] as in <ref> [EC82] </ref>, i.e., ignore all fault-transitions. ii. FRAG F [c] := FRAG [c] [ FaultTrans (F ,TOL,V ), where V is the set of AND-nodes in FRAG [c]. (b) Construct M F = (s 0 ; S; R; R F ; L) as in [EC82] but use FRAG F 's instead of FRAG's. (c) Introduce shared variables into M F to distinguish propositionally identical states (as in [EC82]). 4. Extract the fault-tolerant program from M F by pro jecting onto the individual process indices. <p> ), where V is the set of AND-nodes in FRAG [c]. (b) Construct M F = (s 0 ; S; R; R F ; L) as in <ref> [EC82] </ref> but use FRAG F 's instead of FRAG's. (c) Introduce shared variables into M F to distinguish propositionally identical states (as in [EC82]). 4. Extract the fault-tolerant program from M F by pro jecting onto the individual process indices. Finally, we give the following technical definitions. c ! d iff c (f:guard) = true and L (d) = f:body (L (c)"AP) [ Label TOL (spec) for fault action f . <p> Node e is the unique node from which all other nodes are reachable, 7 This is where our deletion rules differ from those of <ref> [EC82] </ref>. 2. For every AND-node c in D, if c has any sons in D, then every non-fault successor of c in T N is a son of c in D, 3. <p> The portion of the Kripke structure above the dark horizontal line is the model for the mutual exclusion specification that is produced by the CTL decision procedure of <ref> [EC82] </ref> (and from which a fault-intolerant program could be extracted). The entire Kripke structure is the final model produced by our synthesis method. For clarity, only the fault-/recovery-transitions corresponding to the failure of P 1 followed by the failure of P 2 , are shown. <p> Finally, the type of fault-tolerance we require is non-masking. method for this problem. (The model for the barrier synchronization specification that is produced by the synthesis method of <ref> [EC82] </ref> is obtained by removing the four perturbed states and all incident transitions.) For clarity, the fault-transitions are omitted. Also shown is the process P 1 extracted from the model (again P 2 is omitted and can be obtained from P 1 by interchanging process indices 1 and 2). <p> In [AE98], a method is proposed of overcoming the state explosion problem by considering the interaction of processes pairwise. The exponentially large global product of all the processes in the system is never constructed. Instead, using the CTL synthesis method of <ref> [EC82] </ref>, small Kripke structures depicting the product of two processes are constructed and used as the basis for synthesis of programs with arbitrarily many processes. Using the synthesis method given here instead of the [EC82] method, we can construct these "two-process structures," which will now incorporate fault-tolerant behavior. <p> Instead, using the CTL synthesis method of <ref> [EC82] </ref>, small Kripke structures depicting the product of two processes are constructed and used as the basis for synthesis of programs with arbitrarily many processes. Using the synthesis method given here instead of the [EC82] method, we can construct these "two-process structures," which will now incorporate fault-tolerant behavior. We then plan to extend the synthesis method of [AE98] to take these structures as input and produce fault tolerant programs of arbitrary size.
Reference: [EL85] <author> E.A. Emerson and C.L.Lei, </author> <title> "Modalities for model checking: branching time strikes back," </title> <booktitle> 12'th ACM POPL. </booktitle>
Reference-contexts: An example CTL specification is that for the two process mutual exclusion problem (here i 2 f1; 2g): 4 The idea of relativized satisfaction comes from <ref> [EL85] </ref> where it is used to handle fairness in CTL model checking. (0) Initial State (both processes are initially in their Non--critical region): N 1 ^ N 2 (1) It is always the case that any move P i makes from its Noncritical region is into its Trying region and such
Reference: [EMSS93] <author> E.A. Emerson, A.K. Mok, A.P. Sistla, and J. Srini-vasan, </author> <title> "Quantitative temporal reasoning," Real Time Systems Journal 2: </title> <month> 331-352 (January </month> <year> 1993). </year>
Reference: [JV96] <author> M. Jayaram and G. Varghese, </author> <title> "Crash failures can drive protocols to arbitrary states," </title> <booktitle> Proc. 15'th ACM PODC. </booktitle>
Reference-contexts: As a result, the program may be placed in a state it would not have reached under normal computation of the processes. Such state failures are general in the sense that by a sequence of these faults the program may reach arbitrary global states <ref> [JV96] </ref>; thus, general state failures effectively corrupt global state in an undetectable, correctable, and transient manner. 2.4 Fault-Tolerance Properties A tolerance property that a concurrent program satisfies in the presence of a class of faults may be categorized as masking, nonmasking, or fail-safe tolerance [AK98].
Reference: [KV97] <author> O. Kupferman and M. Vardi, </author> <title> "Synthesis with incomplete information," </title> <address> ICTL 97. </address>
Reference-contexts: This objection to PLTL also applies to [PR89, PR89b], as well as [WD90] which solves essentially the same problem as [PR89, PR89b] but in a somewhat more general setting. Finally, <ref> [KV97] </ref> presents a synthesis algorithm for reactive modules and CTL/CTL fl specifications. Similarly to [PR89, PR89b], reactive modules communicate with the environment via input and output signals. 9 Since the environment cannot modify the internal state of the module, [KV97] is not directly applicable to the synthesis problem addressed in this <p> Finally, <ref> [KV97] </ref> presents a synthesis algorithm for reactive modules and CTL/CTL fl specifications. Similarly to [PR89, PR89b], reactive modules communicate with the environment via input and output signals. 9 Since the environment cannot modify the internal state of the module, [KV97] is not directly applicable to the synthesis problem addressed in this paper. Nevertheless, since it does deal with branching time temporal logic, it might be possible to adapt or generalize the approach to deal with faults. 9 There are also "unreadable inputs"|signals that the module cannot observe. <p> This compares favorably to the methods of [PR89, PR89b, WD90], all of which have double exponential time and space complexity in the size of the specification. The method of <ref> [KV97] </ref> also has single exponential time and space complexity. 8 Conclusions and Further Work We have presented a method for the synthesis of fault-tolerant programs from specifications expressed in temporal logic.
Reference: [MW84] <author> Z. Manna and P. Wolper, </author> <title> "Synthesis of communicating processes from temporal logic specifications," </title> <journal> ACM TOPLAS, </journal> <month> 6 </month> <year> (1984) </year> <month> 68-93. </month>
Reference-contexts: 1 Introduction Methods for synthesizing concurrent programs from temporal logic specifications based on the use of a decision procedure for testing temporal satisfiability have been proposed by Emerson and Clarke [EC82] and Manna and Wolper <ref> [MW84] </ref>. An important advantage of these synthesis methods is that they obviate the need to manually compose a program and manually construct a proof of its correctness. One only has to formulate a precise problem specification; the synthesis method then mechanically constructs a correct solution. <p> A serious drawback of these methods, however, is that they deal only with functional correctness properties. Nonfunctional properties such as fault-tolerance are not addressed. For example, the method of Manna and Wolper <ref> [MW84] </ref> produces CSP programs in which all communication takes place between a central synchronizer process and one of its satellite processes.
Reference: [Pe81] <author> G.L. Peterson, </author> <title> "Myths about the mutual exclusion problem," </title> <journal> IPL, </journal> <month> 12 </month> <year> (1981) </year> <month> 115-116. </month>
Reference: [PR89] <author> A. Pnueli and R. Rosner, </author> <title> "On the synthesis of a reactive module," </title> <booktitle> Proc. 16'th ACM POPL, </booktitle> <year> (1989). </year>
Reference-contexts: Hence our synthesis method provides a mechanical way of obtaining such impossibility results. 6 Related Work A fault model may be considered as a particular type of adversarial environment. There has been considerable work on synthesis of programs that interact with an adversarial environment (usually called reactive modules). <ref> [PR89, PR89b] </ref> synthesize reactive modules that interact with an environment via an input variable x (that only the environment can modify) and an output variable y (that only the module can modify). <p> This simply cannot be written in PLTL. It therefore appears that the existential path quantifier of branching time temporal logic is essential in specifying the future behavior of failed processes. This objection to PLTL also applies to <ref> [PR89, PR89b] </ref>, as well as [WD90] which solves essentially the same problem as [PR89, PR89b] but in a somewhat more general setting. Finally, [KV97] presents a synthesis algorithm for reactive modules and CTL/CTL fl specifications. Similarly to [PR89, PR89b], reactive modules communicate with the environment via input and output signals. 9 <p> It therefore appears that the existential path quantifier of branching time temporal logic is essential in specifying the future behavior of failed processes. This objection to PLTL also applies to <ref> [PR89, PR89b] </ref>, as well as [WD90] which solves essentially the same problem as [PR89, PR89b] but in a somewhat more general setting. Finally, [KV97] presents a synthesis algorithm for reactive modules and CTL/CTL fl specifications. Similarly to [PR89, PR89b], reactive modules communicate with the environment via input and output signals. 9 Since the environment cannot modify the internal state of the module, [KV97] is <p> This objection to PLTL also applies to <ref> [PR89, PR89b] </ref>, as well as [WD90] which solves essentially the same problem as [PR89, PR89b] but in a somewhat more general setting. Finally, [KV97] presents a synthesis algorithm for reactive modules and CTL/CTL fl specifications. Similarly to [PR89, PR89b], reactive modules communicate with the environment via input and output signals. 9 Since the environment cannot modify the internal state of the module, [KV97] is not directly applicable to the synthesis problem addressed in this paper. <p> This compares favorably to the methods of <ref> [PR89, PR89b, WD90] </ref>, all of which have double exponential time and space complexity in the size of the specification.
Reference: [PR89b] <author> A. Pnueli and R. Rosner, </author> <title> "On the synthesis of asynchronous reactive modules," </title> <booktitle> Proc. 16th ICALP, </booktitle> <publisher> Springer LNCS 372, </publisher> <year> (1989), </year> <pages> 652-671. </pages>
Reference-contexts: Hence our synthesis method provides a mechanical way of obtaining such impossibility results. 6 Related Work A fault model may be considered as a particular type of adversarial environment. There has been considerable work on synthesis of programs that interact with an adversarial environment (usually called reactive modules). <ref> [PR89, PR89b] </ref> synthesize reactive modules that interact with an environment via an input variable x (that only the environment can modify) and an output variable y (that only the module can modify). <p> This simply cannot be written in PLTL. It therefore appears that the existential path quantifier of branching time temporal logic is essential in specifying the future behavior of failed processes. This objection to PLTL also applies to <ref> [PR89, PR89b] </ref>, as well as [WD90] which solves essentially the same problem as [PR89, PR89b] but in a somewhat more general setting. Finally, [KV97] presents a synthesis algorithm for reactive modules and CTL/CTL fl specifications. Similarly to [PR89, PR89b], reactive modules communicate with the environment via input and output signals. 9 <p> It therefore appears that the existential path quantifier of branching time temporal logic is essential in specifying the future behavior of failed processes. This objection to PLTL also applies to <ref> [PR89, PR89b] </ref>, as well as [WD90] which solves essentially the same problem as [PR89, PR89b] but in a somewhat more general setting. Finally, [KV97] presents a synthesis algorithm for reactive modules and CTL/CTL fl specifications. Similarly to [PR89, PR89b], reactive modules communicate with the environment via input and output signals. 9 Since the environment cannot modify the internal state of the module, [KV97] is <p> This objection to PLTL also applies to <ref> [PR89, PR89b] </ref>, as well as [WD90] which solves essentially the same problem as [PR89, PR89b] but in a somewhat more general setting. Finally, [KV97] presents a synthesis algorithm for reactive modules and CTL/CTL fl specifications. Similarly to [PR89, PR89b], reactive modules communicate with the environment via input and output signals. 9 Since the environment cannot modify the internal state of the module, [KV97] is not directly applicable to the synthesis problem addressed in this paper. <p> This compares favorably to the methods of <ref> [PR89, PR89b, WD90] </ref>, all of which have double exponential time and space complexity in the size of the specification.
Reference: [Sc84] <author> F.B. Schneider, </author> <title> "Byzantine generals in action: implementing fail-stop processors," </title> <booktitle> ACM TOCS 2 (2): </booktitle> <pages> 145-154. </pages>
Reference-contexts: One class is fail-stop failures <ref> [Sc84, Sc90] </ref>: A fault in this class stops a process from executing any actions, possibly forever. Thus, fail-stop failures effectively corrupt program processes in a detectable, uncorrectable, and potentially permanent manner.
Reference: [Sc90] <author> F.B. Schneider, </author> <title> "Implementing fault-tolerant services using the state machine approach: a tutorial," </title> <journal> ACM Computing Surveys, </journal> <volume> 22 (4): </volume> <pages> 299-319. </pages>
Reference-contexts: One class is fail-stop failures <ref> [Sc84, Sc90] </ref>: A fault in this class stops a process from executing any actions, possibly forever. Thus, fail-stop failures effectively corrupt program processes in a detectable, uncorrectable, and potentially permanent manner.
Reference: [WD90] <author> H. Wong-Toi and D.L. Dill, </author> <title> "Synthesizing processes and schedulers from temporal specifications," </title> <booktitle> CAV 90, </booktitle> <publisher> Springer LNCS 531, </publisher> <pages> 272-281. </pages>
Reference-contexts: This simply cannot be written in PLTL. It therefore appears that the existential path quantifier of branching time temporal logic is essential in specifying the future behavior of failed processes. This objection to PLTL also applies to [PR89, PR89b], as well as <ref> [WD90] </ref> which solves essentially the same problem as [PR89, PR89b] but in a somewhat more general setting. Finally, [KV97] presents a synthesis algorithm for reactive modules and CTL/CTL fl specifications. <p> This compares favorably to the methods of <ref> [PR89, PR89b, WD90] </ref>, all of which have double exponential time and space complexity in the size of the specification.
References-found: 20

