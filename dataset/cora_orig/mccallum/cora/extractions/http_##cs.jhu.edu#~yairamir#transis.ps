URL: http://cs.jhu.edu/~yairamir/transis.ps
Refering-URL: http://cs.jhu.edu/~yairamir/
Root-URL: http://www.cs.jhu.edu
Title: The Transis Approach to High Availability Cluster Communication  
Author: Dalia Malki, Yair Amir, Danny Dolev, Shlomo Kramer 
Address: Jerusalem, Israel  
Affiliation: Institute of Computer Science The Hebrew University of Jerusalem  
Pubnum: Technical Report CS94-14  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Afic Inc. MSO: </author> <title> A Replicated Database. </title> <type> private communication, </type> <year> 1993. </year>
Reference-contexts: Various replicated information services are already in wide spread use, such as replicated file systems (e.g. [55, 42, 7, 61, 54, 39, 52]), and replicated databases (e.g. <ref> [1] </ref>). Increasing the availability through replication means that every replica performs all the updates to the information base, and any replica can provide up-to-date snapshots of the information. <p> We justify the Transis design "top down", i.e. starting from a class of distributed applications, we show services that can benefit the application developer. 3.1 Application Classes Active replication using the State Machine approach [53], is widely used in replicated information systems (e.g. Deceit [55], Afic <ref> [1] </ref>). In this method, the information base itself resides on multiple sites. The operations that modify the information (updates) are introduced to the sites in a consistent, global order.
Reference: [2] <author> O. Amir, Y. Amir, and D. Dolev. </author> <title> A Highly Available Application in the Transis Environment. In Proceedings of the Hardware and Software Architectures for Fault Tolerance Workshop, </title> <institution> at Le Mont Saint-Michel, France (LNCS 774), </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: This principle is guaranteed by the virtual synchrony programming model, and its extension to partitionable operation, see below (Section 4.1). The works of Keidar [35] and of Amir <ref> [2, 5] </ref> show how this principle can lead to an efficient merging-mechanism, that supports long term consistent replication. 3.5 Caveat We have manifested at the beginning of this section that communication protocols need to be tailored to various classes of application needs. <p> Transis is useful in providing the communication needs of these applications; the works of Amir and Keidar <ref> [2, 5, 35] </ref> show that the usage of Transis leads to simpler and more efficient design of sample applications. We have confidence that 12 in the future we shall see more works detailing the utilization of communication substrates such as Transis in the construction of high availability projects. <p> In this way, the membership service associates a membership-context with each message. The application can use this to perform consistent operations on received messages, and to merge the histories of joined components. For example, <ref> [2] </ref> describes a replicated mail server that exploits the Transis membership for efficiently implementing a partitionable service. 24 Intuitively, at the basis of our membership protocol, there are two stages: (1) suggest a new membership set, (2) wait for agreement from every machine in the set.
Reference: [3] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. </author> <title> Membership Algorithms for Multicast Communication Groups. </title> <booktitle> In 6th Intl. Workshop on Distributed Algorithms proceedings (WDAG-6), (LCNS, </booktitle> <volume> 647), </volume> <pages> pages 292-312, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: In periods of instability, the weak membership view might diverge at different processes. For purposes such as object replication, this membership is too weak. Therefore, [31] also provides the Strong and the Hybrid memberships for consistent replication. Two membership protocols that are closely related to our work are <ref> [3, 6] </ref>. In [3], we have introduced the concept of partitionable membership service, and extended the definition of virtual synchrony to such a service. [6] utilizes the principles of this membership protocol, and extends it to form a ring of machines with an initial token holder. <p> For purposes such as object replication, this membership is too weak. Therefore, [31] also provides the Strong and the Hybrid memberships for consistent replication. Two membership protocols that are closely related to our work are [3, 6]. In <ref> [3] </ref>, we have introduced the concept of partitionable membership service, and extended the definition of virtual synchrony to such a service. [6] utilizes the principles of this membership protocol, and extends it to form a ring of machines with an initial token holder. <p> Furthermore, we delay the delivery of messages when causal "holes" are created in order to make the acknowledgment mechanism concise. 2. We have built several novel protocols, incorporated within the core of the Transis system, that rely on causal ordering of messages <ref> [26, 3, 27] </ref>. These protocols utilize the causal structure for performing a completely distributed reasoning about the system 11 state. Without causal structure, similar protocols use a centralized source of agreement (e.g. [51]), and do not use knowledge of the history. <p> Transis contains a membership protocol that is integrated in the communication system, such that the notifications of membership changes are delivered to the application among the stream of regular messages <ref> [3, 27] </ref>. Changes to the membership are coordinated with the delivery of regular messages in the system. The problem of maintaining a consistent view of the reachable operational machines is fundamental in the design of distributed systems.
Reference: [4] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. Transis: </author> <title> A Communication Sub-System for High Availability. </title> <booktitle> In 22nd Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 76-84, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: The Trans and Total protocols [43] are genuinely distributed protocols for reliable mul-ticast, preserving causal and total order, respectively. The basic mechanism in Transis for causal reliable delivery of messages is based on the Trans protocol, with several important modifications that adapt it for practical use (see <ref> [4] </ref>). The Total protocol reaches agreement on the total order of messages among a majority of the processes in the systems. The protocol is prone to deadlock in rare situations (see proof in [36]). The Xamp protocol of [60] relies on special network hardware that orders messages.
Reference: [5] <author> Y. Amir, D. Dolev, P. Melliar-Smith, and L. Moser. </author> <title> Persistent Order Maintanence in a Partitioned Network. </title> <note> in preparation, </note> <year> 1994. </year>
Reference-contexts: Our approach to handling partitions is different. We incorporate partitions into the model, and provide the strictest semantics possible in face of partitions. The Transis approach is unique in allowing partitionable operation and in its support for consistent merging upon recovery. Further work done in the Transis project <ref> [35, 5] </ref> shows how the understanding of partitionable operation can lead to the development of algorithms that provide long term guarantees despite failures, avoid the end-to-end acknowledgment needs, and come up with algorithms for long term replication that are more fault tolerant than prior work. <p> Using this service, end-to-end acknowledgment is needed only upon a membership change event such as processor crash, processor recovery, network partition and/or network merge (details on this can be found in <ref> [5] </ref>). At first glance, it appears that a reliable (and moreover ordered, as we see below) multi-cast service would be an "overkill" for the distributed display application, because it needs the most recent snapshot of each object, and not the entire history of changes to the object. <p> This principle is guaranteed by the virtual synchrony programming model, and its extension to partitionable operation, see below (Section 4.1). The works of Keidar [35] and of Amir <ref> [2, 5] </ref> show how this principle can lead to an efficient merging-mechanism, that supports long term consistent replication. 3.5 Caveat We have manifested at the beginning of this section that communication protocols need to be tailored to various classes of application needs. <p> Transis is useful in providing the communication needs of these applications; the works of Amir and Keidar <ref> [2, 5, 35] </ref> show that the usage of Transis leads to simpler and more efficient design of sample applications. We have confidence that 12 in the future we shall see more works detailing the utilization of communication substrates such as Transis in the construction of high availability projects.
Reference: [6] <author> Y. Amir, L. E. Moser, P. M. Melliar-Smith, D. A. Agarwal, and P. Ciarfella. </author> <title> Fast Message Ordering and Membership Using a Logical Token-Passing Ring. </title> <booktitle> In Intl. Conference on Distributed Computing Systems, </booktitle> <pages> pages 551-560, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Ethernet, for example, supports both broadcast and multicast, and the Deering multicast extensions to IP [25] extend IP to support multicast at the Unix Ethernet drivers' level. Similarly, the emerging ATM standard will support multicast dissemination at the network level. 3 exploit hardware multicast where available <ref> [6, 34, 58, 16] </ref>. As shown below, Transis achieves comparably good performance results, due to its highly distributed and efficient protocols. A crucial issue in the performance of high rate communication is the flow control mechanism. <p> An early delivery distributed protocol for totally-ordering multicast messages appears in [26], and is employed in Transis. This protocol is guaranteed to terminate when no failures occur. In case of failures, its operation on top of the Transis membership service guarantees progress. Another totally ordered protocol is described in <ref> [6] </ref>, and was also implemented within the Transis environment. Their protocol uses a revolving token holder that coordinates the transmission and regulates the flow of broadcast messages. One of the drawbacks of the latter method is that the system has to reconfigure whenever the token is omitted. <p> In periods of instability, the weak membership view might diverge at different processes. For purposes such as object replication, this membership is too weak. Therefore, [31] also provides the Strong and the Hybrid memberships for consistent replication. Two membership protocols that are closely related to our work are <ref> [3, 6] </ref>. In [3], we have introduced the concept of partitionable membership service, and extended the definition of virtual synchrony to such a service. [6] utilizes the principles of this membership protocol, and extends it to form a ring of machines with an initial token holder. <p> Therefore, [31] also provides the Strong and the Hybrid memberships for consistent replication. Two membership protocols that are closely related to our work are [3, 6]. In [3], we have introduced the concept of partitionable membership service, and extended the definition of virtual synchrony to such a service. <ref> [6] </ref> utilizes the principles of this membership protocol, and extends it to form a ring of machines with an initial token holder. There are other membership services that allow partitioned operation. <p> In this paper, we elaborate on the first method (details about the token-based protocol can be found in <ref> [6] </ref>). * Our protocols rely on very low message loss rates of the networks. However, under high communication loads, the networks and the underlying protocols can be driven to high loss rates. <p> The Agreed multicast service guarantees that messages arrive reliably and in the same total-order to all their destinations. Since we currently have three versions of Transis that differ in their implementation of the Agreed multicast service <ref> [26, 6] </ref>, we chose to present in the section the tradeoffs in this issue. There are several completely distributed algorithms that build a total order from the local information and reach agreement [43, 26, 49]. <p> On the other hand, these methods can sustain steady transmission loads that are close to the network limits, when all the machines are fairly uniformly active. A different family of protocols orders the messages in a total order by contending for an ordering capability to order messages <ref> [15, 6, 34] </ref>. The Isis ABCAST protocol [15] employs a token-holder within each group of communicating processes. ABCAST messages are multi-cast at will, and their delivery is delayed by all the receiving processes except for the token holder. <p> A sequencer kernel is designated as the central controller. Every message is sent to it via point to point communication, and the sequencer multicasts it to all the machines. The FIFO order of sequencer-transmissions determines a total order for all the messages. The Totem protocol <ref> [6] </ref> uses a revolving token that holds a sequence-number for messages. The holder of the token can emit one or more multicast messages, and update the token sequence accordingly. In order to transmit a multicast message, a processor must obtain the token. <p> Once it is obtained, transmission and ordering is done 19 immediately. Therefore, we say that they have a pre-transmission delay. The advantage of a control scheme like the revolving token of <ref> [6] </ref> is that it regulates the flow of messages efficiently. It is not entirely clear what are the tradeoffs between pre-transmission ordering and post-transmission ordering in these protocols.
Reference: [7] <author> A. Bhide and S. P. Morgan. </author> <title> A Highly Available Network File Server. </title> <type> RC 16161, </type> <institution> IBM Research, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: To illustrate this point, we name a few areas: * The known way to increase the availability of an information service is through replication of the information service on a number of machines. Various replicated information services are already in wide spread use, such as replicated file systems (e.g. <ref> [55, 42, 7, 61, 54, 39, 52] </ref>), and replicated databases (e.g. [1]). Increasing the availability through replication means that every replica performs all the updates to the information base, and any replica can provide up-to-date snapshots of the information.
Reference: [8] <author> K. P. Birman. </author> <title> The Process Group Approach to Reliable Distributed Computing. </title> <journal> Communications of the ACM, </journal> <volume> 36(12), </volume> <month> December </month> <year> 1993. </year>
Reference-contexts: In case no regular message is transmitted, then periodically, an empty message containing only acknowledgment and an "I am alive" indication will go out. These ideas are not new, and are utilized also, in various forms, in <ref> [49, 43, 34, 8] </ref>. Their importance is great in today's networks, that exhibit extremely low message loss rates. * Detection of message losses must be made as soon as possible. Suppose that machines A, B and C send successive messages.
Reference: [9] <author> K. P. Birman. </author> <title> A Response to Cheriton and Skeen's Criticism of Causal and Totally Ordered Communication. </title> <journal> ACM Operating Systems Review, </journal> <volume> 28(1) </volume> <pages> 11-21, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: There is currently a vivid debate in the community about the merit of causally ordered multicast. Cheriton & Skeen [20] hold the position that it is entirely useless. On the other hand, several members of the Isis group <ref> [9, 22, 57, 56] </ref> quite strongly advocate for causally ordered multicast services, and point to several applications that require and use it. It is certainly beyond the scope of this presentation to enter this controversy. However, we find that: 1.
Reference: [10] <author> K. P. Birman. </author> <title> Reliable Distributed Computing with the Isis Toolkit, chapter Virtual Synchrony Model. </title> <publisher> IEEE Press, </publisher> <year> 1994. </year> <note> to appear. </note>
Reference-contexts: The implementation of this membership protocol within the Isis system guarantees another important principle, called virtual synchrony, that ensures that all the processes deliver regular messages in the same order with respect to membership changes <ref> [10] </ref>. In this way, membership changes induce a consistent context on regular messages in all the processors (see also [14]). Moser et al. describe another primary-component membership service [44], that is based on a reliable, totally ordered communication service [43]. <p> Isis is widely used in industrial and in academic settings. The Isis package supports a variety of multicast communication services, and provides the application programmer with the virtually synchronous model of programming <ref> [10, 14] </ref>. Isis mandates the primary-component consistency model. The Gossip project at MIT [40, 37] is based on a novel approach called lazy replication. It is suited for replicating a single service, and lets the client of the service specify the potential causal dependency among requests. <p> The Safe messages are ordered in Agreed order with all other messages of any type. 4.1 Virtual Synchrony and Partitionable Operation Transis provides the application programmer with a programming environment that is conceptually Virtually Synchronous, as defined by Ken Birman et al. in the early work on the Isis system <ref> [10] </ref>, and extended into partitionable environments in [48]. The virtual synchrony model and its extension to partitionable operation encompasses the relation between message passing operations in a process-group, and between control messages provided by the system about process failures and joins in the group. <p> In this sense, membership changes are virtually synchronous, as the processes have identical contexts when messages arrive. This allows the processes to act upon the messages they receive in a consistent way. For a formal definition of the virtual synchrony model, refer to <ref> [10] </ref>. As an important extension to the Isis virtual synchrony model, Transis allows parti-tionable operation: If a group partitions into two components, such that communication between the components is impossible, then each component continues observing the virtual synchrony model separately.
Reference: [11] <author> K. P. Birman, R. Cooper, and B. Gleeson. </author> <title> Design Alternatives for Process Group Membership and Multicast. </title> <type> TR 91-1257, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <month> Dec </month> <year> 1991. </year>
Reference-contexts: Other systems have also realized the importance of an open group service, and provide an emulation layer for specific needs of open groups: For example, Isis provides a coordinator-cohorts mechanism, for client-server interaction <ref> [11] </ref>. * Groups are automatically created by the first member that joins them. Thus, there is no special "create group" operation, and there is no member of a group that is distinguished in any way.
Reference: [12] <author> K. P. Birman, R. Cooper, and B. Gleeson. </author> <title> Programming with Process Groups: Group and Multicast Semantics. </title> <type> TR 91-1185, </type> <institution> dept. of Computer Science, Cornell University, </institution> <month> Jan </month> <year> 1991. </year>
Reference-contexts: This might sound chaotic, at first. However, we require that: * Every pair of machines that go through two consecutive membership changes, receive the same set of messages between the two changes. (This is a generalization of the principle called virtual synchrony, see <ref> [12] </ref>). * Upon re-merging, all the machines in the new membership start with a consistent view of the membership, and agree on the messages that immediately follow it. In this way, the membership service associates a membership-context with each message.
Reference: [13] <author> K. P. Birman, R. Cooper, T. A. Joseph, K. Marzullo, M. Makpangou, K. Kane, F. Schmuck, and M. Wood. </author> <title> The ISIS System Manual. </title> <institution> Dept of Computer Science, Cornell University, </institution> <month> Sep 90. 27 </month>
Reference-contexts: Given the latter requirements, we will see that ordering comes at low cost. Our work on the Transis project started at 1990. At that time, there were already several projects under way in this area: notably, the Isis system <ref> [13, 16] </ref> from Cornell University, has been in wide spread use since around 1987. Also, Psync [49], Lazy Replication [37], the Trans and Total protocols [43]. <p> In many high availability systems, the service layers of multicast communication and membership maintenance are intertwined together (e.g. <ref> [46, 47, 16, 13, 33, 24] </ref>). Therefore, in this section, we relate our work to several types of efforts: 1. Multicast communication protocols. 2. Membership algorithms. 3. General high availability projects. Multicast Communication Protocols The V system [21] was the first to introduce the concept of process-group communication via multicast.
Reference: [14] <author> K. P. Birman and T. Joseph. </author> <title> Exploiting Virtual Synchrony in Distributed Systems. </title> <booktitle> In 11th Ann. Symp. Operating Systems Principles, </booktitle> <pages> pages 123-138, </pages> <month> Nov 87. </month>
Reference-contexts: In this way, membership changes induce a consistent context on regular messages in all the processors (see also <ref> [14] </ref>). Moser et al. describe another primary-component membership service [44], that is based on a reliable, totally ordered communication service [43]. <p> Isis is widely used in industrial and in academic settings. The Isis package supports a variety of multicast communication services, and provides the application programmer with the virtually synchronous model of programming <ref> [10, 14] </ref>. Isis mandates the primary-component consistency model. The Gossip project at MIT [40, 37] is based on a novel approach called lazy replication. It is suited for replicating a single service, and lets the client of the service specify the potential causal dependency among requests.
Reference: [15] <author> K. P. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight Causal and Atomic Group Multicast. </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <year> 1991. </year>
Reference-contexts: The protocol guards consistency by blocking the system in case that the token holder and its L followers in the token-list are unreachable. The Isis system contains a suite of protocols for supporting various orderings in reliable multicast services <ref> [15] </ref>. In the causally ordered multicast service (CBCAST), the causal order among messages is preserved by piggybacking vector-timestamps onto each message. 4 The causal ordering of messages is also maintained across overlapping process groups. <p> On the other hand, these methods can sustain steady transmission loads that are close to the network limits, when all the machines are fairly uniformly active. A different family of protocols orders the messages in a total order by contending for an ordering capability to order messages <ref> [15, 6, 34] </ref>. The Isis ABCAST protocol [15] employs a token-holder within each group of communicating processes. ABCAST messages are multi-cast at will, and their delivery is delayed by all the receiving processes except for the token holder. <p> A different family of protocols orders the messages in a total order by contending for an ordering capability to order messages [15, 6, 34]. The Isis ABCAST protocol <ref> [15] </ref> employs a token-holder within each group of communicating processes. ABCAST messages are multi-cast at will, and their delivery is delayed by all the receiving processes except for the token holder.
Reference: [16] <author> K. P. Birman and R. van Renesse. </author> <title> Reliable Distributed Computing with the Isis Toolkit. </title> <publisher> IEEE Press, </publisher> <year> 1993. </year> <note> to appear. </note>
Reference-contexts: Given the latter requirements, we will see that ordering comes at low cost. Our work on the Transis project started at 1990. At that time, there were already several projects under way in this area: notably, the Isis system <ref> [13, 16] </ref> from Cornell University, has been in wide spread use since around 1987. Also, Psync [49], Lazy Replication [37], the Trans and Total protocols [43]. <p> Ethernet, for example, supports both broadcast and multicast, and the Deering multicast extensions to IP [25] extend IP to support multicast at the Unix Ethernet drivers' level. Similarly, the emerging ATM standard will support multicast dissemination at the network level. 3 exploit hardware multicast where available <ref> [6, 34, 58, 16] </ref>. As shown below, Transis achieves comparably good performance results, due to its highly distributed and efficient protocols. A crucial issue in the performance of high rate communication is the flow control mechanism. <p> In many high availability systems, the service layers of multicast communication and membership maintenance are intertwined together (e.g. <ref> [46, 47, 16, 13, 33, 24] </ref>). Therefore, in this section, we relate our work to several types of efforts: 1. Multicast communication protocols. 2. Membership algorithms. 3. General high availability projects. Multicast Communication Protocols The V system [21] was the first to introduce the concept of process-group communication via multicast.
Reference: [17] <author> A. Borg, W. Blau, W. Oberle, and W. Graetsch. </author> <title> Fault Tolerance in Distributed Unix. </title> <editor> In B. Simons and A. Spector, editors, </editor> <booktitle> Fault-Tolerant Distributed Computing, Lecture Notes in comp. sci. </booktitle> <volume> #448, </volume> <pages> pages 224-243. </pages> <publisher> Springer Verlag, </publisher> <pages> 87. </pages> <note> A revised paper of A. </note> <author> Borg, J. Blaumbach and S. Glazer, </author> <title> `A Message System Supporting Fault Tolerance', </title> <booktitle> 9th sosp, </booktitle> <month> oct 83. </month>
Reference-contexts: On lower thresholds, the system may partition. The user has the control in trading resiliency for consistency. The protocol presented in [32] does not provide any solution for merging operational components upon reconnection. High Availability Projects Borg et al. describe a fault tolerant network Unix system <ref> [17] </ref>. Fault tolerance is achieved through duplicating all the processes in the system, and by routing their external communication through a special multicast communication layer. <p> Another common usage for group communication is in building fault tolerant distributed applications, in which every object is maintained by a group of processes, and the communication among objects is replicated among their representative groups (see for example <ref> [17] </ref>). Other systems have also realized the importance of an open group service, and provide an emulation layer for specific needs of open groups: For example, Isis provides a coordinator-cohorts mechanism, for client-server interaction [11]. * Groups are automatically created by the first member that joins them.
Reference: [18] <author> J. M. Chang and N. Maxemchuck. </author> <title> Realiable Broadcast Protocols. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 2(3) </volume> <pages> 251-273, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: It implements best-effort multicast semantics, and does not make any guarantees about the delivery or the order of delivery of multicast messages. Similarly, VMTP [19] and the IP-multicast extension [25] support unreliable multicast, but do so in a portable way, for more broad systems. Chang et al. <ref> [18] </ref> provide a family of totally ordered multicast protocols using a token revolving within a token list. Messages can be broadcast by any process.
Reference: [19] <author> D. R. Cheriton. VMTP: </author> <title> Versatile Message Transaction Protocol. </title> <type> RFC 1045, </type> <institution> SRI Network Information Center, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: V supports group communication as an operating system primitive. It implements best-effort multicast semantics, and does not make any guarantees about the delivery or the order of delivery of multicast messages. Similarly, VMTP <ref> [19] </ref> and the IP-multicast extension [25] support unreliable multicast, but do so in a portable way, for more broad systems. Chang et al. [18] provide a family of totally ordered multicast protocols using a token revolving within a token list. Messages can be broadcast by any process.
Reference: [20] <author> D. R. Cheriton and D. Skeen. </author> <title> Understanding the Limitations of Causally and Totally Ordered Communication. </title> <booktitle> In 14th Symposium on Operating Systems Principles, </booktitle> <pages> pages 44-57, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Causal-preserving delivery order makes programming somewhat easier, much in the same way that FIFO guarantees make it easier to program two-party interaction. There is currently a vivid debate in the community about the merit of causally ordered multicast. Cheriton & Skeen <ref> [20] </ref> hold the position that it is entirely useless. On the other hand, several members of the Isis group [9, 22, 57, 56] quite strongly advocate for causally ordered multicast services, and point to several applications that require and use it. <p> We have confidence that 12 in the future we shall see more works detailing the utilization of communication substrates such as Transis in the construction of high availability projects. Therefore, we do not see in the limitations detailed in <ref> [20] </ref> a refutation of our approach. 4 The Transis Programming Model The Transis communication system supports process group communication. Groups are conveniently identified by a name (a string) that is selected by the user, such that messages are addressed to the entire group by specifying the group name.
Reference: [21] <author> D. R. Cheriton and W. Zwaenepoel. </author> <title> Distributed Process Groups in the V Kernel. </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> 2(3) </volume> <pages> 77-107, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: Therefore, in this section, we relate our work to several types of efforts: 1. Multicast communication protocols. 2. Membership algorithms. 3. General high availability projects. Multicast Communication Protocols The V system <ref> [21] </ref> was the first to introduce the concept of process-group communication via multicast. V supports group communication as an operating system primitive. It implements best-effort multicast semantics, and does not make any guarantees about the delivery or the order of delivery of multicast messages.
Reference: [22] <author> R. Cooper. </author> <title> Experience with Causally and Totally Ordered Communication Support, A cautionary tale. </title> <journal> ACM Operating Systems Review, </journal> <volume> 28(1) </volume> <pages> 28-31, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: There is currently a vivid debate in the community about the merit of causally ordered multicast. Cheriton & Skeen [20] hold the position that it is entirely useless. On the other hand, several members of the Isis group <ref> [9, 22, 57, 56] </ref> quite strongly advocate for causally ordered multicast services, and point to several applications that require and use it. It is certainly beyond the scope of this presentation to enter this controversy. However, we find that: 1.
Reference: [23] <author> F. Cristian. </author> <title> Reaching agreement on processor group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4(4) </volume> <pages> 175-187, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: For an excellent formal study of the reliable broadcast problem, we refer the reader to [29]. Membership Algorithms The maintenance of the membership of machines is a basic building block of many fault-tolerant applications. Cristian introduces the problem of processor membership maintenance in <ref> [23] </ref>. This work formulates the problem in a synchronous environment, and provides protocols for solving it, 5 assuming that the clocks of different processors are synchronized within some known time skew, that the relative speeds of processors are known, and that message transmission times are bounded. <p> Changes to the membership are coordinated with the delivery of regular messages in the system. The problem of maintaining a consistent view of the reachable operational machines is fundamental in the design of distributed systems. In <ref> [23] </ref>, a formal definition of the problem (and solution) is given for synchronous systems. To the best of our knowledge, the first formal definition of the requirements of membership in asynchronous environments is given in [51].
Reference: [24] <author> F. Cristian, B. Dancey, and J. Dehn. </author> <title> Fault-Tolerance in the Advanced Automation System. </title> <booktitle> In 20th Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 6-17, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In many high availability systems, the service layers of multicast communication and membership maintenance are intertwined together (e.g. <ref> [46, 47, 16, 13, 33, 24] </ref>). Therefore, in this section, we relate our work to several types of efforts: 1. Multicast communication protocols. 2. Membership algorithms. 3. General high availability projects. Multicast Communication Protocols The V system [21] was the first to introduce the concept of process-group communication via multicast. <p> This approach can be very beneficial in a restricted type of applications. The AAS system is a fault tolerant application, developed by IBM Corp for the Federal Aviation Administration to support the air traffic and control system <ref> [24] </ref>. The system is intended to overcome both hardware and software errors that manifest themselves as performance errors. The basic mechanism for increasing the fault tolerance of the system is through server group replication on independent redundant hardware.
Reference: [25] <author> S. E. Deering. </author> <title> Host extensions for IP multicasting. </title> <type> RFC 1112, </type> <institution> SRI Network Information Center, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: Ethernet, for example, supports both broadcast and multicast, and the Deering multicast extensions to IP <ref> [25] </ref> extend IP to support multicast at the Unix Ethernet drivers' level. Similarly, the emerging ATM standard will support multicast dissemination at the network level. 3 exploit hardware multicast where available [6, 34, 58, 16]. <p> V supports group communication as an operating system primitive. It implements best-effort multicast semantics, and does not make any guarantees about the delivery or the order of delivery of multicast messages. Similarly, VMTP [19] and the IP-multicast extension <ref> [25] </ref> support unreliable multicast, but do so in a portable way, for more broad systems. Chang et al. [18] provide a family of totally ordered multicast protocols using a token revolving within a token list. Messages can be broadcast by any process.
Reference: [26] <author> D. Dolev, S. Kramer, and D. Malki. </author> <title> Early Delivery Totally Ordered Broadcast in Asynchronous Environments. </title> <booktitle> In 23rd Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 544-553, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The Xamp protocol of [60] relies on special network hardware that orders messages. The guarantee of message delivery in Xamp is based on a 2-phase acknowledgment protocol. An early delivery distributed protocol for totally-ordering multicast messages appears in <ref> [26] </ref>, and is employed in Transis. This protocol is guaranteed to terminate when no failures occur. In case of failures, its operation on top of the Transis membership service guarantees progress. Another totally ordered protocol is described in [6], and was also implemented within the Transis environment. <p> Furthermore, we delay the delivery of messages when causal "holes" are created in order to make the acknowledgment mechanism concise. 2. We have built several novel protocols, incorporated within the core of the Transis system, that rely on causal ordering of messages <ref> [26, 3, 27] </ref>. These protocols utilize the causal structure for performing a completely distributed reasoning about the system 11 state. Without causal structure, similar protocols use a centralized source of agreement (e.g. [51]), and do not use knowledge of the history. <p> The Agreed multicast service guarantees that messages arrive reliably and in the same total-order to all their destinations. Since we currently have three versions of Transis that differ in their implementation of the Agreed multicast service <ref> [26, 6] </ref>, we chose to present in the section the tradeoffs in this issue. There are several completely distributed algorithms that build a total order from the local information and reach agreement [43, 26, 49]. <p> There are several completely distributed algorithms that build a total order from the local information and reach agreement <ref> [43, 26, 49] </ref>. It is perhaps easiest to understand the all-ack algorithm of Transis, that is also completely distributed. The above referred algorithms are essentially optimizations on this principle.
Reference: [27] <author> D. Dolev, D. Malki, and H. R. </author> <title> Strong. An Asynchronous Membership Protocol that Tolerates Partitions. </title> <note> submitted for publication. Available as CS TR94-6, </note> <institution> Institute of Computer Science, the Hebrew University of Jerusalem, </institution> <year> 1994. </year> <month> 28 </month>
Reference-contexts: Furthermore, we delay the delivery of messages when causal "holes" are created in order to make the acknowledgment mechanism concise. 2. We have built several novel protocols, incorporated within the core of the Transis system, that rely on causal ordering of messages <ref> [26, 3, 27] </ref>. These protocols utilize the causal structure for performing a completely distributed reasoning about the system 11 state. Without causal structure, similar protocols use a centralized source of agreement (e.g. [51]), and do not use knowledge of the history. <p> Transis contains a membership protocol that is integrated in the communication system, such that the notifications of membership changes are delivered to the application among the stream of regular messages <ref> [3, 27] </ref>. Changes to the membership are coordinated with the delivery of regular messages in the system. The problem of maintaining a consistent view of the reachable operational machines is fundamental in the design of distributed systems. <p> In our protocol, the context of regular messages that are sent during membership transitions is determined by their order with respect to the messages used within the membership protocol. In <ref> [27] </ref>, we present the full solution that supports partitioned operation and rejoining. Joining is done multi-way, in a completely symmetrical fashion. In this way, the joining provides a solution to the startup problem as well: Each machine starts up as a singleton set on its own.
Reference: [28] <author> M. Fischer, N. Lynch, and M. Paterson. </author> <title> Impossibility of Distributed Consensus with One Faulty Process. </title> <journal> J. ACM, </journal> <volume> 32 </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Thus, it is possible for a non-primary component in Isis to continue operation shortly after a partition occurs, and before the partition is detected, and perform operations inconsistently with the primary component. Moreover, if the primary component is lost (as, provably, cannot be prevented <ref> [28] </ref>), then the entire system blocks. Another approach, taken e.g. by the Total protocol, allows the system to continue operation only if a majority of the processors are operational and connected [43]. Our approach to handling partitions is different. <p> Their paper defines a primary-component membership service, that maintains the local views of all the operational machines in agreement. Since it is well known that reaching agreement in asynchronous environments is impossible <ref> [28] </ref>, the membership agreement must circumvent this difficulty somehow. The membership protocol in [51] uses an inaccurate failure detector, based on timeout: When a machine is presumed faulty, it is taken out of the view, such that further messages from the faulty machine are discarded .
Reference: [29] <author> V. Hadzilacos and S. Toueg. </author> <title> Fault-Tolerant Broadcasts and Related Problems. </title> <editor> In S. Mullender, editor, </editor> <booktitle> chapter in: Distributed Systems. </booktitle> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: One of the drawbacks of the latter method is that the system has to reconfigure whenever the token is omitted. For an excellent formal study of the reliable broadcast problem, we refer the reader to <ref> [29] </ref>. Membership Algorithms The maintenance of the membership of machines is a basic building block of many fault-tolerant applications. Cristian introduces the problem of processor membership maintenance in [23].
Reference: [30] <author> J. Y. Halpern and Y. Moses. </author> <title> Knowledge and Common Knowledge in a Distributed Environment. </title> <booktitle> In 3rd Annual ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 50-61, </pages> <year> 1984. </year>
Reference-contexts: Often, the all-or-none guarantee is misunderstood, or oversimplified: the fact is that, in an asynchronous environment, no protocol can guarantee true all-or-none semantics despite arbitrary failures without saving messages on stable storage, because, otherwise, the act of message-delivery would require common-knowledge, which is impossible to attain in an asynchronous environment <ref> [30] </ref>. In Transis, we therefore provide two levels of service: Atomic: An Atomic message delivered at any member is guaranteed to be delivered at all the currently operational members of the application, despite message omissions.
Reference: [31] <author> F. Jahanian and W. Moran. </author> <title> Strong, Weak and Hybrid Group Membership. </title> <booktitle> In IEEE Workshop on Management of Replicated Data, </booktitle> <pages> pages 34-38, </pages> <year> 1992. </year>
Reference-contexts: The Psync system possesses a membership mechanism based on causally ordered messages [45]. This membership protocol preserves causal-order between membership changes and regular messages, but does not guarantee virtual synchrony. Jahanian et al. <ref> [31] </ref> provide a suite of membership protocols, unrelated to multicast message ordering. In the Weak Membership of [31], there is no guarantee that all the members see a certain membership installation. <p> This membership protocol preserves causal-order between membership changes and regular messages, but does not guarantee virtual synchrony. Jahanian et al. <ref> [31] </ref> provide a suite of membership protocols, unrelated to multicast message ordering. In the Weak Membership of [31], there is no guarantee that all the members see a certain membership installation. This protocol simply assures that if the communication is timely and there are no faults, then the membership will be in consensus. In periods of instability, the weak membership view might diverge at different processes. <p> This protocol simply assures that if the communication is timely and there are no faults, then the membership will be in consensus. In periods of instability, the weak membership view might diverge at different processes. For purposes such as object replication, this membership is too weak. Therefore, <ref> [31] </ref> also provides the Strong and the Hybrid memberships for consistent replication. Two membership protocols that are closely related to our work are [3, 6].
Reference: [32] <author> F. S. Kaashoek. </author> <title> Group Communication in Distributed Computer Systems. </title> <type> PhD thesis, </type> <institution> Vrije University, </institution> <year> 1992. </year>
Reference-contexts: Independently and roughly at the same time, two other projects in this area were launched: The Horus project [59, 58] rebuilds Isis from scratch, and the Amoeba operating system project integrates a group communication facility within the kernel of the operating system <ref> [34, 32, 33] </ref>. It is, therefore, crucial to explain first, why the Transis project was needed. <p> There are other membership services that allow partitioned operation. The membership service of the Amoeba system <ref> [32] </ref> lets the user determine the minimal size with which the 6 system can continue operating. If the user determines a majority threshold, the result is a primary-component membership service. On lower thresholds, the system may partition. The user has the control in trading resiliency for consistency. <p> If the user determines a majority threshold, the result is a primary-component membership service. On lower thresholds, the system may partition. The user has the control in trading resiliency for consistency. The protocol presented in <ref> [32] </ref> does not provide any solution for merging operational components upon reconnection. High Availability Projects Borg et al. describe a fault tolerant network Unix system [17]. Fault tolerance is achieved through duplicating all the processes in the system, and by routing their external communication through a special multicast communication layer.
Reference: [33] <author> M. F. Kaashoek and A. S. Tanenbaum. </author> <title> Group Communication in the Amoeba Distributed Operating System. </title> <booktitle> In 11th Intl. Conference on Distributed Computing Systems, </booktitle> <pages> pages 882-891, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Independently and roughly at the same time, two other projects in this area were launched: The Horus project [59, 58] rebuilds Isis from scratch, and the Amoeba operating system project integrates a group communication facility within the kernel of the operating system <ref> [34, 32, 33] </ref>. It is, therefore, crucial to explain first, why the Transis project was needed. <p> In many high availability systems, the service layers of multicast communication and membership maintenance are intertwined together (e.g. <ref> [46, 47, 16, 13, 33, 24] </ref>). Therefore, in this section, we relate our work to several types of efforts: 1. Multicast communication protocols. 2. Membership algorithms. 3. General high availability projects. Multicast Communication Protocols The V system [21] was the first to introduce the concept of process-group communication via multicast. <p> Failure notifications are ordered causally with respect to regular messages in the system [45]. The underlying message recovery protocol in Psync may be used on top of available hardware multicast. The Amoeba system contains support for ordered group multicast within the operating system kernel <ref> [34, 33] </ref>. The ordered multicast protocol in Amoeba uses a centralized coordinator for distributing the messages and for setting the total order on them.
Reference: [34] <author> M. F. Kaashoek, A. S. Tanenbaum, S. F. Hummel, and H. E. Bal. </author> <title> An Efficient Reliable Broadcast Protocol. </title> <journal> Operating Systems Review, </journal> <volume> 23(4) </volume> <pages> 5-19, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Independently and roughly at the same time, two other projects in this area were launched: The Horus project [59, 58] rebuilds Isis from scratch, and the Amoeba operating system project integrates a group communication facility within the kernel of the operating system <ref> [34, 32, 33] </ref>. It is, therefore, crucial to explain first, why the Transis project was needed. <p> Ethernet, for example, supports both broadcast and multicast, and the Deering multicast extensions to IP [25] extend IP to support multicast at the Unix Ethernet drivers' level. Similarly, the emerging ATM standard will support multicast dissemination at the network level. 3 exploit hardware multicast where available <ref> [6, 34, 58, 16] </ref>. As shown below, Transis achieves comparably good performance results, due to its highly distributed and efficient protocols. A crucial issue in the performance of high rate communication is the flow control mechanism. <p> Failure notifications are ordered causally with respect to regular messages in the system [45]. The underlying message recovery protocol in Psync may be used on top of available hardware multicast. The Amoeba system contains support for ordered group multicast within the operating system kernel <ref> [34, 33] </ref>. The ordered multicast protocol in Amoeba uses a centralized coordinator for distributing the messages and for setting the total order on them. <p> In case no regular message is transmitted, then periodically, an empty message containing only acknowledgment and an "I am alive" indication will go out. These ideas are not new, and are utilized also, in various forms, in <ref> [49, 43, 34, 8] </ref>. Their importance is great in today's networks, that exhibit extremely low message loss rates. * Detection of message losses must be made as soon as possible. Suppose that machines A, B and C send successive messages. <p> On the other hand, these methods can sustain steady transmission loads that are close to the network limits, when all the machines are fairly uniformly active. A different family of protocols orders the messages in a total order by contending for an ordering capability to order messages <ref> [15, 6, 34] </ref>. The Isis ABCAST protocol [15] employs a token-holder within each group of communicating processes. ABCAST messages are multi-cast at will, and their delivery is delayed by all the receiving processes except for the token holder. <p> Periodically, the token holder sends a message indicating its order of delivery for all received ABCAST messages, and all the other processes comply with it. The Token may also migrate to the sender. The Amoeba system contains a different variation of this scheme, implemented within the operating system kernel <ref> [34] </ref>. A sequencer kernel is designated as the central controller. Every message is sent to it via point to point communication, and the sequencer multicasts it to all the machines. The FIFO order of sequencer-transmissions determines a total order for all the messages.
Reference: [35] <author> I. Keidar. </author> <title> A Highly Available Paradigm for Consistent Object Replication. </title> <type> Master's thesis, </type> <institution> Inst. of Computer Science, The Hebrew University of Jerusalem, </institution> <year> 1994. </year>
Reference-contexts: Our approach to handling partitions is different. We incorporate partitions into the model, and provide the strictest semantics possible in face of partitions. The Transis approach is unique in allowing partitionable operation and in its support for consistent merging upon recovery. Further work done in the Transis project <ref> [35, 5] </ref> shows how the understanding of partitionable operation can lead to the development of algorithms that provide long term guarantees despite failures, avoid the end-to-end acknowledgment needs, and come up with algorithms for long term replication that are more fault tolerant than prior work. <p> This principle is guaranteed by the virtual synchrony programming model, and its extension to partitionable operation, see below (Section 4.1). The works of Keidar <ref> [35] </ref> and of Amir [2, 5] show how this principle can lead to an efficient merging-mechanism, that supports long term consistent replication. 3.5 Caveat We have manifested at the beginning of this section that communication protocols need to be tailored to various classes of application needs. <p> Transis is useful in providing the communication needs of these applications; the works of Amir and Keidar <ref> [2, 5, 35] </ref> show that the usage of Transis leads to simpler and more efficient design of sample applications. We have confidence that 12 in the future we shall see more works detailing the utilization of communication substrates such as Transis in the construction of high availability projects.
Reference: [36] <author> S. Kramer. </author> <title> Total Ordering of Messages in Multicast Communication Systems. </title> <type> Master's thesis, </type> <institution> Inst. of Computer Science, The Hebrew University of Jerusalem, </institution> <year> 1992. </year>
Reference-contexts: The Total protocol reaches agreement on the total order of messages among a majority of the processes in the systems. The protocol is prone to deadlock in rare situations (see proof in <ref> [36] </ref>). The Xamp protocol of [60] relies on special network hardware that orders messages. The guarantee of message delivery in Xamp is based on a 2-phase acknowledgment protocol. An early delivery distributed protocol for totally-ordering multicast messages appears in [26], and is employed in Transis.
Reference: [37] <author> R. Ladin, B. Liskov, L. Shrira, and S. Ghemawat. </author> <title> Lazy Replication: Exploiting the Semantics of Distributed Services. </title> <booktitle> In 9th Ann. Symp. Principles of Distributed Computing, </booktitle> <pages> pages 43-58, </pages> <month> August 90. </month>
Reference-contexts: Our work on the Transis project started at 1990. At that time, there were already several projects under way in this area: notably, the Isis system [13, 16] from Cornell University, has been in wide spread use since around 1987. Also, Psync [49], Lazy Replication <ref> [37] </ref>, the Trans and Total protocols [43]. <p> Isis is widely used in industrial and in academic settings. The Isis package supports a variety of multicast communication services, and provides the application programmer with the virtually synchronous model of programming [10, 14]. Isis mandates the primary-component consistency model. The Gossip project at MIT <ref> [40, 37] </ref> is based on a novel approach called lazy replication. It is suited for replicating a single service, and lets the client of the service specify the potential causal dependency among requests.
Reference: [38] <author> L. Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Comm. ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July 78. </month>
Reference-contexts: For applications that do not utilize totally ordered multicast, we thought it useful to provide a weaker form of ordering: Causal: A causally ordered multicast service preserves the causal order of messages (see <ref> [38] </ref>). Intuitively, causal communication guarantees that a response to a certain mes sage will never be delivered before the message. Causal-preserving delivery order makes programming somewhat easier, much in the same way that FIFO guarantees make it easier to program two-party interaction. <p> Causal Let us denote by deliver p (m) the event in which processor p delivers the message m, and send p (m) the event in which p sends a message m: The causal order on messages 13 is defined as the reflexive, transitive closure of (see <ref> [38] </ref>): (1) m cause ! m 0 if deliver q (m) ! send q (m 0 ) 3 (2) m cause ! m 0 if send q (m) ! send q (m 0 ) The Causal multicast service guarantees that the message delivery order of Causal messages preserves the causal order.
Reference: [39] <author> B. Liskov, S. Ghemawat, R. Gruber, P. Johnson, L. Shrira, and M. Williams. </author> <title> Replication in the Harp File System. </title> <booktitle> In Proceedings of the 13th Symposium on Operating Systems Principles, </booktitle> <pages> pages 226-238, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: To illustrate this point, we name a few areas: * The known way to increase the availability of an information service is through replication of the information service on a number of machines. Various replicated information services are already in wide spread use, such as replicated file systems (e.g. <ref> [55, 42, 7, 61, 54, 39, 52] </ref>), and replicated databases (e.g. [1]). Increasing the availability through replication means that every replica performs all the updates to the information base, and any replica can provide up-to-date snapshots of the information.
Reference: [40] <author> B. Liskov and R. Ladin. </author> <title> Highly-Available Distributed Services and Fault-Tolerant Distributed Garbage Collection. </title> <booktitle> In 5th Ann. Symp. Principles of Distributed Computing, </booktitle> <month> August 86. </month>
Reference-contexts: Isis is widely used in industrial and in academic settings. The Isis package supports a variety of multicast communication services, and provides the application programmer with the virtually synchronous model of programming [10, 14]. Isis mandates the primary-component consistency model. The Gossip project at MIT <ref> [40, 37] </ref> is based on a novel approach called lazy replication. It is suited for replicating a single service, and lets the client of the service specify the potential causal dependency among requests.
Reference: [41] <author> D. Malki and R. van Renesse. </author> <title> The Replication Service Layer. </title> <type> internal manuscript, </type> <year> 1994. </year> <month> 29 </month>
Reference-contexts: However, the system provides no means for merging the components upon recovery. The Horus system intends to adopt the Transis approach to partitionable operation, and to collaborate with us on the development of high level mechanisms and methodologies for partition-recovery <ref> [41] </ref>. The second issue that trigerred the work on Transis is, that the implementation of the 1 Sometimes in the literature, a partition refers to a disconnected network component.
Reference: [42] <author> K. Marzullo and F. Schmuck. </author> <title> Supplying High Availability with a Standard Network File System. </title> <booktitle> In 4th Intl. Conf. Distributed Computing Systems, </booktitle> <pages> pages 447-453. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: To illustrate this point, we name a few areas: * The known way to increase the availability of an information service is through replication of the information service on a number of machines. Various replicated information services are already in wide spread use, such as replicated file systems (e.g. <ref> [55, 42, 7, 61, 54, 39, 52] </ref>), and replicated databases (e.g. [1]). Increasing the availability through replication means that every replica performs all the updates to the information base, and any replica can provide up-to-date snapshots of the information.
Reference: [43] <author> P. M. Melliar-Smith, L. E. Moser, and V. Agrawala. </author> <title> Broadcast Protocols for Distributed Systems. </title> <journal> IEEE Trans. Parallel & Distributed Syst., </journal> <volume> 1(1) </volume> <pages> 17-25, </pages> <month> Jan </month> <year> 1990. </year>
Reference-contexts: At that time, there were already several projects under way in this area: notably, the Isis system [13, 16] from Cornell University, has been in wide spread use since around 1987. Also, Psync [49], Lazy Replication [37], the Trans and Total protocols <ref> [43] </ref>. Independently and roughly at the same time, two other projects in this area were launched: The Horus project [59, 58] rebuilds Isis from scratch, and the Amoeba operating system project integrates a group communication facility within the kernel of the operating system [34, 32, 33]. <p> Moreover, if the primary component is lost (as, provably, cannot be prevented [28]), then the entire system blocks. Another approach, taken e.g. by the Total protocol, allows the system to continue operation only if a majority of the processors are operational and connected <ref> [43] </ref>. Our approach to handling partitions is different. We incorporate partitions into the model, and provide the strictest semantics possible in face of partitions. The Transis approach is unique in allowing partitionable operation and in its support for consistent merging upon recovery. <p> The need to sustain high bandwidth group communication within local clusters will become crucial in many applications. Moreover, platforms supporting hardware multicast will apparently prevail in future networks. As an exception, the Trans protocol <ref> [43] </ref> is a reliable multicast protocol that proposes to use the available hardware multicast. The principles of the Trans protocol underlie the reliable multicast protocol in Transis. We note that the Psync protocol [49] may be used on top of available hardware multicast. <p> Amoeba lets the user trade resiliency to failures for performance: The user may choose parameters to allow fast message delivery on the one hand, or to require higher message stability before delivery. The Trans and Total protocols <ref> [43] </ref> are genuinely distributed protocols for reliable mul-ticast, preserving causal and total order, respectively. The basic mechanism in Transis for causal reliable delivery of messages is based on the Trans protocol, with several important modifications that adapt it for practical use (see [4]). <p> In this way, membership changes induce a consistent context on regular messages in all the processors (see also [14]). Moser et al. describe another primary-component membership service [44], that is based on a reliable, totally ordered communication service <ref> [43] </ref>. The underlying total ordering protocol guarantees agreement on the order of messages throughout the system, and induces agreement on process joins and removals by placing join and remove messages in the stream of totally ordered messages. <p> In case no regular message is transmitted, then periodically, an empty message containing only acknowledgment and an "I am alive" indication will go out. These ideas are not new, and are utilized also, in various forms, in <ref> [49, 43, 34, 8] </ref>. Their importance is great in today's networks, that exhibit extremely low message loss rates. * Detection of message losses must be made as soon as possible. Suppose that machines A, B and C send successive messages. <p> Solaris, MACH, X-kernel). In the current implementation, the Transis multiplexor is implemented as a user level process that remains operational at all times (a daemon process). The principle idea of reliable message delivery within a multicast cluster in Transis is motivated by the Trans algorithm <ref> [43] </ref> and resembles also the Psync algorithm [49]. Messages are transmitted via a single transmission, using the available network multi-cast. The "blobs" in Figure 3 represent multicast messages. Each machine tags its messages with increasing serial numbers, serving as message-ids. <p> There are several completely distributed algorithms that build a total order from the local information and reach agreement <ref> [43, 26, 49] </ref>. It is perhaps easiest to understand the all-ack algorithm of Transis, that is also completely distributed. The above referred algorithms are essentially optimizations on this principle. <p> Using advanced communication facilities, one can replicate information cheaply, conveniently and more quickly. The Transis approach to advanced group communication has acquired a wide recognition in the academic community, mainly due to the following desirable properties: 1. It employs a highly efficient multicast protocol, based on the Trans protocol <ref> [43] </ref>, that utilizes available hardware multicast. 2. It can sustain extremely high communication throughput due to its effective flow con trol mechanism, and its simple group design. 3.
Reference: [44] <author> P. M. Melliar-Smith, L. E. Moser, and V. Agrawala. </author> <title> Membership Algorithms for Asynchronous Distributed Systems. </title> <booktitle> In Intl. Conf. Distributed Computing Systems, </booktitle> <pages> pages 480-488, </pages> <month> May 91. </month>
Reference-contexts: In this way, membership changes induce a consistent context on regular messages in all the processors (see also [14]). Moser et al. describe another primary-component membership service <ref> [44] </ref>, that is based on a reliable, totally ordered communication service [43]. The underlying total ordering protocol guarantees agreement on the order of messages throughout the system, and induces agreement on process joins and removals by placing join and remove messages in the stream of totally ordered messages.
Reference: [45] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> A Membership Protocol based on Partial Order. </title> <booktitle> In proc. of the intl. working conf. on Dependable Computing for Critical Applications, </booktitle> <pages> pages 137-145, </pages> <month> Feb </month> <year> 1991. </year>
Reference-contexts: It provides several multicast communication services among a group of processes. It provides the user with a history context of messages, and allows the user to define semantical-dependent multicast ordering. Failure notifications are ordered causally with respect to regular messages in the system <ref> [45] </ref>. The underlying message recovery protocol in Psync may be used on top of available hardware multicast. The Amoeba system contains support for ordered group multicast within the operating system kernel [34, 33]. <p> On the other hand, the advantage of this approach is that membership changes are consistently ordered with respect to all regular messages. The Psync system possesses a membership mechanism based on causally ordered messages <ref> [45] </ref>. This membership protocol preserves causal-order between membership changes and regular messages, but does not guarantee virtual synchrony. Jahanian et al. [31] provide a suite of membership protocols, unrelated to multicast message ordering.
Reference: [46] <author> S. Mishra, L. L. Peterson, and R. L. Schlichting. </author> <title> Consul: A Communication Substrate for Fault-Tolerant Distributed Programs. </title> <type> TR 91-32, </type> <institution> dept. of Computer Science, University of Arizona, </institution> <year> 1991. </year>
Reference-contexts: In many high availability systems, the service layers of multicast communication and membership maintenance are intertwined together (e.g. <ref> [46, 47, 16, 13, 33, 24] </ref>). Therefore, in this section, we relate our work to several types of efforts: 1. Multicast communication protocols. 2. Membership algorithms. 3. General high availability projects. Multicast Communication Protocols The V system [21] was the first to introduce the concept of process-group communication via multicast. <p> The second track provides real-time services for semi-active replication, within an extra performance architecture. In the extra performance architecture, special homogenous machines are utilized, as well as special purpose network hardware. The Consul project of the University of Arizona <ref> [47, 46] </ref> supports object replication. The system is implemented in a mudular object oriented approach, on top of the X kernel. It employs the Psync communication substrate for multicast communication, and thus allows the user to define semantically dependent multicast orderings.
Reference: [47] <author> S. Mishra, L. L. Peterson, and R. L. Schlichting. </author> <title> Experience with Modularity in Consul. </title> <journal> Software Practice and Experience, </journal> <volume> 23(10) </volume> <pages> 1059-1076, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: In many high availability systems, the service layers of multicast communication and membership maintenance are intertwined together (e.g. <ref> [46, 47, 16, 13, 33, 24] </ref>). Therefore, in this section, we relate our work to several types of efforts: 1. Multicast communication protocols. 2. Membership algorithms. 3. General high availability projects. Multicast Communication Protocols The V system [21] was the first to introduce the concept of process-group communication via multicast. <p> The second track provides real-time services for semi-active replication, within an extra performance architecture. In the extra performance architecture, special homogenous machines are utilized, as well as special purpose network hardware. The Consul project of the University of Arizona <ref> [47, 46] </ref> supports object replication. The system is implemented in a mudular object oriented approach, on top of the X kernel. It employs the Psync communication substrate for multicast communication, and thus allows the user to define semantically dependent multicast orderings.
Reference: [48] <author> L. E. Moser, Y. Amir, P. M. Melliar-Smith, and D. A. Agarwal. </author> <title> Extended Virtual Synchrony. </title> <booktitle> In Intl. Conference on Distributed Computing Systems, </booktitle> <month> June </month> <year> 1994. </year> <note> to appear. Also available as technical report ECE93-22, </note> <institution> Department of Electrical and Computer Engineering, University of California, Santa Barbara, </institution> <address> CA. </address>
Reference-contexts: order with all other messages of any type. 4.1 Virtual Synchrony and Partitionable Operation Transis provides the application programmer with a programming environment that is conceptually Virtually Synchronous, as defined by Ken Birman et al. in the early work on the Isis system [10], and extended into partitionable environments in <ref> [48] </ref>. The virtual synchrony model and its extension to partitionable operation encompasses the relation between message passing operations in a process-group, and between control messages provided by the system about process failures and joins in the group.
Reference: [49] <author> L. L. Peterson, N. C. Buchholz, and R. D. Schlichting. </author> <title> Preserving and Using Context Information in Interprocess Communication. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 7(3) </volume> <pages> 217-246, </pages> <month> August 89. </month>
Reference-contexts: Our work on the Transis project started at 1990. At that time, there were already several projects under way in this area: notably, the Isis system [13, 16] from Cornell University, has been in wide spread use since around 1987. Also, Psync <ref> [49] </ref>, Lazy Replication [37], the Trans and Total protocols [43]. <p> As an exception, the Trans protocol [43] is a reliable multicast protocol that proposes to use the available hardware multicast. The principles of the Trans protocol underlie the reliable multicast protocol in Transis. We note that the Psync protocol <ref> [49] </ref> may be used on top of available hardware multicast. The Transis project is pioneering in the development of high performance multicast protocols that exploit the available multicast hardware. <p> The order of multiple messages may be set by a single message from the coordinator. Total ordering is not maintained in Isis across different process groups. Psync is a multicast communication substrate developed at the University of Arizona <ref> [49] </ref>. It provides several multicast communication services among a group of processes. It provides the user with a history context of messages, and allows the user to define semantical-dependent multicast ordering. Failure notifications are ordered causally with respect to regular messages in the system [45]. <p> In case no regular message is transmitted, then periodically, an empty message containing only acknowledgment and an "I am alive" indication will go out. These ideas are not new, and are utilized also, in various forms, in <ref> [49, 43, 34, 8] </ref>. Their importance is great in today's networks, that exhibit extremely low message loss rates. * Detection of message losses must be made as soon as possible. Suppose that machines A, B and C send successive messages. <p> In the current implementation, the Transis multiplexor is implemented as a user level process that remains operational at all times (a daemon process). The principle idea of reliable message delivery within a multicast cluster in Transis is motivated by the Trans algorithm [43] and resembles also the Psync algorithm <ref> [49] </ref>. Messages are transmitted via a single transmission, using the available network multi-cast. The "blobs" in Figure 3 represent multicast messages. Each machine tags its messages with increasing serial numbers, serving as message-ids. <p> There are several completely distributed algorithms that build a total order from the local information and reach agreement <ref> [43, 26, 49] </ref>. It is perhaps easiest to understand the all-ack algorithm of Transis, that is also completely distributed. The above referred algorithms are essentially optimizations on this principle.
Reference: [50] <author> D. Powell. Delta-4: </author> <title> A Generic Architecture for Dependable Distributed Computing. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Horus implements a clever packing technique that sends multiple messages within one communication packet, and thus achieves extremely high message throughput for short messages. Horus has adopted the principles invented by Transis for supporting partitionable operation. The Delta-4 project <ref> [50] </ref> provides services for constructing dependable software. The project has two tracks: one providing services for active replication in an open system architecture. The open system architecture of Delta-4 allows incorporating standard workstations, 7 but requires special purpose network interfaces.
Reference: [51] <author> A. M. Ricciardi and K. P. Birman. </author> <title> Using Process Groups to Implement Failure Detection in Asynchronous Environments. </title> <booktitle> In proc. annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 341-352, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: To the best of our knowledge, the first formal definition of the requirements of membership in asynchronous environments is given in <ref> [51] </ref>. Their paper defines a primary-component membership service, that maintains the local views of all the operational machines in agreement. In the application requirement in [51], at most one component may exist, and machines outside the primary component are either dead or give up. <p> To the best of our knowledge, the first formal definition of the requirements of membership in asynchronous environments is given in <ref> [51] </ref>. Their paper defines a primary-component membership service, that maintains the local views of all the operational machines in agreement. In the application requirement in [51], at most one component may exist, and machines outside the primary component are either dead or give up. <p> These protocols utilize the causal structure for performing a completely distributed reasoning about the system 11 state. Without causal structure, similar protocols use a centralized source of agreement (e.g. <ref> [51] </ref>), and do not use knowledge of the history. As we have found the causal structure useful for internal system protocols, we conjecture that future developers of higher level protocols can likewise benefit from causally ordered message passing for developing sophisticated distributed algorithms. 3. <p> In [23], a formal definition of the problem (and solution) is given for synchronous systems. To the best of our knowledge, the first formal definition of the requirements of membership in asynchronous environments is given in <ref> [51] </ref>. Their paper defines a primary-component membership service, that maintains the local views of all the operational machines in agreement. Since it is well known that reaching agreement in asynchronous environments is impossible [28], the membership agreement must circumvent this difficulty somehow. The membership protocol in [51] uses an inaccurate failure <p> environments is given in <ref> [51] </ref>. Their paper defines a primary-component membership service, that maintains the local views of all the operational machines in agreement. Since it is well known that reaching agreement in asynchronous environments is impossible [28], the membership agreement must circumvent this difficulty somehow. The membership protocol in [51] uses an inaccurate failure detector, based on timeout: When a machine is presumed faulty, it is taken out of the view, such that further messages from the faulty machine are discarded . In reality, failure detection can be fine-tuned to avoid false-detection almost entirely. <p> In reality, failure detection can be fine-tuned to avoid false-detection almost entirely. This approach is practical, and we adopt it, with an important modification: a presumed failed machine can rejoin the membership, and does not need to give up. In the application requirement in <ref> [51] </ref>, at most one component may exist, and machines outside the primary component are either dead or give up. In large and critical systems, this approach is not realistic, and it is essential to enable operation in face of partitions.
Reference: [52] <author> M. Satyanarayanan, J. Kistler, P. Kumar, M. Okasaki, E. Siegel, and D. Steere. Coda: </author> <title> A highly available file system for a distributed workstation environment. </title> <journal> IEEE trans. on Computers, </journal> <volume> 39(4) </volume> <pages> 447-459, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: To illustrate this point, we name a few areas: * The known way to increase the availability of an information service is through replication of the information service on a number of machines. Various replicated information services are already in wide spread use, such as replicated file systems (e.g. <ref> [55, 42, 7, 61, 54, 39, 52] </ref>), and replicated databases (e.g. [1]). Increasing the availability through replication means that every replica performs all the updates to the information base, and any replica can provide up-to-date snapshots of the information.
Reference: [53] <author> F. Schneider. </author> <title> Implementing Fault Tolerant Services Using The State Machine Approach: </title>
Reference-contexts: We justify the Transis design "top down", i.e. starting from a class of distributed applications, we show services that can benefit the application developer. 3.1 Application Classes Active replication using the State Machine approach <ref> [53] </ref>, is widely used in replicated information systems (e.g. Deceit [55], Afic [1]). In this method, the information base itself resides on multiple sites. The operations that modify the information (updates) are introduced to the sites in a consistent, global order.
References-found: 53

