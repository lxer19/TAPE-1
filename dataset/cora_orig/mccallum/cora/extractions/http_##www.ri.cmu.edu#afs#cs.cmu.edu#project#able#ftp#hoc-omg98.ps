URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/able/ftp/hoc-omg98.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/project/able/www/paper_abstracts/hoc-omg98.html
Root-URL: 
Title: Higher-Order Connectors  
Author: David Garlan 
Degree: Presented at the  
Date: January 6-7, 1998  
Address: Monterey, CA,  Pittsburgh, PA 15213  
Affiliation: Architectures  School of Computer Science Carnegie Mellon University  
Note: Workshop on Compositional Software  
Abstract: A critical issue for architectural design is the nature of the glue, or connectors, with which a system's parts are combined. Thus an important first step toward improving our ability to compose parts is to make to make connectors explicit semantic enties, where they can be documented, analyzed, and (sometimes) used to generate code. A number of notations for software architecture do precisely this. However, a key second step is to understand operations over connectors. In principle, such operations would permit one to produce new connectors out of old ones, adapt existing connectors to new contexts of use, and factor out common properties of connectors so they can be reused. In this paper we argue that the use of "higher order connectors" is one way to achieve this goal.
Abstract-found: 1
Intro-found: 1
Reference: [AG94] <author> Robert Allen and David Garlan. </author> <title> Formalizing architectural connection. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 71-80, </pages> <address> Sorrento, Italy, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: By making connector abstractions explicit, one can make principled design choices between different interaction schemes, support analysis of those interactions, and, in some cases, automatically generate implementations for those interactions. A number of architecture description languages have therefore taken this approach, including Wright <ref> [AG94] </ref>, UniCon [SDK + 95], Acme [GMW97], and SADL [MQ94]. These languages permit the designer to choose among a rich selection of connector types, and (in many cases) to specify new kinds of connector types.
Reference: [GMW97] <author> David Garlan, Robert T. Monroe, and David Wile. ACME: </author> <title> An architecture description interchange language. </title> <booktitle> In Proceedings of CASCON'97, </booktitle> <address> Ontario, Canada, </address> <month> November </month> <year> 1997. </year>
Reference-contexts: By making connector abstractions explicit, one can make principled design choices between different interaction schemes, support analysis of those interactions, and, in some cases, automatically generate implementations for those interactions. A number of architecture description languages have therefore taken this approach, including Wright [AG94], UniCon [SDK + 95], Acme <ref> [GMW97] </ref>, and SADL [MQ94]. These languages permit the designer to choose among a rich selection of connector types, and (in many cases) to specify new kinds of connector types.
Reference: [MQ94] <author> M. Moriconi and X. Qian. </author> <title> Correctness and composition of software architectures. </title> <booktitle> In Proceedings of ACM SIGSOFT'94: Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 164-174, </pages> <address> New Orleans, Louisiana, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: A number of architecture description languages have therefore taken this approach, including Wright [AG94], UniCon [SDK + 95], Acme [GMW97], and SADL <ref> [MQ94] </ref>. These languages permit the designer to choose among a rich selection of connector types, and (in many cases) to specify new kinds of connector types. Unfortunately, in all of these languages, connectors are either provided as primitives (albeit, often a flexible set), or must be defined from scratch.
Reference: [SDK + 95] <author> Mary Shaw, Robert DeLine, Daniel V. Klein, Theodore L. Ross, David M. Young, and Gregory Zelesnik. </author> <title> Abstractions for software architecture and tools to support them. </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Software Architecture, </journal> <volume> 21(4) </volume> <pages> 314-335, </pages> <month> April </month> <year> 1995. </year> <month> 3 </month>
Reference-contexts: By making connector abstractions explicit, one can make principled design choices between different interaction schemes, support analysis of those interactions, and, in some cases, automatically generate implementations for those interactions. A number of architecture description languages have therefore taken this approach, including Wright [AG94], UniCon <ref> [SDK + 95] </ref>, Acme [GMW97], and SADL [MQ94]. These languages permit the designer to choose among a rich selection of connector types, and (in many cases) to specify new kinds of connector types.
Reference: [Sha93] <author> Mary Shaw. </author> <title> Procedure calls are the assembly language of system interconnection: Con--nectors deserve first-class status. </title> <booktitle> In Proceedings of the Workshop on Studies of Software Design, </booktitle> <month> May </month> <year> 1993. </year> <month> 4 </month>
Reference-contexts: are good reasons to believe that higher-order connectors can support sound semantics, useful algebraic theories, and capabilities for implementation guidance and generation. 2 Connectors as first class design entities An important first step in understanding how to integrate components is to permit the explicit description and analysis of connector types <ref> [Sha93] </ref>. By making connector abstractions explicit, one can make principled design choices between different interaction schemes, support analysis of those interactions, and, in some cases, automatically generate implementations for those interactions.
References-found: 5

