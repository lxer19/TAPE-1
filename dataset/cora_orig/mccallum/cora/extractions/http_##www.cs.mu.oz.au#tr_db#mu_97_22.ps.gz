URL: http://www.cs.mu.oz.au/tr_db/mu_97_22.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: Logic Programming with Linear Logic  
Author: Michael David Winikoff 
Degree: Submitted in total fulfilment of the requirements of the degree of Doctor of Philosophy  
Address: Parkville, Victoria 3052 AUSTRALIA  
Affiliation: Department of Computer Science School of Electrical Engineering and Computer Science The University of Melbourne  
Date: 1997  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Samson Abramsky. </author> <title> Computational interpretations of linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 111 </volume> <pages> 3-57, </pages> <year> 1993. </year>
Reference-contexts: A related application of linear logic is its use to derive functional programming languages. This is done using the Curry-Howard isomorphism which states that there is an equivalence between theorems and types in the -calculus. This has been applied by Mackie [98, 99], Abramsky <ref> [1] </ref>, Lafont [91, 92] and Lafont and Girard [49] to derive a linear version of the -calculus. The resulting languages are rather different to logic programming languages.
Reference: [2] <author> Gul Agha. </author> <title> Concurrent Object-Oriented Programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 125-141, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: These are demonstrated in programs 16 and 17. We also show how a range of other paradigms for concurrent programming can be simply and easily embedded in linear logic. Specifically, we embed the Chemical reaction metaphor for concurrent programming [22], the co-ordination language Linda [27, 28], the Actors paradigm <ref> [2] </ref> and Petri Nets [120]. We finish this section with a solution to the dining philosophers problem. We begin with a simple example which illustrates how we can program two communicating processes in Lygon. <p> Program 19 Linda in (X,G) tup (X) call (G). Remove a tuple out (X,G) neg tup (X) O call (G). Add a tuple read (X,G) tup (X) (neg tup (X) O call (G)). Non-destructively read a tuple eval (X,G) call (X) O call (G). The Actor model <ref> [2] </ref> is an abstraction of concurrent processes. An actor is activated 5.4. CONCURRENCY 137 when it receives a message. <p> use of doleft: prove (atom (append ([1],<ref> [2] </ref>,An))) print (An) ! nonlin (R) doleft (R,atom (append ([1],[2],An))) print (An) R = (atom (append ([XjY],Z,[XjQ])) atom (append (Y,Z,Q))) ! doleft ((atom (append ([XjY],Z,[XjQ])) atom (append (Y,Z,Q))) , atom (append ([1],[2],An))) print (An) X = 1 , Y = [] , Z = [2] , An = [1jQ] ! prove (atom (append ([],[2],Q))) print ([1jQ]) ! nonlin (R) doleft (R,atom (append ([],[2],Q))) print ([1jQ]) R = atom (append ([],X,X)) ! doleft (atom (append ([],X,X)) , atom (append ([],[2],Q))) print ([1jQ]) X = [2] , Q = [2] ! print ([1,2]) One operation that is <p> (An) X = 1 , Y = [] , Z = <ref> [2] </ref> , An = [1jQ] ! prove (atom (append ([],[2],Q))) print ([1jQ]) ! nonlin (R) doleft (R,atom (append ([],[2],Q))) print ([1jQ]) R = atom (append ([],X,X)) ! doleft (atom (append ([],X,X)) , atom (append ([],[2],Q))) print ([1jQ]) X = [2] , Q = [2] ! print ([1,2]) One operation that is specific to Lygon is selecting a formula to be reduced. As we have seen there are a number of heuristics which can be applied to reduce the amount of nondeterminism. <p> , Y = [] , Z = <ref> [2] </ref> , An = [1jQ] ! prove (atom (append ([],[2],Q))) print ([1jQ]) ! nonlin (R) doleft (R,atom (append ([],[2],Q))) print ([1jQ]) R = atom (append ([],X,X)) ! doleft (atom (append ([],X,X)) , atom (append ([],[2],Q))) print ([1jQ]) X = [2] , Q = [2] ! print ([1,2]) One operation that is specific to Lygon is selecting a formula to be reduced. As we have seen there are a number of heuristics which can be applied to reduce the amount of nondeterminism.
Reference: [3] <author> Vladimir Alexiev. </author> <title> Applications of linear logic to computation: An overview. </title> <type> Technical Report TR93-18, </type> <institution> University of Alberta, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: (F 1 F 2 ) ? (F 1 ) ? N (F 2 ) ? (!F ) ? ?(F ) ? (9xF ) ? 8x (F ) ? (1) ? ? (0) ? &gt; Good tutorial introductions to linear logic and its applications to computer science can be found in <ref> [3, 4, 123, 124] </ref>. 2.4 Permutabilities Permutabilities [83] play an important role in the proof theoretical analysis of logic programming languages.
Reference: [4] <author> Vladimir Alexiev. </author> <title> Applications of linear logic to computation: An overview. </title> <journal> Bulletin of the IGPL, </journal> <volume> 2(1) </volume> <pages> 77-107, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: (F 1 F 2 ) ? (F 1 ) ? N (F 2 ) ? (!F ) ? ?(F ) ? (9xF ) ? 8x (F ) ? (1) ? ? (0) ? &gt; Good tutorial introductions to linear logic and its applications to computer science can be found in <ref> [3, 4, 123, 124] </ref>. 2.4 Permutabilities Permutabilities [83] play an important role in the proof theoretical analysis of logic programming languages.
Reference: [5] <author> Vladimir Alexiev. </author> <title> The event calculus as a linear logic program. </title> <type> Technical Report 95-24, </type> <institution> University of Alberta, </institution> <year> 1995. </year>
Reference-contexts: We present a range of examples illustrating the application of linear logic and of Lygon to knowledge representation. It is worth noting that the problems we consider have solutions in the classical logic framework. It is also worth emphasising that these solutions are invariably complex and obtuse. In <ref> [5] </ref> Vladimir Alexiev looks at Kowalski's Event Calculus [90]. The event calculus is a formalisation of events and their effect on states. One of the key features of the Event Calculus is that it is executable the theory is realised as a Prolog program. <p> It has also been used to specify filler-gap dependency parsers [65]. Lolli has been used to implement event calculus programs by a number of researchers <ref> [5, 31] </ref>. 1 Available from camille.is.s.u-tokyo.ac.jp:pub/hacl. 6.2. CONCURRENT PROGRAMMING 165 Lolli and Lygon are fairly similar in methodology. Roughly speaking, Lolli can be seen as Lygon minus concurrency. Indeed, the class of formulae usable in Lygon 2 is a superset of the Lolli class.
Reference: [6] <author> Jean-Marc Andreoli. </author> <title> Logic programming with focusing proofs in linear logic. </title> <journal> Journal of Logic and Computation, </journal> <volume> 2(3), </volume> <year> 1992. </year>
Reference-contexts: For example, in linear logic the right rule for O is reversible. The right rule for is relatively reversible if the proof cannot contain N-R (or the equivalent -L). A connective is asynchronous <ref> [6] </ref> if the corresponding right rule is reversible and is relatively asynchronous if the corresponding right rule is relatively reversible. Non asynchronous connectives are referred to as synchronous. <p> In <ref> [6] </ref> Andreoli observes that if there is a proof which begins by applying a syn chronous rule and a side formula is itself synchronous then there exists a proof of the resulting sequent if and only if there is a proof which begins by applying a rule to the synchronous side <p> Unfortunately uniformity is defined in the context of single conclusioned sequent calculi systems. This is a problem since we are interested in a general criteria applicable to a range of both single and multiple conclusion logics including relevant logic [24], temporal and modal logics [118] and linear logic <ref> [6, 10, 70, 85, 109, 140, 147] </ref>. This chapter continues the investigation into the derivation of logic programming languages. We define a number of formal characterisers (including uniformity) and explore the relationships amongst them. We begin with single conclusion logics and then generalise to the multiple conclusion setting. <p> Note that, as an extreme case, the application of standard linear logical equivalences enables one to encode the entirety of linear logic into a subset that can be shown to be uniform <ref> [6, 109] </ref>. Since full linear logic is not uniform this suggests that the use of logical equivalences to extend a logic programming language might not always be appropriate. To see that full linear logic is not uniform consider the sequent pq ` pq. <p> Then there is a proof of ` F where all left rules are part of a sequence which decomposes a single clause. Proof: Observe that all of the left inference rules which can be applied in a Lolli derivation are synchronous. Hence according to the focusing property <ref> [6] </ref> once we have applied a left rule to a program formula we can continue to decompose that formula without a loss of completeness. Furthermore, as observed in [6]: 3.4. <p> Hence according to the focusing property <ref> [6] </ref> once we have applied a left rule to a program formula we can continue to decompose that formula without a loss of completeness. Furthermore, as observed in [6]: 3.4. <p> Proof: Observe that the connectives 8 , ! , ( and O are synchronous when they occur on the left. Thus by an application of the focusing property <ref> [6] </ref> we can apply the left rules decomposing a program clause as an indivisible group of inferences without any loss of completeness. We shall refer to this sequence of inferences as a left-focused proof step or proof step. <p> Then there exists a proof of ` where all left rules are part of a sequence which decomposes a single clause. Proof: Observe that all of the left inference rules which are applicable in Forum derivations are synchronous. Hence according to the focusing property <ref> [6] </ref> once we have applied a left rule to a program formula we can continue to decompose that formula without a loss of completeness. Furthermore, as observed in [6]: When a negative atom A ? is reached at the end of a critical focusing section, the Identity must be used, so <p> Hence according to the focusing property <ref> [6] </ref> once we have applied a left rule to a program formula we can continue to decompose that formula without a loss of completeness. Furthermore, as observed in [6]: When a negative atom A ? is reached at the end of a critical focusing section, the Identity must be used, so that A must be found in the rest of the sequent, either as a restricted resource : : : or as an unrestricted resource : : : Thus, <p> Then there exists a proof of ` where all left rules are part of a sequence which decomposes a single clause. Proof: Observe that all of the left inference rules which are applicable in Lygon 2 derivations are synchronous. Hence according to the focusing property <ref> [6] </ref> once we have applied a left rule to a program formula we can continue to decompose that formula without a loss of completeness. Furthermore, as observed in [6]: When a negative atom A ? is reached at the end of a critical focusing section, the Identity must be used, so <p> Hence according to the focusing property <ref> [6] </ref> once we have applied a left rule to a program formula we can continue to decompose that formula without a loss of completeness. Furthermore, as observed in [6]: When a negative atom A ? is reached at the end of a critical focusing section, the Identity must be used, so that A must be found in the rest of the sequent, either as a restricted resource : : : or as an unrestricted resource : : : Thus, <p> In the following two sections we prove that the resulting lazy system is sound and complete with respect to the standard one sided sequent calculus for linear logic. In section 4.4 we discuss the second problem and note that the observations in <ref> [6, 44] </ref> can be used to provide a heuristic that (partially) solves the second problem. We conclude the chapter with a brief discussion. 78 CHAPTER 4. IMPLEMENTATION ISSUES 4.1 The Challenge of Being Lazy The standard formulation of the inference rules for linear logic have a significant amount of nondeterminism. <p> The situations in which Lygon can safely use don't care nondeterminism to select the active formula can be partially detected by using permutability properties. In particular we use the results of Andreoli <ref> [6] </ref> and Galmiche and Perrier [44]. This section briefly summarises the results of the two papers. For more details we refer the reader to the papers themselves. Note that there is a fair amount of overlap in the results of the two papers although their motivation is different. <p> In practice the current system is adequate for the programs we have written. There are a number of logic programming languages based on linear logic. Some of these, like LinLog <ref> [6] </ref> are based on proof-theoretic analyses, as Lygon is, but, to the best of my knowledge, have not been implemented and hence do not involve the problems of lazy splitting discussed in this thesis. <p> Secondly, and perhaps more importantly, our presentation allows us to simply use the permutability properties explored in <ref> [6, 44] </ref> to reduce the nondeterminism associated with selecting the formula to be reduced. In the Lolli encoding, selecting the next formula to be reduced is done by the resolution rule. <p> For example, the formula p O (q r) is not a valid LinLog goal since the O (asynchronous) occurs outside of a synchronous connective (). 6.1. LINEAR LOGIC PROGRAMMING LANGUAGES 163 LO [10]: LinLog <ref> [6] </ref>: D ::= !8x (G ( A 1 O : : : O A n ) H ::= A j?A j ? j H O H j &gt; j H N H j 8xH D ::= !8x (G ( A p ) R ::= 9x (A ? m G) j R <p> COMPARISON TO OTHER WORK The class of formulae allowed in LinLog is a subset of the Lygon 2 class of formulae. Since there exists an algorithm <ref> [6] </ref> which can translate an arbitrary proof in linear logic to one in the LinLog fragment, it follows that any proof in linear logic can be carried out within Lygon 2 via a syntactic translation.
Reference: [7] <author> Jean-Marc Andreoli, Paolo Ciancarini, and Remo Pareschi. </author> <title> Interaction abstract machines. </title> <type> Technical Report ECRC-92-23, </type> <institution> European Computer-Industry Research Centre (ECRC), ECRC GMBH Arabellastr. 17, D-81925 M unchen, Ger-many, </institution> <year> 1992. </year>
Reference: [8] <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> LO and behold! concurrent structured processes. </title> <journal> SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 44-56, </pages> <year> 1990. </year>
Reference-contexts: Doing this yields a more limited class of formulae but simplifies the implementation. This path was taken in the design of LC [140] and LO <ref> [8] </ref>. In the design of Lygon the opposite choice was made. As a result Lygon has a significantly larger class of formulae but has to contend with the problem that selecting the active formulae may have to be done using don't know nondeterminism.
Reference: [9] <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> Communication as fair distribution of knowledge. </title> <editor> In Andreas Parpcke, editor, </editor> <booktitle> Sixth Annual Conference on Object-Oriented Programming Systems, Languages, and Applications (OOP-SLA), </booktitle> <pages> pages 212-229, </pages> <year> 1991. </year>
Reference: [10] <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> Linear objects: Logical processes with built-in inheritance. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 445-473, </pages> <year> 1991. </year>
Reference-contexts: j A j D N D j G ( D j G ) D j 8x:D ACL [85] G ::= ? j &gt; j A m j?A m j A p j G O G j G N G j 8xG j R m : : : A ? LO <ref> [10] </ref> G ::= A j &gt; j G N G j G O G Forum [109] D ::= G LC [140] G ::= A j 1 ? j &gt; j G O G j G G j 9xG Lygon [122] D ::= A j 1 j ? j D N D <p> Unfortunately uniformity is defined in the context of single conclusioned sequent calculi systems. This is a problem since we are interested in a general criteria applicable to a range of both single and multiple conclusion logics including relevant logic [24], temporal and modal logics [118] and linear logic <ref> [6, 10, 70, 85, 109, 140, 147] </ref>. This chapter continues the investigation into the derivation of logic programming languages. We define a number of formal characterisers (including uniformity) and explore the relationships amongst them. We begin with single conclusion logics and then generalise to the multiple conclusion setting. <p> EXAMPLES 55 3.6.2 LO LO (Linear Objects) <ref> [10] </ref> is one of the earlier languages based on linear logic. It is motivated by a desire to add concurrency and object-oriented features to logic programming. <p> This property is achieved by requiring LinLog goals to consist of synchronous connectives outside asynchronous connectives. For example, the formula p O (q r) is not a valid LinLog goal since the O (asynchronous) occurs outside of a synchronous connective (). 6.1. LINEAR LOGIC PROGRAMMING LANGUAGES 163 LO <ref> [10] </ref>: LinLog [6]: D ::= !8x (G ( A 1 O : : : O A n ) H ::= A j?A j ? j H O H j &gt; j H N H j 8xH D ::= !8x (G ( A p ) R ::= 9x (A ? m G)
Reference: [11] <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> Associative communication and its optimization via abstract interpretation. </title> <type> Technical Report ECRC-92-24, </type> <institution> European Computer-Industry Research Centre (ECRC), ECRC GMBH Arabellastr. 17, D-81925 M unchen, Germany, </institution> <year> 1992. </year>
Reference-contexts: These formulae are not removed from the relevant context but added to the initial context. The initial query is seen as containing an unknown region which is determined as broadcasts are processed. More recent work with LO involves optimising communication by abstract interpretation <ref> [11, 12] </ref> and the use of the language as a co-ordination language [29]. In [42] LO is used to co-ordinate a distributed diary system whose components were written in Prolog.
Reference: [12] <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> Abstract interprtation of linear logic programming. </title> <editor> In D. Miller, editor, </editor> <booktitle> International Logic Programming Symposium, </booktitle> <pages> pages 295-314. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year> <note> 172 BIBLIOGRAPHY </note>
Reference-contexts: If, for example, we know which linear predicates are added and removed by each predicate then it is possible to detect at compile time that a goal can not consume a certain linear predicate. This notion of predicate-level typing is similar to the results of the analysis presented in <ref> [12] </ref> and to the type system of [87]. 160 CHAPTER 5. APPLICATIONS OF LYGON 161 Chapter 6 Comparison to Other Work In this chapter we survey and compare the variety of logic programming languages which are based on linear logic. <p> These formulae are not removed from the relevant context but added to the initial context. The initial query is seen as containing an unknown region which is determined as broadcasts are processed. More recent work with LO involves optimising communication by abstract interpretation <ref> [11, 12] </ref> and the use of the language as a co-ordination language [29]. In [42] LO is used to co-ordinate a distributed diary system whose components were written in Prolog.
Reference: [13] <author> Henry G. Baker. </author> <title> Lively linear Lisp - 'look ma, no garbage!'. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(8) </volume> <pages> 89-98, </pages> <month> August </month> <year> 1992. </year>
Reference: [14] <author> Henry G. Baker. </author> <title> Sparse polynomials and linear logic. </title> <journal> SIGSAM Bulletin, </journal> <volume> 27(4) </volume> <pages> 10-14, </pages> <month> December </month> <year> 1993. </year>
Reference: [15] <author> Henry G. Baker. </author> <title> Linear logic and permutation stacks the forth shall be first. </title> <journal> Computer Architecture News, </journal> <volume> 22(1) </volume> <pages> 34-43, </pages> <month> March </month> <year> 1994. </year>
Reference: [16] <author> Henry G. Baker. </author> <title> A linear logic quicksort. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(2) </volume> <pages> 13-18, </pages> <month> February </month> <year> 1994. </year>
Reference: [17] <author> Henri E. Bal, Jennifer G. Steiner, and Andrew S. Tanenbaum. </author> <title> Programming languages for distributed computing systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 261-322, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: In this section we show how various aspects of concurrency can be expressed in Lygon. Some aspects of concurrency that we shall look at are <ref> [17] </ref>: 1. Specifying multiple processes, 2. Communication, and 3. Synchronisation. These are demonstrated in programs 16 and 17. We also show how a range of other paradigms for concurrent programming can be simply and easily embedded in linear logic. <p> Since a general comparison between linear logic programming languages' approach to concurrency and more general approaches (e.g., rendezvous, remote procedure call (RPC) etc.) is beyond the scope of this section, we shall not discuss these languages further. For a survey of approaches to concurrency we refer the reader to <ref> [17] </ref>. Looking at the linear logic way of doing concurrency in a logic programming framework, one of the main differences from first generation languages is that unification is left unchanged linear logic provides new operations which allow communication and synchronisation to be expressed.
Reference: [18] <author> J.-P. Banatre and D. Le Metayer. </author> <title> Programming by multiset transformation. </title> <journal> Communications of the ACM, </journal> <volume> 36(1) </volume> <pages> 98-111, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: As we shall see, in all cases the embedding is direct and straightforward. The chemical reaction paradigm [22] views a concurrent program as a solution of reacting molecules. Chemical reactions between molecules are local. This paradigm forms the basis of the language Gamma <ref> [18] </ref>. Program 18 gives an example of a simple reaction. Note that since Lygon (like most logic programming languages) is executed using backwards chaining on clauses the implications are reversed. That is, a clause of the form a b indicates that a can be rewritten to b.
Reference: [19] <author> Erik Barendsen and Sjaak Smetsers. </author> <title> Conventional and uniqueness typing in graph rewrite systems. </title> <type> Technical Report CSI-R9328, </type> <institution> Computing Science Institute, University of Nijmegen, </institution> <month> December </month> <year> 1993. </year>
Reference: [20] <author> Erik Barendsen and Sjaak Smetsers. </author> <title> Conventional and uniqueness typing in graph rewrite systems (extended abstract). </title> <editor> In R. Shyamasundar, editor, </editor> <booktitle> Proceedings of the 13th Conference on the Foundations of Software Technology & Theoretical Computer Science (FST&TCS13), </booktitle> <pages> pages 41-51. </pages> <publisher> Springer-Verlag, LNCS 761, </publisher> <year> 1993. </year>
Reference: [21] <author> Erik Barendsen and Sjaak Smetsers. </author> <title> Uniqueness type inference. </title> <editor> In M. Hermenegildo and D. Swierstra, editors, </editor> <booktitle> Proceedings of Programming Languages: Implementation, Logics and Programs (PLILP'95), </booktitle> <pages> pages 189-207. </pages> <publisher> Springer-Verlag, LNCS 982, </publisher> <year> 1995. </year>
Reference: [22] <author> Gerard Berry and Gerard Boudol. </author> <title> The chemical abstract machine. </title> <booktitle> In Conference Record of the Seventeenth Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 81-94, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: Specifying multiple processes, 2. Communication, and 3. Synchronisation. These are demonstrated in programs 16 and 17. We also show how a range of other paradigms for concurrent programming can be simply and easily embedded in linear logic. Specifically, we embed the Chemical reaction metaphor for concurrent programming <ref> [22] </ref>, the co-ordination language Linda [27, 28], the Actors paradigm [2] and Petri Nets [120]. We finish this section with a solution to the dining philosophers problem. We begin with a simple example which illustrates how we can program two communicating processes in Lygon. <p> In the remainder of this section we provide evidence that linear logic in general and Lygon specifically is expressive in this domain. We embed a number of paradigms for concur-rency in Lygon. As we shall see, in all cases the embedding is direct and straightforward. The chemical reaction paradigm <ref> [22] </ref> views a concurrent program as a solution of reacting molecules. Chemical reactions between molecules are local. This paradigm forms the basis of the language Gamma [18]. Program 18 gives an example of a simple reaction.
Reference: [23] <author> Edoardo S. Biagioni. </author> <title> A Structured TCP in Standard ML. </title> <type> Technical Report CMU-CS-94-171, </type> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <month> July </month> <year> 1994. </year>
Reference: [24] <author> A. W. Bollen. </author> <title> Relevant logic programming. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 7 </volume> <pages> 563-585, </pages> <year> 1991. </year>
Reference-contexts: Unfortunately uniformity is defined in the context of single conclusioned sequent calculi systems. This is a problem since we are interested in a general criteria applicable to a range of both single and multiple conclusion logics including relevant logic <ref> [24] </ref>, temporal and modal logics [118] and linear logic [6, 10, 70, 85, 109, 140, 147]. This chapter continues the investigation into the derivation of logic programming languages. We define a number of formal characterisers (including uniformity) and explore the relationships amongst them.
Reference: [25] <author> A. Bonner and L. McCarty. </author> <title> Adding negation-as-failure to intuitionistic logic programming. </title> <editor> In Saumya Debray and Manuel Hermenegildo, editors, </editor> <booktitle> Proceedings of the 1990 North American Conference on Logic Programming, </booktitle> <pages> pages 681-703, </pages> <address> Austin, </address> <month> October </month> <year> 1990. </year> <title> ALP, </title> <publisher> MIT Press. </publisher>
Reference-contexts: The following proposed solution <ref> [25, 40] </ref> uses implication to add a mark to facts which have been processed and uses negation as failure to ensure that marked facts are not processed a second time. even :- not odd. odd :- select (X), (mark (X) =&gt; even). select (X) :- r (X), not mark (X).
Reference: [26] <author> John Boreczky and Lawrence A. Rowe. </author> <title> Building Common Lisp Applications with Reasonable Performance. </title> <type> Technical Report UCB//CSD-93-763, </type> <institution> University of California at Berkeley, Department of Computer Science, </institution> <month> June </month> <year> 1993. </year> <note> BIBLIOGRAPHY 173 </note>
Reference: [27] <author> Nicholas Carriero and David Gelernter. </author> <title> How to write parallel programs: A guide to the perplexed. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 323-357, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Communication, and 3. Synchronisation. These are demonstrated in programs 16 and 17. We also show how a range of other paradigms for concurrent programming can be simply and easily embedded in linear logic. Specifically, we embed the Chemical reaction metaphor for concurrent programming [22], the co-ordination language Linda <ref> [27, 28] </ref>, the Actors paradigm [2] and Petri Nets [120]. We finish this section with a solution to the dining philosophers problem. We begin with a simple example which illustrates how we can program two communicating processes in Lygon. <p> Program 18 Chemical Paradigm o O o o2. go o O o O h2 O h2 O (neg h2o neg h2o). Another model for concurrency is the co-ordination language Linda <ref> [27, 28] </ref>. Linda provides four primitive operations which can be added to any language to yield a concurrent programming language. Versions of Linda have been built on top of C, Scheme, Modula-2, Prolog and other languages. Linda's basic abstraction is of a shared distributed tuple space.
Reference: [28] <author> Nicholas Carriero and David Gelernter. </author> <title> Linda in context. </title> <journal> Communications of the ACM, </journal> <volume> 32(4) </volume> <pages> 444-458, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Communication, and 3. Synchronisation. These are demonstrated in programs 16 and 17. We also show how a range of other paradigms for concurrent programming can be simply and easily embedded in linear logic. Specifically, we embed the Chemical reaction metaphor for concurrent programming [22], the co-ordination language Linda <ref> [27, 28] </ref>, the Actors paradigm [2] and Petri Nets [120]. We finish this section with a solution to the dining philosophers problem. We begin with a simple example which illustrates how we can program two communicating processes in Lygon. <p> Program 18 Chemical Paradigm o O o o2. go o O o O h2 O h2 O (neg h2o neg h2o). Another model for concurrency is the co-ordination language Linda <ref> [27, 28] </ref>. Linda provides four primitive operations which can be added to any language to yield a concurrent programming language. Versions of Linda have been built on top of C, Scheme, Modula-2, Prolog and other languages. Linda's basic abstraction is of a shared distributed tuple space. <p> Starvation can occur, for example, if all the philosophers simultaneously pick up their right chopsticks and then wait for the left chopstick to become available. This particular solution is adapted from <ref> [28] </ref>. For N philosophers there are N 1 room tickets. Before entering the room each philosopher must take a roomticket from a shelf beside the door. This prevents all of the philosophers from being in the room at the same time.
Reference: [29] <author> Stefania Castellani and Paolo Ciancarini. </author> <title> Exploring the coordination space with LO. </title> <type> Technical Report UBLCS-94-6, </type> <institution> University of Bologna, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: A parallel program is one which is run on multiple processors with the aim of attaining better performance. Often, the result of the computation is deterministic. A number of linear logic programming languages are targeted at concurrent applications (e.g. ACL [85, 88, 128] and LO <ref> [7-10, 29, 42] </ref>) and it has been shown that much of the calculus can be mapped into linear logic [108]. In this section we show how various aspects of concurrency can be expressed in Lygon. Some aspects of concurrency that we shall look at are [17]: 1. <p> The initial query is seen as containing an unknown region which is determined as broadcasts are processed. More recent work with LO involves optimising communication by abstract interpretation [11, 12] and the use of the language as a co-ordination language <ref> [29] </ref>. In [42] LO is used to co-ordinate a distributed diary system whose components were written in Prolog. With the exception of the broadcast mechanism the language is a subset of a number of other languages including ACL, Forum and Lygon. A related language to LO is LinLog.
Reference: [30] <author> Iliano Cervesato. </author> <title> Lollipops taste of vanilla too. </title> <editor> In A. Momigliano and M. Or-naghi, editors, </editor> <booktitle> Proof-Theoretical Extensions of Logic Programming, </booktitle> <pages> pages 60-66, </pages> <address> Santa Margherita Ligure, Italy, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The representation of the context, 2. Resolving against clauses, and 3. Selecting the formula to be reduced. Note that the last of these is specific to Lygon and does not appear in the Lolli meta-interpreter <ref> [30] </ref>. We choose to represent a linear formula F as lin (F) and a non-linear formula ?F as ? nonlin (F).
Reference: [31] <author> Iliano Cervesato, Luca Chittaro, and Angelo Montanari. </author> <title> Modal event calculus in Lolli. </title> <type> Technical Report CMU-CS-94-198, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: It has also been used to specify filler-gap dependency parsers [65]. Lolli has been used to implement event calculus programs by a number of researchers <ref> [5, 31] </ref>. 1 Available from camille.is.s.u-tokyo.ac.jp:pub/hacl. 6.2. CONCURRENT PROGRAMMING 165 Lolli and Lygon are fairly similar in methodology. Roughly speaking, Lolli can be seen as Lygon minus concurrency. Indeed, the class of formulae usable in Lygon 2 is a superset of the Lolli class.
Reference: [32] <author> Iliano Cervesato, Joshua S. Hodas, and Frank Pfenning. </author> <title> Efficient resource management for linear logic proof search. </title> <editor> In R. Dyckhoff, H. Herre, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the Fifth International Workshop on Extensions of Logic Programming ELP'96, LNAI 1050, </booktitle> <pages> pages 67-81. </pages> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: The notion of lazy splitting was introduced in Lolli [69], and a lazy method of finding uniform proofs (known in [69] as an input-output model of resource consumption) is given. An extension of this system presented in Hodas' thesis [66] handles the &gt; rule lazily. In <ref> [32] </ref> the notion of lazy splitting is extended to improve the early detection of failure due to inconsistent resource usage in the two premises of a N rule. It is not clear to what extent typical Lolli or Lygon programs benefit from this optimisation.
Reference: [33] <author> Jawahar Chirimar, Carl A. Gunter, and Jon G. Riecke. </author> <title> Proving memory management invariants for a language based on linear logic. </title> <booktitle> In Lisp and Functional Programming, </booktitle> <pages> pages 139-150. </pages> <publisher> ACM, </publisher> <year> 1992. </year>
Reference-contexts: The two main uses of uniqueness types are to guarantee single threading of side effecting I/O operations and to ensure single threading of data structures in particular arrays to ensure that in place updating can be done safely. This second application can be seen as a garbage collection issue <ref> [33, 143] </ref>. A related application of linear logic is its use to derive functional programming languages. This is done using the Curry-Howard isomorphism which states that there is an equivalence between theorems and types in the -calculus.
Reference: [34] <author> Jawahar Lal Chirimar. </author> <title> Proof Theoretic Approach to Specification Languages. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <year> 1995. </year>
Reference-contexts: Work on Forum has mostly concentrated on its use as a specification language. It has been applied to the specification of an ML-like language, a simple RISC processor <ref> [34] </ref> logical inference systems in both natural deduction and sequent calculus styles [106] and transition systems [104]. There is also a group at Universita di Genova working on object oriented programming in a linear logic framework which use Forum [38].
Reference: [35] <author> Sitt Sen Chok and Kim Marriott. </author> <title> Parsing visual languages. </title> <booktitle> In Proceedings of the Eighteenth Australasian Computer Science Conference, </booktitle> <pages> pages 90-98, </pages> <year> 1995. </year>
Reference-contexts: The goal go1 has a single solution which prints handle: 3. The goal go2 has a single solution which prints Result: 3. We move now to an application of Lygon to parsing. In <ref> [35] </ref> constraint multiset grammars are used to parse visual programming languages. Since the linear context is just a multiset this fits in quite nicely with Lygon and suggests that a Lygon implementation of a parser for constraint multiset grammars ought to be straightforward. <p> A final state consists of two nested circles and a label. A start state is a state which is the target of a startarc. A state which is not one of the above is normal. * A trans (ition) is an arc between two states. The rule given in <ref> [35] </ref> is awkward in Lygon since it makes use of non-consuming sub-derivations. The basic problem is that a transition needs to be able to reference its source and destination states; however there can be more than one transition to or from a given state.
Reference: [36] <author> Andrew Davison. </author> <title> A concurrent logic programming encoding of Petri nets. </title> <editor> In G. Gupta, G. Mohag, and R. Topor, editors, </editor> <booktitle> Proceedings of the 16th Australian Computer Science Conference, </booktitle> <pages> pages 379-386, </pages> <year> 1993. </year>
Reference-contexts: In the Petri net above, the only enabled transition is from a to b and it fires by removing the token from a and placing a token on b. Davison <ref> [36] </ref> investigates modelling Petri nets in the guarded Horn clause language Parlog ([50] and [125, chapter 3]). The Lygon realisation below is simpler and more concise. In Lygon (program 21) the Petri net in figure 5.5 is encoded as: t (a) t (b). t (c) t (b) O t (d).
Reference: [37] <author> W. De Hoon. </author> <title> Designing a spreadsheet in a pure functional graph rewriting language. </title> <type> Master's thesis, </type> <institution> Catholic University Nijmegen, </institution> <year> 1993. </year>
Reference: [38] <author> Giorgio Delzanno and Maurizio Martelli. </author> <title> Objects in Forum. </title> <editor> In John Lloyd, editor, </editor> <booktitle> International Logic Programming Symposium, </booktitle> <pages> pages 115-129, </pages> <address> Portland, Oregon, December 1995. </address> <publisher> MIT Press. </publisher>
Reference-contexts: There is also a group at Universita di Genova working on object oriented programming in a linear logic framework which use Forum <ref> [38] </ref>. The class of program formulae permitted by Lygon 2 is precisely a normalised form [106] of the Forum class of program formulae excluding ? headed clauses. Forum's class of goal formulae is limited to asynchronous formulae.
Reference: [39] <author> Denys Duchier. </author> <title> The Oz programming system. </title> <note> http://ps-www.dfki.uni-sb.de/oz/, 1996. </note>
Reference-contexts: Although these languages have become less prominent in the research community they are still alive see for example [76, 77]. A survey of first generation concurrent logic programming can be found in [126]. The second generation includes such languages as AKL [80] and Oz <ref> [39] </ref>. These languages move away from the proof search interpretation of computation and view processes as operating over a shared constraint store. As a result it becomes difficult to view these languages as logic programming languages.
Reference: [40] <author> P. Dung. </author> <title> Hypothetical logic programming. </title> <booktitle> In Proc. 3rd International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 61-73. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The following proposed solution <ref> [25, 40] </ref> uses implication to add a mark to facts which have been processed and uses negation as failure to ensure that marked facts are not processed a second time. even :- not odd. odd :- select (X), (mark (X) =&gt; even). select (X) :- r (X), not mark (X).
Reference: [41] <author> Roy Dyckhoff. </author> <title> Contraction-free sequent calculi for intuitionistic logic. </title> <journal> The Journal of Symbolic Logic, </journal> <volume> 57(3) </volume> <pages> 795-807, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: SEQUENT CALCULUS 9 and are multisets. ; p ` p; ; ? ` ; F; G ` ^ L ` F ^ G; ; F ` ; G ` _ L ` F _ G; ; F ! G ` F ; G ` ! L ` F ! G; <ref> [41] </ref> presents a group of rules which replace ! L: ; G; F ` ! L 1 ; (E ^ H) ! G ` ; E ! G; H ! G ` ! L 3 ; (E ! H) ! G ` rule becomes ` p; :p In figure 2.6 a <p> However, if we replace the standard _ R rule with the rule: ` F 1 ; F 2 ; _ R and modify the rest of the calculus accordingly (see <ref> [41] </ref>) then the sequent has a uniform proof and programs can contain top-level disjunctions. Thirdly, uniformity does not constrain the search for the proof of a sequent with (only) atomic goals.
Reference: [42] <author> Norbert Eisinger. </author> <title> A multi-agent diary manager coordinated with LO. </title> <type> Technical Report ECRC-93-11, </type> <institution> European Computer-Industry Research Centre (ECRC), ECRC GMBH Arabellastr. 17, D-81925 M unchen, Germany, </institution> <month> July </month> <year> 1993. </year> <note> 174 BIBLIOGRAPHY </note>
Reference-contexts: A parallel program is one which is run on multiple processors with the aim of attaining better performance. Often, the result of the computation is deterministic. A number of linear logic programming languages are targeted at concurrent applications (e.g. ACL [85, 88, 128] and LO <ref> [7-10, 29, 42] </ref>) and it has been shown that much of the calculus can be mapped into linear logic [108]. In this section we show how various aspects of concurrency can be expressed in Lygon. Some aspects of concurrency that we shall look at are [17]: 1. <p> The initial query is seen as containing an unknown region which is determined as broadcasts are processed. More recent work with LO involves optimising communication by abstract interpretation [11, 12] and the use of the language as a co-ordination language [29]. In <ref> [42] </ref> LO is used to co-ordinate a distributed diary system whose components were written in Prolog. With the exception of the broadcast mechanism the language is a subset of a number of other languages including ACL, Forum and Lygon. A related language to LO is LinLog.
Reference: [43] <author> Ian Foster and Stephen Taylor. Strand: </author> <title> A practical parallel programming tool. </title> <editor> In Ewing L. Lusk and Ross A. Overbeek, editors, </editor> <booktitle> Logic Programming, Proc. of the North American Conference, </booktitle> <pages> pages 497-512, </pages> <address> Cleveland, 1989. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: The disadvantage is primarily a cluttering of the syntax. The first clause of produce states that under appropriate conditions an ack message and a produce (3) process can evolve to produce (2) and a mesg (1). Note that unlike standard concurrent logic programming languages such as Strand <ref> [43] </ref>, GHC [125, chapter 4], Parlog [50] and [125, chapter 3] and Concurrent Prolog [125, chapters 2 & 5] communication is orthogonal to unification. Unification (the underlying primitive operation of logic programming) is not tampered with. <p> If the unification could succeed by binding a variable in A then it suspends. This suspension is the synchronisation primitive. Languages in this first generation included Parlog [50], Concurrent Prolog [125, chapters 2 & 5], GHC [125, chapter 4] and, later, Strand <ref> [43] </ref>. Although these languages have become less prominent in the research community they are still alive see for example [76, 77]. A survey of first generation concurrent logic programming can be found in [126]. The second generation includes such languages as AKL [80] and Oz [39].
Reference: [44] <author> Didier Galmiche and Guy Perrier. </author> <title> On proof normalization in linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 135(1) </volume> <pages> 67-110, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: In the following two sections we prove that the resulting lazy system is sound and complete with respect to the standard one sided sequent calculus for linear logic. In section 4.4 we discuss the second problem and note that the observations in <ref> [6, 44] </ref> can be used to provide a heuristic that (partially) solves the second problem. We conclude the chapter with a brief discussion. 78 CHAPTER 4. IMPLEMENTATION ISSUES 4.1 The Challenge of Being Lazy The standard formulation of the inference rules for linear logic have a significant amount of nondeterminism. <p> The situations in which Lygon can safely use don't care nondeterminism to select the active formula can be partially detected by using permutability properties. In particular we use the results of Andreoli [6] and Galmiche and Perrier <ref> [44] </ref>. This section briefly summarises the results of the two papers. For more details we refer the reader to the papers themselves. Note that there is a fair amount of overlap in the results of the two papers although their motivation is different. <p> It is easy to verify that the lazy-splitting proof produced conserves the structure of the proof. ffi THEOREM 121 (COMPLETENESS OF OPTIMISATIONS) If there is a proof in the lazy-splitting sequent calculus then a proof search incorporating the observations above will find it. Proof: Theorem 6.1 of <ref> [44] </ref> states that if a sequent is provable then there exists a normal proof that is, a proof which satisfies the optimisations discussed. <p> Secondly, and perhaps more importantly, our presentation allows us to simply use the permutability properties explored in <ref> [6, 44] </ref> to reduce the nondeterminism associated with selecting the formula to be reduced. In the Lolli encoding, selecting the next formula to be reduced is done by the resolution rule.
Reference: [45] <author> G. </author> <title> Gentzen. Investigations into logical deductions, 1935. In M.E. </title> <editor> Szabo, editor, </editor> <booktitle> The Collected Papers of Gerhard Gentzen, </booktitle> <pages> pages 68-131. </pages> <publisher> North-Holland Publishing Co., </publisher> <address> Amsterdam, </address> <year> 1969. </year>
Reference-contexts: We compare Lygon to other work in chapter 6 and conclude with a discussion and a brief look at further work (chapter 7). 4 Introduction 5 Chapter 2 Background 2.1 Sequent Calculus The sequent calculus is a formalism due to Gentzen <ref> [45] </ref> for representing inferences and proofs. It is the standard notation used in the proof theoretical analysis of logic programming since it distinguishes naturally between programs and goals. <p> Single conclusioned calculi do not possess the right contraction and right exchange rules. One of the important early results in the area is that limiting the standard sequent calculus for classical logic to a single conclusion gives a sequent calculus for intuitionistic logic <ref> [45] </ref>. Note that there exists a multiple conclusioned sequent calculus for intuitionistic logic (given in figure 2.3). A sequent calculus is one sided if all succedents (or all antecedents) are empty. <p> The cut elimination theorem is also known as Gentzen's Hauptsatz (main theorem) <ref> [45] </ref>. The cut elimination property has been shown to hold for all of the logics we shall be considering. That cut 3 Note that the rule given in figure 2.7 corresponds to an additive presentation of the cut rule.
Reference: [46] <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: A sequent calculus is one sided if all succedents (or all antecedents) are empty. This can be achieved by shifting formulae across the turnstile by negating them and then using de Morgan rules to push negations inwards. Linear logic was first presented <ref> [46] </ref> as a one sided system since there are half as many rules involved. For example, to construct a one sided sequent calculus for classical logic we can replace sequents ` with sequents ` :; and push negations inwards. <p> For more details we refer the reader to [81]. 2.3 Linear Logic Linear logic was introduced in a seminal 1987 paper by Girard <ref> [46] </ref> and has since inspired much work in the computer science and mathematical communities. Whereas classical logic can be said to be based on the intuitive notion of truth, linear logic is intuitively based on the notion of resources. A predicate in linear logic is a resource.
Reference: [47] <author> Jean-Yves Girard. </author> <title> Linear logic : Its syntax and semantics. </title> <editor> In Jean-Yves Girard, Yves Lafont, and Laurent Regnier, editors, </editor> <booktitle> Advances in Linear Logic, chapter 0. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1995. </year>
Reference-contexts: iff for any finite subset P of D and for any G in G DEFINITION 4 Criterion x is stronger than criterion y (written x y) if we have that 8 8F ` x F ) ` y F 5 A logic without cut-elimination is like a car without engine <ref> [47] </ref> 30 CHAPTER 3. DERIVING LOGIC PROGRAMMING LANGUAGES Let x y. If &lt; D; G; `&gt; is deemed to be an ALPL by criterion x then it is also deemed to be an ALPL by criterion y. We write x 6 y when x is not stronger than y.
Reference: [48] <author> J.Y. Girard. </author> <title> Logic and exceptions: A few remarks. </title> <type> Technical Report 18, </type> <institution> Equipe de logique Mathematique, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: Our final artificial intelligence related example involves non-monotonic reasoning. A logic is non-monotonic if the addition of a fact can cause old facts to become false. Classical logic is monotonic and as a result, attempts at capturing non-monotonic reasoning in classical logic have been complicated. Girard <ref> [48] </ref> argues that linear logic is a good candidate for capturing non-monotonic reasoning. A common application for non-monotonic reasoning is reasoning about exceptional situations and taxonomies. For example, as a rule, birds fly and chirp. We also know that penguins are birds but that they do not fly. <p> We want flying behavior to be suppressed in penguins but not chirping behavior. In order to achieve this antifly must be fly specific. By having antifly consume an instance of fly the correct behavior occurs. antifly neg fly ? Girard refers to antifly as a kamikaze <ref> [48] </ref>.
Reference: [49] <author> J.Y. Girard and Y. Lafont. </author> <title> Linear logic and lazy computation. </title> <booktitle> In TAPSOFT. </booktitle> <publisher> Springer-Verlag LNCS 250, </publisher> <year> 1987. </year>
Reference-contexts: This is done using the Curry-Howard isomorphism which states that there is an equivalence between theorems and types in the -calculus. This has been applied by Mackie [98, 99], Abramsky [1], Lafont [91, 92] and Lafont and Girard <ref> [49] </ref> to derive a linear version of the -calculus. The resulting languages are rather different to logic programming languages. Formally, the execution model in functional programming is based on the reduction of proofs through cut elimination whereas in logic programming the execution model is based on proof search.
Reference: [50] <author> S. Gregory. </author> <title> Parallel logic programming in PARLOG. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mass., </address> <year> 1987. </year>
Reference-contexts: The first clause of produce states that under appropriate conditions an ack message and a produce (3) process can evolve to produce (2) and a mesg (1). Note that unlike standard concurrent logic programming languages such as Strand [43], GHC [125, chapter 4], Parlog <ref> [50] </ref> and [125, chapter 3] and Concurrent Prolog [125, chapters 2 & 5] communication is orthogonal to unification. Unification (the underlying primitive operation of logic programming) is not tampered with. <p> For example, in GHC, unifying a goal A with the head of clause cannot bind variables in A. If the unification could succeed by binding a variable in A then it suspends. This suspension is the synchronisation primitive. Languages in this first generation included Parlog <ref> [50] </ref>, Concurrent Prolog [125, chapters 2 & 5], GHC [125, chapter 4] and, later, Strand [43]. Although these languages have become less prominent in the research community they are still alive see for example [76, 77]. A survey of first generation concurrent logic programming can be found in [126].
Reference: [51] <author> Alessio Guglielmi. </author> <title> Concurrency and plan generation in a logic programming language with a sequential operator. </title> <editor> In Pascal Van Hentenryck, editor, </editor> <booktitle> Logic Programming Proceedings of the Eleventh International Conference on Logic Programming, </booktitle> <pages> pages 240-254, </pages> <institution> Massachusetts Institute of Technology, </institution> <address> 1994. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: We seek to model the state of the world and of operations on it. Our presentation is based on [101-103]. This program was independently written by Alessio Guglielmi <ref> [51] </ref>.
Reference: [52] <author> S. Hanks and D. MacDermott. </author> <title> Nonmonotonic logic and temporal projection. </title> <journal> Artificial Intelligence, </journal> <volume> 33(3) </volume> <pages> 379-412, </pages> <year> 1987. </year>
Reference-contexts: We look at a number of examples: 1. The Yale shooting problem: a prototypical example of the frame problem. 2. Blocks world: an example planning problem. 3. Default reasoning. The Yale shooting problem <ref> [52] </ref> is a prototypical example of a problem involving actions. The main technical challenge in the Yale shooting problem is to model the ap propriate changes of state, subject to certain constraints. In particular: 1. Loading a gun changes its state from unloaded to loaded; 2.
Reference: [53] <author> J. Harland. </author> <title> On normal forms and equivalence for logic programs. </title> <editor> In Krzysztof Apt, editor, </editor> <booktitle> Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 146-160, </pages> <address> Washington, USA, November 1992. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Firstly as discussed in section 3.1 there are problems associated with the blind use of equivalences derived using full linear logic when the proof search process is goal directed. The relationship between goal directed (i.e. operational) equivalence and logical equivalence is nontrivial and involves intermediate logics <ref> [53] </ref>. The logical equivalence of two formulae only implies operational equivalence if the two formulae are within the appropriate subset.
Reference: [54] <author> James Harland. </author> <title> On Hereditary Harrop Formulae as a Basis for Logic Programming. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1991. </year>
Reference-contexts: G ::= D ! G j :D). Note that although the syntax is similar to hereditary Harrop formulae <ref> [54, 105] </ref> the semantics is different since the proof rules are those of classical logic.
Reference: [55] <author> James Harland. </author> <title> On goal-directed provability in classical logic. </title> <booktitle> In Proceedings of the ICLP '94 Post-conference Workshop on Proof-Theoretical Extensions of Logic Programming, </booktitle> <pages> pages 10-18, </pages> <address> Santa Margherita Ligure, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Unfortunately, it suffers from a number of problems. Firstly, uniformity is only defined for single conclusion sequent systems 1 . A straightforward extension to a multiple conclusion setting is fairly obvious <ref> [55, 106, 109, 140] </ref> but it requires that all connectives occurring in goals permute over each other are-striction which we shall see is unnecessary. Another problem with a simple generalisation of uniformity to multiple conclusion sequent systems involves one sided presentations. <p> We begin by reviewing existing relevant work. As far as we are aware there is little existing work which applies the idea of uniformity to determine (in a proof theoretical manner) a logic programming language based on classical logic. In <ref> [55] </ref> the criteria D all and D some (introduced in the next section) are used to derive logic programming languages based on classical logic. The conclusions drawn in the paper are that: 1. D some does not produce any non-trivial languages that do not also satisfy D all . 2. <p> LEMMA 89 (LEMMA 3 OF <ref> [55] </ref>) Let and be respectively a program and goal in SLK. Then ` is provable iff ` F is provable for some F 2 . What is happening is that the omission of ! R and : R prevents the multiple goals from interacting. Thus our results confirm those of [55] <p> <ref> [55] </ref>) Let and be respectively a program and goal in SLK. Then ` is provable iff ` F is provable for some F 2 . What is happening is that the omission of ! R and : R prevents the multiple goals from interacting. Thus our results confirm those of [55] there do not seem to be any interesting languages based on classical logic which satisfy D S but not D A . This should not be 66 CHAPTER 3. <p> In the absence of a notion of atom-guided proof search, the options that have been considered in order to extend uniformity to a multiple conclusion setting <ref> [55, 106, 140] </ref> are: D all : For a sequent of the form ` C; A or ` C there exist proofs where the first step introduces the topmost connective of F for all F 2 C.
Reference: [56] <author> James Harland. </author> <title> A proof-theoretic analysis of goal-directed provability. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(1) </volume> <pages> 69-88, </pages> <year> 1994. </year>
Reference-contexts: Let us consider as an example the multiple conclusioned presentation of intuition-istic logic presented in figure 2.3 on page 9. Since intuitionistic logic has seen a fair amount of work and some definite conclusions <ref> [56] </ref> this is a good test. Consider the proof of the sequent p _ q ` p _ q. Using the standard (single conclu-sioned) rules for intuitionistic logic this sequent has a proof but the proof must begin by applying a left rule.
Reference: [57] <author> James Harland and David Pym. </author> <title> A note on the implementation and applications of linear logic programming languages. </title> <editor> In Gopal Gupta, editor, </editor> <booktitle> Seventeenth Annual Australasian Computer Science Conference, </booktitle> <pages> pages 647-658, </pages> <year> 1994. </year> <note> BIBLIOGRAPHY 175 </note>
Reference-contexts: As a result the implementation problems are correspondingly simpler, in that neither language needs lazy splitting 1 , and so again the problems addressed in this paper do not arise. The last class of linear logic programming languages comprises Lolli [68-70], Forum [109] and Lygon <ref> [57, 122, 149] </ref>. These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful.
Reference: [58] <author> James Harland, David Pym, and Michael Winikoff. </author> <title> Programming in Lygon: A brief overview. </title> <editor> In John Lloyd, editor, </editor> <booktitle> International Logic Programming Symposium, </booktitle> <pages> page 636, </pages> <address> Portland, Oregon, December 1995. </address> <publisher> MIT Press. </publisher>
Reference: [59] <author> James Harland, David Pym, and Michael Winikoff. </author> <title> Programming in Lygon: A system demonstration. </title> <editor> In Martin Wirsing and Maurice Nivat, editors, </editor> <booktitle> Algebraic Methodology and Software Technology, </booktitle> <volume> LNCS 1101, </volume> <pages> page 599. </pages> <publisher> Springer, </publisher> <month> July </month> <year> 1996. </year>
Reference: [60] <author> James Harland, David Pym, and Michael Winikoff. </author> <title> Programming in Lygon: An overview. </title> <editor> In Martin Wirsing and Maurice Nivat, editors, </editor> <booktitle> Algebraic Methodology and Software Technology, </booktitle> <volume> LNCS 1101, </volume> <pages> pages 391-405. </pages> <publisher> Springer, </publisher> <month> July </month> <year> 1996. </year>
Reference: [61] <author> James Harland, David Pym, and Michael Winikoff. </author> <title> Bottom-up execution of linear logic programming languages. </title> <type> Technical Report 97/1, </type> <institution> Melbourne University, Department of Computer Science, </institution> <address> Parkville 3052, AUSTRALIA, </address> <year> 1997. </year>
Reference-contexts: Here we begin with the knowledge that q and r hold and we then conclude from the rule that p must hold. Since bottom up computation is not goal directed, generalising it to linear logic is an open area of research <ref> [61] </ref>. Program 32 illustrates how we can emulate simple bottom up processing in Lygon. We have a collection of facts which are known to hold and we apply rules backwards to derive new facts. <p> The derivation of bottom-up logic programming languages for non-classical logics has only recently begun to be explored <ref> [61] </ref>. Applications for the resulting languages include active databases. 170 CHAPTER 7. CONCLUSIONS AND FURTHER WORK
Reference: [62] <author> P. H. Hartel. </author> <title> Benchmarking implementations of lazy functional languages II - two years later. </title> <type> Technical Report CS-94-21, </type> <institution> Dept. of Comp. Sys, Univ. of Am-sterdam, </institution> <month> December </month> <year> 1994. </year>
Reference: [63] <author> Pieter Hartel and Koen Langendoen. </author> <title> Benchmarking implementations of lazy functional languages. </title> <booktitle> In Functional Programming & Computer Architecture, </booktitle> <pages> pages 341-349, </pages> <address> Copenhagen, </address> <month> June 93. </month>
Reference: [64] <author> Fergus Henderson. </author> <title> Home page of the Mercury project. </title> <note> http://www.cs.mu.oz.au/mercury, 1996. </note>
Reference-contexts: In particular, we look at functional programming languages based on linear language and at uniqueness types. Uniqueness types apply the concept of linearity to values in a (usually declarative) programming language. Uniqueness types exist in Clean [19-21, 130], Mercury <ref> [64, 132, 133] </ref> and in a version of Lisp developed by Henry Baker [13-16]. Uniqueness types are inspired by linear logic but in general they make use of a very limited subset of the logic.
Reference: [65] <author> Joshua Hodas. </author> <title> Specifying filler-gap dependency parsers in a linear-logic programming language. </title> <editor> In K. Apt, editor, </editor> <booktitle> Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 622-636. </pages> <publisher> MIT Press, </publisher> <month> November </month> <year> 1992. </year>
Reference-contexts: The language has been used for a number of example programs [66] which demonstrate basic techniques of linear logic programming (for example, permutations, toggling etc.). It has also been used to specify filler-gap dependency parsers <ref> [65] </ref>. Lolli has been used to implement event calculus programs by a number of researchers [5, 31]. 1 Available from camille.is.s.u-tokyo.ac.jp:pub/hacl. 6.2. CONCURRENT PROGRAMMING 165 Lolli and Lygon are fairly similar in methodology. Roughly speaking, Lolli can be seen as Lygon minus concurrency.
Reference: [66] <author> Joshua Hodas. </author> <title> Logic Programming in Intuitionistic Linear Logic: Theory, Design and Implementation. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <year> 1994. </year>
Reference-contexts: Induction: If the conclusion of a left rule has an empty goal then so does at least one premise of the rule. Hence no sequent with an empty goal can be proven. ffi PROPOSITION 37 Lolli satisfies criterion D strong Proof: See <ref> [66] </ref>. The proof basically involves the use of permutability properties to transform a given proof into one satisfying D strong . ffi COROLLARY:Lolli satisfies criteria D weak and C. We now look at showing that Lolli satisfies criterion E. <p> The notion of lazy splitting was introduced in Lolli [69], and a lazy method of finding uniform proofs (known in [69] as an input-output model of resource consumption) is given. An extension of this system presented in Hodas' thesis <ref> [66] </ref> handles the &gt; rule lazily. In [32] the notion of lazy splitting is extended to improve the early detection of failure due to inconsistent resource usage in the two premises of a N rule. <p> The class of formulae allowed in LC is a subset of the Lygon 2 class. Since LC (like ACL and LO) sacrifices completeness by implementing don't care nondeterminism, it is incapable of expressing programs involving backtracking such as the graph search programs of section 5.3. Lolli Lolli <ref> [66, 69, 70] </ref> (named for the lollipop connective of linear logic (()) was the first linear logic based logic programming language to be designed using uniformity. <p> The Lolli implementation [68] is available from its World Wide Web page [67]. Note that F ) G is defined as (!F ) ( G, this is also the case for Forum. The language has been used for a number of example programs <ref> [66] </ref> which demonstrate basic techniques of linear logic programming (for example, permutations, toggling etc.). It has also been used to specify filler-gap dependency parsers [65]. Lolli has been used to implement event calculus programs by a number of researchers [5, 31]. 1 Available from camille.is.s.u-tokyo.ac.jp:pub/hacl. 6.2.
Reference: [67] <author> Joshua Hodas. </author> <note> Lolli home page. http://www.cs.hmc.edu/hodas/research/lolli/, 1995. </note>
Reference-contexts: Apart from being based on intuitionistic linear logic and thus not allowing O (which is needed for the concurrent applications of linear logic) Lolli is a rich language, particularly in its class of program formulae. The Lolli implementation [68] is available from its World Wide Web page <ref> [67] </ref>. Note that F ) G is defined as (!F ) ( G, this is also the case for Forum. The language has been used for a number of example programs [66] which demonstrate basic techniques of linear logic programming (for example, permutations, toggling etc.).
Reference: [68] <author> Joshua S. Hodas. </author> <title> Lolli: An extension of prolog with linear context management. </title> <editor> In D. Miller, editor, </editor> <booktitle> Workshop on the Prolog Programming Language, </booktitle> <pages> pages 159-168, </pages> <address> Philadelphia, Pennsylvania, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: As we shall see, the linear context can model general state based operations. We begin with a simple example which uses the linear context to store some state information. Program 2 (taken from <ref> [68, 70] </ref>) stores a single bit of information and toggles it. The effect of a call to toggle in a context containing the fact off is to consume the fact and add the fact on. <p> Apart from being based on intuitionistic linear logic and thus not allowing O (which is needed for the concurrent applications of linear logic) Lolli is a rich language, particularly in its class of program formulae. The Lolli implementation <ref> [68] </ref> is available from its World Wide Web page [67]. Note that F ) G is defined as (!F ) ( G, this is also the case for Forum.
Reference: [69] <author> Joshua S. Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intu-itionistic linear logic (extended abstract). </title> <booktitle> In Proc. IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 32-42. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: Other 32 CHAPTER 3. DERIVING LOGIC PROGRAMMING LANGUAGES papers (for example [70]) do not specify which right rule. Note that for a single conclusion setting with no structural rules (for example Lolli <ref> [69, 70] </ref>) these two definitions coincide. Our definition of D weak allows for any right rule to be used and D strong requires that the right rule introduce the goal's topmost connective. <p> According to proposition 29 it therefore satisfies criterion F . ffi 3.4.2 Lolli Lolli was introduced in <ref> [69] </ref>. For our purposes it can be viewed essentially as a single conclusion version of Lygon 6 . <p> These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful. The notion of lazy splitting was introduced in Lolli <ref> [69] </ref>, and a lazy method of finding uniform proofs (known in [69] as an input-output model of resource consumption) is given. An extension of this system presented in Hodas' thesis [66] handles the &gt; rule lazily. <p> These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful. The notion of lazy splitting was introduced in Lolli <ref> [69] </ref>, and a lazy method of finding uniform proofs (known in [69] as an input-output model of resource consumption) is given. An extension of this system presented in Hodas' thesis [66] handles the &gt; rule lazily. <p> The class of formulae allowed in LC is a subset of the Lygon 2 class. Since LC (like ACL and LO) sacrifices completeness by implementing don't care nondeterminism, it is incapable of expressing programs involving backtracking such as the graph search programs of section 5.3. Lolli Lolli <ref> [66, 69, 70] </ref> (named for the lollipop connective of linear logic (()) was the first linear logic based logic programming language to be designed using uniformity.
Reference: [70] <author> Joshua S. Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuition-istic linear logic. </title> <journal> Information and Computation, </journal> <volume> 10(2) </volume> <pages> 327-365, </pages> <year> 1994. </year>
Reference-contexts: Note that the grammar given in figure 2.8 for Lygon is the one developed in [122]. In section 3.11 we derive a different version of the language (which we called Lygon 2 ) which we propose as a replacement for the earlier language design. 20 CHAPTER 2. BACKGROUND Lolli <ref> [70] </ref> D ::= &gt; j A j D N D j G ( D j G ) D j 8x:D ACL [85] G ::= ? j &gt; j A m j?A m j A p j G O G j G N G j 8xG j R m : : : <p> Unfortunately uniformity is defined in the context of single conclusioned sequent calculi systems. This is a problem since we are interested in a general criteria applicable to a range of both single and multiple conclusion logics including relevant logic [24], temporal and modal logics [118] and linear logic <ref> [6, 10, 70, 85, 109, 140, 147] </ref>. This chapter continues the investigation into the derivation of logic programming languages. We define a number of formal characterisers (including uniformity) and explore the relationships amongst them. We begin with single conclusion logics and then generalise to the multiple conclusion setting. <p> An obvious example is the use of logical variables and unification to delay the choice of a term in the 9 R and 8 L rules. Another example is the handling of the R rule in linear logic based programming languages <ref> [70, 150] </ref> (see also chapter 4). An additional problem with the use 3.3. THE SINGLE CONCLUSION CASE 29 of efficiency as a characteriser is that the vast majority of logic programming languages and systems omit the occur check. This yields efficiency but costs sound ness. <p> The wording in [112] requires that a non-atomic goal be the conclusion of the right rule which introduces its topmost connective - i.e. the appropriate logical rule. Other 32 CHAPTER 3. DERIVING LOGIC PROGRAMMING LANGUAGES papers (for example <ref> [70] </ref>) do not specify which right rule. Note that for a single conclusion setting with no structural rules (for example Lolli [69, 70]) these two definitions coincide. <p> Other 32 CHAPTER 3. DERIVING LOGIC PROGRAMMING LANGUAGES papers (for example [70]) do not specify which right rule. Note that for a single conclusion setting with no structural rules (for example Lolli <ref> [69, 70] </ref>) these two definitions coincide. Our definition of D weak allows for any right rule to be used and D strong requires that the right rule introduce the goal's topmost connective. <p> Note that most of the languages in figure 2.8 are multiple conclusion and are covered in section 3.6. Both languages in this section have been shown (in [112] and <ref> [70] </ref> respectively) to satisfy uniformity. The contribution here is to show that they also satisfy criterion F . Since criterion F is stronger than uniformity this is a new result. 3.4.1 Pure Prolog Prolog is often presented as a language based on classical logic which is multiple conclusion. <p> As we shall see, the linear context can model general state based operations. We begin with a simple example which uses the linear context to store some state information. Program 2 (taken from <ref> [68, 70] </ref>) stores a single bit of information and toggles it. The effect of a call to toggle in a context containing the fact off is to consume the fact and add the fact on. <p> Assuming that the cycle is represented as a list, then the test routine will only need to check that the tail of the list of nodes in the cycle is a permutation of the list of nodes in the graph. Hodas and Miller <ref> [70] </ref> have shown that such permutation problems can be solved simply in linear logic programming languages by asserting each element of each list into an appropriately named predicate, such as list1 and list2, and testing that list1 and list2 5.3. GRAPHS 129 have exactly the same solutions. <p> ::= !8x (G ( A p ) R ::= 9x (A ? m G) j R R D ::= !8x (G ( A 1 O : : : O A n ) G ::= A j 1 ? j &gt; j G O G j G G j 9xG Lolli <ref> [70] </ref>: D ::= &gt; j A j D N D j G ( D j G ) D j 8x:D Forum [106]: D ::= G G ::= A j G O G j G N G j G ( G j G ) G j &gt; j ? j 8xG Lygon <p> The class of formulae allowed in LC is a subset of the Lygon 2 class. Since LC (like ACL and LO) sacrifices completeness by implementing don't care nondeterminism, it is incapable of expressing programs involving backtracking such as the graph search programs of section 5.3. Lolli Lolli <ref> [66, 69, 70] </ref> (named for the lollipop connective of linear logic (()) was the first linear logic based logic programming language to be designed using uniformity.
Reference: [71] <author> Joshua S. Hodas and Jeffrey Polakow. </author> <title> Forum as a logic programming language: Preliminary results and observations. </title> <note> http://www.cs.hmc.edu/hodas/papers/, 1996. 176 BIBLIOGRAPHY </note>
Reference-contexts: IMPLEMENTATION ISSUES Additionally, our solution handles the Lolli language as a simple case in which all sequents just happen to have a single formula. Our solution is also applicable to Forum <ref> [71] </ref>. <p> Forum includes ? in programs and in clause heads and as a result it is more of a specification language than a logic programming language. Both of Forum's designers have commented <ref> [71, 111] </ref> that Forum does not appear to be a logic programming language. Two of the reasons why Forum is too expressive to be considered a logic programming language involve higher order quantification. The third is the presence of program clauses of the form G ( ?.
Reference: [72] <author> Jonathan Hogg and Philip Wadler. </author> <title> Real world applications of functional programming. </title> <note> Available from http://www.dcs.gla.ac.uk/fp/realworld/, November 1996. </note>
Reference: [73] <author> H. Hosoya, N. Kobayashi, and A. Yonezawa. </author> <title> Partial evaluation for concurrent languages and its correctness. </title> <note> Technical Report To Appear., </note> <institution> Department of Information Science, University of Tokyo, </institution> <year> 1996. </year>
Reference-contexts: The actual language 1 [128] is an ML-like functional programming language with concurrency primitives inspired by linear logic's connectives. Some early work with ACL looked at process equivalence relations [86]. More recent work centers around the development of language tools such partial evaluators <ref> [73] </ref> and abstract interpreters [84]. ACL has also been used as an implementation language for a concurrent object-oriented programming language and in this context there has been work on providing a type system for the language which is capable of detecting message not understood errors at compile time [87].
Reference: [74] <author> Paul Hudak. </author> <title> Conception, evolution and application of functional programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 359-411, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: In some cases the third logic is just one of the previous two but in general this is not the case. When the implementation makes use of sophisticated algorithms (for example, lazy evaluation for functional languages <ref> [74, 75] </ref>, co-routining [116] or constraint solving [79] for logic programming languages, or indeed, lazy resource allocation for linear logic programming languages) it becomes infeasible to use the implementation rules as a way of visualising execution.
Reference: [75] <author> John Hughes. </author> <title> Why functional programming matters. </title> <editor> In David A. Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, University of Texas at Austin Year of Programming Series, chapter 2, </booktitle> <pages> pages 17-42. </pages> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: In some cases the third logic is just one of the previous two but in general this is not the case. When the implementation makes use of sophisticated algorithms (for example, lazy evaluation for functional languages <ref> [74, 75] </ref>, co-routining [116] or constraint solving [79] for logic programming languages, or indeed, lazy resource allocation for linear logic programming languages) it becomes infeasible to use the implementation rules as a way of visualising execution.
Reference: [76] <author> Matthew Huntbach. </author> <title> An introduction to RGDC as a concurrent object-oriented language. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 8(5) </volume> <pages> 29-37, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: This suspension is the synchronisation primitive. Languages in this first generation included Parlog [50], Concurrent Prolog [125, chapters 2 & 5], GHC [125, chapter 4] and, later, Strand [43]. Although these languages have become less prominent in the research community they are still alive see for example <ref> [76, 77] </ref>. A survey of first generation concurrent logic programming can be found in [126]. The second generation includes such languages as AKL [80] and Oz [39]. These languages move away from the proof search interpretation of computation and view processes as operating over a shared constraint store.
Reference: [77] <author> Matthew M. Huntbach and Graem A. </author> <title> Ringwood. </title> <booktitle> Programming in concurrent logic languages. IEEE Software, </booktitle> <pages> pages 71-82, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: This suspension is the synchronisation primitive. Languages in this first generation included Parlog [50], Concurrent Prolog [125, chapters 2 & 5], GHC [125, chapter 4] and, later, Strand [43]. Although these languages have become less prominent in the research community they are still alive see for example <ref> [76, 77] </ref>. A survey of first generation concurrent logic programming can be found in [126]. The second generation includes such languages as AKL [80] and Oz [39]. These languages move away from the proof search interpretation of computation and view processes as operating over a shared constraint store.
Reference: [78] <author> Graham Hutton. </author> <title> Higher-order functions for parsing. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3) </volume> <pages> 323-343, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Finding ways of using new programming constructs can be highly non-trivial. Programming idioms such as monads in functional programming languages [141, 142] have taken a number of years to emerge. Other examples of non-obvious programming idioms include combinator parsers in functional programming languages <ref> [78] </ref>, difference lists in logic programming languages etc. [117, 134]. In our examples we develop a number of linear logic programming idioms particular ways of using linear logic connectives to achieve a particular behavior. After introducing Lygon from the programmer's perspective, we introduce a number of basic idioms.
Reference: [79] <author> Joxan Jaffar and Jean-Louis Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Conference Record of the Fourteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 111-119, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: In some cases the third logic is just one of the previous two but in general this is not the case. When the implementation makes use of sophisticated algorithms (for example, lazy evaluation for functional languages [74, 75], co-routining [116] or constraint solving <ref> [79] </ref> for logic programming languages, or indeed, lazy resource allocation for linear logic programming languages) it becomes infeasible to use the implementation rules as a way of visualising execution. <p> Lygon can be seen as Prolog + linear logic. Since these two aspects are orthogonal it is feasible to consider languages which combine linear logic features with, say, CLP (&lt;) <ref> [79] </ref> or Mercury [133]. One strategy for developing a Lygon compiler would be to consider a Mercury + Linear Logic language and compile it into Mercury. A second area with significant potential for implementation related further work is the debugging and visualisation of Lygon programs.
Reference: [80] <author> Sverker Janson. AKL: </author> <title> A Multiparadigm Programming Language. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Uppsala University, </institution> <year> 1994. </year>
Reference-contexts: Although these languages have become less prominent in the research community they are still alive see for example [76, 77]. A survey of first generation concurrent logic programming can be found in [126]. The second generation includes such languages as AKL <ref> [80] </ref> and Oz [39]. These languages move away from the proof search interpretation of computation and view processes as operating over a shared constraint store. As a result it becomes difficult to view these languages as logic programming languages. <p> This problem also affects second generation concurrent logic programming languages such as AKL <ref> [80, chapter 7] </ref>. 167 Chapter 7 Conclusions and Further Work This thesis has covered the design, implementation and applications of the linear logic programming language Lygon. In order to design Lygon we defined and compared a number of characterisers of logic programming.
Reference: [81] <author> S. Kleene. </author> <title> Introduction to Metamathematics. </title> <publisher> North Holland, </publisher> <year> 1952. </year>
Reference-contexts: If we have proofs of ` A and ` A ! B then we can derive ` B: . . . . . . . . A ` A B ` B ! L Cut Cut For more details on the sequent calculus we refer the reader to <ref> [81] </ref>. 2.2 Intuitionistic Logic Intuitionistic logic was developed early this century. It shares its syntax with classical logic but differs semantically in that it rejects the law of the excluded middle which states that ` A _ :A is true, i.e., that predicates must be either true or false. <p> For our purposes it is sufficient to know that it can be specified by taking the standard sequent calculus for classical logic and limiting it to single conclusions. For more details we refer the reader to <ref> [81] </ref>. 2.3 Linear Logic Linear logic was introduced in a seminal 1987 paper by Girard [46] and has since inspired much work in the computer science and mathematical communities.
Reference: [82] <author> S. Kleene. </author> <title> Mathematical Logic. </title> <publisher> Wiley and Sons, </publisher> <year> 1968. </year>
Reference-contexts: It is the standard notation used in the proof theoretical analysis of logic programming since it distinguishes naturally between programs and goals. Additionally the sequent calculus rules construct a proof locally (as opposed to natural deduction <ref> [82] </ref>) and allow short direct proofs (as opposed to Hilbert-type systems [82]). This makes the sequent calculus appropriate for systematic (and hence automatable) proof search. A sequent is a construct of the form ` where and are sequences of formulae. is the antecedent and is the succedent. <p> It is the standard notation used in the proof theoretical analysis of logic programming since it distinguishes naturally between programs and goals. Additionally the sequent calculus rules construct a proof locally (as opposed to natural deduction <ref> [82] </ref>) and allow short direct proofs (as opposed to Hilbert-type systems [82]). This makes the sequent calculus appropriate for systematic (and hence automatable) proof search. A sequent is a construct of the form ` where and are sequences of formulae. is the antecedent and is the succedent.
Reference: [83] <author> S.C. Kleene. </author> <title> Permutability of inferences in Gentzen's calculi LK and LJ. </title> <journal> Memoirs of the American Mathematical Society, </journal> <volume> 10 </volume> <pages> 1-26, </pages> <year> 1952. </year>
Reference-contexts: 1 ) ? N (F 2 ) ? (!F ) ? ?(F ) ? (9xF ) ? 8x (F ) ? (1) ? ? (0) ? &gt; Good tutorial introductions to linear logic and its applications to computer science can be found in [3, 4, 123, 124]. 2.4 Permutabilities Permutabilities <ref> [83] </ref> play an important role in the proof theoretical analysis of logic programming languages. We say that (e.g.) -R permutes down over N-L if whenever a proof contains an occurrence of -R immediately above 5 an occurrence of N-L we can swap the order and retain a valid proof. <p> This property is known as focusing. Note that an atom on the left of the turnstile can be considered to be synchronous with respect to focusing. The permutability properties for classical and intuitionistic logic below are from Kleene <ref> [83] </ref>. The permutability properties for linear logic are from Lincoln [94]. Most of the pairs of inference rules permute for classical and intuitionistic logic. The exceptions are outlined below. 6 And ( 2.4.
Reference: [84] <author> N. Kobayashi, M. Nakade, and A. Yonezawa. </author> <title> Static analysis on communication for asynchronous concurrent programming languages. </title> <type> Technical Report 95-04, </type> <institution> Department of Information Science, University of Tokyo, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: The actual language 1 [128] is an ML-like functional programming language with concurrency primitives inspired by linear logic's connectives. Some early work with ACL looked at process equivalence relations [86]. More recent work centers around the development of language tools such partial evaluators [73] and abstract interpreters <ref> [84] </ref>. ACL has also been used as an implementation language for a concurrent object-oriented programming language and in this context there has been work on providing a type system for the language which is capable of detecting message not understood errors at compile time [87].
Reference: [85] <author> Naoki Kobayashi and Akinori Yonezawa. </author> <title> ACL a concurrent linear logic programming paradigm. </title> <editor> In Dale Miller, editor, </editor> <booktitle> Logic Programming Proceedings of the 1993 International Symposium, </booktitle> <pages> pages 279-294, </pages> <address> Vancouver, Canada, 1993. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: BACKGROUND Lolli [70] D ::= &gt; j A j D N D j G ( D j G ) D j 8x:D ACL <ref> [85] </ref> G ::= ? j &gt; j A m j?A m j A p j G O G j G N G j 8xG j R m : : : A ? LO [10] G ::= A j &gt; j G N G j G O G Forum [109] D ::= <p> Unfortunately uniformity is defined in the context of single conclusioned sequent calculi systems. This is a problem since we are interested in a general criteria applicable to a range of both single and multiple conclusion logics including relevant logic [24], temporal and modal logics [118] and linear logic <ref> [6, 10, 70, 85, 109, 140, 147] </ref>. This chapter continues the investigation into the derivation of logic programming languages. We define a number of formal characterisers (including uniformity) and explore the relationships amongst them. We begin with single conclusion logics and then generalise to the multiple conclusion setting. <p> Thus delaying the application of left-focused proof steps until all of the required atoms are present preserves completeness. Furthermore, the proof step produces a left focused proof as desired. ffi 3.6.1 ACL ACL (Asynchronous Communication based on Linear logic) <ref> [85] </ref> has the flavour of a concurrent extension to an ML-like functional language. The concurrent extensions are 54 CHAPTER 3. DERIVING LOGIC PROGRAMMING LANGUAGES based on linear logic. <p> result of left rules or the axiom rule and thus it must be the result of a right rule. ffi COROLLARY:ACL satisfies criteria A and C. 11 Note that, unlike the technical report version of this chapter [151] we are using the extended version of ACL on page 285 of <ref> [85] </ref> which includes quantifiers. 3.6. EXAMPLES 55 3.6.2 LO LO (Linear Objects) [10] is one of the earlier languages based on linear logic. It is motivated by a desire to add concurrency and object-oriented features to logic programming. <p> Some of these, like LinLog [6] are based on proof-theoretic analyses, as Lygon is, but, to the best of my knowledge, have not been implemented and hence do not involve the problems of lazy splitting discussed in this thesis. Others, like ACL <ref> [85, 88, 128] </ref> and LO [8-10] use linear logic as motivation and a design guide for concurrent logic programming. These languages use a somewhat restricted class of formulae which excludes . <p> A parallel program is one which is run on multiple processors with the aim of attaining better performance. Often, the result of the computation is deterministic. A number of linear logic programming languages are targeted at concurrent applications (e.g. ACL <ref> [85, 88, 128] </ref> and LO [7-10, 29, 42]) and it has been shown that much of the calculus can be mapped into linear logic [108]. In this section we show how various aspects of concurrency can be expressed in Lygon. <p> This result is not actually of much practical use although a proof will exist in the Lygon 2 fragment of linear logic we can not necessarily expect the Lygon system to be able to find it efficiently. ACL ACL <ref> [85, 88] </ref> (A Concurrent Language) uses linear logic as the basis for a concurrent programming languages. The actual language 1 [128] is an ML-like functional programming language with concurrency primitives inspired by linear logic's connectives. Some early work with ACL looked at process equivalence relations [86].
Reference: [86] <author> Naoki Kobayashi and Akinori Yonezawa. </author> <title> Logical, testing, and observation equivalence for processes in a linear logic programming. </title> <type> Technical Report 93-4, </type> <institution> Department of Information Science, University of Tokyo, </institution> <year> 1993. </year>
Reference-contexts: ACL ACL [85, 88] (A Concurrent Language) uses linear logic as the basis for a concurrent programming languages. The actual language 1 [128] is an ML-like functional programming language with concurrency primitives inspired by linear logic's connectives. Some early work with ACL looked at process equivalence relations <ref> [86] </ref>. More recent work centers around the development of language tools such partial evaluators [73] and abstract interpreters [84].
Reference: [87] <author> Naoki Kobayashi and Akinori Yonezawa. </author> <title> Type-theoretic foundations for concurrent object-oriented programming. </title> <editor> In Carrie Wilpolt, editor, </editor> <booktitle> Ninth Annual Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <pages> pages 31-45. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1994. </year> <note> BIBLIOGRAPHY 177 </note>
Reference-contexts: This notion of predicate-level typing is similar to the results of the analysis presented in [12] and to the type system of <ref> [87] </ref>. 160 CHAPTER 5. APPLICATIONS OF LYGON 161 Chapter 6 Comparison to Other Work In this chapter we survey and compare the variety of logic programming languages which are based on linear logic. <p> ACL has also been used as an implementation language for a concurrent object-oriented programming language and in this context there has been work on providing a type system for the language which is capable of detecting message not understood errors at compile time <ref> [87] </ref>. Like LO, ACL sacrifices completeness by implementing don't care nondetermin-ism. The class of formulae used in ACL is a subset of the Lygon 2 class of formulae. LC LC (Linear Chemistry) [140] is a minimal concurrent language fairly similar in capabilities to ACL.
Reference: [88] <author> Naoki Kobayashi and Akinori Yonezawa. </author> <title> Typed higher-order concurrent linear logic programming. </title> <type> Technical Report 12, </type> <institution> University of Tokyo, </institution> <year> 1994. </year>
Reference-contexts: Some of these, like LinLog [6] are based on proof-theoretic analyses, as Lygon is, but, to the best of my knowledge, have not been implemented and hence do not involve the problems of lazy splitting discussed in this thesis. Others, like ACL <ref> [85, 88, 128] </ref> and LO [8-10] use linear logic as motivation and a design guide for concurrent logic programming. These languages use a somewhat restricted class of formulae which excludes . <p> A parallel program is one which is run on multiple processors with the aim of attaining better performance. Often, the result of the computation is deterministic. A number of linear logic programming languages are targeted at concurrent applications (e.g. ACL <ref> [85, 88, 128] </ref> and LO [7-10, 29, 42]) and it has been shown that much of the calculus can be mapped into linear logic [108]. In this section we show how various aspects of concurrency can be expressed in Lygon. <p> This result is not actually of much practical use although a proof will exist in the Lygon 2 fragment of linear logic we can not necessarily expect the Lygon system to be able to find it efficiently. ACL ACL <ref> [85, 88] </ref> (A Concurrent Language) uses linear logic as the basis for a concurrent programming languages. The actual language 1 [128] is an ML-like functional programming language with concurrency primitives inspired by linear logic's connectives. Some early work with ACL looked at process equivalence relations [86].
Reference: [89] <author> Alexei P. Kopylov. </author> <title> Decidability of linear affine logic. </title> <editor> In D. Kozen, editor, </editor> <booktitle> Tenth IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 496-504, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: This behavior is known as affine since it is precisely what affine logic <ref> [89] </ref> provides. We can simulate affine facts by using &gt;. Recall that &gt; succeeds in any context. In some sense it can be thought of as a cookie monster which consumes all the linear resources it is given.
Reference: [90] <author> Robert Kowalski and Merek Sergot. </author> <title> A logic-based calculus of events. </title> <journal> New Generation Computing, </journal> <volume> 4(1) </volume> <pages> 67-95, </pages> <year> 1986. </year>
Reference-contexts: It is worth noting that the problems we consider have solutions in the classical logic framework. It is also worth emphasising that these solutions are invariably complex and obtuse. In [5] Vladimir Alexiev looks at Kowalski's Event Calculus <ref> [90] </ref>. The event calculus is a formalisation of events and their effect on states. One of the key features of the Event Calculus is that it is executable the theory is realised as a Prolog program. The Prolog realisation of the Event Calculus relies heavily on negation as failure.
Reference: [91] <author> Yves Lafont. </author> <title> Introduction to linear logic. </title> <booktitle> Lecture Notes for the Summer School in Constructive Logics and Category Theory, </booktitle> <month> August </month> <year> 1988. </year>
Reference-contexts: A related application of linear logic is its use to derive functional programming languages. This is done using the Curry-Howard isomorphism which states that there is an equivalence between theorems and types in the -calculus. This has been applied by Mackie [98, 99], Abramsky [1], Lafont <ref> [91, 92] </ref> and Lafont and Girard [49] to derive a linear version of the -calculus. The resulting languages are rather different to logic programming languages.
Reference: [92] <author> Yves Lafont. </author> <title> Functional programming and linear logic. </title> <booktitle> Lecture Notes for the Summer School on Functional Programming and Constructive Logic. </booktitle> <address> Glasgow., </address> <month> September </month> <year> 1989. </year>
Reference-contexts: A related application of linear logic is its use to derive functional programming languages. This is done using the Curry-Howard isomorphism which states that there is an equivalence between theorems and types in the -calculus. This has been applied by Mackie [98, 99], Abramsky [1], Lafont <ref> [91, 92] </ref> and Lafont and Girard [49] to derive a linear version of the -calculus. The resulting languages are rather different to logic programming languages.
Reference: [93] <author> Patrick Lincoln, Andre Scedrov, and Natarajan Shankar. </author> <title> Linearizing intuitionis-tic implication. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 60 </volume> <pages> 151-177, </pages> <year> 1993. </year>
Reference-contexts: Simplicity 2. Static Clausal Form 3. Dynamic Clausal Form The first, the notion of simplicity, was introduced in [107]. Simplicity restricts occurrences of the ! L rule to have axiomatic right hand premises. This is related to <ref> [93] </ref>. Note that this assumes that the logic has the rule: ` F ; G ` H ! L The advantage of simplicity is that it is simple to reason about and to compare to other criteria. The disadvantage is that it is not general.
Reference: [94] <author> Patrick D. Lincoln. </author> <title> Computational Aspects of Linear Logic. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: This property is known as focusing. Note that an atom on the left of the turnstile can be considered to be synchronous with respect to focusing. The permutability properties for classical and intuitionistic logic below are from Kleene [83]. The permutability properties for linear logic are from Lincoln <ref> [94] </ref>. Most of the pairs of inference rules permute for classical and intuitionistic logic. The exceptions are outlined below. 6 And ( 2.4. <p> Rules which do not appear as row headings can always be permuted up. Rules which do not appear at all can be permuted arbitrarily. Linear Logic Linear logic has more impermutabilities than either classical or intuitionistic logic. In the following table (taken from Lincoln's thesis <ref> [94] </ref>) a number means that the right rule of the connective in that column cannot be permuted below the rule of the row.
Reference: [95] <author> P.D. Lincoln and N. Shankar. </author> <title> Proof search in first-order linear logic and other cut-free sequent calculi. </title> <booktitle> In Ninth IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 282-291, </pages> <year> 1994. </year>
Reference-contexts: Our solution is also applicable to Forum [71]. In addition to the application of this work to the implementation of logic programming languages based on linear logic, the lazy rules above presumably have application in theorem provers for linear logic <ref> [95, 113, 135, 136] </ref>, where they eliminate a significant potential source of inefficiency. 113 Chapter 5 Applications of Lygon In this chapter we look at applications of Lygon.
Reference: [96] <author> J. W. Lloyd. </author> <title> Combining functional and logic programming languages. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proceedings of the 1994 International Logic Programming Symposium, </booktitle> <pages> pages 43-57. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference: [97] <author> J. W. Lloyd. </author> <title> Practical advantages of declarative programming. </title> <booktitle> In Joint Conference on Declarative Programming, </booktitle> <address> GULP-PRODE'94, </address> <year> 1994. </year>
Reference: [98] <author> Ian Mackie. </author> <title> Lilac: A functional programming language based on linear logic. </title> <type> Master's thesis, </type> <institution> Department of Computing, Imperial College of Science, Technology and Medicine, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: A related application of linear logic is its use to derive functional programming languages. This is done using the Curry-Howard isomorphism which states that there is an equivalence between theorems and types in the -calculus. This has been applied by Mackie <ref> [98, 99] </ref>, Abramsky [1], Lafont [91, 92] and Lafont and Girard [49] to derive a linear version of the -calculus. The resulting languages are rather different to logic programming languages.
Reference: [99] <author> Ian Mackie. </author> <title> Lilac: A functional programming language based on linear logic. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(4) </volume> <pages> 395-433, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: A related application of linear logic is its use to derive functional programming languages. This is done using the Curry-Howard isomorphism which states that there is an equivalence between theorems and types in the -calculus. This has been applied by Mackie <ref> [98, 99] </ref>, Abramsky [1], Lafont [91, 92] and Lafont and Girard [49] to derive a linear version of the -calculus. The resulting languages are rather different to logic programming languages.
Reference: [100] <author> Dave Mason. </author> <title> Applications of functional programming. </title> <note> Available from http://www.scs.ryerson.ca/dmason/common/functional.html, June 1997. </note>
Reference: [101] <author> M. Masseron. </author> <title> Generating plans in linear logic II: A geometry of conjunctive actions. </title> <journal> Theoretical Computer Science, </journal> <volume> 113 </volume> <pages> 371-375, </pages> <year> 1993. </year>
Reference: [102] <author> M. Masseron, C. Tollu, and J. Vauzeilles. </author> <title> Generating plans in linear logic. </title> <editor> In K.V. Nori and C.E. Veni Madhavan, editors, </editor> <booktitle> Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 63-75. </pages> <publisher> Springer-Verlag, LNCS 472, </publisher> <month> De-cember </month> <year> 1990. </year>
Reference: [103] <author> M. Masseron, C. Tollu, and J. Vauzeilles. </author> <title> Generating plans in linear logic I: Actions as proofs. </title> <journal> Theoretical Computer Science, </journal> <volume> 113 </volume> <pages> 349-371, </pages> <year> 1993. </year> <note> 178 BIBLIOGRAPHY </note>
Reference: [104] <author> Raymond McDowell, Dale Miller, and Catuscia Palamidessi. </author> <title> Encoding transition systems in sequent calculus: Preliminary report. </title> <booktitle> Electronic Notes in Theoretical Computer Science, </booktitle> <volume> 3, </volume> <year> 1996. </year>
Reference-contexts: Work on Forum has mostly concentrated on its use as a specification language. It has been applied to the specification of an ML-like language, a simple RISC processor [34] logical inference systems in both natural deduction and sequent calculus styles [106] and transition systems <ref> [104] </ref>. There is also a group at Universita di Genova working on object oriented programming in a linear logic framework which use Forum [38]. The class of program formulae permitted by Lygon 2 is precisely a normalised form [106] of the Forum class of program formulae excluding ? headed clauses.
Reference: [105] <author> D. Miler, G. Nadathur, and A. Scedrov. </author> <title> Hedreditary Harrop formulas and uniform proof systems. </title> <booktitle> In Proceedings of the Second Annual Conference on Logics in Computer Science, </booktitle> <pages> pages 98-105, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: G ::= D ! G j :D). Note that although the syntax is similar to hereditary Harrop formulae <ref> [54, 105] </ref> the semantics is different since the proof rules are those of classical logic.
Reference: [106] <author> D. Miller. </author> <title> A multiple-conclusion meta-logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 165(1) </volume> <pages> 201-232, </pages> <year> 1996. </year>
Reference-contexts: Unfortunately, it suffers from a number of problems. Firstly, uniformity is only defined for single conclusion sequent systems 1 . A straightforward extension to a multiple conclusion setting is fairly obvious <ref> [55, 106, 109, 140] </ref> but it requires that all connectives occurring in goals permute over each other are-striction which we shall see is unnecessary. Another problem with a simple generalisation of uniformity to multiple conclusion sequent systems involves one sided presentations. <p> Moreover there does not exist a uniform proof of the sequent. Attempts to use this logical equivalence in a programming language can cause problems. For example, consider the Forum <ref> [106, 109] </ref> fragment of linear logic. As will be discussed in section 3.7, Forum was designed using a multiple conclusion extension of Uniformity. However, for a number of reasons the language is viewed more as a specification language and less as a logic programming language. <p> Note that the need to use atomic goals to guide the proof is not as vital here as it is for the previous case. We term this characteriser asynchronous uniformity. This is the notion that is used in (for example) the design of Forum <ref> [106] </ref>. 46 CHAPTER 3. DERIVING LOGIC PROGRAMMING LANGUAGES 3.5.2 Asynchronous Uniformity Given that we can apply right rules whenever there is a compound goal formulae it is easy to show that we cannot have impermutabilities on the right. <p> It is interesting in that it consists entirely of asynchronous connectives (in goals) and the same class of formulae in programs. D ::= G We begin by considering Forum as the class of formulae above extended using logical equivalences to cover all of linear logic as is done in <ref> [106] </ref>. PROPOSITION 69 Forum satisfies criteria A. Proof: Linear logic does not have generally applicable right structural rules. ffi PROPOSITION 70 Forum fails to satisfy criterion B. Proof: The proof of the sequent ? ` violates criterion B. ffi PROPOSITION 71 Forum fails to satisfy criterion C. <p> FORUM 57 Forum fails most of the tests when considered in conjunction with logical equivalences. We consider Forum in conjunction with logical equivalences because that is the approach followed by Forum's designers in <ref> [106, 109, 111] </ref>. We now consider Forum as it stands, without extension. We shall call this language Forum . LEMMA 72 Forum satisfies criterion A. Proof: Trivial, since linear logic does not provide generally applicable right structural rules. ffi PROPOSITION 73 Forum fails to satisfy criterion B. <p> In the absence of a notion of atom-guided proof search, the options that have been considered in order to extend uniformity to a multiple conclusion setting <ref> [55, 106, 140] </ref> are: D all : For a sequent of the form ` C; A or ` C there exist proofs where the first step introduces the topmost connective of F for all F 2 C. <p> Observe that the program clauses allowed in Lygon 2 are a subset of the Forum class of program clauses 15 . As is observed in <ref> [106] </ref> there exists the following normal form for Forum program clauses: D ::= !(C 1 N : : : N C n ) j (C 1 N : : : N C n ) 14 This is a special case of D ( G. 15 The two classes of formula are <p> ( A 1 O : : : O A n ) G ::= A j 1 ? j &gt; j G O G j G G j 9xG Lolli [70]: D ::= &gt; j A j D N D j G ( D j G ) D j 8x:D Forum <ref> [106] </ref>: D ::= G G ::= A j G O G j G N G j G ( G j G ) G j &gt; j ? j 8xG Lygon 2 (Section 3.11) D ::= (C 1 N : : : N C n ) j !C G ::= A j <p> CONCURRENT PROGRAMMING 165 Lolli and Lygon are fairly similar in methodology. Roughly speaking, Lolli can be seen as Lygon minus concurrency. Indeed, the class of formulae usable in Lygon 2 is a superset of the Lolli class. Forum In some aspects Forum <ref> [106, 109] </ref> is fairly similar to Lygon. The main difference is that Forum satisfies a variant of asynchronous uniformity which does not require that atomic goals guide the proof search process. <p> Work on Forum has mostly concentrated on its use as a specification language. It has been applied to the specification of an ML-like language, a simple RISC processor [34] logical inference systems in both natural deduction and sequent calculus styles <ref> [106] </ref> and transition systems [104]. There is also a group at Universita di Genova working on object oriented programming in a linear logic framework which use Forum [38]. The class of program formulae permitted by Lygon 2 is precisely a normalised form [106] of the Forum class of program formulae excluding <p> in both natural deduction and sequent calculus styles <ref> [106] </ref> and transition systems [104]. There is also a group at Universita di Genova working on object oriented programming in a linear logic framework which use Forum [38]. The class of program formulae permitted by Lygon 2 is precisely a normalised form [106] of the Forum class of program formulae excluding ? headed clauses. Forum's class of goal formulae is limited to asynchronous formulae. <p> The class of program formulae permitted by Lygon 2 is precisely a normalised form [106] of the Forum class of program formulae excluding ? headed clauses. Forum's class of goal formulae is limited to asynchronous formulae. Although an attempt is made in <ref> [106, 109] </ref> to add synchronous connectives (such as 9) using logical equivalences the synchronous connectives are not first class citizens for example there exists a program P and formula F such that P ` 9xF is provable but where there isn't a term t such that P ` F [t=x] is
Reference: [107] <author> Dale Miller. </author> <title> A logical analysis of modules in logic programming. </title> <journal> Journal of Logic Programming, </journal> <pages> pages 79-108, </pages> <year> 1989. </year>
Reference-contexts: Furthermore it fails criteria A and B. There are a number of possible approaches to limiting the proof search process for sequents with atomic goals: 1. Simplicity 2. Static Clausal Form 3. Dynamic Clausal Form The first, the notion of simplicity, was introduced in <ref> [107] </ref>. Simplicity restricts occurrences of the ! L rule to have axiomatic right hand premises. This is related to [93]. <p> DERIVING LOGIC PROGRAMMING LANGUAGES Fully Uniform Uniformity with the addition of left-focusing. Applies to single con clusion systems and corresponds to criterion F . Simple This is one method of insisting that atoms guide the proof search process. It is used in <ref> [107] </ref> and requires that the right premise of the ( L rule be the conclusion of an axiom rule. Left Focussed This is another method of allowing atoms to guide the proof search process. Locally LR This is the criterion used in [122] for defining Lygon.
Reference: [108] <author> Dale Miller. </author> <title> The -calculus as a theory in linear logic: Preliminary results. </title> <editor> In E. Lamma and P. Mello, editors, </editor> <booktitle> Proceedings of the Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 242-265. </pages> <publisher> Springer-Verlag LNCS 660, </publisher> <year> 1992. </year>
Reference-contexts: Often, the result of the computation is deterministic. A number of linear logic programming languages are targeted at concurrent applications (e.g. ACL [85, 88, 128] and LO [7-10, 29, 42]) and it has been shown that much of the calculus can be mapped into linear logic <ref> [108] </ref>. In this section we show how various aspects of concurrency can be expressed in Lygon. Some aspects of concurrency that we shall look at are [17]: 1. Specifying multiple processes, 2. Communication, and 3. Synchronisation. These are demonstrated in programs 16 and 17.
Reference: [109] <author> Dale Miller. </author> <title> A multiple-conclusion meta-logic. </title> <booktitle> In Logic in Computer Science, </booktitle> <pages> pages 272-281, </pages> <year> 1994. </year>
Reference-contexts: 8x:D ACL [85] G ::= ? j &gt; j A m j?A m j A p j G O G j G N G j 8xG j R m : : : A ? LO [10] G ::= A j &gt; j G N G j G O G Forum <ref> [109] </ref> D ::= G LC [140] G ::= A j 1 ? j &gt; j G O G j G G j 9xG Lygon [122] D ::= A j 1 j ? j D N D j D D j G ( A j G ? j 8xD j!D j D <p> Unfortunately uniformity is defined in the context of single conclusioned sequent calculi systems. This is a problem since we are interested in a general criteria applicable to a range of both single and multiple conclusion logics including relevant logic [24], temporal and modal logics [118] and linear logic <ref> [6, 10, 70, 85, 109, 140, 147] </ref>. This chapter continues the investigation into the derivation of logic programming languages. We define a number of formal characterisers (including uniformity) and explore the relationships amongst them. We begin with single conclusion logics and then generalise to the multiple conclusion setting. <p> Unfortunately, it suffers from a number of problems. Firstly, uniformity is only defined for single conclusion sequent systems 1 . A straightforward extension to a multiple conclusion setting is fairly obvious <ref> [55, 106, 109, 140] </ref> but it requires that all connectives occurring in goals permute over each other are-striction which we shall see is unnecessary. Another problem with a simple generalisation of uniformity to multiple conclusion sequent systems involves one sided presentations. <p> Note that, as an extreme case, the application of standard linear logical equivalences enables one to encode the entirety of linear logic into a subset that can be shown to be uniform <ref> [6, 109] </ref>. Since full linear logic is not uniform this suggests that the use of logical equivalences to extend a logic programming language might not always be appropriate. To see that full linear logic is not uniform consider the sequent pq ` pq. <p> Moreover there does not exist a uniform proof of the sequent. Attempts to use this logical equivalence in a programming language can cause problems. For example, consider the Forum <ref> [106, 109] </ref> fragment of linear logic. As will be discussed in section 3.7, Forum was designed using a multiple conclusion extension of Uniformity. However, for a number of reasons the language is viewed more as a specification language and less as a logic programming language. <p> strong D A D S ACL 3 3 3 7 7 3 LC 3 3 3 3 3 3 Forum 3 7 7 7 7 7 Forum Lygon 3 7 7 7 7 7 Lygon ? Lygon Lygon 2 (section 3.11) 3 3 3 7 7 3 3.7 Forum Forum <ref> [109] </ref> is intended more as a specification language than as a programming language. It is interesting in that it consists entirely of asynchronous connectives (in goals) and the same class of formulae in programs. <p> FORUM 57 Forum fails most of the tests when considered in conjunction with logical equivalences. We consider Forum in conjunction with logical equivalences because that is the approach followed by Forum's designers in <ref> [106, 109, 111] </ref>. We now consider Forum as it stands, without extension. We shall call this language Forum . LEMMA 72 Forum satisfies criterion A. Proof: Trivial, since linear logic does not provide generally applicable right structural rules. ffi PROPOSITION 73 Forum fails to satisfy criterion B. <p> As a result the implementation problems are correspondingly simpler, in that neither language needs lazy splitting 1 , and so again the problems addressed in this paper do not arise. The last class of linear logic programming languages comprises Lolli [68-70], Forum <ref> [109] </ref> and Lygon [57, 122, 149]. These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful. <p> CONCURRENT PROGRAMMING 165 Lolli and Lygon are fairly similar in methodology. Roughly speaking, Lolli can be seen as Lygon minus concurrency. Indeed, the class of formulae usable in Lygon 2 is a superset of the Lolli class. Forum In some aspects Forum <ref> [106, 109] </ref> is fairly similar to Lygon. The main difference is that Forum satisfies a variant of asynchronous uniformity which does not require that atomic goals guide the proof search process. <p> The class of program formulae permitted by Lygon 2 is precisely a normalised form [106] of the Forum class of program formulae excluding ? headed clauses. Forum's class of goal formulae is limited to asynchronous formulae. Although an attempt is made in <ref> [106, 109] </ref> to add synchronous connectives (such as 9) using logical equivalences the synchronous connectives are not first class citizens for example there exists a program P and formula F such that P ` 9xF is provable but where there isn't a term t such that P ` F [t=x] is
Reference: [110] <author> Dale Miller. </author> <title> A survey of linear logic programming. </title> <booktitle> Computational Logic: The Newsletter of the European Network in Computational Logic, </booktitle> <volume> 2(2) </volume> <pages> 63-67, </pages> <month> De-cember </month> <year> 1995. </year>
Reference-contexts: The exception is Forum which seems to be roughly equivalent to Lygon (as proposed in [122]) and as a result is harder to implement than Lygon 2 . A survey of the languages can be found in <ref> [110] </ref>. The syntax of the various languages are summarised in figure 6.1.
Reference: [111] <author> Dale Miller. </author> <title> The forum specification language. </title> <note> http://www.cis.upenn.edu/dale/forum/, 1996. </note>
Reference-contexts: FORUM 57 Forum fails most of the tests when considered in conjunction with logical equivalences. We consider Forum in conjunction with logical equivalences because that is the approach followed by Forum's designers in <ref> [106, 109, 111] </ref>. We now consider Forum as it stands, without extension. We shall call this language Forum . LEMMA 72 Forum satisfies criterion A. Proof: Trivial, since linear logic does not provide generally applicable right structural rules. ffi PROPOSITION 73 Forum fails to satisfy criterion B. <p> Forum includes ? in programs and in clause heads and as a result it is more of a specification language than a logic programming language. Both of Forum's designers have commented <ref> [71, 111] </ref> that Forum does not appear to be a logic programming language. Two of the reasons why Forum is too expressive to be considered a logic programming language involve higher order quantification. The third is the presence of program clauses of the form G ( ?.
Reference: [112] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: For example, the goal 9xp (x) is provable from the program p (a) _ p (b); however, neither p (a) nor p (b) are provable from the program. One property which seems essential to our intuition of what constitutes logic programming is goal directedness. Uniformity <ref> [112] </ref> is a formalisation of the intuitive notion of goal-directedness. The sequent ` is seen as comprising a program and a goal . <p> A proof is goal directed if its shape that is the choice of rule to be applied at each step in the derivation of a proof is determined by the goal and not by the program. DEFINITION 1 (UNIFORMITY <ref> [112] </ref>) A proof in the intuitionistic sequent calculus is uniform if each occurrence of a sequent 22 CHAPTER 3. DERIVING LOGIC PROGRAMMING LANGUAGES whose succedent contains a non-atomic formula is the conclusion of the inference rule which introduces its [the non-atomic formula's] top-level connective. <p> c c; a; b ! a ` c c; a; b ! a ` a ^ c b ` b W W b; a ` a c; b; a ` a c; b; b ! a ` a c ` c W W ^ R _ L Miller et al. <ref> [112] </ref> define an idealised abstract interpreter ` O which corresponds to the operational viewpoint. This is linked to logic through the definition of a uniform proof. <p> example consider the one sided presentation derived by replacing the sequent ` with the sequent ; (:) ` using de Morgan rules to push negation inwards to atoms and adding the following rule p; :p ` Note that this rule is derivable: p ` p p; :p ` 1 From <ref> [112] </ref>: A C-proof in which each sequent occurrence has a singleton set for its succedent is also called an I-proof. And later: A uniform proof is an I-proof in which : : : 2 Sufficient de Morgan rules are required. 24 CHAPTER 3. <p> In general ` x F is defined to hold if ` F holds and there is a proof which satisfies some additional constraints. This trivially ensures soundness of the criterion. The next definition is based on the one in <ref> [112] </ref>. It provides the link between criteria and logic programming languages. DEFINITION 3 (ABSTRACT LOGIC PROGRAMMING LANGUAGE (ALPL)) Let D be a set of legal program formulae, G a set of legal goal formulae and ` some notion of provability. <p> However this is not sufficient since it is possible to apply the 9 R rule and then weaken the result. PROPOSITION 4 C 6 A PROPOSITION 5 C 6 B PROPOSITION 6 A 6 C , B 6 C The next criterion is uniformity, introduced in <ref> [112] </ref>. Uniformity restricts sequents with non-atomic goals to be the conclusions of right rules. There is some scope for variation though, as we have a choice as to which right rule. Even for a single conclusion system there is still a choice between a structural and a logical right rule. <p> There is some scope for variation though, as we have a choice as to which right rule. Even for a single conclusion system there is still a choice between a structural and a logical right rule. The wording in <ref> [112] </ref> requires that a non-atomic goal be the conclusion of the right rule which introduces its topmost connective - i.e. the appropriate logical rule. Other 32 CHAPTER 3. DERIVING LOGIC PROGRAMMING LANGUAGES papers (for example [70]) do not specify which right rule. <p> Note that most of the languages in figure 2.8 are multiple conclusion and are covered in section 3.6. Both languages in this section have been shown (in <ref> [112] </ref> and [70] respectively) to satisfy uniformity. The contribution here is to show that they also satisfy criterion F . Since criterion F is stronger than uniformity this is a new result. 3.4.1 Pure Prolog Prolog is often presented as a language based on classical logic which is multiple conclusion. <p> In general ` x is defined to hold if ` holds and there is a proof which satisfies some additional constraints. This trivially ensures soundness of the criterion. 3.5. THE MULTIPLE CONCLUSIONED CASE 43 The next definition is based on the one in <ref> [112] </ref>. It provides the link between criteria and logic programming languages. DEFINITION 16 (ABSTRACT LOGIC PROGRAMMING LANGUAGE (ALPL)) Let D be a set of legal program formulae, G a set of legal goal formulae and ` some notion of provability. <p> An important goal is to suggest a common terminology. As mentioned earlier the seminal work in this area is <ref> [112] </ref> where the original definition of uniformity is presented. Since uniformity works reasonably well in a single conclusion setting there has been little research on extending it until the need arose for a multiple conclusion generalisation. <p> Goal Directed This is an intuitive, informal notion that requires that the proof search process be guided by the goal. Uniform This is the original definition in <ref> [112] </ref> which applies to single conclusion systems. It corresponds to criterion D strong . 68 CHAPTER 3. DERIVING LOGIC PROGRAMMING LANGUAGES Fully Uniform Uniformity with the addition of left-focusing. Applies to single con clusion systems and corresponds to criterion F .
Reference: [113] <author> Alberto Momigliano. </author> <title> Theorem proving via uniform proofs. </title> <type> Manuscript, </type> <year> 1993. </year>
Reference-contexts: Our solution is also applicable to Forum [71]. In addition to the application of this work to the implementation of logic programming languages based on linear logic, the lazy rules above presumably have application in theorem provers for linear logic <ref> [95, 113, 135, 136] </ref>, where they eliminate a significant potential source of inefficiency. 113 Chapter 5 Applications of Lygon In this chapter we look at applications of Lygon.
Reference: [114] <author> Gopalan Nadathur. </author> <title> Uniform provability in classical logic. </title> <type> Technical Report TR-96-09, </type> <institution> University of Chicago, </institution> <year> 1996. </year>
Reference-contexts: A consequence of observation (3) is that A and B both fail to satisfy the left-focusing condition and hence the languages fail to satisfy D A and D S . In <ref> [114, 115] </ref> Nadathur and Loveland examine the application of uniformity to disjunctive logic programming.
Reference: [115] <author> Gopalan Nadathur and Donald W. Loveland. </author> <title> Uniform proofs and disjunctive logic programming (extended abstract). </title> <booktitle> In Tenth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 148-155, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: A consequence of observation (3) is that A and B both fail to satisfy the left-focusing condition and hence the languages fail to satisfy D A and D S . In <ref> [114, 115] </ref> Nadathur and Loveland examine the application of uniformity to disjunctive logic programming.
Reference: [116] <author> Lee Naish. </author> <title> Automating control of logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(3) </volume> <pages> 167-183, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: In some cases the third logic is just one of the previous two but in general this is not the case. When the implementation makes use of sophisticated algorithms (for example, lazy evaluation for functional languages [74, 75], co-routining <ref> [116] </ref> or constraint solving [79] for logic programming languages, or indeed, lazy resource allocation for linear logic programming languages) it becomes infeasible to use the implementation rules as a way of visualising execution.
Reference: [117] <author> Richard A. O'Keefe. </author> <title> The Craft of Prolog. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Programming idioms such as monads in functional programming languages [141, 142] have taken a number of years to emerge. Other examples of non-obvious programming idioms include combinator parsers in functional programming languages [78], difference lists in logic programming languages etc. <ref> [117, 134] </ref>. In our examples we develop a number of linear logic programming idioms particular ways of using linear logic connectives to achieve a particular behavior. After introducing Lygon from the programmer's perspective, we introduce a number of basic idioms. <p> A second area of application involves non standard executions. Typical examples are collecting statistics, tracing and debugging. Meta-interpreters are also used in certain areas of Artificial Intelligence. Meta-interpreters are a part of the Prolog culture <ref> [117, 134] </ref>. The standard vanilla Prolog meta-interpreter handles the resolution mechanism and expresses the essence of Prolog execution in three lines: prove (true) :- true. prove ((A,B)) :- prove (A), prove (B). prove (A) :- clause (A,B), prove (B).
Reference: [118] <author> Mehmet A. Orgun and Wanli Ma. </author> <title> An overview of temporal and modal logic programming. </title> <editor> In D. M. Gabbay and H. J. Ohlbach, editors, </editor> <booktitle> First International Conference on Temporal Logic, </booktitle> <pages> pages 445-479. </pages> <publisher> Springer-Verlag LNAI 827, </publisher> <month> July </month> <year> 1994. </year>
Reference-contexts: Unfortunately uniformity is defined in the context of single conclusioned sequent calculi systems. This is a problem since we are interested in a general criteria applicable to a range of both single and multiple conclusion logics including relevant logic [24], temporal and modal logics <ref> [118] </ref> and linear logic [6, 10, 70, 85, 109, 140, 147]. This chapter continues the investigation into the derivation of logic programming languages. We define a number of formal characterisers (including uniformity) and explore the relationships amongst them.
Reference: [119] <author> M. Persson, K. Oedling, and D. Eriksson. </author> <title> Switching software architecture prototype using real time declarative language. </title> <booktitle> In International Switching Symposium, </booktitle> <month> October </month> <year> 1992. </year> <note> BIBLIOGRAPHY 179 </note>
Reference: [120] <author> J.L. Peterson. </author> <title> Petri nets. </title> <journal> Computing Surveys, </journal> <volume> 9(3) </volume> <pages> 223-252, </pages> <month> September </month> <year> 1977. </year>
Reference-contexts: We also show how a range of other paradigms for concurrent programming can be simply and easily embedded in linear logic. Specifically, we embed the Chemical reaction metaphor for concurrent programming [22], the co-ordination language Linda [27, 28], the Actors paradigm [2] and Petri Nets <ref> [120] </ref>. We finish this section with a solution to the dining philosophers problem. We begin with a simple example which illustrates how we can program two communicating processes in Lygon. <p> Our final example of embedding a concurrent model in Lygon is Petri nets. A Petri net <ref> [120] </ref> consists of labelled places (the bigger circles), transitions and tokens (the filled black circles). A transition is enabled if all places with incoming arcs have at least one token.
Reference: [121] <author> Frank Pfenning, </author> <title> editor. Types in Logic Programming. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1992. </year>
Reference-contexts: One area for further work is the use of syntactic sugar to make common idioms less syntactically clumsy. Rules (see program 28 and [154]) are an example of syntactic sugar. Another area for further work concerns type systems. Type systems for logic programming languages <ref> [121] </ref> describe the usage of terms. In linear logic programming languages it makes sense to also consider a form of typing which operates at the level of predicates.
Reference: [122] <author> David Pym and James Harland. </author> <title> A uniform proof-theoretic investigation of linear logic programming. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(2) </volume> <pages> 175-207, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: A more detailed introduction to Lygon as a programming language can be found in section 5.1. Note that the grammar given in figure 2.8 for Lygon is the one developed in <ref> [122] </ref>. In section 3.11 we derive a different version of the language (which we called Lygon 2 ) which we propose as a replacement for the earlier language design. 20 CHAPTER 2. <p> j 8xG j R m : : : A ? LO [10] G ::= A j &gt; j G N G j G O G Forum [109] D ::= G LC [140] G ::= A j 1 ? j &gt; j G O G j G G j 9xG Lygon <ref> [122] </ref> D ::= A j 1 j ? j D N D j D D j G ( A j G ? j 8xD j!D j D O D 21 Chapter 3 Deriving Logic Programming Languages This chapter is concerned with the derivation of logic programming languages from logics. <p> We shall consider dynamic clausal form since it generalises both simplicity and static clausal form. A problem with dynamic clausal form is that formulating an equivalent logical system which combines the left rules into a single rule can involve considerable ingenuity (see for example <ref> [122] </ref>) and as a result it is generally hard to show that it is not possible to combine the left rules into a single rule. <p> For example the following proof fragment is left-focused: r; ` q p ` p q ( p; r; ` p (q ( p) r; ` p s N ((q ( p) r); ` p This is related to the notion of resolution developed in <ref> [122] </ref>. DEFINITION 11 (CRITERION E ) ` E F if there exists a proof of ` F where all (sub)proofs of sequents with atomic goals are left-focused. <p> Note that it is essential that we have a notion of atomic goals directing the proof search process. We term this characteriser synchronous uniformity. This notion is similar to the notion of locally LR proof search which was used in the design of Lygon <ref> [122] </ref>. (2) By choosing to be guided by compound goals even if there are atomic goals we obtain sufficient guidance. The only place where the proof search process has no restrictions is in the proof of sequents of the form ` A. <p> It can only be proven by applying L first. Since the goal is compound this violates criterion D S . ffi This is symptomatic of the fact that D S is a generalisation of uniformity and that the notion of simple locally LR used in Lygon (see <ref> [122] </ref> is not uniformity. The differences are minor and relate to the following impermutabilities 62 CHAPTER 3. <p> We invite the reader to consult <ref> [122] </ref> for the details of the derivation and for the logical rules involved. 3.9 Applying D A and D S to Classical Logic All of the languages in the previous few sections have been based on linear logic. <p> It is used in [107] and requires that the right premise of the ( L rule be the conclusion of an axiom rule. Left Focussed This is another method of allowing atoms to guide the proof search process. Locally LR This is the criterion used in <ref> [122] </ref> for defining Lygon. Although the paper defines uniform as simple locally LR we feel that this overloading is undesirable since the two concepts are distinct. <p> It insists that decomposition be given priority over resolution and as a consequence limits the language to use (relatively) reversible connectives in goals. It corresponds to criterion D A . 3.11 Re-Deriving Lygon As we have seen, the full Lygon language as presented in <ref> [122] </ref> fails most of the criteria developed. We have introduced two subsets of Lygon - Lygon ? and Lygon . The first still fails criterion D S ; although the failure is not as severe. <p> As a result the implementation problems are correspondingly simpler, in that neither language needs lazy splitting 1 , and so again the problems addressed in this paper do not arise. The last class of linear logic programming languages comprises Lolli [68-70], Forum [109] and Lygon <ref> [57, 122, 149] </ref>. These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful. <p> Languages which fall into this group are Lolli, Lygon 2 and Forum. As we shall see, Lygon 2 is a superset of most other linear logic based logic programming languages. The exception is Forum which seems to be roughly equivalent to Lygon (as proposed in <ref> [122] </ref>) and as a result is harder to implement than Lygon 2 . A survey of the languages can be found in [110]. The syntax of the various languages are summarised in figure 6.1.
Reference: [123] <author> A. Scedrov. </author> <title> A brief guide to linear logic. </title> <editor> In G. Rozenberg and A. Salomaa, editors, </editor> <booktitle> Current Trends in Theoretical Computer Science, </booktitle> <pages> pages 377-394. </pages> <publisher> World Scientific Publishing Co., </publisher> <year> 1993. </year>
Reference-contexts: (F 1 F 2 ) ? (F 1 ) ? N (F 2 ) ? (!F ) ? ?(F ) ? (9xF ) ? 8x (F ) ? (1) ? ? (0) ? &gt; Good tutorial introductions to linear logic and its applications to computer science can be found in <ref> [3, 4, 123, 124] </ref>. 2.4 Permutabilities Permutabilities [83] play an important role in the proof theoretical analysis of logic programming languages.
Reference: [124] <author> A. Scedrov. </author> <title> Linear logic and computation: A survey. </title> <editor> In H. Schwichtenberg, editor, </editor> <booktitle> Proof and Computation, Proceedings Marktoberdorf Summer School 1993, </booktitle> <pages> pages 379-395. </pages> <booktitle> NATO Advanced Science Institutes, Series F, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference-contexts: (F 1 F 2 ) ? (F 1 ) ? N (F 2 ) ? (!F ) ? ?(F ) ? (9xF ) ? 8x (F ) ? (1) ? ? (0) ? &gt; Good tutorial introductions to linear logic and its applications to computer science can be found in <ref> [3, 4, 123, 124] </ref>. 2.4 Permutabilities Permutabilities [83] play an important role in the proof theoretical analysis of logic programming languages.
Reference: [125] <author> Ehud Shapiro, </author> <title> editor. Concurrent Prolog. </title> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: The disadvantage is primarily a cluttering of the syntax. The first clause of produce states that under appropriate conditions an ack message and a produce (3) process can evolve to produce (2) and a mesg (1). Note that unlike standard concurrent logic programming languages such as Strand [43], GHC <ref> [125, chapter 4] </ref>, Parlog [50] and [125, chapter 3] and Concurrent Prolog [125, chapters 2 & 5] communication is orthogonal to unification. Unification (the underlying primitive operation of logic programming) is not tampered with. <p> The first clause of produce states that under appropriate conditions an ack message and a produce (3) process can evolve to produce (2) and a mesg (1). Note that unlike standard concurrent logic programming languages such as Strand [43], GHC [125, chapter 4], Parlog [50] and <ref> [125, chapter 3] </ref> and Concurrent Prolog [125, chapters 2 & 5] communication is orthogonal to unification. Unification (the underlying primitive operation of logic programming) is not tampered with. <p> Note that unlike standard concurrent logic programming languages such as Strand [43], GHC [125, chapter 4], Parlog [50] and [125, chapter 3] and Concurrent Prolog <ref> [125, chapters 2 & 5] </ref> communication is orthogonal to unification. Unification (the underlying primitive operation of logic programming) is not tampered with. <p> In the Petri net above, the only enabled transition is from a to b and it fires by removing the token from a and placing a token on b. Davison [36] investigates modelling Petri nets in the guarded Horn clause language Parlog ([50] and <ref> [125, chapter 3] </ref>). The Lygon realisation below is simpler and more concise. In Lygon (program 21) the Petri net in figure 5.5 is encoded as: t (a) t (b). t (c) t (b) O t (d). <p> This allows experimentation with a language implementation while its design is still being developed. A number of languages began their lives as meta-interpreters including Concurrent Prolog <ref> [125, chapter 2] </ref>, Erlang and of course, Lygon. A second area of application involves non standard executions. Typical examples are collecting statistics, tracing and debugging. Meta-interpreters are also used in certain areas of Artificial Intelligence. Meta-interpreters are a part of the Prolog culture [117, 134]. <p> For example, in GHC, unifying a goal A with the head of clause cannot bind variables in A. If the unification could succeed by binding a variable in A then it suspends. This suspension is the synchronisation primitive. Languages in this first generation included Parlog [50], Concurrent Prolog <ref> [125, chapters 2 & 5] </ref>, GHC [125, chapter 4] and, later, Strand [43]. Although these languages have become less prominent in the research community they are still alive see for example [76, 77]. A survey of first generation concurrent logic programming can be found in [126]. <p> If the unification could succeed by binding a variable in A then it suspends. This suspension is the synchronisation primitive. Languages in this first generation included Parlog [50], Concurrent Prolog [125, chapters 2 & 5], GHC <ref> [125, chapter 4] </ref> and, later, Strand [43]. Although these languages have become less prominent in the research community they are still alive see for example [76, 77]. A survey of first generation concurrent logic programming can be found in [126]. <p> Additionally, they do not suffer from the problem that multiple inputs to a process need to be merged by the programmer leading to both spaghetti code and a loss of efficiency (which can be fixed by adding an additional construct to the language see <ref> [125, chapters 15 & 16] </ref>). This problem also affects second generation concurrent logic programming languages such as AKL [80, chapter 7]. 167 Chapter 7 Conclusions and Further Work This thesis has covered the design, implementation and applications of the linear logic programming language Lygon.
Reference: [126] <author> Ehud Shapiro. </author> <title> The family of concurrent logic programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 413-510, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Although these languages have become less prominent in the research community they are still alive see for example [76, 77]. A survey of first generation concurrent logic programming can be found in <ref> [126] </ref>. The second generation includes such languages as AKL [80] and Oz [39]. These languages move away from the proof search interpretation of computation and view processes as operating over a shared constraint store. As a result it becomes difficult to view these languages as logic programming languages.
Reference: [127] <author> Ehud Y. Shapiro. </author> <title> Algorithmic program debugging. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1983. </year>
Reference-contexts: The current Lygon debugger handles the linear context adequately but is not useful for debugging concurrent programs. In the long run it would seem desirable to make use of algorithmic debugging <ref> [127] </ref>. By debugging at the logical level the complex operational semantics can be avoided. A group at Melbourne University is working on advanced debugging environments for NU-Prolog, Mercury and Lygon. 7.2 Negation as Failure and Aggregates Presently Lygon offers simple Negation as Failure a la Prolog.
Reference: [128] <author> Toshihiro Shimizu and Naoki Kobayashi. </author> <note> HACL Version 0.1 user's manual. FTP with HACL release camille.is.s.u-tokyo.ac.jp:pub/hacl, </note> <month> June </month> <year> 1994. </year>
Reference-contexts: Some of these, like LinLog [6] are based on proof-theoretic analyses, as Lygon is, but, to the best of my knowledge, have not been implemented and hence do not involve the problems of lazy splitting discussed in this thesis. Others, like ACL <ref> [85, 88, 128] </ref> and LO [8-10] use linear logic as motivation and a design guide for concurrent logic programming. These languages use a somewhat restricted class of formulae which excludes . <p> A parallel program is one which is run on multiple processors with the aim of attaining better performance. Often, the result of the computation is deterministic. A number of linear logic programming languages are targeted at concurrent applications (e.g. ACL <ref> [85, 88, 128] </ref> and LO [7-10, 29, 42]) and it has been shown that much of the calculus can be mapped into linear logic [108]. In this section we show how various aspects of concurrency can be expressed in Lygon. <p> ACL ACL [85, 88] (A Concurrent Language) uses linear logic as the basis for a concurrent programming languages. The actual language 1 <ref> [128] </ref> is an ML-like functional programming language with concurrency primitives inspired by linear logic's connectives. Some early work with ACL looked at process equivalence relations [86]. More recent work centers around the development of language tools such partial evaluators [73] and abstract interpreters [84].
Reference: [129] <author> Duncan C. Sinclair. </author> <title> Solid modelling in Haskell. </title> <booktitle> In Glasgow functional programming workshop, </booktitle> <pages> pages 246-263. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference: [130] <author> Sjaak Smetsers, Erik Barendsen, Marko van Eekelen, and Rinus Plasmeijer. </author> <title> Guaranteeing safe destructive updates through a type system with uniqueness information for graphs. </title> <editor> In Schneider and Ehrig, editors, </editor> <booktitle> Proceedings of Graph Transformations in Computer Science, </booktitle> <pages> pages 358-379. </pages> <publisher> Springer-Verlag, LNCS 776, </publisher> <year> 1994. </year>
Reference-contexts: In particular, we look at functional programming languages based on linear language and at uniqueness types. Uniqueness types apply the concept of linearity to values in a (usually declarative) programming language. Uniqueness types exist in Clean <ref> [19-21, 130] </ref>, Mercury [64, 132, 133] and in a version of Lisp developed by Henry Baker [13-16]. Uniqueness types are inspired by linear logic but in general they make use of a very limited subset of the logic.
Reference: [131] <author> Zoltan Somogyi. </author> <title> Stability of logic programs: how to connect don't-know nondeterministic logic programs to the outside world. </title> <type> Technical Report 87/11, </type> <institution> Department of Computer Science, Melbourne University, </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: In the case where an ask is wrongly made into a tell the system could fail. Although most of the concurrent logic programming languages based on linear logic have also sacrificed completeness by opting for don't care nondeterminism (i.e., abandoning backtracking) it is possible <ref> [131] </ref> to use languages with backtracking for concurrent programming and guarantee at compile time that the appropriate parts of the program will not backtrack. A problem with sacrificing completeness is that it opens a gap between the simple declarative semantics and the visualisation semantics described in section 3.12.
Reference: [132] <author> Zoltan Somogyi, Fergus Henderson, Thomas Conway, Andrew Bromage, Tyson Dowd, David Jeffery, Peter Ross, Peter Schachte, and Simon Taylor. </author> <title> Status of the Mercury system. </title> <booktitle> In Proceedings of the JICSLP'96 Workshop on Parallelism and Implementation Technology for (Constraint) Logic Programming Languages, </booktitle> <pages> pages 207-218, </pages> <year> 1996. </year>
Reference-contexts: Since the linear logic aspects are orthogonal to issues of types, modes and language purity there is no reason for Lygon to be impure future work on Lygon may well adopt strong types and modes a la Mercury <ref> [132, 133] </ref>. Syntax Lygon syntax is similar to Prolog syntax with the main difference that goals and the bodies of clauses are a (subset) of linear logic formulae rather than a sequence of atoms. Program clauses are assumed to be reusable (i.e. nonlinear). <p> In particular, we look at functional programming languages based on linear language and at uniqueness types. Uniqueness types apply the concept of linearity to values in a (usually declarative) programming language. Uniqueness types exist in Clean [19-21, 130], Mercury <ref> [64, 132, 133] </ref> and in a version of Lisp developed by Henry Baker [13-16]. Uniqueness types are inspired by linear logic but in general they make use of a very limited subset of the logic.
Reference: [133] <author> Zoltan Somogyi, Fergus Henderson, Thomas Conway, and Richard O'Keefe. </author> <title> Logic programming for the real world. </title> <editor> In Donald A. Smith, editor, </editor> <booktitle> Proceedings of the ILPS'95 Postconference Workshop on Visions for the Future of Logic Programming, </booktitle> <pages> pages 83-94, </pages> <address> Portland, Oregon, </address> <year> 1995. </year> <note> 180 BIBLIOGRAPHY </note>
Reference-contexts: Since the linear logic aspects are orthogonal to issues of types, modes and language purity there is no reason for Lygon to be impure future work on Lygon may well adopt strong types and modes a la Mercury <ref> [132, 133] </ref>. Syntax Lygon syntax is similar to Prolog syntax with the main difference that goals and the bodies of clauses are a (subset) of linear logic formulae rather than a sequence of atoms. Program clauses are assumed to be reusable (i.e. nonlinear). <p> In particular, we look at functional programming languages based on linear language and at uniqueness types. Uniqueness types apply the concept of linearity to values in a (usually declarative) programming language. Uniqueness types exist in Clean [19-21, 130], Mercury <ref> [64, 132, 133] </ref> and in a version of Lisp developed by Henry Baker [13-16]. Uniqueness types are inspired by linear logic but in general they make use of a very limited subset of the logic. <p> Lygon can be seen as Prolog + linear logic. Since these two aspects are orthogonal it is feasible to consider languages which combine linear logic features with, say, CLP (&lt;) [79] or Mercury <ref> [133] </ref>. One strategy for developing a Lygon compiler would be to consider a Mercury + Linear Logic language and compile it into Mercury. A second area with significant potential for implementation related further work is the debugging and visualisation of Lygon programs.
Reference: [134] <author> Leon Sterling and Ehud Shapiro. </author> <title> The Art of Prolog (second edition). </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Consider as an example logic programming in classical logic. It is well known that the Horn clause fragment of the logic forms a logic programming language (namely pure Prolog <ref> [134] </ref>). On the other hand, allowing arbitrary classical logic formulae as goals and programs does not result in a logic programming language since the resulting proof system lacks a number of desirable properties associated with logic programming. <p> Programming idioms such as monads in functional programming languages [141, 142] have taken a number of years to emerge. Other examples of non-obvious programming idioms include combinator parsers in functional programming languages [78], difference lists in logic programming languages etc. <ref> [117, 134] </ref>. In our examples we develop a number of linear logic programming idioms particular ways of using linear logic connectives to achieve a particular behavior. After introducing Lygon from the programmer's perspective, we introduce a number of basic idioms. <p> A second area of application involves non standard executions. Typical examples are collecting statistics, tracing and debugging. Meta-interpreters are also used in certain areas of Artificial Intelligence. Meta-interpreters are a part of the Prolog culture <ref> [117, 134] </ref>. The standard vanilla Prolog meta-interpreter handles the resolution mechanism and expresses the essence of Prolog execution in three lines: prove (true) :- true. prove ((A,B)) :- prove (A), prove (B). prove (A) :- clause (A,B), prove (B).
Reference: [135] <author> Tanel Tammet. </author> <title> Proof search strategies in linear logic. Programming Methodology Group 70, </title> <institution> University of G oteborg and Chalmers University of Technology, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Our solution is also applicable to Forum [71]. In addition to the application of this work to the implementation of logic programming languages based on linear logic, the lazy rules above presumably have application in theorem provers for linear logic <ref> [95, 113, 135, 136] </ref>, where they eliminate a significant potential source of inefficiency. 113 Chapter 5 Applications of Lygon In this chapter we look at applications of Lygon.
Reference: [136] <author> Tanel Tammet. </author> <title> Completeness of resolution for definite answers. Programming Methodology Group 79, </title> <institution> University of G oteborg and Chalmers University of Technology, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: Our solution is also applicable to Forum [71]. In addition to the application of this work to the implementation of logic programming languages based on linear logic, the lazy rules above presumably have application in theorem provers for linear logic <ref> [95, 113, 135, 136] </ref>, where they eliminate a significant potential source of inefficiency. 113 Chapter 5 Applications of Lygon In this chapter we look at applications of Lygon.
Reference: [137] <author> Naoyuki Tamura and Yukio Kaneda. </author> <title> Resource management method for a compiler system of a linear logic programming language. </title> <editor> In Michael Maher, editor, </editor> <booktitle> Proceedings of the 1996 Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> page 545. </pages> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: This observation is borne out by the work in <ref> [137, 138] </ref> where a speedup factor of 25 is reported for small Lolli programs (and a larger speedup is reported for larger programs).
Reference: [138] <author> Naoyuki Tamura and Yuko Kaneda. </author> <title> Extension of WAM for a linear logic programming language. </title> <editor> In T. Ida, A. Ohori, and M. Takeichi, editors, </editor> <booktitle> Second Fuji International Workshop on Functional and Logic Programming, </booktitle> <pages> pages 33-50. </pages> <publisher> World Scientific, </publisher> <month> November </month> <year> 1996. </year>
Reference-contexts: This observation is borne out by the work in <ref> [137, 138] </ref> where a speedup factor of 25 is reported for small Lolli programs (and a larger speedup is reported for larger programs).
Reference: [139] <author> J. Vaghani, K. Ramamohanarao, D. Kemp, Z. Somogyi, P. Stuckey, T. Leask, and J. Harland. </author> <title> The Aditi deductive database system. </title> <journal> VLDB Journal, </journal> <volume> 3(2) </volume> <pages> 245-288, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: This problem can be avoided by using a memoing system such as XSB [144], or a bottom-up system such as Aditi <ref> [139] </ref>. However, it is common to re-write the program above so that the path found is returned as part of the answer. In such cases, systems such as XSB and Aditi will only work for graphs which are acyclic. <p> Other applications for linear logic programming languages include modelling database transactions and further work in artificial intelligence, such as belief revision. The derivation of logic programming languages from non-classical logics has so far focused exclusively on top-down derivations. In the context of deductive databases <ref> [139] </ref> the complementary approach is of importance. Under the bottom-up execution model rules are applied to derive new facts from old facts. The implementation is typically set at a time rather than tuple at a time and the notion of a goal plays a much lesser role.
Reference: [140] <author> Paolo Volpe. </author> <title> Concurrent logic programming as uniform linear proofs. </title> <editor> In Giorgio Levi and Mario Rodrguez-Artalejo, editors, </editor> <booktitle> Algebraic and Logic Programming, </booktitle> <pages> pages 133-149. </pages> <publisher> Springer-Verlag LNCS 850, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: ? j &gt; j A m j?A m j A p j G O G j G N G j 8xG j R m : : : A ? LO [10] G ::= A j &gt; j G N G j G O G Forum [109] D ::= G LC <ref> [140] </ref> G ::= A j 1 ? j &gt; j G O G j G G j 9xG Lygon [122] D ::= A j 1 j ? j D N D j D D j G ( A j G ? j 8xD j!D j D O D 21 Chapter 3 <p> Unfortunately uniformity is defined in the context of single conclusioned sequent calculi systems. This is a problem since we are interested in a general criteria applicable to a range of both single and multiple conclusion logics including relevant logic [24], temporal and modal logics [118] and linear logic <ref> [6, 10, 70, 85, 109, 140, 147] </ref>. This chapter continues the investigation into the derivation of logic programming languages. We define a number of formal characterisers (including uniformity) and explore the relationships amongst them. We begin with single conclusion logics and then generalise to the multiple conclusion setting. <p> Unfortunately, it suffers from a number of problems. Firstly, uniformity is only defined for single conclusion sequent systems 1 . A straightforward extension to a multiple conclusion setting is fairly obvious <ref> [55, 106, 109, 140] </ref> but it requires that all connectives occurring in goals permute over each other are-striction which we shall see is unnecessary. Another problem with a simple generalisation of uniformity to multiple conclusion sequent systems involves one sided presentations. <p> Furthermore according to theorem 61, LO proofs satisfy the left-focusing condition. ffi COROLLARY:LO satisfies D S , C , A and C strong . PROPOSITION 66 LO satisfies B. Proof: Simple induction as for ACL. ffi 3.6.3 LC The language LC (Linear Chemistry) <ref> [140] </ref> is based on a similar proof theoretical analysis to Lolli and Lygon. It is designed to satisfy criterion D A . Its choice of connectives is interesting. Note that LC does not use any binary rules and thus its proofs are sticks rather than trees. <p> In the absence of a notion of atom-guided proof search, the options that have been considered in order to extend uniformity to a multiple conclusion setting <ref> [55, 106, 140] </ref> are: D all : For a sequent of the form ` C; A or ` C there exist proofs where the first step introduces the topmost connective of F for all F 2 C. <p> Doing this yields a more limited class of formulae but simplifies the implementation. This path was taken in the design of LC <ref> [140] </ref> and LO [8]. In the design of Lygon the opposite choice was made. As a result Lygon has a significantly larger class of formulae but has to contend with the problem that selecting the active formulae may have to be done using don't know nondeterminism. <p> Like LO, ACL sacrifices completeness by implementing don't care nondetermin-ism. The class of formulae used in ACL is a subset of the Lygon 2 class of formulae. LC LC (Linear Chemistry) <ref> [140] </ref> is a minimal concurrent language fairly similar in capabilities to ACL. It is interesting for a number of reasons. Firstly, it was systematically derived using a generalisation of uniformity.
Reference: [141] <author> Philip Wadler. </author> <title> Comprehending monads. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 61-78, </pages> <address> Nice, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: The second aim of the chapter is to develop a methodology of Lygon programming. Finding ways of using new programming constructs can be highly non-trivial. Programming idioms such as monads in functional programming languages <ref> [141, 142] </ref> have taken a number of years to emerge. Other examples of non-obvious programming idioms include combinator parsers in functional programming languages [78], difference lists in logic programming languages etc. [117, 134].
Reference: [142] <author> Philip Wadler. </author> <title> The essence of functional programming (invited talk). </title> <booktitle> In 19'th ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: The second aim of the chapter is to develop a methodology of Lygon programming. Finding ways of using new programming constructs can be highly non-trivial. Programming idioms such as monads in functional programming languages <ref> [141, 142] </ref> have taken a number of years to emerge. Other examples of non-obvious programming idioms include combinator parsers in functional programming languages [78], difference lists in logic programming languages etc. [117, 134].
Reference: [143] <author> David Wakeling and Colin Runciman. </author> <title> Linearity and laziness. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <pages> pages 215-240. </pages> <publisher> Springer-Verlag LNCS 523, </publisher> <year> 1991. </year>
Reference-contexts: The two main uses of uniqueness types are to guarantee single threading of side effecting I/O operations and to ensure single threading of data structures in particular arrays to ensure that in place updating can be done safely. This second application can be seen as a garbage collection issue <ref> [33, 143] </ref>. A related application of linear logic is its use to derive functional programming languages. This is done using the Curry-Howard isomorphism which states that there is an equivalence between theorems and types in the -calculus.
Reference: [144] <author> David S. Warren. </author> <title> Programming the PTQ grammar in XSB. </title> <editor> In Raghu Ramakr-ishna, editor, </editor> <booktitle> Applications of Logic Databases, </booktitle> <pages> pages 217-234. </pages> <publisher> Kluwer Academic, </publisher> <year> 1994. </year>
Reference-contexts: For example, the order of the predicates in the recursive rule is important, as due to Pro-log's computation rule, if the predicates are in the reverse order, then goals such as path (a,Y) will loop forever. This problem can be avoided by using a memoing system such as XSB <ref> [144] </ref>, or a bottom-up system such as Aditi [139]. However, it is common to re-write the program above so that the path found is returned as part of the answer. In such cases, systems such as XSB and Aditi will only work for graphs which are acyclic.
Reference: [145] <author> G. White. </author> <title> The design of a situation-based Lygon metainterpreter: I. Simple changes and persistence. </title> <type> Technical Report 729, </type> <institution> Department of Computer Science, Queen Mary and Westfield College, University of London, </institution> <month> October </month> <year> 1996. </year>
Reference-contexts: Linear logic allows a real-isation of the Event Calculus which is pure, direct and implements change as a local operation. In addition to being simpler, being able to view change as a local operation is also considerably more efficient. In <ref> [145] </ref> a more detailed analysis is performed and a Lygon meta-interpreter constructed. The same conclusion that linear logic is a much more natural (and efficient!) framework for representing change is reached. We look at a number of examples: 1.
Reference: [146] <author> Michael Winikoff. </author> <title> Hitch hiker's guide to Lygon 0.7. </title> <type> Technical Report 96/36, </type> <institution> Melbourne University, </institution> <month> October </month> <year> 1996. </year>
Reference-contexts: Lygon is closest to the current Lygon implementation <ref> [146, 147] </ref> (see also section 5.1). PROPOSITION 80 Lygon ? and Lygon satisfy criteria A. Proof: Obvious. ffi 3.8. LYGON 61 PROPOSITION 81 Lygon ? satisfies criterion B. Proof: Proof by induction. <p> There is also a Lygon Road in Edinburgh which is familiar to Harland and Pym. Current information about Lygon can be found on the web [147]. Information on the Lygon language and implementation can be found in <ref> [146] </ref>. 114 CHAPTER 5. <p> The Lygon programs presented were mostly tested under Lygon 0.7.1. A few (those requiring textual input for example) were run under Lygon 0.4. The implementation is available from the Lygon World Wide Web page [147] at http://www.cs.mu.oz.au/winikoff/lygon. For more details on the Ly-gon implementation and its use see <ref> [146] </ref>. 5.2 Basic Techniques We begin by presenting a number of simple Lygon programs. Some of these demonstrate generally useful programming idioms which will be used in later sections. 1 Available from http://clement.info.umoncton.ca/tarau/ 2 As counted by wc. 3 Available from http://www.sunlabs.com:80/research/tcl/ 5.2. <p> Delete one chopstick 6. Write Grabbing chopstick 7. Delete other chopstick 8. Write Grabbing chopstick 9. Write Eating 5.4. CONCURRENCY 141 10. Write Returning 11. Add room ticket and both chopsticks 12. Goto step 1 It is recommended that this program be run with fairness (see <ref> [146] </ref>) turned on.
Reference: [147] <author> Michael Winikoff. </author> <note> Lygon home page. http://www.cs.mu.oz.au/winikoff/lygon, 1996. BIBLIOGRAPHY 181 </note>
Reference-contexts: Unfortunately uniformity is defined in the context of single conclusioned sequent calculi systems. This is a problem since we are interested in a general criteria applicable to a range of both single and multiple conclusion logics including relevant logic [24], temporal and modal logics [118] and linear logic <ref> [6, 10, 70, 85, 109, 140, 147] </ref>. This chapter continues the investigation into the derivation of logic programming languages. We define a number of formal characterisers (including uniformity) and explore the relationships amongst them. We begin with single conclusion logics and then generalise to the multiple conclusion setting. <p> Lygon is closest to the current Lygon implementation <ref> [146, 147] </ref> (see also section 5.1). PROPOSITION 80 Lygon ? and Lygon satisfy criteria A. Proof: Obvious. ffi 3.8. LYGON 61 PROPOSITION 81 Lygon ? satisfies criterion B. Proof: Proof by induction. <p> Lygon the programming language is named after Lygon Street. Lygon street is close to Melbourne University and is known for its restaurants and cafes. There is also a Lygon Road in Edinburgh which is familiar to Harland and Pym. Current information about Lygon can be found on the web <ref> [147] </ref>. Information on the Lygon language and implementation can be found in [146]. 114 CHAPTER 5. <p> The Lygon programs presented were mostly tested under Lygon 0.7.1. A few (those requiring textual input for example) were run under Lygon 0.4. The implementation is available from the Lygon World Wide Web page <ref> [147] </ref> at http://www.cs.mu.oz.au/winikoff/lygon. For more details on the Ly-gon implementation and its use see [146]. 5.2 Basic Techniques We begin by presenting a number of simple Lygon programs.
Reference: [148] <author> Michael Winikoff and James Harland. </author> <title> Deterministic resource management for the linear logic programming language Lygon. </title> <type> Technical Report 94/23, </type> <institution> Mel-bourne University, </institution> <year> 1994. </year>
Reference: [149] <author> Michael Winikoff and James Harland. </author> <title> Implementation and development issues for the linear logic programming language Lygon. </title> <booktitle> In Australasian Computer Science Conference, </booktitle> <pages> pages 563-572, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: As a result the implementation problems are correspondingly simpler, in that neither language needs lazy splitting 1 , and so again the problems addressed in this paper do not arise. The last class of linear logic programming languages comprises Lolli [68-70], Forum [109] and Lygon <ref> [57, 122, 149] </ref>. These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful.
Reference: [150] <author> Michael Winikoff and James Harland. </author> <title> Implementing the linear logic programming language Lygon. </title> <editor> In John Lloyd, editor, </editor> <booktitle> International Logic Programming Symposium, </booktitle> <pages> pages 66-80, </pages> <address> Portland, Oregon, December 1995. </address> <publisher> MIT Press. </publisher>
Reference-contexts: An obvious example is the use of logical variables and unification to delay the choice of a term in the 9 R and 8 L rules. Another example is the handling of the R rule in linear logic based programming languages <ref> [70, 150] </ref> (see also chapter 4). An additional problem with the use 3.3. THE SINGLE CONCLUSION CASE 29 of efficiency as a characteriser is that the vast majority of logic programming languages and systems omit the occur check. This yields efficiency but costs sound ness. <p> These observations (which are incorporated in the current version of Lygon) yield a significant reduction in the nondeterminism associated with selecting the active formula. Benchmarks <ref> [150] </ref> indicate that the overhead of implementing these strategies is not significant. The benefit of these strategies varies heavily depending on the program. For programs which do not use O there is no benefit as formula selection is always trivial. <p> Both these optimisations are incorporated in the Lygon interpreter. Since both of these sources of nondeterminism are exponential, avoiding them is essential for a non-toy implementation. Measurements confirm that these optimisations are significant <ref> [150] </ref>. 4.5. DISCUSSION 111 Whilst the method presented for splitting resources between sub-branches is optimal (in that the and &gt; rules are deterministic) the selection of the formula to be reduced is not. In practice the current system is adequate for the programs we have written.
Reference: [151] <author> Michael Winikoff and James Harland. </author> <title> Deriving logic programming languages. </title> <type> Technical Report 95/26, </type> <institution> Melbourne University, </institution> <year> 1996. </year>
Reference-contexts: Since there are no atoms, we know that the sequent cannot be the result of left rules or the axiom rule and thus it must be the result of a right rule. ffi COROLLARY:ACL satisfies criteria A and C. 11 Note that, unlike the technical report version of this chapter <ref> [151] </ref> we are using the extended version of ACL on page 285 of [85] which includes quantifiers. 3.6. EXAMPLES 55 3.6.2 LO LO (Linear Objects) [10] is one of the earlier languages based on linear logic.
Reference: [152] <author> Michael Winikoff and James Harland. </author> <title> Some applications of the linear logic programing language Lygon. </title> <editor> In Kotagiri Ramamohanarao, editor, </editor> <booktitle> Australasian Computer Science Conference, </booktitle> <pages> pages 262-271, </pages> <month> February </month> <year> 1996. </year>
Reference: [153] <author> Yi Xiao Xu. </author> <title> Debugging environment design for the logic programming language Lygon. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, Royal Melbourne Institute of Technology, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: The user interface is written in TCL/Tk 3 and consists of some 591 lines of code. The graphical user interface is depicted in figure 5.1. The user interface and interpreter communicate via Unix pipes. The system integrates the Lygon four port debugger developed by Yi Xiao Xu <ref> [153] </ref>. The debugger provides an execution trace which can be filtered according to a number of criteria. The Lygon programs presented were mostly tested under Lygon 0.7.1. A few (those requiring textual input for example) were run under Lygon 0.4.
Reference: [154] <author> Helinna Yiu. </author> <title> Programming constructs for Lygon. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, Royal Melbourne Institute of Technology, </institution> <year> 1997. </year> <note> 182 BIBLIOGRAPHY 183 </note>
Reference-contexts: The result (A = neg p N neg q) is then passed to prove. One of the applications of meta-interpreters is to enable easy experimentation with language variants and extensions. One language extension to Lygon which has been proposed <ref> [154] </ref> is rules. A rule of the form rule (N,Is ) Os) is read as stating that in order to prove N we must consume Is and produce Os. Alternatively, the rule rewrites the multiset containing N and Is to the multiset containing Os. <p> One area for further work is the use of syntactic sugar to make common idioms less syntactically clumsy. Rules (see program 28 and <ref> [154] </ref>) are an example of syntactic sugar. Another area for further work concerns type systems. Type systems for logic programming languages [121] describe the usage of terms. In linear logic programming languages it makes sense to also consider a form of typing which operates at the level of predicates.
References-found: 154

