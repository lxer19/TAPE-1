URL: http://www.cs.rutgers.edu/~yur/ICSE/paper.ps
Refering-URL: http://www.cs.rutgers.edu/~landi/pubs.html
Root-URL: http://www.cs.rutgers.edu
Email: fyur,ryder,pstocksg@cs.rutgers.edu  landi@scr.siemens.com  
Phone: +1 732 445  +1 609 734 6500  
Title: Incremental Analysis of Side Effects for C Software Systems  
Author: Jyh-shiarn Yur Barbara G. Ryder William A. Landi Phil Stocks 
Keyword: Dataflow analysis, incremental analysis  
Address: Piscataway NJ 08855, USA  2001  755 College Road East Princeton NJ 08540, USA  
Affiliation: Department of Computer Science Rutgers University  Siemens Corporate Research, Inc.  
Abstract: Incremental static analysis seeks to efficiently update semantic information about an evolving software system, without recomputing "from scratch." Interprocedural modification side effect analysis (M OD) calculates the set of variables possibly modified by execution of a procedure or a statement. We introduce a partial incre-mentalization of M OD for C systems using the hybrid method and present results of a study of 27 C programs, that predicts that our incremental M OD analysis will be substantially cheaper than exhaustive analysis for many program changes. 
Abstract-found: 1
Intro-found: 1
Reference: [BR90] <author> M. Burke and B. G. Ryder. </author> <title> A critical analysis of incremental iterative data flow analysis algorithms. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(7), </volume> <month> July </month> <year> 1990. </year>
Reference-contexts: Pollock and Soffa [PS89] 1 present precise incremental iterative algorithms, using change classification and reinitialization, for bitvector problems. A comparison of these incremental iterative algorithms is found in <ref> [BR90] </ref>. The incremental hybrid algorithm [MR90] handles changes by combining the elimination and iteration methods. A hybrid incremental algorithm for the reference parameter aliasing problem of Fortran is proposed in [MR91].
Reference: [Bur90] <author> M. Burke. </author> <title> An interval-based approach to exhaustive and incremental interproce-dural data flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 341-395, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: These calculations show that incremental analysis will be substantially cheaper than total reanalysis. Related Work Many incremental algorithms have been developed for the data flow analysis, which are useful, especially in a programming environment [Zad84]. Some incremental analyses use incremental elimination methods <ref> [Bur90, CR88, RP88] </ref>; some are based on the technique of restarting iteration [CK84, PS89]. <p> A hybrid incremental algorithm for the reference parameter aliasing problem of Fortran is proposed in [MR91]. For the M OD problem for Fortran-like languages, efficient flow-insensitive algorithms are proposed in [CK84, Coo85], and the incremental MOD problem for Fortran was handled in <ref> [Bur90] </ref>. The incremental M OD problem for C is more complicated than its counterpart for Fortran mainly because the pointer aliasing information for C may change inter- and intra-procedurally.
Reference: [CK84] <author> K. Cooper and K. Kennedy. </author> <title> Efficient computation of flow insensitive interprocedural summary information. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 247-258, </pages> <month> June </month> <year> 1984. </year> <journal> SIG-PLAN Notices, </journal> <volume> Vol 19, No 6. </volume>
Reference-contexts: Related Work Many incremental algorithms have been developed for the data flow analysis, which are useful, especially in a programming environment [Zad84]. Some incremental analyses use incremental elimination methods [Bur90, CR88, RP88]; some are based on the technique of restarting iteration <ref> [CK84, PS89] </ref>. When a change is made, restarting iteration from the previously computed solution does not always yield a precise solution. [RMP88] shows some sufficient conditions under which restarting iteration results in the same solution as an exhaustive iterative method. <p> The incremental hybrid algorithm [MR90] handles changes by combining the elimination and iteration methods. A hybrid incremental algorithm for the reference parameter aliasing problem of Fortran is proposed in [MR91]. For the M OD problem for Fortran-like languages, efficient flow-insensitive algorithms are proposed in <ref> [CK84, Coo85] </ref>, and the incremental MOD problem for Fortran was handled in [Bur90]. The incremental M OD problem for C is more complicated than its counterpart for Fortran mainly because the pointer aliasing information for C may change inter- and intra-procedurally.
Reference: [Coo85] <author> K. Cooper. </author> <title> Analyzing aliases of reference formal parameters. </title> <booktitle> In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 281-290, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: The incremental hybrid algorithm [MR90] handles changes by combining the elimination and iteration methods. A hybrid incremental algorithm for the reference parameter aliasing problem of Fortran is proposed in [MR91]. For the M OD problem for Fortran-like languages, efficient flow-insensitive algorithms are proposed in <ref> [CK84, Coo85] </ref>, and the incremental MOD problem for Fortran was handled in [Bur90]. The incremental M OD problem for C is more complicated than its counterpart for Fortran mainly because the pointer aliasing information for C may change inter- and intra-procedurally.
Reference: [CR88] <author> M. D. Carroll and B. G. Ryder. </author> <title> Incremental data flow analysis via dominator and attribute updates. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 274-284, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: These calculations show that incremental analysis will be substantially cheaper than total reanalysis. Related Work Many incremental algorithms have been developed for the data flow analysis, which are useful, especially in a programming environment [Zad84]. Some incremental analyses use incremental elimination methods <ref> [Bur90, CR88, RP88] </ref>; some are based on the technique of restarting iteration [CK84, PS89].
Reference: [LR92] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximation algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: This can be calculated while parsing the program during compilation. ALIAS (n; RA) is the solution of the interprocedural may alias problem (IPMay Alias) at statement n in the presence of general purpose pointers <ref> [LR92] </ref>. If &lt;*x,*y&gt; is in ALIAS (n; RA), this means that x and y may point to the same object on exit from statement n. <p> We have proved previously that for programs limited to a single level of dereference, a single reaching alias precisely represents calling context for IPMay Alias <ref> [LR92] </ref>. Empirical evidence indicates that this also closely approximates calling context for the side effect calculation in programs with multiple levels of dereferencing [LRZ93]. 2 We name heap variables by their creation site, obtaining an approximate fixed location for those locations allocated [LRZ93]. <p> Since x is a local in main, and thus not accessible in P, we use a special symbol, nv, instead of x, as an abstraction of the variables in the calling procedure which are non visible, but still accessible through their aliases in the called procedure <ref> [LR92] </ref>. Note that nv in different nodes can represent different things.
Reference: [LRZ93] <author> W. Landi, B. G. Ryder, and S. Zhang. </author> <title> In-terprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 56-67, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Software understanding tools used by maintainers to assess the impact of a source code bug fix or enhancement use extracted side effect descriptions for a program. Interprocedural modification side effect analysis (M OD <ref> [LRZ93] </ref>) finds the set of variables in a program whose values may be affected by program execution. Side effects are reported for an individual statement and/or an entire procedure. <p> Statement execution can change the value of a variable either by direct assignment or by indirect assignment through an alias of the lefthand-side variable. Figure 1 shows the relevant parts of the problem decomposition of M OD for C programs with general-purpose pointers <ref> [LRZ93] </ref>. In this decomposition, there are only two data flow problems: ALIAS and PMOD. All others shown are just set combinations of their subproblems. DIRM OD (n) contains the set of variables which may experience direct side effects through assignments at program point n. <p> We have proved previously that for programs limited to a single level of dereference, a single reaching alias precisely represents calling context for IPMay Alias [LR92]. Empirical evidence indicates that this also closely approximates calling context for the side effect calculation in programs with multiple levels of dereferencing <ref> [LRZ93] </ref>. 2 We name heap variables by their creation site, obtaining an approximate fixed location for those locations allocated [LRZ93]. CondIM OD (P; RA) is the union of CondLM OD (n; RA) sets for all statements n in procedure P . <p> Empirical evidence indicates that this also closely approximates calling context for the side effect calculation in programs with multiple levels of dereferencing <ref> [LRZ93] </ref>. 2 We name heap variables by their creation site, obtaining an approximate fixed location for those locations allocated [LRZ93]. CondIM OD (P; RA) is the union of CondLM OD (n; RA) sets for all statements n in procedure P . CondIMOD summarizes all side effects in P except those due to call statements. <p> Our analysis makes the usual assumption of static analysis, namely that all intraprocedural paths are executable. The RA's in our analysis enable a good approximation of the possibly executable interprocedural paths (i.e., realizable paths) <ref> [LRZ93] </ref>. M OD (P ) summarizes possible side effects over all executions of procedure P (i.e., for all calling contexts which occur). New Program Representation Interprocedural static analyses often use a call multi-graph: a graphical representation of the possible calling relations between procedures in a program. <p> We call each such interesting statement a test. The programs are listed in Figure 8, ordered by the number of statements in our intermediate representation <ref> [LRZ93, YR95] </ref>. We also show the number of nodes and edges of the corresponding call-RA graphs. The rightmost two columns show the number of tests (i.e., the number of interesting source statements) and the percentage of the intermediate code corresponding to the set of interesting source statements.
Reference: [MR90] <author> T. J. Marlowe and B. G. Ryder. </author> <title> An efficient hybrid algorithm for incremental data flow analysis. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 184-196, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: This paper describes how we have taken PMOD, a significant subproblem of M OD for C, and made it incremental using the hybrid algorithm for data flow analysis <ref> [MR90] </ref>. This data flow method partitions the flow graph into components, uses fixed point iteration within components to solve local versions of the data flow problem, and knits together these local solutions into a global solution. <p> Pollock and Soffa [PS89] 1 present precise incremental iterative algorithms, using change classification and reinitialization, for bitvector problems. A comparison of these incremental iterative algorithms is found in [BR90]. The incremental hybrid algorithm <ref> [MR90] </ref> handles changes by combining the elimination and iteration methods. A hybrid incremental algorithm for the reference parameter aliasing problem of Fortran is proposed in [MR91]. <p> Figure 2 (d) shows the nv backbind sets for other edges and paths in the call-RA graph. nv backbind fl is explained in the next section. Reformulation of PMOD e , which makes it easier to apply the hybrid algorithm <ref> [MR90] </ref>. E 0 is the edge set of the call-RA graph. The function b maps names between scopes, mapping globals to themselves, discarding locals (and formal parameters), and mapping non visibles to their corresponding names in scope. <p> Incremental Hybrid Algorithm The hybrid data flow analysis algorithm <ref> [MR90] </ref> is based on a graph decomposition (usually by strongly connected components) which divides the flow graph into single entry regions. Local variants of the data flow problem are defined and solved on each region. <p> For each region whose exit node (s) have a changed solution, recalculate the global solutions for nodes within that region. If a source code change affects the region decomposition or topological order, then these must be adjusted before these other steps and recalculation occurs from change points <ref> [MR90] </ref>. The hybrid algorithm must be specialized to specific instances of data flow problems, such as PMOD. The key step in specializing a problem is factoring the global data flow problem into a set of local problems that are solved separately on the region.
Reference: [MR91] <author> T. J. Marlowe and B. G. Ryder. </author> <title> Hybrid incremental alias algorithms. </title> <booktitle> In Proceedings of the Twentyfourth Hawaii International Conference on System Sciences, Volume II, Software, </booktitle> <month> January </month> <year> 1991. </year>
Reference-contexts: A comparison of these incremental iterative algorithms is found in [BR90]. The incremental hybrid algorithm [MR90] handles changes by combining the elimination and iteration methods. A hybrid incremental algorithm for the reference parameter aliasing problem of Fortran is proposed in <ref> [MR91] </ref>. For the M OD problem for Fortran-like languages, efficient flow-insensitive algorithms are proposed in [CK84, Coo85], and the incremental MOD problem for Fortran was handled in [Bur90].
Reference: [PS89] <author> L. Pollock and M. Soffa. </author> <title> An incremental version of iterative data flow analysis. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(12), </volume> <month> December </month> <year> 1989. </year>
Reference-contexts: Related Work Many incremental algorithms have been developed for the data flow analysis, which are useful, especially in a programming environment [Zad84]. Some incremental analyses use incremental elimination methods [Bur90, CR88, RP88]; some are based on the technique of restarting iteration <ref> [CK84, PS89] </ref>. When a change is made, restarting iteration from the previously computed solution does not always yield a precise solution. [RMP88] shows some sufficient conditions under which restarting iteration results in the same solution as an exhaustive iterative method. <p> When a change is made, restarting iteration from the previously computed solution does not always yield a precise solution. [RMP88] shows some sufficient conditions under which restarting iteration results in the same solution as an exhaustive iterative method. Pollock and Soffa <ref> [PS89] </ref> 1 present precise incremental iterative algorithms, using change classification and reinitialization, for bitvector problems. A comparison of these incremental iterative algorithms is found in [BR90]. The incremental hybrid algorithm [MR90] handles changes by combining the elimination and iteration methods.
Reference: [RMP88] <author> B. G. Ryder, T. J. Marlowe, and M. C. Paull. </author> <title> Conditions for incremental iteration: Examples and counterexamples. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 11 </volume> <pages> 1-15, </pages> <year> 1988. </year>
Reference-contexts: Some incremental analyses use incremental elimination methods [Bur90, CR88, RP88]; some are based on the technique of restarting iteration [CK84, PS89]. When a change is made, restarting iteration from the previously computed solution does not always yield a precise solution. <ref> [RMP88] </ref> shows some sufficient conditions under which restarting iteration results in the same solution as an exhaustive iterative method. Pollock and Soffa [PS89] 1 present precise incremental iterative algorithms, using change classification and reinitialization, for bitvector problems. A comparison of these incremental iterative algorithms is found in [BR90]. <p> Restarting iteration can get a correct solution only if the old solution is a safe 4 initial estimate; otherwise, all or part of the solutions must be re-initialized to a safe initial value <ref> [RMP88] </ref>. Changes that can be accommodated by restarting iteration are called additive. 4 For the PMOD problem, an initial estimate is safe, if we can be sure that it will be contained in the final PMOD solution. CondIMOD. Only the LOC 1 information is affected by the change of CondIMOD.
Reference: [RP88] <author> B. G. Ryder and M. C. Paull. </author> <title> Incremental data flow analysis algorithms. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(1) </volume> <pages> 1-50, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: These calculations show that incremental analysis will be substantially cheaper than total reanalysis. Related Work Many incremental algorithms have been developed for the data flow analysis, which are useful, especially in a programming environment [Zad84]. Some incremental analyses use incremental elimination methods <ref> [Bur90, CR88, RP88] </ref>; some are based on the technique of restarting iteration [CK84, PS89].
Reference: [YR95] <author> J. Yur and B.G. Ryder. </author> <title> Incremental analysis of the MOD problem for C. </title> <institution> Laboratory for Computer Science Research Technical Report LCSR-TR-254, Department of Computer Science, Rutgers University, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: If the changed edge is within a region, before information propagation, we have to update the solutions of LOC 1 and LOC 3 within that region, analogously to steps 1-3 in Figure 5. Details about the algorithm M odif yBackbind are given in <ref> [YR95] </ref>. Structural Changes Structural changes are those which can change the shape of the call-RA graph or its decomposition, and thus are harder to handle than non-structural changes. An edge may be added or deleted if the aliases reaching the entry of a procedure change. <p> Then, we are able to handle the inter-region edge as an edge within the resulting region. The case for edge addition without region merge is similar to edge deletion. Details about algorithm AddAnEdge are given in <ref> [YR95] </ref>. IMPACT OF SOURCE CHANGES We have shown how to handle changes to the call-RA graph. The incremental algorithm is effective when the impact of the source code changes on the call-RA graph and the PMOD solution is small. <p> We call each such interesting statement a test. The programs are listed in Figure 8, ordered by the number of statements in our intermediate representation <ref> [LRZ93, YR95] </ref>. We also show the number of nodes and edges of the corresponding call-RA graphs. The rightmost two columns show the number of tests (i.e., the number of interesting source statements) and the percentage of the intermediate code corresponding to the set of interesting source statements.
Reference: [Zad84] <author> F. K. Zadeck. </author> <title> Incremental data flow analysis in a structured program editor. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 132-143, </pages> <month> June </month> <year> 1984. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 19, No 6. </volume>
Reference-contexts: These calculations show that incremental analysis will be substantially cheaper than total reanalysis. Related Work Many incremental algorithms have been developed for the data flow analysis, which are useful, especially in a programming environment <ref> [Zad84] </ref>. Some incremental analyses use incremental elimination methods [Bur90, CR88, RP88]; some are based on the technique of restarting iteration [CK84, PS89].
References-found: 14

