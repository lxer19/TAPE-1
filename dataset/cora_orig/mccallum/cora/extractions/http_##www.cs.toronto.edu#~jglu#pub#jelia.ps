URL: http://www.cs.toronto.edu/~jglu/pub/jelia.ps
Refering-URL: http://www.cs.toronto.edu/~jglu/pub/
Root-URL: http://www.cs.toronto.edu
Title: Higher Order Generalization  
Author: Jianguo Lu Masateru Harao Masami Hagiya 
Keyword: higher order logic, unification, anti-unification, generalization.  
Abstract: Generalization is a fundamental operation of inductive inference. While first order syntactic generalization (anti-unification) is well understood, its various extensions are needed in applications. This paper discusses syntactic higher order generalization in a higher order language 2[1]. Based on the application ordering, we proved the least general generalization exists and is unique up to renaming. An algorithm to compute the least general generalization is presented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Barendregt, </author> <title> Introduction to generalized type systems, </title> <journal> Journal of functional programming, </journal> <volume> Vol. 1, N0. 2, </volume> <year> 1991. </year> <pages> 124-154. </pages>
Reference-contexts: That means any two terms beginning with functional variables are considered equal. Unlike the other approaches, which mainly put restrictions on the situated language, we mainly restrict the notion of the ordering between terms. Our discussion is situated in a restricted form of the language 2 <ref> [1] </ref>. The reason to choose 2 is that it is a simple calculus which allows type variables. It can be used to formalise various concepts in programming languages, such as type definition, abstract data types, and polymorphism. The restriction we added is that abstractions should not occur inside arguments. <p> results similar to the first order anti-unification: 2 * For any two terms t and s, t SF s is decidable. * The least general generalization exists. * The least general generalization is unique up to renaming. 2 Preliminaries The syntax of the restricted 2 can be defined as follows <ref> [1] </ref>: Definition 1 (types and terms) The set of types is defined as: V = fff; ff 1 ; ff 2 ; :::g, (type variables), C = ffl; fl 1 ; fl 2 ; :::g), (type constants), T = V jCjT ! T j [V ]T , (types). <p> Suppose <ref> [; 0 ; 1 ] </ref>t 0 [; 0 ; 2 ]t 0 ... k = Gen ([; k1 ]t k ; [ 0 ; k1 ]s k ; C), T yp (h 0 (r 1 ; :::; r i )) = o 1 ; o 2 ; :::; o k ! <p> For example, H means the usual instantiate ordering in a higher order language, say P 2 <ref> [1] </ref>. 1 the usual instantiation ordering in first order language, M the ordering in M , L the ordering in L (i.e., in higher order patterns), etc.. The arrow means implication. For example, if t S s, then t SF s, and t H s.
Reference: [2] <author> Coquand, T., Huet, G., </author> <title> The calculus of constructions, </title> <journal> Information and Computation, Vol.76, </journal> <volume> No.3/4(1988), </volume> <pages> 95-120. 14 </pages>
Reference-contexts: This paper is devoted to the study of higher order generalization. More specifically, we study the conditions under which the least higher order generalization exist and unique. The most closely related works are [10] [3]. [10] studied generalization in a restricted form of calculus of constructions <ref> [2] </ref>, where terms are higher-order patterns, i.e., free variables can only apply to distinct bound variables. One problem of the generalization in higher-order patterns is the over generalization. <p> Suppose [; 0 ; 1 ]t 0 <ref> [; 0 ; 2 ] </ref>t 0 ... k = Gen ([; k1 ]t k ; [ 0 ; k1 ]s k ; C), T yp (h 0 (r 1 ; :::; r i )) = o 1 ; o 2 ; :::; o k ! o k+1 .
Reference: [3] <author> C.Feng, S.Muggleton, </author> <title> Towards inductive generalization in higher order logic, </title> <editor> In D.Sleeman et al(eds.), </editor> <booktitle> Proceedings of the Ninth International Workshop on Machine Learning, </booktitle> <address> San Mateo, California, 1992. </address> <publisher> Morgan Kaufman. </publisher>
Reference-contexts: Obviously, some restrictions must be imposed on higher order generalization. This paper is devoted to the study of higher order generalization. More specifically, we study the conditions under which the least higher order generalization exist and unique. The most closely related works are [10] <ref> [3] </ref>. [10] studied generalization in a restricted form of calculus of constructions [2], where terms are higher-order patterns, i.e., free variables can only apply to distinct bound variables. One problem of the generalization in higher-order patterns is the over generalization. <p> Another problem of higher-order pattern is that it is inadequate to express some problems. In particular, it can not represent recursion in its terms. This motivated the study of generalization in M <ref> [3] </ref>. In M, free variables can apply to object term, which can contain constants and free variables in addition to bound variables. In this sense, M extends L. On the other hand, it also added some restrictions. <p> Firstly, we defined a new ordering SF . In terms of this ordering, we obtain a much more specific generalization in general. For example, the terms Aab and Bab would be generalized as a single variable x in [10], or as f ts in <ref> [3] </ref>, where t and s are arbitrary terms. In contrast, we will have [f ]f ab as its least general generalization. Secondly, our approach can produce a meaningful generalization of terms of different types and terms of different arities, instead a single variable x.
Reference: [4] <author> M. Hagiya, </author> <title> Generalization from partial parametrization in higher order type theory, </title> <booktitle> Theoretical Computer Science, </booktitle> <address> Vol.63(1989), pp.113-139. </address>
Reference: [5] <author> R.Hasker, </author> <title> The replay of program derivations, </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <year> 1995. </year>
Reference: [6] <author> G.P.Huet, </author> <title> A unification algorithm for typed lambda calculus, </title> <booktitle> Theoretical Computer Science, 1 (1975), </booktitle> <pages> 27-57. </pages>
Reference-contexts: Here we exclude the identity and projection functions as subterms. This is essential to guarantee there exists least generalization in the application ordering. The intuitive behind this is that when we match two higher order terms, in general there are imitation rule and projection rule <ref> [6] </ref>. Here only imitation rule is used. We regard it is projection rule that brings about the unpleasant results and the complexities in higher order generalizations.
Reference: [7] <author> G.Huet, Bernard Lang, </author> <title> Proving and applying program transformations expressed with second order patterns, </title> <journal> Acta Informatica 11, </journal> <pages> 31-55(1978) </pages>
Reference-contexts: Intuitively, here we first freeze some variables in s as a constant, then try to do generalization. The word f reeze comes from <ref> [7] </ref>, which has the notion that when unifying two free variables, we can regard one of them as a constant.
Reference: [8] <author> Jianguo Lu, Jiafu Xu, </author> <title> Analogical Program Derivation based on Type Theory, </title> <booktitle> Theoretical Computer Science, </booktitle> <address> Vol.113, North Holland 1993, pp.259-272. </address>
Reference-contexts: Higher order generalization also finds its applications in analogy analysis <ref> [8] </ref>. It is commonly recognized that a good way to obtain the concrete correspondence between two problems is to obtain the generalization of the two problem first. During the generalization process, we should preserve the structure as much as possible.
Reference: [9] <author> Stephen Muggleton, </author> <title> Inductive logic programming, </title> <journal> New generation computing, </journal> <volume> 8(4) </volume> <pages> 295-318, </pages> <year> 1991 </year>
Reference-contexts: In computer science, especially in the area of artificial intelligence, generalization serves as a foundation of inductive inference, and finds its applications in diverse areas such as inductive logic programming <ref> [9] </ref>, theorem proving [10], program derivation [4][5]. In the strict sense, generalization is a dual problem of first order unification and is often called (ordinary) anti-unification. <p> Due to the fact that it is inadequate in many problems, there are extensions of ordinary anti-unification from various aspects. One direction of extending the anti-unification problem is to take into consideration of some kinds of background information as in <ref> [9] </ref>. Another direction of extension is to promote the order of the underlying language. The problem with higher order generalization is that without some restrictions, the generalization is not well-defined. For fl Address: Robotics Institute, School of Computer Science, Carnegie Mellon University, Pittsburgh PA 15213, USA.
Reference: [10] <author> Frank Pfenning, </author> <title> Unification and anti-unification in the calculus of constructions, </title> <booktitle> Proceedings of the 6th symposium on logic in computer science, </booktitle> <year> 1991. </year> <month> pp.74-85. </month>
Reference-contexts: In computer science, especially in the area of artificial intelligence, generalization serves as a foundation of inductive inference, and finds its applications in diverse areas such as inductive logic programming [9], theorem proving <ref> [10] </ref>, program derivation [4][5]. In the strict sense, generalization is a dual problem of first order unification and is often called (ordinary) anti-unification. <p> Obviously, some restrictions must be imposed on higher order generalization. This paper is devoted to the study of higher order generalization. More specifically, we study the conditions under which the least higher order generalization exist and unique. The most closely related works are <ref> [10] </ref> [3]. [10] studied generalization in a restricted form of calculus of constructions [2], where terms are higher-order patterns, i.e., free variables can only apply to distinct bound variables. One problem of the generalization in higher-order patterns is the over generalization. <p> Obviously, some restrictions must be imposed on higher order generalization. This paper is devoted to the study of higher order generalization. More specifically, we study the conditions under which the least higher order generalization exist and unique. The most closely related works are <ref> [10] </ref> [3]. [10] studied generalization in a restricted form of calculus of constructions [2], where terms are higher-order patterns, i.e., free variables can only apply to distinct bound variables. One problem of the generalization in higher-order patterns is the over generalization. <p> When type information is not important, [x : oe]t is abbreviated as [x]t. Following <ref> [10] </ref>, we have a similar notion of renaming. Given natural numbers n and p, a partial permutation OE from n into p is an injective mapping from f1; 2; :::; ng into f1; 2; :::; pg. <p> Our work differs from the others in the following aspects. Firstly, we defined a new ordering SF . In terms of this ordering, we obtain a much more specific generalization in general. For example, the terms Aab and Bab would be generalized as a single variable x in <ref> [10] </ref>, or as f ts in [3], where t and s are arbitrary terms. In contrast, we will have [f ]f ab as its least general generalization. Secondly, our approach can produce a meaningful generalization of terms of different types and terms of different arities, instead a single variable x.
Reference: [11] <author> John C. Reynolds, </author> <title> Transformational systems and the algebraic structure of atomic formulas, </title> <booktitle> Machine Intelligence 5, </booktitle> <publisher> Edinburgh University Press 1970, </publisher> <pages> 135-151. 15 </pages>
Reference-contexts: More specifically, it can be formulated as: given two terms t and s, find a term r and substitutions 1 and 2 , such that r 1 = t and r 2 = s. Ordinary anti-unification was well understood as early as in 1970 <ref> [11] </ref>. Due to the fact that it is inadequate in many problems, there are extensions of ordinary anti-unification from various aspects. One direction of extending the anti-unification problem is to take into consideration of some kinds of background information as in [9].
References-found: 11

