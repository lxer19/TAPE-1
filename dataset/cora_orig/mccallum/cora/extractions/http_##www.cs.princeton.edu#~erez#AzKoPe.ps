URL: http://www.cs.princeton.edu/~erez/AzKoPe.ps
Refering-URL: http://www.cs.princeton.edu/~erez/publications.html
Root-URL: http://www.cs.princeton.edu
Title: A Note on the Implementation of Replication-Based Garbage Collection for Multithreaded Applications and Multiprocessor Environments  
Author: Alain Azagury Elliot K. Kolodner Erez Petrank 
Keyword: Parallel algorithms, Memory management, Garbage collection.  
Date: August 12, 1998  
Address: 31905, Israel.  
Affiliation: Department of System Technology IBM Haifa Research Lab MATAM, Haifa  
Abstract: Replication-based incremental garbage collection [5, 4] is one of the more appealing concurrent garbage collection algorithms known today. It allows continuous operation of the application (the mutator) with very short pauses for garbage collection. There is a growing need for such garbage collectors suitable for a multithreaded environments such as the Java Virtual Machine. Furthermore, it is desirable to construct collectors that also work on multiprocessor computers. We begin by pointing out an important, yet subtle point which arises when implementing the replication based garbage collector for a multithreaded environment. We first show that a simple and natural implementation of the algorithm may lead to an incorrect behavior of multithreaded applications. We then show that another simple and natural implementation eliminates the problem completely. Thus, the contribution of this part is in stressing this warning to future implementors. Next, we address the effects of the memory coherence model on this algorithm. We show that even when the algorithm is properly implemented with respect to our first observation, a problem might still arise when a multiprocessor system is used. Adopting a naive solution to this problem results in very frequent (and expensive) synchronization. We offer a slight modification to the algorithm which eliminates the problem and requires little synchronization.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. E. Jones and R. D. Lins. </author> <title> Garbage Collection: Algorithms for Automatic Dynamic Memory Management. </title> <publisher> John Wiley & Sons, </publisher> <month> July </month> <year> 1996. </year> <month> 7 </month>
Reference-contexts: In this short note, we do not elaborate on the motivation for garbage collection in general, nor on the need for non-disruptive collection. We also do not discuss the advantages of multithreaded applications. The reader is referred to <ref> [1] </ref> for a good overview on garbage collection algorithms and motivations. The reader may find motivation and experimental results for the specific replication garbage collection algorithm in the original papers [5, 4]. 1.1 A subtle implementation point for multithreaded application We begin with the case of multithreaded applications. <p> Each mutator updates the address and then inserts a mutation record into the 1 This is not the first algorithm that allows parallel copying collection. The reader is referred to <ref> [1] </ref> for a balanced report on the various existing concurrent copying garbage collection algorithms. 3 mutation log. But it may happen that the race on the updates is settled inconsistently with the race on the mutation log.
Reference: [2] <author> J. Gosling, B. Joy and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley. </publisher>
Reference-contexts: We expect this algorithm to prove useful for applications which require fast response, and even for real time applications. fl E-mail: azagury@haifa.vnet.ibm.com. y E-mail: kolodner@haifa.vnet.ibm.com. z E-mail: erezp@haifa.vnet.ibm.com. 1 Environments, which support multithreaded applications are becoming increasingly popular in particular, as part of the Java runtime <ref> [2] </ref>. Furthermore, systems with more than one processor are becoming more common in modern machines, especially in server systems, but also on the desktop.
Reference: [3] <author> S. Nettles. </author> <title> Private communications. </title>
Reference-contexts: The algorithm is discussed for the case of a single mutator thread, for which both possible implementations are fine. We remark that in their original implementation the authors did choose to implement the algorithm in the manner that is suitable for multi-mutator-threads operation <ref> [3] </ref>. 1.2 Care required in a multiprocessor system Next, we consider the behavior of the algorithm in modern multiprocessor environments, e.g., Power-PC, Sparc, Alpha, and Intel. In these environments there is a typical problem of memory coherence.
Reference: [4] <author> S. Nettles and J. O'Toole. </author> <title> Real-time replication-based garbage collection. </title> <booktitle> In Proceedings of SIGPLAN'93 Conference on Programming Languages Design and Implementation, volume 28(6) of ACM SIGPLAN Notices, </booktitle> <address> Albuquerque, New Mexico, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction Replication-based garbage collection <ref> [5, 4] </ref> is one of the more elegant solutions known today for non disruptive concurrent garbage collection with minimal synchronization between the collector and the application program (the mutator). <p> We also do not discuss the advantages of multithreaded applications. The reader is referred to [1] for a good overview on garbage collection algorithms and motivations. The reader may find motivation and experimental results for the specific replication garbage collection algorithm in the original papers <ref> [5, 4] </ref>. 1.1 A subtle implementation point for multithreaded application We begin with the case of multithreaded applications. Namely, there are several mutator threads (and one additional collector thread). <p> This other implementation is as simple and natural as the problematic implementation. We feel that since the problem is subtle, this issue deserves a clear and explicit discussion which should serve as a warning to future implementors. In the original papers <ref> [4, 5] </ref> there is no discussion of this issue. The algorithm is discussed for the case of a single mutator thread, for which both possible implementations are fine. <p> The naive solution, of synchronizing the views of the various processors whenever needed, requires very frequent synchronization is thus unacceptably expensive. Our solution requires only little synchronization. 1.3 Organization In Section 2 we briefly recall the algorithm of replication based garbage collection <ref> [5, 4] </ref>. In Section 3 we discuss the multithreaded environment. We first explain the implementation which is problematic in Subsection 3.1, next, in Subsection 3.2 we present an example of a program that may go astray due to garbage collection activity. <p> In section 4 we discuss the problematic effects of multiprocessor environments on the algorithm and suggest a modification of the algorithm which eliminates the problem. 2 2 Replication based garbage collection In this section, we shortly recall the replication based garbage collection algorithm of <ref> [5, 4] </ref>. In this short note we only briefly recall the replicating algorithm. We assume the reader is familiar with copying garbage collections in general. For details, the reader is referred to [5, 4]. In a simple copying garbage collection the heap is divided into two spaces: From-space and to-space. <p> 2 Replication based garbage collection In this section, we shortly recall the replication based garbage collection algorithm of <ref> [5, 4] </ref>. In this short note we only briefly recall the replicating algorithm. We assume the reader is familiar with copying garbage collections in general. For details, the reader is referred to [5, 4]. In a simple copying garbage collection the heap is divided into two spaces: From-space and to-space. During normal operation the application uses to-space. <p> Thus, this solves our coherence problem as well. 5 Acknowledgments We thank Scott Nettles for his helpful comments and for answering our questions on the details of the implementation in <ref> [4] </ref>.
Reference: [5] <author> S. Nettles, J. O'Toole, D. Pierce and N. Haines. </author> <title> Replication-Based Incremental Copying Collection. </title> <editor> In Bekkers and Cohen, editors. </editor> <booktitle> Proceedings of International Workshop on Memory Management, volume 637 of Lecture Notes in Computer Science, </booktitle> <address> St Malo, France, </address> <month> 16-18 September </month> <year> 1992. </year> <note> Springer-Verlag. 8 </note>
Reference-contexts: 1 Introduction Replication-based garbage collection <ref> [5, 4] </ref> is one of the more elegant solutions known today for non disruptive concurrent garbage collection with minimal synchronization between the collector and the application program (the mutator). <p> We also do not discuss the advantages of multithreaded applications. The reader is referred to [1] for a good overview on garbage collection algorithms and motivations. The reader may find motivation and experimental results for the specific replication garbage collection algorithm in the original papers <ref> [5, 4] </ref>. 1.1 A subtle implementation point for multithreaded application We begin with the case of multithreaded applications. Namely, there are several mutator threads (and one additional collector thread). <p> This other implementation is as simple and natural as the problematic implementation. We feel that since the problem is subtle, this issue deserves a clear and explicit discussion which should serve as a warning to future implementors. In the original papers <ref> [4, 5] </ref> there is no discussion of this issue. The algorithm is discussed for the case of a single mutator thread, for which both possible implementations are fine. <p> The naive solution, of synchronizing the views of the various processors whenever needed, requires very frequent synchronization is thus unacceptably expensive. Our solution requires only little synchronization. 1.3 Organization In Section 2 we briefly recall the algorithm of replication based garbage collection <ref> [5, 4] </ref>. In Section 3 we discuss the multithreaded environment. We first explain the implementation which is problematic in Subsection 3.1, next, in Subsection 3.2 we present an example of a program that may go astray due to garbage collection activity. <p> In section 4 we discuss the problematic effects of multiprocessor environments on the algorithm and suggest a modification of the algorithm which eliminates the problem. 2 2 Replication based garbage collection In this section, we shortly recall the replication based garbage collection algorithm of <ref> [5, 4] </ref>. In this short note we only briefly recall the replicating algorithm. We assume the reader is familiar with copying garbage collections in general. For details, the reader is referred to [5, 4]. In a simple copying garbage collection the heap is divided into two spaces: From-space and to-space. <p> 2 Replication based garbage collection In this section, we shortly recall the replication based garbage collection algorithm of <ref> [5, 4] </ref>. In this short note we only briefly recall the replicating algorithm. We assume the reader is familiar with copying garbage collections in general. For details, the reader is referred to [5, 4]. In a simple copying garbage collection the heap is divided into two spaces: From-space and to-space. During normal operation the application uses to-space.
References-found: 5

