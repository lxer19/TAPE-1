URL: http://theory.lcs.mit.edu/tds/papers/Borowsky/TM-573.ps
Refering-URL: http://theory.lcs.mit.edu/tds/papers/Borowsky/TM-573.html
Root-URL: 
Email: borowsky@hpl.hp.com  eli@cs.ucla.edu  lynch@theory.lcs.mit.edu  rajsbaum@servidor.unam.mx  
Title: The BG Distributed Simulation Algorithm of a fault-tolerant distributed simulation. The distributed simulation implements a
Author: Elizabeth Borowsky Eli Gafni Nancy Lynch Sergio Rajsbaum 
Note: More generally, the algorithm satisfies the requirements  is also presented.  
Date: December 8, 1997  
Address: Palo-Alto, CA 94303  Los Angeles CA 90024  Cambridge, MA 02139  D.F. 04510, Mexico  
Affiliation: Hewlett-Packard Laboratories  Computer Science Department University of California,  Laboratory for Computer Science Massachusetts Institute of Technology  Instituto de Matematicas, UNAM Ciudad Universitaria  
Abstract: One application of this simulation algorithm is to convert an arbitrary k-fault-tolerant n-process solution for the k-set-agreement problem into a wait-free k +1-process solution for the same problem. Since the k+1-process k-set-agreement problem has been shown to have no wait-free solution [4, 16, 24], this transformation implies that there is no k-fault-tolerant solution to the n-process k-set-agreement problem, for any n. fl Preliminary versions of this paper appeared in [4, 20]. y Supported by Air Force Contracts AFOSR F49620-92-J-0125 and F49620-97-1-0337, and NSF contract 9225124CCR and CCR-9520298, and DARPA contracts N00014-92-J-4033 and F19628-95-C-0118. z Part of this work was done at the Laboratory for Computer Science of MIT and at the Cambridge Research Laboratory of DEC. Supported by DGAPA and CONACYT Projects. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Afek, H. Attiya, D. Dolev, E. Gafni, M. Merritt and N. Shavit, </author> <title> Atomic snapshots of shared memory, </title> <journal> Journal of the ACM, </journal> <volume> Vol. 40, No. 4, </volume> <month> September </month> <year> 1993, </year> <pages> 873-890. </pages>
Reference-contexts: Likewise, a system using snapshot shared memory can be implemented in terms of single-writer multi-reader read/write shared variables, again with no change in externally-observable behavior; see, e.g., <ref> [1] </ref> for a construction. <p> Then there exists a snapshot shared memory system that solves D and guarantees f -failure termination. 7 Simulation in Read/Write Systems A system using snapshot shared memory can be implemented in a wait-free manner in terms of single-writer multi-reader read/write shared variables <ref> [1] </ref>. It follows that Theorem 6.10 extends to read/write systems. However, in this section we provide a direct construction, showing how to produce a read/write shared memory system P that f -simulates a read/write shared memory system P 0 .
Reference: [2] <author> Hagit Attiya, Amotz Bar-Noy, Danny Dolev, David Peleg, and Rudiger Reischuk, </author> <title> Renaming in an asynchronous environment, </title> <journal> Journal of the ACM, </journal> <volume> Vol. 37, No. 3, </volume> <month> July </month> <year> 1990, </year> <pages> 524-548. </pages>
Reference: [3] <author> O. Biran, S. Moran, S. Zaks, </author> <title> A combinatorial characterization of the distributed 1-solvable tasks, </title> <journal> Journal of Algorithms, </journal> <volume> vol. 11, </volume> <year> 1990, </year> <pages> 420-440. </pages>
Reference-contexts: This result, together with Theorem 8.1, implies the following: Corollary 8.4 Let 2 f &lt; n. The problem of telling if an n-port loop agreement decision problem has a solution with f -failure termination is not computable. Also, when f = 1, it was proved in <ref> [3] </ref> that the problem of telling if an arbitrary decision problem has solution with f -failure termination is computable. In particular, the problem is computable for any 2-port decision problem obtained from a convergence task. <p> It is possible to use only this particular result, and Theorem 8.1, to prove the following: Corollary 8.5 The problem of telling if an n-port decision problem corresponding to a convergence task T has a solution with 1-failure termination is computable. Notice that the results in <ref> [3] </ref> apply to general decision problems, while this corollary is about decision problems produced by convergence tasks. Also, we stress that Corollary 8.5 follows from the results of [3]. <p> Notice that the results in <ref> [3] </ref> apply to general decision problems, while this corollary is about decision problems produced by convergence tasks. Also, we stress that Corollary 8.5 follows from the results of [3].
Reference: [4] <author> E. Borowsky and E. Gafni, </author> <title> Generalized FLP impossibility result for t-resilient asynchronous computations, </title> <booktitle> in Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993, </year> <pages> 91-100. </pages>
Reference-contexts: k-set-agreement problem into a wait-free k + 1-process solution for the same problem. (A wait-free algorithm is one in which any non-failing process terminates, regardless of the failure of any number of the other processes.) Since the k + 1-process k-set-agreement problem has been shown to have no wait-free solution <ref> [4, 16, 24] </ref>, this transformation implies that there is no k-fault-tolerant solution to the n-process k-set-agreement problem, for any n. As another application, we show how the BG-simulation algorithm can be used to obtain results of [11, 15] about the computability of some decision problems. <p> The presentation has a great deal of interesting modularity, expressed by I/O automaton composition and both forward and backward simulation relations (see [22], for example, for definitions). Composition is used to include a safe agreement module, a simplification of one in <ref> [4] </ref>, as a subroutine. Forward and backward simulation relations are used to view the algorithm as implementing a multi-try snapshot strategy. <p> with a special argument showing that the result of a sequence of reads is the same as the result of a snapshot taken somewhere in the interval of the reads. 2 The original idea of the BG-simulation algorithm and its application to set agreement are due to Borowsky and Gafni <ref> [4] </ref>. The first precise description of the simulation, including a decomposition into modules, the notion of fault-tolerant reducibility between decision problems, and a proof of correctness appeared in Lynch and Rajsbaum [20]. The present paper combines the results of [4] and [20], and adds the abstract notion of fault-tolerant simulation, extensions <p> its application to set agreement are due to Borowsky and Gafni <ref> [4] </ref>. The first precise description of the simulation, including a decomposition into modules, the notion of fault-tolerant reducibility between decision problems, and a proof of correctness appeared in Lynch and Rajsbaum [20]. The present paper combines the results of [4] and [20], and adds the abstract notion of fault-tolerant simulation, extensions for read/write systems, and computability results. Borowsky and Gafni extended the BG-simulation algorithm to systems including set agreement variables [5]; Chaudhuri and Reiners later formalized this extension in [9, 23], following the techniques of [20]. <p> But this contradicts the results of <ref> [4, 10, 16, 24] </ref>. 3.4 Fault-Tolerant Simulation We present a specification, in the I/O automata formalism, of a fault-tolerant distributed simulation. In Theorem 3.3 we show how this specification corresponds to the reducibility of Section 3.3. <p> We now describe a simple design (using snapshot shared memory) for a safe agreement module. It is a slight simplification of the one in <ref> [4] </ref>. The snapshot shared memory contains a val component and a level component for each process i. When process i receives a propose (v) i , it records the value v in its val component and raises its level to 1. <p> In particular, wait-free 2-process consensus is unsolvable [12]. It is possible to use only this particular result, and Theorem 8.1 to prove the following: Corollary 8.2 The consensus problem is not solvable for f 1. Set Agreement. It is known from <ref> [4, 24, 16] </ref> that the (n; k)-set agreement problem is not wait-free solvable. This result together with Theorem 8.1 implies: Corollary 8.3 There is no algorithm that solves the (n; k)-set agreement problem with f -failure termination if f k. Computability.
Reference: [5] <author> E. Borowsky and E. Gafni, </author> <title> The implication of the Borowsky-Gafni simulation on the set consensus hierarchy, </title> <type> Technical Report 930021, </type> <institution> UCLA Computer Science Dept., </institution> <year> 1993. </year>
Reference-contexts: As another application, we show how the BG-simulation algorithm can be used to obtain results of [11, 15] about the computability of some decision problems. Other applications of the algorithm (or variants of it) have appeared in <ref> [5, 6] </ref>, and more recently, in [8, 19]. These examples suggest that the BG-simulation algorithm is a powerful tool for proving solvability and unsolv-ability results for fault-prone asynchronous systems. Thus, it is important to understand what exactly the algorithm guarantees. <p> The present paper combines the results of [4] and [20], and adds the abstract notion of fault-tolerant simulation, extensions for read/write systems, and computability results. Borowsky and Gafni extended the BG-simulation algorithm to systems including set agreement variables <ref> [5] </ref>; Chaudhuri and Reiners later formalized this extension in [9, 23], following the techniques of [20]. In the context of consensus, variants of the BG-simulation were used in [8, 19] to simulate systems with access to general shared objects. This paper is organized as follows. <p> We believe that an important contribution of this paper is providing the basis for the development of an interesting variety of extensions to the simulation algorithm. One extension is proposed in <ref> [5, 6] </ref>, and later formalized (following our techniques) in [9, 23], where the processes of Q simulate a system P 0 that has access to set agreement variables. Other variants of the simulation, for consensus problems in systems with access to general shared objects appear in [8] and in [19].
Reference: [6] <author> E. Borowsky, </author> <title> Capturing the power of resiliency and set consensus in distributed systems, </title> <type> Ph.D. Thesis, </type> <institution> University of California, </institution> <address> Los Angeles, </address> <month> October 15, </month> <year> 1995. </year>
Reference-contexts: As another application, we show how the BG-simulation algorithm can be used to obtain results of [11, 15] about the computability of some decision problems. Other applications of the algorithm (or variants of it) have appeared in <ref> [5, 6] </ref>, and more recently, in [8, 19]. These examples suggest that the BG-simulation algorithm is a powerful tool for proving solvability and unsolv-ability results for fault-prone asynchronous systems. Thus, it is important to understand what exactly the algorithm guarantees. <p> Thus, for each n, it yields an n-process k-set-agreement problem over a set S N1 of N values (see Example 1). 1 Thus the complexes we consider here are colorless, as opposed the colored complexes considered usually in the topology approach to distributed computing (e.g. <ref> [6, 16, 14] </ref>), where each element of a simplex has associated a process id. 29 3. <p> The applications extend results about a system with some number of processes and f failures, to a system with any number of processes and the same number of failures. Further applications are described in <ref> [6] </ref>. 31 Some possible variations on the simulation algorithm of this paper are: (a) Allow each process i of Q to simulate only a (statically determined) subset of the processes of P 0 rather than all the processes of P 0 . (b) Allow more complicated rules for determining the simulated <p> We believe that an important contribution of this paper is providing the basis for the development of an interesting variety of extensions to the simulation algorithm. One extension is proposed in <ref> [5, 6] </ref>, and later formalized (following our techniques) in [9, 23], where the processes of Q simulate a system P 0 that has access to set agreement variables. Other variants of the simulation, for consensus problems in systems with access to general shared objects appear in [8] and in [19]. <p> Stronger notions of reducibility (or fault-tolerant simulation) might include a closer, step-by-step correspondence between the execution of the simulating system P and the simulated system P 0 . Such a stronger notion seems to be needed to obtain results <ref> [6] </ref> relating the topological structure of the executions of P and P 0 . These results seem to indicate that the simulation plays an interesting role in the newly emerging topology approach to distributed computing (e.g. [6, 16, 14]). <p> Such a stronger notion seems to be needed to obtain results [6] relating the topological structure of the executions of P and P 0 . These results seem to indicate that the simulation plays an interesting role in the newly emerging topology approach to distributed computing (e.g. <ref> [6, 16, 14] </ref>).
Reference: [7] <author> S. Chaudhuri, </author> <title> More choices allow more faults: set consensus problems in totally asynchronous systems, </title> <journal> Information and Computation, </journal> <volume> Vol. 105, </volume> <year> 1993, </year> <pages> 132-158. 32 </pages>
Reference-contexts: As an example of an application of the BG-simulation algorithm, consider the n-process k-set agreement problem <ref> [7] </ref>, in which all n processes propose values and decide on at most k of the proposed values. <p> If this reducibility held, then the main theorem of this paper, Theorem 6.10, together with the fact that (n 0 ; k 0 )-set agreement is solvable when f &lt; k 0 <ref> [7] </ref>, would imply the existence of an f -fault-tolerant algorithm to solve (n; k)- set-agreement. But this contradicts the results of [4, 10, 16, 24]. 3.4 Fault-Tolerant Simulation We present a specification, in the I/O automata formalism, of a fault-tolerant distributed simulation.
Reference: [8] <author> T. Chandra, V. Hadzilacos, P. Jayanti, S. Toueg, </author> <title> Wait-freedom vs. t-resiliency and the robustness of wait-free hierarchies, </title> <booktitle> in Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1994, </year> <pages> 334-343. </pages>
Reference-contexts: As another application, we show how the BG-simulation algorithm can be used to obtain results of [11, 15] about the computability of some decision problems. Other applications of the algorithm (or variants of it) have appeared in [5, 6], and more recently, in <ref> [8, 19] </ref>. These examples suggest that the BG-simulation algorithm is a powerful tool for proving solvability and unsolv-ability results for fault-prone asynchronous systems. Thus, it is important to understand what exactly the algorithm guarantees. <p> Borowsky and Gafni extended the BG-simulation algorithm to systems including set agreement variables [5]; Chaudhuri and Reiners later formalized this extension in [9, 23], following the techniques of [20]. In the context of consensus, variants of the BG-simulation were used in <ref> [8, 19] </ref> to simulate systems with access to general shared objects. This paper is organized as follows. We start with the model in Section 2. <p> Other variants of the simulation, for consensus problems in systems with access to general shared objects appear in <ref> [8] </ref> and in [19]. Reducibilities between problems have proved to be useful elsewhere in computer science (e.g., in recursive function theory and complexity theory of sequential algorithms), for classifying problems according to their solvability and computational complexity.
Reference: [9] <author> S. Chaudhuri, P. Reiners, </author> <title> Understanding the set consensus partial order using the Borowsky-Gafni simulation, </title> <booktitle> 10th International Workshop on Distributed Algorithms, </booktitle> <month> Oct. </month> <pages> 9-11, </pages> <year> 1996. </year> <booktitle> Lecture Notes in Computer Science 1151, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> 362-379. </pages>
Reference-contexts: The present paper combines the results of [4] and [20], and adds the abstract notion of fault-tolerant simulation, extensions for read/write systems, and computability results. Borowsky and Gafni extended the BG-simulation algorithm to systems including set agreement variables [5]; Chaudhuri and Reiners later formalized this extension in <ref> [9, 23] </ref>, following the techniques of [20]. In the context of consensus, variants of the BG-simulation were used in [8, 19] to simulate systems with access to general shared objects. This paper is organized as follows. We start with the model in Section 2. <p> We believe that an important contribution of this paper is providing the basis for the development of an interesting variety of extensions to the simulation algorithm. One extension is proposed in [5, 6], and later formalized (following our techniques) in <ref> [9, 23] </ref>, where the processes of Q simulate a system P 0 that has access to set agreement variables. Other variants of the simulation, for consensus problems in systems with access to general shared objects appear in [8] and in [19].
Reference: [10] <author> M.J. Fischer, N.A. Lynch, </author> <title> M.S. Paterson, Impossibility of distributed consensus with one faulty process, </title> <journal> Journal of the ACM, </journal> <volume> Vol. 32, No. 2, </volume> <month> April </month> <year> 1985, </year> <pages> 374-382. </pages>
Reference-contexts: But this contradicts the results of <ref> [4, 10, 16, 24] </ref>. 3.4 Fault-Tolerant Simulation We present a specification, in the I/O automata formalism, of a fault-tolerant distributed simulation. In Theorem 3.3 we show how this specification corresponds to the reducibility of Section 3.3. <p> The N -consensus convergence task is [S N1 ; skel 0 (S N1 ); skel 0 ], where S N1 consists of a simplex of size N , N &gt; 1, and its subsimplexes. Thus, for each n, it yields a consensus decision problem <ref> [10] </ref> for n processes, where the processes start with N possible input values, which are the vertices of S N1 . If the processes start with values that form an input simplex S 2 S N1 , they have to decide values that form a simplex in skel 0 (S). <p> In this section we present several applications of this kind. All the applications we present hold for read/write memory systems and for snapshot memory systems, since one can use the read/write memory or the snapshot memory version of Theorem 8.1. Consensus. It is known <ref> [10, 18] </ref> that the consensus decision problem is not solvable with f -failure termination, when f 1. In particular, wait-free 2-process consensus is unsolvable [12].
Reference: [11] <author> E. Gafni and E. Koutsoupias, </author> <title> 3-processor tasks are undecidable, </title> <booktitle> brief announcement in Proceedings of the 14th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1995, </year> <note> p. 271. Full version submitted for publication. </note>
Reference-contexts: As another application, we show how the BG-simulation algorithm can be used to obtain results of <ref> [11, 15] </ref> about the computability of some decision problems. Other applications of the algorithm (or variants of it) have appeared in [5, 6], and more recently, in [8, 19]. These examples suggest that the BG-simulation algorithm is a powerful tool for proving solvability and unsolv-ability results for fault-prone asynchronous systems. <p> It is known from [4, 24, 16] that the (n; k)-set agreement problem is not wait-free solvable. This result together with Theorem 8.1 implies: Corollary 8.3 There is no algorithm that solves the (n; k)-set agreement problem with f -failure termination if f k. Computability. It is known <ref> [11] </ref> that the problem of telling if a decision problem for n processes, n 3, has a wait-free solution is not computable (i.e., is undecidable).
Reference: [12] <author> M.P. Herlihy, </author> <title> Wait-free synchronization, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 123-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Consensus. It is known [10, 18] that the consensus decision problem is not solvable with f -failure termination, when f 1. In particular, wait-free 2-process consensus is unsolvable <ref> [12] </ref>. It is possible to use only this particular result, and Theorem 8.1 to prove the following: Corollary 8.2 The consensus problem is not solvable for f 1. Set Agreement. It is known from [4, 24, 16] that the (n; k)-set agreement problem is not wait-free solvable.
Reference: [13] <author> M.P. Herlihy and S. Rajsbaum, </author> <title> Set consensus using arbitrary objects, </title> <booktitle> 13th ACM Symposium on Principles of Distributed Computing (PODC '94), </booktitle> <month> Aug. </month> <pages> 14-17, </pages> <address> Los Angeles, </address> <year> 1994, </year> <pages> pp. 324-333. </pages>
Reference: [14] <author> M.P. Herlihy and S. Rajsbaum, </author> <title> A Primer on Algebraic Topology and Distributed Computing, </title> <booktitle> in Computer Science Today, </booktitle> <editor> Jan van Leeuwen (Ed.), </editor> <volume> LNCS Vol. 1000, </volume> <publisher> Springer Verlag, </publisher> <year> 1995, </year> <pages> p. 203-217. </pages>
Reference-contexts: Thus, for each n, it yields an n-process k-set-agreement problem over a set S N1 of N values (see Example 1). 1 Thus the complexes we consider here are colorless, as opposed the colored complexes considered usually in the topology approach to distributed computing (e.g. <ref> [6, 16, 14] </ref>), where each element of a simplex has associated a process id. 29 3. <p> Such a stronger notion seems to be needed to obtain results [6] relating the topological structure of the executions of P and P 0 . These results seem to indicate that the simulation plays an interesting role in the newly emerging topology approach to distributed computing (e.g. <ref> [6, 16, 14] </ref>).
Reference: [15] <author> M.P. Herlihy and S. Rajsbaum, </author> <title> On the decidability of distributed decision tasks, </title> <booktitle> 29th ACM Symp. on the Theory of Computation (STOC), </booktitle> <month> May </month> <year> 1997, </year> <editor> p. </editor> <booktitle> 589-598. Brief Announcement in 15th ACM Symposium on Principles of Distributed Computing (PODC), </booktitle> <year> 1996, </year> <note> p. 279. </note>
Reference-contexts: As another application, we show how the BG-simulation algorithm can be used to obtain results of <ref> [11, 15] </ref> about the computability of some decision problems. Other applications of the algorithm (or variants of it) have appeared in [5, 6], and more recently, in [8, 19]. These examples suggest that the BG-simulation algorithm is a powerful tool for proving solvability and unsolv-ability results for fault-prone asynchronous systems. <p> Then there exists a read/write shared memory system that solves D and guarantees f -failure termination. 8 Applications In Section 8.1, we describe the notion of a convergence task <ref> [15] </ref>, which is used to specify a family of decision problems, one for each number of processes. For example, binary consensus is a convergence task it yields a decision problem for any number of processes. <p> But this is not what one would mean by a family. We now describe a way of defining a family of decision problems called convergence tasks <ref> [15] </ref>. We prove that it is a family in the sense, roughly, that one decision problem in the family is solvable if and only if any other is. <p> The loop agreement convergence task <ref> [15] </ref> is [S 2 ; K; fl], where S 2 is the 2-simplex (~s 0 ; ~s 1 ; ~s 2 ) and its sub--simplexes, K is an arbitrary finite complex with three distinguished vertices ~v 0 ; ~v 1 ; ~v 2 , fl (~s i ) = ~v i <p> Other examples of convergence tasks appear in <ref> [15] </ref>, like uncolored simplex agreement, barycentric agreement, and *-agreement. <p> Computability. It is known [11] that the problem of telling if a decision problem for n processes, n 3, has a wait-free solution is not computable (i.e., is undecidable). This was proved 2 in <ref> [15] </ref> by showing that the following 2 In fact, in [15], the result of Corollary 8.4 is proved directly, and in more general models of shared memory. 30 problem is not computable: Given a loop agreement convergence task, tell if the n-port corresponding decision problem has a wait-free solution. <p> Computability. It is known [11] that the problem of telling if a decision problem for n processes, n 3, has a wait-free solution is not computable (i.e., is undecidable). This was proved 2 in <ref> [15] </ref> by showing that the following 2 In fact, in [15], the result of Corollary 8.4 is proved directly, and in more general models of shared memory. 30 problem is not computable: Given a loop agreement convergence task, tell if the n-port corresponding decision problem has a wait-free solution. <p> We have presented several applications of the simulation algorithm to a class of problems that satisfy the reducibility, including consensus and set agreement, defined by convergence tasks <ref> [15] </ref>. The applications extend results about a system with some number of processes and f failures, to a system with any number of processes and the same number of failures.
Reference: [16] <author> M.P. Herlihy and N. Shavit, </author> <title> The asynchronous computability theorem for t-resilient tasks, </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993, </year> <pages> 111-120. </pages>
Reference-contexts: k-set-agreement problem into a wait-free k + 1-process solution for the same problem. (A wait-free algorithm is one in which any non-failing process terminates, regardless of the failure of any number of the other processes.) Since the k + 1-process k-set-agreement problem has been shown to have no wait-free solution <ref> [4, 16, 24] </ref>, this transformation implies that there is no k-fault-tolerant solution to the n-process k-set-agreement problem, for any n. As another application, we show how the BG-simulation algorithm can be used to obtain results of [11, 15] about the computability of some decision problems. <p> But this contradicts the results of <ref> [4, 10, 16, 24] </ref>. 3.4 Fault-Tolerant Simulation We present a specification, in the I/O automata formalism, of a fault-tolerant distributed simulation. In Theorem 3.3 we show how this specification corresponds to the reducibility of Section 3.3. <p> Thus, for each n, it yields an n-process k-set-agreement problem over a set S N1 of N values (see Example 1). 1 Thus the complexes we consider here are colorless, as opposed the colored complexes considered usually in the topology approach to distributed computing (e.g. <ref> [6, 16, 14] </ref>), where each element of a simplex has associated a process id. 29 3. <p> In particular, wait-free 2-process consensus is unsolvable [12]. It is possible to use only this particular result, and Theorem 8.1 to prove the following: Corollary 8.2 The consensus problem is not solvable for f 1. Set Agreement. It is known from <ref> [4, 24, 16] </ref> that the (n; k)-set agreement problem is not wait-free solvable. This result together with Theorem 8.1 implies: Corollary 8.3 There is no algorithm that solves the (n; k)-set agreement problem with f -failure termination if f k. Computability. <p> Such a stronger notion seems to be needed to obtain results [6] relating the topological structure of the executions of P and P 0 . These results seem to indicate that the simulation plays an interesting role in the newly emerging topology approach to distributed computing (e.g. <ref> [6, 16, 14] </ref>).
Reference: [17] <author> N.A. Lynch, </author> <title> Distributed Algorithms, </title> <publisher> Morgan Kaufmann Publishers, Inc. </publisher> <year> 1996. </year>
Reference-contexts: In Section 8 several applications of the BG-simulation algorithm are described. A final discussion appears in Section 9. 2 The Model The underlying model is the I/O automaton model of Lynch and Tuttle [21], as described, for example, in Chapter 8 of <ref> [17] </ref>. Briefly, an I/O automaton is a state machine whose transitions are labelled with actions. Actions are classified as input, output, or internal. The automaton need not be finite-state, and may have multiple start states. <p> The trace of an execution is the sequence of external actions occurring in that execution. Most of the systems in this paper are asynchronous shared memory systems, as defined, for example, in Chapter 9 of <ref> [17] </ref>. Briefly, an n-process asynchronous shared memory system consists of n processes interacting via instantaneously-accessible shared variables. We allow finitely many or infinitely many shared variables. (Allowing infinitely many shared variables is a slight generalization over what appears in [17], but it does not affect any of the properties we require.) <p> shared memory systems, as defined, for example, in Chapter 9 of <ref> [17] </ref>. Briefly, an n-process asynchronous shared memory system consists of n processes interacting via instantaneously-accessible shared variables. We allow finitely many or infinitely many shared variables. (Allowing infinitely many shared variables is a slight generalization over what appears in [17], but it does not affect any of the properties we require.) Formally, we model the system as a single I/O automaton, whose state consists of all the process local state information plus the values of the shared variables, and whose task structure respects the division into processes. <p> In Section 7 we also consider shared memory systems with single-writer multi-reader read/write shared variables (as defined, for example, in <ref> [17] </ref>). 3 Decision Problems, Reducibility and Simulation In Section 3.1 we define decision problems and in Section 3.2 we say what it means for a system to solve a decision problem. In Section 3.3 we define the fault-tolerant reducibility between decision problems.
Reference: [18] <author> M.C. Loui and H.H. Abu-Amara, </author> <title> Memory requirements for agreement among unreliable asynchronous processes, </title> <editor> in F. P. Preparata (ed.), </editor> <booktitle> Parallel and Distributed Computing, vol. 4 of Advances in Computing Research, </booktitle> <pages> 163-183. </pages> <publisher> JAI Press, </publisher> <address> Greenwich, Conn., </address> <year> 1987. </year>
Reference-contexts: In this section we present several applications of this kind. All the applications we present hold for read/write memory systems and for snapshot memory systems, since one can use the read/write memory or the snapshot memory version of Theorem 8.1. Consensus. It is known <ref> [10, 18] </ref> that the consensus decision problem is not solvable with f -failure termination, when f 1. In particular, wait-free 2-process consensus is unsolvable [12].
Reference: [19] <author> W. Lo and V. Hadzilacos, </author> <title> On the power of shared object types to implement one-resilient consensus, </title> <booktitle> in Proceedings of the 16th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 101-110, </pages> <month> August </month> <year> 1997. </year>
Reference-contexts: As another application, we show how the BG-simulation algorithm can be used to obtain results of [11, 15] about the computability of some decision problems. Other applications of the algorithm (or variants of it) have appeared in [5, 6], and more recently, in <ref> [8, 19] </ref>. These examples suggest that the BG-simulation algorithm is a powerful tool for proving solvability and unsolv-ability results for fault-prone asynchronous systems. Thus, it is important to understand what exactly the algorithm guarantees. <p> Borowsky and Gafni extended the BG-simulation algorithm to systems including set agreement variables [5]; Chaudhuri and Reiners later formalized this extension in [9, 23], following the techniques of [20]. In the context of consensus, variants of the BG-simulation were used in <ref> [8, 19] </ref> to simulate systems with access to general shared objects. This paper is organized as follows. We start with the model in Section 2. <p> Other variants of the simulation, for consensus problems in systems with access to general shared objects appear in [8] and in <ref> [19] </ref>. Reducibilities between problems have proved to be useful elsewhere in computer science (e.g., in recursive function theory and complexity theory of sequential algorithms), for classifying problems according to their solvability and computational complexity.
Reference: [20] <author> N.A. Lynch and S. Rajsbaum, </author> <title> On the Borowsky-Gafni Simulation Algorithm, </title> <booktitle> In Proceedings of the Fourth Israel Symposium on Theory of Computing and Systems, </booktitle> <month> June </month> <year> 1996, </year> <pages> 4-15. </pages>
Reference-contexts: The first precise description of the simulation, including a decomposition into modules, the notion of fault-tolerant reducibility between decision problems, and a proof of correctness appeared in Lynch and Rajsbaum <ref> [20] </ref>. The present paper combines the results of [4] and [20], and adds the abstract notion of fault-tolerant simulation, extensions for read/write systems, and computability results. <p> The first precise description of the simulation, including a decomposition into modules, the notion of fault-tolerant reducibility between decision problems, and a proof of correctness appeared in Lynch and Rajsbaum <ref> [20] </ref>. The present paper combines the results of [4] and [20], and adds the abstract notion of fault-tolerant simulation, extensions for read/write systems, and computability results. Borowsky and Gafni extended the BG-simulation algorithm to systems including set agreement variables [5]; Chaudhuri and Reiners later formalized this extension in [9, 23], following the techniques of [20]. <p> combines the results of [4] and <ref> [20] </ref>, and adds the abstract notion of fault-tolerant simulation, extensions for read/write systems, and computability results. Borowsky and Gafni extended the BG-simulation algorithm to systems including set agreement variables [5]; Chaudhuri and Reiners later formalized this extension in [9, 23], following the techniques of [20]. In the context of consensus, variants of the BG-simulation were used in [8, 19] to simulate systems with access to general shared objects. This paper is organized as follows. We start with the model in Section 2.
Reference: [21] <author> N.A. Lynch, </author> <title> M.R. Tuttle, An Introduction to input/output automata, </title> <journal> CWI-Quarterly, </journal> <volume> Vol. 2, No. 3, </volume> <month> Septem-ber </month> <year> 1989, </year> <pages> 219-246. </pages> <publisher> Centrum voor Wiskunde en Informatica, </publisher> <address> Amsterdam. </address> <note> Also TM-373, </note> <institution> MIT Laboratory for Computer Science, </institution> <month> November </month> <year> 1988. </year> <month> 33 </month>
Reference-contexts: The moral is that one must be careful in applying the simulation it does not work for all pairs of problems, but only those that satisfy the reducibility. We present and verify the BG-simulation algorithm in terms of I/O automata <ref> [21] </ref>. The presentation has a great deal of interesting modularity, expressed by I/O automaton composition and both forward and backward simulation relations (see [22], for example, for definitions). Composition is used to include a safe agreement module, a simplification of one in [4], as a subroutine. <p> In Section 8 several applications of the BG-simulation algorithm are described. A final discussion appears in Section 9. 2 The Model The underlying model is the I/O automaton model of Lynch and Tuttle <ref> [21] </ref>, as described, for example, in Chapter 8 of [17]. Briefly, an I/O automaton is a state machine whose transitions are labelled with actions. Actions are classified as input, output, or internal. The automaton need not be finite-state, and may have multiple start states.
Reference: [22] <author> Nancy Lynch and Frits Vaandrager. </author> <title> Forward and Backward Simulations Part I: </title> <journal> Untimed Systems, Infor--mation and Computation, </journal> <volume> Vol. 121, No. 2, </volume> <month> September </month> <year> 1995, </year> <pages> 214-233. </pages>
Reference-contexts: We present and verify the BG-simulation algorithm in terms of I/O automata [21]. The presentation has a great deal of interesting modularity, expressed by I/O automaton composition and both forward and backward simulation relations (see <ref> [22] </ref>, for example, for definitions). Composition is used to include a safe agreement module, a simplification of one in [4], as a subroutine. Forward and backward simulation relations are used to view the algorithm as implementing a multi-try snapshot strategy. <p> Forward and backward simulation relations are notions used to show that one I/O automaton implements another <ref> [22] </ref>, or in our case, that one I/O automaton solves another; they have nothing to do with simulations in the sense of the BG simulation algorithm. The first level of abstraction is the specification itself; that is, the SimpleSpec automaton. <p> Therefore, u 0 :sim-state (j) 2 fs:sim-state (j)g [ ftrans-snap (s:sim-state; w) : w 2 s:snap-set (j)g, as needed. This lemma implies that every trace of DelayedSpec fi U is a trace of SimpleSpec fi U <ref> [22] </ref>, that is (recall the definition of solves in Section 3.4.3): Corollary 6.2 DelayedSpec solves SimpleSpec. 18 6.2 The System Q with Safe Agreement Modules Our third and final level is the system Q, composed with arbitrary safe agreement modules, and with the propose and agree actions reclassified as internal. <p> At the point where the appropriate safe agreement module chooses the winning actual snapshot, the simulated snapshot succeeds. As in the DelayedSpec, this choice is made after the snapshot attempts. Formally, we use a weak forward simulation <ref> [22] </ref>. The word weak simply indicates that the proof uses invariants. We need the invariants for the definition as well as for the proof of the forward simulation: strictly speaking, the definition of the forward simulation we use is ambiguous without them.
Reference: [23] <author> P. Reiners, </author> <title> Understanding the Set Consensus Partial Order using the Borowsky-Gafni Simulation, M.S. </title> <type> Thesis, </type> <institution> Iowa State University, </institution> <year> 1996. </year>
Reference-contexts: The present paper combines the results of [4] and [20], and adds the abstract notion of fault-tolerant simulation, extensions for read/write systems, and computability results. Borowsky and Gafni extended the BG-simulation algorithm to systems including set agreement variables [5]; Chaudhuri and Reiners later formalized this extension in <ref> [9, 23] </ref>, following the techniques of [20]. In the context of consensus, variants of the BG-simulation were used in [8, 19] to simulate systems with access to general shared objects. This paper is organized as follows. We start with the model in Section 2. <p> We believe that an important contribution of this paper is providing the basis for the development of an interesting variety of extensions to the simulation algorithm. One extension is proposed in [5, 6], and later formalized (following our techniques) in <ref> [9, 23] </ref>, where the processes of Q simulate a system P 0 that has access to set agreement variables. Other variants of the simulation, for consensus problems in systems with access to general shared objects appear in [8] and in [19].
Reference: [24] <author> M. Saks and F. Zaharoglou, </author> <title> Wait-free k-set agreement is impossible: The topology of public knowledge, </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993, </year> <pages> 101-110. 34 </pages>
Reference-contexts: k-set-agreement problem into a wait-free k + 1-process solution for the same problem. (A wait-free algorithm is one in which any non-failing process terminates, regardless of the failure of any number of the other processes.) Since the k + 1-process k-set-agreement problem has been shown to have no wait-free solution <ref> [4, 16, 24] </ref>, this transformation implies that there is no k-fault-tolerant solution to the n-process k-set-agreement problem, for any n. As another application, we show how the BG-simulation algorithm can be used to obtain results of [11, 15] about the computability of some decision problems. <p> But this contradicts the results of <ref> [4, 10, 16, 24] </ref>. 3.4 Fault-Tolerant Simulation We present a specification, in the I/O automata formalism, of a fault-tolerant distributed simulation. In Theorem 3.3 we show how this specification corresponds to the reducibility of Section 3.3. <p> In particular, wait-free 2-process consensus is unsolvable [12]. It is possible to use only this particular result, and Theorem 8.1 to prove the following: Corollary 8.2 The consensus problem is not solvable for f 1. Set Agreement. It is known from <ref> [4, 24, 16] </ref> that the (n; k)-set agreement problem is not wait-free solvable. This result together with Theorem 8.1 implies: Corollary 8.3 There is no algorithm that solves the (n; k)-set agreement problem with f -failure termination if f k. Computability.
References-found: 24

