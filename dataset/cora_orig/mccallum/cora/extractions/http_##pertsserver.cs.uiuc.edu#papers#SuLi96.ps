URL: http://pertsserver.cs.uiuc.edu/papers/SuLi96.ps
Refering-URL: http://pertsserver.cs.uiuc.edu/papers/
Root-URL: http://www.cs.uiuc.edu
Email: fjsun, janeliug@cs.uiuc.edu  
Title: Synchronization Protocols in Distributed Real-Time Systems  
Author: Jun Sun Jane Liu 
Address: Urbana, IL 61801  
Affiliation: Department of Computer Science, University of Illinois, Urbana-Champaign  
Date: May, 1996.  
Note: Appeared in the Proceedings of 16th International Conference on Distributed Computing Systems,  
Abstract: In many distributed real-time systems, the workload can be modeled as a set of periodic tasks, each of which consists of a chain of subtasks executing on different processors. Synchronization protocols are used to govern the release of subtasks so that the precedence constraints among subtasks are satisfied and the schedulability of the resultant system is analyzable. Tasks have different worst-case and average end-to-end response times when different protocols are used. In this paper, we consider distributed real-time systems with independent, periodic tasks and fixed-priority scheduling algorithms. We propose three synchronization protocols and conduct simulation to compare their performance with respect to the two timing aspects. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard-real-time environment. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: 1. Introduction In many real-time systems, the workload can be modeled as a set of periodic tasks <ref> [1] </ref>. Each periodic task is an infinite stream of computation requests that are released at a fixed rate. We call each request an instance of the task. When the context is clear, we may simply say a task to mean an instance of that task. <p> It is well known that fixed priority scheduling is an effective means to schedule periodic tasks on a single processor and to ensure that the time constraints of the tasks are satisfied <ref> [1, 2, 3, 4] </ref>. In this approach, each task is assigned a fixed priority. At any time, the scheduler simply chooses to execute the task with the highest priority among all the tasks whose instances are released but not yet completed. <p> At any time, the scheduler simply chooses to execute the task with the highest priority among all the tasks whose instances are released but not yet completed. A great deal of work has been done on how to assign the priorities <ref> [1, 5, 6] </ref> and how to bound the response times of tasks [1, 7, 2] for single processor systems. In a distributed real-time system, each instance of a task may need to execute on different processors in a sequential order. <p> A great deal of work has been done on how to assign the priorities [1, 5, 6] and how to bound the response times of tasks <ref> [1, 7, 2] </ref> for single processor systems. In a distributed real-time system, each instance of a task may need to execute on different processors in a sequential order. An example is a monitor task that collects remote sensor data and displays the data on the local screen.
Reference: [2] <author> J. Lehoczky. </author> <title> Fixed priority scheduling of periodic task sets with arbitrary deadlines. </title> <booktitle> In 11th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 201-209, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: It is well known that fixed priority scheduling is an effective means to schedule periodic tasks on a single processor and to ensure that the time constraints of the tasks are satisfied <ref> [1, 2, 3, 4] </ref>. In this approach, each task is assigned a fixed priority. At any time, the scheduler simply chooses to execute the task with the highest priority among all the tasks whose instances are released but not yet completed. <p> A great deal of work has been done on how to assign the priorities [1, 5, 6] and how to bound the response times of tasks <ref> [1, 7, 2] </ref> for single processor systems. In a distributed real-time system, each instance of a task may need to execute on different processors in a sequential order. An example is a monitor task that collects remote sensor data and displays the data on the local screen. <p> All instances of the three subtasks are released periodically according to the period p 1 and their own phases. When the PM Protocol Is Used Since all subtasks on each processor are strictly periodic, the Busy Period Analysis method proposed by Lehoczky <ref> [2] </ref> can be applied to obtain a bound on the response time of each subtask. The estimated worst-case EER time of a task is simply the sum of the bounds on the response times of all its subtasks. <p> As we shall see later, such an early release does no harm to the worst-case response times of other subtasks, but helps reduce the average EER times of tasks. One nice attribute of the RG protocol is that we can apply the busy period analysis method for periodic tasks <ref> [2] </ref> to obtain upper bounds on the response times of subtasks, as we do for the PM and MPM protocols. <p> Configurations for the DS Protocol Again, when tasks are synchronized according to the PM protocol, we can compute the estimated worst-case response times of the tasks using a straight forward extension of the Busy Period Analysis method <ref> [2] </ref>. We have developed an iterative algorithm to bound the EER times of tasks synchronized according to the DS protocol. Due to space limitations, the algorithm is not described here; it can be found in [13].
Reference: [3] <author> N. Audsley, A. Burns, K. Tindell, M. Richardson, and A. Wellings. </author> <title> Applying new scheduling theory to static priority pre-emptive scheduling. </title> <journal> Software Engineering Journal, </journal> <volume> 8(5) </volume> <pages> 284-292, </pages> <year> 1993. </year>
Reference-contexts: It is well known that fixed priority scheduling is an effective means to schedule periodic tasks on a single processor and to ensure that the time constraints of the tasks are satisfied <ref> [1, 2, 3, 4] </ref>. In this approach, each task is assigned a fixed priority. At any time, the scheduler simply chooses to execute the task with the highest priority among all the tasks whose instances are released but not yet completed.
Reference: [4] <author> K. W. Tindell. </author> <title> Fixed Priority Scheduling of Hard Real-Time Systems. </title> <type> PhD thesis, </type> <institution> University of York, Department of Computer Science, </institution> <year> 1994. </year>
Reference-contexts: It is well known that fixed priority scheduling is an effective means to schedule periodic tasks on a single processor and to ensure that the time constraints of the tasks are satisfied <ref> [1, 2, 3, 4] </ref>. In this approach, each task is assigned a fixed priority. At any time, the scheduler simply chooses to execute the task with the highest priority among all the tasks whose instances are released but not yet completed.
Reference: [5] <author> J. Leung and J. Whitehead. </author> <title> On the complexity of fixed-priority scheduling of periodic, real-time tasks. Performance Evaluation, </title> <booktitle> 2 </booktitle> <pages> 237-250, </pages> <year> 1982. </year>
Reference-contexts: At any time, the scheduler simply chooses to execute the task with the highest priority among all the tasks whose instances are released but not yet completed. A great deal of work has been done on how to assign the priorities <ref> [1, 5, 6] </ref> and how to bound the response times of tasks [1, 7, 2] for single processor systems. In a distributed real-time system, each instance of a task may need to execute on different processors in a sequential order.
Reference: [6] <author> N. C. Audsley. </author> <title> Optimal priority assignment and feasibility of static priority tasks with arbitrary start times. </title> <type> Technical Report YCS 164, </type> <institution> Dept. of Computer Science, University of York, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: At any time, the scheduler simply chooses to execute the task with the highest priority among all the tasks whose instances are released but not yet completed. A great deal of work has been done on how to assign the priorities <ref> [1, 5, 6] </ref> and how to bound the response times of tasks [1, 7, 2] for single processor systems. In a distributed real-time system, each instance of a task may need to execute on different processors in a sequential order.
Reference: [7] <author> M. Joseph and P. Pandya. </author> <title> Finding response times in a real-time system. </title> <journal> The Computer Journal of the British Computer Society, </journal> <volume> 29(5) </volume> <pages> 390-395, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: A great deal of work has been done on how to assign the priorities [1, 5, 6] and how to bound the response times of tasks <ref> [1, 7, 2] </ref> for single processor systems. In a distributed real-time system, each instance of a task may need to execute on different processors in a sequential order. An example is a monitor task that collects remote sensor data and displays the data on the local screen.
Reference: [8] <author> K. Tindell, A. Burns, and A. Wellings. </author> <title> Allocating real-time tasks. An NP-hard problem made easy. </title> <journal> Real-Time Systems Journal, </journal> <volume> 4(2), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: In such a system, each subtask has a fixed priority, which may or may not be the same as the priorities of its sibling subtasks. Previous studies on the priority assignment problem in distributed real-time systems can be found in <ref> [8, 9, 10] </ref>. In this paper, we are not con 1 In many cases, the communication links can be modeled as processors, and consequently message transmissions can be modeled as communication tasks on the link processors.
Reference: [9] <author> B. Kao and H. Garcia-Molina. </author> <title> Deadline assignment in a distributed soft real-time system. </title> <booktitle> In The 13th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 428-437, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: In such a system, each subtask has a fixed priority, which may or may not be the same as the priorities of its sibling subtasks. Previous studies on the priority assignment problem in distributed real-time systems can be found in <ref> [8, 9, 10] </ref>. In this paper, we are not con 1 In many cases, the communication links can be modeled as processors, and consequently message transmissions can be modeled as communication tasks on the link processors. <p> The execution time of the subtask is equal to its utilization times its period. The last parameter of each system is priority assignment of subtasks. We choose the Proportional-Deadline-Monotonic priority assignment method to assign priorities to subtasks. (A similar method is called the Equal Flexibility assignment in <ref> [9] </ref>.) According to this method, each subtask has a proportional deadline (P D i;j ) defined as follows. P D i;j = P n i D i where D i is the relative deadline of T i , which is equal to its period for this simulation.
Reference: [10] <author> J. Garcia and M. Harbour. </author> <title> Optimized priority assignment for tasks and messages in distributed hard real-time systems. </title> <booktitle> In The Third Workshop on Parallel and Distributed Real-Time Systems, </booktitle> <pages> pages 124-132, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: In such a system, each subtask has a fixed priority, which may or may not be the same as the priorities of its sibling subtasks. Previous studies on the priority assignment problem in distributed real-time systems can be found in <ref> [8, 9, 10] </ref>. In this paper, we are not con 1 In many cases, the communication links can be modeled as processors, and consequently message transmissions can be modeled as communication tasks on the link processors.
Reference: [11] <author> R. Bettati. </author> <title> End-to-End Scheduling to Meet Deadlines in Distributed Systems. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1994. </year>
Reference-contexts: In this paper, we describe three synchronization protocols. The first protocol is a straightforward implementation to enforce the precedence constraints among subtasks. The second protocol is an extension to the one proposed by Bettati, which was designed for flow-shop systems with certain limitations <ref> [11] </ref>. We propose the third protocol that combines the strength of the previous two protocols while avoiding their shortcomings. <p> The Phase Modification (PM) Protocol The Phase Modification protocol, abbreviated as the PM protocol, was initially proposed by Bettati and used to schedule periodic flow-shop tasks <ref> [11] </ref>. Unlike the DS protocol, the PM protocol insists that instances of all subtasks are released periodically according to the periods of their parent tasks. To ensure the precedence constraints among subtask are satisfied, each subtask is given its own phase. The phases of subtasks are properly adjusted as follows.
Reference: [12] <author> B. </author> <title> Hunting. The solution's in the CAN Part 1. </title> <booktitle> Circuit Cellar, </booktitle> <pages> pages 14-20, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: For the sake of discussion, we define the period of a subtask to be equal to the period of its parent task, even if it is not released periodically. In this paper, we do not explicitly model inter-processor communication. In some cases, such as in CAN <ref> [12] </ref>, where chronization Protocol Problem message transmissions are prioritized, communication links can be modeled as processors, and message transmissions can be modeled as communication subtasks on link processors.
Reference: [13] <author> J. Sun and J. Liu. </author> <title> Bounding the end-to-end response times of tasks in a distributed real-time system using the direct synchronization protocol. </title> <type> Technical Report UIUCDCS-R-96-1949, </type> <institution> University of Illinois at Urbana-Champaign, Dept. of Computer Science, </institution> <month> March </month> <year> 1996. </year>
Reference-contexts: However, the performance of this protocol is poor when measured in terms of the estimated worst-case EER times. Upper bounds of the EER times of tasks can be computed by an iterative algorithm described in <ref> [13] </ref>, which is the only known algorithm that provides reasonably tight bounds on the EER times of tasks. As we will see later, when the subtask chains are long and the processor utilizations are high, the algorithm may fail to obtain finite bounds. <p> We have developed an iterative algorithm to bound the EER times of tasks synchronized according to the DS protocol. Due to space limitations, the algorithm is not described here; it can be found in <ref> [13] </ref>. In general, the estimated worst-case EER times of tasks are larger when tasks are synchronized according to the DS protocol than when tasks are synchronized according to the PM protocol.
Reference: [14] <author> S. Chatterjee and J. Strosnider. </author> <title> Distributed pipeline scheduling: End-to-end analysis of heterogeneous, </title> <booktitle> multi-resource real-time systems. In The 15th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 204-211, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: The PM or MPM protocol should be favored when small output jitters are desirable. In previous studies on scheduling distributed real-time applications, such as in <ref> [14] </ref>, subtasks are typically assigned local deadlines and scheduled locally. Loose synchronization among subtasks is assumed. In this paper, we have attempted to provide insight to the synchronization problem in distributed real-time systems and an initial answer towards an unified end-to-end scheduling framework. Much work remains to be done.
References-found: 14

