URL: http://www.cis.ufl.edu/~nabeel/ruleTermination.ps
Refering-URL: http://www.cis.ufl.edu/~nabeel/current.html
Root-URL: http://www.cis.ufl.edu
Email: nabeel@cis.ufl.edu hanson@cis.ufl.edu  
Title: A Solution to the Parallel Trigger Termination Problem  
Author: Nabeel Al-Fayoumi, Eric N. Hanson 
Note: contact author: Hanson  
Web: http://www.cis.ufl.edu/~hanson/  
Address: 301 CSE, P.O. Box 116120  Gainesville, FL 32611-6120  
Affiliation: Rm.  CISE Department University of Florida  
Abstract: In the design of a parallel active database system for a shared-nothing hardware platform, a problem that arises is how to quickly determine when triggers have terminated. This problem is important because triggers normally run as part of the update transaction that triggered them. This update transaction cannot commit until its triggers have finished executing. Hence, for fast update response time, trigger termination must be detected as soon as possible. In addition, in a parallel active database system for a shared-nothing system, it is important to allow trigger actions to execute concurrently on multiple processors to get intra-transaction parallelism. The parallel trigger termination problem is to determine correctly and as quickly as possible when all trigger activations running on behalf of an update transaction have terminated. This paper presents a solution to this problem based on use of a state transition graph for each concurrently executing rule agenda, and proves the solution correct. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anurag Acharya. </author> <title> PPL: an explicitly parallel production language for large scale parallelism. </title> <booktitle> In Proceedings of the IJCAI Workshop on Production Systems and Their Innovative Applications, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: Within a trigger sequence group, rules are run serially. This allows the rule programmer to serialize rules when needed for correctness, and also exploit parallelism when possible. The notion of a trigger sequence group is comparable to the production set concept proposed for the PPL parallel production language <ref> [1, 2] </ref>. <p> When no rules are left on the agenda, rules have terminated. Parallel versions of OPS5 [8], as well as related parallel rule languages like that of the PARULEL system [14] and PPL <ref> [1, 2] </ref> normally are not concerned with testing for termination of rules. These parallel rule systems can execute rules in parallel, and PPL does allow multiple concurrent rule agendas. However, normally a human is in the loop when these systems are executing.
Reference: [2] <author> Anurag Acharya. </author> <title> Scalability in production system programs. </title> <type> Technical Report CMU-CS-94-211, </type> <institution> Carnegie Mellon University, </institution> <month> November </month> <year> 1994. </year> <type> PhD thesis. </type>
Reference-contexts: Within a trigger sequence group, rules are run serially. This allows the rule programmer to serialize rules when needed for correctness, and also exploit parallelism when possible. The notion of a trigger sequence group is comparable to the production set concept proposed for the PPL parallel production language <ref> [1, 2] </ref>. <p> When no rules are left on the agenda, rules have terminated. Parallel versions of OPS5 [8], as well as related parallel rule languages like that of the PARULEL system [14] and PPL <ref> [1, 2] </ref> normally are not concerned with testing for termination of rules. These parallel rule systems can execute rules in parallel, and PPL does allow multiple concurrent rule agendas. However, normally a human is in the loop when these systems are executing.
Reference: [3] <author> David A. Brant and Daniel P. Miranker. </author> <title> Index support for rule activation. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 42-48, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Single-processor trigger systems such as the Starburst rule system, Ariel, HiPAC, the POSTGRES rule system, Ode, Chimera, DATEX etc. <ref> [10, 18, 15, 7, 17, 3] </ref> normally either execute rules as procedure or method calls at the lowest level of update command execution (e.g., as in POSTGRES and Ode) or sequentially at the end of the triggering transaction 6 (e.g., as in Ariel).
Reference: [4] <author> L. Brownston, R. Farrell, E. Kant, and N. Martin. </author> <title> Programming Expert Systems in OPS5: an Introduction to Rule-Based Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1985. </year>
Reference-contexts: Hence, determining when rules are finished with execution is trivial. In the case of AI production rule systems such as OPS5 <ref> [4] </ref>, single-processor implementations have a single agenda. When no rules are left on the agenda, rules have terminated.
Reference: [5] <author> David J. DeWitt, Shahram Ghandeharizadeh, Donovan A. Schneider, Allan Bricker, Hui-I Hsiao, and Rick Rasmussen. </author> <title> The Gamma database machine project. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 44-62, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: We are currently adding a parallel trigger system to the Paradise DBMS [6] in a project called Phalanx. Paradise is a parallel object-relational DBMS based on a shared-nothing hardware model. The parallel processing features of Paradise are comparable to those of the Gamma system <ref> [5] </ref>. Tables in Paradise are partitioned horizontally across the processors. The Phalanx parallel trigger system supports a kind of event-condition-action (ECA) rules [12]. <p> This is necessary to comprehend the different elements that play a roll in the parallel trigger termination problem. The shared-nothing multiprocessor system we assume is similar to that used in the Gamma project <ref> [5] </ref>, where each processor in the system has its own disk storage unit, main memory, and disk controllers. An interconnection network provides a communication media between all the processors.
Reference: [6] <author> David J. DeWitt, Navin Kabra, Jun Luo, Jignesh M. Patel, and Jie-Bing Yu. </author> <title> Client-server Paradise. </title> <booktitle> In Proceedings of the 20th VLDB Conference, </booktitle> <year> 1994. </year>
Reference-contexts: 1 Introduction In order to get very high performance in an active database system it is possible to both test trigger conditions and run trigger actions in parallel. We are currently adding a parallel trigger system to the Paradise DBMS <ref> [6] </ref> in a project called Phalanx. Paradise is a parallel object-relational DBMS based on a shared-nothing hardware model. The parallel processing features of Paradise are comparable to those of the Gamma system [5]. Tables in Paradise are partitioned horizontally across the processors.
Reference: [7] <author> N. Gehani and H.V. Jagadish. </author> <title> Ode as an active database: Constraints and triggers. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Data Bases, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: Single-processor trigger systems such as the Starburst rule system, Ariel, HiPAC, the POSTGRES rule system, Ode, Chimera, DATEX etc. <ref> [10, 18, 15, 7, 17, 3] </ref> normally either execute rules as procedure or method calls at the lowest level of update command execution (e.g., as in POSTGRES and Ode) or sequentially at the end of the triggering transaction 6 (e.g., as in Ariel).
Reference: [8] <author> Anoop Gupta. </author> <title> Implementing OPS5 production systems on DADO. </title> <booktitle> In IEEE International Conference on Parallel Processing, </booktitle> <pages> pages 83-91, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Hence, determining when rules are finished with execution is trivial. In the case of AI production rule systems such as OPS5 [4], single-processor implementations have a single agenda. When no rules are left on the agenda, rules have terminated. Parallel versions of OPS5 <ref> [8] </ref>, as well as related parallel rule languages like that of the PARULEL system [14] and PPL [1, 2] normally are not concerned with testing for termination of rules. These parallel rule systems can execute rules in parallel, and PPL does allow multiple concurrent rule agendas.
Reference: [9] <author> Anoop Gupta, Charles Forgy, D. Kalp, A. Newell, and M. Tambe. </author> <title> Results of parallel implementation of OPS5 on the Encore multiprocessor. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <year> 1987. </year>
Reference-contexts: It is not crucial to detect rule termination at the earliest possible moment. This is in contrast with the parallel trigger termination problem addressed in this paper, where detecting termination quickly is important to allow fast transaction response time. In parallel production rule systems running on shared-memory multiprocessors (e.g., <ref> [9] </ref>) termination can be detected when all threads executing to perform production rule condition testing and action execution have halted. 2.2 Parallel trigger termination issues The above discussion illustrates that testing for trigger or production rule termination is fairly straightforward in single-processor trigger systems and parallel shared-memory trigger systems, and that
Reference: [10] <author> Eric N. Hanson. </author> <title> Rule condition testing and action execution in Ariel. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 49-58, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Single-processor trigger systems such as the Starburst rule system, Ariel, HiPAC, the POSTGRES rule system, Ode, Chimera, DATEX etc. <ref> [10, 18, 15, 7, 17, 3] </ref> normally either execute rules as procedure or method calls at the lowest level of update command execution (e.g., as in POSTGRES and Ode) or sequentially at the end of the triggering transaction 6 (e.g., as in Ariel).
Reference: [11] <author> Eric N. Hanson, I-Cheng Chen, Roxana Dastur, Kurt Engel, Vijay Ramaswamy, and Chun Xu. </author> <title> Flexible and recoverable interaction between applications and active databases. </title> <type> Technical Report 94-033, </type> <institution> University of Florida CIS Department, </institution> <month> September </month> <year> 1994. </year> <note> http://www.cis.ufl.edu/cis/tech-reports/. 18 </note>
Reference-contexts: In the remainder of the paper, we use the terms "rule" and "trigger" interchangeably. In the Phalanx rule language, a rule action can contain a list of arbitrary database commands, including updates, and a special "raise event" command for sending notifications to application programs <ref> [11] </ref>. Since trigger actions can issue arbitrary update commands, the action of a trigger can cause other triggers to fire on any processor. In addition, in a parallel active database system for shared-nothing hardware, it is important to allow trigger actions to execute concurrently to get intra-transaction parallelism.
Reference: [12] <author> Dennis R. McCarthy and Umeshwar Dayal. </author> <title> The architecture of an active data base management system. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 215-224, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Paradise is a parallel object-relational DBMS based on a shared-nothing hardware model. The parallel processing features of Paradise are comparable to those of the Gamma system [5]. Tables in Paradise are partitioned horizontally across the processors. The Phalanx parallel trigger system supports a kind of event-condition-action (ECA) rules <ref> [12] </ref>. The general form of a trigger in Phalanx is as follows: create trigger &lt;triggerName&gt; [propertyList] from &lt;fromList&gt; [on &lt;event-specification&gt;] [when &lt;qualification&gt;] for each [row | statement] begin command-list end The propertyList can be a list of zero or more clauses describing properties of the trigger.
Reference: [13] <institution> Running Oracle in a parallel environment, </institution> <year> 1995. </year> <note> http://www.oracle.com/ products/oracle7/server/whitepapers/parallel/html/pararchit.html. </note>
Reference-contexts: These include that parallel Sybase [16] and Oracle <ref> [13] </ref> servers. The the internal architecture of the trigger subsystems in these products has not been published. We conjecture that they run triggers in a synchronous fashion at one or more points within update transactions.
Reference: [14] <author> S. J. Stolfo, O. Wolfson, P. K. Chan, H. M. Dewan, , L. Woodbury, J. S. Glazier, and D. A. Ohsie. PARULEL: </author> <title> parallel rule processing using meta-rules for redaction. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 13(4), </volume> <month> December </month> <year> 1991. </year>
Reference-contexts: In the case of AI production rule systems such as OPS5 [4], single-processor implementations have a single agenda. When no rules are left on the agenda, rules have terminated. Parallel versions of OPS5 [8], as well as related parallel rule languages like that of the PARULEL system <ref> [14] </ref> and PPL [1, 2] normally are not concerned with testing for termination of rules. These parallel rule systems can execute rules in parallel, and PPL does allow multiple concurrent rule agendas. However, normally a human is in the loop when these systems are executing.
Reference: [15] <author> Michael Stonebraker, Lawrence Rowe, and Michael Hirohama. </author> <title> The implementation of POSTGRES. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(7) </volume> <pages> 125-142, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Single-processor trigger systems such as the Starburst rule system, Ariel, HiPAC, the POSTGRES rule system, Ode, Chimera, DATEX etc. <ref> [10, 18, 15, 7, 17, 3] </ref> normally either execute rules as procedure or method calls at the lowest level of update command execution (e.g., as in POSTGRES and Ode) or sequentially at the end of the triggering transaction 6 (e.g., as in Ariel).
Reference: [16] <institution> Sybase SQL server 11 white paper, </institution> <year> 1995. </year> <note> http://www.sybase.com/Offerings/ Sys-tem11/sqlserver11 whitepaper.html. </note>
Reference-contexts: These include that parallel Sybase <ref> [16] </ref> and Oracle [13] servers. The the internal architecture of the trigger subsystems in these products has not been published. We conjecture that they run triggers in a synchronous fashion at one or more points within update transactions.
Reference: [17] <author> Jennifer Widom and Stefano Ceri, </author> <title> editors. Active Database Systems: Triggers and Rules for Advanced Database Processing. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: Single-processor trigger systems such as the Starburst rule system, Ariel, HiPAC, the POSTGRES rule system, Ode, Chimera, DATEX etc. <ref> [10, 18, 15, 7, 17, 3] </ref> normally either execute rules as procedure or method calls at the lowest level of update command execution (e.g., as in POSTGRES and Ode) or sequentially at the end of the triggering transaction 6 (e.g., as in Ariel).
Reference: [18] <author> Jennifer Widom, Roberta J. Cochrane, and Bruce G. Lindsay. </author> <title> Implementing set-oriented production rules as an extension to Starburst. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Data Bases, </booktitle> <year> 1991. </year> <month> 19 </month>
Reference-contexts: Single-processor trigger systems such as the Starburst rule system, Ariel, HiPAC, the POSTGRES rule system, Ode, Chimera, DATEX etc. <ref> [10, 18, 15, 7, 17, 3] </ref> normally either execute rules as procedure or method calls at the lowest level of update command execution (e.g., as in POSTGRES and Ode) or sequentially at the end of the triggering transaction 6 (e.g., as in Ariel).
References-found: 18

