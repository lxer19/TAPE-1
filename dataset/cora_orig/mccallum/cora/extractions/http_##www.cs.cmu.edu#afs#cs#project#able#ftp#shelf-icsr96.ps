URL: http://www.cs.cmu.edu/afs/cs/project/able/ftp/shelf-icsr96.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/project/able/www/paper_abstracts/stylereuse-icsr.html
Root-URL: 
Title: Abstract  
Abstract: Although numerous mechanisms for promoting software reuse have been proposed and implemented over the years, most have focused on the reuse of implementation code. There is much conjecture and some empirical evidence, however, that the most effective forms of reuse are generally found at more abstract levels of software design. In this paper we discuss software reuse at the architectural level of design. Specifically, we argue that the concept of architectural style is useful for supporting the classification, storage, and retrieval of reusable architectural design elements. We briey describe the Aesop systems Software Shelf, a tool that assists designers in selecting appropriate design elements and patterns based on stylistic information and design constraints. 
Abstract-found: 1
Intro-found: 1
Reference: [AG92] <author> Allen, R. and Garlan, D. </author> <title> A Formal Approach to Software Architectures. </title> <booktitle> Proceedings of IFIP 92. </booktitle> <publisher> Elsevier Science Publishers B.V., </publisher> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Architectural designs are ubiquitous as system documentation for complex industrial software systems. Com- monly they are represented as informal box-and-line diagrams, although recently architectural definition languages are beginning to emerge [Luc+95, Shaw+95], as well as formalisms for architectural specification and analysis <ref> [AG92, Mor94] </ref>. Architectural description has a number of important design-level benefits over code-level descriptions. First, it permits richer descriptions of components. In particular, it is common to partition a components interface into multiple ports, each port determining an interaction with some part of its environment. <p> These objects are either basic architectural entities (individual components and connectors) or else more complex configurations representing design patterns. Representation of Basic Elements: Components. Component storage is best illustrated by example. Consider two basic components built in the pipe-and-filter style <ref> [AG92] </ref> and stored on a Software Shelf. Both are represented as objects derived from the Filter class of architectural entities. The first component is a generic filter (visible as the dashed box labeled filter in figure 1). It defines the basic architectural structure of all Filter objects.
Reference: [AAG93] <author> Abowd, G., Allen, R. and Garlan, D. </author> <title> Using Style to Give Meaning to Software Architecture. </title> <booktitle> In Proc. of SIGSOFT 93: Foundations of Software Engineering, Software Engineering Notes 118(3), </booktitle> <pages> pp 9-20, </pages> <publisher> ACM Press, </publisher> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Second, we make essential use of the notion of architectural idioms or styles as a way of characterizing a family of architectural designs that share a set of common assumptions <ref> [AAG93] </ref>. Third, we take advantage of the emerging class of architecture support tools for developing and analyzing architectures [Shaw+95, Luc+95]. Indeed, their very existence motivated us to provide tools for reusing architectural designs. One of these support tools is our own Aesop system [GAO94].
Reference: [Bat+94] <author> Batory, D. et al. </author> <title> The GenVoca Model of Software System Generators. </title> <journal> IEEE Software, </journal> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: For example, a typical implementation of pipes requires the use of operating systems communications available through I/O libraries. In this case many different architectural elements i.e. all of the pipes in the design use the same implementation. This suggests a strong link between application generation capabilitie, such as <ref> [Bat+94] </ref> and the forms of reuse that our tools support. 8. Conclusion Design reuse would appear to be one of the more promising avenues for improving the prospects for software reuse. But design reuse can mean many things.
Reference: [Bax92] <author> Ira D. Baxter, </author> <title> Design Maintenance Systems. </title> <journal> Comm. of the ACM, </journal> <month> April </month> <year> 1992, </year> <pages> pp. 73-87. </pages>
Reference-contexts: In particular, efforts to raise the level of abstraction in code reuse date back at least to the Draco system [Nei84], which was aimed at reusing domain specific knowledge, tools, and frameworks, and Baxters work on Design Maintenance Sys- tems <ref> [Bax92] </ref>. Currently the most successful forms of design reuse are in three areas.
Reference: [BP89] <author> Biggerstaff, T. and Perlis, A. </author> <title> Software Reusability, Vols. 1 and 2, </title> <publisher> ACM Press/Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Related Work The two areas most closely related to the research presented here are software reuse and software architecture. 2.1. Software Reuse Over the past decade there has been a vast amount of work in the area of software reuse (e.g., see <ref> [BP89] </ref>). Within this broad arena a number of researchers have looked at the problem of design reuse.
Reference: [GHJV94] <author> Gamma, E. et al. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> AddisonWesley, </address> <year> 1994. </year>
Reference-contexts: It is perhaps not surprising then, that some of the more impressive examples of reuse today involve a strong component of design reuse. Prominent examples include specialized frameworks such as user interface toolkits, application generators (such as Visual Basic), domain- specific software architectures [MG92], and object-oriented patterns <ref> [GHJV94] </ref>. But what exactly is design reuse and how can it be exploited? Most examples, such as those just mentioned, capitalize on a specialized domain, providing specific facilities for a fairly narrow class of system. <p> The third area is the recent development of object-oriented design patterns. These patterns attempt to capture common idioms of object-oriented software organization, such as the model-view-controller paradigm of Smalltalk- 80 [KP88]. Recently a number of patterns have been collected into published handbooks <ref> [GHJV94, Pree95] </ref>. Broadly speaking, our work is motivated by the same concerns that these three areas address providing high- level abstractions for constructing new systems based on previous designs and implementations. It does, however, also differ in several ways. <p> More recently, other projects such as the Advanced Distributed Simulation Program has developed a reusable high-level software architecture for integration of diverse sets of simulations. Further, there are the increasingly prominent results of the object-oriented patterns community <ref> [GHJV94] </ref>. 5. Style-Based Architectural Reuse By focusing on the reuse of architectural entities and exploiting the notion of architectural style, it is possible to realize many of the benefits of design-level reuse.
Reference: [GAO95] <author> Garlan, D., Allen, R, and Ockerbloom, J. </author> <title> Architectural Mismatch, or, Why it's hard to build sys-tems out of existing parts -- Experience Report. </title> <booktitle> Proc. of the 17th International Conference on Software Engineering. </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: The assumptions about the context in which an implementation will work are unstated: With concrete code reuse it is often difficult to discover the assumptions about the context in which the component is intended to work <ref> [GAO95] </ref>. Context includes expected protocols of interaction, locus of control, scheduling constraints, etc. 2.
Reference: [GAO94] <author> Garlan, D., Allen, R and Ockerbloom, J. </author> <title> Exploiting Style in Architectural Design Environments. </title> <booktitle> In Proc. of SIGSOFT 94: Foundations of Software Engineering, </booktitle> <month> December </month> <year> 1994, </year> <note> ACM Press. </note>
Reference-contexts: Third, we take advantage of the emerging class of architecture support tools for developing and analyzing architectures [Shaw+95, Luc+95]. Indeed, their very existence motivated us to provide tools for reusing architectural designs. One of these support tools is our own Aesop system <ref> [GAO94] </ref>. As we outline later in this paper, Aesop is a development environment for software architectures. In previous papers we have described the basic concepts behind Aesop and illustrated its use. <p> Third, the use of architectural description naturally leads to the capability for exploiting architectural styles. An architectural style provides a specialized architectural design vocabulary for a family of systems, and typically incorporates a number of idiomatic uses of that vocabulary and design rules for system composition <ref> [GS93, PW92, Mor94, GAO94] </ref>. As a simple example, Unix pipe-and-filter systems provide a specialized component vocabulary of filters (as data stream transformations) and a connector vocabulary of pipes (as data channels). Among the idiomatic patterns are the notions of a strict pipeline topology. <p> The term Software Shelf was originally suggested to us by Jon Ward at Honeywell. 6.1. Aesop Aesop <ref> [GAO94] </ref> is an experimental platform for exploring software architecture and architectural style that, among other things, allows us to test different mechanisms and strategies for supporting architectural reuse.
Reference: [GMW95] <author> Garlan, D., Monroe, R., and Wile, D. ACME: </author> <title> An Architectural Interchange Language. </title> <institution> Carnegie Mellon University Technical Report CMU-CS95-219, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: While it would be possible to write specialized translators from the Shelf to each of these tools, the long term solution will be to use more widely accepted standards for communicating architectural designs. Such standards are beginning to emerge <ref> [GMW95] </ref>, although it will likely be some time before they are widely used. In addition to the lessons learned, this research raises a number of questions about ways to further exploit architecture-based reuse and architectural styles.
Reference: [GR91] <author> Michael M. Gorlick, M. and Razouk, R. </author> <title> Using Weaves for Software Construction and Analysis. </title> <booktitle> Proc. of the 13th International Conference on Software Engineering. </booktitle> <pages> pp. 23-34, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: In this paper we extend those results by showing how a new tool, the Soft-- ware Shelf, can further exploit architectural designs and architectural styles to support design reuse. Outside of our own research, there are two closely related tools for architectural design: Weaves <ref> [GR91] </ref> and MacSTILE [SW88]. Weaves supports the development of systems based on asynchronous typed datastreams. It provides a repository mechanism, called a tray, that, like our Software Shelf, uses the context of an architectural design to determine likely candidates for reuse.
Reference: [GS93] <author> Garlan D. and Shaw, M. </author> <title> An Introduction to Software Architecture. </title> <booktitle> Advances in Software Engineering and Knowledge Engineering, </booktitle> <volume> Vol. </volume> <pages> 1, </pages> <address> New Jersey, 1993. </address> <publisher> World Scientific Publishing Co. </publisher>
Reference-contexts: We have been exploring a different, but complementary approach. Rather than focus on a specific class of system we consider the more general problem of the reuse of architectural designs. An architectural design is concerned with the gross decomposition of a system into a set of interacting components <ref> [GS93, PW92] </ref>. At this level of abstraction, key issues include the assignment of functionality to design elements, protocols of interaction, system extensibility, and broad system properties such as throughput, schedulability, and overall performance. <p> In this paper we leverage the results of this community of research in several ways. First, as we detail later, we adopt the architectural vocabulary of components, connectors and configurations that is becoming increasingly well-accepted as the basis for architectural description <ref> [GS93, PW92] </ref>. Second, we make essential use of the notion of architectural idioms or styles as a way of characterizing a family of architectural designs that share a set of common assumptions [AAG93]. <p> Third, the use of architectural description naturally leads to the capability for exploiting architectural styles. An architectural style provides a specialized architectural design vocabulary for a family of systems, and typically incorporates a number of idiomatic uses of that vocabulary and design rules for system composition <ref> [GS93, PW92, Mor94, GAO94] </ref>. As a simple example, Unix pipe-and-filter systems provide a specialized component vocabulary of filters (as data stream transformations) and a connector vocabulary of pipes (as data channels). Among the idiomatic patterns are the notions of a strict pipeline topology.
Reference: [Jef93] <author> Jeffay, K. </author> <title> The Real-Time Producer/Consumer Paradigm: A paradigm for the construction of effi-cient, predictable real-time systems. </title> <booktitle> Proc.of the 1993 ACM/SIGAPP Symposium on Applied Computing, </booktitle> <publisher> ACM Press, </publisher> <month> February </month> <year> 1993, </year> <pages> pp. 796-804. </pages>
Reference-contexts: A further example: To expand on the previous examples, we now consider a reusable design pattern for a different architectural style. Figure 3 shows a forked memory pattern created in the Real-Time Producer/Consumer (RTP/C) style described in <ref> [Jef93] </ref>. This pattern shows two shared-memory data stores that are synchronously accessed by a pair of independent RTP/C Components. The architectural style defines the basic semantics for the shared-memory components, the synchronous message passing connectors, and other components and connectors available in the style.
Reference: [KP88] <author> Krasner, G. and Pope, S. </author> <title> A Cookbook for Using the Model-View-Controller User Interface Paradigm in Smalltalk-80. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> Aug/Sept. </volume> <year> 1988, </year> <pages> pp. 26-49. </pages>
Reference-contexts: The third area is the recent development of object-oriented design patterns. These patterns attempt to capture common idioms of object-oriented software organization, such as the model-view-controller paradigm of Smalltalk- 80 <ref> [KP88] </ref>. Recently a number of patterns have been collected into published handbooks [GHJV94, Pree95]. Broadly speaking, our work is motivated by the same concerns that these three areas address providing high- level abstractions for constructing new systems based on previous designs and implementations.
Reference: [Kru92] <author> Krueger, C. </author> <title> Software Reuse, </title> <journal> Computing Surveys, </journal> <month> February </month> <year> 1992. </year>
Reference-contexts: In this area reuse is achieved by exploiting a shared implementation base and a common design framework for a specific class of software application <ref> [Kru92] </ref>. The second area is domain-specific software architecture (DSSA). A DSSA system focuses on software support for an application domain, such as avionics, mobile robotics, or command and control [MG92].
Reference: [Luc+95] <author> Luckham, D. et al. </author> <title> Specification and Analysis of System Architecture Using Rapide. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> April </month> <year> 1995. </year>
Reference-contexts: Second, we make essential use of the notion of architectural idioms or styles as a way of characterizing a family of architectural designs that share a set of common assumptions [AAG93]. Third, we take advantage of the emerging class of architecture support tools for developing and analyzing architectures <ref> [Shaw+95, Luc+95] </ref>. Indeed, their very existence motivated us to provide tools for reusing architectural designs. One of these support tools is our own Aesop system [GAO94]. As we outline later in this paper, Aesop is a development environment for software architectures. <p> Architectural designs are ubiquitous as system documentation for complex industrial software systems. Com- monly they are represented as informal box-and-line diagrams, although recently architectural definition languages are beginning to emerge <ref> [Luc+95, Shaw+95] </ref>, as well as formalisms for architectural specification and analysis [AG92, Mor94]. Architectural description has a number of important design-level benefits over code-level descriptions. First, it permits richer descriptions of components.
Reference: [MG92] <author> Mettala, E. and Graham, M.. </author> <title> The Domain-Specific Software Architecture Program. </title> <type> Special Report, </type> <institution> Carnegie Mellon University Software Engineering Institute CMU/SEI-92-SR-9. </institution> <year> 1992. </year>
Reference-contexts: It is perhaps not surprising then, that some of the more impressive examples of reuse today involve a strong component of design reuse. Prominent examples include specialized frameworks such as user interface toolkits, application generators (such as Visual Basic), domain- specific software architectures <ref> [MG92] </ref>, and object-oriented patterns [GHJV94]. But what exactly is design reuse and how can it be exploited? Most examples, such as those just mentioned, capitalize on a specialized domain, providing specific facilities for a fairly narrow class of system. <p> The second area is domain-specific software architecture (DSSA). A DSSA system focuses on software support for an application domain, such as avionics, mobile robotics, or command and control <ref> [MG92] </ref>. Typically it provides one or more domain-specific notations for characterizing a specific use of the architecture, together with tools for using these notations to generate a specific system implementation. The third area is the recent development of object-oriented design patterns.
Reference: [Mor94] <author> Moriconi, M. and Qian, X. </author> <title> Correctness and Composition of Software Architectures, </title> <booktitle> In Proc. of the ACM SIGSOFT 94: Symposium on Foundations of Software Engineering, </booktitle> <month> December, </month> <year> 1994. </year>
Reference-contexts: Architectural designs are ubiquitous as system documentation for complex industrial software systems. Com- monly they are represented as informal box-and-line diagrams, although recently architectural definition languages are beginning to emerge [Luc+95, Shaw+95], as well as formalisms for architectural specification and analysis <ref> [AG92, Mor94] </ref>. Architectural description has a number of important design-level benefits over code-level descriptions. First, it permits richer descriptions of components. In particular, it is common to partition a components interface into multiple ports, each port determining an interaction with some part of its environment. <p> Third, the use of architectural description naturally leads to the capability for exploiting architectural styles. An architectural style provides a specialized architectural design vocabulary for a family of systems, and typically incorporates a number of idiomatic uses of that vocabulary and design rules for system composition <ref> [GS93, PW92, Mor94, GAO94] </ref>. As a simple example, Unix pipe-and-filter systems provide a specialized component vocabulary of filters (as data stream transformations) and a connector vocabulary of pipes (as data channels). Among the idiomatic patterns are the notions of a strict pipeline topology.
Reference: [Nei84] <author> Neighbors, J. </author> <title> The Draco Approach to Constructing Software from Reusable Components. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. </volume> <month> SE10, </month> <note> September 1984 pp. 564-574. </note>
Reference-contexts: Within this broad arena a number of researchers have looked at the problem of design reuse. In particular, efforts to raise the level of abstraction in code reuse date back at least to the Draco system <ref> [Nei84] </ref>, which was aimed at reusing domain specific knowledge, tools, and frameworks, and Baxters work on Design Maintenance Sys- tems [Bax92]. Currently the most successful forms of design reuse are in three areas.
Reference: [PDF87] <author> Prieto-Diaz, R. and Freeman, P. </author> <title> Classifying Software for Reusability. </title> <booktitle> IEEE Software Volume 4(1), </booktitle> <month> January </month> <year> 1987, </year> <pages> pp. 6-16. </pages>
Reference-contexts: Although numerous repository schemas have been developed for classifying software assets, such as component facets <ref> [PDF87] </ref>, most of these mecha <br>- nisms are based on informal classification schemes. Reliance on the accuracy of the informal descriptions of the code is suspect, especially if the annotations were added independently by different people over a significant period of time.
Reference: [Pree95] <author> Pree, W. </author> <title> Design Patterns for Object-Oriented Software Development. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The third area is the recent development of object-oriented design patterns. These patterns attempt to capture common idioms of object-oriented software organization, such as the model-view-controller paradigm of Smalltalk- 80 [KP88]. Recently a number of patterns have been collected into published handbooks <ref> [GHJV94, Pree95] </ref>. Broadly speaking, our work is motivated by the same concerns that these three areas address providing high- level abstractions for constructing new systems based on previous designs and implementations. It does, however, also differ in several ways.
Reference: [PW92] <author> Perry, D. and Wolf, A. </author> <title> Foundations for the Study of Software Architecture. </title> <journal> ACM Software Engineering Notes, </journal> <volume> 17(4), </volume> <month> October </month> <year> 1992, </year> <pages> pp. 40-52. </pages>
Reference-contexts: We have been exploring a different, but complementary approach. Rather than focus on a specific class of system we consider the more general problem of the reuse of architectural designs. An architectural design is concerned with the gross decomposition of a system into a set of interacting components <ref> [GS93, PW92] </ref>. At this level of abstraction, key issues include the assignment of functionality to design elements, protocols of interaction, system extensibility, and broad system properties such as throughput, schedulability, and overall performance. <p> In this paper we leverage the results of this community of research in several ways. First, as we detail later, we adopt the architectural vocabulary of components, connectors and configurations that is becoming increasingly well-accepted as the basis for architectural description <ref> [GS93, PW92] </ref>. Second, we make essential use of the notion of architectural idioms or styles as a way of characterizing a family of architectural designs that share a set of common assumptions [AAG93]. <p> Third, the use of architectural description naturally leads to the capability for exploiting architectural styles. An architectural style provides a specialized architectural design vocabulary for a family of systems, and typically incorporates a number of idiomatic uses of that vocabulary and design rules for system composition <ref> [GS93, PW92, Mor94, GAO94] </ref>. As a simple example, Unix pipe-and-filter systems provide a specialized component vocabulary of filters (as data stream transformations) and a connector vocabulary of pipes (as data channels). Among the idiomatic patterns are the notions of a strict pipeline topology.
Reference: [Shaw+95] <editor> Shaw, M. et al. </editor> <title> Abstractions for Software Architecture and Tools to Support Them. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 314-335, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Second, we make essential use of the notion of architectural idioms or styles as a way of characterizing a family of architectural designs that share a set of common assumptions [AAG93]. Third, we take advantage of the emerging class of architecture support tools for developing and analyzing architectures <ref> [Shaw+95, Luc+95] </ref>. Indeed, their very existence motivated us to provide tools for reusing architectural designs. One of these support tools is our own Aesop system [GAO94]. As we outline later in this paper, Aesop is a development environment for software architectures. <p> Architectural designs are ubiquitous as system documentation for complex industrial software systems. Com- monly they are represented as informal box-and-line diagrams, although recently architectural definition languages are beginning to emerge <ref> [Luc+95, Shaw+95] </ref>, as well as formalisms for architectural specification and analysis [AG92, Mor94]. Architectural description has a number of important design-level benefits over code-level descriptions. First, it permits richer descriptions of components.
Reference: [SW88] <author> Stovsky, M. and Weide, B. </author> <title> Building Interprocess Communication Models Using STILE. </title> <booktitle> Proc. of the 21st annual Hawaii Intl. Conference on System Sciences. </booktitle> <volume> Vol. II </volume>
Reference-contexts: In this paper we extend those results by showing how a new tool, the Soft-- ware Shelf, can further exploit architectural designs and architectural styles to support design reuse. Outside of our own research, there are two closely related tools for architectural design: Weaves [GR91] and MacSTILE <ref> [SW88] </ref>. Weaves supports the development of systems based on asynchronous typed datastreams. It provides a repository mechanism, called a tray, that, like our Software Shelf, uses the context of an architectural design to determine likely candidates for reuse. On the other hand, Weaves focuses on a specific style.
References-found: 23

