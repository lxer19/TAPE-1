URL: http://www.cosc.brocku.ca/Research/TechRep/cs9503.ps
Refering-URL: http://www.cosc.brocku.ca/Research/TechRep/
Root-URL: 
Email: email: tjenkyns@spartan.ac.brocku.ca  
Title: LOOPLESS GRAY CODE ALGORITHMS  
Author: T. A. Jenkyns 
Address: St. Catharines, Ontario  
Affiliation: Department of Mathematics Brock University,  
Abstract: All (non-empty) subsets of -1..n- may be represented as increasing sequences of varying length. In this form, they are easily generated in lexicographic order by elegant and compact algorithms. A second total order on the integer sequences, alternating-lexocographic order, is specified where each increasing sequence differs from its predecessor by the addition of a single new element or deletion of a single old element. Such minimal change listings are known as Gray codes. Using this order, new loopless algorithms for generating all subsets, all &lt; k-subsets, all k-subsets, and all subsets of sizes min to max are given. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ehrlich, G., </author> <title> "Loopless Algorithms for Generating Permutations, Combinations and Other Combinatorial Configurations", </title> <journal> J. ACM 20, </journal> <month> 3 (July </month> <year> 1973), </year> <pages> 500-513. </pages>
Reference-contexts: Let U (a,b) denote the set of all such sequences S where a &lt; length (S) &lt; b. This paper concerns algorithms for generating all members of U (a,b) and the three special cases of U (1,n), U (1,k) and U (k,k) in some order in a list. In <ref> [1] </ref> Gideon Ehrlich formalized the notion of a loopless algorithm for this task as one where, after the initial sequence is generated, each succeeding sequence must be generated by at most a fixed number, K, of operations where K is independent of n. <p> "Process ( S <ref> [1] </ref>...S [k] )" to a procedure which receives the subsets as they are generated for some unspecified purpose. Algorithm L1 (* generates nonempty subsets of -1..n- *) (* as increasing sequences S [1],...,S [k] *) (* in Lexicographic order *) BEGIN S [1]:=1; k:=1; Process ( S [1] ); WHILE S [1] &lt; n DO IF S [k] = n THEN S [k-1]:=S [k-1]+1; k:=k-1 ELSE S [k+1]:=S [ k ]+1; k:=k+1 END; Process ( S [1],...,S [k] ) END END Algorithm L1. <p> Algorithm L1 (* generates nonempty subsets of -1..n- *) (* as increasing sequences S <ref> [1] </ref>,...,S [k] *) (* in Lexicographic order *) BEGIN S [1]:=1; k:=1; Process ( S [1] ); WHILE S [1] &lt; n DO IF S [k] = n THEN S [k-1]:=S [k-1]+1; k:=k-1 ELSE S [k+1]:=S [ k ]+1; k:=k+1 END; Process ( S [1],...,S [k] ) END END Algorithm L1. <p> The latter is not a minimal change so L1 is loopless but does not produce a Gray code. Algorithm L2 (* generates all k-subsets of -1..n- *) (* where 1 &lt; k &lt; max in Lex Order *) BEGIN S <ref> [1] </ref>:=1; k:=1; Process ( S [1] ); WHILE S [1] &lt; n DO IF S [k] = n THEN S [k-1]:=S [k-1]+1; k:=k-1 ELSE IF k &lt; max THEN S [k+1]:=S [k]+1; k:=k+1 ELSE S [k] :=S [k]+1 END; END; Process ( S [1],...,S [k] ) END END Algorithm L2. 3 The following two algorithms contain <p> The latter is not a minimal change so L1 is loopless but does not produce a Gray code. Algorithm L2 (* generates all k-subsets of -1..n- *) (* where 1 &lt; k &lt; max in Lex Order *) BEGIN S <ref> [1] </ref>:=1; k:=1; Process ( S [1] ); WHILE S [1] &lt; n DO IF S [k] = n THEN S [k-1]:=S [k-1]+1; k:=k-1 ELSE IF k &lt; max THEN S [k+1]:=S [k]+1; k:=k+1 ELSE S [k] :=S [k]+1 END; END; Process ( S [1],...,S [k] ) END END Algorithm L2. 3 The following two algorithms contain an unavoidable loop (the <p> Algorithm L3 (* generates all k-subsets of -1..n- *) (* as increasing sequences in Lex Order *) (* j=k or j=first index where S [j]=n-k+j *) BEGIN FOR i:=1 TO k DO S [i]:=i END; Process ( S <ref> [1] </ref>,...,S [k] ); j:=k; WHILE S [1] &lt; n-k+1 DO IF S [k] &lt; n THEN S [k]:=S [k]+1 ELSE S [j-1]:=S [j-1]+1; IF S [j-1] = S [j]-1 THEN j:=j-1 ELSE FOR i:=j TO k DO S [i]:=S [i-1]+1 END; END Process ( S [1],...,S [k] ) END END Algorithm L3. <p> Algorithm L4 (* generates all k-subsets of -1..n- *) (* where min &lt; k &lt; max in Lex Order *) (* j=min or first index where S [j]=n-min+j *) BEGIN FOR i:=1 TO min DO S [i]:=i END; k:=min; Process ( S <ref> [1] </ref>,...,S [k] ); j:=min; WHILE S [1] &lt; n-min+1 DO IF S [min] &lt; n THEN IF S [k] = n THEN S [k-1]:=S [k-1]+1; k:=k-1 ELSE IF k&lt;max THEN S [k+1]:=S [k]+1; k:=k+1 ELSE S [k] :=S [k]+1 END END ELSE S [j-1]:=S [j-1]+1; IF S [j-1] = S [j]-1 THEN j:=j-1 ELSE FOR i:=j TO <p> and k=3 the 10 sequences corresponding to k-subsets of -1..n- have the following alternating-lexicographic order. 1. 1 4 5 3. 1 3 5 5. 1 2 4 7. 2 4 5 9. 2 3 5 In general, S is the last k-sequence in the order if and only if S <ref> [1] </ref> = n-k+1. Suppose S is not the last increasing k-sequence. Let p be the largest index where S [p] &lt; n-k+p. <p> either the last entry is changed up or down by one, or two adjacent entries are changed. 6 Loopless Algorithms for subsets in alternating-lexicographic order Algorithm A1 (* generates nonempty subsets of -1..n- *) (* as increasing sequences in a Gray code *) BEGIN S <ref> [1] </ref>:=1; k:=1; Process ( S [1] ); WHILE S [1] &lt; n DO IF S [k] = n THEN k:=k-1 ELSE S [k+1]:=n; k:=k+1 END; Process ( S [1],...,S [k] ); IF S [k-1] = S [k]-1 THEN S [k-1]:=S [k]; k:=k-1 ELSE S [k+1]:=S [k]; S [k]:=S [k]-1; k:=k+1 END; Process ( S [1],...,S [k] <p> is changed up or down by one, or two adjacent entries are changed. 6 Loopless Algorithms for subsets in alternating-lexicographic order Algorithm A1 (* generates nonempty subsets of -1..n- *) (* as increasing sequences in a Gray code *) BEGIN S <ref> [1] </ref>:=1; k:=1; Process ( S [1] ); WHILE S [1] &lt; n DO IF S [k] = n THEN k:=k-1 ELSE S [k+1]:=n; k:=k+1 END; Process ( S [1],...,S [k] ); IF S [k-1] = S [k]-1 THEN S [k-1]:=S [k]; k:=k-1 ELSE S [k+1]:=S [k]; S [k]:=S [k]-1; k:=k+1 END; Process ( S [1],...,S [k] ) END END Algorithm <p> 'standard reflected (binary) Gray code' (see [5]) produced in reverse order, if the all zero string is added at the end. 7 Algorithm A2 (* generates all k-subsets of -1..n- *) (* where 1 &lt; k &lt; max in a Gray code *) BEGIN S <ref> [1] </ref>:=1; k:=1; Process ( S [1] ); WHILE S [1] &lt; n DO IF ((k MOD 2) &gt; 0 THEN (* k is odd *) IF S [k] = n THEN k:=k-1 ELSE IF k &lt; max THEN S [k+1]:=n; k:=k+1 ELSE S [k]:=S [k]+1 END END ELSE (* k is even *) IF S [k-1] <p> code' (see [5]) produced in reverse order, if the all zero string is added at the end. 7 Algorithm A2 (* generates all k-subsets of -1..n- *) (* where 1 &lt; k &lt; max in a Gray code *) BEGIN S <ref> [1] </ref>:=1; k:=1; Process ( S [1] ); WHILE S [1] &lt; n DO IF ((k MOD 2) &gt; 0 THEN (* k is odd *) IF S [k] = n THEN k:=k-1 ELSE IF k &lt; max THEN S [k+1]:=n; k:=k+1 ELSE S [k]:=S [k]+1 END END ELSE (* k is even *) IF S [k-1] = S [k]-1 THEN <p> END END Process ( S <ref> [1] </ref>,...,S [k] ) END END Algorithm A2. Algorithm A3 (* generates all k-subsets of -1..n- *) (* as increasing sequences in a Gray code *) BEGIN S [1]:=1; FOR i:=2 TO k DO S [i]:=n-k+i END; Process ( S [1],...,S [k] ); j:=2; WHILE S [1] &lt; n-k+1 DO IF j &gt; k THEN S [k]:=S [k]+1; IF S [k] = n THEN j:=j-2 END ELSE IF S [j-1] = S [j]-1 THEN S [j-1]:= S [j]; S [j]:=n-k+j; IF S [j-1]=S [j]-1 THEN j:=j-2 END ELSE S [j]:=S [j]-1; IF j &lt; k THEN S <p> 8 Algorithm A4 (* to generate all k-subsets of -1..n- *) (* where min &lt; k &lt; max in a Gray code *) BEGIN S <ref> [1] </ref>:=1; k:=min; IF min=1 THEN j:=1 ELSE FOR i:=2 TO min DO S [i]:=n-min+i END; j:=2 END; Process ( S [1],...,S [k] ); WHILE S [1] &lt; n-min+1 DO IF ((j MOD 2) &gt; 0 THEN (* j is odd *) IF S [j] = n THEN j:=j-1 ELSE IF j &lt; max THEN S [j+1]:=n; j:=j+1 ELSE S [j]:=S [j]+1; IF S [min]=n THEN j:=j-1 END END ELSE (* j is even *) IF S
Reference: [2] <author> Mifsud, C.J., </author> <title> "Algorithm 154. Combination in Lexicographical Order", </title> <journal> Comm. ACM 6, </journal> <month> (Mar </month> <year> 1963), </year> <month> 103. </month>
Reference-contexts: Section 3 contains algorithms for generating them in lexicographic order. Because this order is so natural, algorithms using it are reinvented frequently and variations have appeared in the literature (see [3] and [4]), perhaps beginning with <ref> [2] </ref>. Sections 4 and 5 discuss alternating-lexicographic order and the final section concludes with new, loopless algorithms for generating them in that order as Gray codes.
Reference: [3] <editor> Nijenhuis, A. and Wilf, H. S., </editor> <publisher> Combinatorial Algorithms , Academic Press, </publisher> <year> 1978. </year>
Reference-contexts: The next section specifies two of the many orders in which the subsets may be generated. Section 3 contains algorithms for generating them in lexicographic order. Because this order is so natural, algorithms using it are reinvented frequently and variations have appeared in the literature (see <ref> [3] </ref> and [4]), perhaps beginning with [2]. Sections 4 and 5 discuss alternating-lexicographic order and the final section concludes with new, loopless algorithms for generating them in that order as Gray codes.
Reference: [4] <author> Reingold, E. M., Nievergelt, J. and Deo, </author> <title> N.,Combinatorial Algorithms, </title> <publisher> Prentice-Hall, </publisher> <year> 1977. </year>
Reference-contexts: The next section specifies two of the many orders in which the subsets may be generated. Section 3 contains algorithms for generating them in lexicographic order. Because this order is so natural, algorithms using it are reinvented frequently and variations have appeared in the literature (see [3] and <ref> [4] </ref>), perhaps beginning with [2]. Sections 4 and 5 discuss alternating-lexicographic order and the final section concludes with new, loopless algorithms for generating them in that order as Gray codes.
Reference: [5] <author> Wilf, H. S., </author> <title> Combinatorial Algorithms: An Update, </title> <publisher> SIAM CBMS-55, </publisher> <year> 1989. </year>
Reference-contexts: If a generating algorithm is loopless, any succeeding sequence cannot differ from its predecessor in more than K entries. When the number of changes is consistently as small as possible, the list of sequences is known as a Gray code (see Wilf <ref> [5] </ref> p. 7). The next section specifies two of the many orders in which the subsets may be generated. Section 3 contains algorithms for generating them in lexicographic order. <p> The cases of odd and even k alternate and both have been put into the body of the loop. The bitstrings corresponding to the subsets generated here are precisely the 'standard reflected (binary) Gray code' (see <ref> [5] </ref>) produced in reverse order, if the all zero string is added at the end. 7 Algorithm A2 (* generates all k-subsets of -1..n- *) (* where 1 &lt; k &lt; max in a Gray code *) BEGIN S [1]:=1; k:=1; Process ( S [1] ); WHILE S [1] &lt; n
References-found: 5

