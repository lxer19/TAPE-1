URL: http://www.cs.virginia.edu/~nr/pubs/team.ps
Refering-URL: http://www.cs.virginia.edu/~nr/activities.html
Root-URL: http://www.cs.virginia.edu
Title: Literate Programming on a Team Project  
Author: Norman Ramsey and Carla Marceau 
Date: February 4, 1991  
Address: 301A Harris B. Dates Drive Ithaca, New York 14850  
Affiliation: Odyssey Research Associates  
Abstract: We used literate programming on a team project to write a 33,000-line program for the Synthesizer Generator. The program, Penelope, was written using WEB, a tool designed for writing literate programs. Unlike other WEB programs, many of which have been written by WEB's developer or by individuals, Penelope was not intended to be published. We used WEB in the hope that both our team and its final product would benefit from the advantages often attributed to literate programming. The WEB source served as good internal documentation throughout development and maintenance, and it continues to document Penelope's design and implementation. Our experience also uncovered a number of problems with WEB.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Donald E. Knuth. </author> <title> Literate programming. </title> <journal> The Computer Journal, </journal> <volume> 27(2) </volume> <pages> 97-111, </pages> <year> 1984. </year>
Reference-contexts: Introduction Donald Knuth coined the term "literate programming" when describing WEB, the tool he used to build T E X <ref> [1] </ref>. He believes that "the time is ripe for significantly better documentation of programs, and that we can best achieve this by considering programs to be works of literature." Knuth and others have presented examples of such programs [2, 3, 4, 5]. <p> Additional expectations of a literate programming tool include flexible order of elaboration, ability to develop program and documentation concurrently in one place, cross-references, and indexing [9]. WEB is the principal tool used for literate programming; a number of implementations are available <ref> [1, 10, 11, 12, 13, 14] </ref>. WEB programmers interleave source code and descriptive text in a single document. When using WEB, a programmer divides the source code into small textual units called modules, and each module carries associated documentation.
Reference: [2] <author> Donald E. Knuth and Jon L. Bentley. </author> <title> Programming pearls: Literate programming. </title> <journal> Communications of the ACM, </journal> <volume> 29(5) </volume> <pages> 364-368, </pages> <month> May </month> <year> 1986. </year> <month> 7 </month>
Reference-contexts: He believes that "the time is ripe for significantly better documentation of programs, and that we can best achieve this by considering programs to be works of literature." Knuth and others have presented examples of such programs <ref> [2, 3, 4, 5] </ref>. Literate programming is usually discussed in the context of publishing programs or of publishing books or articles about programs. T E X and METAFONT, the original applications of WEB, have been published as books [6, 7]. <p> Programs to find random sequences and count common words were written to illustrate the power of literate programming <ref> [2, 3] </ref>. Another program to count common words is a tutorial on how to develop and tune a small program [4]. Another illustrates formal methods of program development and the use of abstract data types [5].
Reference: [3] <author> Donald E. Knuth. </author> <title> Programming pearls: A literate program. </title> <journal> Communi--cations of the ACM, </journal> <volume> 29(6) </volume> <pages> 471-483, </pages> <month> June </month> <year> 1986. </year> <note> Reviewed by M. Douglas McIlroy. </note>
Reference-contexts: He believes that "the time is ripe for significantly better documentation of programs, and that we can best achieve this by considering programs to be works of literature." Knuth and others have presented examples of such programs <ref> [2, 3, 4, 5] </ref>. Literate programming is usually discussed in the context of publishing programs or of publishing books or articles about programs. T E X and METAFONT, the original applications of WEB, have been published as books [6, 7]. <p> Programs to find random sequences and count common words were written to illustrate the power of literate programming <ref> [2, 3] </ref>. Another program to count common words is a tutorial on how to develop and tune a small program [4]. Another illustrates formal methods of program development and the use of abstract data types [5]. <p> The order of fragments is the same in the WEB source and in the published document, which simplifies polishing. We found some of WEB's cosmetic features inadequate, others superfluous. Cosmetics should include appropriate media for presenting programs: not just math and tables but also diagrams and figures <ref> [27, 3, 28] </ref>. Describing data structures was hampered by T E X's lack of support for diagrams and pictures. T E X does make it easy to use mathematical notation, which helped considerably in describing predicate transformation, the simplifier, and the proof system used in the proof constructor.
Reference: [4] <author> David R. Hanson. </author> <title> Literate programming: Printing common words. </title> <journal> Communications of the ACM, </journal> <volume> 30(7) </volume> <pages> 593-599, </pages> <month> July </month> <year> 1987. </year> <note> Reviewed by John Gilbert. </note>
Reference-contexts: He believes that "the time is ripe for significantly better documentation of programs, and that we can best achieve this by considering programs to be works of literature." Knuth and others have presented examples of such programs <ref> [2, 3, 4, 5] </ref>. Literate programming is usually discussed in the context of publishing programs or of publishing books or articles about programs. T E X and METAFONT, the original applications of WEB, have been published as books [6, 7]. <p> Programs to find random sequences and count common words were written to illustrate the power of literate programming [2, 3]. Another program to count common words is a tutorial on how to develop and tune a small program <ref> [4] </ref>. Another illustrates formal methods of program development and the use of abstract data types [5].
Reference: [5] <author> David Gries and Jon Bentley. </author> <title> Programming pearls: Abstract data types. </title> <journal> Communications of the ACM, </journal> <volume> 30(4) </volume> <pages> 284-290, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: He believes that "the time is ripe for significantly better documentation of programs, and that we can best achieve this by considering programs to be works of literature." Knuth and others have presented examples of such programs <ref> [2, 3, 4, 5] </ref>. Literate programming is usually discussed in the context of publishing programs or of publishing books or articles about programs. T E X and METAFONT, the original applications of WEB, have been published as books [6, 7]. <p> Another program to count common words is a tutorial on how to develop and tune a small program [4]. Another illustrates formal methods of program development and the use of abstract data types <ref> [5] </ref>. A valedictory assessment points out three common aspects of the published literate programs: cosmetics, polish, and verisimilitude, of which verisimilitude| the property of using one input to produce both compilable program and published document-is deemed essential [8].
Reference: [6] <author> Donald E. Knuth. </author> <title> T E X: The Program, volume B of Computers & Typesetting. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Literate programming is usually discussed in the context of publishing programs or of publishing books or articles about programs. T E X and METAFONT, the original applications of WEB, have been published as books <ref> [6, 7] </ref>. Other fl This research has been sponsored in part by the USAF, Rome Air Development Center, under contract number F30602-86-C-0071. <p> Extra structure in the form of "parts" has been added to the book version of T E X; a part contains several sections <ref> [6] </ref>. We changed WEAVE's table of contents mechanism to make hierarchical organization possible. The new mechanism supports chapters, sections, and two levels of subsections. We did so without changing WEAVE itself; instead we changed the T E X macros that support WEAVE.
Reference: [7] <author> Donald E. Knuth. METAFONT: </author> <title> The Program, volume D of Computers & Typesetting. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Literate programming is usually discussed in the context of publishing programs or of publishing books or articles about programs. T E X and METAFONT, the original applications of WEB, have been published as books <ref> [6, 7] </ref>. Other fl This research has been sponsored in part by the USAF, Rome Air Development Center, under contract number F30602-86-C-0071.
Reference: [8] <author> Christopher J. Van Wyk. </author> <title> Literate programming: An assessment. </title> <journal> Communications of the ACM, </journal> <volume> 33(3) </volume> <pages> 361-365, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: A valedictory assessment points out three common aspects of the published literate programs: cosmetics, polish, and verisimilitude, of which verisimilitude| the property of using one input to produce both compilable program and published document-is deemed essential <ref> [8] </ref>. Additional expectations of a literate programming tool include flexible order of elaboration, ability to develop program and documentation concurrently in one place, cross-references, and indexing [9]. WEB is the principal tool used for literate programming; a number of implementations are available [1, 10, 11, 12, 13, 14].
Reference: [9] <author> Harold Thimbleby. </author> <title> A review of Donald C. Lindsay's text file difference utility, </title> <journal> diff. Communications of the ACM, </journal> <volume> 32(6) </volume> <pages> 752-755, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Additional expectations of a literate programming tool include flexible order of elaboration, ability to develop program and documentation concurrently in one place, cross-references, and indexing <ref> [9] </ref>. WEB is the principal tool used for literate programming; a number of implementations are available [1, 10, 11, 12, 13, 14]. WEB programmers interleave source code and descriptive text in a single document. <p> Instead, we relied on peer review of programs, rewriting them until the project members understood them. These programs were rarely polished to the point necessary for publication; less polished presentations were adequate. One review of a literate program emphasizes the role of juxtaposed code and documentation <ref> [9] </ref>. It cites several benefits of this juxtaposition, including an incentive to explain and hence to understand what one is doing. During peer reviews of Penelope, we insisted that explanations of programs include explanations of design.
Reference: [10] <author> Harold Thimbleby. </author> <title> Experiences of `literate programming' using cweb (a variant of Knuth's WEB). </title> <journal> Computer Journal, </journal> <volume> 29(3) </volume> <pages> 201-211, </pages> <year> 1986. </year>
Reference-contexts: Additional expectations of a literate programming tool include flexible order of elaboration, ability to develop program and documentation concurrently in one place, cross-references, and indexing [9]. WEB is the principal tool used for literate programming; a number of implementations are available <ref> [1, 10, 11, 12, 13, 14] </ref>. WEB programmers interleave source code and descriptive text in a single document. When using WEB, a programmer divides the source code into small textual units called modules, and each module carries associated documentation.
Reference: [11] <author> Klaus Guntermann and Joachim Schrod. </author> <title> WEB adapted to C. </title> <journal> TUGboat, </journal> <volume> 7(3) </volume> <pages> 134-137, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: Additional expectations of a literate programming tool include flexible order of elaboration, ability to develop program and documentation concurrently in one place, cross-references, and indexing [9]. WEB is the principal tool used for literate programming; a number of implementations are available <ref> [1, 10, 11, 12, 13, 14] </ref>. WEB programmers interleave source code and descriptive text in a single document. When using WEB, a programmer divides the source code into small textual units called modules, and each module carries associated documentation.
Reference: [12] <author> Silvio Levy. </author> <title> WEB adapted to C, another approach. </title> <journal> TUGBoat, </journal> <volume> 8(1) </volume> <pages> 12-13, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: Additional expectations of a literate programming tool include flexible order of elaboration, ability to develop program and documentation concurrently in one place, cross-references, and indexing [9]. WEB is the principal tool used for literate programming; a number of implementations are available <ref> [1, 10, 11, 12, 13, 14] </ref>. WEB programmers interleave source code and descriptive text in a single document. When using WEB, a programmer divides the source code into small textual units called modules, and each module carries associated documentation.
Reference: [13] <author> Wayne Sewell. </author> <title> How to MANGLE your software: the WEB system for Modula-2. </title> <journal> TUGboat, </journal> <volume> 8(2) </volume> <pages> 118-128, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Additional expectations of a literate programming tool include flexible order of elaboration, ability to develop program and documentation concurrently in one place, cross-references, and indexing [9]. WEB is the principal tool used for literate programming; a number of implementations are available <ref> [1, 10, 11, 12, 13, 14] </ref>. WEB programmers interleave source code and descriptive text in a single document. When using WEB, a programmer divides the source code into small textual units called modules, and each module carries associated documentation.
Reference: [14] <author> Norman Ramsey. </author> <title> Literate programming: Weaving a language-independent WEB. </title> <journal> Communications of the ACM, </journal> <volume> 32(9) </volume> <pages> 1051-1055, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Additional expectations of a literate programming tool include flexible order of elaboration, ability to develop program and documentation concurrently in one place, cross-references, and indexing [9]. WEB is the principal tool used for literate programming; a number of implementations are available <ref> [1, 10, 11, 12, 13, 14] </ref>. WEB programmers interleave source code and descriptive text in a single document. When using WEB, a programmer divides the source code into small textual units called modules, and each module carries associated documentation.
Reference: [15] <author> Norman Ramsey. </author> <title> Developing formally verified Ada programs. </title> <booktitle> In Proceedings of the 5th International Workshop on Software Specification and Design, </booktitle> <pages> pages 257-265, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Examples of WEB source and typeset documentation can be found in Reference 1. Using Literate Programming Penelope is a language-based editor intended to help programmers develop formally verified Ada programs <ref> [15, 16, 17] </ref>. It parses annotated Ada programs, performs static semantic checking and overload resolution, computes weakest preconditions by predicate transformation, simplifies the resulting preconditions, and helps users construct proofs of those preconditions. Its source code is 2 an editor specification for the Synthesizer Generator [18].
Reference: [16] <author> Carla Marceau and C. Douglas Harper. </author> <title> An interactive approach to Ada verification. </title> <booktitle> In Proceedings of the 12th National Computer Security Conference, </booktitle> <pages> pages 28-51, </pages> <address> Baltimore, Maryland, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Examples of WEB source and typeset documentation can be found in Reference 1. Using Literate Programming Penelope is a language-based editor intended to help programmers develop formally verified Ada programs <ref> [15, 16, 17] </ref>. It parses annotated Ada programs, performs static semantic checking and overload resolution, computes weakest preconditions by predicate transformation, simplifies the resulting preconditions, and helps users construct proofs of those preconditions. Its source code is 2 an editor specification for the Synthesizer Generator [18].
Reference: [17] <author> David Guaspari, Carla Marceau, and Wolfgang Polak. </author> <title> Formal verification of Ada programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 1058-1075, </pages> <month> September </month> <year> 1990. </year> <month> 8 </month>
Reference-contexts: Examples of WEB source and typeset documentation can be found in Reference 1. Using Literate Programming Penelope is a language-based editor intended to help programmers develop formally verified Ada programs <ref> [15, 16, 17] </ref>. It parses annotated Ada programs, performs static semantic checking and overload resolution, computes weakest preconditions by predicate transformation, simplifies the resulting preconditions, and helps users construct proofs of those preconditions. Its source code is 2 an editor specification for the Synthesizer Generator [18].
Reference: [18] <author> Thomas Reps and Tim Teitelbaum. </author> <title> The Synthesizer Generator Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: It parses annotated Ada programs, performs static semantic checking and overload resolution, computes weakest preconditions by predicate transformation, simplifies the resulting preconditions, and helps users construct proofs of those preconditions. Its source code is 2 an editor specification for the Synthesizer Generator <ref> [18] </ref>. The Synthesizer Gen--erator builds an editor of attributed syntax trees. When a user defines a tree, the editor attributes it. When the user changes the tree, the editor recomputes only those attribute values that have changed [19]. <p> We began implementation with a clearly defined goal and worked from detailed, sometimes formal, specifications. We had time to design the system carefully and used a declarative programming language. We did not have to develop a user interface but used the one provided by the Synthesizer Generator <ref> [18] </ref>. We will continue to use literate programming for Penelope and for future projects. WEB's problems are such that we believe it will be cost-effective for future projects to develop literate programming tools that address some of the criticisms presented here.
Reference: [19] <author> Thomas Reps. </author> <title> Generating Language-Based Environments. </title> <publisher> MIT Press, </publisher> <year> 1984. </year>
Reference-contexts: Its source code is 2 an editor specification for the Synthesizer Generator [18]. The Synthesizer Gen--erator builds an editor of attributed syntax trees. When a user defines a tree, the editor attributes it. When the user changes the tree, the editor recomputes only those attribute values that have changed <ref> [19] </ref>. Penelope has two written specifications: the Ada language reference manual and a denotational-style definition of Ada predicate transformers [20, 21]. After three years of work, the WEB source for the editor is over 33,000 lines. Over 13,000 of those lines are interleaved documentation.
Reference: [20] <institution> US Department of Defense. </institution> <note> The Ada Programming Language Reference Manual, 1983. ANSI/MILSTD 1815A. </note>
Reference-contexts: When a user defines a tree, the editor attributes it. When the user changes the tree, the editor recomputes only those attribute values that have changed [19]. Penelope has two written specifications: the Ada language reference manual and a denotational-style definition of Ada predicate transformers <ref> [20, 21] </ref>. After three years of work, the WEB source for the editor is over 33,000 lines. Over 13,000 of those lines are interleaved documentation. <p> When working on Ada static semantic checking, we found it useful to include in the WEB source some fragments of relevant documents. The fragments included visibility and overloading rules from the Ada reference manual <ref> [20] </ref> and a presentation of the Ada type system derived from Reference 26. Evaluating WEB Using WEB without help from its developer uncovered a number of problems. Some problems relate to the criteria in References 8 and 9, but others do not.
Reference: [21] <author> Wolfgang Polak. </author> <title> Predicate transformer semantics for Ada. </title> <type> Technical Report 89-39, </type> <institution> Odyssey Research Associates, </institution> <month> September </month> <year> 1989. </year>
Reference-contexts: When a user defines a tree, the editor attributes it. When the user changes the tree, the editor recomputes only those attribute values that have changed [19]. Penelope has two written specifications: the Ada language reference manual and a denotational-style definition of Ada predicate transformers <ref> [20, 21] </ref>. After three years of work, the WEB source for the editor is over 33,000 lines. Over 13,000 of those lines are interleaved documentation. <p> To avoid errors, we used WEB to juxtapose the specification and implementation of each predicate transformer. We used T E X's math mode to write the specifications in the notation of denotational semantics. <ref> [21, 25] </ref>. The right model for a literate program that is being maintained and extended is not the novel but the car repair manual. We began writing new code as an explanation or tutorial for our colleagues, but as the text grew we treated it more like a reference work.
Reference: [22] <author> Carla Marceau and Geoffrey Hird. </author> <title> A verified software implementation of an RS-232 repeater using Penelope. </title> <type> Technical Report 90-12, </type> <institution> Odyssey Research Associates, </institution> <year> 1990. </year>
Reference-contexts: Over 13,000 of those lines are interleaved documentation. The editor has been used to verify a software repeater for an asynchronous communication line and security properties of a part of the ASOS operating system kernel <ref> [22, 23, 24] </ref>. Seven programmers have written WEB source, but no more than four have worked on it at any one time. At this writing, the editor is being extended to support Ada libraries.
Reference: [23] <author> D. G. Weber and Roger L. Costello. </author> <title> Beyond A1 using Ada code verification. </title> <type> Technical Report 89-9, </type> <institution> Odyssey Research Associates, </institution> <month> April </month> <year> 1989. </year>
Reference-contexts: Over 13,000 of those lines are interleaved documentation. The editor has been used to verify a software repeater for an asynchronous communication line and security properties of a part of the ASOS operating system kernel <ref> [22, 23, 24] </ref>. Seven programmers have written WEB source, but no more than four have worked on it at any one time. At this writing, the editor is being extended to support Ada libraries.
Reference: [24] <author> Eric R. Anderson, Ben DiVitto, and Ruth M. Hart. ASOS: </author> <title> Information security for real-time systems. </title> <booktitle> In AFCEA West Intelligence Symposium, </booktitle> <year> 1987. </year>
Reference-contexts: Over 13,000 of those lines are interleaved documentation. The editor has been used to verify a software repeater for an asynchronous communication line and security properties of a part of the ASOS operating system kernel <ref> [22, 23, 24] </ref>. Seven programmers have written WEB source, but no more than four have worked on it at any one time. At this writing, the editor is being extended to support Ada libraries.
Reference: [25] <author> Wolfgang Polak. </author> <title> Program verification based on denotational semantics. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 149-158. </pages> <institution> Association for Computing Machinery, </institution> <year> 1981. </year>
Reference-contexts: To avoid errors, we used WEB to juxtapose the specification and implementation of each predicate transformer. We used T E X's math mode to write the specifications in the notation of denotational semantics. <ref> [21, 25] </ref>. The right model for a literate program that is being maintained and extended is not the novel but the car repair manual. We began writing new code as an explanation or tutorial for our colleagues, but as the text grew we treated it more like a reference work.
Reference: [26] <author> H. Ganzinger and K. </author> <title> Ripken. Operator identification in Ada. </title> <journal> ACM SIG-PLAN Notices, </journal> <volume> 15(2) </volume> <pages> 30-42, </pages> <month> February </month> <year> 1980. </year>
Reference: [27] <author> Jon Bentley. </author> <title> More Programming Pearls: Confessions of a Coder, </title> <booktitle> chapter 10 and 11, </booktitle> <pages> pages 101-126. </pages> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: The order of fragments is the same in the WEB source and in the published document, which simplifies polishing. We found some of WEB's cosmetic features inadequate, others superfluous. Cosmetics should include appropriate media for presenting programs: not just math and tables but also diagrams and figures <ref> [27, 3, 28] </ref>. Describing data structures was hampered by T E X's lack of support for diagrams and pictures. T E X does make it easy to use mathematical notation, which helped considerably in describing predicate transformation, the simplifier, and the proof system used in the proof constructor.
Reference: [28] <author> Robert Sedgewick. </author> <title> Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> second edition, </address> <year> 1988. </year>
Reference-contexts: The order of fragments is the same in the WEB source and in the published document, which simplifies polishing. We found some of WEB's cosmetic features inadequate, others superfluous. Cosmetics should include appropriate media for presenting programs: not just math and tables but also diagrams and figures <ref> [27, 3, 28] </ref>. Describing data structures was hampered by T E X's lack of support for diagrams and pictures. T E X does make it easy to use mathematical notation, which helped considerably in describing predicate transformation, the simplifier, and the proof system used in the proof constructor.
Reference: [29] <author> Stuart I. Feldman. </author> <title> Make|a program for maintaining computer programs. </title> <journal> Software|Practice and Experience, </journal> <volume> 9 </volume> <pages> 255-265, </pages> <year> 1979. </year>
Reference-contexts: A more natural way of indicating structure, like the L A T E X mechanism, would have been welcome. Tools should make it easy to use the structure to help readers extract excerpts from literate programs. WEB works poorly with make <ref> [29] </ref>. TANGLE is designed to read and write a complete program. Some TANGLEs can write multiple files, which can then be compiled separately, but those files all get rewritten every time the WEB source changes, and make therefore recompiles them all.
Reference: [30] <author> Steve C. Johnson. </author> <title> Yacc|yet another compiler compiler. </title> <type> Technical Report 32, </type> <institution> Computer Science, AT&T Bell Laboratories, </institution> <address> Murray Hill, New Jersey, </address> <year> 1975. </year>
Reference-contexts: TANGLE is designed to read and write a complete program. Some TANGLEs can write multiple files, which can then be compiled separately, but those files all get rewritten every time the WEB source changes, and make therefore recompiles them all. This problem is familiar; 5 other preprocessors, like yacc <ref> [30] </ref>, can also cause excessive recompilation. The workaround described on page 265 of Reference 31 works for TANGLE. WEB users may be tempted to break their WEB source into many files and run them through TANGLE separately.
Reference: [31] <author> Brian W. Kernighan and Rob Pike. </author> <title> The UNIX Programming Environment. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1984. </year>
Reference: [32] <author> Norman Ramsey. </author> <title> The Spidery WEB system of structured documentation. </title> <type> Technical Report TR-226-89, </type> <institution> Department of Computer Science, Princeton University, </institution> <month> August </month> <year> 1989. </year> <month> 9 </month>
Reference-contexts: Doing so defeats the purpose of writing a literate program; separate compilation does not necessarily imply separate explanation. For example, one would prefer to place a unit's specification and implementation in the same WEB source, even when they should be compiled separately. Our TANGLE <ref> [32] </ref> emits the #line directive of the C preprocessor, making messages from compilers and debuggers refer to line numbers in the WEB source instead of to those in TANGLE's output. Not all compilers or all TANGLEs support such mechanisms. Renumbering is essential for large programs.
Reference: [33] <author> David Lorge Parnas and Paul C. Clements. </author> <title> A rational design process: How and why to fake it. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(2):251-257, </volume> <month> February </month> <year> 1986. </year> <month> 10 </month>
References-found: 33

