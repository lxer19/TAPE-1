URL: http://www.cs.utexas.edu/users/browne/cs380lf97/hicss.ps
Refering-URL: http://www.cs.utexas.edu/users/browne/cs380lf97/
Root-URL: 
Title: Distributed Programming with Associative Broadcast  
Author: Bryan Bayerdorffer 
Address: Austin, TX 78712  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: We propose a new model for distributed programming, called Associative Broadcast, that achieves a high level of communication abstraction by using as its fundamental mode of communication a form of logical broadcast. Each message contains a predicate that specifies the local states of the objects that are to receive the message, rather than their identifiers. Message delivery is asynchronous and requires no knowledge of the global state. Associative Broadcast exploits the broadcasting capabilities of distributed systems, and enables straightforward specification of state-based communication. We use state-based communication to obtain a new solution to the partitioned-network consistency problem in distributed databases. Keywords: distributed systems, broadcasting, naming mechanisms, communication abstraction. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Bayerdorffer, </author> <title> An analytical taxonomy of naming systems, </title> <institution> Univ. of Texas Dept. of CS Tech. </institution> <note> Report TR-92-48, Dec. 1992, submitted to ACM Trans. on Comp. Sys. </note>
Reference-contexts: A formal treatment of these properties appears in <ref> [1] </ref>. 2.4 Implementation strategy We assume that each object resides at one of a set of host sites that are interconnected by a communication network that supports asynchronous, unordered broadcast. Such networks include broadcast-bus (Ethernet), n-cube, ring, and shared-memory architectures.
Reference: [2] <author> B. Bayerdorffer, </author> <title> Associative Broadcast and the communication sematics of naming in concurrent systems, </title> <type> PhD. dissertation, </type> <institution> Dept. of Computer Sciences, Univ. of Texas at Austin, </institution> <month> Dec. </month> <year> 1993 </year>
Reference-contexts: By broadcasting a probe to a group of objects of indeterminate (including possibly zero) size that have the required attributes, we ensure that the probe is received where necessary without sending it to every object in the system. Additional applications of Associative Broadcast are described in <ref> [2] </ref>. 2 Associative Broadcast Associative Broadcast associates with each object a program-specific, mutable set of attributes, called a profile. All communication is carried out by executing the broadcast primitive, which includes in the outgoing message a sender-specified selector. <p> A formal specification of object behavior and the profile/selector matching mechanism, omitted here to conserve space, may be found in <ref> [2] </ref>. An object begins executing an operation when it receives a message, and receives no subsequent messages until execution of that operation terminates. Each object has an initial state that is determined by initial values of its data structures and an initial profile.
Reference: [3] <author> K. Chandy and L. Lamport, </author> <title> Distributed snapshots: Determining global states of distributed systems, </title> <journal> ACM Trans. on Comp. Sys., </journal> <volume> vol. 3, no. 1, </volume> <month> Feb. </month> <year> 1985 </year>
Reference-contexts: New vertices and edges may be added to the graph by ongoing trans actions while probes are in transit. Probe visitations form a consistent view of the distributed graph, in the spirit of Chandy and Lamport's Distributed Snapshots <ref> [3] </ref>. Since the graph is dynamic, and its edges are partitioned among many objects, it is not trivial for the sender of a given probe to determine which objects should receive the probe. <p> The protocol effectively operates on a set of mutually consistent "distributed snapshots" of the system state, even as the global state is changing, in a manner similar to the general algorithm described in <ref> [3] </ref>. The global state examined by the protocol consists of the local states of the objects at the time each first receives a probe. This global state is consistent 3 , but need not exist at any instant. <p> The simple attribute WRITTEN is added to the profile when data item i is modified. The PARTITION attribute identifies the partition in which the object resided prior to reconnection. 3 The notion of consistency referred to here is that defined in <ref> [3] </ref>, and is distinct from database consistency. 4 Recall that the readset of a transaction contains its writeset.
Reference: [4] <author> S. Davidson, </author> <title> Optimism and consistency in partitioned database systems, </title> <journal> ACM Trans. on Database Systems, </journal> <volume> vol. 9, no. 3, </volume> <month> Sept. </month> <year> 1984 </year>
Reference-contexts: We describe the Associative Broadcast model in section 2, and summarize related work in section 3. In section 4, we use Associative Broadcast to specify a symmetric and fully distributed solution to the partitioned-network consistency problem in replicated databases. This solution is based upon Davidson's Optimistic Protocol <ref> [4] </ref>. Unlike the original protocol, it does not require transaction processing to be halted globally during the recovery phase, nor must transactions that are in progress at the time of recovery be aborted. <p> In section 4.3 we present a distributed version of the well-known optimistic protocol of Davidson <ref> [4] </ref> that relies upon Associative Broadcast to eliminate the centralized control and global freezing of transactions of the original algorithm. 4.1 Original optimistic protocol The Optimistic Protocol is based upon the idea of constructing a precedence graph that captures the partial temporal order of all the transactions in the system between
Reference: [5] <author> S. Davidson and H. Garcia-Molina, </author> <title> Consistency in partitioned networks, </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 17, no. 3, </volume> <month> Sept. </month> <year> 1985 </year>
Reference-contexts: Examples of domains in which such communications arise include distributed simulation (e.g. n-body simulations), distributed constraint satisfaction (parallel execution of logic programs [14]), and consistency protocols for replicated databases (recovery from network partition failures <ref> [5] </ref>). The communication primitives of most distributed programming models are not sufficiently abstract to allow dis fl Author's current address: Computer Science Department, U.S. Naval Academy, Annapolis, MD. tributed, symmetric solutions to these problems to be specified simply and concisely.
Reference: [6] <author> N. Francez and B. Hailpern, </author> <title> Script: a communication abstraction mechanism, </title> <booktitle> Proc. ACM Symp. Principles Distributed Computing, </booktitle> <month> Aug. </month> <year> 1983 </year>
Reference-contexts: This is particularly important where several unrelated computations may coexist: A system in which each object has to be written to handle every possible message type is clearly non-modular. Associative Broadcast extends to communication the principle of abstraction that is commonly applied to data types, synchronization, and control sequencing <ref> [6] </ref>.
Reference: [7] <author> N. Gehani and W. Roome, </author> <title> Concurrent C, </title> <journal> Software Pract. Exper., </journal> <volume> vol. 16, no. 9, </volume> <month> Sep. </month> <year> 1986 </year>
Reference-contexts: However, the BSP model allows only system-wide broadcasts, and leaves it to individual recipients to filter out unwanted messages. Similar message filtering is performed by the selective accept statement of Concurrent C <ref> [7] </ref>, although that language has no built-in broadcast primitives. 4 Example In a replicated database, there exist several copies of each data item, with individual copies residing at distinct sites throughout the system.
Reference: [8] <author> N. Gehani, </author> <title> Broadcasting sequential processes (BSP), </title> <journal> IEEE Trans. Software Eng., </journal> <volume> vol. SE-10, no. 4, </volume> <month> July </month> <year> 1984 </year>
Reference-contexts: It is much easier to specify the intended membership of a target set as a single formula in first-order logic at the originator of a broadcast than it is to repeat the specification at each potential recipient, which is the technique suggested by the BSP model in <ref> [8] </ref>. The code that an object executes to alter its profile is typically significantly simpler than any message-filtering code would be. Placing the specification logic in the domain of the sender also makes it easier to understand existing programs. Associative Broadcast also offers advantages for implementation. <p> Since a process joining or leaving a process group typically involves at least one operation per group, emulating target sets using process groups is potentially very expensive. Gehani's paper on Broadcasting Sequential Processes (BSP) <ref> [8] </ref> contains persuasive arguments in favor of using broadcast primitives to structure concurrent computations. However, the BSP model allows only system-wide broadcasts, and leaves it to individual recipients to filter out unwanted messages.
Reference: [9] <author> D. Gelernter, </author> <title> Generative communication in linda, </title> <journal> ACM Trans. Prog. Languages and Systems, </journal> <volume> vol. 7, no. 1, </volume> <month> Jan. </month> <year> 1985 </year>
Reference-contexts: Perhaps the closest in its ability to express communication at a high level of abstraction is Linda <ref> [9] </ref>, in that it makes use of the concept of pattern matching. Linda differs from Associative Broadcast mainly in its communication semantics and its implementation requirements. The same Linda "message" may be received multiple times by the same process, if the process executed multiple reads with the same pattern.
Reference: [10] <author> D. Jefferson, </author> <title> Virtual time, </title> <journal> ACM Trans. Prog. Languages and Systems, </journal> <volume> vol. 7, no. 3, </volume> <month> July </month> <year> 1985 </year>
Reference-contexts: We have used Associative Broadcast to obtain solutions to complex problems from a range of domains, notably concurrent constraint satisfaction, and the specification of a new synchronization protocol based on virtual time <ref> [10] </ref>. An implementation of an Associative Broadcast prototype on an n-cube network is underway.
Reference: [11] <author> L. Lamport, </author> <title> Time, clocks, and the ordering of events in a distributed system, </title> <journal> CACM, </journal> <volume> vol. 21, no. 7, </volume> <month> July </month> <year> 1978 </year>
Reference-contexts: The broadcast of m is followed in finite time by the logical arrivalof m at every object 2 (including the sender), with events at distinct objects being partially ordered according to the usual notion of causality <ref> [11] </ref>. Let m = ([r]; d : : :). The arrival of m at object o is followed immediately (i.e. without intervening events at o) by the receipt of m at o iff the profile of o satisfies r at the occurrence of the arrival event.
Reference: [12] <author> R. Metcalfe and D. Boggs, </author> <title> Ethernet: distributed packet switching for local computer networks, </title> <journal> Communications of the ACM, </journal> <volume> vol. 19, no. 7, </volume> <month> July </month> <year> 1976 </year>
Reference-contexts: 1 Introduction Many distributed systems support asynchronous message broadcast at a cost that is close to that of sending a message to a single recipient, e.g. using Ethernet <ref> [12] </ref>, cellular radio, or satellite networks.
Reference: [13] <author> J. Mogul, et al., </author> <title> The packet filter: an efficient mechanism for user-level network code, </title> <booktitle> Proc. 11th ACM Symp. Operating Systems Principles, </booktitle> <month> Nov. </month> <year> 1987 </year>
Reference-contexts: Previous work on "packet filters"has shown that low-level per-object filtering is practical, and may in fact improve efficiency by reducing the number of context switches needed to process an incoming mes-sage <ref> [13] </ref>. Since packet filters consist of arbitrary user-supplied code, we expect that on average the matching of a selector to a single profile is considerably more efficient than the execution of a single packet filter.
Reference: [14] <editor> A Takeuchi and K. Furukawa, </editor> <booktitle> Parallel logic programming languages, Proc. 3rd Int. Conf. Logic Prog., </booktitle> <publisher> Springer-Verlag, Berlin, </publisher> <pages> pp. 242-254, </pages> <year> 1986 </year>
Reference-contexts: Examples of domains in which such communications arise include distributed simulation (e.g. n-body simulations), distributed constraint satisfaction (parallel execution of logic programs <ref> [14] </ref>), and consistency protocols for replicated databases (recovery from network partition failures [5]). The communication primitives of most distributed programming models are not sufficiently abstract to allow dis fl Author's current address: Computer Science Department, U.S.
References-found: 14

