URL: http://avalon.cs.ucdavis.edu/gfink/papers/taspec.ps
Refering-URL: http://www.cs.ucdavis.edu/research/tech-reports/1995.html
Root-URL: http://www.cs.ucdavis.edu
Title: An interface language between specifications and testing  
Author: George Fink Michael Helmke Matt Bishop Karl Levitt 
Date: August 16, 1995  
Abstract-found: 0
Intro-found: 1
Reference: [AI91] <author> Derek Andrews and Darrel Ince. </author> <title> Practical Formal Methods with VDM. </title> <publisher> McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: Specification languages such as Z [Dil90] and VDM <ref> [AI91] </ref> can be used to fully specify a system at a more abstract level than source code. The data structures and operations can gradually be made more concrete through refinements to the specification, until at some point the boundary between specification and source code is crossed.
Reference: [Bel89] <author> S. M. Bellovin. </author> <title> Security problems in TCP/IP protocol suite. </title> <journal> Computer Communications Review, </journal> <month> April </month> <year> 1989. </year>
Reference-contexts: TCP/IP is the de-facto standard for Internet communications. Implementations of TCP have several known security flaws that have been well documented elsewhere <ref> [Bel89] </ref>. This example examines the detection of a new security related bug in the TCP driver for 4.4BSD-Lite [Net93]. The TCP protocol is specified as a finite state machine.
Reference: [CM84] <author> W. F. Clocksin and C. S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1984. </year>
Reference-contexts: A built-in predicate sizeof returns this number. In the above example, sizeof (set) would be replaced with the value 2. TASPEC's semantic model is loosely based upon that of Prolog <ref> [CM84] </ref>. The state consists of a collection of facts that are tied together by various predicates. The language for expressing invariants is closely related to constructs in Prolog, because the system was designed with Prolog in mind as the engine for monitoring execution.
Reference: [CRS] <author> Juei Chang, Debra J. Richardson, and Sriram Sankar. </author> <title> Structural specification-based testing with ADL. </title> <note> Submitted to ISSTA 1996 as a Regular Paper. </note>
Reference-contexts: Test data can also be generated from specification artifacts. ADL [San89] [SH94] and TAOS have test description languages whereby test data can be categorized. Once categorization is made, generating exhaustive test data with respect to the structure of the specification is 1 possible <ref> [CRS] </ref>. Prior to this work, similar techniques had been used with VDM [DF93]. Related work has also been done to generate test data from the structure of code such as in [GG75] and [How75].
Reference: [DF93] <author> Jeremy Dick and Alain Faivre. </author> <title> Automating the Generation and Sequencing of Test Cases from Model-Based Specifications, </title> <booktitle> chapter 4, </booktitle> <pages> pages 268-284. </pages> <booktitle> First International Symposium of Formal Methods Europe Proceedings. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: ADL [San89] [SH94] and TAOS have test description languages whereby test data can be categorized. Once categorization is made, generating exhaustive test data with respect to the structure of the specification is 1 possible [CRS]. Prior to this work, similar techniques had been used with VDM <ref> [DF93] </ref>. Related work has also been done to generate test data from the structure of code such as in [GG75] and [How75]. With TASPEC and property-based testing, test oracles can be generated independently of descriptions of specific modules or functions.
Reference: [Dil90] <author> Antoni Diller. </author> <title> Z: An Introduction to Formal Methods. </title> <publisher> John Wiley & Sons, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Specifications describe models that programs are supposed to implement. Testing is used to verify if a program's implementation is correct. Specification languages such as Z <ref> [Dil90] </ref> don't provide ways to relate their model to a program state. Alternatively, the program could be developed independent of the specification, so there is no natural correspondence between specification and code. <p> Prior methods for utilizing specifications in testing fall into three loose categories: specifications to generate test data, specifications to create test oracles (verifying the correctness of an execution), and specifications refined into code (and therefore having direct specification-code relationships that can be measured). Specification languages such as Z <ref> [Dil90] </ref> and VDM [AI91] can be used to fully specify a system at a more abstract level than source code. The data structures and operations can gradually be made more concrete through refinements to the specification, until at some point the boundary between specification and source code is crossed.
Reference: [Fin95] <author> George Fink. </author> <title> Discovering security and safety flaws using property-based testing. </title> <type> PhD thesis, </type> <institution> UC Davis, </institution> <year> 1995. </year>
Reference-contexts: Translations between other specification languages and TASPEC can provide additional flexibility to the specification and testing phases of development. 3 Property-based Testing Property-based testing <ref> [Fin95] </ref> uses specifications of generic properties in the TASPEC language to produce structural tests of specific programs. Through location specifications, properties are associated with code. The code thus designated, and all code related to the designated code, is subject to the testing process.
Reference: [FL94] <author> George Fink and Karl Levitt. </author> <title> Property-based testing of privileged programs. </title> <editor> In Bob Werner, editor, </editor> <booktitle> Tenth Annual Computer Security Applications Conference, </booktitle> <pages> pages 154-163. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1994. </year>
Reference-contexts: Currently operational are static analysis, slicing, and code instrumentation modules. Code can be instrumented both for the purposes of obtaining path coverage information, and also for capturing abstract behavior described in TASPEC. The Tester's Assistant (and TASPEC) has been applied to UNIX security properties and network server code <ref> [FL94] </ref>. 4 The Z Specification Language Z is a formal specification language developed at Oxford University that allows software requirements to be specified using a precise mathematical notation. One of the first industry successes using Z was in specifying portions of IBM's CICS system [Kin92].
Reference: [GG75] <author> John B. Goodenough and Susan L. Gerhart. </author> <title> Toward a theory of test data selection. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1(12):156-173, </volume> <month> June </month> <year> 1975. </year>
Reference-contexts: Prior to this work, similar techniques had been used with VDM [DF93]. Related work has also been done to generate test data from the structure of code such as in <ref> [GG75] </ref> and [How75]. With TASPEC and property-based testing, test oracles can be generated independently of descriptions of specific modules or functions. With the emphasis on properties and not on full specification, test oracles can be made to handle a wider class of behavior than that rigidly defined by functional specifications.
Reference: [GH93] <author> John V. Guttag and James J. Horning. </author> <title> Larch: Langauges and Tools for Formal Specification. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Such a specification could also be used to generate tests; however this is little different from generating tests from the source code due to the shared derivation of code and specification. Test oracles can also be automatically generated from other specification-based approaches such as Larch <ref> [GH93] </ref> and TAOS [RAO92] [Ric94]. Function and procedure behavior is specified as in the refinement methods, but in a separate process from the actual coding. The specifications can then serve as independent test oracles without being influenced by implementation bias.
Reference: [GHM87] <author> John D. Gannon, Richard G. Hamlet, and Har-lan D. Mills. </author> <title> Theory of modules. </title> <journal> IEEE Transactions on Software Engineerin, </journal> <volume> SE-13(7):820-829, </volume> <year> 1987. </year>
Reference-contexts: Such information cannot be automatically determined in most cases <ref> [GHM87] </ref>. 6.2 User Required Information As noted above, the user must provide mappings for names in the specification to names in the implementation. Translation of state schemas requires mappings between schema declarations and program variables. The translator records type information about schema declarations and program variables.
Reference: [GJ] <author> Joshua D. Guttman and Dale M. John-son. </author> <title> Three applications of formal methods at MITRE. </title> <note> Unpublished Notes. </note>
Reference-contexts: Our goal in testing has been finding improper state transitions in the protocol. This goal removed the need for a full specification (such as described in <ref> [GJ] </ref>) which is a great time savings when only a part of a system need be tested. Since only illegal TCP state translations are being tested for, only the TCP state machine is specified (see Figure 5). A specification of this in Z is straightforward and illustrated in Figure 6.
Reference: [Guh95] <author> Biswaroop Guha. </author> <title> Vulnerability analysis of TCP/IP suite. </title> <type> Master's thesis, </type> <institution> University of California at Davis, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: TASPEC can express close correspondences between code and abstract semantics. Large portions of Z are shown to be semi-automatically translatable into TASPEC. Test oracles and other testing artifacts can be derived from TASPEC specifications. As an example, a recently discovered flaw <ref> [Guh95] </ref> in an implementation of the TCP protocol is uncovered using this technique. TASPEC has primitive constructs that enables it to be easily translated into slicing criteria and execution monitors. <p> We will accomplish this by specifying the TCP state machine in Z, translating the specification to TASPEC, and then by applying automated testing tools driven by the TASPEC specification. This testing will demonstrate the existence of a newly discovered bug in the 4.4BSD-Lite source code <ref> [Guh95] </ref>. 7.1 Z Specification for TCP Protocol States This example takes a partial Z specification of TCP and uses it to drive the testing process. Our goal in testing has been finding improper state transitions in the protocol.
Reference: [Hel95] <author> Michael Helmke. </author> <title> A semi-formal approach to the validation of requirements traceability from Z to C. </title> <type> Master's thesis, </type> <institution> UC Davis, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: Data-type translation rules define how Z types map into TASPEC. The operator translation rules define the TASPEC query or state change resulting from a given Z operator. The following describes how Z types are represented in TASPEC. Additional rules are described in <ref> [Hel95] </ref>. Sets are represented as assertable facts. For example, s : P Student becomes s (x). If used in a matching expression, x is bound to some value of the set s.
Reference: [How75] <author> William E. Howden. </author> <title> Methodology for the generation of program test data. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-24(5):554-559, </volume> <month> May </month> <year> 1975. </year>
Reference-contexts: Prior to this work, similar techniques had been used with VDM [DF93]. Related work has also been done to generate test data from the structure of code such as in [GG75] and <ref> [How75] </ref>. With TASPEC and property-based testing, test oracles can be generated independently of descriptions of specific modules or functions. With the emphasis on properties and not on full specification, test oracles can be made to handle a wider class of behavior than that rigidly defined by functional specifications.
Reference: [Jia95] <author> Xiaoping Jia. </author> <title> An approach to animating Z specifications. </title> <booktitle> In Proceedings of the 19th Annual International Computer Software and Applications Conference, </booktitle> <address> Dallas, Texas, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: For each invariant in InvList, perform operator trans lation as previously described. Operator Schema Translation This translation algorithm takes an operational schema and translates to TASPEC. A part of the translation algorithm is inspired by the EX algorithm presented in <ref> [Jia95] </ref>. Translation is performed in two parts: preparation and translation. Both algorithms are shown in Appendix A. The algorithm PrepareSchema is required to take a schema and return a list of precondition predicates and assignment predicates.
Reference: [Kin92] <author> Steve King. </author> <title> Specification Case Studies, </title> <booktitle> chapter The use of Z in the restructure of IBM CICS, </booktitle> <pages> pages 202-213. </pages> <publisher> Prentice Hall, </publisher> <address> New York, New York, </address> <year> 1992. </year> <month> 9 </month>
Reference-contexts: One of the first industry successes using Z was in specifying portions of IBM's CICS system <ref> [Kin92] </ref>. Since then, Z has gained popularity as a formal tool in both industry and academia world-wide. In this paper the following terms are used: Declaration Part refers to the upper half of a schema where data declarations and schema inclusions are located.
Reference: [Net93] <author> Netbsd, </author> <year> 1993. </year> <title> Source code for the TCP network device driver available at ftp://ftp.cdrom.com. </title>
Reference-contexts: TCP/IP is the de-facto standard for Internet communications. Implementations of TCP have several known security flaws that have been well documented elsewhere [Bel89]. This example examines the detection of a new security related bug in the TCP driver for 4.4BSD-Lite <ref> [Net93] </ref>. The TCP protocol is specified as a finite state machine.
Reference: [RAO92] <author> Debra J. Richardson, Stephanie Leif Aha, and T. Owen O'Malley. </author> <title> Specification-based test oracles for reactive systems. </title> <booktitle> In 14th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: Such a specification could also be used to generate tests; however this is little different from generating tests from the source code due to the shared derivation of code and specification. Test oracles can also be automatically generated from other specification-based approaches such as Larch [GH93] and TAOS <ref> [RAO92] </ref> [Ric94]. Function and procedure behavior is specified as in the refinement methods, but in a separate process from the actual coding. The specifications can then serve as independent test oracles without being influenced by implementation bias.
Reference: [Ric94] <author> Debra Richardson. TAOS: </author> <title> Testing with analysis and oracle support. </title> <booktitle> In Proceedings of the 1994 International Symposium on Software Testing and Analysis, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: Such a specification could also be used to generate tests; however this is little different from generating tests from the source code due to the shared derivation of code and specification. Test oracles can also be automatically generated from other specification-based approaches such as Larch [GH93] and TAOS [RAO92] <ref> [Ric94] </ref>. Function and procedure behavior is specified as in the refinement methods, but in a separate process from the actual coding. The specifications can then serve as independent test oracles without being influenced by implementation bias.
Reference: [San89] <author> S. Sankar. </author> <title> Automatic Runtime Consistency Checking and Debugging of Formally Specified Programs. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> August </month> <year> 1989. </year> <institution> Also Stanford University Department of Computer Science Technical Report No. STAN-CS-89-1282, and Computer Systems Laboratory Technical Report No. CSL-TR-89-391. </institution>
Reference-contexts: This linkage can be done easily if the unit of specification is the behavior of individual functions (or modules) in the implementation. Formal parameters can be linked with actual parameters, and so on. Test data can also be generated from specification artifacts. ADL <ref> [San89] </ref> [SH94] and TAOS have test description languages whereby test data can be categorized. Once categorization is made, generating exhaustive test data with respect to the structure of the specification is 1 possible [CRS]. Prior to this work, similar techniques had been used with VDM [DF93].
Reference: [SH94] <author> S. Sankar and R. Hayes. </author> <title> Adl | an interface definition language for specifying and testing software. </title> <type> Technical Report CMU-CS-94-WIDL-1, </type> <institution> Carnegie-Mellon University, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: This linkage can be done easily if the unit of specification is the behavior of individual functions (or modules) in the implementation. Formal parameters can be linked with actual parameters, and so on. Test data can also be generated from specification artifacts. ADL [San89] <ref> [SH94] </ref> and TAOS have test description languages whereby test data can be categorized. Once categorization is made, generating exhaustive test data with respect to the structure of the specification is 1 possible [CRS]. Prior to this work, similar techniques had been used with VDM [DF93].
Reference: [Spi92] <author> J. M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <publisher> Prentice-Hall, London, 2nd ed. </publisher> <address> edition, </address> <year> 1992. </year>
Reference-contexts: Input parameter names end with a ? and output parameter names end with a !. The terms pre-names and post-names refer to the set of undashed and input names and dashed and output names respectively. Additional information about Z may be found in <ref> [Spi92] </ref>, [Wor92],[Dil90]. 5 TASPEC TASPEC was created as a specification interface to property-based testing and the Tester's Assistant. 2 TASPEC needed to be able to describe generic flaws and properties but also needed to have a simple correspondence with code in order for test oracles and property-based coverage criteria to be
Reference: [Wor92] <author> John B. Wordsworth. </author> <title> Software Development with Z. </title> <publisher> Addison-Wesley, </publisher> <address> Workingham, Eng-land, </address> <year> 1992. </year>
Reference-contexts: Call PrepareSchema (P; PreNames; PostNames; PreCond; AssignSeq) for each element P in the sequence Pred. 5. Call TranslateSchema (UserInfo; PreCond; AssignSeq) for each PreCond and AssignSeq assigned from the previous step. The Z specification for this example (see figure 4) is taken from <ref> [Wor92] </ref>. The example is of a database to keep track of whether students are enrolled in a class and whether they have taken a particular test.
References-found: 24

