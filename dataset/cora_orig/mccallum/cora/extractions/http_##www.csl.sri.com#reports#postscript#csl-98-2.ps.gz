URL: http://www.csl.sri.com/reports/postscript/csl-98-2.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Title: Fair Synchronous Transition Systems and their Liveness Proofs  
Author: Amir Pnueli Natarajan Shankar Eli Singerman 
Address: Rehovot, ISRAEL  Menlo Park CA, USA  
Affiliation: Dept. of Applied Math. and CS The Weizmann Institute of Science  Computer Science Laboratory SRI International  
Pubnum: Technical Report SRI-CSL-98-02  
Abstract: We present a compositional semantics of synchronous systems that captures both safety and progress properties of such systems. The fair synchronous transitions systems (fsts) model we introduce in this paper extends the basic ffsts model [KP96] by introducing operations for parallel composition, for the restriction of variables, and by addressing fairness. We introduce a weak fairness (justice) condition which ensures that any communication deadlock in a system can only occur through the need for external synchronization. We present an extended version of linear time temporal logic (eltl) for expressing and proving safety and liveness properties of synchronous specifications, and provide a sound and compositional proof system for it. fl This research was supported in part by the Minerva Foundation, by an infrastructure grant from the Israeli Ministry of Science, by US National Science Foundation grants CCR-9509931 and CCR-9712383, and by US Air Force Office of Scientific Research Contract No. F49620-95-C0044. Part of this research was done as part of the European Community project SACRES (EP 20897). The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of NSF, AFOSR, the European Union, or the U.S. Government. We are grateful to Sam Owre for lending assistance with PVS. 
Abstract-found: 1
Intro-found: 1
Reference: [AL95] <author> M. Abadi and L. Lamport. </author> <title> Conjoining Specifications. </title> <journal> TOPLAS, </journal> <volume> 17(3), </volume> <pages> pages 507-534, </pages> <year> 1995. </year>
Reference-contexts: The use of weak fairness constraints ensures that a module can satisfy these constraints without the cooperation of the environment, i.e., the module is receptive <ref> [AL95] </ref>. The fsts model, the compositionality proofs, the extended linear temporal logic, and the accompanying soundness proofs have all been formally verified using PVS [Ow95].
Reference: [BGA97] <author> A. Benveniste, P. Le Guernic, and P. Aubry. </author> <title> Compositionality in dataflow synchronous languages: specification & code generation. </title> <booktitle> Proceedings of COMPOS'97. </booktitle> <pages> 21 </pages>
Reference-contexts: The ffsts model has been used as a common semantic domain for both Signal programs and the C-code generated by compiling them, for proving the correctness of the translation (compilation) [PSS98]. It has also been used in <ref> [BGA97] </ref> as a semantics which is "...fully general to capture the essence of the synchronous paradigm." The fsts model presented here extends ffsts by introducing operations for parallel composition, for the restriction of variables, and by addressing fairness.
Reference: [BGJ91] <author> A. Benveniste, P. Le Guernic, and C. Jacquemot. </author> <title> Synchronous programming with event and relations: the SIGNAL language and its semantics. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 16, </volume> <pages> pages 103-149, </pages> <year> 1991. </year>
Reference-contexts: Such a unifying semantic model can be used to specify the temporal behavior of synchronous systems and to relate different synchronous system descriptions. There are two major classes of synchronous languages [H93]. The imperative languages like Esterel [BG92] and Statecharts [Har87], and declarative languages like Lustre [CHPP87] and Signal <ref> [BGJ91] </ref>. <p> output boolean emptyg = synchro (when (zn = 0)); fill j n := (10 when fill ) default (zn 1) j zn := n $ init 0 j empty := when (n = 0) default (not fill ) Example In Fig. 5, we present a Signal program example, taken from <ref> [BGJ91] </ref>. We simplified the program to make it more self-contained. This small program models a system with a replenishable resource, for example, a water reservoir. The input event fill signals that that the reservoir is filled to the top. The local integer variable n measures the current water level.
Reference: [BG92] <author> G. Berry and G. Gonthier. </author> <title> The ESTEREL Synchronous Program ming Language: Design, semantics, </title> <booktitle> implementation. Science of Computer Programming, </booktitle> <volume> 19(2), </volume> <year> 1992. </year>
Reference-contexts: Such a unifying semantic model can be used to specify the temporal behavior of synchronous systems and to relate different synchronous system descriptions. There are two major classes of synchronous languages [H93]. The imperative languages like Esterel <ref> [BG92] </ref> and Statecharts [Har87], and declarative languages like Lustre [CHPP87] and Signal [BGJ91].
Reference: [CHPP87] <author> P. Caspi, N. Halbwachs, D. Pilaud, and J. Plaice. LUSTRE, </author> <title> a Declarative Language for Programming Synchronous Systems. POPL'87, </title> <publisher> ACM Press, </publisher> <pages> pages 178-188, </pages> <year> 1987. </year>
Reference-contexts: Such a unifying semantic model can be used to specify the temporal behavior of synchronous systems and to relate different synchronous system descriptions. There are two major classes of synchronous languages [H93]. The imperative languages like Esterel [BG92] and Statecharts [Har87], and declarative languages like Lustre <ref> [CHPP87] </ref> and Signal [BGJ91].
Reference: [H93] <author> N. Halbwachs. </author> <title> Synchronous Programming of Reactive Systems. </title> <publisher> Kluwer, </publisher> <address> Dordrecht, The Netherlands, </address> <year> 1993. </year>
Reference-contexts: Such a unifying semantic model can be used to specify the temporal behavior of synchronous systems and to relate different synchronous system descriptions. There are two major classes of synchronous languages <ref> [H93] </ref>. The imperative languages like Esterel [BG92] and Statecharts [Har87], and declarative languages like Lustre [CHPP87] and Signal [BGJ91].
Reference: [Har87] <author> D. Harel. Statecharts: </author> <title> A Visual Formalism for Complex Systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8, </volume> <pages> pages 231-274, </pages> <year> 1987. </year>
Reference-contexts: Such a unifying semantic model can be used to specify the temporal behavior of synchronous systems and to relate different synchronous system descriptions. There are two major classes of synchronous languages [H93]. The imperative languages like Esterel [BG92] and Statecharts <ref> [Har87] </ref>, and declarative languages like Lustre [CHPP87] and Signal [BGJ91].
Reference: [KP96] <author> Y. Kesten and A. Pnueli. </author> <title> An ffsts-based common semantics for signal and statecharts, </title> <month> March </month> <year> 1996. </year> <note> Sacres Manuscript. </note>
Reference-contexts: In this paper, we present a compositional semantics of synchronous systems that captures both safety and progress properties of such systems. The semantics is given in terms of the model of fair synchronous transitions systems (fsts), which is based on the ffsts model <ref> [KP96] </ref>. The ffsts model has been used as a common semantic domain for both Signal programs and the C-code generated by compiling them, for proving the correctness of the translation (compilation) [PSS98]. <p> We denote by the set of all states. For a subset of variables V V, we define a V -state to be a type-consistent interpretation of V . Following [MP91] and <ref> [KP96] </ref>, we define a fair synchronous transition system (fsts) to be a system : hV; fi; ; E; Si; consisting of the following components: * V : A finite set of typed system variables. * fi : The initial condition. <p> no extra cost, since the predicate ready (p) is equivalent to the CTL formula EXp which every model checker knows how to compute very efficiently. 5 The fsts semantics of Signal As mentioned in the introduction, the fsts model is a significant extension of the previous, more basic, ffsts model <ref> [KP96] </ref> obtained by introducing operations (parallel composition and restriction) and by addressing fairness. <p> Nevertheless, to make the paper more self-contained, we present below the translation given by Kesten and Pnueli <ref> [KP96] </ref>. For a variable v, clocked (v) denotes the assertion: clocked (v) : v 6= ? In the following, we describe how to construct an fsts P corresponding to a given Signal program P .
Reference: [MP91] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Con current Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: We denote by the set of all states. For a subset of variables V V, we define a V -state to be a type-consistent interpretation of V . Following <ref> [MP91] </ref> and [KP96], we define a fair synchronous transition system (fsts) to be a system : hV; fi; ; E; Si; consisting of the following components: * V : A finite set of typed system variables. * fi : The initial condition.
Reference: [Ow95] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal Verifi cation for Fault-Tolerant Architectures: Prolegomena to the Design of PVS. </title> <journal> IEEE trans. on software eng., </journal> <volume> 21(2), </volume> <pages> pages 107-125, </pages> <year> 1995. </year>
Reference-contexts: The use of weak fairness constraints ensures that a module can satisfy these constraints without the cooperation of the environment, i.e., the module is receptive [AL95]. The fsts model, the compositionality proofs, the extended linear temporal logic, and the accompanying soundness proofs have all been formally verified using PVS <ref> [Ow95] </ref>. The PVS verification pointed out a number of gaps in our earlier formalization and led to sharper definitions of the basic concepts, and 5 elegant and rigorous proofs. 1 The paper is organized as follows. In Section 2 we introduce the fsts computational model.
Reference: [PSS98] <author> A. Pnueli, M. Siegel, and E. Singerman. </author> <title> Translation Validation. </title> <publisher> TACAS'98, LNCS, </publisher> <year> 1998. </year> <month> 22 </month>
Reference-contexts: The ffsts model has been used as a common semantic domain for both Signal programs and the C-code generated by compiling them, for proving the correctness of the translation (compilation) <ref> [PSS98] </ref>. It has also been used in [BGA97] as a semantics which is "...fully general to capture the essence of the synchronous paradigm." The fsts model presented here extends ffsts by introducing operations for parallel composition, for the restriction of variables, and by addressing fairness.
References-found: 11

