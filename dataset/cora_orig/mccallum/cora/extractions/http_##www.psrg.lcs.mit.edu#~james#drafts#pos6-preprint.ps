URL: http://www.psrg.lcs.mit.edu/~james/drafts/pos6-preprint.ps
Refering-URL: http://www.psrg.lcs.mit.edu/ftpdir/pub/james/papers/osdi-distrib/README.html
Root-URL: 
Title: Hybrid Caching for Scalable Object Systems (Think Globally, Act Locally)  
Author: James O'Toole Liuba Shrira 
Address: Cambridge, Massachusetts, USA  Cambridge, Massachusetts, USA  
Affiliation: Massachusetts Institute of Technology  Massachusetts Institute of Technology  
Abstract: Object-based client caching allows clients to keep more frequently accessed objects while discarding colder objects that reside on the same page. However, when these objects are modified and sent to the server, it may need to read the corresponding page from disk to install the update. These installation reads are not required with a page-based cache because whole pages are sent to the server. We describe a hybrid system that permits clients to cache objects and pages. The system uses a simple cache design that combines the best of object caching and page caching. The client increases its cache hit ratio as in object-based caching. The client avoids some installation reads by sending pages to the server when possible. Using simulated workloads we explore the performance of our design and show that it can offer a significant performance improvement over both pure object caching and pure page caching on a range of workloads.
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Using the EXODUS Storage Manager V2.0.0. </institution> <type> Technical report, </type> <institution> Department of Computer Sciences, University of Wisconsin-Madison, </institution> <month> January </month> <year> 1982. </year> <type> Technical documentation. </type>
Reference-contexts: Many persistent object systems use the more traditional page based architecture where all interaction between clients and servers takes place at the granularity of individual pages <ref> [7, 11, 12, 1] </ref>. Other systems [9, 5] use object server architectures but do not specifically address the problem of installation reads. Dewitt et. al. [6] is one of the first studies that investigated the design choices for a persistent object system architecture.
Reference: [2] <author> Atul Adya. </author> <title> A distributed commit protocol for optimistic concurrency control. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Our focus is on disk performance, so we are ignoring these issues here. Transaction Validation We assume a server architecture similar to that of the Thor persistent object system [10]. The features that we assume are optimistic concurrency control with in-memory commit <ref> [2] </ref>. If the client and server are using a page-based architecture, then we assume that the page server also uses optimistic concur-rency control and in-memory commit. The server uses a concurrency control scheme ensuring that all committing transactions are serialized and that client caches are "almost" up-to-date. <p> The server uses a concurrency control scheme ensuring that all committing transactions are serialized and that client caches are "almost" up-to-date. Committing transactions are validated by the server using a method that does not require disk access; see Adya <ref> [2] </ref> for the details. We use an optimistic con-currency control scheme, so a transaction that reads stale objects is aborted when the server rejects its commit request.
Reference: [3] <author> Jia bing R. Cheng and A. R. Hurson. </author> <title> On the performance issues of object-based buffering. </title> <booktitle> In Proceedings of the Conference on Parallel and Distributed Information Systems, </booktitle> <pages> pages 30-37, </pages> <year> 1991. </year>
Reference-contexts: Similarly, Cheng and Hurson <ref> [3] </ref> demonstrated how an object server architecture can enable more efficient client cache utilization. Numerous studies [4, 16, 8, 17] have addressed issues related to comparing object and page based client cache designs, emphasizing the importance of pointer swizzling costs to the client.
Reference: [4] <author> M. Day. </author> <title> Managing a Cache of Swizzled Objects and Surrogates. </title> <type> PhD thesis, </type> <note> miteecs, In preparation. </note>
Reference-contexts: Similarly, Cheng and Hurson [3] demonstrated how an object server architecture can enable more efficient client cache utilization. Numerous studies <ref> [4, 16, 8, 17] </ref> have addressed issues related to comparing object and page based client cache designs, emphasizing the importance of pointer swizzling costs to the client. Some of these studies considered using hybrid approaches. <p> hybrid object and page based client cache design in light of the cost imposed by installation reads on the server disk. 8 Conclusion Previous studies considered the tradeoffs in the performance of an object and page based client cache in terms of the cost of in memory data structure manipulation <ref> [4, 16, 8, 17] </ref> and in terms of recovery cost [16]. In a scalable object system, client cache design has important effects on the disk load at the server [13]. We explored a cache design that takes in account a previously overlooked aspect of the server disk load: installation reads.
Reference: [5] <author> O. </author> <title> Deux et al. </title> <journal> The story of o 2 . IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 91-108, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Many persistent object systems use the more traditional page based architecture where all interaction between clients and servers takes place at the granularity of individual pages [7, 11, 12, 1]. Other systems <ref> [9, 5] </ref> use object server architectures but do not specifically address the problem of installation reads. Dewitt et. al. [6] is one of the first studies that investigated the design choices for a persistent object system architecture.
Reference: [6] <author> David J. DeWitt, Philippe Futtersack, David Maier, and Fernando Velez. </author> <title> A study of three alternative workstation-server architectures for object oriented database systems. </title> <booktitle> In Proceedings of the 16th Conference on Very Large Data Bases, </booktitle> <pages> pages 107-121, </pages> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: Other systems [9, 5] use object server architectures but do not specifically address the problem of installation reads. Dewitt et. al. <ref> [6] </ref> is one of the first studies that investigated the design choices for a persistent object system architecture. The study focused on the question of distributing the functionality of the persistent object system between the client and the server.
Reference: [7] <author> M. Hornick and S. Zdonik. </author> <title> A Shared, Segmented Memory System for an Object-Oriented Database, </title> <address> pages 273-285. </address> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: Many persistent object systems use the more traditional page based architecture where all interaction between clients and servers takes place at the granularity of individual pages <ref> [7, 11, 12, 1] </ref>. Other systems [9, 5] use object server architectures but do not specifically address the problem of installation reads. Dewitt et. al. [6] is one of the first studies that investigated the design choices for a persistent object system architecture.
Reference: [8] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Object fault handling for persistent programming languages: A performance evaluation. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <pages> pages 288-303, </pages> <year> 1993. </year>
Reference-contexts: Similarly, Cheng and Hurson [3] demonstrated how an object server architecture can enable more efficient client cache utilization. Numerous studies <ref> [4, 16, 8, 17] </ref> have addressed issues related to comparing object and page based client cache designs, emphasizing the importance of pointer swizzling costs to the client. Some of these studies considered using hybrid approaches. <p> hybrid object and page based client cache design in light of the cost imposed by installation reads on the server disk. 8 Conclusion Previous studies considered the tradeoffs in the performance of an object and page based client cache in terms of the cost of in memory data structure manipulation <ref> [4, 16, 8, 17] </ref> and in terms of recovery cost [16]. In a scalable object system, client cache design has important effects on the disk load at the server [13]. We explored a cache design that takes in account a previously overlooked aspect of the server disk load: installation reads.
Reference: [9] <author> W. Kim et al. </author> <title> Architecture of the orion next-generation database system. </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 109-124, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Many persistent object systems use the more traditional page based architecture where all interaction between clients and servers takes place at the granularity of individual pages [7, 11, 12, 1]. Other systems <ref> [9, 5] </ref> use object server architectures but do not specifically address the problem of installation reads. Dewitt et. al. [6] is one of the first studies that investigated the design choices for a persistent object system architecture.
Reference: [10] <author> B. Liskov, M. Day, and L. Shrira. </author> <title> Distributed object management in Thor. </title> <editor> In M. Tamer Ozsu, Umesh Dayal, and Patrick Valduriez, editors, </editor> <booktitle> Distributed Object Management. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, Califor-nia, </address> <year> 1993. </year>
Reference-contexts: There are also other issues that complicate matters: swizzling, object prefetching, object clustering strategies, etc. Our focus is on disk performance, so we are ignoring these issues here. Transaction Validation We assume a server architecture similar to that of the Thor persistent object system <ref> [10] </ref>. The features that we assume are optimistic concurrency control with in-memory commit [2]. If the client and server are using a page-based architecture, then we assume that the page server also uses optimistic concur-rency control and in-memory commit.
Reference: [11] <author> D. Maier and J. Stein. </author> <title> Development and implementation of an object-oriented dbms. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Many persistent object systems use the more traditional page based architecture where all interaction between clients and servers takes place at the granularity of individual pages <ref> [7, 11, 12, 1] </ref>. Other systems [9, 5] use object server architectures but do not specifically address the problem of installation reads. Dewitt et. al. [6] is one of the first studies that investigated the design choices for a persistent object system architecture.
Reference: [12] <institution> MA Object Design Inc., </institution> <month> Burlingtom. </month> <title> An introduction to object store, release 1.0. </title> <year> 1989. </year>
Reference-contexts: Many persistent object systems use the more traditional page based architecture where all interaction between clients and servers takes place at the granularity of individual pages <ref> [7, 11, 12, 1] </ref>. Other systems [9, 5] use object server architectures but do not specifically address the problem of installation reads. Dewitt et. al. [6] is one of the first studies that investigated the design choices for a persistent object system architecture.
Reference: [13] <author> James O'Toole and Liuba Shrira. </author> <title> Opportunistic Log: Efficient Reads in a Reliable Object Server. </title> <type> Technical Report MIT/LCS-TM-506, </type> <month> March </month> <year> 1994. </year> <note> Submitted for publication, available via FTP from psrg.lcs.mit.edu, directory pub/james/papers, filename asplos-submission.ps. </note>
Reference-contexts: To install the modified object onto its containing page, the server may need to read the page from the disk if it is not present in the server cache. In a previous study <ref> [13] </ref> we have shown that the cost of these installation reads can be significant. In this paper we present a design of a hybrid cache that manages at the client both pages and objects. <p> Client cache performance is the dominant factor that we consider because our focus is on reducing the disk load at the server. Our own recent work shows that in an object-based architecture, installation reads can be a significant source of disk load at the server <ref> [13] </ref>. Client Caching In a persistent object system, clients fetch data from a server and operate on it in a local cache. In an object-based architecture, clients fetch objects, update them, and send back updated objects in a commit request to the server. <p> Note that installing an object modification may require a disk read if the corresponding page is not in the server cache. In recent work, we found that these installation reads have a large impact on the performance of reliable object servers <ref> [13] </ref>. We also showed that their cost can be significantly reduced by processing the log opportunisticly. <p> This allows clients to selectively retain some objects from a page and discard the others, or to keep a page intact. Our own recent work shows that in an object-based architecture, installation reads can be a significant source of disk load at the server <ref> [13] </ref>. In a hybrid system, clients may be able to take advantage of increased cache memory utilization while also avoiding some installation reads. 3.1 Hybrid Server To enable the client to cache pages, the server must provide whole pages to the client when responding to fetch requests. <p> The server selects the pending installation from the log opportunisticly, as described in previous work. An installation read is initiated for the page that has the shortest positioning time <ref> [13] </ref>. Whenever a page enters the cache, whether due to a disk read or from the client, all modified objects that belong to that page are installed onto it. <p> This is due to the effect of the opportunistic log <ref> [13] </ref>. Without this improvement, the object system would have had much worse performance than the page system. <p> In a scalable object system, client cache design has important effects on the disk load at the server <ref> [13] </ref>. We explored a cache design that takes in account a previously overlooked aspect of the server disk load: installation reads. We proposed that after first optimizing the client cache to reduce the disk load due to fetches, it is then important to concentrate on avoiding unnecessary installation reads.
Reference: [14] <author> Chris Ruemmler and John Wilkes. </author> <title> Modelling disks. </title> <type> Technical Report HPL-93-68rev1, </type> <institution> Hewlett-Packard Laboratories, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: The disk geometry and other performance characteristics are taken from the HP97560 drive described by Wilkes <ref> [14] </ref>. We chose this disk because it is simple, accurate, and available.
Reference: [15] <author> M. Seltzer, P. Chen., and J. Ousterhout. </author> <title> Disk scheduling revisited. </title> <booktitle> In Proceedings of Winter USENIX, </booktitle> <year> 1990. </year>
Reference-contexts: The server then sends a confirming message to the client. When the number of dirty pages in the cache exceeds the Write-trigger threshold, the server writes one dirty page to the disk. The page is selected using the shortest positioning time algorithm <ref> [15] </ref>.
Reference: [16] <author> Seth J. White and David J. DeWitt. </author> <title> A performance study of alternative object faulting and pointer swizzling strategies. </title> <booktitle> In Proceedings of the 18th VLDB Conference, </booktitle> <pages> pages 419-431, </pages> <year> 1992. </year>
Reference-contexts: Similarly, Cheng and Hurson [3] demonstrated how an object server architecture can enable more efficient client cache utilization. Numerous studies <ref> [4, 16, 8, 17] </ref> have addressed issues related to comparing object and page based client cache designs, emphasizing the importance of pointer swizzling costs to the client. Some of these studies considered using hybrid approaches. <p> hybrid object and page based client cache design in light of the cost imposed by installation reads on the server disk. 8 Conclusion Previous studies considered the tradeoffs in the performance of an object and page based client cache in terms of the cost of in memory data structure manipulation <ref> [4, 16, 8, 17] </ref> and in terms of recovery cost [16]. In a scalable object system, client cache design has important effects on the disk load at the server [13]. We explored a cache design that takes in account a previously overlooked aspect of the server disk load: installation reads. <p> of the cost imposed by installation reads on the server disk. 8 Conclusion Previous studies considered the tradeoffs in the performance of an object and page based client cache in terms of the cost of in memory data structure manipulation [4, 16, 8, 17] and in terms of recovery cost <ref> [16] </ref>. In a scalable object system, client cache design has important effects on the disk load at the server [13]. We explored a cache design that takes in account a previously overlooked aspect of the server disk load: installation reads.
Reference: [17] <author> Paul R. Wilson. </author> <title> Pointer swizzling at page fault time: Efficiently supporting huge address spaces on standard hardware. </title> <journal> Computer Architecture News, </journal> <volume> 19(4) </volume> <pages> 6-13, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Similarly, Cheng and Hurson [3] demonstrated how an object server architecture can enable more efficient client cache utilization. Numerous studies <ref> [4, 16, 8, 17] </ref> have addressed issues related to comparing object and page based client cache designs, emphasizing the importance of pointer swizzling costs to the client. Some of these studies considered using hybrid approaches. <p> hybrid object and page based client cache design in light of the cost imposed by installation reads on the server disk. 8 Conclusion Previous studies considered the tradeoffs in the performance of an object and page based client cache in terms of the cost of in memory data structure manipulation <ref> [4, 16, 8, 17] </ref> and in terms of recovery cost [16]. In a scalable object system, client cache design has important effects on the disk load at the server [13]. We explored a cache design that takes in account a previously overlooked aspect of the server disk load: installation reads.
References-found: 17

