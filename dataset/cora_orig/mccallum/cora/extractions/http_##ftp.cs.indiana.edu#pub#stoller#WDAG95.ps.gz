URL: http://ftp.cs.indiana.edu/pub/stoller/WDAG95.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/stoller.html
Root-URL: http://www.cs.indiana.edu
Email: stoller@cs.cornell.edu, fbs@cs.cornell.edu  
Title: Faster Possibility Detection by Combining Two Approaches  
Author: Scott D. Stoller and Fred B. Schneider 
Address: Ithaca, NY 14853, USA.  
Affiliation: Dept. of Computer Science, Cornell University,  
Abstract: A new algorithm is presented for detecting whether a particular computation of an asynchronous distributed system satisfies Poss (read "possibly "), meaning the system could have passed through a global state satisfying . Like the algorithm of Cooper and Marzullo, may be any global state predicate; and like the algorithm of Garg and Waldecker, Poss is detected quite efficiently if has a certain structure. The new algorithm exploits the structure of some predicates not handled by Garg and Waldecker's algorithm to detect Poss more efficiently than is possible with any algorithm that, like Cooper and Marzullo's, evaluates on every global state through which the system could have passed. A second algorithm is also presented for off-line detection of Poss . It uses Strassen's scheme for fast matrix multiplication. The intrinsic complexity of off-line and on-line detection of Poss is discussed. 
Abstract-found: 1
Intro-found: 1
Reference: [AHU74] <author> Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman. </author> <title> The design and analysis of computer algorithms. </title> <publisher> Addison Wesley, </publisher> <year> 1974. </year>
Reference-contexts: Then = (9ff 1 ; ff 3 2 [1::S] : 13 (ff 1 ; ff 3 ) ^ OE 0 Using Strassen's matrix-multiplication algorithm, the matrix representing 13 can be computed with time complexity fi (S log 2 7 ) <ref> [Str69, AHU74] </ref>. 5 By the naive algorithm, the truth of can then be determined in fi (S 2 ) time. Thus, this algorithm detects Poss M with worst-case time complexity fi (S log 2 7 + S 2 ), or approximately fi (S 2:81 ). <p> Proof. This problem is a special case of the clique problem, which is in NP, so this problem is also in NP. The reduction from satisfiability to the clique problem given by Aho, Hopcroft, and Ullman <ref> [AHU74, pp. 384-386] </ref> has the property that it maps all instances of 3-satisfiability into instances of the clique problem in which the graph is k-partite with jV i j 3. Thus, their reduction shows that the k-partite clique problem with jV i j 3 is NP-hard. ut Theorem 8.
Reference: [BDG88] <author> Jose Luis Balcazar, Josep Diaz, and Joaquim Gabarro. </author> <title> Structural Complexity I. </title> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: However, many properties can not be so expressed. In this paper, we show how to combine Garg and Waldecker's approach with 2 We use standard "order-of-magnitude" symbols O, , and fi. For definitions, see <ref> [BDG88, sec. 2.2] </ref>, whose only idiosyncrasy is using 1 for the operator commonly denoted . any algorithm that constructs the lattice to detect Poss . The result is a new algorithm that has the best features of both and improves on each.
Reference: [BM93] <author> Ozalp Babaoglu and Keith Marzullo. </author> <title> Consistent global states of distributed systems: Fundamental concepts and mechanisms. In Sape Mullender, editor, </title> <journal> Distributed Systems, </journal> <volume> chapter 5, </volume> <pages> pages 97-145. </pages> <publisher> Addison Wesley, </publisher> <editor> 2nd ed., </editor> <year> 1993. </year>
Reference-contexts: Constraining the Search of c #F . Given a state g 1 of c#F , one can compute for each process in F the maximal range of local states of that process that are concurrent with g 1 <ref> [BM93, sec. 4.14.3] </ref>. This information can be exploited in PDDA by restricting the search of c#F so that only local states in these ranges are examined. 3.6 On-line Algorithm The algorithms in [DJR93, JMN95] for computing CGS (c) have on-line versions with the same time complexities as given above.
Reference: [CG94] <author> Craig M. Chase and Vijay K. Garg. </author> <title> On techniques and their limitations for the global predicate detection problem in distributed systems. </title> <type> Technical Report ECE-PDS-1994-04, </type> <institution> Parallel and Distributed Systems Laboratory, University of Texas at Austin, </institution> <year> 1994. </year>
Reference-contexts: To check optimality of any algorithm for detecting Poss , we must determine the intrinsic complexity of the problem. Chase and Garg took a step in this direction by proving that detecting Poss is NP-complete even when restricted to communication-free computations with S 2 <ref> [CG94] </ref>. We advocate characterizing the complexity of detecting Poss for particular classes of formulas . Since conjunctions of 1-local predicates can be detected in polynomial time [GW94], it is natural to ask about the complexity of detecting conjunctions of 2-local predicates.
Reference: [CM91] <author> Robert Cooper and Keith Marzullo. </author> <title> Consistent detection of global predicates. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, 1991. Appeared as ACM SIGPLAN Notices 26(12) </booktitle> <pages> 167-174, </pages> <month> Decem-ber </month> <year> 1991. </year> <title> 6 There are non-linear lower bounds for dynamic (i.e., on-line) graph connectivity problems [FH94]. However, the proofs of these lower bounds depend crucially on the fact that edges can be both added and deleted, while in the on-line version of our clique problem, edges are added but never deleted. </title>
Reference-contexts: This leads to an obvious difficulty for detecting whether a global state predicate (hereafter simply called a "predicate") held. Cooper and Marzullo's solution to this difficulty involves two modalities, which we denote by Poss (read "possibly") and Def (read "definitely") <ref> [CM91] </ref>. These modalities are based on logical time [Lam78] as embodied in the happened-before relation !, a partial order on events that reflects causal dependencies. <p> A computation satisfies Def iff, in all histories consistent with that computation, the system passes through a global state satisfying . Cooper and Marzullo give centralized algorithms for detecting Poss and Def for an arbitrary predicate <ref> [CM91] </ref>. A stub at each process reports the local states of that process to a central monitor. The central monitor incrementally constructs a lattice to represent the set of histories consistent with the computation. A straightforward search of the lattice reveals whether the computation satisfies Poss or Def . <p> Any detection algorithm that constructs the entire lattice| whether it uses the method in <ref> [CM91, MN91] </ref> or the more efficient schemes in [DJR93, JMN95]|has worst-case time complexity that is at least linear in the size of the lattice. Thus, Cooper and Marzullo's algorithms for detecting Poss and Def have worst-case time complexity (S N ). <p> The definition of CGS (c) in terms of k is more convenient for reasoning about detection algorithms, so we take it as primary. 3 Detection Algorithm 3.1 Specification The formal definition of Poss is <ref> [CM91] </ref> c j= Poss iff (9g : g 2 CGS (c) ^ (g)): (4) The off-line detection problem for Poss is: given a computation c and a predicate , determine whether c j= Poss holds.
Reference: [CW87] <author> D. Coppersmith and S. Winograd. </author> <title> Matrix multiplication via arithmetic pro-gressions. </title> <booktitle> In Conference Proceedings of the 19th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 1-6, </pages> <year> 1987. </year>
Reference-contexts: This 5 Any matrix-multiplication algorithm can be used. We phrase our remarks in terms of Strassen's algorithm, even though asymptotically faster algorithms exist <ref> [CW87] </ref>, because Strassen's algorithm is relatively simple and well-known. analysis does not distinguish algorithms that are asymptotically faster on cer-tain predicates. For example, to characterize the advantage of PDDA GW over Cooper and Marzullo's algorithm, one must consider the worst-case complexity of both algorithms on various classes of predicates.
Reference: [DJR93] <author> Claire Diehl, Claude Jard, and Jean-Xavier Rampon. </author> <title> Reachability analysis on distributed executions. </title> <editor> In J.-P. Jouannaud and M.-C. Gaudel, editors, </editor> <booktitle> TAPSOFT '93: Theory and Practice of Software Development, volume 668 of Lecture Notes in Computer Science, </booktitle> <pages> pages 629-643. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Any detection algorithm that constructs the entire lattice| whether it uses the method in [CM91, MN91] or the more efficient schemes in <ref> [DJR93, JMN95] </ref>|has worst-case time complexity that is at least linear in the size of the lattice. Thus, Cooper and Marzullo's algorithms for detecting Poss and Def have worst-case time complexity (S N ). Because the time needed to construct the lattice can be prohibitive, researchers have sought faster detection algorithms. <p> The following analysis shows that a minimum-sized fixed set should be used. The set CGS (c#F ) can be built with worst-case time complexity O (jF j jCGS (c#F )j + jF j 3 S 2 ) using the algorithm in <ref> [DJR93] </ref>, or slightly faster using the algorithm in [JMN95]. For each state g 1 in CGS (c#F ), Garg and Waldecker's algorithm detects c #F j= Poss g 1 with worst-case time complexity O (jF j 2 S). <p> This information can be exploited in PDDA by restricting the search of c#F so that only local states in these ranges are examined. 3.6 On-line Algorithm The algorithms in <ref> [DJR93, JMN95] </ref> for computing CGS (c) have on-line versions with the same time complexities as given above. The same is true of Garg and Waldecker's algorithm.
Reference: [FH94] <author> Michael L. Fredman and Monika Rauch Henzinger. </author> <title> Lower bounds for dynamic connectivity problems in graphs. </title> <type> Technical Report TR 94-1420, </type> <institution> Cornell University, </institution> <month> April </month> <year> 1994. </year> <note> Also appeared in extended abstract: </note> <author> Monika Rauch. </author> <title> Improved Data Structures for Fully Dynamic Biconnectivity. </title> <booktitle> In Proc. 26th Annual Symposium on Theory of Computing (STOC '94), </booktitle> <pages> pages 686-695, </pages> <year> 1994. </year>
Reference: [Fid88] <author> C. Fidge. </author> <title> Timestamps in message-passing systems that preserve the partial ordering. </title> <booktitle> In Proceedings of the 11th Australian Computer Science Conference, </booktitle> <pages> pages 56-66, </pages> <year> 1988. </year>
Reference-contexts: CCR-9014363, NASA/DARPA grant NAG-2-893, and AFOSR grant F49620-94-1-0198. Any opinions, findings, and conclusions or recommendations expressed in this pub lication are those of the authors and do not reflect the views of these agencies. vector clocks <ref> [Fid88, Mat89] </ref>, it|hence the computation|can be determined by processes in the system. Happened-before is not a total order, so it does not uniquely determine the history. But it does restrict the possibilities.
Reference: [FR94] <author> Eddy Fromentin and Michel Raynal. </author> <title> Inevitable global states: a concept to detect properties of distributed computations. Internal Publication PI-842, </title> <publisher> IRISA, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: Thus, Cooper and Marzullo's algorithms for detecting Poss and Def have worst-case time complexity (S N ). Because the time needed to construct the lattice can be prohibitive, researchers have sought faster detection algorithms. One approach has been to change the problem|for example, detecting a different modality <ref> [FR94] </ref> or assuming that the system is partially synchronous [MN91]. Another approach has been to restrict the problem and develop efficient algorithms for detecting only certain classes of predicates [GW92, GW94, TG94]. Our work is inspired by an algorithm of Garg and Waldecker for a restricted problem [GW94].
Reference: [GJ79] <author> Michael R. Garey and David S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: If N is small, an exact solution can be found by exhaustive search; otherwise, an approximation algorithm can be used <ref> [GJ79, pp. 133-134] </ref>. Theorem 3. The problem of finding a minimum-sized fixed set is NP-complete. Proof. We give linear-time reductions in both directions between finding a fixed set for a formula and finding a vertex cover for an undirected graph. <p> Theorem 3. The problem of finding a minimum-sized fixed set is NP-complete. Proof. We give linear-time reductions in both directions between finding a fixed set for a formula and finding a vertex cover for an undirected graph. Since finding a minimum-sized vertex cover is NP-complete <ref> [GJ79] </ref>, it follows that finding a minimum-sized fixed set is also NP-complete. Given an instance V n ff=1 OE ff of finding a fixed set, define the edges of an undirected graph G 0 = ([1::N ]; E 0 ) by E 0 (OE ff ))g.
Reference: [GW92] <author> Vijay K. Garg and Brian Waldecker. </author> <title> Detection of unstable predicates in distributed programs. </title> <booktitle> In Proceedings of the 12th International Conference on Foundations of Software Technology and Theoretical Computer Science, volume 652 of Lecture Notes in Computer Science, </booktitle> <pages> pages 253-264. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: One approach has been to change the problem|for example, detecting a different modality [FR94] or assuming that the system is partially synchronous [MN91]. Another approach has been to restrict the problem and develop efficient algorithms for detecting only certain classes of predicates <ref> [GW92, GW94, TG94] </ref>. Our work is inspired by an algorithm of Garg and Waldecker for a restricted problem [GW94]. Their algorithm detects Poss only for a Boolean combination of local predicates, where a local predicate is defined to be one that depends on the state of a single process.
Reference: [GW94] <author> Vijay K. Garg and Brian Waldecker. </author> <title> Detection of weak unstable predicates in distributed programs. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 5(3) </volume> <pages> 299-307, </pages> <year> 1994. </year>
Reference-contexts: One approach has been to change the problem|for example, detecting a different modality [FR94] or assuming that the system is partially synchronous [MN91]. Another approach has been to restrict the problem and develop efficient algorithms for detecting only certain classes of predicates <ref> [GW92, GW94, TG94] </ref>. Our work is inspired by an algorithm of Garg and Waldecker for a restricted problem [GW94]. Their algorithm detects Poss only for a Boolean combination of local predicates, where a local predicate is defined to be one that depends on the state of a single process. <p> Another approach has been to restrict the problem and develop efficient algorithms for detecting only certain classes of predicates [GW92, GW94, TG94]. Our work is inspired by an algorithm of Garg and Waldecker for a restricted problem <ref> [GW94] </ref>. Their algorithm detects Poss only for a Boolean combination of local predicates, where a local predicate is defined to be one that depends on the state of a single process. <p> We use integers [1::N ] as process names. A computation c is represented as histories c 1 ; : : : ; c N of the constituent processes, together with a happened-before relation ! that is a relation on local states instead of events <ref> [GW94] </ref>. In particular, define ! to be the smallest transitive relation on S N i=1 U (c i ) such that 1. (8i 2 [1::N ] : (8ff 2 [1::(jc i j 1)] : c i [ff] ! c i [ff + 1])). <p> For all computations c and all predicates OE 1 ; : : : ; OE n , c j= Poss n _ OE ff iff ff=1 (c j= Poss OE ff ): Proof. See <ref> [GW94] </ref>. ut Thus, each disjunct of a formula can be detected separately. <p> We advocate characterizing the complexity of detecting Poss for particular classes of formulas . Since conjunctions of 1-local predicates can be detected in polynomial time <ref> [GW94] </ref>, it is natural to ask about the complexity of detecting conjunctions of 2-local predicates. We show that this problem is NP-complete by giving a reduction from the k-partite clique problem, which is defined as follows.
Reference: [JMN95] <author> R. Jegou, R. Medina, and L. Nourine. </author> <title> Linear space algorithm for on-line detection of global predicates. </title> <booktitle> To appear in Proc. International Workshop on Structures in Concurrency Theory (STRICT '95), </booktitle> <year> 1995. </year>
Reference-contexts: Any detection algorithm that constructs the entire lattice| whether it uses the method in [CM91, MN91] or the more efficient schemes in <ref> [DJR93, JMN95] </ref>|has worst-case time complexity that is at least linear in the size of the lattice. Thus, Cooper and Marzullo's algorithms for detecting Poss and Def have worst-case time complexity (S N ). Because the time needed to construct the lattice can be prohibitive, researchers have sought faster detection algorithms. <p> The following analysis shows that a minimum-sized fixed set should be used. The set CGS (c#F ) can be built with worst-case time complexity O (jF j jCGS (c#F )j + jF j 3 S 2 ) using the algorithm in [DJR93], or slightly faster using the algorithm in <ref> [JMN95] </ref>. For each state g 1 in CGS (c#F ), Garg and Waldecker's algorithm detects c #F j= Poss g 1 with worst-case time complexity O (jF j 2 S). <p> This information can be exploited in PDDA by restricting the search of c#F so that only local states in these ranges are examined. 3.6 On-line Algorithm The algorithms in <ref> [DJR93, JMN95] </ref> for computing CGS (c) have on-line versions with the same time complexities as given above. The same is true of Garg and Waldecker's algorithm.
Reference: [Lam78] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-564, </pages> <year> 1978. </year>
Reference-contexts: This leads to an obvious difficulty for detecting whether a global state predicate (hereafter simply called a "predicate") held. Cooper and Marzullo's solution to this difficulty involves two modalities, which we denote by Poss (read "possibly") and Def (read "definitely") [CM91]. These modalities are based on logical time <ref> [Lam78] </ref> as embodied in the happened-before relation !, a partial order on events that reflects causal dependencies. A history of an asynchronous distributed system can be approximated by a computation, which is a set of the events that occurred together with their happened-before relation.
Reference: [Mat89] <author> Friedemann Mattern. </author> <title> Virtual time and global states of distributed systems. </title> <editor> In M. Corsnard, editor, </editor> <booktitle> Proceedings of the International Workshop on Parallel and Distributed Algorithms, </booktitle> <pages> pages 120-131. </pages> <publisher> North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: CCR-9014363, NASA/DARPA grant NAG-2-893, and AFOSR grant F49620-94-1-0198. Any opinions, findings, and conclusions or recommendations expressed in this pub lication are those of the authors and do not reflect the views of these agencies. vector clocks <ref> [Fid88, Mat89] </ref>, it|hence the computation|can be determined by processes in the system. Happened-before is not a total order, so it does not uniquely determine the history. But it does restrict the possibilities. <p> We always use S to denote max (jc 1 j; : : : ; jc N j). We assume each process has a distinguished variable o such that for each local state s, s (o ) is a vector timestamp <ref> [Mat89] </ref> and for all local states s and s 0 , s (o ) &lt; s 0 (o ) iff s ! s 0 .
Reference: [MN91] <author> Keith Marzullo and Gil Neiger. </author> <title> Detection of global state predicates. </title> <booktitle> In Proceedings of the 5th International Workshop on Distributed Algorithms, volume 579 of Lecture Notes in Computer Science, </booktitle> <pages> pages 254-272. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Any detection algorithm that constructs the entire lattice| whether it uses the method in <ref> [CM91, MN91] </ref> or the more efficient schemes in [DJR93, JMN95]|has worst-case time complexity that is at least linear in the size of the lattice. Thus, Cooper and Marzullo's algorithms for detecting Poss and Def have worst-case time complexity (S N ). <p> Because the time needed to construct the lattice can be prohibitive, researchers have sought faster detection algorithms. One approach has been to change the problem|for example, detecting a different modality [FR94] or assuming that the system is partially synchronous <ref> [MN91] </ref>. Another approach has been to restrict the problem and develop efficient algorithms for detecting only certain classes of predicates [GW92, GW94, TG94]. Our work is inspired by an algorithm of Garg and Waldecker for a restricted problem [GW94].
Reference: [Str69] <author> Volker Strassen. </author> <title> Gaussian elimination is not optimal. </title> <journal> Numerische Mathe-matik, </journal> <volume> 13 </volume> <pages> 354-356, </pages> <year> 1969. </year>
Reference-contexts: Then = (9ff 1 ; ff 3 2 [1::S] : 13 (ff 1 ; ff 3 ) ^ OE 0 Using Strassen's matrix-multiplication algorithm, the matrix representing 13 can be computed with time complexity fi (S log 2 7 ) <ref> [Str69, AHU74] </ref>. 5 By the naive algorithm, the truth of can then be determined in fi (S 2 ) time. Thus, this algorithm detects Poss M with worst-case time complexity fi (S log 2 7 + S 2 ), or approximately fi (S 2:81 ).
Reference: [TG94] <author> Alexander I. Tomlinson and Vijay K. Garg. </author> <title> Monitoring functions on global states of distributed programs. </title> <type> Technical Report TR-PDS-1994-006, </type> <institution> Parallel and Distributed Systems Laboratory, University of Texas at Austin, </institution> <year> 1994. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: One approach has been to change the problem|for example, detecting a different modality [FR94] or assuming that the system is partially synchronous [MN91]. Another approach has been to restrict the problem and develop efficient algorithms for detecting only certain classes of predicates <ref> [GW92, GW94, TG94] </ref>. Our work is inspired by an algorithm of Garg and Waldecker for a restricted problem [GW94]. Their algorithm detects Poss only for a Boolean combination of local predicates, where a local predicate is defined to be one that depends on the state of a single process.
References-found: 19

