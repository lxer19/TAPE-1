URL: http://www.pdos.lcs.mit.edu/~dnj/publications/cav98.ps
Refering-URL: http://www.pdos.lcs.mit.edu/~dnj/publications.htm
Root-URL: 
Email: dnj@lcs.mit.edu  
Title: Boolean Compilation of Relational Specifications  
Author: Daniel Jackson 
Note: submitted to CAV98, category A (regular paper)  
Address: 545 Technology Square Cambridge, Mass 02139, USA  
Affiliation: MIT Lab for Computer Science  
Abstract: Relational specifications, in which the states themselves are characterized by relations, have wide application in software design but, until now, limited support from automated tools. This paper describes a new method for finding errors in a relational specification. A property to be checked is cast as a relational formula, which, if the property holds, has no finite models. The user selects a scope that bounds the size of candidate models. The relational formula is then translated into a boolean formula that has a model for every model of the relational formula within that scope. The boolean formula is represented in conjunctive normal form (CNF), being both a good match for relational formulae and the required input format of the most efficient boolean solvers. Certain features of the boolean formula, however, cause an exponential blowup if a direct translation is attempted. But by using some simple strategies case splitting, variable introduction, symmetry breaking and negation caching it is possible to overcome these problems and make translation efficient. The resulting boolean formulae, although often huge, are easily handled by WalkSAT, a stochastic solver. For a variety of specifications we examined, compilation and solving together take less than 10 seconds. 
Abstract-found: 1
Intro-found: 1
Reference: [BC+92] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill and L.J. Hwang. </author> <title> Symbolic model checking: 10 states and beyond. </title> <journal> Information and Computation, </journal> <volume> Vol. 98, No. 2, pp.142170, </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: We have not shown these to be optimal, but they seem to work well in practice. Transitive closure is handled as a byproduct of variable introduction. Rather than computing the series SflflffSflflSfiflflffSflflSflflSfiflfl we use the standard technique of iterative squaring <ref> [BC+92] </ref>: S fl flS S Lffi fl flffS L flflS L fifl8flS L For a scope of k, the series converges in log k steps. A closure expression is first unwound syntactically using this series; the resulting expression then becomes, like any other expression, subject to variable introduction.
Reference: [DJJ96] <editor> Checking Relational Specifications with Binary Decision Diagrams. Craig A. Damon, Daniel Jackson and Somesh Jha. </editor> <booktitle> Proc. 4th ACM SIGSOFT Conf. on Foundations of Software Engineering, </booktitle> <address> San Francisco, CA, </address> <month> October </month> <year> 1996, </year> <month> pp.7080. </month>
Reference-contexts: Detailed performance figures appear in the technical report [Jac97]. 9 9 Related Work We have experimented before with a boolean checker, representing boolean formulae not in CNF but with ordered binary decision diagrams (BDDs) <ref> [DJJ96] </ref>. Although that method performed excellently on some small examples, it did not scale well. BDDs, unlike CNF, are a canonical representation. In model checking, this is essential it allows fixpoints to be detected but in our setting there is little benefit, and the extra cost is unwarranted.
Reference: [DP60] <author> Martin Davis and Hilary Putnam. </author> <title> A computing procedure for quantification theory. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 7, </volume> <pages> pp. </pages> <address> 202215, </address> <year> 1960. </year>
Reference-contexts: Boolean formula are represented as tries, with negation cach ing. 6. Solving. The boolean formula is presented to a satisfaction algorithm. We have experimented with two: a trie-based version [ZS94] of Davis-Putnam <ref> [DP60] </ref>, which we implemented as part of Nitpick in Java, and WalkSAT [SKC94], a stochastic solver developed at Bell Labs, which currently is run as a standalone C program offline. A technical report elaborates on details that were omitted from this paper for lack of space [Jac97].
Reference: [EMW97] <author> Michael D. Ernst, Todd D. Millstein and Daniel S. Weld. </author> <title> Automatic SAT-Compilation of Plan ning Problems. </title> <booktitle> Proc. 15 th International Joint Conference on Artificial Intelligence (IJCAI-97), </booktitle> <address> Na goya, Aichi, Japan, </address> <month> August </month> <year> 1997, </year> <pages> pp. 11691176. </pages>
Reference-contexts: The closest application to ours is in planning, where the problem of finding a plan that satisfies a set of constraints is reduced to finding a model of a boolean formula <ref> [KS96, EMW97] </ref>. The planning problem is technically closer to the model checking problem than to our problem: namely finding a sequence of transitions in a state machine that leads to a state satisfying a given property (in planning, the goal, and in model checking, the negation of the invariant).
Reference: [IBM97] <institution> Object Constraint Language Reference Manual, </institution> <month> September </month> <year> 1997. </year> <note> www.software.ibm.com/ad/ocl. </note>
Reference-contexts: This latter complexity has been one of the obstacles to applying model checking to the analysis of software. Many languages have been developed for describing this kind of structure; in academia, formal specification languages such as Z [Spi92], and in industry, object constraint languages such as OCL <ref> [IBM97] </ref>. Tool support, however, has been confined to simple static checking or to interactive theorem proving. Nitpick is a checker for relational specifications. Its language, NP [JD96b], is essentially the subset of Z corresponding to the relational calculus, and is thus undecidable [Sch79].
Reference: [Jac97] <author> Daniel Jackson. </author> <title> Boolean Compilation of Relational Specifications. </title> <type> Technical Report MIT-LCS-TR 735. </type> <institution> Lab for Computer Science, Massachusetts Institute of Technology, </institution> <address> Cambridge, MA. </address> <note> Decem ber 1997. Available at www.pdos.lcs.mit.edu/~dnj/papers/tr735.ps. </note>
Reference-contexts: A technical report elaborates on details that were omitted from this paper for lack of space <ref> [Jac97] </ref>. In particular, it justifies the design of the intermediate language, and gives its semantics and typing rules. WalkSAT works by local search, and is thus incomplete: it may fail to find a model of the boolean formula when one exists. <p> Mobile IP is a specification of a draft version of a mobile internet protocol for IPv6, written by an undergraduate at Carnegie Mellon [JNW97, Ng97]. The specifications are reproduced in full in the technical report <ref> [Jac97] </ref>. The column marked Cases gives the number of clauses in the DNF representation of the claim; Formulae gives the maximum number of relational formulae in each clause (after variable introduction). <p> The final column gives the time taken by the explicit version of Nitpick. Timings were obtained on a modestly equipped machine; some insignificant platform discrepancies between the two versions of Nitpick are explained in the technical report <ref> [Jac97] </ref>. The entry ?? indicates that a model was not found in a reasonable time; we set a bound of one hour. The explicit checker did find a model for Mobile IP, but for a smaller scope in which different bounds were associated with different types. <p> Symmetry has a marked effect only on examples involving negated equalities. On Style, for example, it reduces the number of clauses from 53,495 to 4,385 for a scope of 4, and translation time from 17s to 2s. Detailed performance figures appear in the technical report <ref> [Jac97] </ref>. 9 9 Related Work We have experimented before with a boolean checker, representing boolean formulae not in CNF but with ordered binary decision diagrams (BDDs) [DJJ96]. Although that method performed excellently on some small examples, it did not scale well. BDDs, unlike CNF, are a canonical representation.
Reference: [JD96a] <author> Elements of Style: </author> <title> Analyzing a Software Design Feature with a Counterexample Detector. </title> <editor> Daniel Jackson and Craig A. </editor> <title> Damon. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 22, No. 7, </volume> <month> July </month> <year> 1996, </year> <pages> pp. 484495. </pages>
Reference-contexts: Style is a specification of the paragraph style hierarchy of Microsoft Word, constructed as a class project in the Masters of Software Engineering degree at Carnegie Mellon; it is described in detail in <ref> [JD96a] </ref>. Allocate is a simplified fragment of a railway interlocking specification written in Z by Praxis UK PLC. Mobile IP is a specification of a draft version of a mobile internet protocol for IPv6, written by an undergraduate at Carnegie Mellon [JNW97, Ng97].
Reference: [JD96b] <author> Daniel Jackson and Craig A. Damon. </author> <title> Nitpick Reference Manual. </title> <institution> CMU-CS-96-109. School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> January </month> <year> 1996. </year> <month> 10 </month>
Reference-contexts: Tool support, however, has been confined to simple static checking or to interactive theorem proving. Nitpick is a checker for relational specifications. Its language, NP <ref> [JD96b] </ref>, is essentially the subset of Z corresponding to the relational calculus, and is thus undecidable [Sch79]. Nitpick cannot, therefore, decide whether a formula is valid; instead it attempts to refute it, by finding a counterexample a model of the formulas negation.
Reference: [JDJ96] <author> Daniel Jackson, Craig A. Damon and Somesh Jha. </author> <title> Faster Checking of Software Specifications. </title> <booktitle> Proc. ACM Conf. on Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, FL, </address> <month> January </month> <year> 1996, </year> <pages> pp. 7990. </pages>
Reference-contexts: The first version of Nitpick searched by enumerating relation values explicitly. A suite of reduction mechanisms, notably exploitation of symmetry in the search space <ref> [JDJ96, JJD97] </ref>, made it possible to analyze a variety of small specifications. A draft standard for a mobile internet protocol, for example, was specified in NP; the subsequent Nitpick analysis revealed a serious flaw (that a routing loop might be set up, causing messages to circulate endlessly) [JNW97, Ng97]. <p> Often, however, a much more effective strategy can be applied. We have shown previously <ref> [JDJ96, JJD97] </ref> that the models of relational formulae are permutation invariant: Given a model of a formula, the assignment that results from permuting the atoms of the underlying universe will also be a model.
Reference: [JJD97] <author> Daniel Jackson, Somesh Jha and Craig A. Damon. </author> <title> Isomorph-free Model Enumeration: A New Method for Checking Relational Specifications. </title> <note> To appear, ACM Transactions on Programming Languages and Systems. </note>
Reference-contexts: The first version of Nitpick searched by enumerating relation values explicitly. A suite of reduction mechanisms, notably exploitation of symmetry in the search space <ref> [JDJ96, JJD97] </ref>, made it possible to analyze a variety of small specifications. A draft standard for a mobile internet protocol, for example, was specified in NP; the subsequent Nitpick analysis revealed a serious flaw (that a routing loop might be set up, causing messages to circulate endlessly) [JNW97, Ng97]. <p> Often, however, a much more effective strategy can be applied. We have shown previously <ref> [JDJ96, JJD97] </ref> that the models of relational formulae are permutation invariant: Given a model of a formula, the assignment that results from permuting the atoms of the underlying universe will also be a model. <p> None of the particular strategies Nitpick employs is especially novel, perhaps with the exception of negation caching. Symmetry breaking exploits the same properties of relational formulae that our previous method exploited <ref> [JDJ97, JJD97] </ref>, albeit in a different manner. Variable introduction and case splitting are standard techniques.
Reference: [JNW97] <author> Daniel Jackson, Yuchung Ng and Jeannette Wing. </author> <note> A Nitpick Analysis of IPv6. Submitted to For mal Aspects of Computing. </note>
Reference-contexts: A draft standard for a mobile internet protocol, for example, was specified in NP; the subsequent Nitpick analysis revealed a serious flaw (that a routing loop might be set up, causing messages to circulate endlessly) <ref> [JNW97, Ng97] </ref>. In this paper, a new checking method based on boolean satisfaction is described. A claim that some property of the specification holds is negated, and translated from a relational formula into a boolean formula. <p> Allocate is a simplified fragment of a railway interlocking specification written in Z by Praxis UK PLC. Mobile IP is a specification of a draft version of a mobile internet protocol for IPv6, written by an undergraduate at Carnegie Mellon <ref> [JNW97, Ng97] </ref>. The specifications are reproduced in full in the technical report [Jac97]. The column marked Cases gives the number of clauses in the DNF representation of the claim; Formulae gives the maximum number of relational formulae in each clause (after variable introduction).
Reference: [KS96] <author> Henry Kautz and Bart Selman. </author> <title> Pushing the envelope: planning, propositional logic, and stochastic search. </title> <booktitle> Proc. 5 th National Conference on Artificial Intelligence, </booktitle> <year> 1996, </year> <pages> pp. 11941201. </pages>
Reference-contexts: The closest application to ours is in planning, where the problem of finding a plan that satisfies a set of constraints is reduced to finding a model of a boolean formula <ref> [KS96, EMW97] </ref>. The planning problem is technically closer to the model checking problem than to our problem: namely finding a sequence of transitions in a state machine that leads to a state satisfying a given property (in planning, the goal, and in model checking, the negation of the invariant).
Reference: [Ng97] <author> Yu-Chung Ng. </author> <title> A Nitpick Specification of IPv6. </title> <type> Senior Honors Thesis, </type> <institution> Computer Science De partment, Carnegie Mellon University, </institution> <month> May </month> <year> 1997. </year>
Reference-contexts: A draft standard for a mobile internet protocol, for example, was specified in NP; the subsequent Nitpick analysis revealed a serious flaw (that a routing loop might be set up, causing messages to circulate endlessly) <ref> [JNW97, Ng97] </ref>. In this paper, a new checking method based on boolean satisfaction is described. A claim that some property of the specification holds is negated, and translated from a relational formula into a boolean formula. <p> Allocate is a simplified fragment of a railway interlocking specification written in Z by Praxis UK PLC. Mobile IP is a specification of a draft version of a mobile internet protocol for IPv6, written by an undergraduate at Carnegie Mellon <ref> [JNW97, Ng97] </ref>. The specifications are reproduced in full in the technical report [Jac97]. The column marked Cases gives the number of clauses in the DNF representation of the claim; Formulae gives the maximum number of relational formulae in each clause (after variable introduction).
Reference: [Sch79] <author> Wolfgang Schoenfeld. </author> <title> An undecidability result for relational algebras. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 44(1), </volume> <month> March </month> <year> 1979. </year>
Reference-contexts: Tool support, however, has been confined to simple static checking or to interactive theorem proving. Nitpick is a checker for relational specifications. Its language, NP [JD96b], is essentially the subset of Z corresponding to the relational calculus, and is thus undecidable <ref> [Sch79] </ref>. Nitpick cannot, therefore, decide whether a formula is valid; instead it attempts to refute it, by finding a counterexample a model of the formulas negation. The search for counterexamples is conducted within a finite scope selected by the user.
Reference: [SLM92] <author> Bart Selman, Hector Levesque and David Mitchell. </author> <title> A new method for solving hard satisfiability problems. </title> <booktitle> Proc. 10 th National Conference on Artificial Intelligence. </booktitle>
Reference-contexts: BDDs, unlike CNF, are a canonical representation. In model checking, this is essential it allows fixpoints to be detected but in our setting there is little benefit, and the extra cost is unwarranted. The remarkable success of the stochastic solver GSAT <ref> [SLM92] </ref> and its descendants has made boolean translation attractive in other domains too. The closest application to ours is in planning, where the problem of finding a plan that satisfies a set of constraints is reduced to finding a model of a boolean formula [KS96, EMW97].
Reference: [SKC94] <author> Bart Selman, Henry Kautz and Bram Cohen. </author> <title> Noise strategies for improving local search. </title> <booktitle> Proc. AAAI-94, </booktitle> <pages> pp. 337343, </pages> <year> 1994. </year>
Reference-contexts: The boolean formulae that are generated are usually huge 1,000 variables and 20,000 clauses but are easily within the grasp of stochastic solvers such as WalkSAT <ref> [SKC94] </ref>. This new method consistently outperforms our previous method, and appears to scale more readily to larger specifications and larger scopes. The compiler generates formulae in conjunctive normal form (CNF). <p> Boolean formula are represented as tries, with negation cach ing. 6. Solving. The boolean formula is presented to a satisfaction algorithm. We have experimented with two: a trie-based version [ZS94] of Davis-Putnam [DP60], which we implemented as part of Nitpick in Java, and WalkSAT <ref> [SKC94] </ref>, a stochastic solver developed at Bell Labs, which currently is run as a standalone C program offline. A technical report elaborates on details that were omitted from this paper for lack of space [Jac97].
Reference: [Spi92] <author> J. Michael Spivey. </author> <title> The Z Notation: A Reference Manual. Second ed, </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: This latter complexity has been one of the obstacles to applying model checking to the analysis of software. Many languages have been developed for describing this kind of structure; in academia, formal specification languages such as Z <ref> [Spi92] </ref>, and in industry, object constraint languages such as OCL [IBM97]. Tool support, however, has been confined to simple static checking or to interactive theorem proving. Nitpick is a checker for relational specifications.

References-found: 17

