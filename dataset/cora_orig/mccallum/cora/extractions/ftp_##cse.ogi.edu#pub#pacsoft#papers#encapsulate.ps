URL: ftp://cse.ogi.edu/pub/pacsoft/papers/encapsulate.ps
Refering-URL: http://www.cse.ogi.edu/~dick/dick.html
Root-URL: http://www.cse.ogi.edu
Title: Encapsulated Effects  
Author: Richard B. Kieburtz John Launchbury 
Date: October 24, 1995  
Affiliation: Oregon Graduate Institute of Science Technology  
Abstract: Side effects in imperative programming languages are ubiquitous, which makes it difficult to reason about programs in other than operational terms. Functional programming languages, on the other hand, claim the advantage that equational logics are sufficient for reasoning, but at the that often useful effects, such as interactive input, exceptions, and explicit updates of state cannot be accommodated. This paper shows a way to bring these two worlds of programming style closer together, by neatly encapsulating the effects-producing semantics features that one wishes to use to design useful and efficient programs. 
Abstract-found: 1
Intro-found: 1
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: Following the distinction made by Damas and Milner <ref> [DM82] </ref>, we distinguish types from type schemes. Type schemes extend types by adding universal qualtifiers over type variables and a distinguished constant, &gt;, to designate untypability. Type scheme expressions are generated by the grammar ::= t j &gt; j 8ff: where t designates a type. <p> Following Damas and Milner <ref> [DM82] </ref>, we let t range over types and range over type schemes in the rules that follow. The specification is completed by adding the rule 13 (here stated informally) that to any expression for which no type can be assigned by these rules, we assing the type scheme &gt;.
Reference: [GS94] <author> J. C. Guzman and A. </author> <title> Suarez. A type system for exceptions. </title> <booktitle> In Proceedings of the 1994 ACM Workshop on ML and its applications, </booktitle> <pages> pages 127-135, </pages> <year> 1994. </year>
Reference-contexts: It had first been observed that mutable state could be confined to a restricted scope so that portions of a program that did not refer to the state would be referentially transparent [SRI91]. Extensions of the type system have been proposed to account for exceptions <ref> [GS94] </ref> and Eother effects [JG89, JG91, TJ92, Tal93]. These approaches rely upon static analysis to determine the possible scope of effects-producing operations. Riecke [Rie93, RV95] has proposed an explicit, encapsulating operator for semantic effects, similar to the eval M operator we have proposed here.
Reference: [JD93] <author> Mark Jones and Luc Duponcheel. </author> <title> Composing monads. </title> <type> Technical Report YALEU/DCS/RR-1004, </type> <institution> Yale University, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: In this section we explore some conditions under which features used in conjunction can be characterized by a composite monad. The idea of composing new mon-ads from old is obviously attractive and has stimulated the efforts of several researchers <ref> [Mog90, JD93, LHJ95] </ref>. Unfortunately, "composition" appears to be the wrong word to use to describe the construction of composite monads. There is no uniform way to construct composites but a few ways to form composite monads useful for programming are known.
Reference: [JD94] <author> Mark Jones and Luc Duponcheel. </author> <title> Composing monads. </title> <type> Technical Report YALEU/DCS/RR-1004, </type> <institution> Yale University, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: has a distribution combinator ffi M 0 (A) : M 0 (R ! A) ! R ! M 0 (A) Sr [R] M 0 (A) = t:r: eval M 0 ( ) fM 0 (apply state r) tg 4 Essentially the same result has been gotten by Jones and Duponcheel <ref> [JD94] </ref>. 26 where for the state reader, apply state : R ! Sr [R](A) ! A.
Reference: [JG89] <author> P. Jouvelot and D. K. Gifford. </author> <title> Reasoning about continuations with control effects. </title> <booktitle> In Proceedings of the 1989 ACM Conference on Programming Language Design and Implementation, </booktitle> <year> 1989. </year>
Reference-contexts: It had first been observed that mutable state could be confined to a restricted scope so that portions of a program that did not refer to the state would be referentially transparent [SRI91]. Extensions of the type system have been proposed to account for exceptions [GS94] and Eother effects <ref> [JG89, JG91, TJ92, Tal93] </ref>. These approaches rely upon static analysis to determine the possible scope of effects-producing operations. Riecke [Rie93, RV95] has proposed an explicit, encapsulating operator for semantic effects, similar to the eval M operator we have proposed here.
Reference: [JG91] <author> P. Jouvelot and D. K. Gifford. </author> <title> Algebraic reconstruction of types and effects. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 303-310, </pages> <year> 1991. </year>
Reference-contexts: It had first been observed that mutable state could be confined to a restricted scope so that portions of a program that did not refer to the state would be referentially transparent [SRI91]. Extensions of the type system have been proposed to account for exceptions [GS94] and Eother effects <ref> [JG89, JG91, TJ92, Tal93] </ref>. These approaches rely upon static analysis to determine the possible scope of effects-producing operations. Riecke [Rie93, RV95] has proposed an explicit, encapsulating operator for semantic effects, similar to the eval M operator we have proposed here.
Reference: [Jon93] <author> Mark Jones. </author> <title> A system of constructor classes. </title> <booktitle> In FPCA'93, </booktitle> <pages> pages 52-61, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The object monad plays a passive role; the structure is determined by the subject. Recognizing this, Mark Jones has proposed monad constructors as a special instance of the class constructor mechanism <ref> [Jon93] </ref> in Gofer. Unfortunately, there is no sure guidance to the formulation of a new monad constructor that will ensure that the construction satisfies the axioms required of a monad. In a semantic composite of two monads in exp-M, the access combinators of both monads are defined.
Reference: [LHJ95] <author> Sheng Liang, Paul Hudak, and Mark Jones. </author> <title> Monad transformers and modular interpreters. </title> <booktitle> In Conference Record of the Twenty Second Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-11, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: In this section we explore some conditions under which features used in conjunction can be characterized by a composite monad. The idea of composing new mon-ads from old is obviously attractive and has stimulated the efforts of several researchers <ref> [Mog90, JD93, LHJ95] </ref>. Unfortunately, "composition" appears to be the wrong word to use to describe the construction of composite monads. There is no uniform way to construct composites but a few ways to form composite monads useful for programming are known.
Reference: [LJ95] <author> John Launchbury and Simon Peyton Jones. </author> <title> State in Haskell. Lisp and Symbolic Computation, </title> <note> (to appear) 1995. </note>
Reference-contexts: Expressions or contexts that don't use the added feature remain syntactically unchanged. However, new operators, added to designate side-effecting actions in the semantics, are not referentially transparent and thus, neither will be a language that is interpreted with respect to a monad of effects. Recently, Peyton Jones and Launchbury <ref> [LJ95] </ref> showed that when a state transformer monad is used to extend the semantics of a Haskell program 1 , the scope of the monad and of its possible effects can be circumscribed. Further, the scope of each state component is manifested in the types given to expressions.
Reference: [Man76] <author> E. Manes. </author> <title> Algebraic Theories, volume 26 of Graduate Texts in Mathematics. </title> <publisher> Springer Verlag, </publisher> <year> 1976. </year>
Reference-contexts: a program's semantics. 5 one of the distinctions traditionally made between imperative and functional programming languages, allowing us to focus on the appropriate modes of reasoning about programs. 3 Monads and their operators A characterization of monads that is directly useful for functional programs is given by so-called Kleisli triples <ref> [Man76] </ref>. <p> The monad map is a derived operator. map M : (a ! b) ! M (a) ! M (b) map M f = ext M (unit M ffi f ) 2 Manes <ref> [Man76] </ref> has used a superscript asterisk to designate the natural extension of a function, i.e. ext f f fl . 6 It is a straightforward consequence of the monad laws that the following equations hold: map M id a = id M (a) (3) and thus that (M; map M )
Reference: [Mil78] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Jour. of Computer and Systems Science, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: A monad is truly an abstract data type. 4.1 A core language The core language in which we shall embed side effecting operations is Milner's simple expression language, exp <ref> [Mil78] </ref>. This language is constructed on a lambda-calculus with constants, explicit pairs and local definitions. It has a Hindley-Milner type system, with a basic value type that we designate by . Its constants include at least one strict, binary operator. <p> In general, products in the monad are tensors that are not cartesian. 5 A type system for monadic expressions Types of expressions interpreted in a monad can be inferred in a Hindley-Milner type system <ref> [Mil78] </ref> extended with multiple sorts of type expressions. The type of an expression in the scope of a monad is assigned a sort particular to the instance of the monad.
Reference: [Mog90] <author> Eugenio Moggi. </author> <title> An abstract view of programming languages. </title> <type> Technical Report LFCS-90-113, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: In this section we explore some conditions under which features used in conjunction can be characterized by a composite monad. The idea of composing new mon-ads from old is obviously attractive and has stimulated the efforts of several researchers <ref> [Mog90, JD93, LHJ95] </ref>. Unfortunately, "composition" appears to be the wrong word to use to describe the construction of composite monads. There is no uniform way to construct composites but a few ways to form composite monads useful for programming are known.
Reference: [Mog91] <author> Eugenio Moggi. </author> <title> Notions of computations and monads. </title> <journal> Information and Compu--tation, </journal> <volume> 93(1) </volume> <pages> 55-92, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Functional programming researchers have experimented with the use of monads as a mathematical abstraction to capture side-effecting semantic features <ref> [Mog91, Wad92] </ref>. Monads allow semantic features of a program to be modularized. A variety of semantic features can be made virtually "plug compatible" within a program, just by expressing the semantic actions in terms of monads. <p> Because the object category is cartesian closed, it is possible to define an operator called the tensorial strength <ref> [Mog91] </ref> for a monad M , which can be expressed using lambda notation (the categorical notation is messy) as M : (M (A) fi S) ! M (A fi S) M = (m; s): map M (apply state s ffi unit St A ) m where apply state : S !
Reference: [Rie93] <author> John G. Riecke. </author> <title> Delimiting the scope of effects. </title> <booktitle> In Proceedings ofACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 146-158, </pages> <year> 1993. </year>
Reference-contexts: Extensions of the type system have been proposed to account for exceptions [GS94] and Eother effects [JG89, JG91, TJ92, Tal93]. These approaches rely upon static analysis to determine the possible scope of effects-producing operations. Riecke <ref> [Rie93, RV95] </ref> has proposed an explicit, encapsulating operator for semantic effects, similar to the eval M operator we have proposed here. Riecke and Viswanathan offer semantic models for an otherwise functional language with recursive definitions and encapsulated effects.
Reference: [RV95] <author> John Riecke and Ramesh Viswanathan. </author> <title> Isolating side effects in sequential languages. </title> <booktitle> In Conference Record of the Twenty Second Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-12, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Extensions of the type system have been proposed to account for exceptions [GS94] and Eother effects [JG89, JG91, TJ92, Tal93]. These approaches rely upon static analysis to determine the possible scope of effects-producing operations. Riecke <ref> [Rie93, RV95] </ref> has proposed an explicit, encapsulating operator for semantic effects, similar to the eval M operator we have proposed here. Riecke and Viswanathan offer semantic models for an otherwise functional language with recursive definitions and encapsulated effects.
Reference: [SRI91] <author> V. Swarup, U. Reddy, and E. Ireland. </author> <title> Assignments for applicative languages. </title> <booktitle> In Proceedings of the Fifth International Conference on Functional Programming Languages and Computer Architecture, volume 523 of Lecture Notes in Computer Science, </booktitle> <pages> pages 192-214. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: It had first been observed that mutable state could be confined to a restricted scope so that portions of a program that did not refer to the state would be referentially transparent <ref> [SRI91] </ref>. Extensions of the type system have been proposed to account for exceptions [GS94] and Eother effects [JG89, JG91, TJ92, Tal93]. These approaches rely upon static analysis to determine the possible scope of effects-producing operations.
Reference: [Tal93] <author> J.-P. Talpin. </author> <title> Theoretical and Practical Aspects of Type and Effect Inference. </title> <type> PhD thesis, </type> <institution> University of Paris VI, </institution> <year> 1993. </year>
Reference-contexts: It had first been observed that mutable state could be confined to a restricted scope so that portions of a program that did not refer to the state would be referentially transparent [SRI91]. Extensions of the type system have been proposed to account for exceptions [GS94] and Eother effects <ref> [JG89, JG91, TJ92, Tal93] </ref>. These approaches rely upon static analysis to determine the possible scope of effects-producing operations. Riecke [Rie93, RV95] has proposed an explicit, encapsulating operator for semantic effects, similar to the eval M operator we have proposed here.
Reference: [TJ92] <author> J.-P. Talpin and P. Jouvelot. </author> <title> Polymorphic types, region and effect inference. </title> <journal> Journal of Functional Programming, </journal> <volume> 2 </volume> <pages> 245-271, </pages> <year> 1992. </year>
Reference-contexts: It had first been observed that mutable state could be confined to a restricted scope so that portions of a program that did not refer to the state would be referentially transparent [SRI91]. Extensions of the type system have been proposed to account for exceptions [GS94] and Eother effects <ref> [JG89, JG91, TJ92, Tal93] </ref>. These approaches rely upon static analysis to determine the possible scope of effects-producing operations. Riecke [Rie93, RV95] has proposed an explicit, encapsulating operator for semantic effects, similar to the eval M operator we have proposed here.
Reference: [Wad92] <editor> Philip Wadler. </editor> <booktitle> The essence of functional programming. In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1992. </year> <month> 31 </month>
Reference-contexts: Functional programming researchers have experimented with the use of monads as a mathematical abstraction to capture side-effecting semantic features <ref> [Mog91, Wad92] </ref>. Monads allow semantic features of a program to be modularized. A variety of semantic features can be made virtually "plug compatible" within a program, just by expressing the semantic actions in terms of monads. <p> The operator unit M injects an ordinary value into the monad. The operator ext M forms the natural extension of a function whose codomain is typed in the monad, yielding a function whose domain also has the structure of the monad. Some authors <ref> [Wad92] </ref> prefer to use a function bind : M (A) ! (A ! M (B)) ! M (B) in place of ext M , but the difference is merely in the order of the arguments.
References-found: 19

