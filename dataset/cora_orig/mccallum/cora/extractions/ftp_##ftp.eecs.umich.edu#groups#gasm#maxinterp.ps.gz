URL: ftp://ftp.eecs.umich.edu/groups/gasm/maxinterp.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.eecs.umich.edu
Email: poetzsch@informatik.tu-muenchen.de  
Title: Developing Efficient Interpreters Based on Formal Language Specifications  
Author: Arnd Poetzsch-Heffter 
Address: D-80290 Munchen  
Affiliation: Institut fur Informatik Technische Universitat  
Abstract: The paper reports on extensions to the MAX system enabling the generation and refinement of interpreters based on formal language specifications. In these specifications, static semantics is defined by an attribution mechanism that allows to enrich syntax trees by control flow graphs. The dynamic semantics is defined by evolving algebras, a framework that has been successfully used to specify realistic programming languages. We apply the combined framework to a non-trivial example language and show how the resulting language specification can be refined in order to improve the efficiency of the generated interpreters. The framework provides enough modularity and flexibility so that such refinements can be carried out by local changes within the framework. Finally, we explain the implementation of the extensions to MAX. 
Abstract-found: 1
Intro-found: 1
Reference: [AU77] <author> A. V. Aho and J. D. Ullman. </author> <title> Principles of Compiler Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1977. </year>
Reference-contexts: To do this, we essentially have to make tasksucc and succ mutually recursive. 10 Stacks for Automatic Storage This paragraph shows how the TOY specification can be refined to implement automatic storage by a standard stack organization (cf. e.g. <ref> [AU77] </ref>). Locations will be simply natural numbers (i.e. the dynamic function VAL can be considered as an array).
Reference: [BR92] <author> E. Borger and D. Rosenzweig. </author> <title> A simple mathematical model for full Prolog. </title> <type> Technical Report TR-33/92, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1992. </year> <month> 13 </month>
Reference: [CO78] <author> R. L. Constable and M. J. O'Donnell. </author> <title> A Programming Logic: With an Introduction to the PL/CV Verifier. </title> <publisher> Winthrop Publishers, </publisher> <year> 1978. </year>
Reference-contexts: Another very important relation is to works using programming language specifications to define the semantics of programming logics. In particular, it is related to positional semantics as defined in <ref> [CO78] </ref>. In deed, our framework can be understood as a generalization of positional semantics in that it provides very flexible formal methods to define positions and the transition relation. Thereby it makes the logic approach of [CO78] applicable to realistic programming languages. 2 Formal Background This section introduces the formal concepts <p> In particular, it is related to positional semantics as defined in <ref> [CO78] </ref>. In deed, our framework can be understood as a generalization of positional semantics in that it provides very flexible formal methods to define positions and the transition relation. Thereby it makes the logic approach of [CO78] applicable to realistic programming languages. 2 Formal Background This section introduces the formal concepts our specifications are based on. First, we define occurrence algebras, an extension of term algebras. Occurrence algebras provide occurrence sorts (e.g. the sort of the variable declaration occurrences in a syntax tree).
Reference: [GH92] <author> Y. Gurevich and J. Huggins. </author> <title> The semantics of the C programming language. </title> <editor> In E. Borger et al., editor, </editor> <booktitle> Computer Science Logic, </booktitle> <pages> pages 274-308, </pages> <year> 1992. </year> <note> LNCS 702. </note>
Reference: [GM89] <author> Y. Gurevich and L. Moss. </author> <title> Algebraic operational semantics and Occam. </title> <editor> In E. Borger et al., editor, </editor> <booktitle> Computer Science Logic, </booktitle> <pages> pages 176-192, </pages> <year> 1989. </year> <note> LNCS 440. </note>
Reference-contexts: Even though its formal foundations are comparably simple, the framework is sufficiently expressive to specify all kinds of programming languages including parallel ones (cf. <ref> [GM89] </ref>). Its flexibility makes it attractive for stepwise refinements of specifications. We attempted to demonstrate this by refining a non-trivial language specification. Finally, we described a prototype implementation that generates interpreters or other language-dependent programming tools from specifications.
Reference: [Gur91] <author> Y. Gurevich. </author> <title> Evolving Algebras, </title> <booktitle> volume 43, </booktitle> <pages> pages 264-284. </pages> <note> EATCS Bulletin, </note> <year> 1991. </year>
Reference-contexts: They have been used to specify the semantics of many different programming languages including C ([GH92]), PROLOG ([BR92]), and Occam ([GM89]). Here, we summarize the definition of evolving algebras given in <ref> [Gur91] </ref>. In an evolving algebra specification, the computation states are described by algebras.
Reference: [Mer93] <author> R. Merk. </author> <title> Generierung von MAX-Attributauswertern. </title> <type> Master's thesis, </type> <institution> Technische Universitat Munchen, </institution> <year> 1993. </year>
Reference: [Mos92] <author> P. Mosses. </author> <title> Action Semantics. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year> <note> "Tracts in Theoretical Computer Science". </note>
Reference-contexts: Nevertheless, different tasks and levels in language design and implementation are til now solved and supported based on different, often unrelated frameworks; consequently, for each task a specification has to be produced from scratch. E.g. there are frameworks for providing very high-level, readable, and formal language specifications (e.g. <ref> [Mos92] </ref>); and frameworks to specify compilation tasks focussing on efficiency: attribute grammars to express identification, typing, and context checking; control flow based specifications for data flow analyses to support optimizations; and pattern driven code generators. <p> The goal of the presented work is not to substitute higher-level frameworks that are more convenient to use, trimmed versus readability, or have specific theoretical properties (all this is true e.g. for action semantics; see <ref> [Mos92] </ref>). The goal is to provide a system supported formal framework that allows to express stepwise refinement of specifications; in particular it should be flexible enough to express globalizing transformations (cf. [Sch85]), seperation of static from dynamic aspects, improvements on the control flow, and refinements based on data types.
Reference: [MS76] <author> R. Milner and C. Stratchey. </author> <title> A Theory of Programming Language Semantics. </title> <publisher> Chap-man and Hall, </publisher> <year> 1976. </year>
Reference-contexts: The easiest way to do this is to consider expression occurrences as local objects (this is called a store semantics in <ref> [MS76] </ref> and reflects the notion of temporary objects in compiler construction). Beside this, it is convenient to consider procedures as local objects for passing their return values.
Reference: [PH93a] <author> A. Poetzsch-Heffter. </author> <title> Interprocedural data flow analysis based on temporal specifications. </title> <type> Technical Report 93-1397, </type> <institution> Cornell University, </institution> <year> 1993. </year>
Reference-contexts: In addition to that, our work is related to systems enabling the implementation of data flow analyses ([Wil81]) and allows to bring data flow analysis and language semantics together (see <ref> [PH93a] </ref>; for a denotational approach cf. [Ven89]). Another very important relation is to works using programming language specifications to define the semantics of programming logics. In particular, it is related to positional semantics as defined in [CO78].
Reference: [PH93b] <author> A. Poetzsch-Heffter. </author> <title> Programming language specification and prototyping using the MAX system. </title> <editor> In J. Penjam M. Bruynooghe, editor, </editor> <booktitle> Programming Language Implementation and Logic Programming, </booktitle> <year> 1993. </year> <note> LNCS 714. </note>
Reference-contexts: And a child should use as much as possible from the parent specification. The framework we present in this paper should be understood as a step towards this picture, even though we focus here on a specific example, the development of interpreters. Approach In <ref> [PH93b] </ref>, we showed how first-order recursive functions defined on occurrence structures can be used like attributes in an attribute grammar specification. <p> They simplify and generalize the concept of occurrence structures as presented in <ref> [PH93b] </ref>. Before the formal definition, we give an informal introduction. <p> This allows us to work with efficient encodings 6 for these occurrences (instead of using a direct implementation of the term-natlist-pairs). Let us call this set of occurrences the nodes 7 of a program. Encodings of nodes were already explointed in the MAX implementation (see <ref> [PH93b] </ref> p. 144). As program points showed up to be helpful for many purposes (cf. section 5.2), we implemented program points as well by encodings.
Reference: [PHE93] <author> A. Poetzsch-Heffter and T. Eisenbarth. </author> <title> The MAX system: A tutorial introduction. </title> <type> Technical Report TUM-I9307, TU, </type> <month> April </month> <year> 1993. </year>
Reference: [Sch85] <author> D. A. Schmidt. </author> <title> Detecting global variables in denotational specifications. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 7 </volume> <pages> 299-310, </pages> <year> 1985. </year>
Reference-contexts: The goal is to provide a system supported formal framework that allows to express stepwise refinement of specifications; in particular it should be flexible enough to express globalizing transformations (cf. <ref> [Sch85] </ref>), seperation of static from dynamic aspects, improvements on the control flow, and refinements based on data types. Compared to attribute grammar based system, our system supports the specification of dynamic semantics and is more expressive as far as the formal part of specifications is concerned.
Reference: [Tof90] <author> M. Tofte. </author> <title> Compiler Generators. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference: [Ven89] <author> G. A. Venkatesh. </author> <title> A framework for construction and evaluation of high-level specification of program analysis techniques. </title> <booktitle> ACM Conference on Progamming Language Design and Implementation, </booktitle> <year> 1989. </year>
Reference-contexts: In addition to that, our work is related to systems enabling the implementation of data flow analyses ([Wil81]) and allows to bring data flow analysis and language semantics together (see [PH93a]; for a denotational approach cf. <ref> [Ven89] </ref>). Another very important relation is to works using programming language specifications to define the semantics of programming logics. In particular, it is related to positional semantics as defined in [CO78].
Reference: [Wil81] <author> R. Wilhelm. </author> <title> Global flow analysis and optimization in the MUG2 compiler generating system. </title> <editor> In S. Muchnick and N. D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 132-159. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
References-found: 16

