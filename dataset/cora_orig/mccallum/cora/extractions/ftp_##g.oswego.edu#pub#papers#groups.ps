URL: ftp://g.oswego.edu/pub/papers/groups.ps
Refering-URL: 
Root-URL: 
Email: dl@g.oswego.edu  
Phone: (315)341-2688  
Title: Objects in Groups  
Author: Doug Lea 
Date: December, 1993  
Address: Oswego, NY, 13126, USA  
Affiliation: SUNY at Oswego NY CASE Center  
Abstract: A group is defined as one or more objects bearing a common abstract relation, common external access policies, common connectivity, and common internal policies. Groups are similar to objects, but lack a single locus of control. They otherwise share features analogous to object-based classes, identities, constraints, and implementations. Groups may be used to organize, analyze, and implement large and distributed object-oriented systems, including those based on CORBA. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Agha, G., & C. Callsen, "ActorSpace: </author> <title> An Open Distributed Programming Paradigm", </title> <booktitle> Proceedings, Hawaii International Conference on System Sciences, </booktitle> <month> January, </month> <year> 1993. </year>
Reference-contexts: It is more extreme for groups simply because there is no single controller present to maintain and ensure these invariants. Sets Groups are special kinds of sets. But unlike Agha's otherwise similar but purely intensionally-based set-like ActorSpace <ref> [1] </ref> construct, groups have both intensional and extensional components. Interfaces (Section 4) describe group capabilities and minimal features of members.
Reference: [2] <author> Agha, G., I. Mason, S. Smith, & C. Talcott, </author> <title> A Foundation for Actor Computation, </title> <type> Technical Report, </type> <institution> University of Illinois at Urbana-Champlain, </institution> <year> 1993. </year>
Reference-contexts: An object may be connected to several channels at the same time. This may be conceptualized and implemented by ascribing multiple mailboxes or listening ports per object. Alternatively, a single mailbox may be used for each object (as in Actor systems <ref> [2] </ref>), to which messages from all connected channels are deposited, possibly tagged by channel. Along another dimension, messages may be processed by objects using interrupt-driven, call-based, or polling techniques, and may establish priorities to messages on certain channels.
Reference: [3] <author> Birman, K., </author> <title> "The Process Group Approach to Reliable Distributed Computing", </title> <journal> Communications of the ACM, </journal> <month> December </month> <year> 1993. </year>
Reference-contexts: Location Group. A group (e.g., a family) in which all members reside at a common loca tion. The concept of a group is by no means novel in OO (see, e.g., [17]) or other accounts of system design (see, e.g., <ref> [3] </ref>), and is in fact increasingly widespread. <p> Control and functionality are instead distributed across member objects. Group-like constructs have found widest applicability in distributed systems, where groups of objects residing on different machines must somehow coordinate their efforts to achieve tasks without the benefit of centralized controllers. Evidence from over a decade of experience <ref> [3] </ref> in (non-OO) distributed systems, especially, suggests that groups will become central organizing constructs in the development of large OO systems. Groups are by no means replacements for objects. When a unique locus of control is logically required, conceptually meaningful, and/or simpler to design, a group-based design is inappropriate. <p> Multi-cast should possess simple and predictable ordering semantics and be fault-tolerant. Minimally, multicast channels should have the FIFO property that messages are received in per-sender issued order. Causal and atomic broadcast protocols may be used to extend these guarantees to causal sequences across multiple senders <ref> [3, 21] </ref>. The strongest possi ble guarantee, full synchronicity, is normally undesirable since it limits parallelism and requires centralized message coordination. In both sequential and distributed systems, underlying transport mechanisms are often point-to-point, in which case group channels and multicast support must be fabricated on top of other primitives.
Reference: [4] <author> Black, A., & M. Immel, </author> <title> "Encapsulating Plurality", </title> <booktitle> Proceedings, ECOOP '93, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [5] <author> Bellur, U., G. Craig, K. Shank, & D. Lea, </author> <title> "Clustering: Composition Methods for Active Object Systems", </title> <booktitle> Proceedings, Hawaii International Conference on System Sciences, </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: In a fully channel-based system, binding is the only means of receiving messages of any kind, so group joins are routinely required upon object construction. These may include, for example, "meta-class groups" containing all objects of a given class and/or "location groups" (or clusters <ref> [7, 5] </ref>) containing objects constructed on a given machine. Also, each new object may construct and join a singleton group.
Reference: [6] <author> Casselman, R., </author> <title> A Role-Based Architectural Model Applied to Object-Oriented Systems, </title> <type> Thesis, </type> <institution> Dept., Systems and Computer Engineering, Carleton University, </institution> <year> 1993. </year> <title> [7] de Champeaux, </title> <editor> D., D. Lea., & P. </editor> <title> Faure, Object-Oriented System Development, </title> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: requests to check for client properties, check against access control lists, engage in authorization protocols, and so on. 5.3 Roles A role is defined by a set of features and services (or interface) employed in a particular context, but without committing to any specific object that must offer them (cf., <ref> [6] </ref>). Specific roles for helpers, subcomponents, or delegates of a composite object may be described in terms of constraints and contracts between the host and the acquaintances. However, in group-based designs, lack of host controllers causes the notion of a role to split into two aspects: Public.
Reference: [8] <author> Gamma, E., R. Helm, R. Johnson, & J. Vlis-sides. </author> <title> "Design Patterns: Abstraction and Reuse of Object-Oriented Designs", </title> <booktitle> Proceedings, ECOOP '93, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In the same way that object construction may be handled through the use of metaclasses or factories/generators <ref> [8, 7] </ref>, it is profitable to centralize (with the help of infrastructure and/or policy support) membership control for a group by defining group managers (or metagroups [19]).
Reference: [9] <author> Gourhant, Y., & Marc Shapiro, "FOG/C++: </author> <title> a Fragmented-Object Generator", </title> <booktitle> Proceedings, USENIX C++ Conference, USENIX, </booktitle> <year> 1990. </year>
Reference-contexts: The best-established means for supporting such maneuvers is to define all adaptable entities as special kinds of groups. A fragmented object <ref> [18, 9] </ref> is a group possessing an inner channel, but not an outer channel. Fragmented objects thus lack public group interfaces.
Reference: [10] <author> Hagsand, O., H. Herzog, K. Birman, & R. Cooper, </author> <booktitle> "Object-Oriented Reliable Computing", Proceedings, International Workshop on Object-Oriented Operating Systems, IEEE, </booktitle> <year> 1992. </year>
Reference-contexts: Except for CORBA compatibility, RDO/C++ shares most features with other efforts that have integrated Isis (or its research follow-on, Horus [30]) into distributed OO systems tools <ref> [10, 17] </ref>, including those of a companion effort, RDO/ST, that uses Isis to support distributed Smalltalk programming. The overall structure of RDO/C++ is similar to that of most C++ distribution tools (e.g., [18]). The RDO/C++ IDL compiler converts IDL to C++ abstract classes and subclasses thereof.
Reference: [11] <author> Harrison, W., & H. </author> <title> Ossher, </title> <booktitle> "Subject-Oriented Programming", Proceedings, OOPSLA '93, ACM, </booktitle> <year> 1993. </year>
Reference-contexts: Membership and access control measures enable the selective export of particular group interfaces for usage by particular clients. Such channels represent views [26] of objects, permitting role-based, subject-oriented <ref> [11] </ref> design and programming methods. Group constructs also help tame extreme forms of object evolution encountered in such designs when objects need to acquire roles that were not even defined at the time they were constructed.
Reference: [12] <author> Helm, R., I. Holland, & D. Gangopadhyay, </author> <title> "Contracts: Specifying Behavioral Compositions in Object-Oriented Systems", </title> <booktitle> Proceedings, OOPSLA '90, ACM, </booktitle> <year> 1990. </year>
Reference-contexts: Group behavior is in part a function of its state. This is an extreme form of the dependencies seen in ordinary composite or delegated objects, where proper functioning of the composite relies on invariant relations and contracts <ref> [12] </ref> holding among acquaintances. It is more extreme for groups simply because there is no single controller present to maintain and ensure these invariants. Sets Groups are special kinds of sets. But unlike Agha's otherwise similar but purely intensionally-based set-like ActorSpace [1] construct, groups have both intensional and extensional components.
Reference: [13] <author> Hogg, J., </author> <title> "Islands: Aliasing Protection In Object-Oriented Languages", </title> <booktitle> Proceedings, OOPSLA '91, ACM, </booktitle> <year> 1991. </year>
Reference-contexts: For groups, analogous dynamic constructs provide a basis for design policies, rules, and tools for limiting and controlling interference. For example, Wills [31] describes a collection of methods that restrict external communication by individual objects to others in particular demesnes. Demesnes, as well as the related concept of islands <ref> [13] </ref>, represent formalisms of particular group-based constructs and policies aimed at simplifying the analysis and design of communications-closed sets of interacting objects by imposing restrictions on the groups with which individual objects may be members and/or clients.
Reference: [14] <author> Hogg, J., D. Lea, R. Holt, A. Wills, & D. de Cham-peaux, </author> <title> "The Geneva Convention on the Treatment of Object Aliasing", </title> <journal> OOPS Messenger, </journal> <month> April </month> <year> 1992. </year>
Reference-contexts: Support for group membership queries enables common OO identity-based processing idioms, for example, those that dynamically test for the presence of aliasing and interference <ref> [14] </ref>. However, even with such support, such checks can at most test "top-level" identity, which fails to detect potential nonindependence of composite objects sharing access to other acquaintances or groups. This places additional burdens on design and implementation measures that otherwise preclude unwanted interference (see Section 5.2).
Reference: [15] <author> Isis Distributed Systems, </author> <title> ISIS User Guide and Reference Manual, Isis Distributed Systems, </title> <publisher> Inc, </publisher> <address> 111 South Cayuga St., Ithaca NY, </address> <year> 1992. </year>
Reference-contexts: The ENS itself defines several variants of "channels" as interfaces. Our prototype tool, RDO/C++ (Reliable Distributed Objects in C++), re-bases basic CORBA functionality on top of the Isis tm Toolkit <ref> [15] </ref>. Isis provides a library of implementation support (written in C) for channels, multicast, membership management, failure detection, fault-tolerance, and group monitoring, along with higher-level tools that assist in the development of group-based designs involving publish-subscribe, standby, spooling, and transaction protocols.
Reference: [16] <author> Krasner, G. & S. Pope, </author> <title> "A Cookbook for Using the Model View Controller User Interface Paradigm in Smalltalk-80", </title> <journal> Journal of Object-Oriented Programming, </journal> <month> August/September </month> <year> 1988. </year>
Reference-contexts: So far, user applications of RDO/C++ tend to exploit only two strengths of groups, subscription and fault-tolerance. RDO/C++ library classes help automate usage of these common idiomatic constructions. This will include, for example, support for Isis-News, a publish-subscribe tool that is mapped onto model-view-controller <ref> [16] </ref> style change and update methods, and also serves as a basis for a CORBA Event Notification Service. Also, RDO/C++ simplifies usage of the Isis coordinator-cohort standby protocol in which only one member of a group responds to a service request, backed up by others in case of failure.
Reference: [17] <author> Maffeis, S., "Electra: </author> <title> Making Distributed Programs Object-Oriented", </title> <booktitle> Proceedings, Symposium on Experiences with Distributed and Multiprocessor Systems, USENIX, </booktitle> <month> September, </month> <year> 1993. </year>
Reference-contexts: Property Group. A group of objects all possessing a possibly transient property (e.g., a group of visible windows). Location Group. A group (e.g., a family) in which all members reside at a common loca tion. The concept of a group is by no means novel in OO (see, e.g., <ref> [17] </ref>) or other accounts of system design (see, e.g., [3]), and is in fact increasingly widespread. <p> A manager may be either a separate entity that is designated to handle binding, etc., or a member of the group that responds to special join and leave messages issued upon binding <ref> [30, 17] </ref>. In either case, managers remain distinct from controllers of the sort described in Section 2 since they do not intercept normal group messages. <p> Except for CORBA compatibility, RDO/C++ shares most features with other efforts that have integrated Isis (or its research follow-on, Horus [30]) into distributed OO systems tools <ref> [10, 17] </ref>, including those of a companion effort, RDO/ST, that uses Isis to support distributed Smalltalk programming. The overall structure of RDO/C++ is similar to that of most C++ distribution tools (e.g., [18]). The RDO/C++ IDL compiler converts IDL to C++ abstract classes and subclasses thereof.
Reference: [18] <author> Makpangou, M., Y. Gourhant, J. Le Narzul, & M. </author> <title> Shapiro "Fragmented Objects for Distributed Abstractions", </title> <booktitle> in Advances in Distributed Systems, IEEE, </booktitle> <year> 1993. </year>
Reference-contexts: The best-established means for supporting such maneuvers is to define all adaptable entities as special kinds of groups. A fragmented object <ref> [18, 9] </ref> is a group possessing an inner channel, but not an outer channel. Fragmented objects thus lack public group interfaces. <p> The overall structure of RDO/C++ is similar to that of most C++ distribution tools (e.g., <ref> [18] </ref>). The RDO/C++ IDL compiler converts IDL to C++ abstract classes and subclasses thereof. C++-level client implementations send messages to local proxies representing individual or group channels (bound via proxy constructor arguments). These proxy objects marshall arguments and transport them through Isis to group members.
Reference: [19] <author> Matsuoka, S., T. Watanabe, & A. Yonezawa, </author> <title> "Hybrid Group Reflective Architecture for Object-Oriented Concurrent Reflective Programming", </title> <booktitle> in Proceedings, ECOOP '91, Lecture Notes in Computer Science, </booktitle> <volume> no 512, </volume> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In the same way that object construction may be handled through the use of metaclasses or factories/generators [8, 7], it is profitable to centralize (with the help of infrastructure and/or policy support) membership control for a group by defining group managers (or metagroups <ref> [19] </ref>). A manager may be either a separate entity that is designated to handle binding, etc., or a member of the group that responds to special join and leave messages issued upon binding [30, 17].
Reference: [20] <author> Milner, R., </author> <title> Communication and Concurrency, </title> <publisher> Prentice Hall International, </publisher> <year> 1989. </year>
Reference-contexts: However, the use of channels versus OIDs represents a conceptual shift, in the direction of other theoretical and applied models of concurrent and distributed processing (e.g., <ref> [20, 28] </ref>). Channels help disambiguate identity from message targeting mechanisms. These may be collapsed in point-to-point systems, but not with groups.
Reference: [21] <author> Mullender, S. (Ed.) </author> <title> Distributed Systems, 2nd ed., </title> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Multi-cast should possess simple and predictable ordering semantics and be fault-tolerant. Minimally, multicast channels should have the FIFO property that messages are received in per-sender issued order. Causal and atomic broadcast protocols may be used to extend these guarantees to causal sequences across multiple senders <ref> [3, 21] </ref>. The strongest possi ble guarantee, full synchronicity, is normally undesirable since it limits parallelism and requires centralized message coordination. In both sequential and distributed systems, underlying transport mechanisms are often point-to-point, in which case group channels and multicast support must be fabricated on top of other primitives.
Reference: [22] <author> OMG, </author> <title> Common Object Request Broker Architecture and Specification, Document 91.12.1, </title> <booktitle> Object Management Group, </booktitle> <year> 1991. </year>
Reference-contexts: of groups in C++-based CORBA systems, by way of experiences in collaborating with Isis Distributed Systems, Inc., to develop a prototype toolkit adding basic group support to CORBA functionality. (This prototype is currently being transformed into an IDS product.) The Object Management Group's CORBA (Common Object Request Broker Architecture) specification <ref> [22] </ref> defines an infrastructure for distributed object systems that is surprisingly amenable to group constructs. Although seemingly class-based, two key constructs (interfaces and ObjRefs) in the CORBA Interface Definition Language (IDL) are defined in a way that apply equally well, if not better, to groups.
Reference: [23] <editor> OMG, </editor> <booktitle> Joint Object Services Submission, Document 93.2.1, Object Management Group, </booktitle> <year> 1993. </year>
Reference: [24] <author> Powell, M., </author> <title> Objects, References, Identifiers and Equality, Document 93.7.5, </title> <booktitle> Object Management Group, </booktitle> <year> 1993. </year>
Reference: [25] <author> Raj, R., E. Tempero, H. Levy, A. Black, N. Hutchinson, & E. </author> <month> Jul, </month> <title> "Emerald: A General Purpose Programming Language", </title> <journal> Software Practice and Experience, </journal> <year> 1991. </year> <month> 12 </month>
Reference-contexts: In a strongly typed framework, eligibility to connect to a channel is statically checkable. Each member must be of a type (class) that conforms <ref> [25] </ref> to the interface. Interface types may be made arbi trarily specific as a means of limiting group membership, even to the extent of presenting de facto requirements that the group be homogeneous, as is common in fault-tolerant applications.
Reference: [26] <author> Scholl, M., C. Laasch, & M. Tresch, </author> <title> "Updatable Views in Object Oriented Databases", </title> <editor> in C. Delo-bel, M. Kifer & Y. Masunaga (eds.) </editor> <title> Deductive and Object-Oriented Databases, </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: However, a different notational ambiguity/nondeterminacy remains possible if an object is a member of more than one group with the same channel type. Membership and access control measures enable the selective export of particular group interfaces for usage by particular clients. Such channels represent views <ref> [26] </ref> of objects, permitting role-based, subject-oriented [11] design and programming methods. Group constructs also help tame extreme forms of object evolution encountered in such designs when objects need to acquire roles that were not even defined at the time they were constructed.
Reference: [27] <author> Shapiro, M., P. Dickman, & D. Plainfosse, </author> <title> SSP Chains: Robust, Distributed References Supporting Acyclic Garbage Collection, </title> <institution> Rapport de Recherche INRIA 1799, </institution> <year> 1992. </year>
Reference-contexts: Each process in a system must have local proxies. Proxies must themselves be managed, requiring additional infrastructure to track the existence and locations of members <ref> [27] </ref> and maintain consistency among proxies, again with a range of transparency options.
Reference: [28] <author> Strom, R., D. Bacon, A. Goldberg, A. Lowry, D. Yellin, & S. Yemeni, </author> <title> Hermes: A Language for Distributed Computing, </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: However, the use of channels versus OIDs represents a conceptual shift, in the direction of other theoretical and applied models of concurrent and distributed processing (e.g., <ref> [20, 28] </ref>). Channels help disambiguate identity from message targeting mechanisms. These may be collapsed in point-to-point systems, but not with groups. <p> Channel types are intrinsically bidirectional, describing the forms of messages received by members, and results sent back to clients. However, a channel and/or its type may also be split into descriptions of client-side versus member-side sending and receiving rights (cf., <ref> [28] </ref>). A channel can represent the extension of a group; a channel type describes its visible features. Groups themselves do not require external interfaces distinct from their corresponding channels. However, channels connecting to groups may differ idiomatically from those connecting to single objects. For example, multiple replies are more common.
Reference: [29] <author> Stroustrup, B., </author> <title> The C++ Programming Language, 2nd ed., </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Although seemingly class-based, two key constructs (interfaces and ObjRefs) in the CORBA Interface Definition Language (IDL) are defined in a way that apply equally well, if not better, to groups. IDL interfaces are very similar to C++ "abstract classes" <ref> [29] </ref>. They define sets of attributes, service procedures, and oneway (resultless) methods. These features must be implemented in a particular target language (often C++). However, IDL interfaces are specifically not tied to single-object implementations, and contain no semantic requirements that interfere with their use as group interfaces.
Reference: [30] <author> Van Renesse, R., K., Birman, R. Cooper, B. Glade, & P. Stephenson, </author> <title> "Reliable Multicast Between Microkernels", </title> <booktitle> Proceedings, USENIX Workshop on Microkernels and Other Kernel Architectures, </booktitle> <month> April, </month> <year> 1992. </year>
Reference-contexts: A manager may be either a separate entity that is designated to handle binding, etc., or a member of the group that responds to special join and leave messages issued upon binding <ref> [30, 17] </ref>. In either case, managers remain distinct from controllers of the sort described in Section 2 since they do not intercept normal group messages. <p> Except for CORBA compatibility, RDO/C++ shares most features with other efforts that have integrated Isis (or its research follow-on, Horus <ref> [30] </ref>) into distributed OO systems tools [10, 17], including those of a companion effort, RDO/ST, that uses Isis to support distributed Smalltalk programming. The overall structure of RDO/C++ is similar to that of most C++ distribution tools (e.g., [18]).
Reference: [31] <author> Wills, A., </author> <title> Formal Methods Applied to Object Oriented Programming, </title> <type> Thesis, </type> <institution> University of Manch-ester, </institution> <year> 1992. </year> <month> 13 </month>
Reference-contexts: Module membership is established by declaring an entity within module scope and external access is controlled via export constructs. For groups, analogous dynamic constructs provide a basis for design policies, rules, and tools for limiting and controlling interference. For example, Wills <ref> [31] </ref> describes a collection of methods that restrict external communication by individual objects to others in particular demesnes.
References-found: 30

