URL: http://www.it.kth.se/docs/Reports/se/diana-lic.ps.Z
Refering-URL: http://www.it.kth.se/docs/Reports/se/
Root-URL: http://www.it.kth.se
Abstract: Program analysis and visualisation (PA&V) is aimed at helping the programmer comprehend a given program by means of graphical presentations. We discuss examples of PA&V systems and classify these systems according to the specification method employed. Three specification methods of PA&V tools are mainly used in current practice: predefinition, annotation and declaration. We argue that systems employing a declarative method are the best suited to handle the PA&V process. First, we propose and provide a prototype implementation of our declarative PA&V toolkit. In our toolkit, the user specifies the constituents of PA&V tools in the given declarative language, and states a request for the synthesis of a particular PA&V tool. The specification and the request are mapped into the logical language in which the proof is performed. If the proof is successful, the requested PA&V tool is synthesised. In order to specify PA&V tools, the user has to separately specify program and view models as well as a mapping between them. The separation of mapping in the specification of PA&V tools and the application of structural synthesis of programs to synthesise these tools are the two novelties contained in our approach. Next, we address the issue of integrating our toolkit with declarative PA&V systems that use concept languages for representing software information. We define a mapping from the declarative NUT language to a concept language ALU N . Finally, we present the results of a couple of experiments with the prototype implementation of our toolkit. 
Abstract-found: 1
Intro-found: 1
Reference: [BGL95] <author> Margaret Burnett, Adele Goldberg, and Ted Lewis, </author> <title> editors. Visual Object-Oriented Programming: Concepts and Environments. </title> <publisher> Manning Publications Co., </publisher> <address> Greenwich,CT, </address> <year> 1995. </year>
Reference: [BMW94] <author> Ted J. Biggerstaff, Bharat G. Mitbander, and Dallas E. Web-ster. </author> <title> Program understanding and the concept assignment problem. </title> <journal> Communications of the ACM, </journal> <volume> 37(5) </volume> <pages> 72-82, </pages> <month> May </month> <year> 1994. </year>
Reference: [Bro88] <author> Marc H. Brown. </author> <title> Exploring algorithms using Balsa-II. </title> <journal> Computer, </journal> <volume> 21(5) </volume> <pages> 14-36, </pages> <month> May </month> <year> 1988. </year>
Reference: [CDZ95] <author> Wayne Citrin, Michael Doherty, and Benjamin Zorn. </author> <title> The design of a completely visual OOP language. </title> <editor> In Margaret Burnett, Adele Goldberg, and Ted Lewis, editors, </editor> <booktitle> Visual Object-Oriented Programming: Concepts and Environments, </booktitle> <pages> pages 67-93. </pages> <publisher> Manning Publications Co., </publisher> <address> Greenwich CT, </address> <year> 1995. </year>
Reference: [Cha96] <author> Jacques Charreyron. </author> <title> Design of high level components for NUT users. M.sc. </title> <type> thesis, </type> <institution> Dept. of Teleinformatics, KTH, </institution> <year> 1996. </year>
Reference-contexts: Any type of graphical view entity in a view is associated with a class in a view model (but not necessarily otherwise). Visualisation of data in MatLab is performed through the use of ready-made classes such as Matrix, MatlabLow, MatlabAnim provided by <ref> [Cha96] </ref>. The link to MatLab is transparent to the user, e.g. the visualisation in MatLab is specified by the user in the NUT language. Example 2.1. As an example, we take an OMT-based graphical presentation of a NUT program.
Reference: [CK91] <author> Shyam R. Chidamber and Chris F. Kemerer. </author> <title> Towards a metrics suite for object-oriented design. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> OOP-SLA'91, </volume> <pages> pages 197-211, </pages> <year> 1991. </year>
Reference-contexts: Although OO metrics lack precise definitions of many fundamental quantities and their correspondence to the program code, a number of studies on industrial systems (for example, [LHKS95], [CS95]) reported one potential benefit of software metrics: the prediction of maintenance effort. We adopt the OO metrics proposed in <ref> [CK91] </ref>, [LHKS95], [PHKV93], [CS95]. Table 4.2 summarises the implemented metrics. Name, definition and viewpoints are provided. Our metrics model is very simple. All measurement data is stored by attributes of class Metrics and derived classes specify which data is passed to visualisation and how this data is to be computed.
Reference: [CLN92] <author> Diego Calvanese, Maurizio Lenzerini, and Daniele Nardi. </author> <title> A unified framework for class-based representation formalisms. </title> <booktitle> In Proceedings of the 4th International Conference on Knowledge Representation and Reasoning, KR'94, </booktitle> <pages> page 258, </pages> <address> Bonn, Germany, 1992. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: In order not to get lost in the variety of KIF language constructs, we shall at this stage limit our study to the mapping of the NUT language to ALU N . We base our work on the results presented in <ref> [CLN92] </ref>, where the ALU N language was presented as a unified framework for class-based representation formalisms. It is advocated in this paper ([CLN92]) that the ALU N language is powerful enough to describe frame systems, object-oriented databases (OODB) and semantic data models. Actually, in [CLN92] the ALU N I language , <p> work on the results presented in <ref> [CLN92] </ref>, where the ALU N language was presented as a unified framework for class-based representation formalisms. It is advocated in this paper ([CLN92]) that the ALU N language is powerful enough to describe frame systems, object-oriented databases (OODB) and semantic data models. Actually, in [CLN92] the ALU N I language , e.g. ALU N with inverse roles, is used. We employ only the correspondence between the OODB languages and ALUN , and for this correspondence inverse roles are not used. Thus, in this thesis we shall consider only the ALU N language. <p> A considerable part of this chapter is devoted to an example (Section 4). The syntax and informal semantics of the NUT declarative language can be found in the Appendix. 3.1 The ALU N language The concept language ALU N <ref> [CLN92] </ref> comprises concepts (denoting sets) and roles (denoting binary relations). <p> The mapping from the NUT declarative language to ALUN is motivated by the informal semantics of the declarative constructs of NUT. We employ the correspondence between an OODB language and ALU N provided in <ref> [CLN92] </ref> for defining the mapping of structural information (classes and their components' definitions ), and extend the mapping in order to deal with computability information (specifications of class methods). As in [CLN92], we first introduce additional concepts: AbstractClass, ArrayType, RecType, SetType, SubtaskType, MethodType; and roles: VALUE, METHODS, MEMBER, NAME, SUBTASKS, INPUTS, <p> We employ the correspondence between an OODB language and ALU N provided in <ref> [CLN92] </ref> for defining the mapping of structural information (classes and their components' definitions ), and extend the mapping in order to deal with computability information (specifications of class methods). As in [CLN92], we first introduce additional concepts: AbstractClass, ArrayType, RecType, SetType, SubtaskType, MethodType; and roles: VALUE, METHODS, MEMBER, NAME, SUBTASKS, INPUTS, OUTPUTS. The reason is that the interpretation domain of ALU N knowledge bases consists of objects without structures whereas the instances of OO-schemata refer to a structured universe. <p> We provide the check for satisfiability in two modes. First, only structural information is considered, e.g. the formalisation of class methods' specification in ALU N is left aside. In this way, the NUT declarative language acts as an OODB language similar to the one selected in <ref> [CLN92] </ref>. We call this mode: OOD mode. Second, we consider the mapping of an entire specification of a NUT class into ALU N and we call this mode for checking satisfiability: OOP mode. Both modes have certain advantages, which we will explain later. OOD mode.
Reference: [CNR90] <author> Yin-Farn Chen, Michael Y. Nishimoto, </author> <title> and C.V. Ramamoorthy. The C information abstraction system. </title> <journal> IEEE Transactions on Software Engineering, 1990. </journal> <volume> 73 74 BIBLIOGRAPHY </volume>
Reference: [Cor89] <author> Thomas A. Corbi. </author> <title> Program understanding: Challenge for the 1990s. </title> <journal> IBM Systems Journal, </journal> <volume> 28(2) </volume> <pages> 294-306, </pages> <year> 1989. </year>
Reference: [CS95] <author> Neville I. Churcher and Martin J. Shepperd. </author> <title> Towards a conceptual framework for object oriented software metrics. </title> <booktitle> SIGSOFT Software Engineering Notes, </booktitle> <volume> 20(2) </volume> <pages> 69-76, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: The measurement of object-oriented (OO) systems design has recently received increasing attention. Although OO metrics lack precise definitions of many fundamental quantities and their correspondence to the program code, a number of studies on industrial systems (for example, [LHKS95], <ref> [CS95] </ref>) reported one potential benefit of software metrics: the prediction of maintenance effort. We adopt the OO metrics proposed in [CK91], [LHKS95], [PHKV93], [CS95]. Table 4.2 summarises the implemented metrics. Name, definition and viewpoints are provided. Our metrics model is very simple. <p> Although OO metrics lack precise definitions of many fundamental quantities and their correspondence to the program code, a number of studies on industrial systems (for example, [LHKS95], <ref> [CS95] </ref>) reported one potential benefit of software metrics: the prediction of maintenance effort. We adopt the OO metrics proposed in [CK91], [LHKS95], [PHKV93], [CS95]. Table 4.2 summarises the implemented metrics. Name, definition and viewpoints are provided. Our metrics model is very simple. All measurement data is stored by attributes of class Metrics and derived classes specify which data is passed to visualisation and how this data is to be computed.
Reference: [CUS95] <author> Bay-Wei Chang, David Ungar, and Randall B. Smith. </author> <title> Getting close to objects. </title> <editor> In Margaret Burnett, Adele Goldberg, and Ted Lewis, editors, </editor> <booktitle> Visual Object-Oriented Programming: Concepts and Environments, </booktitle> <pages> pages 185-190. </pages> <publisher> Manning Publications Co., </publisher> <address> Greenwich, CT, </address> <year> 1995. </year>
Reference: [DBBS91] <author> P. Devanbu, B.W. Ballard, R.J. Brachman, and P.G. Selfridge. </author> <title> LaSSIE: a knowledge-based software information system. In M.R. </title> <editor> Lowry and R.D. McCartney, editors, </editor> <booktitle> Automating Software Design, </booktitle> <pages> pages 25-38. </pages> <publisher> AAAI Press/The MIT Press, </publisher> <address> Menlo Park, CA, </address> <year> 1991. </year>
Reference-contexts: The motivation behind this is quite natural. A number of works [DJ94] [Dev94] <ref> [DBBS91] </ref> report the successful usage of description logics languages for recording software information. As shown in the previous chapter, we employed the NUT declarative language for the same task: representing information about software.
Reference: [Dev92] <author> Premkumar T. Devanbu. </author> <title> GENOA a customizable, language-and front-end independent code analyzer. </title> <booktitle> In Proceedings of the Fourteenth International Conference of Software Engineering (ICSE'92), </booktitle> <pages> pages 307-319, </pages> <address> Melbourne, Australia, </address> <month> May </month> <year> 1992. </year>
Reference: [Dev94] <author> Premkumar T. Devanbu. </author> <title> Software Information Systems. </title> <type> PhD thesis, </type> <institution> New Brunswick, The State University of New Jersey, </institution> <year> 1994. </year>
Reference-contexts: In Software Refinery, the centre of all activities is a program model, which is analysed, transformed and serves as the basis for visualisations. Whereas in our architecture, program and view models are equally important and an explicitly recorded and separated mapping acts as a bridge between them. Similarly, <ref> [Dev94] </ref> argues that code analysers should have two subsystems: front end, which is language-dependent and builds the abstract semantics graph (ASG) from a source program, and back end, which is language-independent and traverses the ASG in a specifiable manner. <p> The motivation behind this is quite natural. A number of works [DJ94] <ref> [Dev94] </ref> [DBBS91] report the successful usage of description logics languages for recording software information. As shown in the previous chapter, we employed the NUT declarative language for the same task: representing information about software. <p> We focus on entities of OO programs (such as class, object) and capture program dependencies in the specifications of these entities. Our approach has many characteristics in common with approaches like REPRISE [RW91], GEN++ <ref> [Dev94] </ref> and Smalltalk [GR83]. The conceptual model underlying REPRISE is an abstract semantics graph, which is an abstract syntax tree with added connections from each use of an entity to its declaration. <p> The C++ program model represents a simplified ontology of C++ programs. As discussed in <ref> [Dev94] </ref>, a complete set of concepts (or classes) for specifying a C++ program model contains about 290 entities, which makes any ambition to provide a complete C++ model, within the scope of this thesis practically impossible.
Reference: [DJ94] <author> Premkumar T. Devanbu and Mark A. Jones. </author> <title> The use of description logics in KBSE systems. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <address> Sorrento, Italy, </address> <year> 1994. </year>
Reference-contexts: The motivation behind this is quite natural. A number of works <ref> [DJ94] </ref> [Dev94] [DBBS91] report the successful usage of description logics languages for recording software information. As shown in the previous chapter, we employed the NUT declarative language for the same task: representing information about software. <p> The work presented here is partial in the sense that a mapping is provided between NUT and ALU N , which is a "theoretical language". A particular implementation of ALU N (for example, any of the systems described in <ref> [DJ94] </ref>) would modify and extend the mapping possibilities. The most important extension could be the mapping between rules in such a language and the specification of relations in the NUT language. Chapter 4 Experiments This chapter presents our experimentation with the prototype implementation of the proposed declarative PA&V toolkit (SoftSpy).
Reference: [DLNN95] <author> Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, and Werner Nutt. </author> <title> The complexity of concept languages. </title> <type> Technical Report DFKI-RR-95-07, </type> <address> Germany, </address> <year> 1995. </year>
Reference: [GC90] <author> Judith E. Grass and Yih-Farn Chen. </author> <title> The C++ information abstractor. </title> <booktitle> In USENIX C++ Conference, </booktitle> <pages> pages 265-277, </pages> <year> 1990. </year>
Reference-contexts: In those cases we ignore the direction, e.g. we consider that two classes C 1 and C 2 are linked if there is a dependency C 1 ! C 2 or C 2 ! C 1 . 4.1 Specification of models 51 <ref> [GC90] </ref>, where a relational database is used as storage media for the dependencies. We focus on entities of OO programs (such as class, object) and capture program dependencies in the specifications of these entities.
Reference: [GF92] <author> Michael R. Genesereth and Richard E. Fikes. </author> <title> Knowledge Interchange Format. </title> <note> Version 3.0. Reference Manual, </note> <year> 1992. </year>
Reference-contexts: The latest significant effort was the development of the Knowledge Interchange Format (KIF) a language with formally defined semantics for knowledge exchange between different knowledge-based systems <ref> [GF92] </ref>. Hence, the mapping between our target languages could be substituted by one between the NUT declarative language and KIF. Actually, KIF is an ALU N 35 36 A mapping from the NUT language to ALU N type language 1 with many additional facilities.
Reference: [GHFM95] <author> John Grundy, John Hosking, Stephen Fenwick, and Warwick Mu-gridge. </author> <title> Connecting the pieces. </title> <editor> In Margaret Burnett, Adele Gold-berg, and Ted Lewis, editors, </editor> <booktitle> Visual Object-Oriented Programming: Concepts and Environments, </booktitle> <pages> pages 229-252. </pages> <publisher> Manning Publications Co., </publisher> <address> Greenwich, CT, </address> <year> 1995. </year> <note> BIBLIOGRAPHY 75 </note>
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: the language and its implementation. </title> <publisher> Addison Wesley, </publisher> <year> 1983. </year>
Reference-contexts: We focus on entities of OO programs (such as class, object) and capture program dependencies in the specifications of these entities. Our approach has many characteristics in common with approaches like REPRISE [RW91], GEN++ [Dev94] and Smalltalk <ref> [GR83] </ref>. The conceptual model underlying REPRISE is an abstract semantics graph, which is an abstract syntax tree with added connections from each use of an entity to its declaration.
Reference: [HN90] <author> Mehdi T. Harandi and Jim Q. Ning. </author> <title> Knowledge-based program analysis. </title> <journal> IEEE Software, </journal> <pages> pages 74-81, </pages> <month> January </month> <year> 1990. </year>
Reference: [JE97] <author> W.Lewis Johnson and Ali Erdem. </author> <title> Interactive explanation of software systems. </title> <journal> Automated Software Engineering, </journal> <volume> 4 </volume> <pages> 53-75, </pages> <month> January </month> <year> 1997. </year>
Reference: [Joh94] <author> W.Lewis Johnson. </author> <title> Knowledge-based software engineering. </title> <editor> In Allen Kent and James G. Williams, editors, </editor> <booktitle> Encyclopedia of Computer Science and Technology, </booktitle> <volume> volume 30, </volume> <pages> pages 173-225. </pages> <publisher> Marcel Dekker, Inc., </publisher> <address> New York, </address> <year> 1994. </year>
Reference: [KM92] <author> Gordon Kotik and Lawrence Markosian. </author> <title> Knowledge-based software reengineering tools. </title> <booktitle> In Proceedings of the Seventh Knowledge-based Software Engineering Conference, </booktitle> <pages> page 258, </pages> <address> Los Alamitos, CA, 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [KNS92] <author> Wojtek Kozaczynski, Jim Ning, and Tom Sarver. </author> <title> Program concept recognition. </title> <booktitle> In Proceedings of the Seventh Knowledge-based Software Engineering Conference, </booktitle> <pages> pages 216-225, </pages> <address> Los Alamitos, CA, 1992. </address> <publisher> IEEE Computer Society Presss. </publisher>
Reference: [KPS94] <author> Jussi Koskinen, Jukka Paakki, and Airi Salminen. </author> <title> Program text as hypertext: Using program dependencies for transient linking. </title> <booktitle> In Proceedings of the 6th Int. Conference on Software Engineering and Knowledge Engineering, </booktitle> <address> SEKE'94, </address> <year> 1994. </year>
Reference: [KST96] <author> Ago Kuusik, Diana Sidarkeviciute, and Enn Tyugu. </author> <title> Knowledge level software visualisation. </title> <type> Technical Report TRITA-IT 96:09, </type> <institution> Dept. of Teleinformatics, KTH, Sweden, </institution> <year> 1996. </year>
Reference: [LC94] <author> Panagiotis K. Linos and Vincent Courtois. </author> <title> A tool for understanding object-oriented program dependencies. </title> <booktitle> In Proceedings of the 3rd IEEE Workshop on Program Comprehension, </booktitle> <year> 1994. </year>
Reference: [LH89] <author> Karl J. Lieberherr and Ian M. Holland. </author> <title> Assuring good style for object-oriented programs. </title> <journal> IEEE Software, </journal> <pages> pages 38-48, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: The NUT program model is easy to build in terms of these functions. If the user analyses a non-NUT program, he can write extraction functions in the NUT language 6 This restriction is by nature similar to the Law of Demeter <ref> [LH89] </ref>, which, informally stated, says that "each method can send messages to only a limited set of objects: to argument objects, to self pseudovariable, and to the immediate subparts of self". 7 Matlab is a registered trademark of MathWorks, Inc. 2.3 The specification and synthesis of PA&V tools 23 or invoke
Reference: [LHKS95] <author> Wei Li, Sallie Henry, Dennis Kafura, and Robert Schulman. </author> <title> Measuring object-oriented design. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 48-55, </pages> <address> July-August 1995. 76 BIBLIOGRAPHY </address>
Reference-contexts: The measurement of object-oriented (OO) systems design has recently received increasing attention. Although OO metrics lack precise definitions of many fundamental quantities and their correspondence to the program code, a number of studies on industrial systems (for example, <ref> [LHKS95] </ref>, [CS95]) reported one potential benefit of software metrics: the prediction of maintenance effort. We adopt the OO metrics proposed in [CK91], [LHKS95], [PHKV93], [CS95]. Table 4.2 summarises the implemented metrics. Name, definition and viewpoints are provided. Our metrics model is very simple. <p> Although OO metrics lack precise definitions of many fundamental quantities and their correspondence to the program code, a number of studies on industrial systems (for example, <ref> [LHKS95] </ref>, [CS95]) reported one potential benefit of software metrics: the prediction of maintenance effort. We adopt the OO metrics proposed in [CK91], [LHKS95], [PHKV93], [CS95]. Table 4.2 summarises the implemented metrics. Name, definition and viewpoints are provided. Our metrics model is very simple. All measurement data is stored by attributes of class Metrics and derived classes specify which data is passed to visualisation and how this data is to be computed.
Reference: [MNB + 94] <author> Lawrence Markosian, Philip Newcomb, Russell Brand, Scott Bur-son, and Ted Kitzmiller. </author> <title> Using an enabling technology to reengineer legacy systems. </title> <journal> Communications of the ACM, </journal> <volume> 37(5) </volume> <pages> 58-70, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: The same program model can be reused together with different view models or the other way around. Different PA&V tools can also have the same program and view models but different mappings. The discussed architecture (as shown in Figure 2.1) shares many characteristics with Software Refinery <ref> [MNB + 94] </ref> a commercially available reengineering-tool development environment. The components of Software Refinery DIALECT, REFINE, WORKBENCH and INTERVISTA 5 imply the separation of program analysis and program presentation.
Reference: [MNS95] <author> G.C. Murphy, D. Notkin, and K. Sullivan. </author> <title> Software reflexion models: Bridging the gap between source and high-level models. </title> <booktitle> In The Third ACM Symposium on the Foundations of Software Engineering (FSE'95), </booktitle> <year> 1995. </year>
Reference: [MT82] <author> Grigori Mints and Enn Tyugu. </author> <title> Justification of the structural synthesis of programs. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 2(3) </volume> <pages> 215-240, </pages> <year> 1982. </year>
Reference-contexts: the following subsection, only the declarative part of the specification (e.g. the entire specification except the implementation of class methods) is mapped into logical axioms. 2.3.2 Logical language A logical justification for the NUT declarative language and its main reasoning procedure the structural synthesis of programs (SSP) is provided in <ref> [MT82] </ref> [Tyu91a] and, recently, in [Uus95]. The explanation is given in terms of intuitionistic propositional logic (IPL). Actually, the NUT environment that supports SSP works in a fragment of IPL. More complex logics were not used since IPL provides an acceptable trade-off between the specification language expressiveness and synthesis efficiency.
Reference: [PBS93] <author> B.A. Price, R.M. Baecker, </author> <title> and I.S. Small. A principled taxonomy of sofware visualization. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 4(3) </volume> <pages> 211-266, </pages> <year> 1993. </year>
Reference: [PHKV93] <author> Wim De Pauw, Richard Helm, Doug Kimelman, and John Vlis-sides. </author> <title> Visualizing the behavior of object-oriented systems. </title> <journal> ACM SIGPLAN Notices, OOPSLA'93, </journal> <volume> 28(10) </volume> <pages> 326-337, </pages> <year> 1993. </year>
Reference-contexts: Although OO metrics lack precise definitions of many fundamental quantities and their correspondence to the program code, a number of studies on industrial systems (for example, [LHKS95], [CS95]) reported one potential benefit of software metrics: the prediction of maintenance effort. We adopt the OO metrics proposed in [CK91], [LHKS95], <ref> [PHKV93] </ref>, [CS95]. Table 4.2 summarises the implemented metrics. Name, definition and viewpoints are provided. Our metrics model is very simple. All measurement data is stored by attributes of class Metrics and derived classes specify which data is passed to visualisation and how this data is to be computed.
Reference: [Qui94] <author> Alex Quilici. </author> <title> A memory-based approach to recognizing programming plans. </title> <journal> Communications of the ACM, </journal> <volume> 37(5) </volume> <pages> 84-93, </pages> <month> May </month> <year> 1994. </year>
Reference: [RBP + 91] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William Lorensen. </author> <title> Object-oriented Modeling and Design. </title> <publisher> Prentice Hall International, Inc., </publisher> <year> 1991. </year>
Reference-contexts: Some results of this experimentation are worth mentioning, because the lessons learned and difficulties encountered were not specific to the implementation environment but rather to the predefined specification method used. The OMT <ref> [RBP + 91] </ref> graphical notation was selected for the graphical presentation, because it includes notations for the representation of static, dynamic and functional aspects of a system. OMT graphical icons are simple to draw, adapt and modify. <p> The link to MatLab is transparent to the user, e.g. the visualisation in MatLab is specified by the user in the NUT language. Example 2.1. As an example, we take an OMT-based graphical presentation of a NUT program. The Object Modelling Technique (OMT) <ref> [RBP + 91] </ref> is a widespread object-oriented software development methodology, which employs a graphical notation for expressing object-oriented models. The pictures produced by the OMT-based visualiser are presented in Chapter 4 where a description of employed OMT graphical symbols is also provided. <p> The extraction of information from a C++ program is done by a parser, tuned to extract the information needed for the construction of our C++ model and to represent the extracted information in a NUT-compliant format. 4.1.2 View models OMT-based visualisation The Object Modelling Technique (OMT) <ref> [RBP + 91] </ref> is a widespread object-oriented software development methodology, which employs a graphical notation for expressing object-oriented models. The OMT graphical notation is not the only one recently proposed by OO researchers. We selected it, because OMT graphical icons are simple to draw, adapt and modify.
Reference: [RC93] <author> Gruia-Catalin Roman and Kenneth C. Cox. </author> <title> A taxonomy of program visualization systems. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 11-24, </pages> <month> Decem-ber </month> <year> 1993. </year>
Reference: [RCWP92] <author> Gruia-Catalin Roman, Kenneth C. Cox, C.Donald Wilcox, and Jerome Y. Plun. PAVANE: </author> <title> a system for declarative visualization of concurrent computations. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 3 </volume> <pages> 161-193, </pages> <year> 1992. </year>
Reference: [RW91] <author> David S. Rosenblum and Alexander L. Wolf. </author> <title> Representing semantically analyzed C++ code with Reprise. </title> <booktitle> In USENIX C++ Conference, </booktitle> <pages> pages 119-134, </pages> <year> 1991. </year>
Reference-contexts: We argue that the proposed architecture facilitates the modification, and assembly and reuse-of-parts of a PA&V tool. It is assumed that the user can 3 Abstract semantics graph is an abstract syntax tree annotated with semantic information such as the scope, type and value of symbols <ref> [RW91] </ref> 20 A Declarative PA&V toolkit change each model separately. Of course, he must take into account references from and to the model when introducing the changes, but, due to the imposed limitations on references, they can easily (even automatically) be detected 4 . <p> We focus on entities of OO programs (such as class, object) and capture program dependencies in the specifications of these entities. Our approach has many characteristics in common with approaches like REPRISE <ref> [RW91] </ref>, GEN++ [Dev94] and Smalltalk [GR83]. The conceptual model underlying REPRISE is an abstract semantics graph, which is an abstract syntax tree with added connections from each use of an entity to its declaration.
Reference: [SAT95] <author> Diana Sidarkeviciute, Mattin Addibpour, and Enn Tyugu. </author> <title> Experimental software analysis in the NUT system. </title> <type> Technical Report TRITA-IT 95:16, </type> <institution> Dept. of Teleinformatics, KTH, Sweden, </institution> <year> 1995. </year> <note> BIBLIOGRAPHY 77 </note>
Reference-contexts: In such a way, for example, the MatLab system 1 was attached to support data visualisation. 2.1.2 A toolkit for creating OMT-based views of a pro gram with the predefined specification method Our experimentation with PA&V in the NUT system started with the development of a toolkit <ref> [SAT95] </ref> for the automatic visualisation of NUT programs. Some results of this experimentation are worth mentioning, because the lessons learned and difficulties encountered were not specific to the implementation environment but rather to the predefined specification method used. <p> The libraries are loaded dynamically. The extraction of information from the NUT program is supported by a set of reflective functions <ref> [SAT95] </ref>, such as get classes, get var, get rel, etc. The set of available functions covers the extraction of all entities and relations according to the ontology (or model) of the NUT program. The existence of reflective functions in NUT considerably facilitates our program analysis task.
Reference: [Sch91] <author> Klaus Schild. </author> <title> A correspondence theory for terminological logics: Preliminary report. </title> <booktitle> In Proceedings of the 12th International Joint Conference on Artificial Intelligence, IJCAI'91, </booktitle> <pages> pages 466-471, </pages> <address> Sydney, Australia, </address> <year> 1991. </year>
Reference-contexts: Two major factors could support this alternative. First, [Uus96] provides a modal justification for the NUT declarative language. Second, <ref> [Sch91] </ref> advocates that ALU N is a notational variant of propositional modal logic.
Reference: [SH94] <author> Peter G. Selfridge and George T. Heineman. </author> <title> Graphical support for code-level software understanding. </title> <booktitle> In The Ninth Knowledge-based Software Engineering Conference, </booktitle> <pages> pages 117-124. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference: [Shu88] <author> N.C. Shu. </author> <title> Visual Programming. </title> <publisher> Van Nostrand Reinhold Company, </publisher> <address> New York, </address> <year> 1988. </year>
Reference: [Sid97] <author> Diana Sidarkeviciute. </author> <title> Program analysis and visualisation: Towards a declarative approach. </title> <journal> Informatica, </journal> <volume> 8(1), </volume> <year> 1997. </year>
Reference-contexts: Thus, objects are treated as worlds and component relations between objects as accessibility relations between worlds. An explanation of the synthesis of PA&V tools in terms of a modal logic was exposed in <ref> [Sid97] </ref>. 2.3.3 Proof The inference carried out by the NUT system is provable realizability [Uus95]. Its main goal is to prove the computability or non-computability of an object or its components. If computability can be proven, an algorithm (or a program) for its computation is synthesised.
Reference: [Sta90] <author> John T. Stasko. </author> <title> TANGO: A framework and system for algorithm animation. </title> <journal> Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <month> September </month> <year> 1990. </year>
Reference: [Tyu91a] <author> Enn Tyugu. </author> <title> Declarative programming in a type theory. </title> <editor> In B. Moller, editor, </editor> <title> Constructing Programs from Specifications. </title> <publisher> Else-vier Science Publishers B.V., North-Holland, </publisher> <year> 1991. </year>
Reference-contexts: following subsection, only the declarative part of the specification (e.g. the entire specification except the implementation of class methods) is mapped into logical axioms. 2.3.2 Logical language A logical justification for the NUT declarative language and its main reasoning procedure the structural synthesis of programs (SSP) is provided in [MT82] <ref> [Tyu91a] </ref> and, recently, in [Uus95]. The explanation is given in terms of intuitionistic propositional logic (IPL). Actually, the NUT environment that supports SSP works in a fragment of IPL. More complex logics were not used since IPL provides an acceptable trade-off between the specification language expressiveness and synthesis efficiency.
Reference: [Tyu91b] <author> Enn Tyugu. </author> <title> Three new generation software environments. </title> <journal> Communications of the ACM, </journal> <volume> 34(6) </volume> <pages> 46-59, </pages> <year> 1991. </year>
Reference-contexts: Thus, here we present and discuss only those features which are most relevant to our PA&V toolkit. 15 16 A Declarative PA&V toolkit The NUT language and its tools. The NUT programming language <ref> [Tyu91b] </ref> rests on two paradigms: object-oriented programming and the automatic synthesis of programs from declarative specifications.
Reference: [UKK + 94] <author> Tarmo Uustalu, Urmas Kopra, Vahur Kotkas, Michail Matskin, and Enn Tyugu. </author> <title> The NUT language report. </title> <institution> Technical Report TRITA-IT R 94:14, Dept. of Teleinformatics, KTH, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: The automatic synthesis of programs, as practised in NUT, is based on proof search in intuitionistic propositional logic (a more detailed description of the NUT system and language can be found in <ref> [UKK + 94] </ref>). The NUT language is supported by various tools such as a compiler and a language-oriented editor. Different synthesis modes allow, for example, to synthesise new PA&V tools without execution or the like. The syntax and informal semantics of the NUT declarative language are given in the Appendix.
Reference: [Uus95] <author> Tarmo Uustalu. </author> <title> Aspects of structural synthesis of programs. </title> <institution> Lic. Thesis TRITA-IT R 95:09, Dept. of Teleinformatics, KTH, </institution> <year> 1995. </year>
Reference-contexts: declarative part of the specification (e.g. the entire specification except the implementation of class methods) is mapped into logical axioms. 2.3.2 Logical language A logical justification for the NUT declarative language and its main reasoning procedure the structural synthesis of programs (SSP) is provided in [MT82] [Tyu91a] and, recently, in <ref> [Uus95] </ref>. The explanation is given in terms of intuitionistic propositional logic (IPL). Actually, the NUT environment that supports SSP works in a fragment of IPL. More complex logics were not used since IPL provides an acceptable trade-off between the specification language expressiveness and synthesis efficiency. <p> Thus, objects are treated as worlds and component relations between objects as accessibility relations between worlds. An explanation of the synthesis of PA&V tools in terms of a modal logic was exposed in [Sid97]. 2.3.3 Proof The inference carried out by the NUT system is provable realizability <ref> [Uus95] </ref>. Its main goal is to prove the computability or non-computability of an object or its components. If computability can be proven, an algorithm (or a program) for its computation is synthesised. The complete and sound set of natural deduction rules of structural synthesis of programs (SSP) is provided in [Uus95] <p> <ref> [Uus95] </ref>. Its main goal is to prove the computability or non-computability of an object or its components. If computability can be proven, an algorithm (or a program) for its computation is synthesised. The complete and sound set of natural deduction rules of structural synthesis of programs (SSP) is provided in [Uus95] and presented below. The Proof Rules of SSP X 1 : : : X n . . . . X oe Y Y U 11 : : : U 1l 1 . . . . U m1 : : : U ml m . . . . <p> Some words should be said about the efficiency. To this purpose, we repeat the discussion presented in <ref> [Uus95] </ref>. The general problem of provability in intuitionistic propositional logic is PSPACE-complete. However, the synthesis problems encountered in practice (as the synthesis of PA&V tools) are proof-theoretically easy, e.g. have proofs with a low degree of hypothesis interaction. <p> has more than n R-succesors in S, y; z are two R-successors of x such that y _ 6=z is not in S 3.2 A mapping 39 3.2 A mapping from the NUT language to ALU N The syntax and informal semantics of the NUT declarative language are given in <ref> [Uus95] </ref> and shortly presented in the Appendix. The mapping from the NUT declarative language to ALUN is motivated by the informal semantics of the declarative constructs of NUT.
Reference: [Uus96] <author> Tarmo Uustalu. </author> <title> A modal justification for structural synthesis of programs in NUT. </title> <type> Technical Report TRITA-IT 96:06, </type> <institution> Dept. of Teleinformatics, KTH, Sweden, </institution> <year> 1996. </year>
Reference-contexts: A logical justification, which does not need flattening, was recently provided in <ref> [Uus96] </ref> and uses a simple intuitionistic normal modal logic. <p> Two major factors could support this alternative. First, <ref> [Uus96] </ref> provides a modal justification for the NUT declarative language. Second, [Sch91] advocates that ALU N is a notational variant of propositional modal logic.
Reference: [Val96] <author> Rando Valt. </author> <title> Extensions to the NUT environment. </title> <type> Technical Report TRITA-IT 96:12, </type> <institution> Dept. of Teleinformatics, KTH, Sweden, </institution> <year> 1996. </year>
Reference-contexts: Extensibility and interoperability. Extensions to libraries of NUT functions or attachments of other tools can be implemented via dynamically load-able C-libraries <ref> [Val96] </ref>. Thus, specialised program libraries or program systems can be neatly integrated with the NUT system. <p> In order to facilitate the understanding of connectionist schemes, we use mnemonic images of classes. These images are created when classes are specified, and together with some essential information about the classes, they represent the ontology of a package. The interface model was proposed and developed in <ref> [Val96] </ref>. It implements the automatic construction of a graphical user interface: briefly, the actions of the interface are collected from the methods of TkInterface subclasses. Of course, due to the existence of the NUT-Tcl/Tk connection, the user can develop his own interface model.
Reference: [WH92] <author> Norman Wilde and Ross Huitt. </author> <title> Maintenance support for object-oriented programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(12) </volume> <pages> 1038-1044, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: When developing program models we focussed on program dependencies in object-oriented programs 1 . A list of such dependencies is provided in <ref> [WH92] </ref> and includes dependencies of conventional programs and the ones specific to OO programs. The latter include class-to-class, class-to-method, class-to-message, class-to-variable, method-to-variable, method-to-message, method-to-method dependencies. We consider only class-to-class dependencies, e.g. inheritance, aggregation and usage ("for interface" and, partly, "for implementation") dependencies.
Reference: [Wil92] <author> Linda Mary Wills. </author> <title> Automated Program Recognition by Graph Parsing. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1992. </year> <note> 78 BIBLIOGRAPHY </note>
References-found: 54

