URL: http://www.cs.berkeley.edu/~suchi/papers/MS.ps.gz
Refering-URL: http://www.cs.berkeley.edu/~suchi/papers/raman-mm98/index.html
Root-URL: 
Abstract: The Application Level Framing (ALF) protocol architecture [3] encourages application control over mechanisms that traditionally fall within the transport layer, e.g., loss detection and recovery. Traditional ARQ-based reliable protocols for unicast (e.g., TCP) as well as multicast (e.g., Horus [38], RMTP [17], etc.) number data units sequentially to detect losses. These transport-level sequence numbers do not permit receivers to flexibly tailor their reliability semantics. Achieving receiver-driven reliability is cumbersome in the existing layered architecture of the network protocol stack where the receiving application has no knowledge of the mapping from application-level objects to transport level sequence numbers. This is an undesirable effect of the traditional model of protocol design that emphasizes information hiding between layers. In this thesis, we propose a new data naming scheme that exposes the structure of application data to the transport layer, thereby enhancing the expressibility of an applications' reliability and ordering semantics. We apply this data naming scheme to a reliable multicast protocol framework to achieve receiver-tailored reliability that greatly enhances its scalability. We have designed and implemented our scalable naming and announcement protocol (SNAP) in the MASH toolkit [21] as a reusable protocol module. At the core of our reliable multicast protocol engine is the randomized timer algorithm for loss recovery based on the Scalable, Reliable Multicast protocol [9]. Using a combination of simulation and analysis, we investigate the asymptotic scaling behavior of this algorithm in extremely large group sizes. We study the protocol's control traffic overhead as a function of group size for various topologies and protocol parameters, on a set of simple, representative topologies the cone (a variant of a clique), the linear chain, and the binary tree. We find that this overhead, as a function of group size, depends strongly on the topology: for the cone, it is always linear; for the chain, it is between constant and logarithmic; and for the tree, it is between constant and linear. The two fundamental contributions of this thesis are (i) the Scalable Naming and Announcement Protocol (SNAP), and (ii) an analysis of the randomized timer algorithm for loss recovery in SRM and SNAP. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Tony Ballardie, Paul Francis, and Jon Crowcroft. </author> <title> Core Based Trees (CBT) An Architecture for Scalable Inter-Domain Multicast Routing. </title> <booktitle> In Proceedings of SIGCOMM '93, </booktitle> <pages> pages 85-95, </pages> <address> San Francisco, CA, </address> <month> September </month> <year> 1993. </year> <note> ACM. </note>
Reference-contexts: In this model, the network delivers a packet from a source to an arbitrary number of receivers by forwarding a copy of that packet along each link of a distribution tree rooted at the source subnet (or, depending on the routing protocol, at a rendezvous point [6] or core router <ref> [1] </ref>). As with unicast, IP multicast is not reliable packets might be dropped at any point along the distribution tree. However, many new multicast applications like shared white-boards [14], webcast tools [29], and distributed simulation are not tolerant to packet loss. <p> 1 + C 2 r) where backoff is the amount of delay, D is an estimate of the one-way delay from the receiver to the source that generated the lost data packet, C 1 ; C 2 are non-negative protocol constants, and r is a uniformly distributed random number in <ref> [0; 1] </ref>. <p> a single NACK L Average NACK latency caused by backoff D i Estimate of one-way delay from node i to the source node backoff i , D i fi (C 1 + C 2 fi r i ) at host i where, r i are uniformly distributed random variables in <ref> [0; 1] </ref> t i Absolute time at which receiver i's timer fires Table 3.1: Summary of notation 3.4 Scaling in the Cone Topology The cone topology models the case of a broadcast LAN. <p> The average delay in transmitting the first NACK depends on the expected value of the minimum timer and is given by (C 1 +C 2 ) G+1 . This result follows directly from noting that the expectation of the minimum of G uniformly distributed random variables in <ref> [0; 1] </ref> is 1 G+1 . The number of duplicates is equal to the expected number of timers that fire within [t min ; t min + ffi], where t min is the value of the smallest timer. <p> + d ji d i + r i ffi; 8j 6= i where d j is the one-way delay to receiver j from the source and d ij is the one-way delay from receiver i to receiver j. r i ; r j are uniformly distributed random numbers picked in <ref> [0; 1] </ref> by the random timer mechanism. We then must have: r i &lt; r j ; 8j &lt; i (3.1) d ij ffi; 8d ij (3.3) From equation 3.4 above, we can conclude that a NACK at node i cannot be suppressed by a NACK at a later node. <p> Pick Containers (n, C, w) n is the target number of containers C is the set of all containers, jCj &gt; n w : C ! Z + , is the weight function <ref> [1] </ref> total P [2] m n log n [3] while m do rand [m] random (0; total) 49 sort (rand) [4] while n do j 0 total 0 success 0 while (c 2 C) ^ (i n log n) do [5] if rand [i] &lt; total then c next container [6]
Reference: [2] <author> G. Chesson. </author> <title> XTP/protocol engine design. </title> <booktitle> In Proceedings of the IFIP WG6.1/6.4 Workshop, R uschlikon, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: section describes these problems and motivates the need for an integrated data naming scheme between the application and the reliable multicast transport protocol, using ALF concepts. 1.2.1 Data Buffering One of the main problems in designing a reliable multicast protocol in a scalable manner is the problem of message implosion <ref> [28, 2, 9] </ref>. In a positive acknowledgment-based reliable multicast scheme, each correctly received packet results in a storm of acknowledgments towards the source overwhelming it and congesting the routers en route. Many reliable multicast algorithms [2, 13, 9] therefore resort to negative acknowledgments from receivers to detect lost packets. <p> In a positive acknowledgment-based reliable multicast scheme, each correctly received packet results in a storm of acknowledgments towards the source overwhelming it and congesting the routers en route. Many reliable multicast algorithms <ref> [2, 13, 9] </ref> therefore resort to negative acknowledgments from receivers to detect lost packets. In such schemes, the source must buffer transmitted packets in order to respond to NAKs. For long-lived applications, such as a shared whiteboard session, this buffering requirement at the transport protocol is unbounded. <p> Pick Containers (n, C, w) n is the target number of containers C is the set of all containers, jCj &gt; n w : C ! Z + , is the weight function [1] total P <ref> [2] </ref> m n log n [3] while m do rand [m] random (0; total) 49 sort (rand) [4] while n do j 0 total 0 success 0 while (c 2 C) ^ (i n log n) do [5] if rand [i] &lt; total then c next container [6] if : selected
Reference: [3] <author> David D. Clark and David L. Tennenhouse. </author> <title> Architectural Considerations for a New Generation of Protocols. </title> <booktitle> In Proceedings of SIGCOMM '90, </booktitle> <address> Philadelphia, PA, </address> <month> September </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: This method of accounting for application semantics in protocol design, known as Application Level Framing or ALF <ref> [3] </ref>, is a boon to protocol performance because the application is optimized for the network and vice versa, but it burdens the implementor with a potentially difficult protocol design problem. <p> The SNAP protocol uses a slotting and damping mechanism similar to SRM. SRM is a negative acknowledgment-based (NAK-based), fully-decentralized reliable multicast protocol originally described by Floyd, et al., in [9]. The SRM framework builds on Clark and Tennenhouse's principle of Application Level Framing (ALF) <ref> [3] </ref>, which provides an elegant solution to the problem of reliable-multicast API design because its flexibility offers applications the opportunity to actively participate in the loss-recovery procedure. To avoid ACK-implosion, SRM uses NAKs. <p> We implemented SNAP as a library of classes in the toolkit. SNAP runs at user-level in the same address space as the application. Since the application and protocol share an address space, upcalls <ref> [3] </ref> by the transport protocol to query the application are implemented as function calls. The namemap that implements the mapping from names to transport level identifiers is a separate modules shown in Figure 2.9. 2.6 Function Call API This section describes the function call API of our implementation of SNAP. <p> Pick Containers (n, C, w) n is the target number of containers C is the set of all containers, jCj &gt; n w : C ! Z + , is the weight function [1] total P [2] m n log n <ref> [3] </ref> while m do rand [m] random (0; total) 49 sort (rand) [4] while n do j 0 total 0 success 0 while (c 2 C) ^ (i n log n) do [5] if rand [i] &lt; total then c next container [6] if : selected (c) ^ (rand [i] &lt;
Reference: [4] <author> J. Crowcroft, Z. Wang, A. Ghosh, and C. Diot. RMFP: </author> <title> A Reliable Multicast Framing Protocol, </title> <month> March </month> <year> 1997. </year> <title> Internet Draft (RFC pending). </title>
Reference-contexts: Most of the existing work focuses on algorithms that ignore application interests. While the independence of transport-level reliability and congestion control algorithms from the application have obvious value, augmenting these with a naming scheme that enables receiver-reliability enhances the scaling properties of the protocol. A recent Internet draft <ref> [4] </ref> on RMFP proposes a two-layered data stream with embedded objects and sequence offsets within objects. This work is orthogonal and complementary to our scalable session announcement protocol. <p> C, w) n is the target number of containers C is the set of all containers, jCj &gt; n w : C ! Z + , is the weight function [1] total P [2] m n log n [3] while m do rand [m] random (0; total) 49 sort (rand) <ref> [4] </ref> while n do j 0 total 0 success 0 while (c 2 C) ^ (i n log n) do [5] if rand [i] &lt; total then c next container [6] if : selected (c) ^ (rand [i] &lt; total + w [c]) then selected (c) = T RU E success
Reference: [5] <author> Brian DeCleene, Supratik Bhattacharaya, Timur Friedman, Mark Keaton, Jim Kurose, Dan Rubenstein, and Don Towsley. </author> <title> Reliable Multicast Framework(RMF): A White Paper, </title> <month> March </month> <year> 1997. </year>
Reference-contexts: This introduces extra message types and restricts applications to use ASCII string names. Separating the namemap module from the core SRM namespace mechanisms provides the application with the flexibility to use any naming convention of choice. Other work on a reliable multicast framework (RMF) <ref> [5] </ref> proposes universal receivers, a concept that allows several protocols to be defined using a set of common packet formats. <p> : C ! Z + , is the weight function [1] total P [2] m n log n [3] while m do rand [m] random (0; total) 49 sort (rand) [4] while n do j 0 total 0 success 0 while (c 2 C) ^ (i n log n) do <ref> [5] </ref> if rand [i] &lt; total then c next container [6] if : selected (c) ^ (rand [i] &lt; total + w [c]) then selected (c) = T RU E success success + 1 total total + w [c] w [c] BASE P RIO c next container if (success = n)
Reference: [6] <author> Stephen Deering, Deborah Estrin, Dino Farinacci, and Van Jacobson. </author> <title> An Architecture for Wide-Area Multicast Routing. </title> <booktitle> In Proceedings of SIGCOMM '94, </booktitle> <address> University College London, London, U.K., </address> <month> September </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: In this model, the network delivers a packet from a source to an arbitrary number of receivers by forwarding a copy of that packet along each link of a distribution tree rooted at the source subnet (or, depending on the routing protocol, at a rendezvous point <ref> [6] </ref> or core router [1]). As with unicast, IP multicast is not reliable packets might be dropped at any point along the distribution tree. However, many new multicast applications like shared white-boards [14], webcast tools [29], and distributed simulation are not tolerant to packet loss. <p> [1] total P [2] m n log n [3] while m do rand [m] random (0; total) 49 sort (rand) [4] while n do j 0 total 0 success 0 while (c 2 C) ^ (i n log n) do [5] if rand [i] &lt; total then c next container <ref> [6] </ref> if : selected (c) ^ (rand [i] &lt; total + w [c]) then selected (c) = T RU E success success + 1 total total + w [c] w [c] BASE P RIO c next container if (success = n) then return selected containers [7] if : selected (c) ^
Reference: [7] <author> Stephen E. Deering. </author> <title> Multicast Routing in a Datagram Internetwork. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Introduction 1.1 Introduction The advent and deployment of IP Multicast <ref> [7] </ref> has enabled a number of new applications [23, 15, 14, 10, 37] that utilize large-scale multi-point communication over wide-area internetworks. IP Multicast extends the traditional, best-effort unicast delivery model of the Internet architecture to enable efficient multi-point packet delivery. <p> total then c next container [6] if : selected (c) ^ (rand [i] &lt; total + w [c]) then selected (c) = T RU E success success + 1 total total + w [c] w [c] BASE P RIO c next container if (success = n) then return selected containers <ref> [7] </ref> if : selected (c) ^ (total + w [c] &lt; rand [i]) then total total + w [c] c next container n n success 50 Appendix B Header Formats In this appendix, we describe the packet formats used in our current prototype implementation of the SNAP protocol.
Reference: [8] <author> R. Fielding, J. Gettys, J. Mogul, H. Frystyk, and T. Berners-Lee. </author> <title> Hypertext Transfer Protocol - HTTP/1.1, Jan 1997. </title> <publisher> RFC-2068. </publisher>
Reference-contexts: To minimize user-perceived latency, these components could be disseminated in par 4 allel to each receiver. If the application used a sequence-based TCP-like protocol, data across all the individual components would be coalesced into a single stream (much like Persistent-HTTP in HTTP 1.1 <ref> [8] </ref>). This imposes an artificial serial order amongst the different components, where none was mandated, resulting in increased latency for many data items. In addition, the loss of data on one component could stall the delivery of data belonging to another one, because of the imposed in-order delivery abstraction.
Reference: [9] <author> Sally Floyd, Van Jacobson, Steven McCanne, Ching-Gung Liu, and Lixia Zhang. </author> <title> A Reliable 56 Multicast Framework for Light-weight Sessions and Application Level Framing. </title> <booktitle> In Proceedings of SIGCOMM '95, </booktitle> <address> Boston, MA, </address> <month> September </month> <year> 1995. </year> <note> ACM. </note>
Reference-contexts: Although mechanisms for reliable unicast transmission are comparatively well-understood and have proven extremely successful (e.g., TCP), making multicast reliable at large scales remains a formidable challenge. Though a number of wide-area reliable multicast protocols have been proposed <ref> [17, 32, 9, 16] </ref>, none currently satisfies the requirements for safe deployment in the global Internet because no existing scheme simultaneously provides (1) scalability to very large multicast sessions, (2) congestion control that accommodates constrained and potentially heterogeneous link bandwidths, and (3) a rich and configurable range of reliability semantics. <p> section describes these problems and motivates the need for an integrated data naming scheme between the application and the reliable multicast transport protocol, using ALF concepts. 1.2.1 Data Buffering One of the main problems in designing a reliable multicast protocol in a scalable manner is the problem of message implosion <ref> [28, 2, 9] </ref>. In a positive acknowledgment-based reliable multicast scheme, each correctly received packet results in a storm of acknowledgments towards the source overwhelming it and congesting the routers en route. Many reliable multicast algorithms [2, 13, 9] therefore resort to negative acknowledgments from receivers to detect lost packets. <p> In a positive acknowledgment-based reliable multicast scheme, each correctly received packet results in a storm of acknowledgments towards the source overwhelming it and congesting the routers en route. Many reliable multicast algorithms <ref> [2, 13, 9] </ref> therefore resort to negative acknowledgments from receivers to detect lost packets. In such schemes, the source must buffer transmitted packets in order to respond to NAKs. For long-lived applications, such as a shared whiteboard session, this buffering requirement at the transport protocol is unbounded. <p> The SNAP protocol uses a slotting and damping mechanism similar to SRM. SRM is a negative acknowledgment-based (NAK-based), fully-decentralized reliable multicast protocol originally described by Floyd, et al., in <ref> [9] </ref>. The SRM framework builds on Clark and Tennenhouse's principle of Application Level Framing (ALF) [3], which provides an elegant solution to the problem of reliable-multicast API design because its flexibility offers applications the opportunity to actively participate in the loss-recovery procedure. To avoid ACK-implosion, SRM uses NAKs. <p> Figure 1.2 illustrates the suppression mechanism in SRM. As in <ref> [9] </ref>, we call C 1 D the deterministic delay and C 2 Dr the random delay. <p> The seminal work of Floyd et al. <ref> [9] </ref> simulated group sizes of up to a few hundred nodes ranging across a set of simple topologies. They showed that it was often possible to choose values of C 1 and C 2 that resulted in N (G) scaling as a constant independent of G. <p> They also proposed an adaptive algorithm to dynamically adjust C 1 and C 2 based on past information for better performance. Our work extends their important findings in two ways. First, we investigate performance for session sizes of up to two orders of magnitude larger than in <ref> [9] </ref>, thus improving our collective understanding of SRM's asymptotic behavior. Reassuringly, our results agree with [9] where the experiments overlap. More generally, we have assessed in detail the behavior of N (G) as a function of C 1 and C 2 . <p> Our work extends their important findings in two ways. First, we investigate performance for session sizes of up to two orders of magnitude larger than in <ref> [9] </ref>, thus improving our collective understanding of SRM's asymptotic behavior. Reassuringly, our results agree with [9] where the experiments overlap. More generally, we have assessed in detail the behavior of N (G) as a function of C 1 and C 2 . <p> This paper is primarily concerned with global recovery in SRM with constant C 1 and C 2 . Variants of SRM have been proposed that use local recovery, in which NACKs and repairs are not sent to the entire group. <ref> [9] </ref>, [18] look at two methods to limit the range of these methods: hop-scoping, and local recovery groups. [19] considers methods for adaptively setting the values for C 1 and C 2 . We do not consider any of the local recovery methods, nor adaptive timer setting. <p> Defining ff = ffi C 2 we have, E [N ] = &lt; 1 + Gff ff G ; ff &lt; 1 Thus, the number of duplicates is roughly linear in the group size. <ref> [9] </ref> reports a similar result for the star topology, which is a cone with = ffi. Observe that this linear dependence applies regardless 33 of whether the delay estimates are accurate or not. <p> Several solutions have been proposed for local recovery in the literature <ref> [17, 9, 27, 33] </ref>. Integrating SNAP with a local recovery scheme could provide greater scalability. * A key ingredient to the success of the general framework approach to reliable multicast is experience drawn from design and implementation of a variety of applications.
Reference: [10] <author> Ron Frederick. </author> <title> Network Video (nv). </title> <institution> Xerox Palo Alto Research Center. ftp://ftp.parc.xerox.com/net-research. </institution>
Reference-contexts: Introduction 1.1 Introduction The advent and deployment of IP Multicast [7] has enabled a number of new applications <ref> [23, 15, 14, 10, 37] </ref> that utilize large-scale multi-point communication over wide-area internetworks. IP Multicast extends the traditional, best-effort unicast delivery model of the Internet architecture to enable efficient multi-point packet delivery.
Reference: [11] <author> R. L. Graham, D. E. Knuth, and O. Patashnik. </author> <title> Concrete Mathematics. </title> <publisher> Addison-Wesley, </publisher> <address> second edition, </address> <year> 1994. </year>
Reference-contexts: We use a randomized scheme similar to lottery scheduling [39]. The analysis of this algorithm is akin to the coupon collectors problem <ref> [11] </ref>. The expected time to select k distinct containers from among a total of n containers is given by O (k log k). The details of the algorithm and its analysis are shown in Appendix A. <p> However, the difference in our case, we need to select n winners. We first generate a list of n log n winners (random numbers), since the expected number of trials before n distinct winners can be chosen is given by n log n <ref> [11] </ref>. The winners are then sorted so that a single scan through the set of all containers gives us the list of distinct winning containers. Hence the expected time of the algorithm is proportional to (n log n + n log 2 n + jCj).
Reference: [12] <author> Mark Handley. </author> <title> SAP: Session Announcement Protocol. Internet Draft, </title> <address> Nov 19, </address> <year> 1996. </year>
Reference-contexts: Source-based announcements fall in the general category of announce-listen protocols where sources periodically announce their data and receivers listen to these announcements to reconstruct the data. Announce-listen protocols are conceptually simple and do not suffer from feeback implosion problems when used over IP multicast. The session announcement protocol (SAP) <ref> [12] </ref> is an open loop reliable protocol that multicasts data periodically. A receiver simply waits for source 3 Alternatively, an application declares its preferences in a profile at startup time. 16 announcements to receive all data.
Reference: [13] <author> Hugh Holbrook, Sandeep Singhal, and David Cheriton. </author> <title> Log-Based Receiver-Reliable Multi-cast for Distributed Interactive Simulation. </title> <booktitle> In Proceedings of SIGCOMM '95, </booktitle> <address> Boston, MA, </address> <month> September </month> <year> 1995. </year> <note> ACM. </note>
Reference-contexts: In a positive acknowledgment-based reliable multicast scheme, each correctly received packet results in a storm of acknowledgments towards the source overwhelming it and congesting the routers en route. Many reliable multicast algorithms <ref> [2, 13, 9] </ref> therefore resort to negative acknowledgments from receivers to detect lost packets. In such schemes, the source must buffer transmitted packets in order to respond to NAKs. For long-lived applications, such as a shared whiteboard session, this buffering requirement at the transport protocol is unbounded.
Reference: [14] <author> Van Jacobson and Steven McCanne. </author> <note> LBL Whiteboard. </note> <institution> Lawrence Berkeley Laboratory. ftp://ftp.ee.lbl.gov/conferencing/wb. </institution>
Reference-contexts: Introduction 1.1 Introduction The advent and deployment of IP Multicast [7] has enabled a number of new applications <ref> [23, 15, 14, 10, 37] </ref> that utilize large-scale multi-point communication over wide-area internetworks. IP Multicast extends the traditional, best-effort unicast delivery model of the Internet architecture to enable efficient multi-point packet delivery. <p> As with unicast, IP multicast is not reliable packets might be dropped at any point along the distribution tree. However, many new multicast applications like shared white-boards <ref> [14] </ref>, webcast tools [29], and distributed simulation are not tolerant to packet loss. Whiteboard state, for example, is persistent; if a piece of a drawing update is lost, the application cannot leave the drawing in an incomplete state. <p> Sequence numbers generated at the sender side of the transport protocol alone are grossly inadequate for this. Several applications require sophisticated control over what portions of a data space they need reliably delivered. For example, in the shared whiteboard application <ref> [14, 36] </ref>, receivers do not require immediate recovery of items on pages not currently being viewed. Since loss recovery is initiated by the receiver, the receiving application must have sufficient information to determine whether a loss needs to be repaired. <p> At the receiving side, data is passed up to the application in ADU units, as determined by the sender. Examples of an ADU include a single scan of a JPEG image, or a whiteboard drawing operation <ref> [14] </ref>. While applications can generate ADUs of arbitrary sizes, a packet, which is the unit of network transmission is at most the network maximum transmission unit (MTU).
Reference: [15] <author> Van Jacobson and Steven McCanne. </author> <title> Visual Audio Tool. </title> <institution> Lawrence Berkeley Laboratory. ftp://ftp.ee.lbl.gov/conferencing/vat. </institution>
Reference-contexts: Introduction 1.1 Introduction The advent and deployment of IP Multicast [7] has enabled a number of new applications <ref> [23, 15, 14, 10, 37] </ref> that utilize large-scale multi-point communication over wide-area internetworks. IP Multicast extends the traditional, best-effort unicast delivery model of the Internet architecture to enable efficient multi-point packet delivery.
Reference: [16] <author> B. Levine, D. B. Lavo, and J. J. Garcia-Luna-Aceves. </author> <title> The Case for Concurrent Reliable Multi-casting Using Shared Ack Trees. </title> <booktitle> In Proceedings of ACM Multimedia, </booktitle> <address> Boston, MA, </address> <month> November </month> <year> 1996. </year> <note> ACM. </note>
Reference-contexts: Although mechanisms for reliable unicast transmission are comparatively well-understood and have proven extremely successful (e.g., TCP), making multicast reliable at large scales remains a formidable challenge. Though a number of wide-area reliable multicast protocols have been proposed <ref> [17, 32, 9, 16] </ref>, none currently satisfies the requirements for safe deployment in the global Internet because no existing scheme simultaneously provides (1) scalability to very large multicast sessions, (2) congestion control that accommodates constrained and potentially heterogeneous link bandwidths, and (3) a rich and configurable range of reliability semantics.
Reference: [17] <author> John C. Lin and Sanjoy Paul. RMTP: </author> <title> A Reliable Multicast Transport Protocol. </title> <booktitle> In Proceedings IEEE Infocom '96, </booktitle> <pages> pages 1414-1424, </pages> <address> San Francisco, CA, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: Although mechanisms for reliable unicast transmission are comparatively well-understood and have proven extremely successful (e.g., TCP), making multicast reliable at large scales remains a formidable challenge. Though a number of wide-area reliable multicast protocols have been proposed <ref> [17, 32, 9, 16] </ref>, none currently satisfies the requirements for safe deployment in the global Internet because no existing scheme simultaneously provides (1) scalability to very large multicast sessions, (2) congestion control that accommodates constrained and potentially heterogeneous link bandwidths, and (3) a rich and configurable range of reliability semantics. <p> Several solutions have been proposed for local recovery in the literature <ref> [17, 9, 27, 33] </ref>. Integrating SNAP with a local recovery scheme could provide greater scalability. * A key ingredient to the success of the general framework approach to reliable multicast is experience drawn from design and implementation of a variety of applications.
Reference: [18] <author> Ching-Gung Liu, Deborah Estrin, Scott Shenker, and Lixia Zhang. </author> <title> Local Recovery in SRM. </title> <journal> Submitted to IEEE Transactions on Networking, </journal> <year> 1998. </year>
Reference-contexts: This paper is primarily concerned with global recovery in SRM with constant C 1 and C 2 . Variants of SRM have been proposed that use local recovery, in which NACKs and repairs are not sent to the entire group. [9], <ref> [18] </ref> look at two methods to limit the range of these methods: hop-scoping, and local recovery groups. [19] considers methods for adaptively setting the values for C 1 and C 2 . We do not consider any of the local recovery methods, nor adaptive timer setting.
Reference: [19] <author> Ching-Gung Liu, Deborah Estrin, Scott Shenker, and Lixia Zhang. </author> <title> Recovery Timer Adaptation in SRM. </title> <journal> Submitted to IEEE Transactions on Networking, </journal> <year> 1998. </year>
Reference-contexts: We also briefly consider the case where C 1 and C 2 are a function of the location in the topology; this aspect of our work was inspired by the results on adaptive timers in <ref> [19] </ref>. There, the timer constants were set in response to the number of duplicates observed and the latency of the responses, and this naturally led to the parameters being different for different members e.g., members located at different depths in a tree would have different settings. <p> Not only do these results help us predict the performance of SRM, but they could influence the design of related sub-components of SRM, e.g., the choice of bounding values of C 1 and C 2 in the proposed adaptive algorithm. A more recent paper <ref> [19] </ref> studied scaling behavior for group sizes up to 200 members, with C 1 = 0 and C 2 set adaptively. In addition, Nonnenmacher and Biersack [25] looked at the effect of timer distribution on scaling behavior and showed that exponentially distributed timers yield better scaling properties. <p> Variants of SRM have been proposed that use local recovery, in which NACKs and repairs are not sent to the entire group. [9], [18] look at two methods to limit the range of these methods: hop-scoping, and local recovery groups. <ref> [19] </ref> considers methods for adaptively setting the values for C 1 and C 2 . We do not consider any of the local recovery methods, nor adaptive timer setting. <p> In order to reduce this growth in N (G) to a constant, while still retaining C 1 = 0 for the sake of low latency, we can make C 2 a function of the delay from the source. This follows the work Liu et al. who propose, in <ref> [19] </ref>, 37 using a new adaptive timer algorithm. Analysis similar to the previous case (equation (3.4)) shows that the number of duplicates is bounded by a constant when we use C 2 = D * for any * &gt; 0. <p> In order to reduce this growth in N (G) to a constant, while still retaining C 1 = 0, as we did for the linear chain topology, we make C 2 a function of the delay from the source. The adaptation algorithm described in <ref> [19] </ref> results in C 2 values that increase roughly linearly in D, the distance of a receiver from the source. Here we do not model the dynamics of the adaptation, but instead merely insert the dependence on D directly.
Reference: [20] <author> Steven McCanne et al. </author> <note> Ucb/lbnl/vint network simulator - ns (version 2). http://www-mash.cs.berkeley.edu/ns/. </note>
Reference-contexts: First, R recovers missing bindings from the map. Missing data from the containers I ; J; and K is then recovered. 2.4 SNAP: Performance Evaluation To evaluate the performance of SNAP within the SRM framework, we conducted a simulation study using the network simulator ns <ref> [20] </ref>. We used a single source with up to 55 receivers. Background traffic in the simulations was generated using TCP connections.
Reference: [21] <author> Steven McCanne et al. </author> <title> Towards a Common Infrastructure for Multimedia-Networking Mid-dleware. </title> <booktitle> In Proceedings of the Seventh International Workshop on Network and OS Support for Digital Audio and Video, </booktitle> <address> St. Louis, CA, </address> <month> May </month> <year> 1997. </year> <journal> ACM. </journal> <volume> 57 </volume>
Reference-contexts: generally applicable to SRM can also be applied to this case to improve scaling behavior and eliminate the extra duplicates. 23 copies of a request and 3 identical copies of a response are multicast. 2.5 Implementation We have implemented a prototype of the naming scheme and SNAP in the MASH <ref> [21] </ref> toolkit. The MASH platform is a scripting-based programming environment for networked multimedia applications. It provides composable basic building blocks such as network objects, codecs, widgets, and an event-driven programming model. We implemented SNAP as a library of classes in the toolkit. <p> We have reported results from our simulation studies of convergence time and message complexity of the protocol. These results show that the protocol's bandwidth consumption scales well to large group sizes. We have also designed and implemented this Scalable Naming and Announcement Protocol as part of the MASH <ref> [21] </ref> toolkit. 27 Chapter 3 Asymptotic Behavior of Global Recovery 3.1 Introduction In this chapter, we investigate the asymptotic scaling properties of the slotting and damping algorithm used in SRM and SNAP. <p> Based on simulation studies of convergence time and message complexity of the protocol, we demonstrate that the protocol's bandwidth consumption scales well to large group sizes. We have designed and implemented this Scalable Naming and Announcement Protocol (SNAP) as part of the MASH <ref> [21] </ref> toolkit. We have also carried out a performance evaluation using analysis and simulation to study the scaling behavior of slotting and damping algorithm used in SNAP and SRM.
Reference: [22] <author> Steven McCanne and Sally Floyd. </author> <title> The LBNL Network Simulator. </title> <institution> University of California, Berkeley. </institution> <note> http://www-mash.cs.berkeley.edu/ns/. </note>
Reference-contexts: This typically allows the receivers closer to the source to suppress the NACKs from receivers further away. One of the key points in our investigation is how the setting of the timer constants affects this behavior. 3.3 Simulations We used the VINT network simulator ns <ref> [22] </ref> for our work.
Reference: [23] <author> Steven McCanne and Van Jacobson. </author> <title> vic: video conference. </title> <institution> Lawrence Berkeley Laboratory and University of California, Berkeley. ftp://ftp.ee.lbl.gov/conferencing/vic. </institution>
Reference-contexts: Introduction 1.1 Introduction The advent and deployment of IP Multicast [7] has enabled a number of new applications <ref> [23, 15, 14, 10, 37] </ref> that utilize large-scale multi-point communication over wide-area internetworks. IP Multicast extends the traditional, best-effort unicast delivery model of the Internet architecture to enable efficient multi-point packet delivery.
Reference: [24] <author> Jeffrey C. Mogul. </author> <title> Efficient use of workstations for passive monitoring of local area networks. </title> <booktitle> In Proceedings of SIGCOMM '90, </booktitle> <address> Philadelphia, PA, </address> <month> September </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: While the path MTU in a unicast session is well-defined as the smallest MTU of any hop in the path from a datagram's source to its destination <ref> [24] </ref>, the same is not true in a multicast session because it involves multiple receivers and hence multiple data paths from the sender to receivers. As an approximation, we use the interface MTU for the packet size. <p> For links that have even smaller MTU than the value picked, the protocol can limit the bandwidth consumed by retransmissions using a scoped or localized repair mechanism to avoid retransmission floods. For these reasons, we try not to rely on IP fragmentation and reassembly <ref> [24] </ref> to handle large ADUs whose sizes exceed the network MTU. 10 If an ADU handed to the SRM framework exceeds the packet size, it is fragmented into multiple pieces each of which fits into a packet.
Reference: [25] <author> J. Nonnenmacher and E. W. Biersack. </author> <title> Optimal Multicast Feedback. </title> <booktitle> IEEE Infocom, </booktitle> <year> 1998. </year>
Reference-contexts: A more recent paper [19] studied scaling behavior for group sizes up to 200 members, with C 1 = 0 and C 2 set adaptively. In addition, Nonnenmacher and Biersack <ref> [25] </ref> looked at the effect of timer distribution on scaling behavior and showed that exponentially distributed timers yield better scaling properties. They found that having this distribution depend on the group size could result in improved scaling. <p> Thus, we do not consider varying the timer constants with group size, as in <ref> [25] </ref>, as this does not seem like a realistic possibility. Furthermore, we assume that losses are detected immediately when the next packet arrives. Since a packet is delivered to different receivers at different absolute times, losses are detected at different times. <p> Our simulations, shown in Figure 3.3, confirm this result. C 2 and C 1 0, C 2 &gt; 0. N (G) grows roughly linearly for any fixed timer distribution. However, as shown by Non-nenmacher and Biersack <ref> [25] </ref>, if one makes the distribution dependent on the size of the loss group then one can change this linear scaling. <p> One can remove the linear term entirely by considering the scheme where each receiver picks a number k from an exponential distribution with average a G and sets the backoff to kffi. This is essentially a discrete version of the exponential distribution considered by Nonnen-macher and Biersack <ref> [25] </ref>. Here, the average number of NACKs is E (N ) = a and the average latency is E (L) = e a ffi 1e a .
Reference: [26] <author> John K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: The software architecture is shown in Figure 2.9. The protocol framework has two interfaces: one with an event system that allows the library to register events and invokes the specified handlers when these occur. In our implementation, the Tcl <ref> [26] </ref> event loop provides these functions, but it is possible to install an alternate event handling system provided it supports a similar API. The other important interface to SNAP is the application-transport interface. Our basic framework offers the following functions calls.
Reference: [27] <author> C. Papadopoulos, G. Parulkar, and G. Varghese. </author> <title> An Error Control Scheme for Large-Scale Multicast Applications, </title> <booktitle> IEEE. In Proceedings IEEE Infocom '98, </booktitle> <address> San Francisco, CA, </address> <year> 1998. </year>
Reference-contexts: Several solutions have been proposed for local recovery in the literature <ref> [17, 9, 27, 33] </ref>. Integrating SNAP with a local recovery scheme could provide greater scalability. * A key ingredient to the success of the general framework approach to reliable multicast is experience drawn from design and implementation of a variety of applications.
Reference: [28] <author> Dridhar Pingali, Don Towsley, and James F. Kurose. </author> <title> A comparison of sender-initiated and receiver-initiated reliable multicast protocols. </title> <booktitle> In Proceedings of SIGMETRICS '94, </booktitle> <address> Santa Clara, CA, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: section describes these problems and motivates the need for an integrated data naming scheme between the application and the reliable multicast transport protocol, using ALF concepts. 1.2.1 Data Buffering One of the main problems in designing a reliable multicast protocol in a scalable manner is the problem of message implosion <ref> [28, 2, 9] </ref>. In a positive acknowledgment-based reliable multicast scheme, each correctly received packet results in a storm of acknowledgments towards the source overwhelming it and congesting the routers en route. Many reliable multicast algorithms [2, 13, 9] therefore resort to negative acknowledgments from receivers to detect lost packets.
Reference: [29] <institution> PointCast Inc. PointCast Home Page. </institution> <note> http://www.pointcast.com. </note>
Reference-contexts: As with unicast, IP multicast is not reliable packets might be dropped at any point along the distribution tree. However, many new multicast applications like shared white-boards [14], webcast tools <ref> [29] </ref>, and distributed simulation are not tolerant to packet loss. Whiteboard state, for example, is persistent; if a piece of a drawing update is lost, the application cannot leave the drawing in an incomplete state.
Reference: [30] <author> R. Rivest. </author> <title> The MD5 Message-Digest Algorithm. ARPANET Working Group Requests for Comment, </title> <institution> DDN Network Information Center, MIT Laboratory for Computer Science and RSA Data Security, Inc., </institution> <year> 1992. </year> <month> RFC-1321. </month>
Reference-contexts: An example of such a hash function h is MD-5 <ref> [30] </ref>. MD-5 has the special property that no known computationally feasible technique exists to produce two distinct messages having the same hash value. Such a hash function gives us signatures that are unique with high probability. <p> Since MD-5 <ref> [30] </ref> produces a random 128-bit quantity, the resulting 64 bits obtained from the of the two halves of this quantity are also random. For requests and repairs, this header contains the &lt;sourceID, container ID&gt; of the original source that produced the data.
Reference: [31] <author> Henning Schulzrinne, Steve Casner, Ron Frederick, and Van Jacobson. RTP: </author> <title> A Transport Protocol for Real-Time Applications. </title> <institution> Internet Engineering Task Force, Audio-Video Transport Working Group, </institution> <month> November </month> <year> 1991. </year> <note> Internet Draft expires 3/1/96. </note>
Reference-contexts: Names could be URL strings, for example in a webcast application. However, it is conceivable that a sophisticated application may use other types of names, perhaps with a different profile specification just as different application-specific RTP <ref> [31] </ref> profiles are possible. Our framework allows a different namemap module to be used with the core naming and announcement protocol. 2.2 Source Identifiers A namespace is source-specific and reflects the structure of data generated by that source. <p> A source ID collision occurs when two distinct sources use the same identifier while transmitting data; this is an event that must ideally be avoided, or at the very least, its occurrence must be minimized. RTP <ref> [31] </ref> uses randomly generated 32-bit source identifiers for multicast audio/video transmission and detects collisions and resolves them, but does not perform any repair when one is detected. The only ill-effects of a collision in this case are degraded quality for a brief duration of time, until the collision is resolved. <p> Because the original identifier is an arbitrary user-supplied string that can be retained when moving from one terminal to another, terminal independence is easily achieved as well. Our solution minimizes the probability of collisions and resolves any collisions that might occur using the technique described in the RTP specification <ref> [31] </ref>. In addition, we ensure that the two important requirements of time invariance and terminal independence are met.
Reference: [32] <author> W. Garth Smith and Alex Koifman. </author> <title> A Distributed Interactive Simulation Intranet Using RAMP, a Reliable Adaptive Multicast Protocol. </title> <booktitle> In Proceedings of the Fourteenth Workshop on Standards for the Interoperability of Distributed Simulations, </booktitle> <address> Orlando, FL, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: Although mechanisms for reliable unicast transmission are comparatively well-understood and have proven extremely successful (e.g., TCP), making multicast reliable at large scales remains a formidable challenge. Though a number of wide-area reliable multicast protocols have been proposed <ref> [17, 32, 9, 16] </ref>, none currently satisfies the requirements for safe deployment in the global Internet because no existing scheme simultaneously provides (1) scalability to very large multicast sessions, (2) congestion control that accommodates constrained and potentially heterogeneous link bandwidths, and (3) a rich and configurable range of reliability semantics.
Reference: [33] <author> Tony Speakman, Dino Farinacci, Steven Lin, and Alex Tweedly. </author> <title> Pretty Good Multicast (PGM) Transport Protocol Specification, </title> <month> January </month> <year> 1998. </year> <title> Internet Draft (RFC pending). </title>
Reference-contexts: Several solutions have been proposed for local recovery in the literature <ref> [17, 9, 27, 33] </ref>. Integrating SNAP with a local recovery scheme could provide greater scalability. * A key ingredient to the success of the general framework approach to reliable multicast is experience drawn from design and implementation of a variety of applications.
Reference: [34] <author> W. Richard Stevens. </author> <title> TCP/IP Illustrated Volume 1. </title> <publisher> Addison-Wesley, </publisher> <month> Nov </month> <year> 1994. </year> <month> 58 </month>
Reference-contexts: Unicast transport protocols like TCP <ref> [34] </ref>, and several multicast ones ([17, 13, 32]) adopt this approach.
Reference: [35] <author> W. Richard Stevens. </author> <title> TCP/IP Illustrated, Volume 1 The Protocols. </title> <publisher> Addison-Wesley, </publisher> <address> first edition, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: We study how RTT estimation might affect asymptotic scaling behavior in the different topologies by comparing 2 Even in the case of a single TCP connection, where RTT estimates are gathered on every ACK, the sender's RTT-estimator is known to often be inaccurate <ref> [35] </ref>. 29 performance in two extreme cases: one with exact RTT estimations and one where all members have the same hardwired RTT estimate. 3.1.1 Related Work In this section, we summarize some important prior work related to the analysis of SRM.
Reference: [36] <author> Teck-Lee Tung. MediaBoard: </author> <title> A distributed, shared collaboration application. </title> <type> UCB CS Masters Report, </type> <month> February </month> <year> 1998. </year>
Reference-contexts: Sequence numbers generated at the sender side of the transport protocol alone are grossly inadequate for this. Several applications require sophisticated control over what portions of a data space they need reliably delivered. For example, in the shared whiteboard application <ref> [14, 36] </ref>, receivers do not require immediate recovery of items on pages not currently being viewed. Since loss recovery is initiated by the receiver, the receiving application must have sufficient information to determine whether a loss needs to be repaired. <p> We plan to port a number of existing applications including the MASH mediaboard <ref> [36] </ref>, and mashcast [40] to effectively demonstrate the power of application-level framing. * While the MASH platform has served as a convenient development environment for implementing SNAP, it is cumbersome to use the protocol implementation in applications not part of MASH.
Reference: [37] <author> Thierry Turletti. </author> <title> INRIA Video Conferencing System (ivs). </title> <institution> Institut National de Recherche en Informatique et an Automatique. </institution> <note> http://www.inria.fr/rodeo/ivs.html. </note>
Reference-contexts: Introduction 1.1 Introduction The advent and deployment of IP Multicast [7] has enabled a number of new applications <ref> [23, 15, 14, 10, 37] </ref> that utilize large-scale multi-point communication over wide-area internetworks. IP Multicast extends the traditional, best-effort unicast delivery model of the Internet architecture to enable efficient multi-point packet delivery.
Reference: [38] <author> Robbert van Renesse, Kenneth P. Birman, and Silvano Maffeis. Horus, </author> <title> a Flexible Group Communication System. </title> <journal> Communications of the ACM, </journal> <year> 1996. </year>
Reference: [39] <author> Carl A. Waldspurger and William E. Weihl. </author> <title> Lottery Scheduling: Flexible Proportional-Share Resource Management. </title> <booktitle> In First Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 1-11. </pages> <publisher> USENIX Association, </publisher> <year> 1995. </year>
Reference-contexts: Since we cannot transmit meta information about all the containers in a source's namespace, we give priority to containers that have not been announced for the longest period of time. We use a randomized scheme similar to lottery scheduling <ref> [39] </ref>. The analysis of this algorithm is akin to the coupon collectors problem [11]. The expected time to select k distinct containers from among a total of n containers is given by O (k log k). The details of the algorithm and its analysis are shown in Appendix A. <p> The views expressed here do not reflect the position or policy of the U.S. government. 48 Appendix A Container Selection Algorithm We present the algorithm used to select containers to be transmitted in a session announcement packet. The algorithm is similar to lottery scheduling <ref> [39] </ref>. The goal of the algorithm is to select n containers out of a set C. The likelihood of selecting a container c, is proportional to its weight, w [c]. When a container is selected, its weight is dropped to a base priority level.
Reference: [40] <author> Kristin Wright. MASHCast: </author> <note> Applying SRM Middleware to Webcast. Presentation at the Winter '98 MASH Retreat. </note>
Reference-contexts: We plan to port a number of existing applications including the MASH mediaboard [36], and mashcast <ref> [40] </ref> to effectively demonstrate the power of application-level framing. * While the MASH platform has served as a convenient development environment for implementing SNAP, it is cumbersome to use the protocol implementation in applications not part of MASH.
Reference: [41] <author> Maya Yajnik, Jim Kurose, and Don Towsley. </author> <title> Packet Loss Correlation in the MBone Multicast Network. </title> <booktitle> IEEE Global Internet Conference, </booktitle> <year> 1996. </year>
Reference-contexts: In its original form, ns turned out to have prolific memory usage with heavy-weight nodes, links, and multicast routing infrastruc 3 Measurements reported in <ref> [41] </ref> show that most correlated losses occur close to the source. 31 ture, and could not support more than a few hundred nodes on an ordinary workstation. However, we took advantage of ns's extensible object-oriented architecture and made several modifications and extensions to it.
References-found: 41

