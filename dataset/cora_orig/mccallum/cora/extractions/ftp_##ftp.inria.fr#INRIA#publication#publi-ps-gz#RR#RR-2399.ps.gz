URL: ftp://ftp.inria.fr/INRIA/publication/publi-ps-gz/RR/RR-2399.ps.gz
Refering-URL: http://www.cs.umd.edu/~keleher/bib/dsmbiblio/node8.html
Root-URL: 
Title: LarchantRDOSS: a distributed shared persistent memory and its garbage collector  
Author: Marc Shapiro, Paulo Ferreira N 
Note: PROGRAMME 1  
Date: Novembre 1994  
Affiliation: INSTITUT NATIONAL DE RECHERCHE EN INFORMATIQUE ET EN AUTOMATIQUE  Also: Cornell Computer Science  
Pubnum: TR941466  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. P. Atkinson, P. J. Bailey, K. J. Chisholm, P. W. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <booktitle> Computer, </booktitle> <address> 26(4):360365, </address> <year> 1983. </year> <title> [2] zalp Babao glu and Keith Marzullo. Consistent Global States of Distributed Systems: Fundamental Concepts and Mechanisms, </title> <booktitle> chapter 4, </booktitle> <pages> pages 5593. </pages> <note> AddisonWesley, ACM Press, second edition edition, </note> <year> 1993. </year>
Reference-contexts: Pointers and allocation information are sup ple mented, internally, by locationindependent data structures. From these, the system deter mines which objects are actually shareable by other applications (any object reachable from a persistent object is itself persistent; this is called persistence by reachability <ref> [1] </ref>), by tracing from a persistent root. Such automatic management results in a simple and natural programming model, because the application need not worry about inputoutput or deallo cation.
Reference: [3] <author> Brian N. Bershad and Matthew J. Zekauskas. Midway: </author> <title> Shared memory parallel programming with entry consistency for distributed memory multiprocessors. </title> <type> Technical Report CMUCS91170, </type> <institution> CarnegieMellon University, </institution> <address> Pittsburgh, PA (USA), </address> <month> September </month> <year> 1991. </year>
Reference-contexts: Larchant BMX Two slightly different versions of the Lar chant architecture are being developed, cal led respectively LarchantBMX and Larchant RDOSS. Both systems implement essentially the same ideas and algorithms but differ in some important aspects. LarchantBMX implements an object granularity entryconsistent <ref> [3] </ref> single distri buted address space abstraction. The collec tor runs concurrently with the mutator, in the same address space; therefore updates must be reported to the collector. Pointer compari sons must use a special primitive. LarchantRDOSS is a simplited version of LarchantBMX.
Reference: [4] <author> Kenneth Birman, Andre Schiper, and Pat Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3):272314, </volume> <month> August </month> <year> 1991. </year>
Reference-contexts: Updates ow from an application or a collector process, to the local (owner) CS, which propagates it to the other servers. A BS stores updates on disk. Since an update or a token ows only from the owner to other processes, it can be sent using Isis causal broadcast <ref> [4] </ref>. 4 4 Communication between the application and collec tor processes and the storage service, and between the sto rage servers, uses RDO, a Corbacompliant veneer to Isis, a product of Isis Distributed Systems, Inc.
Reference: [5] <author> Paulo Ferreira and Marc Shapiro. </author> <title> Garbage collection and DSM consistency. </title> <booktitle> In Proc. of the First Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <address> Monterey, CA (USA), </address> <month> November </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: The algorithm is exactly the same as above, except that scions 6 Since the trst version of LarchantRDOSS does not swizzle, it follows that its garbage collector doesn't move objects either. 7 LarchantBMX <ref> [6, 5] </ref> does not have reserve locks. Like any update, patch consistency is ensured by the fact that only the owner of an object can move it. <p> Since LarchantRDOSS runs on top of Isis, we simply send the create, POL, and delete messages using the causal communication primitive cbcast. LarchantBMX <ref> [5, 6] </ref> does not depend on Isis; in this system, we use piggybacking to implement causality. 5 Conclusion The problem of tracing a largescale shared distributed store seems intractable at trst glance. We have shown an algorithm that gives an approximation of the global trace, with none of the drawbacks.
Reference: [6] <author> Paulo Ferreira and Marc Shapiro. </author> <title> Garbage collection of persistent objects in distributed shared memory. </title> <booktitle> In Proc. of the 6th Int. Workshop on Persistent Object Systems, </booktitle> <address> Tarascon (France), </address> <month> September </month> <year> 1994. </year> <month> SpringerVerlag. </month>
Reference-contexts: The algorithm is exactly the same as above, except that scions 6 Since the trst version of LarchantRDOSS does not swizzle, it follows that its garbage collector doesn't move objects either. 7 LarchantBMX <ref> [6, 5] </ref> does not have reserve locks. Like any update, patch consistency is ensured by the fact that only the owner of an object can move it. <p> Since LarchantRDOSS runs on top of Isis, we simply send the create, POL, and delete messages using the causal communication primitive cbcast. LarchantBMX <ref> [5, 6] </ref> does not depend on Isis; in this system, we use piggybacking to implement causality. 5 Conclusion The problem of tracing a largescale shared distributed store seems intractable at trst glance. We have shown an algorithm that gives an approximation of the global trace, with none of the drawbacks.
Reference: [7] <author> Marc Shapiro, Peter Dickman, and David Plainfoss. </author> <title> SSP chains: Robust, distributed RR n 2399 references supporting acyclic garbage collection. </title> <institution> Rapport de Recherche 1799, Institut National de la Recherche en Informatique et Automatique, Rocquencourt (France), </institution> <month> nov </month> <year> 1992. </year> <note> Also available as Broadcast Technical Report #1. </note>
Reference-contexts: reference counting (RC), for the following reasons: (1) RC is not complete (it does not collect cycles of garbage). (2) The existence of mul tiple kinds of roots (transient roots and persistent roots) makes RC awkward. (3) We have already studied ex tensively a widearea, faulttolerant version of reference counting <ref> [8, 7] </ref> and have found it inadequate for a shared memory environment. As we shall see, our new algorithm combines tracing, whenever economically feasible, with a variant of RC when tracing would be too expensive. <p> The specitcation could be extended to sending pointers in messages or through other channels, by integrating the SSPC protocols <ref> [7] </ref> into LarchantRDOSS. This is topic for future work.
Reference: [8] <author> Marc Shapiro, Olivier Gruber, and David Plainfoss. </author> <title> A garbage detection protocol for a realistic distributed objectsupport system. </title> <institution> Rapport de Recherche 1320, Institut National de la Recherche en Informatique et Automatique, Rocquencourt (France), </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: reference counting (RC), for the following reasons: (1) RC is not complete (it does not collect cycles of garbage). (2) The existence of mul tiple kinds of roots (transient roots and persistent roots) makes RC awkward. (3) We have already studied ex tensively a widearea, faulttolerant version of reference counting <ref> [8, 7] </ref> and have found it inadequate for a shared memory environment. As we shall see, our new algorithm combines tracing, whenever economically feasible, with a variant of RC when tracing would be too expensive.

References-found: 7

