URL: http://ftp.eecs.umich.edu/people/rundenst/papers/r-92-6-rev.ps
Refering-URL: http://ftp.eecs.umich.edu/people/rundenst/papers/
Root-URL: http://www.eecs.umich.edu
Title: A Class Classification Algorithm For Supporting Consistent Object Views  
Author: ELKE A. RUNDENSTEINER 
Keyword: Index Terms: Object-oriented views, automatic classification, view consistency, virtual schemata, virtual classes, object algebra, type lattice, knowledge representation, knowledge discovery.  
Address: Ann Arbor 1301 Beal Ave Ann Arbor, MI 48109-2122  
Affiliation: Dept. of Elect. Engineering and Computer Science Software Systems Research Laboratory The University of Michigan,  
Email: e-mail: rundenst@eecs.umich.edu  
Phone: fax: (313) 763-1503 phone: (313) 936-2971  
Web: December/4/1992  
Abstract: In recent years, object-oriented views have been recognized as a powerful mechanism for customizing the structural as well as behavioral aspects of interfaces to object-oriented databases (OODBs) for diverse users. Existing approaches either require the user to explicit specify the relationship between a newly derived virtual class and existing base classes, or they simply relate a virtual class directly with its source class or even with the root of the schema. This clearly results in information loss. In this paper, we propose a solution to this classification problem of object-oriented views which accomplishes the following goals: (2) manage well-organized schemas that explicitly model the relationships of classes and thus are more comprehensible to users, (1) support type resolution for shared property functions, and (3) achieve performance improvements due to exploiting class relationships during query processing. Our system organizes both base and virtual classes into one comprehensive global schema graph based on which object-oriented views virtual, possibly restructured, subschema graphs of the global schema can be specified in a consistent manner. Class classification then is concerned with the integration of virtual classes derived using an object-oriented query into one unifying global schema. An automatic approach towards class integration is preferable over a manual approach, since it does not only prevent the introduction of inconsistencies into the schema, but it also relieves the view definer from a tedious task. In this paper, we therefore present an algorithm for automatic class integration. We show that this automatic classifier successfully addresses the following two classification problems: (1) the mismatch of type inheritance for virtual classes and (2) the integration of classes with conflicting subset and subtype relationships into one consistent schema graph. We present proofs of correctness and a complexity analysis of the classification algorithm. Finally, an analysis of virtual classes derived by different object algebra operators reveals that the complexity of classification can be considerably improved for most operators. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abiteboul, S., and Bonner, A., </author> <title> "Objects and Views," </title> <booktitle> in Proc. SIGMOD'91, </booktitle> <pages> pp. 238 - 247. </pages>
Reference-contexts: In this paper, we present a solution to the second task, while solutions to the first and the third tasks of MultiView are given in [30] and in [34], respectively. Other work on object-oriented views <ref> [36, 40, 1] </ref> indicates the need for classification, MultiView is unique in providing a complete solution to this classification problem for object-oriented data models. 1 Explicit capture of class relationships between stored and derived classes in the form of a global schema graph brings numerous advantages. <p> Then VC is placed below all its direct parent classes and above all its direct children classes (Definition 7). As we will show in the following sections, this simplified classification algorithm advocated repeatedly in the literature <ref> [35, 40, 1] </ref> does not correctly account for the type inheritance underlying the object-oriented schema graph. <p> This, of course, also requires a reevaluation of the inheritance strategies, as has also been noted in <ref> [1] </ref>. While the original base classes always inherit methods from classes higher up in the class hierarchy, derived classes may 'inherit' methods from classes lower in the class hierarchy. <p> Scholl et al. [36] do not consider the problem of generating multiple view schemata, which is an integral part of MultiView. In Abiteboul and Bonner's <ref> [1] </ref> view mechanism, the user is in charge of constructing local view schemata using the import/export facility of O 2 . Their solution of class integration focusses on select classes, and does for instance not handle hide classes. It thus results in partial rather in complete classification.
Reference: [2] <author> Aho, A. V., Hopcroft, J. E., and Jeffrey, D. U., </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley Pub. Company, </publisher> <year> 1974. </year>
Reference: [3] <author> Bancilhon and W. Kim, </author> <title> "Object-Oriented Database Systems: In Transition," </title> <booktitle> SIGMOD RECORD, </booktitle> <volume> Vol. 19, No. 4, </volume> <month> Dec. </month> <year> 1990, </year> <pages> pp. 49 - 53. </pages>
Reference: [4] <author> Banerjee, J., Kim, W., Kim, H. J., and Korth, F., </author> <title> "Semantics and Implementation of Schema Evolution in Object-Oriented Databases," </title> <booktitle> Proc. of ACM SIMOD'87, </booktitle> <month> May </month> <year> 1987, </year> <pages> pp. </pages> <address> 311- 322. </address>
Reference: [5] <author> Beck, H. W., Gala, S. K., and Navathe, S. B., </author> <title> "Classification as a Query Processing Technique in the CANDIDE Semantic Data Model," </title> <booktitle> SIGMOD, </booktitle> <year> 1989, </year> <pages> pp. 572 - 581. </pages>
Reference: [6] <author> Bergamaschi, S. and Sartori, C., </author> <title> "On Taxonomic Reasoning in Conceptual Design," </title> <journal> ACM TODS, </journal> <volume> vol. 17, no. 3, </volume> <month> Sept. </month> <year> 1992, </year> <pages> pp. 385 - 422. </pages>
Reference-contexts: We have identified two classification problems related to object-oriented data models that existing work on classification <ref> [6, 27, 9] </ref> does not appropriately handle. They are (1) the type inheritance mismatch for virtual classes and (2) the composition of is-a incompatible subset and subtype hierarchies into one consistent class hierarchy. <p> Therefore, we will be able to extend our system by plugging in more realistic predicates and thus extending the subsumes () function correspondingly. One pleasant side effort of this design choice is that our current classification algorithm is tractable <ref> [6, 27, 9] </ref>. We plan to integrate our class integration software with the other parts of the MultiView prototype in the future. 12 RELATED WORK An immediate extension of the view mechanism from relational databases to OODB systems is to define a view to be equal to an object-oriented query. <p> Lastly, since the derivation of new classes is accomplished in MultiView using well-defined object algebra operators, we are able to reduce the complexity of classification depending on the operator used for derivation. This issue is not addressed in [35]. Other work of more theoretical nature, such as <ref> [6, 27, 9] </ref>, analyses different concept description languages to determine the complexity of classification.
Reference: [7] <author> Borgida, A., Brachman, R. J., McGuiness, D. L. and Resnick, L. A., </author> <title> CLASSIC: A Structural Data Model for Objects," </title> <booktitle> SIGMOD, </booktitle> <year> 1989, </year> <pages> pp. 58 - 67. </pages>
Reference: [8] <author> Bouzeghoub, M., "MORSE: </author> <title> a functional query language and its semantic data model," </title> <booktitle> Proc. of 84 Trends and Applications of Databases, </booktitle> <address> IEEE-NBS, Gaithersburg, </address> <year> 1984. </year>
Reference: [9] <author> Brachman, R. J., and Levesque, H. J., </author> <title> "The Tractability of Subsumption in Frame-Based Description Languages," </title> <booktitle> Proc. AAAI, </booktitle> <year> 1984, </year> <pages> pp. 34 - 37. </pages>
Reference-contexts: We have identified two classification problems related to object-oriented data models that existing work on classification <ref> [6, 27, 9] </ref> does not appropriately handle. They are (1) the type inheritance mismatch for virtual classes and (2) the composition of is-a incompatible subset and subtype hierarchies into one consistent class hierarchy. <p> Therefore, we will be able to extend our system by plugging in more realistic predicates and thus extending the subsumes () function correspondingly. One pleasant side effort of this design choice is that our current classification algorithm is tractable <ref> [6, 27, 9] </ref>. We plan to integrate our class integration software with the other parts of the MultiView prototype in the future. 12 RELATED WORK An immediate extension of the view mechanism from relational databases to OODB systems is to define a view to be equal to an object-oriented query. <p> Lastly, since the derivation of new classes is accomplished in MultiView using well-defined object algebra operators, we are able to reduce the complexity of classification depending on the operator used for derivation. This issue is not addressed in [35]. Other work of more theoretical nature, such as <ref> [6, 27, 9] </ref>, analyses different concept description languages to determine the complexity of classification.
Reference: [10] <author> Brachman, R. J., and Schmolze, J. G., </author> <title> "An Overview of the KL-ONE Knowledge Representation System," </title> <journal> Cognitive Science, </journal> <volume> 9, </volume> <year> 1985. </year>
Reference: [11] <author> Cattell, R. G. G., </author> <title> Object Data Management, </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: We compare MultiView to related work in Section 12 and conclude with Section 13. 2 OBJECT-ORIENTED CONCEPTS 2.1 The Object Model The concepts needed for the remainder of the paper are introduced below, while a thorough coverage of object-oriented database concepts can be found in <ref> [11] </ref>. A class C i 2 C has a unique class name, a type description and a set membership. The type associated with a class C, type (C), consists of a number of property functions, properties (type (C)), or short, properties (C). <p> class hierarchy structure where the correct placement of a new class can always be enforced. 6.1 The Type Closure and Class Closure Properties In our object model (as well as in most others), a property is defined exactly once and, if used elsewhere, it is inherited from this original definition <ref> [11] </ref>. A consequence of this is the fact that if two types t1 and t2 share some common properties, then they must have ultimately inherited them from the same type.
Reference: [12] <author> Date, C. J., </author> <title> An Introduction to Database Systems, Vol. I, Fifth Edition, </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1990. </year>
Reference-contexts: Note however that a relational schema is simply a set of `unrelated' relations <ref> [12] </ref>, whereas an object-oriented data schema corresponds to a complex structure of classes interrelated via generalization and decomposition relationships [21, 22] (See also Figure 1). We therefore define an object-oriented view, also called a view schema, to be a virtual, possibly restructured, subschema graph of the global schema [30].
Reference: [13] <author> Delcambre, L. M. L., and Davis, K. C., </author> <title> "Automatic Validation of Object-Oriented Database Structures," </title> <booktitle> Proc. Data Engin. Conf., </booktitle> <year> 1989, </year> <pages> pp. 2 - 9. </pages>
Reference: [14] <author> Deux, O., </author> <title> "The Story of O 2 ", IEEE Trans. </title> <journal> on Knowledge and Data Eng., </journal> <volume> vol. 2, no. 1, </volume> <month> March </month> <year> 1990, </year> <pages> pp. 91 - 108. </pages>
Reference-contexts: This in turn will allow us to evaluate other object-oriented database software for their suitability as platform for an efficient view support system. We are currently considering IRIS [15] and O 2 <ref> [14] </ref> as potential candidates for our future efforts. IRIS supports the notion of multiple types per object; and O 2 supports the modification of classes allowing to add new methods and attributes at run-time.
Reference: [15] <author> D. Fishman et al., </author> <title> "Iris: An Object-Oriented Database Management System," </title> <journal> in ACM Trans. on Office Information Systems, </journal> <volume> vol. 5, no. 1, </volume> <month> Jan. </month> <year> 1987, </year> <pages> pp. 48 - 69. </pages>
Reference-contexts: However, in the long term, different storage structures for efficient support of multiple types per object are needed. The table-based approach taken by IRIS <ref> [15] </ref> appears to be a step in the right direction. Finally, we are addressing the third issue by rewriting the meta-data management system to maintain information about sub- and superclasses with respect to different points of reference (namely, the original base schema, the global schema, and all the view schemata). <p> Our experience with this first prototype will lead to a clear understanding of the system requirements of view support. This in turn will allow us to evaluate other object-oriented database software for their suitability as platform for an efficient view support system. We are currently considering IRIS <ref> [15] </ref> and O 2 [14] as potential candidates for our future efforts. IRIS supports the notion of multiple types per object; and O 2 supports the modification of classes allowing to add new methods and attributes at run-time.
Reference: [16] <author> Gilbert, J. P., </author> <title> "Supporting User Views," </title> <booktitle> OODB Task Group Workshop Proceedings, </booktitle> <address> Ottawa, Canada, </address> <month> Oct. </month> <year> 1990. </year>
Reference: [17] <author> Goldstein, I. and Bobrow, D. G., </author> <title> Descriptions for a Programming Environment, </title> <booktitle> Proc. AAAI, </booktitle> <volume> 1, </volume> <year> 1980. </year>
Reference: [18] <author> Heiler, S., and Zdonik, S. B., </author> <title> "Object views: Extending the vision," </title> <booktitle> In Proc. IEEE Data Engineering Conf., </booktitle> <address> Los Angeles, </address> <month> Feb. </month> <year> 1990, </year> <journal> pg. </journal> <volume> 86 - 93. </volume>
Reference-contexts: Most initial proposals of views on OODBs suggest a direct extension of the view mechanism from relational databases to OODB systems, namely, they define an object-oriented view to be equal to an object-oriented query <ref> [18, 36, 21] </ref>. Note however that a relational schema is simply a set of `unrelated' relations [12], whereas an object-oriented data schema corresponds to a complex structure of classes interrelated via generalization and decomposition relationships [21, 22] (See also Figure 1). <p> Similarly, we have proposed algorithms for the third task elsewhere [34]. The first task of MultiView supports the customization of existing classes by deriving virtual classes with a modified type description and membership content. This part of MultiView is similar to the work of object-oriented views by others <ref> [21, 18, 36] </ref>. We utilize an object algebra as query language for class customization, as defined in in Figure 1. The object algebra provides six basic operators that can be nested to form arbitrarily complex class derivations. A discussion and examples of the object algebra can be found elsewhere [30]. <p> In fact, many efforts of defining views for OODBs follow this approach; that is, they suggest the use of the query language defined for their respective object model to derive a virtual class. Some examples are view mechanisms for the Fugue Model in <ref> [18] </ref>, for the Orion model in [21], and for integrating databases in [19]. These efforts are equivalent in functionality to task one of MultiView. Most of these approaches do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as "stand-alone" objects [18], or <p> in <ref> [18] </ref>, for the Orion model in [21], and for integrating databases in [19]. These efforts are equivalent in functionality to task one of MultiView. Most of these approaches do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as "stand-alone" objects [18], or they are attached directly as subclasses of the schema root class [21], or they are attached directly as subclasses of the source classes of the view derivation [25]. <p> We believe strongly that this is sufficient for many application domains, in particular, since the join operator can be simulated using the refine operator. However, it would be interesting to investigate whether, and if so how, MultiView could be extended to also handle object-generating algebra operators <ref> [21, 18] </ref>. Lastly, we propose view optimization as a new open problem that arises from our research on object-oriented views.
Reference: [19] <author> Kaul, M., Drosten, K., and Neuhold, E.J., "ViewSystem: </author> <title> Integrating Heterogeneous Information Bases by Object-Oriented Views," </title> <booktitle> In Proc. IEEE Data Engineering Conf., </booktitle> <address> Los Angeles, </address> <month> Feb. </month> <year> 1990, </year> <journal> pg. </journal> <volume> 2 - 10. </volume>
Reference-contexts: Some examples are view mechanisms for the Fugue Model in [18], for the Orion model in [21], and for integrating databases in <ref> [19] </ref>. These efforts are equivalent in functionality to task one of MultiView. Most of these approaches do not discuss the integration of derived classes into the global schema.
Reference: [20] <author> S. N. Khoshafian and G. P. Copeland, </author> <title> "Object Identity," </title> <booktitle> in Proc. OOPSLA'86, ACM, </booktitle> <month> Sep. </month> <year> 1986, </year> <pages> pp. 406-416. </pages>
Reference: [21] <author> Kim, W., </author> <title> A model of queries in object-oriented databases, </title> <booktitle> In Proc. Int. Conf. on Very Large Databases, </booktitle> <pages> pp. 423 - 432, </pages> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: Most initial proposals of views on OODBs suggest a direct extension of the view mechanism from relational databases to OODB systems, namely, they define an object-oriented view to be equal to an object-oriented query <ref> [18, 36, 21] </ref>. Note however that a relational schema is simply a set of `unrelated' relations [12], whereas an object-oriented data schema corresponds to a complex structure of classes interrelated via generalization and decomposition relationships [21, 22] (See also Figure 1). <p> Note however that a relational schema is simply a set of `unrelated' relations [12], whereas an object-oriented data schema corresponds to a complex structure of classes interrelated via generalization and decomposition relationships <ref> [21, 22] </ref> (See also Figure 1). We therefore define an object-oriented view, also called a view schema, to be a virtual, possibly restructured, subschema graph of the global schema [30]. <p> Similarly, we have proposed algorithms for the third task elsewhere [34]. The first task of MultiView supports the customization of existing classes by deriving virtual classes with a modified type description and membership content. This part of MultiView is similar to the work of object-oriented views by others <ref> [21, 18, 36] </ref>. We utilize an object algebra as query language for class customization, as defined in in Figure 1. The object algebra provides six basic operators that can be nested to form arbitrarily complex class derivations. A discussion and examples of the object algebra can be found elsewhere [30]. <p> In fact, many efforts of defining views for OODBs follow this approach; that is, they suggest the use of the query language defined for their respective object model to derive a virtual class. Some examples are view mechanisms for the Fugue Model in [18], for the Orion model in <ref> [21] </ref>, and for integrating databases in [19]. These efforts are equivalent in functionality to task one of MultiView. Most of these approaches do not discuss the integration of derived classes into the global schema. <p> These efforts are equivalent in functionality to task one of MultiView. Most of these approaches do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as "stand-alone" objects [18], or they are attached directly as subclasses of the schema root class <ref> [21] </ref>, or they are attached directly as subclasses of the source classes of the view derivation [25]. Scholl et al.'s recent work [36] sketch the class integration process for a selected subset of the operators of the query language COOL. <p> We believe strongly that this is sufficient for many application domains, in particular, since the join operator can be simulated using the refine operator. However, it would be interesting to investigate whether, and if so how, MultiView could be extended to also handle object-generating algebra operators <ref> [21, 18] </ref>. Lastly, we propose view optimization as a new open problem that arises from our research on object-oriented views.
Reference: [22] <author> D. Maier, J. Stein, A. Otis, and A. Purdy, </author> <title> "Development of an Object-Oriented DBMS," </title> <booktitle> in Proc. </booktitle> <address> OOPSLA'86, </address> <month> Sep. </month> <year> 1986, </year> <pages> pp. 472-482. </pages>
Reference-contexts: Note however that a relational schema is simply a set of `unrelated' relations [12], whereas an object-oriented data schema corresponds to a complex structure of classes interrelated via generalization and decomposition relationships <ref> [21, 22] </ref> (See also Figure 1). We therefore define an object-oriented view, also called a view schema, to be a virtual, possibly restructured, subschema graph of the global schema [30]. <p> (|E |) 2 directly below SC, children no below SC above SC above SC below SC below SC algorithm B = type hierarchy preparation and class placement algorithm A = class placement (given correct type hierarchy) Legend 11 IMPLEMENTATION ISSUES For the first prototype of MultiView we have chosen GemStone <ref> [22] </ref> due to the availability of this software at our site.
Reference: [23] <author> Missikoff, M., and Scholl, M., </author> <title> "An Algorithm for Insertion into a Lattice: Application to Type Classification," </title> <booktitle> Foundations of Data Organization and Algorithms, 3 rd Int. Conf., </booktitle> <address> FODD'89, France, </address> <month> June </month> <year> 1989, </year> <pages> pp. 64 - 82. </pages>
Reference-contexts: In this paper, we present an algorithm for automatic classification that solves both problems. The solution is based on type lattice theory <ref> [23] </ref>, the essence of which is the creation of additional intermediate classes that restructure the schema graph. We present proofs of correctness and a complexity analysis for the classification algorithm. Furthermore, we characterize classification requirements of virtual classes derived by different object algebra operators. <p> The work by Missikoff and Scholl <ref> [23] </ref>, that proves that the first set of types g i as specified in Lemma 1 is sufficient to guarantee the closure of the resulting type hierarchy (See Theorem below), is directly applicable to our research. <p> The computation of the new types t 0 i can hence be done in a single pass without recursive iteration over the newly generated types t 0 i . The proof for Lemma 2 can be found in <ref> [23] </ref>. We now extend this result from the type hierarchy to the class hierarchy. <p> Proof: The proof is given in [33]. 16 6.3 Minimizing the Generation of Intermediate Classes Next, we discuss how to limit the number of intermediate classes g i generated for assuring the closure of a schema graph after class integration. This work is based on <ref> [23] </ref>. Definition 13. Given a type hierarchy TG=(TV,TE) and a new type t V C to be integrated into TG. <p> For each equivalence group G i , there is one type t i 2 G i that is minimal and unique in G i . The proof of correctness for Theorem 1 can be found in <ref> [23] </ref>. Next, we extend Definition 13 and Theorem 1 from types to classes. Definition 14. Given a schema graph G=(V,E) and a new class VC to be integrated into G. <p> For C i , C j 2 G, we say that C j is a parent* of C i , denoted by parent*(C i )=C j , if C j =rep (G j ) and exists an edge e=&lt; G i ; G j &gt; in G*. In <ref> [23] </ref>, it is shown that G* is isomorphic to GG defined above. Theorem 4. Given a closed schema G=(V,E) and a class VC to be inserted into G. <p> This then justifies part two of Theorem 4. A more detailed proof of Theorem 4 with respect to the type hierarchy can be found in <ref> [23] </ref>. Example 9. Figure 9.a shows a schema graph G with a partition induced by the class VC. <p> Figure 11.a shows the schema G before type classification. We assume that the virtual class VC is derived by the view derivation "VC = hide [b] from C4". For a explanation of the example see [33]. In <ref> [23] </ref>, the algorithm has been shown to be of quadratic complexity O (m 2 ) with m the number of edges in G. <p> Our work on classification is closely related to the research by Missikoff et al. <ref> [23] </ref> on inserting types into a lattice structure. Rather than dealing with an object-oriented model, they assume a simple record-oriented type system. Our classification algorithm, on the other hand, is extended to be applicable to a class 33 generalization hierarchy.
Reference: [24] <author> Missikoff, M., "MOKA: </author> <title> A User-friendly Front-End for Knowledge Acquisition," </title> <booktitle> Int'l Workshop on Database Machines and Artificial Intelligence, </booktitle> <address> Minowbrook, N.Y., </address> <month> July </month> <year> 1987. </year>
Reference: [25] <author> Morsi, M. M., Navthe, s. B., Kim, H. K., </author> <title> An Extensible Object-Oriented Database Testbed, </title> <booktitle> Int. Conf. on Data Engineering, </booktitle> <year> 1992, </year> <pages> pp. 150 - 157. </pages>
Reference-contexts: Instead, the derived classes are treated as "stand-alone" objects [18], or they are attached directly as subclasses of the schema root class [21], or they are attached directly as subclasses of the source classes of the view derivation <ref> [25] </ref>. Scholl et al.'s recent work [36] sketch the class integration process for a selected subset of the operators of the query language COOL. <p> Their solution of class integration focusses on select classes, and does for instance not handle hide classes. It thus results in partial rather in complete classification. Morsi et al. <ref> [25] </ref> are developing a graphical interface for DAG rearrangement views of a class hierarchy. This tool is part of a graphical environment for schema evolution and version support, and hence focuses on defining a view using manipulation operations similar in flavor to typical schema evolution operators.
Reference: [26] <author> J. Mylopoulos, P. A. Bernstein, and H.K.T. Wong. </author> <title> "A Language Facility for Designing Database-Intensive Applications," </title> <journal> in ACM Trans. on Database Systems, </journal> <volume> vol. 5, issue 2, </volume> <pages> pp. 185-207, </pages> <month> June </month> <year> 1980. </year>
Reference: [27] <author> Nebel, B., </author> <title> "Terminological Reasoning Is Inherently Intractable," </title> <booktitle> in Artifical Intelligence, 43 (1990), </booktitle> <pages> pp. 235 - 249. </pages>
Reference-contexts: We have identified two classification problems related to object-oriented data models that existing work on classification <ref> [6, 27, 9] </ref> does not appropriately handle. They are (1) the type inheritance mismatch for virtual classes and (2) the composition of is-a incompatible subset and subtype hierarchies into one consistent class hierarchy. <p> Therefore, we will be able to extend our system by plugging in more realistic predicates and thus extending the subsumes () function correspondingly. One pleasant side effort of this design choice is that our current classification algorithm is tractable <ref> [6, 27, 9] </ref>. We plan to integrate our class integration software with the other parts of the MultiView prototype in the future. 12 RELATED WORK An immediate extension of the view mechanism from relational databases to OODB systems is to define a view to be equal to an object-oriented query. <p> Lastly, since the derivation of new classes is accomplished in MultiView using well-defined object algebra operators, we are able to reduce the complexity of classification depending on the operator used for derivation. This issue is not addressed in [35]. Other work of more theoretical nature, such as <ref> [6, 27, 9] </ref>, analyses different concept description languages to determine the complexity of classification.
Reference: [28] <author> Richardson, J. and Schwarz, P., </author> <title> Aspects: Extending Objects to Support Multiple, Independent Roles, </title> <booktitle> in SIGMOD, </booktitle> <year> 1991, </year> <pages> pp. 298 - 307. </pages>
Reference: [29] <author> E. A. Rundensteiner, L. Bic, J. Gilbert, and M. Yin, </author> <title> "Set-Restricted Semantic Groupings," </title> <journal> in IEEE Trans. on Data and Knowledge Engineering, </journal> <note> to appear in April 1993. </note>
Reference-contexts: A class is also a container for a set of object instances, denoted by extent (C) <ref> [29] </ref>. 2.2 Type Hierarchy and Type Relationships Definition 1. We define a partial order on types T as follows.
Reference: [30] <author> Rundensteiner, E. A., </author> <title> "MultiView: A Methodology for Supporting Multiple View Schemata in Object-Oriented Databases," </title> <booktitle> 18th Int. Conference on Very Large Data Bases (VLDB'92), </booktitle> <address> Vancouver, Canada, </address> <pages> pp. 187 - 198, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: We therefore define an object-oriented view, also called a view schema, to be a virtual, possibly restructured, subschema graph of the global schema <ref> [30] </ref>. The construction of these view schemata raises challenging research issues in terms of how to restructure view schema graphs, how to relate them with the global schema structure, and how to effectively share information between views. <p> stored query - interrelated with other classes via diverse relationships view schema = - schema graph of virtual classes - complex interrelated graph structure explicit relationships between objects (complex objects) view schema = - collection of view definitions - set of `unrelated' relations We have developed a methodology, called MultiView <ref> [30] </ref>, for supporting multiple view schemata that successfully addresses these problems. The key idea of MultiView is to organize both base and virtual classes into one comprehensive global schema graph based on which object-oriented views can be specified in a consistent manner. <p> In this paper, we present a solution to the second task, while solutions to the first and the third tasks of MultiView are given in <ref> [30] </ref> and in [34], respectively. <p> Person TeenageGirl (Person /" Age&lt;21 /" Age&gt;=13 /" Sex=female) Adult (Person /" Age&gt;=21) TeenageBoy (Minor /" Age&gt;=13 /" Sex=male) (e) View Schema Generation. 7 In this paper, we present a solution to the second task. Solutions to the first and the third tasks of MultiView are given in <ref> [30] </ref> and in [34], respectively. The separation of the view schema design process into a number of well-defined tasks has several advantages. First, it simplifies the view specification and maintenance, since each of the tasks can be solved independently from the others. <p> We utilize an object algebra as query language for class customization, as defined in in Figure 1. The object algebra provides six basic operators that can be nested to form arbitrarily complex class derivations. A discussion and examples of the object algebra can be found elsewhere <ref> [30] </ref>. The second task of MultiView, which is the subject of this paper, supports the integration of virtual classes into one global schema.
Reference: [31] <author> Rundensteiner, E. A., and Bic, L., </author> <title> "Set Operations in Object-Based Data Models", </title> <journal> in IEEE Transaction on Data and Knowledge Engineering, </journal> <note> to appear in Volume 4, Issue 3, </note> <month> June </month> <year> 1992. </year>
Reference-contexts: The characterization of both problems is made possible by our approach of distinguishing between the type and the set content of a class as two independent concepts <ref> [31] </ref>. The first problem is concerned with constructing a type (and also class) hierarchy that includes the type of the new virtual class while assuring the correct type inheritance for all classes. <p> We ensure uniqueness of properties by associating a unique property identifier with each newly defined property. Two properties that have the same property name can thus be distinguished internally based on their identifier. For other schemes of disambiguation of property names see <ref> [31] </ref>. 3 Given a finite set of types T, we call t 1 a direct subtype of t n , denoted by t 1 OE t n , if (t 1 t n ) and (t 1 6= t n ) and there are no other types t k j 2 <p> Each directed edge e from t 1 to t 2 , e = &lt;t 1 ; t 2 &gt;, represents the direct subtype relationship (t 1 OE t 2 ) in TV. Operators for forming new types based on two existing types are introduced next <ref> [31] </ref>. Definition 3. Let t1,t2 2 T . Then t is a function from T 2 ! T that defines a new type t3 by t3 = t1 t t2. The property functions properties t3 of t3 are defined by: properties t3 = properties t1 [ properties t2 . <p> In fact, we will describe two problems that this class integration algorithm does not properly address. 5 PROBLEMS OF CLASSIFICATION IN OBJECT-ORIENTED DATA MODELS Based on our distinction between the type and the set content of a class as two independent concepts <ref> [31] </ref>, we have identified the following two problems related to classification in object-oriented data models: 1. inheritance mismatch problem in the type hierarchy, and 2. the problem of composing is-a incompatible subset and subtype hierarchies into one class hierarchy. 3 Since we assume for simplicity that property functions have a unique
Reference: [32] <author> Rundensteiner, E. A., </author> <title> "Design Views for Synthesis: Provide Both Uniform Data Integration and Diverse Data Customization," </title> <institution> Electrical Engineering and Computer Science Dept., University of Michigan, Ann Arbor, </institution> <type> Tech. Rep. </type> <institution> CSE-TR-148-92, </institution> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Last but not least, the usage of MultiView to solve real applications is needed to validate its usefulness. Indeed, the development of MultiView has been driven by our need to provide multiple design views for CAD tools working on a central database <ref> [32] </ref>.
Reference: [33] <author> Rundensteiner, E. A., </author> <title> "Object-Oriented Views: A Novel Approach to Tool Integration in Design Environments," </title> <type> Dissertation, </type> <institution> Info. and Computer Science Department, Univ. of Cal., Irvine, </institution> <type> Tech. Rep. </type> <pages> 92-83, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: Example 1. We depict base and virtual classes by circles and dotted circles, respectively. Figure 2 shows the relationship between (a) a base schema BS, (c) a global schema GS, and (e) a view schema VS. 3 THE MultiView METHODOLOGY MultiView <ref> [33] </ref> breaks view specification into the following three tasks: 1. the generation of customized classes using object-oriented queries, 2. the integration of derived classes into one consistent global schema graph, and 3. the specification of arbitrarily complex view schemata composed of both base and virtual classes on top of the augmented <p> In [34], we show that a simple algorithm can be used to automatically augment a set of selected view classes to generate a valid view schema hierarchy <ref> [33] </ref>. The example given next presents an overview of view specification in MultiView. Example 2. Given the global schema GS in Figure 2.a, the view definer specifies the virtual classes ALU and LogicUnits using object-oriented queries (Figure 2.b). The integration of these classes into GS is given in Figure 2.c. <p> Proof: The proof is given in <ref> [33] </ref>. 16 6.3 Minimizing the Generation of Intermediate Classes Next, we discuss how to limit the number of intermediate classes g i generated for assuring the closure of a schema graph after class integration. This work is based on [23]. Definition 13. <p> Proof: The proof is given in <ref> [33] </ref>. 4 When dealing with an is-a compatible schema graph, then VC being a subtype of these classes would also be a subset of rep (G i ). Hence, content (rep (G i )) [ content (V C) = content (rep (G i )) 18 Lemma 5. <p> More formally, for all C j 2 G i , all classes C k 2 V with (C j is-a * C k ) and (C k is-a * rep (G i )) must also be members of G i . Proof (By contradiction): The proof is given in <ref> [33] </ref>. 6.4 Interconnecting Intermediate Classes Let f () denote the function defined by f (t j ) = (t j u V C) = g j . <p> Figure 11.a shows the schema G before type classification. We assume that the virtual class VC is derived by the view derivation "VC = hide [b] from C4". For a explanation of the example see <ref> [33] </ref>. In [23], the algorithm has been shown to be of quadratic complexity O (m 2 ) with m the number of edges in G. <p> Based on Definition 16, the algorithm for finding the correct position for VC in the schema G=(V,E) is given in Figure 12 (See a detailed description in <ref> [33] </ref>). Next we demonstrate the algorithm on an example. Example 12. In Figure 13, the first step of the algorithm finds the DIRECT-PARENTS V C set by depth-first downwards traversal of G starting from the root C0. <p> Theorem 5. (Correctness) Given the schema G = (V,E) and a class VC, the Class-Placement algorithm in Figure 12 integrates VC into G with the resulting G representing a valid schema as defined in Definition 6. Proof: The proof of correctness is given in <ref> [33] </ref>. A detailed description of the algorithms and their analysis for accomplishing subtasks (1) and (3) of the Class-Placement algorithm given in Figure 12 can be found in [33]. <p> Proof: The proof of correctness is given in <ref> [33] </ref>. A detailed description of the algorithms and their analysis for accomplishing subtasks (1) and (3) of the Class-Placement algorithm given in Figure 12 can be found in [33]. Note that these algorithms handle multiple inheritance, which often has been ignored by classification algorithms proposed for description languages in artifical intelligence. <p> Figure 10 depicts the resulting class integration algorithm. Detailed examples of applying the classification algorithm can be found in <ref> [33] </ref>. 26 C0 sup C3 sup sup C9 C10 sup sup C4 sub sub sub sub C15 C16 C19 C20 C23 C25 C26 C30 C2 C1 C7 C8 sup C5 C6 C11 sup sub sub sub sub sub C13 C17 C18 C21 C22 C24 C27 C28 C29 VC search spaces for <p> We found that in the majority of cases the type hierarchy preparation procedure, which has quadratic complexity, need not be run 6 . The table in Figure 17 presents a summary of our results, while a more detailed discussion can be found elsewhere <ref> [33] </ref>. The first column of the 6 For the following, we refer to the simple class placement procedure defined in Section 7 by algorithm A and to the more complex algorithm for generating intermediate types defined in Section 8 by algorithm B.
Reference: [34] <author> Rundensteiner, E. A. and Bic, L., </author> <title> "Automatic View Schema Generation in Object-Oriented Databases," </title> <institution> Dept. of Information and Computer Science, Univ. of Cal., Irvine, </institution> <type> Tech. Rep. </type> <pages> 92-15, </pages> <year> 1992. </year>
Reference-contexts: In this paper, we present a solution to the second task, while solutions to the first and the third tasks of MultiView are given in [30] and in <ref> [34] </ref>, respectively. <p> In fact, it reduces the problem of determining the class generalization hierarchy for each of the view schemata to a simple graph-theoretic algorithm <ref> [34] </ref>. Also, if the virtual classes are not integrated with the classes in the global schema, then a view schema would correspond to a collection of possibly `unrelated' classes rather than a generalization schema graph. <p> Solutions to the first and the third tasks of MultiView are given in [30] and in <ref> [34] </ref>, respectively. The separation of the view schema design process into a number of well-defined tasks has several advantages. First, it simplifies the view specification and maintenance, since each of the tasks can be solved independently from the others. <p> In this paper, we present, for instance, algorithms that automate the second task of integrating virtual classes into one consistent global schema graph. Similarly, we have proposed algorithms for the third task elsewhere <ref> [34] </ref>. The first task of MultiView supports the customization of existing classes by deriving virtual classes with a modified type description and membership content. This part of MultiView is similar to the work of object-oriented views by others [21, 18, 36]. <p> This supports for instance the virtual restructuring of the is-a hierarchy by allowing to hide from and to expose classes within a view schema. In <ref> [34] </ref>, we show that a simple algorithm can be used to automatically augment a set of selected view classes to generate a valid view schema hierarchy [33]. The example given next presents an overview of view specification in MultiView. Example 2.
Reference: [35] <author> Schmolze, J. G., and Lipkis, T. A., </author> <title> Classification in the KL-ONE Knowledge Representation System, </title> <booktitle> The Eigth Int. Joint Conf. on Artificial Intelligence, </booktitle> <address> (IJCAI'83), </address> <month> Aug. </month> <year> 1983, </year> <title> vol.1, </title> <journal> pg. </journal> <volume> 330 - 332. </volume>
Reference-contexts: A discussion of advantages of our approach can be found in the Introduction (Section 1) and thus is not repeated here. 4.2 A Simple Classification Algorithm Classification is the process of taking a new [class] description and putting it where it belongs in the [class] hierarchy <ref> [35] </ref>. A class is in the "right place" if it is below all classes that subsume it and if it is above all classes that it subsumes. <p> We thus need to define a boolean function subsumes (): subsumes (C1; C2) = ae true if C1 is a C2 f ail otherwise While exact details of the subsumes () function are dependent on the object model, we characterize its general features next <ref> [35] </ref>. <p> For object-oriented data models, the classification problem is not decidable since it may involve the comparison of arbitrary methods and predicates <ref> [35] </ref>. Therefore, our classification algorithm is sound but not complete. For instance, if two classes have property functions with equivalent semantics but different property identifiers, then the subsumes () function will fail even though these two classes may indeed by equivalent. <p> Then VC is placed below all its direct parent classes and above all its direct children classes (Definition 7). As we will show in the following sections, this simplified classification algorithm advocated repeatedly in the literature <ref> [35, 40, 1] </ref> does not correctly account for the type inheritance underlying the object-oriented schema graph. <p> Of course, class integration, which does not become an issue when dealing with an individual class only, is as of now unexplored in the context of their system. Algorithms for special forms of the classification problem have been proposed in the Artificial Intelligence literature. Schmolze and Lipkis <ref> [35] </ref>, for instance, describe a classifier for `concepts' in the KL-ONE Knowledge Representation System. The KL-ONE Knowledge Representation scheme does not include behavioral abstractions and abstract data types as done in an object-oriented model. Hence, the type inheritance mismatch problem is not addressed by their solution. <p> Lastly, since the derivation of new classes is accomplished in MultiView using well-defined object algebra operators, we are able to reduce the complexity of classification depending on the operator used for derivation. This issue is not addressed in <ref> [35] </ref>. Other work of more theoretical nature, such as [6, 27, 9], analyses different concept description languages to determine the complexity of classification.
Reference: [36] <author> Scholl, M. H., Laasch, C. and Tresch, M., </author> <title> Updatable Views in Object-Oriented Databases, </title> <booktitle> Proc. 2nd DOOD Conf., </booktitle> <address> Muenich, </address> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: Most initial proposals of views on OODBs suggest a direct extension of the view mechanism from relational databases to OODB systems, namely, they define an object-oriented view to be equal to an object-oriented query <ref> [18, 36, 21] </ref>. Note however that a relational schema is simply a set of `unrelated' relations [12], whereas an object-oriented data schema corresponds to a complex structure of classes interrelated via generalization and decomposition relationships [21, 22] (See also Figure 1). <p> In this paper, we present a solution to the second task, while solutions to the first and the third tasks of MultiView are given in [30] and in [34], respectively. Other work on object-oriented views <ref> [36, 40, 1] </ref> indicates the need for classification, MultiView is unique in providing a complete solution to this classification problem for object-oriented data models. 1 Explicit capture of class relationships between stored and derived classes in the form of a global schema graph brings numerous advantages. <p> Similarly, we have proposed algorithms for the third task elsewhere [34]. The first task of MultiView supports the customization of existing classes by deriving virtual classes with a modified type description and membership content. This part of MultiView is similar to the work of object-oriented views by others <ref> [21, 18, 36] </ref>. We utilize an object algebra as query language for class customization, as defined in in Figure 1. The object algebra provides six basic operators that can be nested to form arbitrarily complex class derivations. A discussion and examples of the object algebra can be found elsewhere [30]. <p> if they have equal identifiers rather than by comparing the actual function body, the later being a potentially undecidable problem. 11 5.1 The Type Inheritance Problem The first problem is concerned with constructing a type hierarchy that assures the proper inheritance of property functions after the insertion of new classes <ref> [36] </ref>. As we demonstrate below, in some cases there may be no correct placement for a class VC in a given schema graph G. <p> Instead, the derived classes are treated as "stand-alone" objects [18], or they are attached directly as subclasses of the schema root class [21], or they are attached directly as subclasses of the source classes of the view derivation [25]. Scholl et al.'s recent work <ref> [36] </ref> sketch the class integration process for a selected subset of the operators of the query language COOL. <p> This localized class integration approach is directly guided by the derivation of a virtual class, and they do not, as we have shown in this paper, present an algorithm for finding the globally most appropriate location in the schema graph. Scholl et al. <ref> [36] </ref> do not consider the problem of generating multiple view schemata, which is an integral part of MultiView. In Abiteboul and Bonner's [1] view mechanism, the user is in charge of constructing local view schemata using the import/export facility of O 2 . <p> As discussed in Section 11, future work needs to focus on implementation issues, such as an object representation that allows for object instances to be a member of many types <ref> [36] </ref>, and new efficient strategies for method resolution. Other important issues, such as query processing techniques on views, materialized views, and view updates, which have been extensively studied in the relational model, must now be reexamined in the context of object-oriented data models. <p> In this paper, we have restricted the set of object algebra operators to be object-preserving <ref> [36] </ref>. We believe strongly that this is sufficient for many application domains, in particular, since the join operator can be simulated using the refine operator. However, it would be interesting to investigate whether, and if so how, MultiView could be extended to also handle object-generating algebra operators [21, 18].
Reference: [37] <author> Shilling, J. J., and Sweeney, P. F., </author> <title> Three Steps to Views: Extending the Object-Oriented Paradigm, </title> <booktitle> in Proc. of the Int. Conf. on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA'89), </booktitle> <address> New Orleans , Sep. </address> <year> 1989, </year> <pages> 353 - 361. </pages>
Reference-contexts: In this paper, we have provided a solution for this. In fact, by breaking the view schemata definition process into a number of distinct phases, we were able to reduce the view definition to a simple yet powerful mechanism. Shilling and Sweeney's approach <ref> [37] </ref> propose that a class has multiple type interfaces instead of having one type, whereas MultiView uses the type refinement capability of the generalization hierarchy for specializing types. Our work does not require the extension of the class concept and thus we can use current query languages for class customization.
Reference: [38] <author> D. W. Shipman, </author> <title> "The Functional Data Model and the Data Language DAPLEX," </title> <journal> in ACM Trans. on Database Systems, </journal> <volume> vol. 6, issue 1, </volume> <pages> pp. 140-173, </pages> <month> Mar. </month> <year> 1981. </year>
Reference: [39] <author> Stein, L. A., and Zdonik, S. B., "Clovers: </author> <title> The Dynamic Behavior of Types and Instances," </title> <institution> Brown Univ. </institution> <type> Technical Rep. </type> <institution> No. CS-89-42, </institution> <month> Nov. </month> <year> 1989. </year>
Reference: [40] <author> Tanaka, K., Yoshikawa, M., and Ishihara, K., </author> <title> "Schema Virtualization in Object-Oriented Databases," </title> <booktitle> In Proc. IEEE Data Engineering Conf., </booktitle> <month> Feb. </month> <year> 1988, </year> <journal> pg. </journal> <volume> 23 - 30. </volume>
Reference-contexts: In this paper, we present a solution to the second task, while solutions to the first and the third tasks of MultiView are given in [30] and in [34], respectively. Other work on object-oriented views <ref> [36, 40, 1] </ref> indicates the need for classification, MultiView is unique in providing a complete solution to this classification problem for object-oriented data models. 1 Explicit capture of class relationships between stored and derived classes in the form of a global schema graph brings numerous advantages. <p> Then VC is placed below all its direct parent classes and above all its direct children classes (Definition 7). As we will show in the following sections, this simplified classification algorithm advocated repeatedly in the literature <ref> [35, 40, 1] </ref> does not correctly account for the type inheritance underlying the object-oriented schema graph. <p> Neither the use of a query language to define arbitrary view classes (e.g., join or select) nor the classification of such classes is addressed by their work. Tanaka et al.'s pioneering work on schema virtualization <ref> [40] </ref> does not distinguish between the task of integrating derived classes into a common schema and the task of generating view schemata. While recognizing the need for class integration, they do not present a general classification algorithm.
References-found: 40

