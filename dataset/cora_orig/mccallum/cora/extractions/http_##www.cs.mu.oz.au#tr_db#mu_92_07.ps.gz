URL: http://www.cs.mu.oz.au/tr_db/mu_92_07.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: CONSTRAINTS FOR QUERY OPTIMIZATION IN DEDUCTIVE DATABASES  
Author: James Harland Kotagiri Ramamohanarao 
Address: Melbourne  
Affiliation: Department of Computer Science, University of  
Abstract: There are many ways in which the query answering process for deductive databases may be optimised. At the heart of many of these methods is some form of constraint on the variables of the query, so that facts which are not relevant to the query are not computed. In this paper we show how fold/unfold transformations may be used to propagate some forms of constraint which are not captured by techniques such as magic sets. In particular, the fold/unfold transformation provides a straightforward way to propagate constraints involving multiple occurrence of a variable.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Gardiner and J. Shepherdson, </author> <title> Unfold/Fold Transformations of Logic Programs, </title> <booktitle> in Computational Logic: Essays in Honour of Alan Robinson 565-583, </booktitle> <editor> J-L. Lassez and G. Plotkin (eds.), </editor> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In this paper we show how such constraints may be propagated by the use of fold and unfold transformations <ref> [11, 1] </ref>. We also show how some binding patterns not captured by magic sets, such as those discussed in [3], may be captured very naturally by the use of fold/unfold transformations. <p> We also use the usual notion of adornment [12] in order to express mode information. We shall use the default left-to-right sideways information-passing strategy (sip) throughout this paper. The definitions of the fold/unfold transformations are given in <ref> [11, 1] </ref>, and are somewhat involved; for our purposes it will suffice to note that folding replaces a given conjunction of goals in the body of a clause with a call to an equivalent predicate, whereas unfolding "unwinds" the definition of a given predicate by replacing occurrences of the predicate by
Reference: [2] <author> J. Grant and J. Minker, </author> <title> Integrity Constraints in Knowledge Based Systems, </title> <type> Technical Report CS-TR-2223, </type> <institution> Department of Computer Science, University of Maryland, </institution> <year> 1989. </year>
Reference-contexts: It was shown in [4] how such constraints may be propagated. Another possibility is to use integrity constraints to restrict the search space of the query <ref> [2] </ref>. Another kind of constraint that may be propagated are those which arise from multiple occurrences of the same variable. <p> The important point is that once a constraint is identified, the propagation of the constraint should be straightforward, using known techniques. In the future we hope to explore the possibilities for such a methodology using integrity constraints for optimization, in the manner of Minker et al. <ref> [2] </ref>.
Reference: [3] <author> J. Han, </author> <title> Is it Possible to Capture More Bindings than Magic Rule Rewriting?, </title> <booktitle> Proceedings of the ILPS'91 workshop on Deductive Databases, </booktitle> <address> San Diego, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: In this paper we show how such constraints may be propagated by the use of fold and unfold transformations [11, 1]. We also show how some binding patterns not captured by magic sets, such as those discussed in <ref> [3] </ref>, may be captured very naturally by the use of fold/unfold transformations. Hence we show how the use of these simple techniques may be used as a powerful means of constraint propagation, an observation mentioned in [10]. This paper is organised as follows. <p> Thus empirical evidence will be useful guide for determining when the number of answers is "sufficiently large" and the intersection "sufficiently small" to justify this transformation. 5 4 "Non-Magic" Constraints In <ref> [3] </ref> it is shown how the propagation of some binding constraints, which are not captured by magic sets, may be propagated by using unfolding. In this section we show how two examples of this sort may be performed more simply by the use of folding as well. <p> Thus the constraint is not a binding constraint, but a filtering one, in that certain values pass the filter and others don't. In <ref> [3] </ref> it is shown how this constraint may be propagated by unfolding, to obtain the clauses p (X 1 ; X; Y ) :- e (X 1 ; X; Y ). d (X 2 ; Y 1 ). e (X 3 ; X 2 ; Y 1 ); d (X 3 <p> This is known as an existential query, and certain techniques for optimisation of such queries are known [7]. The important point to note is that not only does the use of folding allow us to propagate the constraint more neatly than <ref> [3] </ref>, but also it allows us to easily identify further optimisations, such as the existential one. Another example given in [3] is the one below. p (X; Y; Z) :- e (X; Y; Z). d (Y 1 ; Z; Z 1 ). <p> The important point to note is that not only does the use of folding allow us to propagate the constraint more neatly than <ref> [3] </ref>, but also it allows us to easily identify further optimisations, such as the existential one. Another example given in [3] is the one below. p (X; Y; Z) :- e (X; Y; Z). d (Y 1 ; Z; Z 1 ). In this case, the constraint is propagated to the clauses below in [3]: p (X; Y; Z) :- e (X; Y; Z). d (Y 1 ; Z; Z 1 <p> Another example given in <ref> [3] </ref> is the one below. p (X; Y; Z) :- e (X; Y; Z). d (Y 1 ; Z; Z 1 ). In this case, the constraint is propagated to the clauses below in [3]: p (X; Y; Z) :- e (X; Y; Z). d (Y 1 ; Z; Z 1 ). p (X 1 ; X; Y ) :- ccdd (X; Y; Z; X 2 ; Y 2 ; Z 2 ), p (X 2 ; Y 2 ; Z 2 ). ccdd (X; <p> These same transformations have been used previously for constraint propagation [4], and as the latter examples show, it would seem that this method of propagation should be the standard method. It should also be noted that the techniques of <ref> [3] </ref> are specifically designed for linear recursive rules, whereas the fold/unfold transformations do not have this intrinsic limitation, and hence provide a more general framework for constraint propagation, which in turn may make use of specific properties, such as linear recursion. 5 Conclusion We have seen how certain types of constraints
Reference: [4] <author> D. Kemp, K. Ramamohanrao, I. Balbin and K. Meenakshi, </author> <title> Propagating Constraints in Recursive Deductive Databases, </title> <booktitle> Proceedings of the North American Conference on Logic Programming 981-998, </booktitle> <address> Cleveland, </address> <month> October, </month> <year> 1989. </year>
Reference-contexts: For example, a constraint such as X &gt; 1 is not a binding constraint, but rather a "filtering" constraint, in that certain values of X make this constraint true and others do not. It was shown in <ref> [4] </ref> how such constraints may be propagated. Another possibility is to use integrity constraints to restrict the search space of the query [2]. Another kind of constraint that may be propagated are those which arise from multiple occurrences of the same variable. <p> The above examples show how the fold/unfold transformations may be used to propagate certain types of constraints. These same transformations have been used previously for constraint propagation <ref> [4] </ref>, and as the latter examples show, it would seem that this method of propagation should be the standard method.
Reference: [5] <author> J. Naughton, R. Ramakrishnan, Y. Sagiv and J. Ullman, </author> <title> Efficient Evaluation of Right-, Left-, and Multi-Linear Rules, </title> <booktitle> Proceedings of the SIGMOD International Symposium on Management of Data 235-242, </booktitle> <address> Portland, </address> <month> May, </month> <year> 1989. </year>
Reference: [6] <author> J. Naughton, R. Ramakrishnan, Y. Sagiv and J. Ullman, </author> <title> Argument Reduction by Factoring, </title> <booktitle> Proceedings of the Fifteenth International Conference on Very Large Data Bases 173-182, </booktitle> <address> Amsterdam, </address> <month> August, </month> <year> 1989. </year>
Reference: [7] <author> R. Ramakrishnan, C. Beeri and R. Krishnamurthy, </author> <title> Optimizing Existential Datalog Queries, </title> <booktitle> Proceedings of the ACM Symposium on Principles of Database Systems 89-102, </booktitle> <address> Austin, </address> <month> March, </month> <year> 1988. </year>
Reference-contexts: This is known as an existential query, and certain techniques for optimisation of such queries are known <ref> [7] </ref>. The important point to note is that not only does the use of folding allow us to propagate the constraint more neatly than [3], but also it allows us to easily identify further optimisations, such as the existential one.
Reference: [8] <author> Y. Sagiv, </author> <title> Is There Anything Better than Magic?, </title> <booktitle> Proceedings of the North American Conference on Logic Programming 235-254, </booktitle> <address> Austin, </address> <month> October, </month> <year> 1990. </year>
Reference: [9] <author> T. Sato and H. Tamnaki, </author> <title> Deterministic Transformation and Determinitic Synthesis, Programming of Future Genreation Computers II 307-327, </title> <editor> K. Fuchi and L. Koptt (eds.), </editor> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference: [10] <author> D. Srivastava and R. Ramakrishnan, </author> <title> Fold/Unfold in Constraint Query Optimization, </title> <type> draft manuscript, </type> <year> 1991. </year>
Reference-contexts: Hence we show how the use of these simple techniques may be used as a powerful means of constraint propagation, an observation mentioned in <ref> [10] </ref>. This paper is organised as follows. In Section 2 we give the necessary technical preliminaries, and in the following section we show how multiple variable constraints may be propagated by fold/unfold transformations.
Reference: [11] <author> H. Tamaki and T. Sato, </author> <title> Unfold/Fold Transformation of Logic Programs, </title> <booktitle> Proceedings of the Second International Conference on Logic Programming 127-138, </booktitle> <address> Uppsala, </address> <month> July, </month> <year> 1984. </year>
Reference-contexts: In this paper we show how such constraints may be propagated by the use of fold and unfold transformations <ref> [11, 1] </ref>. We also show how some binding patterns not captured by magic sets, such as those discussed in [3], may be captured very naturally by the use of fold/unfold transformations. <p> We also use the usual notion of adornment [12] in order to express mode information. We shall use the default left-to-right sideways information-passing strategy (sip) throughout this paper. The definitions of the fold/unfold transformations are given in <ref> [11, 1] </ref>, and are somewhat involved; for our purposes it will suffice to note that folding replaces a given conjunction of goals in the body of a clause with a call to an equivalent predicate, whereas unfolding "unwinds" the definition of a given predicate by replacing occurrences of the predicate by
Reference: [12] <author> J. Ullman, </author> <title> Implementation of Logical Query Languages for Databases, </title> <journal> ACM Transactions on Database Systems 10:3:289-321, </journal> <year> 1985. </year> <month> 9 </month>
Reference-contexts: Furthermore, we assume that all clauses are range-restricted, i.e. that all variables which occur in the head of a clause must occur in the body of the clause (note that this means that the base relations must contain only ground terms). We also use the usual notion of adornment <ref> [12] </ref> in order to express mode information. We shall use the default left-to-right sideways information-passing strategy (sip) throughout this paper.
References-found: 12

