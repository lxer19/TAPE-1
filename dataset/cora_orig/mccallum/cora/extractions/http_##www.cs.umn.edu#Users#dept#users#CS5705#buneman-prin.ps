URL: http://www.cs.umn.edu/Users/dept/users/CS5705/buneman-prin.ps
Refering-URL: http://www.cs.umn.edu/Users/dept/users/CS5705/
Root-URL: http://www.cs.umn.edu
Email: Email: fpeter, valg@cis.upenn.edu  Email: shamim@bellcore.com  Email: limsoon@iss.nus.sg  
Title: Principles of Programming with Complex Objects and Collection Types  
Author: Peter Buneman Shamim Naqvi Val Tannen Limsoon Wong 
Address: 200 South 33rd Street, Philadelphia, PA 19104.  445 South Street, Morristown, NJ 07960-1910.  Heng Mui Keng Terrace, Singapore 0511.  
Affiliation: University of Pennsyvania, Department of Computer and Information Science,  Bellcore,  Institute of Systems Science.  
Note: Invited paper appeared in Theoretical Computer Science 149(1):3-48, 1995. Extended abstract appeared in Proceedings of 4th International Conference on Database Theory.  
Date: January 95  
Abstract: We present a new principle for the development of database query languages that the primitive operations should be organized around types. Viewing a relational database as consisting of sets of records, this principle dictates that we should investigate separately operations for records and sets. There are two immediate advantages of this approach, which is partly inspired by basic ideas from category theory. First, it provides a language for structures in which record and set types may be freely combined: nested relations or complex objects. Second, the fundamental operations for sets are closely related to those for other "collection types" such as bags or lists, and this suggests how database languages may be uniformly extended to these new types. The most general operation on sets, that of structural recursion, is one in which not all programs are well-defined. In looking for limited forms of this operation that always give rise to well-defined operations, we find a number of close connections with existing database languages, notably those developed for complex objects. Moreover, even though the general paradigm of structural recursion is shown to be no more expressive than one of the existing languages for complex objects, it possesses certain properties of uniformity that make it a better candidate for an efficient, practical language. Thus rather than developing query languages by extending, for example, relational calculus, we advocate a very powerful paradigm in which a number of well-known database database languages are to be found as natural sublanguages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul, C. Beeri, </author> <title> On the power of languages for the manipulation of complex objects, </title> <booktitle> in "Proceedings of International Workshop on Theory and Applications of Nested Relations and Complex Objects," </booktitle> <address> Darmstadt, </address> <year> 1988. </year>
Reference-contexts: To overcome these limitations, there have been two general strategies. The first has been to add extra operations such as a fixpoint or while [14, 3]. The second has been to consider higher-order logics <ref> [1] </ref> or restricted algebras for higher-order (nested) relations [51, 57, 16]. <p> In section 5 we further augment the language with a powerset operation R (=; cond), to obtain the algebra of Abiteboul and Beeri <ref> [1] </ref>. In view of conservativity over relational algebra, this algebra cannot express functions such as transitive closure and parity test without a potentially expensive excursion through an powerset type. Furthermore, we show that it cannot uniformly compute the cardinality of a set no matter what extra arithmetic primitives are added. <p> In <ref> [1] </ref>, Abiteboul and Beeri introduce three languages that can all express powerset, and they show them to be equivalent: a "complex object" algebra and calculus, and an extension to datalog with certain higher-order predicates such as subset and membership. <p> If we add for each complex object type oe the primitive powerset oe : foeg ! ffoegg, we obtain a formalism equivalent to the complex object algebra in <ref> [1] </ref>. <p> external functions are absent While we have explained through theorem 5.1 in what sense structural recursion is strictly more powerful than A&B, we still want to explain the intuition that since A&B can do certain least fixed points, in fact enough to simulate a Datalog-like language with predicates on sets <ref> [1] </ref>, it will be able to express the functions defined by structural recursion, which are also least relations given appropriate properties. It will turn out that we can justify this intuition formally, but our reduction from structural recursion to A&B will not be polymorphic. <p> Our approach can be used for different collections: languages for or-sets were studied in [33, 23, 38] and bag languages in [37]. As mentioned before, [54] shows that transitive closure, which is efficiently expressible using structural recursion, has a necessarily exponential implementation in complex-object algebra <ref> [1] </ref>. [30] show how to encode related database languages in the simply-typed lambda-calculus. The possibility of treating arrays as collection types is suggested in [12].
Reference: [2] <author> S. Abiteboul and G. </author> <title> Hillebrand Space usage in functional query languages, </title> <booktitle> in "LNCS 893: Proceedings of 5th International Conference on Database Theory," </booktitle> <pages> 439-454, </pages> <address> Prague, Czech Republic, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: Suciu and Paredaens [54] show that if we adopt the usual, eager, evaluation strategy for queries, then any A&B expression for transitive closure must construct an intermediate result of exponential size, hence obtaining an EXPSPACE lower bound. Abiteboul and Hillebrand <ref> [2] </ref> show that an operational semantics with pipelining optimizations yields a PSPACE (but still EXPTIME) algorithm for the A&B expression of transitive closure mentioned above.
Reference: [3] <author> S. Abiteboul, V. Vianu, </author> <title> Fixpoint extensions of first-order logic and Datalog-like languages, </title> <booktitle> in "Proceedings of 4th IEEE Symposium on Logic in Computer Science," </booktitle> <pages> 71-79, </pages> <address> Pacific Grove, California, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: To overcome these limitations, there have been two general strategies. The first has been to add extra operations such as a fixpoint or while <ref> [14, 3] </ref>. The second has been to consider higher-order logics [1] or restricted algebras for higher-order (nested) relations [51, 57, 16].
Reference: [4] <author> A. V. Aho, J. D. Ullman, </author> <title> Universality of data retrieval languages, </title> <booktitle> in "Proceedings 6th Symposium on Principles of Programming Languages," </booktitle> <pages> 110-120, </pages> <address> Texas, </address> <month> January </month> <year> 1979. </year>
Reference-contexts: 1 Introduction Overcoming the limitations of first-order logic as a database query language has always been a major focus of relational database research. The limitations are well-known: first-order logic cannot express certain simple computations on relations <ref> [4] </ref>; also, by its nature, it cannot directly express queries on structures that are not simple relations, such as nested relations or other useful database types such as bags (multisets) and lists. To overcome these limitations, there have been two general strategies. <p> At the same time the nested relational algebra has severe limitations on expressiveness. Indeed, in view of corollary 4.6 and <ref> [4, 14] </ref>, there are also polynomial time operations such as transitive closure and parity that cannot be defined in R (=; cond). In this section we consider constructs that extend the expressive power of R (=; cond).
Reference: [5] <author> F. Bancilhon, T. Briggs, S. Khoshafian, P. Valduriez, </author> <title> A powerful and simple database language, </title> <booktitle> in "Proceedings of 14th International Conference on Very Large Data Bases," </booktitle> <pages> 97-105, </pages> <year> 1988. </year>
Reference: [6] <author> H. Barendregt, </author> <title> "The Lambda Calculus: Its Syntax and Semantics," </title> <publisher> Elsevier, </publisher> <year> 1984. </year> <month> 36 </month>
Reference-contexts: As is customary, we identify those expressions that differ only in the name of the bound variables, and we adopt the bound variable convention <ref> [6] </ref> which says that in any given mathematical context, we can assume that all the bound variables are distinct among themselves and distinct from the free variables occurring in that context.
Reference: [7] <author> V. Breazu-Tannen, P. Buneman, S. Naqvi, </author> <title> Structural recursion as a query language, </title> <booktitle> in "Pro--ceedings of 3rd International Workshop on Database Programming Languages," </booktitle> <pages> 9-19, </pages> <address> Naphlion, Greece, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: Considerable effort is needed to realize this semantics in the syntax of a practical programming language. Since the inception of this work in <ref> [7, 9] </ref>, there have been two practical developments. The first is the implementation of practical languages: Shaharazade by Naqvi and his colleagues at Bellcore [50, 60]. Shahrazade has been used to model telecommunications operations support systems. <p> Also, much data is contained in special-purpose software such as sequence-matching programs, that implement external functions (point 4). 35 7.2 Further results on structural recursion and collection types Since the appearance of the papers on which this work was based <ref> [7, 9] </ref>, a substantial body of related research has appeared. Following the conservative extension result of [63], [52] shows that by adding a bounded fixed-point construct to R (=; cond) gives us, at relational types, inflationary datalog.
Reference: [8] <author> V. Breazu-Tannen, R. Subrahmanyam, </author> <title> Logical and computational aspects of programming with Sets/Bags/Lists, </title> <booktitle> in "LNCS 510: Proceedings of 18th International Colloquium on Automata, Languages, and Programming," </booktitle> <pages> 60-75, </pages> <address> Madrid, Spain, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: definable by structural recursion. 2 In fact, if we consider only sr comb and what can be from it, then our definitions and results further generalize to binary trees (by dropping the associativity requirement) hence to all the levels of Boom's hierarchy of types [43]. 3 Using some higher-order programming <ref> [8] </ref>, or some exponential computations [56], one can also define sr add in terms of sr comb. 8 Some identities Because initiality postulates unique homomorphisms and because the composition of two homomorphisms is also a homomorphism it follows immediately that if i is left-commutative then sr add list (i; e) = <p> The bad news Unfortunately, even for simple programming languages featuring structural recursion (together with a few basic constructs such as the ability to manipulate pairs), asking whether equational conditions like associativity, left-idempotence, commutativity, etc., are true about program phrases is undecidable, in fact, not even recursively axiomatizable <ref> [8, 53] </ref>. <p> In what follows, we will perpetrate a slight abuse of notation by writing semantic proofs of semantic facts in programming syntax. (In fact, the proofs for the next lemma can all be formalized in syntax too, by using one of the logics described in <ref> [8] </ref>.) We still need one more notation: the semantic transitive closure of R is denoted by R + . Proposition 5.2 1. fg is transitive. If T is transitive then i (r; T ) is also transitive. 2. Let T be transitive.
Reference: [9] <author> V. Breazu-Tannen, P. Buneman, L. Wong, </author> <title> Naturally embedded query languages, </title> <booktitle> in "LNCS 646: Proceedings of 4th International Conference on Database Theory," </booktitle> <pages> 140-154, </pages> <address> Berlin, Germany, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: In 24 fact, by corollary 4.6, it is clear that queries such as transitive closure, equal cardinality, and parity, are not definable in A&B without a potentially costly excursion through a powerset. This observation, made in <ref> [9] </ref>, begs the question: is there an "efficient" way of programming these queries in A&B? This is a delicate question since it depends on accepting a "reasonable" notion of operational semantics for A&B. <p> Considerable effort is needed to realize this semantics in the syntax of a practical programming language. Since the inception of this work in <ref> [7, 9] </ref>, there have been two practical developments. The first is the implementation of practical languages: Shaharazade by Naqvi and his colleagues at Bellcore [50, 60]. Shahrazade has been used to model telecommunications operations support systems. <p> Also, much data is contained in special-purpose software such as sequence-matching programs, that implement external functions (point 4). 35 7.2 Further results on structural recursion and collection types Since the appearance of the papers on which this work was based <ref> [7, 9] </ref>, a substantial body of related research has appeared. Following the conservative extension result of [63], [52] shows that by adding a bounded fixed-point construct to R (=; cond) gives us, at relational types, inflationary datalog.
Reference: [10] <author> P. Buneman, L. Libkin, D. Suciu, V. Tannen, L. Wong, </author> <title> Comprehension syntax, </title> <booktitle> SIGMOD Record 23 (1994), </booktitle> <pages> 87-96. </pages>
Reference-contexts: The language CPL exploits this to obtain a query that is based on the semantics given in this paper and that manipulates the collection types lists, bags and sets together with records and variants. A description of CPL is given in <ref> [10] </ref>, from which the following example of an Employee type is taken. f [Name : [FirstName : string,LastName : string], DNum : int, Status : &lt;Regular : [Salary : int Extension : string], Consultant : [Day Rate : int, Phone : string]&gt;, Projects : f string g]g 34 In which [FirstName
Reference: [11] <author> P. Buneman, R. E. Frankel, R. Nikhil, </author> <title> An implementation technique for database query languages, </title> <journal> ACM Transactions on Database Systems 7, </journal> <volume> No. 2 (1982), </volume> <pages> 164-187. </pages>
Reference-contexts: It is interesting to note that FQL <ref> [11] </ref>, a language designed for the pragmatic purpose of communicating with functional/network databases was based roughly on the same set of functional operators. 3.3 Translations between the calculus and the algebra As we mentioned before, expressions in the calculus define functions when we consider their free variables as arguments.
Reference: [12] <author> P. Buneman, </author> <title> The Fast Fourier Transform as a Database Query. </title> <type> Technical Report MS-CIS-93-37/L&C 60, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <address> Philadelphia, PA 19104, </address> <month> March </month> <year> 1993. </year>
Reference-contexts: As mentioned before, [54] shows that transitive closure, which is efficiently expressible using structural recursion, has a necessarily exponential implementation in complex-object algebra [1]. [30] show how to encode related database languages in the simply-typed lambda-calculus. The possibility of treating arrays as collection types is suggested in <ref> [12] </ref>. Connections with parallel complexity classes are studied in [53]. [56] shows that, in the presence of suitable external functions, sr add set is strictly more expressive that sr comb set . [55] studies foundational issues concerning complex objects with queries over external functions. Acknowledgements.
Reference: [13] <author> A. Chandra, D. Harel, </author> <title> Computable queries for relational databases, </title> <journal> Journal of Computer and System Sciences 21, </journal> <volume> No. 2 (1980), </volume> <pages> 156-178. </pages>
Reference-contexts: By taking the semantic statement and the g's to be bijections, we get that all the queries definable in A&B are generic or consistent <ref> [13] </ref>. Genericity with respect to additional primitive operations can also be shown by working with bijections that are homomorphisms for these operations. These results extend to structural recursion. 7 Recent Developments and Related Work This paper is about the semantics of languages that derive from structural recursion over collection types.
Reference: [14] <author> A. Chandra, D. Harel, </author> <title> Structure and complexity of relational queries, </title> <journal> Journal of Computer and System Sciences 25 (1982), </journal> <pages> 99-128. </pages>
Reference-contexts: To overcome these limitations, there have been two general strategies. The first has been to add extra operations such as a fixpoint or while <ref> [14, 3] </ref>. The second has been to consider higher-order logics [1] or restricted algebras for higher-order (nested) relations [51, 57, 16]. <p> At the same time the nested relational algebra has severe limitations on expressiveness. Indeed, in view of corollary 4.6 and <ref> [4, 14] </ref>, there are also polynomial time operations such as transitive closure and parity that cannot be defined in R (=; cond). In this section we consider constructs that extend the expressive power of R (=; cond).
Reference: [15] <author> E. F. Codd, </author> <title> A relational model for large shared databanks, </title> <journal> Communications of the ACM 13, </journal> <volume> No. 6 (1970), </volume> <pages> 377-387. </pages>
Reference-contexts: g fi oe fi oe ! oe It should be noted [64] that the addition of the conditional is a convenience; it does not greatly affect the expressive power of R (=). 4.5 Discussion Nested relational algebras were introduced to relax the first normal form restriction originally imposed by Codd <ref> [15] </ref> and considered unacceptable in many modern applications [41, 40, 26, 29]. The earliest definition was that of Jaeschke and Schek [29] who allowed the components of tuples to be sets of atomic values. That is, nesting of relations was restricted to two levels.
Reference: [16] <author> L. S. Colby, </author> <title> A recursive algebra for nested relations, </title> <journal> Information Systems 15, </journal> <volume> No. 5 (1990), </volume> <pages> 567-582. </pages>
Reference-contexts: To overcome these limitations, there have been two general strategies. The first has been to add extra operations such as a fixpoint or while [14, 3]. The second has been to consider higher-order logics [1] or restricted algebras for higher-order (nested) relations <ref> [51, 57, 16] </ref>. <p> The language of Thomas and Fischer [57] is the most widely known of nested relational algebras. The language of Schek and Scholl [51] is an extension of Thomas and Fischer's with a recursive projection operator. The language of Colby <ref> [16] </ref> is in turn an extension of Schek and Scholl's that makes all operators recursive. It is a theorem of Colby [16] that her algebra is expressible in the algebra of Thomas and Fischer. 20 This result can be strengthened by showing that R (=) coincides in expressive power with these <p> The language of Schek and Scholl [51] is an extension of Thomas and Fischer's with a recursive projection operator. The language of Colby <ref> [16] </ref> is in turn an extension of Schek and Scholl's that makes all operators recursive. It is a theorem of Colby [16] that her algebra is expressible in the algebra of Thomas and Fischer. 20 This result can be strengthened by showing that R (=) coincides in expressive power with these three nested relational languages. <p> This constant need for restructuring was eliminated by Schek and Scholl [51] who introduced a recursive projection operator for navigation and later by Colby <ref> [16] </ref> who made all her operators recursive. Their method is ad hoc in the sense that individual definitions are required for each recursive operator. For example, the semantics given by Schek and Scholl [51] for the recursive projection operator has over 10 cases.
Reference: [17] <author> L. Fegaras, </author> <title> Efficient optimization of iterative queries, </title> <booktitle> in "Proceedings of 4th International Workshop on Database Programming Languages," </booktitle> <pages> 200-225, </pages> <address> New York, </address> <month> August </month> <year> 1993. </year>
Reference: [18] <author> L. Fegaras, D. Maier, </author> <title> Towards an effective calculus for object query languages, </title> <booktitle> in "Proceedings of ACM SIGMOD Conference on Management of Data," </booktitle> <address> San Jose, </address> <month> May </month> <year> 1995. </year> <note> To appear. </note>
Reference: [19] <author> J.A. Goguen, J.W.Thatcher, E.G. Wagner, </author> <title> An initial algebra approach to the specification, correctness and implementation of abstract data types, </title> <booktitle> in "Current Trends in Programming Methodology," </booktitle> <pages> 80-149, </pages> <publisher> Prentice Hall, </publisher> <year> 1978. </year>
Reference-contexts: Functions defined by simple recursion are homomorphisms with respect to these constructors. Structural recursion is the concept that generalizes simple recursion to any data type that can be defined by a similar algebraic universality property <ref> [19] </ref>. Consequently, we devote the next subsection (2.1) to exhibiting two groups of constructors for each of the collection types that interest us.
Reference: [20] <author> J. Goguen, J. Meseguer, </author> <title> Completeness of many-sorted equational logic, </title> <journal> Houston Journal of Mathematics 11, </journal> <volume> No. 3 (1985), </volume> <pages> 307-334. </pages>
Reference: [21] <author> M. Gyssens, D. Van Gucht, </author> <title> A comparison between algebraic query languages for flat and nested databases, </title> <booktitle> Theoretical Computer Science 87, </booktitle> <pages> 263-286, </pages> <year> 1991. </year> <month> 37 </month>
Reference-contexts: We show that the languages obtained by adding any one of these operations to R are equally expressive. These languages have polynomial time complexity. A similar but weaker result was obtained in <ref> [21] </ref> by assuming the presence of a powerset operation. We then show that R augmented with equality testing is equivalent to the well-known nested relational algebra of Thomas and Fischer [57]. By [49] it follows that our nested relational language is conservative with respect to flat relational algebra. <p> Negate the second column (we have just shown that this can be done with nest 1 ) and apply cartesian product to each tuple to obtain only those elements in difference (R; S). This completes the proof. 2 A related result was proved by Gyssens and Van Gucht <ref> [21] </ref> who showed that these non-monotonic operators are inter-definable in the language of Schek and Scholl [51] when the powerset operator was made available as an additional primitive.
Reference: [22] <author> M. Gyssens and D. Van Gucht, </author> <title> The Powerset Algebra as a natural tool to handle nested database relations, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 45, </volume> <pages> 76-103, </pages> <year> 1992 </year>
Reference-contexts: In [1], Abiteboul and Beeri introduce three languages that can all express powerset, and they show them to be equivalent: a "complex object" algebra and calculus, and an extension to datalog with certain higher-order predicates such as subset and membership. Gyssens and Van Gucht <ref> [22] </ref> show that several augmentations of the nested relational algebra with recursive and iterative constructs are equivalent to the augmentation with powerset.
Reference: [23] <author> E. Gunter and L. Libkin, OR-SML: </author> <title> A functional database programming language for disjunctive information, </title> <booktitle> in "Proceedings of Conference on Database and Expert Systems Applications," </booktitle> <address> Athens, Greece, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Other results on expressive power are to be found in [34, 36, 35]. Our approach can be used for different collections: languages for or-sets were studied in <ref> [33, 23, 38] </ref> and bag languages in [37]. As mentioned before, [54] shows that transitive closure, which is efficiently expressible using structural recursion, has a necessarily exponential implementation in complex-object algebra [1]. [30] show how to encode related database languages in the simply-typed lambda-calculus.
Reference: [24] <author> K. Hart, L. Wong, </author> <title> A query interface for heterogeneous biological data sources, </title> <type> Manuscript, </type> <month> February </month> <year> 1994. </year> <note> Available on WWW via ftp://www.cis.upenn.edu/ pub/ papers/ db-research/ kleisli.ps.Z. </note>
Reference-contexts: Few implement query languages allow function definition. We believe a functional account of database query languages is important here. At the university of Pennsylvania interfaces have been constructed between CPL/Kleislli and several biological databases that are part of the Human Genome Project <ref> [64, 25, 24] </ref>. This language has provided biological researchers with a simple language for querying and integrating a number of biological data sources, something that could not be performed by existing query languages.
Reference: [25] <author> K. Hart, L. Wong, C. Overton, P. Buneman, </author> <title> Using a query language to integrate biological data, in "Abstracts of Meeting on the Interconnection of Molecular Biology Databases," </title> <publisher> Stanford, </publisher> <month> August </month> <year> 1994. </year> <note> Available on WWW via http://www.cis.upenn.edu/ ~cbil/ mimbd94/ mimbd94CPL.html. </note>
Reference-contexts: Few implement query languages allow function definition. We believe a functional account of database query languages is important here. At the university of Pennsylvania interfaces have been constructed between CPL/Kleislli and several biological databases that are part of the Human Genome Project <ref> [64, 25, 24] </ref>. This language has provided biological researchers with a simple language for querying and integrating a number of biological data sources, something that could not be performed by existing query languages.
Reference: [26] <author> T. Imielinski, S. Naqvi, K. Vadaparty, </author> <title> Querying design and planning databases, </title> <booktitle> in "LNCS 566: Proceedings of 2nd International Conference on Deductive and Object Oriented Databases," </booktitle> <pages> 524-545, </pages> <address> Munich, Germany, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: should be noted [64] that the addition of the conditional is a convenience; it does not greatly affect the expressive power of R (=). 4.5 Discussion Nested relational algebras were introduced to relax the first normal form restriction originally imposed by Codd [15] and considered unacceptable in many modern applications <ref> [41, 40, 26, 29] </ref>. The earliest definition was that of Jaeschke and Schek [29] who allowed the components of tuples to be sets of atomic values. That is, nesting of relations was restricted to two levels.
Reference: [27] <author> N. Immerman, S. Patnaik, D. Stemple, </author> <title> The expressiveness of a family of finite set languages, </title> <booktitle> in "Proceedings of 10th ACM Symposium on Principles of Database Systems," </booktitle> <pages> 37-52, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: An awkward way of dealing with this problem is to assume non-deterministic semantics, meaning that there is a set of outcomes for programs such as DIFF. Another possibility <ref> [27] </ref> is to assume that each set carries an intrinsic ordering that dictates the order in which the iteration progresses.
Reference: [28] <author> ISO, </author> <title> Standard 9075, Information Processing Systems, Database Language SQL, </title> <year> 1987. </year>
Reference-contexts: In addition, it provides a framework with which to extend nested relational algebra to other collection types, and allows 23 us to reason about languages with external functions such as the aggregate operations of SQL <ref> [28] </ref>.
Reference: [29] <author> G. Jaeschke, H. J. Schek, </author> <title> Remarks on the algebra of non-first-normal-form relations, </title> <booktitle> in "Proceedings ACM Symposium on Principles of Database Systems," </booktitle> <pages> 124-138, </pages> <address> Los Angeles, California, </address> <month> March </month> <year> 1982. </year>
Reference-contexts: should be noted [64] that the addition of the conditional is a convenience; it does not greatly affect the expressive power of R (=). 4.5 Discussion Nested relational algebras were introduced to relax the first normal form restriction originally imposed by Codd [15] and considered unacceptable in many modern applications <ref> [41, 40, 26, 29] </ref>. The earliest definition was that of Jaeschke and Schek [29] who allowed the components of tuples to be sets of atomic values. That is, nesting of relations was restricted to two levels. <p> The earliest definition was that of Jaeschke and Schek <ref> [29] </ref> who allowed the components of tuples to be sets of atomic values. That is, nesting of relations was restricted to two levels. This restriction was relaxed by Thomas and Fischer [57] who allowed relations to be nested to arbitrary depth.
Reference: [30] <author> G. G. Hillebrand, P. C. Kanellakis, and H. G. Mairson. </author> <title> Database query languages embedded in the typed lambda calculus. </title> <booktitle> in "Proceedings of 8th IEEE Symposium on Logic in Computer Science," </booktitle> <pages> 332-343, </pages> <address> Montreal, Canada, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Our approach can be used for different collections: languages for or-sets were studied in [33, 23, 38] and bag languages in [37]. As mentioned before, [54] shows that transitive closure, which is efficiently expressible using structural recursion, has a necessarily exponential implementation in complex-object algebra [1]. <ref> [30] </ref> show how to encode related database languages in the simply-typed lambda-calculus. The possibility of treating arrays as collection types is suggested in [12].
Reference: [31] <author> J. Lambek, P. J. Scott, </author> <title> "Introduction to Higher Order Categorical Logic," </title> <publisher> Cambridge University Press, </publisher> <address> London, </address> <year> 1986. </year>
Reference: [32] <author> L. Libkin, </author> <title> "Aspects of Partial Information in Databases," </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <address> Philadelphia, PA 19104, </address> <month> August </month> <year> 1994. </year>
Reference: [33] <author> L. Libkin, L. Wong, </author> <title> Semantic representations and query languages for or-sets, </title> <booktitle> in "Proceedings of 12th ACM Symposium on Principles of Database Systems," </booktitle> <pages> 37-48, </pages> <address> Washington, D. C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Because, both flat and nested relational algebra are now seen as natural fragments of a general programming paradigm, we are in a position to extend them to other collection types, though we do not do this here; see <ref> [33, 37, 35] </ref>. In section 5 we further augment the language with a powerset operation R (=; cond), to obtain the algebra of Abiteboul and Beeri [1]. <p> Other results on expressive power are to be found in [34, 36, 35]. Our approach can be used for different collections: languages for or-sets were studied in <ref> [33, 23, 38] </ref> and bag languages in [37]. As mentioned before, [54] shows that transitive closure, which is efficiently expressible using structural recursion, has a necessarily exponential implementation in complex-object algebra [1]. [30] show how to encode related database languages in the simply-typed lambda-calculus.
Reference: [34] <author> L. Libkin, L. Wong, </author> <title> Aggregate functions, conservative extension, and linear orders, </title> <booktitle> in "Proceedings of 4th International Workshop on Database Programming Languages," </booktitle> <pages> 282-294, </pages> <address> Manhattan, New York, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: That is, we can show that the definability of a function in R (=) is independent of any restriction that can be imposed on the depth of set nesting in intermediate data <ref> [34, 35, 63] </ref>. 4.4 Conditionals An if-then-else construct is often needed in programming. Consider the function cond oe : funit g fi (oe fi oe) ! oe such that cond (B; q; r) returns q if B is nonempty and r otherwise. <p> Following the conservative extension result of [63], [52] shows that by adding a bounded fixed-point construct to R (=; cond) gives us, at relational types, inflationary datalog. In <ref> [34, 35] </ref> it is shown that nesting at intermediate types does not add expressiveness in presence of aggregate functions and certain generic queries. Other results on expressive power are to be found in [34, 36, 35]. <p> In [34, 35] it is shown that nesting at intermediate types does not add expressiveness in presence of aggregate functions and certain generic queries. Other results on expressive power are to be found in <ref> [34, 36, 35] </ref>. Our approach can be used for different collections: languages for or-sets were studied in [33, 23, 38] and bag languages in [37].
Reference: [35] <author> L. Libkin, L. Wong, </author> <title> Conservativity of nested relational calculi with internal generic functions, </title> <booktitle> Information Processing Letters 49 (1994), </booktitle> <pages> 273-280. 38 </pages>
Reference-contexts: Because, both flat and nested relational algebra are now seen as natural fragments of a general programming paradigm, we are in a position to extend them to other collection types, though we do not do this here; see <ref> [33, 37, 35] </ref>. In section 5 we further augment the language with a powerset operation R (=; cond), to obtain the algebra of Abiteboul and Beeri [1]. <p> That is, we can show that the definability of a function in R (=) is independent of any restriction that can be imposed on the depth of set nesting in intermediate data <ref> [34, 35, 63] </ref>. 4.4 Conditionals An if-then-else construct is often needed in programming. Consider the function cond oe : funit g fi (oe fi oe) ! oe such that cond (B; q; r) returns q if B is nonempty and r otherwise. <p> Following the conservative extension result of [63], [52] shows that by adding a bounded fixed-point construct to R (=; cond) gives us, at relational types, inflationary datalog. In <ref> [34, 35] </ref> it is shown that nesting at intermediate types does not add expressiveness in presence of aggregate functions and certain generic queries. Other results on expressive power are to be found in [34, 36, 35]. <p> In [34, 35] it is shown that nesting at intermediate types does not add expressiveness in presence of aggregate functions and certain generic queries. Other results on expressive power are to be found in <ref> [34, 36, 35] </ref>. Our approach can be used for different collections: languages for or-sets were studied in [33, 23, 38] and bag languages in [37].
Reference: [36] <author> L. Libkin, L. Wong, </author> <title> New techniques for studying set languages, bag languages, and aggregate functions, </title> <booktitle> in "Proceedings of 13th ACM Symposium on Principles of Database Systems," </booktitle> <pages> 155-166, </pages> <address> Minneapolis, Minnesota, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: In [34, 35] it is shown that nesting at intermediate types does not add expressiveness in presence of aggregate functions and certain generic queries. Other results on expressive power are to be found in <ref> [34, 36, 35] </ref>. Our approach can be used for different collections: languages for or-sets were studied in [33, 23, 38] and bag languages in [37].
Reference: [37] <author> L. Libkin, L. Wong, </author> <title> Some properties of query languages for bags, </title> <booktitle> in "Proceedings of 4th International Workshop on Database Programming Languages," </booktitle> <pages> 97-114, </pages> <address> Manhattan, New York, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Because, both flat and nested relational algebra are now seen as natural fragments of a general programming paradigm, we are in a position to extend them to other collection types, though we do not do this here; see <ref> [33, 37, 35] </ref>. In section 5 we further augment the language with a powerset operation R (=; cond), to obtain the algebra of Abiteboul and Beeri [1]. <p> Other results on expressive power are to be found in [34, 36, 35]. Our approach can be used for different collections: languages for or-sets were studied in [33, 23, 38] and bag languages in <ref> [37] </ref>. As mentioned before, [54] shows that transitive closure, which is efficiently expressible using structural recursion, has a necessarily exponential implementation in complex-object algebra [1]. [30] show how to encode related database languages in the simply-typed lambda-calculus. The possibility of treating arrays as collection types is suggested in [12].
Reference: [38] <author> L. Libkin, </author> <title> Approximation in databases, </title> <booktitle> in "LNCS 893: Proceedings of 5th International Conference on Database Theory," </booktitle> <pages> 411-424, </pages> <address> Prague, Czech Republic, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: Other results on expressive power are to be found in [34, 36, 35]. Our approach can be used for different collections: languages for or-sets were studied in <ref> [33, 23, 38] </ref> and bag languages in [37]. As mentioned before, [54] shows that transitive closure, which is efficiently expressible using structural recursion, has a necessarily exponential implementation in complex-object algebra [1]. [30] show how to encode related database languages in the simply-typed lambda-calculus.
Reference: [39] <author> S. MacLane, </author> <title> "Categories for the Working Mathematician," </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1971. </year>
Reference-contexts: The technical development in the paper does not require familiarity with category theory; however readers interested in understanding our motivation may wish to refer to the introductory material in texts such as such as <ref> [39] </ref> or [42]. This paper does not deal with the practical aspects of the design of syntax for query languages, but focusses on the semantics of the constructs that could be used in such a langauge. <p> Monads ext () is interesting not only because it is expressive, but also because it is an instance of a mathematically ubiquitous and hence well-studied concept, that of monad (see <ref> [39] </ref> or [42] where monads are called algebraic theories). An introduction to category theory and to monads is beyond the scope of this paper. While the main body of the paper makes several references to monads, notably in section 3, these references are mainly about terminology.
Reference: [40] <author> I. A. Macleod, </author> <title> A database management system for document retrieval applications, </title> <journal> Information Systems 6, </journal> <volume> No. </volume> <month> 2 </month> <year> (1981). </year>
Reference-contexts: should be noted [64] that the addition of the conditional is a convenience; it does not greatly affect the expressive power of R (=). 4.5 Discussion Nested relational algebras were introduced to relax the first normal form restriction originally imposed by Codd [15] and considered unacceptable in many modern applications <ref> [41, 40, 26, 29] </ref>. The earliest definition was that of Jaeschke and Schek [29] who allowed the components of tuples to be sets of atomic values. That is, nesting of relations was restricted to two levels.
Reference: [41] <author> A. Makinouchi, </author> <title> A consideration on normal form of not necessarily normalised relation in the relational data model, </title> <booktitle> in "Proceedings of 3rd International Conference on Very Large Databases," </booktitle> <pages> 447-453, </pages> <address> Tokyo, Japan, </address> <month> October </month> <year> 1977. </year>
Reference-contexts: should be noted [64] that the addition of the conditional is a convenience; it does not greatly affect the expressive power of R (=). 4.5 Discussion Nested relational algebras were introduced to relax the first normal form restriction originally imposed by Codd [15] and considered unacceptable in many modern applications <ref> [41, 40, 26, 29] </ref>. The earliest definition was that of Jaeschke and Schek [29] who allowed the components of tuples to be sets of atomic values. That is, nesting of relations was restricted to two levels.
Reference: [42] <author> E. G. Manes, </author> <title> "Algebraic Theories," </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1976. </year>
Reference-contexts: The technical development in the paper does not require familiarity with category theory; however readers interested in understanding our motivation may wish to refer to the introductory material in texts such as such as [39] or <ref> [42] </ref>. This paper does not deal with the practical aspects of the design of syntax for query languages, but focusses on the semantics of the constructs that could be used in such a langauge. We comment on some of the problems of syntax in the conclusions to this paper. <p> Monads ext () is interesting not only because it is expressive, but also because it is an instance of a mathematically ubiquitous and hence well-studied concept, that of monad (see [39] or <ref> [42] </ref> where monads are called algebraic theories). An introduction to category theory and to monads is beyond the scope of this paper. While the main body of the paper makes several references to monads, notably in section 3, these references are mainly about terminology. <p> oe 2 ! o 2 , write f 1 fi f 2 := hf 1 ffi fst; f 2 ffi sndi : oe 1 fi oe 2 ! o 1 fi o 2 : The choice of sng; map () and flatten to describe monads is only one of several <ref> [42] </ref>.
Reference: [43] <author> L. Meertens, </author> <title> Algorithmics|towards programming as a mathematical activity, </title> <booktitle> in "Proceedings of CWI Symposium on Mathematics and Computer Science," </booktitle> <pages> 289-334, </pages> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference-contexts: 5.2 contains further examples of functions definable by structural recursion. 2 In fact, if we consider only sr comb and what can be from it, then our definitions and results further generalize to binary trees (by dropping the associativity requirement) hence to all the levels of Boom's hierarchy of types <ref> [43] </ref>. 3 Using some higher-order programming [8], or some exponential computations [56], one can also define sr add in terms of sr comb. 8 Some identities Because initiality postulates unique homomorphisms and because the composition of two homomorphisms is also a homomorphism it follows immediately that if i is left-commutative then
Reference: [44] <author> A. R. Meyer, J. C. Mitchell, E. Moggi, R. Statman, </author> <title> Empty types in polymorphic - calculus, </title> <booktitle> in "Proceedings of the 14th Symposium on Principles of Programming Languages," </booktitle> <pages> 253-262. </pages> <month> January </month> <year> 1987. </year>
Reference: [45] <author> R. Milner, M. Tofte, R. Harper, </author> <title> "The Definition of Standard ML," </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference: [46] <author> E. Moggi, </author> <title> Notions of computation and monads, </title> <booktitle> Information and Computation 93(1991), </booktitle> <pages> 55-92. </pages>
Reference-contexts: In particular, we shall present a "calculus" and an equivalent "algebra" of functions for nested relations. The algebra is inspired by a well-understood categorical construction, the monad (or triple). The idea that monads could be used to organize semantics of programming constructs is due to Moggi <ref> [46] </ref>. Wadler [61] showed that they are also useful in organizing syntax, in particular they explain the "list-comprehension" syntax of functional programming. Moreover Trinder and Wadler [59] showed that an extension of comprehensions can implement the (flat) relational calculus. <p> For the calculus one can find a corresponding axiomatization, in the style of lambda calculus (appendix B, and see <ref> [46] </ref>). If we think of the equational theories as semantics, it turns out that a more profound relationship exists between the calculus and the algebra: we show in appendix B that the translations given above "preserve and reflect" these equational theories. Notation.
Reference: [47] <author> S. Naqvi, S. Tsur, </author> <title> "A Logical Language for Data and Knowledge Bases," </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference: [48] <author> A. Ohori, P. Buneman, V. Breazu-Tannen, </author> <title> Database programming in Machiavelli, a polymorphic language with static type inference, </title> <booktitle> in "Proceedings of ACM-SIGMOD International Conference on Management of Data," </booktitle> <pages> 46-57, </pages> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year>
Reference: [49] <author> J. Paredaens, D. Van Gucht, </author> <title> Converting nested relational algebra expressions into flat algebra expressions, </title> <journal> ACM Transaction on Database Systems 17, </journal> <volume> No. 1 (1992), </volume> <pages> 65-93. </pages>
Reference-contexts: These languages have polynomial time complexity. A similar but weaker result was obtained in [21] by assuming the presence of a powerset operation. We then show that R augmented with equality testing is equivalent to the well-known nested relational algebra of Thomas and Fischer [57]. By <ref> [49] </ref> it follows that our nested relational language is conservative with respect to flat relational algebra. That is, the queries with flat relations as input and flat relations as output are expressible in (flat) relational 3 algebra. <p> Proof. It is known from Paredaens and Van Gucht <ref> [49] </ref> that every function from flat relations to flat relations expressible in T homas&F ischer is also expressible in flat relational algebra.
Reference: [50] <author> Y. Saraiya, </author> <title> Optimizing functional query languages, </title> <booktitle> in "Proceedings of Conference on Information and Knowledge Management," </booktitle> <address> Washington, D. C., </address> <year> 1993. </year>
Reference-contexts: Considerable effort is needed to realize this semantics in the syntax of a practical programming language. Since the inception of this work in [7, 9], there have been two practical developments. The first is the implementation of practical languages: Shaharazade by Naqvi and his colleagues at Bellcore <ref> [50, 60] </ref>. Shahrazade has been used to model telecommunications operations support systems. One such prototype system allows planners and designers to manipulate models of Digital Loop Carrier systems with multiple choices of subcomponents, i.e., a parts explosion with functionally equivalent subparts.
Reference: [51] <author> H.-J. Schek, M. H. Scholl, </author> <title> The relational model with relation-valued attributes, </title> <journal> Information Systems 11, </journal> <volume> No. 2 (1989), </volume> <pages> 137-147. </pages>
Reference-contexts: To overcome these limitations, there have been two general strategies. The first has been to add extra operations such as a fixpoint or while [14, 3]. The second has been to consider higher-order logics [1] or restricted algebras for higher-order (nested) relations <ref> [51, 57, 16] </ref>. <p> This completes the proof. 2 A related result was proved by Gyssens and Van Gucht [21] who showed that these non-monotonic operators are inter-definable in the language of Schek and Scholl <ref> [51] </ref> when the powerset operator was made available as an additional primitive. <p> The language of Thomas and Fischer [57] is the most widely known of nested relational algebras. The language of Schek and Scholl <ref> [51] </ref> is an extension of Thomas and Fischer's with a recursive projection operator. The language of Colby [16] is in turn an extension of Schek and Scholl's that makes all operators recursive. <p> However, nest and unnest are not mutual inverses, and some care has to be taken during restructuring, as can be gauged from the full proof of Theorem 4.5 [64]. This constant need for restructuring was eliminated by Schek and Scholl <ref> [51] </ref> who introduced a recursive projection operator for navigation and later by Colby [16] who made all her operators recursive. Their method is ad hoc in the sense that individual definitions are required for each recursive operator. For example, the semantics given by Schek and Scholl [51] for the recursive projection <p> by Schek and Scholl <ref> [51] </ref> who introduced a recursive projection operator for navigation and later by Colby [16] who made all her operators recursive. Their method is ad hoc in the sense that individual definitions are required for each recursive operator. For example, the semantics given by Schek and Scholl [51] for the recursive projection operator has over 10 cases. The map () construct of R (=; cond) allows all operations to be performed at all levels of nesting; thus completely eliminating the need for restructuring through nest and unnest, as in Thomas and Fischer's algebra.
Reference: [52] <author> D. Suciu, </author> <title> Fixpoints and bounded fixpoints for complex objects, </title> <booktitle> in "Proceedings of 4th International Workshop on Database Programming Languages," </booktitle> <pages> 263-281, </pages> <address> Manhattan, New York, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Following the conservative extension result of [63], <ref> [52] </ref> shows that by adding a bounded fixed-point construct to R (=; cond) gives us, at relational types, inflationary datalog. In [34, 35] it is shown that nesting at intermediate types does not add expressiveness in presence of aggregate functions and certain generic queries.
Reference: [53] <author> D. Suciu, V. Tannen, </author> <title> A query language for NC, </title> <booktitle> in "Proceedings of 13th ACM Symposium on Principles of Database Systems," </booktitle> <pages> 167-178, </pages> <address> Minneapolis, Minnesota, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: The bad news Unfortunately, even for simple programming languages featuring structural recursion (together with a few basic constructs such as the ability to manipulate pairs), asking whether equational conditions like associativity, left-idempotence, commutativity, etc., are true about program phrases is undecidable, in fact, not even recursively axiomatizable <ref> [8, 53] </ref>. <p> The possibility of treating arrays as collection types is suggested in [12]. Connections with parallel complexity classes are studied in <ref> [53] </ref>. [56] shows that, in the presence of suitable external functions, sr add set is strictly more expressive that sr comb set . [55] studies foundational issues concerning complex objects with queries over external functions. Acknowledgements.
Reference: [54] <author> D. Suciu, J. Paredaens, </author> <title> Any algorithm in the complex object algebra with powerset needs exponential space to compute transitive closure, </title> <booktitle> in "Proceedings of 13th ACM Symposium on Principles of Database Systems," </booktitle> <pages> 201-209, </pages> <address> Minneapolis, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: This observation, made in [9], begs the question: is there an "efficient" way of programming these queries in A&B? This is a delicate question since it depends on accepting a "reasonable" notion of operational semantics for A&B. Suciu and Paredaens <ref> [54] </ref> show that if we adopt the usual, eager, evaluation strategy for queries, then any A&B expression for transitive closure must construct an intermediate result of exponential size, hence obtaining an EXPSPACE lower bound. <p> Other results on expressive power are to be found in [34, 36, 35]. Our approach can be used for different collections: languages for or-sets were studied in [33, 23, 38] and bag languages in [37]. As mentioned before, <ref> [54] </ref> shows that transitive closure, which is efficiently expressible using structural recursion, has a necessarily exponential implementation in complex-object algebra [1]. [30] show how to encode related database languages in the simply-typed lambda-calculus. The possibility of treating arrays as collection types is suggested in [12].
Reference: [55] <author> D. Suciu, </author> <title> Domain-independent queries on databases with external functions, </title> <booktitle> in "LNCS 893: Proceedings of 5th International Conference on Database Theory," </booktitle> <pages> 177-190, </pages> <address> Prague, Czech Republic, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: The possibility of treating arrays as collection types is suggested in [12]. Connections with parallel complexity classes are studied in [53]. [56] shows that, in the presence of suitable external functions, sr add set is strictly more expressive that sr comb set . <ref> [55] </ref> studies foundational issues concerning complex objects with queries over external functions. Acknowledgements. The authors thank Foto Afrati, Dirk Van Gucht, Leonid Libkin, Hermann Puhlmann, Jon Riecke, Dan Suciu, and Steve Vickers for helpful discussions and Paul Taylor for his diagram macros.
Reference: [56] <author> D. Suciu, L. Wong, </author> <title> On two forms of structural recursion, </title> <booktitle> in "LNCS 893: Proceedings of 5th International Conference on Database Theory," </booktitle> <pages> 111-124, </pages> <address> Prague, Czech Republic, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: In fact, if we consider only sr comb and what can be from it, then our definitions and results further generalize to binary trees (by dropping the associativity requirement) hence to all the levels of Boom's hierarchy of types [43]. 3 Using some higher-order programming [8], or some exponential computations <ref> [56] </ref>, one can also define sr add in terms of sr comb. 8 Some identities Because initiality postulates unique homomorphisms and because the composition of two homomorphisms is also a homomorphism it follows immediately that if i is left-commutative then sr add list (i; e) = sr add bag (i; e) <p> The possibility of treating arrays as collection types is suggested in [12]. Connections with parallel complexity classes are studied in [53]. <ref> [56] </ref> shows that, in the presence of suitable external functions, sr add set is strictly more expressive that sr comb set . [55] studies foundational issues concerning complex objects with queries over external functions. Acknowledgements.
Reference: [57] <author> S. J. Thomas, P. C. Fischer, </author> <title> Nested relational structures, </title> <booktitle> in "Advances in Computing Research: The Theory of Databases," </booktitle> <pages> 269-307, </pages> <publisher> JAI Press, </publisher> <year> 1986. </year>
Reference-contexts: To overcome these limitations, there have been two general strategies. The first has been to add extra operations such as a fixpoint or while [14, 3]. The second has been to consider higher-order logics [1] or restricted algebras for higher-order (nested) relations <ref> [51, 57, 16] </ref>. <p> These languages have polynomial time complexity. A similar but weaker result was obtained in [21] by assuming the presence of a powerset operation. We then show that R augmented with equality testing is equivalent to the well-known nested relational algebra of Thomas and Fischer <ref> [57] </ref>. By [49] it follows that our nested relational language is conservative with respect to flat relational algebra. That is, the queries with flat relations as input and flat relations as output are expressible in (flat) relational 3 algebra. <p> The language of Thomas and Fischer <ref> [57] </ref> is the most widely known of nested relational algebras. The language of Schek and Scholl [51] is an extension of Thomas and Fischer's with a recursive projection operator. The language of Colby [16] is in turn an extension of Schek and Scholl's that makes all operators recursive. <p> The earliest definition was that of Jaeschke and Schek [29] who allowed the components of tuples to be sets of atomic values. That is, nesting of relations was restricted to two levels. This restriction was relaxed by Thomas and Fischer <ref> [57] </ref> who allowed relations to be nested to arbitrary depth. Their algebraic query language consisted of the operators of flat relational algebra generalized to nested relations together with two operators for nesting and unnesting relations. However, their operators can only be applied to the outermost level of nested relations.
Reference: [58] <author> P. W. Trinder, </author> <title> Comprehensions, a query notation for DBPLs, </title> <booktitle> in "Proceedings of 3rd International Workshop on Database Programming Languages," </booktitle> <pages> 49-62, </pages> <address> Nahplion, Greece, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: Wadler [61] showed that they are also useful in organizing syntax, in particular they explain the "list-comprehension" syntax of functional programming. Moreover Trinder and Wadler [59] showed that an extension of comprehensions can implement the (flat) relational calculus. Trinder and Watt <ref> [58, 62] </ref>, have also sought after a uniform algebra for several different bulk types; in particular they have proved a number of optimizations using categorical identities. <p> We shall use R for M (fg; [). Wadler has already noted the usefulness of this extension to a monad and termed it a ringad, hence the R; see <ref> [58] </ref>. We shall also use the shorthand notations e 1 ^ / e 2 := fe 1 g [ e 2 and fe 1 ; : : : ; e n g := fe 1 g [ : : : [ fe n g. <p> Trinder <ref> [58] </ref> has already studied optimizations for languages like the ones we present in this paper. Using comprehension syntax, which is equivalent to , he identifies qualifier interchange as an identity on comprehensions that generalizes the important optimization known as selection promotion. <p> collection programming language CPL The observation that the monad operations we have used in this paper can be used to interpret the syntax of comprehensions used in functional programming languages was first made by Wadler [61], and the connection with database query languages was shown by Trinder, Wadler and Watt <ref> [58, 59, 62] </ref>. Comprehension syntax, as it is realized in CPL, superficially resembles Zermelo-Fraenkel set notation, but there are important differences.
Reference: [59] <author> P. W. Trinder, P. L. Wadler, </author> <title> List comprehensions and the relational calculus, </title> <booktitle> in "Proceedings of 1988 Glasgow Workshop on Functional Programming," </booktitle> <pages> 115-123, </pages> <address> Rothesay, Scotland, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: The idea that monads could be used to organize semantics of programming constructs is due to Moggi [46]. Wadler [61] showed that they are also useful in organizing syntax, in particular they explain the "list-comprehension" syntax of functional programming. Moreover Trinder and Wadler <ref> [59] </ref> showed that an extension of comprehensions can implement the (flat) relational calculus. Trinder and Watt [58, 62], have also sought after a uniform algebra for several different bulk types; in particular they have proved a number of optimizations using categorical identities. <p> collection programming language CPL The observation that the monad operations we have used in this paper can be used to interpret the syntax of comprehensions used in functional programming languages was first made by Wadler [61], and the connection with database query languages was shown by Trinder, Wadler and Watt <ref> [58, 59, 62] </ref>. Comprehension syntax, as it is realized in CPL, superficially resembles Zermelo-Fraenkel set notation, but there are important differences.
Reference: [60] <author> G. Venkatesh, M. Kohli, Shahrazade: </author> <title> A database query language for design and planning applications, </title> <type> Bellcore technical memorandum. </type> <institution> Bellcore, </institution> <address> Box 1910, Morristown, NJ 07960 </address>
Reference-contexts: Considerable effort is needed to realize this semantics in the syntax of a practical programming language. Since the inception of this work in [7, 9], there have been two practical developments. The first is the implementation of practical languages: Shaharazade by Naqvi and his colleagues at Bellcore <ref> [50, 60] </ref>. Shahrazade has been used to model telecommunications operations support systems. One such prototype system allows planners and designers to manipulate models of Digital Loop Carrier systems with multiple choices of subcomponents, i.e., a parts explosion with functionally equivalent subparts.
Reference: [61] <author> P. L. Wadler, </author> <title> Comprehending monads, </title> <booktitle> Mathematical Structures in Computer Science 2(1992), </booktitle> <pages> 461-493. </pages>
Reference-contexts: In particular, we shall present a "calculus" and an equivalent "algebra" of functions for nested relations. The algebra is inspired by a well-understood categorical construction, the monad (or triple). The idea that monads could be used to organize semantics of programming constructs is due to Moggi [46]. Wadler <ref> [61] </ref> showed that they are also useful in organizing syntax, in particular they explain the "list-comprehension" syntax of functional programming. Moreover Trinder and Wadler [59] showed that an extension of comprehensions can implement the (flat) relational calculus. <p> recursion on other collection types (in this paper we have focussed on sets.) 7.1 The collection programming language CPL The observation that the monad operations we have used in this paper can be used to interpret the syntax of comprehensions used in functional programming languages was first made by Wadler <ref> [61] </ref>, and the connection with database query languages was shown by Trinder, Wadler and Watt [58, 59, 62]. Comprehension syntax, as it is realized in CPL, superficially resembles Zermelo-Fraenkel set notation, but there are important differences.
Reference: [62] <author> D. A. Watt, P. W. Trinder, </author> <title> Towards a Theory of Bulk Types, </title> <type> Fide Technical Report 91/26, </type> <institution> Glasgow University, </institution> <address> Glasgow G12 8QQ, Scotland, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Wadler [61] showed that they are also useful in organizing syntax, in particular they explain the "list-comprehension" syntax of functional programming. Moreover Trinder and Wadler [59] showed that an extension of comprehensions can implement the (flat) relational calculus. Trinder and Watt <ref> [58, 62] </ref>, have also sought after a uniform algebra for several different bulk types; in particular they have proved a number of optimizations using categorical identities. <p> collection programming language CPL The observation that the monad operations we have used in this paper can be used to interpret the syntax of comprehensions used in functional programming languages was first made by Wadler [61], and the connection with database query languages was shown by Trinder, Wadler and Watt <ref> [58, 59, 62] </ref>. Comprehension syntax, as it is realized in CPL, superficially resembles Zermelo-Fraenkel set notation, but there are important differences.
Reference: [63] <author> L. Wong, </author> <title> Normal forms and conservative properties for query languages over collection types, </title> <booktitle> in "Proceedings of 12th ACM Symposium on Principles of Database Systems," </booktitle> <pages> 26-36, </pages> <address> Washington, D. C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: That is, we can show that the definability of a function in R (=) is independent of any restriction that can be imposed on the depth of set nesting in intermediate data <ref> [34, 35, 63] </ref>. 4.4 Conditionals An if-then-else construct is often needed in programming. Consider the function cond oe : funit g fi (oe fi oe) ! oe such that cond (B; q; r) returns q if B is nonempty and r otherwise. <p> (if p 0 x then (y2 S: f (x; y)g) else fg) This is a sort of normal form 6 , so we will try to reach the same by transforming equationally the other expression, namely cartprod ((select x from R where p 0 x); S). 6 In fact, Wong <ref> [63, 64] </ref> organizes these equational theories as confluent and terminating rewrite systems. 31 Expanding the syntactic sugar we get x 0 2 (x2 R: (if p 0 x then fxg else fg)): pairwith 2 (x 0 ; S) Applying axiom 8, appendix B x2 R: (x 0 2 (if p 0 <p> Following the conservative extension result of <ref> [63] </ref>, [52] shows that by adding a bounded fixed-point construct to R (=; cond) gives us, at relational types, inflationary datalog. In [34, 35] it is shown that nesting at intermediate types does not add expressiveness in presence of aggregate functions and certain generic queries.
Reference: [64] <author> L. Wong, </author> <title> "Querying Nested Collections," </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <address> Philadelphia, PA 19104, </address> <month> August </month> <year> 1994. </year> <note> 40 APPENDICES </note>
Reference-contexts: This is not difficult if one define f 0 by induction on the structure of f . The complete proof can be found in Wong <ref> [64] </ref>. We provide the case when f has the form map (g) for illustration. To define map (g) 0 : fffififoegg ! fffififo gg, assume by hypothesis that g 0 : fffifioeg ! fffifio g exists. <p> it useful to have a conditional in the calculus-style e : funit g e 1 : oe e 2 : oe if e then e 1 else e 2 : oe or in the algebra-style cond oe : funit g fi oe fi oe ! oe It should be noted <ref> [64] </ref> that the addition of the conditional is a convenience; it does not greatly affect the expressive power of R (=). 4.5 Discussion Nested relational algebras were introduced to relax the first normal form restriction originally imposed by Codd [15] and considered unacceptable in many modern applications [41, 40, 26, 29]. <p> However, nest and unnest are not mutual inverses, and some care has to be taken during restructuring, as can be gauged from the full proof of Theorem 4.5 <ref> [64] </ref>. This constant need for restructuring was eliminated by Schek and Scholl [51] who introduced a recursive projection operator for navigation and later by Colby [16] who made all her operators recursive. Their method is ad hoc in the sense that individual definitions are required for each recursive operator. <p> (if p 0 x then (y2 S: f (x; y)g) else fg) This is a sort of normal form 6 , so we will try to reach the same by transforming equationally the other expression, namely cartprod ((select x from R where p 0 x); S). 6 In fact, Wong <ref> [63, 64] </ref> organizes these equational theories as confluent and terminating rewrite systems. 31 Expanding the syntactic sugar we get x 0 2 (x2 R: (if p 0 x then fxg else fg)): pairwith 2 (x 0 ; S) Applying axiom 8, appendix B x2 R: (x 0 2 (if p 0 <p> Few implement query languages allow function definition. We believe a functional account of database query languages is important here. At the university of Pennsylvania interfaces have been constructed between CPL/Kleislli and several biological databases that are part of the Human Genome Project <ref> [64, 25, 24] </ref>. This language has provided biological researchers with a simple language for querying and integrating a number of biological data sources, something that could not be performed by existing query languages.
References-found: 64

