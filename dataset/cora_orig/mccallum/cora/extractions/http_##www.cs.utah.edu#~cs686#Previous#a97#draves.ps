URL: http://www.cs.utah.edu/~cs686/Previous/a97/draves.ps
Refering-URL: http://www.cs.utah.edu/~cs686/Previous/a97/
Root-URL: 
Title: Implementing Bit-addressing with Specialization software cache combined with a fast, optimistic sharing analysis built into
Author: Scott Draves 
Note: A  
Address: 5000 Forbes Avenue, Pittsburgh, PA 15213, USA  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: General media-processing programs are easily expressed with bit-addressing and variable-sized bit-fields. But the natural implementation of bit-addressing relies on dynamic shift offsets and repeated loads, resulting in slow execution. If the code is specialized to the alignment of the data against word boundaries, the offsets become static and many repeated loads can be removed. We show how introducing modular arithmetic into an automatic compiler generator enables the transformation of a program that uses bit-addressing into a synthesizer of fast specialized programs. In partial-evaluation jargon we say: modular arithmetic is supported by extending the binding time lattice used by the static analysis in a polyvariant compiler generator. The new binding time Cyclic functions like a partially static integer. 
Abstract-found: 1
Intro-found: 1
Reference: [ASeUl86] <author> A V Aho, R Sethi, J D Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley 1986. </publisher>
Reference-contexts: The standard approach to eliminating them is to apply common subexpression elimination (CSE) and aliasing analysis (see Chapter 10.8 of <ref> [ASeUl86] </ref>) to residual programs. Efficient handling of stores is beyond traditional techniques, however. We propose fast, optimistic sharing and static caching as an alternative. We implement the cache with a monad [Wadler92]. Uses of the load word primitive are replaced by calls to a cached load procedure load word c.
Reference: [BoDu93] <author> Anders Bondorf, Dirk Dussart. </author> <title> Handwriting Cogen for a CPS-Based Partial Evaluator. Partial Evaluation and Semantics-Based Program Manipulation, </title> <year> 1994. </year>
Reference-contexts: The binding times form a lattice because they represent partial information: it is always safe for the compiler to throw away information; this is called lifting and is the meaning of the lift annotation in the -language. <ref> [BoDu93] </ref> shows how to derive a cogen from -mix in two steps. The first step converts a specializer into a compiler generator by adding an extra level of quoting to S so static statements are copied into the compiler and dynamic ones are emitted.
Reference: [ChaUng91] <author> Craig Chambers, David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <booktitle> Conference on Programming Language Design and Implementation, </booktitle> <year> 1990. </year>
Reference-contexts: Fabius [LeLe96] uses fast automatic specialization for run-time code generation of a subset of ML, but cannot handle bit-addressing. Tempo [CoHoNoNoVo96] attempts to automate the kind of RTCG used by Synthesis. Self takes an automatic but less general approach to run-time code generation <ref> [ChaUng91] </ref>, as do recent just-in-time (JIT) implementations of Java [GoJoSte96]. Past work in bit-level processing has not emphasized implementation on word-machines. VHDL [IEEE91] allows this level of specification, but lacks an efficient compiler. Synchronous real-time languages like Signal [GuBoGaMa91] support programming with streams, but not at the bit level.
Reference: [CoHoNoNoVo96] <author> Charles Consel, Luke Hornof, Francois Noel, Jacque Noye, Nicolae Volanschi. </author> <title> A Uniform Approach for Compile-Time and Run-Time Specialization. </title> <booktitle> Dagstuhl Workshop on Partial Evaluation (LNCS1110), </booktitle> <year> 1996. </year>
Reference-contexts: On the right is another possibility. adds a Lisp-style interface to RTCG to the C programming language. Fabius [LeLe96] uses fast automatic specialization for run-time code generation of a subset of ML, but cannot handle bit-addressing. Tempo <ref> [CoHoNoNoVo96] </ref> attempts to automate the kind of RTCG used by Synthesis. Self takes an automatic but less general approach to run-time code generation [ChaUng91], as do recent just-in-time (JIT) implementations of Java [GoJoSte96]. Past work in bit-level processing has not emphasized implementation on word-machines.
Reference: [Consel93] <author> Charles Consel. </author> <title> Polyvariant Binding-Time Analysis For Applicative Languages. Partial Evaluation and Semantics-Based Program Manipulation, </title> <year> 1993. </year>
Reference-contexts: Unless we manually lift r to dynamic, S will diverge. Monovariant BTA is well-understood and can be efficiently implemented with type-inference [Henglein91]. Polyvariant BTA is usually implemented with abstract interpretation <ref> [Consel93] </ref>. [[mix]] can be defined with S like this: t 2 Type ::= atom | Type -&gt; Type d, e 2 Exp ::= Val | Var | Exp Exp | lambda Var:Type .
Reference: [DaFi92] <author> Olivier Danvy, Andrzej Filinksi. </author> <title> Representing Control, a Study of the CPS Transformation. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 361-391. </pages>
Reference: [Danvy96] <author> Olivier Danvy. </author> <title> Type-Directed Partial Evaluation. </title> <booktitle> Principles of Programming Languages, </booktitle> <year> 1996. </year>
Reference-contexts: The system described here is a polyvariant version of type-directed partial evaluation <ref> [Danvy96] </ref>, much like [Sheard96]. A specializer mix satisfies the following equation where italic names denote program texts and Quine quotes [[]] denote ordinary evaluation: [[f ]] x y = [[[[mix]] f x]] y There are many ways to implement [[mix]]; a simple curry function suffices. <p> The second step involves adding a continuation argument to S to allow propagation of a static context into the arms of a conditional with a dynamic test. One of the interesting results of <ref> [Danvy96] </ref> is how this property (the handling of sum-types) can be achieved while remaining in direct style by using the shift/reset control operators ([DaFi92] Section 5.2). Making a working implementation of a compiler generator in a call-by-value language requires handling of memoization, inlin-ing, and code duplication as well.
Reference: [Deutsch94] <author> Alain Deutsch. </author> <title> Interprocedural May-Alias analysis for pointers: Beyond k-limiting. </title> <booktitle> Conference on Programming Language Design and Implementation, </booktitle> <year> 1994. </year>
Reference-contexts: Part of the implementation appears in Appendix A. In fact, any cache strategy could be used as long as it does not depend on the values themselves. Note that safely eliminating loads in the presence of stores requires negative may-alias information (knowing that values will not be equal) <ref> [Deutsch94] </ref>. We have not yet implemented anything to guarantee this. The prime variable is the size of the cache. How many previous loads should be stored? Though this is currently left to a manual setting, automation appears feasible because requirements combine simply.
Reference: [Draves96] <author> Scott Draves. </author> <title> Compiler Generation for Interactive Graphics using Intermediate Code. </title> <booktitle> Dagstuhl Workshop on Partial Evaluation (LNCS1110), </booktitle> <year> 1996. </year>
Reference-contexts: The aliasing information becomes part of the static information given to compilers, stored in the memo tables, etc. Details appear in <ref> [Draves96] </ref>. In Nitrous the generated compilers keep track of the names of the dynamic values; the aliases? function merely tests these names for equality. Thus at compile time a cached load operation requires only a set-membership (memq) operation. <p> Otherwise a word is fetched from memory, bit-anded with the mask, bit-ored with the line contents, and written to memory. 5 Implementations We currently have two implementations of bit-addressing: Nitrous and Simple, a first-order system. Both are available from http://www.cs.cmu.edu/ spot. Nitrous <ref> [Draves96] </ref> is an automatic compiler generator for a higher-order, three-address-code intermediate language. It handles partially-static structures (product types), moves static contexts past dynamic conditionals (sum types), cyclic integers, sharing, and memoization. It uses the dynamic-conditional heuristic. <p> A number of examples were specialized, compiled to C (includ-ing GCC's indirect-goto extension), and benchmarked. At the time of <ref> [Draves96] </ref>, performance was about half that of hand-written, specialized C code; since then the performance has been significantly improved. Unfortunately Nitrous fails to terminate when given more complicated input.
Reference: [EnHsKa95] <author> Dawson Engler, Wilson Hsieh, M Frans Kaashoek. </author> <title> `C: A Language for High-Level, Efficient, and Machine-independent Dynamic Code Generation. </title> <booktitle> Conference on Programming Language Design and Implementation, </booktitle> <year> 1995. </year>
Reference-contexts: Fast manual systems such as Synthesis [Massalin92] and the Blit terminal [Pi-LoRei85] confirmed the performance benefits of RTCG in operating systems and bit-mapped graphics, respectively. `C <ref> [EnHsKa95] </ref> vertical axis. Oscillators a and b sum to modulate c as well as feeding back into a. On the right is another possibility. adds a Lisp-style interface to RTCG to the C programming language.
Reference: [Futamura71] <author> Y Futamura. </author> <title> Partial evalutaion of computation process an approach to a compiler-compiler. </title> <journal> Systems, Computers, Controls, </journal> <volume> 2 </volume> <month> 45-50. </month> <title> speed of general code normalized to specialized code. </title>
Reference-contexts: Many systems (including ours) use the dynamic-conditional heuristic, which inlines calls to procedures that do not contain a conditional with dynamic predicate. A remarkably pleasing though less practical way of implementing [[cogen]] is by self-application of a specializer [[[[mix]] mix mix]], as suggested in <ref> [Futamura71] </ref> and first implemented in [JoSeSo85]. 1 Not formally because our -language is not the ML of the example. hb q ri 2 Cyclic = ZZ fi Exp fi ZZ m 2 M = Exp + Val + Cyclic + F R hb q ri = b*q+r S e 0 +e
Reference: [GoJo91] <author> Carsten K Gomard, Neil Jones. </author> <title> A partial evaluator for the untyped lambda-calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 21-69. </pages>
Reference-contexts: Note that the if clause requires that when a conditional has dynamic predicate, then both arms are also dynamic. S is similar to the -mix of <ref> [GoJo91] </ref>, but because -mix is monovariant, it uses a two-level input language where source lambda terms have been labeled either for execution or immediate residualization. S reserves judgement until the is applied; S depends on lift annotations to emit functions. Note that many cases are missing from S .
Reference: [GoJoSte96] <author> James Gosling, Bill Joy, Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley 1996. </publisher>
Reference-contexts: Tempo [CoHoNoNoVo96] attempts to automate the kind of RTCG used by Synthesis. Self takes an automatic but less general approach to run-time code generation [ChaUng91], as do recent just-in-time (JIT) implementations of Java <ref> [GoJoSte96] </ref>. Past work in bit-level processing has not emphasized implementation on word-machines. VHDL [IEEE91] allows this level of specification, but lacks an efficient compiler. Synchronous real-time languages like Signal [GuBoGaMa91] support programming with streams, but not at the bit level.
Reference: [Granger89] <author> Philippe Granger. </author> <title> Static Analysis of Arithmetic Con-gruences. </title> <journal> International Journal of Computer Math, ?:165-199. </journal>
Reference-contexts: This paper shows how to implement bit-addressing with a partial evaluator. Section 2 presents a polyvariant, direct-style specializer and briefly describes how to derive a compiler generator from it. Section 3 extends the specializer with cyclic integers, resulting in an analysis similar to <ref> [Granger89] </ref>. Section 3.2 shows how irregular (data-dependent) layouts are handled. Section 4 shows how extending of partial evaluation allows fast elimination of redundant loads and stores.
Reference: [GuBoGaMa91] <author> P Le Guernic, M Le Borgne, T Gauthier, C Le Maire. </author> <title> Programing real time applications with SIGNAL. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9) </volume> <pages> 1305-1320. </pages>
Reference-contexts: Past work in bit-level processing has not emphasized implementation on word-machines. VHDL [IEEE91] allows this level of specification, but lacks an efficient compiler. Synchronous real-time languages like Signal <ref> [GuBoGaMa91] </ref> support programming with streams, but not at the bit level. This paper shows how to implement bit-addressing with a partial evaluator. Section 2 presents a polyvariant, direct-style specializer and briefly describes how to derive a compiler generator from it.
Reference: [Henglein91] <author> Fritz Henglein. </author> <title> Efficient Type Inference for Higher-Order Binding-Time Analysis. </title> <booktitle> International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <year> 1991. </year>
Reference-contexts: Unless we manually lift r to dynamic, S will diverge. Monovariant BTA is well-understood and can be efficiently implemented with type-inference <ref> [Henglein91] </ref>. Polyvariant BTA is usually implemented with abstract interpretation [Consel93]. [[mix]] can be defined with S like this: t 2 Type ::= atom | Type -&gt; Type d, e 2 Exp ::= Val | Var | Exp Exp | lambda Var:Type .
Reference: [HePa90] <author> John L Hennessy, David A Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann 1990. </publisher>
Reference-contexts: But if we store several words to the same location, all writes before the last write are redundant. We can implement store word c the same way a hardware write-back cache does (second edition of <ref> [HePa90] </ref> page 379): cache lines are extended with a dirty flag; stores only go to memory when a cache line is discarded. The time problem above is solved by buffering the writes. The load is unnecessary if subsequent stores eventually overwrite the entire word.
Reference: [IEEE91] <author> IEEE. </author> <title> IEEE Standard 1076: VHDL Language Reference Manual. </title> <booktitle> IEEE 1991. </booktitle>
Reference-contexts: Tempo [CoHoNoNoVo96] attempts to automate the kind of RTCG used by Synthesis. Self takes an automatic but less general approach to run-time code generation [ChaUng91], as do recent just-in-time (JIT) implementations of Java [GoJoSte96]. Past work in bit-level processing has not emphasized implementation on word-machines. VHDL <ref> [IEEE91] </ref> allows this level of specification, but lacks an efficient compiler. Synchronous real-time languages like Signal [GuBoGaMa91] support programming with streams, but not at the bit level. This paper shows how to implement bit-addressing with a partial evaluator.
Reference: [JoGoSe93] <author> Neil Jones, Carsten K Gomard, Peter Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice-Hall 1993. </publisher>
Reference: [JoSche86] <author> Ulric Jrring, William Scherlis. </author> <title> Compilers and Staging Transformations. </title> <booktitle> Principles of Programming Languages, </booktitle> <year> 1986. </year>
Reference-contexts: Because we expect to use this residual function many times, this gives us a way of `factoring' or `staging' computations as in <ref> [JoSche86] </ref>. -calculus extended with explicit types on abstractions, constants, primitives, a conditional, and a lift annotation. We say the lift is an `annotation' because in the `ordinary' semantics of the -calculus, lift has no meaning; it becomes the identity function.
Reference: [JoSeSo85] <author> Neil D Jones, P Sestoft, H Sndergaard. </author> <title> An experiment in partial evaluation: The generation of a compiler generator. Rewriting Techniques and Applications, </title> <address> Dijon, France, </address> <year> 1985. </year>
Reference-contexts: Many systems (including ours) use the dynamic-conditional heuristic, which inlines calls to procedures that do not contain a conditional with dynamic predicate. A remarkably pleasing though less practical way of implementing [[cogen]] is by self-application of a specializer [[[[mix]] mix mix]], as suggested in [Futamura71] and first implemented in <ref> [JoSeSo85] </ref>. 1 Not formally because our -language is not the ML of the example. hb q ri 2 Cyclic = ZZ fi Exp fi ZZ m 2 M = Exp + Val + Cyclic + F R hb q ri = b*q+r S e 0 +e 1 = match (S e
Reference: [LeLe96] <author> Peter Lee, Mark Leone. </author> <title> Optimizing ML with Run-Time Code Generation. </title> <booktitle> Conference on Programming Language Design and Implementation, </booktitle> <year> 1996. </year>
Reference-contexts: Oscillators a and b sum to modulate c as well as feeding back into a. On the right is another possibility. adds a Lisp-style interface to RTCG to the C programming language. Fabius <ref> [LeLe96] </ref> uses fast automatic specialization for run-time code generation of a subset of ML, but cannot handle bit-addressing. Tempo [CoHoNoNoVo96] attempts to automate the kind of RTCG used by Synthesis.
Reference: [Massalin92] <author> Henry Massalin. </author> <title> Efficient Implementation of Fundamental Operating System Services. </title> <address> Columbia 1992. </address>
Reference-contexts: Other interfaces to run-time code generation have been explored in a variety of places: there have been manual systems such as Common Lisp [Steele90] with eval, macros with back-quote/comma syntax, and slow code generation. Fast manual systems such as Synthesis <ref> [Massalin92] </ref> and the Blit terminal [Pi-LoRei85] confirmed the performance benefits of RTCG in operating systems and bit-mapped graphics, respectively. `C [EnHsKa95] vertical axis. Oscillators a and b sum to modulate c as well as feeding back into a.
Reference: [PiLoRei85] <author> Rob Pike, Bart Locanthi, John Reiser. </author> <title> Hardware/Software Trade-offs for Bitmap Graphics on the Blit. </title> <journal> Software-Practice and Experience, </journal> <volume> 15 </volume> <pages> 131-151. </pages>
Reference: [Sheard96] <author> Tim Sheard. </author> <title> A Type-directed, On-line, Partial Evaluator for a Polymorphic Language. </title> <publisher> OGI-TR-96-004. </publisher>
Reference-contexts: The system described here is a polyvariant version of type-directed partial evaluation [Danvy96], much like <ref> [Sheard96] </ref>. A specializer mix satisfies the following equation where italic names denote program texts and Quine quotes [[]] denote ordinary evaluation: [[f ]] x y = [[[[mix]] f x]] y There are many ways to implement [[mix]]; a simple curry function suffices.
Reference: [Steele90] <author> Guy Steele. </author> <title> Common Lisp the Language. </title> <publisher> Digital Press 1990. </publisher>
Reference-contexts: With RTCG, the user may define voices with their own wiring diagrams. Other interfaces to run-time code generation have been explored in a variety of places: there have been manual systems such as Common Lisp <ref> [Steele90] </ref> with eval, macros with back-quote/comma syntax, and slow code generation. Fast manual systems such as Synthesis [Massalin92] and the Blit terminal [Pi-LoRei85] confirmed the performance benefits of RTCG in operating systems and bit-mapped graphics, respectively. `C [EnHsKa95] vertical axis.
Reference: [Wadler92] <editor> Philip Wadler. </editor> <booktitle> The Essence of Functional Programming. Principles of Programming Languages, </booktitle> <year> 1992. </year>
Reference-contexts: Efficient handling of stores is beyond traditional techniques, however. We propose fast, optimistic sharing and static caching as an alternative. We implement the cache with a monad <ref> [Wadler92] </ref>. Uses of the load word primitive are replaced by calls to a cached load procedure load word c. The last several addresses and memory values are stored in a table in the monad; when load word c is called the table is checked.
Reference: [WeiCoRuSe91] <author> Daniel Weise, Roland Conybeare, Erik Ruf, Scott Seligman. </author> <title> Automatic online program specialization. </title> <booktitle> International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <year> 1991. </year>
Reference-contexts: Section 2.1 discusses efficient implementation via compiler generaton and introduces the concept of binding times. Section 2 is generally a review of partial evaluation practice; [Jo-GoSe93] is the standard text of the field and may be considered a reference of first resort if you can find it. <ref> [WeiCoRuSe91] </ref> is a more widely available description of an advanced on-line special-izer. The system described here is a polyvariant version of type-directed partial evaluation [Danvy96], much like [Sheard96].
References-found: 28

