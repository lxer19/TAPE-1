URL: ftp://ftp.cs.colorado.edu/users/alw/papers/pos6.ps.Z
Refering-URL: http://www.cs.colorado.edu/users/alw/AvailablePubs.html
Root-URL: http://www.cs.colorado.edu
Title: From Persistent Object Systems,  Semantic Synchronization in a Persistent Ob ject System Library  
Author: M.P. Atkinson, D. Maier, and V. Benzaken Andrea H. Skarra Naser S. Barghouti Alexander L. Wolf 
Address: Murray Hill, NJ 07974 USA  Boulder, CO 80309 USA  
Affiliation: Software and Systems Research Laboratory, AT&T Bell Laboratories  Department of Computer Science, University of Colorado  
Date: 1995  
Note: (eds.), Springer-Verlag, London,  
Abstract: The paper describes a synchronization scheme that exploits the semantics of collections and indexes to improve concurrency in a persistent object system library. The library implements a common execution model in which data (rather than operations or queries) are shipped between a transaction and the database at a granularity no smaller than an object. The paper describes the impact of the execution model on the extent to which semantics can be used in synchronization, and it develops several techniques that yield higher concurrency levels in this common though restrictive model. Finally, it examines the process and tradeoffs involved in designing a semantic synchronization protocol. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: It grants requests that do not conflict, it delays requests that do conflict, and it denies requests whose delay would result in deadlock. A traditional protocol uses just the two lock types Read (Share) and Write (Exclusive) with the usual conflict semantics <ref> [1, 7] </ref>. It associates every data access with one or the other of the locks automatically, regardless of the kind of data or the context.
Reference: [2] <author> W. Du and A. K. Elmagarmid. </author> <title> Quasi Serializability: a Correctness Criterion for Global Concurrency Control in Interbase. </title> <booktitle> In Proceedings of 15th International Conference on Very Large Data Bases, </booktitle> <year> 1989. </year>
Reference-contexts: Three main approaches have been proposed to improve concurrency: (1) extended transaction models [6, 10, 17, 19], (2) new correctness criteria <ref> [2, 5, 26, 28] </ref>, and (3) semantics-based concurrency control schemes [9, 20, 22, 24, 30]. Our scheme follows the third approach. Schemes that follow the third approach maintain the atomicity of transactions, but use application semantics to allow more concurrency than traditional Read/Write serializability.
Reference: [3] <author> D. J. Ecklund, E. F. Ecklund, R. O. Eifrig, and F. M. Tonge. DVSS: </author> <title> A Distributed Version Storage Server for CAD Applications. </title> <booktitle> In Proceedings of 13th International Conference on Very Large Data Bases, </booktitle> <year> 1987. </year>
Reference-contexts: These versions can either co-exist indefinitely or can be merged into a single consistent version, if needed. In that respect, they are similar to data sharing models based on read-only versions <ref> [3, 11, 12] </ref>. Versioning schemes, however, fail to provide correctness criteria for concurrent access. Moreover, unrestrained proliferation of versions requires complex, human intervention to reconcile coexistent, parallel versions. Finally, the schemes that enforce linear version histories commonly place the burden of reconciliation on the later-committing transactions.
Reference: [4] <editor> O. Deux et al. </editor> <title> The O 2 System. </title> <journal> Communications of the ACM, </journal> <volume> 34(10), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: Moreover, the unit of data transfer between a transaction and the database is at least the size of an object; a transaction does not read or write individual attributes alone. The commercial object-oriented DBMSs <ref> [4, 15, 21, 23, 27] </ref> support the same model, and henceforth we call it the OO execution model. In contrast, the currently proposed models of semantic concurrency control (cf. <p> Unlike our scheme, however, most of the semantics-based schemes assume either finely-grained data access or encapsulated shared memory. The execution model we assume is similar to those of most commercial OODBMSs, including O 2 <ref> [4] </ref>, ObjectStore [15], Objectivity/DB [21], ON-TOS [23], and Versant [27]. In these OODBMSs, as in Persi, objects are cached in the client process memory, and the client is responsible for computations on these objects.
Reference: [5] <author> H. Garcia-Molina. </author> <title> Using Semantic Knowledge for Transaction Processing in a Distributed Database. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 8(2), </volume> <month> June </month> <year> 1983. </year>
Reference-contexts: Alternatively, the DBMS may support semantic protocols with an extensible synchronization algorithm, namely one whose behavior is modified by semantic specifications that it takes as input from the database administrator. The form of the specification is typically a compatibility matrix over a set of transaction types <ref> [5, 17] </ref> or a set of synchronization primitives such as events, semantic lock types, or abstract type operations [9, 13, 29]. <p> Three main approaches have been proposed to improve concurrency: (1) extended transaction models [6, 10, 17, 19], (2) new correctness criteria <ref> [2, 5, 26, 28] </ref>, and (3) semantics-based concurrency control schemes [9, 20, 22, 24, 30]. Our scheme follows the third approach. Schemes that follow the third approach maintain the atomicity of transactions, but use application semantics to allow more concurrency than traditional Read/Write serializability.
Reference: [6] <author> H. Garcia-Molina and K. Salem. SAGAS. </author> <booktitle> In Proceedings of ACM SIGMOD Annual Conference, </booktitle> <year> 1987. </year>
Reference-contexts: Three main approaches have been proposed to improve concurrency: (1) extended transaction models <ref> [6, 10, 17, 19] </ref>, (2) new correctness criteria [2, 5, 26, 28], and (3) semantics-based concurrency control schemes [9, 20, 22, 24, 30]. Our scheme follows the third approach.
Reference: [7] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: It grants requests that do not conflict, it delays requests that do conflict, and it denies requests whose delay would result in deadlock. A traditional protocol uses just the two lock types Read (Share) and Write (Exclusive) with the usual conflict semantics <ref> [1, 7] </ref>. It associates every data access with one or the other of the locks automatically, regardless of the kind of data or the context.
Reference: [8] <author> J. N. Gray, R. A. Lorie, G. R. Putzolu, and I. L. Traiger. </author> <title> Granularity of Locks and Degrees of Consistency in a Shared Data Base. </title> <type> Technical Report RJ 1654, </type> <institution> IBM Research Laboratory, </institution> <month> September </month> <year> 1975. </year>
Reference-contexts: A semantic protocol and its lock types may be "hardwired" into the DBMS synchronization algorithm. For example, the multigranularity locking protocol 130 employs a fixed set of five lock types that capture the access semantics of physically nested objects such as records within files <ref> [8] </ref>. A DBMS that supports the protocol may implement just those lock types and no others. Alternatively, the DBMS may support semantic protocols with an extensible synchronization algorithm, namely one whose behavior is modified by semantic specifications that it takes as input from the database administrator.
Reference: [9] <author> M. P. Herlihy and W. E. Weihl. </author> <title> Hybrid Concurrency Control for Abstract Data Types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43 </volume> <pages> 25-61, </pages> <year> 1991. </year> <month> 145 </month>
Reference-contexts: The form of the specification is typically a compatibility matrix over a set of transaction types [5, 17] or a set of synchronization primitives such as events, semantic lock types, or abstract type operations <ref> [9, 13, 29] </ref>. The synchronization algorithm uses the specifications to decide conflict among concurrent transactions in much the same way that a traditional algorithm uses the conflict relation over Read and Write locks. The correctness criterion in semantic protocols that corresponds to serializ-ability is semantic serializability. <p> Three main approaches have been proposed to improve concurrency: (1) extended transaction models [6, 10, 17, 19], (2) new correctness criteria [2, 5, 26, 28], and (3) semantics-based concurrency control schemes <ref> [9, 20, 22, 24, 30] </ref>. Our scheme follows the third approach. Schemes that follow the third approach maintain the atomicity of transactions, but use application semantics to allow more concurrency than traditional Read/Write serializability. <p> The semantic information used is either information about transactions, such as the access pattern of a transaction (e.g., [24]), or information about operations, such as whether or not two operations commute (e.g., <ref> [9] </ref>). Some models exploit commutativity of operations at multiple levels of abstraction (e.g., [20, 30]). The semantic information is used to allow executions that would be disallowed under traditional Read/Write serializabil-ity. Unlike our scheme, however, most of the semantics-based schemes assume either finely-grained data access or encapsulated shared memory.
Reference: [10] <author> G. E. Kaiser and C. Pu. </author> <title> Dynamic Restructuring of Transactions. </title> <editor> In A. K. Elmagarmid, editor, </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference-contexts: Three main approaches have been proposed to improve concurrency: (1) extended transaction models <ref> [6, 10, 17, 19] </ref>, (2) new correctness criteria [2, 5, 26, 28], and (3) semantics-based concurrency control schemes [9, 20, 22, 24, 30]. Our scheme follows the third approach.
Reference: [11] <author> R. H. Katz and E. Chang. </author> <title> Managing Change in a Computer-Aided Design Database. </title> <booktitle> In Proceedings of 13th International Conference on Very Large Data Bases, </booktitle> <year> 1987. </year>
Reference-contexts: These versions can either co-exist indefinitely or can be merged into a single consistent version, if needed. In that respect, they are similar to data sharing models based on read-only versions <ref> [3, 11, 12] </ref>. Versioning schemes, however, fail to provide correctness criteria for concurrent access. Moreover, unrestrained proliferation of versions requires complex, human intervention to reconcile coexistent, parallel versions. Finally, the schemes that enforce linear version histories commonly place the burden of reconciliation on the later-committing transactions.
Reference: [12] <author> R. H. Katz and S. Weiss. </author> <title> Design Transaction Management. </title> <booktitle> In Proceedings of 21st ACM/IEEE Design Automation Conference, </booktitle> <year> 1984. </year>
Reference-contexts: These versions can either co-exist indefinitely or can be merged into a single consistent version, if needed. In that respect, they are similar to data sharing models based on read-only versions <ref> [3, 11, 12] </ref>. Versioning schemes, however, fail to provide correctness criteria for concurrent access. Moreover, unrestrained proliferation of versions requires complex, human intervention to reconcile coexistent, parallel versions. Finally, the schemes that enforce linear version histories commonly place the burden of reconciliation on the later-committing transactions.
Reference: [13] <author> H. F. Korth. </author> <title> Locking Primitives in a Database System. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 30(1), </volume> <month> January </month> <year> 1983. </year>
Reference-contexts: The form of the specification is typically a compatibility matrix over a set of transaction types [5, 17] or a set of synchronization primitives such as events, semantic lock types, or abstract type operations <ref> [9, 13, 29] </ref>. The synchronization algorithm uses the specifications to decide conflict among concurrent transactions in much the same way that a traditional algorithm uses the conflict relation over Read and Write locks. The correctness criterion in semantic protocols that corresponds to serializ-ability is semantic serializability. <p> The protocol extends prior use of Update locks on flat objects <ref> [13] </ref> to its use on collections. The conflict table is symmetric, however, because we implement the lock types with standard Read and Write locks (cf. Section 5.5). When Persi fetches a collection or a data object o from disk, it obtains a Read lock on o for the transaction.
Reference: [14] <author> H. T. Kung and C. H. Papadimitriou. </author> <title> An Optimality Theory of Concur-rency Control for Databases. </title> <booktitle> In Proceedings of ACM SIGMOD Annual Conference, </booktitle> <year> 1979. </year>
Reference-contexts: If a DBMS instead uses a synchronization protocol that exploits the semantics of the data and the application, however, the number of transactions that can execute concurrently increases <ref> [14] </ref>. A semantic protocol and its lock types may be "hardwired" into the DBMS synchronization algorithm. For example, the multigranularity locking protocol 130 employs a fixed set of five lock types that capture the access semantics of physically nested objects such as records within files [8].
Reference: [15] <author> C. Lamb, C. Landis, J. Orenstein, and D. Weinreb. </author> <title> The ObjectStore Database System. </title> <journal> Communications of the ACM, </journal> <volume> 34(10), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: Moreover, the unit of data transfer between a transaction and the database is at least the size of an object; a transaction does not read or write individual attributes alone. The commercial object-oriented DBMSs <ref> [4, 15, 21, 23, 27] </ref> support the same model, and henceforth we call it the OO execution model. In contrast, the currently proposed models of semantic concurrency control (cf. <p> Unlike our scheme, however, most of the semantics-based schemes assume either finely-grained data access or encapsulated shared memory. The execution model we assume is similar to those of most commercial OODBMSs, including O 2 [4], ObjectStore <ref> [15] </ref>, Objectivity/DB [21], ON-TOS [23], and Versant [27]. In these OODBMSs, as in Persi, objects are cached in the client process memory, and the client is responsible for computations on these objects.
Reference: [16] <author> D. B. Lomet. </author> <title> Key Range Locking Strategies for Improved Concurrency. </title> <booktitle> In Proceedings of 19th International Conference on Very Large Data Bases, </booktitle> <year> 1993. </year>
Reference-contexts: In particular, transactions that access different sets of objects are free to use the index concurrently; a transaction can commit its changes even before another terminates. Our solution is similar to key range locking <ref> [16] </ref>, a mechanism developed independently at approximately the same time. For brevity, we refer the reader to [25] for a more complete description of the locking algorithm. 5.5 OS Services Persi uses the OS as a storage manager (i.e., SunOS or UNIX System V together with NFS 5 ).
Reference: [17] <author> N. A. Lynch. </author> <title> Multilevel Atomicity|A new Correctness Criterion for Database Concurrency Control. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 8(4), </volume> <month> December </month> <year> 1983. </year>
Reference-contexts: Alternatively, the DBMS may support semantic protocols with an extensible synchronization algorithm, namely one whose behavior is modified by semantic specifications that it takes as input from the database administrator. The form of the specification is typically a compatibility matrix over a set of transaction types <ref> [5, 17] </ref> or a set of synchronization primitives such as events, semantic lock types, or abstract type operations [9, 13, 29]. <p> Three main approaches have been proposed to improve concurrency: (1) extended transaction models <ref> [6, 10, 17, 19] </ref>, (2) new correctness criteria [2, 5, 26, 28], and (3) semantics-based concurrency control schemes [9, 20, 22, 24, 30]. Our scheme follows the third approach.
Reference: [18] <author> C. Mohan and F. Levine. ARIES/IM: </author> <title> An Efficient and High Concurrency Index Management Method Using Write-Ahead Logging. </title> <booktitle> In Proceedings of ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1992. </year>
Reference-contexts: At commit, Persi upgrades any Update locks to Write locks, and it saves all Write-locked objects to disk. 5.4 Indexes Persi synchronizes access to an index by means of locks on the objects that the index references, rather than locks on the index itself. The scheme derives from Aries/IM <ref> [18] </ref>. For each key-value kv for which an index i has at least one entry, there is some nonempty set of objects in the associated collection, whose attributes have the values in kv.
Reference: [19] <author> J. E. B. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: Three main approaches have been proposed to improve concurrency: (1) extended transaction models <ref> [6, 10, 17, 19] </ref>, (2) new correctness criteria [2, 5, 26, 28], and (3) semantics-based concurrency control schemes [9, 20, 22, 24, 30]. Our scheme follows the third approach.
Reference: [20] <author> J. E. B. Moss, N. D. Griffeth, and Marc H. Graham. </author> <title> Abstraction in Recovery Management. </title> <booktitle> In Proceedings of ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1986. </year>
Reference-contexts: Three main approaches have been proposed to improve concurrency: (1) extended transaction models [6, 10, 17, 19], (2) new correctness criteria [2, 5, 26, 28], and (3) semantics-based concurrency control schemes <ref> [9, 20, 22, 24, 30] </ref>. Our scheme follows the third approach. Schemes that follow the third approach maintain the atomicity of transactions, but use application semantics to allow more concurrency than traditional Read/Write serializability. <p> The semantic information used is either information about transactions, such as the access pattern of a transaction (e.g., [24]), or information about operations, such as whether or not two operations commute (e.g., [9]). Some models exploit commutativity of operations at multiple levels of abstraction (e.g., <ref> [20, 30] </ref>). The semantic information is used to allow executions that would be disallowed under traditional Read/Write serializabil-ity. Unlike our scheme, however, most of the semantics-based schemes assume either finely-grained data access or encapsulated shared memory.
Reference: [21] <institution> Objectivity, Inc., </institution> <address> Menlo Park, CA. </address> <note> Objectivity Database Reference Manual, </note> <year> 1990. </year>
Reference-contexts: Moreover, the unit of data transfer between a transaction and the database is at least the size of an object; a transaction does not read or write individual attributes alone. The commercial object-oriented DBMSs <ref> [4, 15, 21, 23, 27] </ref> support the same model, and henceforth we call it the OO execution model. In contrast, the currently proposed models of semantic concurrency control (cf. <p> Unlike our scheme, however, most of the semantics-based schemes assume either finely-grained data access or encapsulated shared memory. The execution model we assume is similar to those of most commercial OODBMSs, including O 2 [4], ObjectStore [15], Objectivity/DB <ref> [21] </ref>, ON-TOS [23], and Versant [27]. In these OODBMSs, as in Persi, objects are cached in the client process memory, and the client is responsible for computations on these objects.
Reference: [22] <author> P. E. O'Neil. </author> <title> The Escrow Transactional Method. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 11(4), </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: Three main approaches have been proposed to improve concurrency: (1) extended transaction models [6, 10, 17, 19], (2) new correctness criteria [2, 5, 26, 28], and (3) semantics-based concurrency control schemes <ref> [9, 20, 22, 24, 30] </ref>. Our scheme follows the third approach. Schemes that follow the third approach maintain the atomicity of transactions, but use application semantics to allow more concurrency than traditional Read/Write serializability.
Reference: [23] <editor> Ontologic, </editor> <publisher> Inc., </publisher> <address> Billerica, MA. </address> <note> ONTOS Reference Manual, </note> <year> 1989. </year>
Reference-contexts: Moreover, the unit of data transfer between a transaction and the database is at least the size of an object; a transaction does not read or write individual attributes alone. The commercial object-oriented DBMSs <ref> [4, 15, 21, 23, 27] </ref> support the same model, and henceforth we call it the OO execution model. In contrast, the currently proposed models of semantic concurrency control (cf. <p> Unlike our scheme, however, most of the semantics-based schemes assume either finely-grained data access or encapsulated shared memory. The execution model we assume is similar to those of most commercial OODBMSs, including O 2 [4], ObjectStore [15], Objectivity/DB [21], ON-TOS <ref> [23] </ref>, and Versant [27]. In these OODBMSs, as in Persi, objects are cached in the client process memory, and the client is responsible for computations on these objects.
Reference: [24] <author> K. Salem and H. Garcia-Molina. </author> <title> Altruistic Locking. </title> <type> Technical Report UMIACS-TR-90-104 CS-TR-2512, </type> <institution> Institute for Advanced Computer Studies, Department of Computer Science, University of Maryland, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Three main approaches have been proposed to improve concurrency: (1) extended transaction models [6, 10, 17, 19], (2) new correctness criteria [2, 5, 26, 28], and (3) semantics-based concurrency control schemes <ref> [9, 20, 22, 24, 30] </ref>. Our scheme follows the third approach. Schemes that follow the third approach maintain the atomicity of transactions, but use application semantics to allow more concurrency than traditional Read/Write serializability. <p> Our scheme follows the third approach. Schemes that follow the third approach maintain the atomicity of transactions, but use application semantics to allow more concurrency than traditional Read/Write serializability. The semantic information used is either information about transactions, such as the access pattern of a transaction (e.g., <ref> [24] </ref>), or information about operations, such as whether or not two operations commute (e.g., [9]). Some models exploit commutativity of operations at multiple levels of abstraction (e.g., [20, 30]). The semantic information is used to allow executions that would be disallowed under traditional Read/Write serializabil-ity.
Reference: [25] <author> A. H. Skarra. SLEVE: </author> <title> Semantic Locking for EVEnt synchronization. </title> <booktitle> In Proceedings of Ninth International Conference on Data Engineering. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year> <note> An expanded version is Technical Memorandum 59113-920303-03TM, </note> <institution> AT&T Bell Laboratories, </institution> <month> March, </month> <year> 1992. </year> <month> 146 </month>
Reference-contexts: Our solution is similar to key range locking [16], a mechanism developed independently at approximately the same time. For brevity, we refer the reader to <ref> [25] </ref> for a more complete description of the locking algorithm. 5.5 OS Services Persi uses the OS as a storage manager (i.e., SunOS or UNIX System V together with NFS 5 ). <p> The semantic locks in the synchronization scheme are implemented as functions that request Read or Write locks from the OS in a way that simulates the concurrency behavior defined by the scheme. A tool SLEVE <ref> [25] </ref> generates the functions automatically from concurrency specifications in the form of conflict tables. 6 Example Consider an instance, Hondas, of the data type Collection of Autos that was defined in Section 1. The Hondas object groups instances of the class Auto whose make is Honda.
Reference: [26] <author> D. Stemple and R. Morrison. </author> <title> Specifying Flexible Concurrency Control Schemes: An Abstract Operational Approach. </title> <booktitle> In Proceedings of 15th Aus-tralian Computer Science Conference, </booktitle> <year> 1992. </year>
Reference-contexts: Three main approaches have been proposed to improve concurrency: (1) extended transaction models [6, 10, 17, 19], (2) new correctness criteria <ref> [2, 5, 26, 28] </ref>, and (3) semantics-based concurrency control schemes [9, 20, 22, 24, 30]. Our scheme follows the third approach. Schemes that follow the third approach maintain the atomicity of transactions, but use application semantics to allow more concurrency than traditional Read/Write serializability.
Reference: [27] <institution> Versant Object Technology, </institution> <address> Menlo Park, CA. </address> <month> VERSANT ODBMS: </month> <title> A Technical Overview for Software Developers, </title> <year> 1992. </year>
Reference-contexts: Moreover, the unit of data transfer between a transaction and the database is at least the size of an object; a transaction does not read or write individual attributes alone. The commercial object-oriented DBMSs <ref> [4, 15, 21, 23, 27] </ref> support the same model, and henceforth we call it the OO execution model. In contrast, the currently proposed models of semantic concurrency control (cf. <p> Unlike our scheme, however, most of the semantics-based schemes assume either finely-grained data access or encapsulated shared memory. The execution model we assume is similar to those of most commercial OODBMSs, including O 2 [4], ObjectStore [15], Objectivity/DB [21], ON-TOS [23], and Versant <ref> [27] </ref>. In these OODBMSs, as in Persi, objects are cached in the client process memory, and the client is responsible for computations on these objects.
Reference: [28] <author> H. Wachter and A. Reuter. </author> <title> The ConTract Model. </title> <editor> In A. K. Elmagarmid, editor, </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference-contexts: Three main approaches have been proposed to improve concurrency: (1) extended transaction models [6, 10, 17, 19], (2) new correctness criteria <ref> [2, 5, 26, 28] </ref>, and (3) semantics-based concurrency control schemes [9, 20, 22, 24, 30]. Our scheme follows the third approach. Schemes that follow the third approach maintain the atomicity of transactions, but use application semantics to allow more concurrency than traditional Read/Write serializability.
Reference: [29] <author> W. E. Weihl. </author> <title> Commutativity-Based Concurrency Control for Abstract Data Types. </title> <booktitle> In IEEE Proceedings of 21st Annual Hawaii International Conference on System Sciences, </booktitle> <year> 1988. </year>
Reference-contexts: The form of the specification is typically a compatibility matrix over a set of transaction types [5, 17] or a set of synchronization primitives such as events, semantic lock types, or abstract type operations <ref> [9, 13, 29] </ref>. The synchronization algorithm uses the specifications to decide conflict among concurrent transactions in much the same way that a traditional algorithm uses the conflict relation over Read and Write locks. The correctness criterion in semantic protocols that corresponds to serializ-ability is semantic serializability.
Reference: [30] <author> G. Weikum and H.-J. Schek. </author> <title> Concepts and Applications of Multilevel Transactions and Open Nested Transactions. </title> <editor> In A. K. Elmagarmid, editor, </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan Kauf-mann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference-contexts: Three main approaches have been proposed to improve concurrency: (1) extended transaction models [6, 10, 17, 19], (2) new correctness criteria [2, 5, 26, 28], and (3) semantics-based concurrency control schemes <ref> [9, 20, 22, 24, 30] </ref>. Our scheme follows the third approach. Schemes that follow the third approach maintain the atomicity of transactions, but use application semantics to allow more concurrency than traditional Read/Write serializability. <p> The semantic information used is either information about transactions, such as the access pattern of a transaction (e.g., [24]), or information about operations, such as whether or not two operations commute (e.g., [9]). Some models exploit commutativity of operations at multiple levels of abstraction (e.g., <ref> [20, 30] </ref>). The semantic information is used to allow executions that would be disallowed under traditional Read/Write serializabil-ity. Unlike our scheme, however, most of the semantics-based schemes assume either finely-grained data access or encapsulated shared memory.
Reference: [31] <author> A. L. Wolf. </author> <title> An Initial Look at Abstraction Mechanisms and Persistence. </title> <editor> In A. Dearle, G. M. Shaw, and S. B. Zdonik, editors, </editor> <title> Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice. The Fourth International Workshop on Persistent Object Systems. </booktitle> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1991. </year>
Reference-contexts: List () returns a sorted list that hides the insertion order. We designed and implemented a synchronization protocol that guarantees semantic serializability in Persi <ref> [31] </ref>, a persistent object system library that supports a transaction execution model commonly used in object-oriented database systems (OODBMSs). The objective of the protocol is to maintain consistency across the database while maximizing concurrency among transactions, whether they navigate to objects or use associative retrieval.
Reference: [32] <author> A. L. Wolf. </author> <title> The Persi Persistent Object System Library. Available from the author, </title> <month> June </month> <year> 1993. </year>
Reference-contexts: Below, we briefly describe the features of Persi required to understand the work presented in this paper. We do this by detailing the class developer interface to Persi's features for persistence, collections, and automatic index maintenance. A more complete description of Persi can be found in <ref> [32] </ref>. 4.1 Persistent Objects A persistent object is an instance of a class that is a subclass of the Persi class Object. 2 Class Object serves to define the operations used in a special, hidden protocol between Persi and persistent objects.
References-found: 32

