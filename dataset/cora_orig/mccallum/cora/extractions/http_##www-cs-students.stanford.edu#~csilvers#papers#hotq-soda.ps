URL: http://www-cs-students.stanford.edu/~csilvers/papers/hotq-soda.ps
Refering-URL: http://www-cs-students.stanford.edu/~csilvers/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: cher@cemi.msk.su  avg@research.nj.nec.com  csilvers@theory.stanford.edu  
Title: Buckets, Heaps, Lists, and Monotone Priority Queues  
Author: Boris V. Cherkassky Andrew V. Goldberg Craig Silverstein 
Date: 3  
Note: 1  
Address: Krasikova St. 32 117418, Moscow, Russia  4 Independence Way Princeton, NJ 08540  Stanford, CA 94305  
Affiliation: Central Econ. and Math. Inst.  NEC Research Institute  Computer Science Department Stanford University  
Abstract: We introduce the heap-on-top (hot) priority queue data structure that combines the multi-level bucket data structure of Denardo and Fox and a heap. We use the new data structure to obtain an O(m + n(log C) expected time implementation of Dijkstra's shortest path algorithm, improving the previous bounds. We can implement hot queues even more efficiently in practice by using sorted lists to represent small priority queues. Our experimental results in the context of Dijkstra's algorithm show that this implementation of hot queues performs very well and is more robust than implementations based only on heap or multi-level bucket data structures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: We call a sequence of operations on a priority queue balanced if the sequence starts and ends with an empty queue. In particular, implementations of Dijkstra's shortest path algorithm produce balanced operation sequences. In this paper we use the RAM model of computation <ref> [1] </ref>. The only nonobvious result about the model we use appears in [9], where it is attributed to B. Schieber.
Reference: [2] <author> R. K. Ahuja, K. Mehlhorn, J. B. Orlin, and R. E. Tar-jan. </author> <title> Faster Algorithms for the Shortest Path Problem. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 37(2) </volume> <pages> 213-223, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in [4, 14, 19]. Alternative implementations of priority queues use buckets (e.g. <ref> [2, 7, 11, 12] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [3] for a related data structure. Heaps are particularly efficient when the number of elements on the heap is small. <p> We also give an alternative and more insightful description of the multi-level bucket data structure. (Concurrently and independently, a similar description has been given by Raman [17].) Hot queues are related to radix heaps (RH) 1 of Ahuja et al. <ref> [2] </ref>. An RH is similar to the multi-level buckets, but uses a heap to find nonempty buckets. To get the best bounds, the heap operation time in an RH should depend on the number of distinct keys on the heap. The most complicated part of [2] is modifying Fibonacci heaps [14] <p> 1 of Ahuja et al. <ref> [2] </ref>. An RH is similar to the multi-level buckets, but uses a heap to find nonempty buckets. To get the best bounds, the heap operation time in an RH should depend on the number of distinct keys on the heap. The most complicated part of [2] is modifying Fibonacci heaps [14] to meet this requirement. In contrast, the hot queue bounds do not require anything special from the heap. We can use Fibonacci heaps with no modifications and achieve the same bounds as RH. Using the heap of Thorup [19], we obtain even better bounds. <p> On a network with N vertices, m arcs, and integral lengths in the range [0; C], the shortest path problem can be solved in O (m + n (log C) 1 3 +* ) expected time. This improves the deterministic bound of O (m + n log C) of <ref> [2] </ref>. (The hot queue implementation based on Fibonacci heaps matches this deterministic bound.) 5 Implementation Details Our previous papers [7, 15] describe implementations of multi-level buckets. Our implementation of hot queues augments the multi-level bucket implementation of [15]. See [15] for details of the multi-level bucket implementation.
Reference: [3] <author> P. Van Emde Boas, R. Kaas, and E. Zijlstra. </author> <title> Design and Implementation of an Efficient Priority Queue. </title> <journal> Math. Systems Theory, </journal> <volume> 10 </volume> <pages> 99-127, </pages> <year> 1977. </year>
Reference-contexts: The fastest implementations of heaps are described in [4, 14, 19]. Alternative implementations of priority queues use buckets (e.g. [2, 7, 11, 12]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See <ref> [3] </ref> for a related data structure. Heaps are particularly efficient when the number of elements on the heap is small. Bucket-based priority queues are particularly efficient when the maximum event duration C is small.
Reference: [4] <author> G. S. Brodal. </author> <title> Worst-Case Efficient Priority Queues. </title> <booktitle> In Proc. 7th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 52-58, </pages> <year> 1996. </year>
Reference-contexts: In this paper we deal with monotone priority queues. Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in <ref> [4, 14, 19] </ref>. Alternative implementations of priority queues use buckets (e.g. [2, 7, 11, 12]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [3] for a related data structure.
Reference: [5] <author> R. Brown. </author> <title> Calandar Queues: A Fast O(1) Priority Queue Implementation for the Simulation Event Set Problem. </title> <journal> Comm. ACM, </journal> <volume> 31 </volume> <pages> 1220-1227, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction A priority queue is a data structure that maintains a set of elements and supports operations insert, decrease-key, and extract-min. Priority queues are fundamental data structures with many applications. Typical applications include graph algorithms (e.g. [14]) and event simulation (e.g. <ref> [5] </ref>).
Reference: [6] <author> B. V. Cherkassky and A. V. Goldberg. </author> <title> Heap-on-Top Priority Queues. </title> <type> Technical Report 96-042, </type> <institution> NEC Research Institute, Princeton, NJ, </institution> <year> 1996. </year> <note> Available via URL http://www.neci.nj.nec.com/homepages/avg/pub/neci-tr-96-042.ps. </note>
Reference-contexts: Since Thorup's bounds depend on the total number of elements on the heap, RH cannot take immediate advantage of this data structure. We believe that data structures are especially interesting if they work well both in theory and in practice. A preliminary version of the hot queue data structure <ref> [6] </ref> did not perform well in practice. Based on experimental feedback, we modified the data structure to be more practical. We also developed techniques that make hot queues more efficient in practice.
Reference: [7] <author> B. V. Cherkassky, A. V. Goldberg, and T. Radzik. </author> <title> Shortest Paths Algorithms: Theory and Experimental Evaluation. </title> <journal> Math. Prog., </journal> <volume> 73 </volume> <pages> 129-174, </pages> <year> 1996. </year>
Reference-contexts: Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in [4, 14, 19]. Alternative implementations of priority queues use buckets (e.g. <ref> [2, 7, 11, 12] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [3] for a related data structure. Heaps are particularly efficient when the number of elements on the heap is small. <p> Our experimental results show that hot queues perform best overall and are more robust than either of the other two data structures. This is especially significant because a multi-level bucket implementation of Dijkstra's algorithm compared favorably with other implementations of the algorithm in a previous study <ref> [7] </ref> and was shown to be very robust. For many problem classes, the hot queue implementation of Dijkstra's algorithm is the best both in theory and in practice. Due to the page limit, we omit some proofs, details, and experimental data. <p> This improves the deterministic bound of O (m + n log C) of [2]. (The hot queue implementation based on Fibonacci heaps matches this deterministic bound.) 5 Implementation Details Our previous papers <ref> [7, 15] </ref> describe implementations of multi-level buckets. Our implementation of hot queues augments the multi-level bucket implementation of [15]. See [15] for details of the multi-level bucket implementation. Consider a k-level hot queue. <p> Most of the problem families we use are the same as in our previous paper [15]. The next two sections describe the problem families. 6.1 The Graph TypesTwo types of graphs we explored were grids produced using the GRIDGEN generator <ref> [7] </ref>. These graphs can be characterized by a length x and width y. The graph is formed by constructing x layers, each of which is a path of length y. <p> The families are summarized in Table 2. In general, each family is constructed by varying one parameter while holding the others constant. Different families can vary the same parameter, using different constant values. 7 Experimental Results The 2- and 3-level bucket structures are very robust <ref> [7, 15] </ref>. In most cases, 2- and 3-level hot queues perform similarly to, although usually slightly better than, the corresponding multi-level bucket structures. One level hot queues are significantly more robust than one level buckets, but not as robust as 2- and 3-level hot queues.
Reference: [8] <author> B. V. Cherkassky, A. V. Goldberg, and C. Silver-stein. Buckets, </author> <title> Heaps, Lists, and Monotone Priority Queues. </title> <type> Technical Report 96-070, </type> <institution> NEC Research Institute, Princeton, NJ, </institution> <year> 1996. </year> <note> Available via URL http://www.neci.nj.nec.com/homepages/avg/pub/neci-tr-96-070.ps. </note>
Reference-contexts: For many problem classes, the hot queue implementation of Dijkstra's algorithm is the best both in theory and in practice. Due to the page limit, we omit some proofs, details, and experimental data. A full version of the paper appears in <ref> [8] </ref>. 2 Preliminaries A priority queue is a data structure that maintains a set of elements and supports operations insert, decrease-key, and extract-min. We assume that elements have keys used to compare the elements and denote the key of an element u by (u).
Reference: [9] <author> R. Cole and U. Vishkin. </author> <title> Deterministic Coin Tossing with Applications to Optimal Parallel List Ranking. </title> <journal> Information and Control, </journal> <volume> 70 </volume> <pages> 32-53, </pages> <year> 1986. </year>
Reference-contexts: In particular, implementations of Dijkstra's shortest path algorithm produce balanced operation sequences. In this paper we use the RAM model of computation [1]. The only nonobvious result about the model we use appears in <ref> [9] </ref>, where it is attributed to B. Schieber.
Reference: [10] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: At this point we switch to a heap. We use a k-heap with k = 4, which worked best in our tests. (See e.g. <ref> [10] </ref>.) To implement priority queue operations using a sorted list, we use doubly linked list sorted in nondecreasing order. Our implementation is designed for the shortest path application.
Reference: [11] <author> E. V. Denardo and B. L. Fox. </author> <title> Shortest-Route Methods: 1. Reaching, Pruning, </title> <journal> and Buckets. Oper. Res., </journal> <volume> 27 </volume> <pages> 161-186, </pages> <year> 1979. </year>
Reference-contexts: Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in [4, 14, 19]. Alternative implementations of priority queues use buckets (e.g. <ref> [2, 7, 11, 12] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [3] for a related data structure. Heaps are particularly efficient when the number of elements on the heap is small. <p> In this sense, heaps and buckets complement each other. We introduce heap-on-top priority queues (hot queues), which combine the multi-level bucket data structure of Denardo and Fox <ref> [11] </ref> and a heap. These queues use the heap instead of buckets when buckets would be sparsely occupied. The resulting implementation takes advantage of the best performance features of both data structures. <p> Schieber. The result is that given two machine words, we can find, in constant time, the index of the most significant bit in which the two words differ. 3 Multi-Level Buckets In this section we describe the k-level bucket data structure of Denardo and Fox <ref> [11] </ref>. We give a simpler description of this data structure by treating the element keys as base- numbers for a certain parameter . Consider a bucket structure B that contains k levels of buckets, where k is a positive integer. <p> A simple way of finding the first nonempty bucket at level i is to go through the buckets. This takes O () time. Lemma 3.4. We can find the first nonempty bucket at a level in O () time. Remark. One can do better <ref> [11] </ref>. Divide buckets at every level into groups of size dlog Ce, each group containing consecutive buckets. For each group, maintain a dlog Ce-bit number with bit j equal to 1 if and only if the j-th bucket in the group is not empty.
Reference: [12] <author> R. B. Dial. </author> <title> Algorithm 360: Shortest Path Forest with Topological Ordering. </title> <journal> Comm. ACM, </journal> <volume> 12 </volume> <pages> 632-633, </pages> <year> 1969. </year>
Reference-contexts: Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in [4, 14, 19]. Alternative implementations of priority queues use buckets (e.g. <ref> [2, 7, 11, 12] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [3] for a related data structure. Heaps are particularly efficient when the number of elements on the heap is small.
Reference: [13] <author> E. W. Dijkstra. </author> <title> A Note on Two Problems in Connexion with Graphs. </title> <journal> Numer. Math., </journal> <volume> 1 </volume> <pages> 269-271, </pages> <year> 1959. </year>
Reference-contexts: Priority queues are fundamental data structures with many applications. Typical applications include graph algorithms (e.g. [14]) and event simulation (e.g. [5]). An important subclass of priority queues used in applications such as event simulation and in Dijkstra's shortest path algorithm <ref> [13] </ref> is the class of monotone pri fl This work was done while the author was visiting NEC Research Institute. y Supported by the Department of Defense, with partial support from NSF Award CCR-9357849, with matching funds from IBM, Schlumberger Foundation, Shell Foundation, and Xerox Corporation. ority queues.
Reference: [14] <author> M. L. Fredman and R. E. Tarjan. </author> <title> Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 34 </volume> <pages> 596-615, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction A priority queue is a data structure that maintains a set of elements and supports operations insert, decrease-key, and extract-min. Priority queues are fundamental data structures with many applications. Typical applications include graph algorithms (e.g. <ref> [14] </ref>) and event simulation (e.g. [5]). <p> In this paper we deal with monotone priority queues. Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in <ref> [4, 14, 19] </ref>. Alternative implementations of priority queues use buckets (e.g. [2, 7, 11, 12]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [3] for a related data structure. <p> An RH is similar to the multi-level buckets, but uses a heap to find nonempty buckets. To get the best bounds, the heap operation time in an RH should depend on the number of distinct keys on the heap. The most complicated part of [2] is modifying Fibonacci heaps <ref> [14] </ref> to meet this requirement. In contrast, the hot queue bounds do not require anything special from the heap. We can use Fibonacci heaps with no modifications and achieve the same bounds as RH. Using the heap of Thorup [19], we obtain even better bounds. <p> The first fact is that the number of elements on H never exceeds t since each level accounts for at most t elements. The second fact is Lemma 4.1. Given the first fact and Theorem 3.1, the bounds are straightforward. For Fibonacci heaps <ref> [14] </ref>, the amortized time bounds are I (N ) = D (N ) = F (N ) = O (1), and X (N ) = O (log N ).
Reference: [15] <author> A. V. Goldberg and C. Silverstein. </author> <title> Implementations of Dijkstra's Algorithm Based on Multi-Level Buckets. </title> <type> Technical Report 95-187, </type> <institution> NEC Research Institute, Princeton, NJ, </institution> <year> 1995. </year>
Reference-contexts: This improves the deterministic bound of O (m + n log C) of [2]. (The hot queue implementation based on Fibonacci heaps matches this deterministic bound.) 5 Implementation Details Our previous papers <ref> [7, 15] </ref> describe implementations of multi-level buckets. Our implementation of hot queues augments the multi-level bucket implementation of [15]. See [15] for details of the multi-level bucket implementation. Consider a k-level hot queue. <p> Our implementation of hot queues augments the multi-level bucket implementation of <ref> [15] </ref>. See [15] for details of the multi-level bucket implementation. Consider a k-level hot queue. As in the multi-level bucket implementation, we set to the smallest power of two greater or equal to C 1=k . <p> Our implementation of hot queues augments the multi-level bucket implementation of <ref> [15] </ref>. See [15] for details of the multi-level bucket implementation. Consider a k-level hot queue. As in the multi-level bucket implementation, we set to the smallest power of two greater or equal to C 1=k . <p> Each of these has parameters to tune, and the results we show are for the best parameter values we tested. Most of the problem families we use are the same as in our previous paper <ref> [15] </ref>. The next two sections describe the problem families. 6.1 The Graph TypesTwo types of graphs we explored were grids produced using the GRIDGEN generator [7]. These graphs can be characterized by a length x and width y. <p> C was the same as for long grids. The third type of graphs includes random graphs with uniform arc length distribution. A random graph with n vertices has 4n arcs. The fourth type of graphs is the only type that is new compared to <ref> [15] </ref>. These are based on a cycle of n vertices, numbered 1 to n. In addition, each vertex is connected to d 1 distinct vertices. <p> The families are summarized in Table 2. In general, each family is constructed by varying one parameter while holding the others constant. Different families can vary the same parameter, using different constant values. 7 Experimental Results The 2- and 3-level bucket structures are very robust <ref> [7, 15] </ref>. In most cases, 2- and 3-level hot queues perform similarly to, although usually slightly better than, the corresponding multi-level bucket structures. One level hot queues are significantly more robust than one level buckets, but not as robust as 2- and 3-level hot queues.
Reference: [16] <author> A. V. Goldberg and R. E. Tarjan. </author> <title> Expected Performance of Dijkstra's Shortest Path Algorithm. </title> <type> Technical Report 96-062, </type> <institution> NEC Research Institute, Princeton, NJ, </institution> <year> 1996. </year>
Reference-contexts: Our implementation is designed for the shortest path application. In this application, the number of decrease-key operations on the elements of the active bucket tends to be very small (in <ref> [16] </ref>, this fact is proven for random graphs). Because of this, elements inserted into the list or moved by the decrease-key operation tend to be close to the beginning of the list. A different implementation may be better for a different application.
Reference: [17] <author> R. Raman. </author> <title> Fast Algorithms for Shortest Paths and Sorting. </title> <type> Technical Report TR 96-06, </type> <address> King's Colledge, London, </address> <year> 1996. </year>
Reference-contexts: The resulting implementation takes advantage of the best performance features of both data structures. We also give an alternative and more insightful description of the multi-level bucket data structure. (Concurrently and independently, a similar description has been given by Raman <ref> [17] </ref>.) Hot queues are related to radix heaps (RH) 1 of Ahuja et al. [2]. An RH is similar to the multi-level buckets, but uses a heap to find nonempty buckets. <p> Our experiments show that the resulting implementation is more robust than the heap or the multi-level bucket data structures. The new heap of Raman <ref> [17] </ref> instead of Thorup's heap improves our time bound: a factor of log * C is replaced by p Hot queues seem more practical than radix heaps. The latter data structure requires more bookkeeping.
Reference: [18] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA, </address> <year> 1983. </year>
Reference-contexts: The running time of Dijkstra's algorithm is dominated by a balanced sequence of priority queue operations that includes O (n) insert and extract-min operations and O (m) decrease-key operations (see e.g. <ref> [18] </ref>). The maximum event duration for this sequence of operations is C. The bounds for the queue operations immediately imply the following result. Theorem 4.3.

References-found: 18

