URL: http://www.isi.edu/~touch/pubs/infocomm99/infocomm99.ps
Refering-URL: http://www.isi.edu/~touch/pubs/infocomm99/
Root-URL: http://www.isi.edu
Email: -faber,touch,wyue-@isi.edu  
Phone: Phone: 310-822-1511  
Title: The TIME-WAIT state in TCP and Its Effect on Busy Servers  
Author: Theodore Faber Joe Touch Wei Yue 
Address: 4676 Admiralty Way Marina del Rey, CA 90292  
Affiliation: University of Southern California/Information Sciences Institute  
Abstract: Hosts providing important network services such as HTTP and FTP incur a per-connection memory load from TCP that can adversely affect their connection rate and throughput. The memory requirement is directly tied to the number of connections; caching and other sharing methods will not alleviate it. We hav e observed HTTP throughput reductions of as much as 50% under SunOS 4.1.3 due to this loading. This paper advocates off-loading the memory requirements to the growing number of clients. This reduces server memory requirements as connection rate at that server gro ws due to increases in the number of clients and the bandwidth available on the network. Our approaches control server memory load better with growing client load than per-transaction techniques such as persistent HTTP connections. Our approaches also interoperate with persistent connections to take advantage of their other benefits. This paper describes the causes of the memory loading, called TIME-WAIT loading, and defines three methods of alleviating it that scale with increasing number of clients. We present measurements of the systems and a comparison of their properties. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Jon Postel, ed., </author> <title> Transmission Control Protocol, </title> <month> RFC-793/STD-7 (September, </month> <year> 1981). </year>
Reference-contexts: Under HTTP, this host is usually the server [2]. To temporarily block connections, one endpoint keeps a copy of the TCP control block (TCB) indicating that the connection has been terminated recently. Such a connection is in the TIME-WAIT state <ref> [1] </ref>. Connections in TIME-WAIT are moved to CLOSED and their TCB discarded after enough time has passed that all packets from the same connection have left the network. <p> The Function of TIME-WAIT The purpose of TIME-WAIT is to prevent delayed packets from one connection being accepted by a later connection. Concurrent connections are isolated by other mechanisms, primarily by addresses, ports, and sequence numbers <ref> [1] </ref>. The TIME-WAIT state avoids the situation depicted in run down the page. Packets are labelled with the header ags that are relevant to connection establishment and shutdown; unlabelled packets carry only data. <p> Closing a connection that is in the ESTABLISHED state is called actively closing, closing from CLOSE-WAIT is passively closing. If both ends close the connection from ESTABLISHED, this is a simultaneous close, and both endpoints do a modified active close <ref> [1] </ref>. (See Figure 2.) Intuitively, the first endpoint to close a connection closes it actively, and the second passively; HTTP and FTP servers generally close connections actively. <p> During a simultaneous open, neither endpoint is in the server role, so neither has the TW-Negotiate value has priority. As establishment progresses, both sides will find themselves in SYN-RCVD (the state transitions are CLOSEDfiSYN-SENTfiSYN-RCVD) Each will know two TW-Negotiate values: theirs and the other endpoint's <ref> [1] </ref>. From here, each endpoint behaves as if it were a client in step 3 of the negotiation and had received the value in Table 1 from its peer. At most one endpoint will disagree with the conclusion, and send an &lt;RST&gt;.
Reference: 2. <author> R. Fielding, J. Gettys, J. Mogul, H. Frystyk, and T. Berners-Lee, </author> <title> Hypertext Transport Protocol - HTTP/1.1, RFC-2068 (January, </title> <year> 1997). </year>
Reference-contexts: The effect on HTTP servers is of particular interest because they carry a large amount of Internet traffic. TCP requires that the endpoint that closes a connection blocks further connections on the same host/port pair until there are no packets from that connection remaining in the network <ref> [2] </ref>. Under HTTP, this host is usually the server [2]. To temporarily block connections, one endpoint keeps a copy of the TCP control block (TCB) indicating that the connection has been terminated recently. Such a connection is in the TIME-WAIT state [1]. <p> TCP requires that the endpoint that closes a connection blocks further connections on the same host/port pair until there are no packets from that connection remaining in the network <ref> [2] </ref>. Under HTTP, this host is usually the server [2]. To temporarily block connections, one endpoint keeps a copy of the TCP control block (TCB) indicating that the connection has been terminated recently. Such a connection is in the TIME-WAIT state [1]. <p> We chose to modify HTTP because it is a major source of client/server Internet traffic. Early versions of HTTP relied on the closing of the TCP connection to indicate the end of a transaction. Among the changes is HTTP 1.1 <ref> [2] </ref> is the support of persistent connections, a technique that allows clients to pass multiple transactions over the same TCP connection. In order to support persistent connections, the end-of-connection and end-of-transaction indications have been decoupled. <p> We modify HTTP 1.1 to include a notification from the client that the connection is closed. This notification takes the form of an extension request, called CLIENT_CLOSE. An extension request is a new HTTP command, like PUT or POST, that is not explicitly defined in the HTTP specification <ref> [2] </ref> A CLIENT_CLOSE request requires no reply. It terminates a series of requests on a persistent connection, and indicates to the server that the client has closed the TCP connection. A client will close the TCP connection immediately after sending the CLIENT_CLOSE request to the server. <p> A CLIENT_CLOSE request differs from including a Connection: close in the header of a request because a request that includes Connection: close still requires a reply from the server, and the server will (actively) close the connection <ref> [2] </ref>. A CLIENT_CLOSE request indicates that the client has severed the TCP connection, and that the server should close its end without replying. CLIENT_CLOSE is a minor extension to the HTTP protocol. <p> The client closes the connection immediately after sending the CLIENT_CLOSE. Modified clients are compatible with the HTTP 1.1 specification <ref> [2] </ref>. A server that does not understand CLIENT_CLOSE will see a conventional HTTP exchange, followed by a request that it does not implement, and a closed connection when it tries to send the required error response. <p> Mogul et al. note that discriminating between a persistent connection that is temporarily idle and one that is closed can be difficult for servers because many operating systems do not notify the server that the client has closed the connection until the server tries to read from it <ref> [2] </ref>. CLIENT_CLOSE marks closing connections, which simplifies the server code that detects and closes connections that clients have closed. -8- Having a client decide when to initiate a CLIENT_CLOSE is somewhat complex. It has to consider user browsing patterns, state of local resources, and the state of server resources.
Reference: 3. <author> Robert G. Moskowitz, </author> <title> Why in the World Is the Web So Slow, </title> <journal> Network Computing, </journal> <pages> pp. </pages> <address> 22-24 (March 15, </address> <year> 1996). </year>
Reference-contexts: The presence of many TIME-WAIT TCBs can increases the demultiplexing time for active connections. We hav e seen throughput drop by 50% at loaded endpoints, and the effect on commercial servers has been noted elsewhere <ref> [3] </ref>. Some TCP implementations address the demultiplexing problem without addressing the memory load; we discuss them in Section 2.2. The design of TCP places the TIME-WAIT TCB at the endpoint that closes the connection; this decision conicts with the semantics of many application protocols.
Reference: 4. <author> J. Postel and J. K. Reynolds, </author> <title> File Transfer Protocol, </title> <journal> RFC-959, USC/Information Sciences Institute (October, </journal> <year> 1985). </year>
Reference-contexts: Performance Problems at Busy Servers Because client/server protocols are generally synchronized request/response protocols, the protocol specification usually determines which endpoint will close the transport connection. For example, FTP clients know a file has been delivered successfully if the connection on which the file was transferred closes gracefully <ref> [4] </ref>; this implies that the server closes connections. TCP commentators encourage client/server systems to arrange for the client to close connections to avoid TIME-WAIT loading [8]. Many protocols, such as FTP, do not follow this convention. We discuss the reasons for this in Section 2.3.
Reference: 5. <author> Sun Microsystems, Inc., </author> <title> Remote Procedure Call Specification, </title> <address> RFC-1057 (June 1, </address> <year> 1988). </year>
Reference-contexts: In each case, the application protocol requires that servers close the transport connection, and the transport protocol requires that servers incur a memory cost if they do. Protocols that use other methods of marking end-of-transaction, e.g., SUN RPC over TCP <ref> [5] </ref>, can have the clients close connections at the expense of a more complex application protocol. If the number of clients continues to increase, the only way to keep server TIME-WAIT memory requirements constant is to move the TIME-WAIT TCBs to clients.
Reference: 6. <author> Jon Postel, ed., </author> <title> Internet Protocol, </title> <month> RFC-791/STD-5 (September </month> <year> 1981). </year>
Reference-contexts: The MSL is defined as the longest period of time that a packet can remain undelivered in the network. Originally, the TTL field of an IP packet was the amount of time the packet could remain undelivered, but in practice the field has become a hop count <ref> [6] </ref>. Therefore, the MSL is an estimate rather than a guarantee. The Internet host requirements document suggests a using 2 minutes as the MSL [7], but some implementations use values as small as 30 seconds [8].
Reference: 7. <institution> Internet Engineering Task Force, R. </institution> <note> Braden, </note> <editor> ed., </editor> <title> Requirements for Internet Hosts - Communications Layers, </title> <month> RFC-1122 (October </month> <year> 1989). </year>
Reference-contexts: Therefore, the MSL is an estimate rather than a guarantee. The Internet host requirements document suggests a using 2 minutes as the MSL <ref> [7] </ref>, but some implementations use values as small as 30 seconds [8]. Under most conditions waiting 2 MSL is sufficient to drain duplicates, but they can and do arrive after that time.
Reference: 8. <author> W. Richard Stevens, </author> <title> TCP/IP Illustrated, Volume 1, The Protocols, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <institution> et al. </institution> <year> (1994). </year>
Reference-contexts: Therefore, the MSL is an estimate rather than a guarantee. The Internet host requirements document suggests a using 2 minutes as the MSL [7], but some implementations use values as small as 30 seconds <ref> [8] </ref>. Under most conditions waiting 2 MSL is sufficient to drain duplicates, but they can and do arrive after that time. <p> For example, FTP clients know a file has been delivered successfully if the connection on which the file was transferred closes gracefully [4]; this implies that the server closes connections. TCP commentators encourage client/server systems to arrange for the client to close connections to avoid TIME-WAIT loading <ref> [8] </ref>. Many protocols, such as FTP, do not follow this convention. We discuss the reasons for this in Section 2.3. Because application protocols do not take TIME-WAIT TCB distribution into account, heavily loaded servers can have thousands of connections in TIME-WAIT that consume memory and can slow active connections. <p> There are a finite number of mbufs available in the system, and mbufs consumed by TCBs cannot be used for other purposes such as moving data. Some systems on high speed networks can run 1 The diagram layout is modelled after one appearing in <ref> [8] </ref>. out of mbufs due to TIME-WAIT buildup under high connection load. A SPARCStation 20/71 under SunOS 4.1.3 on a 640 Mb/s Myrinet [10] cannot support more than 60 connections/sec because of this limit.
Reference: 9. <author> Gary R. Wright and W. Richard Stevens, </author> <title> TCP/IP Illustrated, </title> <booktitle> Volume 2 The Implementation, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <institution> et al. </institution> <year> (1995). </year>
Reference-contexts: Because application protocols do not take TIME-WAIT TCB distribution into account, heavily loaded servers can have thousands of connections in TIME-WAIT that consume memory and can slow active connections. In BSD-based TCP implementations, TCBs are kept in mbufs, the memory allocation unit of the networking subsystem <ref> [9] </ref>. There are a finite number of mbufs available in the system, and mbufs consumed by TCBs cannot be used for other purposes such as moving data. <p> Barriers to Adoption Although the algorithm above is simple to describe, it represents a significant change to the TCP state machine. Many TCP implementations are descended from the original BSD reference implementation of the TCP/IP stack that directly implements the TCP state machine <ref> [9] </ref>. Implementing changes to that state machine would require significant programming and testing effort. Furthermore, proofs of TCP correctness that rely on the TCP state machine would be invalidated. The state machine changes reect the fact that information from connection establishment affects the closure.
Reference: 10. <author> Myricom, Inc., Nannette J. Boden, Danny Cohen, Robert E. Felderman, Alan E Kulawik, Charles L. Seitz, Jakov N. Selovic, and Wen-King Su, Myrinet: </author> <title> A Gigabit-per-second Local Area Network, </title> <booktitle> IEEE Micro, </booktitle> <pages> pp. 29-36, </pages> <note> IEEE (February 1995). </note>
Reference-contexts: Some systems on high speed networks can run 1 The diagram layout is modelled after one appearing in [8]. out of mbufs due to TIME-WAIT buildup under high connection load. A SPARCStation 20/71 under SunOS 4.1.3 on a 640 Mb/s Myrinet <ref> [10] </ref> cannot support more than 60 connections/sec because of this limit. Demultiplexing incoming packets requires searching the endpoint's list of TCBs which will be full of of TIME-WAIT TCBs at a TIME-WAIT loaded server.
Reference: 11. <editor> Mike Karels and David Borman, </editor> <title> Personal Communication (July 1997). </title>
Reference-contexts: We show an example in Section 5. Modern TCP implementations avoid the overhead of the linear search of TIME-WAIT TCBs when demultiplexing packets. BSDI/OS keeps TIME-WAIT TCBs at the end of the list of TCBs, so that they can be used as a terminator for the linear search <ref> [11] </ref>. Looking TCBs up in a hash table reduces lookup times both for systems with many TIME-WAIT TCBs and for many active connections [12].
Reference: 12. <author> Paul E. McKenney and Ken F. Dove, </author> <title> Efficient Demultiplexing of Incoming TCP Packets, </title> <booktitle> Proceedings of SIGCOMM 1992, </booktitle> <volume> vol. 22, no. 4, </volume> <pages> pp. 269-279, </pages> <address> Baltimore, MD (August 17-20, </address> <year> 1992). </year>
Reference-contexts: BSDI/OS keeps TIME-WAIT TCBs at the end of the list of TCBs, so that they can be used as a terminator for the linear search [11]. Looking TCBs up in a hash table reduces lookup times both for systems with many TIME-WAIT TCBs and for many active connections <ref> [12] </ref>. Some systems address TIME-WAIT loading by using a shorter MSL, hoping to age the TIME-WAIT TCBs out of the system sooner, which weakens the protection afforded by TIME-WAIT. If TIME-WAIT TCBs are kept at clients, they can afford to keep them for the full MSL.
Reference: 13. <author> Hendrik Frystyk Nielsen, James Gettys, Anselm Baird-Smith, Eric Prud'hommeaux, Hakon Wium Lie, and Chris Lilley, </author> <title> Network Performance Effects of HTTP/1.1, CSS1, </title> <booktitle> and PNG, Proceedings of the SIG-COMM Symposium on Applications, Technologies, Architectures, and Protocols for Computer Communication, </booktitle> <pages> pp. 155-166, </pages> <address> Cannes, France (14-18 September 1997). </address>
Reference-contexts: This makes the post-connection memory requirement explicit and allows either endpoint to decline the connection if the overhead is unacceptable. Furthermore it is transparent to 2 This is false in protocols that can have multiple pending requests, e.g., pipelined HTTP requests <ref> [13] </ref>. applications using the transport, and allows them to close the transport connection as part of their protocol without incurring hidden costs. We propose adding a TCP option, TW-Negotiate, that indicates which end of the connection will hold the TCBs.
Reference: 14. <author> Van Jacobson, Robert Braden, and D. </author> <title> Borman, TCP Extensions for High Performance, </title> <month> RFC-1323 (May </month> <year> 1992). </year>
Reference-contexts: We propose adding a TCP option, TW-Negotiate, that indicates which end of the connection will hold the TCBs. TW-Negotiate will be negotiated during the three-way handshake that is used to synchronize TCP sequence numbers. The three-way handshake has been used to negotiate other options, such as TCP window scaling <ref> [14] </ref>. The negotiation algorithm for a client/server connection: 1. Client includes the TW-Negotiate option in the &lt;SYN&gt; packet for the connection. TW-Negotiate contains the IP address of the end that will hold the TCB. The option's presence indicates that the client supports negotiation.
Reference: 15. <author> R. Braden, </author> <note> TIME-WAIT Assassination Hazards in TCP, RFC-1337, USC/Information Sciences Institute (May 1992). </note>
Reference-contexts: The behavior of an active close is unaffected. Using an &lt;RST&gt; packet means that this system only works with TCP stacks that accept &lt;RST&gt; packets that arrive for a connection in TIME-WAIT state. Such stacks are susceptible to TIME-WAIT assassination <ref> [15] </ref>, which can lead to connections becoming desynchronized or destroyed. TIME-WAIT assassination is the accidental or malicious deletion of a TIME-WAIT TCB at an endpoint, which can lead to confusion as shown in Figure 1. <p> Our system assassinates TIME-WAIT states at the server and replaces them at the client, which does not change TCP's behavior. Adding our system to a server that is susceptible to TIME-WAIT assassination does not make it more vulnerable, but a server that implements the changes in <ref> [15] </ref> to prevent assassinations will not benefit the system described in this section. Interactions between a server that prevents TIME-WAIT assassination and a client that implement our changes do not compromise TIME-WAIT guarantees.
Reference: 16. <author> James Gettys, </author> <title> Personal Communication (December 1997). </title>
Reference-contexts: As mentioned above, servers may choose to terminate persistent connections in order to reuse the resources allocated to that connection. Servers need a mechanism to communicate their commitment level to a connection, so that clients and servers are more likely to decide to terminate the same ones <ref> [16] </ref>. The CLIENT_CLOSE request has been implemented directly in the apache-1.2.4 server [17] and test programs from the WebSTONE performance suite [18]. Patches are available from the authors.
Reference: 17. <author> Roy T. Fielding and Gail Kaiser, </author> <title> Collaborative Work: The Apache Server Project, </title> <journal> IEEE Internet Computing, </journal> <volume> vol. 1, no. 4, </volume> <pages> pp. 88-90, </pages> <note> IEEE (July/August 1997). </note>
Reference-contexts: Servers need a mechanism to communicate their commitment level to a connection, so that clients and servers are more likely to decide to terminate the same ones [16]. The CLIENT_CLOSE request has been implemented directly in the apache-1.2.4 server <ref> [17] </ref> and test programs from the WebSTONE performance suite [18]. Patches are available from the authors.
Reference: 18. <author> Gene Trent and Mark Sake, WebSTONE: </author> <title> The First Generation in HTTP Server Benchmarking, </title> <note> white paper, Silicon Graphics International (February 1995). </note>
Reference-contexts: Servers need a mechanism to communicate their commitment level to a connection, so that clients and servers are more likely to decide to terminate the same ones [16]. The CLIENT_CLOSE request has been implemented directly in the apache-1.2.4 server [17] and test programs from the WebSTONE performance suite <ref> [18] </ref>. Patches are available from the authors. Adopting the HTTP solution is effective if HTTP connections are the a major source of TIME-WAIT loading; how-ev er, if another protocol begins loading servers with TIME-WAIT states, that protocol will have to be modified as well. <p> Experiments In this section we present experiments that demonstrate TIME-WAIT loading and show that our solutions reduce its effects. The proposed solutions have been implemented under SunOS 4.1.3 and initial evaluations of their performance have been made using both custom benchmark programs and the WebSTONE benchmark <ref> [18] </ref>. The tests were run on workstations connected to the 640 Mb/sec Myrinet LAN. We performed two experiments. The first experiment shows that TCB load degrades server performance and that our modifications reduce that degradation.
References-found: 18

