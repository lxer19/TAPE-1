URL: ftp://softlib.rice.edu/pub/CRPC-TRs/reports/CRPC-TR96657-S.ps.gz
Refering-URL: http://www.crpc.rice.edu/CRPC/softlib/TRs_online.html
Root-URL: 
Title: Interprocedural Pointer Analysis for C  
Author: John Lu 
Affiliation: Rice University Department of Computer Science  
Abstract: Interprocedural pointer analysis provides information on the values pointer variables may have at various points in a program. It is especially useful in languages like C, where pointers are extensively used. This analysis does not improve code directly but is used by other optimizations. This paper presents a framework in which to perform pointer analysis. Basic questions that any pointer analyzer must answer are discussed, and answers to these questions are developed. A working pointer analyzer is presented with performance results given for the analyzer. The effect of the analyzer on the running time of various programs is also shown.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers, Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: The complications that arise from these events are a result of the parameter binding mechanism in C, which relies on call-by-value parameters <ref> [1] </ref>. This seems simpler than the call-by-reference convention used in Fortran; however, the presence of pointer variables in C re-introduces all of the problems caused by reference parameters in other languages, as Figure 1 shows.
Reference: [2] <author> J. P. Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> Conference Record of the Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 29-41, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: Using alias pairs is an unfortunate consequence of thinking of pointer analysis in terms of the framework used to analyze aliases in FORTRAN caused by call-by-reference parameters <ref> [2] </ref>. Formal parameters in a call-by-reference language are not equivalent to memory locations. They are alternative names given to memory locations within a function. In this situation, alias pairs are the correct information to gather. In C, however, the situation is somewhat different. <p> This was not done in order to show the core of PL. For regions modeling a scalar variable, we know that an explicit store to them will kill old values. This could be struct inner - int a; -; struct outer - struct inner c <ref> [2] </ref>; struct inner d; -; main (int argc, char **argv) - int *a; struct outer g; a=(int *) malloc (sizeof (int)); a=(int *) malloc (sizeof (int)); f (); void f () - int *p,a; f (); main's function regions @ a @ g.c @ g.d.a @ g.d.b f's function regions @ <p> This occurs because the analyzer does not understand how 21 struct foo - int a,b <ref> [2] </ref>; void f () - int *p; struct foo c; /* good addressing */ p=c.b; /* bad addressing */ p=(int *) &c; p [1]=3; /* analyzer thinks this stores to c.b */ p+=2; p [0]=3; /* analyzer thinks this stores to c.a */ - f's function regions @ c.a 0 4
Reference: [3] <author> Preston Briggs. </author> <title> The massively scalar compiler project. </title> <type> Technical report, </type> <institution> Rice University, </institution> <year> 1994. </year>
Reference-contexts: Note that variable a in function f () is an example of an ALVR and is given a global region. 4.4 Implementation Our implementation was done within the Massively Scalar Compiler Project <ref> [3] </ref>. C-code is translated into ILOC our intermediate language, by C2I. C2I generates a region for each scalar and array variable. Each field of a structure and each compiler-generated location is also given a region.
Reference: [4] <author> D.R. Chase, M. Wegman, and F.K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <journal> SIGPLAN Notices, </journal> <volume> 25(6) </volume> <pages> 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Thus, much effort described in the literature has been directed at discovering and representing the shape of pointer-based structures constructed in the heap <ref> [8, 4, 17, 12] </ref>. From our perspective, the issue of understanding the internal structure of the heap is orthogonal to the rest of the analyzer. * The simplest solution available to us would model the whole heap with a single name.
Reference: [5] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <volume> 19(6) </volume> <pages> 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference: [6] <author> John Cocke and Ken Kennedy. </author> <title> An algorithm for reduction of operator strength. </title> <journal> Communications of the ACM, </journal> <month> 20(11), November </month> <year> 1977. </year>
Reference-contexts: For example, a source-level analysis is unlikely to disambiguate two pointer references that use induction variables introduced by operator strength reduction <ref> [6] </ref>. In designing an analyzer, the compiler writer should consider the uses to which the results will be put. We intend to use the results of our analysis to drive optimizations on a low-level representation of the program. Therefore, our analyzer will work from an assembly-like representation of the code.
Reference: [7] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year> <month> 23 </month>
Reference-contexts: A load or store labeled with a function region F R j;k indicates that the load or store may reference or modify the topmost instantiation of F R j;k . To label all the loads and stores, the program must be converted into SSA form <ref> [7] </ref>. This includes giving SSA names to all global regions and the topmost instantiation of all function regions. To generate SSA names for regions, the intermediate form must specify where a region may be modified and where it may be referenced.
Reference: [8] <author> Alain Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6) </volume> <pages> 230-241, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Thus, much effort described in the literature has been directed at discovering and representing the shape of pointer-based structures constructed in the heap <ref> [8, 4, 17, 12] </ref>. From our perspective, the issue of understanding the internal structure of the heap is orthogonal to the rest of the analyzer. * The simplest solution available to us would model the whole heap with a single name.
Reference: [9] <author> Maryam Emami, Rakesh Ghiya, and Laurie Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6) </volume> <pages> 242-256, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: The same machinery used to analyze memory pointers can track pointers to functions, as long as the compiler can recognize both the creation of such pointers and their actual use. Hendren noted this advantage in her 1994 pldi paper <ref> [9] </ref>. 2.2 Modeling Parameter Binding The analyzer must include a mechanism for modeling the effects of executing a procedure call and a subsequent return on the state of the program's name space.
Reference: [10] <author> R.P. Wilson et al. </author> <title> SUIF: An infrastructure for research on parallelizing and optimizing compilers. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(12) </volume> <pages> 31-37, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: Ruf uses explicit names to model parameter binding. 3.3 Program Representation Landi and Ryder, and Hendren both use a C-like representation in their analysis. Wilson and Lam build their work in the SUIF (Stanford University Intermediate Format) environment <ref> [10] </ref>. It is not clear what kind of representation the other groups use. 3.4 Flow Sensitivity Choi presents both flow-sensitive and flow-insensitive versions of his algorithm. He also notes that killing information can be used with a flow-insensitive version to improve its accuracy.
Reference: [11] <author> J. T. Hecht, Y. Wang, B. Connor, S. H. Blanton, and S. P. Daiger. Nonsyndromic cleft lip and palate: </author> <title> No evidence of linkage to hla of factor 13a. </title> <journal> American Journal of Human Genetics, </journal> <volume> 52 </volume> <pages> 1230-1233, </pages> <year> 1993. </year>
Reference-contexts: In our testing, mlink was run with the CLP data set. The CLP data set describes several families with many members who have autosomal dominant nonsyndromic cleft lip and palate <ref> [11] </ref>. We thank Dr. Jacqueline T. Hecht for contributing disease family data. Development of the CLP data set was supported by grants from the National Institutes of Health and Shriners Hospital. Finally, we wish to thank Bill Landi for the allroots program.
Reference: [12] <author> Joseph Hummel, Laurie J. Hendren, and Alexander Nicolau. </author> <title> A general data dependence test for dynamic, pointer-based data structures. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6) </volume> <pages> 218-229, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Thus, much effort described in the literature has been directed at discovering and representing the shape of pointer-based structures constructed in the heap <ref> [8, 4, 17, 12] </ref>. From our perspective, the issue of understanding the internal structure of the heap is orthogonal to the rest of the analyzer. * The simplest solution available to us would model the whole heap with a single name.
Reference: [13] <editor> N.D. Jones and S.S. Muchnick. </editor> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <volume> 8(6) </volume> <pages> 66-74, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: Another solution would be to allow the user to specify what calls allocate memory. This would accurately split the heap for all memory allocators. Another popular approach to splitting the heap is k-limiting <ref> [13] </ref>. This approach allows up to k copies of a heap name to be generated where k is pre-determined. The goal of the k-limited approach is to allow for more accurate analysis of heap structures.
Reference: [14] <author> Robert W. Cottingham Jr., Ramana M. Idury, and Alejandro A. Schaffer. </author> <title> Faster sequential genetic linkage computations. </title> <journal> American Journal of Human Genetics, </journal> <volume> 53 </volume> <pages> 252-263, </pages> <year> 1993. </year>
Reference-contexts: We also thank Alejandro A. Schaffer for allowing us to test mlink. mlink comes from version 2.2 of the FASTLINK <ref> [14, 21] </ref> implementation of the LINKAGE [18] package for genetic linkage analysis. Genetic linkage analysis is a statistical technique used to map genes and find the approximate location of disease genes.
Reference: [15] <author> W. Landi and B.G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: We will consider work by five specific groups: Landi and Ryder <ref> [15, 16] </ref>, Choi et al.[5], Hendren et al.[9], Wilson and Lam [22], and Ruf [20]. The following sections summarize their individual approaches and describe their position relative to the issues raised in the previous section. 3.1 Choice of Problem Both Landi and Ryder, and Choi analyze alias pairs.
Reference: [16] <author> William Landi and Barbara G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(7) </volume> <pages> 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: We will consider work by five specific groups: Landi and Ryder <ref> [15, 16] </ref>, Choi et al.[5], Hendren et al.[9], Wilson and Lam [22], and Ruf [20]. The following sections summarize their individual approaches and describe their position relative to the issues raised in the previous section. 3.1 Choice of Problem Both Landi and Ryder, and Choi analyze alias pairs.
Reference: [17] <author> J.R. Larus and P.N. Hlifinger. </author> <title> Detecting conflicts between stucture accesses. </title> <journal> SIGPLAN Notices, </journal> <volume> 23(6) </volume> <pages> 21-34, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Thus, much effort described in the literature has been directed at discovering and representing the shape of pointer-based structures constructed in the heap <ref> [8, 4, 17, 12] </ref>. From our perspective, the issue of understanding the internal structure of the heap is orthogonal to the rest of the analyzer. * The simplest solution available to us would model the whole heap with a single name.
Reference: [18] <author> G. M. Lathrop, J. M. Lalouel, C. Julier, and J. Ott. </author> <title> Strategies for multilocus analysis in humans. </title> <booktitle> Proceedings of the National Academy of Sciences of the U.S.A., </booktitle> <volume> 81 </volume> <pages> 3443-3446, </pages> <year> 1984. </year>
Reference-contexts: We also thank Alejandro A. Schaffer for allowing us to test mlink. mlink comes from version 2.2 of the FASTLINK [14, 21] implementation of the LINKAGE <ref> [18] </ref> package for genetic linkage analysis. Genetic linkage analysis is a statistical technique used to map genes and find the approximate location of disease genes. LINKAGE/FASTLINK is a package of programs used by geneticists around the world to find the approximate location of disease genes.
Reference: [19] <author> Eugene W. Myers. </author> <title> A precise interprocedural data flow algorithm. </title> <booktitle> In Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <address> Williamsburg, Vir-ginia, </address> <month> January </month> <year> 1981. </year>
Reference-contexts: May Modifies information is the classic example of a problem that gains no additional information from considering intraprocedural control flow. 4 Flow-sensitive analysis will, in practice, be slower <ref> [19] </ref>. We feel that the increased precision obtained with a flow-sensitive analysis is critical in computing points-to information.
Reference: [20] <author> Erik Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <journal> SIGPLAN Notices, </journal> <volume> 30(6) </volume> <pages> 13-22, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: We will consider work by five specific groups: Landi and Ryder [15, 16], Choi et al.[5], Hendren et al.[9], Wilson and Lam [22], and Ruf <ref> [20] </ref>. The following sections summarize their individual approaches and describe their position relative to the issues raised in the previous section. 3.1 Choice of Problem Both Landi and Ryder, and Choi analyze alias pairs.
Reference: [21] <author> Alejandro A. Schaffer, Sandeep K. Gupta, K. Shriram, and Robert W. Cottingham Jr. </author> <title> Avoiding recomputation in linkage analysis. </title> <booktitle> Human Heredity, </booktitle> <volume> 44 </volume> <pages> 225-237, </pages> <year> 1994. </year>
Reference-contexts: We also thank Alejandro A. Schaffer for allowing us to test mlink. mlink comes from version 2.2 of the FASTLINK <ref> [14, 21] </ref> implementation of the LINKAGE [18] package for genetic linkage analysis. Genetic linkage analysis is a statistical technique used to map genes and find the approximate location of disease genes.
Reference: [22] <author> Robert P. Wilson and Monica S. Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <journal> SIGPLAN Notices, </journal> <volume> 30(6) </volume> <pages> 1-12, </pages> <month> June </month> <year> 1995. </year> <month> 24 </month>
Reference-contexts: We will consider work by five specific groups: Landi and Ryder [15, 16], Choi et al.[5], Hendren et al.[9], Wilson and Lam <ref> [22] </ref>, and Ruf [20]. The following sections summarize their individual approaches and describe their position relative to the issues raised in the previous section. 3.1 Choice of Problem Both Landi and Ryder, and Choi analyze alias pairs.
References-found: 22

