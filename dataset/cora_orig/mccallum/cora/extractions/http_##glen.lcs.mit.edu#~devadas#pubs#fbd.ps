URL: http://glen.lcs.mit.edu/~devadas/pubs/fbd.ps
Refering-URL: http://glen.lcs.mit.edu/~devadas/pubs/boolean.html
Root-URL: 
Title: Probabilistic Manipulation of Boolean Functions Using Free Boolean Diagrams  
Author: Amelia Shen, Srinivas Devadas Abhijit Ghosh 
Address: Cambridge, MA  Sunnyvale, CA  
Affiliation: Massachusetts Institute of Technology  Mitsubishi Electric Research Laboratories  
Abstract: We propose a data structure for Boolean functions termed the Free Boolean Diagram. A Free Boolean Diagram allows decision vertices as in the conventional Binary Decision Diagram, but also allows function vertices corresponding to the and and xor functions. It has been shown previously that the equivalence of two Free Boolean Diagrams can be decided probabilistically in polynomial time. Based on the equivalence checking method, we develop a set of algorithms for the probabilistic construction of Free Boolean Diagrams from multilevel combinational logic circuits, and for their manipulation. These algorithms are modified versions of reduced, ordered Binary Decision Diagram manipulation methods. We provide the implementation details of a Free Boolean Diagram package. We show that functions difficult to verify using reduced, ordered Binary Decision Diagrams can be verified using the Free Boolean Diagrams package using substantially less memory. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Blum, A. K. Chandra, and M. N. Wegman. </author> <title> Equivalence of Free Boolean Graphs Can Be Decided Probabilistically in Polynomial Time. </title> <journal> Information Processing Letters, </journal> <volume> 10(2) </volume> <pages> 80-82, </pages> <month> March </month> <year> 1980. </year>
Reference-contexts: Our main contribution is the development of probabilistic algorithms for the construction and manipulation of FBDs based upon the fundamental result of Blum, Chandra and Wegman <ref> [1] </ref>, and the recent result of Gergov and Meinel [9]. The FBDs presented here are not canonical but are a more powerful representation than ROBDDs because of the augmentations mentioned above. FBDs allow for different orderings along different paths from the root to a terminal vertex. <p> Two multilevel circuits can be probabilistically checked for equivalence by constructing their respective FBDs and comparing their signatures. 2 Related work is described in Section 2. In Section 3 we give the terminology and review the equivalence checking methods of <ref> [1] </ref> and [9] that form the basis for Boolean operations on FBDs. The weakly canonical form for FBDs is presented in Section 4. We describe the implementation of cofactor, xor, and and methods in Section 5. Implementation details of the manipulation package are discussed in Section 6. <p> We describe the implementation of cofactor, xor, and and methods in Section 5. Implementation details of the manipulation package are discussed in Section 6. Results obtained from using this package are given in Section 7. 2 Previous Work in Probabilistic Manipulation The work of Blum, Chandra and Wegman <ref> [1] </ref> and that of Gergov and Meinel [9] upon which our probabilistic manipulation algorithms are based will be described in Section 3. Semi-numeric Binary Decision Diagrams in [11], used the theory of Blum, Chandra and Wegman [1] as a means for probabilistic verification of previously unverifiable circuits. <p> 7. 2 Previous Work in Probabilistic Manipulation The work of Blum, Chandra and Wegman <ref> [1] </ref> and that of Gergov and Meinel [9] upon which our probabilistic manipulation algorithms are based will be described in Section 3. Semi-numeric Binary Decision Diagrams in [11], used the theory of Blum, Chandra and Wegman [1] as a means for probabilistic verification of previously unverifiable circuits. <p> In the figure, attributed edges are indicated by dots on them. 3.2 Probabilistic Equivalence of FBDs It has been shown that the noncontainment problem for FBDs without function vertices, is NP-complete [8]. However Blum, Chandra and Wegman <ref> [1] </ref> have given a polynomial time algorithm to probabilistically decide the equivalence of two FBDs without and and xor vertices. A brief description of the bottom-up version of the algorithm follows. Let F be an algebraic field with at least 2n elements. <p> It was shown in <ref> [1] </ref> that for two graphs G 1 and G 2 , if jG 1 j is not equal to jG 2 j, then G 1 and G 2 are definitely not equivalent. <p> Further, by increasing the cardinality of S the error probability for a single run can be reduced significantly. 3.3 xor Vertices Gergov and Meinel [9] have extended the the equivalence algorithm of <ref> [1] </ref> to include function vertices that correspond to parity functions, i.e., xor vertices. We describe their method below. A primitive polynomial of degree m and characteristic 2 can be used to generate a Galois Field with 2 m elements GF (2 m ) [12].
Reference: [2] <author> K. S. Brace, R. L. Rudell, and R. E. Bryant. </author> <title> Efficient Implementation of a BDD Package. </title> <booktitle> In Proc. of 27 th Design Automation Conference, </booktitle> <pages> pages 40-45, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: This method is similar to Brace, Rudell and Bryant's ite algorithm <ref> [2] </ref>. However, the method allows for the introduction and retainment of function vertices in the resulting FBD. As with the strongly canonical form for ROBDDs [2], during the and operation on FBDs we can ensure a reduced result. <p> This method is similar to Brace, Rudell and Bryant's ite algorithm <ref> [2] </ref>. However, the method allows for the introduction and retainment of function vertices in the resulting FBD. As with the strongly canonical form for ROBDDs [2], during the and operation on FBDs we can ensure a reduced result. Using the theory of Gergov and Meinel [9], the xor operation on two FBDs can be computed trivially. We use attributed edges to complement FBDs. <p> Automatic methods of function vertex introduction and retainment are critical to obtaining compact-sized FBDs from arbitrary logic-level circuits. 3 Preliminaries The reduced, ordered Binary Decision Diagram is defined in [3] and an efficient implementation of a manipulation package is described in <ref> [2] </ref>. <p> The reduce algorithm is similar to that of [3]. Further, the strongly canonical framework for ROBDDs developed in <ref> [2] </ref> can also be generalized to FBDs. We describe the reduction algorithm and the canonical form for FBDs in this section. The reduction method for FBDs simply corresponds to a bottom-up traversal of the FBD computing the signature for every vertex in the FBD. <p> If the signature is present, we use the representation that has the highest index at the root. 6 Implementation The implementation of the FBD package mimics the structures and routines described in <ref> [2] </ref>, with modifications to accommodate function signatures, and function vertices. <p> As mentioned in Section 6.1, we use a polynomial of degree 16 to generate a field with 2 16 elements. Each signature requires 16 bits, i.e. 2 bytes. 1 Addition is carried out in binary or decimal arithmetic. 13 We also implemented the complement edge scheme described in <ref> [2] </ref>. When a complement edge on a vertex F is encountered, the signature for the corresponding function is simply j1 jF jj. Note that we do not have to enforce the restrictions on the use of negative edges as in [2], as our canonicity property is based on signatures. 6.3 Hash <p> 13 We also implemented the complement edge scheme described in <ref> [2] </ref>. When a complement edge on a vertex F is encountered, the signature for the corresponding function is simply j1 jF jj. Note that we do not have to enforce the restrictions on the use of negative edges as in [2], as our canonicity property is based on signatures. 6.3 Hash Tables The unique table is a hash table that records vertices with unique signatures. The unique table is essential for maintaining the canonicity of the FBD vertices. <p> If the pairs match, the result of the and is taken from the cache entry. Before we look for an entry in the computed table, we convert the pair to a standard pair, similar to the standard triple of <ref> [2] </ref>. Since all the tables use the FBD vertex signatures as keys, and the results of the computed table lookups are signatures, the table entries do not rely on actual vertex addresses. <p> The actual vertices can be replaced, altered and updated in the unique table without corrupting other table entries. 6.4 Memory Requirement It was shown in <ref> [2] </ref> that the memory usage per ROBDD vertex is 22 bytes per vertex under certain assumptions. The same computation shows the amortized memory cost for the FBD package is 32 bytes per vertex. This number includes the hash tables and 4 passes for the signature computation.
Reference: [3] <author> R. Bryant. </author> <title> Graph-Based Algorithms for Boolean Function Manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: 1 Introduction The task of representing and manipulating Boolean functions efficiently is central to many different problems in logic synthesis, testing and verification. In recent years, reduced, ordered Binary Decision Diagrams (ROBDDs) <ref> [3] </ref> have gained widespread use in the areas of combinational and sequential logic verification (e.g. [6, 13]) due to their canonicity and ease of manipulation. The efficiency of an ROBDD representation depends strongly on the input ordering. <p> Automatic methods of function vertex introduction and retainment are critical to obtaining compact-sized FBDs from arbitrary logic-level circuits. 3 Preliminaries The reduced, ordered Binary Decision Diagram is defined in <ref> [3] </ref> and an efficient implementation of a manipulation package is described in [2]. <p> The reduce algorithm is similar to that of <ref> [3] </ref>. Further, the strongly canonical framework for ROBDDs developed in [2] can also be generalized to FBDs. We describe the reduction algorithm and the canonical form for FBDs in this section.
Reference: [4] <author> R. Bryant. </author> <title> On the Complexity of VLSI Implementations and Graph Representations of Boolean Functions with Application to Integer Multiplication. </title> <journal> In IEEE Transactions on Computers, </journal> <pages> pages 205-213, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: The efficiency of an ROBDD representation depends strongly on the input ordering. Finding a good ordering is a difficult problem that has received considerable attention (e.g. [13]). However, there are classes of combinational circuits, notably multipliers, for which ROBDDs, under any possible input ordering, have a provably exponential size <ref> [4] </ref>. There have been efforts to increase the power of the ROBDD representation, while trading off canonicity or ease of manipulation. In Section 2, we describe previous work in this area. <p> Semi-numeric Binary Decision Diagrams in [11], used the theory of Blum, Chandra and Wegman [1] as a means for probabilistic verification of previously unverifiable circuits. An example of the orthogonal partitioning of a hidden weighted bit function that has an O (1:14 n )-sized ROBDD under any possible ordering <ref> [4] </ref> into n O (n 2 )-sized ROBDDs that have pairwise null intersections was given in [11]. While the methods of [11] augment the capabilities of ROBDD manipulation algorithms, methods are not presented that directly manipulate graphs with function vertices. <p> Differences in size between FBDs and ROBDDs using the same global ordering are directly attributable to the function vertices. Most of the examples are from the ISCAS-85 and 89 benchmark set. mm is the min-max function. The example hwb is the hidden weighted bit function described in <ref> [4] </ref>. FBDs for this function can be created with O (n 2 ) size using or vertices, whereas any ROBDD representation has O (1:14 n ) vertices. rotate32 is the function from [7].
Reference: [5] <author> R. Bryant. </author> <title> Free Binary Decision Diagrams. </title> <type> Personal Communication, </type> <month> April </month> <year> 1992. </year>
Reference-contexts: The same construction can be used to obtain an FBD of polynomial-size for this function. The and vertices in FBDs are critical to achieving the exponential reduction in size relative to ROBDDs. In unpublished work <ref> [5] </ref>, Brace and Bryant have generalized the apply algorithm for ROBDDs to work with BDDs that do not have an ordering restriction. However, the variable selection heuristics used in their apply algorithm did not succeed in significantly outperforming ROBDD manipulation algorithms.
Reference: [6] <author> O. Coudert, C. Berthet, and J. C. Madre. </author> <title> Verification of Sequential Machines Using Boolean Functional Vectors. </title> <booktitle> In IMEC-IFIP Int'l Workshop on Applied Formal Methods for Correct VLSI Design, </booktitle> <pages> pages 111-128, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: 1 Introduction The task of representing and manipulating Boolean functions efficiently is central to many different problems in logic synthesis, testing and verification. In recent years, reduced, ordered Binary Decision Diagrams (ROBDDs) [3] have gained widespread use in the areas of combinational and sequential logic verification (e.g. <ref> [6, 13] </ref>) due to their canonicity and ease of manipulation. The efficiency of an ROBDD representation depends strongly on the input ordering. Finding a good ordering is a difficult problem that has received considerable attention (e.g. [13]).
Reference: [7] <author> S. Devadas. </author> <title> Comparing Two-Level and Ordered Binary Decision Diagram Representations of Logic Functions. </title> <booktitle> In IEEE Transactions on Computer-Aided Design, </booktitle> <pages> pages 722-723, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The xor vertices in FBDs are critical to achieving the exponential reduction in size relative to ROBDDs. An example of a function that has an O (n 2 )-sized unordered BDD and an O (2 n 2 )-sized ROBDD under any possible ordering is given in <ref> [7] </ref>. The same construction can be used to obtain an FBD of polynomial-size for this function. The and vertices in FBDs are critical to achieving the exponential reduction in size relative to ROBDDs. <p> The example hwb is the hidden weighted bit function described in [4]. FBDs for this function can be created with O (n 2 ) size using or vertices, whereas any ROBDD representation has O (1:14 n ) vertices. rotate32 is the function from <ref> [7] </ref>. FBDs for this function can be created with O (n 2 ) size using and vertices, whereas any ROBDD representation has O (2 n 2 ) vertices. C2670 and C5315 also benefit significantly from xor vertices.
Reference: [8] <author> S. Fortune, J. Hopcroft, and E. M. Schmidt. </author> <title> The Complexity of Equivalence and Containment for Free Single Variable Program Schemes. </title> <editor> In Goos, Hartmanis, Ausiello and Bohm Eds., </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 62, </volume> <pages> pages 227-240, </pages> <year> 1978. </year>
Reference-contexts: Note that the two subfunctions rooted at the * vertex do not have any common inputs. In the figure, attributed edges are indicated by dots on them. 3.2 Probabilistic Equivalence of FBDs It has been shown that the noncontainment problem for FBDs without function vertices, is NP-complete <ref> [8] </ref>. However Blum, Chandra and Wegman [1] have given a polynomial time algorithm to probabilistically decide the equivalence of two FBDs without and and xor vertices. A brief description of the bottom-up version of the algorithm follows. Let F be an algebraic field with at least 2n elements.
Reference: [9] <author> J. Gergov and C. Meinel. </author> <title> Frontiers of Feasible and Probabilistic Feasible Boolean Manipulation With Branching Programs. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 665 </volume> <pages> 576-585, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: Our main contribution is the development of probabilistic algorithms for the construction and manipulation of FBDs based upon the fundamental result of Blum, Chandra and Wegman [1], and the recent result of Gergov and Meinel <ref> [9] </ref>. The FBDs presented here are not canonical but are a more powerful representation than ROBDDs because of the augmentations mentioned above. FBDs allow for different orderings along different paths from the root to a terminal vertex. <p> However, the method allows for the introduction and retainment of function vertices in the resulting FBD. As with the strongly canonical form for ROBDDs [2], during the and operation on FBDs we can ensure a reduced result. Using the theory of Gergov and Meinel <ref> [9] </ref>, the xor operation on two FBDs can be computed trivially. We use attributed edges to complement FBDs. Probabilistic cofactor, complement, and, and xor form a complete set of algorithms for FBD manipulation that can be used to directly construct an FBD from a multilevel circuit. <p> Two multilevel circuits can be probabilistically checked for equivalence by constructing their respective FBDs and comparing their signatures. 2 Related work is described in Section 2. In Section 3 we give the terminology and review the equivalence checking methods of [1] and <ref> [9] </ref> that form the basis for Boolean operations on FBDs. The weakly canonical form for FBDs is presented in Section 4. We describe the implementation of cofactor, xor, and and methods in Section 5. Implementation details of the manipulation package are discussed in Section 6. <p> Implementation details of the manipulation package are discussed in Section 6. Results obtained from using this package are given in Section 7. 2 Previous Work in Probabilistic Manipulation The work of Blum, Chandra and Wegman [1] and that of Gergov and Meinel <ref> [9] </ref> upon which our probabilistic manipulation algorithms are based will be described in Section 3. Semi-numeric Binary Decision Diagrams in [11], used the theory of Blum, Chandra and Wegman [1] as a means for probabilistic verification of previously unverifiable circuits. <p> Further, by increasing the cardinality of S the error probability for a single run can be reduced significantly. 3.3 xor Vertices Gergov and Meinel <ref> [9] </ref> have extended the the equivalence algorithm of [1] to include function vertices that correspond to parity functions, i.e., xor vertices. We describe their method below.
Reference: [10] <author> J. Gergov and C. Meinel. Mod-2-OBDD's: </author> <title> A Generalization of OBDD's and EXOR-Sum-of-Products. </title> <booktitle> In Proceedings of the IFIP Workshop on Applications of the Reed-Muller Expansion in Circuit Design, </booktitle> <year> 1993. </year>
Reference-contexts: While the methods of [11] augment the capabilities of ROBDD manipulation algorithms, methods are not presented that directly manipulate graphs with function vertices. We note here that Gergov and Meinel showed that polynomial-sized MOD-2-OBDDs can represent the hidden-weighted bit function <ref> [10] </ref>. The same construction can be used to show that polynomial-sized FBDs can represent the hidden-weighted bit function. The xor vertices in FBDs are critical to achieving the exponential reduction in size relative to ROBDDs.
Reference: [11] <author> J. Jain, J. Bitner, D. Fussell, and J. Abraham. </author> <title> Probabilistic Verification of Boolean Functions. In Formal Methods in System Design: </title> <journal> An International Journal, </journal> <volume> volume 1, </volume> <pages> pages 63-118, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Semi-numeric Binary Decision Diagrams in <ref> [11] </ref>, used the theory of Blum, Chandra and Wegman [1] as a means for probabilistic verification of previously unverifiable circuits. <p> An example of the orthogonal partitioning of a hidden weighted bit function that has an O (1:14 n )-sized ROBDD under any possible ordering [4] into n O (n 2 )-sized ROBDDs that have pairwise null intersections was given in <ref> [11] </ref>. While the methods of [11] augment the capabilities of ROBDD manipulation algorithms, methods are not presented that directly manipulate graphs with function vertices. We note here that Gergov and Meinel showed that polynomial-sized MOD-2-OBDDs can represent the hidden-weighted bit function [10]. <p> An example of the orthogonal partitioning of a hidden weighted bit function that has an O (1:14 n )-sized ROBDD under any possible ordering [4] into n O (n 2 )-sized ROBDDs that have pairwise null intersections was given in <ref> [11] </ref>. While the methods of [11] augment the capabilities of ROBDD manipulation algorithms, methods are not presented that directly manipulate graphs with function vertices. We note here that Gergov and Meinel showed that polynomial-sized MOD-2-OBDDs can represent the hidden-weighted bit function [10]. <p> If G 1 and G 2 are not equivalent, then jG 1 j is not equal to jG 2 j with a probability of &gt; 1 2 . It was further shown in <ref> [11] </ref> that the probability of error associated with the probabilistic equivalence check is less than ( n jSj ) k , where k is the number of "runs". <p> The upper bound on the error probability for the circuits is given by ( n jSj ) k fi num ut hits, the error probability for the equivalence check times the number of unique table hits <ref> [11] </ref>. In the above examples, we used a field size of jSj = 2 16 and 4 passes.
Reference: [12] <author> R. Lidl and H. Niederreiter. </author> <title> Finite Fields. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: We describe their method below. A primitive polynomial of degree m and characteristic 2 can be used to generate a Galois Field with 2 m elements GF (2 m ) <ref> [12] </ref>. Arithmetic in a finite field of characteristic 2 is essentially mod 2 arithmetic. Therefore, for any element a 2 GF (2 m ), a + a 0, where 0 is the identity element. <p> The signatures in the figure are shown as polynomials, but the polynomials are represented by binary numbers in the implementation. For more details regarding arithmetic on finite fields the reader is referred to <ref> [12] </ref>. 6.2 FBD Structures Each vertex in an FBD is associated with an FBD vertex structure. An FBD vertex (also called a node) has forward pointers only, one to the low child vertex and one to the high child vertex.
Reference: [13] <author> S. Malik, A. R. Wang, R. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Logic Verification using Binary Decision Diagrams in a Logic Synthesis Environment. </title> <booktitle> In Proceedings of the Int'l Conference on Computer-Aided Design, </booktitle> <pages> pages 6-9, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: 1 Introduction The task of representing and manipulating Boolean functions efficiently is central to many different problems in logic synthesis, testing and verification. In recent years, reduced, ordered Binary Decision Diagrams (ROBDDs) [3] have gained widespread use in the areas of combinational and sequential logic verification (e.g. <ref> [6, 13] </ref>) due to their canonicity and ease of manipulation. The efficiency of an ROBDD representation depends strongly on the input ordering. Finding a good ordering is a difficult problem that has received considerable attention (e.g. [13]). <p> The efficiency of an ROBDD representation depends strongly on the input ordering. Finding a good ordering is a difficult problem that has received considerable attention (e.g. <ref> [13] </ref>). However, there are classes of combinational circuits, notably multipliers, for which ROBDDs, under any possible input ordering, have a provably exponential size [4]. There have been efforts to increase the power of the ROBDD representation, while trading off canonicity or ease of manipulation.
Reference: [14] <author> R. Rudell. </author> <title> Dynamic Variable Ordering in Ordered Binary Decision Diagrams . In Proceedings of the Int'l Conference on Computer-Aided Design, </title> <month> November </month> <year> 1993. </year>
Reference-contexts: However, in order to retain the efficiency of ROBDD manipulation methods the FBD algorithms currently require a good global input ordering. Ongoing work includes the development of dynamic variable selection methods during the and operation, the incorporation of dynamic re-ordering as in <ref> [14] </ref>, and application to sequential logic verification. 9 Acknowledgements Thanks to Randy Bryant and Richard Rudell for discussions regarding free Boolean Diagram construction. Thanks to Jordan Gergov and Christoph Meinel for bringing -BP1s and MOD-2-OBDDs to our attention.
Reference: [15] <author> E. M. Sentovich, K. J. Singh, C. Moon, H. Savoj, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Sequential Circuit Design Using Synthesis and Optimization. </title> <booktitle> In Proceedings of the Int'l Conference on Computer Design: VLSI in Computers and Processors, </booktitle> <pages> pages 328-333, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In most cases the same global ordering for all outputs was given to the FBD package and the ROBDD package implemented in the program sis <ref> [15] </ref>. Examples marked with an asterisk required different orderings for different outputs to create BDDs. For these examples, any further manipulation of the output BDDs requires the FBD package. All CPU times are reported in seconds on a SPARCstation 10.

References-found: 15

