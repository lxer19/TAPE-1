URL: ftp://ftp.ics.hawaii.edu/pub/tr/ics-tr-95-15.ps.Z
Refering-URL: ftp://ftp.ics.hawaii.edu/pub/tr/INDEX.html
Root-URL: 
Email: corbett@hawaii.edu  
Title: Constructing Abstract Models of Concurrent Real-Time Software  
Author: James C. Corbett 
Address: Manoa  
Affiliation: Department of Information and Computer Science University of Hawai'i at  
Abstract: Concurrent real-time software is used in many safety-critical applications. Assuring the quality of such software requires the use of formal methods. Before a program can be analyzed formally, however, we must construct a mathematical model that captures the aspects of the program we want to verify. In this paper, we show how to construct mathematical models of concurrent real-time software that are suitable for analyzing the program's timing properties. Our approach differs from schedulability analysis in that we do not assume that the software has a highly restricted structure (e.g., a set of periodic tasks). Also, unlike most more abstract models of real-time systems, we account for essential properties of real implementations, such as resource constraints and run-time overhead. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, C. Courcoubetis, N. Halbwachs, T. Hen-zinger, P. Ho, X. Nicollin, A. Olivero, J. Sifakis, and S. Yovine. </author> <title> The algorithmic analysis of hybrid systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 138 </volume> <pages> 3-34, </pages> <year> 1995. </year>
Reference-contexts: In a continuous time model, we could represent this region with a millisecond delay in the real interval [1027; 1937]. By changing the time unit to seconds and sacrificing some accuracy, we could instead represent the code region using a second delay in the real interval <ref> [1; 2] </ref>. Note that both of these representations are conservative abstractionsevery program behavior is represented. <p> t 0 2 [L a ; U a ], t 1 2 [L c ; U c ], t 2 2 [L b ; U b ]. 3 Model In this section, we formally define the model of Section 2 as a special type of constant slope linear hybrid automaton <ref> [1] </ref> in which each edge has an associated priority used to reason about preemption. Hybrid automata combine a finite-state control with a set of real-valued variables. <p> The values of the variables change continuously while the automaton remains at a control location, and may change discretely with an instantaneous transition from one control location to another. Here we use the more standard notation and terminology of <ref> [1] </ref> to define the model from [4]. We 2 The difference between activities a and at is purely technical. <p> : : : ; ` 0 n )) 2 Edg iff there exist e i = (` i ; a i ; i ; R i ; p i ; ` 0 i ) 2 Edg i for i = 1; : : : ; n such that 3 In <ref> [1] </ref>, activities are functions f : R 0 ! V . <p> abstraction of the program if every execution is represented by a run (note that not every run must represent an execution). 3.6 Analysis Once a program is represented as a hybrid automaton, this automaton can be analyzed automatically using either the path-based procedure of [4] or the fixpoint-based procedure of <ref> [1] </ref>.
Reference: [2] <author> R. Alur and D. Dill. </author> <title> Automata for modeling real-time systems. </title> <booktitle> In Proc. 17th Int. Colloq. </booktitle> <address> Aut. Lang. Prog., </address> <year> 1990. </year>
Reference-contexts: In a continuous time model, we could represent this region with a millisecond delay in the real interval [1027; 1937]. By changing the time unit to seconds and sacrificing some accuracy, we could instead represent the code region using a second delay in the real interval <ref> [1; 2] </ref>. Note that both of these representations are conservative abstractionsevery program behavior is represented.
Reference: [3] <author> B. Berthomieu and M. Diaz. </author> <title> Modeling and verification of time dependent systems using time Petri nets. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17 </volume> <pages> 259-273, </pages> <year> 1991. </year>
Reference: [4] <author> J. C. Corbett. </author> <title> Modeling and analysis of real-time Ada tasking programs. </title> <booktitle> In Ramamritham [15], </booktitle> <pages> pages 132-141. </pages>
Reference-contexts: In particular, we describe how a form of hybrid automaton from <ref> [4] </ref> can be used to capture all behaviors of a concurrent real-time Ada program and account for the overhead of thread synchronization, timer services, context switches, atomic code segments, and interrupts. <p> This paper is organized as follows. Section 2 uses a discussion of the issues in representing concurrent real-time software to introduce the model from <ref> [4] </ref>, which is then formally defined in Section 3. Section 4 discusses how the various kinds of run-time overhead can be accounted for in this context. Finally, Section 5 concludes. 2 Representation In this section, we introduce our model informally by discussing the basic issues in representing concurrent real-time programs. <p> The values of the variables change continuously while the automaton remains at a control location, and may change discretely with an instantaneous transition from one control location to another. Here we use the more standard notation and terminology of [1] to define the model from <ref> [4] </ref>. We 2 The difference between activities a and at is purely technical. <p> The PHA is a conservative abstraction of the program if every execution is represented by a run (note that not every run must represent an execution). 3.6 Analysis Once a program is represented as a hybrid automaton, this automaton can be analyzed automatically using either the path-based procedure of <ref> [4] </ref> or the fixpoint-based procedure of [1]. The feasibility of this approach is demonstrated in [4], which presents an automated analysis of a small but complex Ada program. 4 Overhead Given the basic representation of concurrent programs described in Section 2, we now consider how various common sources of run-time overhead <p> by a run (note that not every run must represent an execution). 3.6 Analysis Once a program is represented as a hybrid automaton, this automaton can be analyzed automatically using either the path-based procedure of <ref> [4] </ref> or the fixpoint-based procedure of [1]. The feasibility of this approach is demonstrated in [4], which presents an automated analysis of a small but complex Ada program. 4 Overhead Given the basic representation of concurrent programs described in Section 2, we now consider how various common sources of run-time overhead can be accounted for in this context. <p> Although smaller PHAs are not necessarily easier to analyze, our experience <ref> [4] </ref> suggests that keeping the number of control locations and transitions to a minimum is critical for a tractable analysis. We are currently investigating the extension of this work to multiprocessor resource constraints and the representation of the Ada 95 synchronization constructs.
Reference: [5] <author> A. N. Fredette and R. Cleaveland. RTSL: </author> <title> a formal language for real-time schedulability analysis. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <pages> pages 274-283, </pages> <year> 1993. </year>
Reference-contexts: In practice, schedulability analysis [10] is used to guarantee real-time requirements for programs comprising highly structured units of computation with limited interaction (e.g., periodic tasks with precedence constraints). Formal models for more general concurrent systems include timed Petri nets [3,7], timed automata [2,13], timed process algebras <ref> [5, 6, 16] </ref>, and real-time logics [8, 11]. These models, however, are intended for analysis of specifications, not implementations. As such, they do not address the difficult issues that arise in representing real software.
Reference: [6] <author> R. Gerber and I. Lee. </author> <title> A layered approach to automating the verification of real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 18(9) </volume> <pages> 768-784, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: In practice, schedulability analysis [10] is used to guarantee real-time requirements for programs comprising highly structured units of computation with limited interaction (e.g., periodic tasks with precedence constraints). Formal models for more general concurrent systems include timed Petri nets [3,7], timed automata [2,13], timed process algebras <ref> [5, 6, 16] </ref>, and real-time logics [8, 11]. These models, however, are intended for analysis of specifications, not implementations. As such, they do not address the difficult issues that arise in representing real software.
Reference: [7] <author> C. Ghezzi, D. Mandriolli, S. Morasca, and M. Pezze. </author> <title> A unified high-level Petri net model for time-critical systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(2), </volume> <month> Feb. </month> <year> 1991. </year>
Reference: [8] <author> C. Ghezzi, D. Mandriolli, and A. Morzenti. </author> <title> Trio: A logic language for executable specifications of real-time systems. </title> <journal> Journal of Systems and Software, </journal> <volume> 12(2) </volume> <pages> 107-123, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Formal models for more general concurrent systems include timed Petri nets [3,7], timed automata [2,13], timed process algebras [5, 6, 16], and real-time logics <ref> [8, 11] </ref>. These models, however, are intended for analysis of specifications, not implementations. As such, they do not address the difficult issues that arise in representing real software. For example, resource constraints are absent in most of these models and are awkward to represent within them.
Reference: [9] <author> E. W. Giering and T. P. Baker. </author> <title> The Gnu Ada run-time library (GNARL): </title> <booktitle> Design and implementation. In Proceedings of the Eleventh Annual Washington Ada Symposium and Summer ACM SIGAda Meeting (WAdaS '94), </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Some of the implementation de-tails we consider are compiler dependent; our discussion is based on GNARL <ref> [9] </ref>, the run-time system for the GNU Ada compiler (GNAT). We selected GNAT since the source code of both GNARL and the POSIX thread library over which it is implemented is freely available. <p> For timing analysis, however, we must consider how such constructs are implemented over the primitives provided by the operating system, and in particular, capture when the threads involved are blocked. We use the implementation of rendezvous in GNARL <ref> [9] </ref> to illustrate the principles involved in building an abstract model of such constructs.
Reference: [10] <author> M. G. Harbour, M. H. Klein, and J. P. Lehoczky. </author> <title> Timing analysis for fixed-priority scheduling of hard real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 20(1) </volume> <pages> 13-28, </pages> <year> 1994. </year>
Reference-contexts: Timing analysis of concurrent software, however, is far less developed. In practice, schedulability analysis <ref> [10] </ref> is used to guarantee real-time requirements for programs comprising highly structured units of computation with limited interaction (e.g., periodic tasks with precedence constraints). Formal models for more general concurrent systems include timed Petri nets [3,7], timed automata [2,13], timed process algebras [5, 6, 16], and real-time logics [8, 11].
Reference: [11] <author> F. Jahanian and A. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 12(5) </volume> <pages> 890-904, </pages> <year> 1986. </year>
Reference-contexts: Formal models for more general concurrent systems include timed Petri nets [3,7], timed automata [2,13], timed process algebras [5, 6, 16], and real-time logics <ref> [8, 11] </ref>. These models, however, are intended for analysis of specifications, not implementations. As such, they do not address the difficult issues that arise in representing real software. For example, resource constraints are absent in most of these models and are awkward to represent within them.
Reference: [12] <author> S. Lim, Y. Bae, G. T. Jang, B. Rhee, S. Min, C. Y. Park, H. Shin, K. Park, and C. S. Kim. </author> <title> An accurate worst case timing analysis technique for RISC processors. </title> <booktitle> In Ramamritham [15], </booktitle> <pages> pages 97-108. </pages>
Reference-contexts: For sequential code, tools to bound the worst case fl This research was supported by National Science Foundation grant CCR-9308067. execution time have already been constructed [14] and some now account for the effects of caching and pipelining <ref> [12] </ref>. Timing analysis of concurrent software, however, is far less developed. In practice, schedulability analysis [10] is used to guarantee real-time requirements for programs comprising highly structured units of computation with limited interaction (e.g., periodic tasks with precedence constraints).
Reference: [13] <author> J. S. Ostroff. </author> <title> Deciding properties of timed transition models. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(2) </volume> <pages> 170-183, </pages> <year> 1990. </year>
Reference: [14] <author> C. Y. Park and A. C. Shaw. </author> <title> Experiments with a program timing tool based on source-level timing schema. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 48-57, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: For sequential code, tools to bound the worst case fl This research was supported by National Science Foundation grant CCR-9308067. execution time have already been constructed <ref> [14] </ref> and some now account for the effects of caching and pipelining [12]. Timing analysis of concurrent software, however, is far less developed. <p> Such non-busy transitions are shown using dotted arrows. The automaton representing the program, formed by composing the automata representing its threads, is also shown. 2.2 Timing Constraints To model the real-time behavior of the program, we add timing constraints to the transitions of our model. Using existing techniques <ref> [14] </ref>, we can derive upper and lower bounds on the execution time of the sequential code region each transition represents. We consider transitions to be instantaneous and model the execution time of a code region with a appropriate delay before its transition.
Reference: [15] <author> K. Ramamritham, </author> <title> editor. </title> <booktitle> Proceedings of the Real-Time Systems Symposium. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> Dec. </month> <year> 1994. </year>
Reference: [16] <author> G. M. Reed and A. W. Roscoe. </author> <title> A timed model for communicating sequential processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 58 </volume> <pages> 249-261, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: In practice, schedulability analysis [10] is used to guarantee real-time requirements for programs comprising highly structured units of computation with limited interaction (e.g., periodic tasks with precedence constraints). Formal models for more general concurrent systems include timed Petri nets [3,7], timed automata [2,13], timed process algebras <ref> [5, 6, 16] </ref>, and real-time logics [8, 11]. These models, however, are intended for analysis of specifications, not implementations. As such, they do not address the difficult issues that arise in representing real software.
Reference: [17] <author> A. C. Shaw. </author> <title> Reasoning about time in higher-level language software. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 15(7) </volume> <pages> 875-889, </pages> <year> 1989. </year>
Reference-contexts: This overhead, though small, must be accounted for in a conservative abstraction. We suggest two ways to do this. First, we could use the technique described in <ref> [17] </ref>, which uses bounds on the interrupt frequency and handler execution time to inflate the upper bounds of all thread code regions.
References-found: 17

