URL: ftp://ftp.cs.uoregon.edu/pub/ariola/popl98.ps
Refering-URL: http://www.cs.uoregon.edu/~ariola/publications.html
Root-URL: http://www.cs.uoregon.edu
Email: ariola@cs.uoregon.edu sabry@cs.uoregon.edu  
Title: Correctness of Monadic State: An Imperative Call-by-Need Calculus language level, constructs that act on the
Author: Zena M. Ariola Amr Sabry 
Note: Semantically, at the source  The  
Address: Eugene, OR 97403  
Affiliation: Department of Computer Information Science University of Oregon  
Abstract: Recently, we have noted that the consistency of the two views is far from obvious: all it takes for the implementation to become unsound is one judiciously-placed beta-step in the optimization phase of the compiler. This discovery motivates the current paper in which we formalize and show the correctness of the implementation of monadic state. For the proof, we first design a typed call-by-need language that models the intermediate language of the compiler, together with a type-preserving compilation map. Second, we show that the compilation is semantics-preserving by proving that the compilation of every source axiom yields an observational equivalence of the target language. Because of the wide semantic gap between the source and target languages, we perform this last step using an additional intermediate language. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ariola, Z. M., and Blom, S. </author> <title> Cyclic lambda calculi. </title> <booktitle> In the International Symposium on Theoretical Aspects of Computer Software, Sendai, </booktitle> <address> Japan (Septem-ber 1997). </address>
Reference-contexts: In this paper, we develop the semantic infrastructure for the intermediate languages used for implementing monadic state and use it to prove the correctness of the efficient implementation of monadic state. The semantics is based on an imperative call-by-need -calculus that extends the pure call-by-need -calculus <ref> [1, 2, 3, 4] </ref> with references to model the intermediate languages of Haskell compilers. The imperative call-by-need -calculus has the following properties. <p> The imperative operations new, read, and write, all expect this token as their first argument. Following the design of the applied call-by-need - calculus <ref> [1, 2, 3, 4] </ref>, we distinguish two kinds of pairs. In contrast to (e 1 ; e 2 ), pairs of the form [e 1 ; e 2 ] are values that can be duplicated. <p> fi - ` k : t k [ fx : t g ` e : t 0 ` e 1 : t ` e 2 : - ` 2 : - 4.3 Semantics I: Call-by-Need with Recursion We begin with the semantics of the subset of the language excluding assignments <ref> [1, 2] </ref>. To reduce the number of reductions we use evaluation contexts to abstract some common patterns. <p> ; h2 j D y ; ` = V y i) = ((V; fD; ` = V g)) y Some of the steps use semantic equalities that are not part of the calculus like the collection of unused bindings, and the identification of different representations of the same underlying graph <ref> [1] </ref>. The cases for new and write proceed similarly. 2 7 Imperative Lazy Programming In addition to being the main technical device for proving the correctness of the implementation for monadic state, the imperative call-by-need -calculus is useful in its own right. <p> It is now easy to use the axioms to calculate that the expression (f () + f ()) reduces to 1+2=3. 8 Related Work Our work builds directly on Ariola et al.'s call-by-need calculi <ref> [1, 4] </ref>, the encapsulation and implementation of monadic state by Launchbury and Peyton Jones [18, 19], and the axiomatization of monadic state by Launchbury and Sabry [20].
Reference: [2] <author> Ariola, Z. M., and Blom, S. </author> <title> Lambda calculi plus letrec. </title> <type> Tech. Rep. </type> <institution> CIS-TR-97-05, Dept. of Computer and Information Science, University of Oregon, </institution> <year> 1997. </year>
Reference-contexts: In this paper, we develop the semantic infrastructure for the intermediate languages used for implementing monadic state and use it to prove the correctness of the efficient implementation of monadic state. The semantics is based on an imperative call-by-need -calculus that extends the pure call-by-need -calculus <ref> [1, 2, 3, 4] </ref> with references to model the intermediate languages of Haskell compilers. The imperative call-by-need -calculus has the following properties. <p> The imperative operations new, read, and write, all expect this token as their first argument. Following the design of the applied call-by-need - calculus <ref> [1, 2, 3, 4] </ref>, we distinguish two kinds of pairs. In contrast to (e 1 ; e 2 ), pairs of the form [e 1 ; e 2 ] are values that can be duplicated. <p> fi - ` k : t k [ fx : t g ` e : t 0 ` e 1 : t ` e 2 : - ` 2 : - 4.3 Semantics I: Call-by-Need with Recursion We begin with the semantics of the subset of the language excluding assignments <ref> [1, 2] </ref>. To reduce the number of reductions we use evaluation contexts to abstract some common patterns. <p> (# n ) = e; d 1 ; d 2 i Reductions for Pairs: (e 1 ; e 2 ) ! h [x; y] j x = e 1 ; y = e 2 i snd [e 1 ; e 2 ] ! e 2 new 2 e ! h <ref> [`; 2] </ref> j ` = ei hE [read 2 `] j ` = v; di ! hE [[v; 2]] j ` = v; di hE [write 2 ` e 1 ] j ` = e 2 ; di ! hE [[(); 2]] j ` = e 1 ; di hE [#] <p> e 2 ) ! h [x; y] j x = e 1 ; y = e 2 i snd [e 1 ; e 2 ] ! e 2 new 2 e ! h [`; 2] j ` = ei hE [read 2 `] j ` = v; di ! hE <ref> [[v; 2] </ref>] j ` = v; di hE [write 2 ` e 1 ] j ` = e 2 ; di ! hE [[(); 2]] j ` = e 1 ; di hE [#] j var (#) = E 1 [# 1 ]; : : : ; var (# n ) <p> 2 ] ! e 2 new 2 e ! h [`; 2] j ` = ei hE [read 2 `] j ` = v; di ! hE [[v; 2]] j ` = v; di hE [write 2 ` e 1 ] j ` = e 2 ; di ! hE <ref> [[(); 2] </ref>] j ` = e 1 ; di hE [#] j var (#) = E 1 [# 1 ]; : : : ; var (# n ) = E n [read 2 `]; ` = v; di ! hE [#] j var (#) = E 1 [# 1 ]; : <p> j var (#) = E 1 [# 1 ]; : : : ; var (# n ) = E n [read 2 `]; ` = v; di ! hE [#] j var (#) = E 1 [# 1 ]; : : : ; var (# n ) = E n <ref> [[v; 2] </ref>]; ` = v; di hE [#] j var (#) = E 1 [# 1 ]; : : : ; var (# n ) = E n [write 2 ` e 1 ]; ` = e 2 ; di ! hE [#] j var (#) = E 1 [# 1 <p> 1 [# 1 ]; : : : ; var (# n ) = E n [write 2 ` e 1 ]; ` = e 2 ; di ! hE [#] j var (#) = E 1 [# 1 ]; : : : ; var (# n ) = E n <ref> [[(); 2] </ref>]; ` = e 1 ; di the enclosing context. Note that in the third rule, the internal box is only flattened when is needed. We will discuss the reasons for this restriction after having introduced the operations on reference cells. <p> A non demanded flattening could disallow a reference operation that would otherwise be possible, as shown in the diagram below: hx:y j y = hread 2 ` j ` = 0ii - hx:y j y = read 2 `; ` = 0i hx:y j y = <ref> [0; 2] </ref>; ` = 0i - ? The flattening is necessary to allow reductions of the form: hy j y = hread 2 ` j di; ` = vi - hy j y = [v; 2]; d; ` = vi At this point, the only thing that we require is that <p> 0ii - hx:y j y = read 2 `; ` = 0i hx:y j y = [0; 2]; ` = 0i - ? The flattening is necessary to allow reductions of the form: hy j y = hread 2 ` j di; ` = vi - hy j y = <ref> [v; 2] </ref>; d; ` = vi At this point, the only thing that we require is that the calculus be consistent. Unfortunately, this calculus turns out to be non-confluent [5]. The culprit is the substitution inside the bindings of a box, which is essential in a call-by-need setting. <p> Theorem 11 The imperative call-by-need lambda-calculus has unique infinite normal forms. Proof. The result for the pure part of the calculus is shown in <ref> [2] </ref>. Since the reference rules commute with the other rules, the result for the full calculus constitutes an easy extension of the previous result. 2 5 Compilation Having set up the source and target languages, we formalize the compilation map. <p> The same holds in the other direction. This guarantees that the infinite normal form does not change. The SPS ? -name calculus without reference operations corresponds to the cyclic call-by-name evaluation calculus <ref> [2] </ref>, and hence we can use a technique similar to the one we previously used to prove that sharing preserves infinite normal forms. 2 Since the notion of infinite normal form defines a congruence on the set of terms, we have as a corollary of the previous theorem that SPS-need is <p> V y ii = hread x ` j x = 2; D y ; ` = V y i = hread 2 ` j x = 2; D y ; ` = V y i = hread 2 ` j D y ; ` = V y i = h <ref> [V y ; 2] </ref> j D y ; ` = V y i = (V y ; h2 j D y ; ` = V y i) = ((V; fD; ` = V g)) y Some of the steps use semantic equalities that are not part of the calculus like the
Reference: [3] <author> Ariola, Z. M., and Felleisen, M. </author> <title> The call-by-need lambda calculus. </title> <journal> Journal of Functional Programming 7, </journal> <month> 3 </month> <year> (1997). </year>
Reference-contexts: In this paper, we develop the semantic infrastructure for the intermediate languages used for implementing monadic state and use it to prove the correctness of the efficient implementation of monadic state. The semantics is based on an imperative call-by-need -calculus that extends the pure call-by-need -calculus <ref> [1, 2, 3, 4] </ref> with references to model the intermediate languages of Haskell compilers. The imperative call-by-need -calculus has the following properties. <p> The imperative operations new, read, and write, all expect this token as their first argument. Following the design of the applied call-by-need - calculus <ref> [1, 2, 3, 4] </ref>, we distinguish two kinds of pairs. In contrast to (e 1 ; e 2 ), pairs of the form [e 1 ; e 2 ] are values that can be duplicated. <p> Unfortunately, this calculus turns out to be non-confluent [5]. The culprit is the substitution inside the bindings of a box, which is essential in a call-by-need setting. One solution is to restrict this rule to evaluation contexts <ref> [3] </ref>.
Reference: [4] <author> Ariola, Z. M., Felleisen, M., Maraist, J., Oder-sky, M., and Wadler, P. </author> <title> A call-by-need lambda calculus. </title> <booktitle> In the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (1995), </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <pages> pp. 233-246. </pages>
Reference-contexts: In this paper, we develop the semantic infrastructure for the intermediate languages used for implementing monadic state and use it to prove the correctness of the efficient implementation of monadic state. The semantics is based on an imperative call-by-need -calculus that extends the pure call-by-need -calculus <ref> [1, 2, 3, 4] </ref> with references to model the intermediate languages of Haskell compilers. The imperative call-by-need -calculus has the following properties. <p> The imperative operations new, read, and write, all expect this token as their first argument. Following the design of the applied call-by-need - calculus <ref> [1, 2, 3, 4] </ref>, we distinguish two kinds of pairs. In contrast to (e 1 ; e 2 ), pairs of the form [e 1 ; e 2 ] are values that can be duplicated. <p> It is now easy to use the axioms to calculate that the expression (f () + f ()) reduces to 1+2=3. 8 Related Work Our work builds directly on Ariola et al.'s call-by-need calculi <ref> [1, 4] </ref>, the encapsulation and implementation of monadic state by Launchbury and Peyton Jones [18, 19], and the axiomatization of monadic state by Launchbury and Sabry [20].
Reference: [5] <author> Ariola, Z. M., and Klop, J. W. </author> <title> Lambda calculus with explicit recursion. </title> <type> Tech. Rep. </type> <institution> CIS-TR-96-04, Dept. of Computer and Information Science, University of Oregon, </institution> <year> 1996. </year> <note> To appear in Inf. Comp.. </note>
Reference-contexts: Unfortunately, this calculus turns out to be non-confluent <ref> [5] </ref>. The culprit is the substitution inside the bindings of a box, which is essential in a call-by-need setting. One solution is to restrict this rule to evaluation contexts [3].
Reference: [6] <author> Augustsson, L., Rittri, M., and Synek, D. </author> <title> Functional pearl: On generating unique names. </title> <journal> Journal of Functional Programming 4, </journal> <month> 1 (Jan. </month> <year> 1994), </year> <month> 117-123. </month> <title> Original version: Splitting Infinite Sets of Unique Names by Hidden State Changes, </title> <type> Tech. Rep. 67, </type> <institution> Programming Methodology Group, Chalmers University of Technology, </institution> <year> 1992. </year>
Reference-contexts: Like many system-level Haskell programs, the implementation of memo functions relies on expressions with side-effects [9, 16]. Since Haskell bans such expressions, programmers that need this functionality either write low-level routines in C or in an ad hoc variant of Haskell that integrates computational effects with the call-by-need semantics <ref> [6] </ref>. Not only does the imperative call-by-need -calculus let programmers express such services as suggested above, but also it provides the infrastructure to reason about the cor rectness and properties of such services.
Reference: [7] <author> Cartwright, R., and Felleisen, M. </author> <title> The semantics of program dependence. </title> <booktitle> In the ACM SIGPLAN Conference on Programming Language Design and Implementation (1989), </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <pages> pp. 13-27. </pages>
Reference-contexts: This intuitive argument can be made precise to provide a formal proof of the type-based encapsulation of monadic state [20]. 2.3 Evaluation Contexts The semantics of the source language can be conveniently specified using a set of reductions. Because of the lazy semantics and lazy store updates <ref> [7, 13, 17] </ref>, the definition of the reductions is intertwined with the definition of evaluation contexts. Therefore, we define evaluation contexts first. These contexts use two auxiliary concepts: return contexts R and dependency chains H.
Reference: [8] <author> Chen, C.-P., and Hudak, P. </author> <title> Rolling your own mutable ADT|A connection between linear types and monads. </title> <booktitle> In the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (15-17 Jan. 1997), </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <pages> pp. 54-66. </pages>
Reference-contexts: The correctness of "updates-in-place" is a long standing problem that has been studied extensively. In the context of monads, a number of researchers <ref> [8, 15, 26, 33, 35] </ref> noted that when the state monad is treated as an abstract data type, it ought to be possible to implement the state operations more efficiently using destructive updates.
Reference: [9] <author> Cook, B., and Launchbury, J. </author> <title> Disposable memo functions. </title> <booktitle> In the ACM SIGPLAN Haskell Workshop (1997). </booktitle>
Reference-contexts: We briefly motivate the additional expressive power of the calculus over pure call-by-need calculi with one example. Like many system-level Haskell programs, the implementation of memo functions relies on expressions with side-effects <ref> [9, 16] </ref>. Since Haskell bans such expressions, programmers that need this functionality either write low-level routines in C or in an ad hoc variant of Haskell that integrates computational effects with the call-by-need semantics [6].
Reference: [10] <author> Crank, E. </author> <title> Parameter-passing and the lambda calculus. </title> <type> Master's thesis, </type> <institution> Dept. of Computer Science, Rice University, </institution> <year> 1990. </year>
Reference-contexts: The imperative call-by-need -calculus has the following properties. It is expressed using a set of local program transformations in the style of Felleisen and Hieb's v -S-calculus [12] and Crank's theories for parameter-passing in the -calculus <ref> [10, 11] </ref>. As expected some observational equivalences that held between pure call-by-need terms (e.g., fi) are no longer valid in the presence of assignments.
Reference: [11] <author> Crank, E., and Felleisen, M. </author> <title> Parameter-passing and the lambda calculus. </title> <booktitle> In the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (1991), </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <pages> pp. 233-244. </pages>
Reference-contexts: The imperative call-by-need -calculus has the following properties. It is expressed using a set of local program transformations in the style of Felleisen and Hieb's v -S-calculus [12] and Crank's theories for parameter-passing in the -calculus <ref> [10, 11] </ref>. As expected some observational equivalences that held between pure call-by-need terms (e.g., fi) are no longer valid in the presence of assignments. <p> The imperative call-by-need calculus uses ideas developed in the context of imperative call-by-value calculi <ref> [11, 12, 28] </ref> as well as in the conservative extensions of functional languages with assignments [22, 31]. The correctness of "updates-in-place" is a long standing problem that has been studied extensively.
Reference: [12] <author> Felleisen, M., and Hieb, R. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <type> Theoret. </type> <institution> Comput. Sci. </institution> <month> 102 </month> <year> (1992), </year> <type> 235-271. Tech. Rep. 89-100, </type> <institution> Rice University. </institution>
Reference-contexts: The imperative call-by-need -calculus has the following properties. It is expressed using a set of local program transformations in the style of Felleisen and Hieb's v -S-calculus <ref> [12] </ref> and Crank's theories for parameter-passing in the -calculus [10, 11]. As expected some observational equivalences that held between pure call-by-need terms (e.g., fi) are no longer valid in the presence of assignments. <p> The imperative call-by-need calculus uses ideas developed in the context of imperative call-by-value calculi <ref> [11, 12, 28] </ref> as well as in the conservative extensions of functional languages with assignments [22, 31]. The correctness of "updates-in-place" is a long standing problem that has been studied extensively.
Reference: [13] <author> Field, J. </author> <title> A simple rewriting semantics for realistic imperative programs and its application to program analysis (preliminary report). </title> <type> Tech. Rep. </type> <institution> YALE/DCS/RR-909, Dept. of Computer Science, Yale University, </institution> <year> 1992. </year> <booktitle> ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 98-107. </pages>
Reference-contexts: This intuitive argument can be made precise to provide a formal proof of the type-based encapsulation of monadic state [20]. 2.3 Evaluation Contexts The semantics of the source language can be conveniently specified using a set of reductions. Because of the lazy semantics and lazy store updates <ref> [7, 13, 17] </ref>, the definition of the reductions is intertwined with the definition of evaluation contexts. Therefore, we define evaluation contexts first. These contexts use two auxiliary concepts: return contexts R and dependency chains H.
Reference: [14] <author> Guzm an, J. C., and Hudak, P. </author> <title> Single-threaded polymorphic lambda calculus. </title> <booktitle> In the IEEE Symposium on Logic in Computer Science (1990), </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, Calif., </publisher> <pages> pp. 333-343. </pages>
Reference-contexts: Indeed, other con structs in the language may now interact with the monadic 11 effects in unpredictable ways and we can no longer reason about the implementation of the monadic effects in isolation. The problem of the correctness of "updates-in-place" has been studied in other contexts <ref> [14, 29, 30, 34, 36] </ref>.
Reference: [15] <author> Hudak, P. </author> <title> Mutable abstract datatypes -or- how to have your state and munge it too. </title> <type> Tech. Rep. </type> <institution> YALEU/DCS/RR-914, Dept. of Computer Science, Yale University, </institution> <month> December </month> <year> 1992. </year> <month> Revised May </month> <year> 1993. </year>
Reference-contexts: The correctness of "updates-in-place" is a long standing problem that has been studied extensively. In the context of monads, a number of researchers <ref> [8, 15, 26, 33, 35] </ref> noted that when the state monad is treated as an abstract data type, it ought to be possible to implement the state operations more efficiently using destructive updates.
Reference: [16] <author> Hughes, J. </author> <title> Lazy memo-functions. </title> <type> Tech. Rep. 21, </type> <institution> Programming Methodology Group, Chalmers University of Technology, </institution> <year> 1985. </year>
Reference-contexts: We briefly motivate the additional expressive power of the calculus over pure call-by-need calculi with one example. Like many system-level Haskell programs, the implementation of memo functions relies on expressions with side-effects <ref> [9, 16] </ref>. Since Haskell bans such expressions, programmers that need this functionality either write low-level routines in C or in an ad hoc variant of Haskell that integrates computational effects with the call-by-need semantics [6].
Reference: [17] <author> Launchbury, J. </author> <title> Lazy imperative programming. </title> <type> Tech. Rep. </type> <institution> YALEU/DCS/RR-968, Dept. of Computer Science, Yale University, </institution> <year> 1993. </year> <booktitle> ACM SIGPLAN Workshop on State in Programming Languages. </booktitle>
Reference-contexts: This intuitive argument can be made precise to provide a formal proof of the type-based encapsulation of monadic state [20]. 2.3 Evaluation Contexts The semantics of the source language can be conveniently specified using a set of reductions. Because of the lazy semantics and lazy store updates <ref> [7, 13, 17] </ref>, the definition of the reductions is intertwined with the definition of evaluation contexts. Therefore, we define evaluation contexts first. These contexts use two auxiliary concepts: return contexts R and dependency chains H.
Reference: [18] <author> Launchbury, J., and Peyton Jones, S. L. </author> <title> Lazy functional state threads. </title> <booktitle> In the ACM SIGPLAN Conference on Programming Language Design and Implementation (1994), </booktitle> <pages> pp. 24-35. </pages>
Reference-contexts: It is now easy to use the axioms to calculate that the expression (f () + f ()) reduces to 1+2=3. 8 Related Work Our work builds directly on Ariola et al.'s call-by-need calculi [1, 4], the encapsulation and implementation of monadic state by Launchbury and Peyton Jones <ref> [18, 19] </ref>, and the axiomatization of monadic state by Launchbury and Sabry [20]. The imperative call-by-need calculus uses ideas developed in the context of imperative call-by-value calculi [11, 12, 28] as well as in the conservative extensions of functional languages with assignments [22, 31].
Reference: [19] <author> Launchbury, J., and Peyton Jones, S. L. </author> <title> State in Haskell. Lisp Symbol. </title> <journal> Comput. </journal> <volume> 8 (1995), </volume> <pages> 193-341. </pages>
Reference-contexts: This type-based separation leads to elegant ways of stating and inferring invariants about the code. For example, a standard type system for Haskell, extended with one rule, can track the lifetimes of references and guarantee non-interference among references in several threads <ref> [19, 20] </ref>. Even better, recent results suggest that such an analysis can be performed in the intermediate language of a type-directed SML compiler [24]. By exposing information to the type system, not only can compiler writers perform sophisticated analyses elegantly, but also they can avoid some analyses altogether. <p> For an efficient implementation: * no code should be generated for sequencing assign ments, and * no code should be generated for passing the store. At first sight, such an efficient implementation appears easy to realize, and is indeed implemented in the Glasgow Haskell compiler (ghc) <ref> [19] </ref>. In the intermediate language of the compiler, the monadic combinators are inlined to eliminate the overhead of sequencing assignments, and the store is represented using a global implicit data structure. Unfortunately, the efficient implementation of monadic state is more subtle than it first appears. <p> The evaluation of the expression executes N , returns its value, and discards the final state. The sto construct also encapsulates the state, in the sense that the state is neither accessible nor visible to the outside world <ref> [19, 20] </ref>. 2.2 Types Both the monadic extension to the pure language and the encapsulation of state rely critically on types. Stateful computations can only be generated using the term constructors: ret, &gt;>=, New, Read, and Write. Furthermore, their types are built using a special type constructor ST. <p> The first phase of compilation closely follows the denotational semantics of the source language <ref> [19] </ref>: it reformulates the program in explicit store-passing style. <p> It is now easy to use the axioms to calculate that the expression (f () + f ()) reduces to 1+2=3. 8 Related Work Our work builds directly on Ariola et al.'s call-by-need calculi [1, 4], the encapsulation and implementation of monadic state by Launchbury and Peyton Jones <ref> [18, 19] </ref>, and the axiomatization of monadic state by Launchbury and Sabry [20]. The imperative call-by-need calculus uses ideas developed in the context of imperative call-by-value calculi [11, 12, 28] as well as in the conservative extensions of functional languages with assignments [22, 31].
Reference: [20] <author> Launchbury, J., and Sabry, A. </author> <title> Monadic state: Axiomatization and type safety. </title> <booktitle> In the ACM SIGPLAN International Conference on Functional Programming (1997), </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <pages> pp. 227-238. </pages>
Reference-contexts: This type-based separation leads to elegant ways of stating and inferring invariants about the code. For example, a standard type system for Haskell, extended with one rule, can track the lifetimes of references and guarantee non-interference among references in several threads <ref> [19, 20] </ref>. Even better, recent results suggest that such an analysis can be performed in the intermediate language of a type-directed SML compiler [24]. By exposing information to the type system, not only can compiler writers perform sophisticated analyses elegantly, but also they can avoid some analyses altogether. <p> In the intermediate language of the compiler, the monadic combinators are inlined to eliminate the overhead of sequencing assignments, and the store is represented using a global implicit data structure. Unfortunately, the efficient implementation of monadic state is more subtle than it first appears. We have noted <ref> [20, 27] </ref> that fi-steps are generally unsound in the intermediate language of compilers such as ghc. The unsoundness of fi has several consequences. <p> The evaluation of the expression executes N , returns its value, and discards the final state. The sto construct also encapsulates the state, in the sense that the state is neither accessible nor visible to the outside world <ref> [19, 20] </ref>. 2.2 Types Both the monadic extension to the pure language and the encapsulation of state rely critically on types. Stateful computations can only be generated using the term constructors: ret, &gt;>=, New, Read, and Write. Furthermore, their types are built using a special type constructor ST. <p> This intuitive argument can be made precise to provide a formal proof of the type-based encapsulation of monadic state <ref> [20] </ref>. 2.3 Evaluation Contexts The semantics of the source language can be conveniently specified using a set of reductions. Because of the lazy semantics and lazy store updates [7, 13, 17], the definition of the reductions is intertwined with the definition of evaluation contexts. Therefore, we define evaluation contexts first. <p> In conclusion, fi-steps in particular, and call-by-name reasoning principles in general are incompatible with the implementation strategy described in Subsection 3.2. We were the first to note this problem and have conjectured <ref> [20, 27] </ref> that optimizations based on call-by-need semantics would be sound in the intermediate language of the compiler. Intuitively, call-by-need transformations would not duplicate non-values such as (new 2 0). <p> that the expression (f () + f ()) reduces to 1+2=3. 8 Related Work Our work builds directly on Ariola et al.'s call-by-need calculi [1, 4], the encapsulation and implementation of monadic state by Launchbury and Peyton Jones [18, 19], and the axiomatization of monadic state by Launchbury and Sabry <ref> [20] </ref>. The imperative call-by-need calculus uses ideas developed in the context of imperative call-by-value calculi [11, 12, 28] as well as in the conservative extensions of functional languages with assignments [22, 31]. The correctness of "updates-in-place" is a long standing problem that has been studied extensively.
Reference: [21] <author> L evy, J.-J. </author> <title> Optimal reductions in the lambda-calculus. In To H-.B. </title> <booktitle> Curry: Essays in Combinatory Logic, Lambda Calculus and Formalism (1980), </booktitle> <publisher> Academic Press, </publisher> <pages> pp. 159-291. 12 </pages>
Reference-contexts: Therefore, we prefer to prove consistency by showing unicity of infinite normal forms, also called Bohm trees <ref> [21] </ref>, which are defined as the limit of the chain of observations collected during reduction. Theorem 11 The imperative call-by-need lambda-calculus has unique infinite normal forms. Proof. The result for the pure part of the calculus is shown in [2].
Reference: [22] <author> Odersky, M., Rabin, D., and Hudak, P. </author> <title> Call by name, assignment, and the lambda calculus. </title> <booktitle> In the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (Jan. 1993), </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <pages> pp. 43-56. </pages>
Reference-contexts: The imperative call-by-need calculus uses ideas developed in the context of imperative call-by-value calculi [11, 12, 28] as well as in the conservative extensions of functional languages with assignments <ref> [22, 31] </ref>. The correctness of "updates-in-place" is a long standing problem that has been studied extensively.
Reference: [23] <author> Peyton Jones, S., and Launchbury, J. </author> <title> Unboxed values as first class citizens. </title> <booktitle> In the Conference on Functional Programming and Computer Architecture (Sept. </booktitle> <year> 1991), </year> <editor> Hughes, Ed., </editor> <volume> vol. </volume> <booktitle> 523 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, Berlin, </publisher> <pages> pp. 636-646. </pages>
Reference-contexts: The solution to the problem is to treat the type as an unboxed type, and to restrict type variables not to range over unboxed types <ref> [23] </ref>. 3.6 Recursion Since the use of assignments can easily create cyclic structures, a proper handling of recursion is a prerequisite to handling state. The source language has two constructs for recursion: let and sto.
Reference: [24] <author> Peyton Jones, S., Launchbury, J., Shields, M., and Tolmach, A. </author> <title> Bridging the gulf: A common intermediate language for ML and Haskell. </title> <booktitle> In the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (1998), </booktitle> <publisher> ACM Press, </publisher> <address> New York. </address> <note> To appear. </note>
Reference-contexts: For example, a standard type system for Haskell, extended with one rule, can track the lifetimes of references and guarantee non-interference among references in several threads [19, 20]. Even better, recent results suggest that such an analysis can be performed in the intermediate language of a type-directed SML compiler <ref> [24] </ref>. By exposing information to the type system, not only can compiler writers perform sophisticated analyses elegantly, but also they can avoid some analyses altogether.
Reference: [25] <editor> Peyton Jones, S. L. </editor> <booktitle> The Implementation of Functional Programming Languages. International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Intuitively, call-by-need transformations would not duplicate non-values such as (new 2 0). Fortunately, even before the monadic extensions, compilers such as ghc were careful not to duplicate work and hence refrained from using fi steps for performance reasons <ref> [25] </ref>. Consequently, the addition of assignments to the back end did not cause any immediate problems. However, this non-duplication is not a mere optimization issue, but an essential correctness issue. 3.4 Demanding Values vs.
Reference: [26] <author> Peyton Jones, S. L., and Wadler, P. </author> <title> Imperative functional programming. </title> <booktitle> In the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (1993), </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <pages> pp. 71-84. </pages>
Reference-contexts: The correctness of "updates-in-place" is a long standing problem that has been studied extensively. In the context of monads, a number of researchers <ref> [8, 15, 26, 33, 35] </ref> noted that when the state monad is treated as an abstract data type, it ought to be possible to implement the state operations more efficiently using destructive updates.
Reference: [27] <author> Sabry, A. </author> <title> What is a purely functional language? Journal of Functional Programming (1997). </title> <note> To appear. </note>
Reference-contexts: In the intermediate language of the compiler, the monadic combinators are inlined to eliminate the overhead of sequencing assignments, and the store is represented using a global implicit data structure. Unfortunately, the efficient implementation of monadic state is more subtle than it first appears. We have noted <ref> [20, 27] </ref> that fi-steps are generally unsound in the intermediate language of compilers such as ghc. The unsoundness of fi has several consequences. <p> In conclusion, fi-steps in particular, and call-by-name reasoning principles in general are incompatible with the implementation strategy described in Subsection 3.2. We were the first to note this problem and have conjectured <ref> [20, 27] </ref> that optimizations based on call-by-need semantics would be sound in the intermediate language of the compiler. Intuitively, call-by-need transformations would not duplicate non-values such as (new 2 0). <p> M j read L M j write L M N V ::= K j x:M j ` j f` i = W i g j [M; N ] D ::= ` i = M i Being a pure language, the semantics of SPS should be indifferent to the parameter-passing mechanism <ref> [27] </ref>. Indeed we will develop a call-by-name semantics and a call-by-need semantics, and show their equivalence. The call-by-name semantics is in Figure 7. Note that the location returned by the new operator is uniquely determined from D.
Reference: [28] <author> Sabry, A., and Field, J. </author> <title> Reasoning about explicit and implicit representations of state. </title> <type> Tech. Rep. </type> <institution> YALEU/DCS/RR-968, Dept. of Computer Science, Yale University, </institution> <year> 1993. </year> <booktitle> ACM SIGPLAN Workshop on State in Programming Languages, </booktitle> <pages> pages 17-30. </pages>
Reference-contexts: The imperative call-by-need calculus uses ideas developed in the context of imperative call-by-value calculi <ref> [11, 12, 28] </ref> as well as in the conservative extensions of functional languages with assignments [22, 31]. The correctness of "updates-in-place" is a long standing problem that has been studied extensively.
Reference: [29] <author> Schmidt, D. A. </author> <title> Detecting global variables in denota-tional specifications. </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 7, </volume> <month> 2 (Apr. </month> <year> 1985), </year> <pages> 299-310. </pages>
Reference-contexts: Indeed, other con structs in the language may now interact with the monadic 11 effects in unpredictable ways and we can no longer reason about the implementation of the monadic effects in isolation. The problem of the correctness of "updates-in-place" has been studied in other contexts <ref> [14, 29, 30, 34, 36] </ref>.
Reference: [30] <author> Sestoft, P. </author> <title> Replacing function parameters by global variables. </title> <booktitle> In the Conference on Functional Programming and Computer Architecture (1989). </booktitle>
Reference-contexts: Indeed, other con structs in the language may now interact with the monadic 11 effects in unpredictable ways and we can no longer reason about the implementation of the monadic effects in isolation. The problem of the correctness of "updates-in-place" has been studied in other contexts <ref> [14, 29, 30, 34, 36] </ref>. <p> The problem of the correctness of "updates-in-place" has been studied in other contexts [14, 29, 30, 34, 36]. We have not yet explored the detailed connections with linear logic but it appears that the path semantics used by Sestoft <ref> [30] </ref> in a call-by-value context does not easily extend to the call-by-need world. 9 Conclusion and Future Work We have formalized the implementation of monadic state using a typed imperative call-by-need language and a type-preserving compilation map.
Reference: [31] <author> Swarup, V., Reddy, U., and Ireland, E. </author> <title> Assignments for applicative languages. </title> <booktitle> In the Conference on Functional Programming and Computer Architecture (1991), </booktitle> <pages> pp. 192-214. </pages>
Reference-contexts: The imperative call-by-need calculus uses ideas developed in the context of imperative call-by-value calculi [11, 12, 28] as well as in the conservative extensions of functional languages with assignments <ref> [22, 31] </ref>. The correctness of "updates-in-place" is a long standing problem that has been studied extensively.
Reference: [32] <author> Tarditi, D., Morrisett, G., Cheng, P., Stone, C., Harper, R., and Lee, P. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In the ACM SIGPLAN Conference on Programming Language Design and Implementation (1996), </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <pages> pp. 181-192. </pages>
Reference-contexts: By exposing information to the type system, not only can compiler writers perform sophisticated analyses elegantly, but also they can avoid some analyses altogether. For example, before eliminating common subexpressions, the TIL compiler <ref> [32] </ref> must guarantee that the subexpressions have no side-effects using either a weak syntactic check or a sophisticated and complicated analysis. In the presence of monadic state, the type system provides the advantages of the sophisticated analysis without its complexity as the types automatically distinguish semantic values from computations.
Reference: [33] <author> Wadler, P. </author> <title> Comprehending monads. </title> <booktitle> In the ACM Conference on Lisp and Functional Programming (1990), </booktitle> <pages> pp. 61-78. </pages>
Reference-contexts: The correctness of "updates-in-place" is a long standing problem that has been studied extensively. In the context of monads, a number of researchers <ref> [8, 15, 26, 33, 35] </ref> noted that when the state monad is treated as an abstract data type, it ought to be possible to implement the state operations more efficiently using destructive updates. <p> For example, Wadler states: The abstract data type for ST guarantees that it is safe to perform updates (indicated by as sign) in place no special analysis technique is required <ref> [33, p.70] </ref>. However, in an implementation like ghc, the monad com-binators are eventually expressed using more primitive operations (see the compilation map in Figure 6).
Reference: [34] <author> Wadler, P. </author> <title> Is there a use for linear logic. </title> <booktitle> In the Symposium on Partial Evaluation and Semantics-Based Program Manipulation (1991), </booktitle> <publisher> ACM Press, </publisher> <address> New York. </address>
Reference-contexts: Indeed, other con structs in the language may now interact with the monadic 11 effects in unpredictable ways and we can no longer reason about the implementation of the monadic effects in isolation. The problem of the correctness of "updates-in-place" has been studied in other contexts <ref> [14, 29, 30, 34, 36] </ref>.
Reference: [35] <author> Wadler, P. </author> <title> The essence of functional programming (invited talk). </title> <booktitle> In the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (1992), </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <pages> pp. 1-14. </pages>
Reference-contexts: The correctness of "updates-in-place" is a long standing problem that has been studied extensively. In the context of monads, a number of researchers <ref> [8, 15, 26, 33, 35] </ref> noted that when the state monad is treated as an abstract data type, it ought to be possible to implement the state operations more efficiently using destructive updates.
Reference: [36] <author> Wakeling, D., and Runciman, C. </author> <title> Linearity and laziness. </title> <booktitle> In the Conference on Functional Programming and Computer Architecture (Sept. </booktitle> <year> 1991), </year> <editor> Hughes, Ed., </editor> <volume> vol. </volume> <booktitle> 523 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, Berlin, </publisher> <pages> pp. 215-240. 13 </pages>
Reference-contexts: Indeed, other con structs in the language may now interact with the monadic 11 effects in unpredictable ways and we can no longer reason about the implementation of the monadic effects in isolation. The problem of the correctness of "updates-in-place" has been studied in other contexts <ref> [14, 29, 30, 34, 36] </ref>.
References-found: 36

