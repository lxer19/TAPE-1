URL: ftp://ftp.eecs.umich.edu/people/hucka/publications/sde-tools-paper.ps.gz
Refering-URL: http://ai.eecs.umich.edu/people/hucka/publications.html
Root-URL: http://www.cs.umich.edu
Email: E-mail: hucka@engin.umich.edu  
Title: The Soar Development Environment  
Author: Michael Hucka and John E. Laird 
Date: 19 April 1994  
Address: Ann Arbor, MI 48109-2110 U.S.A.  
Affiliation: Depart. of Electrical Engineering and Computer Science University of Michigan  
Abstract: The Soar Development Environment (SDE) is an integrated environment for developing rule-based programs in the Soar language. It is designed to provide editing and debugging facilities, commands for creating skeleton source code for common constructs, facilities for locating the definitions of task components, and other features. It emphasizes context-sensitive operation by maintaining information about the program being developed. Our goal has been to provide users of Soar with a development environment that not only helps them to work more efficiently, but that also helps them to cope with problems of complexity and program management with such a rule-based language. In this paper we describe some of the principles followed in SDE as well as the design and implementation of several of its facilities. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. L. Forgy, </author> <title> "Rete: A fast algorithm for the many pattern/many object pattern match problem," </title> <journal> Artificial Intelligence, </journal> <volume> vol. 19, no. 1, </volume> <pages> pp. 17-37, </pages> <month> September </month> <year> 1982. </year>
Reference-contexts: Data are represented using attribute-value notation, and rule matching is implemented using a modified version of the Rete algorithm <ref> [1] </ref>. However, certain aspects of Soar are novel. Three aspects are relevant to describing SDE. 3 objects around on a table in response to human instructions. The arcs show the sequence of operator invocations that arise due to the dynamics of the situation. Based on Huffman and Laird [3].
Reference: [2] <author> O. N. Garcia and Y.-T. Chien, </author> <title> editors, Knowledge-Based Systems: Fundamentals and Tools, </title> <publisher> Los Alamitos, </publisher> <address> Calif., </address> <year> 1991. </year>
Reference-contexts: Rule-based systems thus support applications for which exploratory programming is more suitable than the "waterfall" model of software engineering <ref> [2, 10] </ref>. This modularity and incremental development can lead to complex systems that are difficult for programmers to implement and maintain. This tends to be true even with languages that provide constructs for organizing task knowledge.
Reference: [3] <author> S. B. Huffman and J. E. Laird, </author> <title> "Learning procedures from interactive natural language instructions," </title> <booktitle> in Machine Learning: Proceedings of the Tenth International Conference, </booktitle> <editor> P. Utgoff, editor, </editor> <year> 1993. </year>
Reference-contexts: However, certain aspects of Soar are novel. Three aspects are relevant to describing SDE. 3 objects around on a table in response to human instructions. The arcs show the sequence of operator invocations that arise due to the dynamics of the situation. Based on Huffman and Laird <ref> [3] </ref>. First, operators and problem spaces are prominent components of task knowledge in Soar. An operator in Soar proposes changes to working memory to transform the current state; these proposals are subject to a decision procedure that is run every execution cycle to determine which changes are to take place. <p> Since Soar's initial development over a decade ago, it has been used to implement a large number of systems, ranging from various models of human cognitive function [6], to expert systems such as 4 a subset of R1 [9], to intelligent agents such as Instructo-Soar <ref> [3] </ref>. The latter is a fairly large Soar system consisting of 2500 hand-coded rules spread over 255 files. 2.2 GNU Emacs We chose to start with an existing editor rather than to develop a stand-alone system primarily for two reasons.
Reference: [4] <author> J. Krieger, </author> <title> "Building expert systems," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 97-100, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: It also differs from recent approaches that abstract away from the textual rule representation 2 in favor of a graphically-oriented system <ref> [4, 7] </ref>, or that use a higher-level rule-based language that compiles into more basic rules [12], in that SDE allows the programmer to work at the level of the original rules.
Reference: [5] <author> J. E. Laird, C. B. Congdon, E. Altmann, and R. Doorenbos, </author> <title> "Soar user's manual, </title> <type> version 6," Technical report, </type> <institution> Artificial Intelligence Laboratory, University of Michigan, </institution> <year> 1993. </year>
Reference-contexts: There are numerous other important aspects of the Soar architecture, such as the fact that it learns new rules as it resolves subgoals, but they are not relevant to the present discussion of SDE. Newell [6] and Laird et al. <ref> [5] </ref> describe Soar in detail.
Reference: [6] <author> A. Newell, </author> <title> Unified Theories of Cognition, </title> <publisher> Harvard University Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: This modularity and incremental development can lead to complex systems that are difficult for programmers to implement and maintain. This tends to be true even with languages that provide constructs for organizing task knowledge. Soar is one such language <ref> [6] </ref>; in Soar, tasks are formulated as heuristic search involving the application of operators to states in problem spaces, and thus problem spaces and operators serve as foci for organizing task knowledge. Although this helps in structuring a program, common problem areas still remain. <p> There are numerous other important aspects of the Soar architecture, such as the fact that it learns new rules as it resolves subgoals, but they are not relevant to the present discussion of SDE. Newell <ref> [6] </ref> and Laird et al. [5] describe Soar in detail. Since Soar's initial development over a decade ago, it has been used to implement a large number of systems, ranging from various models of human cognitive function [6], to expert systems such as 4 a subset of R1 [9], to intelligent <p> Newell <ref> [6] </ref> and Laird et al. [5] describe Soar in detail. Since Soar's initial development over a decade ago, it has been used to implement a large number of systems, ranging from various models of human cognitive function [6], to expert systems such as 4 a subset of R1 [9], to intelligent agents such as Instructo-Soar [3].
Reference: [7] <author> M. Perlin and P. Gaertner, </author> <title> "A graphical constraint-based production system environment," </title> <booktitle> in Proceedings of the 2nd International IEEE Conference on Tools for Artificial Intelligence, </booktitle> <pages> pp. 181-188, </pages> <year> 1990. </year>
Reference-contexts: It also differs from recent approaches that abstract away from the textual rule representation 2 in favor of a graphically-oriented system <ref> [4, 7] </ref>, or that use a higher-level rule-based language that compiles into more basic rules [12], in that SDE allows the programmer to work at the level of the original rules.
Reference: [8] <author> F. E. Ritter, M. Hucka, and T. F. McGinnis, </author> <title> "Soar-mode manual," </title> <type> Tech. Rep. </type> <institution> CMU-CS-92-205, Carnegie Mellon University, School of Computer Science, </institution> <year> 1992. </year>
Reference-contexts: Some of the basic functionality of SDE is based on Soar Mode 5.0, developed with Frank Ritter and Tom McGinnis at Carnegie Mellon University <ref> [8] </ref>. We are thankful for their efforts, the opportunity to start with their system, and for frequent discussions. Finally, we would like to thank Bonnie John at Carnegie Mellon for many comments regarding SDE's usability, the many other users who contributed feedback, and the developers of GNU Emacs.
Reference: [9] <author> P. S. Rosenbloom, J. E. Laird, J. McDermott, A. Newell, and E. Orciuch, "R1-Soar: </author> <title> An experiment in knowledge-intensive programming in a problem-solving architecture," </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence, </journal> <volume> vol. 7, no. 5, </volume> <pages> pp. 561-569, </pages> <month> September </month> <year> 1985. </year>
Reference-contexts: Newell [6] and Laird et al. [5] describe Soar in detail. Since Soar's initial development over a decade ago, it has been used to implement a large number of systems, ranging from various models of human cognitive function [6], to expert systems such as 4 a subset of R1 <ref> [9] </ref>, to intelligent agents such as Instructo-Soar [3]. The latter is a fairly large Soar system consisting of 2500 hand-coded rules spread over 255 files. 2.2 GNU Emacs We chose to start with an existing editor rather than to develop a stand-alone system primarily for two reasons.
Reference: [10] <author> I. Sommerville, </author> <title> Software Engineering, </title> <publisher> Addison-Wesley Publishing Company, 3rd edition, </publisher> <year> 1989. </year>
Reference-contexts: Rule-based systems thus support applications for which exploratory programming is more suitable than the "waterfall" model of software engineering <ref> [2, 10] </ref>. This modularity and incremental development can lead to complex systems that are difficult for programmers to implement and maintain. This tends to be true even with languages that provide constructs for organizing task knowledge.
Reference: [11] <author> R. M. Stallman, </author> <title> GNU Emacs Manual, Free Software Foundation, </title> <address> Cambridge, MA, ninth edition, </address> <year> 1993. </year>
Reference-contexts: We chose GNU Emacs because many Soar users already use Emacs, it provides the required extensibility, and it is freely available. GNU Emacs is a powerful, general-purpose, customizable editing environment, able to run on a wide variety of computers and operating systems, including X Window Based-based Unix workstations <ref> [11] </ref>. Besides providing text-editing facilities, GNU Emacs includes special facilities for working with Lisp and many other languages; it can interface to a large number of external systems, including command shells, program debuggers, version control software; and much more.
Reference: [12] <author> G. R. Yost, TAQL: </author> <title> A Problem Space Tool for Expert System Development, </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1992. </year> <month> 16 </month>
Reference-contexts: It also differs from recent approaches that abstract away from the textual rule representation 2 in favor of a graphically-oriented system [4, 7], or that use a higher-level rule-based language that compiles into more basic rules <ref> [12] </ref>, in that SDE allows the programmer to work at the level of the original rules.
References-found: 12

