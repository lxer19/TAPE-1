URL: http://www.cs.toronto.edu/~eugenia/papers/trans.ps
Refering-URL: http://www.cs.toronto.edu/~eugenia/publications.html
Root-URL: http://www.cs.toronto.edu
Email: degiacomo@dis.uniroma1.it  eugenia@cs.toronto.edu  reiter@cs.toronto.edu  
Title: Non-Terminating Processes in the Situation Calculus  
Author: Giuseppe De Giacomo Eugenia Ternovskaia Ray Reiter 
Address: "La Sapienza"  Toronto  Toronto  
Affiliation: Dipartimento di Informatica e Sistemistica Universita di Roma  Department of Computer Science University of  Department of Computer Science University of  
Abstract-found: 0
Intro-found: 1
Reference: [Acz77] <author> P. Aczel. </author> <title> An introduction to inductive definitions. </title> <editor> In J. Barwise, editor, </editor> <booktitle> Handbook of Mathematical Logic, </booktitle> <pages> pages 739-782. </pages> <publisher> Elsevier, </publisher> <year> 1977. </year>
Reference-contexts: Observe that exo can actually occur only if both P oss (exo; s) and DynaP oss (exo; s) hold in s. 5 Logical representation of inductive definitions and fixpoints The relations Trans and Final are defined inductively. Inductive definitions <ref> [Acz77, Mos74] </ref> are broadly used in mathematical logic for defining sets. For the past several years they became popular in computer science [CC92].
Reference: [CC92] <author> P. Cousot and R. Cousot. </author> <title> Inductive definitions, semantics and abstract interpretation. </title> <booktitle> In Conference Record of the 19 th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <address> New York, U.S.A., 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Inductive definitions [Acz77, Mos74] are broadly used in mathematical logic for defining sets. For the past several years they became popular in computer science <ref> [CC92] </ref>.
Reference: [Cou90] <author> P. Cousot. </author> <title> Methods and logics for proving programs. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 841-989. </pages> <year> 1990. </year>
Reference: [DGLL97] <author> G. De Giacomo, H. J. Levesque, and Y. Lesperance. </author> <title> Reasoning about concurrent executions, prioritized interrupts, and exogenous actions in the situation calculus. </title> <note> Submitted, </note> <year> 1997. </year>
Reference-contexts: The framework obtained is quite powerful. It allows the specification of the dynamic system by modeling one agent with a program, and external events by suitable dynamic laws (extensions to multiple agents are also possible, see <ref> [DGLL97] </ref> for hints). Observe that although related this framework is more general than that typically considered in program verification, where exogenous actions that are specified by dynamic laws (axioms) are not allowed. There are many directions for further research.
Reference: [Eme96] <author> E. A. Emerson. </author> <title> Automated temporal reasoning about reactive systems. In Logics for Concur-rency: Structure versus Automata, </title> <booktitle> number 1043 in Lecture Notes in Computer Science, </booktitle> <pages> pages 41-101. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: In particular properties expressible by logics of programs, such as dynamic logics [KT90], mu-calculus [Par70, Sti96], and temporal logics <ref> [Eme96] </ref>, can be rephrased in our setting. Let us present some examples. 1.
Reference: [Heh93] <author> E.C.R. Hehner. </author> <title> A practical theory of programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: ~y)(~x) j [(9P )[(8~y)P (~y) oe (P; ~y)] ^ P (~x)]g (7) The last sentence can be taken as a definition of a greatest fixpoint. 4 Interpreting oe as an abbreviation for : _ 5 The idea of defining a least fixpoint using two principles, construction and induction, is from <ref> [Heh93] </ref>. 6 6 Examples of expressible dynamic properties With Trans and Final in place a wide variety of dynamic properties can be expressed by relying on second order formulae expressing least and greatest fixpoint properties.
Reference: [Hen90] <author> M. Hennessy. </author> <title> The Semantics of Programming Languages. </title> <publisher> John Wiley & Sons, </publisher> <year> 1990. </year>
Reference-contexts: Observe however that in this way programs cannot be quantified over, because they are not terms of the language of the situation calculus. The kind of semantics Do associates to programs, which is based on the complete evaluation of the program, is sometimes called evaluation semantics <ref> [Hen90] </ref>. Such a semantics is not well suited to interpret non-terminating programs, like infinite loops, since for such programs the evaluation can never be completed and a final situation can never be reached. <p> For non-terminating programs one needs to rely on a semantics that allows for interpreting segments of program executions. So we adopt a kind of semantics called computational semantics <ref> [Hen90] </ref>, which is based on "single steps" of computation, or transitions 1 . A step here is either a primitive or a test action. We begin by introducing two special relations, Final and Trans. <p> Note that this formulation of Do is equivalent to the one in [LRL + 97] (c.f. <ref> [Hen90] </ref>). 4 Exogenous actions Exogenous action are primitive actions that are not under the control of the program. They are executed by other agents in an asynchronous way wrt the program. Trans can be easily modified to take into account exogenous actions as well.
Reference: [Kna28] <author> B. Knaster. </author> <title> Un theoreme sur les fonctions d'ensembles. </title> <journal> Ann. Soc. Polon. Math., </journal> <volume> 6 </volume> <pages> 133-134, </pages> <year> 1928. </year>
Reference-contexts: The construction principle tells us how to obtain these elements recursively. (8~x)Z (~x) j (Z; ~x) (1) In this case is called a constructor for Z. Any solution of this recursive equation is called a fixpoint of the operator . The Knaster-Tarski Theorem <ref> [Kna28, Tar55] </ref> guarantees that if the operator is monotone, the equation (1) has both a least and a greatest solution. A sufficient condition for monotonicity is that all occurrence of Z occur within a even number of negations 4 .
Reference: [KT90] <author> D. Kozen and J. Tiuryn. </author> <title> Logics of programs. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 790-840. </pages> <year> 1990. </year>
Reference-contexts: In particular properties expressible by logics of programs, such as dynamic logics <ref> [KT90] </ref>, mu-calculus [Par70, Sti96], and temporal logics [Eme96], can be rephrased in our setting. Let us present some examples. 1.
Reference: [Lei94] <author> D. Leivant. </author> <title> Higher order logic. </title> <booktitle> In Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <volume> volume 2, </volume> <pages> pages 229-321. </pages> <publisher> Clarendon Press, </publisher> <year> 1994. </year>
Reference-contexts: To follow this approach it is necessary to quantify over programs and so, unlike in [LRL + 97], we need to encode GOLOG programs as first-order terms, including introducing constants denoting variables, and so on. This is laborious but quite straightforward <ref> [Lei94] </ref> 2 . We omit all such details here and simply use programs within formulas as if they were already first-order terms. Final and Trans are denoted by predicates defined inductively on the structure of the first argument.
Reference: [LRL + 97] <author> H.J. Levesque, R. Reiter, Y. Lesperance, F. Lin, and R. Scherl. GOLOG: </author> <title> a logic programming language for dynamic domains. </title> <journal> J. of Logic Programming, </journal> <note> 1997. To appear. </note>
Reference-contexts: Examples of axioms for the initial situation for our coffee delivery example are: :(9p)hasCoff ee (p; S 0 ); robotLocation (S 0 ) = CM: These have the intended reading that initially, no one has coffee, and the robot is located at the coffee machine (CM ). See <ref> [LRL + 97] </ref> for a full description. 2.2 GOLOG GOLOG [LRL + 97] is a situation calculus-based logic programming language that allows for defining complex actions using a repertoire of user specified primitive actions. <p> See <ref> [LRL + 97] </ref> for a full description. 2.2 GOLOG GOLOG [LRL + 97] is a situation calculus-based logic programming language that allows for defining complex actions using a repertoire of user specified primitive actions. GOLOG provides the usual kinds of imperative programming language control structures as well as various forms of nondeterminism. <p> Primitive actions: a. Do action a in the current situation. Actually a is a pseudo-action obtained from an action by suppressing the situation argument in each functional fluent. The function a [s] that given a pseudo-action a and a situation s returns the original action (see <ref> [LRL + 97] </ref>). 2. Test actions: OE?. Test the truth value of expression OE in the current situation. As for primitive actions, OE is a pseudo-formula obtained from a situation calculus formula by suppressing all situation arguments. <p> Conditionals: if OE then ffi 1 else ffi 2 , which is expressed as (OE?; ffi 1 ) j (:OE?; ffi 2 ). 9. Procedures, including recursion: proc P rocN ame (~v) ffi P rocName endProc. 3 Single step semantics for GOLOG In <ref> [LRL + 97] </ref>, GOLOG programs are interpreted by means of a special relation Do (ffi; s; s 0 ) that given a (generally nondeterministic) program ffi and a situation s returns a possible situation s 0 , resulting by executing ffi starting from s. Actually in [LRL + 97] the relation <p> semantics for GOLOG In <ref> [LRL + 97] </ref>, GOLOG programs are interpreted by means of a special relation Do (ffi; s; s 0 ) that given a (generally nondeterministic) program ffi and a situation s returns a possible situation s 0 , resulting by executing ffi starting from s. Actually in [LRL + 97] the relation Do is not denoted by a predicate, but instead it is defined implicitly by using macros expansion rules such as: Do (ffi 1 ; ffi 2 ; s; s 0 ) = (9s 00 )Do (ffi 1 ; s; s 00 ) ^ Do (ffi 2 <p> Trans (ffi; s; ffi 0 ; s 0 ) is intended to say that program ffi in situation s may legally execute one step, ending in situation s 0 with program ffi 0 remaining. To follow this approach it is necessary to quantify over programs and so, unlike in <ref> [LRL + 97] </ref>, we need to encode GOLOG programs as first-order terms, including introducing constants denoting variables, and so on. This is laborious but quite straightforward [Lei94] 2 . We omit all such details here and simply use programs within formulas as if they were already first-order terms. <p> Note that this formulation of Do is equivalent to the one in <ref> [LRL + 97] </ref> (c.f. [Hen90]). 4 Exogenous actions Exogenous action are primitive actions that are not under the control of the program. They are executed by other agents in an asynchronous way wrt the program. Trans can be easily modified to take into account exogenous actions as well. <p> Observe that it has exactly the form we have used to define Trans and Final (as well as Do (ffi fl ; s; s 0 ) in <ref> [LRL + 97] </ref>). 5.3 Coinduction principle: Greatest fixpoints To guarantee that Z is the biggest solution of (1), we apply the coinduction principle: (8P; ~x)f [(8~y)P (~y) oe (P; ~y)] oe [P (~x) oe Z (~x)]g (5) i.e., whatever solution P of the recursive specification we take, Z includes it.
Reference: [LS87] <author> J. Loeckx and K. Sieber. </author> <title> Foundation of Program Verification. </title> <address> Teubner-Wiley, New York, </address> <year> 1987. </year>
Reference: [Mos74] <author> Y.N. Moschovakis. </author> <title> Elementary Induction on Abstract Structures. </title> <publisher> Amsterdam, North Holland, </publisher> <year> 1974. </year>
Reference-contexts: Observe that exo can actually occur only if both P oss (exo; s) and DynaP oss (exo; s) hold in s. 5 Logical representation of inductive definitions and fixpoints The relations Trans and Final are defined inductively. Inductive definitions <ref> [Acz77, Mos74] </ref> are broadly used in mathematical logic for defining sets. For the past several years they became popular in computer science [CC92].
Reference: [MP95] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems, </title> <booktitle> Vol. </booktitle> <pages> 1-2. </pages> <publisher> Springer-Verlag, </publisher> <pages> 1992-1995. </pages>
Reference: [Par70] <author> D. Park. </author> <title> Fixpoint induction and proofs of program properties. </title> <booktitle> In Machine Intelligence, </booktitle> <volume> volume 5, </volume> <pages> pages 59-78. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1970. </year>
Reference-contexts: In particular properties expressible by logics of programs, such as dynamic logics [KT90], mu-calculus <ref> [Par70, Sti96] </ref>, and temporal logics [Eme96], can be rephrased in our setting. Let us present some examples. 1.
Reference: [Plo81] <author> G. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI-FN-19, </type> <institution> Computer Science Dept. Aarhus Univ. Denmark, </institution> <year> 1981. </year>
Reference-contexts: It is convenient to include a special "empty" program ", denoting that nothing of the program remains to be performed. 1 Both types of semantics belong to the family of structural operational semantics introduced in <ref> [Plo81] </ref>. 2 We assume that the predicates introduced in this section, including Final and Trans, cannot occur in tests, hence disallowing self-reference. 3 The definition of Final is as follows: (8ffi)Final (ffi) j (8F )[: : : oe F (ffi)] where : : : stands for the conjunction of the universal
Reference: [Rei91] <author> R. Reiter. </author> <title> The frame problem in the situation calculus: a simple solution (sometimes) and a completeness result for goal regression. </title> <editor> In Vladimir Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <pages> pages 359-380. </pages> <publisher> Academic Press, </publisher> <address> San Diego, CA, </address> <year> 1991. </year>
Reference-contexts: These capture the causal laws of the domain, together with a solution to the frame problem <ref> [Rei91] </ref>.
Reference: [Sti96] <author> C. Stirling. </author> <title> Modal and temporal logics for processes. In Logics for Concurrency: Structure versus Automata, </title> <booktitle> number 1043 in Lecture Notes in Computer Science, </booktitle> <pages> pages 149-237. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Dynamic properties are typically fixpoint properties, expressed as the least or greatest solutions of certain recursive logical equations (e.g. see <ref> [Sti96] </ref>). <p> In particular properties expressible by logics of programs, such as dynamic logics [KT90], mu-calculus <ref> [Par70, Sti96] </ref>, and temporal logics [Eme96], can be rephrased in our setting. Let us present some examples. 1.
Reference: [Tar55] <author> B. Tarski. </author> <title> A lattice-theoretical fixpoint theorem and its applications. </title> <journal> Pacific J. Math., </journal> <volume> 5 </volume> <pages> 285-309, </pages> <year> 1955. </year>
Reference-contexts: The construction principle tells us how to obtain these elements recursively. (8~x)Z (~x) j (Z; ~x) (1) In this case is called a constructor for Z. Any solution of this recursive equation is called a fixpoint of the operator . The Knaster-Tarski Theorem <ref> [Kna28, Tar55] </ref> guarantees that if the operator is monotone, the equation (1) has both a least and a greatest solution. A sufficient condition for monotonicity is that all occurrence of Z occur within a even number of negations 4 .
References-found: 19

