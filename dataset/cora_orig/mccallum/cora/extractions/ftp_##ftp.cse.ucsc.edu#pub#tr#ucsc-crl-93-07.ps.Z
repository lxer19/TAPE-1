URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-93-07.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: Transparent Remote Procedure Calls  
Author: Michelle Denise Abram Prof. Darrell D. E. Long Prof. Tracy Larrabee Prof. Charles E. M c Dowell Dean 
Degree: A thesis submitted in partial satisfaction of the requirements for the degree of MASTER OF SCIENCE in COMPUTER AND INFORMATION SCIENCE by  The thesis of Michelle Denise Abram is approved:  
Date: December 1992  
Affiliation: UNIVERSITY OF CALIFORNIA SANTA CRUZ  of Graduate Studies and Research  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. T. Almes. </author> <title> The impact of language and system on remote procedure call design. </title> <booktitle> In Proceedings of the 6th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 414-421. </pages> <publisher> IEEE, </publisher> <month> May </month> <year> 1986. </year>
Reference-contexts: First, there are two problems with at least once semantics. If a server crashes, the repeated attempts to contact the server (especially in the case of a frequently called server) run the risk of clogging the network with packets. Also, there is the problem of non-idempotent procedures <ref> [1] </ref>. If a timeout should occur solely because of a delay in the network transmission, a non-idempotent procedure could execute multiple times with incorrect results. This could create errors in the application. <p> For this reason, we to require host specification by the user. The user must directly specify the host in the form of an argument to the remote procedure call. One improvement of this idea presented by Almes <ref> [1] </ref> is the allowance of an optional argument that indicates the host. If it is not included, it is assumed that the client wishes to contact any version of that procedure with matching types. This idea is a part of the future work for our package. <p> This is vital to a properly implemented remote procedure call package. Another way to handle binding that would preserve more transparency would be to have optional arguments that specify the server. This idea is discussed in Almes' paper on remote procedure call design <ref> [1] </ref>. Using this method, the user could omit the specification of the unique identifier and bind to any server that matches the argument and result types that it specifies. On the other hand, if the programmer does wish to precisely define a server, he has the option of doing so.
Reference: [2] <author> P. A. Alsberg and J. D. Day. </author> <title> A principle for resilient sharing of distributed resources. </title> <booktitle> In Proceedings of the Second International Conference on Software Engineering. IEEE, </booktitle> <year> 1976. </year>
Reference-contexts: A number of different methods have been developed to handle these problems. There are a number of very simple protocols that have been developed for replicated data management. Some examples of these are the primary site <ref> [2] </ref>, primary copy [45], and available copy [5] protocols. The problem with these simple protocols is that they approach distributed data management in a naive fashion. The primary site protocol involves storing data at a primary site with copies of the original at a set of cohort sites.
Reference: [3] <author> H. Aschmann, N. Giger, E. Hoepli, P. Janak, and H. Kirmann. Alphorn: </author> <title> A remote procedure call environment for fault-tolerant, heterogeneous, </title> <journal> distributed systems. IEEE Micro, </journal> <volume> 11 </volume> <pages> 16-27, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: A problem with this is that some services implemented by RPC users may require procedure calls that do not force the caller to wait for the result. Aschmann et al. refer to these as remote procedure invocations <ref> [3] </ref>. One example is the PARPC system presented by Martin et al., which calls several procedures in parallel and blocks only until one of the results returns. A client processes the results from the single invocation and then resumes its blocked state until another invocation returns a result [29]. <p> This would cause the stub compiler to create stubs that excluded the return process. This way, the transparency of the package 63 is preserved. Like the Alphorn remote procedure call package <ref> [3] </ref>, we are unlikely to allow asynchronous remote procedure calls with return values. 64
Reference: [4] <author> D. Barbara, H. Garcia-Molina, and A. Spauster. </author> <title> Policies for dynamic vote reassignment. </title> <booktitle> In Proceedings of the 6th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 37-44, </pages> <address> Cambridge, 1986. </address> <publisher> IEEE. </publisher>
Reference-contexts: Witnesses are not data objects; they are records of the state of the data object [33]. A witness must be a part of the quorum when the voting entity reads data objects. Other modifications of these simple algorithms include dynamic vote adjustment <ref> [4] </ref> and dynamic quorum adjustment [28] protocols. These algorithms make a distributed database more sensitive to changes in its configuration, and this increases the robustness of the database.
Reference: [5] <author> P. A. Bernstein and N. Goodman. </author> <title> An algorithm for concurrency control and recovery in replicated distributed databases. </title> <journal> ACM Transactions on Database Systems, </journal> <pages> pages 596-615, </pages> <month> December </month> <year> 1984. </year>
Reference-contexts: A number of different methods have been developed to handle these problems. There are a number of very simple protocols that have been developed for replicated data management. Some examples of these are the primary site [2], primary copy [45], and available copy <ref> [5] </ref> protocols. The problem with these simple protocols is that they approach distributed data management in a naive fashion. The primary site protocol involves storing data at a primary site with copies of the original at a set of cohort sites.
Reference: [6] <author> A. D. Birrell. </author> <title> Secure communication using remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 1-14, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: This is one of the additions that we would like to make to our package. We would like to handle the problem of network transmission by simply using an established data encryption mechanism, as was done in the Cedar RPC facility <ref> [6] </ref>. For the Data Encryption Standard (DES) [31], there is a great deal of available software. We could incorporate this into our package. DES works through private keys.
Reference: [7] <author> A. D. Birrell, R. Levin, R. M. Needham, and M. D. Schroeder. Grapevine: </author> <title> an excercise in distributed computing. </title> <journal> Communications of the ACM, </journal> <volume> 28(4) </volume> <pages> 260-274, </pages> <month> April </month> <year> 1982. </year>
Reference-contexts: The stubs are generated by a stub generator called Lupine, which takes an interface description (consisting of a list of the procedures, the types of their arguments, and the types of the return values) and produces the stubs from it. Cedar uses the Grapevine distributed database <ref> [7] </ref> to hold connection information about the available 7 procedures [8]. This facilitates binding between clients and servers. The overall structure of the Cedar RPC facility has become standard for remote procedure call packages. There are several other examples of fully implemented RPC systems.
Reference: [8] <author> A. D. Birrell and B. J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2 </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: Similarly, in a remote procedure call, the calling process is suspended, the data is passed to the remote server, and the procedure is activated on the remote host <ref> [8] </ref>. It performs its computations on the data and returns a result. The difference lies in the way that arguments and results are passed between the calling program and the remote procedure. In local procedure calls, the arguments are passed into local memory (typically in register on the stack). <p> Since our intent was to create a convenient heterogeneous computing environment, we have chosen to implement a remote procedure call package at the user level. 2.1.2 Remote Procedure Calls The idea of remote procedure calls derives from the seminal paper by Birrel and Nelson on the Cedar programming environment <ref> [19, 8] </ref>. This system was constructed for Dorado machines, and it provides a model where a client and server communicate via the networking services provided by the package. <p> Cedar uses the Grapevine distributed database [7] to hold connection information about the available 7 procedures <ref> [8] </ref>. This facilitates binding between clients and servers. The overall structure of the Cedar RPC facility has become standard for remote procedure call packages. There are several other examples of fully implemented RPC systems. <p> Birrell and Nelson state <ref> [8] </ref>: Major issues facing the designer of an RPC facility include: the precise semantics of a call in the presence of machine and communication failures; the semantics of address-containing arguments in the (possible) absence of a shared address space; integration of remote calls into existing (or future) programming systems; binding (how <p> The drawbacks and difficulties of at least once and exactly once semantics caused us to choose at most once semantics. This is the choice made in the Cedar RPC environment, which guarantees that the procedure has executed exactly once if the client receives an actual result (not an exception) <ref> [8] </ref>. 2.2.3 Argument Semantics In an RPC package, there is also the issue of how to pass arguments to the remote procedures. There are several argument semantics, three of which concern us: call by reference, call by value, and call by value result [40]. <p> To establish a connection with the correct server, the client must find the server's network endpoint [44]. A commonly used method is maintaining a database that holds the procedure connection information. Cedar RPC uses the Grapevine distributed database <ref> [8] </ref>. The types and instances of each procedure are stored in this database, and this allows the client to locate the proper instance of each procedure that it calls [8]. <p> Cedar RPC uses the Grapevine distributed database <ref> [8] </ref>. The types and instances of each procedure are stored in this database, and this allows the client to locate the proper instance of each procedure that it calls [8]. In contrast, Sun RPC has a port mapper daemon that is called by the client to locate a particular program and version. The difference is that the port mapper is local to specific machines.
Reference: [9] <author> J. Bloomer. </author> <title> Power Programming with RPC. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <address> Sebastopl, California, </address> <year> 1991. </year>
Reference-contexts: Despite this drawback, we chose to use this method because of the simplicity of its construction. 16 Another way of translating between different data representations is the receiver-makes-it-right conversion method <ref> [9] </ref>. Apollo NDR uses this method for data conversion [44]. The idea of receiver-makes-it-right is leaving the responsibility for all type conversion to the receiving side. With these semantics, types are converted directly between varying architectures without the intermediate conversion.
Reference: [10] <author> M. R. Brown, K. N. Killing, and E. A. Taft. </author> <title> The Alpine file system. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 3(4) </volume> <pages> 261-293, </pages> <year> 1985. </year>
Reference-contexts: In addition to remote procedure calls, there are distributed file systems, remote execution, and remote evaluation. Distributed file systems are environments in which files and resources are accessible across machine boundaries. There are several such systems, including NFS 1 [37], the Andrew file system (AFS) [30], Alpine <ref> [10] </ref>, and many others. Although this paradigm primarily deals with the distribution of resources, it is related to the topic of remote procedure calls in the following sense. A programmer can conduct distributed computation in a distributed file system by using files as communication mechanisms.
Reference: [11] <author> M. Burrows and M. Abadi. </author> <title> A logic of authentication. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(1) </volume> <pages> 18-36, </pages> <month> February </month> <year> 1990. </year> <month> 65 </month>
Reference-contexts: There are two aspects of this issue. First, there is the issue of guaranteeing that communication only occurs between authorized clients and servers. This is known as intruder protection <ref> [11] </ref>. The second aspect of security involves the services provided by the application. With many widely accessible commands, there is the issue of restricting which clients can use the services offered by a procedure server. Both of these issues are very important in a distributed computing environment.
Reference: [12] <author> Xerox Corporation. Courier: </author> <title> the Remote Procedure Call Protocol. Xerox System Integration Standard, Stamford, </title> <address> Connecticut, </address> <month> December </month> <year> 1981. </year>
Reference-contexts: This facilitates binding between clients and servers. The overall structure of the Cedar RPC facility has become standard for remote procedure call packages. There are several other examples of fully implemented RPC systems. These include Xerox Courier <ref> [12] </ref>, Firefly RPC [38], Apollo RPC [14, 44] (which is the basis of DCE RPC 2 [16, 44]), and Sun RPC [22, 23, 44]. Sun RPC has become a de facto standard, since it is so widely used. DCE RPC, which is actually more versatile, is also gaining acceptance.
Reference: [13] <author> G. F. Coulouris and J. Dollimore. </author> <title> Distributed Systems: Concepts and Design. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Menlo Park, California, </address> <year> 1988. </year>
Reference-contexts: The server can crash. 4. The client can crash. To handle these problems, an RPC package must include extensive error checking and recovery mechanisms. There are three basic types of execution semantics that apply to remote procedure calls: at least once, at most once, and exactly once semantics <ref> [13] </ref>. With at least once semantics, the client makes repeated attempts to successfully execute the procedure until it either times out or receives an indication of a server failure. <p> These small additions (keywords and host specification) are all that is required to use our package. Once the user has written the program, he runs it through the stub compiler, and the stub compiler produces customized stub routines. Procedures in our package are executed with at most once semantics <ref> [13] </ref>. The client and server only make one request for a procedure call. When errors occur during the steps of RPC execution, execution aborts, and either the client stub or the server propagates the errors back to the user's program.
Reference: [14] <author> T. H. Dineen, P. J. Leach, N. W. Mishkin, J. N. Pato, and G. L. Wyant. </author> <title> The network computing architecture and system: An environment for developing distributed applications. </title> <booktitle> In Proceedings of the 1987 Summer USENIX Conference, </booktitle> <pages> pages 385-398. </pages> <publisher> USENIX, </publisher> <year> 1987. </year>
Reference-contexts: This facilitates binding between clients and servers. The overall structure of the Cedar RPC facility has become standard for remote procedure call packages. There are several other examples of fully implemented RPC systems. These include Xerox Courier [12], Firefly RPC [38], Apollo RPC <ref> [14, 44] </ref> (which is the basis of DCE RPC 2 [16, 44]), and Sun RPC [22, 23, 44]. Sun RPC has become a de facto standard, since it is so widely used. DCE RPC, which is actually more versatile, is also gaining acceptance.
Reference: [15] <author> T. H. Dineen, P. J. Leach, N. W. Mishkin, J. N. Pato, and G. L. Wyant. </author> <title> The network computing architecture and system: An environment for developing distributed applications. </title> <booktitle> In Proceedings of Summer 1987 USENIX Conference, </booktitle> <pages> pages 385-398. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: The interface definition consists of the function prototypes, any types specifically associated with the remote procedures, and a unique universal identifier (uuid), which the user can generate with uuidgen <ref> [15] </ref>. The user then writes the client application code, the server initialization code, and the server operation code, which are the actual definitions of the remote procedures. IDL produces a header and two object files. <p> The exception to this is that pointers and pointer-containing data structures cannot be passed to procedures. DCE RPC handles complex data types (such as trees declared with pointers) by using transmissible types provided by the user <ref> [15] </ref>. Since this also sacrifices transparency to a significant extent, we have chosen to disallow complex data structures containing pointers. Since our package depends primarily on protocols and languages that are widely used, it should be relatively simple to port it to most computing environments.
Reference: [16] <author> Open Software Foundation. </author> <title> DCE RPC. </title> <address> Cambridge, Massachusettes, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: The overall structure of the Cedar RPC facility has become standard for remote procedure call packages. There are several other examples of fully implemented RPC systems. These include Xerox Courier [12], Firefly RPC [38], Apollo RPC [14, 44] (which is the basis of DCE RPC 2 <ref> [16, 44] </ref>), and Sun RPC [22, 23, 44]. Sun RPC has become a de facto standard, since it is so widely used. DCE RPC, which is actually more versatile, is also gaining acceptance. These are the primary packages to which we will compare our package.
Reference: [17] <author> Open Software Foundation. </author> <title> Introduction to OSF DCE. </title> <publisher> Prentice Hall, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1992. </year>
Reference-contexts: DCE RPC is also very similar to Cedar RPC. Its distributed data base design differs from Cedar in that it has two parts. DCE RPC makes use of a Cell Directory Service, which holds machine and interface information, and an RPC daemon, which provides the network endpoint information <ref> [17] </ref>. The other aspects of its general structure are very similar. <p> IDL produces a header and two object files. These 41 object files are the stubs containing the hidden details of remote procedure call execution. They are linked to the client and server programs during compilation <ref> [17] </ref>. The major problem with DCE RPC is that it has several library routines that the user must include in his own code [17]. Figure 5.1 shows a simple example of a DCE RPC application. <p> They are linked to the client and server programs during compilation <ref> [17] </ref>. The major problem with DCE RPC is that it has several library routines that the user must include in his own code [17]. Figure 5.1 shows a simple example of a DCE RPC application. This example starts one procedure server for a simple successor () function and has the client call it.
Reference: [18] <author> D. K. Gifford. </author> <title> Weighted voting for replicated data. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Operqting System Principles, </booktitle> <pages> pages 150-161, </pages> <address> Pacific Grove, </address> <year> 1979. </year>
Reference-contexts: Together, they implement a majority consensus voting algorithm to promote fault-tolerance in the replicated database. The algorithm that we use is similar to the algorithm presented by Gifford on weighted voting <ref> [18] </ref>. In this model, copies of the data are distributed across several hosts, and we assign quorums for read and write operations. If a quorum of the sites having replicas of the data object is not available, then the data is assumed to be unavailable.
Reference: [19] <author> D. K. Gifford, R. M. Needham, and M. D. Schroeder. </author> <title> The Cedar file system. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 288-298, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Since our intent was to create a convenient heterogeneous computing environment, we have chosen to implement a remote procedure call package at the user level. 2.1.2 Remote Procedure Calls The idea of remote procedure calls derives from the seminal paper by Birrel and Nelson on the Cedar programming environment <ref> [19, 8] </ref>. This system was constructed for Dorado machines, and it provides a model where a client and server communicate via the networking services provided by the package. <p> There are several variations of this protocol. One refinement of majority consensus voting involves assigning weights to each of the sites in the distributed database <ref> [19] </ref>. Weighting of sites depends upon the characteristics of the site. Another way of improving majority consensus voting is to create witnesses. Witnesses are not data objects; they are records of the state of the data object [33].
Reference: [20] <author> B. T. Harrison. </author> <title> Using DCE. </title> <booktitle> DEC Professional, </booktitle> <pages> pages 44-54, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: First, consider DCE RPC. To use the DCE RPC package, a user goes through several steps. The user must first create a file using the DCE Interface Definition Language (IDL) and run it through the IDL compiler <ref> [20] </ref>. The interface definition consists of the function prototypes, any types specifically associated with the remote procedures, and a unique universal identifier (uuid), which the user can generate with uuidgen [15].
Reference: [21] <author> M. P. Herlihy and M. S. McKendry. </author> <title> Timestamp-based orphan elimination. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(7) </volume> <pages> 825-831, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: We can handle this problem by switching to version numbers with allowances made for invalid entries in the database. 6.3.6 Orphan Detection One significant issue in distributed computing is the problem of orphan processes. An orphan is an activity or process executing on behalf of an aborted transaction <ref> [21] </ref>. Such processes waste system resources. Although this is unlikely to result in inaccurate results in the RPC paradigm, the problem of system resources can escalate intolerably for frequently accessed procedure calls. <p> At present, 62 our package only aborts handler processes if the client specifically tells the handler to terminate. This can cause unnecessary use of resources on the host. One way of approaching this problem would be to use the method proposed by Her-lihy <ref> [21] </ref>. Herlihy proposes eliminating orphans by using a time-stamp based algorithm. Transactions have a quiesce time and a release time. When the termination invariant, which is the stipulation that Last (Quiesce (A)) F irst (Release (A)), is violated, the orphan process is aborted.
Reference: [22] <author> Sun Microsystems Incorporated. </author> <title> RPC: Remote Procedure Call, Protocol Specification, </title> <type> Version 2. </type> <institution> Mountain View, California, </institution> <month> January </month> <year> 1985. </year>
Reference-contexts: There are several other examples of fully implemented RPC systems. These include Xerox Courier [12], Firefly RPC [38], Apollo RPC [14, 44] (which is the basis of DCE RPC 2 [16, 44]), and Sun RPC <ref> [22, 23, 44] </ref>. Sun RPC has become a de facto standard, since it is so widely used. DCE RPC, which is actually more versatile, is also gaining acceptance. These are the primary packages to which we will compare our package. <p> Stubs are generated by the rpcgen program, which requires an XDR 3 [23] interface specification. In Sun RPC, the function performed by Grapevine is handled by a name server that runs on every machine <ref> [22] </ref>. Each name server maintains information about the procedure servers on its own machine. DCE RPC is also very similar to Cedar RPC. Its distributed data base design differs from Cedar in that it has two parts. <p> The user must create a program name, program version number, and procedure number that completely identifies each procedure. Further, Sun RPC requires explicit binding to a particular procedure server by the user's client program (with a separate, multi-argument procedure call) <ref> [22] </ref>. We bind clients to servers in a manner similar to the method used in Cedar RPC. In our package, we maintain a distributed database; a client that wishes to contact a procedure must first consult the database via the name server.
Reference: [23] <author> Sun Microsystems Incorported. XDR: </author> <title> External Data Representation Stabdard. </title> <address> Mountain View, California, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: There are several other examples of fully implemented RPC systems. These include Xerox Courier [12], Firefly RPC [38], Apollo RPC [14, 44] (which is the basis of DCE RPC 2 [16, 44]), and Sun RPC <ref> [22, 23, 44] </ref>. Sun RPC has become a de facto standard, since it is so widely used. DCE RPC, which is actually more versatile, is also gaining acceptance. These are the primary packages to which we will compare our package. <p> Sun RPC has a run-time library that carries out all of the networking , and a port mapper that records the network end-points of the procedure servers. Stubs are generated by the rpcgen program, which requires an XDR 3 <ref> [23] </ref> interface specification. In Sun RPC, the function performed by Grapevine is handled by a name server that runs on every machine [22]. Each name server maintains information about the procedure servers on its own machine. DCE RPC is also very similar to Cedar RPC.
Reference: [24] <author> S. C. Johnson. </author> <title> YACC: Yet another compiler-compiler. </title> <type> Technical Report 32, </type> <institution> Bell Laboratories, </institution> <address> Murray Hill, New Jersey, </address> <month> July </month> <year> 1975. </year>
Reference-contexts: The second phase, the stub generation phase, is the main portion of the stub compiler. It consists of two main parts: the lexical analyzer, which is written using the Lex lexical analyzer [26], and the parser, which uses Yacc <ref> [24] </ref> to define the keywords and syntax of the ANSI C language. Stub generation is accomplished through the cooperative activity of these two services. The lexical analyzer serves three purposes. First, it identifies keywords, symbols, and constants to the parser.
Reference: [25] <author> B. W. Kernighan and D. M. Ritchie. </author> <title> The C Programming Lanugage. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: Further, the design of the stub compiler is also an issue in creating a complete remote procedure call facility. The ideas and trade-offs of remote procedure call design are discussed below. 2.2.1 Existing systems Our system is designed for the ANSI standard C programming language <ref> [25] </ref>. We chose C because it is so widely used. The choice of ANSI C (as opposed to traditional C) was due to the availability of function prototyping. In ANSI C, a programmer can declare functions with their arguments and argument types before actually defining the function. <p> In C, only call by value is actually possible. However, call by reference semantics can be simulated by passing pointer arguments to functions. This way, the address becomes accessible to the procedure, and when the procedure dereferences the pointer, it affects the original memory location <ref> [25] </ref>. Dereferencing pointers on a remote machine generally makes no sense; therefore, our package restricts argument semantics to call by value. This creates a problem with array handling. It would be a significant weakness for us to disallow array arguments.
Reference: [26] <author> M. E. Lesk. </author> <title> Lex a lexical analyzer generator. </title> <type> Technical Report 39, </type> <institution> Bell Laboratories, </institution> <address> Murray Hill, New Jersey, </address> <month> October </month> <year> 1975. </year>
Reference-contexts: The output of this phase is piped directly to phase two of the compilation process. The second phase, the stub generation phase, is the main portion of the stub compiler. It consists of two main parts: the lexical analyzer, which is written using the Lex lexical analyzer <ref> [26] </ref>, and the parser, which uses Yacc [24] to define the keywords and syntax of the ANSI C language. Stub generation is accomplished through the cooperative activity of these two services. The lexical analyzer serves three purposes. First, it identifies keywords, symbols, and constants to the parser.
Reference: [27] <author> D. D. E. </author> <title> Long. </title> <type> Private Communication. </type>
Reference-contexts: This makes it difficult to recognize invalid entries (which would remain if a deletion failed). This problem could be surmounted by deleting any invalid entries before writing a new entry and raising the version one past the version number of the invalid entry <ref> [27] </ref>. However, this would mean that the problem could not be handled in the database servers. The name server would need to send to all of the databases to find any invalid entries that might remain in any of the databases. <p> The advantage of using UDP is low overhead. Connection-oriented protocols require establishment of exclusive connections for each transmission session. To provide the user with reliable byte stream transmission with no record boundaries, the state must be maintained throughout the transmission <ref> [27] </ref>. This means that this is much slower to implement than simple datagram protocols. Since these connections are exclusive, each remote procedure call to a different host would involve establishing a separate connection. <p> Much of the complexity lies in the design of an LALR parser. The parser may place large amounts of information on its stack before executing the code generation commands <ref> [27] </ref>. Also, placing commands in the middle of parsing statements creates resolution errors in the parser. We have surmounted this problem by placing conditional statements in both the lexical analyzer and the parser. <p> We would like to improve the handling of undiscriminated unions. The way that we propose to do this is to handle them according to the largest data type in the union fields <ref> [27] </ref>. Although the accuracy will still not be guaranteed in this case, this is a better solution than the present implementation. The second issue regarding data representation in our package deals with overhead. Network standard representations provide a reliable and very portable mechanism for data transmission in heterogeneous environments. <p> This way, random failures of sites and heavily loaded networks will not result in large numbers of unnecessary procedure call failures. Last, the use of time stamps instead of version numbers in our package could present problems. The main problem is the chance of drifting clocks on the hosts <ref> [27] </ref>. If the times in the local hosts do not remain accurate, invalid entries could remain in the database.
Reference: [28] <author> D. D. E. </author> <title> Long. The Management of Replication in a Distributed System. </title> <type> PhD thesis, </type> <institution> University of California at San Diego, </institution> <year> 1988. </year> <month> 66 </month>
Reference-contexts: With available copy, writes are sent to every copy of a data object, and reads are performed on any copy available. Failures are detected by sites that remain in operation <ref> [28] </ref>. In all of these protocols, there are significant weaknesses that adversely affect the robustness of a database. Both the primary site and primary copy protocols depend upon a single copy for all data updates on particular data objects. <p> Witnesses are not data objects; they are records of the state of the data object [33]. A witness must be a part of the quorum when the voting entity reads data objects. Other modifications of these simple algorithms include dynamic vote adjustment [4] and dynamic quorum adjustment <ref> [28] </ref> protocols. These algorithms make a distributed database more sensitive to changes in its configuration, and this increases the robustness of the database. <p> Hence, the loss of one half of the sites will bring the system to a halt, regardless of the fact that many of the servers may still be running <ref> [28] </ref>. As a result of this problem, we would like to implement an algorithm that has dynamic quorum adjustment. This way, random failures of sites and heavily loaded networks will not result in large numbers of unnecessary procedure call failures.
Reference: [29] <author> B. Martin, C. Bergan, and B. Russ. PARPC: </author> <title> a system for parallel procedure calls. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing. IEEE, </booktitle> <year> 1987. </year>
Reference-contexts: To avoid concerning programmers with these details, we have implemented a stub compiler to generate the code required to execute remote procedures. It is similar to the idea presented by Martin, et al. in their parallel remote procedure call package <ref> [29] </ref> and Reid's RPCC stub compiler [36]. Our stub compiler uses the keywords, remote and external as indications of which set of run-time library routines the application must call. <p> One example is the PARPC system presented by Martin et al., which calls several procedures in parallel and blocks only until one of the results returns. A client processes the results from the single invocation and then resumes its blocked state until another invocation returns a result <ref> [29] </ref>. A way for us to approach the problem of asynchronous procedure calls would be to add a type specifier to the ANSI C language that will indicate an asynchronous remote procedure call. This would cause the stub compiler to create stubs that excluded the return process.
Reference: [30] <author> J. H. Morris, M. Satyanarayanan, M. H. Conner, J. H. Howard, D. S. Rosenthal, and F. D. Smith. Andrew: </author> <title> a distributed personal computing environment. </title> <journal> Communications of the ACM, </journal> <volume> 29(3) </volume> <pages> 184-201, </pages> <year> 1986. </year>
Reference-contexts: In addition to remote procedure calls, there are distributed file systems, remote execution, and remote evaluation. Distributed file systems are environments in which files and resources are accessible across machine boundaries. There are several such systems, including NFS 1 [37], the Andrew file system (AFS) <ref> [30] </ref>, Alpine [10], and many others. Although this paradigm primarily deals with the distribution of resources, it is related to the topic of remote procedure calls in the following sense. A programmer can conduct distributed computation in a distributed file system by using files as communication mechanisms.
Reference: [31] <institution> National Bureau of Standards (United States). Data encryption standard, </institution> <year> 1977. </year> <title> Federal Information Processing Standards No. </title> <type> 46. </type>
Reference-contexts: Both of these issues are very important in a distributed computing environment. In remote procedure call environments, one commonly used method for secure data transmission is incorporation of an established encryption mechanism into the package. For instance, the Cedar RPC package uses the Data Encryption Standard (DES) <ref> [31] </ref> for optional intruder protection [46]. DES provides protection from eavesdropping, and it detects attempts at modification, replay, and call creation. There is widely available software implementing the DES standard. There are different ways to handle the problem of user permissions. <p> This is one of the additions that we would like to make to our package. We would like to handle the problem of network transmission by simply using an established data encryption mechanism, as was done in the Cedar RPC facility [6]. For the Data Encryption Standard (DES) <ref> [31] </ref>, there is a great deal of available software. We could incorporate this into our package. DES works through private keys. If private keys are created as a part of the initial connection establishment process, then secure communication between a client and a particular procedure server could continue.
Reference: [32] <author> D. Otway. </author> <title> Remote execution: a model for process to process interactions. </title> <booktitle> In Proceedings of the International Open Systems Conference, </booktitle> <pages> pages 363-376. </pages> <publisher> IEEE, </publisher> <month> March </month> <year> 1987. </year>
Reference-contexts: It has the advantages of asynchronous messaging, back calls, rapid bulk delivery, rate based flow control, and portability across file systems. While these features can be useful in certain situations, it would be too heavyweight to start processes for the smaller tasks that remote procedures often handle <ref> [32] </ref>. A more appropriate paradigm for distributed programming is remote evaluation. With remote evaluation, a client program sends executable code to another machine, and a server on the receiving machine executes it.
Reference: [33] <author> J.-F. Paris. </author> <title> Voting with witnesses: A consistency scheme for replicated files. </title> <booktitle> In Proceedings of the 6th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 606-612, </pages> <address> Cambridge, 1986. </address> <publisher> IEEE. </publisher>
Reference-contexts: Weighting of sites depends upon the characteristics of the site. Another way of improving majority consensus voting is to create witnesses. Witnesses are not data objects; they are records of the state of the data object <ref> [33] </ref>. A witness must be a part of the quorum when the voting entity reads data objects. Other modifications of these simple algorithms include dynamic vote adjustment [4] and dynamic quorum adjustment [28] protocols.
Reference: [34] <author> D. A. Patterson and J. L. Hennessy. </author> <title> Computer Architecture: A Quantitive Approach. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, California, </address> <year> 1990. </year>
Reference-contexts: One byte is used to indicate the type of data to follow, and 64 bits are used to indicate the number of data items of this type. Our network standard uses Big-Endian <ref> [34] </ref> byte ordering because of its popularity in UNIX-related systems. Through the cooperative activity of all of these modules and services, we cover nearly all of the issues concerning a complete remote procedure call facility. We designed each component of the package to maximize efficiency, robustness, and flexibility.
Reference: [35] <author> J. B. Postel. </author> <title> User Datagram Protocol. </title> <type> Technical Report RFC-768, </type> <institution> USC Information Sciences Institute, </institution> <month> August </month> <year> 1980. </year>
Reference-contexts: If only the acknowledgment of the acknowledgment is lost, both sides can still behave as if the transmission has successfully completed. We implemented our data transmission mechanism with UNIX sockets and the UDP transmission protocol <ref> [35] </ref>. UDP is an unreliable, connectionless protocol that sends small packets of data (called datagrams) across the network. The advantage of using UDP is low overhead. Connection-oriented protocols require establishment of exclusive connections for each transmission session.
Reference: [36] <author> I. Reid. </author> <title> RPCC-a stub compiler for Sun RPC. </title> <booktitle> In Proceedings of Summer 1987 USENIX Conference, </booktitle> <pages> pages 8-12. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: A similar idea has been done for the Sun RPC package. Irving Reid, as described in his paper on RPCC, developed a stub compiler that created Sun RPC stubs from what he called annotated C programs <ref> [36] </ref>. It automatically generates XDR functions and procedure stubs that use the available Sun RPC library routines. It operates by interpreting C comments as RPCC commands. <p> To avoid concerning programmers with these details, we have implemented a stub compiler to generate the code required to execute remote procedures. It is similar to the idea presented by Martin, et al. in their parallel remote procedure call package [29] and Reid's RPCC stub compiler <ref> [36] </ref>. Our stub compiler uses the keywords, remote and external as indications of which set of run-time library routines the application must call. The stub compiler generates server and client stub routines that consist primarily of run-time library function calls. 21 3.2 Semantics The semantics in this package are simple.
Reference: [37] <author> R. Sandberg, D. Goldberg, S. Kleiman, D. Walsh, and B. Lyon. </author> <title> Design and implementation of the Sun network file system. </title> <booktitle> In Proceedings of the Summer 1985 USENIX Conference, </booktitle> <pages> pages 119-130, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: In addition to remote procedure calls, there are distributed file systems, remote execution, and remote evaluation. Distributed file systems are environments in which files and resources are accessible across machine boundaries. There are several such systems, including NFS 1 <ref> [37] </ref>, the Andrew file system (AFS) [30], Alpine [10], and many others. Although this paradigm primarily deals with the distribution of resources, it is related to the topic of remote procedure calls in the following sense.
Reference: [38] <author> M. D. Schroeder and M. Burrows. </author> <title> Performance of Firefly RPC. </title> <journal> Operating Systems Review, </journal> <volume> 23(5) </volume> <pages> 83-90, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: This facilitates binding between clients and servers. The overall structure of the Cedar RPC facility has become standard for remote procedure call packages. There are several other examples of fully implemented RPC systems. These include Xerox Courier [12], Firefly RPC <ref> [38] </ref>, Apollo RPC [14, 44] (which is the basis of DCE RPC 2 [16, 44]), and Sun RPC [22, 23, 44]. Sun RPC has become a de facto standard, since it is so widely used. DCE RPC, which is actually more versatile, is also gaining acceptance.
Reference: [39] <author> J. G. Segun and P. Wilms. </author> <title> A majority cnsensus algorithm for the consistency for duplicated and distribted information. </title> <booktitle> In Proceedings of the 1st International Converence on Distributed Computing Systems, </booktitle> <pages> pages 617-624. </pages> <publisher> IEEE, </publisher> <year> 1979. </year>
Reference-contexts: To avoid depending on these unwarranted assumptions, we chose to use algorithms that involved quorums and voting for data validation. For its distributed database, our package uses a simple quorum consensus protocol known as majority consensus voting <ref> [39] </ref>. For an entry to be valid, there must be a set 14 percentage (quorum) of exactly matching entries from the sites holding replicas of the database. There are several variations of this protocol.
Reference: [40] <author> R. Sethi. </author> <title> Programming Languages: Concepts and Constructs. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Menlo Park, California, </address> <year> 1989. </year>
Reference-contexts: There are several argument semantics, three of which concern us: call by reference, call by value, and call by value result <ref> [40] </ref>. With call by reference semantics, the address of the argument is passed to the procedure, and the procedure is able to permanently (outside of the scope of the procedure) change the value of that parameter.
Reference: [41] <author> K. B. </author> <title> Sheets. A kernel level remote procedure call mechanism. </title> <booktitle> In 11th Annual International Computer Software and Application Conference, </booktitle> <pages> pages 687-693. </pages> <publisher> IEEE, </publisher> <month> October </month> <year> 1987. </year>
Reference-contexts: Some remote procedure call environments have been integrated into the kernels of operating systems. Examples of these include XINU'S RPC facility <ref> [41] </ref>, the implementation of RPC in the Berkeley UNIX kernel [49], and Sprite RPC [48]. The Berkeley UNIX RPC and Sprite RPC facilities were largely experimental. Implementing RPC facilities in the kernel makes remote procedure calls significantly faster. However, this makes it impossible to expand them to heterogeneous environments.
Reference: [42] <author> S. K. Shrivastava and F. Panzieri. </author> <title> The design of a reliable remote procedure call mechanism. </title> <journal> In Transactions on Computers, </journal> <pages> pages 692-697. </pages> <publisher> IEEE, </publisher> <month> July </month> <year> 1982. </year>
Reference-contexts: The first issue is the choice of the underlying data transmission protocol. There are two categories of transmission protocols: transport connection services (virtual circuits) and datagram services <ref> [42] </ref>. Transport connection services are designed to provide fully reliable communication between processes. They involve establishment of exclusive connections between clients and servers and transmission of data as a logical stream.
Reference: [43] <author> J. W. Stamos and D. K. Gifford. </author> <title> Implementing remote evaluation. </title> <journal> IEEE Transactions on Softwae Engineering, </journal> <volume> 16(7) </volume> <pages> 710-722, </pages> <month> July </month> <year> 1990. </year> <month> 67 </month>
Reference-contexts: This paradigm has the advantage of accuracy with respect to the exact service being requested by the client (without added overhead). The problems with this idea are that it is significantly less intuitive to the programmer, and its semantics are more obscure (they use call-by-sharing argument semantics <ref> [43] </ref>. Since all of these methods have drawbacks with respect to distributed programming, we have chosen remote procedure calls. 1 Network File System 6 Remote procedure calls are one of the most widely used methods for distributed computation.
Reference: [44] <author> R. W. Stevens. </author> <title> UNIX Network Programming. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1990. </year>
Reference-contexts: This facilitates binding between clients and servers. The overall structure of the Cedar RPC facility has become standard for remote procedure call packages. There are several other examples of fully implemented RPC systems. These include Xerox Courier [12], Firefly RPC [38], Apollo RPC <ref> [14, 44] </ref> (which is the basis of DCE RPC 2 [16, 44]), and Sun RPC [22, 23, 44]. Sun RPC has become a de facto standard, since it is so widely used. DCE RPC, which is actually more versatile, is also gaining acceptance. <p> The overall structure of the Cedar RPC facility has become standard for remote procedure call packages. There are several other examples of fully implemented RPC systems. These include Xerox Courier [12], Firefly RPC [38], Apollo RPC [14, 44] (which is the basis of DCE RPC 2 <ref> [16, 44] </ref>), and Sun RPC [22, 23, 44]. Sun RPC has become a de facto standard, since it is so widely used. DCE RPC, which is actually more versatile, is also gaining acceptance. These are the primary packages to which we will compare our package. <p> There are several other examples of fully implemented RPC systems. These include Xerox Courier [12], Firefly RPC [38], Apollo RPC [14, 44] (which is the basis of DCE RPC 2 [16, 44]), and Sun RPC <ref> [22, 23, 44] </ref>. Sun RPC has become a de facto standard, since it is so widely used. DCE RPC, which is actually more versatile, is also gaining acceptance. These are the primary packages to which we will compare our package. <p> This idea is a part of the future work for our package. The second part of binding is finding the server on the specified host. To establish a connection with the correct server, the client must find the server's network endpoint <ref> [44] </ref>. A commonly used method is maintaining a database that holds the procedure connection information. Cedar RPC uses the Grapevine distributed database [8]. <p> Despite this drawback, we chose to use this method because of the simplicity of its construction. 16 Another way of translating between different data representations is the receiver-makes-it-right conversion method [9]. Apollo NDR uses this method for data conversion <ref> [44] </ref>. The idea of receiver-makes-it-right is leaving the responsibility for all type conversion to the receiving side. With these semantics, types are converted directly between varying architectures without the intermediate conversion. <p> One way is to provide identification information that the server can use to decide whether a request should be granted. Sun RPC provides a UNIX authentication option that includes a time stamp, a local host name, and the client's effective IDs (user and group) <ref> [44] </ref>. Using this method requires a mechanism (such as a database) to determine whether certain IDs 18 have permission to execute particular services. Also, user-identification would require a way of identifying users across different environments. <p> In Sun RPC, the data to be sent across the network using a connectionless protocol must be capable of fitting into one datagram packet of a size determined by the package <ref> [44] </ref>. Thus, Sun RPC encourages greater dependence upon connection-oriented protocols. There are many established mechanisms for transmitting across a network using connectionless protocols. <p> The problem of restricting the users of a particular procedure could be handled similarly. Sun RPC, as mentioned in Section 2.2.9, offers the options of both UNIX authentication and DES authentication <ref> [44] </ref>. Since our goal is to make our package usable in heterogeneous environments, we do not feel the need to implement operating system specific authentication. A viable alternative would be to use DES authentication for our package.
Reference: [45] <author> M. Stonebreaker. </author> <title> Concurrency control and consistency of multiple copies of data in distributed Ingres. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5:188-194, </volume> <month> May </month> <year> 1979. </year>
Reference-contexts: A number of different methods have been developed to handle these problems. There are a number of very simple protocols that have been developed for replicated data management. Some examples of these are the primary site [2], primary copy <ref> [45] </ref>, and available copy [5] protocols. The problem with these simple protocols is that they approach distributed data management in a naive fashion. The primary site protocol involves storing data at a primary site with copies of the original at a set of cohort sites.
Reference: [46] <author> D. C. Swinehart, P. T. Zellweger, R. J. Beach, and R. B. Hagmann. </author> <title> A structural view of the cedar programming environment. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(4) </volume> <pages> 419-490, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: In remote procedure call environments, one commonly used method for secure data transmission is incorporation of an established encryption mechanism into the package. For instance, the Cedar RPC package uses the Data Encryption Standard (DES) [31] for optional intruder protection <ref> [46] </ref>. DES provides protection from eavesdropping, and it detects attempts at modification, replay, and call creation. There is widely available software implementing the DES standard. There are different ways to handle the problem of user permissions.
Reference: [47] <author> A. S. Tannenbaum. </author> <title> Computer Networks. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1988. </year>
Reference-contexts: Transport connections must maintain state information and send numerous packets across the network simply to establish the connection. Since the cost of connection-oriented data transmission is so high, we chose to use a datagram service <ref> [47] </ref>. Using connectionless transmission protocols creates the need for a reliable datagram transmission algorithm. Several protocols have been been created for connectionless data transmission. One protocol is the stop-and-wait protocol. <p> The tasks of these routines include packing all of the data into structures interpreted on the application level <ref> [47] </ref> and using the byte-level marshaling routines to convert them to the network standard representation. The structures created in these routines simply associate a type definition, a type size, and an array size with each argument. <p> The multiple read and write operations performed by these functions are carried out in parallel. 4.5 Networking Module The networking module provides the functions that actually send byte streams across the network. It implements the sliding window protocol with selective repeat <ref> [47] </ref>. This protocol consists of creating a set sequence size of packet numbers, setting a window size, and restricting the valid number of acceptable packets to the range of the window. The window moves modularly through the sequence numbers, expanding and contracting as acknowledgments are received. <p> Whenever the window is advanced, sliding receive copies the data into the return buffer in the proper order. These two functions complete a data transmission session whenever the receiver verifies that it has received all of the packets. To handle this, we implemented a three way handshake <ref> [47] </ref> algorithm for transmission termination. In three way handshake, when the receiver acknowledges the last packet, the sender must acknowledge the termi 38 nating acknowledgment. We added this to be sure the sender knows that the last packet has been successfully transmitted. <p> Since this error will be propagated back through all levels of the package, this could lead to inconsistent results for the user. Although we implemented a three-way-handshake <ref> [47] </ref> to help alleviate some of this problem, problems can still arise with the loss of final packets. The second set of difficulties that we encountered during our implementation involved the stub compiler.
Reference: [48] <author> B. B. Welch. </author> <title> The Sprite remote procedure call system. </title> <type> Technical Report UCB/CSD 86/302, </type> <institution> University of California at Berkeley, </institution> <month> June </month> <year> 1986. </year>
Reference-contexts: Some remote procedure call environments have been integrated into the kernels of operating systems. Examples of these include XINU'S RPC facility [41], the implementation of RPC in the Berkeley UNIX kernel [49], and Sprite RPC <ref> [48] </ref>. The Berkeley UNIX RPC and Sprite RPC facilities were largely experimental. Implementing RPC facilities in the kernel makes remote procedure calls significantly faster. However, this makes it impossible to expand them to heterogeneous environments.
Reference: [49] <author> K. White. </author> <title> An implementation of a remote procedure call protocol in the Berkeley UNIX kernel. </title> <type> Technical Report UCB/CSD 85/248, </type> <institution> Computer Science Divisions, Department of Electrical Engineering and Computer Science, University of California at Berkeley, </institution> <month> June </month> <year> 1985. </year>
Reference-contexts: Some remote procedure call environments have been integrated into the kernels of operating systems. Examples of these include XINU'S RPC facility [41], the implementation of RPC in the Berkeley UNIX kernel <ref> [49] </ref>, and Sprite RPC [48]. The Berkeley UNIX RPC and Sprite RPC facilities were largely experimental. Implementing RPC facilities in the kernel makes remote procedure calls significantly faster. However, this makes it impossible to expand them to heterogeneous environments.
References-found: 49

