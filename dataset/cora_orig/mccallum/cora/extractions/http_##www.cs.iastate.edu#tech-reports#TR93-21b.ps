URL: http://www.cs.iastate.edu/tech-reports/TR93-21b.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: 
Title: Blended Algebraic and Denotational Semantics for ADT Languages with Mutable Objects  
Author: Gary T. Leavens and Krishna Kishore Dhara TR #-b Gary T. Leavens and Krishna Kishore Dhara, 
Degree: All rights reserved.  
Keyword: algebraic semantics, algebraic models, denotational semantics, abstract data type, objects, mutation, model theory, simulation relation. 1992 CR Categories: D.3.3 [Programming Languages] Language Constructs Abstract data types; F.3.2 [Logics and Meanings of Programs] Semantics of Programming Languages algebraic approaches to semantics, denotational semantics.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa Sate University  
Note: Submitted for publication. c  
Date: September, 1993 (Revised March, September 1994)  1993, 1994.  
Abstract: The original versions (TR93-21 and TR93-21a) of this report were titled "A Model Theory for Abstract Data Types with Mutable Objects (extended abstract)". 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. J. Alencar and J. A. Goguen. </author> <title> OOZE: An object oriented Z environment. </title> <editor> In P. America, editor, </editor> <booktitle> ECOOP '91: European Conference on Object Oriented Programming, volume 512 of Lecture Notes in Computer Science, </booktitle> <pages> pages 180-199. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: These authors did not investigate simulation relations, or the use of mixed algebraic and denotational semantics. Several authors use Kripke (i.e., possible world) models to give semantics to mutation and object identities [18] <ref> [1] </ref> [72] [25]. One could consider our algebras to be Kripke models if we were to include the store as part of the algebra. However, we believe that keeping the store outside the algebra leads to a cleaner separation of the algebra and the semantics of .
Reference: [2] <author> Pierre America. </author> <title> Inheritance and subtyping in a parallel object-oriented language. </title> <editor> In Jean Bezivin et al., editors, </editor> <booktitle> ECOOP '87, European Conference on Object-Oriented Programming, Paris, France, </booktitle> <pages> pages 234-242, </pages> <address> New York, N.Y., </address> <month> June </month> <year> 1987. </year> <title> Springer-Verlag. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 276. </volume>
Reference-contexts: 1 Introduction Abstract data types (ADTs) are important in programming, particularly in object-oriented (OO) programming. The recent interest in OO programming has focused renewed attention on problems of specifying and verifying such programs <ref> [2] </ref> [40] [32] [3] [28] [68] [67]. A key idea in the verification of OO programs is that of behavioral subtyping.
Reference: [3] <author> Pierre America. </author> <title> Designing an object-oriented programming language with behavioural subtyping. </title> <editor> In J. W. de Bakker, W. P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop, Noordwijkerhout, The Netherlands, May/June 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 60-90. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Abstract data types (ADTs) are important in programming, particularly in object-oriented (OO) programming. The recent interest in OO programming has focused renewed attention on problems of specifying and verifying such programs [2] [40] [32] <ref> [3] </ref> [28] [68] [67]. A key idea in the verification of OO programs is that of behavioral subtyping.
Reference: [4] <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland Publishing Co., </publisher> <address> New York, N.Y., </address> <year> 1984. </year> <note> Revised Edition. </note>
Reference-contexts: Stack ADT, the push method produces a new stack value, it does not mutate an object. fl This work was supported in part by the National Science Foundation under Grant CCR-9108654. 1 Denotational semantics [64] [57] [44] also is based on a referentially transparent model theory (the lambda calculus [9] <ref> [4] </ref>), but since the techniques of denotational semantics are designed to model programming languages, not equational specifications, it does not have any difficulty in modeling state, mutation, and aliasing.
Reference: [5] <editor> M. Bidoit, H.-J. Kreowski, P. Lescanne, F. Orejas, and D. Sannella, editors. </editor> <title> Algebraic System Specification and Development: A Survey and Annotated Bibliography, </title> <booktitle> volume 501 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> ISBN 0-387-54060-1. </note>
Reference-contexts: A key idea in the verification of OO programs is that of behavioral subtyping. Because a model of an ADT can be thought of as a mathematical abstraction of an ADT specification (or the code that implements it) [49] [35] [15] [14] [74] <ref> [5] </ref>, several authors have used the variations on multi-sorted algebras as a formal framework for studying behavioral subtyping [7] [32] [30] [51] [33].
Reference: [6] <author> Hans-Juergen Boehm. </author> <title> Side effects and aliasing can have simple axiomatic descriptions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(4) </volume> <pages> 637-655, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: Perhaps dynamic logic or other related axiomatic specification techniques <ref> [6] </ref> would be useful in specifying our models, or in developing their theory. Another possibility is developing the theory more fully by defining the appropriate category or institution [55]. 40 Another direction for future work is to extend our results to more interesting languages.
Reference: [7] <author> Kim B. Bruce and Peter Wegner. </author> <title> An algebraic model of subtype and inheritance. </title> <editor> In Francois Ban~cilhon and Peter Buneman, editors, </editor> <booktitle> Advances in Database Programming Languages, </booktitle> <pages> pages 75-96. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Because a model of an ADT can be thought of as a mathematical abstraction of an ADT specification (or the code that implements it) [49] [35] [15] [14] [74] [5], several authors have used the variations on multi-sorted algebras as a formal framework for studying behavioral subtyping <ref> [7] </ref> [32] [30] [51] [33].
Reference: [8] <author> Jolly Chen. </author> <title> The Larch/Generic interface language. </title> <type> Technical report, </type> <institution> Massachusetts Institute of Technology, EECS department, </institution> <month> May </month> <year> 1989. </year> <note> The author's Bachelor's thesis. Available from John Guttag at MIT (guttag@lcs.mit.edu). </note>
Reference-contexts: Stores are defined simultaneously, but are not contained in -algebras. This definition of algebra and stores below was inspired by work on models of types for interface specification languages [73] <ref> [8] </ref>. To explain a term used in the definition below, a finite function, f : S fin ! T is a function S ! T ? such that f has a proper result (not ?) only on a finite number of arguments. <p> The detailed semantics of type and method declarations are suppressed, because one only deals with their denotations: algebras of a given signature. 39 4 Related Work Our algebraic models are based, in part, on the work of Wing [73] and Chen <ref> [8] </ref>. These authors did not investigate simulation relations, or the use of mixed algebraic and denotational semantics. Several authors use Kripke (i.e., possible world) models to give semantics to mutation and object identities [18] [1] [72] [25].
Reference: [9] <author> A. Church. </author> <title> The Calculi of Lambda Conversion, </title> <booktitle> volume 6 of Annals of Mathematics Studies. </booktitle> <publisher> Princeton University Press, </publisher> <address> Princeton, N.J., </address> <year> 1941. </year> <title> Reprinted by Klaus Reprint Corp., </title> <address> New York in 1965. </address>
Reference-contexts: standard Stack ADT, the push method produces a new stack value, it does not mutate an object. fl This work was supported in part by the National Science Foundation under Grant CCR-9108654. 1 Denotational semantics [64] [57] [44] also is based on a referentially transparent model theory (the lambda calculus <ref> [9] </ref> [4]), but since the techniques of denotational semantics are designed to model programming languages, not equational specifications, it does not have any difficulty in modeling state, mutation, and aliasing.
Reference: [10] <author> William R. Cook. </author> <title> A denotational semantics of inheritance. </title> <type> Technical Report CS-89-33, </type> <institution> Department of Computer Science, Brown University, </institution> <address> Providence, Rhode Island, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: However, when one looks at the treatment of ADTs in the denotational semantics of programming languages such as CLU [56], or OO languages such as Smalltalk and CLOS <ref> [10] </ref>, one searches in vain for something that is easily identifiable as an algebraic model of the ADTs. Despite the clearly identifiable modules that define ADTs in such languages, there is no algebraic structure that is identifiable as the denotation of the program modules that implement ADTs.
Reference: [11] <author> N. G. de Bruijn. </author> <title> A survey of the project automath. </title> <editor> In J. P. Seldin and J. R. Hind-ley, editors, To H. B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 579-606. </pages> <publisher> Academic Press, Inc., </publisher> <address> New York, N.Y., </address> <year> 1980. </year>
Reference-contexts: This also means that the signature and algebra returned do not reflect these details of the representation of objects used in this semantics. Some remarks about the notation used below are also in order. The type of P is a dependent type <ref> [11] </ref> [58, Chapter 8]; for example, the signature of the algebra returned is the same as the signature returned. Recall that the signature and the -algebra A used below are defined in Figures 4 and 6.
Reference: [12] <author> Krishna Kishore Dhara. </author> <title> Subtyping among mutable types in object-oriented programming languages. </title> <type> Master's thesis, </type> <institution> Iowa State University, Department of Computer Science, Ames, Iowa, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: But the main thrust of our investigations with these techniques is to extend our notions of legal behavioral subtyping in object-oriented programming to types with mutable objects <ref> [12] </ref> [13]. As a first step, one could use something like our simulation relations to algebraically characterize when one set of ADTs with mutable objects implements another. 6 Conclusions The "split semantics" technique presented in this paper is a blend of algebraic and deno-tational semantics. <p> In support of this we have offered a notion of homomorphic relation (our simulation relations) and have shown that it is preserved by expressions and commands in a simple language. The addition of more realistic features to the language, such as loops, does not destroy this fundamental property <ref> [12] </ref> [13]. The semantics of the simple language, and the proof of this property demonstrate the utility of these techniques.
Reference: [13] <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Subtyping for mutable types in object-oriented programming languages. </title> <type> Technical Report 92-36, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, November </month> <year> 1992. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Because there is nothing analogous to a multi-sorted algebra in the semantics of such programming languages, it is difficult to apply ideas from multi-sorted algebras (such as behavioral subtyping for immutable objects). In our previous model-theoretic work on behavioral subtyping [34] [27] [33] <ref> [13] </ref>, we have tried to use algebraic structures as the denotations of ADT specifications, while at the same time working with a denotational semantics. <p> But the main thrust of our investigations with these techniques is to extend our notions of legal behavioral subtyping in object-oriented programming to types with mutable objects [12] <ref> [13] </ref>. As a first step, one could use something like our simulation relations to algebraically characterize when one set of ADTs with mutable objects implements another. 6 Conclusions The "split semantics" technique presented in this paper is a blend of algebraic and deno-tational semantics. <p> In support of this we have offered a notion of homomorphic relation (our simulation relations) and have shown that it is preserved by expressions and commands in a simple language. The addition of more realistic features to the language, such as loops, does not destroy this fundamental property [12] <ref> [13] </ref>. The semantics of the simple language, and the proof of this property demonstrate the utility of these techniques.
Reference: [14] <author> Hartmut Ehrig and Bernd Mahr. </author> <title> Fundamentals of Algebraic Specification 1: Equations and Initial Semantics. </title> <booktitle> EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1985. </year>
Reference-contexts: A key idea in the verification of OO programs is that of behavioral subtyping. Because a model of an ADT can be thought of as a mathematical abstraction of an ADT specification (or the code that implements it) [49] [35] [15] <ref> [14] </ref> [74] [5], several authors have used the variations on multi-sorted algebras as a formal framework for studying behavioral subtyping [7] [32] [30] [51] [33]. <p> A i n fg A g) [ f [ ~ S 7! f ]g A g]OPS A ) A To handle the hiding of the operation interpretations for operations named "creator (T)", "setter (I)", or "getter (I)", we adapt the notion of a reduct of an algebra (see, for example, <ref> [14, Section 6.8] </ref>) to this setting. Since we will only be using reducts to hide such operations, we only define Aj (hideInternalMessages ) for a -algebra A. Let OPS and OPS 0 be the operation symbols of and (hideInternalMessages ), respectively.
Reference: [15] <author> J. A. Goguen, J. W. Thatcher, and E. G. Wagner. </author> <title> An initial algebra approach to the specification, correctness and implementation of abstract data types. </title> <editor> In Raymond T. Yeh, editor, </editor> <booktitle> Current Trends in Programming Methodology, </booktitle> <volume> volume 4, </volume> <pages> pages 80-149. </pages> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1978. </year>
Reference-contexts: A key idea in the verification of OO programs is that of behavioral subtyping. Because a model of an ADT can be thought of as a mathematical abstraction of an ADT specification (or the code that implements it) [49] [35] <ref> [15] </ref> [14] [74] [5], several authors have used the variations on multi-sorted algebras as a formal framework for studying behavioral subtyping [7] [32] [30] [51] [33].
Reference: [16] <author> J. A. Goguen, J. W. Thatcher, E. G. Wagner, and J. B. Wright. </author> <title> Initial algebra semantics and continuous algebras. </title> <journal> Journal of the ACM, </journal> <volume> 24 </volume> <pages> 68-95, </pages> <year> 1977. </year>
Reference-contexts: Recursive procedures seem to pose no particular difficulties; and we leave as future work the working out of the appropriate domain theory for constructing algebras with recursive methods and recursive data. Work on continuous algebras may be of use in solving such problems <ref> [16] </ref> [70] [20] [43] [74, Section 3.3.3]. Another feature not in is block structure, more specifically local declarations of types and methods.
Reference: [17] <author> Joseph A. Goguen. </author> <title> Realization is universal. </title> <journal> Math. Systems Theory, </journal> <volume> 6(4) </volume> <pages> 359-374, </pages> <year> 1973. </year>
Reference-contexts: An algebra may have more sort symbols than type symbols because it may be convenient to introduce hidden sorts in a model. (So, if we followed Goguen <ref> [17] </ref>, we would call algebras "machines".) The set of object types is the set of types whose objects are modeled by locations. An immutable object might be modeled by a location whose value never changes or might be modeled by a value that is not a location.
Reference: [18] <author> Joseph A. Goguen and Jose Meseguer. </author> <title> Unifying functional, object-oriented and relational programming with logical semantics. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1987. </year>
Reference-contexts: Although we have not done so, studying ways to give semantics to type and method declarations, or other languages for specifying such algebras might be fruitful. One could, for example, define the algebras not by programming, but by some specification method <ref> [18] </ref> or logic programming technique. Note especially that in Figure 8, we have given what amounts to an equational presentation of an algebra with mutable objects. The kind of mutation allowed is not just one-level mutation either; that is, it is not just variables containing pure values. <p> These authors did not investigate simulation relations, or the use of mixed algebraic and denotational semantics. Several authors use Kripke (i.e., possible world) models to give semantics to mutation and object identities <ref> [18] </ref> [1] [72] [25]. One could consider our algebras to be Kripke models if we were to include the store as part of the algebra. However, we believe that keeping the store outside the algebra leads to a cleaner separation of the algebra and the semantics of .
Reference: [19] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80, The Language and its Implementation. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1983. </year>
Reference-contexts: Alternatively, one could model first-class procedures as objects, and give them types and values in the algebra. (This would more closely correspond to Smalltalk <ref> [19] </ref>.) We leave it as future work to work out the details of such approaches. Recursive procedures seem to pose no particular difficulties; and we leave as future work the working out of the appropriate domain theory for constructing algebras with recursive methods and recursive data.
Reference: [20] <author> I. </author> <title> Guessarian. Algebraic Semantics, </title> <booktitle> volume 99 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1981. </year> <month> 48 </month>
Reference-contexts: Recursive procedures seem to pose no particular difficulties; and we leave as future work the working out of the appropriate domain theory for constructing algebras with recursive methods and recursive data. Work on continuous algebras may be of use in solving such problems [16] [70] <ref> [20] </ref> [43] [74, Section 3.3.3]. Another feature not in is block structure, more specifically local declarations of types and methods.
Reference: [21] <author> Yuri Gurevich. </author> <title> Evolving algebras: A tutorial introduction. </title> <journal> Bulletin of the EATCS, </journal> <volume> 43 </volume> <pages> 264-284, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: This is done in order to keep the meaning of the algebra fixed and the semantics of the algebra's methods purely functional. If the store were part of the algebra, then the algebra would change (evolve, as in <ref> [21] </ref> [22]), but then the denotational semantics would lose its characteristic referential transparency; that is, the denotational semantics would no longer be written over a purely functional base. <p> For homomorphic relationships on Kripke models to be preserved by programs, the environment would also have to be included in the Kripke model, which would further destroy our separation between the language semantics and the semantics of the data types. Evolving algebras <ref> [21] </ref> [22] are algebraic structures whose operations may be updated. The relationship between our algebraic models and evolving algebras seems to be that our state plus our algebra is very similar to an evolving algebra.
Reference: [22] <author> Yuri Gurevich. </author> <title> Evolving algebras: An attempt to discover semantics. </title> <editor> In G. Rozenberg and A. Salomaa, editors, </editor> <booktitle> Current Trends in Theoretical Computer Science, </booktitle> <pages> pages 266-292. </pages> <publisher> World Scientific, </publisher> <year> 1993. </year>
Reference-contexts: This is done in order to keep the meaning of the algebra fixed and the semantics of the algebra's methods purely functional. If the store were part of the algebra, then the algebra would change (evolve, as in [21] <ref> [22] </ref>), but then the denotational semantics would lose its characteristic referential transparency; that is, the denotational semantics would no longer be written over a purely functional base. <p> For homomorphic relationships on Kripke models to be preserved by programs, the environment would also have to be included in the Kripke model, which would further destroy our separation between the language semantics and the semantics of the data types. Evolving algebras [21] <ref> [22] </ref> are algebraic structures whose operations may be updated. The relationship between our algebraic models and evolving algebras seems to be that our state plus our algebra is very similar to an evolving algebra.
Reference: [23] <author> Yuri Gurevich and James K. Huggins. </author> <title> The semantics of the c programming language. </title> <editor> In E. Borger et al., editors, </editor> <booktitle> Computer Science Logic, Proceedings, 1992, volume 702 of Lecture Notes in Computer Science, </booktitle> <pages> pages 274-308. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1992. </year> <note> Errata to appear in the 1993 Computer Science Logic proceedings. Corrected copy obtained from the authors. </note>
Reference-contexts: one part of the "algebra" that evolves, namely not our algebra but our environment and store, makes our semantics more of a blend of denotational semantics and algebraic model theory than evolving algebras, as one can see by comparing our semantics with the evolving algebra semantics for C given in <ref> [23] </ref>. Action semantics [45] [71, Chapters 7-8] also uses algebraic techniques to specify data more abstractly than standard denotational semantics. However, in action semantics, the locations are not part of the algebra, and so the datatypes that one specifies must be immutable.
Reference: [24] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(4) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: In other words, our model of an object is a typed location. Locations are typed in the sense that a location l : T can only store a value of type T . Each object (location) contains a value, sometimes called an "abstract value" <ref> [24] </ref>, which can be extracted by a store mapping, as is usual in denotational semantics [57]. (This resembles Scheifler's denotational semantics of CLU [56], and would be similar to a semantics of LISP.) An object may "contain" other objects, if its value contains other locations.
Reference: [25] <author> R. Jungclaus, G. Saake, and C. Sernadas. </author> <title> Formal specification of object systems. </title> <editor> In S. Abramsky and T. S. E. Maibaum, editors, </editor> <booktitle> TAPSOFT '91, Proceedings of the International Joint Conference on Theory and Practice of Software Development, Brighton, UK, Volume 2, Advances in Distributed Computing (ADC) and Colloquium on Combining Paradigms for Software Development (CCPSD), volume 494 of Lecture Notes in Computer Science, </booktitle> <pages> pages 60-82. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> April </month> <year> 1991. </year>
Reference-contexts: These authors did not investigate simulation relations, or the use of mixed algebraic and denotational semantics. Several authors use Kripke (i.e., possible world) models to give semantics to mutation and object identities [18] [1] [72] <ref> [25] </ref>. One could consider our algebras to be Kripke models if we were to include the store as part of the algebra. However, we believe that keeping the store outside the algebra leads to a cleaner separation of the algebra and the semantics of . <p> Mason and Talcott focus on equational logics for reasoning about programs that use mutation, whereas our work has not progressed to a reasoning calculus. 5 Future Work In view of the use of dynamic logic [26] in some of the related work on Kripke models [72] <ref> [25] </ref>, it would be interesting to investigate the relationship between our techniques and dynamic logic. Perhaps dynamic logic or other related axiomatic specification techniques [6] would be useful in specifying our models, or in developing their theory.
Reference: [26] <author> Dexter Kozen and J. Tiuryn. </author> <title> Logics of programs. </title> <editor> In J. van Leewen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 14, </booktitle> <pages> pages 789-840. </pages> <publisher> The MIT Press, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: Mason and Talcott focus on equational logics for reasoning about programs that use mutation, whereas our work has not progressed to a reasoning calculus. 5 Future Work In view of the use of dynamic logic <ref> [26] </ref> in some of the related work on Kripke models [72] [25], it would be interesting to investigate the relationship between our techniques and dynamic logic. Perhaps dynamic logic or other related axiomatic specification techniques [6] would be useful in specifying our models, or in developing their theory.
Reference: [27] <author> Gary T. Leavens. </author> <title> Modular verification of object-oriented programs with subtypes. </title> <type> Technical Report 90-09, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, July </month> <year> 1990. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Because there is nothing analogous to a multi-sorted algebra in the semantics of such programming languages, it is difficult to apply ideas from multi-sorted algebras (such as behavioral subtyping for immutable objects). In our previous model-theoretic work on behavioral subtyping [34] <ref> [27] </ref> [33] [13], we have tried to use algebraic structures as the denotations of ADT specifications, while at the same time working with a denotational semantics.
Reference: [28] <author> Gary T. Leavens. </author> <title> Modular specification and verification of object-oriented programs. </title> <journal> IEEE Software, </journal> <volume> 8(4) </volume> <pages> 72-80, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Abstract data types (ADTs) are important in programming, particularly in object-oriented (OO) programming. The recent interest in OO programming has focused renewed attention on problems of specifying and verifying such programs [2] [40] [32] [3] <ref> [28] </ref> [68] [67]. A key idea in the verification of OO programs is that of behavioral subtyping. <p> For simplicity, the "output" of the main procedure (and hence the program) is defined to be the values of the constants in D 2 . The split of the main procedure into two parts is motivated by our studies of behavioral subtyping [32] <ref> [28] </ref> [30]. Informally, OO programmers often add new subtypes of existing types to a running program, with the expectation that once objects of the new subtypes are created the rest of the program will continue running as before. <p> Since we will be ignoring the details of type and method declarations, in what follows, let = (TYPES; OPS; ResType) stand for an arbitrary signature. The simulation relations we study help one decide when one ADT behaves like an other [59] [46] <ref> [28] </ref> [31]. This is useful in theoretical contexts [42]; also the general idea of 28 simulation and refinement of ADTs is important for optimization. If the abstraction of a faster implementation simulates a slower one's behavior, then one can replace the slower implementation by the faster implementation.
Reference: [29] <author> Gary T. Leavens and Krishna Kishore Dhara. </author> <title> A foundation for the model theory of abstract data types with mutation and aliasing (preliminary version). </title> <type> Technical Report 92-35, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, November </month> <year> 1992. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Our models have features for investigating observability notions, such as observable equivalence; we are trying to use these features to precisely define a notion of "observable aliasing" for objects of abstract data types <ref> [29] </ref>. But the main thrust of our investigations with these techniques is to extend our notions of legal behavioral subtyping in object-oriented programming to types with mutable objects [12] [13].
Reference: [30] <author> Gary T. Leavens and Don Pigozzi. </author> <title> Typed homomorphic relations extended with sub-types. </title> <type> Technical Report 91-14, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, June </month> <year> 1991. </year> <booktitle> Appears in the proceedings of Mathematical Foundations of Programming Semantics '91, Springer-Verlag, Lecture Notes in Computer Science, </booktitle> <volume> volume 598, </volume> <pages> pages 144-167, </pages> <year> 1992. </year>
Reference-contexts: Because a model of an ADT can be thought of as a mathematical abstraction of an ADT specification (or the code that implements it) [49] [35] [15] [14] [74] [5], several authors have used the variations on multi-sorted algebras as a formal framework for studying behavioral subtyping [7] [32] <ref> [30] </ref> [51] [33]. <p> In Section 3 we also show that this notion of simulation is preserved by expressions and commands in this language. This kind of theorem is the key to model-theoretic study of subtyping (compare <ref> [30] </ref>). Following this we discuss related work in Section 4, future work and open problems in Section 5, and offer some conclusions in Section 6. 2 A Simple Language This section presents the syntax and semantics of a simple language, called . <p> For simplicity, the "output" of the main procedure (and hence the program) is defined to be the values of the constants in D 2 . The split of the main procedure into two parts is motivated by our studies of behavioral subtyping [32] [28] <ref> [30] </ref>. Informally, OO programmers often add new subtypes of existing types to a running program, with the expectation that once objects of the new subtypes are created the rest of the program will continue running as before. The behavior will be "enhanced" but nothing should break in the unchanged code. <p> We are especially interested in studying behavioral properties of algebraic models with mutable types in the context of object-oriented programming. In such studies we often define languages that compute over models of ADTs, allowing us to start with the algebraic structures and compare their properties (for example, <ref> [30] </ref>). A small example of such a study appears in the next section. However, we hasten to point out that others are also interested in questions of behavioral properties of programs. For example, full abstraction is such a question.
Reference: [31] <author> Gary T. Leavens and Don Pigozzi. </author> <title> Typed homomorphic relations extended with sub-types. </title> <editor> In Stephen Brookes, editor, </editor> <booktitle> Mathematical Foundations of Programming Semantics '91, volume 598 of Lecture Notes in Computer Science, </booktitle> <pages> pages 144-167. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1992. </year> <month> 49 </month>
Reference-contexts: Since we will be ignoring the details of type and method declarations, in what follows, let = (TYPES; OPS; ResType) stand for an arbitrary signature. The simulation relations we study help one decide when one ADT behaves like an other [59] [46] [28] <ref> [31] </ref>. This is useful in theoretical contexts [42]; also the general idea of 28 simulation and refinement of ADTs is important for optimization. If the abstraction of a faster implementation simulates a slower one's behavior, then one can replace the slower implementation by the faster implementation.
Reference: [32] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about object-oriented programs that use subtypes (extended abstract). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 212-223, </pages> <month> October </month> <year> 1990. </year> <booktitle> OOPSLA ECOOP '90 Proceedings, N. Meyrowitz (editor). </booktitle>
Reference-contexts: 1 Introduction Abstract data types (ADTs) are important in programming, particularly in object-oriented (OO) programming. The recent interest in OO programming has focused renewed attention on problems of specifying and verifying such programs [2] [40] <ref> [32] </ref> [3] [28] [68] [67]. A key idea in the verification of OO programs is that of behavioral subtyping. <p> Because a model of an ADT can be thought of as a mathematical abstraction of an ADT specification (or the code that implements it) [49] [35] [15] [14] [74] [5], several authors have used the variations on multi-sorted algebras as a formal framework for studying behavioral subtyping [7] <ref> [32] </ref> [30] [51] [33]. <p> For simplicity, the "output" of the main procedure (and hence the program) is defined to be the values of the constants in D 2 . The split of the main procedure into two parts is motivated by our studies of behavioral subtyping <ref> [32] </ref> [28] [30]. Informally, OO programmers often add new subtypes of existing types to a running program, with the expectation that once objects of the new subtypes are created the rest of the program will continue running as before.
Reference: [33] <author> Gary T. Leavens and William E. Weihl. </author> <title> Subtyping, modular specification, and modular verification for applicative object-oriented programs. </title> <type> Technical Report 92-28d, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, August </month> <year> 1994. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: a model of an ADT can be thought of as a mathematical abstraction of an ADT specification (or the code that implements it) [49] [35] [15] [14] [74] [5], several authors have used the variations on multi-sorted algebras as a formal framework for studying behavioral subtyping [7] [32] [30] [51] <ref> [33] </ref>. <p> Because there is nothing analogous to a multi-sorted algebra in the semantics of such programming languages, it is difficult to apply ideas from multi-sorted algebras (such as behavioral subtyping for immutable objects). In our previous model-theoretic work on behavioral subtyping [34] [27] <ref> [33] </ref> [13], we have tried to use algebraic structures as the denotations of ADT specifications, while at the same time working with a denotational semantics. <p> We require that such functions be polymorphic, because it affords considerable notational convenience; if we were modeling an object-oriented language with message passing, the polymorphism would be of the essence <ref> [33] </ref>, but in this setting we could excise it at the cost of additional notation. Stores are finite functions because they are not defined for all potential locations. <p> So the formulation of simulation relations we present relates states over one algebra to states over another algebra. (In this respect it is similar to the base case of the logical relations used, for example, in [47] [48] [65]. They are extensions of the relations used in <ref> [33] </ref>.) Definition 3.1 (simulation relation) Let C and A be -algebras.
Reference: [34] <author> Gary Todd Leavens. </author> <title> Verifying Object-Oriented Programs that use Subtypes. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> December </month> <year> 1988. </year> <note> Published as MIT/LCS/TR-439 in February 1989. </note>
Reference-contexts: Because there is nothing analogous to a multi-sorted algebra in the semantics of such programming languages, it is difficult to apply ideas from multi-sorted algebras (such as behavioral subtyping for immutable objects). In our previous model-theoretic work on behavioral subtyping <ref> [34] </ref> [27] [33] [13], we have tried to use algebraic structures as the denotations of ADT specifications, while at the same time working with a denotational semantics.
Reference: [35] <author> Barbara H. Liskov and Stephen N. Zilles. </author> <title> Specification techniques for data abstraction. </title> <journal> Transactions on Software Engineering, </journal> <volume> 1(1), </volume> <month> March </month> <year> 1975. </year>
Reference-contexts: A key idea in the verification of OO programs is that of behavioral subtyping. Because a model of an ADT can be thought of as a mathematical abstraction of an ADT specification (or the code that implements it) [49] <ref> [35] </ref> [15] [14] [74] [5], several authors have used the variations on multi-sorted algebras as a formal framework for studying behavioral subtyping [7] [32] [30] [51] [33].
Reference: [36] <author> I. A. Mason. </author> <title> The Semantics of Destructive Lisp. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1986. </year> <note> Also available as CSLI Lecture Notes No. </note> <month> 5, </month> <title> Center for the Study of Language and Information, </title> <publisher> Stanford University. </publisher>
Reference-contexts: The idea of computing over an algebra is also found in [66]. Our separation between the algebra and the semantics of is similar to what Mason and Talcott have studied the semantics of LISP <ref> [36] </ref> and other languages with mutation [37] [38]. Their work mainly uses operational semantics, and as such is complimentary to our denotational/algebraic approach.
Reference: [37] <author> Ian Mason and Carolyn Talcott. </author> <title> Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(3) </volume> <pages> 287-328, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: The idea of computing over an algebra is also found in [66]. Our separation between the algebra and the semantics of is similar to what Mason and Talcott have studied the semantics of LISP [36] and other languages with mutation <ref> [37] </ref> [38]. Their work mainly uses operational semantics, and as such is complimentary to our denotational/algebraic approach.
Reference: [38] <author> Ian A. Mason and Carolyn L. Talcott. </author> <title> References, local variables and operational reasoning. </title> <booktitle> In Seventh Annual Symposium on logic in computer science. IEEE, </booktitle> <year> 1992. </year>
Reference-contexts: The idea of computing over an algebra is also found in [66]. Our separation between the algebra and the semantics of is similar to what Mason and Talcott have studied the semantics of LISP [36] and other languages with mutation [37] <ref> [38] </ref>. Their work mainly uses operational semantics, and as such is complimentary to our denotational/algebraic approach.
Reference: [39] <author> Albert R. Meyer and Kurt Sieber. </author> <title> Towards fully abstract semantics for local variables: Preliminary report. </title> <booktitle> In Proc. 15 th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <address> San Diego, </address> <pages> pages 191-203. </pages> <publisher> ACM, </publisher> <year> 1988. </year>
Reference-contexts: The idea is to restrict the domain of procedure denotations so that a procedure can only affect certain variables, not the entire store <ref> [39] </ref>. Reddy has investigated another approach to the full abstraction problem for local variables that uses techniques akin to object-oriented programming to prevent unwanted 1 Yuri Gurevich, personal communication, March 1994. 27 modifications to the store [52].
Reference: [40] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: 1 Introduction Abstract data types (ADTs) are important in programming, particularly in object-oriented (OO) programming. The recent interest in OO programming has focused renewed attention on problems of specifying and verifying such programs [2] <ref> [40] </ref> [32] [3] [28] [68] [67]. A key idea in the verification of OO programs is that of behavioral subtyping.
Reference: [41] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: Such bindings cannot be changed, and are therefore constant bindings. This is not a great restriction, however, as the programmer can define any desired type of variables by defining objects with one field. (This is similar to the way variables are treated in, for example, SML <ref> [41] </ref> [50].) For example, the following shows how one would write integer variables. type IntVar fields (val: Int); method mkIntVar (e:Int): Void nothing; return new IntVar (e) -; method assign (v:IntVar, e:Int): Void - v.val := e; return nothing -; method read (v:IntVar): Int nothing; return v.val -; The form of
Reference: [42] <author> John C. Mitchell. </author> <title> Type systems for programming languages. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 8, </booktitle> <pages> pages 365-458. </pages> <publisher> North-Holland, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: The simulation relations we study help one decide when one ADT behaves like an other [59] [46] [28] [31]. This is useful in theoretical contexts <ref> [42] </ref>; also the general idea of 28 simulation and refinement of ADTs is important for optimization. If the abstraction of a faster implementation simulates a slower one's behavior, then one can replace the slower implementation by the faster implementation.
Reference: [43] <author> B. Moller. </author> <title> On the algebraic specification of infinite objects|ordered and continuous models of algebraic types. </title> <journal> Acta Informatica, </journal> <volume> 22 </volume> <pages> 537-578, </pages> <year> 1985. </year>
Reference-contexts: Recursive procedures seem to pose no particular difficulties; and we leave as future work the working out of the appropriate domain theory for constructing algebras with recursive methods and recursive data. Work on continuous algebras may be of use in solving such problems [16] [70] [20] <ref> [43] </ref> [74, Section 3.3.3]. Another feature not in is block structure, more specifically local declarations of types and methods.
Reference: [44] <author> Peter D. Mosses. </author> <title> Denotational semantics. </title> <editor> In J. van Leewen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 11, </booktitle> <pages> pages 577-631. </pages> <publisher> The MIT Press, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: For example, in the standard Stack ADT, the push method produces a new stack value, it does not mutate an object. fl This work was supported in part by the National Science Foundation under Grant CCR-9108654. 1 Denotational semantics [64] [57] <ref> [44] </ref> also is based on a referentially transparent model theory (the lambda calculus [9] [4]), but since the techniques of denotational semantics are designed to model programming languages, not equational specifications, it does not have any difficulty in modeling state, mutation, and aliasing.
Reference: [45] <author> Peter D. Mosses. </author> <title> Action Semantics, </title> <booktitle> volume 26 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: Action semantics <ref> [45] </ref> [71, Chapters 7-8] also uses algebraic techniques to specify data more abstractly than standard denotational semantics. However, in action semantics, the locations are not part of the algebra, and so the datatypes that one specifies must be immutable.
Reference: [46] <author> Tobias Nipkow. </author> <title> Non-deterministic data types: Models and implementations. </title> <journal> Acta Informatica, </journal> <volume> 22(16) </volume> <pages> 629-661, </pages> <month> March </month> <year> 1986. </year> <month> 50 </month>
Reference-contexts: For simplicity, we do not worry about garbage collection in the semantics. 2.2.1 Visible Types and External Values To facilitate the study of visible behavior, we distinguish a subset of types as visible types; these are the types of values that can be "output" by a program [60] <ref> [46] </ref>. <p> Since we will be ignoring the details of type and method declarations, in what follows, let = (TYPES; OPS; ResType) stand for an arbitrary signature. The simulation relations we study help one decide when one ADT behaves like an other [59] <ref> [46] </ref> [28] [31]. This is useful in theoretical contexts [42]; also the general idea of 28 simulation and refinement of ADTs is important for optimization. If the abstraction of a faster implementation simulates a slower one's behavior, then one can replace the slower implementation by the faster implementation.
Reference: [47] <author> P. W. O'Hearn and R. D. Tennent. </author> <title> Semantics of local variables. </title> <editor> In M. P. Fourman, P. T. Johnstone, and A. M. Pitts, editors, </editor> <booktitle> Applications of Categories in Computer Science, volume 177 of London Mathematical Society Lecture Note Series, </booktitle> <pages> pages 217-238. </pages> <publisher> Cambridge University Press, </publisher> <address> Cambridge, England, </address> <year> 1992. </year>
Reference-contexts: However, we hasten to point out that others are also interested in questions of behavioral properties of programs. For example, full abstraction is such a question. Recent work on full abstraction has focused on the semantics of blocks and local variables. The work of O'Hearn and Tennent <ref> [47] </ref> [48] [65] and the work of Sieber [62] [63] [61] use logical relations (i.e., higher-order extensions of the kind of simulation relations we study in the next section), to obtain a restricted domain of procedure denotations. <p> So the formulation of simulation relations we present relates states over one algebra to states over another algebra. (In this respect it is similar to the base case of the logical relations used, for example, in <ref> [47] </ref> [48] [65]. They are extensions of the relations used in [33].) Definition 3.1 (simulation relation) Let C and A be -algebras.
Reference: [48] <author> Peter W. O'Hearn and Robert D. Tennent. </author> <title> Relational parametricity and local variables. </title> <booktitle> In Proc. 20 th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 171-184, </pages> <year> 1993. </year>
Reference-contexts: However, we hasten to point out that others are also interested in questions of behavioral properties of programs. For example, full abstraction is such a question. Recent work on full abstraction has focused on the semantics of blocks and local variables. The work of O'Hearn and Tennent [47] <ref> [48] </ref> [65] and the work of Sieber [62] [63] [61] use logical relations (i.e., higher-order extensions of the kind of simulation relations we study in the next section), to obtain a restricted domain of procedure denotations. <p> So the formulation of simulation relations we present relates states over one algebra to states over another algebra. (In this respect it is similar to the base case of the logical relations used, for example, in [47] <ref> [48] </ref> [65]. They are extensions of the relations used in [33].) Definition 3.1 (simulation relation) Let C and A be -algebras.
Reference: [49] <author> D. L. Parnas. </author> <title> A technique for the specification of software modules with examples. </title> <journal> Communications of the ACM, </journal> <volume> 15(5) </volume> <pages> 330-336, </pages> <month> May </month> <year> 1972. </year>
Reference-contexts: A key idea in the verification of OO programs is that of behavioral subtyping. Because a model of an ADT can be thought of as a mathematical abstraction of an ADT specification (or the code that implements it) <ref> [49] </ref> [35] [15] [14] [74] [5], several authors have used the variations on multi-sorted algebras as a formal framework for studying behavioral subtyping [7] [32] [30] [51] [33].
Reference: [50] <author> Laurence C. Paulson. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: Such bindings cannot be changed, and are therefore constant bindings. This is not a great restriction, however, as the programmer can define any desired type of variables by defining objects with one field. (This is similar to the way variables are treated in, for example, SML [41] <ref> [50] </ref>.) For example, the following shows how one would write integer variables. type IntVar fields (val: Int); method mkIntVar (e:Int): Void nothing; return new IntVar (e) -; method assign (v:IntVar, e:Int): Void - v.val := e; return nothing -; method read (v:IntVar): Int nothing; return v.val -; The form of a <p> To aid the reader, we use notations like ^x for lists. We also assume an auxiliary function length, that gives the length of a list. We use a map functional as in SML <ref> [50] </ref>, as well as a foldright functional, which is defined below as the fixedpoint of a generator. (For simplicity of notation, we use the convention that the application of a function of a type such as S fi T ! T ? to ? produces ?.) foldright : 8S:8T:(S fi T
Reference: [51] <author> F. Parisi Presicce and A. Pierantonio. </author> <title> An algebraic view of inheritance and subtyp-ing in object oriented programming. </title> <editor> In A. van Lamsweerde and A. Fugetta, editors, </editor> <booktitle> ESEC '91: 3rd European Software Engineering Conference, Milan, Italy, volume 550 of Lecture Notes in Computer Science, </booktitle> <pages> pages 364-379. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: Because a model of an ADT can be thought of as a mathematical abstraction of an ADT specification (or the code that implements it) [49] [35] [15] [14] [74] [5], several authors have used the variations on multi-sorted algebras as a formal framework for studying behavioral subtyping [7] [32] [30] <ref> [51] </ref> [33].
Reference: [52] <author> Uday S. Reddy. </author> <title> Passivity and independence. </title> <booktitle> In Proceedings Ninth Annual IEEE Symposium on Logic in Computer Science, Paris, France, </booktitle> <pages> pages 342-352. </pages> <publisher> IEEE, </publisher> <month> July </month> <year> 1994. </year>
Reference-contexts: Reddy has investigated another approach to the full abstraction problem for local variables that uses techniques akin to object-oriented programming to prevent unwanted 1 Yuri Gurevich, personal communication, March 1994. 27 modifications to the store <ref> [52] </ref>. We speculate that it might be possible to characterize, perhaps algebraically, varieties of algebras that have behavior that is appropriate, and that this might be of some interest in the study of full abstraction for programming languages with local variables.
Reference: [53] <author> John C. Reynolds. </author> <title> Using category theory to design implicit conversions and generic operators. </title> <editor> In Neil D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, Aarhus, Denmark, volume 94 of Lecture Notes in Computer Science, </booktitle> <pages> pages 211-258. </pages> <publisher> Springer-Verlag, </publisher> <month> January </month> <year> 1980. </year>
Reference-contexts: It will also be useful in the application of this work to object-oriented programming with message passing (which supports a kind of dynamic overloading [69]). The signatures are thus a simplified form of the signatures used in category-sorted algebras <ref> [53] </ref> [54].
Reference: [54] <author> John C. Reynolds. </author> <title> Three approaches to type structure. </title> <editor> In Hartmut Ehrig, Chris-tiane Floyd, Maurice Nivat, and James Thatcher, editors, </editor> <booktitle> Mathematical Foundations of Software Development, Proceedings of the International Joint Conference on Theory and Practice of Software Development (TAPSOFT), Berlin. Volume 1: Colloquium on Trees in Algebra and Programming (CAAP '85), volume 185 of Lecture Notes in Computer Science, </booktitle> <pages> pages 97-138. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> March </month> <year> 1985. </year>
Reference-contexts: It will also be useful in the application of this work to object-oriented programming with message passing (which supports a kind of dynamic overloading [69]). The signatures are thus a simplified form of the signatures used in category-sorted algebras [53] <ref> [54] </ref>.
Reference: [55] <author> Donald Sannella and Andrzej Tarlecki. </author> <title> Specifications in an arbitrary institution. </title> <journal> Information and Computation, </journal> 76(2/3):165-210, February/March 1988. A revised version of the paper that appeared in the 1984 Semantics of Data Types Symposium, LNCS <volume> 173, </volume> pages <pages> 337-356. </pages>
Reference-contexts: Perhaps dynamic logic or other related axiomatic specification techniques [6] would be useful in specifying our models, or in developing their theory. Another possibility is developing the theory more fully by defining the appropriate category or institution <ref> [55] </ref>. 40 Another direction for future work is to extend our results to more interesting languages. We mentioned some language extensions that would be interesting for investigating the utility of the split semantics in Section 2.4 above.
Reference: [56] <author> Scheifler. </author> <title> A denotational semantics of CLU. </title> <type> Technical Report TR-201, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> May </month> <year> 1978. </year>
Reference-contexts: The essential technique used in denotational semantics to model state is to pass around a "store mapping" to simulate the computer's memory. However, when one looks at the treatment of ADTs in the denotational semantics of programming languages such as CLU <ref> [56] </ref>, or OO languages such as Smalltalk and CLOS [10], one searches in vain for something that is easily identifiable as an algebraic model of the ADTs. <p> Each object (location) contains a value, sometimes called an "abstract value" [24], which can be extracted by a store mapping, as is usual in denotational semantics [57]. (This resembles Scheifler's denotational semantics of CLU <ref> [56] </ref>, and would be similar to a semantics of LISP.) An object may "contain" other objects, if its value contains other locations. <p> We believe that our approach to describing the semantics of languages with ADTs | the split semantics | is a fruitful way to do semantics for such languages. Traditional denotational semantics "compiles" the implementations of ADTs into an undifferentiated mass of functions, Cartesian products, etc. (For example, see <ref> [56] </ref>.) The mess that results from this "compilation" process is difficult to compare to the specifications of the abstract types, and difficult to extract from the rest of a program.
Reference: [57] <author> David A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, Inc., </publisher> <address> Boston, Mass., </address> <year> 1986. </year>
Reference-contexts: For example, in the standard Stack ADT, the push method produces a new stack value, it does not mutate an object. fl This work was supported in part by the National Science Foundation under Grant CCR-9108654. 1 Denotational semantics [64] <ref> [57] </ref> [44] also is based on a referentially transparent model theory (the lambda calculus [9] [4]), but since the techniques of denotational semantics are designed to model programming languages, not equational specifications, it does not have any difficulty in modeling state, mutation, and aliasing. <p> Locations are typed in the sense that a location l : T can only store a value of type T . Each object (location) contains a value, sometimes called an "abstract value" [24], which can be extracted by a store mapping, as is usual in denotational semantics <ref> [57] </ref>. (This resembles Scheifler's denotational semantics of CLU [56], and would be similar to a semantics of LISP.) An object may "contain" other objects, if its value contains other locations. <p> One can think of the program as printing these values (labeled by each identifier's name). OBSERVATION [A] def = STATE [A] ! ANSWERS ? (11) ANSWERS def = Identifier fin ! EXTERNALS (12) Lists and Tuples For lists and tuples we follow the notation in <ref> [57] </ref>. For tuples, we use the usual pairing notation, and indicate indexing with a downward arrow; for example, (x; y) # 2 = y. As usual, tuples are written with vector notation, ~v. Recall that the notation D fl means all finite tuples of D. <p> The notation A 0 j (hideInternalMessages 0 ) is the reduct of A 0 without these primitives; this notation is defined above in the auxiliary functions for algebras. As a simplification in the semantics, we use ? both for nontermination and for any error condition. As in <ref> [57] </ref>, we use a strict let construct; for example, the value of let x = ? in 3 is ?.
Reference: [58] <author> David A. Schmidt. </author> <title> The Structure of Typed Programming Languages. </title> <booktitle> Foundations of Computing Series. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: This also means that the signature and algebra returned do not reflect these details of the representation of objects used in this semantics. Some remarks about the notation used below are also in order. The type of P is a dependent type [11] <ref> [58, Chapter 8] </ref>; for example, the signature of the algebra returned is the same as the signature returned. Recall that the signature and the -algebra A used below are defined in Figures 4 and 6. The valuation functions for type declarations, T D, and method declarations, MD, are defined below.
Reference: [59] <author> Oliver Schoett. </author> <title> Behavioural correctness of data representations. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 14(1) </volume> <pages> 43-57, </pages> <month> June </month> <year> 1990. </year> <month> 51 </month>
Reference-contexts: Since we will be ignoring the details of type and method declarations, in what follows, let = (TYPES; OPS; ResType) stand for an arbitrary signature. The simulation relations we study help one decide when one ADT behaves like an other <ref> [59] </ref> [46] [28] [31]. This is useful in theoretical contexts [42]; also the general idea of 28 simulation and refinement of ADTs is important for optimization. If the abstraction of a faster implementation simulates a slower one's behavior, then one can replace the slower implementation by the faster implementation.
Reference: [60] <author> Oliver Schoett. </author> <title> An observational subset of first-order logic cannot specify the be-havior of a counter. </title> <editor> In C. Choffrut and M. Jantzen, editors, </editor> <booktitle> STACS 91 8th Annual Symposium on Theoretical Aspects of Computer Science Hamburg, Germany, February 1991 Proceedings, volume 480 of Lecture Notes in Computer Science, </booktitle> <pages> pages 499-510. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: For simplicity, we do not worry about garbage collection in the semantics. 2.2.1 Visible Types and External Values To facilitate the study of visible behavior, we distinguish a subset of types as visible types; these are the types of values that can be "output" by a program <ref> [60] </ref> [46].
Reference: [61] <author> K. Sieber. </author> <title> Call-by-value and non-determinism. </title> <editor> In M. Bezem and J.F. Groote, editors, </editor> <booktitle> International Conference on Typed Lambda Calculi and Applications, number 664 in Lecture Notes in Computer Science, </booktitle> <pages> pages 376-390, </pages> <address> Utrecht, The Netherlands, March 1993. </address> <publisher> Springer-Verlag. TLCA'93. </publisher>
Reference-contexts: For example, full abstraction is such a question. Recent work on full abstraction has focused on the semantics of blocks and local variables. The work of O'Hearn and Tennent [47] [48] [65] and the work of Sieber [62] [63] <ref> [61] </ref> use logical relations (i.e., higher-order extensions of the kind of simulation relations we study in the next section), to obtain a restricted domain of procedure denotations.
Reference: [62] <author> Kurt Sieber. </author> <title> Reasoning about sequential functions via logical relations. </title> <editor> In M. P. Four-man, P. T. Johnstone, and A. M. Pitts, editors, </editor> <booktitle> Proc. LMS Symposium on Applications of Categories in Computer Science, Durham 1991, LMS Lecture Note Series 177, </booktitle> <pages> pages 258-269. </pages> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: For example, full abstraction is such a question. Recent work on full abstraction has focused on the semantics of blocks and local variables. The work of O'Hearn and Tennent [47] [48] [65] and the work of Sieber <ref> [62] </ref> [63] [61] use logical relations (i.e., higher-order extensions of the kind of simulation relations we study in the next section), to obtain a restricted domain of procedure denotations.
Reference: [63] <author> Kurt Sieber. </author> <title> New steps towards full abstraction for local variables. </title> <booktitle> In Proc. ACM SIGPLAN Workshop on State in Programming Languages, </booktitle> <pages> pages 88-100, </pages> <address> Copenhagen, Denmark, </address> <year> 1993. </year> <note> Published as Yale University, </note> <institution> Dept. of Comp. Sci. </institution> <note> Technical Report YALEU/DCS/RR-968. </note>
Reference-contexts: For example, full abstraction is such a question. Recent work on full abstraction has focused on the semantics of blocks and local variables. The work of O'Hearn and Tennent [47] [48] [65] and the work of Sieber [62] <ref> [63] </ref> [61] use logical relations (i.e., higher-order extensions of the kind of simulation relations we study in the next section), to obtain a restricted domain of procedure denotations.
Reference: [64] <author> J. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1977. </year>
Reference-contexts: For example, in the standard Stack ADT, the push method produces a new stack value, it does not mutate an object. fl This work was supported in part by the National Science Foundation under Grant CCR-9108654. 1 Denotational semantics <ref> [64] </ref> [57] [44] also is based on a referentially transparent model theory (the lambda calculus [9] [4]), but since the techniques of denotational semantics are designed to model programming languages, not equational specifications, it does not have any difficulty in modeling state, mutation, and aliasing.
Reference: [65] <author> R. D. Tennent. </author> <title> Correctness of data representations in Algol-like languages. </title> <editor> In A. W. Roscoe, editor, </editor> <title> A Classical Mind, Essays in Honour of C. </title> <editor> A. R. </editor> <booktitle> Hoare, chapter 23, </booktitle> <pages> pages 405-417. </pages> <publisher> Prentice-Hall International, </publisher> <year> 1994. </year>
Reference-contexts: However, we hasten to point out that others are also interested in questions of behavioral properties of programs. For example, full abstraction is such a question. Recent work on full abstraction has focused on the semantics of blocks and local variables. The work of O'Hearn and Tennent [47] [48] <ref> [65] </ref> and the work of Sieber [62] [63] [61] use logical relations (i.e., higher-order extensions of the kind of simulation relations we study in the next section), to obtain a restricted domain of procedure denotations. <p> So the formulation of simulation relations we present relates states over one algebra to states over another algebra. (In this respect it is similar to the base case of the logical relations used, for example, in [47] [48] <ref> [65] </ref>. They are extensions of the relations used in [33].) Definition 3.1 (simulation relation) Let C and A be -algebras.
Reference: [66] <author> J. V. Tucker and J. I. Zucker. </author> <title> Toward a general theory of computation and specification over abstract data types. </title> <editor> In S. G. Akl, F. Fiala, and W. W. Koczkodaj, editors, </editor> <booktitle> Advances in Computing and Information ICCI '90, International Conference on Computing and Information, </booktitle> <address> Niagara Falls, Canada, </address> <month> May </month> <year> 1990, </year> <booktitle> volume 468 of Lecture Notes in Computer Science, </booktitle> <pages> pages 129-133. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: Our semantic techniques allow one to obtain some of the benefits of action semantics without adopting its idiosyncratic notation. The idea of computing over an algebra is also found in <ref> [66] </ref>. Our separation between the algebra and the semantics of is similar to what Mason and Talcott have studied the semantics of LISP [36] and other languages with mutation [37] [38]. Their work mainly uses operational semantics, and as such is complimentary to our denotational/algebraic approach.
Reference: [67] <author> Mark Utting. </author> <title> An Object-Oriented Refinement Calculus with Modular Reasoning. </title> <type> PhD thesis, </type> <institution> University of New South Wales, Kensington, Australia, </institution> <year> 1992. </year> <note> Draft of February 1992 obtained from the Author. </note>
Reference-contexts: 1 Introduction Abstract data types (ADTs) are important in programming, particularly in object-oriented (OO) programming. The recent interest in OO programming has focused renewed attention on problems of specifying and verifying such programs [2] [40] [32] [3] [28] [68] <ref> [67] </ref>. A key idea in the verification of OO programs is that of behavioral subtyping.
Reference: [68] <author> Mark Utting and Ken Robinson. </author> <title> Modular reasoning in an object-oriented refinement calculus. </title> <editor> In R. S. Bird, C. C. Morgan, and J. C. P. Woodcock, editors, </editor> <booktitle> Mathematics of Program Construction, Second International Conference, Oxford, U.K., June/July, volume 669 of Lecture Notes in Computer Science, </booktitle> <pages> pages 344-367. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Abstract data types (ADTs) are important in programming, particularly in object-oriented (OO) programming. The recent interest in OO programming has focused renewed attention on problems of specifying and verifying such programs [2] [40] [32] [3] [28] <ref> [68] </ref> [67]. A key idea in the verification of OO programs is that of behavioral subtyping.
Reference: [69] <author> Philip Wadler and Stephen Blott. </author> <title> How to make ad-hoc polymorphism less ad hoc. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, Texas, </address> <pages> pages 60-76. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: It will also be useful in the application of this work to object-oriented programming with message passing (which supports a kind of dynamic overloading <ref> [69] </ref>). The signatures are thus a simplified form of the signatures used in category-sorted algebras [53] [54].
Reference: [70] <author> E. G. Wagner, J. W. Thatcher, and J. B. Wright. </author> <title> Programming languages as mathematical objects. </title> <editor> In J. Winkowski, editor, </editor> <booktitle> Mathematical Foundations of Computer Science, volume 10 of Lecture Notes in Computer Science, </booktitle> <pages> pages 84-101. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1978. </year> <month> 52 </month>
Reference-contexts: Recursive procedures seem to pose no particular difficulties; and we leave as future work the working out of the appropriate domain theory for constructing algebras with recursive methods and recursive data. Work on continuous algebras may be of use in solving such problems [16] <ref> [70] </ref> [20] [43] [74, Section 3.3.3]. Another feature not in is block structure, more specifically local declarations of types and methods.
Reference: [71] <author> David A. Watt. </author> <title> Programming Language Syntax and Semantics. </title> <publisher> Prentice Hall Interna--tional Series in Computer Science. Prentice-Hall, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: That is, if : ENV [A] and if x : T 2 dom (), then (x) 2 VALS A T . We write emptyEnviron for the empty finite function from identifiers to denotable values, and define the following functions on environments, for any -algebra A <ref> [71] </ref>. emptyEnviron : ENV [A] = I : ? overlay : ENV [A] fi ENV [A] ! ENV [A] overlay ( 1 ; 2 ) = I : if I 2 dom ( 1 ) then 1 [[I]] else 2 [[I]] bind : Identifier fi VALS A ! ENV [A] bind <p> Action semantics [45] <ref> [71, Chapters 7-8] </ref> also uses algebraic techniques to specify data more abstractly than standard denotational semantics. However, in action semantics, the locations are not part of the algebra, and so the datatypes that one specifies must be immutable.
Reference: [72] <author> R. J. Wieringa. </author> <title> A formalization of objects using equational dynamic logic. </title> <editor> In C. De-lobel, M. Kifer, and Y. Masanaga, editors, </editor> <booktitle> Deductive and object-Oriented Databases, volume 566 of Lecture Notes in Computer Science, </booktitle> <pages> pages 431-452. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: These authors did not investigate simulation relations, or the use of mixed algebraic and denotational semantics. Several authors use Kripke (i.e., possible world) models to give semantics to mutation and object identities [18] [1] <ref> [72] </ref> [25]. One could consider our algebras to be Kripke models if we were to include the store as part of the algebra. However, we believe that keeping the store outside the algebra leads to a cleaner separation of the algebra and the semantics of . <p> Mason and Talcott focus on equational logics for reasoning about programs that use mutation, whereas our work has not progressed to a reasoning calculus. 5 Future Work In view of the use of dynamic logic [26] in some of the related work on Kripke models <ref> [72] </ref> [25], it would be interesting to investigate the relationship between our techniques and dynamic logic. Perhaps dynamic logic or other related axiomatic specification techniques [6] would be useful in specifying our models, or in developing their theory.
Reference: [73] <author> Jeannette Marie Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: Stores are defined simultaneously, but are not contained in -algebras. This definition of algebra and stores below was inspired by work on models of types for interface specification languages <ref> [73] </ref> [8]. To explain a term used in the definition below, a finite function, f : S fin ! T is a function S ! T ? such that f has a proper result (not ?) only on a finite number of arguments. <p> The detailed semantics of type and method declarations are suppressed, because one only deals with their denotations: algebras of a given signature. 39 4 Related Work Our algebraic models are based, in part, on the work of Wing <ref> [73] </ref> and Chen [8]. These authors did not investigate simulation relations, or the use of mixed algebraic and denotational semantics. Several authors use Kripke (i.e., possible world) models to give semantics to mutation and object identities [18] [1] [72] [25].
Reference: [74] <author> Martin Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. van Leewen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 13, </booktitle> <pages> pages 675-788. </pages> <publisher> The MIT Press, </publisher> <address> New York, N.Y., </address> <year> 1990. </year> <month> 53 </month>
Reference-contexts: A key idea in the verification of OO programs is that of behavioral subtyping. Because a model of an ADT can be thought of as a mathematical abstraction of an ADT specification (or the code that implements it) [49] [35] [15] [14] <ref> [74] </ref> [5], several authors have used the variations on multi-sorted algebras as a formal framework for studying behavioral subtyping [7] [32] [30] [51] [33]. <p> Recursive procedures seem to pose no particular difficulties; and we leave as future work the working out of the appropriate domain theory for constructing algebras with recursive methods and recursive data. Work on continuous algebras may be of use in solving such problems [16] [70] [20] [43] <ref> [74, Section 3.3.3] </ref>. Another feature not in is block structure, more specifically local declarations of types and methods.
References-found: 74

