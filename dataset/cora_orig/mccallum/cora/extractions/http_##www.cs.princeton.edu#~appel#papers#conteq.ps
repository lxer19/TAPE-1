URL: http://www.cs.princeton.edu/~appel/papers/conteq.ps
Refering-URL: http://www.cs.princeton.edu/~appel/vita.html
Root-URL: http://www.cs.princeton.edu
Title: Intensional Equality for Continuations  
Author: Andrew W. Appel 
Date: September 8, 1995  
Affiliation: Princeton University  
Abstract: Continuations, expressing "what the program will do from now on," are a much-used tool of semantics, and sometimes show up as a user-accessible programming feature. But most use of continuations is parametric, in the sense that functions behave the same way independent of their continuation. I will show that nonparametric use of continuations allows very substantial, almost incredible gains in program speed. Furthermore, this technique is compatible with almost any style of programming language; imperative, functional, even object-oriented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Matthias Felleisen. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Fifteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 180-90, </pages> <address> New York, Jan 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: This call-with-current-continuation feature has been criticized as being too expensive to implement because entire control stacks need to be copied. Some researchers <ref> [1, 2] </ref> propose a "prompt" primitive to ameliorate the expense by manipulating continuations in a carefully controlled way. Here I will propose a new, limited continuation primitive that is cheap (even for stacks) and that can accomplish certain things for which prompts are too weak. <p> That is, fastroot.c must be both fast and correct. To derive a good solution to this problem, I examined the continuation transform Q of the quickroot function: Q : (Int fi Kont) ! Cont 1 main (int ac, char *av []) - (void) srandom (atoi (av <ref> [1] </ref>)); for (i = 0; i &lt; 10000000; i++) - j = quickroot (random ()); - exit (0); - double cbrt (double); int quickroot (int i) -return (int) cbrt ((double) i);- The library function cbrt computes floating-point cube roots. where Cont is a conventional continuation function of the form Store ! <p> This was sufficient to win the contest, had I been eligible to enter. Furthermore, my version gave correct answers on any test input that Jacobson was able to devise. 2 #include &lt;stdio.h&gt; mainX (int ac, char *av []) - (void) srandom (atoi (av <ref> [1] </ref>)); for (i = 0; i &lt; 10000000; i++) - j = quickroot (random ()); - exit (0); - endMain ()-- double cbrt (double); extern main (); unsigned mycaller [] =-0x81c3e008,0x9010001f-; int quickroot (int i) -static x=0; if (x) return (int) cbrt ((double) i); x=1; unsigned *p, *q, caller; union -unsigned
Reference: [2] <author> Carl A. Gunter, Didier Remy, and Jon G. Riecke. </author> <title> A generalization of exceptions and control in ML-like languages. </title> <booktitle> In Proc. Seventh Int'l Conf. on Functional Programming and Computer Architecture, </booktitle> <pages> pages 12-23. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year> <month> 4 </month>
Reference-contexts: This call-with-current-continuation feature has been criticized as being too expensive to implement because entire control stacks need to be copied. Some researchers <ref> [1, 2] </ref> propose a "prompt" primitive to ameliorate the expense by manipulating continuations in a carefully controlled way. Here I will propose a new, limited continuation primitive that is cheap (even for stacks) and that can accomplish certain things for which prompts are too weak.
References-found: 2

