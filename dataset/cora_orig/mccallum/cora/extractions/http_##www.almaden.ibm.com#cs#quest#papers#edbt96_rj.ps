URL: http://www.almaden.ibm.com/cs/quest/papers/edbt96_rj.ps
Refering-URL: http://www.almaden.ibm.com/cs/quest/publications.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: SEQUENTIAL PATTERNS: GENERALIZATIONS AND PERFORMANCE IMPROVEMENTS  
Author: Ramakrishnan Srikant Rakesh Agrawal 
Keyword: LIMITED DISTRIBUTION NOTICE  
Address: 650 Harry Road San Jose, CA 95120-6099  Yorktown Heights, New York San Jose, California Zurich, Switzerland  
Affiliation: IBM Research Division Almaden Research Center  IBM Research Division  
Note: MINING  
Abstract: Research Report This report has been submitted for publication outside of IBM and will probably be copyrighted if accepted for publication. It has been issued as a Research Report for early dissemination of its contents. In view of the transfer of copyright to the outside publisher, its distribution outside of IBM prior to publication should be limited to peer communications and specific requests. After outside publication, requests should be filled only by reprints or legally obtained copies of the article (e.g., payment of royalties). 
Abstract-found: 1
Intro-found: 1
Reference: [AGM + 90] <author> S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman. </author> <title> A basic local alignment search tool. </title> <journal> Journal of Molecular Biology, </journal> <year> 1990. </year>
Reference-contexts: Techniques based on multiple alignment [Wat89] have been proposed to find entire text sequences that are similar. There also has been work to find locally similar subsequences <ref> [AGM + 90] </ref> [Roy92] [VA89]. However, as pointed out in [WCM + 94], these techniques apply when the discovered patterns consist of consecutive characters or multiple lists of consecutive characters separated by a fixed length of noise characters. 4 1.2.
Reference: [AIS93] <author> Rakesh Agrawal, Tomasz Imielinski, and Arun Swami. </author> <title> Mining association rules between sets of items in large databases. </title> <booktitle> In Proc. of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 207-216, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: For the cases that the extended AprioriAll can handle, our empirical evaluation reported in Section 4 shows that GSP is upto 20 times faster. Somewhat related to our work is the problem of mining association rules <ref> [AIS93] </ref>. Association rules are rules about what items are bought together within a transaction, and are thus intra-transaction patterns, unlike inter-transaction sequential patterns. The problem of finding association rules when there is a user-defined taxonomy on items has been addressed in [SA95] [HF95].
Reference: [AS94] <author> Rakesh Agrawal and Ramakrishnan Srikant. </author> <title> Fast Algorithms for Mining Association Rules. </title> <booktitle> In Proc. of the 20th Int'l Conference on Very Large Databases, </booktitle> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: If there is no max-gap constraint, we also delete candidate sequences that have any subsequence without mini mum support. The above procedure is reminiscent of the candidate generation procedure for finding association rules <ref> [AS94] </ref>; however details are quite different. 10 Frequent Candidate 4-Sequences 3-Sequences after join after pruning h (1, 2) (3) i h (1, 2) (3, 4) i h (1, 2) (3, 4) i h (1) (3, 4) i h (2) (3, 4) i Example Figure 3 shows L 3 , and C <p> We transform the representation of the data-sequence d so that we can efficiently find whether a specific candidate is a subsequence of d. 3.2.1. Reducing the number of candidates that need to be checked We adapt the hash-tree data structure of <ref> [AS94] </ref> for this purpose. A node of the hash-tree either contains a list of sequences (a leaf node) or a hash table (an interior node). In an interior node, each non-empty bucket of the hash table points to another node. <p> This algorithm splits the problem of finding sequential patterns into three phases: 1. Itemset Phase. All itemsets with minimum support are found. These also correspond to the sequential patterns with exactly 1 element. Any of the algorithms for finding frequent itemsets (for example, <ref> [AS94] </ref>) can be used in this phase. 2. Transformation Phase. The frequent itemsets are mapped to integers. The database is then transformed, with each transaction being replaced by the set of all frequent itemsets contained in the transaction.
Reference: [AS95] <author> Rakesh Agrawal and Ramakrishnan Srikant. </author> <title> Mining Sequential Patterns. </title> <booktitle> In Proc. of the 11th Int'l Conference on Data Engineering, </booktitle> <address> Taipei, Taiwan, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: 1. Introduction Data mining, also known as knowledge discovery in databases, has been recognized as a promising new area for database research. This area can be defined as efficiently discovering interesting patterns from large databases. A new data mining problem, discovering sequential patterns, was introduced in <ref> [AS95] </ref>. The input data is a set of sequences, called data-sequences. Each data-sequence is a list of transactions, where each transaction is a sets of literals, called items. Typically there is a transaction-time associated with each transaction. A sequential pattern also consists of a list of sets of items. <p> The patterns discovered using this data could be used in disease research to help identify symptoms/diseases that precede certain diseases. However, the problem definition as introduced in <ref> [AS95] </ref> has the following limitations: 1. Absence of time constraints. Users often want to specify maximum and/or min 1 imum time gaps between adjacent elements of the sequential pattern. <p> With this taxonomy, a customer who bought "Foundation" followed by "Perfect Spy" would support the patterns " `Foundation' followed by `Perfect Spy' ", " `Asimov' followed by `Perfect Spy' ", " `Science Fiction' followed by `Le Carre' ", etc. In this paper, we generalize the problem definition given in <ref> [AS95] </ref> to incorporate time constraints, sliding time windows, and taxonomies in sequential patterns. We present GSP (Generalized Sequential Patterns), a new algorithm that discovers all such sequential patterns. <p> Empirical evaluation shows that GSP scales linearly with the number of data-sequences, and has very good scale-up properties with respect to the number of transactions per data-sequence and number of items per transaction. 2 1.1. Related Work In addition to introducing the problem of sequential patterns, <ref> [AS95] </ref> presented three algorithms for solving this problem, but these algorithms do not handle time constraints, sliding windows, or taxonomies. Two of these algorithms were designed to find only maximal sequential patterns; however, many applications require all patterns and their supports. <p> of total data-sequences that "contain" this sequence. (Although the word "contains" is not strictly accurate once we incorporate taxonomies, it captures the spirt of when a data-sequence contributes to the support of a sequential pattern.) We now define when a data-sequence contains a sequence, starting with the definition as in <ref> [AS95] </ref>, and then adding taxonomies, sliding windows, and time constraints: * as in [AS95]: In the absence of taxonomies, sliding windows and time constraints, a data-sequence contains a sequence s if s is a subsequence of the data-sequence. * plus taxonomies: We say that a transaction T contains an item x <p> strictly accurate once we incorporate taxonomies, it captures the spirt of when a data-sequence contributes to the support of a sequential pattern.) We now define when a data-sequence contains a sequence, starting with the definition as in <ref> [AS95] </ref>, and then adding taxonomies, sliding windows, and time constraints: * as in [AS95]: In the absence of taxonomies, sliding windows and time constraints, a data-sequence contains a sequence s if s is a subsequence of the data-sequence. * plus taxonomies: We say that a transaction T contains an item x 2 I if x is in T or x is an ancestor of <p> Note that if there is no taxonomy, min-gap = 0, max-gap = 1 and window-size = 0 we get the notion of sequential patterns as introduced in <ref> [AS95] </ref>, where there are no time constraints and items in an element come from a single transaction. 2.1. <p> Example Consider the data-sequences shown in Figure 2. For simplicity, we have assumed that the transaction-times are integers; they could represent, for instance, the number of days after January 1, 1995. We have used an abbreviated version of the taxonomy given in With the <ref> [AS95] </ref> problem definition, the only 2-element sequential patterns are: 7 Database D Sequence-Id Transaction Items Time C1 1 Ringworld C1 2 Foundation C1 15 Ringworld Engineers, Second Foundation C2 1 Foundation, Ringworld C2 20 Foundation and Empire C2 50 Ringworld Engineers Taxonomy T h (Ringworld) (Ringworld Engineers) i, h (Foundation) (Ringworld <p> Fortunately, this does not affect correctness, although it adds some redundant counting effort. 4. Performance Evaluation We compare the performance of GSP to the AprioriAll algorithm given in <ref> [AS95] </ref>, using both synthetic and real-life datasets. We also show the scale-up properties of GSP, and study the effect of time constraints and sliding-window transactions on the performance of GSP. Our experiments were performed on an IBM RS/6000 250 workstation with 128 MB of main memory running AIX 3.2.5. <p> The data resided in the AIX file system and was stored on a local 2GB SCSI 3.5" drive, with measured sequential throughput of about 2 MB/second. 4.1. A Brief Review of AprioriAll In order to explain performance trends, we first give essential details of the AprioriAll algorithm <ref> [AS95] </ref>. This algorithm splits the problem of finding sequential patterns into three phases: 1. Itemset Phase. All itemsets with minimum support are found. These also correspond to the sequential patterns with exactly 1 element. <p> However, it is much simpler since the candidates are lists of integers, rather than a list of sets of integers. 4.2. Synthetic Datasets We use the same synthetic datasets as in <ref> [AS95] </ref>, albeit with more data-sequences. The synthetic data generation program takes the parameters shown in Table 1. We generated datasets by setting N S = 5000, N I = 25000 and N = 10000. The number of data-sequences, jDj was set to 100,000. <p> Summary We are given a database of sequences, where each sequence is a list of transactions ordered by transaction-time, and each transaction is a set of items. The problem of mining sequential patterns introduced in <ref> [AS95] </ref> is to discover all sequential patterns with a user-specified minimum support, where the support of a pattern is the number of data-sequences that contain the pattern. We addressed some critical limitations of the earlier work in order to make sequential patterns useful for real applications. <p> We presented GSP, a new algorithm that discovers these generalized sequential patterns. It is a complete algorithm in that it guarantees finding all patterns that have a user-specified minimum support. Empirical evaluation using synthetic and real-life data indicates that GSP is much faster than the AprioriAll algorithm presented in <ref> [AS95] </ref>. GSP scales linearly with the number of data-sequences, and has very good scale-up properties with respect to the average data-sequence size. The GSP algorithm has been implemented as part of the Quest data mining prototype at IBM Research, and is incorporated in the IBM data mining product.
Reference: [CR93] <author> Andrea Califano and Isidore Rigoutsos. </author> <title> FLASH: A fast look-up algorithm for string homology. </title> <booktitle> In Proc. of the 1st Int'l Conference on Intelligent Systems for Molecular Biology, </booktitle> <pages> pages 353-359, </pages> <address> Bethesda, MD, </address> <month> July </month> <year> 1993. </year> <month> 28 </month>
Reference-contexts: Our problem is related to the problem of finding text subsequences that match a given regular expression (c.f. the UNIX grep utility). There also has been work on finding text subsequences that approximately match a given string (e.g. <ref> [CR93] </ref> [WM92]). These techniques are oriented toward finding matches for one pattern. In our problem, the difficulty is in figuring out what patterns to try and then efficiently finding out which of those patterns are contained in enough data sequences.
Reference: [DM85] <author> Thomas G. Dietterich and Ryszard S. Michalski. </author> <title> Discovering patterns in se-quences of events. </title> <journal> Artificial Intelligence, </journal> <volume> 25 </volume> <pages> 187-232, </pages> <year> 1985. </year>
Reference-contexts: Discovering patterns in sequences of events has been an area of active research in AI (see, for example, <ref> [DM85] </ref>). However, the focus in this body of work is on finding the rule underlying the generation of a given sequence in order to be able to predict a plausible sequence continuation (e.g. the rule to predict what number will come next, given a sequence of numbers).
Reference: [HF95] <author> J. Han and Y. Fu. </author> <title> Discovery of multiple-level association rules from large databases. </title> <booktitle> In Proc. of the 21st Int'l Conference on Very Large Databases, </booktitle> <address> Zurich, Switzerland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: Association rules are rules about what items are bought together within a transaction, and are thus intra-transaction patterns, unlike inter-transaction sequential patterns. The problem of finding association rules when there is a user-defined taxonomy on items has been addressed in [SA95] <ref> [HF95] </ref>. A problem of discovering similarities in a database of genetic sequences, presented in 3 [WCM + 94], is relevant. However, the patterns they wish to discover are subsequences made up of consecutive characters separated by a variable number of noise characters.
Reference: [MTV95] <author> Heikki Mannila, Hannu Toivonen, and A. Inkeri Verkamo. </author> <title> Discovering frequent episodes in sequences. </title> <booktitle> In Proc. of the Int'l Conference on Knowledge Discovery in Databases and Data Mining (KDD-95), </booktitle> <address> Montreal, Canada, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: In addition, we are interested in finding all sequences with minimum support rather than some frequent patterns. A problem of discovering frequent episodes in a sequence of events was presented in <ref> [MTV95] </ref>. Their patterns are arbitrary DAG (directed acyclic graphs), where each vertex corresponds to a single event (or item) and an edge from event A to event B denotes that A occurred before B.
Reference: [Roy92] <author> M. A. Roytberg. </author> <title> A search for common patterns in many sequences. </title> <booktitle> Computer Applications in the Biosciences, </booktitle> <volume> 8(1) </volume> <pages> 57-64, </pages> <year> 1992. </year>
Reference-contexts: Techniques based on multiple alignment [Wat89] have been proposed to find entire text sequences that are similar. There also has been work to find locally similar subsequences [AGM + 90] <ref> [Roy92] </ref> [VA89]. However, as pointed out in [WCM + 94], these techniques apply when the discovered patterns consist of consecutive characters or multiple lists of consecutive characters separated by a fixed length of noise characters. 4 1.2.
Reference: [SA95] <author> Ramakrishnan Srikant and Rakesh Agrawal. </author> <title> Mining Generalized Association Rules. </title> <booktitle> In Proc. of the 21st Int'l Conference on Very Large Databases, </booktitle> <address> Zurich, Switzerland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: Association rules are rules about what items are bought together within a transaction, and are thus intra-transaction patterns, unlike inter-transaction sequential patterns. The problem of finding association rules when there is a user-defined taxonomy on items has been addressed in <ref> [SA95] </ref> [HF95]. A problem of discovering similarities in a database of genetic sequences, presented in 3 [WCM + 94], is relevant. However, the patterns they wish to discover are subsequences made up of consecutive characters separated by a variable number of noise characters. <p> We now find item 2 at time 90, while item 6 remains at time 95. Since the time gap between 90 and 95 is less than the window size, we are done. 3.3. Taxonomies The ideas presented in <ref> [SA95] </ref> for discovering association rules with taxonomies carry over to the current problem. <p> Given this information, we would "expect" the support of the pattern h (Foundation) (Ringworld) i to be 7.5%, since half the "Asimov"s are "Foundation"s. If the actual support of h (Foundation) (Ringworld) i is close to 7.5%, the pattern can be considered "redundant". The interest measure introduced in <ref> [SA95] </ref> also carries over and can be used to prune such redundant patterns.
Reference: [VA89] <author> M. Vingron and P. Argos. </author> <title> A fast and sensitive multiple sequence alignment algorithm. </title> <booktitle> Computer Applications in the Biosciences, </booktitle> <volume> 5 </volume> <pages> 115-122, </pages> <year> 1989. </year>
Reference-contexts: Techniques based on multiple alignment [Wat89] have been proposed to find entire text sequences that are similar. There also has been work to find locally similar subsequences [AGM + 90] [Roy92] <ref> [VA89] </ref>. However, as pointed out in [WCM + 94], these techniques apply when the discovered patterns consist of consecutive characters or multiple lists of consecutive characters separated by a fixed length of noise characters. 4 1.2.
Reference: [Wat89] <author> M. S. Waterman, </author> <title> editor. Mathematical Methods for DNA Sequence Analysis. </title> <publisher> CRC Press, </publisher> <year> 1989. </year>
Reference-contexts: These techniques are oriented toward finding matches for one pattern. In our problem, the difficulty is in figuring out what patterns to try and then efficiently finding out which of those patterns are contained in enough data sequences. Techniques based on multiple alignment <ref> [Wat89] </ref> have been proposed to find entire text sequences that are similar. There also has been work to find locally similar subsequences [AGM + 90] [Roy92] [VA89].
Reference: [WCM + 94] <author> Jason Tsong-Li Wang, Gung-Wei Chirn, Thomas G. Marr, Bruce Shapiro, Den-nis Shasha, and Kaizhong Zhang. </author> <title> Combinatorial pattern discovery for scientific data: Some preliminary results. </title> <booktitle> In Proc. of the ACM SIGMOD Conference on Management of Data, </booktitle> <address> Minneapolis, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: The problem of finding association rules when there is a user-defined taxonomy on items has been addressed in [SA95] [HF95]. A problem of discovering similarities in a database of genetic sequences, presented in 3 <ref> [WCM + 94] </ref>, is relevant. However, the patterns they wish to discover are subsequences made up of consecutive characters separated by a variable number of noise characters. A sequence in our problem consists of list of sets of characters (items), rather than being simply a list of characters. <p> Techniques based on multiple alignment [Wat89] have been proposed to find entire text sequences that are similar. There also has been work to find locally similar subsequences [AGM + 90] [Roy92] [VA89]. However, as pointed out in <ref> [WCM + 94] </ref>, these techniques apply when the discovered patterns consist of consecutive characters or multiple lists of consecutive characters separated by a fixed length of noise characters. 4 1.2. Organization of the Paper We give a formal description of the problem of mining generalized sequential patterns in Section 2.
Reference: [WM92] <author> S. Wu and U. Manber. </author> <title> Fast text searching allowing errors. </title> <journal> Communications of the ACM, </journal> <volume> 35(10) </volume> <pages> 83-91, </pages> <month> October </month> <year> 1992. </year> <month> 29 </month>
Reference-contexts: Our problem is related to the problem of finding text subsequences that match a given regular expression (c.f. the UNIX grep utility). There also has been work on finding text subsequences that approximately match a given string (e.g. [CR93] <ref> [WM92] </ref>). These techniques are oriented toward finding matches for one pattern. In our problem, the difficulty is in figuring out what patterns to try and then efficiently finding out which of those patterns are contained in enough data sequences.
References-found: 14

