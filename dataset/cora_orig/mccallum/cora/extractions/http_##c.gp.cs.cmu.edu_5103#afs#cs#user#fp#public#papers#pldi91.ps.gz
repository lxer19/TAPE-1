URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/papers/pldi91.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/papers/
Root-URL: http://www.cs.cmu.edu
Email: tsf@cs.cmu.edu  fp@cs.cmu.edu  
Title: Refinement Types for ML  
Author: Tim Freeman Frank Pfenning 
Address: Pittsburgh, Pennsylvania 15213-3890  Pittsburgh, Pennsylvania 15213-3890  
Affiliation: School of Computer Science Carnegie Mellon University  School of Computer Science Carnegie Mellon University  
Abstract: We describe a refinement of ML's type system allowing the specification of recursively defined subtypes of user-defined datatypes. The resulting system of refinement types preserves desirable properties of ML such as decidability of type inference, while at the same time allowing more errors to be detected at compile-time. The type system combines abstract interpretation with ideas from the intersection type discipline, but remains closely tied to ML in that refinement types are given only to programs which are already well-typed in ML. 
Abstract-found: 1
Intro-found: 1
Reference: [AC90] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Sub-typing recursive types. </title> <type> Research Report 62, </type> <institution> Digital Systems Research Center, Palo Alto, California, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: We do not know of any useful examples which would be ruled out by this restriction. Algorithms for dealing with such declarations in Subtyping Recursive Types by Amadio and Cardelli <ref> [AC90] </ref> do not appear to apply directly to our situation.
Reference: [BCM + 90] <author> J. R. Burch, E. M. Clarke, K. L. McMil-lan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <address> Philadelphia, PA, June 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: A naive representation of the refinement types of stdpos!stdpos would list all of these functions. Compact representations of refinement types, for example through an appropriate generalization of Binary Decision Diagrams <ref> [Bry86, BCM + 90] </ref> to deal with function types, seem promising. Since finding a type error in a program with refinement types will require looking at representations of refinement types, we will have to find a reasonably concise way to print these types.
Reference: [Bry86] <author> Randal E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: this lattice: ? ?e stdpos std bitstr @ @ @ In general, closure under intersection and union may add many new elements to the lattice|a fact which, in an implementation, must be addressed through compact representation methods such as those described in "Graph-Based Algorithms for Boolean Function Manipulation" by Bryant <ref> [Bry86] </ref>. <p> A naive representation of the refinement types of stdpos!stdpos would list all of these functions. Compact representations of refinement types, for example through an appropriate generalization of Binary Decision Diagrams <ref> [Bry86, BCM + 90] </ref> to deal with function types, seem promising. Since finding a type error in a program with refinement types will require looking at representations of refinement types, we will have to find a reasonably concise way to print these types.
Reference: [Car89] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <type> Research Report 45, </type> <institution> Digital Equipment Corporation, Systems Research Center, Palo Alto, California, </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: One interesting aspect of our proposal is that it merges two views which are traditionally considered 2 as opposites: should recursive types be generative (as the ML datatype construct), or should they be non-generative (as, for example, in Quest <ref> [Car89] </ref> in functional programming or in typed HiLog [YFS91] in logic programming). Our conclusion is that generative types should be the principal notion, but that non-generative recursively defined subtypes can make a type system significantly more powerful and useful. The remainder of the paper is organized as follows.
Reference: [CCHO89] <author> Peter Canning, William Cook, Walter Hill, and Walter Olthoff. </author> <title> F-bounded poly-morphism for object-oriented programming. </title> <booktitle> In Functional Programming Languages and Computer Architecture. ACM, </booktitle> <year> 1989. </year>
Reference-contexts: This is another case where decidability must be balanced with the desire for accuracy in type checking. 5 Polymorphism The interaction between polymorphism and subtypes is potentially problematic. The main mechanism considered so far in the literature is bounded quantification <ref> [CCHO89, CW85] </ref>, where the domain of a type variable is restricted to range over subtypes of a given bound. In this paper we continue the separation of the ML types and refinement types and obtain a restricted form of bounded quantification.
Reference: [CDDK86] <author> Dominique Clement, Joelle Despeyroux, Thierry Despeyroux, and Gilles Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In Proceedings of the 1986 Conference on LISP and Functional Programming. </booktitle> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: In particular, we do not extend the language of programs for ML (only the language of types) and, furthermore, we provide refined type information only for programs which are already well-typed in ML. In this preliminary report we only deal with an extension of Mini-ML <ref> [CDDK86] </ref>, but we believe that the ideas described here can be further ex To appear in ACM SIGPLAN 1991 Conference on Programming Language Design and Implementation. tended to the full Standard ML language. <p> The remainder of the paper is organized as follows. In Section 2 we introduce the syntax of our language, following the presentation of Mini-ML <ref> [CDDK86] </ref>. In Section 3 we show how recursive refinement type declarations can be used to generate finite lattices defining the domain of abstract interpretation for type inference. These lattices of values induce subtype relationships on the function types, as we describe in Section 4. <p> This is sometimes paraphrased as well-typed programs cannot go wrong, that is, if an expression has refinement type , and evaluation of that expression terminates, then the value of the expression will also have the type . The operational semantics is very close to the one given for Mini-ML <ref> [CDDK86] </ref> and we omit it here.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17 </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference-contexts: This is another case where decidability must be balanced with the desire for accuracy in type checking. 5 Polymorphism The interaction between polymorphism and subtypes is potentially problematic. The main mechanism considered so far in the literature is bounded quantification <ref> [CCHO89, CW85] </ref>, where the domain of a type variable is restricted to range over subtypes of a given bound. In this paper we continue the separation of the ML types and refinement types and obtain a restricted form of bounded quantification.
Reference: [GS84] <author> Ferenc Gecseg and Magnus Steinby. </author> <title> Tree Automata. </title> <publisher> Akademiai Kiado, </publisher> <address> Budapest, </address> <year> 1984. </year>
Reference-contexts: Intuitively, this is because these sets cannot be described by regular expressions. In fact, our rectype declarations (with the proper restrictions, see Section 3) have a close connection to regular expressions since our declarations specify so-called regular tree sets for which many well-understood algorithms exist <ref> [GS84] </ref>. Regular tree sets have also shown themselves to be useful in the context of typed logic programming [Mis84, YFS91]. <p> In the following section we show how this information can be lifted to refinement types including the function type constructor !. Our rectype declarations are essentially regular tree grammars and they almost define regular tree sets as discussed in Tree Automata by Gecseg and Steinby <ref> [GS84] </ref>. The only change is that we have functions in 4 our trees, but since we require our rectype declarations to have an ML type on the left-hand side of any !, this extension turns out to be benign.
Reference: [HJ90] <author> Nevin Heintze and Joxan Jaffar. </author> <title> A decision procedure for a class of set constraints. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <address> Philadelphia. </address> <publisher> IEEE, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: This appears to be much more difficult, if not impossible, in approaches using general set constraints as, for example, in <ref> [HJ90] </ref>, or abstract interpretation which is not tied to the type system. We also would like to explore the possibility of refining predefined types, such as int, which are not given as datatype declarations. There are no conceptual difficulties as long as the appropriate subtype structure forms a lattice.
Reference: [KTU89] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> Type-checking in the presence of polymorphic recursion. </title> <note> To appear in TOPLAS, Oc-tober 1989. </note>
Reference-contexts: This notion is already implicit in the earlier examples: ff singleton is a refinement of ff list, but neither bool singleton nor std list are refinements of ff list. A relaxation of this notion could quickly lead to undecidable type inference problems, as in the Milner-Mycroft calculus <ref> [KTU89, Myc84] </ref>. On the other hand, this restriction entails some loss of accuracy in determining refinement type information in some cases.
Reference: [Mis84] <author> Prateek Mishra. </author> <title> Towards a theory of types in Prolog. </title> <booktitle> In International Symposium on Logic Programming, </booktitle> <pages> pages 289-298. </pages> <publisher> IEEE, </publisher> <year> 1984. </year>
Reference-contexts: Regular tree sets have also shown themselves to be useful in the context of typed logic programming <ref> [Mis84, YFS91] </ref>.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Standard ML <ref> [MTH90] </ref> is a practical programming language with higher-order functions, polymorphic types, and a well-developed module system. It is a statically typed language, which allows the compiler to detect many kinds of errors at compile time, thus leading to more reliable programs. <p> The refinement types proposed here address only a subset of Standard ML <ref> [MTH90] </ref>. We need to carefully examine the interaction of refinement types with other features of the ML type system, such as imperative type variables and equality types, since we would like to extend our proposal to encompass all of Standard ML.
Reference: [Myc84] <author> Alan Mycroft. </author> <title> Polymorphic Type Schemes and Recursive Definitions, </title> <booktitle> pages 217-228. International Symposium on Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1984. </year> <note> LNCS 167. </note>
Reference-contexts: This notion is already implicit in the earlier examples: ff singleton is a refinement of ff list, but neither bool singleton nor std list are refinements of ff list. A relaxation of this notion could quickly lead to undecidable type inference problems, as in the Milner-Mycroft calculus <ref> [KTU89, Myc84] </ref>. On the other hand, this restriction entails some loss of accuracy in determining refinement type information in some cases.
Reference: [Pie89] <author> Benjamin Pierce. </author> <title> A decision procedure for the subtype relation on intersection types with bounded variables. </title> <type> Technical Report 9 CMU-CS-89-169, </type> <institution> School of Computer Sci--ence, Carnegie Mellon University, Pitts-burgh, Pennsylvania, </institution> <month> September </month> <year> 1989. </year>
Reference-contexts: Here we avoid explicit typing, while still retaining decidability, by allowing only the intersection of types which are subtypes of a common ML type. It is also this restriction which makes the combination of polymorphism and intersection types simple and direct (see <ref> [Pie89] </ref> for an investigation in a more general context). As we will see later, we also require a form of union types so we can assign more accurate types to case statements.
Reference: [Pie90] <author> Benjamin C. Pierce. </author> <title> Preliminary investigation of a calculus with intersection and union types. </title> <type> Unpublished manuscript, </type> <month> June </month> <year> 1990. </year>
Reference-contexts: As we will see later, we also require a form of union types so we can assign more accurate types to case statements. The inspiration for this and for the subtyp-ing rules for function types (sketched in Section 4) are due to Pierce <ref> [Pie90] </ref>. In many examples, subtypes which could be specified explicitly as refinement types are implicit in current ML programs.
Reference: [RDR88] <author> Simone Ronchi Della Rocca. </author> <title> Principal type scheme and unification for intersection type discipline. </title> <journal> Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 181-209, </pages> <year> 1988. </year>
Reference-contexts: We borrow the operator ^ from the intersection type discipline <ref> [RDR88] </ref>, though we use it in a very restricted way here (we can only intersect types which are refinements of the same ML type). Type inference for intersection types, however, is in general undecidable.
Reference: [Rey88] <author> John C. Reynolds. </author> <title> Preliminary design of the programming language Forsythe. </title> <type> Technical Report CMU-CS-88-159, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: Type inference for intersection types, however, is in general undecidable. Thus, for them to be useful in a programming language, some explicit type annotations are required, as, for example, in Forsythe <ref> [Rey88] </ref>. Here we avoid explicit typing, while still retaining decidability, by allowing only the intersection of types which are subtypes of a common ML type.
Reference: [YFS91] <author> Eyal Yardeni, Thom Fruehwirth, and Ehud Shapiro. </author> <title> Polymorphically typed logic programs. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Types in Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year> <note> To appear. 10 </note>
Reference-contexts: Regular tree sets have also shown themselves to be useful in the context of typed logic programming <ref> [Mis84, YFS91] </ref>. <p> One interesting aspect of our proposal is that it merges two views which are traditionally considered 2 as opposites: should recursive types be generative (as the ML datatype construct), or should they be non-generative (as, for example, in Quest [Car89] in functional programming or in typed HiLog <ref> [YFS91] </ref> in logic programming). Our conclusion is that generative types should be the principal notion, but that non-generative recursively defined subtypes can make a type system significantly more powerful and useful. The remainder of the paper is organized as follows.
References-found: 18

