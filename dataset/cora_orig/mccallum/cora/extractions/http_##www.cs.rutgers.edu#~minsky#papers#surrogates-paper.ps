URL: http://www.cs.rutgers.edu/~minsky/papers/surrogates-paper.ps
Refering-URL: http://www.cs.rutgers.edu/~minsky/pubs.html
Root-URL: http://www.cs.rutgers.edu
Email: minsky@cs.rutgers.edu  partha@cs.rutgers.edu  
Title: Providing Multiple Views for Objects by Means of Surrogates  
Author: Naftaly H. Minsky Partha pratim Pal 
Note: Work supported in part by NSF grants No. CCR-9308773, and in part by ARPA Contract Number DABT63-93-C-0064 Work supported by NSF grants No. CCR-9308773  
Date: December 5, 1995  
Address: New Brunswick, NJ 08903 USA  
Affiliation: Department of Computer Science Rutgers University  
Abstract: This paper introduces the notion of a surrogate object which allows an object to appear different and behave differently when used from different parts of a system. This concept requires some minor modifications to the classical inheritance-based object-oriented systems, mostly involving a judicious use of delegation. A concrete implementation of this concept under law-governed architecture is described, and some of its applications are briefly discussed. keywords: surrogate objects, delegation, object-oriented programming, law-governed architecture, reusing legacy objects, access-control, subject-oriented programming. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R.S. Fabry. </author> <title> Capability-based addressing. </title> <journal> Communications of the ACM, </journal> <volume> 17(7) </volume> <pages> 403-412, </pages> <month> July </month> <year> 1974. </year>
Reference-contexts: Yet, access control is generally not supported by programming languages, under which "access to data is [ordinarily] provided on all-or-nothing basis," as stated by Jones and Liskov [5]. We show here that the capability-based access control mechanism <ref> [1] </ref> can be implemented efficiently, with no run-time overhead, by means of surrogates. Consider, for example, a network of nodes connected by means of unidirectional conduits called pipes, as illustrated in part (a) of Figure 7. <p> These surrogate objects serve here in the same role served by capabilities in operating systems <ref> [1] </ref>. The surrogate p1, for example, carries the rights to invoke methods push and inspect, because these are the features which, due to rule R13, would be delegated to the base object p of its surrogate.
Reference: [2] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns: Michroarchitectures for Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: a surrogate could delegate push in one context and pull in another, whereas a single node may need to push one pipe and pull from another pipe. 6 Related Work 6.1 Wrappers and Similar Devices Structurally, there is a similarity between our surrogates and the wrappers of Gamma et al. <ref> [2] </ref>, the handle-body idiom in C++ [15], the accessors in OATH [6], or the template-hook composition meta pattern of Pree [12]: all of them enclose a component much like our base object.
Reference: [3] <author> W. Harrison, M. Kaplan, A. Katz, V. Kruskal, E. Lan, and H. L. Ossher. </author> <title> Prototype support for subject-Oriented Programming. </title> <booktitle> In OOPSLA' 94 Workshop on Subjectivity, </booktitle> <year> 1994. </year> <note> Position Paper. </note>
Reference-contexts: The accessors in OATH solves this problem by writing dispatching code as in wrappers, in the accessor class. 6.3 Subject-Oriented Programming Methodologically, our model of surrogates is closely related to that of Harrison and Ossher <ref> [4, 3] </ref>, and to a lesser extent to that of Shilling and Sweeney [13].
Reference: [4] <author> W. Harrison and H. L. Ossher. </author> <title> Subject-Oriented Programming (A Critique of Pure Objects). </title> <booktitle> In Proceedings of OOPSLA'93, </booktitle> <pages> pages 411-428, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction One often needs to provide different parts of a large and evolving system with different views of a single object <ref> [4] </ref>. <p> Moreover, one would like such views to be maintainable with minimal effort, while the system-divisions that use them evolve. Unfortunately, the classical OO model of programming is does not support multiple views of this kind. Harrison and Ossher <ref> [4] </ref>, in particular, state that: "designers of such suites ["divisions," in our terminology] are forced either to forego advantages of the object oriented style [such as en capsulation and polymorphism] or to anticipate all future applications, treating all extrinsic information as though it were intrinsic to the object's nature." Their solution <p> unique object-identity, and by means of global composition rules. 1 The term "feature" is used in this paper for either an attribute (instance variable) of an object, or for its method. 2 The terms intrinsic and extrinsic for the features of a surrogate object are borrowed from Harrison and Ossher <ref> [4] </ref>. 2 In this paper we introduce another approach to multiplicity of views, which is more consistent with the classical OO model of programming. <p> The accessors in OATH solves this problem by writing dispatching code as in wrappers, in the accessor class. 6.3 Subject-Oriented Programming Methodologically, our model of surrogates is closely related to that of Harrison and Ossher <ref> [4, 3] </ref>, and to a lesser extent to that of Shilling and Sweeney [13].
Reference: [5] <author> A.K. Jones and B.H. Liskov. </author> <title> A language extension mechanism for controlling access to shared data. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 277-285, </pages> <year> 1976. </year>
Reference-contexts: Yet, access control is generally not supported by programming languages, under which "access to data is [ordinarily] provided on all-or-nothing basis," as stated by Jones and Liskov <ref> [5] </ref>. We show here that the capability-based access control mechanism [1] can be implemented efficiently, with no run-time overhead, by means of surrogates. Consider, for example, a network of nodes connected by means of unidirectional conduits called pipes, as illustrated in part (a) of Figure 7.
Reference: [6] <author> Brian Kennedy. </author> <title> The features of the object-oriented type hierarchy (OATH). </title> <booktitle> In Proceedings of the Usenix C++ Conference, </booktitle> <pages> pages 41-50, </pages> <year> 1991. </year>
Reference-contexts: another, whereas a single node may need to push one pipe and pull from another pipe. 6 Related Work 6.1 Wrappers and Similar Devices Structurally, there is a similarity between our surrogates and the wrappers of Gamma et al. [2], the handle-body idiom in C++ [15], the accessors in OATH <ref> [6] </ref>, or the template-hook composition meta pattern of Pree [12]: all of them enclose a component much like our base object. However, in the case of a wrapper, the enclosing class a) conforms to and b) is strongly coupled to the compo 15 nent class (equivalent to our base class).
Reference: [7] <author> H. Lieberman. </author> <title> Using prototypical objects to implement shared behavior in object oriented systems. </title> <booktitle> In Proceedings of the OOPSLA'86 Conference, </booktitle> <pages> pages 214-223, </pages> <month> September-October </month> <year> 1986. </year>
Reference-contexts: Second, note that delegation is not new here; it has been used, in particular, as the basis for the prototype-and-delegation style of OO programming <ref> [7] </ref> | and alternative for class-based programming. <p> Delegation has been considered by some researchers <ref> [7] </ref> an alternative to classes and inheritance, as an underlying principle in object oriented programming, and there has been some debate about the relative merit of these two principles [14]. What this paper suggests, perhaps, is that the two principles can be usefully combined.
Reference: [8] <author> N.H. Minsky. </author> <title> Law-governed systems. </title> <journal> The IEE Software Engineering Journal, </journal> <month> September </month> <year> 1991. </year>
Reference-contexts: Under this approach, which is based on the concept of law-governed architecture (LGA) <ref> [8, 9] </ref>, views are provided by what we call surrogate objects, which delegate selected messages to their base objects, but can also act on their own. <p> Interactions between the component-parts of the system being developed. The rules that regulate the former kind of interactions, thus governing the process of evolution of P, are enforced dynamically, when the regulated operations are invoked. The structure of these rules has been described in <ref> [8] </ref>, and its knowledge will not be required for the rest of this paper. <p> Finally, it should be pointed out that the critical process of changing the law itself, by the creation and destruction of rules, is also tightly regulated under LGA, as described in <ref> [8] </ref>. 4 Implementing Surrogates in Darwin-E In this section we describe how the concept of surrogates introduced in Section 2 is implemented under the Darwin-E environment for programs written in Eiffel.
Reference: [9] <author> N.H. Minsky. </author> <title> Law-governed regularities in object systems; part 1: Principles. </title> <type> Technical Report LCSR-TR-220, </type> <institution> Rutgers University, LCSR, </institution> <note> De-cember 1994. (Accepted for publication in Theory and Practice of Object Systems (TOPAS)). </note>
Reference-contexts: Under this approach, which is based on the concept of law-governed architecture (LGA) <ref> [8, 9] </ref>, views are provided by what we call surrogate objects, which delegate selected messages to their base objects, but can also act on their own.
Reference: [10] <author> N.H. Minsky and P Pal. </author> <title> Law-governed regularities in object systems; part 2: the eiffel case. </title> <type> Technical Report LCSR-TR-228, </type> <institution> Rutgers University, LCSR, </institution> <month> December </month> <year> 1994. </year> <note> (Accepted for publication in Theory and Practice of Object Systems (TOPAS), subject to minor changes.). </note>
Reference-contexts: We describe a specific implementation of our approach using the Darwin-E software development environment <ref> [10] </ref>, which establishes LGA over Eiffel systems. But, in principle, this approach is applicable to any class-based object-oriented language. The rest of the paper is organized as follows. Section 2 defines our notion of surrogates. Section 3 provides a brief overview of LGA and the darwin-E environment. <p> We will confine ourselves mostly to those aspects of Darwin-E that are directly relevant for our surrogates. For more about this environment the reader is referred to <ref> [10] </ref>. The main novelty of LGA is that it associates with every software development project P an explicit set of rules L called the law of the project, which is strictly enforced by the environment that manages this project. <p> There are quite a number of additional interactions that can be regulated by the law under Darwin-E, most of which are discussed in <ref> [10] </ref>. Each such interaction is regulated by rules specific to it. For example, the call interactions can be controlled by the cannot call and/or the can call rules.
Reference: [11] <author> N.H. Minsky and D. Rozenshtein. </author> <title> Controllable delegation: An exercise in law-governed systems. </title> <booktitle> In Proceedings of the OOPSLA'89 Conference, </booktitle> <pages> pages 371-380, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: What this paper suggests, perhaps, is that the two principles can be usefully combined. Here we have shown that delegation can help in facilitating multiple views. And we believe that, if properly controlled <ref> [11] </ref>, delegation could have some additional applications for class-based languages, which deserve some careful examination. 17
Reference: [12] <author> Wolfgang Pree. </author> <title> Design Patterns for Object-Oriented Software Development. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: one pipe and pull from another pipe. 6 Related Work 6.1 Wrappers and Similar Devices Structurally, there is a similarity between our surrogates and the wrappers of Gamma et al. [2], the handle-body idiom in C++ [15], the accessors in OATH [6], or the template-hook composition meta pattern of Pree <ref> [12] </ref>: all of them enclose a component much like our base object. However, in the case of a wrapper, the enclosing class a) conforms to and b) is strongly coupled to the compo 15 nent class (equivalent to our base class).
Reference: [13] <author> J. Shilling and P. Sweeney. </author> <title> Three steps to views: Extending the object-oriented paradigm. </title> <booktitle> In OOPSLA' 89, </booktitle> <pages> pages 353-361, </pages> <year> 1989. </year> <month> 18 </month>
Reference-contexts: The accessors in OATH solves this problem by writing dispatching code as in wrappers, in the accessor class. 6.3 Subject-Oriented Programming Methodologically, our model of surrogates is closely related to that of Harrison and Ossher [4, 3], and to a lesser extent to that of Shilling and Sweeney <ref> [13] </ref>. Like in the model of Harrison and Ossher, we distinguish between the intrinsic features of an object and the extrinsic features needed by different sets of clients, and we facilitate the independent evolution of different divisions of a system. But there are significant technical differences between these two models.
Reference: [14] <author> Lieberman H. Stein, L.A. and D. Ungar. </author> <title> A shared view of sharing: The treaty of orlando. </title> <editor> In Won Kim and F. Lochovsky, editors, </editor> <booktitle> Object-Oriented Concepts, Applications and Databases. </booktitle> <year> 1989. </year>
Reference-contexts: Delegation has been considered by some researchers [7] an alternative to classes and inheritance, as an underlying principle in object oriented programming, and there has been some debate about the relative merit of these two principles <ref> [14] </ref>. What this paper suggests, perhaps, is that the two principles can be usefully combined. Here we have shown that delegation can help in facilitating multiple views. And we believe that, if properly controlled [11], delegation could have some additional applications for class-based languages, which deserve some careful examination. 17
Reference: [15] <author> B. Stroustrap. </author> <title> The C++ Programming Language. </title> <address> Addision-Wesly, </address> <year> 1994. </year>
Reference-contexts: one context and pull in another, whereas a single node may need to push one pipe and pull from another pipe. 6 Related Work 6.1 Wrappers and Similar Devices Structurally, there is a similarity between our surrogates and the wrappers of Gamma et al. [2], the handle-body idiom in C++ <ref> [15] </ref>, the accessors in OATH [6], or the template-hook composition meta pattern of Pree [12]: all of them enclose a component much like our base object. <p> Such rules are beyond the scope of the present paper. 16 6.2 Overloading ! in C++ The delegation performed by our surrogates can be implemented very easily by overloading the ! operator of C++ <ref> [15] </ref> as in smart pointers [16]. Therefore C++ specific devices such as the smart pointers or handle-body can perform the kind of delegation we are proposing here, but with certain problems as explained below.
Reference: [16] <author> Bjarne Stroustrup. </author> <title> The evolution of C++ 1985 to 1987. </title> <booktitle> In Proceedings of the Usenix C++ Workshop, </booktitle> <pages> pages 1-22, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Such rules are beyond the scope of the present paper. 16 6.2 Overloading ! in C++ The delegation performed by our surrogates can be implemented very easily by overloading the ! operator of C++ [15] as in smart pointers <ref> [16] </ref>. Therefore C++ specific devices such as the smart pointers or handle-body can perform the kind of delegation we are proposing here, but with certain problems as explained below.
References-found: 16

