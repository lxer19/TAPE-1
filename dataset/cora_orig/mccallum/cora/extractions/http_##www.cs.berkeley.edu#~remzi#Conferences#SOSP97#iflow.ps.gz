URL: http://www.cs.berkeley.edu/~remzi/Conferences/SOSP97/iflow.ps.gz
Refering-URL: http://www.cs.berkeley.edu/~remzi/Conferences/SOSP97/
Root-URL: 
Email: fandru,liskovg@lcs.mit.edu  
Title: A Decentralized Model for Information Flow Control  
Author: Andrew C. Myers Barbara Liskov 
Address: 545 Technology Square, Cambridge, MA 02139  
Affiliation: MIT Laboratory for Computer Science  
Date: October 1997  
Note: Proceedings of the 16th ACM Symposium on Operating Systems Principles, Saint-Malo, France,  
Abstract: This paper presents a new model for controlling information flow in systems with mutual distrust and decentralized authority. The model allows users to share information with distrusted code (e.g., downloaded applets), yet still control how that code disseminates the shared information to others. The model improves on existing multilevel security models by allowing users to declassify information in a decentralized way, and by improving support for fine-grained data sharing. The paper also shows how static program analysis can be used to certify proper information flows in this model and to avoid most run-time information flow checks. 
Abstract-found: 1
Intro-found: 1
Reference: [AR80] <author> Gregory R. Andrews and Richard P. Reitman. </author> <title> An axiomatic approach to information flow in programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(1) </volume> <pages> 56-76, </pages> <year> 1980. </year>
Reference-contexts: When data is derived from several sources, all the sources must agree to release the data. Our model can largely be checked statically, like some existing information flow models <ref> [DD77, AR80] </ref>. We define user-supplied program annotations, called labels, that describe the allowed flow of information in a program. An notated programs can be checked at compile time, in a man-ner similar to type checking, to ensure that they do not violate information flow rules. <p> (L 1 t L 2 ) = owners (L 1 ) [ owners (L 2 ) readers (L 1 t L 2 ; O) = readers (L 1 ; O) " readers (L 2 ; O) (The symbol has also been used to denote the join of two security classes <ref> [DD77, AR80] </ref>.) Note that L 1 v L 1 t L 2 for all labels L 1 and L 2 . Joining is a restriction and therefore it does not leak information. 3.3 The Principal Hierarchy To allow compile-time analysis, slots must be immutably labeled. <p> This labeling rule holds as long as all programs terminate, or at least as long as there is no way to derive information from the non-termination of a program <ref> [DD77, AR80] </ref>. The way one decides that a program has not terminated is to time its execution, either explicitly or through asynchronous communication with another thread. We do not address timing channels in this paper. <p> Our propagation of ownership information is also reminiscent of models of access control that merge ACLs at run time [MMN90]. Static analysis of security guarantees also has a long history. It has been applied to information flow <ref> [DD77, AR80] </ref> and to access control [JL78, RSC92]. There has recently been more interest in provably-secure programming languages, treating information flow checks in the domain of type checking [VSI96, Vol97]. Also, integrity constraints [Bib77] have been treated as type checking [PO95]. <p> Also, integrity constraints [Bib77] have been treated as type checking [PO95]. We have avoided considering covert channels arising from time measurement and thread communication. A scheme for statically analyzing thread communication has been proposed <ref> [AR80] </ref>; essentially, a second basic block label is added with different propagation rules. This second label is used to restrict communication with other threads. The same technique would remove timing channels, and could be applied to our scheme. <p> We have not considered the possibility of covert channels that arise from timing channels and from asynchronous communication between threads, which can also be used to create timing channels. The technique of having a timing label for each basic block, as in Andrews and Reitman <ref> [AR80] </ref>, may help with this problem, but more investigation is needed.
Reference: [Bib77] <author> K. J. Biba. </author> <title> Integrity considerations for secure computer systems. </title> <type> Technical Report ESD-TR-76-372, </type> <institution> USAF Electronic Systems Division, Bedford, </institution> <address> MA, </address> <month> April </month> <year> 1977. </year>
Reference-contexts: It has been applied to information flow [DD77, AR80] and to access control [JL78, RSC92]. There has recently been more interest in provably-secure programming languages, treating information flow checks in the domain of type checking [VSI96, Vol97]. Also, integrity constraints <ref> [Bib77] </ref> have been treated as type checking [PO95]. We have avoided considering covert channels arising from time measurement and thread communication. A scheme for statically analyzing thread communication has been proposed [AR80]; essentially, a second basic block label is added with different propagation rules. <p> However, because declassify is intended to allow information to flow across or down the lattice, standard security policies such as non-interference [GM84] are intentionally inapplicable. Because integrity <ref> [Bib77] </ref> constraints have a natural lattice structure, supporting them may be an interesting extension to our label model; the label model can be augmented to allow each owner to establish an independent integrity policy, just as each owner now can establish an independent information flow policy.
Reference: [BL75] <author> D. E. Bell and L. J. LaPadula. </author> <title> Secure computer system: Unified exposition and Multics interpretation. </title> <type> Technical Report ESD-TR-75-306, </type> <institution> MITRE Corp. MTR-2997, Bedford, </institution> <address> MA, </address> <year> 1975. </year> <note> Available as NTIS AD-A023 588. </note>
Reference-contexts: The lattice model of information flow comes from the early work of Bell and LaPadula <ref> [BL75] </ref> and Denning [Den76]. More recent work on information flow policies has examined complex aggregation policies for commercial applications [CW87, BN89, Fol91]. We have not addressed policies that capture conflicts of interest, though our fine-grained tracking of own ership information seems applicable.
Reference: [BN89] <author> D. F. Brewer and J. Nash. </author> <title> The Chinese wall security policy. </title> <booktitle> In Proc. of the IEEE Symposium 17 on Security and Privacy, </booktitle> <pages> pages 206-258, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: The lattice model of information flow comes from the early work of Bell and LaPadula [BL75] and Denning [Den76]. More recent work on information flow policies has examined complex aggregation policies for commercial applications <ref> [CW87, BN89, Fol91] </ref>. We have not addressed policies that capture conflicts of interest, though our fine-grained tracking of own ership information seems applicable. Many of these information control models use dynamic labels rather than static labels and therefore cannot be checked statically.
Reference: [CW87] <author> David Clark and David R. Wilson. </author> <title> A comparison of commerical and military computer security policies. </title> <booktitle> In Proc. of the IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 184-194, </pages> <year> 1987. </year>
Reference-contexts: The lattice model of information flow comes from the early work of Bell and LaPadula [BL75] and Denning [Den76]. More recent work on information flow policies has examined complex aggregation policies for commercial applications <ref> [CW87, BN89, Fol91] </ref>. We have not addressed policies that capture conflicts of interest, though our fine-grained tracking of own ership information seems applicable. Many of these information control models use dynamic labels rather than static labels and therefore cannot be checked statically.
Reference: [DD77] <author> Dorothy E. Denning and Peter J. Denning. </author> <title> Certification of programs for secure information flow. </title> <journal> Comm. of the ACM, </journal> <volume> 20(7) </volume> <pages> 504-513, </pages> <year> 1977. </year>
Reference-contexts: When data is derived from several sources, all the sources must agree to release the data. Our model can largely be checked statically, like some existing information flow models <ref> [DD77, AR80] </ref>. We define user-supplied program annotations, called labels, that describe the allowed flow of information in a program. An notated programs can be checked at compile time, in a man-ner similar to type checking, to ensure that they do not violate information flow rules. <p> (L 1 t L 2 ) = owners (L 1 ) [ owners (L 2 ) readers (L 1 t L 2 ; O) = readers (L 1 ; O) " readers (L 2 ; O) (The symbol has also been used to denote the join of two security classes <ref> [DD77, AR80] </ref>.) Note that L 1 v L 1 t L 2 for all labels L 1 and L 2 . Joining is a restriction and therefore it does not leak information. 3.3 The Principal Hierarchy To allow compile-time analysis, slots must be immutably labeled. <p> In this section, we discuss some issues related to static analysis of annotated code, though we defer issues of how to extend a programming language till the next section. In Section 4.1, we explain the importance of static checking to information flow control, and the problem of implicit flows <ref> [DD77] </ref>. In Section 4.2, we describe a simple way to prevent implicit flows from leaking information by using static analysis. 4.1 Static vs. Dynamic Checking Information flow checks can be viewed as an extension to type checking. <p> A compile-time check only provides information about the program that is being compiled. Similarly, link-time and load-time checks provide information only about the program, and may be considered to be static checks for the purposes of this work. Implicit information flows <ref> [DD77] </ref> are difficult to prevent without static analysis. <p> This rule for basic block label propagation is equivalent to the rule of Denning and Denning <ref> [DD77] </ref>. Now, consider the execution of a while statement, which creates a loop in the basic block diagram. This situation is illustrated in Figure 5. Note that for the final basic block, we obtain B = ? by reasoning in the same way as we did for the if statement. <p> This labeling rule holds as long as all programs terminate, or at least as long as there is no way to derive information from the non-termination of a program <ref> [DD77, AR80] </ref>. The way one decides that a program has not terminated is to time its execution, either explicitly or through asynchronous communication with another thread. We do not address timing channels in this paper. <p> Note that in each statement rule, B represents the label for the basic block containing the statement. Many of these rules are similar in intent to those found in Denning and Denning <ref> [DD77] </ref>, though these rules are different in that they are expressed without using the meet operator (u). 5.3 Labeled Types As described, values and slots have labels that restrict information flow. In statically-typed languages, values and slots also have static types that can be said to restrict flow. <p> The assignment is legal if e t r t B v f. This rule is equivalent to the one in Denning and Denning <ref> [DD77] </ref>. The rule for assignment to an array element is similar, except that the label on the array index is included on the left-hand side. <p> Our propagation of ownership information is also reminiscent of models of access control that merge ACLs at run time [MMN90]. Static analysis of security guarantees also has a long history. It has been applied to information flow <ref> [DD77, AR80] </ref> and to access control [JL78, RSC92]. There has recently been more interest in provably-secure programming languages, treating information flow checks in the domain of type checking [VSI96, Vol97]. Also, integrity constraints [Bib77] have been treated as type checking [PO95].
Reference: [Den76] <author> Dorothy E. Denning. </author> <title> A lattice model of secure information flow. </title> <journal> Comm. of the ACM, </journal> <volume> 19(5) </volume> <pages> 236-243, </pages> <year> 1976. </year>
Reference-contexts: write data that is readable by a group principal to a channel that is readable by a member of the group, since the member principal can act for the group principal. 3.6 Security Class Lattice If we consider just Rule 1, the set of labels forms a conventional security-class lattice <ref> [Den76] </ref>, where each element in the lattice is one of the possible labels. Labels exist in a partial order as defined by the restriction operator, v. <p> The lattice model of information flow comes from the early work of Bell and LaPadula [BL75] and Denning <ref> [Den76] </ref>. More recent work on information flow policies has examined complex aggregation policies for commercial applications [CW87, BN89, Fol91]. We have not addressed policies that capture conflicts of interest, though our fine-grained tracking of own ership information seems applicable.
Reference: [DG84] <author> William F. Dowling and Jean H. Gallier. </author> <title> Linear-time algorithms for testing the satisfiability of propositional Horn formul. </title> <journal> Journal of Logic Programming, </journal> <volume> 1(3) </volume> <pages> 267-284, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: The goal of verification is to determine whether there are assignments to the local variable labels and basic block labels that satisfy all the constraints. This problem is similar in form to the problem of satisfying propositional Horn clauses; in fact, a linear-time algorithm for satisfying Horn clauses <ref> [DG84, RM96] </ref> can be adapted easily to this problem. If, on the other hand, we had permitted use of both the t and u operators in constructing label expressions, the label satisfaction problem would have become NP-complete [RM96].
Reference: [Fol91] <author> Simon N. Foley. </author> <title> A taxonomy for information flow policies and models. </title> <booktitle> In Proc. of the IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 98-108, </pages> <year> 1991. </year>
Reference-contexts: The lattice model of information flow comes from the early work of Bell and LaPadula [BL75] and Denning [Den76]. More recent work on information flow policies has examined complex aggregation policies for commercial applications <ref> [CW87, BN89, Fol91] </ref>. We have not addressed policies that capture conflicts of interest, though our fine-grained tracking of own ership information seems applicable. Many of these information control models use dynamic labels rather than static labels and therefore cannot be checked statically.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <month> August </month> <year> 1996. </year> <note> ISBN 0-201-63451-1. </note>
Reference-contexts: As the system grows larger and more complex, and incorporates distrusted code (e.g., web applications), complete trust becomes unattainable. Systems that support the downloading of distrusted code are particularly in need of a better security model. For example, Java <ref> [GJS96] </ref> supports downloading of code from remote sites, which creates the possibility that the downloaded code will transfer private data to those sites. Java attempts to prevent these transfers by using a compartmental security model, but this approach largely prevents applications from sharing data. <p> Procedures may contain variable declarations, assignments, if statements, and while statements; they return results by assigning to special return variables, as in Pascal. Variables of record or array types are references to storage on the heap, as in Java <ref> [GJS96] </ref> and CLU [LAB + 84], so that assignment of a record or array (e.g., r1 := r2 or a1 := a2) makes the variables aliases for each other. For simplicity, the language has no exceptions.
Reference: [GM84] <author> J. A. Goguen and J. Meseguer. </author> <title> Unwinding and inference control. </title> <booktitle> In Proc. of the IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 11-20, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: However, because declassify is intended to allow information to flow across or down the lattice, standard security policies such as non-interference <ref> [GM84] </ref> are intentionally inapplicable.
Reference: [JG91] <author> Pierre Jouvelot and David K. Gifford. </author> <title> Algebraic reconstruction of types and effects. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 303-310, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The same technique would remove timing channels, and could be applied to our scheme. It is not clear how well this scheme works in practice; it seems likely to restrict timing and communication quite severely. Static side-effect and region analysis <ref> [JG91] </ref>, which aims to infer all possible side-effects caused by a piece of code, may be able to capture effects like timing channels. 8 Conclusions This work was motivated by a desire to provide better security when using downloaded applications, by making fine-grained information flow control practical and efficient.
Reference: [JL78] <author> Anita K. Jones and Barbara Liskov. </author> <title> A language extension for expressing constraints on data access. </title> <journal> Comm. of the ACM, </journal> <volume> 21(5) </volume> <pages> 358-367, </pages> <month> May </month> <year> 1978. </year>
Reference-contexts: Type checks may be performed at compile time or at run time, though compile-time checks are obviously preferred when applicable because they impose no run-time overhead. Access control checks are usually performed at run time, although some access control checks may be performed at compile time <ref> [JL78, RSC92] </ref>. In general, it seems that some access control checks must be performed dynamically in order to give the system sufficient flexibility. <p> Our propagation of ownership information is also reminiscent of models of access control that merge ACLs at run time [MMN90]. Static analysis of security guarantees also has a long history. It has been applied to information flow [DD77, AR80] and to access control <ref> [JL78, RSC92] </ref>. There has recently been more interest in provably-secure programming languages, treating information flow checks in the domain of type checking [VSI96, Vol97]. Also, integrity constraints [Bib77] have been treated as type checking [PO95]. We have avoided considering covert channels arising from time measurement and thread communication.
Reference: [LAB + 84] <author> Barbara Liskov, Russell Atkinson, Toby Bloom, J. Eliot Moss, J. Craig Schaffert, Robert Schei-fler, and Alan Snyder. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year> <note> Also published as Lecture Notes in Computer Science 114, </note> <editor> G. Goos and J. Hartmanis, Eds., </editor> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Procedures may contain variable declarations, assignments, if statements, and while statements; they return results by assigning to special return variables, as in Pascal. Variables of record or array types are references to storage on the heap, as in Java [GJS96] and CLU <ref> [LAB + 84] </ref>, so that assignment of a record or array (e.g., r1 := r2 or a1 := a2) makes the variables aliases for each other. For simplicity, the language has no exceptions.
Reference: [LABW91] <author> Butler Lampson, Mart n Abadi, Michael Burrows, and Edward Wobber. </author> <title> Authentication in distributed systems: Theory and practice. </title> <booktitle> In Proc. 13th ACM Symp. on Operating System Principles (SOSP), </booktitle> <pages> pages 165-182, </pages> <month> October </month> <year> 1991. </year> <title> Operating System Review, </title> <type> 253(5). </type>
Reference-contexts: For example, every member of a group might have the right to act for the group principal. The acts for relation is reflexive and transitive, defining a hierarchy or partial order of principals. This model is similar to a speaks for hierarchy <ref> [LABW91] </ref>, though roles are treated here as first-class principals. We assume that the principal structure can be queried using the primitive acts-for function to discover whether the current principal has the right to act for another principal.
Reference: [Lam73] <author> Butler W. Lampson. </author> <title> A note on the confinement problem. </title> <journal> Comm. of the ACM, </journal> <volume> 10 </volume> <pages> 613-615, </pages> <year> 1973. </year>
Reference: [LY96] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine. </title> <publisher> Addison-Wesley, </publisher> <address> Englewood Cliffs, NJ, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Code transfer is useful both for clients, which download applications from servers, and for servers, which upload code and data from clients for remote evaluation. The annotations could be used to extend many conventional programming languages, intermediate code (such as JVM <ref> [LY96] </ref>), or machine code, where the labeling system defined here makes a good basis for security proofs [Nec97]. Labeled machine code and security proofs could work together: proof annotations for object code would be generated as a byproduct of compiling a program that contains information flow annotations. <p> These annotations could be applied to other programming models, such as compiled code or JVM code <ref> [LY96] </ref>. The language supports the usual simple types: integers, strings, records, and arrays of any legal type including other array types. Procedures may contain variable declarations, assignments, if statements, and while statements; they return results by assigning to special return variables, as in Pascal. <p> An obvious next step is to implement the model by extending an existing language compiler, and developing working applications for examples like those in Section 2. It should also be possible to augment the Java Virtual Machine <ref> [LY96] </ref> with annotations similar to those proposed in Section 5. The bytecode verifier would check both types and labels at the time that code is downloaded into the system. The computational model described in Section 5 has a reasonable set of data types.
Reference: [MMN90] <author> Catherine J. McCollum, Judith R. Messing, and LouAnna Notargiacomo. </author> <title> Beyond the pale of MAC and DAC defining new forms of access control. </title> <booktitle> In Proc. of the IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 190-200, </pages> <year> 1990. </year>
Reference-contexts: IX [MR92] is a good example of a practical information flow control system that takes this approach. Our propagation of ownership information is also reminiscent of models of access control that merge ACLs at run time <ref> [MMN90] </ref>. Static analysis of security guarantees also has a long history. It has been applied to information flow [DD77, AR80] and to access control [JL78, RSC92]. There has recently been more interest in provably-secure programming languages, treating information flow checks in the domain of type checking [VSI96, Vol97].
Reference: [MR92] <author> M. D. McIlroy and J. A. Reeds. </author> <title> Multilevel security in the UNIX tradition. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 22(8) </volume> <pages> 673-694, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: We have not addressed policies that capture conflicts of interest, though our fine-grained tracking of own ership information seems applicable. Many of these information control models use dynamic labels rather than static labels and therefore cannot be checked statically. IX <ref> [MR92] </ref> is a good example of a practical information flow control system that takes this approach. Our propagation of ownership information is also reminiscent of models of access control that merge ACLs at run time [MMN90]. Static analysis of security guarantees also has a long history.
Reference: [Nec97] <author> George C. Necula. </author> <title> Proof-carrying code. </title> <booktitle> In Proc. of ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 106-119, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: The annotations could be used to extend many conventional programming languages, intermediate code (such as JVM [LY96]), or machine code, where the labeling system defined here makes a good basis for security proofs <ref> [Nec97] </ref>. Labeled machine code and security proofs could work together: proof annotations for object code would be generated as a byproduct of compiling a program that contains information flow annotations. The remainder of the paper describes the model and how checking is done.
Reference: [PO95] <author> Jens Palsberg and Peter rbk. </author> <title> Trust in the - calculus. </title> <booktitle> In Proc. 2nd International Symposium on Static Analysis, number 983 in Lecture Notes in Computer Science, </booktitle> <pages> pages 314-329. </pages> <publisher> Springer, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: It has been applied to information flow [DD77, AR80] and to access control [JL78, RSC92]. There has recently been more interest in provably-secure programming languages, treating information flow checks in the domain of type checking [VSI96, Vol97]. Also, integrity constraints [Bib77] have been treated as type checking <ref> [PO95] </ref>. We have avoided considering covert channels arising from time measurement and thread communication. A scheme for statically analyzing thread communication has been proposed [AR80]; essentially, a second basic block label is added with different propagation rules. This second label is used to restrict communication with other threads.
Reference: [RM96] <author> Jakob Rehof and Torben . Mogensen. </author> <title> Tractable constraints in finite semilattices. </title> <booktitle> In Proc. 3rd International Symposium on Static Analysis, number 1145 in Lecture Notes in Computer Science, </booktitle> <pages> pages 285-300. </pages> <publisher> Springer-Verlag, </publisher> <month> Septem-ber </month> <year> 1996. </year>
Reference-contexts: The goal of verification is to determine whether there are assignments to the local variable labels and basic block labels that satisfy all the constraints. This problem is similar in form to the problem of satisfying propositional Horn clauses; in fact, a linear-time algorithm for satisfying Horn clauses <ref> [DG84, RM96] </ref> can be adapted easily to this problem. If, on the other hand, we had permitted use of both the t and u operators in constructing label expressions, the label satisfaction problem would have become NP-complete [RM96]. <p> If, on the other hand, we had permitted use of both the t and u operators in constructing label expressions, the label satisfaction problem would have become NP-complete <ref> [RM96] </ref>. The algorithm works by keeping track of conservative upper bounds for each unknown label. Initially, all the upper bounds are set to &gt;. The algorithm then iteratively decreases the upper bounds, until either all equations are satisfied or a contradiction is observed.
Reference: [RSC92] <author> Joel Richardson, Peter Schwarz, and Luis-Felipe Cabrera. CACL: </author> <title> Efficient fine-grained protection for objects. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 154-165, </pages> <address> Vancouver, BC, Canada, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Type checks may be performed at compile time or at run time, though compile-time checks are obviously preferred when applicable because they impose no run-time overhead. Access control checks are usually performed at run time, although some access control checks may be performed at compile time <ref> [JL78, RSC92] </ref>. In general, it seems that some access control checks must be performed dynamically in order to give the system sufficient flexibility. <p> The implementor of the called procedure is also protected, because the procedure uses only the authority its implementor wishes to claim, and only where needed. (This is similar to the CACL model <ref> [RSC92] </ref>, but provides more protection for the implementor.) 5.12 protected [T] Run-time label checking is conveniently accomplished by using the special type protected [T]. A protected [T] is an immutable object that contains two things: a value of type T, and a label that protects the value. <p> Our propagation of ownership information is also reminiscent of models of access control that merge ACLs at run time [MMN90]. Static analysis of security guarantees also has a long history. It has been applied to information flow [DD77, AR80] and to access control <ref> [JL78, RSC92] </ref>. There has recently been more interest in provably-secure programming languages, treating information flow checks in the domain of type checking [VSI96, Vol97]. Also, integrity constraints [Bib77] have been treated as type checking [PO95]. We have avoided considering covert channels arising from time measurement and thread communication.
Reference: [Vol97] <author> Dennis Volpano. </author> <title> Provably-secure programming languages for remote evaluation. </title> <journal> ACM SIG-PLAN Notices, </journal> <volume> 32(1) </volume> <pages> 117-119, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: Static analysis of security guarantees also has a long history. It has been applied to information flow [DD77, AR80] and to access control [JL78, RSC92]. There has recently been more interest in provably-secure programming languages, treating information flow checks in the domain of type checking <ref> [VSI96, Vol97] </ref>. Also, integrity constraints [Bib77] have been treated as type checking [PO95]. We have avoided considering covert channels arising from time measurement and thread communication. A scheme for statically analyzing thread communication has been proposed [AR80]; essentially, a second basic block label is added with different propagation rules.
Reference: [VSI96] <author> Dennis Volpano, Geoffrey Smith, and Cyn-thia Irvine. </author> <title> A sound type system for secure flow analysis. </title> <journal> Journal of Computer Security, </journal> <volume> 4(3) </volume> <pages> 167-187, </pages> <year> 1996. </year>
Reference-contexts: For any two types S and T where S is a subtype of T (S T ), and for any two labels L 1 and L 2 where L 1 v L 2 , SfL 1 g T fL 2 g <ref> [VSI96] </ref>. This formula also implies that SfL 1 g T fL 1 t L 3 g, for any other label L 3 . Parametric types such as arrays and records explicitly mention labels on their type parameters. <p> Static analysis of security guarantees also has a long history. It has been applied to information flow [DD77, AR80] and to access control [JL78, RSC92]. There has recently been more interest in provably-secure programming languages, treating information flow checks in the domain of type checking <ref> [VSI96, Vol97] </ref>. Also, integrity constraints [Bib77] have been treated as type checking [PO95]. We have avoided considering covert channels arising from time measurement and thread communication. A scheme for statically analyzing thread communication has been proposed [AR80]; essentially, a second basic block label is added with different propagation rules.
References-found: 25

