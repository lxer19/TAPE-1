URL: ftp://ftp.csd.uu.se/pub/papers/reports/0145.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: On cyclic process dependencies and the verification of absence of deadlocks in reactive systems  
Author: Richard Carlsson and H-akan Millroth 
Address: Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Computing Science Department Uppsala University  
Note: ISSN 1100-0686  
Abstract: UPMAIL Technical Report No. 145 Abstract We introduce the class of weak process dependency relations, and give definitions of starvation and deadlock cycles in terms of these. We show the usefulness of our definitions in reasoning about deadlocks, in the general sense of all forms of infinite process suspension, including the local form also known as livelock. In particular, we make a formal distinction between three complementary cases of deadlock: starvation, deadlock cycles, and a form we call non-closing deadlocks. Furthermore, we state assumptions under which absence of deadlocks may be verified for a program by verifying absence of deadlock cycles, and discuss when dependencies between deadlocked processes can safely be excluded. We give a generalised framework for verifying absence of deadlock cycles, in terms of our definitions, extending the method developed by Stephen P. Masticola to local deadlocks. Lastly, we demonstrate how Masticola's method can be mapped onto our framework, and briefly discuss the relation between resource allo cation dependencies and weak process dependency relations.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Joe Armstrong, Robert Virding, Claes Wikstrom and Mike Williams. </author> <title> Concurrent Programming in Erlang, 2nd ed. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: Stephen P. Masticola [4], describes a static detection method based on finding possible dependency cycles in programs, and evaluates this for large programs in Ada and Concurrent C, showing good results. We believe the method could be applied successfully to programs in concurrent functional languages such as Erlang <ref> [1] </ref>. <p> Let a cycle in a relation R be a sequence (a 1 ; : : : a n ) such that for all i 2 <ref> [1; n 1] </ref>, a i R a i+1 and a n R a 1 , and furthermore, for any a i and a j in the sequence, a i = a j ) i = j. <p> A deadlock cycle in under R is a cycle (p 1 ; : : : p n ) in R such that for all i 2 <ref> [1; n] </ref>, p i is deadlocked in . <p> With this scheme, we only need to verify for each cycle (~ 1 ; : : : ~ k ) in D A (a), for a 2 A, that there is no deadlock cycle in any 2 fl A (a) such that () contains for each i 2 <ref> [1; k] </ref> at least one concrete process state in fl ffi (~ i ). <p> This work was motivated by an attempt to find a practical deadlock analysis method [2] for the concurrent functional language Erlang, in which asynchronous message passing is the sole form of process communication <ref> [1] </ref>. Our work provides a theoretical basis for extending the methods in [4], or the generalization given in section 8, to programs in Erlang or similar languages, such as Concurrent ML [5].
Reference: [2] <author> Richard Carlsson. </author> <title> Towards a deadlock analysis for Erlang programs. </title> <type> Master's thesis. </type> <institution> Uppsala University, </institution> <month> February </month> <year> 1997. </year>
Reference-contexts: Dynamic (run-time) detection of deadlocks is in general not possible to perform with high precision, due to the speed requirements on such methods. Also, occurred deadlocks are expensive in time to remedy, and information might be irretrievably lost in the process. Therefore, and for other reasons (see e. g. <ref> [2] </ref>), static program verification would be much preferred over dynamic methods. Process synchronization deadlocks are in general more difficult to handle than the more commonly studied case of resource allocation deadlocks, as encountered in e. g. operating systems. <p> Masticola [4]. Lastly, we have shown as an example how Masticola's method can be mapped onto our generalised framework, and briefly discussed the relation between resource allocation dependencies and weak process dependency relations. This work was motivated by an attempt to find a practical deadlock analysis method <ref> [2] </ref> for the concurrent functional language Erlang, in which asynchronous message passing is the sole form of process communication [1].
Reference: [3] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Conference Record of the 4th annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 238-252, </pages> <address> Los Angeles, California, </address> <year> 1977. </year>
Reference-contexts: The above amounts to the same as computing, e. g. using abstract interpretation <ref> [3] </ref>, for the program point where a process has suspended, the set of synchronizations the same process could execute from that point on if it was unblocked (or a safe approximation thereof), under the assumption that nothing is known about those values that are not statically determined in the code for
Reference: [4] <author> Stephen P. Masticola. </author> <title> Static detection of deadlocks in polynomial time. </title> <publisher> Ph. </publisher> <address> D. </address> <institution> dissertation. New Brunswick Rutgers, State University of New Jersey, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: The difficulty of making the problem tractable at the same time as retaining sufficient precision has previously made this latter method practically useless for large programs. Stephen P. Masticola <ref> [4] </ref>, describes a static detection method based on finding possible dependency cycles in programs, and evaluates this for large programs in Ada and Concurrent C, showing good results. We believe the method could be applied successfully to programs in concurrent functional languages such as Erlang [1]. <p> Section 10 briefly discusses the relation between resource allocation deadlocks and the process dependency relations we have defined. Section 11 concludes the article and discusses future work. Masticola gives in <ref> [4] </ref> a detailed overview of related work; none of which however has had any direct influence on this work. 2 Preliminaries We will base our discussion on a mathematical abstraction of reactive systems in general: we assume that processes, environments or stores, devices, and similar concepts, can be modelled using the <p> incoming edges, or v is part of a circuit in G, or G contains a vertex w which has no incoming edges or is part of a circuit in G, and there is a path in G from w to v. (What follows is based on the proof given in <ref> [4] </ref>, section 2.2.3, lemma 1.) Suppose there is a vertex v in G which is not in one of the three categories of the lemma. <p> that such a control path could transcend any number of process spawns.) If a process which is deadlocked according to Definition 3.2 can be shown not to be dependent on any possible process under this rule, we may safely regard it as starved. 1 This is the criterion used in <ref> [4] </ref> for the initial stage which locates circuits in a graph model of the program text. 11 A slight improvement on this is to involve those variable bindings (or memory contents) in processes which do not vary with the input, and their effects on which control paths may be chosen, and <p> Also, for each state, the dependency relation must be computed and deadlock cycles searched for. The method we suggest instead is that developed and applied (with some success, also for large programs, although on limited models of concurrency and synchronization) by Stephen P. Masticola <ref> [4] </ref>, which we will here attempt to generalise as far as possible, through application of the weak process dependency relations we have detailed in the previous sections. <p> We may gather any extra information about the reachable states of the program, particularly regarding the correlation of process states, 15 such as the "can't happen together"-analysis in <ref> [4] </ref>. Specifically, all processes forming a deadlock cycle must obviously be able to coexist, and restrictions on the possible combinations of program points and of environments/stores might be found. <p> process p in the cycle and a non-blocked process q in the state such that p is strongly dependent on q; in other words that q will eventually unblock p if the scheduling is fair. 9 An example To illustrate the generalization presented in section 8 of Masticola's verification method <ref> [4] </ref>, we demonstrate how that method can be seen as a special case of the generalised scheme; indeed almost the simplest case. <p> Formally, Masticola limits his ambition to verifying absence of global deadlocks, but as we have showed in the above sections, under certain assumptions the results are valid also for local deadlocks. The "waits-on"-relation assumed by Masticola is intuitive rather than well-defined, but as the criteria used in <ref> [4] </ref> for approximating this relation are safe also for approximating a corresponding weak process dependency relation as discussed in sections 7 and 8, this is not a problem. <p> We have also given a generalised framework for verifying absence of deadlock cycles, in terms of our definitions, which covers both the standard method and that developed by Stephen P. Masticola <ref> [4] </ref>. Lastly, we have shown as an example how Masticola's method can be mapped onto our generalised framework, and briefly discussed the relation between resource allocation dependencies and weak process dependency relations. <p> This work was motivated by an attempt to find a practical deadlock analysis method [2] for the concurrent functional language Erlang, in which asynchronous message passing is the sole form of process communication [1]. Our work provides a theoretical basis for extending the methods in <ref> [4] </ref>, or the generalization given in section 8, to programs in Erlang or similar languages, such as Concurrent ML [5]. <p> apply these methods to concurrent programming languages as general as Erlang, a number of problems regarding precision must first be solved, e. g. and most importantly: * In determining the set of synch edges, Masticola relies mostly on synchronization statements using static names for signals, remote procedure calls, channels, etc. <ref> [4] </ref>. <p> Masticola suggests a strategy of partitioning the set of possible processes which exe 18 cute a particular piece of program text, into a small number of classes, giving each its own representation, and uses this in analysing Concurrent C programs <ref> [4] </ref>. It seems unlikely, however, that this method will suffice for programs making more extensive use of such parallellism.
Reference: [5] <author> J. H. Reppy. </author> <title> CML: A Higher-order Concurrent Language. </title> <booktitle> In ACM Symposium on Programming Language Design and Implementation, </booktitle> <year> 1991. </year>
Reference-contexts: Our work provides a theoretical basis for extending the methods in [4], or the generalization given in section 8, to programs in Erlang or similar languages, such as Concurrent ML <ref> [5] </ref>. It is our hope that this work will support and extend the application of what seems to be a practical and powerful approach to static deadlock detection, to all areas of concurrent computing and reactive systems.
Reference: [6] <author> R. N. Taylor. </author> <title> A general-purpose algorithm for analyzing concurrent programs. </title> <journal> In Communications of the ACM, </journal> <volume> Vol. 26, No. 5 (1983), </volume> <pages> pp. 362-376. </pages>
Reference-contexts: We merely note here that this problem needs to be further looked into. 8 Verifying absence of deadlock cycles The traditional method <ref> [6] </ref> of statically verifying absence of deadlocks, or detecting them, is to exhaustively generate all concurrency states reachable from a member of the set of initial states for the program.
References-found: 6

