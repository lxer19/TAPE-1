URL: http://www.isse.gmu.edu:80/~csis/publications/tkde96.ps
Refering-URL: http://www.isse.gmu.edu:80/~csis/publication.html
Root-URL: 
Title: Advanced Transaction Processing in Multilevel Secure File Stores  
Author: Elisa Bertino Sushil Jajodia Luigi Mancini Indrajit Ray 
Keyword: Index Terms|Data management system, File system management, Transaction processing, Concurrency control, Two-phase locking, Exception handling, Security kernel, Mandatory access control, Covert channels.  
Abstract: The concurrency control requirements for transaction processing in a multilevel secure file system are different from those in conventional transaction processing systems. In particular, there is the need to coordinate transactions at different security levels avoiding both potential timing covert channels and the starvation of transactions at higher security levels. Suppose a transaction at a lower security level attempts to write a data item that is being read by a transaction at a higher security level. On the one hand, a timing covert channel arises if the transaction at the lower security level is either delayed or aborted by the scheduler. On the other hand, the transaction at the high security level may be subjected to an indefinite delay if it is forced to abort repeatedly. This paper extends the classical two-phase locking mechanism to multilevel secure file systems. The scheme presented here prevents potential timing covert channels and avoids the abort of higher level transactions nonetheless guaranteeing serializability. The programmer is provided with a powerful set of linguistic constructs that supports exception handling, partial rollback and forward recovery. The proper use of these constructs can prevent the indefinite delay in completion of a higher level transaction, and allows the programmer to trade off starvation with transaction isolation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. L. Eppinger, L. B. Mummert, and A. Z. Spector, Eds., Camelot and Avalon: </author> <title> A Distributed Transaction Facility, </title> <publisher> Morgan Kaufman Publishers, Inc., </publisher> <address> San Mateo, Cali-fornia, </address> <year> 1991. </year>
Reference-contexts: Indeed, a large class of applications exists for which the full power of a DBMS may not be required, but for which reliable, concurrent access to shared data is a crucial requirement. As a result, transaction facilities are now being supported in many file systems such as Camelot <ref> [1] </ref> and Arjuna [2]. While transaction management techniques and algorithms are fairly well understood for data management systems, this is not the case for multilevel secure systems.
Reference: [2] <author> S. K. Shrivastava and D. L. McCue, </author> <title> "Structuring Fault-Tolerant Object Systems for Modularity in a Distributed Environment," </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> vol. 5, no. 4, </volume> <pages> pp. 421-432, </pages> <year> 1994. </year>
Reference-contexts: As a result, transaction facilities are now being supported in many file systems such as Camelot [1] and Arjuna <ref> [2] </ref>. While transaction management techniques and algorithms are fairly well understood for data management systems, this is not the case for multilevel secure systems.
Reference: [3] <author> D.E. Bell and L.J. LaPadula, </author> <title> "Secure Computer Systems: Unified Exposition and Multics Interpretation," </title> <type> Tech. Rep. </type> <institution> MTR-2997, The Mitre Corp., </institution> <address> Burlington Road, Bedford, MA 01730, USA, </address> <month> March </month> <year> 1976. </year>
Reference-contexts: the following mandatory access rules: A process P can write to a data item x only if x is at the same security level as that of P , and can read x only if x is at a security level lower than or equal to that of P (cf. <ref> [3] </ref>). The development of a multilevel secure data management system requires a careful re-visitation of the architectural components, techniques and algorithms used in a conventional non-secure system. <p> That is, the transaction must be at the same security level as the data item x, if it has to write to x. Note that the second constraint is the restricted version of the ?-property which allows transactions to write to higher levels <ref> [3, 5] </ref>; the constrained version is desirable for integrity reasons. In addition to these two restrictions, a secure system must guard against illegal information flows through covert channels.
Reference: [4] <author> B. W. Lampson, </author> <title> "A Note on the Confinement Problem," </title> <journal> Communication of the ACM, </journal> <volume> vol. 16, no. 10, </volume> <pages> pp. 613-615, </pages> <month> October </month> <year> 1973. </year>
Reference-contexts: The development of a multilevel secure data management system requires a careful re-visitation of the architectural components, techniques and algorithms used in a conventional non-secure system. If a system intended to be secure is not designed properly, it may have covert channels <ref> [4, 5] </ref> which can be exploited by sophisticated intruders to gain illegal access to data. Secure transaction processing is not easily achieved by the conventional techniques, as these have grave security implications. To illustrate, consider the following example.
Reference: [5] <author> D. E. Denning, </author> <title> Cryptography and Data Security, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1982. </year>
Reference-contexts: The development of a multilevel secure data management system requires a careful re-visitation of the architectural components, techniques and algorithms used in a conventional non-secure system. If a system intended to be secure is not designed properly, it may have covert channels <ref> [4, 5] </ref> which can be exploited by sophisticated intruders to gain illegal access to data. Secure transaction processing is not easily achieved by the conventional techniques, as these have grave security implications. To illustrate, consider the following example. <p> That is, the transaction must be at the same security level as the data item x, if it has to write to x. Note that the second constraint is the restricted version of the ?-property which allows transactions to write to higher levels <ref> [3, 5] </ref>; the constrained version is desirable for integrity reasons. In addition to these two restrictions, a secure system must guard against illegal information flows through covert channels.
Reference: [6] <author> T. F. Keefe, W. T. Tsai, and J. Srivastava, </author> <title> "Multilevel secure database concurrency control," </title> <booktitle> in Proceedings of the IEEE 6th Int'l Conference on Data Engineering, </booktitle> <address> Los Angeles, California, </address> <month> February </month> <year> 1990, </year> <pages> pp. 337-344. </pages>
Reference-contexts: To date, no research effort has been reported dealing with the problem of secure con-currency control in the context of secure file systems, although this problem has been investigated within the framework of database systems. In <ref> [6] </ref>, Keefe, Tsai and Srivastava present a formal framework for secure concurrency control in multilevel databases. Lam-port [7], Reed and Kanodia [8] and Schaefer [9] offer solutions to the secure readers/writers problem.
Reference: [7] <author> L. Lamport, </author> <title> "Concurrent Reading and Writing," </title> <journal> Communications of the ACM, </journal> <volume> vol. 20, no. 11, </volume> <pages> pp. 806-811, </pages> <month> Nov. </month> <year> 1977. </year>
Reference-contexts: In [6], Keefe, Tsai and Srivastava present a formal framework for secure concurrency control in multilevel databases. Lam-port <ref> [7] </ref>, Reed and Kanodia [8] and Schaefer [9] offer solutions to the secure readers/writers problem. While these solutions are secure, they do not yield serializable schedules when applied to transactions (since transactions contain read and write sets that are often related).
Reference: [8] <author> D. P. Reed and R. K. Kanodia, </author> <title> "Synchronization with eventcounts and sequencers," </title> <journal> Communications of ACM, </journal> <volume> vol. 22, no. 2, </volume> <pages> pp. 115-123, </pages> <month> Feb. </month> <year> 1979. </year>
Reference-contexts: In [6], Keefe, Tsai and Srivastava present a formal framework for secure concurrency control in multilevel databases. Lam-port [7], Reed and Kanodia <ref> [8] </ref> and Schaefer [9] offer solutions to the secure readers/writers problem. While these solutions are secure, they do not yield serializable schedules when applied to transactions (since transactions contain read and write sets that are often related).
Reference: [9] <author> M. Schaefer, </author> <title> "Quasi-Synchronization of Readers and Writers in a Secure Multi-Level Environment," </title> <type> Tech. Rep. </type> <institution> TM-5407/003, Syst. Develop. Corp., </institution> <month> September </month> <year> 1974. </year> <month> 32 </month>
Reference-contexts: In [6], Keefe, Tsai and Srivastava present a formal framework for secure concurrency control in multilevel databases. Lam-port [7], Reed and Kanodia [8] and Schaefer <ref> [9] </ref> offer solutions to the secure readers/writers problem. While these solutions are secure, they do not yield serializable schedules when applied to transactions (since transactions contain read and write sets that are often related).
Reference: [10] <author> P. Ammann and S. Jajodia, </author> <title> "A Timestamp Ordering Algorithm for Secure, Single--Version, Multi-Level Databases," Database Security, V: Status and Prospects, </title> <editor> Carl E. Landwehr, ed., </editor> <publisher> North-Holland, Amsterdam, </publisher> <pages> pp. 23-25, </pages> <year> 1992. </year>
Reference-contexts: Moreover, they suffer from the problem of starvation, i.e., transactions that are reading lower level data items may be subject to indefinite delays. Ammann and Jajodia <ref> [10] </ref> give two timestamp based algorithms that yield serializable schedules; however, both suffer from starvation. Recently, secure versions of commercial DBMSs are providing concurrency control that is free of timing covert channel; however, the solutions adopted in these systems are not completely satisfactory.
Reference: [11] <institution> Oracle Corp., </institution> <address> Redwood City, CA, </address> <note> Trusted Oracle Administrator's Guide, </note> <year> 1992. </year>
Reference-contexts: For example, the concurrency control algorithm of Trusted Oracle 1 Throughout this paper, we use the terms high and low to refer to two security levels such that the former is strictly higher than the latter in the partial order. 2 DBMS <ref> [11] </ref> is based on a combination of 2PL, multiversioning and timestamp ordering. As shown in [12], the histories generated by this concurrency control algorithm are not always one-copy serializable.
Reference: [12] <author> S. Jajodia and V. Atluri, </author> <title> "Alternative Correctness Criteria for Concurrent Execution of Transactions in Multilevel Secure Database Systems," </title> <booktitle> in Proceedings of the IEEE Symposium on Security and Privacy, </booktitle> <address> Oakland, California, </address> <month> May </month> <year> 1992, </year> <pages> pp. 216-224. </pages>
Reference-contexts: As shown in <ref> [12] </ref>, the histories generated by this concurrency control algorithm are not always one-copy serializable.
Reference: [13] <institution> Informix Software, Inc., </institution> <address> Menlo Park, CA, </address> <note> Informix-OnLine/Secure Administrator's Guide, </note> <month> April </month> <year> 1993. </year>
Reference-contexts: As shown in [12], the histories generated by this concurrency control algorithm are not always one-copy serializable. As an additional example, Informix-OnLine/Secure DBMS <ref> [13, 14] </ref> uses an approach in which a low level transaction can acquire a write lock on a low data item, even if a high level transaction holds a read lock on this data item. Thus, a low level transaction is never delayed by a high level transaction. <p> Rather it is to provide a secure concurrency control protocol that is based on locks on single-version data, and to provide flexibility to the system programmer. Indeed, our new system primitives allow the system programmer to emulate other secure concurrency control protocols like that of <ref> [13, 14] </ref>. Nonetheless, it appears that the ideas presented here can be suitably modified to support higher levels of concurrency in the conventional transaction processing framework thus leading to improved performance.
Reference: [14] <institution> Informix Software, Inc., </institution> <address> Menlo Park, CA, </address> <note> Informix-OnLine/Secure Security Features User's Guide, </note> <month> April </month> <year> 1993. </year>
Reference-contexts: As shown in [12], the histories generated by this concurrency control algorithm are not always one-copy serializable. As an additional example, Informix-OnLine/Secure DBMS <ref> [13, 14] </ref> uses an approach in which a low level transaction can acquire a write lock on a low data item, even if a high level transaction holds a read lock on this data item. Thus, a low level transaction is never delayed by a high level transaction. <p> Rather it is to provide a secure concurrency control protocol that is based on locks on single-version data, and to provide flexibility to the system programmer. Indeed, our new system primitives allow the system programmer to emulate other secure concurrency control protocols like that of <ref> [13, 14] </ref>. Nonetheless, it appears that the ideas presented here can be suitably modified to support higher levels of concurrency in the conventional transaction processing framework thus leading to improved performance.
Reference: [15] <author> F. Cristian, </author> <title> "Exception Handling and Software Fault Tolerance," </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-31, no. 6, </volume> <pages> pp. 531-540, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: The use of delayed signals not only allows the notions of exception handling and forward recovery, as defined in <ref> [15] </ref>, but also increases concurrency among transactions while preserving serializability, as will be shown subsequently. The rest of the paper is organized as follows. Section 2 summarizes the security model on which our work is based. Section 3 provides an overview of the approach.
Reference: [16] <author> J. Gray and A. Reuter, </author> <title> Transaction Processing: Concepts and Techniques, </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: However, as the whole body of a standard Lock Manager, written with all the requisite defensive programming, exception handlers, optimizations, deadlock detectors, etc. comes to about a thousand lines of actual code <ref> [16] </ref>, it is easily verifiable. Thus the assumption of a Trusted Lock Manager, which jeopardizes neither security nor integrity, is justified. Note also that although we use the term Trusted File Manager, this component need not be fully trusted. <p> Such constructs can be convenient in practical system programming, since in many applications it is useful to have a compromise between correctness and performance <ref> [16] </ref>. However, in order to ensure serializability the strong definition of well-formedness is required as in Definition 5.8. The simplest way to make the transaction in Figure 10 well-formed, is to replace all the GetSignals by the default invocation of GetSignal, viz. GetSignal [! RollBack] thus satisfying condition 4 above. <p> Moreover, the costs associated with maintaining one extra granule in the lock instance graph is high <ref> [16] </ref>. Thus, it is better to have single level file stores for each security level, for implementing a secure hierarchical locking protocol.
Reference: [17] <author> M. A. Shcaffer and G. Walsh, "LOCK/ix: </author> <title> On Implementing Unix on the LOCK TCB," </title> <booktitle> in Proceedings of the 11th National Computer Security Conference, </booktitle> <month> October </month> <year> 1988, </year> <pages> pp. 17-20. </pages>
Reference-contexts: Thus the assumption of a Trusted Lock Manager, which jeopardizes neither security nor integrity, is justified. Note also that although we use the term Trusted File Manager, this component need not be fully trusted. We refer the interested reader to <ref> [17, 18, 19] </ref> for implementation of File Managers that require a small Trusted Computing Base as their only trusted component. The function of the Trusted Lock Manager is to provide the basic operations of locking and unlocking data items. <p> The description of such a Trusted File Manager is beyond the scope of this paper. We refer to <ref> [17, 18, 19] </ref> for description of multilevel file systems that provide file services to transactions at a particular level in a manner transparent to all lower level transactions.
Reference: [18] <author> C. E. Irvine, T. B. Acheson, and M. F. Thompson, </author> <title> "Building Trust Into a Multilevel File System.," </title> <booktitle> in Proceedings of the 13th National Computer Security Conference, </booktitle> <address> Washington D.C., </address> <year> 1990. </year>
Reference-contexts: Thus the assumption of a Trusted Lock Manager, which jeopardizes neither security nor integrity, is justified. Note also that although we use the term Trusted File Manager, this component need not be fully trusted. We refer the interested reader to <ref> [17, 18, 19] </ref> for implementation of File Managers that require a small Trusted Computing Base as their only trusted component. The function of the Trusted Lock Manager is to provide the basic operations of locking and unlocking data items. <p> The description of such a Trusted File Manager is beyond the scope of this paper. We refer to <ref> [17, 18, 19] </ref> for description of multilevel file systems that provide file services to transactions at a particular level in a manner transparent to all lower level transactions.
Reference: [19] <author> C. E. </author> <title> Irvine, "A Multilevel File System for High Assurance," </title> <booktitle> in Proceedings of the IEEE Symposium on Security and Privacy, </booktitle> <address> Oakland, CA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Thus the assumption of a Trusted Lock Manager, which jeopardizes neither security nor integrity, is justified. Note also that although we use the term Trusted File Manager, this component need not be fully trusted. We refer the interested reader to <ref> [17, 18, 19] </ref> for implementation of File Managers that require a small Trusted Computing Base as their only trusted component. The function of the Trusted Lock Manager is to provide the basic operations of locking and unlocking data items. <p> The description of such a Trusted File Manager is beyond the scope of this paper. We refer to <ref> [17, 18, 19] </ref> for description of multilevel file systems that provide file services to transactions at a particular level in a manner transparent to all lower level transactions.
Reference: [20] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman, </author> <title> Concurrency Control and Recovery in Database Systems, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1987. </year> <month> 33 </month>
Reference-contexts: 1 (sl) undo (gs 1 (sl)) undo (w 1 [z]) undo (r 1 [x]) r 1 [x] w 1 [s] r 1 [u] rs 1 r 1 [p] gs 1 (nil) c 1 2 The interleaving of a set of transactions, when they execute concurrently, is modeled by a history <ref> [20] </ref>. Definition 5.2 Two operations p and q are said to conflict, if they both operate on the same data item and at least one of them is a write operation.
References-found: 20

