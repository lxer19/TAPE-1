URL: http://www.cs.rice.edu:80/~hristo/maxplanar.ps.Z
Refering-URL: http://www.cs.rice.edu:80/~hristo/publications.html
Root-URL: 
Email: email: hristo@cs.rice.edu  
Title: A LINEAR ALGORITHM FOR FINDING A MAXIMAL PLANAR SUBGRAPH  
Author: HRISTO N. DJIDJEV 
Address: P.O. Box 1892, Houston, TX 77251, USA  
Affiliation: Department of Computer Science, Rice University  
Abstract: We construct an optimal linear time algorithm for the maximal planar subgraph problem: given a graph G, find a planar subgraph G 0 of G such that adding to G 0 any edge of G not present in G 0 leads to a non-planar graph. Our solution is based on a dynamic graph search procedure and a fast data structure for on-line planarity testing of triconnected graphs. Our algorithm can be transformed into a new optimal planarity testing algorithm. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, J. E. Hopcroft, J.D. Ullman, </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1974. </year>
Reference-contexts: When we split a path the labels of the labeled mezzosets in the smaller half are updated. For an initial set of k mezzosets this algorithm requires totally O (k log k) time for all splits and O (1) time for any query <ref> [1] </ref>. Since k = O (n= log n), this yields an O (n) bound on the time for operations on the level of labeled mezzosets. A similar method and the same bound apply for maintaining the labels of the labeled microsets.
Reference: [2] <author> K. Booth, G. Lueker, </author> <title> Testing for the consecutive ones property, interval graphs, and graph planarity using PQ-tree algorithm, </title> <journal> J. Comp. Syst. Sci. </journal> <volume> 13, </volume> <year> 1976, </year> <pages> pp. 335-379. </pages>
Reference-contexts: Many problems that are computationally hard for arbitrary graphs have efficient solutions for the case of planar graphs. Testing an n-vertex m-edge graph for planarity takes O (n + m) time <ref> [14, 2] </ref>. If the graph is not planar, then often a problem arises of how to find a planar subgraph that is as close to the given graph, as possible. A problem of this type is called a graph planarization problem. <p> Their result improved (if m = o (n 2 = log n)) the best previous O (n 2 ) algorithm from [16] (based on the PQ-tree technique <ref> [2] </ref>). An algorithm with the same complexity bound of O (m log n) can also be derived from the incremental planarity testing algorithm of Di Battista and Tamassia [5]. <p> Our algorithm for the maximal planar subgraph problem can be transformed into a linear algorithm for planarity testing based on an approach entirely different from the existing ones. The previous algorithms of Hopcroft and Tarjan [14] and Booth and Lueker <ref> [2] </ref> are based on the Jordan Curve Theorem while our algorithm is based on the uniqueness of the planar embedding of any triconnected planar graph. This paper is organized as follows. <p> Then G is planar iff G = G 0 . This result is interesting because the new algorithm is based on an approach entirely different from the existing ones. The linear algorithms of Hopcroft and Tarjan [14] and Booth and Lueker <ref> [2] </ref> (and their modifications) essentially use the Jordan Curve Theorem which states that any closed curve in the plane divides it into exactly two connected regions. In contrast, our algorithm is based on the uniqueness of the planar embedding of any triconnected planar graph. <p> In contrast, our algorithm is based on the uniqueness of the planar embedding of any triconnected planar graph. It will be of theoretical and practical interest to refine our technique in order to construct a new practical algorithm for planarity testing whose performance is comparable to the algorithms of <ref> [14, 2] </ref>.
Reference: [3] <author> J. Cai, X. Han, and R.E. Tarjan, </author> <title> An O(m log n)-time algorithm for the maximal planar subgraph, </title> <journal> SIAM Journal on Computing, </journal> <volume> 22 (1993), </volume> <pages> 1142-1162, </pages> . 
Reference-contexts: Such graph G 0 is called a maximal planar subgraph of G. This problem has been intensively investigated in relation to its applications to circuit layout [20, 17, 4, 19, 16]. More recently, Cai, Han, and Tarjan <ref> [3] </ref> developed an O (m log n) algorithm for the maximal planar subgraph problem based on the Hopcroft-Tarjan planarity testing algorithm. Their result improved (if m = o (n 2 = log n)) the best previous O (n 2 ) algorithm from [16] (based on the PQ-tree technique [2]).
Reference: [4] <author> T. Chiba, I. Nishioka, and I. Shirakawa, </author> <title> An algorithm of maximal planarization of graphs, </title> <booktitle> Proc. IEEE Int. Symp. on Circuits and Systems, </booktitle> <year> 1978, </year> <pages> 649-652. </pages>
Reference-contexts: Such graph G 0 is called a maximal planar subgraph of G. This problem has been intensively investigated in relation to its applications to circuit layout <ref> [20, 17, 4, 19, 16] </ref>. More recently, Cai, Han, and Tarjan [3] developed an O (m log n) algorithm for the maximal planar subgraph problem based on the Hopcroft-Tarjan planarity testing algorithm.
Reference: [5] <author> G. Di Battista, R. Tamassia, </author> <title> Incremental planarity testing, </title> <booktitle> Proc. IEEE Symp. on Found. of Comp. Sci., </booktitle> <year> (1989), </year> <pages> 436-441. </pages>
Reference-contexts: An algorithm with the same complexity bound of O (m log n) can also be derived from the incremental planarity testing algorithm of Di Battista and Tamassia <ref> [5] </ref>. Using an approach similar to [5], Westbrook [23] described an algorithm that works in O (n log n + mff (m; n)) worst-case time plus an additional O (n) expected time. <p> An algorithm with the same complexity bound of O (m log n) can also be derived from the incremental planarity testing algorithm of Di Battista and Tamassia <ref> [5] </ref>. Using an approach similar to [5], Westbrook [23] described an algorithm that works in O (n log n + mff (m; n)) worst-case time plus an additional O (n) expected time. <p> Our algorithm uses a tree-represented decomposition of a biconnected graph into triconnected components, a common feature of the incremental planarity testing algorithms <ref> [5, 6, 23, 21] </ref>. We use a variation of the decomposition tree of Di Battista and Tamassia, however any of the alternative representations could be used instead. <p> Preliminaries. In this section we give some basic definitions related to graph connectivity and graph orientation and describe briefly the data structure for maintaining the biconnected and triconnected components of a graph developed by Di Battista and Tamassia <ref> [5, 6] </ref>. 2.1. Definitions. We use standard graph terminology [12]. An undirected graph G is connected, if any two vertices of G are connected by a path. The maximal connected subgraphs of G are the connected components of G. <p> Decompositions of biconnected graphs. First we consider the case where G is biconnected. Let n be the number of vertices and m be the number of edges of G. We recall the definition of SPQR trees from <ref> [5] </ref>. An SPQR tree for G is a recursively defined tree T closely related to the decomposition of G with respect to its split pairs. T has four types of nodes S, P, Q, and R and there is an st-graph, skeleton (), associated with each node of T . <p> The endpoints of each edge e in the skeleton of the root of T correspond to a maximal split pair of G and e represents the set of split components of that split pair (see Figure 1). Formally, SPQR trees are defined as follows <ref> [5, 6] </ref>. Let G be an st-graph with source s and sink t. An SPQR tree T for G has four types of nodes S, P, Q, and R and there is an st-graph, skeleton (), associated with each node of T . <p> that the skeleton of any internal node of a SPQR tree has either a unique planar embedding (if is an R node), or any two edges can be placed on the same face (if is a P, Q, or S node.) For a more detailed discussion of SPQR trees see <ref> [5, 6] </ref>. Our next goal is to show how to reduce a planarity testing in a graph to planarity testing in skeletons of nodes of its SPQR tree. 2.2.1. Planarity testing using SPQR trees. <p> A peripheral node is a node whose virtual edge is peripheral. The following lemma relates incremental planarity testing in an arbitrary graph to incremental planarity testing in its tricomponents (assuming proper (v 1 ) is an ancestor of proper (v 2 )). Lemma 2.2. <ref> [5] </ref> There exists a planar embedding of G such that v 1 and v 2 belong to the same face if and only if (i) pr (v 1 ) and pr (v 2 ) are on the same face of some planar embedding of skeleton ((v 1 ; v 2 )), <p> To solve the TMPS problem we need a fast procedure that tests if any arbitrary pair of vertices belong to any face of the embedding. We will use the following method of representing planar embeddings from <ref> [5] </ref>. 3.1. Representation of planar st-graphs. Let G be a planar st-graph. For any vertex x, the incoming edges in x appear consecutively around x and the edges 6 Fig. 3. <p> Updating the data structures. Our update algorithms are simpler and more efficient than the algorithms of <ref> [5, 23, 21] </ref> because of our use of U paths. 4.2.1. The update paths.
Reference: [6] <author> G. Di Battista, R. Tamassia, </author> <title> On-line graph algorithms with SPQR trees, </title> <booktitle> Proc. Intern. Colloquium on Automata, Languages and Programming (1990), </booktitle> <pages> 598-611. </pages>
Reference-contexts: Our algorithm uses a tree-represented decomposition of a biconnected graph into triconnected components, a common feature of the incremental planarity testing algorithms <ref> [5, 6, 23, 21] </ref>. We use a variation of the decomposition tree of Di Battista and Tamassia, however any of the alternative representations could be used instead. <p> Preliminaries. In this section we give some basic definitions related to graph connectivity and graph orientation and describe briefly the data structure for maintaining the biconnected and triconnected components of a graph developed by Di Battista and Tamassia <ref> [5, 6] </ref>. 2.1. Definitions. We use standard graph terminology [12]. An undirected graph G is connected, if any two vertices of G are connected by a path. The maximal connected subgraphs of G are the connected components of G. <p> The endpoints of each edge e in the skeleton of the root of T correspond to a maximal split pair of G and e represents the set of split components of that split pair (see Figure 1). Formally, SPQR trees are defined as follows <ref> [5, 6] </ref>. Let G be an st-graph with source s and sink t. An SPQR tree T for G has four types of nodes S, P, Q, and R and there is an st-graph, skeleton (), associated with each node of T . <p> that the skeleton of any internal node of a SPQR tree has either a unique planar embedding (if is an R node), or any two edges can be placed on the same face (if is a P, Q, or S node.) For a more detailed discussion of SPQR trees see <ref> [5, 6] </ref>. Our next goal is to show how to reduce a planarity testing in a graph to planarity testing in skeletons of nodes of its SPQR tree. 2.2.1. Planarity testing using SPQR trees. <p> In the next sections we will describe data structures for answering queries of types (i), (ii), and (iii) from Lemma 2.2 in a constant time. 2.3. Decompositions of connected graphs. In order to handle connected graphs that are not necessarily biconnected we define the BC trees introduced in <ref> [6] </ref> which are extensions of the SPQR trees. To construct a BC tree of a connected graph G first find all bicomponents of G. <p> one of b 1 and b k+1 is an ancestor to the other and the edge (c i1 ; c i ) can be added to b i while preserving planarity then we call b i a peripheral level-1 node (with respect to path p.) We have the following lemma <ref> [6] </ref>. Lemma 2.3.
Reference: [7] <author> H. N. Djidjev, </author> <title> On some properties of nonplanar graphs, Compt. </title> <journal> rend. Acad. bulg. Sci., </journal> <volume> vol. 37 (1984), 9, </volume> <pages> 1183-1185. </pages>
Reference-contexts: A problem of this type is called a graph planarization problem. For any n vertex graph G of genus g there exists a vertex set of size O ( p ng) whose removal leads to a planar graph <ref> [7] </ref>. However, the linear implementation of the algorithm that finds such planarizing set requires a genus-g embedding of G as input; the best algorithm that finds such embedding [8] is polynomial in n, but doubly exponential in g.
Reference: [8] <author> H.N. Djidjev, J. Reif, </author> <title> An efficient algorithm for the genus problem with explicit construction of forbidden subgraphs, </title> <booktitle> Proc. Annual ACM Symposium on Theory of Computing (1991), </booktitle> <address> pp.337-347. </address>
Reference-contexts: However, the linear implementation of the algorithm that finds such planarizing set requires a genus-g embedding of G as input; the best algorithm that finds such embedding <ref> [8] </ref> is polynomial in n, but doubly exponential in g. Another version of the graph planarization problem, the problem of finding the smallest number of edges whose removal leaves a planar graph, is known to be NP-complete [11].
Reference: [9] <author> S. Even and R.E. Tarjan, </author> <title> Computing an st-numbering, </title> <booktitle> Theoretical Computer Science 2 (1976), </booktitle> <pages> 339-344. </pages>
Reference-contexts: For the precise definition and a linear time algorithm that finds the tricomponents of a graph see [13]. An st-graph is a directed acyclic graph with exactly one source and exactly one sink. Any biconnected graph can be converted into an st-graph using the linear time st-numbering algorithm of <ref> [9] </ref>. A planar st-graph is an st-graph that is embedded in the plane such that the source and the sink belong to the external face of the embedding. Let G be an st-graph.
Reference: [10] <author> H. Gabow and R.E. Tarjan, </author> <title> A linear-time algorithm for a special case of disjoint set union, </title> <institution> J. Compu. Syst. Sci., </institution> <month> 30 </month> <year> (1985), </year> <pages> 209-220. </pages>
Reference-contexts: Next we show how to solve this problem making use of the microset technique of Gabow and Tarjan <ref> [10] </ref>. 8 3.2. A find-split-insert data structure. 3.2.1. Formulation of the problem. <p> Each operation will take O (1) amortized time on a random access machine with unit cost measure and O (log n) bits machine word. The technique we use is similar to the one developed by Gabow and Tarjan <ref> [10] </ref> for a variation of the set union problem. The same technique was used also by Imai and Asano [15] for the problem of maintaining a partition of a sorted sequence of integers under a sequence of split, find, and insert operations. 3.2.2. The data structure. <p> Finally, if 2 is labeled, we 9 apply the algorithm for labeled mezzosets on 2 . We will next describe the algorithms applied in the two cases. On levels of labeled mezzosets we use the "relabel the smaller half" technique <ref> [10] </ref>. By this technique we store with each mezzoset its label and maintain the sequence of labeled mezzosets in any path as a doubly linked list. When we split a path the labels of the labeled mezzosets in the smaller half are updated. <p> Furthermore, we dynamically maintain for each level-2 node belonging to a path in U paths a set of all vertices x of G such that proper (x) = . This can be done by using the linear incremental set union algorithm of Gabow and Tarjan <ref> [10] </ref>. Hence one can find the proper allocation node of any vertex of G in O (1) amortized time, provided that belongs to a path of U paths.
Reference: [11] <author> M.R. Garey and D.S. Johnson, </author> <title> Algorithms and Intractability: A Guide to the Theory of NP Completeness. </title> <address> San Francisco, </address> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference-contexts: Another version of the graph planarization problem, the problem of finding the smallest number of edges whose removal leaves a planar graph, is known to be NP-complete <ref> [11] </ref>.
Reference: [12] <author> F. Harary. </author> <title> Graph Theory, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1969. </year>
Reference-contexts: Preliminaries. In this section we give some basic definitions related to graph connectivity and graph orientation and describe briefly the data structure for maintaining the biconnected and triconnected components of a graph developed by Di Battista and Tamassia [5, 6]. 2.1. Definitions. We use standard graph terminology <ref> [12] </ref>. An undirected graph G is connected, if any two vertices of G are connected by a path. The maximal connected subgraphs of G are the connected components of G. A vertex v is a cutvertex if the removal of v increases the number of components.
Reference: [13] <author> J. Hopcroft and R.E. Tarjan, </author> <title> Dividing a graph into triconnected components, </title> <journal> SIAM J. Comput. </journal> <volume> 2, </volume> <year> 1973, </year> <pages> pp. 135-158. </pages>
Reference-contexts: Each of v and w is included in both G 1 and G 2 . For the precise definition and a linear time algorithm that finds the tricomponents of a graph see <ref> [13] </ref>. An st-graph is a directed acyclic graph with exactly one source and exactly one sink. Any biconnected graph can be converted into an st-graph using the linear time st-numbering algorithm of [9].
Reference: [14] <author> J. Hopcroft and R.E. Tarjan, </author> <title> Efficient planarity testing, </title> <journal> J.ACM, </journal> <volume> 21:4, </volume> <year> 1974, </year> <pages> pp. 549-568. </pages>
Reference-contexts: Many problems that are computationally hard for arbitrary graphs have efficient solutions for the case of planar graphs. Testing an n-vertex m-edge graph for planarity takes O (n + m) time <ref> [14, 2] </ref>. If the graph is not planar, then often a problem arises of how to find a planar subgraph that is as close to the given graph, as possible. A problem of this type is called a graph planarization problem. <p> Our algorithm for the maximal planar subgraph problem can be transformed into a linear algorithm for planarity testing based on an approach entirely different from the existing ones. The previous algorithms of Hopcroft and Tarjan <ref> [14] </ref> and Booth and Lueker [2] are based on the Jordan Curve Theorem while our algorithm is based on the uniqueness of the planar embedding of any triconnected planar graph. This paper is organized as follows. <p> Then G is planar iff G = G 0 . This result is interesting because the new algorithm is based on an approach entirely different from the existing ones. The linear algorithms of Hopcroft and Tarjan <ref> [14] </ref> and Booth and Lueker [2] (and their modifications) essentially use the Jordan Curve Theorem which states that any closed curve in the plane divides it into exactly two connected regions. In contrast, our algorithm is based on the uniqueness of the planar embedding of any triconnected planar graph. <p> In contrast, our algorithm is based on the uniqueness of the planar embedding of any triconnected planar graph. It will be of theoretical and practical interest to refine our technique in order to construct a new practical algorithm for planarity testing whose performance is comparable to the algorithms of <ref> [14, 2] </ref>.
Reference: [15] <author> H. Imai and T. Asano, </author> <title> Dynamic orthogonal segment intersection search, </title> <note> in Journal of Algorithms 8, </note> <year> 1987, </year> <pages> pp. 1-18. </pages>
Reference-contexts: The technique we use is similar to the one developed by Gabow and Tarjan [10] for a variation of the set union problem. The same technique was used also by Imai and Asano <ref> [15] </ref> for the problem of maintaining a partition of a sorted sequence of integers under a sequence of split, find, and insert operations. 3.2.2. The data structure. The edges currently in paths of P are partitioned into subsets of edges occupying consecutive memory locations called mezzosets.
Reference: [16] <author> R. Jayakumar, K. Thulasiraman, and M.N.S. Swamy, </author> <title> O(n 2 ) algorithms for graph pla-narization, </title> <journal> IEEE Trans. on Comp.-Aided Design 8 (1989), </journal> <pages> 257-267. </pages>
Reference-contexts: Such graph G 0 is called a maximal planar subgraph of G. This problem has been intensively investigated in relation to its applications to circuit layout <ref> [20, 17, 4, 19, 16] </ref>. More recently, Cai, Han, and Tarjan [3] developed an O (m log n) algorithm for the maximal planar subgraph problem based on the Hopcroft-Tarjan planarity testing algorithm. <p> More recently, Cai, Han, and Tarjan [3] developed an O (m log n) algorithm for the maximal planar subgraph problem based on the Hopcroft-Tarjan planarity testing algorithm. Their result improved (if m = o (n 2 = log n)) the best previous O (n 2 ) algorithm from <ref> [16] </ref> (based on the PQ-tree technique [2]). An algorithm with the same complexity bound of O (m log n) can also be derived from the incremental planarity testing algorithm of Di Battista and Tamassia [5].
Reference: [17] <author> M. Marek-Sadowska, </author> <title> Planarization algorithm for integrated circuits engineering, </title> <booktitle> Proc. IEEE Int. Symp. on Circuits and Systems, </booktitle> <year> 1979, </year> <pages> 919-923. </pages>
Reference-contexts: Such graph G 0 is called a maximal planar subgraph of G. This problem has been intensively investigated in relation to its applications to circuit layout <ref> [20, 17, 4, 19, 16] </ref>. More recently, Cai, Han, and Tarjan [3] developed an O (m log n) algorithm for the maximal planar subgraph problem based on the Hopcroft-Tarjan planarity testing algorithm.
Reference: [18] <author> T. Nishizeki, N. Chiba, </author> <title> Planar Graphs: Theory and Algorithms, </title> <publisher> North Holland, </publisher> <year> 1988. </year>
Reference-contexts: Planar graphs arise naturally in many applications of graph theory, e.g., in circuit and VLSI design, network design and analysis, computational geometry, and are one of the most intensively studied classes of graphs <ref> [18] </ref>. Many problems that are computationally hard for arbitrary graphs have efficient solutions for the case of planar graphs. Testing an n-vertex m-edge graph for planarity takes O (n + m) time [14, 2]. <p> A subdivision of a graph H is a graph H 0 that can be obtained by H by replacing some of the edges of H by paths having at most their endpoints in common. Lemma 2.1. <ref> [18] </ref> A planar graph G has a unique embedding in the plane if and only if G is a subdivision of a triconnected graph.
Reference: [19] <author> T. Ozawa and H. Takahashi, </author> <title> A graph-planarization algorithm and its applications to random graphs, in Graph Theory and Algorithms, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 108, </volume> <pages> 95-107, </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Such graph G 0 is called a maximal planar subgraph of G. This problem has been intensively investigated in relation to its applications to circuit layout <ref> [20, 17, 4, 19, 16] </ref>. More recently, Cai, Han, and Tarjan [3] developed an O (m log n) algorithm for the maximal planar subgraph problem based on the Hopcroft-Tarjan planarity testing algorithm.
Reference: [20] <author> K. Pasedach, </author> <title> Criterion and algorithms for determination of bipartite graphs and their application to planarization of graphs, </title> <booktitle> in Graphen-Sprachen und Algorithmen in Graphen, </booktitle> <pages> 175-183, </pages> <publisher> Carl Hanser Verlag, </publisher> <address> Germany, </address> <year> 1976. </year>
Reference-contexts: Such graph G 0 is called a maximal planar subgraph of G. This problem has been intensively investigated in relation to its applications to circuit layout <ref> [20, 17, 4, 19, 16] </ref>. More recently, Cai, Han, and Tarjan [3] developed an O (m log n) algorithm for the maximal planar subgraph problem based on the Hopcroft-Tarjan planarity testing algorithm.
Reference: [21] <author> J.A. La Poutre, </author> <title> Alpha-algorithms for incremental planarity testing, </title> <booktitle> Proc. of the Ann. ACM Symp. on Theory of Comput., </booktitle> <year> 1994, </year> <pages> 706-715. </pages>
Reference-contexts: Using an approach similar to [5], Westbrook [23] described an algorithm that works in O (n log n + mff (m; n)) worst-case time plus an additional O (n) expected time. La Poutre <ref> [21] </ref> recently gave an incremental planarity testing algorithm that takes O (ff (m; n)) amortized time per operation, which can be transformed into an O (n + mff (m; n)) time algorithm for the maximal planar subgraph problem. fl A preliminary version of this paper will be presented at WADS '95. <p> Our algorithm uses a tree-represented decomposition of a biconnected graph into triconnected components, a common feature of the incremental planarity testing algorithms <ref> [5, 6, 23, 21] </ref>. We use a variation of the decomposition tree of Di Battista and Tamassia, however any of the alternative representations could be used instead. <p> lower bound on the amortized time per operation of any algorithm that maintains a decomposition of the triconnected components of a graph subject to arbitrary edge insertions, which gave rise to the conjecture that O (ff (m; n)) is the best possible time bound for the incremental planarity testing problem <ref> [21] </ref>. Another technique we use is maintaining in each bicomponent a special dynamic path of nodes of the decomposition tree such that all testing and updating operations are performed on nodes of that path. <p> Updating the data structures. Our update algorithms are simpler and more efficient than the algorithms of <ref> [5, 23, 21] </ref> because of our use of U paths. 4.2.1. The update paths.
Reference: [22] <author> R.E. Tarjan, </author> <title> Efficiency of a good but not linear set union algorithm, </title> <journal> J. ACM, </journal> <volume> 22 (1975), </volume> <pages> 215-225. </pages>
Reference: [23] <author> J. Westbrook, </author> <title> Fast incremental planarity testing, </title> <booktitle> Proc. Int. Col. on Automata, Languages, and Programming, </booktitle> <year> 1992, </year> <pages> 342-353. 18 </pages>
Reference-contexts: An algorithm with the same complexity bound of O (m log n) can also be derived from the incremental planarity testing algorithm of Di Battista and Tamassia [5]. Using an approach similar to [5], Westbrook <ref> [23] </ref> described an algorithm that works in O (n log n + mff (m; n)) worst-case time plus an additional O (n) expected time. <p> Our algorithm uses a tree-represented decomposition of a biconnected graph into triconnected components, a common feature of the incremental planarity testing algorithms <ref> [5, 6, 23, 21] </ref>. We use a variation of the decomposition tree of Di Battista and Tamassia, however any of the alternative representations could be used instead. <p> Note that our ability to make a choice of the order in which to insert, while possible, the edges into the subgraph so that planarity is preserved is essential for achieving O (1) amortized time per test and insert operation. As noted by Westbrook <ref> [23] </ref>, there is an (ff (m; n)) lower bound on the amortized time per operation of any algorithm that maintains a decomposition of the triconnected components of a graph subject to arbitrary edge insertions, which gave rise to the conjecture that O (ff (m; n)) is the best possible time bound <p> Updating the data structures. Our update algorithms are simpler and more efficient than the algorithms of <ref> [5, 23, 21] </ref> because of our use of U paths. 4.2.1. The update paths.
References-found: 23

