URL: http://www.win.tue.nl/~hooman/RPC.ps
Refering-URL: http://www.win.tue.nl/~hooman/RPC.html
Root-URL: http://www.win.tue.nl
Email: e-mail: wsinjh@win.tue.nl  
Title: Using PVS for an Assertional Verification of the RPC-Memory Specification Problem  
Author: Jozef Hooman 
Address: P.O. Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Dept. of Computing Science Eindhoven University of Technology  
Abstract: The RPC-Memory Specification Problem has been specified and verified in an assertional method, supported by the verification system PVS. Properties of the components are expressed in the higher-order logic of PVS and all implementations have been verified by means of the interactive proof checker of PVS. A simplification of the memory specification allowing multiple atomic reads has been proved correct. Additionally, to increase the confidence in the specification, an implementation-oriented specification of the inner memory is shown to be equivalent to our original property-oriented formulation. 
Abstract-found: 1
Intro-found: 1
Reference: [Hoo91] <author> J. Hooman. </author> <title> Specification and Compositional Verification of Real-Time Systems. </title> <publisher> LNCS 558, Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Concluding remarks can be found in section 5. 0.1 Formal Background Starting point of our approach is a formal method for the specification and verification of distributed real-time systems <ref> [Hoo91] </ref>. The method has been inspired by Hoare triples (precondition, program, postcondition), which have been extended to deal with the timing of events [Hoo94b]. To distinguish the resulting framework from classical Hoare logic, we use "assumption" and "commitment" instead of "precondition" and "postcondition". <p> For simplicity, also the syntactic constraints of the parallel composition rule, which require that the assertions of a component only refer to its static interface, are omitted. We refer to <ref> [Hoo91] </ref> for more details and a soundness proof of the parallel composition rule. Here the proof rules are simply postulated as axioms. Further, it should be mentioned that the assumption-commitment framework has been used here mainly because it was available in PVS from earlier examples [Hoo94a].
Reference: [Hoo94a] <author> J. Hooman. </author> <title> Correctness of real time systems by construction. </title> <booktitle> In Formal Techniques in Real-Time and Fault-Tolerant Systems, </booktitle> <pages> pages 19-40. </pages> <note> LNCS 863, </note> <year> 1994. </year>
Reference-contexts: This rule is taken from previous work, where a framework based on assumption/commitment pairs has been devised for the top-down design of distributed real-time systems. In <ref> [Hoo94a] </ref>, a mixed formalism in which programs and assumption/commitment based specifications are combined, has been defined in the PVS specification language. 1 PVS is free available, see WWW page http://www.csl.sri.com/sri-csl-pvs.html To our experience, the use of the tool PVS significantly increases both the speed with which a complete solution can be <p> Then a compositional rule for parallel composition has been formulated by requiring that the assertions of a component only refer to events of its own static interface. In previous work, our framework for the top-down design of distributed real-time programs has been formulated in PVS <ref> [Hoo94a] </ref>. There the semantics of programs is essentially a relation on states with some additional components to record the timing behavior of systems. Based on this semantics, the soundness of a number of proof rules for programming constructs (e.g., sequential composition, iteration, parallel composition) have been proved. <p> We refer to [Hoo91] for more details and a soundness proof of the parallel composition rule. Here the proof rules are simply postulated as axioms. Further, it should be mentioned that the assumption-commitment framework has been used here mainly because it was available in PVS from earlier examples <ref> [Hoo94a] </ref>. In the RPC-Memory Specification the assumption is not relevant and will be true in all specifications. 0.2 Basic PVS Framework In general, a PVS specification consists of a number of theories. First the basic specification primitives are defined in a theory specs which can be imported by other theories. <p> The symbol "+" indicates that these types are nonempty. specs : THEORY BEGIN Value, Program : TYPE+ Next we define variables of type Program and of the predefined type bool. Specifications consist of a pair of boolean formulas (predicates on states in the full framework of <ref> [Hoo94a] </ref>), called assumption and commitment. To achieve a flexi-ble framework in which programs and specifications can be mixed freely, a specification is also considered as a program. <p> Also implicit in the informal specification are the properties if the inner memory (e.g., the meaning of atomicity). In the RPC-Memory example only a small part of our real-time framework has been used. In <ref> [Hoo94a] </ref> we show how PVS can be used during the design of real-time systems by an example of the top-down derivation of a distributed real-time control system (a chemical batch processing system).
Reference: [Hoo94b] <author> J. Hooman. </author> <title> Extending Hoare logic to real-time. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6(6A):801-825, </volume> <year> 1994. </year>
Reference-contexts: The method has been inspired by Hoare triples (precondition, program, postcondition), which have been extended to deal with the timing of events <ref> [Hoo94b] </ref>. To distinguish the resulting framework from classical Hoare logic, we use "assumption" and "commitment" instead of "precondition" and "postcondition". The assumption-commitment structure of specifications is especially convenient for the formulation of compositional proof rules for sequential constructs.
Reference: [Hoo95] <author> J. Hooman. </author> <title> Verifying part of the ACCESS.bus protocol using PVS. </title> <booktitle> In Proceedings 15th Conference on the Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 96-110. </pages> <publisher> LNCS 1026, Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: In [Hoo94a] we show how PVS can be used during the design of real-time systems by an example of the top-down derivation of a distributed real-time control system (a chemical batch processing system). Another example of the formalization of an informal specification can be found in <ref> [Hoo95] </ref> where part of an ACCESS.bus protocol, connecting a host computer with a dynamically changing number of devices, has been specified and verified. Acknowledgments We are grateful to Job Zwiers for the suggestion to use event attributes, thus simplifying our initial solution.
Reference: [JPZ94] <author> W. Janssen, M. Poel, and J. Zwiers. </author> <title> The compositional approach to sequential consistency and lazy caching. </title> <institution> Memoranda informatica 94-37, University of Twente, </institution> <year> 1994. </year>
Reference-contexts: Events are used to model the occurrence of actions such as a procedure call, a return of a procedure, and an atomic read or write. Causality relations between events are represented by a partial order. Further we use the notation of event attributes from <ref> [JPZ94] </ref> to express, for instance, the arguments and the timing of an action. Moreover, all implementations given in the formulation of the specification problem are verified by means of the PVS proof checker, using a compositional rule for parallel composition. <p> of this relation is made explicit in lemma caustrans. procinterface : THEORY BEGIN IMPORTING specs Event : TYPE+ E, E1, E2, E3, E4, E5 : VAR Event &lt; : (strict_order?[Event]) ; caustrans : LEMMA (EXISTS E2 : E1 &lt; E2 AND E2 &lt; E3) IMPLIES E1 &lt; E3 Similar to <ref> [JPZ94] </ref> we introduce event attributes. For the current specification problem we start with five attributes, event type etype, component number comp, process identity ident, argument argu, and name name.
Reference: [Lam94] <author> L. Lamport. </author> <title> Verification and specification of concurrent programs. </title> <booktitle> In A Decade of Concurrency, </booktitle> <pages> pages 347-374. </pages> <note> LNCS 803, </note> <year> 1994. </year>
Reference-contexts: There is, however, a danger that the specification does not correspond to the informal specification and it is relatively easy to introduce inconsistencies (see also the remarks about axiomatic specifications in <ref> [Lam94] </ref>). In the specification given here we have tried to stay as close as possible to the informal formulation of the specification problem. When needed, the resulting formal specification can be transformed into an equivalent, more convenient, specification.
Reference: [ORS92] <author> S. Owre, J. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <booktitle> In 11th Conference on Automated Deduction, volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 748-752. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: 0 Introduction A solution of the RPC-Memory Specification Problem is presented using an as-sertional method supported by the verification system PVS 1 (Prototype Verification System) <ref> [ORS92] </ref>. The PVS specification language is a higher-order typed logic, with many built-in types including booleans, integers, rationals, sequences, lists, and sets. Specifications can be structured into a hierarchy of parameterized theories.
Reference: [ORSvH95] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <year> 1995. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Another technique in PVS is the use of "putative" theorems, that is, one tries to prove properties that should follow from the specification (see <ref> [ORSvH95] </ref>). Especially the failure of such a proof is helpful because it might reveal errors in the specification or the understanding of the system. As an illustration of this method, in section 2.2 an implementation-oriented specification of the inner memory is proved to be equivalent to our original, property-oriented, formulation.
References-found: 8

