URL: http://www.cis.ohio-state.edu/~neelam/papers/reuse.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~neelam/papers/research.html
Root-URL: 
Email: e-mail: fneelam,fridellag@cis.ohio-state.edu  
Title: Inheritance: From Code Reuse to Reasoning Reuse  
Author: Neelam Soundarajan and Stephen Fridella 
Date: September 30, 1997  
Address: Columbus, OH 43210  
Affiliation: Computer and Information Science The Ohio State University  
Abstract: Much of the power of the Object-Oriented approach to developing large systems derives from the notion of inheritance. Given an existing base class, a designer can use inheritance to build a derived class that extends, or that slightly differs from the base class. But in order to exploit the full potential of inheritance to building systems incrementally, the designer must also be able to reason about the derived class incrementally. This paper presents a specification notation and verification procedure that allows such incremental reasoning to be carried out; the approach makes important use of the concrete specification of a class, in addition to the usual abstract specification. The reasoning reuse that the approach enables is illustrated by applying it to a simple example. Finally, the motivation underlying and the details of the approach are contrasted with those of behavioral subtyping. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. </author> <title> America. Designing an object oriented programming language with behavioral subtyping. </title> <booktitle> In Foundations of Object-Oriented Languages, REX School/Workshop, </booktitle> <volume> LNCS 489, </volume> <pages> pages 69-90. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: that we are not asking the question `Given a base class B and a derived class D, under what conditions can a client program use objects that are instances of D in place of instances of B?' The answer to that question is provided by the work on behavioral subtyping <ref> [1, 6, 7] </ref>. Informally, a class A is a behavioral subtype of another class B if the behavior exhibited by objects that are instances of A is in some sense consistent with behaviors allowed by the class B.
Reference: [2] <author> K.K. Dhara and G.T. Leavens. </author> <title> Forcing behavioral subtyping through specification inheritance. </title>
Reference-contexts: And conversely, if D is a derived class of B there is no guarantee that it will be a behavioral subtype of B. 1 The work on 1 [3] and <ref> [2] </ref> consider restrictions on how inheritance is used to ensure that the derived class is a behavioral subtype of the base class; we will relate our work to theirs later in the paper. behavioral subtyping is motivated by the desire to free the designer of the client code from having to <p> This is a remarkable degree of specification reuse that handily matches the code reuse. One might be tempted to argue that the reason for this is that BetterAccount is a (weak) behavioral subtype <ref> [2] </ref> of BankAccount. 16 But we will shortly mention another equally simple example which is not a behavioral subtype, strong or weak, of BankAccount for which also we will be able to inherit much of the base class specification. Next let us consider the verification task. <p> That only leaves us with the 16 BetterAccount is not a behavioral subtype of BankAccount according to the definition of Liskov and Wing [6, 7], but it is a weak behavioral subtype, as per the definition of Dhara and Leavens <ref> [2] </ref>. 11 task of verifying that RemTransaction preserves the invariant. This is easily done. Suppose I nv holds in a state !. This asserts that the sum of sbal and each of the transaction amounts in the array his is equal to bal. <p> This is perhaps the most important difference between behavioral subtyping <ref> [6, 3, 2] </ref> and our work; whereas the work on behavioral subtyping focuses on the relation between the abstract specifications of classes, our work shows how the derived class designer can use the concrete specification of the base class to build derived classes that are similar to but not (necessarily) behavioral <p> But this line doesn't really represent a reuse of specifications because in general there is no guarantee that (the abstract specification of) D will be a behavioral subtype of (the abstract specification of) B. Edwards [3] and Dhara and Leavens <ref> [2] </ref> consider restrictions on how inheritance is used to ensure that the behavioral subtype relation holds. Our work shows that even if these restrictions are not satisfied, we have considerable specification and verification reuse, represented by the two intermediate 13 horizontal lines. <p> But note that this assurance comes at a price: we must be willing to ignore the differences between these classes. Dhara and Leavens <ref> [2] </ref> call this the `information loss' problem since we are losing information about this difference. This might be acceptable if, for instance, the difference between the two classes was essentially with respect to performance.
Reference: [3] <author> S. Edwards. </author> <title> Representation inheritance: A safe form of `white box' code inheritance. </title> <booktitle> In Software Reuse, </booktitle> <pages> pages 27-51. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: And conversely, if D is a derived class of B there is no guarantee that it will be a behavioral subtype of B. 1 The work on 1 <ref> [3] </ref> and [2] consider restrictions on how inheritance is used to ensure that the derived class is a behavioral subtype of the base class; we will relate our work to theirs later in the paper. behavioral subtyping is motivated by the desire to free the designer of the client code from <p> This is perhaps the most important difference between behavioral subtyping <ref> [6, 3, 2] </ref> and our work; whereas the work on behavioral subtyping focuses on the relation between the abstract specifications of classes, our work shows how the derived class designer can use the concrete specification of the base class to build derived classes that are similar to but not (necessarily) behavioral <p> But this line doesn't really represent a reuse of specifications because in general there is no guarantee that (the abstract specification of) D will be a behavioral subtype of (the abstract specification of) B. Edwards <ref> [3] </ref> and Dhara and Leavens [2] consider restrictions on how inheritance is used to ensure that the behavioral subtype relation holds. Our work shows that even if these restrictions are not satisfied, we have considerable specification and verification reuse, represented by the two intermediate 13 horizontal lines.
Reference: [4] <author> J. Guttag, J. Horning, and J. Wing. </author> <title> The larch family of specification languages. </title> <journal> IEEE Software, </journal> <volume> 2, </volume> <year> 1985. </year>
Reference-contexts: The abstract specification A will be the usual ADT-type specification <ref> [4] </ref>, consisting of a conceptual, mathematical model of B, and the specifications of the methods of B in terms of pre- and post-conditions in this model.
Reference: [5] <author> C. Jones. </author> <title> Systematic Software Development Using VDM. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: The idea of concrete specifications is not new. Such specifications are also used in standard approaches such as those of <ref> [5] </ref>, although for a different purpose: Consider the class B. How do we establish that it meets its abstract specification? The actual bodies of B's operations 6 are of course written in terms of the internal data members of B and operate on those members, not on a `conceptual' entity.
Reference: [6] <author> B. Liskov and J. Wing. </author> <title> A new definition of the subtype relation. </title> <booktitle> In ECOOP, </booktitle> <year> 1993. </year>
Reference-contexts: that we are not asking the question `Given a base class B and a derived class D, under what conditions can a client program use objects that are instances of D in place of instances of B?' The answer to that question is provided by the work on behavioral subtyping <ref> [1, 6, 7] </ref>. Informally, a class A is a behavioral subtype of another class B if the behavior exhibited by objects that are instances of A is in some sense consistent with behaviors allowed by the class B. <p> That only leaves us with the 16 BetterAccount is not a behavioral subtype of BankAccount according to the definition of Liskov and Wing <ref> [6, 7] </ref>, but it is a weak behavioral subtype, as per the definition of Dhara and Leavens [2]. 11 task of verifying that RemTransaction preserves the invariant. This is easily done. Suppose I nv holds in a state !. <p> This is perhaps the most important difference between behavioral subtyping <ref> [6, 3, 2] </ref> and our work; whereas the work on behavioral subtyping focuses on the relation between the abstract specifications of classes, our work shows how the derived class designer can use the concrete specification of the base class to build derived classes that are similar to but not (necessarily) behavioral <p> If further, we abide by the requirement that the derived class must be a behavioral subtype, then the abstract specifications of B and D will have the relation described by, for instance, Liskov and Wing <ref> [6, 7] </ref>; this is represented by the top most horizontal line in the figure, joining the boxes corresponding to the absract specifications of B and D.
Reference: [7] <author> B. Liskov and J. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM TOPLAS, </journal> <volume> 16 </volume> <pages> 1811-1841, </pages> <year> 1994. </year>
Reference-contexts: that we are not asking the question `Given a base class B and a derived class D, under what conditions can a client program use objects that are instances of D in place of instances of B?' The answer to that question is provided by the work on behavioral subtyping <ref> [1, 6, 7] </ref>. Informally, a class A is a behavioral subtype of another class B if the behavior exhibited by objects that are instances of A is in some sense consistent with behaviors allowed by the class B. <p> That only leaves us with the 16 BetterAccount is not a behavioral subtype of BankAccount according to the definition of Liskov and Wing <ref> [6, 7] </ref>, but it is a weak behavioral subtype, as per the definition of Dhara and Leavens [2]. 11 task of verifying that RemTransaction preserves the invariant. This is easily done. Suppose I nv holds in a state !. <p> If further, we abide by the requirement that the derived class must be a behavioral subtype, then the abstract specifications of B and D will have the relation described by, for instance, Liskov and Wing <ref> [6, 7] </ref>; this is represented by the top most horizontal line in the figure, joining the boxes corresponding to the absract specifications of B and D.
Reference: [8] <author> R. Martin. </author> <title> Designing object oriented C++ applications using the Booch method. </title> <publisher> Prentice-Hall, </publisher> <year> 1995. </year>
Reference-contexts: Despite the distinction between behavioral subtyping and inheritance, it is often claimed, and in this context this requirement is usually called the Liskov Substitution Principle (LSP), that the derived class must be a behavioral subtype of the base class (see, for instance, <ref> [8] </ref>, or the frequent debates on the topic in the newsgroup comp.object).
Reference: [9] <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Thus even if the invariant of the base class is not maintained by the derived class, one or more of the operations defined in the base class may be inherited by D. This is different from the kind of invariant that, for instance, <ref> [9] </ref> uses. 5 3 Reusing Verification Consider again the base class B and the derived class D.
Reference: [10] <author> N. Soundarajan. </author> <title> Understanding frameworks. </title> <type> Technical report, </type> <institution> Ohio State University, </institution> <year> 1997. </year>
Reference-contexts: The second approach is quite complex but would probably be useful in situations, such as OO frameworks, where such functions are used heavily; for some preliminary ideas on the details of such an approach, see <ref> [10] </ref>. In the currentq paper we will assume that the first approach is used. Next consider the second task we need to go through, that of verifying that each method of D leaves its invariant satisfied.
Reference: [11] <author> N. Soundarajan and S. Fridella. </author> <title> Inheriting and modifying behavior. </title> <booktitle> In TOOLS, </booktitle> <year> 1997. </year>
Reference-contexts: 9 As far as operations that are defined or redefined in D are concerned, we must, of course, come up with appropriate concrete specifications describing their effects on the various member variables (both those declared in D as well as those inherited from B). 7 We consider private members in <ref> [11] </ref>. Eiffel has no private members, only public and protected; thus all members of a class are accessible in derived classes. Java allows not only derived classes, but all other classes that are in the same `package' as B to access all members of B except those declared private.
Reference: [12] <author> R. Stata and J.V. Guttag. </author> <title> Modular reasoning in the presence of subclassing. </title> <booktitle> In OOPSLA. </booktitle> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: If the redefined g's behavior is consistent with its specification in B (and this is effectively what <ref> [12] </ref> requires) then there would be no need to reverify f but this seems an unlikely scenario; why redefine g if its new behavior is going to be consistent with its old behavior? 13 11 In practice, of course, it is quite possible that the base class designer has not actually
References-found: 12

