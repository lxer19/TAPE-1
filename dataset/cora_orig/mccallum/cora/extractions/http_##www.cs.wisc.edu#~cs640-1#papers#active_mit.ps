URL: http://www.cs.wisc.edu/~cs640-1/papers/active_mit.ps
Refering-URL: http://www.cs.wisc.edu/~cs640-1/740.syllabus.html
Root-URL: http://www.cs.wisc.edu
Title: ANTS: A Toolkit for Building and Dynamically Deploying Network Protocols  
Author: David J. Wetherall, John V. Guttag and David L. Tennenhouse 
Affiliation: Software Devices and Systems Group Laboratory for Computer Science Massachusetts Institute of Technology  
Date: April 1998  
Address: OPENARCH'98, San Francisco, CA,  
Note: To appear in IEEE  
Abstract: We present a novel approach to building and deploying network protocols. The approach is based on mobile code, demand loading, and caching techniques. The architecture of our system allows new protocols to be dynamically deployed at both routers and end systems, without the need for coordination and without unwanted interaction between co-existing protocols. In this paper, we describe our architecture and its realization in a prototype implementation. To demonstrate how to exploit our architecture, we present two simple protocols that operate within our prototype to introduce multicast and mobility services into a network that initially lacks them. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Ballardie et al. </author> <title> Core based Trees. </title> <booktitle> In SIG-COMM'93, </booktitle> <year> 1993. </year>
Reference-contexts: or make a new one if necessary if (m == null) - m = new W_JAN (); n.put (group, sender, m, IDLE); - // are we at an intermediate node? add: if (reverse != 0) - if (m.nodes == null) - // start a new list m.nodes = new W_N <ref> [1] </ref>; m.nodes [0] = reverse; else // does it contain our info? for (int i = 0; i &lt; m.nodes.length; i++) if (m.nodes [i] == reverse) break add; // if not, add it int len = m.nodes.length; W_N [] nn = new W_N [len+1]; System.arraycopy (m.nodes,0,nn,0,len); nn [len] = reverse; m.nodes <p> This choice is typical of the flexibility that ants offers protocol developers. If multiple senders are needed, then multiple distribution trees may be formed by having members subscribe to each of the senders. Alternatively, the sender may be considered the root of a core-based tree <ref> [1] </ref>, with messages routed up the tree towards the root and down other branches. 4 Prototype Implementation We have been experimenting with a prototype implementation of the ants architecture 3 .
Reference: [2] <author> R. Braden et al. </author> <title> Resource ReSerVation Protocol (RSVP) Version 1 Functional Specification. </title> <type> Internet Draft, </type> <month> Nov </month> <year> 1996. </year>
Reference-contexts: The slow evolution is attributable neither to a lack of need nor to a lack of innovative ideas. In the case of IP, for example, changes are underway to better support multimedia applications, as well as to accommodate a larger number of potentially mobile hosts <ref> [4, 2, 3, 14] </ref>. Unfortunately, though agreement on the need for these changes was reached many years ago, they are still not fully deployed. The problem is that the current process of changing network protocols is both lengthy and difficult. It requires standardization, since internetworking protocols fl djw@lcs.mit.edu. http://www.sds.lcs.mit.edu/.
Reference: [3] <author> S. Deering and R. Hinden. </author> <title> Internet Protocol, Version 6 (IPv6) Specification. Request For Comments 1883, </title> <month> Dec </month> <year> 1995. </year>
Reference-contexts: The slow evolution is attributable neither to a lack of need nor to a lack of innovative ideas. In the case of IP, for example, changes are underway to better support multimedia applications, as well as to accommodate a larger number of potentially mobile hosts <ref> [4, 2, 3, 14] </ref>. Unfortunately, though agreement on the need for these changes was reached many years ago, they are still not fully deployed. The problem is that the current process of changing network protocols is both lengthy and difficult. It requires standardization, since internetworking protocols fl djw@lcs.mit.edu. http://www.sds.lcs.mit.edu/.
Reference: [4] <author> S. E. Deering. </author> <title> Host Extensions for IP multicasting. Request For Comments 1112, </title> <month> Aug </month> <year> 1989. </year>
Reference-contexts: The slow evolution is attributable neither to a lack of need nor to a lack of innovative ideas. In the case of IP, for example, changes are underway to better support multimedia applications, as well as to accommodate a larger number of potentially mobile hosts <ref> [4, 2, 3, 14] </ref>. Unfortunately, though agreement on the need for these changes was reached many years ago, they are still not fully deployed. The problem is that the current process of changing network protocols is both lengthy and difficult. It requires standardization, since internetworking protocols fl djw@lcs.mit.edu. http://www.sds.lcs.mit.edu/. <p> if (m != null) - if (m.nodes != null) - // send a copy every way for (int i = 0; i &lt; m.nodes.length; i++) n.routefornode (this, m.nodes [i]); else // or deliver to application n.delivertoapp (this, dpt); - 3.2 Multicast We introduce a basic Multicast protocol, resembling IP multicast <ref> [4] </ref>, composed of two cooperating capsule types 2 . One type of capsule is sent to subscribe to a group, and the other carries the multicast message itself. Applications that wish to receive messages sent to a given group by a particular sender periodically send Subscribe capsules towards the sender.
Reference: [5] <author> P. Deutsch and C. A. Grant. </author> <title> A Flexible Measurement Tool for Software Systems. </title> <booktitle> In Information Processing, </booktitle> <year> 1971. </year>
Reference-contexts: Processing time and link bandwidth are allocated by time and capsule quanta, respectively; node memory is allocated by cached objects, since caching converts memory into a renewable resource. We hope, however, that it will prove feasible to enforce static limits at nodes with a scheme similar to <ref> [5] </ref> or by using proof-carrying code techniques [12]. 4 2.3 Code Distribution The third component of our architecture is a code distribution system. Given a programmable infrastructure, a mechanism is needed for propagating program definitions to where they are needed.
Reference: [6] <author> G. Di Marzo et al. </author> <title> The Messenger Paradigm and its Impact on Distributed Systems. </title> <booktitle> In Workshop on Intelligent Computer Communication, </booktitle> <year> 1995. </year>
Reference-contexts: The most similar recent work we are aware of is the messenger paradigm <ref> [6] </ref> and work on flexible protocol stacks that preceded it [18]. Like our system, this work allows new protocols to be deployed. The intent, however, is to investigate the structuring of communicating systems, including distributed operating systems and intelligent agents.
Reference: [7] <author> R. Gilligan and E. Nordmark. </author> <title> Transition Mechanisms for IPv6 Hosts and Routers. Request For Comments 1933, </title> <month> April </month> <year> 1996. </year>
Reference-contexts: This poses no bootstrapping problem however: it is straightforward to select which protocol to use in the first place with a directory service, e.g., in the same manner that the selection of IPv4 versus IPv6 is being incorporated into the DNS <ref> [7] </ref> for the IPv6 transition. // look up forwarding record W_JAN m = (W_JAN)n.get (group, sender); // must find it to continue if (m != null) - if (m.nodes != null) - // send a copy every way for (int i = 0; i &lt; m.nodes.length; i++) n.routefornode (this, m.nodes [i]);
Reference: [8] <author> J. Hartman et al. </author> <title> Liquid Software: A New Paradigm for Networked Systems. </title> <type> Technical Report TR96-11, </type> <institution> Dept. of Computer Science, Univ. of Arizona, </institution> <year> 1996. </year>
Reference-contexts: Our work is complementary to several other active network efforts. The use of general-purpose Java byte-codes and VM has allowed us to evolve our architecture quickly, but at the cost of less control over resource usage and lower absolute performance. Research at the University of Arizona on Liquid Software <ref> [8] </ref> and Scout [11] enable a finer granularity of local resource management as well as competitive performance through the construction of a specialized node operating system.
Reference: [9] <author> N. C. Hutchinson and L. L. Peterson. </author> <title> The x-Kernel: An Architecture for Implementing Network Protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: Our architecture views the network as a (somewhat restricted) distributed programming system, and provides a programming language-like model for expressing new protocols in terms of operations at nodes. Compared with alternative systems in which new protocols may be formed by selecting from a library of components, e.g., the x-kernel <ref> [9] </ref>, ants provides the greater flexibility that accompanies a programming language and the convenience of dynamic deployment. In the next section of this paper, we present the ants protocol architecture. <p> The intent, however, is to investigate the structuring of communicating systems, including distributed operating systems and intelligent agents. As such, it lacks the network layer specializations, e.g., demand loading, that we have developed. Some modern protocol architectures have been configurable, as opposed to programmable. The x-kernel <ref> [9] </ref> provides a collection of micro-protocols from which protocols (e.g., RPC) can be synthesized. Configurable systems can further increase their flexibility by deferring the selection of components until runtime, and so the x-kernel supports the dynamic composition of micro-protocols on a per packet basis.
Reference: [10] <author> L. Lehman, S. Garland, and D. Tennenhouse. </author> <title> Active Reliable Multicast. </title> <booktitle> In INFOCOM '98, </booktitle> <year> 1998. </year>
Reference-contexts: We have used it to test and debug the Mobile and Multicast protocols discussed in this paper, as well as a number of other protocols developed in our group, e.g.,a high performance reliable multicast developed by Lehman <ref> [10] </ref>, a TCP SYN-flooding defense protocol developed by Van [19], and an auction service developed by Legedza.
Reference: [11] <author> D. Mosberger and L. L. Peterson. </author> <title> Making Paths Explicit in the Scout Operating System. </title> <booktitle> In 2nd Symp. on Operating System Design and Implementation, </booktitle> <year> 1996. </year>
Reference-contexts: The use of general-purpose Java byte-codes and VM has allowed us to evolve our architecture quickly, but at the cost of less control over resource usage and lower absolute performance. Research at the University of Arizona on Liquid Software [8] and Scout <ref> [11] </ref> enable a finer granularity of local resource management as well as competitive performance through the construction of a specialized node operating system.
Reference: [12] <author> G. Necula and P. Lee. </author> <title> Safe Kernel Extensions Without Run-Time Checking. </title> <booktitle> In 2nd Symp. on Operating System Design and Implementation, </booktitle> <year> 1996. </year>
Reference-contexts: We hope, however, that it will prove feasible to enforce static limits at nodes with a scheme similar to [5] or by using proof-carrying code techniques <ref> [12] </ref>. 4 2.3 Code Distribution The third component of our architecture is a code distribution system. Given a programmable infrastructure, a mechanism is needed for propagating program definitions to where they are needed.
Reference: [13] <author> C. Partridge. </author> <title> Late-Binding RPC: A Paradigm for Distributed Computation in a Gigabit Environment. </title> <type> PhD thesis, </type> <institution> Harvard University, </institution> <year> 1992. </year>
Reference-contexts: We speculate that this was because of difficulties with safety and efficiency, problems that may now be more tractable, given the recent advances in mobile code and operating system technology. End-to-end code shipping to improve performance has been studied in the context of RPC <ref> [15, 13] </ref>. Our approach offers a greater scope for customization by including intermediate nodes as well as end-systems. Our work is complementary to several other active network efforts.
Reference: [14] <author> C. Perkins, Ed. </author> <title> IP Mobility Support. Request For Comments 2002, </title> <month> Oct </month> <year> 1996. </year>
Reference-contexts: The slow evolution is attributable neither to a lack of need nor to a lack of innovative ideas. In the case of IP, for example, changes are underway to better support multimedia applications, as well as to accommodate a larger number of potentially mobile hosts <ref> [4, 2, 3, 14] </ref>. Unfortunately, though agreement on the need for these changes was reached many years ago, they are still not fully deployed. The problem is that the current process of changing network protocols is both lengthy and difficult. It requires standardization, since internetworking protocols fl djw@lcs.mit.edu. http://www.sds.lcs.mit.edu/. <p> Despite the simplicity of this scheme, it provides the essential feature of mobility: hosts may be reached as they move without introducing another layer of addressing. There are also some interesting comparisons with Mobile IP <ref> [14] </ref>. First, it is not necessary to confine mobile forwarding information to the edges of the network.
Reference: [15] <author> J. W. Stamos and D. K. Gifford. </author> <title> Remote Evaluation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 537-565, </pages> <month> Oct </month> <year> 1990. </year> <month> 11 </month>
Reference-contexts: We speculate that this was because of difficulties with safety and efficiency, problems that may now be more tractable, given the recent advances in mobile code and operating system technology. End-to-end code shipping to improve performance has been studied in the context of RPC <ref> [15, 13] </ref>. Our approach offers a greater scope for customization by including intermediate nodes as well as end-systems. Our work is complementary to several other active network efforts.
Reference: [16] <author> D. Tennenhouse et al. </author> <title> A Survey of Active Network Research. </title> <journal> IEEE Communications Magazine, </journal> <pages> pages 80-86, </pages> <month> Jan </month> <year> 1997. </year>
Reference-contexts: This paper presents a new approach to network service innovation that addresses all of these problems. The essence of our approach is to standardize a communication model (rather than individual communication protocols) that allows uncoordinated deployment of coexisting protocols. We have developed an active network <ref> [16, 17] </ref> toolkit, called ants 1 , in which new protocols are automatically deployed at both intermediate nodes and end systems by using mobile code techniques.
Reference: [17] <author> D. L. Tennenhouse and D. Wetherall. </author> <title> Towards an Active Network Architecture. </title> <booktitle> In Multimedia Computing and Networking 96, </booktitle> <year> 1996. </year>
Reference-contexts: This paper presents a new approach to network service innovation that addresses all of these problems. The essence of our approach is to standardize a communication model (rather than individual communication protocols) that allows uncoordinated deployment of coexisting protocols. We have developed an active network <ref> [16, 17] </ref> toolkit, called ants 1 , in which new protocols are automatically deployed at both intermediate nodes and end systems by using mobile code techniques.
Reference: [18] <author> C. Tschudin. </author> <title> Flexible Protocol Stacks. </title> <booktitle> In SIG-COMM'91, </booktitle> <year> 1991. </year>
Reference-contexts: The most similar recent work we are aware of is the messenger paradigm [6] and work on flexible protocol stacks that preceded it <ref> [18] </ref>. Like our system, this work allows new protocols to be deployed. The intent, however, is to investigate the structuring of communicating systems, including distributed operating systems and intelligent agents. As such, it lacks the network layer specializations, e.g., demand loading, that we have developed.
Reference: [19] <author> V. C. Van. </author> <title> A Defense Against Address Spoofing Using Active Networks. </title> <type> M.Eng Thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: We have used it to test and debug the Mobile and Multicast protocols discussed in this paper, as well as a number of other protocols developed in our group, e.g.,a high performance reliable multicast developed by Lehman [10], a TCP SYN-flooding defense protocol developed by Van <ref> [19] </ref>, and an auction service developed by Legedza.
Reference: [20] <author> D. J. Wetherall and D. L. Tennenhouse. </author> <title> The ACTIVE IP Option. </title> <booktitle> In 7th SIGOPS European Workshop, </booktitle> <year> 1996. </year>
Reference-contexts: They also supply the resources shared between protocols and enforce constraints on how these resources may be used as protocols are executed. We describe our node design along these two lines. Node Primitives We chose an initial set of primitives based on our experience with a predecessor system <ref> [20] </ref>. This work suggests that a relatively small set of primitives is sufficient to express a number of different and useful forwarding routines. We support the categories of node primitives listed below.
Reference: [21] <author> Y. Yemini and S. da Silva. </author> <title> Towards Programmable Networks. </title> <booktitle> In FIP/IEEE Intl. Workshop on Distributed Systems Operations and Management, </booktitle> <year> 1996. </year>
Reference-contexts: Research at the University of Pennsylvania on PLAN and BBN on Sprocket enables stronger resource management and security guarantees across the nodes of a network through the use of language design techniques. Finally, 10 research on active signaling at USC ISI and NetScript at Columbia University <ref> [21] </ref> explore alternative models of active networks in which new services are introduced for control rather than data transfer purposes, or by network management agents rather than all users. 6 Conclusions In this paper, we have presented an architecture that supports the construction and dynamic deployment of network protocols.
Reference: [22] <author> J. Zander and R. Forchheimer. </author> <title> Softnet An Approach to High-Level Packet Communication. </title> <booktitle> In ARRL 2nd Computer Networking Conference, </booktitle> <year> 1983. </year> <month> 12 </month>
Reference-contexts: Although configurable systems are capable of expressing a range of protocols, their means of composition, e.g., layering, is less flexible than that of a programming language. The earliest programmable network based on mobile code that we are aware of is Softnet <ref> [22] </ref>, an experimental packet radio network constructed in the early 1980s. Its goal was similar to our own: to allow users to define their own high level services. As with our approach, packets were considered to be programs of a language, FORTH, and interpreted at nodes on arrival.
References-found: 22

