URL: ftp://ftp.cs.caltech.edu/tr/cs-tr-93-20.ps.Z
Refering-URL: ftp://ftp.cs.caltech.edu/tr/INDEX.html
Root-URL: http://www.cs.caltech.edu
Email: ulla@cs.caltech.edu  
Title: Distributed Diners: From UNITY Specification to CC++ Implementation  
Author: Ulla Binau 
Note: Note: The reader is assumed to be familiar with UNITY [CM88] and C, C++ or CC++ [KR88, Str91, CK92]. visiting from  
Date: June 3, 1993  
Affiliation: Department of Computer Science California Institute of Technology  Department of Computer Science at The Technical University of Denmark  
Pubnum: Caltech-CS-TR-93-20  
Abstract: Resource conflicts may typically be described as the dining philosophers problem (or diners for short). In this report we derive a distributed message-passing solution to the diners problem from the shared memory solution presented in [CM88, Ch.12 Dining Philosophers]. We define an isomorphism between variables in the shared memory state and variables in the distributed state. This allows us to translate the shared memory UNITY specification to a distributed UNITY specification without affecting the validity of the original refinement proof. It turns out that the translated progress properties cannot be fulfilled by the solution scheme we have in mind. However, we show that weaker properties may be used instead, still without affecting the correctness of the original proof. The derivation of a UNITY program from the translated properties is not quite obvious. Hence we introduce an extra refinement step prior to deriving our distributed UNITY implementation. Finally the distributed UNITY implementation is translated to Compositional C++, (CC++) a parallel extension of C and C++. 
Abstract-found: 1
Intro-found: 1
Reference: [And92] <author> Flemming Andersen. </author> <title> A Theorem Prover for UNITY in Higher Order Logic. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Technical University of Denmark, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Ongoing work on mechanically verifying the properties in the afore mentioned example using HOL-UNITY <ref> [And92] </ref> shows that tactics can be written to prove the properties automatically. Knowledge of the detailed steps of the proofs are not important to complete the mechanical proofs with these tactics. Rather the locality and composition of properties seem to be the hurdle.
Reference: [Bin92] <author> Ulla Binau. </author> <title> Mutual exclusion in a token ring in CC++: Program and proof. </title> <type> Technical Report Caltech-CS-TR-92-11, </type> <institution> California Institute of Technology, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: ^ :u:clean:v ^ :u:r:v ^ v:f:u ^ :v:clean:u ^ :v:r:u ^ N oneOf (u:f c:v; u:rc:v; v:f c:u; v:rc:u)) in user []os invariant (u:T _ u:H _ u:E) ^ (v:T _ v:H _ v:E)^ a ^ u:b ^ v:b ^ u:c ^ v:c in user []os 1 Please refer to <ref> [Bin92] </ref> for a more detailed discussion of the notion of invariant in UNITY versus the general definition of the term. 29 Program u.server (N,E,ch,tc) declare f,r,clean : array [0..N-1] of Boolean act : far, as, ap g sdine : ft, h, eg initially 8 v : :E [u,v] _ u v
Reference: [Bin93] <author> Ulla Binau. </author> <title> Distributed diners in CC++: The "complete" proof. </title> <type> Technical report, </type> <institution> California Institute of Technology, </institution> <year> 1993. </year> <note> To be pulished. </note>
Reference-contexts: A closer look at the proof of correctness for the final refinement step in [CM88, Sec.12.7.3] shows that we might replace (odn16), (odn18) and (odn19) by the following properties of the composite system. (See <ref> [Bin93] </ref> for a completed proof of correctness for the last refinement step in [CM88, Sec.12.7.3] and the full proofs for the refinements in this report.): u:sendreq:v 7! v:r:u _ u:rc:v in user []os (dn16') u:sendf ork:v 7! v:f:u _ u:f c:v in user []os (dn18') (u:h 0 ^ u:mayeat 0 )
Reference: [CK92] <author> K. Mani Chandy and Carl Kesselman. </author> <title> CC ++ : A declarative concurrent object-oriented programming notation. </title> <type> Technical Report Caltech-CS-TR-92-01, </type> <institution> California Institute of Technology, </institution> <year> 1992. </year>
Reference: [CM88] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: This type of problem is often referred to as the dining philosophers (or diners) problem. The problem has been formalized and solved for shared memory systems in e.g., <ref> [CM88, Ch.12] </ref>. We could start from scratch; formalize the problem and derive a solution. However, since this would imply re-doing much of the work done by Chandy and Misra, we find it more appealing to extend their refinement. <p> The control system and philosopher u interacts via a shared variable u:dine, which reflects the state of the philosopher, and we define: u:t (u:dine = t) (1) u:h (u:dine = h) (2) u:e (u:dine = e) (3) The behavior of the philosophers (user of di nners) is specified in UNITY <ref> [CM88, Sec.12.2] </ref> as follows: u:t unless u:h in user (udn1) stable u:h in user (udn2) u:e unless u:t in user (udn3) Conditional Property in user (udn4) Hypothesis: invariant E [u; v] =&gt; :u:e _ :v:e Conclusion: u:e 7! :u:e The problem is to derive a control system (operating system os) that <p> u:e unless u:t in user (udn3) Conditional Property in user (udn4) Hypothesis: invariant E [u; v] =&gt; :u:e _ :v:e Conclusion: u:e 7! :u:e The problem is to derive a control system (operating system os) that guarantees the behavior of the combined philosopher and control system (diners) given by 2 <ref> [CM88, Sec.12.2] </ref>: invariant :(u:e ^ v:e ^ E [u; v]) in user []os (dn1) u:h 7! u:e in user []os (dn2) Note: We have, here and in the following, eased the notation by assuming implicit universal quantification over any free variables in program properties. <p> That is, e.g., (dn2) should read: 8u :: u:h 7! u:e 1.2 The Diners Algorithm We now describe the (final) algorithm presented in <ref> [CM88, Chap.12] </ref>. 1.2.1 Informal Description With each edge we associate a fork, which can be clean or dirty, and a request token. Initially all forks are dirty and all philosophers are thinking. <p> The value of f ork [u; v] (rf [u; v]) indicates who currently holds the fork (request). The status (clean/dirty) of each fork is recorded in the shared boolean matrix clean [u; v]. The following UNITY specification of the control system (os of dinners) is taken from <ref> [CM88, Sec.12.8] </ref>. constant u:t in os (odn1) stable u:e in os (odn2) invariant G 0 is acyclic in os (odn7) invariant u:e ^ E [u; v] ) (f ork [u; v] = u) ^ :clean [u; v] in os (odn10) 3 (fork [u; v] = v) ^ clean [u; v] unless <p> The priority is defined by: (prior [u; v] = u) ((f ork [u; v] = u) = clean [u; v]) The acyclicity of G 0 is preserved as long as rules 1 and 2 <ref> [CM88, p.297] </ref> are obeyed: 1. The direction of an edge is changed only when a process on which the edge is incident changes state from hungry to eating. 2. <p> The second rule is obviously obeyed since a philosopher holds all his forks when he eats and they all are dirty (odn10). The first rule must similarly be obeyed due to (odn10-odn12). (odn7) is thus only needed to ensure proper initialization. In <ref> [CM88, Chap.12] </ref> it has been proved that an implementation fulfilling this specification will implement a correct solution to the problem. <p> In [CM88, Chap.12] it has been proved that an implementation fulfilling this specification will implement a correct solution to the problem. One such implementation is the shared memory UNITY program given in <ref> [CM88, Sec.12.9] </ref> (see below). 4 Program os always 8u :: (u:mayeat = 8v : E [u; v] : (f ork [u; v] = u) ^ (clean [u; v] _ (rf [u; v] = v))) 8u; v : E [u; v] : sendreq [u; v] = ((fork [u; v] = v) ^ <p> i [] h [](u; v) :: sendreq [u; v] ! rf [u; v] := v i [] h [](u; v) :: sendfork [u; v] ! fork [u; v]; clean [u; v] := v; true i end 1.3 Shared Memory UNITY Implementation the diners problem using a slightly different syntax than <ref> [CM88] </ref>. 1.4 Towards a Distributed Implementation Chandy and Misra [CM88, p.311] suggest the following implementation scheme for a distributed memory system: The reader may replace the shared variables f ork [u; v], clean [u; v], and rf [u; v] in program os by variables local to processes u, v and channels, <p> ! rf [u; v] := v i [] h [](u; v) :: sendfork [u; v] ! fork [u; v]; clean [u; v] := v; true i end 1.3 Shared Memory UNITY Implementation the diners problem using a slightly different syntax than [CM88]. 1.4 Towards a Distributed Implementation Chandy and Misra <ref> [CM88, p.311] </ref> suggest the following implementation scheme for a distributed memory system: The reader may replace the shared variables f ork [u; v], clean [u; v], and rf [u; v] in program os by variables local to processes u, v and channels, in both directions, between u and v. <p> However, in our channel implementation messages can only be received one at a time, so we cannot prove these properties from our program. A closer look at the proof of correctness for the final refinement step in <ref> [CM88, Sec.12.7.3] </ref> shows that we might replace (odn16), (odn18) and (odn19) by the following properties of the composite system. (See [Bin93] for a completed proof of correctness for the last refinement step in [CM88, Sec.12.7.3] and the full proofs for the refinements in this report.): u:sendreq:v 7! v:r:u _ u:rc:v in <p> A closer look at the proof of correctness for the final refinement step in <ref> [CM88, Sec.12.7.3] </ref> shows that we might replace (odn16), (odn18) and (odn19) by the following properties of the composite system. (See [Bin93] for a completed proof of correctness for the last refinement step in [CM88, Sec.12.7.3] and the full proofs for the refinements in this report.): u:sendreq:v 7! v:r:u _ u:rc:v in user []os (dn16') u:sendf ork:v 7! v:f:u _ u:f c:v in user []os (dn18') (u:h 0 ^ u:mayeat 0 ) 7! :(u:h 0 ^ u:mayeat 0 ) in user []os (dn19') So we <p> A complete mechanical derivation tool, i.e. from specification to implementation, would likewise require a UNITY property to program translator and a UNITY program to CC++ program translator. Acknowledgment The further refinement of the final os specification in <ref> [CM88] </ref> as opposed to a refinement from scratch was inspired by Singh's work on program refinement [Sin92]. Mani Chandy inspired the functional programming idea behind the CC++ program, and I would like to thank him for his very valuable support during my work.
Reference: [KR88] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Langauge. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference: [Sin92] <author> Ambuj K. Singh. </author> <title> Program refinement in fair transition systems. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, UCSB, </institution> <year> 1992. </year> <note> An earlier version appears in LNCS 506, p.128-147. </note>
Reference-contexts: Acknowledgment The further refinement of the final os specification in [CM88] as opposed to a refinement from scratch was inspired by Singh's work on program refinement <ref> [Sin92] </ref>. Mani Chandy inspired the functional programming idea behind the CC++ program, and I would like to thank him for his very valuable support during my work. Also thanks to Rustan Leino and Peter Hofstee for a good push, when I was stuck on an invariant proof.
Reference: [Siv93] <author> Paul Sivilotti. </author> <title> A verified integration of imperative parallel programming paradigms in an object-oriented language. </title> <type> Technical Report Caltech-CS-TR-93-21, </type> <institution> California Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: A thorough discussion of these is beyond the scope of this paper and may be found in <ref> [Siv93] </ref>. In the following passages we give a short description of the communication primitives used in this context, i.e. a subset of the routines involving message passing via channels.
Reference: [Str91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <type> Addison-Wesley, </type> <institution> AT&T Bell Laboratories, </institution> <address> 2nd edition, </address> <year> 1991. </year> <month> 39 </month>
References-found: 9

