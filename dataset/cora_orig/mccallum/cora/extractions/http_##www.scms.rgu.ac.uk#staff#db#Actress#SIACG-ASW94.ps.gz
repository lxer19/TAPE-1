URL: http://www.scms.rgu.ac.uk/staff/db/Actress/SIACG-ASW94.ps.gz
Refering-URL: http://www.scms.rgu.ac.uk/staff/db/
Root-URL: 
Title: Sort Inference in the Actress Compiler Generator  
Author: Deryck F. Brown David A. Watt 
Abstract: Actress accepts the action-semantic description of a source language, and from it generates a compiler. The generated compiler translates its source program to an action, performs sort inference on this action, (optionally) simplifies it by transformations, and finally translates it to object code. The sort inference phase provides valuable information for the subsequent transformation and code generation phases. In this paper we study the problem of sort inference on actions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken and E. L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Functional Programming and Computer Architecture '93, </booktitle> <pages> pages 31-41, </pages> <year> 1993. </year>
Reference-contexts: For example, list [truth-value] is the sort of all lists of truth values, list <ref> [1] </ref> is the sort of all lists of ones 3 , list [natural] is the sort of all lists of natural numbers, and list [truth-value natural] is the sort of all lists of truth values and natural numbers (a sort of heterogeneous lists). <p> However, when A is the sub-action of `unfolding', or the body of an abstraction, the sorts of the transients and bindings passed into A are not initially known. In these cases Palsberg's sort-checker resorts to ad hoc means to continue. Recently, Aiken et al. <ref> [1, 2] </ref> have applied type inference with type constraints to the problem of analysing a dynamically-typed -calculus to identify the places where run-time type checks are necessary.
Reference: [2] <author> A. Aiken, E. L. Wimmers, and T. K. Lakshman. </author> <title> Soft typing with conditional types. </title> <booktitle> In Proceedings of the 21st Conference on Principles of Programming Languages, </booktitle> <year> 1994. </year>
Reference-contexts: However, when A is the sub-action of `unfolding', or the body of an abstraction, the sorts of the transients and bindings passed into A are not initially known. In these cases Palsberg's sort-checker resorts to ad hoc means to continue. Recently, Aiken et al. <ref> [1, 2] </ref> have applied type inference with type constraints to the problem of analysing a dynamically-typed -calculus to identify the places where run-time type checks are necessary.
Reference: [3] <author> D. F. Brown. </author> <title> Sort inference in action semantic specifications. </title> <type> PhD thesis, </type> <institution> Department of Computing Science, University of Glasgow, </institution> <year> 1994. </year> <note> In preparation. </note>
Reference-contexts: Therefore it restricts sort terms to those generated by the BNF grammar in Table 2. This class of sorts has the following useful properties <ref> [3] </ref>: * The basic individuals are partitioned into a number of basic sorts, such that every basic individual belongs to a unique basic sort. Thus we can talk about the basic sort of a given basic individual. * Individuals of constructed sorts are not expressible. <p> Again, the sort of the resulting abstraction is made to have empty input transients. Space does not permit us to present all the sort inference rules here. They are presented in full in <ref> [3] </ref>. 5.2 Sort Inference Algorithm Our sort inference algorithm is based on the Even-Schmidt algorithm [7], but is improved in several important respects. Our algorithm achieves a greater measure of internal uniformity, by using record schemes for both transients and bindings. <p> Nevertheless, Even and Schmidt's work has strongly influenced our own. Our main contributions have been removal of the unnecessary `kind' structure, extension to a more representative subset of action notation, proper treatment of abstractions, and formalisation of the sort inference algorithm by a complete set of inference rules <ref> [3] </ref>. In [6], Doh and Schmidt address a related problem in sort inference.
Reference: [4] <author> D. F. Brown, H. Moura, and D. A. Watt. Actress: </author> <title> an action semantics directed compiler generator. </title> <booktitle> In Compiler Construction '92, Lecture Notes in Computer Science, </booktitle> <pages> pages 95-109. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Actress is an action-semantics directed compiler generator <ref> [4] </ref>. That is to say, it accepts a formal description of the syntax and action semantics [8, 14] of a particular programming language, the source language, and from this formal description it automatically generates a compiler that translates the source language to C object code. <p> An action-semantic description is structured like a denotational description, with semantic functions and semantic equations, but the denotations of phrases are expressed in action notation. 3 The Actress Compiler Generator Actress is a compiler (and interpreter) generation system developed at the University of Glasgow by Brown, Moura, and Watt <ref> [4] </ref>. It provides a collection of modules that operate on actions (represented internally as trees).
Reference: [5] <author> L. Cardelli and J. C. Mitchell. </author> <title> Operations on records. </title> <booktitle> In Workshop on Mathematical Foundations of Programming Language Semantics, Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1989. </year>
Reference-contexts: These record sorts are similar to the record types studied by Wand, Cardelli, Mitchell and others <ref> [5, 12, 13] </ref>. The domain of each record sort must be known, i.e., there must be no variables ranging over the domain of a record sort.
Reference: [6] <author> K. Doh and D. A. Schmidt. </author> <title> Extraction of strong typing laws from action semantics definitions. </title> <booktitle> In ESOP '92, volume 582 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <month> 18 </month>
Reference-contexts: ,! (fg; fg) unfold : (fgfl 18 ; fb: true, x: cellgfl 19 ) ,! (fg; fg) 6 Related Work As well as the work described in this paper, sort inference for action notation is a central theme of the mainly theoretical work of Schmidt's group at Kansas State University <ref> [7, 6] </ref>, and forms part of the more practical compiler-generation work of Palsberg at Aarhus University [10]. In [7], Even and Schmidt study the sort properties of a small dialect of action notation, and present a sort inference algorithm for this dialect. <p> Our main contributions have been removal of the unnecessary `kind' structure, extension to a more representative subset of action notation, proper treatment of abstractions, and formalisation of the sort inference algorithm by a complete set of inference rules [3]. In <ref> [6] </ref>, Doh and Schmidt address a related problem in sort inference.
Reference: [7] <author> S. Even and D. A. Schmidt. </author> <title> Type inference for action semantics. </title> <editor> In N. Jones, editor, </editor> <booktitle> ESOP '90, 3rd European Symposium on Programming, volume 432 of Lecture Notes in Computer Science, </booktitle> <pages> pages 118-133, </pages> <address> Copenhagen, Denmark, 1990. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany. </address>
Reference-contexts: Finally, a record sort scheme may have a row variable ( or fl) affixed to it. Row variables are used to represent possible extra unknown fields. Combining these ideas with those of Even and Schmidt <ref> [7] </ref>, we write the sort scheme of an action A as follows: A : (t; b) ,! (t 0 ; b 0 ) (5) where t and b are the record sort schemes of the transients and bindings used by A, and where t 0 and b 0 are the record <p> Again, the sort of the resulting abstraction is made to have empty input transients. Space does not permit us to present all the sort inference rules here. They are presented in full in [3]. 5.2 Sort Inference Algorithm Our sort inference algorithm is based on the Even-Schmidt algorithm <ref> [7] </ref>, but is improved in several important respects. Our algorithm achieves a greater measure of internal uniformity, by using record schemes for both transients and bindings. <p> ,! (fg; fg) unfold : (fgfl 18 ; fb: true, x: cellgfl 19 ) ,! (fg; fg) 6 Related Work As well as the work described in this paper, sort inference for action notation is a central theme of the mainly theoretical work of Schmidt's group at Kansas State University <ref> [7, 6] </ref>, and forms part of the more practical compiler-generation work of Palsberg at Aarhus University [10]. In [7], Even and Schmidt study the sort properties of a small dialect of action notation, and present a sort inference algorithm for this dialect. <p> In <ref> [7] </ref>, Even and Schmidt study the sort properties of a small dialect of action notation, and present a sort inference algorithm for this dialect.
Reference: [8] <author> P. D. Mosses. </author> <title> Action Semantics. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science 26. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Actress is an action-semantics directed compiler generator [4]. That is to say, it accepts a formal description of the syntax and action semantics <ref> [8, 14] </ref> of a particular programming language, the source language, and from this formal description it automatically generates a compiler that translates the source language to C object code. The generated compiler first translates each source program to an action, which we call the program action. <p> Section 5 describes our sort inference algorithm, and the sort inference rules that guide it. Section 6 surveys related work, and Section 7 concludes. 2 Action Notation Action semantics was developed by Mosses and Watt <ref> [8, 14] </ref>. As compared with other methods, action semantics has unusually good pragmatic qualities: action-semantic descriptions are easy to read, to write, and to modify. An action is a computational entity, which can be performed. <p> It provides a collection of modules that operate on actions (represented internally as trees). These modules include: 1 For historical reasons, this version of action notation differs slightly from that given in Mosses <ref> [8] </ref> and Watt [14]. 2 Primitive Informal meaning complete Completes immediately (i.e., does nothing). fail Fails immediately. give Y Gives the datum yielded by Y , labelled 0. give Y label #n Gives the datum yielded by Y , labelled n. bind k to Y Produces a single binding, of identifier <p> of increased compilation time: compile 0 L = encode A ffi transf orm A ffi check A ffi act L ffi parse L (4) 4 (a) truth-values (b) truth-values and naturals 4 Sorts 4.1 Data Sorts in Standard Action Notation The theoretical foundation of action notation is Mosses' unified algebras <ref> [8] </ref>. This algebraic framework elegantly solves some of the problems that beset older algebraic frameworks, by the simple expedient of abandoning the usual sharp distinction between values and sorts. In a unified algebra, a sort is just a classification of individuals.
Reference: [9] <author> H. Moura and D. A. Watt. </author> <title> Action transformations in the Actress compiler generator. </title> <booktitle> In Compiler Construction 5th International Conference, CC '94, Lecture Notes in Computer Science, </booktitle> <pages> pages 16-30. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: no guarantee that the given static semantics is sound with respect to the language's dynamic semantics. 13 Analogously, Actress will continue to accept both dynamically-scoped and statically-scoped languages, but will recognise the latter special case and exploit it to generate compilers that avoid generating code to manipulate bindings at run-time <ref> [9] </ref>. 17 of action notation to date. Indeed, Actress remains unique in its ability to handle actions requiring runtime sort checks. However, we also recognise that better performance could be obtained by generating a language-specific sort checker, using information gained from analysing the action semantics specification of the language.
Reference: [10] <author> J. Palsberg. </author> <title> A provably correct compiler generator. </title> <booktitle> In ESOP '92, volume 582 of Lecture Notes in Computer Science, </booktitle> <pages> pages 418-434. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: fg) 6 Related Work As well as the work described in this paper, sort inference for action notation is a central theme of the mainly theoretical work of Schmidt's group at Kansas State University [7, 6], and forms part of the more practical compiler-generation work of Palsberg at Aarhus University <ref> [10] </ref>. In [7], Even and Schmidt study the sort properties of a small dialect of action notation, and present a sort inference algorithm for this dialect. <p> Actress will not restrict the source language, however. It will continue to accept semantic descriptions of both dynamically-typed and statically-typed languages, but will recognise the latter special case and exploit it to generate compilers that avoid generating run-time sort checks. 13 Palsberg's compiler generation system Cantor <ref> [10] </ref> takes a pragmatic approach to sort inference (which is not a central part of his work).
Reference: [11] <author> D. A. Schmidt, </author> <month> Apr. </month> <year> 1991. </year> <type> Personal communication. </type>
Reference-contexts: Our algorithm achieves a greater measure of internal uniformity, by using record schemes for both transients and bindings. It infers exactly which transients and bindings an 6 For which sort inference is undecidable <ref> [11] </ref>. 13 action uses, using fl-variables to represent transients and bindings passed to the action but not used. It infers action sorts more precisely, by using a more refined sort hierarchy (Figure 1). <p> On the assumption that the described language is statically typed, they show 10 The `else' combinator is related to the `or' combinator, and has a similar rule. 11 However, their methods can be extended to remove some of these limitations <ref> [11] </ref>. 16 how to extract static type inference rules from the semantic equations of an action-semantic description. We intend to develop this work and apply it to Actress.
Reference: [12] <author> M. Wand. </author> <title> Complete type inference for simple objects. </title> <booktitle> In Proceedings of the 2nd IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1987. </year>
Reference-contexts: These record sorts are similar to the record types studied by Wand, Cardelli, Mitchell and others <ref> [5, 12, 13] </ref>. The domain of each record sort must be known, i.e., there must be no variables ranging over the domain of a record sort.
Reference: [13] <author> M. Wand. </author> <title> Type inference for record concatenation and simple objects. </title> <booktitle> In Proceedings of the 4th IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1989. </year>
Reference-contexts: These record sorts are similar to the record types studied by Wand, Cardelli, Mitchell and others <ref> [5, 12, 13] </ref>. The domain of each record sort must be known, i.e., there must be no variables ranging over the domain of a record sort. <p> While record sorts can be used to specify the sorts of individual actions, they are not sufficient to describe sort inference over actions. For this, we need to extend the record sorts into record sort schemes. This extension follows the extension of record types into record schemes given in <ref> [13] </ref>. We extend the notation as follows. We extend sorts to sort schemes which include sort variables, denoted by , which range over sorts. Also, instead of mapping field names to sorts directly, record sort schemes map names to field schemes. <p> Table 3: Syntax of action sorts in Actress * rebind : (fgfl 7 ; fg 1 ) ,! (fg; fg 1 ) * furthermore bind "x" to the integer bound to "y" : (fgfl 8 ; fy: integerg 2 ) ,! (fg; fx: integer, y: integerg 2 ) Unlike Wand <ref> [13] </ref>, we use two different classes of row variables. This reflects the different uses of the information given to an action. Firstly, any transients or bindings explicitly used within the body of an action appear explicitly in its sort scheme.
Reference: [14] <author> D. A. Watt. </author> <title> Programming Language Syntax and Semantics. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall, </publisher> <address> Hemel Hempstead, England, </address> <year> 1991. </year> <month> 19 </month>
Reference-contexts: 1 Introduction Actress is an action-semantics directed compiler generator [4]. That is to say, it accepts a formal description of the syntax and action semantics <ref> [8, 14] </ref> of a particular programming language, the source language, and from this formal description it automatically generates a compiler that translates the source language to C object code. The generated compiler first translates each source program to an action, which we call the program action. <p> Section 5 describes our sort inference algorithm, and the sort inference rules that guide it. Section 6 surveys related work, and Section 7 concludes. 2 Action Notation Action semantics was developed by Mosses and Watt <ref> [8, 14] </ref>. As compared with other methods, action semantics has unusually good pragmatic qualities: action-semantic descriptions are easy to read, to write, and to modify. An action is a computational entity, which can be performed. <p> It provides a collection of modules that operate on actions (represented internally as trees). These modules include: 1 For historical reasons, this version of action notation differs slightly from that given in Mosses [8] and Watt <ref> [14] </ref>. 2 Primitive Informal meaning complete Completes immediately (i.e., does nothing). fail Fails immediately. give Y Gives the datum yielded by Y , labelled 0. give Y label #n Gives the datum yielded by Y , labelled n. bind k to Y Produces a single binding, of identifier k to the
References-found: 14

