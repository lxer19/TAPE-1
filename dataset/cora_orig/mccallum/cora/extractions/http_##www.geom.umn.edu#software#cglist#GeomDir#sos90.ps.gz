URL: http://www.geom.umn.edu/software/cglist/GeomDir/sos90.ps.gz
Refering-URL: http://www.geom.umn.edu/software/cglist/GeomDir/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Simulation of Simplicity: A Technique to Cope with Degenerate Cases in Geometric Algorithms 1  
Author: Herbert Edelsbrunner and Ernst Peter Mucke 
Keyword: Computational geometry, degenerate data, implementation, programming tool, perturbation, determinants, symbolic computation.  
Note: ACM Transactions on Graphics, 9(1):66-104, 1990.  
Abstract: This paper describes a general-purpose programming technique, called the Simulation of Simplicity, which can be used to cope with degenerate input data for geometric algorithms. It relieves the programmer from the task to provide a consistent treatment for every single special case that can occur. The programs that use the technique tend to be considerably smaller and more robust than those that do not use it. We believe that this technique will become a standard tool in writing geometric software. 
Abstract-found: 1
Intro-found: 1
Reference: [AHU74] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1974. </year>
Reference-contexts: A typical way to resolve this tie is to pretend that the number with smaller index is smaller (assuming the integers are indexed, e.g., by their positions in an array). Or think of Kruskal's algorithm for constructing a minimum spanning tree of a weighted graph (see <ref> [AHU74] </ref>). At each step it chooses the shortest edge that can be added to the current collection of edges without creating a cycle. If this edge is not unique, then any one of the candidate edges is taken. <p> But how can we quantify "sufficiently far from zero"? In any case, we could now use Gaussian elimination (see e.g., [GVL83]) which takes O (D 3 ) time or asymptotically faster methods based on matrix multiplication as described for instance in <ref> [AHU74] </ref>. We do not believe that the latter methods could be of any practical use, though. However, if the value that we get is suspiciously close to zero, we have to use some other method to determine the sign of the determinant.
Reference: [AI86] <author> F. Aurenhammer and H. Imai. </author> <title> Geometric relations among Voronoi diagrams. </title> <type> Technical Report 228, </type> <institution> Institute fur Informationsverarbeitung, Technische Universitat Graz, Austria, </institution> <year> 1986. </year>
Reference-contexts: Examples are Voronoi diagrams or, more generally, power diagrams for arbitrary order and weighted Voronoi diagrams (see for instance [Ed87] and <ref> [AI86] </ref>). It is beyond the scope of this paper to describe how the data for those problems are used to generate hyperplanes | it will be enough to know that they are obtained via geometric transforms which do not create vertical hyperplanes.
Reference: [Ch52] <author> A. Charnes. </author> <title> Optimality and Degeneracy in Linear Programming. </title> <journal> Econometrica, </journal> <volume> 20(2) </volume> <pages> 160-170, </pages> <month> April </month> <year> 1952. </year>
Reference-contexts: A similar but less elaborate method has been used to solve degenerate linear programs. This leads to the implementation of the simplex algorithm referred to as the "lexicographical method" (see <ref> [Ch52] </ref>, [DOW55], [Da63], or [Ch83] for details). In computational geometry, this technique has been used in a couple of papers, including [Ed86] and [EW86], to avoid the otherwise necessary Simulation of Simplicity 3 discussion of degenerate cases.
Reference: [Ch83] <author> V. Chvatal. </author> <title> Linear Programming. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: A similar but less elaborate method has been used to solve degenerate linear programs. This leads to the implementation of the simplex algorithm referred to as the "lexicographical method" (see [Ch52], [DOW55], [Da63], or <ref> [Ch83] </ref> for details). In computational geometry, this technique has been used in a couple of papers, including [Ed86] and [EW86], to avoid the otherwise necessary Simulation of Simplicity 3 discussion of degenerate cases. This paper presents the theoretical foundations of SoS as well as details of its implementation.
Reference: [CK80] <author> V. Chvatal and G. Klincsek. </author> <title> Finding Largest Convex Subsets. </title> <booktitle> In Proceedings of the 11-th Southeastern Conference on Combinatorics, Graph Theory and Computing, </booktitle> <pages> pages 453-460, </pages> <year> 1980. </year>
Reference-contexts: Prime examples are the construction of convex hulls (see [PH77], [PS85], [Se81], [Se86], or [Ed87]), computing -matrices as discussed in [GP83] and [Ed87], and finding convex subsets (see <ref> [CK80] </ref>, [EG89], and [Ed87]). The remainder of this section considers the primitive operations required by the three-dimensional convex hull algorithm of Preparata and Hong which is described in [PH77], [PS85], and [Ed87]. The first step of the algorithm sorts the points in x 1 -direction.
Reference: [Da63] <author> G. B. Dantzig. </author> <title> Linear Programming and Extensions. </title> <publisher> Princeton University Press, </publisher> <address> Princeton, New Jersey, </address> <year> 1963. </year>
Reference-contexts: A similar but less elaborate method has been used to solve degenerate linear programs. This leads to the implementation of the simplex algorithm referred to as the "lexicographical method" (see [Ch52], [DOW55], <ref> [Da63] </ref>, or [Ch83] for details). In computational geometry, this technique has been used in a couple of papers, including [Ed86] and [EW86], to avoid the otherwise necessary Simulation of Simplicity 3 discussion of degenerate cases. This paper presents the theoretical foundations of SoS as well as details of its implementation.
Reference: [DOW55] <author> G. B. Dantzig, A. Orden, and P. Wolfe. </author> <title> The Generalized Simplex Method for Minimizing a Linear Form Under Linear inequality Restrictions. </title> <journal> Pacific Journal of Mathematics, </journal> <volume> 5(2) </volume> <pages> 183-195, </pages> <month> June </month> <year> 1955. </year>
Reference-contexts: A similar but less elaborate method has been used to solve degenerate linear programs. This leads to the implementation of the simplex algorithm referred to as the "lexicographical method" (see [Ch52], <ref> [DOW55] </ref>, [Da63], or [Ch83] for details). In computational geometry, this technique has been used in a couple of papers, including [Ed86] and [EW86], to avoid the otherwise necessary Simulation of Simplicity 3 discussion of degenerate cases.
Reference: [Ed86] <author> H. Edelsbrunner. </author> <title> Edge-Skeletons in Arrangements with Applications. </title> <journal> Algorithmica, </journal> <volume> 1(1) </volume> <pages> 93-109, </pages> <year> 1986. </year>
Reference-contexts: This leads to the implementation of the simplex algorithm referred to as the "lexicographical method" (see [Ch52], [DOW55], [Da63], or [Ch83] for details). In computational geometry, this technique has been used in a couple of papers, including <ref> [Ed86] </ref> and [EW86], to avoid the otherwise necessary Simulation of Simplicity 3 discussion of degenerate cases. This paper presents the theoretical foundations of SoS as well as details of its implementation. <p> In order to increase the credibility of our claim that SoS is indeed a practical programming tool, the second author compiled a prototype version of a SoS library [Mu88] and implemented the three-dimensional edge-skeleton algorithm of <ref> [Ed86] </ref>. We believe it is fair to say that this algorithm is an extraordinary challenge for someone who wants to do it without SoS.
Reference: [Ed87] <author> H. Edelsbrunner. </author> <title> Algorithms in Combinatorial Geometry. </title> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, West Germany, </address> <year> 1987. </year>
Reference-contexts: Simulation of Simplicity 8 There are plenty of algorithms for point set problems which are based on computing the orientation of a sequence of points. Prime examples are the construction of convex hulls (see [PH77], [PS85], [Se81], [Se86], or <ref> [Ed87] </ref>), computing -matrices as discussed in [GP83] and [Ed87], and finding convex subsets (see [CK80], [EG89], and [Ed87]). The remainder of this section considers the primitive operations required by the three-dimensional convex hull algorithm of Preparata and Hong which is described in [PH77], [PS85], and [Ed87]. <p> Simulation of Simplicity 8 There are plenty of algorithms for point set problems which are based on computing the orientation of a sequence of points. Prime examples are the construction of convex hulls (see [PH77], [PS85], [Se81], [Se86], or <ref> [Ed87] </ref>), computing -matrices as discussed in [GP83] and [Ed87], and finding convex subsets (see [CK80], [EG89], and [Ed87]). The remainder of this section considers the primitive operations required by the three-dimensional convex hull algorithm of Preparata and Hong which is described in [PH77], [PS85], and [Ed87]. <p> Prime examples are the construction of convex hulls (see [PH77], [PS85], [Se81], [Se86], or <ref> [Ed87] </ref>), computing -matrices as discussed in [GP83] and [Ed87], and finding convex subsets (see [CK80], [EG89], and [Ed87]). The remainder of this section considers the primitive operations required by the three-dimensional convex hull algorithm of Preparata and Hong which is described in [PH77], [PS85], and [Ed87]. The first step of the algorithm sorts the points in x 1 -direction. <p> [PH77], [PS85], [Se81], [Se86], or <ref> [Ed87] </ref>), computing -matrices as discussed in [GP83] and [Ed87], and finding convex subsets (see [CK80], [EG89], and [Ed87]). The remainder of this section considers the primitive operations required by the three-dimensional convex hull algorithm of Preparata and Hong which is described in [PH77], [PS85], and [Ed87]. The first step of the algorithm sorts the points in x 1 -direction. To perform this step, it needs to compare the x 1 -coordinates of two points, which can be done by computing the orientation of their orthogonal projections onto the x 1 -axis. <p> This becomes obvious when one thinks of the importance of problems such as linear programming, computing the intersection of half-spaces, and constructing arrangements of hyperplanes (see [PS85] and <ref> [Ed87] </ref> for further details and references). The goal of this section is to demonstrate how the techniques of Section 4 can be used to implement a typical primitive operation needed in those algorithms. This will open up an entire class of problems to the use of SoS. <p> Examples are Voronoi diagrams or, more generally, power diagrams for arbitrary order and weighted Voronoi diagrams (see for instance <ref> [Ed87] </ref> and [AI86]). It is beyond the scope of this paper to describe how the data for those problems are used to generate hyperplanes | it will be enough to know that they are obtained via geometric transforms which do not create vertical hyperplanes. <p> This transformation can be traced back in the literature to [Se82] and has since been used throughout the computational geometry literature (see [GS85], [PS85], and <ref> [Ed87] </ref>). For the case of circles in the plane we explain this transformation in detail and finally phrase the predicate for general dimensions.
Reference: [EG89] <author> H. Edelsbrunner and L. J. Guibas. </author> <title> Topologically Sweeping an Arrangement. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 38(1) </volume> <pages> 165-194, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Prime examples are the construction of convex hulls (see [PH77], [PS85], [Se81], [Se86], or [Ed87]), computing -matrices as discussed in [GP83] and [Ed87], and finding convex subsets (see [CK80], <ref> [EG89] </ref>, and [Ed87]). The remainder of this section considers the primitive operations required by the three-dimensional convex hull algorithm of Preparata and Hong which is described in [PH77], [PS85], and [Ed87]. The first step of the algorithm sorts the points in x 1 -direction.
Reference: [EW86] <author> H. Edelsbrunner and R. Waupotitsch. </author> <title> Computing a Ham-Sandwich Cut in Two Dimensions. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 2(2) </volume> <pages> 171-178, </pages> <month> June </month> <year> 1986. </year> <title> Simulation of Simplicity 32 </title>
Reference-contexts: This leads to the implementation of the simplex algorithm referred to as the "lexicographical method" (see [Ch52], [DOW55], [Da63], or [Ch83] for details). In computational geometry, this technique has been used in a couple of papers, including [Ed86] and <ref> [EW86] </ref>, to avoid the otherwise necessary Simulation of Simplicity 3 discussion of degenerate cases. This paper presents the theoretical foundations of SoS as well as details of its implementation.
Reference: [Fo85] <author> A. R. Forrest. </author> <title> Computational Geometry in Practice. </title> <editor> In E. A. Earnshaw, editor, </editor> <booktitle> Fundamental Algorithms for Computer Graphics, </booktitle> <pages> pages 707-724, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, West Germany, </address> <year> 1985. </year>
Reference-contexts: If that number is odd, then the test point lies within the polygon, and if the number is even, then it lies outside the polygon. As pointed out in <ref> [Fo85] </ref>, it is not a trivial matter to implement this algorithm, even if we assume that the test point does not lie on the boundary of the polygon.
Reference: [GP83] <author> J. E. Goodman and R. Pollack. </author> <title> Multidimensional Sorting. </title> <journal> SIAM Journal on Computing, </journal> <volume> 12(3) </volume> <pages> 484-507, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: Simulation of Simplicity 8 There are plenty of algorithms for point set problems which are based on computing the orientation of a sequence of points. Prime examples are the construction of convex hulls (see [PH77], [PS85], [Se81], [Se86], or [Ed87]), computing -matrices as discussed in <ref> [GP83] </ref> and [Ed87], and finding convex subsets (see [CK80], [EG89], and [Ed87]). The remainder of this section considers the primitive operations required by the three-dimensional convex hull algorithm of Preparata and Hong which is described in [PH77], [PS85], and [Ed87].
Reference: [GS85] <author> L. J. Guibas and J. Stolfi. </author> <title> Primitives for manipulation of general subdivisions and the computation of Voronoi diagrams. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 4(2) </volume> <pages> 74-123, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Such a test is useful for constructing Voronoi diagrams (as shown in <ref> [GS85] </ref> for d = 2) and other problems where circles and spheres play a role. An elegant solution to this problem can be given using a transform that lifts a sphere in d dimensions to d + 1 dimensions where it is represented by a hyperplane. <p> This transformation can be traced back in the literature to [Se82] and has since been used throughout the computational geometry literature (see <ref> [GS85] </ref>, [PS85], and [Ed87]). For the case of circles in the plane we explain this transformation in detail and finally phrase the predicate for general dimensions.
Reference: [GVL83] <author> G. H. Golub and Ch. F. Van Loan. </author> <title> Matrix Computations. </title> <publisher> John Hopkins University Press, </publisher> <address> Baltimore, Maryland, </address> <year> 1983. </year>
Reference-contexts: But how can we quantify "sufficiently far from zero"? In any case, we could now use Gaussian elimination (see e.g., <ref> [GVL83] </ref>) which takes O (D 3 ) time or asymptotically faster methods based on matrix multiplication as described for instance in [AHU74]. We do not believe that the latter methods could be of any practical use, though.
Reference: [Kn69] <author> D. E. Knuth. </author> <booktitle> The Art of Computer Programming. Volume 2: Seminumerical Algorithms. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1969. </year>
Reference-contexts: Assuming that the coordinates or parameters are integers, we can either use long integer arithmetic or modular arithmetic based on the Chinese remainder theorem. For details on both methods refer to <ref> [Kn69] </ref>.
Reference: [Mu88] <author> E. P. Mucke. </author> <title> SoS | A First Implementation. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, Urbana, Illinois, </institution> <month> September </month> <year> 1988. </year>
Reference-contexts: In order to increase the credibility of our claim that SoS is indeed a practical programming tool, the second author compiled a prototype version of a SoS library <ref> [Mu88] </ref> and implemented the three-dimensional edge-skeleton algorithm of [Ed86]. We believe it is fair to say that this algorithm is an extraordinary challenge for someone who wants to do it without SoS.
Reference: [PH77] <author> F. P. Preparata and S. J. Hong. </author> <title> Convex Hulls of Finite Sets of Points in Two and Three Dimensions. </title> <journal> Communications of the ACM, </journal> <volume> 20(2) </volume> <pages> 87-93, </pages> <month> February </month> <year> 1977. </year>
Reference-contexts: Simulation of Simplicity 8 There are plenty of algorithms for point set problems which are based on computing the orientation of a sequence of points. Prime examples are the construction of convex hulls (see <ref> [PH77] </ref>, [PS85], [Se81], [Se86], or [Ed87]), computing -matrices as discussed in [GP83] and [Ed87], and finding convex subsets (see [CK80], [EG89], and [Ed87]). The remainder of this section considers the primitive operations required by the three-dimensional convex hull algorithm of Preparata and Hong which is described in [PH77], [PS85], and [Ed87]. <p> convex hulls (see <ref> [PH77] </ref>, [PS85], [Se81], [Se86], or [Ed87]), computing -matrices as discussed in [GP83] and [Ed87], and finding convex subsets (see [CK80], [EG89], and [Ed87]). The remainder of this section considers the primitive operations required by the three-dimensional convex hull algorithm of Preparata and Hong which is described in [PH77], [PS85], and [Ed87]. The first step of the algorithm sorts the points in x 1 -direction. To perform this step, it needs to compare the x 1 -coordinates of two points, which can be done by computing the orientation of their orthogonal projections onto the x 1 -axis.
Reference: [PS85] <author> F. P. Preparata and M. I. Shamos. </author> <title> Computational Geometry | An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: Simulation of Simplicity 8 There are plenty of algorithms for point set problems which are based on computing the orientation of a sequence of points. Prime examples are the construction of convex hulls (see [PH77], <ref> [PS85] </ref>, [Se81], [Se86], or [Ed87]), computing -matrices as discussed in [GP83] and [Ed87], and finding convex subsets (see [CK80], [EG89], and [Ed87]). The remainder of this section considers the primitive operations required by the three-dimensional convex hull algorithm of Preparata and Hong which is described in [PH77], [PS85], and [Ed87]. <p> hulls (see [PH77], <ref> [PS85] </ref>, [Se81], [Se86], or [Ed87]), computing -matrices as discussed in [GP83] and [Ed87], and finding convex subsets (see [CK80], [EG89], and [Ed87]). The remainder of this section considers the primitive operations required by the three-dimensional convex hull algorithm of Preparata and Hong which is described in [PH77], [PS85], and [Ed87]. The first step of the algorithm sorts the points in x 1 -direction. To perform this step, it needs to compare the x 1 -coordinates of two points, which can be done by computing the orientation of their orthogonal projections onto the x 1 -axis. <p> This becomes obvious when one thinks of the importance of problems such as linear programming, computing the intersection of half-spaces, and constructing arrangements of hyperplanes (see <ref> [PS85] </ref> and [Ed87] for further details and references). The goal of this section is to demonstrate how the techniques of Section 4 can be used to implement a typical primitive operation needed in those algorithms. This will open up an entire class of problems to the use of SoS. <p> This transformation can be traced back in the literature to [Se82] and has since been used throughout the computational geometry literature (see [GS85], <ref> [PS85] </ref>, and [Ed87]). For the case of circles in the plane we explain this transformation in detail and finally phrase the predicate for general dimensions.
Reference: [Se81] <author> R. Seidel. </author> <title> A convex hull algorithm optimal for point sets in even dimensions. </title> <type> Technical Report 81-14, </type> <institution> Department of Computer Science, University of British Columbia, Vancouver, British Columbia, </institution> <year> 1981. </year>
Reference-contexts: Simulation of Simplicity 8 There are plenty of algorithms for point set problems which are based on computing the orientation of a sequence of points. Prime examples are the construction of convex hulls (see [PH77], [PS85], <ref> [Se81] </ref>, [Se86], or [Ed87]), computing -matrices as discussed in [GP83] and [Ed87], and finding convex subsets (see [CK80], [EG89], and [Ed87]). The remainder of this section considers the primitive operations required by the three-dimensional convex hull algorithm of Preparata and Hong which is described in [PH77], [PS85], and [Ed87].
Reference: [Se82] <author> R. Seidel. </author> <title> On the size of closest-point Voronoi diagrams. </title> <type> Technical Report F94, </type> <institution> Institute fur Informationsverarbeitung, Technische Universitat Graz, Austria, </institution> <year> 1982. </year>
Reference-contexts: An elegant solution to this problem can be given using a transform that lifts a sphere in d dimensions to d + 1 dimensions where it is represented by a hyperplane. This transformation can be traced back in the literature to <ref> [Se82] </ref> and has since been used throughout the computational geometry literature (see [GS85], [PS85], and [Ed87]). For the case of circles in the plane we explain this transformation in detail and finally phrase the predicate for general dimensions.
Reference: [Se86] <author> R. Seidel. </author> <title> Constructing Higher-Dimensional Convex Hulls in Logarithmic Cost per Face. </title> <booktitle> In Proceedings of the 18-th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 484-507, </pages> <address> Berkeley, California, </address> <month> May 22-30 </month> <year> 1986. </year>
Reference-contexts: Simulation of Simplicity 8 There are plenty of algorithms for point set problems which are based on computing the orientation of a sequence of points. Prime examples are the construction of convex hulls (see [PH77], [PS85], [Se81], <ref> [Se86] </ref>, or [Ed87]), computing -matrices as discussed in [GP83] and [Ed87], and finding convex subsets (see [CK80], [EG89], and [Ed87]). The remainder of this section considers the primitive operations required by the three-dimensional convex hull algorithm of Preparata and Hong which is described in [PH77], [PS85], and [Ed87].
Reference: [Ya87] <author> C. K. Yap. </author> <title> Symbolic Treatment of Geometric Degeneracies. </title> <booktitle> In Proceedings of the 13-th IFIP Conference on System Modeling and Optimization, </booktitle> <address> Chuo University, Tokyo, </address> <year> 1987. </year>
Reference-contexts: The tie-breaking part of the code appears in the lowest level of the algorithm, namely, in the procedures that implement the needed primitive operations. Different techniques following the same main approach have recently been suggested in <ref> [Ya87, Ya88] </ref>. A large part of this paper is devoted to demonstrating that the overhead in time caused by the use of the more elaborate primitive procedures required by SoS is negligible. <p> This is because the perturbation may decide that a point is inside the hull if it lies on a boundary edge or face. In this case the point would be prematurely discarded. We refer to <ref> [Ya87] </ref> for a more extensive discussion of the limitations of symbolic methods aimed at resolving robustness problems in geometric algorithms.
Reference: [Ya88] <author> C. K. Yap. </author> <title> A Geometric Consistency Theorem for a Symbolic Perturbation Scheme. </title> <booktitle> In Proceedings of the 4-th Annual ACM Symposium on Computational Geometry, </booktitle> <pages> pages 134-142, </pages> <address> Urbana, Illinois, </address> <month> June 6-8 </month> <year> 1988. </year> <title> Simulation of Simplicity 33 </title>
Reference-contexts: The tie-breaking part of the code appears in the lowest level of the algorithm, namely, in the procedures that implement the needed primitive operations. Different techniques following the same main approach have recently been suggested in <ref> [Ya87, Ya88] </ref>. A large part of this paper is devoted to demonstrating that the overhead in time caused by the use of the more elaborate primitive procedures required by SoS is negligible.
References-found: 24

