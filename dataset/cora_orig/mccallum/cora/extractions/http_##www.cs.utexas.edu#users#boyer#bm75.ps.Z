URL: http://www.cs.utexas.edu/users/boyer/bm75.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/boyer/publications.html
Root-URL: 
Title: Proving Theorems About LISP Functions  
Author: robert s. boyer and j strother moore 
Address: Edinburgh, Edinburgh, Scotland  
Affiliation: University of  
Abstract: Program verification is the idea that properties of programs can be precisely stated and proved in the mathematical sense. In this paper, some simple heuristics combining evaluation and mathematical induction are described, which the authors have implemented in a program that automatically proves a wide variety of theorems about recursive LISP functions. The method the program uses to generate induction formulas is described at length. The theorems proved by the program include that REVERSE is its own inverse and that a particular SORT program is correct. A list of theorems proved by the program is given. key words and phrases: LISP, automatic theorem-proving, structural induction, program verification cr categories: 3.64, 4.22, 5.21
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Bledsoe, W. W. </author> <title> Splitting and reduction heursitics in automatic theorem proving. </title> <journal> Artif. Intel. </journal> <volume> 2, 1 (1971), 55 77. </volume>
Reference-contexts: Our experience confirms, and was motivated by, a conviction that proofs and computations are essentially similar. This conviction was inspired by conversations with Bob Kowalski and Pat Hayes, and the beauty of LISP. Our program is in the style of theorem-proving programs written by Bledsoe <ref> [1, 2] </ref>. We would like to note that our program uses no search and has no knowledge of user functions other than their definitions.
Reference: 2. <author> Bledsoe, W. W., Boyer, R. S., and Henneman, W. H. </author> <title> Computer proofs of limit theorems. Artif. Intel. </title> <booktitle> 3 (1972), </booktitle> <pages> 27-60. </pages>
Reference-contexts: Our experience confirms, and was motivated by, a conviction that proofs and computations are essentially similar. This conviction was inspired by conversations with Bob Kowalski and Pat Hayes, and the beauty of LISP. Our program is in the style of theorem-proving programs written by Bledsoe <ref> [1, 2] </ref>. We would like to note that our program uses no search and has no knowledge of user functions other than their definitions.
Reference: 3. <author> Brotz, D. </author> <title> Proving theorems by mathematical induction. </title> <type> Ph.D. </type> <institution> Th., Com-put. Sci. Dep., Stanford U., Stanford, Calif., </institution> <year> 1973. </year>
Reference-contexts: Consequently our theorem-prover frequently reproves simple facts like the associativity of APPEND. 11 Related Work An excellent survey of the various methods for verifying programs is presented in Manna, Ness, and Vuillemin, 1972 [16]. Brotz, 1973 <ref> [3] </ref> has implemented an arithmetic theorem-prover very similar to ours. His system generates its own induction formulas and uses the generalization heuristic we use (without "type functions").
Reference: 4. <author> Burstall, R. M. </author> <title> Proving properties of programs by structural induction. </title> <journal> Comput. J. </journal> <volume> 12 (1969), </volume> <pages> 41-48. </pages>
Reference-contexts: His heuristic will always choose a term 11 recursed upon (due to restrictions on the forms of recursive equations allowed), but it will not always choose the one we choose. Our program uses structural induction, which was introduced into the literature by Burstall, 1969 <ref> [4] </ref>, although it was used earlier by McCarthy and Painter, 1967 [19] in a compiler correctness proof. Common alternative inductive methods for recursive languages are computational induction (Park, 1969 [24]) and recursion induction (McCarthy, 1963 [17]). Both are essentially induction on the depth of function calls.
Reference: 5. <author> Cooper, D. </author> <title> Programs for mechanical program verification. </title> <booktitle> In Machine Intelligence 6, </booktitle> <editor> B. Meltzer and D. Michie, Eds., </editor> <publisher> Edinburgh U. Press, </publisher> <address> Ed-inburgh, </address> <year> 1971, </year> <pages> pp. 43-59. </pages>
Reference-contexts: In this approach, inductive assertions are attached to points in a program and are used to generate "verification conditions," which are theorems that must be proved to establish the correctness of the program. King 1969 [15], Good, 1970 [12], Cooper, 1971 <ref> [5] </ref>, Gerhart, 1972 [11], Deutsch, 1973 [7], Igarashi, London, and Luckham, 1973 [13], Elspas, Levitt, and Waldinger, 1973 [9], and Topor and Burstall, 1973 [26] have implemented systems which use this method for languages which include assignments (possibly to arrays), jumps or loops, and defined procedure calls.
Reference: 6. <author> Darlington, J., and Burstall, R. M. </author> <title> A system which automatically improves programs. </title> <booktitle> Proc. Internat. Joint Conf. on Artif. Intell., </booktitle> <year> 1973, </year> <pages> pp. 479-485. </pages>
Reference-contexts: These programs require the user to invent inductive assertions. Elspas, 1972 [8], Wegbreit, 1973 [27], and Katz and Manna, 1973 [14] present heuristics for generating inductive assertions automatically. Darlington and Burstall, 1973 <ref> [6] </ref> describe a system which will take functions such as the ones in our LISP subset and write equivalent programs which are more efficient. This system will replace recursion by iteration, merge loops, and use data structures (destructively) when permitted. Appendix A.
Reference: 7. <author> Deutsch, L. P. </author> <title> An interactive program verifier. </title> <type> Ph.D. </type> <institution> Th., Comput. Sci. Dep., U. of California, Berkeley, Calif., </institution> <year> 1973. </year>
Reference-contexts: In this approach, inductive assertions are attached to points in a program and are used to generate "verification conditions," which are theorems that must be proved to establish the correctness of the program. King 1969 [15], Good, 1970 [12], Cooper, 1971 [5], Gerhart, 1972 [11], Deutsch, 1973 <ref> [7] </ref>, Igarashi, London, and Luckham, 1973 [13], Elspas, Levitt, and Waldinger, 1973 [9], and Topor and Burstall, 1973 [26] have implemented systems which use this method for languages which include assignments (possibly to arrays), jumps or loops, and defined procedure calls. These programs require the user to invent inductive assertions.
Reference: 8. <author> Elspas, B. </author> <title> The semiautomatic generation of inductive assertions for program correctness proofs. </title> <type> Rep. No. 55, Seminar, </type> <institution> Des Instituts fur Theorie der Automaten und Schaltnetzwerke, Gesellschaft fur Mathematik und Datenverarbeitung, Bonn, </institution> <month> Aug. </month> <year> 21,1972. </year>
Reference-contexts: These programs require the user to invent inductive assertions. Elspas, 1972 <ref> [8] </ref>, Wegbreit, 1973 [27], and Katz and Manna, 1973 [14] present heuristics for generating inductive assertions automatically. Darlington and Burstall, 1973 [6] describe a system which will take functions such as the ones in our LISP subset and write equivalent programs which are more efficient.
Reference: 9. <author> Elspas, B., Levitt, K. N., and Waldinger, R. J. </author> <title> An interactive system for the verification of computer programs. </title> <type> Final rep., Project 1891, </type> <institution> Stanford Res. Inst., Menlo Park, Calif., </institution> <year> 1973. </year>
Reference-contexts: King 1969 [15], Good, 1970 [12], Cooper, 1971 [5], Gerhart, 1972 [11], Deutsch, 1973 [7], Igarashi, London, and Luckham, 1973 [13], Elspas, Levitt, and Waldinger, 1973 <ref> [9] </ref>, and Topor and Burstall, 1973 [26] have implemented systems which use this method for languages which include assignments (possibly to arrays), jumps or loops, and defined procedure calls. These programs require the user to invent inductive assertions.
Reference: 10. <author> Floyd, R. W. </author> <title> Assigning meaning to programs. </title> <booktitle> Proceedings of a Symposium in Applied Mathematics, </booktitle> <volume> Vol. 19: </volume> <booktitle> Mathematical Aspects of Computer Science, </booktitle> <editor> J. T. Schwartz, Ed., </editor> <publisher> Amer. Math. Soc., Providence, </publisher> <editor> R. I., </editor> <year> 1967, </year> <pages> pp. 19-32. </pages>
Reference-contexts: Milner, 1972 [20] and Milner and Weyhrauch, 1972 [21] describe a proof checker for Scott's Logic for Computable Functions (Scott, 1970 [25]) which uses computational induction. The most commonly used method is for flow diagram languages and was suggested by Naur, 1966 [23] and Floyd, 1967 <ref> [10] </ref>. In this approach, inductive assertions are attached to points in a program and are used to generate "verification conditions," which are theorems that must be proved to establish the correctness of the program.
Reference: 11. <author> Gerhart, S. </author> <title> Verification of APL programs. </title> <type> Ph.D. </type> <institution> Th., Carnegie-Mellon U., </institution> <address> Pittsburgh, Pa., </address> <year> 1972. </year>
Reference-contexts: In this approach, inductive assertions are attached to points in a program and are used to generate "verification conditions," which are theorems that must be proved to establish the correctness of the program. King 1969 [15], Good, 1970 [12], Cooper, 1971 [5], Gerhart, 1972 <ref> [11] </ref>, Deutsch, 1973 [7], Igarashi, London, and Luckham, 1973 [13], Elspas, Levitt, and Waldinger, 1973 [9], and Topor and Burstall, 1973 [26] have implemented systems which use this method for languages which include assignments (possibly to arrays), jumps or loops, and defined procedure calls.
Reference: 12. <author> Good, D. </author> <title> Toward a man-machine system for proving program correctness. </title> <type> Ph.D. </type> <institution> Th., Dep. of Comput. Sci., U. of Wisconsin, Madison, </institution> <address> Wis., </address> <year> 1970. </year>
Reference-contexts: In this approach, inductive assertions are attached to points in a program and are used to generate "verification conditions," which are theorems that must be proved to establish the correctness of the program. King 1969 [15], Good, 1970 <ref> [12] </ref>, Cooper, 1971 [5], Gerhart, 1972 [11], Deutsch, 1973 [7], Igarashi, London, and Luckham, 1973 [13], Elspas, Levitt, and Waldinger, 1973 [9], and Topor and Burstall, 1973 [26] have implemented systems which use this method for languages which include assignments (possibly to arrays), jumps or loops, and defined procedure calls.
Reference: 13. <author> Igarashi, S., London, R. L., and Luckham, D. C. </author> <title> Automatic program verification I: A logical basis and its implementation. </title> <type> Rep. 200, </type> <institution> Stanford Artif. Intel. Lab., Stanford, Calif., </institution> <year> 1973. </year>
Reference-contexts: King 1969 [15], Good, 1970 [12], Cooper, 1971 [5], Gerhart, 1972 [11], Deutsch, 1973 [7], Igarashi, London, and Luckham, 1973 <ref> [13] </ref>, Elspas, Levitt, and Waldinger, 1973 [9], and Topor and Burstall, 1973 [26] have implemented systems which use this method for languages which include assignments (possibly to arrays), jumps or loops, and defined procedure calls. These programs require the user to invent inductive assertions.
Reference: 14. <author> Katz, S. M., and Manna, Z. </author> <title> A heuristic approach to program verification. </title> <booktitle> Proc. Int'l Joint Conf. on Artif. Intell., </booktitle> <year> 1973, </year> <pages> pp. 500-512. </pages>
Reference-contexts: These programs require the user to invent inductive assertions. Elspas, 1972 [8], Wegbreit, 1973 [27], and Katz and Manna, 1973 <ref> [14] </ref> present heuristics for generating inductive assertions automatically. Darlington and Burstall, 1973 [6] describe a system which will take functions such as the ones in our LISP subset and write equivalent programs which are more efficient.
Reference: 15. <author> King, J. </author> <title> A program verifier. </title> <type> Ph.D. </type> <institution> Th., Carnegie-Mellon U., </institution> <address> Pittsburgh, Pa., </address> <year> 1969. </year>
Reference-contexts: In this approach, inductive assertions are attached to points in a program and are used to generate "verification conditions," which are theorems that must be proved to establish the correctness of the program. King 1969 <ref> [15] </ref>, Good, 1970 [12], Cooper, 1971 [5], Gerhart, 1972 [11], Deutsch, 1973 [7], Igarashi, London, and Luckham, 1973 [13], Elspas, Levitt, and Waldinger, 1973 [9], and Topor and Burstall, 1973 [26] have implemented systems which use this method for languages which include assignments (possibly to arrays), jumps or loops, and defined
Reference: 16. <author> Manna, Z., Ness, S., and Vuillemln, J. </author> <title> Inductive methods for proving properties of programs. Proceedings of an ACM Conference on Proving Assertions about Programs, </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 7, No. </volume> <month> 1 (Jan. </month> <year> 1972), </year> <pages> pp. 27-50. </pages>
Reference-contexts: Consequently our theorem-prover frequently reproves simple facts like the associativity of APPEND. 11 Related Work An excellent survey of the various methods for verifying programs is presented in Manna, Ness, and Vuillemin, 1972 <ref> [16] </ref>. Brotz, 1973 [3] has implemented an arithmetic theorem-prover very similar to ours. His system generates its own induction formulas and uses the generalization heuristic we use (without "type functions").
Reference: 17. <author> McCarthy, J. </author> <title> A basis for a mathematical theory of computation. In Computer Programming and Formal Systems, </title> <editor> P. Braffort and D. Hirsch-berg, Eds., </editor> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1963, </year> <pages> pp. 33-70. </pages>
Reference-contexts: Our program uses structural induction, which was introduced into the literature by Burstall, 1969 [4], although it was used earlier by McCarthy and Painter, 1967 [19] in a compiler correctness proof. Common alternative inductive methods for recursive languages are computational induction (Park, 1969 [24]) and recursion induction (McCarthy, 1963 <ref> [17] </ref>). Both are essentially induction on the depth of function calls. Milner, 1972 [20] and Milner and Weyhrauch, 1972 [21] describe a proof checker for Scott's Logic for Computable Functions (Scott, 1970 [25]) which uses computational induction.
Reference: 18. <author> McCarthy, J., et al. </author> <title> LISP 1.5 Programmer's Manual. </title> <publisher> M.I.T. Press, </publisher> <address> Cambridge, Mass., </address> <year> 1962. </year>
Reference-contexts: No further information is required of the user. This paper describes many aspects of the program in brevity. A thorough presentation can be found in [22]. 2 Our LISP Subset We use a subset of pure LISP <ref> [18] </ref> which has as primitives NIL, CONS, CAR, CDR, COND, and EQUAL. With these primitive we can define recursive functions such as those in Appendix A, and we can prove theorems such as those in Appendix B about these functions.
Reference: 19. <author> Mccarthy, J., and Painter, J. A. </author> <title> Correctness of a compiler for arithmetic expressions. </title> <booktitle> Proceedings of a Symposium in Applied Mathematics, </booktitle> <volume> Vol. 19, </volume> <booktitle> Mathematical Aspects of Computer Science, </booktitle> <editor> Schwartz, J. T., Ed., </editor> <publisher> Amer. Math. Soc., Providence, </publisher> <editor> R. I., </editor> <year> 1967, </year> <pages> pp. 33-41. </pages>
Reference-contexts: Our program uses structural induction, which was introduced into the literature by Burstall, 1969 [4], although it was used earlier by McCarthy and Painter, 1967 <ref> [19] </ref> in a compiler correctness proof. Common alternative inductive methods for recursive languages are computational induction (Park, 1969 [24]) and recursion induction (McCarthy, 1963 [17]). Both are essentially induction on the depth of function calls.
Reference: 20. <author> Milner, R. </author> <title> Implementation and application of Scott's logic for computable functions. Proceedings of an ACM Conference on Proving Assertions about Programs, </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 7, No. </volume> <month> 1 (Jan. </month> <year> 1972), </year> <pages> pp. 1-6. </pages>
Reference-contexts: Common alternative inductive methods for recursive languages are computational induction (Park, 1969 [24]) and recursion induction (McCarthy, 1963 [17]). Both are essentially induction on the depth of function calls. Milner, 1972 <ref> [20] </ref> and Milner and Weyhrauch, 1972 [21] describe a proof checker for Scott's Logic for Computable Functions (Scott, 1970 [25]) which uses computational induction. The most commonly used method is for flow diagram languages and was suggested by Naur, 1966 [23] and Floyd, 1967 [10].
Reference: 21. <author> Milner, R., and Weyhrauch, R. </author> <title> Proving compiler correctness in a mechanized logic In Machine Intelligence 7, </title> <editor> B. Meltzer and D. Michie, Eds., </editor> <publisher> Edinburgh U. Press, Edinburgh, </publisher> <year> 1972, </year> <pages> pp. 5170. </pages>
Reference-contexts: Common alternative inductive methods for recursive languages are computational induction (Park, 1969 [24]) and recursion induction (McCarthy, 1963 [17]). Both are essentially induction on the depth of function calls. Milner, 1972 [20] and Milner and Weyhrauch, 1972 <ref> [21] </ref> describe a proof checker for Scott's Logic for Computable Functions (Scott, 1970 [25]) which uses computational induction. The most commonly used method is for flow diagram languages and was suggested by Naur, 1966 [23] and Floyd, 1967 [10].
Reference: 22. <author> Moore, J S. </author> <title> Computational logic: Structure sharing and proof of program properties. </title> <type> Ph.D. </type> <institution> Th., Dep. of Computational Logic, School of Artif. Intel., U. of Edinburgh, Edinburgh, </institution> <year> 1973. </year>
Reference-contexts: The program uses only its knowledge of the LISP primitives and the LISP definitions supplied by the user. No further information is required of the user. This paper describes many aspects of the program in brevity. A thorough presentation can be found in <ref> [22] </ref>. 2 Our LISP Subset We use a subset of pure LISP [18] which has as primitives NIL, CONS, CAR, CDR, COND, and EQUAL.
Reference: 23. <author> Naur, P. </author> <title> Proof of algorithms by general snapshots. </title> <booktitle> BIT 6 (1966), </booktitle> <pages> 310-316. </pages>
Reference-contexts: Milner, 1972 [20] and Milner and Weyhrauch, 1972 [21] describe a proof checker for Scott's Logic for Computable Functions (Scott, 1970 [25]) which uses computational induction. The most commonly used method is for flow diagram languages and was suggested by Naur, 1966 <ref> [23] </ref> and Floyd, 1967 [10]. In this approach, inductive assertions are attached to points in a program and are used to generate "verification conditions," which are theorems that must be proved to establish the correctness of the program.
Reference: 24. <author> Park, D. </author> <title> Fixpoint induction and proofs of program properties. </title> <booktitle> In Ma--chine Intelligence 5, </booktitle> <editor> B. Meltzer and D. Michie, Eds., </editor> <publisher> Edinburgh U. Press, Edinburgh, </publisher> <year> 1969, </year> <pages> pp. 59-78. </pages>
Reference-contexts: Our program uses structural induction, which was introduced into the literature by Burstall, 1969 [4], although it was used earlier by McCarthy and Painter, 1967 [19] in a compiler correctness proof. Common alternative inductive methods for recursive languages are computational induction (Park, 1969 <ref> [24] </ref>) and recursion induction (McCarthy, 1963 [17]). Both are essentially induction on the depth of function calls. Milner, 1972 [20] and Milner and Weyhrauch, 1972 [21] describe a proof checker for Scott's Logic for Computable Functions (Scott, 1970 [25]) which uses computational induction.
Reference: 25. <author> Scott, D. </author> <title> Outline of a Mathematical Theory of Computation. </title> <type> Tech. </type> <institution> Monograph PRG-2, Programming Res. Group, Oxford U. Computing Lab., </institution> <month> Nov. </month> <year> 1970. </year>
Reference-contexts: Both are essentially induction on the depth of function calls. Milner, 1972 [20] and Milner and Weyhrauch, 1972 [21] describe a proof checker for Scott's Logic for Computable Functions (Scott, 1970 <ref> [25] </ref>) which uses computational induction. The most commonly used method is for flow diagram languages and was suggested by Naur, 1966 [23] and Floyd, 1967 [10].
Reference: 26. <author> Topor, R., and Burstall, R. M. </author> <title> Private communication (1973). </title>
Reference-contexts: King 1969 [15], Good, 1970 [12], Cooper, 1971 [5], Gerhart, 1972 [11], Deutsch, 1973 [7], Igarashi, London, and Luckham, 1973 [13], Elspas, Levitt, and Waldinger, 1973 [9], and Topor and Burstall, 1973 <ref> [26] </ref> have implemented systems which use this method for languages which include assignments (possibly to arrays), jumps or loops, and defined procedure calls. These programs require the user to invent inductive assertions.
Reference: 27. <author> Wegbreit, B. </author> <title> The synthesis of loop predicates. </title> <journal> Comm. </journal> <note> ACM 17, 2(Feb. 1974),102-112. received september 1993; revised april 1994 22 </note>
Reference-contexts: These programs require the user to invent inductive assertions. Elspas, 1972 [8], Wegbreit, 1973 <ref> [27] </ref>, and Katz and Manna, 1973 [14] present heuristics for generating inductive assertions automatically. Darlington and Burstall, 1973 [6] describe a system which will take functions such as the ones in our LISP subset and write equivalent programs which are more efficient.
References-found: 27

