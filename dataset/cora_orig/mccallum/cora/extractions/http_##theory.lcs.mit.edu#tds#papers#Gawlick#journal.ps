URL: http://theory.lcs.mit.edu/tds/papers/Gawlick/journal.ps
Refering-URL: http://theory.lcs.mit.edu/tds/papers/Gawlick/journal.html
Root-URL: 
Title: Liveness in Timed and Untimed Systems  
Author: Roberto Segala Rainer Gawlick Jtrgen Stgaard-Andersen Nancy Lynch 
Keyword: Automata, timed automata, I/O automata, liveness, receptiveness, formal verification, simulation techniques.  
Address: Denmark, DK-2800 Lyngby, Denmark.  545 Technology Square, Cam bridge, MA 02139.  
Affiliation: Department of Computer Science, University of Bologna, Italy. Laboratory for Computer Science, Massachusetts Institute of Technology and McKinsey Co. Department of Computer Science, Technical University of  Laboratory for Computer Science, Massachusetts Institute of Technology,  
Note: Supported by NSF grant CCR-89-15206, by DARPA contracts N00014-89-J-1988 and N00014-92-J-4033, by ONR contract N00014-91-J-1046, and by ARPA contract F19628-95-C-0118. Also supported in part at the Technical University of Denmark by the Danish Technical Research Council.  
Abstract: When proving the correctness of algorithms in distributed systems, one generally considers safety conditions and liveness conditions. The Input/Output (I/O) automaton model and its timed version have been used successfully, but have focused on safety conditions and on a restricted form of liveness called fairness. In this paper we develop a new I/O automaton model, and a new timed I/O automaton model, that permit the verification of general liveness properties on the basis of existing verification techniques. Our models include a notion of receptiveness which extends the idea of receptiveness of other existing formalisms, and enables the use of compositional verification techniques. The presentation includes an embedding of the untimed model into the timed model which preserves all the interesting attributes of the untimed model. Thus, our models constitute a coordinated framework for the description of concurrent and distributed systems satisfying general liveness properties. 
Abstract-found: 1
Intro-found: 1
Reference: [AL91a] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 2(82) </volume> <pages> 253-284, </pages> <year> 1991. </year>
Reference-contexts: The framework is intended to support a variety of verification techniques, including simulation methods, compositional reasoning, algebraic methods, and temporal logic methods. A successful technique for the verification of safety properties and some special liveness properties is based on the simulation method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref>, applied to the Input/Output automaton model of [LT87] and to its generalization to the timed case [MMT91]. I/O automata are state machines with a labeled transition relation where the labels, also called actions , model communication. <p> Due to the close connection between environment-freedom in our untimed model and receptiveness in other existing models, we have uniformed our terminology to the existing literature. 2 others, our models support the simulation based proof method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref>. In [GSSL93] we show how the simulation based proof method can be used to handle liveness by means of an Execution Correspondence Theorem, which extracts from a simulation relation more information than just trace inclusion. <p> A key aspect of the models is the notion of receptiveness, which expresses the fact that a live (timed) I/O automaton does not constrain its environment. Moreover, [GSSL93] extends the simulation method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref> to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in [SLL93b, SLL93a].
Reference: [AL91b] <author> M. Abadi and L. Lamport. </author> <title> An old-fashioned recipe for real time. </title> <editor> In de Bakker et al. </editor> <booktitle> [dBHRR91], </booktitle> <pages> pages 1-27. 49 </pages>
Reference-contexts: Moreover, the work in [SLL93b, SLL93a] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. The mutual exclusion algorithm of Fischer <ref> [Fis85, AL91b] </ref> is another instance of a timed implementation for an untimed specification. <p> Receptiveness also implies feasibility as defined in [LS89]. The failure free complete trace structures of [Dil88] are also properly generalized by our model. In the timed case, our model generalizes [MMT91] and the notion of strong I/O feasibility introduced in [VL92]. Finally, in contrast to <ref> [AL91b] </ref>, our timed model does not give either the system or the environment control over the passage of time. We believe that our coordinated untimed and timed models comprise a good general framework for verification of concurrent systems. <p> The presentation of both the untimed and timed models starts with a general automaton model with liveness conditions in the style of <ref> [AL91b] </ref>; then the I/O distinction is introduced together with the receptiveness property and the proof of compositionality. <p> In [GSSL93] simulation based proof techniques are extended to live preorder, and in [SLL93b] the new proof techniques are used to verify nontrivial communication protocols. 4.6 Comparison with Other Timed Models This section compares our timed model with the work of <ref> [AL91b, MMT91, VL92] </ref>. The formalism that is used in [AL91b] is the Temporal Logic of Actions (TLA) [Lam91] extended with a new variable now that models time. <p> The formalism that is used in <ref> [AL91b] </ref> is the Temporal Logic of Actions (TLA) [Lam91] extended with a new variable now that models time. A specification S consists of the conjunction of three formulas Init ^ ^ L where Init represents the initial configurations of S, is a safety property, and L is a liveness property. <p> The subformula Init ^ corresponds to our safe timed I/O automata, while the subformula L corresponds to our timed liveness conditions. In <ref> [AL91b] </ref> L can also be satisfied by finite or Zeno executions or by executions that do not satisfy Init ^ . The formula L is a liveness condition for Init ^ based on our definition iff the pair (Init ^ ; L) is machine-closed based on the definition in [AL91b]. <p> In <ref> [AL91b] </ref> L can also be satisfied by finite or Zeno executions or by executions that do not satisfy Init ^ . The formula L is a liveness condition for Init ^ based on our definition iff the pair (Init ^ ; L) is machine-closed based on the definition in [AL91b]. There is a special formula NZ in [AL91b] that is used to express non-Zenoness, i.e., that time advances forever. Time blocking or Zeno behaviors are undesirable in [AL91b] as well as in our model; however, it is possible for the safety part of a specification to describe systems for 38 <p> The formula L is a liveness condition for Init ^ based on our definition iff the pair (Init ^ ; L) is machine-closed based on the definition in <ref> [AL91b] </ref>. There is a special formula NZ in [AL91b] that is used to express non-Zenoness, i.e., that time advances forever. Time blocking or Zeno behaviors are undesirable in [AL91b] as well as in our model; however, it is possible for the safety part of a specification to describe systems for 38 which time cannot advance past a given upper <p> condition for Init ^ based on our definition iff the pair (Init ^ ; L) is machine-closed based on the definition in <ref> [AL91b] </ref>. There is a special formula NZ in [AL91b] that is used to express non-Zenoness, i.e., that time advances forever. Time blocking or Zeno behaviors are undesirable in [AL91b] as well as in our model; however, it is possible for the safety part of a specification to describe systems for 38 which time cannot advance past a given upper bound whenever a particular state is reached. Such a situation is eliminated in [AL91b] by requiring the pair (; NZ <p> or Zeno behaviors are undesirable in <ref> [AL91b] </ref> as well as in our model; however, it is possible for the safety part of a specification to describe systems for 38 which time cannot advance past a given upper bound whenever a particular state is reached. Such a situation is eliminated in [AL91b] by requiring the pair (; NZ ) to be machine-closed. <p> A major difference between our notion of receptiveness and the notion of receptiveness of <ref> [AL91b] </ref> is in the role of time: in our model no one is allowed to have control over time; in [AL91b] either the system or its environment must have control over time. We believe that it is more reasonable to assume that no one has control over time. <p> A major difference between our notion of receptiveness and the notion of receptiveness of <ref> [AL91b] </ref> is in the role of time: in our model no one is allowed to have control over time; in [AL91b] either the system or its environment must have control over time. We believe that it is more reasonable to assume that no one has control over time. The model of [MMT91] is an extension to the timed model of the I/O automaton model of [LT87]. <p> For example, [SLL93a] shows how an untimed specification (of the at-most-once message delivery problem) is implemented by a system that assumes upper time bounds on certain process steps and channel delays. Fischer's mutual exclusion algorithm <ref> [Fis85, AL91b] </ref> is another such example. Figure 1 depicts the stepwise development one would use for an implementation proof like the one in [SLL93a]. The stepwise development in Figure 1, however, raises the issue of what it means to implement an untimed specification with a timed implementation. <p> We recognize this objection and regard the generalization of the model as future work. In fact, our model is closer to the classical models of the process algebraic community (e.g., labeled transition systems) than the models of <ref> [AL93, AL91b] </ref>, and thus may represent a natural starting point for possible generalizations. Some promising results come from [Seg93], which shows that there is a strong connection between the trace semantics of I/O automata and the must preorder of the theory of testing [DH84].
Reference: [AL93] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <year> 1993. </year>
Reference-contexts: This motivates a generalization of the I/O automaton model and its timed version to handle general liveness properties in such a way that the simulation based proof method still applies. 1 A simple and natural generalization is motivated by <ref> [AL93] </ref>, which models a machine as a pair (A; L) consisting of an automaton and A and a subset L of its behaviors satisfying the desired liveness property. The implementation notion can then be expressed by live trace inclusion just as fair trace inclusion expresses implementation for I/O automata. <p> The liveness properties of a system [AS85], i.e., what must eventually happen, can be expressed by a subset L of the executions of its safe part A, as proposed in <ref> [AL93] </ref>. Thus, informally, a live automaton is a pair (A; L) where A is an automaton and L is a subset of its executions. The executions of L, which satisfy both the safety and liveness requirements of (A; L), are the only ones that can occur in the described system. <p> Our restriction on the pair (A; L) implies that the pair (exec (A); L) is machine-closed as defined in <ref> [AL93] </ref>. <p> Some of the problems arising from the requirement that a live I/O automaton should behave properly independently of the inputs provided by its environment are addressed in <ref> [Dil88, AL93] </ref>. Their solutions lead to the notion of receptiveness . Intuitively a system is receptive if it behaves properly independently of the inputs provided by its environment, or equivalently, if it does not constrain its environment. <p> Example 3.4 shows that the simpler definition thus gives the system too much power for parallel composition to be closed. 3.5 Preorder Relations for Live I/O Automata In <ref> [LT87, Dil88, AL93] </ref> the notion of implementation is expressed through some form of trace inclusion. Similar notions of implementation can be defined on live I/O automata. <p> The conformation preorder of [Dil88], which expresses the notion of implementation for complete trace structures, coincides with the live preorder when dealing with failure free complete trace structures. Finally, the notion of implementation of <ref> [AL93] </ref>, which works in a state based model, coincides with the live preorder up to a different notion of traces arising from the state structure of the model. In [AL93], a system M 1 implements a system M 2 iff the set of "traces" of the realizable part of M 1 <p> Finally, the notion of implementation of <ref> [AL93] </ref>, which works in a state based model, coincides with the live preorder up to a different notion of traces arising from the state structure of the model. In [AL93], a system M 1 implements a system M 2 iff the set of "traces" of the realizable part of M 1 is a subset of the set of "traces" of the realizable part of M 2 . <p> Furthermore, if a system M is receptive, then M is equal to its realizable part. Thus, for receptive systems, the implementation notion of <ref> [AL93] </ref> is just the live trace preorder. The reader is referred to Section 3.6 for more discussion of realizability. Note that the live preorder implies the safe preorder whenever the involved automata have finite internal nondeterminism. <p> This in turn causes the substitutivity of the parallel composition operator to fail. There are several ways to justify the live preorder as an adequate notion of implementation for live I/O automata. Since the live preorder captures the implementation notions of <ref> [LT87, 17 Dil88, AL93] </ref> it can rest on the justifications provided for these implementation notions. For example, the fair preorder of [LT87] is justified by two observations. First, the fact that I/O automata are input-enabled guarantees that a system must respond to any environment. <p> In [GSSL93] simulation based proof techniques are extended to the live preorder, and in [SLL93b] the new proof techniques are used to verify nontrivial communication protocols. 3.6 Comparison with Other Models This section compares our model with the models of <ref> [Dil88, LT87, AL93] </ref> and the work of [RWZ92]. The model of complete trace structures of [Dil88] is a special case of our model. <p> Thus [LT87] can only express some special cases of our general liveness conditions. The model of <ref> [AL93] </ref> is based on unlabeled state transition systems and is suitable for the modeling of shared memory systems. An action in [AL93] is identified with a set of transitions, and transitions are partitioned into environment transitions and system transitions. <p> Thus [LT87] can only express some special cases of our general liveness conditions. The model of <ref> [AL93] </ref> is based on unlabeled state transition systems and is suitable for the modeling of shared memory systems. An action in [AL93] is identified with a set of transitions, and transitions are partitioned into environment transitions and system transitions. The environment moves by performing an arbitrary finite number of environment transitions and the system responds by performing zero or one system transitions. <p> The environment moves by performing an arbitrary finite number of environment transitions and the system responds by performing zero or one system transitions. Function g is not necessary in a strategy for a system of <ref> [AL93] </ref> since the environment chooses the next shared state in its move and does not modify the internal state. Function f chooses a new transition based on the past history of the system. <p> Function f chooses a new transition based on the past history of the system. In this paper we have defined receptiveness by requiring the existence of a strategy that can "win the game" after any finite execution ff. In <ref> [AL93] </ref> a weaker property called realizability is considered, where the requirement is the existence of a strategy that can win starting from any start state. The realizable part of a system of [AL93] is the set of behaviors that can be the outcome of some strategy. <p> In <ref> [AL93] </ref> a weaker property called realizability is considered, where the requirement is the existence of a strategy that can win starting from any start state. The realizable part of a system of [AL93] is the set of behaviors that can be the outcome of some strategy. A system that coincides with its realizable part is called receptive. The notion of receptiveness of [AL93] corresponds to our notion of receptiveness, as can be derived easily from Proposition 9 of [AL93]. <p> The realizable part of a system of <ref> [AL93] </ref> is the set of behaviors that can be the outcome of some strategy. A system that coincides with its realizable part is called receptive. The notion of receptiveness of [AL93] corresponds to our notion of receptiveness, as can be derived easily from Proposition 9 of [AL93]. Example 3.2 shows a live automaton (A; L) which is not receptive. <p> of a system of <ref> [AL93] </ref> is the set of behaviors that can be the outcome of some strategy. A system that coincides with its realizable part is called receptive. The notion of receptiveness of [AL93] corresponds to our notion of receptiveness, as can be derived easily from Proposition 9 of [AL93]. Example 3.2 shows a live automaton (A; L) which is not receptive. However, (A; L) is realizable, and (A 0 ; L 0 ), which is defined in the same example, is the realizable part of (A; L). In [AL93] systems are compared based on their realizable parts. <p> receptiveness, as can be derived easily from Proposition 9 of <ref> [AL93] </ref>. Example 3.2 shows a live automaton (A; L) which is not receptive. However, (A; L) is realizable, and (A 0 ; L 0 ), which is defined in the same example, is the realizable part of (A; L). In [AL93] systems are compared based on their realizable parts. Thus, it is necessary to determine the realizable part of a system before its safety properties can be determined, and for this reason realizable systems are closed under parallel composition in [AL93]. <p> In <ref> [AL93] </ref> systems are compared based on their realizable parts. Thus, it is necessary to determine the realizable part of a system before its safety properties can be determined, and for this reason realizable systems are closed under parallel composition in [AL93]. In other words, L can add new safety properties to A. However, later in [AL93] a notion of machine-realizability is introduced which separates safety and liveness properties and requires receptiveness just like our live I/O automata. <p> Thus, it is necessary to determine the realizable part of a system before its safety properties can be determined, and for this reason realizable systems are closed under parallel composition in <ref> [AL93] </ref>. In other words, L can add new safety properties to A. However, later in [AL93] a notion of machine-realizability is introduced which separates safety and liveness properties and requires receptiveness just like our live I/O automata. <p> We recognize this objection and regard the generalization of the model as future work. In fact, our model is closer to the classical models of the process algebraic community (e.g., labeled transition systems) than the models of <ref> [AL93, AL91b] </ref>, and thus may represent a natural starting point for possible generalizations. Some promising results come from [Seg93], which shows that there is a strong connection between the trace semantics of I/O automata and the must preorder of the theory of testing [DH84].
Reference: [AS85] <author> B. Alpern and F.B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21(4) </volume> <pages> 181-185, </pages> <year> 1985. </year>
Reference-contexts: Particularly important are formalisms that can model distributed and concurrent systems and those that can model real time systems, i.e., systems that rely on time constraints in order to guarantee correct behavior. Formalisms should be able to support verification of both safety and liveness properties <ref> [AS85] </ref>. Roughly speaking, a liveness property specifies that certain desirable events will eventually occur, while a safety property specifies that undesirable events will never occur. In this paper, we present a coordinated framework that permits modeling and verification of safety and liveness properties for both timed and untimed systems. <p> Note, that a finite trace might be the trace of an infinite execution. 4 3.2 Live Automata The automaton A of Definition 3.1 can be thought of as expressing the safety properties of a system <ref> [AS85] </ref>, i.e, what always holds, or equivalently what is never supposed to happen. The liveness properties of a system [AS85], i.e., what must eventually happen, can be expressed by a subset L of the executions of its safe part A, as proposed in [AL93]. <p> trace might be the trace of an infinite execution. 4 3.2 Live Automata The automaton A of Definition 3.1 can be thought of as expressing the safety properties of a system <ref> [AS85] </ref>, i.e, what always holds, or equivalently what is never supposed to happen. The liveness properties of a system [AS85], i.e., what must eventually happen, can be expressed by a subset L of the executions of its safe part A, as proposed in [AL93]. Thus, informally, a live automaton is a pair (A; L) where A is an automaton and L is a subset of its executions.
Reference: [BG91] <editor> J.C.M. Baeten and J.F. Groote, editors. </editor> <booktitle> Proceedings of CONCUR 91, Amsterdam, volume 527 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [BPV94] <author> D.J.B. Bosscher, I. Polak, and F.W. Vaandrager. </author> <title> Verification of an audio control protocol. </title> <editor> In Langmaack, de Roever, and Vytopil, editors, </editor> <booktitle> Proceedings of the Symposium on Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 863 of Lecture Notes in Computer Science, </booktitle> <pages> pages 170-192, </pages> <year> 1994. </year> <note> Full version available as Report CS-R9445, </note> <institution> CWI, </institution> <address> Amsterdam, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: Furthermore, any patient construction over a live I/O automaton leads to a receptive pair. A more general sufficient condition for receptiveness is given in <ref> [BPV94] </ref>, where 2 The kernel of a preorder v is defined to be the equivalence defined by x y 4 48 linear hybrid systems are introduced as a basic model for the study of an audio control proto-col.
Reference: [Cle92] <editor> W.R. Cleaveland, editor. </editor> <booktitle> Proceedings of CONCUR 92, </booktitle> <address> Stony Brook, NY, USA, </address> <booktitle> volume 630 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [dBHRR91] <editor> J.W. de Bakker, C. Huizing, W.P. de Roever, and G. Rozenberg, editors. </editor> <booktitle> Proceedings of the REX Workshop "Real-Time: Theory in Practice", volume 600 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [DH84] <author> R. De Nicola and M. Hennessy. </author> <title> Testing equivalences for processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 83-133, </pages> <year> 1984. </year>
Reference-contexts: Some promising results come from [Seg93], which shows that there is a strong connection between the trace semantics of I/O automata and the must preorder of the theory of testing <ref> [DH84] </ref>. Another line of research consists of extending the current model to handle systems with probabilistic behaviors. The ultimate goal would be a model where probabilistic behaviors, timing constraints, safety properties, and liveness properties can be integrated together.
Reference: [Dil88] <author> D. Dill. </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-Independent Circuits. </title> <publisher> ACM Distinguished Dissertations. MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: The restrictions on L are given by a property called receptiveness 1 , which captures the intuitive idea that a live (timed) I/O automaton must not constrain its environment. The receptiveness property is defined, using ideas from <ref> [Dil88] </ref>, by means of a two-person game between a live (timed) I/O automaton and its environment. Specifically, the environment provides arbitrary inputs while the system tries to react so that it behaves according to its liveness condition. <p> Our models generalize several existing models. The fairness condition of I/O automata satisfies the receptiveness property; thus, live I/O automata are a proper generalization of I/O automata. Receptiveness also implies feasibility as defined in [LS89]. The failure free complete trace structures of <ref> [Dil88] </ref> are also properly generalized by our model. In the timed case, our model generalizes [MMT91] and the notion of strong I/O feasibility introduced in [VL92]. Finally, in contrast to [AL91b], our timed model does not give either the system or the environment control over the passage of time. <p> Some of the problems arising from the requirement that a live I/O automaton should behave properly independently of the inputs provided by its environment are addressed in <ref> [Dil88, AL93] </ref>. Their solutions lead to the notion of receptiveness . Intuitively a system is receptive if it behaves properly independently of the inputs provided by its environment, or equivalently, if it does not constrain its environment. <p> Example 3.4 shows that the simpler definition thus gives the system too much power for parallel composition to be closed. 3.5 Preorder Relations for Live I/O Automata In <ref> [LT87, Dil88, AL93] </ref> the notion of implementation is expressed through some form of trace inclusion. Similar notions of implementation can be defined on live I/O automata. <p> In particular, the live preorder coincides with the fair preorder if, for each live I/O automaton (A; L), L is chosen to be the set of fair executions of A. The conformation preorder of <ref> [Dil88] </ref>, which expresses the notion of implementation for complete trace structures, coincides with the live preorder when dealing with failure free complete trace structures. <p> In [GSSL93] simulation based proof techniques are extended to the live preorder, and in [SLL93b] the new proof techniques are used to verify nontrivial communication protocols. 3.6 Comparison with Other Models This section compares our model with the models of <ref> [Dil88, LT87, AL93] </ref> and the work of [RWZ92]. The model of complete trace structures of [Dil88] is a special case of our model. <p> The model of complete trace structures of <ref> [Dil88] </ref> is a special case of our model. Specifically, the model of [Dil88] does not include a state structure, so that the safe part of a live automaton in [Dil88] is given by a set of traces. <p> The model of complete trace structures of <ref> [Dil88] </ref> is a special case of our model. Specifically, the model of [Dil88] does not include a state structure, so that the safe part of a live automaton in [Dil88] is given by a set of traces. <p> The model of complete trace structures of <ref> [Dil88] </ref> is a special case of our model. Specifically, the model of [Dil88] does not include a state structure, so that the safe part of a live automaton in [Dil88] is given by a set of traces. <p> By ignoring the state structure of a system, the model in <ref> [Dil88] </ref> may erroneously view as receptive a state machine that is not receptive based on our model since its traces may be receptive. Thus, complete trace structures are not adequate whenever the state structure of a system is important. <p> A substantial verification project using the model appears in [SLL93b, SLL93a]. In addition to generalizing the I/O automaton model [LT87] and its timed version [MMT91], our model generalizes the failure free complete trace structures of <ref> [Dil88] </ref> and the strong I/O feasibility notion of [VL92]. People familiar with process algebras might object to our model, arguing that receptiveness is too restrictive since it rules out several systems that might be of interest at a high level of abstraction.
Reference: [Fis85] <author> M. Fischer. Re: </author> <title> Where are you? E-mail message to Leslie Lamport. Arpanet message number 8506252257.AA07636@YALE-BULLDOG.YALE/ARPA (47 lines), </title> <month> June 25 </month> <year> 1985. </year>
Reference-contexts: Moreover, the work in [SLL93b, SLL93a] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. The mutual exclusion algorithm of Fischer <ref> [Fis85, AL91b] </ref> is another instance of a timed implementation for an untimed specification. <p> For example, [SLL93a] shows how an untimed specification (of the at-most-once message delivery problem) is implemented by a system that assumes upper time bounds on certain process steps and channel delays. Fischer's mutual exclusion algorithm <ref> [Fis85, AL91b] </ref> is another such example. Figure 1 depicts the stepwise development one would use for an implementation proof like the one in [SLL93a]. The stepwise development in Figure 1, however, raises the issue of what it means to implement an untimed specification with a timed implementation.
Reference: [GSSL93] <author> R. Gawlick, R. Segala, J.F. Stgaard-Andersen, and N.A. Lynch. </author> <title> Liveness in timed and untimed systems. </title> <type> Technical Report MIT/LCS/TR-587, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: We believe that our coordinated untimed and timed models comprise a good general framework for verification of concurrent systems. Besides the fact that our models generalize several 1 In our original work <ref> [GSSL93, GSSL94] </ref> we used the term environment-freedom. Due to the close connection between environment-freedom in our untimed model and receptiveness in other existing models, we have uniformed our terminology to the existing literature. 2 others, our models support the simulation based proof method of [AL91a, LV91, LV93, LV95, Jon91]. <p> Due to the close connection between environment-freedom in our untimed model and receptiveness in other existing models, we have uniformed our terminology to the existing literature. 2 others, our models support the simulation based proof method of [AL91a, LV91, LV93, LV95, Jon91]. In <ref> [GSSL93] </ref> we show how the simulation based proof method can be used to handle liveness by means of an Execution Correspondence Theorem, which extracts from a simulation relation more information than just trace inclusion. <p> Our models have already been used in [SLL93b, SLL93a] to verify a non-trivial communication protocol used in the Internet, and the verifications require all the new expressiveness provided in this paper and the simulation tools provided in <ref> [GSSL93] </ref>. After some preliminary definitions, given in Section 2, the paper is divided into three main sections. Section 3 presents the untimed model, Section 4 presents the timed model, and Section 5 embeds the untimed model into the timed model by means of the patient operator. <p> If the involved systems have finite internal nondeterminism, then the live preorder implies the safe preorder. Thus the live preorder guarantees both safety and liveness properties. It is well known that simulation based proof techniques [LV93] can be used for implementation notions based on trace inclusion. In <ref> [GSSL93] </ref> simulation based proof techniques are extended to the live preorder, and in [SLL93b] the new proof techniques are used to verify nontrivial communication protocols. 3.6 Comparison with Other Models This section compares our model with the models of [Dil88, LT87, AL93] and the work of [RWZ92]. <p> It is well known that simulation based proof techniques [LV91, LV95] can be used for imple mentation notions based on trace inclusion. In <ref> [GSSL93] </ref> simulation based proof techniques are extended to live preorder, and in [SLL93b] the new proof techniques are used to verify nontrivial communication protocols. 4.6 Comparison with Other Timed Models This section compares our timed model with the work of [AL91b, MMT91, VL92]. <p> A key aspect of the models is the notion of receptiveness, which expresses the fact that a live (timed) I/O automaton does not constrain its environment. Moreover, <ref> [GSSL93] </ref> extends the simulation method of [AL91a, LV91, LV93, LV95, Jon91] to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in [SLL93b, SLL93a].
Reference: [GSSL94] <author> R. Gawlick, R. Segala, J.F. Stgaard-Andersen, and N.A. Lynch. </author> <title> Liveness in timed and un-timed systems. </title> <editor> In S. Abiteboul and E. Shamir, editors, </editor> <booktitle> Proceedings 21 th ICALP, Jerusalem, volume 820 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> A full version appears as MIT Technical Report number MIT/LCS/TR-587. </note>
Reference-contexts: We believe that our coordinated untimed and timed models comprise a good general framework for verification of concurrent systems. Besides the fact that our models generalize several 1 In our original work <ref> [GSSL93, GSSL94] </ref> we used the term environment-freedom. Due to the close connection between environment-freedom in our untimed model and receptiveness in other existing models, we have uniformed our terminology to the existing literature. 2 others, our models support the simulation based proof method of [AL91a, LV91, LV93, LV95, Jon91].
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Engle-wood Cliffs, </address> <year> 1985. </year>
Reference-contexts: Thus, local (A) = int (A) [ out (A). The interaction between safe I/O automata is specified by the parallel composition operator. We use the synchronization style of <ref> [Hoa85, LT87] </ref>, where automata synchronize on their common actions and evolve independently on the others. We also retain the constraint of [LT87] that each action is under the control of at most one automaton by defining parallel composition only for compatible safe I/O automata.
Reference: [Jon91] <author> B. Jonsson. </author> <title> Simulations between specifications of distributed systems. </title> <booktitle> In Baeten and Groote [BG91], </booktitle> <pages> pages 346-360. </pages>
Reference-contexts: The framework is intended to support a variety of verification techniques, including simulation methods, compositional reasoning, algebraic methods, and temporal logic methods. A successful technique for the verification of safety properties and some special liveness properties is based on the simulation method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref>, applied to the Input/Output automaton model of [LT87] and to its generalization to the timed case [MMT91]. I/O automata are state machines with a labeled transition relation where the labels, also called actions , model communication. <p> Due to the close connection between environment-freedom in our untimed model and receptiveness in other existing models, we have uniformed our terminology to the existing literature. 2 others, our models support the simulation based proof method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref>. In [GSSL93] we show how the simulation based proof method can be used to handle liveness by means of an Execution Correspondence Theorem, which extracts from a simulation relation more information than just trace inclusion. <p> A key aspect of the models is the notion of receptiveness, which expresses the fact that a live (timed) I/O automaton does not constrain its environment. Moreover, [GSSL93] extends the simulation method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref> to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in [SLL93b, SLL93a].
Reference: [Lam91] <author> L. Lamport. </author> <title> The temporal logic of actions. </title> <type> Technical Report 79, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: The formalism that is used in [AL91b] is the Temporal Logic of Actions (TLA) <ref> [Lam91] </ref> extended with a new variable now that models time. A specification S consists of the conjunction of three formulas Init ^ ^ L where Init represents the initial configurations of S, is a safety property, and L is a liveness property.
Reference: [LS89] <author> N.A. Lynch and E.W. Stark. </author> <title> A proof of the Kahn principle for Input/Output automata. </title> <journal> Information and Computation, </journal> <volume> 82(1) </volume> <pages> 81-92, </pages> <year> 1989. </year>
Reference-contexts: Our models generalize several existing models. The fairness condition of I/O automata satisfies the receptiveness property; thus, live I/O automata are a proper generalization of I/O automata. Receptiveness also implies feasibility as defined in <ref> [LS89] </ref>. The failure free complete trace structures of [Dil88] are also properly generalized by our model. In the timed case, our model generalizes [MMT91] and the notion of strong I/O feasibility introduced in [VL92]. <p> Example 3.4 also exposes the flaw in a simpler and more intuitive definition for receptiveness we originally considered for this paper. The simpler definition, which is a natural generalization of the fairness condition of [LT87] and is also discussed in <ref> [LS89] </ref>, states that "a pair (A; L) is receptive if for each finite execution ff of A and each (finite or infinite) sequence fi of input actions there is an execution fragment ff 0 of A such that ff 0 din (A) = fi and ff a ff 0 2 L."
Reference: [LT87] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the 6 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <address> Vancouver, Canada, </address> <month> August </month> <year> 1987. </year> <note> A full version is available as MIT Technical Report MIT/LCS/TR-387. 50 </note>
Reference-contexts: A successful technique for the verification of safety properties and some special liveness properties is based on the simulation method of [AL91a, LV91, LV93, LV95, Jon91], applied to the Input/Output automaton model of <ref> [LT87] </ref> and to its generalization to the timed case [MMT91]. I/O automata are state machines with a labeled transition relation where the labels, also called actions , model communication. <p> Section 3.5 defines two preorder relations, the safe preorder and the live preorder, and shows in what sense the live preorder can express a notion of implementation. Section 3.6 compares our model with existing work. 3 3.1 Automata We define automata using the presentation style of <ref> [LT87] </ref>. Essentially, an automaton is a labeled transition system [Plo81]. <p> In a physical system this is ensured by executing the two processes on separate processors or by using a fair scheduler in a multiprogramming environment. The notion of fairness of I/O automata <ref> [LT87] </ref> exactly captures this particular physical assumption. Second, a liveness condition can be used to specify additional properties that a system is required to satisfy. For example, in a mutual exclusion problem we may require a process to eventually exit the critical region whenever it enters it. <p> can express many specific intuitive ideas, for the purpose of this paper a liveness condition simply represents the set of executions that a system can exhibit whenever it is "working properly". 3.3 Safe I/O Automata Our notion of safe I/O automaton is the same as the "unfair" I/O automaton of <ref> [LT87] </ref>, i.e., the automaton obtained by removing the partition of the locally-controlled actions from an I/O automaton of [LT87]. 5 Definition 3.3 (Safe I/O automaton) A safe I/O automaton A is an automaton aug-mented with an external action signature, esig (A) = (in (A); out (A)), which partitions ext (A) into <p> set of executions that a system can exhibit whenever it is "working properly". 3.3 Safe I/O Automata Our notion of safe I/O automaton is the same as the "unfair" I/O automaton of <ref> [LT87] </ref>, i.e., the automaton obtained by removing the partition of the locally-controlled actions from an I/O automaton of [LT87]. 5 Definition 3.3 (Safe I/O automaton) A safe I/O automaton A is an automaton aug-mented with an external action signature, esig (A) = (in (A); out (A)), which partitions ext (A) into input and output actions. In each state, each input action must be enabled. <p> Thus, local (A) = int (A) [ out (A). The interaction between safe I/O automata is specified by the parallel composition operator. We use the synchronization style of <ref> [Hoa85, LT87] </ref>, where automata synchronize on their common actions and evolve independently on the others. We also retain the constraint of [LT87] that each action is under the control of at most one automaton by defining parallel composition only for compatible safe I/O automata. <p> Thus, local (A) = int (A) [ out (A). The interaction between safe I/O automata is specified by the parallel composition operator. We use the synchronization style of [Hoa85, LT87], where automata synchronize on their common actions and evolve independently on the others. We also retain the constraint of <ref> [LT87] </ref> that each action is under the control of at most one automaton by defining parallel composition only for compatible safe I/O automata. Compatibility requires that each action be an output action of at most one safe I/O automaton. <p> Proof. Direct consequence of Corollary 8 of <ref> [LT87] </ref>. Parallel composition is typically used to build complex systems based on simpler components. Two other operators are defined and used for I/O automata: hiding, which transforms some output actions into internal actions, and renaming, which changes the name to some actions. <p> Example 3.4 also exposes the flaw in a simpler and more intuitive definition for receptiveness we originally considered for this paper. The simpler definition, which is a natural generalization of the fairness condition of <ref> [LT87] </ref> and is also discussed in [LS89], states that "a pair (A; L) is receptive if for each finite execution ff of A and each (finite or infinite) sequence fi of input actions there is an execution fragment ff 0 of A such that ff 0 din (A) = fi and <p> Example 3.4 shows that the simpler definition thus gives the system too much power for parallel composition to be closed. 3.5 Preorder Relations for Live I/O Automata In <ref> [LT87, Dil88, AL93] </ref> the notion of implementation is expressed through some form of trace inclusion. Similar notions of implementation can be defined on live I/O automata. <p> The safe preorder is the same as the unfair preorder of I/O automata <ref> [LT87] </ref>, while the live preorder is a generalization of the fair preorder of [LT87]. In particular, the live preorder coincides with the fair preorder if, for each live I/O automaton (A; L), L is chosen to be the set of fair executions of A. <p> The safe preorder is the same as the unfair preorder of I/O automata <ref> [LT87] </ref>, while the live preorder is a generalization of the fair preorder of [LT87]. In particular, the live preorder coincides with the fair preorder if, for each live I/O automaton (A; L), L is chosen to be the set of fair executions of A. <p> The substitutivity results for the safe trace preorder are already proven in <ref> [LT87] </ref>. The substitutivity results for the live trace preorder follow directly from the definition of the parallel composition operator after observing, as it is proved in Corollary 8 of [LT87], that parallel composition of execution sets preserves trace equivalence. <p> The substitutivity results for the safe trace preorder are already proven in <ref> [LT87] </ref>. The substitutivity results for the live trace preorder follow directly from the definition of the parallel composition operator after observing, as it is proved in Corollary 8 of [LT87], that parallel composition of execution sets preserves trace equivalence. The following example shows that the absence of receptiveness can lead to situations where the substitutivity result of Theorem 3.21 breaks. <p> This in turn causes the substitutivity of the parallel composition operator to fail. There are several ways to justify the live preorder as an adequate notion of implementation for live I/O automata. Since the live preorder captures the implementation notions of <ref> [LT87, 17 Dil88, AL93] </ref> it can rest on the justifications provided for these implementation notions. For example, the fair preorder of [LT87] is justified by two observations. First, the fact that I/O automata are input-enabled guarantees that a system must respond to any environment. <p> There are several ways to justify the live preorder as an adequate notion of implementation for live I/O automata. Since the live preorder captures the implementation notions of [LT87, 17 Dil88, AL93] it can rest on the justifications provided for these implementation notions. For example, the fair preorder of <ref> [LT87] </ref> is justified by two observations. First, the fact that I/O automata are input-enabled guarantees that a system must respond to any environment. In our model the same property is guaranteed by the concept of receptiveness. <p> In [GSSL93] simulation based proof techniques are extended to the live preorder, and in [SLL93b] the new proof techniques are used to verify nontrivial communication protocols. 3.6 Comparison with Other Models This section compares our model with the models of <ref> [Dil88, LT87, AL93] </ref> and the work of [RWZ92]. The model of complete trace structures of [Dil88] is a special case of our model. <p> Thus, complete trace structures are not adequate whenever the state structure of a system is important. The I/O automaton model of <ref> [LT87] </ref> is also a special case of our model. An I/O automaton M of [LT87] can be represented in our model as the receptive pair (A; L), where A is the I/O automaton M without the partition of its locally-controlled actions and L is the set of fair executions of M <p> Thus, complete trace structures are not adequate whenever the state structure of a system is important. The I/O automaton model of <ref> [LT87] </ref> is also a special case of our model. An I/O automaton M of [LT87] can be represented in our model as the receptive pair (A; L), where A is the I/O automaton M without the partition of its locally-controlled actions and L is the set of fair executions of M . <p> Thus <ref> [LT87] </ref> can only express some special cases of our general liveness conditions. The model of [AL93] is based on unlabeled state transition systems and is suitable for the modeling of shared memory systems. <p> Finally, it is easy to show, given our definition of receptiveness, that the set of live traces of any live I/O automaton is union-game realizable according to [RWZ92], and thus describable by means of a standard I/O automaton of <ref> [LT87] </ref>. However, in general the I/O automaton description would involve a lot of encoding and would be extremely unnatural. That is, even though the I/O automata of [LT87] and our live I/O automata are formally equivalent, fairness is not adequate to describe general liveness. 4 Timed Systems The notion of liveness <p> traces of any live I/O automaton is union-game realizable according to [RWZ92], and thus describable by means of a standard I/O automaton of <ref> [LT87] </ref>. However, in general the I/O automaton description would involve a lot of encoding and would be extremely unnatural. That is, even though the I/O automata of [LT87] and our live I/O automata are formally equivalent, fairness is not adequate to describe general liveness. 4 Timed Systems The notion of liveness discussed in the previous section is now extended to the timed model. <p> We believe that it is more reasonable to assume that no one has control over time. The model of [MMT91] is an extension to the timed model of the I/O automaton model of <ref> [LT87] </ref>. The locally-controlled actions of an automaton are partitioned into classes, each one of which is associated with a lower bound (possibly 0 but not 1) and an upper bound (possibly 1 but not 0). <p> In this section we argue that receptiveness is not severe by providing examples of sufficient conditions for receptiveness. Other examples are likely to be derived in the future based on new applications. Ordinary I/O automata <ref> [LT87] </ref> are examples of receptive systems. That is, systems specified using weak fairness assumptions are receptive. Romijn and Vaandrager [RV96] provide an even stronger syntactic criterion for receptiveness in our model by introducing fair I/O automata. <p> Furthermore the values of the continuous variables can be bounded to remain on one side of a hyperplane. Reaching a bound means forcing some action to occur before time can elapse. 7 Concluding Remarks This paper extends I/O automata <ref> [LT87, MMT91] </ref> to handle general liveness properties in both the timed and untimed model, and creates a coordinated framework where timed and untimed systems can be analyzed. <p> Moreover, [GSSL93] extends the simulation method of [AL91a, LV91, LV93, LV95, Jon91] to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in [SLL93b, SLL93a]. In addition to generalizing the I/O automaton model <ref> [LT87] </ref> and its timed version [MMT91], our model generalizes the failure free complete trace structures of [Dil88] and the strong I/O feasibility notion of [VL92].
Reference: [LV91] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations for timing-based systems. </title> <editor> In de Bakker et al. </editor> <booktitle> [dBHRR91], </booktitle> <pages> pages 397-446. </pages>
Reference-contexts: The framework is intended to support a variety of verification techniques, including simulation methods, compositional reasoning, algebraic methods, and temporal logic methods. A successful technique for the verification of safety properties and some special liveness properties is based on the simulation method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref>, applied to the Input/Output automaton model of [LT87] and to its generalization to the timed case [MMT91]. I/O automata are state machines with a labeled transition relation where the labels, also called actions , model communication. <p> Due to the close connection between environment-freedom in our untimed model and receptiveness in other existing models, we have uniformed our terminology to the existing literature. 2 others, our models support the simulation based proof method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref>. In [GSSL93] we show how the simulation based proof method can be used to handle liveness by means of an Execution Correspondence Theorem, which extracts from a simulation relation more information than just trace inclusion. <p> This shows part 1. For part 2 we need to show infinite trace inclusion as well, which follows from finite trace inclusion, closure under prefix of trace sets, and the fact that trace sets of automata with finite internal nondeterminism are closed under prefix ordering limit <ref> [LV91] </ref>. 16 The proof of Proposition 3.20 supports the requirement of our definition of a liveness condition (Definition 3.2) that every safe execution be extendible to a live execution. <p> This is a standard result that appears in <ref> [LV91] </ref>. 3. Similar to the proof of Proposition 3.19, part 1. Use timed executions and timed traces instead of executions and traces, respectively. The important property of the safe and live preorders is that they are substitutive for parallel composition. <p> Proof. The substitutivity result is a direct consequence of Lemma 4.5 and the observation, analogous to the one of the untimed model, that parallel composition of timed execution sets preserve timed trace equivalence. It is well known that simulation based proof techniques <ref> [LV91, LV95] </ref> can be used for imple mentation notions based on trace inclusion. <p> A key aspect of the models is the notion of receptiveness, which expresses the fact that a live (timed) I/O automaton does not constrain its environment. Moreover, [GSSL93] extends the simulation method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref> to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in [SLL93b, SLL93a].
Reference: [LV93] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations part I: Untimed systems. </title> <type> Technical Report MIT/LCS/TM-486, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: The framework is intended to support a variety of verification techniques, including simulation methods, compositional reasoning, algebraic methods, and temporal logic methods. A successful technique for the verification of safety properties and some special liveness properties is based on the simulation method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref>, applied to the Input/Output automaton model of [LT87] and to its generalization to the timed case [MMT91]. I/O automata are state machines with a labeled transition relation where the labels, also called actions , model communication. <p> Due to the close connection between environment-freedom in our untimed model and receptiveness in other existing models, we have uniformed our terminology to the existing literature. 2 others, our models support the simulation based proof method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref>. In [GSSL93] we show how the simulation based proof method can be used to handle liveness by means of an Execution Correspondence Theorem, which extracts from a simulation relation more information than just trace inclusion. <p> Therefore, even in the implementation something has to happen after fi has occurred. If the involved systems have finite internal nondeterminism, then the live preorder implies the safe preorder. Thus the live preorder guarantees both safety and liveness properties. It is well known that simulation based proof techniques <ref> [LV93] </ref> can be used for implementation notions based on trace inclusion. <p> A key aspect of the models is the notion of receptiveness, which expresses the fact that a live (timed) I/O automaton does not constrain its environment. Moreover, [GSSL93] extends the simulation method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref> to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in [SLL93b, SLL93a].
Reference: [LV95] <author> Nancy Lynch and Frits Vaandrager. </author> <title> Forward and backward simulations Part II: </title> <journal> Timing-based systems. Information and Computation, </journal> <volume> 121(2) </volume> <pages> 214-233, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: The framework is intended to support a variety of verification techniques, including simulation methods, compositional reasoning, algebraic methods, and temporal logic methods. A successful technique for the verification of safety properties and some special liveness properties is based on the simulation method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref>, applied to the Input/Output automaton model of [LT87] and to its generalization to the timed case [MMT91]. I/O automata are state machines with a labeled transition relation where the labels, also called actions , model communication. <p> Due to the close connection between environment-freedom in our untimed model and receptiveness in other existing models, we have uniformed our terminology to the existing literature. 2 others, our models support the simulation based proof method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref>. In [GSSL93] we show how the simulation based proof method can be used to handle liveness by means of an Execution Correspondence Theorem, which extracts from a simulation relation more information than just trace inclusion. <p> In particular, Examples 3.1, 3.2, 3.4, and 3.5 apply equally to the timed model. In the rest of the paper our discussion focuses on issues specific to the timed model. 4.1 Timed Automata The following definition of a timed automaton is the same as the corresponding definition in <ref> [LV95] </ref> except for the fact that our definition allows multiple internal actions. Also, the notions of timed executions and timed traces are the same as the definitions of [LV95]. The definitions are repeated here but the reader is referred to [LV95] for further details. <p> to the timed model. 4.1 Timed Automata The following definition of a timed automaton is the same as the corresponding definition in <ref> [LV95] </ref> except for the fact that our definition allows multiple internal actions. Also, the notions of timed executions and timed traces are the same as the definitions of [LV95]. The definitions are repeated here but the reader is referred to [LV95] for further details. Times are specified using a dense time domain T. In this paper, as in [LV95], let T be R 0 , the set of non-negative reals. <p> timed automaton is the same as the corresponding definition in <ref> [LV95] </ref> except for the fact that our definition allows multiple internal actions. Also, the notions of timed executions and timed traces are the same as the definitions of [LV95]. The definitions are repeated here but the reader is referred to [LV95] for further details. Times are specified using a dense time domain T. In this paper, as in [LV95], let T be R 0 , the set of non-negative reals. <p> Also, the notions of timed executions and timed traces are the same as the definitions of <ref> [LV95] </ref>. The definitions are repeated here but the reader is referred to [LV95] for further details. Times are specified using a dense time domain T. In this paper, as in [LV95], let T be R 0 , the set of non-negative reals. Definition 4.1 (Timed automaton) A timed automaton A is an automaton whose set of external actions contains a collection of special time-passage actions f-(t) j t 2 R &gt;0 g. <p> In <ref> [LV95] </ref> axiom S2 is explained further and compared to the weaker axiom that says the following: if time can pass in one step, then it can pass in two steps with the time of the intermediate state being any time in the interval. <p> Timed Traces In the untimed model automata are compared based on their traces. This turns out to be inadequate in the timed model, since time is invisible in a trace (cf. <ref> [LV95] </ref> for more details). This leads to timed traces, which consist of visible actions paired with their time of occurrence (timed sequences) together with a time of termination. <p> Proof. The substitutivity result is a direct consequence of Lemma 4.5 and the observation, analogous to the one of the untimed model, that parallel composition of timed execution sets preserve timed trace equivalence. It is well known that simulation based proof techniques <ref> [LV91, LV95] </ref> can be used for imple mentation notions based on trace inclusion. <p> A key aspect of the models is the notion of receptiveness, which expresses the fact that a live (timed) I/O automaton does not constrain its environment. Moreover, [GSSL93] extends the simulation method of <ref> [AL91a, LV91, LV93, LV95, Jon91] </ref> to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in [SLL93b, SLL93a].
Reference: [MMP91] <author> O. Maler, Z. Manna, and A. Pnueli. </author> <title> From timed to hybrid systems. </title> <editor> In de Bakker et al. </editor> <booktitle> [dBHRR91], </booktitle> <pages> pages 447-484. </pages>
Reference-contexts: Also, the intuition about the execution of a timed system is that visible actions occur at points in time, and that time passes "continuously" between these points. These observations lead to the definition of a timed execution. The definition is close to the notion of hybrid computation of <ref> [MMP91] </ref> where continuous changes and discrete events alternate during the execution of a system.
Reference: [MMT91] <author> M. Merritt, F. Modugno, and M. Tuttle. </author> <title> Time constrained automata. </title> <booktitle> In Baeten and Groote [BG91], </booktitle> <pages> pages 408-423. </pages>
Reference-contexts: A successful technique for the verification of safety properties and some special liveness properties is based on the simulation method of [AL91a, LV91, LV93, LV95, Jon91], applied to the Input/Output automaton model of [LT87] and to its generalization to the timed case <ref> [MMT91] </ref>. I/O automata are state machines with a labeled transition relation where the labels, also called actions , model communication. <p> Receptiveness also implies feasibility as defined in [LS89]. The failure free complete trace structures of [Dil88] are also properly generalized by our model. In the timed case, our model generalizes <ref> [MMT91] </ref> and the notion of strong I/O feasibility introduced in [VL92]. Finally, in contrast to [AL91b], our timed model does not give either the system or the environment control over the passage of time. <p> In [GSSL93] simulation based proof techniques are extended to live preorder, and in [SLL93b] the new proof techniques are used to verify nontrivial communication protocols. 4.6 Comparison with Other Timed Models This section compares our timed model with the work of <ref> [AL91b, MMT91, VL92] </ref>. The formalism that is used in [AL91b] is the Temporal Logic of Actions (TLA) [Lam91] extended with a new variable now that models time. <p> We believe that it is more reasonable to assume that no one has control over time. The model of <ref> [MMT91] </ref> is an extension to the timed model of the I/O automaton model of [LT87]. The locally-controlled actions of an automaton are partitioned into classes, each one of which is associated with a lower bound (possibly 0 but not 1) and an upper bound (possibly 1 but not 0). <p> An automaton M of <ref> [MMT91] </ref> can be represented in our model as a pair (A; L) where A is a safe timed I/O automaton with a transition relation that satisfies all the timing constraints of M , and L is the set of all admissible executions of A. <p> It is easy to check that (A; L) is receptive and that admissible timed trace inclusion in <ref> [MMT91] </ref> coincides with live trace inclusion in our model. However, there are liveness conditions that can be represented in our model but cannot be represented naturally in the model of [MMT91]. <p> It is easy to check that (A; L) is receptive and that admissible timed trace inclusion in <ref> [MMT91] </ref> coincides with live trace inclusion in our model. However, there are liveness conditions that can be represented in our model but cannot be represented naturally in the model of [MMT91]. The work in [VL92] does not deal with general liveness properties, and argues that finite and admissible timed traces inclusion is generally sufficient to express a useful notion of implementation whenever time is involved. <p> In the timed case we have seen that the automata of <ref> [MMT91] </ref> are receptive, and we have mentioned that the strong I/O feasibility condition of [VL92] is a sufficient conditions for receptiveness. Furthermore, any patient construction over a live I/O automaton leads to a receptive pair. <p> Furthermore the values of the continuous variables can be bounded to remain on one side of a hyperplane. Reaching a bound means forcing some action to occur before time can elapse. 7 Concluding Remarks This paper extends I/O automata <ref> [LT87, MMT91] </ref> to handle general liveness properties in both the timed and untimed model, and creates a coordinated framework where timed and untimed systems can be analyzed. <p> Moreover, [GSSL93] extends the simulation method of [AL91a, LV91, LV93, LV95, Jon91] to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in [SLL93b, SLL93a]. In addition to generalizing the I/O automaton model [LT87] and its timed version <ref> [MMT91] </ref>, our model generalizes the failure free complete trace structures of [Dil88] and the strong I/O feasibility notion of [VL92].
Reference: [NS92] <author> X. Nicollin and J. Sifakis. </author> <title> An overview and synthesis on timed process algebras. </title> <editor> In K.G. Larsen and A. Skou, editors, </editor> <booktitle> Proceedings of the Third Workshop on Computer Aided Verification, </booktitle> <address> Aalborg, Denmark, </address> <month> July </month> <year> 1991, </year> <booktitle> volume 575 of Lecture Notes in Computer Science, </booktitle> <pages> pages 376-398. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The close relationship between the receptiveness property in the untimed and the timed model allows the models to be tied together, thus permitting the verification of timed implementations of untimed specifications. Specifically, the paper presents a patient operator <ref> [NS92, VL92] </ref> that converts (untimed) live I/O automata into live timed I/O automata without timing constraints. The patient operator preserves receptiveness and the live trace preorder relation of the untimed model. <p> Our approach to this issue is to convert the untimed systems in the stepwise development to timed systems by applying a patient 40 operator that adds arbitrary time-passage steps. The patient operator we use is similar to the one of <ref> [NS92, VL92] </ref>. To complement the patient operator, this section proves the Embedding Theorem which states that a concrete level implements an abstract level in the untimed model if and only if the patient version of the concrete level implements the patient version of the abstract level in the timed model.
Reference: [Plo81] <author> G.D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer science Department, Aarhus University, </institution> <year> 1981. </year>
Reference-contexts: Section 3.6 compares our model with existing work. 3 3.1 Automata We define automata using the presentation style of [LT87]. Essentially, an automaton is a labeled transition system <ref> [Plo81] </ref>.
Reference: [RV96] <author> J.M.T. Romijn and F. Vaandrager. </author> <title> A note on fairness in I/O automata. </title> <journal> Information Processing Letters, </journal> <volume> 59(5) </volume> <pages> 245-250, </pages> <year> 1996. </year>
Reference-contexts: Other examples are likely to be derived in the future based on new applications. Ordinary I/O automata [LT87] are examples of receptive systems. That is, systems specified using weak fairness assumptions are receptive. Romijn and Vaandrager <ref> [RV96] </ref> provide an even stronger syntactic criterion for receptiveness in our model by introducing fair I/O automata. A fair I/O automaton is a safe I/O automaton A equipped with sets wfair (A) and sfair (A) of subsets of local (A), called the weak fairness and strong fairness sets, respectively. <p> The elements of wfair (A) are sets of actions over which weak fairness is enforced, while the elements of wfair (A) are sets of actions over which strong fairness is enforced. It is proven in <ref> [RV96] </ref> that a fair I/O automaton A is receptive if each reachable state in A enables at most countably many sets in wfair (A) [ sfair (A) and each set of sfair (A) is input resistant, i.e., each set in sfair (A) is never disabled by the occurrence of an input
Reference: [RWZ92] <author> N. Reingold, D.W. Wang, and L.D. Zuck. </author> <title> Games I/O automata play. </title> <booktitle> In Cleaveland [Cle92], </booktitle> <pages> pages 325-339. </pages>
Reference-contexts: In [GSSL93] simulation based proof techniques are extended to the live preorder, and in [SLL93b] the new proof techniques are used to verify nontrivial communication protocols. 3.6 Comparison with Other Models This section compares our model with the models of [Dil88, LT87, AL93] and the work of <ref> [RWZ92] </ref>. The model of complete trace structures of [Dil88] is a special case of our model. Specifically, the model of [Dil88] does not include a state structure, so that the safe part of a live automaton in [Dil88] is given by a set of traces. <p> Finally, it is easy to show, given our definition of receptiveness, that the set of live traces of any live I/O automaton is union-game realizable according to <ref> [RWZ92] </ref>, and thus describable by means of a standard I/O automaton of [LT87]. However, in general the I/O automaton description would involve a lot of encoding and would be extremely unnatural.
Reference: [Seg93] <author> R. Segala. </author> <title> Quiescence, fairness, testing and the notion of implementation. </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings of CONCUR 93, Hildesheim, Germany, volume 715 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In fact, our model is closer to the classical models of the process algebraic community (e.g., labeled transition systems) than the models of [AL93, AL91b], and thus may represent a natural starting point for possible generalizations. Some promising results come from <ref> [Seg93] </ref>, which shows that there is a strong connection between the trace semantics of I/O automata and the must preorder of the theory of testing [DH84]. Another line of research consists of extending the current model to handle systems with probabilistic behaviors.
Reference: [SLL93a] <author> J.F. Stgaard-Andersen, B. Lampson, and N.A. Lynch. </author> <title> Correctness of at-most-once message delivery protocols. </title> <booktitle> In FORTE '93 Sixth International Conference on Formal Description Techniques, </booktitle> <year> 1993. </year>
Reference-contexts: Compositionality is needed for modular design techniques. Despite its success, the I/O automaton model is not general enough to handle some recent verification work in <ref> [SLL93b, SLL93a] </ref>. In particular, [SLL93b, SLL93a] provide examples where fairness is not adequate to express liveness naturally. Moreover, the work in [SLL93b, SLL93a] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. <p> Compositionality is needed for modular design techniques. Despite its success, the I/O automaton model is not general enough to handle some recent verification work in <ref> [SLL93b, SLL93a] </ref>. In particular, [SLL93b, SLL93a] provide examples where fairness is not adequate to express liveness naturally. Moreover, the work in [SLL93b, SLL93a] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. <p> Compositionality is needed for modular design techniques. Despite its success, the I/O automaton model is not general enough to handle some recent verification work in <ref> [SLL93b, SLL93a] </ref>. In particular, [SLL93b, SLL93a] provide examples where fairness is not adequate to express liveness naturally. Moreover, the work in [SLL93b, SLL93a] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. The mutual exclusion algorithm of Fischer [Fis85, AL91b] is another instance of a timed implementation for an untimed specification. <p> In [GSSL93] we show how the simulation based proof method can be used to handle liveness by means of an Execution Correspondence Theorem, which extracts from a simulation relation more information than just trace inclusion. Our models have already been used in <ref> [SLL93b, SLL93a] </ref> to verify a non-trivial communication protocol used in the Internet, and the verifications require all the new expressiveness provided in this paper and the simulation tools provided in [GSSL93]. After some preliminary definitions, given in Section 2, the paper is divided into three main sections. <p> Thus, one would like to work in the untimed model as much as possible and only switch to the timed model when it is needed. Sometimes, however, an algorithm that uses time implements a specification that does not use time. For example, <ref> [SLL93a] </ref> shows how an untimed specification (of the at-most-once message delivery problem) is implemented by a system that assumes upper time bounds on certain process steps and channel delays. Fischer's mutual exclusion algorithm [Fis85, AL91b] is another such example. <p> Fischer's mutual exclusion algorithm [Fis85, AL91b] is another such example. Figure 1 depicts the stepwise development one would use for an implementation proof like the one in <ref> [SLL93a] </ref>. The stepwise development in Figure 1, however, raises the issue of what it means to implement an untimed specification with a timed implementation. <p> Moreover, [GSSL93] extends the simulation method of [AL91a, LV91, LV93, LV95, Jon91] to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in <ref> [SLL93b, SLL93a] </ref>. In addition to generalizing the I/O automaton model [LT87] and its timed version [MMT91], our model generalizes the failure free complete trace structures of [Dil88] and the strong I/O feasibility notion of [VL92].
Reference: [SLL93b] <author> J.F. Stgaard-Andersen, N.A. Lynch, and B.W. Lampson. </author> <title> Correctness of communication protocols. a case study. </title> <type> Technical Report MIT/LCS/TR-589, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Compositionality is needed for modular design techniques. Despite its success, the I/O automaton model is not general enough to handle some recent verification work in <ref> [SLL93b, SLL93a] </ref>. In particular, [SLL93b, SLL93a] provide examples where fairness is not adequate to express liveness naturally. Moreover, the work in [SLL93b, SLL93a] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. <p> Compositionality is needed for modular design techniques. Despite its success, the I/O automaton model is not general enough to handle some recent verification work in <ref> [SLL93b, SLL93a] </ref>. In particular, [SLL93b, SLL93a] provide examples where fairness is not adequate to express liveness naturally. Moreover, the work in [SLL93b, SLL93a] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. <p> Compositionality is needed for modular design techniques. Despite its success, the I/O automaton model is not general enough to handle some recent verification work in <ref> [SLL93b, SLL93a] </ref>. In particular, [SLL93b, SLL93a] provide examples where fairness is not adequate to express liveness naturally. Moreover, the work in [SLL93b, SLL93a] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. The mutual exclusion algorithm of Fischer [Fis85, AL91b] is another instance of a timed implementation for an untimed specification. <p> In [GSSL93] we show how the simulation based proof method can be used to handle liveness by means of an Execution Correspondence Theorem, which extracts from a simulation relation more information than just trace inclusion. Our models have already been used in <ref> [SLL93b, SLL93a] </ref> to verify a non-trivial communication protocol used in the Internet, and the verifications require all the new expressiveness provided in this paper and the simulation tools provided in [GSSL93]. After some preliminary definitions, given in Section 2, the paper is divided into three main sections. <p> Thus the live preorder guarantees both safety and liveness properties. It is well known that simulation based proof techniques [LV93] can be used for implementation notions based on trace inclusion. In [GSSL93] simulation based proof techniques are extended to the live preorder, and in <ref> [SLL93b] </ref> the new proof techniques are used to verify nontrivial communication protocols. 3.6 Comparison with Other Models This section compares our model with the models of [Dil88, LT87, AL93] and the work of [RWZ92]. The model of complete trace structures of [Dil88] is a special case of our model. <p> It is well known that simulation based proof techniques [LV91, LV95] can be used for imple mentation notions based on trace inclusion. In [GSSL93] simulation based proof techniques are extended to live preorder, and in <ref> [SLL93b] </ref> the new proof techniques are used to verify nontrivial communication protocols. 4.6 Comparison with Other Timed Models This section compares our timed model with the work of [AL91b, MMT91, VL92]. <p> The work in [VL92] does not deal with general liveness properties, and argues that finite and admissible timed traces inclusion is generally sufficient to express a useful notion of implementation whenever time is involved. The work in <ref> [SLL93b] </ref>, however, has shown that liveness is useful even in a timed model. In general, the automata of [VL92] are not receptive; however, in order to avoid trivial implementations, [VL92] assumes some form of I/O distinction and some form of receptiveness at the lower level of implementation. <p> Moreover, [GSSL93] extends the simulation method of [AL91a, LV91, LV93, LV95, Jon91] to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in <ref> [SLL93b, SLL93a] </ref>. In addition to generalizing the I/O automaton model [LT87] and its timed version [MMT91], our model generalizes the failure free complete trace structures of [Dil88] and the strong I/O feasibility notion of [VL92].
Reference: [VL92] <author> F.W. Vaandrager and N.A. Lynch. </author> <title> Action transducers and timed automata. </title> <booktitle> In Cleaveland [Cle92], </booktitle> <pages> pages 436-455. 51 </pages>
Reference-contexts: The close relationship between the receptiveness property in the untimed and the timed model allows the models to be tied together, thus permitting the verification of timed implementations of untimed specifications. Specifically, the paper presents a patient operator <ref> [NS92, VL92] </ref> that converts (untimed) live I/O automata into live timed I/O automata without timing constraints. The patient operator preserves receptiveness and the live trace preorder relation of the untimed model. <p> Receptiveness also implies feasibility as defined in [LS89]. The failure free complete trace structures of [Dil88] are also properly generalized by our model. In the timed case, our model generalizes [MMT91] and the notion of strong I/O feasibility introduced in <ref> [VL92] </ref>. Finally, in contrast to [AL91b], our timed model does not give either the system or the environment control over the passage of time. We believe that our coordinated untimed and timed models comprise a good general framework for verification of concurrent systems. <p> iff (A 1 ; L 1 ) v fl St (A 2 ; L 2 ): Live: (A 1 ; L 1 ) v Lt (A 2 ; L 2 ) iff t-traces (L 1 ) t-traces (L 2 ): The safe-non-Zeno preorder is the relation that is used in <ref> [VL92] </ref>. This preorder is used in [VL92] instead of the more natural safe-admissible preorder since finite timed traces are needed for substitutivity of a sequential composition operator. Note that the live preorder implies the safe preorder whenever the involved safe timed I/O automata have timed finite internal nondeterminism. <p> ) v fl St (A 2 ; L 2 ): Live: (A 1 ; L 1 ) v Lt (A 2 ; L 2 ) iff t-traces (L 1 ) t-traces (L 2 ): The safe-non-Zeno preorder is the relation that is used in <ref> [VL92] </ref>. This preorder is used in [VL92] instead of the more natural safe-admissible preorder since finite timed traces are needed for substitutivity of a sequential composition operator. Note that the live preorder implies the safe preorder whenever the involved safe timed I/O automata have timed finite internal nondeterminism. <p> In [GSSL93] simulation based proof techniques are extended to live preorder, and in [SLL93b] the new proof techniques are used to verify nontrivial communication protocols. 4.6 Comparison with Other Timed Models This section compares our timed model with the work of <ref> [AL91b, MMT91, VL92] </ref>. The formalism that is used in [AL91b] is the Temporal Logic of Actions (TLA) [Lam91] extended with a new variable now that models time. <p> However, there are liveness conditions that can be represented in our model but cannot be represented naturally in the model of [MMT91]. The work in <ref> [VL92] </ref> does not deal with general liveness properties, and argues that finite and admissible timed traces inclusion is generally sufficient to express a useful notion of implementation whenever time is involved. The work in [SLL93b], however, has shown that liveness is useful even in a timed model. <p> The work in [SLL93b], however, has shown that liveness is useful even in a timed model. In general, the automata of <ref> [VL92] </ref> are not receptive; however, in order to avoid trivial implementations, [VL92] assumes some form of I/O distinction and some form of receptiveness at the lower level of implementation. There is a very close connection between the technical definitions of I/O feasibility and strong I/O feasibility of [VL92] and our notion <p> The work in [SLL93b], however, has shown that liveness is useful even in a timed model. In general, the automata of <ref> [VL92] </ref> are not receptive; however, in order to avoid trivial implementations, [VL92] assumes some form of I/O distinction and some form of receptiveness at the lower level of implementation. There is a very close connection between the technical definitions of I/O feasibility and strong I/O feasibility of [VL92] and our notion of receptiveness. <p> the automata of <ref> [VL92] </ref> are not receptive; however, in order to avoid trivial implementations, [VL92] assumes some form of I/O distinction and some form of receptiveness at the lower level of implementation. There is a very close connection between the technical definitions of I/O feasibility and strong I/O feasibility of [VL92] and our notion of receptiveness. It is possible to represent each timed I/O automaton A of [VL92] with the pair (A; L) where L is the set of admissible executions of A. The notion of I/O feasibility of [VL92], which requires each finite timed execution of A to be extendible <p> There is a very close connection between the technical definitions of I/O feasibility and strong I/O feasibility of <ref> [VL92] </ref> and our notion of receptiveness. It is possible to represent each timed I/O automaton A of [VL92] with the pair (A; L) where L is the set of admissible executions of A. The notion of I/O feasibility of [VL92], which requires each finite timed execution of A to be extendible to an admissible timed execution of A using locally-controlled actions only, is stronger than requiring that L <p> the technical definitions of I/O feasibility and strong I/O feasibility of <ref> [VL92] </ref> and our notion of receptiveness. It is possible to represent each timed I/O automaton A of [VL92] with the pair (A; L) where L is the set of admissible executions of A. The notion of I/O feasibility of [VL92], which requires each finite timed execution of A to be extendible to an admissible timed execution of A using locally-controlled actions only, is stronger than requiring that L is a liveness condition for A and weaker than requiring that (A; L) is a live timed I/O automaton. <p> In order to have closure under parallel composition, <ref> [VL92] </ref> introduces a stronger requirement on I/O automata called strong I/O feasibility. Strong I/O feasibility adds to I/O feasibility the requirement that the safe part of an I/O automaton A does not exhibit any system-Zeno execution. <p> Our approach to this issue is to convert the untimed systems in the stepwise development to timed systems by applying a patient 40 operator that adds arbitrary time-passage steps. The patient operator we use is similar to the one of <ref> [NS92, VL92] </ref>. To complement the patient operator, this section proves the Embedding Theorem which states that a concrete level implements an abstract level in the untimed model if and only if the patient version of the concrete level implements the patient version of the abstract level in the timed model. <p> In the timed case we have seen that the automata of [MMT91] are receptive, and we have mentioned that the strong I/O feasibility condition of <ref> [VL92] </ref> is a sufficient conditions for receptiveness. Furthermore, any patient construction over a live I/O automaton leads to a receptive pair. <p> A substantial verification project using the model appears in [SLL93b, SLL93a]. In addition to generalizing the I/O automaton model [LT87] and its timed version [MMT91], our model generalizes the failure free complete trace structures of [Dil88] and the strong I/O feasibility notion of <ref> [VL92] </ref>. People familiar with process algebras might object to our model, arguing that receptiveness is too restrictive since it rules out several systems that might be of interest at a high level of abstraction. We recognize this objection and regard the generalization of the model as future work.
References-found: 31

