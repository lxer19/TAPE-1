URL: http://cs.nyu.edu/phd_students/afshar/coreA4.ps
Refering-URL: http://www.cs.nyu.edu/phd_students/afshar/index.html
Root-URL: http://www.cs.nyu.edu
Title: Higher-Order Conditional Synchronization  
Author: by Niki Afshartous 
Date: July 23  
Note: DRAFT  
Abstract-found: 0
Intro-found: 1
Reference: [AMT94] <author> Andrew W. Appel, James S. Mattson, and David R. Tarditi. </author> <title> A lexical analyzer generator for Standard ML.version 1.6.0. </title> <month> October </month> <year> 1994. </year>
Reference-contexts: The implementation consists of a parser which utilizes sml-lex <ref> [AMT94] </ref> and sml-yacc [TA94], a static analysis and translation module which utilizes the sml basis library, and a run-time system module which extends CML with support for FCS. The architecture diagram (Figure 5.0.1) illustrates a source-to-source transformation and a run-time system consisting of CML extended for FCS loaded into SML/NJ.
Reference: [Bal95] <author> Henri E. Bal. </author> <title> Comparing data sychronization in Ada 95 and Orca. </title> <journal> ACM Ada Letters, </journal> <volume> 15(1):5063, </volume> <month> Jan/Feb </month> <year> 1995. </year>
Reference: [BB90] <author> G. Berry and G. Boudol. </author> <title> The chemical abstract machine. </title> <booktitle> In Principles of Programming Languages, </booktitle> <pages> pages 8194. </pages> <publisher> ACM, </publisher> <year> 1990. </year>
Reference-contexts: Concurrent evaluation . As in semantics of cv , concurrent evaluation is detned as a transition system between tnite sets of process states. This is based on the style of the Chemical Abstract Machine <ref> [BB90] </ref>.
Reference: [BF96] <author> Paolo Di Blasio and Kathleen Fisher. </author> <title> A calculus for concurent objects. </title> <booktitle> In Concurrency Theory CONCUR '96, volume 1119 of LNCS, </booktitle> <pages> pages 655670, </pages> <year> 1996. </year>
Reference-contexts: In addition, blocking operations should be prevented during evaluation of the synchronization condition. To allow otherwise would result in ambiguous semantics. To enforce these restrictions we identify eects ' as being either pure or impure eects as in <ref> [BF96] </ref>. Di Blasio and Fisher detne an impure eect ' as containing a write eect for the purpose of disallowing write eects in their synchronization guards. We take 3.2.
Reference: [BKT88] <author> Henri Bal, M. Frans Kaashock, and Andrew Tanenbaum. Orca: </author> <title> A language for parallel programming of distributed systems. In Usenix/SERC Workshop on Experiences with Building Distributed and Multiprocessor Systems. </title> <publisher> Vrije University, </publisher> <address> Netherlands, </address> <year> 1988. </year>
Reference-contexts: Synchronizing with Second-class conditions Both Ada95 [Int95] and Orca <ref> [BKT88] </ref> have a similar form of conditional synchronization. of the two languages. The left column is Orca code and the right column is Ada 95 code. Both examples implement a shared counter abstraction whose operations may be invoked concurrently.
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1982. </year>
Reference-contexts: Values which are stored at locations in the store are assigned imperative types. The source types are shown in Figure 2.2.1. Type schemes <ref> [DM82] </ref> can have quantited type variables. ::= 8ff 1 ; :::; ff n :t The variables ff 1 ; :::; ff n are bound in and are denoted by bv (). Substitutions map type variables to types and imperative type variables to imperative types where S ranges over all substitutions.
Reference: [FF86] <author> Mattias Felleisen and Daniel Friedman. </author> <title> Formal Description of Programming Concepts III, chapter Control operators, the SECD-machine, and the calculus. </title> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference-contexts: The set F Const includes the following event-valued combinators and constructors: choose, recvEvt, sendEvt, and wrap. We add to this list condEvt and the store operations: assignment, dereference, and allocation (set,get, and new). The style of the dynamic semantics is based on Felleisen's notion of an evaluation context <ref> [FF86] </ref> which uses term-rewriting and small-step reductions. This method has been shown to simplify type soundness proofs and provides a framework amenable to language extensions [WF92].
Reference: [GA89] <author> Allan Gottlieb and George S Almasi. </author> <title> Highly Parallel Computing, chapter 2. </title> <publisher> Benjamin/Cummings Publishing, </publisher> <year> 1989. </year>
Reference-contexts: The term barrier was coined by Jordan [Jor78]. Barriers have been applied in parallel applications such as global atmospheric circulation, the n-body gravitational problem, and parallel sorting <ref> [GA89] </ref>. The argument n to function makeBarrier in Figure 1.2.4 corresponds to the number of threads partici pating. Each thread signals that it has reached the barrier applying sync to the event returned by makeBarrier. An auxiliary thread is spawned to coordinate increments to the counter reference variable. 10 1.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specitcation. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <month> June </month> <year> 1996. </year>
Reference-contexts: In this case either a rendezvous between two threads or FCS. Third, our analysis and translation allow non-local variables to be used in the synchronization condition where this was previously disallowed in Orca and Ada95. With the introduction of concurrency into mainstream languages like Java <ref> [GJS96] </ref> concur-rency has manifested itself as being useful for a broad class of application development. Yet the basis for synchronization in Java, the monitor [Hoa74], is not well-integrated with the type system and consequently does not aid the programmer suciently in building concurrent-access abstractions.
Reference: [GMP89] <author> A Giacalone, P Mishra, and S Prasad. </author> <title> Facile: A symmetric integration of concurrent and functional programming. </title> <journal> In International Journal of Parallel Programming, </journal> <volume> volume 18. </volume> <year> 1989. </year>
Reference-contexts: Recursion. We provide no built-in mechanism for recursion since cv has none due to the fact that the call-by-value Y v combinator can be implemented using processes and channels. The CML example in Figure 2.1.4 by Reppy was adopted from <ref> [GMP89] </ref> and uses only the what is provided by cv . The unrolling normally associated with the Y v combinator is done by sending a copy of the function across a channel. In Figure 2.1.4 a copy of the function g is sent across channel a for the next iteration.
Reference: [Gor95] <author> Andrew D. Gordon. </author> <title> Bisimilarity as a theory of functional programming. </title> <month> June </month> <year> 1995. </year>
Reference-contexts: j S is a simulationg We also detne [ ] as [S] = f (a; b) j whenever a ! a 0 there exists b 0 such that b ! b 0 and a 0 S b 0 g Our proof technique is based on the following principle called strong-coinduction <ref> [Gor95] </ref>. Let - be the greatest txed-point of monotone F then X if X F (X [ -) We are interested in similarity as opposed to bisimilarity since there is only a translation in one direction (source to target). Next we detne consistency for sequential contgurations. Definition 4.2.2.
Reference: [Hoa74] <author> C. A. R. Hoare. </author> <title> Monitors: an operating system structuring concept. </title> <journal> Communications of the ACM, </journal> <volume> 17:549 557, </volume> <year> 1974. </year>
Reference-contexts: Both examples implement a shared counter abstraction whose operations may be invoked concurrently. Updates to variables inside the Orca object and the Ada95 protected type are properly synchronized according to the language detnitions. This provides monitor-like <ref> [Hoa74] </ref> functionality. Our focus will be on the AwaitValue operation in the Orca code and the Await_Zero entry in the Ada95 code since this is where the conditional synchronization appears. <p> With the introduction of concurrency into mainstream languages like Java [GJS96] concur-rency has manifested itself as being useful for a broad class of application development. Yet the basis for synchronization in Java, the monitor <ref> [Hoa74] </ref>, is not well-integrated with the type system and consequently does not aid the programmer suciently in building concurrent-access abstractions. By incorporating trst-class mechanisms like FCS the language can facilitate programming with concurrency. 59 60 7. CONCLUSION
Reference: [HS86] <author> R. J. Hindley and J. P. Seldin. </author> <title> Introduction to Combinators and -Calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: Then if we cut out D 1 and replace it with D 2 and also substitute occurrences of e 1 for e 2 then the resulting tree still satistes deduction D. The detailed proof in <ref> [HS86] </ref> uses induction on the height of the tree. Subject reduction illustrates that evaluation preserves types. We now demonstrate subject reduction for both sequential and concurrent contgurations in the target language t cv .
Reference: [Int95] <author> Intermetrics, Inc. </author> <title> Ada 95 Rationale, </title> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Synchronizing with Second-class conditions Both Ada95 <ref> [Int95] </ref> and Orca [BKT88] have a similar form of conditional synchronization. of the two languages. The left column is Orca code and the right column is Ada 95 code. Both examples implement a shared counter abstraction whose operations may be invoked concurrently.
Reference: [JG91] <author> Pierre Jouvelot and D. Giord. </author> <title> Algebraic reconstruction of types and eects. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: To support our translation scheme, we incorporate into the target language ( t cv ) eects and regions [TJ92] [TJ94] [Luc87] <ref> [JG91] </ref> [LG91]. 3.1. Dynamic semantics of target The salient distinction of the target language is the introduction of region names. Region names are run-time representations of regions and are values in the target as shown in Figure 3.1.1.
Reference: [JGF96] <author> Simon Peyton Jones, Andrew Gordon, and Sigbjorn Finne. </author> <title> Concurrent Haskell. </title> <booktitle> ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1996. </year>
Reference-contexts: The motivation for synchrons was the design of space-ecient algorithms as the modular composition of aggregate data operations. In contrast, FCS is a simpler mechanism that is well-suited for general-purpose development. Concurrent Haskell <ref> [JGF96] </ref> contains the MVar : a trst-class synchronization mechanism that provides atomically mutable state. Using MVar it is shown in [JGF96] how to construct a buered channel, skip channel, and quantity semaphore. <p> In contrast, FCS is a simpler mechanism that is well-suited for general-purpose development. Concurrent Haskell <ref> [JGF96] </ref> contains the MVar : a trst-class synchronization mechanism that provides atomically mutable state. Using MVar it is shown in [JGF96] how to construct a buered channel, skip channel, and quantity semaphore. Like the synchron, MVar's are not well-suited for general-purpose development since they are low-level and are intended as building blocks for higher-level abstractions.
Reference: [Jor78] <author> Harry Jordan. </author> <title> A special purpose architecture for tnite element analysis. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <pages> pages 263266, </pages> <year> 1978. </year>
Reference-contexts: This kind of guarantee cannot be programmed since it is dependant upon the thread scheduler. Next, we use condEvt to write the function makeBarrier that returns an event to be sub sequently used by a group of threads participating in barrier synchronization. The term barrier was coined by Jordan <ref> [Jor78] </ref>. Barriers have been applied in parallel applications such as global atmospheric circulation, the n-body gravitational problem, and parallel sorting [GA89]. The argument n to function makeBarrier in Figure 1.2.4 corresponds to the number of threads partici pating.
Reference: [LG91] <author> J. Lucassen and D. Giord. </author> <title> Polymorphic eect systems. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: To support our translation scheme, we incorporate into the target language ( t cv ) eects and regions [TJ92] [TJ94] [Luc87] [JG91] <ref> [LG91] </ref>. 3.1. Dynamic semantics of target The salient distinction of the target language is the introduction of region names. Region names are run-time representations of regions and are values in the target as shown in Figure 3.1.1.
Reference: [Luc87] <author> J. M. Lucassen. </author> <title> Types and Eects, towards the integration of functional and imperative programing. </title> <institution> Mit/lcs/tr-408, MIT Laboratory for Computer Science, </institution> <year> 1987. </year>
Reference-contexts: To support our translation scheme, we incorporate into the target language ( t cv ) eects and regions [TJ92] [TJ94] <ref> [Luc87] </ref> [JG91] [LG91]. 3.1. Dynamic semantics of target The salient distinction of the target language is the introduction of region names. Region names are run-time representations of regions and are values in the target as shown in Figure 3.1.1.
Reference: [Mil89] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year> <note> 61 62 BIBLIOGRAPHY </note>
Reference-contexts: Then following Lemma 4.2.3 we state and prove consistency for sequential and subsequently concurent contgurations. We also show that the consistency properties can be formulated as satisfying a similarity relation. The following detnitions are from <ref> [Mil89] </ref>. 42 4. TRANSLATION Definition 4.2.1. A relation S Rel is a simulation i a S b implies: whenever a ! a 0 9b 0 such that b ! b 0 and a 0 S b 0 . Let similarity .
Reference: [Pap89] <author> Michael Papathomas. </author> <title> Concurrency Issues in Object-Oriented Programming Languages, </title> <institution> pages 207245. Centre Universitaire d'Informatique, University of Geneva, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: The introduction of FCS complements the existing work in this area. 6.2. Concurrent object-oriented languages There are a plethora of approaches to integrating concurrency and object-orientation. Papath-omas developed a taxonomy to identify the salient distinctions between the dierent approaches <ref> [Pap89] </ref>. The main distinction is whether or not the object model is orthogonal to concurrency. FCS could enhance these languages since it would allow an object to export partial information about its internal state without violating encapsulation. This would be accomplished by having a method return a conditional event.
Reference: [Rep91] <author> John Reppy. </author> <title> Synchronous operations as trst-class values. </title> <booktitle> In SIGPLAN Programming Language Design and Implementation, </booktitle> <pages> pages 293259. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: In section 1.2.1 we present an overview of CML before describing our extension in section 1.2.2. 1.2.1. CML overview. An important advance towards the goal of integrating concurrency into programming languages is the concept of trst-class synchronous operations, which trst appeared in PML <ref> [Rep91] </ref> and was then later enhanced in Concurrent ML (CML) ([Rep92],[Rep95]). The salient feature of CML is the data type event , which represents a trst-class synchronous operation. An event value encapsulates a delayed operation that will be performed in the future.
Reference: [Rep92] <author> John Reppy. </author> <title> Higher-Order Concurrency. </title> <type> Technical report tr 92-1285, </type> <institution> Cornell University, </institution> <year> 1992. </year>
Reference-contexts: Synchronizing with First-class conditions We chose to introduce FCS as an extension of Concurrent ML (CML) <ref> [Rep92] </ref> which has trst-class synchronous operations. CML is a concurrent extension of Standard ML of New Jersey . In section 1.2.1 we present an overview of CML before describing our extension in section 1.2.2. 1.2.1. CML overview. <p> INTRODUCTION CHAPTER 2 Source language To express the semantics of FCS we detne s cv , which extends cv <ref> [Rep92] </ref> with FCS and imperative features. 2.1. Dynamic semantics of source From cv , the ground terms are variables, base constants, function constants, and channel names. The set F Const includes the following event-valued combinators and constructors: choose, recvEvt, sendEvt, and wrap. <p> Intuitively, the bigStep function makes an arbitrarily long computation execute as a single small-step reduction. eval (e) = v ffi (bigStep; x:e) = v Our focus now turns to detning the semantics of FCS. See <ref> [Rep92] </ref> for the semantics of the channel operations. What follows are the reduction rules for synchronization on a conditional event. For FCS, synchronization proceeds by evaluation of the encapsulated condition. In 2.1.1 below applying sync to a conditional event yields a condEval value which has two components. <p> false]i =) l 1 ; K; P + h i a ; E i a [()]i + j b ; E j b [fbegin 2 e j b e j b g] E where i 2 f0::mg j 2 f0::ng (2.1.7) For completeness we also include the concurrent reductions from <ref> [Rep92] </ref> for the the CML rendezvous and process and channel creation since these reductions are referenced in the correctness proofs for the translation. The only change is incorporating the global state L . The rendezvous relies on a notion of matching events which we describe trst. <p> The fourth property follows from the trst three. The proof is a case analysis of the left hand side of the =) relation. For the cases involving channel operations and process creation see <ref> [Rep92] </ref>. The cases pertaining to FCS follow where the focus is on proving the third property since there is no process or channel creation for FCS. <p> With the subject reduction theorems in hand we can now continue towards the overall goal of establishing syntactic soundness. The following sequence of detnitions and lemmas are adapted from <ref> [Rep92] </ref> and [WF92]. <p> A well-formed contguration is stuck if one or more of its processes are stuck. In <ref> [Rep92] </ref> the expressions which cause a process to become stuck are: * E [b v], such that ffi (b; v) is undetned * E [v v 0 ] , where v is not of the form x:e * E [sync v] , such that v =2 Event . <p> The idea is to show by case analysis that stuck expressions are inconsistent with type inference rules of the static semantics. See <ref> [Rep92] </ref> for the cases involving the concurrency operations and [WF92] for the cases involving the store operations. We do the case for condEvt 0 . The proof is by contradiction. 38 3. <p> See <ref> [Rep92] </ref> for the proof which relies on uniform evaluation, subject reduction, untypability of stuck contgurations, and well-formed contgurations.
Reference: [Rep95] <author> John Reppy. </author> <title> First-class synchronous operations. In Theory and Practice of Parallel Programming. </title> <publisher> Springer-Verlag LNCS, </publisher> <year> 1995. </year>
Reference: [Sar93] <author> Vijay Saraswat. </author> <title> Concurrent Constraint Programming. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The synchronization in this case would involve private instance variables of a server object. Hence a client object could establish that a server object has reached a certain state. 57 58 6. RELATED WORK 6.3. Concurrent constraint programming There is a form of synchronization in CCP (Concurrent Constraint Programming) <ref> [Sar93] </ref> which supertcially resembles FCS. In CCP, communication and control between concurrently executing agents is mediated through operations on constraints. What makes this model of computation unique is that there is a global store of constraints which has a monotonic property.
Reference: [TA94] <author> David R. Tarditi and Andrew W. Appel. </author> <note> ML-Yacc user's manual version 2.3. </note> <month> October </month> <year> 1994. </year>
Reference-contexts: The implementation consists of a parser which utilizes sml-lex [AMT94] and sml-yacc <ref> [TA94] </ref>, a static analysis and translation module which utilizes the sml basis library, and a run-time system module which extends CML with support for FCS. The architecture diagram (Figure 5.0.1) illustrates a source-to-source transformation and a run-time system consisting of CML extended for FCS loaded into SML/NJ.
Reference: [TJ92] <author> Jean-Pierre Talpin and Pierre Jouvelot. </author> <title> Polymorphic type, region and eect inference. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(2), </volume> <year> 1992. </year>
Reference-contexts: To support our translation scheme, we incorporate into the target language ( t cv ) eects and regions <ref> [TJ92] </ref> [TJ94] [Luc87] [JG91] [LG91]. 3.1. Dynamic semantics of target The salient distinction of the target language is the introduction of region names. Region names are run-time representations of regions and are values in the target as shown in Figure 3.1.1. <p> The distinction is that theorem 2.1.7 is concerned with any store update for contguration c l whereas theorem 3.1.2 only cares about sync-regions. 3.2. Static semantics of target Before presenting the static semantics of the target language we trst give an overview of eects and regions <ref> [TJ92] </ref>.
Reference: [TJ94] <author> Jean-Pierre Talpin and Pierre Jouvelot. </author> <title> Information and Computation, chapter The Type and Eect Dicipline. </title> <publisher> Academic Press, </publisher> <year> 1994. </year>
Reference-contexts: Dave MacQueen has devised a scheme that assigns a rank to type variables that reects the level of lexical nesting. This scheme has been used in the SML/NJ compiler. Talpin and Jouvelot have also used eects to control generalization <ref> [TJ94] </ref>. We choose the method due to Tofte which applies the applicative closure to the type of let-bound variables when the corresponding expression may expand the domain of the store. Not using the applicative closure would lead to an unsound type system is illustrated by the example: 2.2. <p> To support our translation scheme, we incorporate into the target language ( t cv ) eects and regions [TJ92] <ref> [TJ94] </ref> [Luc87] [JG91] [LG91]. 3.1. Dynamic semantics of target The salient distinction of the target language is the introduction of region names. Region names are run-time representations of regions and are values in the target as shown in Figure 3.1.1.
Reference: [Tof90] <author> Mads Tofte. </author> <title> Type inference for polymorphic references. </title> <booktitle> In Information and Computation, </booktitle> <year> 1990. </year>
Reference-contexts: Static semantics of source Type variables are partitioned into two sets for the purpose of controlling type generalization. This method was used by Tofte <ref> [Tof90] </ref> to construct the trst sound polymorphic type system with imperative features. u 2 ImpTyVar t 2 AppTyVar ff 2 TyVar = ImpTyVar [ AppTyVar The set of imperative types is the set of types which contain no applicative type variables. 2 ft j FTV (t ) ImpTyVarg We use FTV <p> However, it is well known that generalizing type variables that appear in the types of stored values results in a unsound type system <ref> [Tof90] </ref>. Hence a variety of mechanisms have been used to restrict generalization. Dave MacQueen has devised a scheme that assigns a rank to type variables that reects the level of lexical nesting. This scheme has been used in the SML/NJ compiler.
Reference: [TT97] <author> Mads Tofte and Jean-Pierre Talpin. </author> <booktitle> Region-based memory management. In Information and Computation, </booktitle> <year> 1997. </year>
Reference-contexts: ! t 2 function types j t 1 fi t 2 pair types j t chan channel types j t event ' pure event types j ref (t ) reference types j t list lists where i 0; j 0; k 0: This method was devised by Tofte and Talpin <ref> [TT97] </ref> to distinguish the types of region polymorphic functions from regular functions. Compound type schemes are used solely for region polymorphic functions. The underlining t helps to identify the compound type schemes. <p> : ref (t 1 ); ' 1 62 SR 1 ; e 0 2 ); unit; ' 1 [ ' 2 [ fwrite ()g (4.1.6) ' 0 ' ' 0 frv (e 0 ) frv (T E; t ) (4.1.7) 1 This is similar to the letregion translation rule in <ref> [TT97] </ref>. 4.2.
Reference: [Tur96] <author> Franklyn Turbak. </author> <title> First-class sychronization barriers. </title> <booktitle> ACM International Conference on Functional Programming, </booktitle> <year> 1996. </year>
Reference-contexts: We chose the former approach since it does not require extending the garbage collector. 55 56 5. IMPLEMENTATION CHAPTER 6 Related work 6.1. Concurrent functional languages The synchron <ref> [Tur96] </ref> is a trst-class barrier mechanism that is more powerful than our barrier example of section 1.2.3. With the synchron the number of threads participating in the barrier is not txed as additional threads may subsequently join the barrier group.
Reference: [WF92] <author> Andrew K. Wright and Mathias Felleisen. </author> <title> A syntactic approach to type soundness. </title> <booktitle> In Information and Computation, </booktitle> <year> 1992. </year>
Reference-contexts: The style of the dynamic semantics is based on Felleisen's notion of an evaluation context [FF86] which uses term-rewriting and small-step reductions. This method has been shown to simplify type soundness proofs and provides a framework amenable to language extensions <ref> [WF92] </ref>. The source language grammar is shown in In addition to the syntactic class of expressions, e 2 EXP, and values, v 2 VAL, there is a syntactic class of event values, ev 2 EVENT VAL. <p> Application and let expressions are reduced by substituting v for x in the body of e (fireduction). To support imperative features we use Wright and Felleisen's <ref> [WF92] </ref> reductions for store operations (Figure 2.1.2). The rule for set creates a new store binding which associates the reference variable x with the value v . Applying get to reference variable x returns the stored value while set updates a store location. <p> Proof. The proof is a case analysis of the syntactic structure of e 1 and ! . For the cases involving fi-reduction , let, and set see <ref> [WF92] </ref> (Note: Appendix ?). <p> With the subject reduction theorems in hand we can now continue towards the overall goal of establishing syntactic soundness. The following sequence of detnitions and lemmas are adapted from [Rep92] and <ref> [WF92] </ref>. <p> The idea is to show by case analysis that stuck expressions are inconsistent with type inference rules of the static semantics. See [Rep92] for the cases involving the concurrency operations and <ref> [WF92] </ref> for the cases involving the store operations. We do the case for condEvt 0 . The proof is by contradiction. 38 3. TARGET LANGUAGE We assume that the stuck expression is P () = E [condEvt 0 v] and the contguration is well typed.
References-found: 32

