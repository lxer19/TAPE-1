URL: http://glen.lcs.mit.edu/~devadas/pubs/impl.ps
Refering-URL: http://glen.lcs.mit.edu/~devadas/pubs/form.html
Root-URL: 
Title: Computation of Floating Mode Delay in Combinational Circuits: Practice and Implementation  
Author: Srinivas Devadas Kurt Keutzer Sharad Malik Albert Wang 
Note: Final Manuscript  
Address: Cambridge  Mountain View  Mountain View  
Affiliation: Department of EECS MIT,  Synopsys  Department of EE Princeton University  Synopsys  
Abstract: Delay computation in combinational logic circuits is complicated by the existence of unsensit-izable (false) paths and this problem is arising with increasing frequency in circuits produced by high-level synthesis procedures. Various sensitization conditions have been proposed in the past to eliminate false paths in logic circuits, but we use a recently developed single-vector condition, that is known to be necessary and sufficient for a path to be responsible for the delay of a circuit (i.e. true) in the floating delay model. In this paper we build on this theory and develop an efficient and correct delay computation algorithm, for the floating mode delay. The algorithm uses a technique we call timed-test generation and can be incorporated into any stuck-at fault test generation framework. We describe in detail an implementation of the timed-test generation algorithm that uses both logical and timed, forward/backward implication and backtrace procedures to simultaneously prove the truth or falsity of sets of paths in the circuit. Logical and temporal conflict detection during implication and backtrace are used to speed up the algorithm. Unlike previous techniques, the algorithm remains highly efficient even when a large number of distinct gate and path delays exist in the given circuit. We provide a comprehensive set of results that show significant speed-ups over previous delay computation techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Benkoski, E. Meersch, L. Claesen, and H. De Man. </author> <title> Efficient Algorithms for Solving the False Path Problem in Timi ng Verification. </title> <booktitle> In The Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 44-47, </pages> <year> 1987. </year>
Reference-contexts: Work in this model has included results by [2] <ref> [1] </ref> [9] and [4]. The two important issues in eliminating false paths are correctness and efficiency.
Reference: [2] <author> D. Brand and V. Iyengar. </author> <title> Timing analysis using functional analysis. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(10), </volume> <month> October </month> <year> 1988. </year>
Reference-contexts: Work in this model has included results by <ref> [2] </ref> [1] [9] and [4]. The two important issues in eliminating false paths are correctness and efficiency. <p> Work in this model has included results by [2] [1] [9] and [4]. The two important issues in eliminating false paths are correctness and efficiency. While the work of <ref> [2, 9] </ref> and others made significant strides in the direction of correct false path identification even the recent work of [9], that proposed a condition called viability, could not be said to correctly identify the paths that were responsible for the delay of the circuit, although it could accurately identify the
Reference: [3] <author> M. A. Breuer and A. D. Friedman. </author> <title> Diagnosis and Reliable Design of Digital Systems. </title> <publisher> Computer Science Press, </publisher> <year> 1976. </year>
Reference-contexts: Stuck-at-0 can be defined similarly. A circuit has a single-stuck-at-fault if there is one stuck-at-fault in the circuit. A circuit has a multiple-stuck-at-fault (multifault) if there are one or more stuck-at-faults in the circuit. For a fuller treatment of testing terminology, see <ref> [3, 7] </ref>. 2.3 Timing In this section we introduce terminology that will allow us to discuss timing issues as well as fault models for temporal behavior.
Reference: [4] <author> H. C. Chen and D. H. Du. </author> <title> Path sensitization in critical path problem. </title> <booktitle> In Proceedings, Tau 90: 1990 ACM Workshop on Timing Issues in the Specification and Synthesis of Digital Systems, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: The general framework for this work has been the observation that for a path to be true in the combinational circuit under consideration it must be true in the floating delay model <ref> [4] </ref>. The floating delay model is a model for the delay of a circuit that looks at the sensitization of paths in the circuit on a single vector and makes conservative assumptions about the prior state of the circuit on application of that vector. <p> Work in this model has included results by [2] [1] [9] and <ref> [4] </ref>. The two important issues in eliminating false paths are correctness and efficiency. <p> The ability to correctly identify paths that are responsible for the delay of a circuit is absolutely necessary for proper performance optimization, but it was not until the work of <ref> [4] </ref> that a condition was offered that correctly identified true paths in the floating delay model. <p> While the results presented for a simple implementation of timed test generation in [5] resulted in substantial speed improvements over the implementations of <ref> [4, 9] </ref>, the initial implementation still left much to be desired in terms of efficiency. In this paper, we use the general timed-test generation framework of [5] but provide details on the implementation techniques necessary to make a computationally 2 efficient floating delay calculator. <p> We provide a comprehensive set of results that show significant speed-ups over previous delay computation techniques. This paper is organized as follows: In Section 2 we provide the notation and terminology used. In Section 3, we briefly review the work of <ref> [4, 5] </ref>. In Section 4, we present our global strategy for timed test generation, that uses timed forward and backward implication, and timed backtrace procedures. The timed forward implication, backward implication and backtrace procedures are described in Sections 5, 6 and 7, respectively. <p> The critical path is the longest sensitizable path in the circuit. The delay of a circuit is the length of the critical path. 3 Review of Relevant Theory In <ref> [4] </ref> a condition that is necessary and sufficient for a path to be responsible for the delay of a circuit, was presented. This condition is summarized below. <p> The CPU times are on a SUN-4 workstation. Some of these examples have literally millions of paths. However, the "sets of paths" paradigm followed in our delay computation algorithm allows for efficient false path identification. The strategies of <ref> [9, 4, 6] </ref> do not complete within reasonable times for the large circuits (notably the multipliers) because they operate on a per path basis. More recent implementations of the procedures of [6] that use some notions from [5] perform well on all the circuits under a unit delay model.
Reference: [5] <author> S. Devadas, K. Keutzer, and S. Malik. </author> <title> Delay Computation in Combinational Circuits: Theory and Algorithms. </title> <booktitle> In The Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 176-179, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: An equivalent necessary and sufficient condition for a path to be true in the floating delay model was given with an independent derivation in <ref> [5] </ref> and there the failure of the viability criterion was also demonstrated. Given necessary and sufficient conditions for a path to be true the problem remains to eliminate false paths and determine the correct delay of a circuit in a computationally efficient manner. <p> Correctness issues aside, the principal problem with previous false-path eliminating static timing verifiers has been that they compute the truth or falsity of one path at a time. This approach can be unacceptably slow for circuits with large numbers of paths. The work of <ref> [5] </ref> introduced a general timed-test generation strategy that enabled the consideration of entire sets of paths, rather than individual paths, avoiding the need for explicit path enumeration in false path identification. While the results presented for a simple implementation of timed test generation in [5] resulted in substantial speed improvements over <p> The work of <ref> [5] </ref> introduced a general timed-test generation strategy that enabled the consideration of entire sets of paths, rather than individual paths, avoiding the need for explicit path enumeration in false path identification. While the results presented for a simple implementation of timed test generation in [5] resulted in substantial speed improvements over the implementations of [4, 9], the initial implementation still left much to be desired in terms of efficiency. In this paper, we use the general timed-test generation framework of [5] but provide details on the implementation techniques necessary to make a computationally 2 efficient <p> While the results presented for a simple implementation of timed test generation in <ref> [5] </ref> resulted in substantial speed improvements over the implementations of [4, 9], the initial implementation still left much to be desired in terms of efficiency. In this paper, we use the general timed-test generation framework of [5] but provide details on the implementation techniques necessary to make a computationally 2 efficient floating delay calculator. To use stuck-at-fault testing methods, in [5] the analogs of the stuck-at-fault and the D calculus were introduced, but in this paper we show how a computationally efficient test generator can be constructed. <p> In this paper, we use the general timed-test generation framework of <ref> [5] </ref> but provide details on the implementation techniques necessary to make a computationally 2 efficient floating delay calculator. To use stuck-at-fault testing methods, in [5] the analogs of the stuck-at-fault and the D calculus were introduced, but in this paper we show how a computationally efficient test generator can be constructed. We provide a comprehensive set of results that show significant speed-ups over previous delay computation techniques. <p> We provide a comprehensive set of results that show significant speed-ups over previous delay computation techniques. This paper is organized as follows: In Section 2 we provide the notation and terminology used. In Section 3, we briefly review the work of <ref> [4, 5] </ref>. In Section 4, we present our global strategy for timed test generation, that uses timed forward and backward implication, and timed backtrace procedures. The timed forward implication, backward implication and backtrace procedures are described in Sections 5, 6 and 7, respectively. <p> If there is even one controlling value at the inputs to g, then must be the first to present the controlling value. The condition above directly translates to false path identification algorithms that operate on a per path basis. In <ref> [5] </ref> an alternative condition, equivalent to the one above, is given in terms of the detection of multifaults in an ENF description of a circuit or alternatively in a leaf-DAG. This condition naturally leads to a delay analysis procedure that avoids explicit path enumeration. <p> To avoid an explicit construction of a leaf-DAG or ENF representation of a circuit a timed D calculus was presented in <ref> [5] </ref> to allow for efficient multiple stuck-at fault test generation. We briefly outline this procedure below: Assume a multilevel circuit C 0 , where all inverters are at the primary inputs. <p> It was proven in <ref> [5] </ref> that the timed D calculus described above would allow the propagation of the multiple stuck-at fault only along paths of length ffi. <p> These conflicts may be time 9 conflicts or logical conflicts. During forward implication, gates may be removed from the justification list. During backward implication, gates may be added to or removed from the justification list. 5.2 Timed Calculus The timed D-calculus introduced in <ref> [5] </ref> and reviewed in Section 3 has been slightly modified in this application. Rather than propagate D and D's explicitly it was found somewhat more compact to treat all elements of the calculus as Boolean logical values annotated with delays. <p> The strategies of [9, 4, 6] do not complete within reasonable times for the large circuits (notably the multipliers) because they operate on a per path basis. More recent implementations of the procedures of [6] that use some notions from <ref> [5] </ref> perform well on all the circuits under a unit delay model. However, their performance may suffer when a large number of paths have distinct delays that are close to the true delay of the circuit.
Reference: [6] <author> P. C. McGeer et al. </author> <title> Timing analysis and delay-fault test generation using path recursive functions. </title> <booktitle> In Proceedings of the Int'l Workshop on Logic Synthesis, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: The CPU times are on a SUN-4 workstation. Some of these examples have literally millions of paths. However, the "sets of paths" paradigm followed in our delay computation algorithm allows for efficient false path identification. The strategies of <ref> [9, 4, 6] </ref> do not complete within reasonable times for the large circuits (notably the multipliers) because they operate on a per path basis. More recent implementations of the procedures of [6] that use some notions from [5] perform well on all the circuits under a unit delay model. <p> The strategies of [9, 4, 6] do not complete within reasonable times for the large circuits (notably the multipliers) because they operate on a per path basis. More recent implementations of the procedures of <ref> [6] </ref> that use some notions from [5] perform well on all the circuits under a unit delay model. However, their performance may suffer when a large number of paths have distinct delays that are close to the true delay of the circuit.
Reference: [7] <author> H. Fujiwara. </author> <title> Logic Testing and Design for Testability. </title> <publisher> MIT Press, </publisher> <address> Cambridge MA, </address> <year> 1985. </year>
Reference-contexts: Stuck-at-0 can be defined similarly. A circuit has a single-stuck-at-fault if there is one stuck-at-fault in the circuit. A circuit has a multiple-stuck-at-fault (multifault) if there are one or more stuck-at-faults in the circuit. For a fuller treatment of testing terminology, see <ref> [3, 7] </ref>. 2.3 Timing In this section we introduce terminology that will allow us to discuss timing issues as well as fault models for temporal behavior. <p> Note that the timing information restricts the propagation of the fault or line justification along a particular set of paths. In this section we will describe an overall strategy toward timed test generation, used in our timed-test implementation TrueD-F, that is reminiscent of the FAN <ref> [7] </ref> algorithm for stuck-at fault test generation. <p> In the case of conflict or failure, we have to restore the state of the network to what it was immediately prior to the primary input setting that caused this failure. This is done much the same as in test generation algorithms <ref> [7] </ref>, using a incremental change list in a restoration routine. 4.3 The Timed Value of a Gate The timed value for each gate in the combinational logic circuit has three fields, a logic value timed value.value, a lower bound on the delay timed value.lower, and an upper bound on the delay <p> Again, the number of backtracks are reduced when irredundant versions of the above circuits are tested for their true delays. 9 Summary and Future Work We presented details on TrueD-F, a sophisticated implementation of timed test generation that uses ideas from the stuck-at fault test generators PODEM [8] and FAN <ref> [7] </ref>. Timed forward implication, timed backward implication and timed backtrace procedures were developed in a search strategy that determines the truth or falsity of sets of paths simultaneously. In addition to using a novel, and correct, floating delay criterion, the implementation described here significantly outperforms other previous delay computation methods.
Reference: [8] <author> P. Goel. </author> <title> An Implicit Enumeration Algorithm to Generate Tests for Combinational Logic Circuits. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C30(3):215-222, </volume> <month> March </month> <year> 1981. </year>
Reference-contexts: Again, the number of backtracks are reduced when irredundant versions of the above circuits are tested for their true delays. 9 Summary and Future Work We presented details on TrueD-F, a sophisticated implementation of timed test generation that uses ideas from the stuck-at fault test generators PODEM <ref> [8] </ref> and FAN [7]. Timed forward implication, timed backward implication and timed backtrace procedures were developed in a search strategy that determines the truth or falsity of sets of paths simultaneously.
Reference: [9] <author> P. C. McGeer and R. K. Brayton. </author> <title> Integrating Functional and Temporal Domains in Logic Design. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year> <month> 19 </month>
Reference-contexts: Work in this model has included results by [2] [1] <ref> [9] </ref> and [4]. The two important issues in eliminating false paths are correctness and efficiency. While the work of [2, 9] and others made significant strides in the direction of correct false path identification even the recent work of [9], that proposed a condition called viability, could not be said to <p> Work in this model has included results by [2] [1] [9] and [4]. The two important issues in eliminating false paths are correctness and efficiency. While the work of <ref> [2, 9] </ref> and others made significant strides in the direction of correct false path identification even the recent work of [9], that proposed a condition called viability, could not be said to correctly identify the paths that were responsible for the delay of the circuit, although it could accurately identify the <p> Work in this model has included results by [2] [1] <ref> [9] </ref> and [4]. The two important issues in eliminating false paths are correctness and efficiency. While the work of [2, 9] and others made significant strides in the direction of correct false path identification even the recent work of [9], that proposed a condition called viability, could not be said to correctly identify the paths that were responsible for the delay of the circuit, although it could accurately identify the delay of the circuit in the floating delay model. <p> While the results presented for a simple implementation of timed test generation in [5] resulted in substantial speed improvements over the implementations of <ref> [4, 9] </ref>, the initial implementation still left much to be desired in terms of efficiency. In this paper, we use the general timed-test generation framework of [5] but provide details on the implementation techniques necessary to make a computationally 2 efficient floating delay calculator. <p> The CPU times are on a SUN-4 workstation. Some of these examples have literally millions of paths. However, the "sets of paths" paradigm followed in our delay computation algorithm allows for efficient false path identification. The strategies of <ref> [9, 4, 6] </ref> do not complete within reasonable times for the large circuits (notably the multipliers) because they operate on a per path basis. More recent implementations of the procedures of [6] that use some notions from [5] perform well on all the circuits under a unit delay model.

References-found: 9

