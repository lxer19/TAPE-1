URL: ftp://ftp.cs.wpi.edu/pub/techreports/96-1.ps.gz
Refering-URL: http://cs.wpi.edu/Resources/techreports/index.html
Root-URL: 
Email: heineman@cs.wpi.edu  kaiser@cs.columbia.edu  
Title: The cord approach to Extensible Concurrency Control  
Author: George T. Heineman Gail E. Kaiser fl, George T. Heineman and Gail E. Kaiser 
Keyword: Component, DBMS architecture  
Note: c  
Web: WPI-CS-TR-96-1  
Address: Worcester, MA  New York, NY  
Affiliation: Worcester Polytechnic Institute Department of Computer Science  Columbia University Department of Computer Science  
Abstract: Database management systems (DBMSs) have been increasingly used for advanced application domains, such as software development environments, network management, workflow management systems, computer-aided design and manufacturing, and managed healthcare. In these domains, the standard correctness model of serializability is often too restrictive. We introduce the notion of a Concurrency Control Language (CCL) that allows a database application designer to specify concurrency control policies to tailor the behavior of a transaction manager. A well-crafted set of policies defines an extended transaction model. The necessary semantic information required by the CCL run-time engine is extracted from a task manager, a (logical) module by definition included in all advanced applications. This module stores task models that encode the semantic information about the transactions submitted to the DBMS. We have designed a rule-based CCL, called cord, and have implemented a run-time engine that can be hooked to a conventional transaction manager to implement the sophisticated concurrency control required by advanced database applications. We present an architecture for systems based on cord and describe how we integrated the cord engine with the Exodus Storage Manager to implement Altruistic Locking. fl This paper is based on work sponsored in part by Advanced Research Project Agency order B128 monitored by Rome Lab F30602-94-C-0197, in part by National Science Foundation CCR-9301092, and in part by the New York State Science and Technology Foundation Center for Advanced Technology in High Performance Computing and Communications in Healthcare 94013. Heineman was also supported in part by an AT&T Fellowship. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the government, ARPA, NSF, NYSSTF, or AT&T. keywords: Extended Transaction Models, Extensible Concurrency Control, Transaction Manager
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Agrawal, J. L. Bruno, A. El Abbadi, and V. Krishnaswamy. </author> <title> Relative serializability: An approach for relaxing the atomicity of transactions. </title> <booktitle> In ACM-SIGMOD/PODS 1994 International Conference on Management of Data, </booktitle> <pages> pages 139-149, </pages> <address> Minnesota, USA, </address> <month> May </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: The ETM specification enumerates the differences from serializability, the standard correctness model for most DBMSs. We view approaches that model every database access by all transactions (such 2 as pattern machines [32] or Relative Serializability <ref> [1] </ref>) as impractical since each transaction that wishes to relax atomicity would first have to analyze the operations of all other potentially affected transactions.
Reference: [2] <author> Roger Barga and Calton Pu. </author> <title> A practical and modular method to implement extended transaction models. </title> <booktitle> In 21st International Conference on Very Large Data Bases, </booktitle> <address> Zurich, Switzerland, </address> <year> 1995. </year>
Reference-contexts: One drawback is that all the components of the resultant system appear to be built from scratch, and there seems to be no way to integrate a TMM with an existing DBMS. Barga and Pu have designed a Reflective Transaction Framework to implement extended transaction models <ref> [2] </ref>. Using transaction adapters, add-on modules that are built on top of an existing TM, they show how to extend the underlying functionality of the TM. In their case, they extended 15 the Encina [12] transaction processing monitor by capitalizing on the callback functionality provided by Encina.
Reference: [3] <author> Naser S. Barghouti. </author> <title> Concurrency Control in Rule-Based Software Development Environments. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <month> February </month> <year> 1992. </year> <note> CUCS-001-92. 17 </note>
Reference-contexts: The cord language is a rule-based CCL influenced by Barghouti's 4 type attribute transaction tid, lockset, parent, subtransactions, top level object oid, name, lockset, class lock lock mode, tid, object Control Rule Language <ref> [3] </ref>. The preamble defines mediator functions in an objectcode file that will be dynamically linked with the cord engine to extend its functionality. <p> A configurable lock-matrix, however, is not powerful enough to provide fine-grained control; for example, AL could not be implemented solely by a complex matrix (as in Papyrus [28]). The TM could always be modified to acquire semantic information when determining lock conflicts. Barghouti <ref> [3] </ref> designed a TM that employed a special-purpose language for programming concurrency control policies for rule-based software development environments (RBDEs). His TM extracted seven pieces of semantic information from RBDEs and had a language for specifying concurrency control policies.
Reference: [4] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Concurrency control in advanced database applications. </title> <journal> ACM Computing Surveys, </journal> <volume> 23(3) </volume> <pages> 269-317, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Advanced database applications (henceforth applications) require more sophisticated concurrency control mechanisms than the standard ACID transaction model provides <ref> [4, 29, 11] </ref>. For this reason, many extended transaction models (ETMs) have been developed [14, 31, 23] that rely on special semantic information about the transactions and their operations.
Reference: [5] <author> Israel Z. Ben-Shaul and Gail E. Kaiser. </author> <title> A Paradigm for Decentralized Process Modeling. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, MA, </address> <year> 1995. </year>
Reference-contexts: These diverse applications have one feature in common they have a task manager that stores rich semantic information about the transactions submitted to DBMS. The FlowMark Workflow system [26], for example, stores a workflow process as a directed acyclic graph of activities. In the Oz Process-Centered Environment <ref> [5] </ref>, a process engine interprets task models encoded in planning-style rules. <p> The size and number of mediator code is reasonable, especially considering the extra benefits of being able to tailor an ETM on top of an existing DBMS. The ESR cord experiment was implemented and tested within Oz <ref> [5] </ref>, a rule-based process-centered environment. The AL solution was first designed and tested for a small demonstration environment and then was reproduced within Exodus.
Reference: [6] <author> Israel Z. Ben-Shaul, Gail E. Kaiser, and George T. Heineman. </author> <title> An architecture for multiuser software development environments. </title> <journal> Computing Systems, The Journal of the USENIX Association, </journal> <volume> 6(2) </volume> <pages> 65-103, </pages> <month> Spring </month> <year> 1993. </year>
Reference-contexts: To use these new lock modes, however, the application designer might have to modify and rebuild parts of the system. Some DBMSs provide support for defining new lock modes as needed, without any recompilation. The TM in the Marvel process-centered environment <ref> [6] </ref>, for example, determines its lock modes from a fully-configurable lock matrix file; each Marvel task encodes the lock modes it will request from the TM.
Reference: [7] <author> P. A. Bernstein and N. Goodman. </author> <title> Timestamp-based algorithms for concurrency control in distributed database systems. </title> <editor> In Lochovsky and Taylor, editors, </editor> <booktitle> Proceedings of the 6th Conference on Very Large Databases, </booktitle> <address> Montreal, Canada, October 1980. </address> <publisher> Morgan Kaufmann Publishers. </publisher>
Reference-contexts: The same cord engine was used for all experiments: only the mediator code and ETM specifications changed. 6.1 Support for Locking The TM can detect serializability conflicts using either locking, timestamp ordering (TO) <ref> [7] </ref>, optimistic concurrency control (OCC) [24], or any other equivalent method. In addition to being the most popular, we feel that locking is most suitable for extensible concurrency control. OCC is inappropriate for several reasons. First, OCC determines conflicts after they occur, when a transaction, T , attempts to commit.
Reference: [8] <author> A. Biliris, S. Dar, N. Gehani, H.V. Jagadish, and K. Ramamritham. </author> <title> ASSET: A system for supporting extended transactions. </title> <booktitle> In 1994 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 44-54, </pages> <address> Minneapolis MN, </address> <month> May </month> <year> 1994. </year> <journal> Special issue of SIGMOD Record, </journal> <volume> 23(2), </volume> <month> June </month> <year> 1994. </year>
Reference-contexts: An ETM can be completely characterized by a list of axiomatic definitions. This specification, however, cannot readily be used by a DBMS to implement an ETM for an application. Inspired by Acta, Asset <ref> [8] </ref> allows users to define custom transaction semantics for specific applications. It provides transaction primitives that can be composed together to define a variety of ETMs. Asset still needs some higher layer, however, to appropriately organize its primitives based upon the available semantic information.
Reference: [9] <author> M. Carey, D. DeWitt, G. Graefe, D. Haight, J. Richardson, D. Schuh, E. Shekita, and S. Van-denberg. </author> <title> The exodus extensible dbms project: An overview. </title> <editor> In Stanley B. Zdonik and David Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, chapter 7.3, </booktitle> <pages> pages 474-499. </pages> <publisher> Morgan Kaufman, </publisher> <address> San Mateo CA, </address> <year> 1990. </year>
Reference-contexts: We present the features of a rule-based CCL called cord (for COoRDination) and its cord engine, and show how to implement Altruistic Locking (AL) [31], a well-known ETM from the literature. We then discuss our experience integrating the cord engine with the Exodus Storage Manager <ref> [9] </ref> to implement AL within Exodus. Finally, we evaluate our efforts and related work, and summarize our contributions. 2 Architecture TM. The ETM specification is first translated into a machine-readable format that is loaded by the CCL engine upon initialization. <p> Neither the TM nor the cord engine were altered in any way; only the ETM specification and mediator code (included dynamic code) were added for this solution. 5 Example Integration with DBMS We next integrated the cord engine with the Exodus Storage Manager <ref> [9] </ref>. In Exodus, client applications share memory pages from a virtual "volume" residing on a storage manager server. A locking conflict, therefore, occurs on a particular page and volume.
Reference: [10] <author> Panos K. Chrysanthis and Krithi Ramamritham. </author> <title> Synthesis of Extended Transaction Models using ACTA. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(3) </volume> <pages> 450-491, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: The add dependency (?Tconflict, ?Tactive, abort) action, for example, ensures that if the TM ever aborts ?Tactive, the cord engine will abort ?Tconflict. Removing dependencies between transactions, for example, allows a sub-transaction to be treated as top-level. Acta <ref> [10] </ref> defines twelve types of dependencies between transactions, but we limit cord to these two since most of the Acta dependencies are the domain of the database application, and too tightly bind the TM with the task manager. suspend (?t1, ?t2) blocks transaction ?t1 until ?t2 has either committed or aborted, <p> When attaching the cord engine to an existing TM, the cord primitive actions (i.e., abort, suspend) are parameterized to invoke corresponding primitives from the API for the TM. If the TM cannot suspend transactions, for example, no cord rule can use this primitive. 7 Related Work The Acta framework <ref> [10] </ref> constructs a theoretical model that helps reason about and compare different ETMs. An ETM can be completely characterized by a list of axiomatic definitions. This specification, however, cannot readily be used by a DBMS to implement an ETM for an application.
Reference: [11] <author> Umesh Dayal, Hector Garcia-Molina, Mei Hsu, Ben Kao, and Ming-Chien Shan. </author> <title> Third generation TP monitors: A database challenge. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 22(2) </volume> <pages> 393-397, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Advanced database applications (henceforth applications) require more sophisticated concurrency control mechanisms than the standard ACID transaction model provides <ref> [4, 29, 11] </ref>. For this reason, many extended transaction models (ETMs) have been developed [14, 31, 23] that rely on special semantic information about the transactions and their operations.
Reference: [12] <institution> Encina Product Overview, Transarc Corp, </institution> <address> Pittsburgh, PA. http://www.transarc.com. </address>
Reference-contexts: Motivating Example Consider solving this banking example to allow the Balance transaction to observe temporarily inconsistent data. If the TM has a sophisticated interface, such as Encina <ref> [12] </ref>, it might be possible to modify and reimplement the application for an individual case. As more and more special cases arise, however, some model is needed to reduce complexity; as an example, Epsilon Serializabil-ity [30] (ESR) is an ETM that increases concurrency by allowing bounded inconsistencies to occur. <p> These changes are represented by the thin black rectangles in Figure 2; Figure 3 shows the modified Lock primitive in more detail. We feel these two features should be part of any DBMS that provides extensible transaction management; in fact, this interface is already very similar to Encina <ref> [12] </ref>. In Section 5 we describe how we modified the Exodus Storage Manager to include these features. <p> Barga and Pu have designed a Reflective Transaction Framework to implement extended transaction models [2]. Using transaction adapters, add-on modules that are built on top of an existing TM, they show how to extend the underlying functionality of the TM. In their case, they extended 15 the Encina <ref> [12] </ref> transaction processing monitor by capitalizing on the callback functionality provided by Encina. This is very similar to our approach at utilizing the mediator architecture of our TM component.
Reference: [13] <author> K. P. Eswaran, J. N. Gray, R. A. Lorie, and I. L. Traiger. </author> <title> The notions of consistency and predicate locks in a database system. </title> <journal> Communications of the ACM, </journal> 19(11) 624-632, November 1976. 
Reference-contexts: AL is an extension to two-phase locking (2PL) <ref> [13] </ref> that accommodates long-lived transactions. Under 2PL, short transactions will encounter serious delays since database resources can be locked for significant lengths of time. In AL, several transactions can hold conflicting locks on a data item if constraints AL1 and AL2 in Figure 7 are satisfied.
Reference: [14] <author> Hector Garcia-Molina and Kenneth Salem. </author> <title> Sagas. </title> <editor> In Umeshwar Dayal and Irv Traiger, editors, </editor> <booktitle> ACM SIGMOD 1987 Annual Conference, </booktitle> <pages> pages 249-259, </pages> <address> San Francisco CA, </address> <month> May </month> <year> 1987. </year> <journal> Special issue of SIGMOD Record, </journal> <volume> 16(3), </volume> <month> December </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Advanced database applications (henceforth applications) require more sophisticated concurrency control mechanisms than the standard ACID transaction model provides [4, 29, 11]. For this reason, many extended transaction models (ETMs) have been developed <ref> [14, 31, 23] </ref> that rely on special semantic information about the transactions and their operations. There is no consensus, however, as to which ETM is appropriate for advanced applications; most likely, there never will be, since each ETM is optimized for a particular behavior.
Reference: [15] <author> Dimitrios Georgakopoulos, Mark Hornick, and Amit Sheth. </author> <title> An overview of workflow management: From process modeling to workflow automation infrastructure. </title> <booktitle> Distributed and Parallel Databases, </booktitle> <volume> 3 </volume> <pages> 119-153, </pages> <year> 1995. </year>
Reference-contexts: Alternatively, the application could be tightly integrated with the TM (e.g., transactional workflows <ref> [15] </ref>), granting the application fine-grained control over transaction behavior.
Reference: [16] <author> Dimitris Georgakopoulos, Mark Hornick, Piotr Krychniak, and Frank Manola. </author> <title> Specification and management of extended transactions in a programmable transaction environment. </title> <booktitle> In 10th International Conference on Data Engineering, </booktitle> <pages> pages 462-473, </pages> <address> Houston TX, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: It provides transaction primitives that can be composed together to define a variety of ETMs. Asset still needs some higher layer, however, to appropriately organize its primitives based upon the available semantic information. The Transaction Specification and Management Environment (TSME) <ref> [16] </ref> is closest to our approach. TSME provides a transaction specification language and a programmable transaction management mechanism (TMM) that configures a run-time environment to support a specified ETM. TMM translates a transaction model specification into a set of instructions and assembles run-time support from a transaction processing toolkit.
Reference: [17] <author> J. Gray, R. Lorie, and G. Putzolu. </author> <title> Granularity of locks and degrees of consistency in a shared database. </title> <booktitle> In International Conference on Very Large Data Bases, </booktitle> <pages> pages 428-451. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1975. </year>
Reference-contexts: Thus, implementing the Donate operation itself required some effort. In [31], the authors discuss other problems, related to recovery, that AL might introduce. The second problem reveals a subtle interaction between granularity locking <ref> [17] </ref> and AL. When scanning a file, Exodus acquires a file lock instead of acquiring a separate lock for each page in the file. The transaction scanning a file, however, cannot donate this file lock until it completes the scan.
Reference: [18] <author> Thanasis Hadzilacos and Vassos Hadzilacos. </author> <title> Transactions synchronization in object bases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43 </volume> <pages> 2-24, </pages> <year> 1991. </year>
Reference-contexts: These cord rules can be viewed as concurrency control methods that an object employs to resolve conflicts (similar to an approach suggested by <ref> [18] </ref>). Multiple rules defined for the same class are differentiated by a selection criterion, allowing the cord engine to select at run-time the most applicable cord rule. Each cord rule can optionally bind variables (shown as ?var) that refer to semantic infor 5 mation required by its policies.
Reference: [19] <author> George T. Heineman. </author> <title> A Transaction Manager Component Supporting Extended Transaction Models. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <year> 1996. </year> <month> Forthcoming. 18 </month>
Reference-contexts: an object, the TM invokes the cord engine to resolve the conflict, constructing a scenario containing the object's unique identifier (oid) and class name, and the unique transaction identifiers (tid) of the two conflicting transactions (i.e., if three transactions conflict with each other, the conflicts are handled in pairwise fashion; <ref> [19] </ref> presents an approach for handling sets of conflicts at once). The cord engine acts like an expert system, reacting to conflicts by invoking the appropriate policy. If no suitable policy is found, the TM responds to the conflict in its usual fashion. <p> Other actions are defined in <ref> [19] </ref>. The DBMS engineers are responsible for integrating the TM with the cord engine. In addition to the effort outlined in Section 2, this means that mediator functions need to be written for each of cord's default actions to interface to the specific TM. <p> Note that ESR is equivalent to Serializability if all transaction*-spec values are 0. In this paper, we implement a restricted form of ESR that does not allow update transactions to import consistency; a more general form of ESR has been implemented in <ref> [19] </ref>. Each ET maintains a fixed ImpLimit (ExpLimit) as part of its *-spec that determines the bounded amount of inconsistency it can import (export). Each ET also maintains a running import (export) accumulator that it updates whenever it imports (exports) inconsistency.
Reference: [20] <author> George T. Heineman and Gail E. Kaiser. </author> <title> An architecture for integrating concurrency control into environment frameworks. </title> <booktitle> In 17th International Conference on Software Engineering, </booktitle> <pages> pages 305-313, </pages> <address> Seattle WA, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: The transaction scanning a file, however, cannot donate this file lock until it completes the scan. To work around this problem, we programmed a client application to mimic a scan by manually requesting each page in order. 6 Evaluation In a previous paper <ref> [20] </ref>, we presented an architecture for integrating a TM component into environment frameworks.
Reference: [21] <author> Mark F. Hornick and Stanley B. Zdonik. </author> <title> A shared, segmented memory system for an object-oriented database. </title> <journal> ACM Transactions on Office Automation Systems, </journal> <volume> 5(1) </volume> <pages> 70-95, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: In lock-based TMs, the most common means of extension is to provide additional lock modes, or allow new ones to be defined. Most lock-based systems use a matrix to record lock compatibility information (e.g., Exodus and ObServer <ref> [21] </ref>).
Reference: [22] <author> Gail E. Kaiser. </author> <title> Cooperative transactions for multi-user environments. </title> <editor> In Won Kim, editor, </editor> <title> Modern Database Systems: The Object Model, Interoperability, and Beyond, </title> <booktitle> chapter 20, </booktitle> <pages> pages 409-433. </pages> <publisher> ACM Press, </publisher> <address> New York NY, </address> <year> 1994. </year>
Reference-contexts: The only contention for shared objects occurs when a transaction checks in/out an object. We view checkout, versions, and configurations as the domain of the application rather than something to be imposed by the TM. See <ref> [22] </ref> for a survey of extended checkout models. 16 8 Contributions and Future Work Advanced database applications use databases to store information but they require more sophisticated concurrency control policies than standard DBMSs provide. Fortunately, such applications contain semantic information that describes their transactional needs.
Reference: [23] <author> Gail E. Kaiser and Calton Pu. </author> <title> Dynamic restructuring of transactions. </title> <editor> In Ahmed K. El-magarmid, editor, </editor> <title> Database Transaction Models for Advanced Applications, </title> <booktitle> chapter 8, </booktitle> <pages> pages 265-295. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo CA, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Advanced database applications (henceforth applications) require more sophisticated concurrency control mechanisms than the standard ACID transaction model provides [4, 29, 11]. For this reason, many extended transaction models (ETMs) have been developed <ref> [14, 31, 23] </ref> that rely on special semantic information about the transactions and their operations. There is no consensus, however, as to which ETM is appropriate for advanced applications; most likely, there never will be, since each ETM is optimized for a particular behavior.
Reference: [24] <author> H. T. Kung and John Robinson. </author> <title> On optimistic methods for concurrency control. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(2) </volume> <pages> 213-226, </pages> <month> June </month> <year> 1981. </year>
Reference-contexts: The same cord engine was used for all experiments: only the mediator code and ETM specifications changed. 6.1 Support for Locking The TM can detect serializability conflicts using either locking, timestamp ordering (TO) [7], optimistic concurrency control (OCC) <ref> [24] </ref>, or any other equivalent method. In addition to being the most popular, we feel that locking is most suitable for extensible concurrency control. OCC is inappropriate for several reasons. First, OCC determines conflicts after they occur, when a transaction, T , attempts to commit.
Reference: [25] <institution> Programming Systems Lab. </institution> <note> Marvel 3.1.1 administrator manual. Technical Report CUCS-038-93c, </note> <institution> Columbia University Department of Computer Science, </institution> <year> 1993. </year>
Reference-contexts: In the context of Barghouti's Control Rule Language, we successfully implemented the cord suspend action in the Marvel process-centered environment <ref> [25] </ref>, but this required significant portions of process engine (i.e., Marvel's task manager) to be reimplemented to be aware that a process task could be suspended at any point during its execution.
Reference: [26] <author> F. Leymann and D. </author> <title> Roller. Business processes management with FlowMark. </title> <booktitle> In 39th IEEE Computer Society International Conference (CompCon), Digest of Papers, </booktitle> <pages> pages 230-233, </pages> <address> San Francisco, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: Advanced applications include software development environments, network management, work-flow management systems, computer-aided design and manufacturing, and managed healthcare. These diverse applications have one feature in common they have a task manager that stores rich semantic information about the transactions submitted to DBMS. The FlowMark Workflow system <ref> [26] </ref>, for example, stores a workflow process as a directed acyclic graph of activities. In the Oz Process-Centered Environment [5], a process engine interprets task models encoded in planning-style rules.
Reference: [27] <author> C. Mohan, D. Haderle, B. Lindsay, H. Piradesh, and P. Schwarz. </author> <title> ARIES: A transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging. </title> <journal> ACM Transactions on Database Systems, </journal> <year> 1991. </year>
Reference-contexts: If the transaction only flushes its pages onto durable storage when it commits, future transactions that read this page will see the old value. This problem could have been foreseen since AL does not guarantee failure-atomic transactions and Exodus implements log-based recovery based on the ARIES algorithm <ref> [27] </ref>. We therefore need to flush these pages to storage whenever a page is donated. Also, since the client forces pages to the server when a transaction commits, we must not force already donated pages. Thus, implementing the Donate operation itself required some effort.
Reference: [28] <author> Marie-Anne Neimat and Kevin Wilkinson. </author> <title> Extensible transaction management in Papyrus. </title> <editor> In Bruce Shriver, editor, </editor> <booktitle> 23rd Annual Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 503-511, </pages> <address> Kona HI, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: A configurable lock-matrix, however, is not powerful enough to provide fine-grained control; for example, AL could not be implemented solely by a complex matrix (as in Papyrus <ref> [28] </ref>). The TM could always be modified to acquire semantic information when determining lock conflicts. Barghouti [3] designed a TM that employed a special-purpose language for programming concurrency control policies for rule-based software development environments (RBDEs).
Reference: [29] <editor> Erich Neuhold and Michael Stonebraker (editors). </editor> <title> Future directions in DBMS research. </title> <journal> SIG-MOD Record, </journal> <volume> 18(1) </volume> <pages> 17-26, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Advanced database applications (henceforth applications) require more sophisticated concurrency control mechanisms than the standard ACID transaction model provides <ref> [4, 29, 11] </ref>. For this reason, many extended transaction models (ETMs) have been developed [14, 31, 23] that rely on special semantic information about the transactions and their operations.
Reference: [30] <author> Calton Pu. </author> <title> Generalized transaction processing with epsilon-serializability. </title> <booktitle> In Proceedings of the 1991 International Workshop on High Performance Transaction Systems, </booktitle> <year> 1991. </year>
Reference-contexts: If the TM has a sophisticated interface, such as Encina [12], it might be possible to modify and reimplement the application for an individual case. As more and more special cases arise, however, some model is needed to reduce complexity; as an example, Epsilon Serializabil-ity <ref> [30] </ref> (ESR) is an ETM that increases concurrency by allowing bounded inconsistencies to occur. The TM could be reimplemented to support ESR, but if the behavior changed yet again, more reimplementation would be necessary. <p> Appendix B contains an example of this mediator function. These examples of mediation show how the cord engine is insulated from the details of the other system components. 3.2 Motivating Example Revisited To return to our opening example, we now present a cord implementation of ESR <ref> [30] </ref>. Each Epsilon Transaction (ET) has a specification (called an *-spec) of its allowed import and export inconsistency. A transaction imports inconsistency by reading the uncommitted results of an update transaction; this update transaction is then considered to have exported inconsistency.
Reference: [31] <author> Kenneth Salem, Hector Garcia-Molina, and Jeannie Shands. </author> <title> Altruistic locking. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(1) </volume> <pages> 117-165, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Advanced database applications (henceforth applications) require more sophisticated concurrency control mechanisms than the standard ACID transaction model provides [4, 29, 11]. For this reason, many extended transaction models (ETMs) have been developed <ref> [14, 31, 23] </ref> that rely on special semantic information about the transactions and their operations. There is no consensus, however, as to which ETM is appropriate for advanced applications; most likely, there never will be, since each ETM is optimized for a particular behavior. <p> We present the features of a rule-based CCL called cord (for COoRDination) and its cord engine, and show how to implement Altruistic Locking (AL) <ref> [31] </ref>, a well-known ETM from the literature. We then discuss our experience integrating the cord engine with the Exodus Storage Manager [9] to implement AL within Exodus. Finally, we evaluate our efforts and related work, and summarize our contributions. 2 Architecture TM. <p> If either the application or the TM is replaced, only the specific mediator functions need to be rewritten; the cord engine remains unchanged. 4 Example Extended Transaction Model We now present a full cord solution to extending a TM for Altruistic Locking (AL) ETM <ref> [31] </ref>. AL is an extension to two-phase locking (2PL) [13] that accommodates long-lived transactions. Under 2PL, short transactions will encounter serious delays since database resources can be locked for significant lengths of time. <p> The Unlock operation is extended by binding its unlock before mediator to AL::unlock before; this mediator and the new AL::donate primitive operation manage d (a). When transactions commit (abort), the commit after (abort after) mediator, bound to AL::complete tx, updates ActiveSet. The AL protocol presented in <ref> [31] </ref> upgrades read locks to write locks solely to preserve the indebted relationship between transactions. Instead of altering the locks held by the lock manager, our solution maintains several sets for each database object a and transaction T , as shown in Figure 7. <p> We therefore need to flush these pages to storage whenever a page is donated. Also, since the client forces pages to the server when a transaction commits, we must not force already donated pages. Thus, implementing the Donate operation itself required some effort. In <ref> [31] </ref>, the authors discuss other problems, related to recovery, that AL might introduce. The second problem reveals a subtle interaction between granularity locking [17] and AL. When scanning a file, Exodus acquires a file lock instead of acquiring a separate lock for each page in the file.
Reference: [32] <author> Andrea Helen Skarra. </author> <title> A Model of Concurrency Control for Cooperating Transactions. </title> <type> PhD thesis, </type> <institution> Brown University, </institution> <month> May </month> <year> 1991. </year> <month> 19 </month>
Reference-contexts: The ETM specification enumerates the differences from serializability, the standard correctness model for most DBMSs. We view approaches that model every database access by all transactions (such 2 as pattern machines <ref> [32] </ref> or Relative Serializability [1]) as impractical since each transaction that wishes to relax atomicity would first have to analyze the operations of all other potentially affected transactions.
References-found: 32

