URL: http://www.cs.cmu.edu/afs/cs/usr/garth/pub/SDCR/SDCR-final-report.ps
Refering-URL: http://gs213.sp.cs.cmu.edu/prog/findhome/?query=Garth.Gibson
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Storage I/O Issues in Large-Scale Computing  (HP Labs) With participation from  
Author: Garth A. Gibson (CMU), Jeffrey Scott Vitter (Duke), and John Wilkes Alok Choudhary (Northwestern), Peter Corbett (IBM), Thomas H. Cor-men (Dartmouth), Carla Schlatter Ellis (Duke), Michael T. Goodrich (Johns Hopkins), Peter High-nam (Schlumberger), David Kotz (Dartmouth), Kai Li (Princeton), Richard R. Muntz (UCLA), Joseph Pasquale (UCSD), M. Satyanarayanan (CMU), and Darren Erik Vengroff 
Affiliation: (Delaware).  
Note: Report of the Working Group on  ACM Workshop on Strategic Directions in Computing Research Edited by  
Abstract: ACM Computing Surveys, 28 (4), December 1996, also available as http://www.cs.duke.edu/~jsv/report.ps. Copyright c fl 1996 by the Association for Computing Machinery, Inc. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Acharya, A., Uysal, M., Bennett, R., Mendelson, A., Beynon, M., Hollingsworth, J. K., Saltz, J., and Sussman, A. </author> <title> Tuning the performance of I/O intensive parallel applications. </title> <booktitle> In Fourth Workshop on Input/Output in Parallel and Distributed Systems (Philadelphia, </booktitle> <month> May </month> <year> 1996), </year> <pages> pp. 15-27. </pages>
Reference-contexts: If storage systems could recognize and exploit this structure information where it is useful, they could provide more effective application support. Similarly, the access patterns of I/O-intensive applications, within and across files, are increasingly predictable <ref> [1, 17, 40] </ref>. For example, matrix subroutines often access data in regular patterns called strides. Full text search sequentially processes each file in a set. Incremental compilation and linking generally operate on the same set of files and library modules during each invocation.
Reference: [2] <author> Baker, M. G., Hartman, J. H., Kupfer, M. D., Shirriff, K. W., and Ousterhout, J. K. </author> <title> Measurements of a distributed file system. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating Systems Principles (October 1991), </booktitle> <pages> pp. 198-212. </pages>
Reference-contexts: Models of all levels of abstraction will be needed: workload distributions, extensive application traces, device and subsystem simulations, mathematical models of service class interactions, asymptotic behavior, and average-case and worst-case bounds <ref> [2, 10, 41, 59, 60, 71, 78] </ref>. Rapid progress in the modeling area is important to some strategic goals. For example, the utility of specific data-type or access-pattern information depends upon the existence of models exploiting this information.
Reference: [3] <author> Bershad, B. N., Savage, S., Pardyak, P., Sirer, E. G., Fiuczynski, M., Becker, D., Eggers, S., and Chambers, C. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles (Copper Mountain, </booktitle> <address> Colorado, </address> <month> December </month> <year> 1995). </year>
Reference-contexts: An important recent approach to application customization in operating systems can also be applied to storage systems. This is the use of mechanisms that allow applications to help operating systems make critical policy decisions <ref> [3, 22] </ref>.
Reference: [4] <author> Berson, S., Golubchik, L., and Muntz, R. R. </author> <title> Fault tolerant design of multimedia servers. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data (1995), </booktitle> <pages> pp. 364-375. </pages>
Reference-contexts: Storage systems for continuous media, and the associated bandwidth and latency guarantees, make heavy use of scheduling to maximize storage efficiency while providing as much predictability as possible <ref> [4, 56] </ref>.
Reference: [5] <author> Brustoloni, J. C., and Steenkiste, P. </author> <title> Effects of buffering semantics on I/O performance. </title> <booktitle> In Proceedings of the 1996 OSDI Conference (1996). </booktitle> <pages> 11 </pages>
Reference-contexts: The storage system may refuse this, but instead counteroffer a guarantee if the application is willing to use a more appropriate request size. Similarly, a best-effort access may inquire of the storage system the access size and alignment that leads to highest throughput <ref> [5, 53] </ref>. The negotiation interface can be extended to handle dynamic changes in the application requirements or the available resources that may nullify a pre-negotiated service quality. Prefetching and caching policies on mobile computers with variable network connectivity are expected to need such cooperative dynamic adaptation [51].
Reference: [6] <author> Buzzard, G., Jacobson, D., Mackey, M., Marovich, S., and Wilkes, J. </author> <title> An implementation of the Hamlyn sender-managed interface architecture. </title> <booktitle> In Proceedings of the 1996 OSDI Conference (Seattle, </booktitle> <address> WA, </address> <month> October </month> <year> 1996), </year> <booktitle> Usenix Association, </booktitle> <address> Berkeley, CA. </address>
Reference-contexts: Consequently, demanding applications such as database management systems prefer to take total responsibility [67]. In the analogous case of the network interface, there is also much interest in allowing applications to access devices directly and bear responsibility for management <ref> [6, 46, 72] </ref>. An important recent approach to application customization in operating systems can also be applied to storage systems. This is the use of mechanisms that allow applications to help operating systems make critical policy decisions [3, 22].
Reference: [7] <author> Cao, P., Felten, E. W., Karlin, A., and Li, K. </author> <title> Implementation and performance of integrated application-controlled caching, prefetching and disk scheduling. </title> <note> ACM Transactions on Computer Systems (to appear). An earlier version available as Technical Report CS-TR-94-493, </note> <institution> Princeton University. </institution>
Reference-contexts: For example, algorithms have been developed for efficient use of device parallelism and cache resources, given sufficient access pattern information or hints <ref> [7, 36, 54] </ref>. Useful extensions would be to support multiple active streams with different information sources (type, access pattern, service parameter), different accuracies of advance knowledge, and different service requirements.
Reference: [8] <author> Carey, M. J., DeWitt, D. J., Franklin, M. J., Hall, N. E., McAuliffe, M. L., Naughton, J. F., Schuh, D. T., Solomon, M. H., Tan, C. K., Tsatalos, O. G., White, S. J., and Zwilling, M. J. </author> <title> Shoring up persistent applications. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data (1994), </booktitle> <pages> pp. 383-394. </pages>
Reference-contexts: Framework-oriented interfaces can be effective for irregular memory access patterns. By a similar extension of the storage abstraction, object-oriented storage (or object stores) enhance the integrity of persistent data (that is, its resistance to loss of semantic meaning) through type-safe, object-oriented computational models <ref> [8, 33, 45, 52, 64, 79] </ref>. The efficiency of array-oriented, framework-oriented, and object-oriented storage systems depends critically upon the appropriate mapping of the higher-level semantics to the functionality of the lower levels of the I/O system.
Reference: [9] <author> Chen, P. M., Lee, E. K., Gibson, G. A., Katz, R. H., and Patterson, D. A. </author> <title> RAID: high-performance, reliable secondary storage. </title> <journal> ACM Computing Surveys 26, </journal> <month> 2 (June </month> <year> 1994), </year> <pages> 145-185. </pages>
Reference-contexts: and to distribute spare sectors so that a replacement sector can be near a faulty sector, without having to modify the applications that use the device (in this case, operating systems software). 6 Virtual device interfaces are used by disk arrays (commonly called Redundant Arrays of Inde--pendent Disks, or RAID <ref> [9] </ref>) that provide full or partial redundancy for stored data to increase its availability. By doing so, they are able to hide the details of the location of redundant information and its relationship with non-redundant data (for example, which blocks are in a mirrored pair or parity set) [42].
Reference: [10] <author> Chen, S., and Towsley, D. </author> <title> A queueing analysis of RAID architectures. </title> <type> Tech. Rep. COINS 91-71, </type> <institution> University of Massachusetts, Department of Computer and Information Science, University of Mas-sachusetts, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: Models of all levels of abstraction will be needed: workload distributions, extensive application traces, device and subsystem simulations, mathematical models of service class interactions, asymptotic behavior, and average-case and worst-case bounds <ref> [2, 10, 41, 59, 60, 71, 78] </ref>. Rapid progress in the modeling area is important to some strategic goals. For example, the utility of specific data-type or access-pattern information depends upon the existence of models exploiting this information.
Reference: [11] <author> Chiang, Y.-J., Goodrich, M. T., Grove, E. F., Tamassia, R., Vengroff, D. E., and Vitter, J. S. </author> <title> External-memory graph algorithms. </title> <booktitle> In Proceedings of the Sixth Annual ACM-SIAM Symposium on Discrete Algorithms (San Francisco, </booktitle> <address> CA, </address> <month> January </month> <year> 1995), </year> <pages> pp. 139-149. </pages>
Reference-contexts: Linear algebra methodologies are useful in designing I/O-efficient algorithms that manipulate data obliviously in regular patterns [16, 44], and techniques based on simulating parallel algorithms and rearranging data by sorting have been successful for adaptive processing and irregularly structured data <ref> [11] </ref>. Higher-level abstractions, perhaps implemented by compilers and runtime systems, will be needed to provide storage access semantics and support for these new I/O-efficient algorithms and the applications that use them.
Reference: [12] <author> Corbett, P., Feitelson, D., Fineberg, S., Hsu, Y., Nitzberg, B., Prost, J.-P., Snir, M., Traversat, B., and Wong, P. </author> <title> Overview of the MPI-IO parallel I/O interface. </title> <booktitle> In IPPS '95 Workshop on Input/Output in Parallel and Distributed Systems (April 1995), </booktitle> <pages> pp. 1-15. </pages>
Reference-contexts: Access-oriented extensions to the read 7 write interface typically include data type specifications and collective specification of multiple transfers, sometimes involving the memories of multiple processing nodes. These interfaces, possibly integrated into parallel programming toolkits, preserve the programmer abstraction of explicitly requesting data transfer <ref> [12, 13, 14, 62, 65] </ref>. Array-oriented (or type-oriented) interfaces [15, 69] define compiler-recognized data types (typically arrays) and operations on these datatypes. Out-of-core computation is directly specified and no explicit I/O transfers are managed by programmers.
Reference: [13] <author> Corbett, P. F., and Feitelson, D. G. </author> <title> The Vesta parallel file system. </title> <journal> ACM Transactions on Computer Systems 14, </journal> <month> 3 (August </month> <year> 1996), </year> <pages> 225-264. </pages>
Reference-contexts: Access-oriented extensions to the read 7 write interface typically include data type specifications and collective specification of multiple transfers, sometimes involving the memories of multiple processing nodes. These interfaces, possibly integrated into parallel programming toolkits, preserve the programmer abstraction of explicitly requesting data transfer <ref> [12, 13, 14, 62, 65] </ref>. Array-oriented (or type-oriented) interfaces [15, 69] define compiler-recognized data types (typically arrays) and operations on these datatypes. Out-of-core computation is directly specified and no explicit I/O transfers are managed by programmers.
Reference: [14] <author> Corbett, P. F., Feitelson, D. G., Prost, J.-P., Almasi, G. S., Baylor, S. J., Bolmarcich, A. S., Hsu, Y., Satran, J., Snir, M., Colao, R., Herr, B., Kavaky, J., Morgan, T. R., and Zlotek, A. </author> <title> Parallel file systems for the IBM SP computers. </title> <journal> IBM Systems Journal 34, </journal> <month> 2 (January </month> <year> 1995), </year> <pages> 222-248. </pages>
Reference-contexts: Access-oriented extensions to the read 7 write interface typically include data type specifications and collective specification of multiple transfers, sometimes involving the memories of multiple processing nodes. These interfaces, possibly integrated into parallel programming toolkits, preserve the programmer abstraction of explicitly requesting data transfer <ref> [12, 13, 14, 62, 65] </ref>. Array-oriented (or type-oriented) interfaces [15, 69] define compiler-recognized data types (typically arrays) and operations on these datatypes. Out-of-core computation is directly specified and no explicit I/O transfers are managed by programmers.
Reference: [15] <author> Cormen, T. H., and Colvin, A. </author> <title> ViC*: A preprocessor for virtual-memory C*. </title> <type> Tech. Rep. </type> <institution> PCS-TR94-243, Dept. of Computer Science, Dartmouth College, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: These interfaces, possibly integrated into parallel programming toolkits, preserve the programmer abstraction of explicitly requesting data transfer [12, 13, 14, 62, 65]. Array-oriented (or type-oriented) interfaces <ref> [15, 69] </ref> define compiler-recognized data types (typically arrays) and operations on these datatypes. Out-of-core computation is directly specified and no explicit I/O transfers are managed by programmers. Array-oriented systems are effective for scientific computations that make regular strides through arrays of data.
Reference: [16] <author> Cormen, T. H., and Wisniewski, L. F. </author> <title> Asymptotically tight bounds for performing BMMC permutations on parallel disk systems. </title> <booktitle> In Proceedings of the Fifth Symposium on Parallel Algorithms and Architectures (June 1993), </booktitle> <pages> pp. 130-139. </pages>
Reference-contexts: Much effort will be needed in designing I/O-efficient algorithms that use fundamentally new approaches than their internal-memory counterparts. Linear algebra methodologies are useful in designing I/O-efficient algorithms that manipulate data obliviously in regular patterns <ref> [16, 44] </ref>, and techniques based on simulating parallel algorithms and rearranging data by sorting have been successful for adaptive processing and irregularly structured data [11].
Reference: [17] <author> Curewitz, K., Krishnan, P., and Vitter, J. S. </author> <title> Practical prefetching via data compression. </title> <booktitle> In Proceedings of the 1993 ACM SIGMOD International Conference on Management of Data (May 1993), </booktitle> <pages> pp. 257-266. </pages>
Reference-contexts: If storage systems could recognize and exploit this structure information where it is useful, they could provide more effective application support. Similarly, the access patterns of I/O-intensive applications, within and across files, are increasingly predictable <ref> [1, 17, 40] </ref>. For example, matrix subroutines often access data in regular patterns called strides. Full text search sequentially processes each file in a set. Incremental compilation and linking generally operate on the same set of files and library modules during each invocation.
Reference: [18] <author> Dahlin, M., Wang, R., Anderson, T., and Patterson, D. </author> <title> Cooperative caching: Using remote client memory to improve file system performance. </title> <booktitle> In Proceedings of the 1996 OSDI Conference (November 1994). [19] de Jonge, </booktitle> <editor> W., Kaashoek, M. F., and Hsieh, W. C. </editor> <title> The logical disk: A new approach to improving file systems. </title> <booktitle> In Proc. of 14th ACM Symp. on Operating Systems Principles (December 1993). [20] del Rosario, </booktitle> <editor> J. M., and Choudhary, A. </editor> <title> High performance I/O for parallel computers: Problems and prospects. </title> <booktitle> IEEE Computer 27, </booktitle> <month> 3 (March </month> <year> 1994), </year> <pages> 59-68. </pages>
Reference-contexts: In addition to exploiting the cycles of these idle machines in parallel and distributed applications, storage systems can exploit idle cycles or memory resources for global memory management <ref> [18, 24, 29] </ref>. 4.8 Application influence over operating system policies Although it is valid to say that operating systems were invented to hide storage access and management from applications, their handling of storage systems is more generic than is appropriate for many applications.
Reference: [21] <author> Drapeau, A. L., Shirriff, K. W., Hartman, J. H., Miller, E. L., Sesha, S., Katz, R. H., Lutz, K., Patterson, D. A., Lee, E. K., Chen, P. M., and Gibson, G. A. </author> <title> Raid-ii: A high-bandwidth network file server. </title> <booktitle> In Proc. 21st Annual International Symposium on Computer Architecture (April 1994). </booktitle>
Reference-contexts: Substantial additional processing power will be available not only in end-user processors but also in server machines, storage devices and subsystems, and network devices. Putting this additional processing power to work may be a powerful tool for meeting the strategic goals of I/O systems <ref> [21, 27] </ref>. The computing power is local to the devices and can take advantage of specialized and real-time knowledge. Subsystem processing can be used for on-the-fly modeling of alternative storage configurations and dynamic reconfiguration.
Reference: [22] <author> Engler, D. R., Kaashoek, M. F., and O'Toole, Jr., J. Exokernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles (Copper Mountain, </booktitle> <publisher> CO, </publisher> <month> December </month> <year> 1995). </year> <month> 12 </month>
Reference-contexts: An important recent approach to application customization in operating systems can also be applied to storage systems. This is the use of mechanisms that allow applications to help operating systems make critical policy decisions <ref> [3, 22] </ref>.
Reference: [23] <author> English, R. M., and Stepanov, A. A. Loge: </author> <title> a self-organizing storage device. </title> <booktitle> In Proceedings of the USENIX Winter'92 Technical Conference (San Francisco, </booktitle> <address> CA, </address> <month> January </month> <year> 1992), </year> <pages> pp. 237-251. </pages>
Reference-contexts: Storage devices are typically burdened by long positioning times, and a virtual device can be used to dynamically remap the physical location associated with a logical block, thus reducing the current access latency <ref> [19, 23, 57, 58, 73] </ref>. Additionally, most modern disk drives perform dynamic request reordering, in some cases taking advantage of low-level information available only inside the storage device to optimize the request sequencing [35, 63].
Reference: [24] <author> Feeley, M. J., Morgan, W. E., Pighin, F. P., Karlin, A. R., Levy, H. M., and Thekkath, C. A. </author> <title> Implementing global memory management in a workstation cluster. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles (Copper Mountain, </booktitle> <address> Colorado, </address> <month> December </month> <year> 1995). </year>
Reference-contexts: In addition to exploiting the cycles of these idle machines in parallel and distributed applications, storage systems can exploit idle cycles or memory resources for global memory management <ref> [18, 24, 29] </ref>. 4.8 Application influence over operating system policies Although it is valid to say that operating systems were invented to hide storage access and management from applications, their handling of storage systems is more generic than is appropriate for many applications.
Reference: [25] <author> Ferrari, D. </author> <title> Client requirements for real-time communication services. </title> <journal> IEEE Communications Magazine 28, </journal> <volume> 11 (Nov. </volume> <year> 1990), </year> <pages> 65-72. </pages>
Reference-contexts: access plan to their storage system; this approach lends itself to more detailed and accurate information with less delay. 8 4.4 Quality of service negotiation The quality of service abstraction developed in the networking community is appealing because it addresses issues similar to ours, such as latency, bandwidth, and reliability <ref> [25] </ref>. If we group the requirements of storage access and management into distinct classes of service, the most relevant parameters of each class can be identified and passed to storage as access is initiated or space is allocated.
Reference: [26] <author> Gelb, J. P. </author> <title> System managed storage. </title> <journal> IBM Systems Journal 28, </journal> <volume> 1 (1989), </volume> <pages> 77-103. </pages>
Reference-contexts: In many cases, a great deal of additional information is available to describe the goals or behaviors of clients. Such needs can be captured by associating attributes with the storage or its accesses, and used to drive selection of storage device, placement, and dynamic policies such as caching <ref> [26, 30, 77] </ref>. Research problems here include finding the correct way to specify client needs and storage device behaviors and how best to map one to the other.
Reference: [27] <author> Gibson, G. A., Nagle, D. P., Amiri, K., Chang, F. W., Feinberg, E., Lee, H. G. C., Ozceri, B., Riedel, E., and Rochberg, D. </author> <title> A case for network-attached secure disks. </title> <type> Tech. Rep. </type> <institution> CMU-CS-96-142, Carnegie-Mellon University, </institution> <month> October </month> <year> 1996. </year>
Reference-contexts: Substantial additional processing power will be available not only in end-user processors but also in server machines, storage devices and subsystems, and network devices. Putting this additional processing power to work may be a powerful tool for meeting the strategic goals of I/O systems <ref> [21, 27] </ref>. The computing power is local to the devices and can take advantage of specialized and real-time knowledge. Subsystem processing can be used for on-the-fly modeling of alternative storage configurations and dynamic reconfiguration.
Reference: [28] <author> Gibson, G. A., Stodolsky, D., Chang, P. W., Courtright II, W. V., Demetriou, C. G., Ginting, E., Holland, M., Ma, Q., Neal, L., Patterson, R. H., Su, J., Youssef, R., and Zelenka, J. </author> <title> The Scotch parallel storage systems. </title> <booktitle> In Proceedings of 40th IEEE Computer Society International Conference (San Francisco, Spring 1995), </booktitle> <pages> pp. 403-410. </pages>
Reference-contexts: For example, applications and storage systems can 10 cooperate to provide optimizations specific to their access and management needs, such as better memory management, reduced data copying, and parallel execution of simple filtering functions near the data <ref> [28, 49] </ref>. 5 Concluding Remarks Storage systems are a large and important component of computing systems, and they will continue to play a vital role in the forseable future.
Reference: [29] <author> Golding, R., Bosch, P., Staelin, C., Sullivan, T., and Wilkes, J. </author> <title> Idleness is not sloth. </title> <booktitle> In Proceedings of Winter USENIX Technical Conference (Jaunary 1995), Usenix Association, </booktitle> <address> Berkeley, CA, </address> <pages> pp. 201-212. </pages>
Reference-contexts: In addition to exploiting the cycles of these idle machines in parallel and distributed applications, storage systems can exploit idle cycles or memory resources for global memory management <ref> [18, 24, 29] </ref>. 4.8 Application influence over operating system policies Although it is valid to say that operating systems were invented to hide storage access and management from applications, their handling of storage systems is more generic than is appropriate for many applications.
Reference: [30] <author> Golding, R., Shriver, E., Sullivan, T., and Wilkes, J. </author> <title> Attribute-managed storage. </title> <booktitle> In Workshop on Modeling and Specification of I/O (San Antonio, </booktitle> <address> TX, </address> <month> October </month> <year> 1995). </year>
Reference-contexts: This might allow, for example, a storage subsystem to accept new devices or workload requirements and transparently (re)configure itself to utilize the resources of the new device or meet the workload requirements <ref> [43, 30] </ref>. As these examples demonstrate, virtual device interfaces have already been exploited effectively in several ways. <p> In many cases, a great deal of additional information is available to describe the goals or behaviors of clients. Such needs can be captured by associating attributes with the storage or its accesses, and used to drive selection of storage device, placement, and dynamic policies such as caching <ref> [26, 30, 77] </ref>. Research problems here include finding the correct way to specify client needs and storage device behaviors and how best to map one to the other.
Reference: [31] <author> Griffioen, J., and Appleton, R. </author> <title> Reducing file system latency using a predictive approach. </title> <booktitle> In Proc. of 1994 Summer USENIX Conf. </booktitle> <address> (Boston, MA, </address> <year> 1994). </year>
Reference-contexts: Data types and access patterns are closely related in that we can use a data type to anticipate the data's access pattern. Wherever possible, transparent extraction of storage attributes or access patterns of specific applications is desirable <ref> [31, 68] </ref>. Transparency reduces the impetus of programmers to specialize for particular storage capabilities, avoids the costs of retrofitting old codes and retraining programmers, and avoids establishing new interdependencies between applications and storage that may become inappropriate or inefficient as technology changes.
Reference: [32] <author> Holland, M., Gibson, G. A., and Siewiorek, D. P. </author> <title> Architectures and algorithms for on-line failure recovery in redundant disk arrays. </title> <journal> Journal of Distributed and Parallel Databases 2, </journal> <month> 3 (July </month> <year> 1994), </year> <pages> 295-335. </pages>
Reference-contexts: Furthermore, disk failures can be transparently identified; the data from the broken disks can be automatically reconstructed onto spare disks, and future accesses remapped to the new devices <ref> [32] </ref>. Storage devices are typically burdened by long positioning times, and a virtual device can be used to dynamically remap the physical location associated with a logical block, thus reducing the current access latency [19, 23, 57, 58, 73].
Reference: [33] <author> Hurson, A., Pakzad, S. H., and bing Cheng, J. </author> <title> Object-oriented database management systems: Evolution and performance issues. </title> <note> IEEE Computer (February 1993). </note>
Reference-contexts: Framework-oriented interfaces can be effective for irregular memory access patterns. By a similar extension of the storage abstraction, object-oriented storage (or object stores) enhance the integrity of persistent data (that is, its resistance to loss of semantic meaning) through type-safe, object-oriented computational models <ref> [8, 33, 45, 52, 64, 79] </ref>. The efficiency of array-oriented, framework-oriented, and object-oriented storage systems depends critically upon the appropriate mapping of the higher-level semantics to the functionality of the lower levels of the I/O system.
Reference: [34] <author> IEEE Storage System Standards Working Group, </author> <title> Project 1244. Reference Model for Open Storage Systems Interconnection, </title> <month> September </month> <year> 1994. </year> <note> See also http://www.arl.mil/IEEE/ssswg.html. </note>
Reference-contexts: For more information on this area, we refer the reader to the proceedings of the IEEE Symposia on Mass Storage Systems and work elsewhere that touches on the integration of tertiary storage systems into an overall storage hierarchy (e.g., <ref> [34, 37, 47, 66] </ref>). In the next section we discuss the issues and problems in large-scale storage. An important set of broad strategic goals are identified in Section 3, and relevant research directions are outlined in Section 4. <p> Although related to a standards effort that has been underway for the last decade <ref> [34] </ref>, this strategic direction is not necessarily about standards; the goal of unification of I/O techniques is to enable new I/O intensive applications to build on the successful techniques developed specifically for other application domains.
Reference: [35] <author> Jacobson, D. M., and Wilkes, J. </author> <title> Disk scheduling algorithms based on rotational position. </title> <type> Tech. Rep. </type> <institution> HPL-CSP-91-7, Hewlett-Packard Laboratories, </institution> <address> Palo Alto, CA, </address> <note> 24th February (revised 1st March) 1991. </note>
Reference-contexts: Additionally, most modern disk drives perform dynamic request reordering, in some cases taking advantage of low-level information available only inside the storage device to optimize the request sequencing <ref> [35, 63] </ref>. Since there is no single redundant disk array organization that is optimal for all accesses, the choice of redundancy scheme used to protect data can be dynamically selected so as to balance competing demands for low cost, high throughput, and high availability [48, 61, 76].
Reference: [36] <author> Kimbrel, T., Tomkins, A., Patterson, R. H., Bershad, B., Cao, P., Felten, E. W., Gibson, G., Karlin, A. R., and Li, K. </author> <title> A trace-driven comparison of algorithms for parallel prefetching and caching. </title> <booktitle> In Proceedings of the 1996 OSDI Conference (1996). </booktitle>
Reference-contexts: For example, algorithms have been developed for efficient use of device parallelism and cache resources, given sufficient access pattern information or hints <ref> [7, 36, 54] </ref>. Useful extensions would be to support multiple active streams with different information sources (type, access pattern, service parameter), different accuracies of advance knowledge, and different service requirements.
Reference: [37] <author> Kohl, J. T., and Staelin, C. HighLight: </author> <title> using a log-structured file system for tertiary storage management. </title> <booktitle> In Proceedings of the Winter USENIX Technical Conference (San Diego, </booktitle> <address> CA, </address> <month> January </month> <year> 1993), </year> <booktitle> Usenix Association, </booktitle> <address> Berkeley, CA, </address> <pages> pp. 435-447. </pages>
Reference-contexts: For more information on this area, we refer the reader to the proceedings of the IEEE Symposia on Mass Storage Systems and work elsewhere that touches on the integration of tertiary storage systems into an overall storage hierarchy (e.g., <ref> [34, 37, 47, 66] </ref>). In the next section we discuss the issues and problems in large-scale storage. An important set of broad strategic goals are identified in Section 3, and relevant research directions are outlined in Section 4.
Reference: [38] <author> Kotz, D. </author> <title> Disk-directed I/O for MIMD multiprocessors. </title> <booktitle> In Proceedings of the 1994 Symposium on Operating Systems Design and Implementation (November 1994), </booktitle> <pages> pp. 61-74. </pages> <note> Updated as Dartmouth TR PCS-TR94-226 on November 8, </note> <year> 1994. </year>
Reference-contexts: Scheduling can improve device throughput by reordering accesses for lowered positioning times, balance the use of resources over multiple requesting applications, and reduce processing overheads by coalescing distinct accesses into a single larger access <ref> [38, 55] </ref>. For example, algorithms have been developed for efficient use of device parallelism and cache resources, given sufficient access pattern information or hints [7, 36, 54].
Reference: [39] <author> Kotz, D., and Ellis, C. S. </author> <title> Prefetching in file systems for MIMD multiprocessors. </title> <journal> IEEE Transactions on Parallel and Distributed Systems 1, </journal> <month> 2 (April </month> <year> 1990), </year> <pages> 218-230. </pages>
Reference-contexts: Prefetching and write-behind can hide access latency by overlapping accesses with computation or other accesses, increasing exploitation of parallel storage resources, and migrating storage accesses to less busy periods <ref> [39] </ref>. Caching policies can lessen the cost of accessing storage and can help balance the load on storage devices.
Reference: [40] <author> Kotz, D., and Ellis, C. S. </author> <title> Practical prefetching techniques for multiprocessor file systems. </title> <journal> Journal of Distributed and Parallel Databases 1, </journal> <month> 1 (January </month> <year> 1993), </year> <pages> 33-51. </pages>
Reference-contexts: If storage systems could recognize and exploit this structure information where it is useful, they could provide more effective application support. Similarly, the access patterns of I/O-intensive applications, within and across files, are increasingly predictable <ref> [1, 17, 40] </ref>. For example, matrix subroutines often access data in regular patterns called strides. Full text search sequentially processes each file in a set. Incremental compilation and linking generally operate on the same set of files and library modules during each invocation.
Reference: [41] <author> Lee, E. K., and Katz, R. H. </author> <title> An analytic performance model of disk arrays. </title> <booktitle> In Proceedings of SIGMETRICS (1993), </booktitle> <pages> pp. 98-109. 13 </pages>
Reference-contexts: Models of all levels of abstraction will be needed: workload distributions, extensive application traces, device and subsystem simulations, mathematical models of service class interactions, asymptotic behavior, and average-case and worst-case bounds <ref> [2, 10, 41, 59, 60, 71, 78] </ref>. Rapid progress in the modeling area is important to some strategic goals. For example, the utility of specific data-type or access-pattern information depends upon the existence of models exploiting this information.
Reference: [42] <author> Lee, E. K., and Katz, R. H. </author> <title> The performance of parity placements in disk arrays. </title> <journal> IEEE Transactions on Computers 42, </journal> <month> 6 (June </month> <year> 1993), </year> <pages> 651-664. </pages>
Reference-contexts: By doing so, they are able to hide the details of the location of redundant information and its relationship with non-redundant data (for example, which blocks are in a mirrored pair or parity set) <ref> [42] </ref>. Furthermore, disk failures can be transparently identified; the data from the broken disks can be automatically reconstructed onto spare disks, and future accesses remapped to the new devices [32].
Reference: [43] <author> Lee, E. K., and Thekkath, C. A. </author> <title> Petal: Distributed virtual disks. </title> <booktitle> In Proceedings of the 1996 ASPLOS Conference (1996). </booktitle>
Reference-contexts: This might allow, for example, a storage subsystem to accept new devices or workload requirements and transparently (re)configure itself to utilize the resources of the new device or meet the workload requirements <ref> [43, 30] </ref>. As these examples demonstrate, virtual device interfaces have already been exploited effectively in several ways.
Reference: [44] <author> Li, Z., Reif, J. H., and Gupta, S. K. S. </author> <title> Synthesizing efficient out-of-core programs for block recursive algorithms using block-cyclic data distributions. </title> <booktitle> In Proceedings of the 1996 International Conference on Parallel Processing (August 1996). </booktitle>
Reference-contexts: Much effort will be needed in designing I/O-efficient algorithms that use fundamentally new approaches than their internal-memory counterparts. Linear algebra methodologies are useful in designing I/O-efficient algorithms that manipulate data obliviously in regular patterns <ref> [16, 44] </ref>, and techniques based on simulating parallel algorithms and rearranging data by sorting have been successful for adaptive processing and irregularly structured data [11].
Reference: [45] <author> Liskov, B., Maheshwari, U., and Ng, T. </author> <title> Partitioned garbage collection of a large stable heap. </title> <booktitle> In Proceedings of IWOOOS 1996 (Seattle, </booktitle> <address> WA, </address> <year> 1996). </year>
Reference-contexts: Framework-oriented interfaces can be effective for irregular memory access patterns. By a similar extension of the storage abstraction, object-oriented storage (or object stores) enhance the integrity of persistent data (that is, its resistance to loss of semantic meaning) through type-safe, object-oriented computational models <ref> [8, 33, 45, 52, 64, 79] </ref>. The efficiency of array-oriented, framework-oriented, and object-oriented storage systems depends critically upon the appropriate mapping of the higher-level semantics to the functionality of the lower levels of the I/O system.
Reference: [46] <author> Maeda, C., and Bershad, B. </author> <title> Protocol service decomposition for high-performance networking. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles (December 1993), </booktitle> <pages> pp. 244-255. </pages>
Reference-contexts: Consequently, demanding applications such as database management systems prefer to take total responsibility [67]. In the analogous case of the network interface, there is also much interest in allowing applications to access devices directly and bear responsibility for management <ref> [6, 46, 72] </ref>. An important recent approach to application customization in operating systems can also be applied to storage systems. This is the use of mechanisms that allow applications to help operating systems make critical policy decisions [3, 22].
Reference: [47] <author> Miller, E. L., and Katz, R. H. </author> <title> An analysis of file migration in a Unix supercomputing environment. </title> <booktitle> In Proceedings of the Winter USENIX Technical Conference (San Diego, </booktitle> <address> CA, </address> <month> January </month> <year> 1993), </year> <booktitle> Usenix Association, </booktitle> <address> Berkeley, CA, </address> <pages> pp. 421-433. </pages>
Reference-contexts: For more information on this area, we refer the reader to the proceedings of the IEEE Symposia on Mass Storage Systems and work elsewhere that touches on the integration of tertiary storage systems into an overall storage hierarchy (e.g., <ref> [34, 37, 47, 66] </ref>). In the next section we discuss the issues and problems in large-scale storage. An important set of broad strategic goals are identified in Section 3, and relevant research directions are outlined in Section 4.
Reference: [48] <author> Mogi, K., and Kitsuregawa, M. </author> <title> Dynamic parity stripe reorganizations for RAID5 disk arrays. </title> <booktitle> In Proceedings of the Third International Conference on Parallel and Distributed Information Systems (September 1994), </booktitle> <pages> pp. 17-26. </pages>
Reference-contexts: Since there is no single redundant disk array organization that is optimal for all accesses, the choice of redundancy scheme used to protect data can be dynamically selected so as to balance competing demands for low cost, high throughput, and high availability <ref> [48, 61, 76] </ref>. Using a virtual device model, self-managing storage systems may migrate into the storage system much of the low-level device-management functions that are traditionally exported into client operating systems.
Reference: [49] <author> Mosberger, D., and Peterson, L. L. </author> <title> Making paths explicit in the Scout operating system. </title> <booktitle> In Proceedings of the 1996 OSDI Conference (1996). </booktitle>
Reference-contexts: For example, applications and storage systems can 10 cooperate to provide optimizations specific to their access and management needs, such as better memory management, reduced data copying, and parallel execution of simple filtering functions near the data <ref> [28, 49] </ref>. 5 Concluding Remarks Storage systems are a large and important component of computing systems, and they will continue to play a vital role in the forseable future.
Reference: [50] <author> Mowry, T. C., Demke, A. K., and Krieger, O. </author> <title> Automatic compiler-inserted I/O prefetching for out-of-core applications. </title> <booktitle> In Proceedings of the 1996 OSDI Conference (1996). </booktitle>
Reference-contexts: Alternatives to the transparent learning of types and access patterns include analysis tools in compilers and explicit hints by applications. For example, a compiler for code that processes a memory-mapped matrix structure has been shown to anticipate data needed by future iterations as it processes current iterations <ref> [50] </ref>.
Reference: [51] <author> Noble, B., Price, M., and Satyanarayanan, M. </author> <title> A programming interface for application-aware adaptation in mobile computing. </title> <booktitle> In Proceedings of the Second USENIX Symposium on Mobile & Location-Independent Computing (Ann Arbor, </booktitle> <address> MI, </address> <month> April </month> <year> 1995). </year>
Reference-contexts: The negotiation interface can be extended to handle dynamic changes in the application requirements or the available resources that may nullify a pre-negotiated service quality. Prefetching and caching policies on mobile computers with variable network connectivity are expected to need such cooperative dynamic adaptation <ref> [51] </ref>.
Reference: [52] <author> O'Toole, J., and Shrira, L. </author> <title> Opportunistic log: Efficient installation reads in a reliable object server. </title> <booktitle> In Proc of First Usenix Conference On Operating System Design and Implementation (Monterey, </booktitle> <address> CA, </address> <year> 1994). </year>
Reference-contexts: Framework-oriented interfaces can be effective for irregular memory access patterns. By a similar extension of the storage abstraction, object-oriented storage (or object stores) enhance the integrity of persistent data (that is, its resistance to loss of semantic meaning) through type-safe, object-oriented computational models <ref> [8, 33, 45, 52, 64, 79] </ref>. The efficiency of array-oriented, framework-oriented, and object-oriented storage systems depends critically upon the appropriate mapping of the higher-level semantics to the functionality of the lower levels of the I/O system.
Reference: [53] <author> Pasquale, J., Anderson, E., and Muller, P. K. </author> <title> Container shipping: Operating system support for I/O-intensive applications. </title> <journal> IEEE Computer (March 1994). </journal>
Reference-contexts: The storage system may refuse this, but instead counteroffer a guarantee if the application is willing to use a more appropriate request size. Similarly, a best-effort access may inquire of the storage system the access size and alignment that leads to highest throughput <ref> [5, 53] </ref>. The negotiation interface can be extended to handle dynamic changes in the application requirements or the available resources that may nullify a pre-negotiated service quality. Prefetching and caching policies on mobile computers with variable network connectivity are expected to need such cooperative dynamic adaptation [51].
Reference: [54] <author> Patterson, R. H., Gibson, G. A., Ginting, E., Stodolsky, D., and Zelenka, J. </author> <title> Informed prefetching and caching. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles (December 1995), </booktitle> <pages> pp. 79-95. </pages>
Reference-contexts: For example, algorithms have been developed for efficient use of device parallelism and cache resources, given sufficient access pattern information or hints <ref> [7, 36, 54] </ref>. Useful extensions would be to support multiple active streams with different information sources (type, access pattern, service parameter), different accuracies of advance knowledge, and different service requirements.
Reference: [55] <author> Purakayastha, A., Ellis, C. S., and Kotz, D. </author> <title> ENWRICH: a compute-processor write caching scheme for parallel file systems. </title> <booktitle> In Fourth Workshop on Input/Output in Parallel and Distributed Systems (May 1996), </booktitle> <pages> pp. 55-68. </pages>
Reference-contexts: Scheduling can improve device throughput by reordering accesses for lowered positioning times, balance the use of resources over multiple requesting applications, and reduce processing overheads by coalescing distinct accesses into a single larger access <ref> [38, 55] </ref>. For example, algorithms have been developed for efficient use of device parallelism and cache resources, given sufficient access pattern information or hints [7, 36, 54].
Reference: [56] <author> Reddy, A. N., and Wyllie, J. C. </author> <title> I/O issues in a multimedia system. </title> <journal> IEEE Computer (March 1994). </journal>
Reference-contexts: Storage systems for continuous media, and the associated bandwidth and latency guarantees, make heavy use of scheduling to maximize storage efficiency while providing as much predictability as possible <ref> [4, 56] </ref>.
Reference: [57] <author> Rosenblum, M., and Ousterhout, J. K. </author> <title> The design and implementation of a log-structured file system. </title> <journal> ACM Trans. on Computer Sys. </journal> <volume> 10, </volume> <month> 1 (Feb. </month> <year> 1992). </year>
Reference-contexts: Storage devices are typically burdened by long positioning times, and a virtual device can be used to dynamically remap the physical location associated with a logical block, thus reducing the current access latency <ref> [19, 23, 57, 58, 73] </ref>. Additionally, most modern disk drives perform dynamic request reordering, in some cases taking advantage of low-level information available only inside the storage device to optimize the request sequencing [35, 63].
Reference: [58] <author> Ruemmler, C., and Wilkes, J. </author> <title> Disk shu*ing. </title> <type> Tech. Rep. </type> <institution> HPL-91-156, Hewlett-Packard Laboratories, </institution> <address> Palo Alto, CA, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Storage devices are typically burdened by long positioning times, and a virtual device can be used to dynamically remap the physical location associated with a logical block, thus reducing the current access latency <ref> [19, 23, 57, 58, 73] </ref>. Additionally, most modern disk drives perform dynamic request reordering, in some cases taking advantage of low-level information available only inside the storage device to optimize the request sequencing [35, 63].
Reference: [59] <author> Ruemmler, C., and Wilkes, J. </author> <title> UNIX disk access patterns. </title> <booktitle> In Proceedings of the Winter USENIX Technical Conference (San Diego, </booktitle> <address> CA, </address> <month> January </month> <year> 1993), </year> <pages> pp. 405-420. </pages>
Reference-contexts: Models of all levels of abstraction will be needed: workload distributions, extensive application traces, device and subsystem simulations, mathematical models of service class interactions, asymptotic behavior, and average-case and worst-case bounds <ref> [2, 10, 41, 59, 60, 71, 78] </ref>. Rapid progress in the modeling area is important to some strategic goals. For example, the utility of specific data-type or access-pattern information depends upon the existence of models exploiting this information.
Reference: [60] <author> Ruemmler, C., and Wilkes, J. </author> <title> An introduction to disk drive modelling. </title> <booktitle> IEEE Computer 3, </booktitle> <month> 27 (March </month> <year> 1994), </year> <pages> 17-28. 14 </pages>
Reference-contexts: Models of all levels of abstraction will be needed: workload distributions, extensive application traces, device and subsystem simulations, mathematical models of service class interactions, asymptotic behavior, and average-case and worst-case bounds <ref> [2, 10, 41, 59, 60, 71, 78] </ref>. Rapid progress in the modeling area is important to some strategic goals. For example, the utility of specific data-type or access-pattern information depends upon the existence of models exploiting this information.
Reference: [61] <author> Savage, S., and Wilkes, J. </author> <title> AFRAID| a frequently redundant array of independent disks. </title> <booktitle> In Proceedings of the 1996 Winter USENIX Conference (January 1996), </booktitle> <pages> pp. 27-39. </pages>
Reference-contexts: Since there is no single redundant disk array organization that is optimal for all accesses, the choice of redundancy scheme used to protect data can be dynamically selected so as to balance competing demands for low cost, high throughput, and high availability <ref> [48, 61, 76] </ref>. Using a virtual device model, self-managing storage systems may migrate into the storage system much of the low-level device-management functions that are traditionally exported into client operating systems.
Reference: [62] <author> Seamons, K. E., Chen, Y., Jones, P., Jozwiak, J., and Winslett, M. </author> <title> Server-directed collective I/O in Panda. </title> <booktitle> In Proceedings of Supercomputing '95 (December 1995). </booktitle>
Reference-contexts: Access-oriented extensions to the read 7 write interface typically include data type specifications and collective specification of multiple transfers, sometimes involving the memories of multiple processing nodes. These interfaces, possibly integrated into parallel programming toolkits, preserve the programmer abstraction of explicitly requesting data transfer <ref> [12, 13, 14, 62, 65] </ref>. Array-oriented (or type-oriented) interfaces [15, 69] define compiler-recognized data types (typically arrays) and operations on these datatypes. Out-of-core computation is directly specified and no explicit I/O transfers are managed by programmers.
Reference: [63] <author> Seltzer, M., Chen, P., and Ousterhout, J. </author> <title> Disk scheduling revisited. </title> <booktitle> In Proceedings of Winter USENIX Technical Conference (January 1990), p. </booktitle> <volume> 313 323. </volume>
Reference-contexts: Additionally, most modern disk drives perform dynamic request reordering, in some cases taking advantage of low-level information available only inside the storage device to optimize the request sequencing <ref> [35, 63] </ref>. Since there is no single redundant disk array organization that is optimal for all accesses, the choice of redundancy scheme used to protect data can be dynamically selected so as to balance competing demands for low cost, high throughput, and high availability [48, 61, 76].
Reference: [64] <author> Shrira, L., Liskov, B., Castro, M., and Adya, A. </author> <title> How to scale transactional storage systems. </title> <booktitle> In Proceedings of SIGOPS European Workshop on Operating System Support for World Wide Applications (Connemara, </booktitle> <address> Ireland, </address> <year> 1996). </year>
Reference-contexts: Framework-oriented interfaces can be effective for irregular memory access patterns. By a similar extension of the storage abstraction, object-oriented storage (or object stores) enhance the integrity of persistent data (that is, its resistance to loss of semantic meaning) through type-safe, object-oriented computational models <ref> [8, 33, 45, 52, 64, 79] </ref>. The efficiency of array-oriented, framework-oriented, and object-oriented storage systems depends critically upon the appropriate mapping of the higher-level semantics to the functionality of the lower levels of the I/O system.
Reference: [65] <author> Shriver, E. A. M., and Wisniewski, L. F. </author> <title> An API for choreographing data accesses. </title> <type> Tech. Rep. </type> <institution> PCS-TR95-267, Dartmouth College Department of Computer Science, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: Access-oriented extensions to the read 7 write interface typically include data type specifications and collective specification of multiple transfers, sometimes involving the memories of multiple processing nodes. These interfaces, possibly integrated into parallel programming toolkits, preserve the programmer abstraction of explicitly requesting data transfer <ref> [12, 13, 14, 62, 65] </ref>. Array-oriented (or type-oriented) interfaces [15, 69] define compiler-recognized data types (typically arrays) and operations on these datatypes. Out-of-core computation is directly specified and no explicit I/O transfers are managed by programmers.
Reference: [66] <author> Sienknecht, T. F., Friedrich, R. J., Martinka, J. J., and Friedenbach, P. M. </author> <title> The implications of distributed data in a commercial environment on the design of hierarchical storage y management. Performance Evaluation 20, </title> <month> 1-3 (May </month> <year> 1994), </year> <pages> 3-25. </pages>
Reference-contexts: For more information on this area, we refer the reader to the proceedings of the IEEE Symposia on Mass Storage Systems and work elsewhere that touches on the integration of tertiary storage systems into an overall storage hierarchy (e.g., <ref> [34, 37, 47, 66] </ref>). In the next section we discuss the issues and problems in large-scale storage. An important set of broad strategic goals are identified in Section 3, and relevant research directions are outlined in Section 4.
Reference: [67] <author> Stonebraker, M. </author> <title> Operating system support for database management. </title> <journal> Communications of the ACM 7, </journal> <month> 24 (July </month> <year> 1981). </year>
Reference-contexts: Consequently, demanding applications such as database management systems prefer to take total responsibility <ref> [67] </ref>. In the analogous case of the network interface, there is also much interest in allowing applications to access devices directly and bear responsibility for management [6, 46, 72]. An important recent approach to application customization in operating systems can also be applied to storage systems.
Reference: [68] <author> Tait, C. D., and Duchamp, D. </author> <title> Detection and exploitation of file working sets. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems (Arlington, </booktitle> <address> TX, 1991), </address> <publisher> IEEE Computer Society, </publisher> <address> Washington, DC, </address> <pages> pp. 2-9. </pages>
Reference-contexts: Data types and access patterns are closely related in that we can use a data type to anticipate the data's access pattern. Wherever possible, transparent extraction of storage attributes or access patterns of specific applications is desirable <ref> [31, 68] </ref>. Transparency reduces the impetus of programmers to specialize for particular storage capabilities, avoids the costs of retrofitting old codes and retraining programmers, and avoids establishing new interdependencies between applications and storage that may become inappropriate or inefficient as technology changes.
Reference: [69] <author> Thakur, R., Choudhary, A., Bordawekar, R., More, S., and Kuditipudi, S. </author> <title> Passion: Optimized I/O for parallel applications. </title> <booktitle> Computer (June 1996), </booktitle> <pages> 70-78. </pages>
Reference-contexts: These interfaces, possibly integrated into parallel programming toolkits, preserve the programmer abstraction of explicitly requesting data transfer [12, 13, 14, 62, 65]. Array-oriented (or type-oriented) interfaces <ref> [15, 69] </ref> define compiler-recognized data types (typically arrays) and operations on these datatypes. Out-of-core computation is directly specified and no explicit I/O transfers are managed by programmers. Array-oriented systems are effective for scientific computations that make regular strides through arrays of data.
Reference: [70] <author> Vengroff, D. E., and Vitter, J. S. </author> <title> I/O-efficient computation: The TPIE approach. </title> <booktitle> In Proceedings of the Goddard Conference on Mass Storage Systems and Technologies (College Park, </booktitle> <address> MD, </address> <month> September </month> <year> 1996), </year> <booktitle> NASA Conference Publication 3340, </booktitle> <volume> Volume II, </volume> <pages> pp. 553-570. </pages>
Reference-contexts: Array-oriented (or type-oriented) interfaces [15, 69] define compiler-recognized data types (typically arrays) and operations on these datatypes. Out-of-core computation is directly specified and no explicit I/O transfers are managed by programmers. Array-oriented systems are effective for scientific computations that make regular strides through arrays of data. Framework-oriented interfaces <ref> [70] </ref> extend access-oriented interfaces by providing a set of efficient high-level data access methods that manage the redistribution of storage data, requiring programmers only to specify the operations to be done on the data as it is redistributed. Framework-oriented interfaces can be effective for irregular memory access patterns.
Reference: [71] <author> Vitter, J. S., and Shriver, E. A. M. </author> <title> Algorithms for parallel memory, I: Two-level memories and II: Hierarchical multilevel memories. </title> <note> Algorithmica 12, 2/3 (August and September 1994), 110-169. [72] von Eicken, </note> <author> T., Culler, D. E., Goldstein, S. C., and Schauser, K. E. </author> <title> Active messages: A mechanism for integrated communication and computation. </title> <booktitle> In Proceedings of the 19th ACM International Symposium on Computer Architecture (May 1992), </booktitle> <pages> pp. 256-266. </pages>
Reference-contexts: Models of all levels of abstraction will be needed: workload distributions, extensive application traces, device and subsystem simulations, mathematical models of service class interactions, asymptotic behavior, and average-case and worst-case bounds <ref> [2, 10, 41, 59, 60, 71, 78] </ref>. Rapid progress in the modeling area is important to some strategic goals. For example, the utility of specific data-type or access-pattern information depends upon the existence of models exploiting this information.
Reference: [73] <author> Vongsathorn, P., and Carson, S. D. </author> <title> A system for adaptive disk rearrangement. </title> <journal> Software|Practice and Experience 20, </journal> <month> 3 (March </month> <year> 1990), </year> <pages> 225-242. </pages>
Reference-contexts: Storage devices are typically burdened by long positioning times, and a virtual device can be used to dynamically remap the physical location associated with a logical block, thus reducing the current access latency <ref> [19, 23, 57, 58, 73] </ref>. Additionally, most modern disk drives perform dynamic request reordering, in some cases taking advantage of low-level information available only inside the storage device to optimize the request sequencing [35, 63].
Reference: [74] <author> Wetherall, D., and Tennenhouse, D. </author> <title> The ACTIVE IP option. </title> <booktitle> In Proceedings of the 7th ACM SIGOPS European Workshop (Connemara, </booktitle> <address> Ireland, </address> <month> September </month> <year> 1996). </year>
Reference-contexts: There are also opportunities for tight coupling with network protocols. New directions in networking research, notably the ability to execute functions in network devices, might be put to good use for meeting end-to-end application requirements from storage access <ref> [74, 75] </ref>.
Reference: [75] <author> Wilkes, J. </author> <title> DataMesh research project, phase 1. </title> <booktitle> In Proceedings of the USENIX File Systems Workshop (May 1992), </booktitle> <pages> pp. 63-69. </pages>
Reference-contexts: There are also opportunities for tight coupling with network protocols. New directions in networking research, notably the ability to execute functions in network devices, might be put to good use for meeting end-to-end application requirements from storage access <ref> [74, 75] </ref>.
Reference: [76] <author> Wilkes, J., Golding, R., Staelin, C., and Sullivan, T. </author> <title> The HP AutoRAID hierarchical storage system. </title> <journal> ACM Transactions on Computer Systems 14, </journal> <month> 1 (February </month> <year> 1996), </year> <pages> 108-136. </pages>
Reference-contexts: Since there is no single redundant disk array organization that is optimal for all accesses, the choice of redundancy scheme used to protect data can be dynamically selected so as to balance competing demands for low cost, high throughput, and high availability <ref> [48, 61, 76] </ref>. Using a virtual device model, self-managing storage systems may migrate into the storage system much of the low-level device-management functions that are traditionally exported into client operating systems. <p> For example, the utility of specific data-type or access-pattern information depends upon the existence of models exploiting this information. New storage subsystem designs such as HP AutoRAID or StorageTek Iceberg have much more complex behavior than prior subsystems such as single hard disks or RAID level 5 arrays <ref> [76] </ref>.
Reference: [77] <author> Wilkes, J., and Stata, R. </author> <title> Specifying data availability in multi-device file systems. </title> <booktitle> In Operating Systems Review (1991), vol. 25 of Position paper for 4th ACM SIGOPS European Workshop, </booktitle> <pages> pp. 56-59. </pages>
Reference-contexts: In many cases, a great deal of additional information is available to describe the goals or behaviors of clients. Such needs can be captured by associating attributes with the storage or its accesses, and used to drive selection of storage device, placement, and dynamic policies such as caching <ref> [26, 30, 77] </ref>. Research problems here include finding the correct way to specify client needs and storage device behaviors and how best to map one to the other.
Reference: [78] <author> Worthington, B. L., Ganger, G. R., Patt, Y. N., and Wilkes, J. </author> <title> On-line extraction of SCSI disk drive parameters. </title> <booktitle> In Proceedings of SIGMETRICS'95 (Ottawa, </booktitle> <address> Canada, </address> <month> May </month> <year> 1995), </year> <pages> pp. 146-156. </pages>
Reference-contexts: Models of all levels of abstraction will be needed: workload distributions, extensive application traces, device and subsystem simulations, mathematical models of service class interactions, asymptotic behavior, and average-case and worst-case bounds <ref> [2, 10, 41, 59, 60, 71, 78] </ref>. Rapid progress in the modeling area is important to some strategic goals. For example, the utility of specific data-type or access-pattern information depends upon the existence of models exploiting this information.
Reference: [79] <author> Yong, V., Naughton, J., and Yu, J. </author> <title> Storage reclamation and reorganization in client-server persistent object stores. </title> <booktitle> In In Proceedings of Data Engineering Conference (Houston, </booktitle> <address> TX, </address> <year> 1994). </year> <month> 15 </month>
Reference-contexts: For example, it is usually an application's responsibility to eliminate the dangling pointers that can be created when memory structures are stored and accessed in distinct pieces <ref> [79] </ref>. Scale. Large systems bring new problems and exacerbate old ones. The multitude of devices needed for large storage systems are hard to configure, monitor, and manage. Examples of very large scale include multi-terabyte global information systems, geographic information systems (GIS), grand challenge datasets, and digital libraries. <p> Framework-oriented interfaces can be effective for irregular memory access patterns. By a similar extension of the storage abstraction, object-oriented storage (or object stores) enhance the integrity of persistent data (that is, its resistance to loss of semantic meaning) through type-safe, object-oriented computational models <ref> [8, 33, 45, 52, 64, 79] </ref>. The efficiency of array-oriented, framework-oriented, and object-oriented storage systems depends critically upon the appropriate mapping of the higher-level semantics to the functionality of the lower levels of the I/O system.
References-found: 76

