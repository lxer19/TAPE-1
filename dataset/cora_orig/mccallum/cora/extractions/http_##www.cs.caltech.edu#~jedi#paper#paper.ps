URL: http://www.cs.caltech.edu/~jedi/paper/paper.ps
Refering-URL: http://www.ugcs.caltech.edu./~jedi/
Root-URL: http://www.cs.caltech.edu
Email: adam-@cs.caltech.edu  
Title: Providing Easier Access to Remote Objects in ClientServer Systems  
Author: Jonathan Aldrich, James Dooley, Scott Mandelsohn, and Adam Rifkin -jonal, jdooley, scott, 
Affiliation: California Institute of Technology  
Abstract: The Java Environment for Distributed Invocation (JEDI) is efficient, dynamic, and easier to use than alternative communication systems for distributed Java objects. Existing state-of-the-art mechanisms for remote method calls on Java objects, such as RMI, require users to perform a complicated series of steps. Furthermore, the compiled static interfaces these systems use limit their functionality. This paper presents the design and implementation of JEDI's simpler approach utilizing dynamic proxies. We discuss a means of integrating JEDI with a publicly available CORBA ORB, followed by the tests used to ensure the robustness of the JEDI system. Comparing this system's performance with that of other communication facilities such as UDP, TCP, and RMI demonstrates the efficiency of JEDI. A calendar program illustrates the flexibility and usability tradeoffs of employing JEDI in distributed clientserver applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Berners-Lee, R. Cailliau, J. Groff and B. Pollermann, </author> <title> World Wide Web: The Information Universe, </title> <journal> Electronic Networking: Research, Applications, and Policy , Volume 1, </journal> <volume> Number 2, </volume> <year> 1992. </year>
Reference-contexts: Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA [16] or DCOM [6]. Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI <ref> [1] </ref>. Method calls on remote objects can be made using Open Network Computing Remote Procedure Calls [24] or Java's Remote Method Invocation [11].
Reference: [2] <author> K. Mani Chandy, Jonathan Aldrich, and Dan Zimmerman, </author> <title> The Infospheres Infrastructure 2.0 Specification, </title> <institution> California Institute of Technology Computer Science Technical Report, </institution> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Providing a security filter mechanism for incoming JEDI method calls, perhaps allowing for trustsigned method invocation chains [12]. As a mechanism for dynamic method invocations, JEDI has become the communication substrate used with Caltech's work on Infospheres 2.0, allowing the development of location-independent mobile objects with RPCs <ref> [2] </ref>. This system will be integrated with both events and the Infospheres mailbox and message packages, creating a JavaBeans-based infrastructure that supports RPCs and messages.
Reference: [3] <author> K. Mani Chandy and Adam Rifkin, </author> <title> Systematic Composition of Objects in Distributed Internet Applications: </title> <booktitle> Processes And Sessions, Conference Proceedings of the Thirtieth Hawaii International Conference on System Sciences (HICSS), Maui, </booktitle> <volume> Volume 1, </volume> <month> January </month> <year> 1997, </year> <pages> pp. 395-404. </pages>
Reference-contexts: The Infospheres Infrastructure [4] offers a solution to the scaling problem by providing mailboxes that can send and receive typed messages. With these mechanisms, developers can set up sessions of persistent communicating objects <ref> [3] </ref>. 2.4. A Simple, Dynamic, and Global Vision for Distributed Computing We envision a distributed computing model with billions of objects scattered over the globe, interacting with each other via the Internet [4]. <p> When a group leader decides to hold a meeting, he queries the other group members in a peer-to-peer session <ref> [3] </ref> to determine an appropriate meeting time. The calendar application then locks in the appropriate slots for the group meeting in each of the respective group members' schedules. Because of the request-response nature of the scheduling algorithm we used, this application maps naturally to remote method call semantics.
Reference: [4] <author> K. Mani Chandy, Adam Rifkin, Paolo A.G. Sivilotti, Jacob Mandelson, Matthew Richardson, Wesley Tanaka, and Luke Weisman, </author> <title> A WorldWide Distributed System Using Java and the Internet, </title> <booktitle> IEEE International Symposium on High Performance Distributed Computing (HPDC-5) , Syracuse, </booktitle> <address> New York, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: 1. Introduction Java programs can use the Internet for distributed computations in many different ways [8]. One such technique involves message passing [9] between objects on different machines, as exemplified by Caltech's Infospheres Infrastructure <ref> [4] </ref>, IBM's Aglets [13], and the iBus multicast system [15]. Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA [16] or DCOM [6]. Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI [1]. <p> Furthermore, although CORBA was designed to scale to accommodate communication among many objects, neither DCOM nor RMI presently seems suitable for communication among more than a few objects [17]. The Infospheres Infrastructure <ref> [4] </ref> offers a solution to the scaling problem by providing mailboxes that can send and receive typed messages. With these mechanisms, developers can set up sessions of persistent communicating objects [3]. 2.4. <p> With these mechanisms, developers can set up sessions of persistent communicating objects [3]. 2.4. A Simple, Dynamic, and Global Vision for Distributed Computing We envision a distributed computing model with billions of objects scattered over the globe, interacting with each other via the Internet <ref> [4] </ref>. Because objects in one Java VM usually communicate with method calls, we believe that a communications system based on remote method calls is conceptually more simple than a message-passing system. <p> JEDI's niche is in low-end distributed system development as an efficient, easier-to-use alternative to RMI in Java programs. An example of this use is the calendar application we describe next. 4.4. Comparing Implementations of a Simple Distributed Application As illustrated in figure 6, a calendar scheduling application <ref> [4] </ref> is an example of distributed resource management [20]. For comparison of the application of different techniques for distributed program development, we implemented this calendar application using Java with simple local method calls, after which we distributed the program using RMI, Infospheres, and JEDI.
Reference: [5] <author> K. Mani Chandy, Joe Kiniry, Adam Rifkin, and Dan Zimmerman, </author> <title> A Framework for Structured Distributed Object Computing, </title> <booktitle> Parallel Computing, </booktitle> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: Further integrating JEDI with CORBA. 4. Allowing secure transactions on JEDI objects, including rollback and two-phase commit capabilities. 5. Allowing persistent objects that are woken up when a remote method call is made on them, as is permitted by Infospheres Djinns <ref> [5] </ref>. 6. Providing a security filter mechanism for incoming JEDI method calls, perhaps allowing for trustsigned method invocation chains [12]. As a mechanism for dynamic method invocations, JEDI has become the communication substrate used with Caltech's work on Infospheres 2.0, allowing the development of location-independent mobile objects with RPCs [2].
Reference: [6] <author> David Chappell, </author> <title> Understanding ActiveX and OLE , Microsoft Press, </title> <year> 1996. </year>
Reference-contexts: One such technique involves message passing [9] between objects on different machines, as exemplified by Caltech's Infospheres Infrastructure [4], IBM's Aglets [13], and the iBus multicast system [15]. Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA [16] or DCOM <ref> [6] </ref>. Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI [1]. Method calls on remote objects can be made using Open Network Computing Remote Procedure Calls [24] or Java's Remote Method Invocation [11]. <p> As described in section 4.1, we have worked on an ILU interface that allows CORBA objects to call methods on JEDI objects. 2.3. Comparing RMI, CORBA, and DCOM Microsoft has recently developed a Java interface to their Distributed Component Object Model (DCOM) <ref> [6] </ref>. DCOM is another system that allows RPC-like calls on remote objects; it uses a DCE-like IDL language to define interfaces. Like CORBA, RMI, and RPC, DCOM requires compiling interfaces written in its IDL into stub objects. The server object must then be written to implement the defined interface.
Reference: [7] <author> Ben Eng, </author> <title> ORB Core Feature Matrix, </title> <note> http://www.vex.net/~ben/orbmatrix.html , 1997. </note>
Reference-contexts: We examined Xerox PARC's Inter-Language Unification (ILU) system [10], which interoperates with other CORBA ORBs using the Internet Inter-ORB Protocol (IIOP). Although ILU does not implement many features of the commercial ORBs <ref> [7] </ref>, it provides DII and is freely available. As described in section 4.1, we have worked on an ILU interface that allows CORBA objects to call methods on JEDI objects. 2.3.
Reference: [8] <author> James Gosling, Bill Joy, and Guy Steele, </author> <title> The Java Language Specification, Addison-Wesley Developers Press, Sunsoft Java Series, </title> <year> 1996. </year>
Reference-contexts: 1. Introduction Java programs can use the Internet for distributed computations in many different ways <ref> [8] </ref>. One such technique involves message passing [9] between objects on different machines, as exemplified by Caltech's Infospheres Infrastructure [4], IBM's Aglets [13], and the iBus multicast system [15]. Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA [16] or DCOM [6].
Reference: [9] <author> C.A.R. Hoare, </author> <title> Communicating Sequential Processes, </title> <journal> Communications of the ACM , Volume 21, </journal> <volume> Number 8, </volume> <pages> Pages 666-677, </pages> <year> 1978. </year>
Reference-contexts: 1. Introduction Java programs can use the Internet for distributed computations in many different ways [8]. One such technique involves message passing <ref> [9] </ref> between objects on different machines, as exemplified by Caltech's Infospheres Infrastructure [4], IBM's Aglets [13], and the iBus multicast system [15]. Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA [16] or DCOM [6].
Reference: [10] <author> Bill Janssen and Mike Spreitzer, </author> <note> ILU Reference Manual . Xerox PARC, </note> <year> 1997. </year>
Reference-contexts: Any method invoked through the DSI is passed through a single upcall method (written by the programmer) that is responsible for checking the method name and forwarding it to the correct implementation method. We examined Xerox PARC's Inter-Language Unification (ILU) system <ref> [10] </ref>, which interoperates with other CORBA ORBs using the Internet Inter-ORB Protocol (IIOP). Although ILU does not implement many features of the commercial ORBs [7], it provides DII and is freely available.
Reference: [11] <author> Javasoft Java RMI Team, </author> <title> Java Remote Method Invocation Specification, Sun Microsystems, </title> <year> 1997. </year>
Reference-contexts: Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI [1]. Method calls on remote objects can be made using Open Network Computing Remote Procedure Calls [24] or Java's Remote Method Invocation <ref> [11] </ref>. With each of these techniques, the programmer must deal with creating extra interfaces (often in a different language) and must do other setup work to handle low-level communication details. This paper explores remote method calling facilities that automatically handle some of the more cumbersome communication and synchronization responsibilities [18]. <p> In this section, we explore and compare some of the current communication mechanisms in client-server systems: RMI, CORBA and IIOP, DCOM, and Infospheres. 2.1. Java's Remote Method Invocation The Remote Method Invocation (RMI) system furnished by Java 1.1 allows RPC-like access to remote objects <ref> [11] </ref>. RMI includes support for data serialization, remote class loading, and socket manipulation.
Reference: [12] <author> Rohit Khare and Adam Rifkin, </author> <title> Weaving a Web of Trust, </title> <journal> World Wide Web Journal special issue on security, </journal> <volume> Volume 2, Number 3, </volume> <pages> pages 77-112, </pages> <month> summer </month> <year> 1997. </year>
Reference-contexts: Allowing persistent objects that are woken up when a remote method call is made on them, as is permitted by Infospheres Djinns [5]. 6. Providing a security filter mechanism for incoming JEDI method calls, perhaps allowing for trustsigned method invocation chains <ref> [12] </ref>. As a mechanism for dynamic method invocations, JEDI has become the communication substrate used with Caltech's work on Infospheres 2.0, allowing the development of location-independent mobile objects with RPCs [2].
Reference: [13] <author> D.B. Lange and M. </author> <title> Oshima , Programming Mobile Agents in Java With the Java Aglet API, </title> <institution> IBM Research, </institution> <year> 1997 </year>
Reference-contexts: 1. Introduction Java programs can use the Internet for distributed computations in many different ways [8]. One such technique involves message passing [9] between objects on different machines, as exemplified by Caltech's Infospheres Infrastructure [4], IBM's Aglets <ref> [13] </ref>, and the iBus multicast system [15]. Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA [16] or DCOM [6]. Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI [1].
Reference: [14] <author> Doug Lea. </author> <title> Design for Open Systems in Java, </title> <booktitle> Proceedings of the Second International Conference on Coordination Models and Languages , Berlin, </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: Following this technique requires thinking carefully about the distributed aspects of the system, because distributed systems have unique features of which programmers must be aware [26]. We used a responsibility-driven design <ref> [14] </ref> to coordinate the scheduling activities of multiple distributed calendar programs for each port of the system.
Reference: [15] <author> Silvano Maffeis, iBus: </author> <title> The Java Internet Software Bus, </title> <note> available at http://www.olsen.ch/export/ftp/ users/maffeis/ibus/ibus_overview.ps.gz , Olsen & Associates, </note> <institution> Zurich, </institution> <year> 1997. </year>
Reference-contexts: 1. Introduction Java programs can use the Internet for distributed computations in many different ways [8]. One such technique involves message passing [9] between objects on different machines, as exemplified by Caltech's Infospheres Infrastructure [4], IBM's Aglets [13], and the iBus multicast system <ref> [15] </ref>. Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA [16] or DCOM [6]. Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI [1]. <p> RMI can use only a few wire protocols (currently TCP/IP and HTTP), but some applications would benefit from the use of custom transport protocols available through a generic message infrastructure. The ACE framework [22] and the iBus project <ref> [15] </ref> both provide a layered component-based Java communication system that allows plug-in custom transport protocols to provide different quality of service facilities to applications. 2.2. CORBA The Object Management Group's (OMG) Common Object Request Broker Architecture (CORBA) allows the development of distributed applications with component objects [25].
Reference: [16] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification (CORBA ), revision 2.0, </title> <year> 1995. </year>
Reference-contexts: One such technique involves message passing [9] between objects on different machines, as exemplified by Caltech's Infospheres Infrastructure [4], IBM's Aglets [13], and the iBus multicast system [15]. Another technique involves accessing remote objects through a request broker active on a remote machine using CORBA <ref> [16] </ref> or DCOM [6]. Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI [1]. Method calls on remote objects can be made using Open Network Computing Remote Procedure Calls [24] or Java's Remote Method Invocation [11]. <p> Then the programmer writes the client program and an object that implements the server's interface. The client and server can then be compiled and run. CORBA has support for clients to discover and use interfaces dynamically through its Dynamic Invocation Interface (DII) <ref> [16] </ref>. When using DII, the client creates its method calls at runtime, rather than calling methods in the stub. The CORBA Dynamic Skeleton Interface (DSI) specification allows server objects to update their interfaces at runtime.
Reference: [17] <author> Robert Orfali and Dan Harkey, </author> <title> Client/Server Programming with Java and CORBA , John Wiley & Sons, </title> <publisher> Inc., </publisher> <address> New York, </address> <year> 1997. </year>
Reference-contexts: Like CORBA, RMI, and RPC, DCOM requires compiling interfaces written in its IDL into stub objects. The server object must then be written to implement the defined interface. Comparing DCOM with RMI and CORBA <ref> [17] </ref>, we note all three offer somewhat seamless Java integration, typed parameter support, and reasonable performance. <p> Furthermore, although CORBA was designed to scale to accommodate communication among many objects, neither DCOM nor RMI presently seems suitable for communication among more than a few objects <ref> [17] </ref>. The Infospheres Infrastructure [4] offers a solution to the scaling problem by providing mailboxes that can send and receive typed messages. With these mechanisms, developers can set up sessions of persistent communicating objects [3]. 2.4. <p> RPC requires a static, compile-time interface, and standard CORBA requires the same. Through the Dynamic Invocation Interface facilities, CORBA clients can discover resources dynamically. However, DII is somewhat difficult to use many steps are required to construct a dynamic request object <ref> [17] </ref>. If the client must query the server for the interface of the method it wants to call, performance may decrease dramatically. DCOM Automation is likewise complicated and difficult to use.
Reference: [18] <author> L.L. Peterson and B.S. Davie, </author> <title> Computer Networks: A Systems Approach, </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: With each of these techniques, the programmer must deal with creating extra interfaces (often in a different language) and must do other setup work to handle low-level communication details. This paper explores remote method calling facilities that automatically handle some of the more cumbersome communication and synchronization responsibilities <ref> [18] </ref>. Many existing systems, including Java's RMI, require a programmer to run interface code through a preprocessor to create stub and skeleton objects. We have developed an alternative system for remote method calling, offering the programmer complete control over communication while simplifying the model of distributed computing.
Reference: [19] <author> Ernest N. Prabhakar, </author> <title> Implementing Distributed Objects: Doing It the Easy Way with NeXT's Portable Distributed Objects, </title> <journal> Dr. Dobb's Journal, </journal> <month> August </month> <year> 1995. </year>
Reference-contexts: However, these approaches suffer from high setup costs due to programming complexity, lack of configuration ease, evolving wire-level security, and limited dynamic discovery and dynamic dispatch when compared with systems such as NeXT's Portable Distributed Objects <ref> [19] </ref>. Furthermore, although CORBA was designed to scale to accommodate communication among many objects, neither DCOM nor RMI presently seems suitable for communication among more than a few objects [17].
Reference: [20] <author> Ravi Ramamoorthi, Adam Rifkin, Boris Dimitrov, and K. Mani Chandy, </author> <title> A General Resource Reservation Framework for Scientific Computing, </title> <booktitle> Proceedings of the First International Scientific Computing in ObjectOriented Parallel Environments (ISCOPE) Conference, </booktitle> <address> Marina del Rey, </address> <month> December </month> <year> 1997. </year>
Reference-contexts: An example of this use is the calendar application we describe next. 4.4. Comparing Implementations of a Simple Distributed Application As illustrated in figure 6, a calendar scheduling application [4] is an example of distributed resource management <ref> [20] </ref>. For comparison of the application of different techniques for distributed program development, we implemented this calendar application using Java with simple local method calls, after which we distributed the program using RMI, Infospheres, and JEDI.
Reference: [21] <author> Ron Resnick, </author> <title> Bringing Distributed Objects to the World Wide Web, </title> <note> http://www.interlog.com/~resnick/ javacorb.html , 1996. Excerpted in Dr. Dobbs Sourcebook special issue on distributed objects, </note> <month> January </month> <year> 1997. </year>
Reference-contexts: These experiments include studying the integration of JEDI with CORBA, testing the reliability and performance of JEDI, and using JEDI to develop an application from scratch. We conclude with a short summary of our JEDI findings. 2. Existing Systems Until recently, Java lacked a native clientserver method invocation paradigm <ref> [21] </ref>, but several supplementary systems are available to provide this functionality. In this section, we explore and compare some of the current communication mechanisms in client-server systems: RMI, CORBA and IIOP, DCOM, and Infospheres. 2.1.
Reference: [22] <author> Douglas C. Schmidt, </author> <title> ACE: an ObjectOriented Framework for Developing Distributed Applications, </title> <booktitle> Proceedings of the Sixth USENIX C++ Technical Conference , Cambridge, </booktitle> <month> April </month> <year> 1994. </year>
Reference-contexts: RMI can use only a few wire protocols (currently TCP/IP and HTTP), but some applications would benefit from the use of custom transport protocols available through a generic message infrastructure. The ACE framework <ref> [22] </ref> and the iBus project [15] both provide a layered component-based Java communication system that allows plug-in custom transport protocols to provide different quality of service facilities to applications. 2.2.
Reference: [23] <author> Douglas C. Schmidt and Andy Gokhale, </author> <title> Measuring the Performance of Communication Middleware on HighSpeed Networks, </title> <booktitle> SIGCOMM Conference , Stanford University, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: Research has shown the importance of measuring not only two-way ping latency in distributed object oriented systems, but also throughput and latency for sending different kinds of data structures <ref> [23] </ref>. We tested JEDI and RMI by passing a 35 Kb, richly typed, treelike data structure in a remote method call. In this case RMI sent the structure in 0.85 seconds, while JEDI took 1.56 seconds.
Reference: [24] <author> R. Srinivasan, </author> <title> RFC 1831 - Open Network Computing RPC: Remote Procedure Call Protocol Specification , Version 2, </title> <month> August </month> <year> 1995. </year>
Reference-contexts: Some systems communicate with remote objects through a gateway to a Web server using HTTP and CGI [1]. Method calls on remote objects can be made using Open Network Computing Remote Procedure Calls <ref> [24] </ref> or Java's Remote Method Invocation [11]. With each of these techniques, the programmer must deal with creating extra interfaces (often in a different language) and must do other setup work to handle low-level communication details.
Reference: [25] <author> Steve Vinoski, </author> <title> CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments, </title> <journal> IEEE Communications Magazine , Volume 14, </journal> <volume> Number 2, </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: CORBA The Object Management Group's (OMG) Common Object Request Broker Architecture (CORBA) allows the development of distributed applications with component objects <ref> [25] </ref>. CORBA's language-independence allows objects written in different languages to communicate with one another. All object interaction is routed through intermediary Object Request Brokers (ORBs) which communicate through the industry-standard IIOP protocol (see figure 2).
Reference: [26] <author> Jim Waldo, Geoff Wyant, Ann Wollrath, </author> <title> and Sam Kendall, </title>
Reference-contexts: Following this technique requires thinking carefully about the distributed aspects of the system, because distributed systems have unique features of which programmers must be aware <ref> [26] </ref>. We used a responsibility-driven design [14] to coordinate the scheduling activities of multiple distributed calendar programs for each port of the system.
References-found: 26

