URL: ftp://theory.lcs.mit.edu/pub/cilk/astark-thesis.ps.gz
Refering-URL: http://theory.lcs.mit.edu/~cilk/abstracts/astark-thesis.html
Root-URL: 
Title: Debugging Multithreaded Programs that Incorporate User-Level Locking  
Author: by Andrew F. Stark Arthur C. Smith 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degrees of Bachelor of Science in Computer Science and Engineering and Master of Engineering in Electrical Engineering and Computer Science at the  c Andrew F. Stark, MCMXCVIII. All rights reserved. The author hereby grants to MIT permission to reproduce and distribute publicly paper and electronic copies of this thesis document in whole or in part, and to grant others the right to do so. Author  Certified by Charles E. Leiserson Professor of Computer Science and Engineering Thesis Supervisor Accepted by  Chairman, Department Committee on Graduate Theses  
Date: June 1998  May 22, 1998  
Affiliation: MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. Barnes and P. Hut. </author> <title> A hierarchical O(N log N ) force-calculation algorithm. </title> <journal> Nature, </journal> <volume> 324 </volume> <pages> 446-449, </pages> <year> 1986. </year>
Reference-contexts: memory that is at the address contained in register 2." In a dag scheduling, the memory location read by this instruction's instantiation is fixed, and may not correspond to the location specified by register 2. 67 int x [2]; int z; Cilk lockvar A; cilk int main () f x <ref> [1] </ref> = 1; Cilk lock init (A); spawn bar1 (); spawn bar2 (); sync; printf ("%d", x); return 0; g cilk void bar1 () f Cilk lock (A); z = *y; Cilk unlock (A); g cilk void bar2 () f Cilk lock (A); (*y)++; Cilk unlock (A); g tion anomaly. <p> Thus, for this application, the maximum number of locks held by a thread is k = 2, and L is at most the maximum degree of any vertex. n-body: An n-body gravity simulation using the Barnes-Hut algorithm <ref> [1] </ref>.
Reference: [2] <author> Philippe Bekaert, Frank Suykens de Laet, and Philip Dutre. Renderpark, </author> <year> 1997. </year> <note> Available on the Internet from http://www.cs.kuleuven.ac./cwis/research/ graphics/RENDERPARK/. </note>
Reference-contexts: So instead of implementing our own radiosity code, we downloaded a large radiosity application developed at the Computer Graphics Research Group of the Katholieke Universiteit Leuven, in Belgium <ref> [2] </ref>. Since the code is written in C, and Cilk is a simple extension of C, running the code as a Cilk program is effortless. 18 The difficulty, however, is that the program is large, consisting of 75 source files and 23,000 lines of code. <p> example, an instruction might be "read into register 1 the contents of memory that is at the address contained in register 2." In a dag scheduling, the memory location read by this instruction's instantiation is fixed, and may not correspond to the location specified by register 2. 67 int x <ref> [2] </ref>; int z; Cilk lockvar A; cilk int main () f x [1] = 1; Cilk lock init (A); spawn bar1 (); spawn bar2 (); sync; printf ("%d", x); return 0; g cilk void bar1 () f Cilk lock (A); z = *y; Cilk unlock (A); g cilk void bar2 () <p> If we can speed up code that has already been optimized by graphics experts, our results clearly demonstrate the usefulness of Cilk. We therefore downloaded a radiosity application, rad, which was originally written 94 by Bekaert, Suykens de Laet, and Dutre at the Katholieke Universiteit Leuven in Belgium <ref> [2] </ref>. The application is large, consisting of 75 source files and around 25,000 lines of code. The application is written in C, and every C program is a legal Cilk program, so "porting" the application to Cilk required no effort. Correctly parallelizing the code, however, is not as trivial.
Reference: [3] <author> Robert D. Blumofe. </author> <title> Executing Multithreaded Programs Efficiently. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: Also, verifying that a program works correctly in one scheduling does not preclude the possibility of bugs in future executions. In this thesis, we develop techniques for debugging parallel programs coded in the Cilk language. The Cilk <ref> [3, 4, 7, 16, 23] </ref> project is designed to make it easy for programmers to write efficient parallel programs. Parallel computing has long been an area of research, but it has yet to reach the "mainstream" world of professional programmers, even though parallel machines are becoming more available.
Reference: [4] <author> Robert D. Blumofe, Christopher F. Joerg, Bradley C. Kuszmaul, Charles E. Leiserson, Keith H. Randall, and Yuli Zhou. Cilk: </author> <title> An efficient multithreaded runtime system. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 37(1) </volume> <pages> 55-69, </pages> <month> August </month> <year> 1996. </year>
Reference-contexts: Also, verifying that a program works correctly in one scheduling does not preclude the possibility of bugs in future executions. In this thesis, we develop techniques for debugging parallel programs coded in the Cilk language. The Cilk <ref> [3, 4, 7, 16, 23] </ref> project is designed to make it easy for programmers to write efficient parallel programs. Parallel computing has long been an area of research, but it has yet to reach the "mainstream" world of professional programmers, even though parallel machines are becoming more available. <p> In particular, we explain how a program execution can be viewed as a sequence of "instruction instantiations." We can view the abstract execution machine for a multithreaded language as a (sequentially consistent [26]) shared memory together with a collection of interpreters. (See <ref> [4, 9, 20] </ref> for examples of multithreaded implementations similar to this model.) Each interpreter contains private state which only it can modify. <p> This balancing is difficult to do at compile time when the behavior of the computation is difficult to predict. Cilk provides a dynamic scheduler which balances tasks across processors using 93 optimized C code. Measurements were done on an 8-processor 167-MHz UltraSPARC I. a provably good work-stealing algorithm <ref> [4] </ref>. Radiosity, then, is a good test for the capabilities of Cilk's scheduler. Past attempts at parallelizing radiosity have required the algorithm to be modified with explicit load balancing [41]. In order to effectively test Cilk's performance, we prefer not to develop our own radiosity application. <p> When the average parallelism of the program is much greater than the number of processors P being used, a theorem shows that Cilk's scheduler runs the program in time approximately T 1 =P with high probability <ref> [4] </ref>. The average parallelism of the formfactor calculations is measured as 221. Unfortunately, this measurement does not account for time spent in contention for user locks; such contention both adds work for the program and reduces parallelism.
Reference: [5] <author> Guang-Ien Cheng. </author> <title> Algorithms for race detection in multithreaded programs with atomicity. </title> <type> Master's thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1998. </year>
Reference-contexts: We are developing extensions of the Nondeterminator-2's detection algorithms that work properly for programs that hold locks across parallel control constructs. See <ref> [5] </ref> for more discussion. 24 cilk int fib (int n) f int y; return n; x = spawn fib (n-1); y = spawn fib (n-1); sync; return (x+y); g The computation of a Cilk program on a given input can be viewed as a directed acyclic graph, or dag , in <p> In some cases, it is possible to determine that some subset of the accesses actually constitutes a dag race, and those accesses can be reported in preference to the entire umbrella. See <ref> [5] </ref> for more details. When false reports due to infeasible dag races occur, we would like to provide some way for the user to inform the Nondeterminator-2 that these races are infeasible, so that it can avoid reporting them in future executions.
Reference: [6] <author> Guang-Ien Cheng, Mingdong Feng, Charles E. Leiserson, Keith Randall, and Andrew F. Stark. </author> <title> Detecting data races in cilk programs that use locks. </title> <booktitle> In In proceedings of the Tenth Annual ACM Symposium on Parallel Algorithms and Architectures (SPAA), </booktitle> <address> Puerto Vallarta, Mexico, </address> <month> June 28-July 2 </month> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: Some of the ideas described in Chapter 9 were inspired by our experiences parallelizing the radiosity application; these experiences are described in Chapter 10. Chapter 11 offers some concluding remarks. Some of the results in this thesis appear in <ref> [6] </ref> and represent joint work with Guang-Ien Cheng, Mingdong Feng, Charles E. <p> Cilk's scheduler uses a work-stealing algorithm to achieve provably good performance. While this feature is not the main focus of this paper, it surfaces again as motivation for the radiosity example. 1 Some of the results in this chapter appear in <ref> [6] </ref>. 23 In order to make it as easy as possible for programmers to express parallelism, Cilk was designed as a simple extension to C. A Cilk program is a C program with a few keywords added. <p> A program obeys the umbrella locking discipline if it contains no unprotected umbrellas. In other words, within each umbrella of accesses to a location l, all threads must agree on at least one lock to protect their 1 Some of the results in this chapter appear in <ref> [6] </ref>. 33 leaf represents a thread that accesses l. Each umbrella of accesses to l is enclosed by a dashed line. accesses to l. The next theorem shows that adherence to the umbrella discipline precludes dag races from occurring. <p> Abelian programs The program in Figure 8-1 is an example of an abelian program. The program is read-permute nondeterministic, as the updates to x may happen in different orders. 1 Some of the results in this chapter appear in <ref> [6] </ref>. 73 int x; Cilk lockvar A; cilk int main () f Cilk lock init (A); spawn UpdateX1 (); spawn UpdateX2 (); sync; printf ("%d", x); return 0; g cilk void UpdateX1 () f Cilk lock (A); x += 2; Cilk unlock (A); g cilk void UpdateX2 () f Cilk lock <p> In one phase of the program, parallel threads race to build various parts of an "octtree" 2 Some of the results in this section appear in <ref> [6] </ref>. 3 These characterizations do not count the implicit fake r-lock used by the detection algorithms. 90 Parameters Time (sec.) Slowdown Program input k L orig. All. Br. All.
Reference: [7] <author> Cilk-5.1 Reference Manual. </author> <note> Available on the Internet from http://theory.lcs. mit.edu/~cilk. 119 </note>
Reference-contexts: Also, verifying that a program works correctly in one scheduling does not preclude the possibility of bugs in future executions. In this thesis, we develop techniques for debugging parallel programs coded in the Cilk language. The Cilk <ref> [3, 4, 7, 16, 23] </ref> project is designed to make it easy for programmers to write efficient parallel programs. Parallel computing has long been an area of research, but it has yet to reach the "mainstream" world of professional programmers, even though parallel machines are becoming more available.
Reference: [8] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: This execution order mirrors that of normal C programs: every subcomputation that is spawned executes com pletely before the procedure that spawned it continues. Every spawned procedure 4 is given a unique ID at runtime. These IDs are kept in the fast disjoint-set data structure <ref> [8, Chapter 22] </ref> analyzed by Tarjan [43]. <p> Each part is protected by an associated lock, and the first thread to acquire that lock builds that part of the structure. As the program never holds more than one lock at a time, we have k = L = 1. bucket: A bucket sort <ref> [8, Section 9.4] </ref>. Parallel threads acquire the lock associated with a bucket before adding elements to it. This algorithm is analogous to the typical way a hash table is accessed in parallel.
Reference: [9] <author> David E. Culler, Anurag Sah, Klaus Erik Schauser, Thorsten von Eicken, and John Wawrzynek. </author> <title> Fine-grain parallelism with minimal hardware support: A compiler-controlled threaded abstract machine. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <pages> pages 164-175, </pages> <address> Santa Clara, California, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: In particular, we explain how a program execution can be viewed as a sequence of "instruction instantiations." We can view the abstract execution machine for a multithreaded language as a (sequentially consistent [26]) shared memory together with a collection of interpreters. (See <ref> [4, 9, 20] </ref> for examples of multithreaded implementations similar to this model.) Each interpreter contains private state which only it can modify.
Reference: [10] <author> Anne Dinning and Edith Schonberg. </author> <title> An empirical comparison of monitoring algorithms for access anomaly detection. </title> <booktitle> In Proceedings of the Second ACM SIG-PLAN Symposium on Principles & Practice of Parallel Programming (PPoPP), </booktitle> <pages> pages 1-10. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [12, 21, 29, 32], while others perform an "on-the-fly" analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [10, 11, 14, 15, 28, 36] </ref>, by binary rewriting [39], or by augmenting the machine's cache coherence protocol [30, 37]. In this thesis, we present two race detection algorithms which are based on the Nondeterminator [14], a tool that finds dag races in Cilk programs that do not use locks. <p> so can obtain speedup 17 Handles Algorithm Handles series- Detects Time per Total locks parallel memory access space programs English-Hebrew NO YES Dag races O (pt) O (V t + min (bp; V tp)) labeling [36] Task NO YES Dag races O (t) O (t 2 + V t) Recycling <ref> [10] </ref> Offset-span NO YES Dag races O (p) O (V + min (bp; V p)) Labeling [28] SP-bags [14] NO YES Dag races O (ff (V; V )) O (V ) Lock YES YES Dag races O (tn k ) O (t 2 + tn k V ) Covers [11] Eraser <p> of the algorithm here. 43 Handles Algorithm Handles series- Detects Time per Total locks parallel memory access space dags English-Hebrew NO YES Dag races O (pt) O (V t + min (bp; V tp)) labeling [36] Task NO YES Dag races O (t) O (t 2 + V t) Recycling <ref> [10] </ref> Offset-span NO YES Dag races O (p) O (V + min (bp; V p)) Labeling [28] SP-bags [14] NO YES Dag races O (ff (V; V )) O (V ) Lock YES YES Dag races O (tk 2 L) O (t 2 + tkLV ) Covers [11] Eraser Eraser [39] <p> At each memory access, the algorithm does O (t) comparisons of size O (p) labels, for a time of O (pt). Essentially, then, the algorithm slows down ordinary execution by a factor of O (pt). 2 The task recycling algorithm, due to Dinning and Schonberg <ref> [10] </ref>, records more information in order to reduce the time to check if two threads are concurrent. Like English-Hebrew labeling, the algorithm does not address programs with locks. The algorithm uses at most t task identifiers, which it assigns to all the threads.
Reference: [11] <author> Anne Dinning and Edith Schonberg. </author> <title> Detecting access anomalies in programs with critical sections. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 85-96. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [12, 21, 29, 32], while others perform an "on-the-fly" analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [10, 11, 14, 15, 28, 36] </ref>, by binary rewriting [39], or by augmenting the machine's cache coherence protocol [30, 37]. In this thesis, we present two race detection algorithms which are based on the Nondeterminator [14], a tool that finds dag races in Cilk programs that do not use locks. <p> Tighter, more complicated bounds on All-Sets are given in Chapter 2. In previous work, Dinning and Schonberg's "Lock Covers" algorithm <ref> [11] </ref> also detects all dag races in a computation. The All-Sets algorithm improves the Lock Covers algorithm by generalizing the data structures and techniques from the original Nondeterminator to produce better time and space bounds. <p> Recycling [10] Offset-span NO YES Dag races O (p) O (V + min (bp; V p)) Labeling [28] SP-bags [14] NO YES Dag races O (ff (V; V )) O (V ) Lock YES YES Dag races O (tn k ) O (t 2 + tn k V ) Covers <ref> [11] </ref> Eraser Eraser [39] YES NO discipline O (k) O (kV ) violations All-Sets YES YES Dag races O (n k ff (V; V ))) O (n k V ) Umbrella Brelly YES YES discipline O (k ff (V; V )) O (kV ) violations p = maximum depth of nested <p> V t) Recycling [10] Offset-span NO YES Dag races O (p) O (V + min (bp; V p)) Labeling [28] SP-bags [14] NO YES Dag races O (ff (V; V )) O (V ) Lock YES YES Dag races O (tk 2 L) O (t 2 + tkLV ) Covers <ref> [11] </ref> Eraser Eraser [39] YES NO discipline O (k) O (kV ) violations All-Sets YES YES Dag races O (L (k + ff (V; V ))) O (kLV ) Umbrella Brelly YES YES discipline O (k ff (V; V )) O (kV ) violations p = maximum depth of nested parallelism <p> That is, they report as dag races parallel updates, even if those updates hold a lock in common. Dinning and Schonberg give a way to extend their previous 46 work to correctly identify dag races in programs with locks <ref> [11] </ref>. The idea is to keep, for every thread id in an access history, the set of locks that were held at the time of that access. Accesses that use distinct locksets must all be recorded in the access history. <p> Missed races and false reports are not a problem when the program being debugged 106 is abelian, but programmers would like to know whether an ostensibly abelian pro-gram is actually abelian. Dinning and Schonberg give a conservative compile-time algorithm to check if a program is "internally deterministic" <ref> [11] </ref>, and we have given thought as to how the abelian property might likewise be conservatively checked. The parallelizing compiler techniques of Rinard and Diniz [38] may be applicable.
Reference: [12] <author> Perry A. Emrath, Sanjoy Ghosh, and David A. Padua. </author> <title> Event synchronization analysis for debugging parallel programs. </title> <booktitle> In Proceedings of Supercomputing '91, </booktitle> <pages> pages 580-588, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Since understanding any nontrivial semantics of the program is generally undecidable, however, most race detectors are dynamic tools in which potential races are detected at runtime by executing the program on a given input. Some dynamic race detectors perform a post-mortem analysis based on program execution traces <ref> [12, 21, 29, 32] </ref>, while others perform an "on-the-fly" analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [10, 11, 14, 15, 28, 36], by binary rewriting [39], or by augmenting the machine's cache coherence protocol [30, 37].
Reference: [13] <author> Perry A. Emrath and Davis A. Padua. </author> <title> Automatic detection of nondeterminacy in parallel programs. </title> <booktitle> In Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 89-99, </pages> <address> Madison, Wisconsin, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: A program might behave nondeterministically "in the middle" of execution but produce a deterministic answer. Rather than using the term "nondeterministic" ambiguously, it is desirable to distinguish between its many forms. Emrath and Padua <ref> [13] </ref> call a program determinate if it "always leads to the same results," or nondeterminate otherwise. They further divide these categories into subcategories. They call a program internally determinate if the sequence of instructions each thread executes, along with the values of the variables used by each instruction, is determinate.
Reference: [14] <author> Mingdong Feng and Charles E. Leiserson. </author> <title> Efficient detection of determinacy races in Cilk programs. </title> <booktitle> In Proceedings of the Ninth Annual ACM Symposium on Parallel Algorithms and Architectures (SPAA), </booktitle> <pages> pages 1-11, </pages> <address> Newport, Rhode Island, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [12, 21, 29, 32], while others perform an "on-the-fly" analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [10, 11, 14, 15, 28, 36] </ref>, by binary rewriting [39], or by augmenting the machine's cache coherence protocol [30, 37]. In this thesis, we present two race detection algorithms which are based on the Nondeterminator [14], a tool that finds dag races in Cilk programs that do not use locks. <p> On-the-fly debuggers directly instrument memory accesses via the compiler [10, 11, 14, 15, 28, 36], by binary rewriting [39], or by augmenting the machine's cache coherence protocol [30, 37]. In this thesis, we present two race detection algorithms which are based on the Nondeterminator <ref> [14] </ref>, a tool that finds dag races in Cilk programs that do not use locks. The Nondeterminator executes a Cilk program serially on a given input, maintaining an efficient "SP-bags" data structure to keep track of the logical series/parallel 14 relationships between threads. <p> programs English-Hebrew NO YES Dag races O (pt) O (V t + min (bp; V tp)) labeling [36] Task NO YES Dag races O (t) O (t 2 + V t) Recycling [10] Offset-span NO YES Dag races O (p) O (V + min (bp; V p)) Labeling [28] SP-bags <ref> [14] </ref> NO YES Dag races O (ff (V; V )) O (V ) Lock YES YES Dag races O (tn k ) O (t 2 + tn k V ) Covers [11] Eraser Eraser [39] YES NO discipline O (k) O (kV ) violations All-Sets YES YES Dag races O (n <p> Next we review the SP-bags algorithm <ref> [14] </ref> used by the original Nondeterminator. We then we present the All-Sets algorithm itself, show that it is correct, and analyze its performance. <p> Lines 1-3 check to see if a dag race has occurred and report any violations. Lines 5-11 then add the current locker to the lockers shadow space and prune redundant lockers. Correctness of All-Sets Before proving the correctness of All-Sets, we restate two lemmas from <ref> [14] </ref>. Lemma 1 Suppose that three threads e 1 , e 2 , and e 3 execute in order in a serial, depth-first execution of a Cilk program, and suppose that e 1 e 2 and e 1 k e 3 . <p> dags English-Hebrew NO YES Dag races O (pt) O (V t + min (bp; V tp)) labeling [36] Task NO YES Dag races O (t) O (t 2 + V t) Recycling [10] Offset-span NO YES Dag races O (p) O (V + min (bp; V p)) Labeling [28] SP-bags <ref> [14] </ref> NO YES Dag races O (ff (V; V )) O (V ) Lock YES YES Dag races O (tk 2 L) O (t 2 + tkLV ) Covers [11] Eraser Eraser [39] YES NO discipline O (k) O (kV ) violations All-Sets YES YES Dag races O (L (k + <p> Assuming that mod is a constant time operation, the time to check each memory access is just O (p), the time to compare two labels. The SP-bags algorithm <ref> [14] </ref>, as we have seen, uses a variation on Tarjan's least common ancestor algorithm to find the logical relationships between threads.
Reference: [15] <author> Yaacov Fenster. </author> <title> Detecting parallel access anomalies. </title> <type> Master's thesis, </type> <institution> Hebrew University, </institution> <month> March </month> <year> 1998. </year> <month> 120 </month>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [12, 21, 29, 32], while others perform an "on-the-fly" analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [10, 11, 14, 15, 28, 36] </ref>, by binary rewriting [39], or by augmenting the machine's cache coherence protocol [30, 37]. In this thesis, we present two race detection algorithms which are based on the Nondeterminator [14], a tool that finds dag races in Cilk programs that do not use locks.
Reference: [16] <author> Matteo Frigo, Keith H. Randall, and Charles E. Leiserson. </author> <booktitle> The implementation of the Cilk-5 multithreaded language. In Proceedings of the ACM SIGPLAN '98 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: Also, verifying that a program works correctly in one scheduling does not preclude the possibility of bugs in future executions. In this thesis, we develop techniques for debugging parallel programs coded in the Cilk language. The Cilk <ref> [3, 4, 7, 16, 23] </ref> project is designed to make it easy for programmers to write efficient parallel programs. Parallel computing has long been an area of research, but it has yet to reach the "mainstream" world of professional programmers, even though parallel machines are becoming more available.
Reference: [17] <author> Andrew V. Goldberg and Robert E. Tarjan. </author> <title> A new approach to the maximum flow problem. </title> <booktitle> In Proceedings of the Eighteenth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 136-146, </pages> <address> Berkeley, California, </address> <month> 28-30 May </month> <year> 1986. </year>
Reference-contexts: According to Theorem 9, the worst-case slowdown factor for Brelly is about fi (k). In order to compare our experimental results with the theoretical bounds, we characterize our four test programs in terms of the parameters k and L: 3 maxflow: A maximum-flow code based on Goldberg's push-relabel method <ref> [17] </ref>. Each vertex in the graph contains a lock. Parallel threads perform simple operations asynchronously on graph edges and vertices.
Reference: [18] <author> Cindy M. Goral, Kenneth K. Torrance, Donald P. Greenberg, and Bennett Bat-taile. </author> <title> Modeling the interaction of light between diffuse surfaces. </title> <journal> Computer Graphics, </journal> <volume> 18(3) </volume> <pages> 213-222, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: This formula leads to the following set of linear equations <ref> [18] </ref>: B i = E i + i j B j F ij where B i is the power/area of patch i, E i is the emitted power/area of patch i, i is the reflectance of patch i, and F ij is the formfactor from i to j, the fraction of
Reference: [19] <author> Henri Gourard. </author> <title> Computer display of curved surfaces. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1971. </year>
Reference-contexts: We then ran the resulting code through 1 Actually, the color of patches is determined by assigning colors to vertices and then interpolating those colors to the rest of the patch, typically with Gourard shading <ref> [19] </ref>. 96 the Nondeterminator to look for data races. Since the code was initially serial, it did not contain any locks, and was therefore abelian.
Reference: [20] <author> Michael Halbherr, Yuli Zhou, and Chris F. Joerg. </author> <title> MIMD-style parallel programming with continuation-passing threads. </title> <booktitle> In Proceedings of the 2nd International Workshop on Massive Parallelism: Hardware, Software, and Applications, </booktitle> <address> Capri, Italy, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: In particular, we explain how a program execution can be viewed as a sequence of "instruction instantiations." We can view the abstract execution machine for a multithreaded language as a (sequentially consistent [26]) shared memory together with a collection of interpreters. (See <ref> [4, 9, 20] </ref> for examples of multithreaded implementations similar to this model.) Each interpreter contains private state which only it can modify.
Reference: [21] <author> David P. Helmbold, Charles E. McDowell, and Jian-Zhong Wang. </author> <title> Analyzing traces with anonymous synchronization. </title> <booktitle> In Proceedings of the 1990 International Conference on Parallel Processing, </booktitle> <pages> pages II70-II77, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Since understanding any nontrivial semantics of the program is generally undecidable, however, most race detectors are dynamic tools in which potential races are detected at runtime by executing the program on a given input. Some dynamic race detectors perform a post-mortem analysis based on program execution traces <ref> [12, 21, 29, 32] </ref>, while others perform an "on-the-fly" analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [10, 11, 14, 15, 28, 36], by binary rewriting [39], or by augmenting the machine's cache coherence protocol [30, 37].
Reference: [22] <author> Richard C. Holt. </author> <title> Some deadlock properties of computer systems. </title> <journal> Computing Surveys, </journal> <volume> 4(3) </volume> <pages> 179-196, </pages> <month> September </month> <year> 1972. </year>
Reference-contexts: A locking discipline is a programming methodology that dictates a restriction on the use of locks. For example, many programs adopt the discipline of acquiring locks in a fixed order so as to avoid deadlock <ref> [22] </ref>. Similarly, the "umbrella" locking discipline precludes dag races by requiring that each location be protected by the same lock within every parallel subcomputation of the computation.
Reference: [23] <author> Christopher F. Joerg. </author> <title> The Cilk System for Parallel Multithreaded Computing. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Mass-achusetts Institute of Technology, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: Also, verifying that a program works correctly in one scheduling does not preclude the possibility of bugs in future executions. In this thesis, we develop techniques for debugging parallel programs coded in the Cilk language. The Cilk <ref> [3, 4, 7, 16, 23] </ref> project is designed to make it easy for programmers to write efficient parallel programs. Parallel computing has long been an area of research, but it has yet to reach the "mainstream" world of professional programmers, even though parallel machines are becoming more available.
Reference: [24] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <note> second edition, 1988. 121 </note>
Reference-contexts: Cilk alleviates this problem by allowing programmers to code in the Cilk language, which is a simple extension to the programming language C <ref> [24] </ref>. The Cilk runtime system then automatically and efficiently runs this code on multiprocessor machines. Cilk programs can still have nondeterminacy bugs, however. Figure 1-1 shows a Cilk program that behaves nondeterministically. The procedures foo1 and foo2 run in parallel, resulting in parallel access to the shared variable x.
Reference: [25] <author> Philip N. Klein, Hsueh-I Lu, and Robert H. B. Netzer. </author> <title> Race-condition detection in parallel computation with semaphores. </title> <type> Technical Report CS-96-04, </type> <institution> Brown University, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: For a program that runs in time T , discovering which reorderings of the instructions conform to the semaphore constraint can be reduced from a size T graph problem that is NP-hard <ref> [25] </ref>.
Reference: [26] <author> Leslie Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):690-691, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: In particular, we explain how a program execution can be viewed as a sequence of "instruction instantiations." We can view the abstract execution machine for a multithreaded language as a (sequentially consistent <ref> [26] </ref>) shared memory together with a collection of interpreters. (See [4, 9, 20] for examples of multithreaded implementations similar to this model.) Each interpreter contains private state which only it can modify.
Reference: [27] <author> Leslie Lamport. </author> <title> The mutual exclusion problem: Part I | A theory of inter-process communication. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 33(2) </volume> <pages> 313-326, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: A nondeterminate program is called associatively nondeterminate if the nondeterminate output is due only to lack of associativity of floating-point operations, or completely nondeterminate otherwise. Netzer and Miller [35] use a formal model of program behavior based on Lamport's theory of concurrent systems <ref> [27] </ref> to define nondeterminism. They are specifically concerned with defining race conditions. They define a general race to occur in a program when two conflicting memory accesses are not forced to occur in a fixed order.
Reference: [28] <author> John Mellor-Crummey. </author> <title> On-the-fly detection of data races for programs with nested fork-join parallelism. </title> <booktitle> In Proceedings of Supercomputing'91, </booktitle> <pages> pages 24-33. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [12, 21, 29, 32], while others perform an "on-the-fly" analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [10, 11, 14, 15, 28, 36] </ref>, by binary rewriting [39], or by augmenting the machine's cache coherence protocol [30, 37]. In this thesis, we present two race detection algorithms which are based on the Nondeterminator [14], a tool that finds dag races in Cilk programs that do not use locks. <p> access space programs English-Hebrew NO YES Dag races O (pt) O (V t + min (bp; V tp)) labeling [36] Task NO YES Dag races O (t) O (t 2 + V t) Recycling [10] Offset-span NO YES Dag races O (p) O (V + min (bp; V p)) Labeling <ref> [28] </ref> SP-bags [14] NO YES Dag races O (ff (V; V )) O (V ) Lock YES YES Dag races O (tn k ) O (t 2 + tn k V ) Covers [11] Eraser Eraser [39] YES NO discipline O (k) O (kV ) violations All-Sets YES YES Dag races <p> access space dags English-Hebrew NO YES Dag races O (pt) O (V t + min (bp; V tp)) labeling [36] Task NO YES Dag races O (t) O (t 2 + V t) Recycling [10] Offset-span NO YES Dag races O (p) O (V + min (bp; V p)) Labeling <ref> [28] </ref> SP-bags [14] NO YES Dag races O (ff (V; V )) O (V ) Lock YES YES Dag races O (tk 2 L) O (t 2 + tkLV ) Covers [11] Eraser Eraser [39] YES NO discipline O (k) O (kV ) violations All-Sets YES YES Dag races O (L <p> The storage for parent vectors together with the space for access histories yields O (t 2 + V t) total space. Mellor-Crummey's offset-span labeling approach <ref> [28] </ref> reduces the size of access histories by keeping ids only for "lowest leftmost" and "lowest rightmost" readers. In this way, all dag races can be found, because a write that races with any read also races with one of the reads in the access history.
Reference: [29] <author> Barton P. Miller and Jong-Deok Choi. </author> <title> A mechanism for efficient debugging of parallel programs. </title> <booktitle> In Proceedings of the 1988 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 135-144, </pages> <address> Atlanta, Georgia, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: Since understanding any nontrivial semantics of the program is generally undecidable, however, most race detectors are dynamic tools in which potential races are detected at runtime by executing the program on a given input. Some dynamic race detectors perform a post-mortem analysis based on program execution traces <ref> [12, 21, 29, 32] </ref>, while others perform an "on-the-fly" analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [10, 11, 14, 15, 28, 36], by binary rewriting [39], or by augmenting the machine's cache coherence protocol [30, 37].
Reference: [30] <author> Sang Lyul Min and Jong-Deok Choi. </author> <title> An efficient cache-based access anomaly detection scheme. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <pages> pages 235-244, </pages> <address> Palo Alto, California, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: On-the-fly debuggers directly instrument memory accesses via the compiler [10, 11, 14, 15, 28, 36], by binary rewriting [39], or by augmenting the machine's cache coherence protocol <ref> [30, 37] </ref>. In this thesis, we present two race detection algorithms which are based on the Nondeterminator [14], a tool that finds dag races in Cilk programs that do not use locks. <p> Its O (k ff (V; V )) amortized time per memory access and O (kV ) space usage are almost equivalent to Eraser's asymptotic bounds. Others have proposed detecting races by "piggybacking" on the machine's cache coherence protocol <ref> [30, 37] </ref>. In principle, such piggybacking is only useful in detecting data races that actually occur in an execution. That is, the cache coherence protocol can detect when threads that actually run in parallel access the same location.
Reference: [31] <author> Greg Nelson, K. Rustan M. Leino, James B. Saxe, and Raymie Stata. </author> <title> Extended static checking home page, </title> <note> 1996. Available on the Internet from http://www.research.digital.com/SRC/esc/Esc.html. </note>
Reference-contexts: Even for such programs, however, we expect that reporting dag races to the user provides a useful debugging heuristic. Indeed, this approach has been implicitly taken by all previous dynamic race-detection tools. Race-detection algorithms In previous work, some efforts have been made to detect data races statically (at compile-time) <ref> [31, 42] </ref>. Static debuggers have the advantage that they sometimes can draw conclusions about the program for all inputs.
Reference: [32] <author> Robert H. B. Netzer and Sanjoy Ghosh. </author> <title> Efficient race condition detection for shared-memory programs with Post/Wait synchronization. </title> <booktitle> In Proceedings of the 1992 International Conference on Parallel Processing, </booktitle> <address> St. Charles, Illinois, </address> <month> August </month> <year> 1992. </year> <month> 122 </month>
Reference-contexts: Since understanding any nontrivial semantics of the program is generally undecidable, however, most race detectors are dynamic tools in which potential races are detected at runtime by executing the program on a given input. Some dynamic race detectors perform a post-mortem analysis based on program execution traces <ref> [12, 21, 29, 32] </ref>, while others perform an "on-the-fly" analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [10, 11, 14, 15, 28, 36], by binary rewriting [39], or by augmenting the machine's cache coherence protocol [30, 37].
Reference: [33] <author> Robert H. B. Netzer and Barton P. Miller. </author> <title> Improving the accuracy of data race detection. </title> <booktitle> In Proceedings of the Third ACM SIGPLAN Symposium on Principles & Practice of Parallel Programming (PPoPP), </booktitle> <pages> pages 133-144, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Reducing false race reports As we have seen, some dag races may not correspond to data races if they are artifacts of other races or of noncommutative critical sections. Other researchers have attempted to algorithmically identify "first races," as compared to later artifacts of those races <ref> [33, 34] </ref>. While we do not attempt anything of this magnitude, we do implement several tricks that can make the race reports of the Nondeterminator-2 more manageable for the user. The first trick is to avoid reporting the "same" race more than once.
Reference: [34] <author> Robert H. B. Netzer and Barton P. Miller. </author> <title> Experience with techniques for refining data race detection. </title> <type> Technical Report CS-92-55, </type> <institution> Brown University, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: Reducing false race reports As we have seen, some dag races may not correspond to data races if they are artifacts of other races or of noncommutative critical sections. Other researchers have attempted to algorithmically identify "first races," as compared to later artifacts of those races <ref> [33, 34] </ref>. While we do not attempt anything of this magnitude, we do implement several tricks that can make the race reports of the Nondeterminator-2 more manageable for the user. The first trick is to avoid reporting the "same" race more than once.
Reference: [35] <author> Robert H. B. Netzer and Barton P. Miller. </author> <title> What are race conditions? ACM Letters on Programming Languages and Systems, </title> <booktitle> 1(1) </booktitle> <pages> 74-88, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: If a program's output is determinate, but the program is not internally determinate, Emrath and Padua say it is externally determinate. A nondeterminate program is called associatively nondeterminate if the nondeterminate output is due only to lack of associativity of floating-point operations, or completely nondeterminate otherwise. Netzer and Miller <ref> [35] </ref> use a formal model of program behavior based on Lamport's theory of concurrent systems [27] to define nondeterminism. They are specifically concerned with defining race conditions.
Reference: [36] <author> Itzhak Nudler and Larry Rudolph. </author> <title> Tools for the efficient development of efficient parallel programs. </title> <booktitle> In Proceedings of the First Israeli Conference on Computer Systems Engineering, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [12, 21, 29, 32], while others perform an "on-the-fly" analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [10, 11, 14, 15, 28, 36] </ref>, by binary rewriting [39], or by augmenting the machine's cache coherence protocol [30, 37]. In this thesis, we present two race detection algorithms which are based on the Nondeterminator [14], a tool that finds dag races in Cilk programs that do not use locks. <p> Cilk is ideally suited for this parallelization, because its load-balancing scheduler is provably good, and so can obtain speedup 17 Handles Algorithm Handles series- Detects Time per Total locks parallel memory access space programs English-Hebrew NO YES Dag races O (pt) O (V t + min (bp; V tp)) labeling <ref> [36] </ref> Task NO YES Dag races O (t) O (t 2 + V t) Recycling [10] Offset-span NO YES Dag races O (p) O (V + min (bp; V p)) Labeling [28] SP-bags [14] NO YES Dag races O (ff (V; V )) O (V ) Lock YES YES Dag races <p> The Brelly algorithm is the fastest algorithm that detects locking discipline violations in fully series-parallel programs. The original work in this area was the English-Hebrew labeling method proposed by Nudler and Rudolph <ref> [36] </ref>. Their model assumes nested parallelism similar to Cilk's spawn/sync, but does not address programs that use locks. 1 In order to determine the logical relation between threads, each thread is given an English label and a Hebrew label. <p> discuss handling explicit synchronization operations between parallel threads, but we do not discuss that portion of the algorithm here. 43 Handles Algorithm Handles series- Detects Time per Total locks parallel memory access space dags English-Hebrew NO YES Dag races O (pt) O (V t + min (bp; V tp)) labeling <ref> [36] </ref> Task NO YES Dag races O (t) O (t 2 + V t) Recycling [10] Offset-span NO YES Dag races O (p) O (V + min (bp; V p)) Labeling [28] SP-bags [14] NO YES Dag races O (ff (V; V )) O (V ) Lock YES YES Dag races
Reference: [37] <author> Dejan Perkovic and Peter Keleher. </author> <title> Online data-race detection via coherency guarantees. </title> <booktitle> In Proceedings of the Second USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <address> Seattle, Washington, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: On-the-fly debuggers directly instrument memory accesses via the compiler [10, 11, 14, 15, 28, 36], by binary rewriting [39], or by augmenting the machine's cache coherence protocol <ref> [30, 37] </ref>. In this thesis, we present two race detection algorithms which are based on the Nondeterminator [14], a tool that finds dag races in Cilk programs that do not use locks. <p> In previous work, Dinning and Schonberg's "Lock Covers" algorithm [11] also detects all dag races in a computation. The All-Sets algorithm improves the Lock Covers algorithm by generalizing the data structures and techniques from the original Nondeterminator to produce better time and space bounds. Perkovic and Keleher <ref> [37] </ref> offer an on-the-fly race-detection algorithm that "piggybacks" on a cache-coherence protocol for lazy release consistency. <p> Its O (k ff (V; V )) amortized time per memory access and O (kV ) space usage are almost equivalent to Eraser's asymptotic bounds. Others have proposed detecting races by "piggybacking" on the machine's cache coherence protocol <ref> [30, 37] </ref>. In principle, such piggybacking is only useful in detecting data races that actually occur in an execution. That is, the cache coherence protocol can detect when threads that actually run in parallel access the same location.
Reference: [38] <author> Martin C. Rinard and Pedro C. Diniz. </author> <title> Commutativity analysis: A new analysis framework for parallelizing compilers. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 54-67, </pages> <address> Philadelphia, Pennsylvania, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Dinning and Schonberg give a conservative compile-time algorithm to check if a program is "internally deterministic" [11], and we have given thought as to how the abelian property might likewise be conservatively checked. The parallelizing compiler techniques of Rinard and Diniz <ref> [38] </ref> may be applicable. The guarantee of the Nondeterminator-2 for abelian programs requires that the program be deadlock-free, which is left to the user to verify. We would prefer to have a way of checking if a program, or at least a computation of a program, is deadlock free.
Reference: [39] <author> Stefan Savage, Michael Burrows, Greg Nelson, Patrick Sobalvarro, and Thomas Anderson. Eraser: </author> <title> A dynamic race detector for multi-threaded programs. </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Operating Systems Principles (SOSP), </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [12, 21, 29, 32], while others perform an "on-the-fly" analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [10, 11, 14, 15, 28, 36], by binary rewriting <ref> [39] </ref>, or by augmenting the machine's cache coherence protocol [30, 37]. In this thesis, we present two race detection algorithms which are based on the Nondeterminator [14], a tool that finds dag races in Cilk programs that do not use locks. <p> If a program obeys the umbrella discipline, a dag race cannot occur, because parallel accesses are always protected by the same lock. The Brelly algorithm detects violations of the umbrella locking discipline. Savage et al. <ref> [39] </ref> originally suggested that efficient debugging tools can be developed by requiring programs to obey a locking discipline. Their Eraser tool enforces a simple discipline in which any shared variable is protected by a single lock throughout the course of the program execution. <p> NO YES Dag races O (p) O (V + min (bp; V p)) Labeling [28] SP-bags [14] NO YES Dag races O (ff (V; V )) O (V ) Lock YES YES Dag races O (tn k ) O (t 2 + tn k V ) Covers [11] Eraser Eraser <ref> [39] </ref> YES NO discipline O (k) O (kV ) violations All-Sets YES YES Dag races O (n k ff (V; V ))) O (n k V ) Umbrella Brelly YES YES discipline O (k ff (V; V )) O (kV ) violations p = maximum depth of nested parallelism t = <p> [10] Offset-span NO YES Dag races O (p) O (V + min (bp; V p)) Labeling [28] SP-bags [14] NO YES Dag races O (ff (V; V )) O (V ) Lock YES YES Dag races O (tk 2 L) O (t 2 + tkLV ) Covers [11] Eraser Eraser <ref> [39] </ref> YES NO discipline O (k) O (kV ) violations All-Sets YES YES Dag races O (L (k + ff (V; V ))) O (kLV ) Umbrella Brelly YES YES discipline O (k ff (V; V )) O (kV ) violations p = maximum depth of nested parallelism t = maximum <p> As we have seen, the algorithm uses O (kLV ) space and O (L (k + ff (V; V ))) amortized time per memory access. Savage et al. <ref> [39] </ref> originally proposed the idea of using a locking discipline for race-detection purposes. Their discipline requires that every access to a variable that is shared be protected a single lock. Their model does not allow for nested parallelism or barriers.
Reference: [40] <author> Volker Strumpen. </author> <title> Compiler technology for portable checkpoints, </title> <note> 1998. Extended abstract, available at http://theory.lcs.mit.edu/~strumpen/porch.ps.gz. </note>
Reference-contexts: Publishing of objects could be more elegantly handled in a strongly-typed language. A possible solution for C is to use checkpointing technology, which is able to automatically trace through entire data structures <ref> [40] </ref>.
Reference: [41] <author> D. Stuttard, A. Worral, </author> <title> D.J. Paddon, and C.P. Willis. A parallel radiosity system for large data sets. </title> <booktitle> In ACM International Conference on Computer Graphics, </booktitle> <address> Pilzen, </address> <year> 1995. </year> <month> 123 </month>
Reference-contexts: Measurements were done on an 8-processor 167-MHz UltraSPARC I. a provably good work-stealing algorithm [4]. Radiosity, then, is a good test for the capabilities of Cilk's scheduler. Past attempts at parallelizing radiosity have required the algorithm to be modified with explicit load balancing <ref> [41] </ref>. In order to effectively test Cilk's performance, we prefer not to develop our own radiosity application. It is somewhat "unfair" to develop such a test by writing code that is intentionally designed to work well with Cilk.
Reference: [42] <author> Sunsoft. lock lint, </author> <year> 1994. </year> <title> See Sun Workshop Documentation for command-line utilities, </title> <note> available at http://www.math.colostate.edu/manuals/sunpro/ workshop/command line/WS locklint.doc.html. </note>
Reference-contexts: Even for such programs, however, we expect that reporting dag races to the user provides a useful debugging heuristic. Indeed, this approach has been implicitly taken by all previous dynamic race-detection tools. Race-detection algorithms In previous work, some efforts have been made to detect data races statically (at compile-time) <ref> [31, 42] </ref>. Static debuggers have the advantage that they sometimes can draw conclusions about the program for all inputs.
Reference: [43] <author> Robert Endre Tarjan. </author> <title> Efficiency of a good but not linear set union algorithm. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 22(2) </volume> <pages> 215-225, </pages> <month> April </month> <year> 1975. </year> <month> 124 </month>
Reference-contexts: Every spawned procedure 4 is given a unique ID at runtime. These IDs are kept in the fast disjoint-set data structure [8, Chapter 22] analyzed by Tarjan <ref> [43] </ref>.
References-found: 43

