URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR395.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Email: email: colby@dpsi.com  email: saxton@cs.uregina.ca  email: vgucht@cs.indiana.edu.  
Title: A Query Language for List-Based Complex Objects  
Author: Latha S. Colby Lawrence V. Saxton Dirk Van Gucht 
Affiliation: University of Regina, Dept. of Comp. Science,  Indiana University, Comp. Science Dept.,  
Address: Dr., Bloomington, IN, 47408;  Regina, Saskatchewan S4S 0A2, Canada,  Bloomington, IN 47405-4101,  
Note: Data Parallel Systems Inc., 4617 Morningside  
Date: May 1994 (revised)  
Abstract: We present a language for querying list-based complex objects. The language is shown to express precisely the polynomial-time generic list-object functions. The iteration mechanism of the language is based on a new approach wherein, in addition to the list over which the iteration is performed, a second list is used to control the number of iteration steps. During the iteration, the intermediate results can be moved to the output list as well as re-inserted into the list being iterated over. A simple syntactic constraint allows the growth rate of the intermediate results to be tightly controlled which, in turn, restricts the expressiveness of the language to PTIME. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and C. Beeri. </author> <title> On the power of languages for the manipulation of complex objects. </title> <booktitle> In Proceedings of the International Workshop on Theory and Applications of Nested Relations and Complex Objects, </booktitle> <address> Darmstadt, </address> <year> 1987. </year>
Reference-contexts: Similar languages were studied in a more general setting of set-based (non-recursive) complex objects by Abiteboul and Beeri <ref> [1] </ref> and Hull and Su [12, 14]. These languages were shown to express exactly all the elementary queries by Hull and Su [13]. <p> We will be interested in list-object functions that are computable (Section 2.2) and generic (Section 2.3). 2.1 Types and Domains List-object types have much in common with the non-recursive complex object types studied by Abiteboul and Beeri <ref> [1] </ref>, and Hull and Su [14]. The domain elements of a non-recursive complex object type all have a bounded nesting depth of tuple and set constructions. List-object types are essentially non-recursive complex object types wherein the set-constructor is replaced by the list-constructor. <p> And, a word over the full alphabet is coded correspondingly. For example the word ((( [[[ 1 0 jj 0 ]]] jj [[[ 0 jj 1 1 1 ]]] ))) is coded by the list ((((; <ref> [[[ ; 1; 0; jj ; 0; ] </ref>]] ; jj ; [[[ ; 0; jj ; 1; 1; 1; ]]] ; )))) For simplicity we have used the original symbols to represent their corresponding codes. <p> And, a word over the full alphabet is coded correspondingly. For example the word ((( [[[ 1 0 jj 0 ]]] jj [[[ 0 jj 1 1 1 ]]] ))) is coded by the list ((((; [[[ ; 1; 0; jj ; 0; ]]] ; jj ; <ref> [[[ ; 0; jj ; 1; 1; 1; ] </ref>]] ; )))) For simplicity we have used the original symbols to represent their corresponding codes. <p> The set of all the atomic elements in this list is fa; b; c; dg. We can now assign a bijective mapping from this set to the set of numbers f1; 2; 3; 4g. One such mapping may be represented by the list ([a; (1)]; [b; (1; 1)]; <ref> [c; (1; 1; 1)] </ref>; [d; (1; 1; 1; 1)]), where the second component of each tuple is the unary representation of a number between 1 and 4. The first step in the encoding process will generate such a mapping. <p> We can now assign a bijective mapping from this set to the set of numbers f1; 2; 3; 4g. One such mapping may be represented by the list ([a; (1)]; [b; (1; 1)]; [c; (1; 1; 1)]; <ref> [d; (1; 1; 1; 1)] </ref>), where the second component of each tuple is the unary representation of a number between 1 and 4. The first step in the encoding process will generate such a mapping. <p> So, the final encoded list of the example list will be ((((; <ref> [[[ ; 1; jj ; 1; 1; ] </ref>]] ; jj ; [[[ ; 1; 1; 1; jj ; 1; ]]] ; jj ; [[[ ; 1; 1; jj ; 1; 1; 1; 1; ]]] ; )))) Step 1 The input list is flattened and all the duplicates are removed to get <p> So, the final encoded list of the example list will be ((((; [[[ ; 1; jj ; 1; 1; ]]] ; jj ; <ref> [[[ ; 1; 1; 1; jj ; 1; ] </ref>]] ; jj ; [[[ ; 1; 1; jj ; 1; 1; 1; 1; ]]] ; )))) Step 1 The input list is flattened and all the duplicates are removed to get the list of all atomic elements in the input list. <p> So, the final encoded list of the example list will be ((((; [[[ ; 1; jj ; 1; 1; ]]] ; jj ; [[[ ; 1; 1; 1; jj ; 1; ]]] ; jj ; <ref> [[[ ; 1; 1; jj ; 1; 1; 1; 1; ] </ref>]] ; )))) Step 1 The input list is flattened and all the duplicates are removed to get the list of all atomic elements in the input list. This can be done by applying the appropriate "flatten" at each step. <p> So, if (a; b; c; d) is the list of atomic elements, then the final result of Step 1 will be the list ([a; (1)]; [b; (1; 1)]; <ref> [c; (1; 1; 1)] </ref>; [d; (1; 1; 1; 1)]). Step 2 Let l 0 be a list of type ((B)) containing n empty lists, where n is the size of the original input list l. The list l 0 can be constructed easily from l. <p> So, if (a; b; c; d) is the list of atomic elements, then the final result of Step 1 will be the list ([a; (1)]; [b; (1; 1)]; [c; (1; 1; 1)]; <ref> [d; (1; 1; 1; 1)] </ref>). Step 2 Let l 0 be a list of type ((B)) containing n empty lists, where n is the size of the original input list l. The list l 0 can be constructed easily from l.
Reference: [2] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural languages for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 41(2) </volume> <pages> 181-229, </pages> <year> 1990. </year>
Reference-contexts: We will first summarize results concerning set-based query languages, and relate and compare these with our results. Theoretical issues related to set-based query languages have been investigated by several researchers (e.g., <ref> [2, 3, 8, 7, 17, 21] </ref>).
Reference: [3] <author> S. Abiteboul and V. Vianu. </author> <title> Generic computation and its complexity. </title> <booktitle> In Proceedings of the 23rd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 209-219, </pages> <year> 1991. </year>
Reference-contexts: We will first summarize results concerning set-based query languages, and relate and compare these with our results. Theoretical issues related to set-based query languages have been investigated by several researchers (e.g., <ref> [2, 3, 8, 7, 17, 21] </ref>).
Reference: [4] <author> V. Breazu-Tannen, P. Buneman, and S. Naqvi. </author> <title> Structural recursion as a query langauge. </title> <booktitle> In Proceedings of the 3rd International Workshop on Database Programming Languages, </booktitle> <pages> pages 9-19, </pages> <address> Nafplion, Greece, </address> <month> August </month> <year> 1991. </year> <note> Morgan Kaufmann. 32 </note>
Reference-contexts: These languages were shown to express exactly all the elementary queries by Hull and Su [13]. There have also been several interesting efforts to apply functional programming paradigms, in particular list comprehension [20], structural recursion <ref> [4, 5] </ref>, and typed lambda calculus [11] to the design of set-based query languages.
Reference: [5] <author> V. Breazu-Tannen, P. Buneman, and L. Wong. </author> <title> Naturally embedded query languages. </title> <booktitle> In LNCS 646: Proceedings of the International Conference on Database Theory, </booktitle> <pages> pages 140-154. </pages> <publisher> Springer-verlag, </publisher> <month> October </month> <year> 1992. </year>
Reference-contexts: These languages were shown to express exactly all the elementary queries by Hull and Su [13]. There have also been several interesting efforts to apply functional programming paradigms, in particular list comprehension [20], structural recursion <ref> [4, 5] </ref>, and typed lambda calculus [11] to the design of set-based query languages.
Reference: [6] <author> A. Chandra. </author> <title> Programming primitives for database languages. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 50-62, </pages> <month> May </month> <year> 1981. </year>
Reference-contexts: It is obviously this second fact which does not extend to the list setting. (In this regard, the for-loop relational algebra <ref> [6] </ref>, which also characterizes the polynomial queries over ordered (flat) relations, is a much better candidate for adaptation to list query languages.) Even though the functional query language approaches present elegant platforms, there too difficulties exist. These difficulties are evident in the SRL language of Immerman, Patnaik and Stemple.
Reference: [7] <author> A. Chandra and D. Harel. </author> <title> Computable queries for relational data bases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: We will first summarize results concerning set-based query languages, and relate and compare these with our results. Theoretical issues related to set-based query languages have been investigated by several researchers (e.g., <ref> [2, 3, 8, 7, 17, 21] </ref>).
Reference: [8] <author> A. Chandra and D. Harel. </author> <title> Structure and complexity of relational queries. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25 </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: We will first summarize results concerning set-based query languages, and relate and compare these with our results. Theoretical issues related to set-based query languages have been investigated by several researchers (e.g., <ref> [2, 3, 8, 7, 17, 21] </ref>).
Reference: [9] <author> S. Grumbach and T. Milo. </author> <title> Towards tractable algebras for bags. </title> <booktitle> In Proceedings of the twelfth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 49-58, </pages> <address> Washingtion, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: First, and driven by the object-oriented methodology, the pointer (i.e., reference) type was added to accommodate recursive data types and object creation. Secondly, and driven by the needs of specialized data applications, data types such as arrays, multisets (also called bags), finite-lists, streams etc., were added (e.g. <ref> [9, 18, 19] </ref>). This paper is situated in the theory of query languages for database models that support non-recursive data types defined via the tuple and finite-list type constructors. We call these types collectively the list-based complex object types (or simply list-object types).
Reference: [10] <author> M. Gyssens and D. Van Gucht. </author> <title> The powerset algebra as a result of adding programming constructs to the nested relational algebra. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 225-232, </pages> <address> Chicago, IL, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: In sharp contrast, in the case of nested relations (relations whose values are relations in turn), when the lfp construct is added to the nested relational algebra, the language is equivalent to the nested algebra + powerset <ref> [10] </ref>. Similar languages were studied in a more general setting of set-based (non-recursive) complex objects by Abiteboul and Beeri [1] and Hull and Su [12, 14]. These languages were shown to express exactly all the elementary queries by Hull and Su [13].
Reference: [11] <author> G. G. Hillebrand, P. C. Kanellakis, and H. G. Mairson. </author> <title> Database query languages embedded in the typed lambda calculus. </title> <booktitle> In LICS, </booktitle> <year> 1993. </year>
Reference-contexts: These languages were shown to express exactly all the elementary queries by Hull and Su [13]. There have also been several interesting efforts to apply functional programming paradigms, in particular list comprehension [20], structural recursion [4, 5], and typed lambda calculus <ref> [11] </ref> to the design of set-based query languages.
Reference: [12] <author> R. Hull and J. Su. </author> <title> Untyped sets, invention, and computable queries. </title> <booktitle> In Proceedings of the eighth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 347-359, </pages> <year> 1989. </year>
Reference-contexts: Similar languages were studied in a more general setting of set-based (non-recursive) complex objects by Abiteboul and Beeri [1] and Hull and Su <ref> [12, 14] </ref>. These languages were shown to express exactly all the elementary queries by Hull and Su [13].
Reference: [13] <author> R. Hull and J. Su. </author> <title> On the expressive power of database queries with intermediate types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43(1) </volume> <pages> 219-267, </pages> <year> 1991. </year>
Reference-contexts: Similar languages were studied in a more general setting of set-based (non-recursive) complex objects by Abiteboul and Beeri [1] and Hull and Su [12, 14]. These languages were shown to express exactly all the elementary queries by Hull and Su <ref> [13] </ref>. There have also been several interesting efforts to apply functional programming paradigms, in particular list comprehension [20], structural recursion [4, 5], and typed lambda calculus [11] to the design of set-based query languages.
Reference: [14] <author> R. Hull and J. Su. </author> <title> Algebraic and calculus query languages for recursively typed complex objects. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 47 </volume> <pages> 121-156, </pages> <year> 1993. </year>
Reference-contexts: Similar languages were studied in a more general setting of set-based (non-recursive) complex objects by Abiteboul and Beeri [1] and Hull and Su <ref> [12, 14] </ref>. These languages were shown to express exactly all the elementary queries by Hull and Su [13]. <p> Interestingly, extending the type system to recursive types, which allow objects to have arbitrarily deep nesting, increases the complexity of the language beyond PTIME. This behavior is consistent with the results by Hull and Su <ref> [14] </ref> that show that the power of various complex object languages increases from the elementary queries to computable queries when the underlying (set-based) type system is extended from non-recursive to recursive. 2 The rest of this paper is organized as follows. <p> We will be interested in list-object functions that are computable (Section 2.2) and generic (Section 2.3). 2.1 Types and Domains List-object types have much in common with the non-recursive complex object types studied by Abiteboul and Beeri [1], and Hull and Su <ref> [14] </ref>. The domain elements of a non-recursive complex object type all have a bounded nesting depth of tuple and set constructions. List-object types are essentially non-recursive complex object types wherein the set-constructor is replaced by the list-constructor. <p> A list-object function f from S to ff, denoted f : S ! ff is a (partial) function from inst (S) to Dom (ff). We will only be interested in computable list-object functions. To make this notion precise, we adapt some material from Hull and Su <ref> [14] </ref>.
Reference: [15] <author> N. Immerman, S. Patnaik, and D. Stemple. </author> <title> The expressiveness of a family of finite set languages. </title> <type> Technical Report 91-96, </type> <institution> Computer and Information Science Department, University of Massachusetts, </institution> <year> 1991. </year>
Reference-contexts: Recently, Immerman, Patnaik and Stemple presented an elegant, functionally oriented language for sets called SRL (the set-reduce language) in <ref> [15, 16] </ref>. This language uses an iterative construct called set-reduce whose traversal depends on the order of the elements in the set (intuitively, set-reduce views the set as a duplicate free list). They show how different complexity classes can be captured by introducing syntactic restrictions on SRL.
Reference: [16] <author> N. Immerman, S. Patnaik, and D. Stemple. </author> <title> The expressiveness of a family of finite set languages. </title> <booktitle> In Proceedings of the tenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 37-52, </pages> <year> 1991. </year>
Reference-contexts: Recently, Immerman, Patnaik and Stemple presented an elegant, functionally oriented language for sets called SRL (the set-reduce language) in <ref> [15, 16] </ref>. This language uses an iterative construct called set-reduce whose traversal depends on the order of the elements in the set (intuitively, set-reduce views the set as a duplicate free list). They show how different complexity classes can be captured by introducing syntactic restrictions on SRL.
Reference: [17] <author> N. Immmerman. </author> <title> Relational queries computable in polynomial time. </title> <journal> Information and Control, </journal> <volume> 68 </volume> <pages> 86-104, </pages> <year> 1986. </year> <month> 33 </month>
Reference-contexts: We will first summarize results concerning set-based query languages, and relate and compare these with our results. Theoretical issues related to set-based query languages have been investigated by several researchers (e.g., <ref> [2, 3, 8, 7, 17, 21] </ref>). <p> Theoretical issues related to set-based query languages have been investigated by several researchers (e.g., [2, 3, 8, 7, 17, 21]). The earliest significant result in this area, relevant to the research presented here, was the theorem by Immerman <ref> [17] </ref> and Vardi [21] stating that the query language FO + lfp (i.e., first-order logic augmented with the least fixed point construct) characterizes the class of polynomial time queries over flat, ordered relational databases.
Reference: [18] <author> D. Maier and B. Vance. </author> <title> A call to order. </title> <booktitle> In Proceedings of the twelfth ACM SIGACT--SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-16, </pages> <address> Washing-tion, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: First, and driven by the object-oriented methodology, the pointer (i.e., reference) type was added to accommodate recursive data types and object creation. Secondly, and driven by the needs of specialized data applications, data types such as arrays, multisets (also called bags), finite-lists, streams etc., were added (e.g. <ref> [9, 18, 19] </ref>). This paper is situated in the theory of query languages for database models that support non-recursive data types defined via the tuple and finite-list type constructors. We call these types collectively the list-based complex object types (or simply list-object types).
Reference: [19] <author> D. S. Parker, E. Simon, and P. Valduriez. </author> <title> SVP a model capturing sets, streams and parallelism. </title> <booktitle> In Proceedings of the 18th VLDB Conference, </booktitle> <pages> pages 115-126, </pages> <address> Vancouver, Canada, </address> <year> 1992. </year>
Reference-contexts: First, and driven by the object-oriented methodology, the pointer (i.e., reference) type was added to accommodate recursive data types and object creation. Secondly, and driven by the needs of specialized data applications, data types such as arrays, multisets (also called bags), finite-lists, streams etc., were added (e.g. <ref> [9, 18, 19] </ref>). This paper is situated in the theory of query languages for database models that support non-recursive data types defined via the tuple and finite-list type constructors. We call these types collectively the list-based complex object types (or simply list-object types).
Reference: [20] <author> P. Trinder. </author> <title> Comprehensions, a query notation for DBPLs. </title> <booktitle> In Proceedings of the 3rd International Workshop on Database Programming Languages, </booktitle> <pages> pages 55-68, </pages> <address> Nafplion, Greece, August 1991. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: These languages were shown to express exactly all the elementary queries by Hull and Su [13]. There have also been several interesting efforts to apply functional programming paradigms, in particular list comprehension <ref> [20] </ref>, structural recursion [4, 5], and typed lambda calculus [11] to the design of set-based query languages.
Reference: [21] <author> M. Vardi. </author> <title> The complexity of relational query languages. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 137-146, </pages> <year> 1982. </year> <month> 34 </month>
Reference-contexts: We will first summarize results concerning set-based query languages, and relate and compare these with our results. Theoretical issues related to set-based query languages have been investigated by several researchers (e.g., <ref> [2, 3, 8, 7, 17, 21] </ref>). <p> Theoretical issues related to set-based query languages have been investigated by several researchers (e.g., [2, 3, 8, 7, 17, 21]). The earliest significant result in this area, relevant to the research presented here, was the theorem by Immerman [17] and Vardi <ref> [21] </ref> stating that the query language FO + lfp (i.e., first-order logic augmented with the least fixed point construct) characterizes the class of polynomial time queries over flat, ordered relational databases.
References-found: 21

