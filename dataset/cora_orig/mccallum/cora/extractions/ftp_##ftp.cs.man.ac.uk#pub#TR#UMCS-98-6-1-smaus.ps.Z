URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-smaus.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Title: Preventing Instantiation Errors and Loops for Logic Programs with Several Modes Using block Declarations  
Author: Jan-Georg Smaus yz Pat Hill Andy King 
Note: Extended abstract  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. R. Apt and I. Luitjes. </author> <title> Verification of logic programs with delay declarations. In AMAST'95, </title> <publisher> LNCS, </publisher> <address> Berlin, 1995. </address> <publisher> Springer Verlag. Invited Lecture. </publisher>
Reference-contexts: Technical Report Series, Department of Computer Science, University of Manchester, ISSN 1361-6161. Report number UMCS-98-6-1. http://www.cs.man.ac.uk/cstechrep/titles98.html y University of Kent at Canterbury, Canterbury, CT2 7NF, United Kingdom, j.g.smaus@ukc.ac.uk, telephone xx44/1227/827553, fax xx44/1227/762811. z Jan-Georg Smaus was supported by EPSRC Grant No. GR/K79635. 2 Preliminaries We use the notation of <ref> [1, 3] </ref>. For the examples we use SICStus [2] notation. We recall some important notions. A syntactic object is called linear if every variable occurs in it at most once. <p> In <ref> [1] </ref>, each predicate has a single mode. The idea is that in a query, every piece of data is produced (i.e. output) before it is consumed (i.e. input), and every piece of data is produced only once. "Before" refers to the textual position. <p> We generalise this by associating, with each query and each clause in a program, a permutation of the (body) atoms, such that the "reordered" program meets the requirements in <ref> [1] </ref>. For a different mode, the permutations would be different. 1 In examples, an actual permutation is written in the form h (1); : : : ; (n)i. <p> This program is nicely moded in mode fpermute (I ; O ); delete (I ; O ; I )g, and permutation nicely moded in fpermute (O ; I ); delete (O ; I ; O )g (the second clause is h2; 1i-nicely moded). Following <ref> [1] </ref>, we show a persistence property of permutation nicely-modedness. Lemma 3.1 Every SLD-resolvent of a permutation nicely moded query Q and a permutation nicely moded clause C is permutation nicely moded. <p> Lemma 3.1 Every SLD-resolvent of a permutation nicely moded query Q and a permutation nicely moded clause C is permutation nicely moded. Proof sketch: For Q and C = h B, there are permutations and ae such that (Q) and h ae (B) are nicely moded. By <ref> [1, Lemma 11] </ref> every resolvent of (Q) and h ae (B) is nicely moded. Thus it follows that every resolvent of Q and C is permutation nicely moded. Permutation nicely-modedness could be used to show that the occur-check can be omitted. <p> For mode flength (O ; I ); len aux (O; I ; I )g, it is not permutation nicely moded, since the input in len_aux ([],N,N) is not linear. The second concept we generalise from <ref> [1] </ref> is well-typedness. As with modes, we assume that the types are given. In the examples, they will be the obvious ones. Definition 3.2 [permutation well typed] Let n 0 and be a permutation such that (i) = i whenever i =2 f1; : : : ; ng. <p> The same holds assuming types permute (numlist; numlist), delete (num; numlist; numlist). The following lemma is shown as Lemma 3.1, using <ref> [1, Lemma 23] </ref>. Lemma 3.2 Every SLD-resolvent of a permutation well typed query and a permutation well typed clause is permutation well typed. <p> For different programs, different approaches are applicable. 4.1 Exploiting constant types The first approach aims at preventing instantiation and type errors for built-ins which require arguments to be ground, in particular arithmetic built-ins. It is proposed in <ref> [1] </ref> to equip these predicates with delay declarations such that they are only executed when the input is ground. The advantage is that one can reason about arbitrary arithmetic expressions, e.g. quicksort ([1+1,3-8],M). The disadvantage is that block declarations cannot be used. <p> The disadvantage is that block declarations cannot be used. In contrast, we assume that the type of arithmetic built-ins is the constant type num, rather than arithmetic expressions. Then we show that block declarations are sufficient. The following lemma is a straightforward variation of <ref> [1, Lemma 27] </ref>. 2 S i and T i are the vectors of types of the input and output arguments, respectively. <p> The program is not permutation simply typed for fqs (O ; I ); append (O ; O; I ); part (O; I ; I ; I )g, because of [X|Bs2] in an output position. 3 This is similar to "the delay declarations imply matching" <ref> [1] </ref>. 4.2 Atomic positions Sometimes, when the above method does not work because a program is not permutation simply typed, it is still possible to show absence of instantiation errors for arithmetic predicates. <p> We envisage a program development tool which would help a programmer to verify the conditions and to reorder atoms in clause bodies to ensure that one of the methods applies for each mode. This work was inspired by <ref> [1] </ref>. For arithmetic built-ins, [1] requires declarations which delay an atom until the arguments are ground. Such declarations are usually implemented not as efficiently as block declarations. Little attention is given to termination, proposing a method limited to deterministic programs. <p> We envisage a program development tool which would help a programmer to verify the conditions and to reorder atoms in clause bodies to ensure that one of the methods applies for each mode. This work was inspired by <ref> [1] </ref>. For arithmetic built-ins, [1] requires declarations which delay an atom until the arguments are ground. Such declarations are usually implemented not as efficiently as block declarations. Little attention is given to termination, proposing a method limited to deterministic programs.
Reference: [2] <institution> Intelligent Systems Laboratory, SICS, </institution> <address> PO Box 1263, S-164 29 Kista, Sweden. </address> <note> SICStus Prolog User's Manual, 1997. http://www.sics.se/isl/sicstus/sicstus toc.html. </note>
Reference-contexts: For all of the above, we show that under realistic assumptions, block declarations, which declare that certain arguments of an atom must be at least non-variable before that atom can be selected, are sufficient. In SICStus <ref> [2] </ref>, block declarations are efficiently implemented; the instantiation test has hardly any impact on performance. Thus such constructs are the most frequently used delay declarations in practice. For arithmetic built-ins, we exploit that for numbers, being non-variable implies being ground, and show how to prevent instantiation and type errors. <p> Report number UMCS-98-6-1. http://www.cs.man.ac.uk/cstechrep/titles98.html y University of Kent at Canterbury, Canterbury, CT2 7NF, United Kingdom, j.g.smaus@ukc.ac.uk, telephone xx44/1227/827553, fax xx44/1227/762811. z Jan-Georg Smaus was supported by EPSRC Grant No. GR/K79635. 2 Preliminaries We use the notation of [1, 3]. For the examples we use SICStus <ref> [2] </ref> notation. We recall some important notions. A syntactic object is called linear if every variable occurs in it at most once.
Reference: [3] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Technical Report Series, Department of Computer Science, University of Manchester, ISSN 1361-6161. Report number UMCS-98-6-1. http://www.cs.man.ac.uk/cstechrep/titles98.html y University of Kent at Canterbury, Canterbury, CT2 7NF, United Kingdom, j.g.smaus@ukc.ac.uk, telephone xx44/1227/827553, fax xx44/1227/762811. z Jan-Georg Smaus was supported by EPSRC Grant No. GR/K79635. 2 Preliminaries We use the notation of <ref> [1, 3] </ref>. For the examples we use SICStus [2] notation. We recall some important notions. A syntactic object is called linear if every variable occurs in it at most once.
Reference: [4] <author> S. Luttringhaus-Kappel. </author> <title> Control generation for logic programs. </title> <editor> In D. Warren, editor, </editor> <booktitle> Proceedings of ICLP, </booktitle> <pages> pages 478-495. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: In <ref> [4] </ref>, a method is proposed to generate control automatically to ensure termination, giving practical evidence that control declarations were generated for many programs. The method assumes arbitrary delay-respecting derivations and hence does not work for programs where termination depends on left-based derivations.
Reference: [5] <author> E. Marchiori and F. Teusink. </author> <title> Proving termination of logic programs with delay declarations. </title> <editor> In J. Lloyd, editor, </editor> <booktitle> Proceedings of ILPS, </booktitle> <pages> pages 447-461. </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: In [4], a method is proposed to generate control automatically to ensure termination, giving practical evidence that control declarations were generated for many programs. The method assumes arbitrary delay-respecting derivations and hence does not work for programs where termination depends on left-based derivations. The results of <ref> [5] </ref> are not comparable to ours because they assume a local selection rule (always selects an atom which was introduced in the most recent resolution step).
Reference: [6] <author> L. Naish. </author> <title> Coroutining and the construction of terminating logic programs. </title> <type> Technical Report 92/5, </type> <institution> University of Melbourne, </institution> <year> 1992. </year>
Reference-contexts: Sometimes, it is not even necessary to have any delay declarations at all for arithmetic built-ins. Preventing a predicate from using its own output as input (circular modes) is crucial for termination <ref> [6] </ref>. We generalise this to multi-moded predicates. Another source of loops [6] is speculative output bindings, i.e. bindings made before it is known that a solution exists. We propose two methods for dealing with this problem and thus proving (or ensuring) termination. <p> Sometimes, it is not even necessary to have any delay declarations at all for arithmetic built-ins. Preventing a predicate from using its own output as input (circular modes) is crucial for termination <ref> [6] </ref>. We generalise this to multi-moded predicates. Another source of loops [6] is speculative output bindings, i.e. bindings made before it is known that a solution exists. We propose two methods for dealing with this problem and thus proving (or ensuring) termination. Which method must be applied will depend on the program and on the mode being considered. <p> Termination can be proven for Ex. 5.1, but not for Ex. 4.1. There is a more sophisticated method [7], but it requires more complex checks. Example 5.1 The query permute (V,[1]) (Ex. 3.1) loops because delete produces a speculative output binding <ref> [6] </ref>: The output variable Y is bound before it is known that this binding will never have to be undone. Assuming left-based derivations, termination in both modes can be ensured by replacing the second clause with permute ([U | X1], Y) :- delete (U, Y, Z), permute (X1, Z). <p> Assuming left-based derivations, termination in both modes can be ensured by replacing the second clause with permute ([U | X1], Y) :- delete (U, Y, Z), permute (X1, Z). This technique can be described as putting recursive calls last <ref> [6] </ref>. To explain termination, we have to apply a different reasoning for the different modes. In mode permute (I,O), delete is used in mode delete (I ; O ; I ), and in this mode it does not make speculative bindings. <p> It turns out that by this construction, 0 is infinite. Lemma 5.1 says that for non-speculative programs, atom order in clause bodies is irrelevant for termination. 5.2 Termination by not using speculative bindings In LD-derivations, speculative bindings are never used <ref> [6] </ref>. Assuming left-based derivations, all derivations are LD-derivations, provided the leftmost atom in a query is always selectable. This immediately implies the following lemma. <p> For arithmetic built-ins, [1] requires declarations which delay an atom until the arguments are ground. Such declarations are usually implemented not as efficiently as block declarations. Little attention is given to termination, proposing a method limited to deterministic programs. The good intuitive explanations for loops in <ref> [6] </ref> guided our search for further ideas and their formalisation. To ensure termination, some heuristics are proposed, without formal proof.
Reference: [7] <author> J.-G. Smaus, P. M. Hill, and A. King. </author> <title> Termination of logic programs with block declarations running in several modes. </title> <editor> In C. Palamadessi, editor, </editor> <booktitle> Proceedings of PLILP/ALP, </booktitle> <publisher> LNCS. Springer Verlag, </publisher> <year> 1998. </year>
Reference-contexts: Our approach is simple, and the conditions are easy to check. Termination can be proven for Ex. 5.1, but not for Ex. 4.1. There is a more sophisticated method <ref> [7] </ref>, but it requires more complex checks. Example 5.1 The query permute (V,[1]) (Ex. 3.1) loops because delete produces a speculative output binding [6]: The output variable Y is bound before it is known that this binding will never have to be undone.
Reference: [8] <author> Z. Somogyi, F. Henderson, and T. Conway. </author> <title> The execution algorithm of Mercury, an efficient purely declarative logic programming language. </title> <journal> Journal of Logic Programming, </journal> <month> November </month> <year> 1996. </year> <title> 4 Mercury [8] takes the same approach, and the versions are all generated by the compiler. </title>
References-found: 8

