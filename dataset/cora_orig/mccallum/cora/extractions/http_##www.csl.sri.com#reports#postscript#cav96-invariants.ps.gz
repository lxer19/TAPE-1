URL: http://www.csl.sri.com/reports/postscript/cav96-invariants.ps.gz
Refering-URL: http://www.csl.sri.com/cav96-invariants.html
Root-URL: 
Phone: 2  
Title: Powerful Techniques for the Automatic Generation of Invariants  
Author: Saddek Bensalem ? Yassine Lakhnech and Hassen Saidi ??? 
Address: Miniparc-Zirst, Rue Lavoisier 38330 Montbonnot St-Martin, France.  Kiel, Preuerstr. 1-9, D-24105 Kiel, Germany.  
Affiliation: 1 VERIMAG,  Institut fur Informatik und Praktische Mathematik Christian-Albrechts-Universitat zu  
Abstract: When proving invariance properties of programs one is faced with two problems. The first problem is related to the necessity of proving tautologies of the considered assertion language, whereas the second manifests in the need of finding sufficiently strong invariants. This paper focuses on the second problem and describes techniques for the automatic generation of invariants. The first set of these techniques is applicable on sequential transition systems and allows to derive so-called local invariants, i.e. predicates which are invariant at some control location. The second is applicable on networks of transition systems and allows to combine local invariants of the sequential components to obtain local invariants of the global systems. Furthermore, a refined strengthening technique is presented that allows to avoid the problem of size-increase of the considered predicates which is the main drawback of the usual strengthening technique. The proposed techniques are illustrated by examples.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> K.R. Apt. </author> <title> Ten years of Hoare's logic : a survey, part I. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 3(2) </volume> <pages> 431-483, </pages> <year> 1981. </year>
Reference-contexts: Next, we briefly recall the basic idea for proving invariance properties of programs. This idea underlies many proof rules formulated in different settings (e.g. <ref> [8, 1, 15] </ref>). To do so, we recall the definition of some predicate transformers. Definition 3.
Reference: 2. <author> N. Bjtner, A. Browne, and Z. Manna. </author> <title> Automatic generation of invariants and in termediate assertions. </title> <editor> In U. Montanari, editor, </editor> <booktitle> 1st Int. Conf. on Principles and Practice of Constraint Programming, </booktitle> <year> 1995. </year>
Reference-contexts: Here, we present results which are to our knowledge new or extensions of existing ones. Other interesting recent results are reported in <ref> [2] </ref>. These techniques represent an important component of a tool which is being developed to support the computer-aided verification of safety properties of 3 This list of references is far from being exhaustive. See [15] for other references. reactive programs. <p> We concentrate on strategies which are to our knowledge new or extensions of strategies presented in other works (e.g. <ref> [9, 11, 15, 14, 2] </ref>). The auxiliary predicates derived using our strategies are proved to be invariant by construction.
Reference: 3. <author> M. Caplain. </author> <title> Finding invariant assertions for proving programs. </title> <booktitle> In Proc. Int. Conf. on Reliable Software, </booktitle> <address> Los Angeles, CA, </address> <year> 1975. </year>
Reference-contexts: The problem of automatically constructing invariants from program description has been intensively investigated in the seventieth leading to results reported in e.g. <ref> [11, 9, 3, 7] </ref> 3 . Here, we present results which are to our knowledge new or extensions of existing ones. Other interesting recent results are reported in [2].
Reference: 4. <author> E.M. Clarke, E.A. Emerson, and E. Sistla. </author> <title> Automatic verification of finite state concurrent systems using temporal logic specifications: A practical approach. </title> <booktitle> In POPL'83. ACM, </booktitle> <year> 1983. </year>
Reference-contexts: 1 Introduction Model checking <ref> [17, 4, 13, 20] </ref> is by now a well-known method for proving properties of reactive programs. The main reason for its success is that it works fully automatically, i.e. without any intervention of the user.
Reference: 5. <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In 4th ACM symp. of Prog. Lang., </booktitle> <pages> pages 238-252. </pages> <publisher> ACM Press, </publisher> <year> 1977. </year>
Reference-contexts: Concerning Szymanski's mutual exclusion algorithm, we verified the parameterized as well as the unparameterized case. We intend to combine our techniques with others as abstract interpretation <ref> [5] </ref> to discover relationships between program variables that can be used to derive invariants and to investigate heuristics and strategies for the decomposition of large programs. Acknowledgements We thank J. Sifakis who continuously encouraged and supported this work. Many interesting discussions with S. Graf and A.
Reference: 6. <author> E. W. Dijkstra. </author> <title> Guarded commands, nondeterminacy, and formal derivation. </title> <journal> Comm. ACM, </journal> <volume> 18(8) </volume> <pages> 453-457, </pages> <year> 1975. </year>
Reference-contexts: The most general one allows to propagate even in the presence of loops. Again our technique is applicable in cases not covered by the propagation techniques presented in e.g. [15, 14]. Refined strengthening: One of the most used techniques for strengthening invariants is by calculating the weakest (liberal) precondition <ref> [6] </ref> w.r.t. the considered invariant and taking it as a conjunct. A drawback of this method is that it increases the complexity of the considered predicate, and hence, after few steps its application leads in many cases to unmanageable predicates. <p> Note that the gpre [] and post [] are the weakest liberal precondition and strongest postcondition predicate transformers <ref> [6] </ref>.
Reference: 7. <author> B. Elspas. </author> <title> The semiautomatic generation of inductive assertions for proving pro gram correctness. </title> <type> Research report, </type> <institution> SRI, </institution> <address> Menlo Park, CA, </address> <year> 1974. </year>
Reference-contexts: The problem of automatically constructing invariants from program description has been intensively investigated in the seventieth leading to results reported in e.g. <ref> [11, 9, 3, 7] </ref> 3 . Here, we present results which are to our knowledge new or extensions of existing ones. Other interesting recent results are reported in [2].
Reference: 8. <author> R. W. Floyd. </author> <title> Assigning meanings to programs. In In. </title> <journal> Proc. Symp. on Appl. Math. </journal> <volume> 19, </volume> <pages> pages 19-32. </pages> <publisher> American Mathematical Society, </publisher> <year> 1967. </year>
Reference-contexts: Next, we briefly recall the basic idea for proving invariance properties of programs. This idea underlies many proof rules formulated in different settings (e.g. <ref> [8, 1, 15] </ref>). To do so, we recall the definition of some predicate transformers. Definition 3.
Reference: 9. <author> S. M. German and B. Wegbreit. </author> <title> A synthesizer of inductive assertions. </title> <journal> IEEE Trans. On Software Engineering, </journal> <volume> 1 </volume> <pages> 68-75, </pages> <month> March </month> <year> 1975. </year>
Reference-contexts: The problem of automatically constructing invariants from program description has been intensively investigated in the seventieth leading to results reported in e.g. <ref> [11, 9, 3, 7] </ref> 3 . Here, we present results which are to our knowledge new or extensions of existing ones. Other interesting recent results are reported in [2]. <p> We concentrate on strategies which are to our knowledge new or extensions of strategies presented in other works (e.g. <ref> [9, 11, 15, 14, 2] </ref>). The auxiliary predicates derived using our strategies are proved to be invariant by construction.
Reference: 10. <author> S. Graf and H. Saidi. </author> <title> Verifying invariants using theorem proving. </title> <booktitle> In In this volume, </booktitle> <year> 1996. </year>
Reference-contexts: These techniques represent an important component of a tool which is being developed to support the computer-aided verification of safety properties of 3 This list of references is far from being exhaustive. See [15] for other references. reactive programs. Here, we give a brief description of this tool (See <ref> [10] </ref> for a detailed discussion). It consists of the following components: Front-end: The front-end takes as input a description of a transition sys tem written as a program in a simple programming language and a predicate to be proved as invariant of the described transition system.
Reference: 11. <author> S. Katz and Z. Manna. </author> <title> A heuristic approach to program verification. </title> <booktitle> In Proc. 3rd Int. Joint Conf. on Artificial Intelligence, </booktitle> <address> Stanford,CA, </address> <year> 1976. </year>
Reference-contexts: The problem of automatically constructing invariants from program description has been intensively investigated in the seventieth leading to results reported in e.g. <ref> [11, 9, 3, 7] </ref> 3 . Here, we present results which are to our knowledge new or extensions of existing ones. Other interesting recent results are reported in [2]. <p> We concentrate on strategies which are to our knowledge new or extensions of strategies presented in other works (e.g. <ref> [9, 11, 15, 14, 2] </ref>). The auxiliary predicates derived using our strategies are proved to be invariant by construction.
Reference: 12. <author> L. Lamport. </author> <title> A new solution of Dijkstra's concurrent programming problem. </title> <journal> Comm. ACM, </journal> <volume> 17(8) </volume> <pages> 453-455, </pages> <year> 1974. </year>
Reference-contexts: All predicates that can be generated by these strategies are proved to be invariant by construction. The use of these techniques for various mutual exclusion algorithms shows that they are promising. For instance, in case of the Bakery algorithm <ref> [12, 15] </ref>, which is an infinite-state program, we generate an invariant that is sufficiently strong to prove the required property. <p> In this section, we present techniques we use to prove invariance properties of networks without calculating the product. These techniques have been successfully applied to many mutual exclusion algorithms, e.g. the Bakery mutual exclusion algorithm <ref> [12, 15] </ref> in three different versions and Szymanski's mutual exclusion algorithm [18, 19] both parameterized and for two processes. Definition 10. <p> Q i := Q i ^ propg (S i ; Q i ), for i = 1; 2 5. return P ^ Q 1 ^ Q 2 4 Example The example we consider is the Bakery mutual exclusion algorithm <ref> [12, 15] </ref>. Two processes are competing to enter their respective critical sections represented by location 4. Thus, the invariant we are going to prove is given by the predicate IN V = :(pc 1 = 4 ^ pc 2 = 4).
Reference: 13. <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs sat isfy their linear specification. </title> <booktitle> In POPL, </booktitle> <pages> pages 97-107, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction Model checking <ref> [17, 4, 13, 20] </ref> is by now a well-known method for proving properties of reactive programs. The main reason for its success is that it works fully automatically, i.e. without any intervention of the user.
Reference: 14. <author> Z. Manna, A. Anuchitanukul, N. Bjtner, A. Browne, E. Chang, M. Colon, L. De Alfaro, H. Devarajan, H. Sipma, and T. Uribe. </author> <title> STeP : The Stanford Temporal Prover. </title> <type> Technical report, </type> <institution> Stanford Univ., Stanford, </institution> <address> CA, </address> <year> 1995. </year>
Reference-contexts: This is more general than the one called reaffirmed invariants in <ref> [15, 14] </ref>. Propagation of invariants: This technique allows to propagate an assertion that holds whenever control is at some fixed control location to other control locations. We consider two instances of this technique. The most general one allows to propagate even in the presence of loops. <p> We consider two instances of this technique. The most general one allows to propagate even in the presence of loops. Again our technique is applicable in cases not covered by the propagation techniques presented in e.g. <ref> [15, 14] </ref>. Refined strengthening: One of the most used techniques for strengthening invariants is by calculating the weakest (liberal) precondition [6] w.r.t. the considered invariant and taking it as a conjunct. <p> We concentrate on strategies which are to our knowledge new or extensions of strategies presented in other works (e.g. <ref> [9, 11, 15, 14, 2] </ref>). The auxiliary predicates derived using our strategies are proved to be invariant by construction. <p> This is a generalization of the reaffirmed invariance strategy presented in <ref> [15, 14] </ref>. Let S = hX; pc : DC; T; I ^pc = d 0 i be given. For ff DC, let L (ff) denote the set of transitions t with tar (t) 2 ff. <p> Moreover, calculating the set of reachable states using the post operator does not terminate (no fix-point can be reached in a finite number of steps). Calculating the weakest invariance property that is contained in IN V does terminate after 8 steps (cf. <ref> [14] </ref>). We can automatically generate by our techniques an invariant that is inductive and that allows to prove that IN V is indeed an invariant.
Reference: 15. <author> Z. Manna and A. Pnueli. </author> <title> Temporal Verification of Reactive Systems: Safety. </title> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: This is more general than the one called reaffirmed invariants in <ref> [15, 14] </ref>. Propagation of invariants: This technique allows to propagate an assertion that holds whenever control is at some fixed control location to other control locations. We consider two instances of this technique. The most general one allows to propagate even in the presence of loops. <p> We consider two instances of this technique. The most general one allows to propagate even in the presence of loops. Again our technique is applicable in cases not covered by the propagation techniques presented in e.g. <ref> [15, 14] </ref>. Refined strengthening: One of the most used techniques for strengthening invariants is by calculating the weakest (liberal) precondition [6] w.r.t. the considered invariant and taking it as a conjunct. <p> All predicates that can be generated by these strategies are proved to be invariant by construction. The use of these techniques for various mutual exclusion algorithms shows that they are promising. For instance, in case of the Bakery algorithm <ref> [12, 15] </ref>, which is an infinite-state program, we generate an invariant that is sufficiently strong to prove the required property. <p> Other interesting recent results are reported in [2]. These techniques represent an important component of a tool which is being developed to support the computer-aided verification of safety properties of 3 This list of references is far from being exhaustive. See <ref> [15] </ref> for other references. reactive programs. Here, we give a brief description of this tool (See [10] for a detailed discussion). <p> Then, the set of computations of S 1 k S 2 is defined to be that of S 1 N Invariance Properties We consider a class of properties, named invariance properties (cf. <ref> [15] </ref>). Intuitively, a property P is an invariant of a transition system S, if in each state of the system S this property holds. In other words, each state that is reached during a computation of S satisfies P . Definition 2. <p> Next, we briefly recall the basic idea for proving invariance properties of programs. This idea underlies many proof rules formulated in different settings (e.g. <ref> [8, 1, 15] </ref>). To do so, we recall the definition of some predicate transformers. Definition 3. <p> We concentrate on strategies which are to our knowledge new or extensions of strategies presented in other works (e.g. <ref> [9, 11, 15, 14, 2] </ref>). The auxiliary predicates derived using our strategies are proved to be invariant by construction. <p> This is a generalization of the reaffirmed invariance strategy presented in <ref> [15, 14] </ref>. Let S = hX; pc : DC; T; I ^pc = d 0 i be given. For ff DC, let L (ff) denote the set of transitions t with tar (t) 2 ff. <p> Refined Strengthening Suppose we are given a proposed invariant P for transition system S with transitions T . Suppose also that the proof of P ) gpre [! t ](P ) fails for t 1 ; ; t m . The method of strengthening invariants (e.g. <ref> [15] </ref>) proposes to try as next invariant P 1 = P ^ V m i=1 gpre [! t i ](P ). <p> In this section, we present techniques we use to prove invariance properties of networks without calculating the product. These techniques have been successfully applied to many mutual exclusion algorithms, e.g. the Bakery mutual exclusion algorithm <ref> [12, 15] </ref> in three different versions and Szymanski's mutual exclusion algorithm [18, 19] both parameterized and for two processes. Definition 10. <p> Q i := Q i ^ propg (S i ; Q i ), for i = 1; 2 5. return P ^ Q 1 ^ Q 2 4 Example The example we consider is the Bakery mutual exclusion algorithm <ref> [12, 15] </ref>. Two processes are competing to enter their respective critical sections represented by location 4. Thus, the invariant we are going to prove is given by the predicate IN V = :(pc 1 = 4 ^ pc 2 = 4). <p> The use of these heuristics for the verification of various mutual exclusion algorithms shows that they are promising. They have been applied to different versions of the Bakery, Dekker, Peterson, and Szymanski algorithms (see <ref> [15] </ref> for a recent presentation of many of these algorithms and for references). Concerning Szymanski's mutual exclusion algorithm, we verified the parameterized as well as the unparameterized case.
Reference: 16. <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <year> 1995. </year>
Reference-contexts: It consists of the following components: Front-end: The front-end takes as input a description of a transition sys tem written as a program in a simple programming language and a predicate to be proved as invariant of the described transition system. Then, it produces a PVS-theory <ref> [16] </ref> that mainly contains the verification conditions to be proved. The front-end analyses also the program and generates a file containing information needed to decide, for each control location, whether some invariant generation procedure can be applied. <p> In case the system is unable to prove the invariance of P , it may either do some strengthening or enter the interactive modus and requires the user's guidance. This choice is made by the user. - PVS is the theorem prover developed at SRI <ref> [16] </ref>. It is used during the automatic- as well as interactive proof procedure to discharge the verification conditions. 2 Transition Systems and Invariance Properties We assume an underlying assertion language A that includes first-order predicate logic and interpreted symbols for expressing the standard operations and relations over some concrete domains.
Reference: 17. <author> J. P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in CESAR. </title> <booktitle> In Proc. 5th Int. Sym. on Programming, volume 137 of Lecture Notes in Computer Science, </booktitle> <pages> pages 337-351. </pages> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: 1 Introduction Model checking <ref> [17, 4, 13, 20] </ref> is by now a well-known method for proving properties of reactive programs. The main reason for its success is that it works fully automatically, i.e. without any intervention of the user.
Reference: 18. <author> B. K. Szymanski. </author> <title> A simple solution to Lamport's concurrent programming problem verification. </title> <booktitle> In Proc. Intern. Conf. on Supercomputing Sys., </booktitle> <pages> pages 621-626, </pages> <year> 1988. </year>
Reference-contexts: In this section, we present techniques we use to prove invariance properties of networks without calculating the product. These techniques have been successfully applied to many mutual exclusion algorithms, e.g. the Bakery mutual exclusion algorithm [12, 15] in three different versions and Szymanski's mutual exclusion algorithm <ref> [18, 19] </ref> both parameterized and for two processes. Definition 10.
Reference: 19. <author> B. K. Szymanski and J. M. Vidal. </author> <title> Automatic verfication of a class of symmetric parallel programs. </title> <booktitle> In Proc. 13th IFIP World Computer Congress, </booktitle> <year> 1994. </year>
Reference-contexts: In this section, we present techniques we use to prove invariance properties of networks without calculating the product. These techniques have been successfully applied to many mutual exclusion algorithms, e.g. the Bakery mutual exclusion algorithm [12, 15] in three different versions and Szymanski's mutual exclusion algorithm <ref> [18, 19] </ref> both parameterized and for two processes. Definition 10.
Reference: 20. <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In LICS'86. IEEE, </booktitle> <year> 1986. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: 1 Introduction Model checking <ref> [17, 4, 13, 20] </ref> is by now a well-known method for proving properties of reactive programs. The main reason for its success is that it works fully automatically, i.e. without any intervention of the user.
References-found: 20

