URL: http://www.cs.mtu.edu/~dkkuras/resume/paper.ps
Refering-URL: http://www.cs.mtu.edu/~dkkuras/resume/resume.html
Root-URL: http://www.cs.mtu.edu
Email: jang@eis.comm.mot.com  fcarr,sweany,dkkurasg@mtu.edu  
Title: A Code Generation Framework for VLIW Architectures with Partitioned Register Banks  
Author: Saurabh Jang Steve Carr Philip Sweany Darla Kuras 
Address: 1301 East Algonquin Road Schaumburg, IL 60196  Houghton MI 49931-1295  
Affiliation: Motorola Corporation  Department of Computer Science Michigan Technological University  
Abstract: Modern computers are taking increasing advantage of the instruction-level parallelism (ILP) available in programs with advances in both machine and compiler design. Unfortunately, large amounts of ILP hardware and aggressive instruction scheduling techniques put large demands on a machine's register resources. With large amounts of ILP, it becomes difficult to maintain a single monolithic register bank and a high clock rate. The number of ports required for such a register bank severely hampers access time [2, 8]. To provide support for large amounts of ILP while retaining a high clock rate, registers can be partitioned among several different register banks. Each bank is directly accessible by only a subset of the functional units with explicit inter-bank copies required to move data between banks. Therefore, a compiler must deal not only with achieving maximal parallelism via aggressive scheduling, but also with data placement to limit inter-bank copies. This paper describes our approach to partitioning values among available register banks. Our method provides flexibility for our retargetable compiler by representing machine dependent features as node and edge weights and by remaining independent of scheduling and register allocation methods. Preliminary experimentation with our framework has shown a degradation in execution performance of 33% on average when compared to an unrealizable monolithic-register-bank VLIW architecture with the same level of ILP. This compares very favorably with other approaches to the same problem. fl This research was supported by a grant from Texas Instruments.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Briggs, K. D. Cooper, K. Kennedy, and L. Torczon. </author> <title> Coloring heuristics for register allocation. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(7):275284, </volume> <month> July </month> <year> 1989. </year> <booktitle> Proceedings of the ACM SIG-PLAN '89 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Thus, comparisons are difficult. 3. Register Assignment with Partitioned Regis ter Banks A good deal of work has investigated how registers should be assigned when a machine has a single register bank of equivalent registers <ref> [4, 5, 1] </ref>. However, on architectures with high degrees of ILP, it is often inconvenient or impossible to have a single register bank associated with all functional units. Such a single register bank would require too many read/write ports to be practical [2].
Reference: [2] <author> A. Capitanio, N. Dutt, and A. Nicolau. </author> <title> Partitioned Register Files for VLIW's: A Preliminary Analysis of Tradeoffs. </title> <booktitle> In Proceedings of the 25th Annual International Symposium on Microarchitecture (MICRO-25), </booktitle> <pages> pages 292300, </pages> <address> Portland, OR, </address> <month> December 1-4 </month> <year> 1992. </year>
Reference-contexts: Unfortunately, large amounts of ILP hardware and aggressive instruction scheduling techniques put large demands on a machine's register resources. With these demands, it becomes difficult to maintain a single monolithic register bank. The number of ports required for such a register bank severely hampers access time <ref> [2, 8] </ref>. Partitioned register banks are one mechanism for providing high degrees of ILP with a high clock rate (Texas Instruments already produces several DSP chips that have partitioned register banks to support high ILP [14].) Unfortunately, partitioned register banks may inhibit achieved ILP. <p> Our method abstracts away machine-dependent details from partitioning with edge and node weights, a feature that is extremely important in the context of a retar-getable compiler. Capitanio et al. present a code-generation technique for limited connectivity VLIWs in <ref> [2] </ref>. They report results for two of the seven loops tested, which, for three functional units, each with a dedicated register bank show degradation in performance of 57% and 69% over code obtained with three functional units and a single register bank. <p> However, on architectures with high degrees of ILP, it is often inconvenient or impossible to have a single register bank associated with all functional units. Such a single register bank would require too many read/write ports to be practical <ref> [2] </ref>. Consider an architecture with a rather modest ILP level of six. This means that we wish to initiate up to six operations each clock cycle. <p> Since finding an optimal cut-set is NP-complete [10], we need to focus on heuristic solutions. To initially evaluate our framework, we chose a graph partitioning algorithm by Lee, Park and Kim [12] to find the components in our graph. This algorithm is mentioned by Capitanio et al. <ref> [2] </ref> and is not specific to our register partitioning problem. The Lee, Park, Kim (LPK) algorithm finds a heuristic solution to the uniform k-way partitioning problem. <p> The machine model chosen included 3 general-purpose functional units, each with its own register bank. This 3-wide partitioning was chosen in part to compare our results with those presented in <ref> [2] </ref>. In our machine model, we assumed that all integer computations within a functional unit required 1 cycle, while all floating point computation within a functional unit required 2 cycles. <p> The table lists both the number of instructions and number of execution cycles as normalized values. Comparing our work with that of Capitanio, et al. <ref> [2] </ref> is not straightforward since their algorithm is applied to only single block loops and ours is applied to whole programs. Further they assume that each operation can complete in one cycle, including inter-bank copies. Thus, our model penalizes such copies more than Capitanio's does. <p> At the heart of this framework is a heuristic-based approach to partitioning the register component graph for each function. The performance of our register graph partitioning compares favorably to another study of partitioning for a similar model <ref> [2] </ref>. In addition, the flexibility of our register component graph allows us to easily represent, and generate code for, partitioned register banks with idiosyncrasies that often appear in special-purpose architectures such as DSP chips. <p> Preliminary results, while giving low increases in copy instructions, suggest the opportunity for further improvements in the register graph partitioning technique to increase parallelism. These opportunities will be fully investigated in future work. Given the significant degradation in performance that this and other register partitioning techniques <ref> [2] </ref> have shown when compared to an ideal model with a single register bank, one might think that an interconnection network between the functional units and the register banks (thereby allowing full access to each register for each functional unit) as in the case of TTAs is a better approach.
Reference: [3] <author> A. Capitanio, N. Dutt, and A. Nicolau. </author> <title> Toward register allocation for multiple register file vliw architectures. </title> <type> Technical Report TR94-6, </type> <institution> Computer Science Department, University of California at Irvine, </institution> <address> Irvine, CA, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Additionally, chip space is limited and allocating space to an interconnection network may be neither feasible nor cost effective. Capitanio, et al. <ref> [3] </ref> present a different algorithm for assigning registers to banks based upon an interconnection network like that proposed by Janssen and Corporaal. They call their method hypergraph coloring. In their model, graph nodes, which represent registers, are connected by hyperedges, edges that can connect more than two nodes.
Reference: [4] <author> G. J. Chaitin. </author> <title> Register allocation and spilling via graph coloring. </title> <journal> SIGPLAN Notices, </journal> <volume> 17(6):98105, </volume> <month> June </month> <year> 1982. </year> <booktitle> Proceedings of the ACM SIGPLAN '82 Symposium on Compiler Construction. </booktitle>
Reference-contexts: Thus, comparisons are difficult. 3. Register Assignment with Partitioned Regis ter Banks A good deal of work has investigated how registers should be assigned when a machine has a single register bank of equivalent registers <ref> [4, 5, 1] </ref>. However, on architectures with high degrees of ILP, it is often inconvenient or impossible to have a single register bank associated with all functional units. Such a single register bank would require too many read/write ports to be practical [2]. <p> Needless to say, this complicates matters. By pre-coloring <ref> [4] </ref> both the register bank choice and the register number choice within each bank, however, it can be accommodated within our register component graph framework. 3.2.
Reference: [5] <author> F. C. Chow and J. L. Hennessy. </author> <title> Register allocation by priority-based coloring. </title> <journal> SIGPLAN Notices, </journal> <volume> 19(6):222232, </volume> <month> June </month> <year> 1984. </year> <booktitle> Proceedings of the ACM SIGPLAN '84 Symposium on Compiler Construction. </booktitle>
Reference-contexts: Thus, comparisons are difficult. 3. Register Assignment with Partitioned Regis ter Banks A good deal of work has investigated how registers should be assigned when a machine has a single register bank of equivalent registers <ref> [4, 5, 1] </ref>. However, on architectures with high degrees of ILP, it is often inconvenient or impossible to have a single register bank associated with all functional units. Such a single register bank would require too many read/write ports to be practical [2].
Reference: [6] <author> J. Ellis. </author> <title> A Compiler for VLIW Architectures. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <year> 1984. </year>
Reference-contexts: We call this technique register component graph partitioning, since the nodes of the graph represent virtual registers appearing in the program's intermediate code. 2. Previous Work Ellis described the first solution to the problem of generating code for partitioned register banks in his thesis <ref> [6] </ref>. His method, called BUG (bottom-up greedy), is applied to a scheduling context at a time (e.g., a trace). His method is intimately intertwined with instruction scheduling and utilizes machine-dependent details within the partitioning algorithm.
Reference: [7] <author> K. Farkas, P. Chow, N. Jouppi, and Z. Vranesic. </author> <title> A muliclus-ter architecture: Reducing cycle time through partitioning. </title> <booktitle> In Proceedings of the 30th International Symposium on Mi-croarchitecture (MICRO-30), </booktitle> <pages> pages 149159, </pages> <address> Research Triangle Park, NC, </address> <month> December </month> <year> 1997. </year>
Reference: [8] <author> J. Fisher, P. Faraboschi, and G. Desoli. </author> <title> Custom-fit processors: </title> <booktitle> Letting applications define architecures. In Twenty-Ninth Annual Symposium on Micorarchitecture (MICRO-29), </booktitle> <pages> pages 324335, </pages> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: Unfortunately, large amounts of ILP hardware and aggressive instruction scheduling techniques put large demands on a machine's register resources. With these demands, it becomes difficult to maintain a single monolithic register bank. The number of ports required for such a register bank severely hampers access time <ref> [2, 8] </ref>. Partitioned register banks are one mechanism for providing high degrees of ILP with a high clock rate (Texas Instruments already produces several DSP chips that have partitioned register banks to support high ILP [14].) Unfortunately, partitioned register banks may inhibit achieved ILP.
Reference: [9] <author> S. Freudenberger. </author> <title> Private communication. </title>
Reference-contexts: They report results that show significantly less degradation than either the partitioning scheme of Capitanio et al. or our preliminary results. However, their interconnection network actually represents a different architectural paradigm making comparisons less meaningful. Indeed it is surmised <ref> [9] </ref> that their interconnection network would likely degrade processor cycle time significantly, making this architectural paradigm infeasible for hardware supporting the high levels of ILP where maintaining a single register bank is impractical.
Reference: [10] <author> M. Garey and D. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. W.H. </title> <publisher> Freeman and Company, </publisher> <address> San Francisco, CA, </address> <year> 1979. </year>
Reference-contexts: Cut-Set Heuristics Given the register component graph described above, in general we need to find a minimal cost cut-set. Since finding an optimal cut-set is NP-complete <ref> [10] </ref>, we need to focus on heuristic solutions. To initially evaluate our framework, we chose a graph partitioning algorithm by Lee, Park and Kim [12] to find the components in our graph. This algorithm is mentioned by Capitanio et al. [2] and is not specific to our register partitioning problem.
Reference: [11] <author> J. Janssen and H. Corporaal. </author> <title> Partitioned register files for TTAs. </title> <booktitle> In Twenty-Eighth Annual Symposium on Micorarchi-tecture (MICRO-28), </booktitle> <pages> pages 301312, </pages> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: Janssen and Corporaal propose an architecture called a Transport Triggered Architecture (TTA) that has an interconnection network between functional units and register banks so that each functional unit can access each register bank <ref> [11] </ref>. They report results that show significantly less degradation than either the partitioning scheme of Capitanio et al. or our preliminary results. However, their interconnection network actually represents a different architectural paradigm making comparisons less meaningful.
Reference: [12] <author> C. Lee, C. Park, and M. Kim. </author> <title> An efficient algorithm for graph partitioning using a problem transformation method. </title> <booktitle> In Computer-Aided Design, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: An optimal schedule for this code fragment, assuming a single multi-ported register bank is shown in Figure 1. It requires 7 cycles to complete. If we run the partitioning algorithm of Lee, et al. <ref> [12] </ref>, on the above graph for k = 2, one potential partitioning (given the appropriate edge and node weights) is the following: P 1 : fr1; r2; r4; r5; r6g Graph P 2 : fr3; r7; r8; r9; r10g Given the unit latency assumption we can generate the schedule in Figure <p> Since finding an optimal cut-set is NP-complete [10], we need to focus on heuristic solutions. To initially evaluate our framework, we chose a graph partitioning algorithm by Lee, Park and Kim <ref> [12] </ref> to find the components in our graph. This algorithm is mentioned by Capitanio et al. [2] and is not specific to our register partitioning problem. The Lee, Park, Kim (LPK) algorithm finds a heuristic solution to the uniform k-way partitioning problem.
Reference: [13] <author> P. H. Sweany and S. J. Beaty. </author> <title> Overview of the Rocket re-targetable C compiler. </title> <type> Technical Report CS-94-01, </type> <institution> Department of Computer Science, Michigan Technological University, Houghton, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: The weight for each register component graph node, GN, is the sum of the frequency value, F , for each operation in which GN appears as a destination. 4. Experimental Evaluation We have implemented the above algorithm in Rocket, a retargetable optimizing compiler for C and Fortran <ref> [13] </ref>. Our preliminary results are summarized in Table 1 which lists the results we obtained by applying the LPK algorithm to the register component graphs built for each benchmark. The machine model chosen included 3 general-purpose functional units, each with its own register bank.
Reference: [14] <institution> Texas Instruments. </institution> <note> Details on Signal Processing, issue 47 edition, </note> <month> March </month> <year> 1997. </year>
Reference-contexts: The number of ports required for such a register bank severely hampers access time [2, 8]. Partitioned register banks are one mechanism for providing high degrees of ILP with a high clock rate (Texas Instruments already produces several DSP chips that have partitioned register banks to support high ILP <ref> [14] </ref>.) Unfortunately, partitioned register banks may inhibit achieved ILP. <p> An alternative to the single register bank for an architecture is to have a distinct set of registers associated with each functional unit (or cluster of functional units). Examples of such architectures include the Multiflow Trace and several chips manufactured by Texas Instruments for digital signal processing <ref> [14] </ref>. Operations performed in any functional unit would require registers with the proper associated register bank. Copying a value from one register bank to another could be expensive.
References-found: 14

