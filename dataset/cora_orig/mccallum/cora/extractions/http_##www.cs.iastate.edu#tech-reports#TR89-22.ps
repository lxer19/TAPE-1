URL: http://www.cs.iastate.edu/tech-reports/TR89-22.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: 
Title: A Distributed Search Program for the 3x 1 Problem  
Author: TR - Gary T. Leavens 
Address: 226 Atanasoff Ames, IA 50011  
Affiliation: Iowa State University of Science and Technology Department of Computer Science  
Date: November, 1989  
Abstract-found: 0
Intro-found: 1
Reference: [Day87] <author> Mark S. Day. </author> <title> Replication and Reconfiguration in a Distributed Mail Repository. </title> <type> Technical Report MIT/LCS/TR-376, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: Unfortunately, not putting handlers that the search guardians need in the catalog means that search system is not easily reconfigured. This is not serious, since ease of reconfiguration is not a major requirement. However, one can do guardian replacement as in Mark Day's thesis <ref> [Day87] </ref>, even though the coordinator's report handlers are not in the catalog. This is done as follows. It is easy to replace the search guardians using Day's scheme.
Reference: [Hay84] <author> B. Hayes. </author> <title> Computer Recreations: On the Ups and Downs of Hailstone Numbers. </title> <journal> Scientific American, </journal> <volume> 250(1) </volume> <pages> 10-16, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: The alternative formulation of the function T , does not map odd integers n to (3n + 1)=2, but rather to 3n + 1 H (n) = 3n + 1; if n 1 (mod 2), (1:2) The function H is modeled after the so-called hailstone algorithm <ref> [Hay84] </ref>. Since the article by Hayes was how I originally encountered the problem, the iterates of H figured prominently in the first searches. One defines the iterates of H in the same way as T . <p> If k j is even, then H (j+1) (n) = k j =2 = T (i+1) (n). There are graphs in the article by Hayes that show the wildly erratic and unpredicatable behavior of the iterates of H <ref> [Hay84] </ref>. The behavior of T is, of course, similarly wild and unpredictable. 6 1.2 Derived Measures The computer program described in this report was designed to find peaks in certain measures derived from the iterates of the functions T and H.
Reference: [HS86] <author> W. Daniel Hillis and Guy L. Steele Jr. </author> <title> Data Parallel Algorithms. </title> <journal> Communications of the ACM, </journal> <volume> 29(12) </volume> <pages> 1170-1183, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: would be to have each processor check a single number rather than an interval, have each processor that found a peak record that peak, and then have each processor work on the next number as determined by adding the number of processors 1 to the number it worked on before <ref> [HS86] </ref>. This algorithm would be difficult to manage if the processors could not move in lock step.
Reference: [Lag85] <author> J. C. Lagarias. </author> <title> The 3x+1 Problem and its Generalizations. </title> <journal> The American Mathematical Monthly, </journal> <volume> 92(1) </volume> <pages> 3-23, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: a brief history of the search. 1.1 The 3x + 1 Problem The 3x + 1 problem concerns iterates of the following function: T (n) = (3n + 1)=2; if n 1 (mod 2), (1:1) which takes odd integers n to (3n + 1)=2 and even integers n to n=2 <ref> [Lag85, Page 4] </ref>. "The 3x + 1 Conjecture asserts that, starting from any positive integer n, repeated iteration of this function eventually produces the value 1" [Lag85, Page 3]. This conjecture, as Lagarias states, is apparently intractable. <p> (3n + 1)=2; if n 1 (mod 2), (1:1) which takes odd integers n to (3n + 1)=2 and even integers n to n=2 [Lag85, Page 4]. "The 3x + 1 Conjecture asserts that, starting from any positive integer n, repeated iteration of this function eventually produces the value 1" <ref> [Lag85, Page 3] </ref>. This conjecture, as Lagarias states, is apparently intractable. The program discussed in this report is not concerned with validating or disproving the 3x + 1 conjecture. Instead, the program is designed to investigate certain measures related to the iterates of T (and the function H described below). <p> These numbers are called peaks because if one graphs the positive integers 1 This definition differs from Lagarias's in the treatment of the number one. In Lagarias's paper <ref> [Lag85] </ref>, (1) = 1, but in the above definition (1) = 0. 2 Again, this definition differs from Lagarias's for the number one, since in Lagarias's paper 1 (1) = 2 but in the above definition 1 (1) = 0. 3 This definition also differs slightly from Lagarias's, since by my <p> The idea of the following lemmas was brought to my attention by Mike Vermeulen. It is related to the Collatz graph discussed in <ref> [Lag85] </ref>. Lemma 3.1.9. Let j and k be given so that 0 &lt; j &lt; k. If there is some m &gt; 0 such that H (m) (j) = k, then k cannot be a peak in steps or max value.
Reference: [Lam81] <author> B. W. Lampson. </author> <title> Atomic Transactions. </title> <booktitle> In Distributed Systems-Architecture and Implementation, volume 105 of Lecture Notes in Computer Science, </booktitle> <pages> pages 246-265. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1981. </year> <title> This is a revised version of Lampson and Sturgis's unpublished Crash Recovery in a Distributed Data Storage System. </title>
Reference-contexts: Information recorded on stable storage survives (with high probability) the crash of a computer and any guardians running on it. However, stable storage is more expensive than volatile storage, since duplicate copies of information are necessary to ensure that it survives crashes <ref> [Lam81] </ref>. It is therefore important to decide what information will be kept in stable storage, and what will be kept in volatile storage. Since the coordinator's purpose is to do bookkeeping, most of its information must be kept in stable storage. This includes the following essential information. 1.
Reference: [LDH + 87] <author> Barbara Liskov, Mark Day, Maurice Herlihy, Paul Johnson, Gary Leavens, Robert Scheifler, and William Weihl. </author> <title> Argus Reference Manual. </title> <type> Technical Report 400, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> October </month> <year> 1987. </year> <note> An earlier version appeared as Programming Methodology Group Memo 54 in March 1987. </note>
Reference-contexts: Introduction The distributed system described in this report was designed to do some experimental mathematics and to allow some simple experimentation with the Argus distributed programming language and system [LS83] <ref> [LDH + 87] </ref>. The system as finally implemented ran on six (and sometimes more) computers over several years, with all the computers cooperating in the search for certain numbers. The numbers themselves are related to the 3x + 1 problem.
Reference: [Lea86] <author> Gary T. Leavens. </author> <title> Using a Guardian to Make Progress in a Long Computation: The Search for Hailstone Peaks. DSG Note 142, </title> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> May </month> <year> 1986. </year>
Reference-contexts: This allows one a greater probability of making progress in a long computation. (DSG note 142 discusses this point in more detail <ref> [Lea86] </ref>.) Thus the next number to be searched and any (candidate) peaks found are kept on stable storage. In addition, a search guardian also keeps information about earlier peaks in stable storage, both for detecting when it has found a new peak and for algorithmic efficiency (see below). <p> It was ended when it reached 100,085,608,537, over a year later. The initial version of the program is described in an internal note at MIT <ref> [Lea86] </ref>.
Reference: [Lea87] <author> Gary T. Leavens. </author> <title> The Hailstone System. DSG Note 148, </title> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: DEC VAX 750 prj,pm-prj DEC micro-vax II electron DEC micro-vax II graviton DEC micro-vax II proton DEC micro-vax II neutron DEC micro-vax II positron DEC micro-vax II photon DEC micro-vax II muon DEC micro-vax II kaon DEC VAX 3200 meson DEC VAX 3200 was described in a similar internal note <ref> [Lea87] </ref>, which has been updated in the main body of this report. 8 May 1986 77,671 First guardian written. The search started using only rinso. 15 May 1986 3,272,371 Started using 2 machines. Rinso and prj. 20 May 1986 8,210,229 Rinso catches up to prj by reaching 5,004,427.
Reference: [LS83] <author> Barbara Liskov and Robert Scheifler. </author> <title> Guardians and Actions: Linguistic Support for Robust, Distributed Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 381-404, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: Introduction The distributed system described in this report was designed to do some experimental mathematics and to allow some simple experimentation with the Argus distributed programming language and system <ref> [LS83] </ref> [LDH + 87]. The system as finally implemented ran on six (and sometimes more) computers over several years, with all the computers cooperating in the search for certain numbers. The numbers themselves are related to the 3x + 1 problem. <p> This is especially true in Argus, where the computers are connected over a network and communication among computers takes several orders of magnitude more time than the time for checking an individual number <ref> [LS83] </ref>. Thus the program is designed to give each computer an interval of numbers instead of a single number. Each computer checks all the numbers in the interval given to it. <p> Finally, a search guardian keeps two handler objects that are its connection to the coordinator on stable storage. In Argus, information that is kept on stable storage must be stored in atomic data containers <ref> [LS83] </ref> that support synchronization and consistency in the face of parallel processing and machine crashes. However, atomic data containers, such as atomic arrays, are less efficient than non-atomic data containers, as there is some overhead for locking, etc.
Reference: [Ver86a] <author> Mike Vermeulen, </author> <month> December </month> <year> 1986. </year> <title> Private communication. In this mail message Mike states and proves the theorem that if n mod 6 = 5, then n cannot be a peak in steps or values. </title>
Reference-contexts: Indeed the iterates of H first multiply (2k 1)=3 by 3 and add 1, obtaining 2k, and then divide 2k by 2 obtaining k. This result, due to Mike Vermeulen <ref> [Ver86a] </ref>, is proved in the following lemma. 21 Lemma 3.1.11. Let k &gt; 0. If k mod 6 = 5, then T ((2k 1=3)) = k and H (2) ((2k 1)=3) = k. Proof: Suppose k &gt; 0 and k mod 6 = 5.
Reference: [Ver86b] <author> Mike Vermeulen, </author> <month> January </month> <year> 1986. </year> <title> Private communication. In this mail message Mike explains his composite polynomials, including a C program that generates them. </title> <type> 48 </type>
Reference-contexts: For each n, the m bit Vermeulen polynomial for n will be written Vpoly m (n). To explain how these polynomials are generated, consider the following examples, adapted from a mail message <ref> [Ver86b] </ref>. Items to the right of the dot (.) in last bits do not affect the other bits, and items to the left of the dot do. The following is the generation of an 8 bit Vermeulen polynomial, Vpoly 8 (3). <p> However, even if composite polynomials are not used in the iteration algorithm, they can be used to generate a priori cutoffs. 3.2.3 A Priori Cutoffs based on Composite Polynomials Composite polynomials lead to new strategies for cutoffs <ref> [Ver86b] </ref>. 27 Steps Mike Vermeulen cuts off the search for peaks in steps a priori as follows. Lemma 3.2.1. Let m &gt; 0 be given. Let 0 &lt; r 1 &lt; r 2 &lt; 2 m , Vpoly m (r 1 ) = Vpoly (r 2 ).
References-found: 11

