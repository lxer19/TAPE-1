URL: http://http.cs.berkeley.edu/~fateman/papers/extrat.ps
Refering-URL: http://http.cs.berkeley.edu/~fateman/algebra.html
Root-URL: 
Title: Computation with the Extended Rational Numbers and an Application to Interval Arithmetic  
Author: Richard J. Fateman and Tak W. Yan 
Affiliation: Computer Science Division, EECS Dep't University of California at Berkeley  Computer Science Department Stanford University  
Abstract: Programming languages such as Common Lisp, and virtually every computer algebra system (CAS), support exact arbitrary-precision integer arithmetic as well as exact rational number computation. Several CAS include interval arithmetic directly, but not in the extended form indicated here. We explain why changes to the usual rational number system to include infinity and "not-a-number" may be useful, especially to support robust interval computation. We describe techniques for implementing these changes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Apple Computer Inc. </institution> <note> Apple Numerics Manual, </note> <editor> 2nd ed. </editor> <publisher> Addison Wesley Publ. </publisher> <year> 1988. </year>
Reference-contexts: Nevertheless, exactness for performing arithmetic intervals should continue to be of use in strict error bound calculations. 8 Acknowledgments Thanks to especially to W. Kahan for numerous discussions. J. Coonen supplied reference material on Apple's SANE <ref> [1] </ref> standard, as well as general and comments. Guy Steele, Jr. and Steven Haflich, members of the Common Lisp standardization committee have also been helpful.
Reference: [2] <author> IEEE Computer Society Microprocessor Standards Committee Task P754, </author> <title> a standard for binary floating-point arithmetic, (see, for example, draft 8.0, </title> <booktitle> Computer 14, </booktitle> <month> 3 Mar. </month> <year> 1981, </year> <pages> 52-63) </pages>
Reference-contexts: The tables below give the addition, multiplication, negation, and reciprocation for this model. Note that +0 = 0 arithmetically, but division by them always produces unequal results. Other ways of distinguishing them (e.g. by copysign <ref> [2] </ref>) should be provided. We choose to define the result of (+0)+(0) to be +0. This is not always the correct choice, but the complications that would ensue by allowing yet a third zero (unsigned 0) are unappealing.
Reference: [3] <author> W. Kahan. </author> <title> A More Complete Interval Arithmetic. Unpublished lecture notes for a summer course at the Univ. </title> <institution> of Michigan, </institution> <address> Ann Arbor, </address> <year> 1968., </year>
Reference-contexts: The disadvantage of these extensions is that some well-known theorems which apply to the field of rational numbers fail to hold with respect to 0/0 and 1/0. The extent to which these violations constitute hazards is fairly limited <ref> [3] </ref>. There are two exceptional circumstances in cancellation: If (a x)=(b x) 6= a=b then (a x)=(b x) is 0=0. If (a x) (b x) 6= a b then (a x) (b x) is 0=0. <p> In Lisp, the logical existing mechanism to use is is analogous to catch and throw, implemented through the error system. An example of such a technique is given in Appendix I. 5 Interval Arithmetic A useful application of extended rational numbers is in interval arithmetic <ref> [3] </ref>, [11], [8], [7], [10]. The model for interval arithmetic we use comprises both projective and affine real models: the projective model is implemented for intervals themselves, although an affine model is used for the endpoints. Let r, s, p, and q denote any extended affine rational numbers. <p> Let r, s, p, and q denote any extended affine rational numbers. If r &lt; s, then [r,s] is the interior interval fx 2 R : r x sg and [s,r] is the exterior interval fx 2 R : x r or s xg. In accordance with Kahan's suggestions <ref> [3] </ref>, allowances can be made for intervals which, if an endpoint is 0 or 1=0 indicate whether or not to exclude that endpoint by a sign. The complications of having open/closed endpoints at arbitrary points seems not worth the bother, however.
Reference: [4] <author> W. Kahan. </author> <title> What Numbers?, class notes for course Math 128A, </title> <booktitle> Fall, </booktitle> <year> 1992, </year> <institution> Univ. of Calif. Berkeley. </institution>
Reference-contexts: Some thought has to be given to the ways in which a user might change at run-time form one model to the other, or to mix them <ref> [4] </ref>. <p> From the numeric computation perspective it tends to be more conservative in the sense of giving 0/0 (not-a-number) in more circumstances than the affine mode. Kahan <ref> [4] </ref> provides more discussion on this topic. The table of operations below is more specific on this point. In the projective model, the object 1/0 is an analog to the IEEE 754 floating-point standard's infinity. <p> Although 1 = 1 is true, every other case of y = z is false if y or z is 1 or NaN; and NaN 6= NaN. (This description is largely quoted from Kahan <ref> [4] </ref>, which also provides further discussion.) For the binary operations + and *, we give tables for the logical cross-product, where 0 = 0=1, 1=0 is real infinity, and x and y are "normal" non-zero members of the rational field. + 0 1=0 0=0 x 1=0 1=0 0=0 0=0 1=0 y <p> Other ways of distinguishing them (e.g. by copysign [2]) should be provided. We choose to define the result of (+0)+(0) to be +0. This is not always the correct choice, but the complications that would ensue by allowing yet a third zero (unsigned 0) are unappealing. Kahan <ref> [4] </ref> provides the following rules for the affine extension: 0 = +0 arithmetically, although they can be distinguished in other ways. The sign of a product or quotient is "+" if the operands have the same sign, "" otherwise, regardless of the operands being finite, zero, or infinite.
Reference: [5] <author> W. Kahan. </author> <title> Presubstitution and Continued Fractions, </title> <institution> EECS Dep't, Univ. of Calif. Berkeley unpublished, </institution> <year> 1987. </year> <title> See also, Rational Arithmetic in Floating-Point, </title> <institution> PAM-343, Ctr Pure and Appl. Math. Univ. of Calif, Berkeley, </institution> <year> 1986. </year>
Reference-contexts: raise a flag or, at a user option, execute additional code, but the computation should normally proceed.) A simple example of this situation is the computation of a + b=(c + 1=d) which is defined for d = 0 as a even though a division by zero has occurred (see <ref> [5] </ref> for more on this topic). We describe two systems that in effect retain a small but useful amount of information to indicate how we departed 1 from the rational domain. One system allows us to compute with two additional "extended rational numbers" 0/0 and 1/0.
Reference: [6] <author> W. Kahan. </author> <title> Branch Cuts for Complex Elementary Functions. in The State of the Art of Numerical Analysis, </title> <editor> A. Iserles and M. J. D. Powell (eds.) </editor> <publisher> Oxford Univ. Press, </publisher> <year> 1987. </year>
Reference-contexts: Consequently we are forced to have two zeroes: positive 0 (represented by 0/1) and negative (0) (represented by 0/-1). Among other reasons for preferring it, this model is more suited to transcendental functions <ref> [6] </ref> allowing one to describe branch cuts more specifically. The tables below give the addition, multiplication, negation, and reciprocation for this model. Note that +0 = 0 arithmetically, but division by them always produces unequal results. Other ways of distinguishing them (e.g. by copysign [2]) should be provided.
Reference: [7] <author> Ramon E. Moore. </author> <title> Methods and Applications of Interval Analysis. </title> <note> SIAM studies in applied mathematics, 1979 also, Reliability in computing: the role of interval methods in scientific computing,Academic Press, </note> <year> 1988. </year>
Reference-contexts: In Lisp, the logical existing mechanism to use is is analogous to catch and throw, implemented through the error system. An example of such a technique is given in Appendix I. 5 Interval Arithmetic A useful application of extended rational numbers is in interval arithmetic [3], [11], [8], <ref> [7] </ref>, [10]. The model for interval arithmetic we use comprises both projective and affine real models: the projective model is implemented for intervals themselves, although an affine model is used for the endpoints. Let r, s, p, and q denote any extended affine rational numbers.
Reference: [8] <editor> K. Nickel (ed). </editor> <booktitle> Interval Mathematics 1985, Proceedings of the Int'l Symp. </booktitle> <address> Freiburg i. Br., FRG, </address> <month> September, </month> <year> 1985, </year> <note> Lect. NOtes in Comp. </note> <institution> Sci, </institution> <address> 212, </address> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: In Lisp, the logical existing mechanism to use is is analogous to catch and throw, implemented through the error system. An example of such a technique is given in Appendix I. 5 Interval Arithmetic A useful application of extended rational numbers is in interval arithmetic [3], [11], <ref> [8] </ref>, [7], [10]. The model for interval arithmetic we use comprises both projective and affine real models: the projective model is implemented for intervals themselves, although an affine model is used for the endpoints. Let r, s, p, and q denote any extended affine rational numbers.
Reference: [9] <author> Guy L. Steele, Jr. </author> <title> Common Lisp the Language, 2nd ed., </title> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference-contexts: The construction of these programs depends on the availability of arbitrary-precision integer arithmetic. In an attempt to head off yet more duplicative programming and the introduction of incompatible names for such operations, the standard for Common Lisp <ref> [9] </ref> has established data types and names for operations for exact rational numbers. However, not all the details have been specified, and the loose ends may be tied up in several ways. There are two rationales for extending the rational numbers, aesthetic and utilitarian. <p> They could be used to augment any Common Lisp <ref> [9] </ref> standard system to provide computation over the extended rational numbers or this projective model of (interior and exterior interval arithmetic with affine rational or IEEE floating-point endpoints.) Unfortunately, as general and extensible as is the Common Lisp design, adding new "numeric" types cannot be done entirely smoothly | the user
Reference: [10] <author> Ulrich W. Kulisch, Willard L. Miranker. </author> <title> Computer Arithmetic in Theory and Practice, </title> <publisher> Academic Press, </publisher> <year> 1981. </year>
Reference-contexts: In Lisp, the logical existing mechanism to use is is analogous to catch and throw, implemented through the error system. An example of such a technique is given in Appendix I. 5 Interval Arithmetic A useful application of extended rational numbers is in interval arithmetic [3], [11], [8], [7], <ref> [10] </ref>. The model for interval arithmetic we use comprises both projective and affine real models: the projective model is implemented for intervals themselves, although an affine model is used for the endpoints. Let r, s, p, and q denote any extended affine rational numbers.
Reference: [11] <author> Jean Vuillemin, </author> <title> Exact Real Computer Arithmetic with Continued Fractions. </title> <journal> IEEE Trans. on Cmptrs. </journal> <volume> 39 1990, </volume> <pages> 1087-1105. </pages>
Reference-contexts: In Lisp, the logical existing mechanism to use is is analogous to catch and throw, implemented through the error system. An example of such a technique is given in Appendix I. 5 Interval Arithmetic A useful application of extended rational numbers is in interval arithmetic [3], <ref> [11] </ref>, [8], [7], [10]. The model for interval arithmetic we use comprises both projective and affine real models: the projective model is implemented for intervals themselves, although an affine model is used for the endpoints. Let r, s, p, and q denote any extended affine rational numbers.
Reference: [12] <author> S. Wolfram. </author> <title> Mathematica|A System for Doing Mathematics, 2nd edition, </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year> <month> 5 </month>
Reference-contexts: It is rather easy to do this sloppily and somewhat miss the point of interval arithmetic, as was done in the first version of Mathematica <ref> [12] </ref>. Nevertheless, exactness for performing arithmetic intervals should continue to be of use in strict error bound calculations. 8 Acknowledgments Thanks to especially to W. Kahan for numerous discussions. J. Coonen supplied reference material on Apple's SANE [1] standard, as well as general and comments.
References-found: 12

