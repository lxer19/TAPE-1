URL: http://www.cs.mu.oz.au/tr_db/mu_96_07.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: (lee@cs.mu.OZ.AU, http://www.cs.mu.oz.au/~lee)  
Title: A declarative view of modes  
Author: Lee Naish 
Address: Parkville, Victoria 3052 Australia  
Affiliation: Department of Computer Science University of Melbourne  
Pubnum: Technical Report 96/7  
Abstract: Mode information in logic programming is concerned with such things as inputs and outputs of procedures, producers and consumers of variable bindings, instantiation states of calls during execution and the order of execution. Modes seem inextricably tied to the procedural rather than the declarative view of logic programs. Despite this, we argue that purely declarative information can actually express the essence of modes remarkable well. The declarative view allows a high level notion of correctness which is independent of how the information is used. We start from a framework which includes types and show how a set of ground atoms related to the success set can be used to express mode information. We introduce constrained regular trees to define such sets and show how they can be used as the basis for a polymorphic mode system. The mode system can express directional types, back communication and linearity and can be used to infer lower level mode information for languages such as Mercury. Keywords: logic programming, modes, types, constrained regular trees, linearity, set constraints, multisets 
Abstract-found: 1
Intro-found: 1
Reference: [Aik94] <author> Alexander Aiken. </author> <title> Set constraints: Results, applications and future directions. </title> <booktitle> In Proceedings of the 1994 Conference on Principles and Practice of Constraint Programming, </booktitle> <pages> pages 171-179, </pages> <year> 1994. </year>
Reference-contexts: Although constrained regular trees are significantly more powerful than other formalisms which have been developed <ref> [Aik94] </ref>, there are a couple of promising indications. The first is that the treatment of polymorphism in functional language type checking and inference appears to make such analysis equivalent to a reasonably rich constraint language for constrained regular trees. The second is Ueda's mode inference algorithm for GHC [Ued95].
Reference: [BBP + 82] <author> D.L. Bowen, Lawrence Byrd, Fernando C.N. Pereira, Luis M. Pereira, and David H.D. Warren. </author> <title> DECsystem-10 prolog user's manual. </title> <type> Occasional Paper 27, </type> <institution> Department of Artificial Intelligence, University of Edinburgh, </institution> <address> Scotland, </address> <month> Novem-ber </month> <year> 1982. </year>
Reference-contexts: The primary focus of this paper is modes, though we rely on a framework which includes types. Modes seem to be inherently linked to the procedural view of logic programming. Perhaps the first formal use of descriptive modes was in DEC-10 Prolog <ref> [BBP + 82] </ref>, which allowed programmers to declare that certain arguments would always be free or always be instantiated when a procedure was called. This information relied on the left to right execution order and was used by the compiler for optimisation.
Reference: [BLR92] <author> F. Bronsard, T. K. Lakshman, and U. S. Reddy. </author> <title> A framework of directionality for proving termination of logic programs. </title> <booktitle> In Proceedings of the Ninth Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 321-335, </pages> <year> 1992. </year>
Reference-contexts: This lower level instantiatedness information is supplied directly by declarations in systems such as NU-Prolog [TZ86] and is sometimes used for compiler optimisations. The mode declarations of Mercury [SHC95] specify the instantiation state of calls and solutions, like the mode dependencies of <ref> [BLR92] </ref>, and are used for reordering calls at compile time. This mode system is the most precise and consistent of all the prescriptive mode systems and along with determinism declarations it enables optimisations which make Mercury faster than any existing Prolog system.
Reference: [BM95] <author> J. Boye and J. Maluszynski. </author> <title> Two aspects of directional types. </title> <editor> In Leon Sterling, editor, </editor> <booktitle> Proceedings of the Twelfth International Conference on Logic Programming, </booktitle> <pages> pages 747-761, </pages> <address> Kanagawa, Japan, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: There are some lower level aspects of directional types which are not present in our view. Types generally include non-ground terms and proofs of well typedness are dependent on the execution order. We avoid non-ground terms partly by using more expressive languages for describing sets of ground terms. In <ref> [BM95] </ref> there is a distinction made between input-output correctness, which can be given a declarative interpretation, and call correctness, which depends on the execution order. The restrictive nature of call correctness results in interesting uses of logic variables being considered ill-typed even in programs which can execute left to right. <p> Our approach to modes is very close to input-output correctness and S-well-typing is also a sufficient condition for type correctness. However, since we avoid non-ground terms we are able to give a simple model theoretic declarative semantics rather than use the proof theoretic notions of <ref> [BM95] </ref>. 3.3 Safe calls We would expect a mode system to distinguish between different instantiation states of calls. For example, the call append (X,Y,[a,b]) may be considered safe in some sense whereas the less instantiated append (X,Y,Z) may not.
Reference: [CG86] <author> Keith L. Clark and Steve Gregory. </author> <title> PARLOG: parallel programming in logic. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(1) </volume> <pages> 1-49, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: IC-Prolog [CM79] introduced prescriptive modes to control the execution order and support coroutines. The high level ideas of producers and consumers, as used by IC-Prolog, and input and output arguments, as used by Parlog <ref> [CG86] </ref>, are implemented by suspending calls which are insufficiently instantiated at run time. This lower level instantiatedness information is supplied directly by declarations in systems such as NU-Prolog [TZ86] and is sometimes used for compiler optimisations.
Reference: [CM79] <author> K.L. Clark and F.G. McCabe. </author> <title> The control facilities of IC-prolog. </title> <editor> In Donald Michie, editor, </editor> <booktitle> Expert systems in the microelectronic age, </booktitle> <pages> pages 122-149. </pages> <publisher> Edin-burgh University Press, </publisher> <year> 1979. </year>
Reference-contexts: This information relied on the left to right execution order and was used by the compiler for optimisation. More expressive ways of describing modes are now used for optimising compilers [vRD90], parallelising code [WHD88] and analysing termination [BLR92][Nai93a]. IC-Prolog <ref> [CM79] </ref> introduced prescriptive modes to control the execution order and support coroutines. The high level ideas of producers and consumers, as used by IC-Prolog, and input and output arguments, as used by Parlog [CG86], are implemented by suspending calls which are insufficiently instantiated at run time.
Reference: [DH88] <author> Roland Dietrich and Frank Hagl. </author> <title> A polymorphic type system with subtypes for prolog. </title> <editor> In H. Ganzinger, editor, </editor> <booktitle> Proceedings of the Second European Symposium on Programming, </booktitle> <pages> pages 79-93, </pages> <address> Nancy, France, </address> <month> March </month> <year> 1988. </year> <note> published as Lecture Notes in Computer Science 300 by Springer-Verlag. </note>
Reference: [Nai92] <author> Lee Naish. </author> <title> Types and the intended meaning of logic programs. </title> <editor> In Frank Pfen ning, editor, </editor> <booktitle> Types in logic programming, </booktitle> <pages> pages 189-216. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1992. </year>
Reference-contexts: We then present an expressive polymorphic mode system which has a very simple declarative semantics. Finally, mode checking and inference are briefly discussed. 1 2 Background The need for types In this section we briefly summarise our views on types <ref> [Nai92] </ref>. Types are essential to logic programming because most logic programs do not contain sufficient information about the programmer's intended interpretation. For example, in the intended interpretation of append all arguments are lists whereas the normal definition can succeed with non-lists in the last two arguments.
Reference: [Nai93a] <author> Lee Naish. </author> <title> Coroutining and the construction of terminating logic programs. </title> <journal> Australian Computer Science Communications, </journal> <volume> 15(1) </volume> <pages> 181-190, </pages> <year> 1993. </year>
Reference-contexts: This implies the more instantiated mode append (i; i; i) since the set of calls which are known to be safe has the desirable property of being closed under instantiation <ref> [Nai93a] </ref>. If we use the more precise mode set M = fappend (X; Y; Z)jX 2 list ^ Y 2 list ( Z 2 listg then append ([a],X,[a,b]) is known to be safe and the mode set can be summarised by the mode append (o; o; i).
Reference: [Nai93b] <author> Lee Naish. </author> <title> Verification of logic programs and imperative programs. </title> <editor> In Jean Marie Jacquet, editor, </editor> <booktitle> Constructing logic programs, </booktitle> <pages> pages 143-164. </pages> <publisher> Wiley, </publisher> <address> Chich-ester, England, </address> <year> 1993. </year>
Reference-contexts: It has been observed that mode information can also make type checking more flexible, by allowing subtypes to be used [DH88][RNP92], for example. This is not just a coincidence. In <ref> [Nai93b] </ref> we investigated the reasoning behind the construction and verification of logic programs. There are two components to (partial) correctness: the clauses in S must be true in the intended interpretation and the program must be type correct.
Reference: [Red92] <author> Uday Reddy. </author> <title> A typed foundation for directional logic programs. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Illinous at Urbana-Champaign, Urbana, Illinous, </institution> <year> 1992. </year>
Reference-contexts: The propagation of this constraint ultimately results in the mode for the pushed elements being inferred as input. Without this constraint the modes of pushed and popped elements are just inferred as being complementary. In the type and mode scheme of Reddy based on linear logic <ref> [Red92] </ref> the base case which discards a non-empty stack forces the stack and its elements to be "persistent" and the exponential fragment of linear logic must be used in the types.
Reference: [RNP92] <author> Yann Rouzaud and Lan Nguyen-Phuong. </author> <title> Integrating modes and subtypes into a Prolog type-checker. </title> <booktitle> In Proceedings of the Ninth Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 85-97, </pages> <year> 1992. </year> <month> 12 </month>
Reference: [Sha83] <author> Ehud Y. Shapiro. </author> <title> A subset of Concurrent Prolog and its interpreter. </title> <institution> Research Report CS83-06, Department of Applied Mathematics, Weizmann Institute of Science, Rehovot, Israel, </institution> <year> 1983. </year>
Reference-contexts: We now give a slightly longer example: a simple version of the stack object originally used to illustrate back communication in Concurrent Prolog <ref> [Sha83] </ref>. The procedure stack accepts a list of push/1 and pop/1 "messages". The push messages add the argument of push to the stack and the pop messages remove an element and unify it with the argument of pop (typically a variable).
Reference: [SHC95] <author> Zoltan Somogyi, Fergus J. Henderson, and Thomas Conway. </author> <title> Mercury: an ef ficient purely declarative logic programming language. </title> <booktitle> In Proceedings of the Australian Computer Science Conference, </booktitle> <pages> pages 499-512, </pages> <address> Glenelg, Australia, </address> <month> February </month> <year> 1995. </year>
Reference-contexts: This lower level instantiatedness information is supplied directly by declarations in systems such as NU-Prolog [TZ86] and is sometimes used for compiler optimisations. The mode declarations of Mercury <ref> [SHC95] </ref> specify the instantiation state of calls and solutions, like the mode dependencies of [BLR92], and are used for reordering calls at compile time. <p> Our starting point is the standard way of defining regular sets of terms using a parametric "type" definition language (such as that used by Mercury <ref> [SHC95] </ref>, several other logic programming types systems and most functional programming languages) and the universal type any. For simplicity we do not distinguish between function and predicate symbols. Given a set of type definitions, a ground expression denotes a regular set of terms.
Reference: [TWM95] <author> David N Turner, Philip Wadler, and Christian Mossin. </author> <title> Once upon a type. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <address> San Diego, California, </address> <year> 1995. </year>
Reference-contexts: By using multiset inequalities other useful information can be expressed. It seems an interesting relationship exists between constrained regular trees using multiset inequalities and linear types in functional programming <ref> [TWM95] </ref> and linear logic in general 1 .
Reference: [TZ86] <author> James Thom and Justin Zobel. </author> <title> NU-Prolog reference manual, version 1.0. </title> <type> Tech nical Report 86/10, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <year> 1986. </year>
Reference-contexts: The high level ideas of producers and consumers, as used by IC-Prolog, and input and output arguments, as used by Parlog [CG86], are implemented by suspending calls which are insufficiently instantiated at run time. This lower level instantiatedness information is supplied directly by declarations in systems such as NU-Prolog <ref> [TZ86] </ref> and is sometimes used for compiler optimisations. The mode declarations of Mercury [SHC95] specify the instantiation state of calls and solutions, like the mode dependencies of [BLR92], and are used for reordering calls at compile time.
Reference: [Ued95] <author> K. Ueda. </author> <title> I/O mode analysis in concurrent logic programming. </title> <editor> In T. Ito and Yonezawa, editors, </editor> <booktitle> Theory and practice of parallel programming, number 907 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: It would then be possible to push variables and get them instantiated by popping non-variables or use the code in any other way such that the modes of the pushed elements and the popped elements are complementary. In the mode system developed for flat GHC <ref> [Ued95] </ref>, the base case of (the GHC version of) stack1 imposes an input constraint on the stack and its elements. The propagation of this constraint ultimately results in the mode for the pushed elements being inferred as input. <p> The first is that the treatment of polymorphism in functional language type checking and inference appears to make such analysis equivalent to a reasonably rich constraint language for constrained regular trees. The second is Ueda's mode inference algorithm for GHC <ref> [Ued95] </ref>. This can be seen as using constrained regular trees with multiset equalities as constraints. 9 Conclusion All programming languages, by their nature, have a procedural interpretation. A great advantage of logic programming is that a simpler declarative interpretation is also possible.
Reference: [vRD90] <author> P. van Roy and A.M. Despain. </author> <title> The benefits of global flow analysis for an optimiz ing prolog compiler. </title> <booktitle> In Proceedings of the Second North American Conference on Logic Programming, </booktitle> <address> Austin, Texas, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: This information relied on the left to right execution order and was used by the compiler for optimisation. More expressive ways of describing modes are now used for optimising compilers <ref> [vRD90] </ref>, parallelising code [WHD88] and analysing termination [BLR92][Nai93a]. IC-Prolog [CM79] introduced prescriptive modes to control the execution order and support coroutines.
Reference: [Wad89] <author> Philip Wadler. </author> <title> Theorems for free! In Functional Programming and Computer Architecture, </title> <month> Sept 89. </month>
Reference-contexts: A first order functional program can be translated into a moded logic program and the polymorphic types can be translated into polymorphic modes. The theorems for free <ref> [Wad89] </ref> obtained for functional programs are a direct consequence of the way we define M and the fact that it is a superset of SS (P ). Consider the following mode declaration: :- mode p (T, ~T).
Reference: [WHD88] <author> Richard Warren, Manuel Hermenegildo, and Saumya K. Debray. </author> <title> On the prac ticality of global flow analysis of logic programs. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Proceedings of the Fifth International Confer-ence/Symposium on Logic Programming, </booktitle> <pages> pages 684-699, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year> <month> 13 </month>
Reference-contexts: This information relied on the left to right execution order and was used by the compiler for optimisation. More expressive ways of describing modes are now used for optimising compilers [vRD90], parallelising code <ref> [WHD88] </ref> and analysing termination [BLR92][Nai93a]. IC-Prolog [CM79] introduced prescriptive modes to control the execution order and support coroutines.
References-found: 20

