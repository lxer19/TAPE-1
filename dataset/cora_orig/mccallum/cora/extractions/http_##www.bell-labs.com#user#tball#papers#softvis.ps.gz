URL: http://www.bell-labs.com/user/tball/papers/softvis.ps.gz
Refering-URL: http://www.cs.umd.edu/users/north/infoviz.html
Root-URL: 
Email: (tball@research.bell-labs.com)  (eick@research.bell-labs.com)  
Title: Software Visualization in the Large  
Author: Thomas Ball Stephen G. Eick 
Note: IEEE Computer, Vol. 29, No.4, April 1996. pp. 33-43  
Date: April 1996  
Abstract: Copyright 1996 IEEE. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE. 
Abstract-found: 1
Intro-found: 1
Reference: [BE94] <author> Thomas Ball and Stephen G. Eick. </author> <title> Visualizing program slices. </title> <booktitle> In IEEE/CS Symposium on Visual Languages, </booktitle> <pages> pages 288-295, </pages> <address> St. Louis, Missouri, </address> <month> 4 October </month> <year> 1994. </year>
Reference-contexts: While slices are typically smaller than the original program, they may still be quite large and complex, crossing many procedure, file, and module boundaries. Code visualization via reduced textual representations is well suited for displaying and exploring program slices <ref> [BE94] </ref>. 12 rectangle. Within each procedure's rectangle appears a line representation of the procedure's code. Colors are used to distinguish executed (light gray) and unexecuted code (dark gray), and also to distinguish code in the slice (colored) from other code.
Reference: [BM90] <author> Ronald M. Baecker and A. Marcus. </author> <title> Human Factors and Typography for More Readable Programs. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: This line view looks somewhat like that of Baecker and Marcus <ref> [BM90] </ref> (p. 235) who focus on techniques for typesetting C code. The biggest difference is that their views are exact scaled reductions of pretty-printed code, whereas our focus is on a variety of scalable representations.
Reference: [Bro88] <author> Marc H. Brown. </author> <title> Algorithm animation. </title> <booktitle> In ACM Distinguished Dissertations. </booktitle> <publisher> MIT Press, </publisher> <address> New York, </address> <year> 1988. </year> <month> 16 </month>
Reference-contexts: For example, a node in the graph may represent a procedure and an edge may represent a calling relationship between two procedures. Run-time behavior. Algorithm animation uses graphical representations of data structures and motion to illustrate the higher-level behavior of algorithms <ref> [Bro88] </ref> [Sta90] [RCWP92]. Lower-level views based on program profiles or traces can reveal bugs and performance anomalies. The code itself. Pretty printers are a basic and widely used form of code visualization. <p> For a nice overview and taxonomy of software visualization techniques see [PSB93]. 5.1 Algorithm Animation Many people associate software visualization with algorithm animation, using pictures and computer graphics to understand the execution of programs. Brown's dissertation <ref> [Bro88] </ref> established algorithm animation as a fundamental technique for illustrating complicated algorithms.
Reference: [CE94] <author> James O. Coplien and Jon Erickson. </author> <title> Examining the software development process. </title> <journal> Dr. Dobb's Journal, </journal> 19(11) 88-95, October 1994. 
Reference-contexts: 1 Introduction It is well known that large computer programs are complex and difficult to maintain. Production-sized systems, particularly legacy software, may contain millions of lines of code. Even a seemingly simple, small-team software 1 project, such as a spreadsheet, is very complicated <ref> [CE94] </ref>. Understanding, changing, and repairing code in large systems is time consuming and costly. Perhaps the most difficult software engineering projects involve "programming in the large." These large-team projects are often in maintenance mode and the enhancements involve subtle changes to complex legacy code written over many years.
Reference: [Cha90] <editor> S.-K. Chang, editor. </editor> <booktitle> Principles of Visual Programming. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1990. </year>
Reference-contexts: To address these shortcomings we have developed scalable techniques for visualizing program text, text properties, and relationships involving program text. We focus on text because it is the dominant medium for implementing large software systems. Visual languages have made great strides, particularly in restricted domains <ref> [Cha90] </ref>), but are not often used for general-purpose, large-scale program development. Virtually all coding of large systems takes place in text, and this will likely be the case for the foreseeable future. Programs are embodied in text and program modifications are made through changes to the text.
Reference: [ESEES92] <author> Stephen G. Eick, Joseph L. Steffen, and Jr. Eric E. Sumner. </author> <title> Seesoft T M |a tool for visualizing line oriented software statistics. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(11) </volume> <pages> 957-968, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Our work takes a complementary approach to algorithm animation, focusing on the static or dynamic properties of programs that can associated with lines of code rather than illustrating how algorithms operate. 5.2 Text Views The line representation (Figure 1) was originally introduced for showing software change history in <ref> [ESEES92] </ref>. This line view looks somewhat like that of Baecker and Marcus [BM90] (p. 235) who focus on techniques for typesetting C code. The biggest difference is that their views are exact scaled reductions of pretty-printed code, whereas our focus is on a variety of scalable representations.
Reference: [GKNV93] <author> Emden R. Gansner, Eleftherios E. Koutsofios, Stephen C. </author> <title> North, and K.P. Vo. A technique for drawing directed graphs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(3) </volume> <pages> 214-230, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: The nodes and edges of the graph must be positioned in a pleasing and informative layout so as to clearly show the structure of the underlying graph. Many techniques have been proposed for laying out arbitrary graphs <ref> [GKNV93] </ref>. Unfortunately, in practice, drawing informative graphs is exceedingly difficult, particularly for large systems. The function call graph for even a tiny single-person project many contain thousand of links and hundreds of nodes.
Reference: [HM75] <author> J. W. Hunt and M. D. McIlroy. </author> <title> An algorithm for differential file comparison. </title> <type> Technical Report Computing Science TR #41, </type> <institution> Bell Laboratories, </institution> <address> Murray Hill, N.J., </address> <year> 1975. </year>
Reference-contexts: If the hues of the respective half-lines are different, then the original fix and subsequent fix-on-fix occurred far apart in time, requiring duplicate programmer discovery. 9 3.2 Program comparison In the Unix environment diff is the standard tool for comparing two files <ref> [HM75] </ref>. There are versions of diff for performing three way comparisons of files (diff3), side-by-side comparisons (sdiff), and graphical interfaces for showing diff output (see, for example, SGI's gdiff command.) Although there has been extensive work on differencing algorithms, scant attention has been paid to understanding diff output.
Reference: [JS91] <author> Brian Johnson and Ben Shneiderman. </author> <title> Tree-maps: A space-filling approach to the visualization of hierarchical information structures. </title> <booktitle> In IEEE Visualization '91 Conference Proceedings, </booktitle> <pages> pages 284-291, </pages> <address> San Diego, California, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: This suggests showing software by using techniques for visualizing hierarchical data. A method developed by Johnson and Shneiderman shows hierarchies using a generalization of the pie-chart called a tree-map <ref> [JS91] </ref>. Figure 5 shows an extension of their technique modified to show source code organized into three subsystems, each containing directories which in turn contain files. The left pane represents the entire software system, and X, Y, and Z represent its three subsystems.
Reference: [PSB93] <author> Blane A. Price, Ian S. Small, and Ronald M. Baecker. </author> <title> A taxonomy of software visualization. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 4(3), </volume> <year> 1993. </year>
Reference-contexts: For a nice overview and taxonomy of software visualization techniques see <ref> [PSB93] </ref>. 5.1 Algorithm Animation Many people associate software visualization with algorithm animation, using pictures and computer graphics to understand the execution of programs. Brown's dissertation [Bro88] established algorithm animation as a fundamental technique for illustrating complicated algorithms.
Reference: [RCWP92] <author> Gruia-Catalin Roman, Kenneth C. Cox, C. Donald Wilcox, and Jerome Y. Plun. Pavane: </author> <title> A system for declarative visualization of concurrent computations. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 3(2) </volume> <pages> 161-193, </pages> <year> 1992. </year>
Reference-contexts: For example, a node in the graph may represent a procedure and an edge may represent a calling relationship between two procedures. Run-time behavior. Algorithm animation uses graphical representations of data structures and motion to illustrate the higher-level behavior of algorithms [Bro88] [Sta90] <ref> [RCWP92] </ref>. Lower-level views based on program profiles or traces can reveal bugs and performance anomalies. The code itself. Pretty printers are a basic and widely used form of code visualization.

References-found: 11

