URL: http://www.cs.dartmouth.edu/~jasonliu/courses/sim188/biblio/ck94.ps.gz
Refering-URL: http://www.cs.dartmouth.edu/~jasonliu/courses/sim188/notes-13.html
Root-URL: http://www.cs.dartmouth.edu
Email: rfc@eng.sun.com  pardo@cs.washington.edu  
Title: Shade: A Fast Instruction-Set Simulator for Execution Profiling  
Author: Bob Cmelik David Keppel 
Address: Washington  
Affiliation: Sun Microsystems, Inc.  University of  
Abstract: Tracing tools are used widely to help analyze, design, and tune both hardware and software systems. This paper describes a tool called Shade which combines efficient instruction-set simulation with a flexible, extensible trace generation capability. Efficiency is achieved by dynamically compiling and caching code to simulate and trace the application program. The user may control the extent of tracing in a variety of ways; arbitrarily detailed application state information may be collected during the simulation, but tracing less translates directly into greater efficiency. Current Shade implementations run on SPARC systems and simulate the SPARC (Versions 8 and 9) and MIPS I instruction sets. This paper describes the capabilities, design, implementation, and performance of Shade, and discusses instruction set emulation in general. 
Abstract-found: 1
Intro-found: 1
Reference: [AS92] <author> Kristy Andrews and Duane Sand, </author> <title> Migrating a CISC Computer Family onto RISC via Object Code Translation, </title> <booktitle> Proc. of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <pages> 213-222, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: Detail MD MP Signals OK Technology OK___________________________________________________________________________________________________________________________ ___________________________________________________________________________________________________________________________ Accelerator <ref> [AS92] </ref> sim exe us Y N Y Y scc+gi Y ATOM [SE94] tb C exe* u N N Y N aug N ATUM [ASH86] sim/atr exe us Y Y= Y Y emu Y dis+mod+run [FC88] sim/atr asm u N N N N scc N Dynascope [Sosic92] db/atr/otr hll u N N <p> Predecode interpreters (pdi) that pre-convert to a quick-to-decode intermediate representation. The IR can be many forms; a particularly fast, simple, and common form is threaded code (tci ). _____________________________________________________________________________________________________________ Translation Performance Name Reference (s) Units Assumptions (Slowdown) Notes _____________________________________________________________________________________________________________ _____________________________________________________________________________________________________________ Accelerator <ref> [AS92] </ref> ebb nr, bo, ph, regs 3 pages dis+mod+run [FC88] bb nr 10 Executor [Hostetter93] proc nr 10 mixed code g88 [Bedichek90] i nr, bo 30 pages gsim [Magnusson93, Magnusson94] bb nr, bo 30 pages Mable [DLHH93] i 20-80 mg88 [Bedichek94] i nr, bo 80 pages Migrant [SE93] ebb nr,bo - <p> However, since the compiler is used at run time, translation must be fast enough that the improved performance more than pays for the overhead of dynamic compilation [KEH91]; in addition, code quality may be worse than that of a static cross-compiler <ref> [AS92, SCKMR93] </ref> since dynamic code analysis may need to cut corners in order to minimize the compiler's running time. Where interpreter specifics are unavailable the tool is listed as using a general interpreter (gi ). Many tools listed as aug and emu execute most instructions using host hardware. <p> Translation techniques can be mixed by using one technique optimistically for good performance and another as a fallback when the first fails. However, such implementations have added complexity because they rely on having two translators <ref> [AS92, SCKMR93, Magnusson94, VF94] </ref>. Bugs OK describes whether the tool is robust in the face of application errors such as memory addressing errors or divide-by-zero errors. Typically, a simulator that checks for addressing errors requires extra checks on every instruction that writes memory. <p> Most tools avoid cross-architecture execution or omit some machine features. These choices improve execution efficiency but limit the tool's applicability. Some exceptions are g88 derivatives [Bedichek90, Magnusson93, Bedichek94, Magnusson94] which are somewhat less efficient than Shade and also Accelerator <ref> [AS92] </ref> and MX/Vest [SCKMR93] which do not perform any tracing and which use two translators, one optimistic and one conservative, to achieve high efficiency.
Reference: [ASH86] <author> Anant Agarwal, Richard L. Sites, and Mark Horowitz, ATUM: </author> <title> A New Technique for Capturing Address Traces Using Microcode, </title> <booktitle> Proc. of the 13th International Symposium on Computer Architecture, </booktitle> <pages> 119-127, </pages> <month> Jun. </month> <year> 1986. </year>
Reference-contexts: Detail MD MP Signals OK Technology OK___________________________________________________________________________________________________________________________ ___________________________________________________________________________________________________________________________ Accelerator [AS92] sim exe us Y N Y Y scc+gi Y ATOM [SE94] tb C exe* u N N Y N aug N ATUM <ref> [ASH86] </ref> sim/atr exe us Y Y= Y Y emu Y dis+mod+run [FC88] sim/atr asm u N N N N scc N Dynascope [Sosic92] db/atr/otr hll u N N S Y pdi Y Executor [Hostetter93] sim exe u N N Y Y pdi Y g88 [Bedichek90] sim/db exe usd Y N Y
Reference: [Baumann86] <author> Robert A. Baumann, </author> <title> Z80MU, </title> <journal> Byte, </journal> <pages> 203-216, </pages> <month> Oct. </month> <year> 1986. </year>
Reference-contexts: N N aug N Titan [BKW90] atr exe us Y N Y N aug N TRAPEDS [SJF92] atr asm us Y Y= S N aug N Tango Lite [GH92] atr asm u N Y1 N S aug N WWT [RHLLLW93] atr/otr exe u Y Y+ Y N emu+aug+ddi Y Z80MU <ref> [Baumann86] </ref> sim exe u (s) N N Y Y ddi Y ___________________________________________________________________________________________________________________________ Shade [CK93] sim/atr/otr/tb C exe u N N Y Y dcc N ___________________________________________________________________________________________________________________________ Table 5. Summary of some related systems studying the behavior of other translation tools (compilers, etc.). <p> Mimic [May87] ebb nr, bo, regs 4 no fp, no align, +compile Moxie [CHKW86] bb nr 2 MX/Vest [SCKMR93] ip bo 2 mixed code, fp prec SELF [CUL89] ip none N/A VM spec SoftPC [Nielsen91] 10 SPIM [HP93] i nr, bo 25 ST-80 [DS84] proc none N/A VM spec Z80MU <ref> [Baumann86] </ref> i nr, bo, regs mixed code _____________________________________________________________________________________________________________ 3-6 same machine Shade [CK93] ebb nr, bo 8-15 different machines (tracing off) _____________________________________________________________________________________________________________ Table 6. Summary of some cross-architecture simulators Static cross-compilation (scc ) which decodes and dispatches during cross-compilation, avoiding essentially all runtime dispatch costs.
Reference: [BDCW91] <author> Eric A. Brewer, Chrysanthos N. Dellarocas, Adrian Colbrook, and William E. Weihl, PROTEUS: </author> <title> A High-Performance Parallel-Architecture Simulator, </title> <institution> MIT/LCS/TR-516, Massachusetts Institute of Technology, </institution> <year> 1991. </year>
Reference-contexts: N Y N pdi Y ST-80 [DS84] sim exe u N N Y Y dcc Y MPtrace [EKKL90] atr asm u N Y= S N aug N Pixie [MIPS86] atr exe* u Y N Y N aug N Pixie-II [Killian94] atr/otr/db exe* us Y N Y S scc N Proteus <ref> [BDCW91] </ref> atr hll u N Y1 N S aug N RPPT [CMMJS88] atr hll u N Y1 N N aug N Titan [BKW90] atr exe us Y N Y N aug N TRAPEDS [SJF92] atr asm us Y Y= S N aug N Tango Lite [GH92] atr asm u N Y1
Reference: [Bedichek90] <author> Robert Bedichek, </author> <title> Some Efficient Architecture Simulation Techniques, </title> <booktitle> Winter 1990 USENIX Conference, </booktitle> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: N Y N aug N ATUM [ASH86] sim/atr exe us Y Y= Y Y emu Y dis+mod+run [FC88] sim/atr asm u N N N N scc N Dynascope [Sosic92] db/atr/otr hll u N N S Y pdi Y Executor [Hostetter93] sim exe u N N Y Y pdi Y g88 <ref> [Bedichek90] </ref> sim/db exe usd Y N Y Y tci Y gsim [Magnusson93, Magnusson94] sim/db/atr/otr/tb C exe usd Y Y1 Y Y tci+dcc Y Mable [DLHH93] sim/db/atr exe u N Y1 N Y ddi N mg88 [Bedichek94] sim/db/atr/otr/tb C exe usd Y Y1 Y Y tci Y Migrant [SE93] sim exe u <p> can be many forms; a particularly fast, simple, and common form is threaded code (tci ). _____________________________________________________________________________________________________________ Translation Performance Name Reference (s) Units Assumptions (Slowdown) Notes _____________________________________________________________________________________________________________ _____________________________________________________________________________________________________________ Accelerator [AS92] ebb nr, bo, ph, regs 3 pages dis+mod+run [FC88] bb nr 10 Executor [Hostetter93] proc nr 10 mixed code g88 <ref> [Bedichek90] </ref> i nr, bo 30 pages gsim [Magnusson93, Magnusson94] bb nr, bo 30 pages Mable [DLHH93] i 20-80 mg88 [Bedichek94] i nr, bo 80 pages Migrant [SE93] ebb nr,bo - Mimic [May87] ebb nr, bo, regs 4 no fp, no align, +compile Moxie [CHKW86] bb nr 2 MX/Vest [SCKMR93] ip bo <p> Typically, a simulator that checks for addressing errors requires extra checks on every instruction that writes memory. In some systems the checks are simple range checks; tools that support multiple address spaces and sparse address spaces generally require full address translation <ref> [Bedichek90] </ref>. Y* indicates that checking can be turned on but performance is worse. 6.2. Cross-Architecture Simulation Table 6 summarizes various features of tools that are used for cross-architecture simulation. The Translation Units column shows translation-time tradeoffs between analysis complexity and performance. <p> Most tools avoid cross-architecture execution or omit some machine features. These choices improve execution efficiency but limit the tool's applicability. Some exceptions are g88 derivatives <ref> [Bedichek90, Magnusson93, Bedichek94, Magnusson94] </ref> which are somewhat less efficient than Shade and also Accelerator [AS92] and MX/Vest [SCKMR93] which do not perform any tracing and which use two translators, one optimistic and one conservative, to achieve high efficiency.
Reference: [Bedichek94] <author> Robert Bedichek, </author> <title> The Meerkat Multicomputer: Tradeoffs in Multicomputer Architecture, </title> <type> Doctoral Dissertation, </type> <institution> University of Washington Department of Comp. Sci. and Eng., </institution> <note> 1994 (in preparation). </note>
Reference-contexts: Y pdi Y Executor [Hostetter93] sim exe u N N Y Y pdi Y g88 [Bedichek90] sim/db exe usd Y N Y Y tci Y gsim [Magnusson93, Magnusson94] sim/db/atr/otr/tb C exe usd Y Y1 Y Y tci+dcc Y Mable [DLHH93] sim/db/atr exe u N Y1 N Y ddi N mg88 <ref> [Bedichek94] </ref> sim/db/atr/otr/tb C exe usd Y Y1 Y Y tci Y Migrant [SE93] sim exe u Y N Y Y scc+emu Y Mimic [May87] sim exe u N N N N dcc N MINT [VF94] atr exe u N Y1 Y N pdi+dcc Y* Moxie [CHKW86] sim exe u N N <p> Name Reference (s) Units Assumptions (Slowdown) Notes _____________________________________________________________________________________________________________ _____________________________________________________________________________________________________________ Accelerator [AS92] ebb nr, bo, ph, regs 3 pages dis+mod+run [FC88] bb nr 10 Executor [Hostetter93] proc nr 10 mixed code g88 [Bedichek90] i nr, bo 30 pages gsim [Magnusson93, Magnusson94] bb nr, bo 30 pages Mable [DLHH93] i 20-80 mg88 <ref> [Bedichek94] </ref> i nr, bo 80 pages Migrant [SE93] ebb nr,bo - Mimic [May87] ebb nr, bo, regs 4 no fp, no align, +compile Moxie [CHKW86] bb nr 2 MX/Vest [SCKMR93] ip bo 2 mixed code, fp prec SELF [CUL89] ip none N/A VM spec SoftPC [Nielsen91] 10 SPIM [HP93] i nr, <p> Most tools avoid cross-architecture execution or omit some machine features. These choices improve execution efficiency but limit the tool's applicability. Some exceptions are g88 derivatives <ref> [Bedichek90, Magnusson93, Bedichek94, Magnusson94] </ref> which are somewhat less efficient than Shade and also Accelerator [AS92] and MX/Vest [SCKMR93] which do not perform any tracing and which use two translators, one optimistic and one conservative, to achieve high efficiency. <p> It currently lacks kernel-mode tracing facilities provided by some other tools though some of these tools limit machine features and/or require hand-instrumentation of key kernel code. Shade collects more trace information than most other tools, though it lacks the timing-level simulation of mg88 <ref> [Bedichek94] </ref>. With Shade, the analyzer can select the amount of trace data that it collects, and analyzers that consume little trace data pay little tracing overhead. Thus, it is typically the analysis tools that limit overall performance.
Reference: [BKW90] <author> Anita Borg, R. E. Kessler, and David W. Wall, </author> <title> Generation and Analysis of Very Long Address Traces, </title> <booktitle> Proc. of the 17th Annual Symposium on Computer Architecture, </booktitle> <pages> 270-279, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Third, trace generation should be fast, both so that traces can be recreated on demand, instead of being archived on bulk storage, and so that it is possible to study realistic workloads, since partial workloads may not provide representative information <ref> [BKW90] </ref>. Fourth, a tracing tool should provide arbitrarily detailed trace information To appear in the 1994 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems. <p> Y= S N aug N Pixie [MIPS86] atr exe* u Y N Y N aug N Pixie-II [Killian94] atr/otr/db exe* us Y N Y S scc N Proteus [BDCW91] atr hll u N Y1 N S aug N RPPT [CMMJS88] atr hll u N Y1 N N aug N Titan <ref> [BKW90] </ref> atr exe us Y N Y N aug N TRAPEDS [SJF92] atr asm us Y Y= S N aug N Tango Lite [GH92] atr asm u N Y1 N S aug N WWT [RHLLLW93] atr/otr exe u Y Y+ Y N emu+aug+ddi Y Z80MU [Baumann86] sim exe u (s) N
Reference: [CHKW86] <author> F. Chow, M. Himelstein, E. Killian, and L. Weber, </author> <title> Engineering a RISC Compiler System, </title> <booktitle> IEEE COMPCON, </booktitle> <month> Mar. </month> <year> 1986. </year>
Reference-contexts: N Y ddi N mg88 [Bedichek94] sim/db/atr/otr/tb C exe usd Y Y1 Y Y tci Y Migrant [SE93] sim exe u Y N Y Y scc+emu Y Mimic [May87] sim exe u N N N N dcc N MINT [VF94] atr exe u N Y1 Y N pdi+dcc Y* Moxie <ref> [CHKW86] </ref> sim exe u N N Y N scc N MX/Vest [SCKMR93] sim exe u N Y= Y Y scc+gi Y Purify [HJ92] db exe* u N N Y N aug Y qp/qpt [LB94] atr/otr exe u N N N N aug N SELF [CUL89] sim exe u N N Y <p> [Hostetter93] proc nr 10 mixed code g88 [Bedichek90] i nr, bo 30 pages gsim [Magnusson93, Magnusson94] bb nr, bo 30 pages Mable [DLHH93] i 20-80 mg88 [Bedichek94] i nr, bo 80 pages Migrant [SE93] ebb nr,bo - Mimic [May87] ebb nr, bo, regs 4 no fp, no align, +compile Moxie <ref> [CHKW86] </ref> bb nr 2 MX/Vest [SCKMR93] ip bo 2 mixed code, fp prec SELF [CUL89] ip none N/A VM spec SoftPC [Nielsen91] 10 SPIM [HP93] i nr, bo 25 ST-80 [DS84] proc none N/A VM spec Z80MU [Baumann86] i nr, bo, regs mixed code _____________________________________________________________________________________________________________ 3-6 same machine Shade [CK93] ebb
Reference: [CK93] <author> Robert F. Cmelik and David Keppel, Shade: </author> <title> A Fast Instruction-Set Simulator for Execution Profiling, </title> <type> SMLI 93-12, </type> <institution> UWCSE 93-06-06, Sun Microsystems Laboratories, Inc., and the University of Washington, </institution> <year> 1993. </year>
Reference-contexts: When more TC space is needed than is available, Shade frees all entries in the TC and clears the TLB. Full flushing is used because translation chaining makes most other freeing strategies tedious <ref> [CK93] </ref>. Since full flushing deletes useful translations, the TC is made large so that freeing is rare [CK93]. Shade also flushes the TC and TLB when the analyzer changes the tracing strategy (typically rare), since tracing is hardcoded into the translations. <p> Full flushing is used because translation chaining makes most other freeing strategies tedious <ref> [CK93] </ref>. Since full flushing deletes useful translations, the TC is made large so that freeing is rare [CK93]. Shade also flushes the TC and TLB when the analyzer changes the tracing strategy (typically rare), since tracing is hardcoded into the translations. If an application uses self-modifying code, the TC, TLB, and translation chaining entries for the modified code become invalid and must be flushed. <p> Since address pair lists are of fixed length, address pairs can be pushed off the end of a list and lost, which makes the corresponding translations inaccessible via the TLB. The TLB is large enough that this is not usually a problem <ref> [CK93] </ref> and translations are also likely to still be accessible via chaining from other translations. 3.4. Other Considerations The decision to simulate, trace, and analyze all in the same process leads to conflicts over the use of per-process state and resources. <p> In general, conflicts are resolved by partitioning the resource, by time multiplexing it between contenders, or by simulating (virtualizing) the resource. Some conflicts are unresolved, usually due to an incomplete implementation <ref> [CK93] </ref>. Shade's target code parser is ad hoc, though machine code parsers can be built automatically [Ramsey93]. Shade uses an ad hoc code generator which generates code in roughly one pass. Some minor backpatching is later performed to chain translations and replace nops in delay slots. <p> The resulting code could no doubt be im proved, but the time spent in the user-supplied analyzer usually dwarfs the time spent in Shade's code generation, simulation, and tracing combined. Many of the implementation issues and choices, as well as some of the implementation alternatives, are described elsewhere <ref> [CK93] </ref>, as are details of the signal and exception handling and implementation of the system call interface. 4. <p> This difference complicates the translation compiler. Some host/target differences help Shade-MIPS.V8's efficiency. In particular, the MIPS architecture employs values stored in general purpose integer registers in place of integer condition codes. This reduces contention for the host condition codes <ref> [CK93] </ref>. 4.2. Shade-V9.V8 Shade-V9.V8 simulates a V9 SPARC target and runs on a V8 SPARC host. The principal problems of simulating V9 applica tions on V8 hosts are wider integer registers and additional condi-1. <p> The host integer condition codes are often required (as in the add example above) to simulate 64-bit operations which themselves do not involve condition codes. This increases the number of contenders for the host condition codes <ref> [CK93] </ref>. Shade-V9.V8's performance is likely to degrade as compilers take advantage of more V9 features. For example, V9 supports more floating point registers and floating point condition codes than V8. V9 compilers that make better use of these registers will increase register pressure on the V8 host. <p> The time distribution is determined by several factors. Better optimization takes longer and produces faster running code, both of which increase the percentage of time spent in code generation. The simulation time (Sim ) comes mostly from saving and restoring condition codes <ref> [CK93] </ref>, simulating save and restore, and from main loop execution; larger target basic blocks tend to reduce condition code and main loop overheads. A small TC increases the frequency with which useful translations are discarded. A small or ineffective TLB increases the frequency with which useful translations are lost. <p> Note that without translation caching, the compiler would be invoked every time a target in struction was run and applications would run hundreds or thousands of times slower. Measurements of the TC and TLB effectiveness are reported elsewhere <ref> [CK93] </ref>. 6. Related Work This section describes related work and summarizes the capabilities and implementation techniques of other simulators, virtual machines and tracing tools. <p> aug N TRAPEDS [SJF92] atr asm us Y Y= S N aug N Tango Lite [GH92] atr asm u N Y1 N S aug N WWT [RHLLLW93] atr/otr exe u Y Y+ Y N emu+aug+ddi Y Z80MU [Baumann86] sim exe u (s) N N Y Y ddi Y ___________________________________________________________________________________________________________________________ Shade <ref> [CK93] </ref> sim/atr/otr/tb C exe u N N Y Y dcc N ___________________________________________________________________________________________________________________________ Table 5. Summary of some related systems studying the behavior of other translation tools (compilers, etc.). Consuming assembly code (asm) is less portable than a high-level language but can provide more detailed information. <p> Moxie [CHKW86] bb nr 2 MX/Vest [SCKMR93] ip bo 2 mixed code, fp prec SELF [CUL89] ip none N/A VM spec SoftPC [Nielsen91] 10 SPIM [HP93] i nr, bo 25 ST-80 [DS84] proc none N/A VM spec Z80MU [Baumann86] i nr, bo, regs mixed code _____________________________________________________________________________________________________________ 3-6 same machine Shade <ref> [CK93] </ref> ebb nr, bo 8-15 different machines (tracing off) _____________________________________________________________________________________________________________ Table 6. Summary of some cross-architecture simulators Static cross-compilation (scc ) which decodes and dispatches during cross-compilation, avoiding essentially all runtime dispatch costs. <p> Dynamic cross-compilation (dcc) is performed at runtime and thus can work with any code including dynamically-linked libraries. Also, dynamic cross-compilers can perform optimistic optimizations and recompile if the assumptions were too strong <ref> [Johnston79, SW79, May87, HCU91, CK93] </ref>.
Reference: [Cmelik93] <author> Robert F. Cmelik, </author> <title> The Shade User's Manual, </title> <institution> Sun Microsystems Laboratories, Inc., </institution> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: Analyzers see Shade as a collection of library functions <ref> [Cmelik93] </ref>. Analyzers call these functions to identify the application program to be simulated, specify the level of tracing detail, and to simulate one or more application instructions while collecting the specified trace information.
Reference: [CMMJS88] <author> R. C. Covington, S. Madala, V. Mehta, J. R. Jump, and J. B. Sinclair, </author> <title> The Rice Parallel Processing Testbed, </title> <booktitle> ACM SIGMETRICS, </booktitle> <pages> 4-11, </pages> <year> 1988. </year>
Reference-contexts: N Y Y dcc Y MPtrace [EKKL90] atr asm u N Y= S N aug N Pixie [MIPS86] atr exe* u Y N Y N aug N Pixie-II [Killian94] atr/otr/db exe* us Y N Y S scc N Proteus [BDCW91] atr hll u N Y1 N S aug N RPPT <ref> [CMMJS88] </ref> atr hll u N Y1 N N aug N Titan [BKW90] atr exe us Y N Y N aug N TRAPEDS [SJF92] atr asm us Y Y= S N aug N Tango Lite [GH92] atr asm u N Y1 N S aug N WWT [RHLLLW93] atr/otr exe u Y Y+
Reference: [CUL89] <author> Craig Chambers, David Ungar, and Elgin Lee, </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes, </title> <booktitle> OOPSLA '89 Proceedings, </booktitle> <pages> 49-70, </pages> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: Y1 Y N pdi+dcc Y* Moxie [CHKW86] sim exe u N N Y N scc N MX/Vest [SCKMR93] sim exe u N Y= Y Y scc+gi Y Purify [HJ92] db exe* u N N Y N aug Y qp/qpt [LB94] atr/otr exe u N N N N aug N SELF <ref> [CUL89] </ref> sim exe u N N Y Y dcc Y SoftPC [Nielsen91] sim exe u (s)d N N Y Y dcc Y Spa [Irlam93] atr exe u N N S Y ddi N SPIM [HP93] sim/atr exe u N N Y N pdi Y ST-80 [DS84] sim exe u N N <p> [Magnusson93, Magnusson94] bb nr, bo 30 pages Mable [DLHH93] i 20-80 mg88 [Bedichek94] i nr, bo 80 pages Migrant [SE93] ebb nr,bo - Mimic [May87] ebb nr, bo, regs 4 no fp, no align, +compile Moxie [CHKW86] bb nr 2 MX/Vest [SCKMR93] ip bo 2 mixed code, fp prec SELF <ref> [CUL89] </ref> ip none N/A VM spec SoftPC [Nielsen91] 10 SPIM [HP93] i nr, bo 25 ST-80 [DS84] proc none N/A VM spec Z80MU [Baumann86] i nr, bo, regs mixed code _____________________________________________________________________________________________________________ 3-6 same machine Shade [CK93] ebb nr, bo 8-15 different machines (tracing off) _____________________________________________________________________________________________________________ Table 6.
Reference: [DLHH93] <author> Peter Davies, Philippe LaCroute, John Heinlein, and Mark Horowitz, Mable: </author> <title> A Technique for Efficient Machine Simulation, (to appear), Quantum Effect Design, </title> <publisher> Inc., and Stanford University. </publisher>
Reference-contexts: N scc N Dynascope [Sosic92] db/atr/otr hll u N N S Y pdi Y Executor [Hostetter93] sim exe u N N Y Y pdi Y g88 [Bedichek90] sim/db exe usd Y N Y Y tci Y gsim [Magnusson93, Magnusson94] sim/db/atr/otr/tb C exe usd Y Y1 Y Y tci+dcc Y Mable <ref> [DLHH93] </ref> sim/db/atr exe u N Y1 N Y ddi N mg88 [Bedichek94] sim/db/atr/otr/tb C exe usd Y Y1 Y Y tci Y Migrant [SE93] sim exe u Y N Y Y scc+emu Y Mimic [May87] sim exe u N N N N dcc N MINT [VF94] atr exe u N Y1 <p> ). _____________________________________________________________________________________________________________ Translation Performance Name Reference (s) Units Assumptions (Slowdown) Notes _____________________________________________________________________________________________________________ _____________________________________________________________________________________________________________ Accelerator [AS92] ebb nr, bo, ph, regs 3 pages dis+mod+run [FC88] bb nr 10 Executor [Hostetter93] proc nr 10 mixed code g88 [Bedichek90] i nr, bo 30 pages gsim [Magnusson93, Magnusson94] bb nr, bo 30 pages Mable <ref> [DLHH93] </ref> i 20-80 mg88 [Bedichek94] i nr, bo 80 pages Migrant [SE93] ebb nr,bo - Mimic [May87] ebb nr, bo, regs 4 no fp, no align, +compile Moxie [CHKW86] bb nr 2 MX/Vest [SCKMR93] ip bo 2 mixed code, fp prec SELF [CUL89] ip none N/A VM spec SoftPC [Nielsen91] 10
Reference: [DS84] <author> Peter Deutsch and Alan M. Schiffman, </author> <title> Efficient Implementation of the Smalltalk-80 System, </title> <booktitle> 11th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> 297-302, </pages> <month> Jan. </month> <year> 1984. </year>
Reference-contexts: N N aug N SELF [CUL89] sim exe u N N Y Y dcc Y SoftPC [Nielsen91] sim exe u (s)d N N Y Y dcc Y Spa [Irlam93] atr exe u N N S Y ddi N SPIM [HP93] sim/atr exe u N N Y N pdi Y ST-80 <ref> [DS84] </ref> sim exe u N N Y Y dcc Y MPtrace [EKKL90] atr asm u N Y= S N aug N Pixie [MIPS86] atr exe* u Y N Y N aug N Pixie-II [Killian94] atr/otr/db exe* us Y N Y S scc N Proteus [BDCW91] atr hll u N Y1 N <p> An obvious implementation executes programs by fetching, decoding, and then interpreting each instruction in isolation. Most of the implementations optimize by predecoding and then caching the decoded result; by translating to host code to make direct use of the host's prefetch and decode hardware <ref> [DS84] </ref>; and by executing target instructions in the context of their neighbors so that target state (e.g. simulated registers) can be accessed efficiently (e.g. from host registers) across target instruction boundaries. The implementations are: Hardware emulation including both dedicated hardware and mi crocode (emu ). <p> 80 pages Migrant [SE93] ebb nr,bo - Mimic [May87] ebb nr, bo, regs 4 no fp, no align, +compile Moxie [CHKW86] bb nr 2 MX/Vest [SCKMR93] ip bo 2 mixed code, fp prec SELF [CUL89] ip none N/A VM spec SoftPC [Nielsen91] 10 SPIM [HP93] i nr, bo 25 ST-80 <ref> [DS84] </ref> proc none N/A VM spec Z80MU [Baumann86] i nr, bo, regs mixed code _____________________________________________________________________________________________________________ 3-6 same machine Shade [CK93] ebb nr, bo 8-15 different machines (tracing off) _____________________________________________________________________________________________________________ Table 6.
Reference: [EKKL90] <author> Susan J. Eggers, David Keppel, Eric J. Koldinger, and Henry M. Levy, </author> <title> Techniques for Efficient Inline Tracing on a Shared-Memory Multiprocessor, </title> <journal> ACM SIGMETRICS, </journal> <volume> 37- 47, </volume> <month> May </month> <year> 1990. </year>
Reference-contexts: Y Y dcc Y SoftPC [Nielsen91] sim exe u (s)d N N Y Y dcc Y Spa [Irlam93] atr exe u N N S Y ddi N SPIM [HP93] sim/atr exe u N N Y N pdi Y ST-80 [DS84] sim exe u N N Y Y dcc Y MPtrace <ref> [EKKL90] </ref> atr asm u N Y= S N aug N Pixie [MIPS86] atr exe* u Y N Y N aug N Pixie-II [Killian94] atr/otr/db exe* us Y N Y S scc N Proteus [BDCW91] atr hll u N Y1 N S aug N RPPT [CMMJS88] atr hll u N Y1 N
Reference: [Evans92] <author> Doug Evans, </author> <type> Personal comm., </type> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: Shade analyzers have been used for pure simulation (no tracing), to generate memory address traces for use by other tools, provide a debugger interface to a simulated target machine for compiler cross-development <ref> [Evans92] </ref>, observe instruction operand values [Richardson92], analyze memory cache performance, analyze microprocessor pipeline performance, and analyze Shade's own performance. Analyzers see Shade as a collection of library functions [Cmelik93]. <p> Shade analyzers have used both C and C++ as the extension language [NG88]. We note also that although Shade is not designed for debugging, Shade-V9.V8 has been used as the back end of a debugger <ref> [Evans92] </ref>. Shade's flexibility and performance does come at a penalty. For example, Shade performs inter-instruction analysis and host code generation; this makes Shade more complex and less portable than, e.g., g88.
Reference: [FC88] <author> Richard M. Fujimoto and William B. Campbell, </author> <title> Efficient Instruction Level Simulation of Computers, </title> <journal> Transactions of The Society for Computer Simulation, </journal> <volume> 5(2): </volume> <pages> 109-124, </pages> <year> 1988. </year>
Reference-contexts: Detail MD MP Signals OK Technology OK___________________________________________________________________________________________________________________________ ___________________________________________________________________________________________________________________________ Accelerator [AS92] sim exe us Y N Y Y scc+gi Y ATOM [SE94] tb C exe* u N N Y N aug N ATUM [ASH86] sim/atr exe us Y Y= Y Y emu Y dis+mod+run <ref> [FC88] </ref> sim/atr asm u N N N N scc N Dynascope [Sosic92] db/atr/otr hll u N N S Y pdi Y Executor [Hostetter93] sim exe u N N Y Y pdi Y g88 [Bedichek90] sim/db exe usd Y N Y Y tci Y gsim [Magnusson93, Magnusson94] sim/db/atr/otr/tb C exe usd Y <p> The IR can be many forms; a particularly fast, simple, and common form is threaded code (tci ). _____________________________________________________________________________________________________________ Translation Performance Name Reference (s) Units Assumptions (Slowdown) Notes _____________________________________________________________________________________________________________ _____________________________________________________________________________________________________________ Accelerator [AS92] ebb nr, bo, ph, regs 3 pages dis+mod+run <ref> [FC88] </ref> bb nr 10 Executor [Hostetter93] proc nr 10 mixed code g88 [Bedichek90] i nr, bo 30 pages gsim [Magnusson93, Magnusson94] bb nr, bo 30 pages Mable [DLHH93] i 20-80 mg88 [Bedichek94] i nr, bo 80 pages Migrant [SE93] ebb nr,bo - Mimic [May87] ebb nr, bo, regs 4 no fp, <p> Tracing tools typically produce only address traces, and often run only on the machine for which the trace is desired. Even tools that allow cross-architecture simulation tend to limit the generality of the machine simulation or of the tracing facilities in order to maintain efficiency <ref> [FC88, HP93] </ref>. Shade supports cross-architecture tracing and simulates user-mode operation in detail. It currently lacks kernel-mode tracing facilities provided by some other tools though some of these tools limit machine features and/or require hand-instrumentation of key kernel code.
Reference: [GH92] <author> Stephen R. Goldschmidt and John L. Hennessy, </author> <title> The Accuracy of Trace-Driven Simulations of Multiprocessors, </title> <institution> CSL-TR-92-546, Stanford University Computer Systems Laboratory, </institution> <month> Sep. </month> <year> 1992. </year>
Reference-contexts: Y S scc N Proteus [BDCW91] atr hll u N Y1 N S aug N RPPT [CMMJS88] atr hll u N Y1 N N aug N Titan [BKW90] atr exe us Y N Y N aug N TRAPEDS [SJF92] atr asm us Y Y= S N aug N Tango Lite <ref> [GH92] </ref> atr asm u N Y1 N S aug N WWT [RHLLLW93] atr/otr exe u Y Y+ Y N emu+aug+ddi Y Z80MU [Baumann86] sim exe u (s) N N Y Y ddi Y ___________________________________________________________________________________________________________________________ Shade [CK93] sim/atr/otr/tb C exe u N N Y Y dcc N ___________________________________________________________________________________________________________________________ Table 5.
Reference: [HCU91] <author> Urs H"olzle, Craig Chambers, and David Ungar, </author> <title> Optimizing Dynamically-Typed Object-Oriented Languages With Polymorphic Inline Caches, </title> <booktitle> Proc. of the European Conference on Object-Oriented Programming (ECOOP), </booktitle> <month> Jul. </month> <year> 1991. </year>
Reference-contexts: Dynamic cross-compilation (dcc) is performed at runtime and thus can work with any code including dynamically-linked libraries. Also, dynamic cross-compilers can perform optimistic optimizations and recompile if the assumptions were too strong <ref> [Johnston79, SW79, May87, HCU91, CK93] </ref>.
Reference: [HJ92] <author> Reed Hastings and Bob Joyce, Purify: </author> <title> Fast Detection of Memory Leaks and Access Errors, </title> <booktitle> Proc. of the Winter Usenix Conference, </booktitle> <pages> 125-136, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: N Y Y scc+emu Y Mimic [May87] sim exe u N N N N dcc N MINT [VF94] atr exe u N Y1 Y N pdi+dcc Y* Moxie [CHKW86] sim exe u N N Y N scc N MX/Vest [SCKMR93] sim exe u N Y= Y Y scc+gi Y Purify <ref> [HJ92] </ref> db exe* u N N Y N aug Y qp/qpt [LB94] atr/otr exe u N N N N aug N SELF [CUL89] sim exe u N N Y Y dcc Y SoftPC [Nielsen91] sim exe u (s)d N N Y Y dcc Y Spa [Irlam93] atr exe u N N
Reference: [Hostetter93] <author> Mat Hostetter, </author> <type> Personal comm., </type> <month> Jul. </month> <year> 1993. </year>
Reference-contexts: Y Y scc+gi Y ATOM [SE94] tb C exe* u N N Y N aug N ATUM [ASH86] sim/atr exe us Y Y= Y Y emu Y dis+mod+run [FC88] sim/atr asm u N N N N scc N Dynascope [Sosic92] db/atr/otr hll u N N S Y pdi Y Executor <ref> [Hostetter93] </ref> sim exe u N N Y Y pdi Y g88 [Bedichek90] sim/db exe usd Y N Y Y tci Y gsim [Magnusson93, Magnusson94] sim/db/atr/otr/tb C exe usd Y Y1 Y Y tci+dcc Y Mable [DLHH93] sim/db/atr exe u N Y1 N Y ddi N mg88 [Bedichek94] sim/db/atr/otr/tb C exe usd <p> The IR can be many forms; a particularly fast, simple, and common form is threaded code (tci ). _____________________________________________________________________________________________________________ Translation Performance Name Reference (s) Units Assumptions (Slowdown) Notes _____________________________________________________________________________________________________________ _____________________________________________________________________________________________________________ Accelerator [AS92] ebb nr, bo, ph, regs 3 pages dis+mod+run [FC88] bb nr 10 Executor <ref> [Hostetter93] </ref> proc nr 10 mixed code g88 [Bedichek90] i nr, bo 30 pages gsim [Magnusson93, Magnusson94] bb nr, bo 30 pages Mable [DLHH93] i 20-80 mg88 [Bedichek94] i nr, bo 80 pages Migrant [SE93] ebb nr,bo - Mimic [May87] ebb nr, bo, regs 4 no fp, no align, +compile Moxie [CHKW86]
Reference: [HP93] <author> John Hennessy and David Patterson, </author> <title> Computer Organization and Design: The Hardware-Software Interface (Appendix A, by James R. Larus), </title> <publisher> Morgan Kaufman, </publisher> <year> 1993. </year>
Reference-contexts: Y N aug Y qp/qpt [LB94] atr/otr exe u N N N N aug N SELF [CUL89] sim exe u N N Y Y dcc Y SoftPC [Nielsen91] sim exe u (s)d N N Y Y dcc Y Spa [Irlam93] atr exe u N N S Y ddi N SPIM <ref> [HP93] </ref> sim/atr exe u N N Y N pdi Y ST-80 [DS84] sim exe u N N Y Y dcc Y MPtrace [EKKL90] atr asm u N Y= S N aug N Pixie [MIPS86] atr exe* u Y N Y N aug N Pixie-II [Killian94] atr/otr/db exe* us Y N Y <p> 20-80 mg88 [Bedichek94] i nr, bo 80 pages Migrant [SE93] ebb nr,bo - Mimic [May87] ebb nr, bo, regs 4 no fp, no align, +compile Moxie [CHKW86] bb nr 2 MX/Vest [SCKMR93] ip bo 2 mixed code, fp prec SELF [CUL89] ip none N/A VM spec SoftPC [Nielsen91] 10 SPIM <ref> [HP93] </ref> i nr, bo 25 ST-80 [DS84] proc none N/A VM spec Z80MU [Baumann86] i nr, bo, regs mixed code _____________________________________________________________________________________________________________ 3-6 same machine Shade [CK93] ebb nr, bo 8-15 different machines (tracing off) _____________________________________________________________________________________________________________ Table 6. <p> Tracing tools typically produce only address traces, and often run only on the machine for which the trace is desired. Even tools that allow cross-architecture simulation tend to limit the generality of the machine simulation or of the tracing facilities in order to maintain efficiency <ref> [FC88, HP93] </ref>. Shade supports cross-architecture tracing and simulates user-mode operation in detail. It currently lacks kernel-mode tracing facilities provided by some other tools though some of these tools limit machine features and/or require hand-instrumentation of key kernel code.
Reference: [Hsu89] <author> Peter Hsu, </author> <title> Introduction to Shadow, Sun Microsystems, </title> <publisher> Inc., </publisher> <month> 28 Jul. </month> <year> 1989. </year>
Reference-contexts: Acknowledgements Shade owes much to its predecessors, particularly its immediate predecessor Shadow, which was created by Peter Hsu <ref> [Hsu89] </ref>. Robert Cmelik developed Shade, with numerous suggestions from David Keppel. Steve Richardson, Malcolm Wing, and others in the Shade user community provided useful user interface feedback and helped debug Shade.
Reference: [Irlam93] <author> Gordon Irlam, </author> <type> Personal comm., </type> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: Y Y scc+gi Y Purify [HJ92] db exe* u N N Y N aug Y qp/qpt [LB94] atr/otr exe u N N N N aug N SELF [CUL89] sim exe u N N Y Y dcc Y SoftPC [Nielsen91] sim exe u (s)d N N Y Y dcc Y Spa <ref> [Irlam93] </ref> atr exe u N N S Y ddi N SPIM [HP93] sim/atr exe u N N Y N pdi Y ST-80 [DS84] sim exe u N N Y Y dcc Y MPtrace [EKKL90] atr asm u N Y= S N aug N Pixie [MIPS86] atr exe* u Y N Y
Reference: [James90] <author> David James, </author> <title> Multiplexed Busses: </title> <journal> The Endian Wars Continue, IEEE Micro Magazine, </journal> <pages> 9-22, </pages> <month> Jun. </month> <year> 1990. </year>
Reference-contexts: On average, Shade-MIPS.V8 executes about 10 SPARC instructions to simulate a MIPS instruction. Some differences between the host and target machines make Shade-MIPS.V8 less faithful, slower, or more complicated. For example, MIPS systems support both big-endian and little-endian byte ordering <ref> [James90] </ref>, but V8 SPARC only supports the former. Shade-MIPS.V8 currently runs only code that has been compiled for MIPS systems running in big-endian mode. Shade thus avoids the more complicated simulation of little-endian access. Similarly, Shade-MIPS.V8 does not check for overflows that would cause exceptions on MIPS systems.
Reference: [Johnston79] <author> Ronald L. Johnston, </author> <title> The Dynamic Incremental Compiler of APL"3000, </title> <journal> APL Quote Quad, </journal> <volume> 9(4): </volume> <pages> 82-87, </pages> <institution> Association for Computing Machinery (ACM), </institution> <month> Jun. </month> <year> 1979. </year>
Reference-contexts: Dynamic cross-compilation (dcc) is performed at runtime and thus can work with any code including dynamically-linked libraries. Also, dynamic cross-compilers can perform optimistic optimizations and recompile if the assumptions were too strong <ref> [Johnston79, SW79, May87, HCU91, CK93] </ref>.
Reference: [Kane87] <author> Gerry Kane, </author> <title> MIPS R2000 RISC Architecture, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1987. </year>
Reference-contexts: Other Shades have been developed. The first (Shade-MIPS.V8) runs UMIPS-V [UMIPSV], MIPS I <ref> [Kane87] </ref> binaries, and the second (Shade-V9.V8) runs SunOS 4.x, Version 9 SPARC [SPARC9] binaries. The host system for both is SunOS 4.x, Version 8 SPARC. There are also versions of Shade-V8.V8 and Shade-V9.V8 where both the host and target operating systems are Solaris 2.x [SunOS5].
Reference: [KEH91] <author> David Keppel, Susan J. Eggers, and Robert R. </author> <note> Henry, </note>
Reference-contexts: SMC OK describes whether the tool is able to operate on programs where the instruction space changes dynamically. Dynamic linking is the most common reason, but there are a number of other uses <ref> [KEH91] </ref>. Static rewrite tools can sometimes (S ) link dynamically to statically-rewritten code, but the dynamically-formed link can't be rewritten statically and thus may go untraced. Technology describes the general implementation techniques used in the tool [Pittman87]. <p> Also, dynamic cross-compilers can perform optimistic optimizations and recompile if the assumptions were too strong [Johnston79, SW79, May87, HCU91, CK93]. However, since the compiler is used at run time, translation must be fast enough that the improved performance more than pays for the overhead of dynamic compilation <ref> [KEH91] </ref>; in addition, code quality may be worse than that of a static cross-compiler [AS92, SCKMR93] since dynamic code analysis may need to cut corners in order to minimize the compiler's running time. Where interpreter specifics are unavailable the tool is listed as using a general interpreter (gi ).
References-found: 28

