URL: http://osl.cs.uiuc.edu/Papers/nielsen-agha.ps
Refering-URL: http://osl.cs.uiuc.edu/Papers/RT.html
Root-URL: http://www.cs.uiuc.edu
Email: Email: bnielsen@cs.auc.dk Email: agha@cs.uiuc.edu  
Title: Towards Reusable Real-Time Objects  
Author: Brian Nielsen Gul Agha 
Address: Fredrik Bajersvej 7E 1304 W. Springfield Av. DK-9220 Aalborg, Denmark Urbana, Illinois 61801, U.S.A  
Affiliation: Aalborg University University of Illinois at Urbana-Champaign Dept. of Computer Science Dept. of Computer Science  
Abstract: Large and complex real-time systems can benefit significantly from a component based development approach where new systems are constructed by composing reusable, documented and previously tested concurrent objects. However, reusing objects which execute under real-time constraints is problematic because often application specific time and synchronization constraints are embedded in the internals of these objects. This tight coupling of functionality and real-time constraints make objects interdependent, and consequently unlikely to be reusable in other systems. We propose a model which facilitate separate and modular specification of real-time constraints and functional behavior of objects, and show through a series of examples how this separation is possible. We present our ideas in the context of the actor-model for modelling untimed objects and our real-time synchronizers language for expressing real-time and synchronization constraints. The synchronizers govern the interaction and execution of the untimed objects. We treat our model formally, and succinctly define what effect real-time constraints has on a set of concurrent objects. We briefly discuss how a middleware scheduling and event-dispatching service can use the synchronizers to execute the system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Gul Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, Los Alamitos, </publisher> <address> California, </address> <year> 1986. </year> <note> ISBN 0-262-01092-5. </note>
Reference-contexts: Our goal is to succinctly define constraints and their effects on the objects they constrain. Section 4 provides the formal definitions. Finally, in Section 5 we discuss implementation. 3 Specification of interaction constraints In the Actor model <ref> [1, 2, 4] </ref> distributed computing entities (hardware or software) are modeled as abstract self-contained objects called actors. An actor encapsulates a state, provides a set of public methods, and potentially invokes public methods in other objects by means of message passing.
Reference: [2] <author> Gul Agha. </author> <title> Concurrent Object-Oriented Programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 125-141, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Our goal is to succinctly define constraints and their effects on the objects they constrain. Section 4 provides the formal definitions. Finally, in Section 5 we discuss implementation. 3 Specification of interaction constraints In the Actor model <ref> [1, 2, 4] </ref> distributed computing entities (hardware or software) are modeled as abstract self-contained objects called actors. An actor encapsulates a state, provides a set of public methods, and potentially invokes public methods in other objects by means of message passing.
Reference: [3] <author> Gul Agha. </author> <title> Modeling Concurrent Systems: Actors, Nets, and the Problem of Abstraction and Composition. </title> <booktitle> In 17th International Conference on Application and Theory of Petri Nets, </booktitle> <address> Osaka, Japan, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: When an actor executed a become it created a new anonymous actor to carry out the rest of its computation, and prepared itself to receive a new message. Thus, in the classic model, actors were multi-threaded, and tended to be extremely fine-grained. In recent literature <ref> [3] </ref>, the simpler ready has replaced become, with essentially no loss of expressiveness. In addition we have, due to brevity, omitted the semantic definition of dynamic actor creation. 14 tracking the values of the state-variables, and b is the remainder of the actor's behavior.
Reference: [4] <author> Gul Agha, Ian A. Mason, Scott F. Smith, and Carolyn L. Talcott. </author> <title> A Foundation for Actor Computation. </title> <journal> Journal of Functional Programming, </journal> <note> page 68pp, To be published. </note>
Reference-contexts: Our goal is to succinctly define constraints and their effects on the objects they constrain. Section 4 provides the formal definitions. Finally, in Section 5 we discuss implementation. 3 Specification of interaction constraints In the Actor model <ref> [1, 2, 4] </ref> distributed computing entities (hardware or software) are modeled as abstract self-contained objects called actors. An actor encapsulates a state, provides a set of public methods, and potentially invokes public methods in other objects by means of message passing. <p> This defines how the state of the actor system changes when a primitive operation is performed, thus giving an abstract interpretation. The actor semantics presented here is inspired by the work of Agha et. al. <ref> [4] </ref> where additional information can be found, but ours is imperative in style, whereas that is applicative. Our semantic model abstracts away the notion of methods. Instead, each actor has a single behavior|a sequence of statements|which it applies to every incoming message.
Reference: [5] <author> Mehmet Aksit, Jan Bosch, William van der Sterren, and Lodewijk Bergmans. </author> <title> Real-Time Specification Inheritance Anomalies and Real-Time Filters. </title> <booktitle> In Proceedings ECOOP, </booktitle> <pages> pages 386-407, </pages> <year> 1994. </year>
Reference-contexts: Our work is a continuation of this line of research where we have emphasized real-time 24 systems and a formal treatment of the model. Related work that permit separate specification of real-time and synchronization constraints for an object oriented language is <ref> [5] </ref> which proposes the composition filter model. Real-time input and output filters declared in an extended interface enable the specification of time bounds on method executions. Among many, one difference is that RT-Synchronizers takes a global view of a collection of objects rather than of a single object.
Reference: [6] <author> Rajeev Alur, Costas Courcoubetis, and David Dill. </author> <title> Model-checking for real-time systems. </title> <booktitle> In Proceedings of the Fifth IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 414-425, </pages> <year> 1990. </year>
Reference-contexts: Our approach to defining the semantics is inspired by recent research in formal specification languages for real-time systems, and the use of timed transition systems are borrowed from these languages. Often, the languages take the form of extended automata (Timed automata <ref> [6] </ref>, Timed Graphs [6, 17]), or process algebras such as Timed CSP [25]. A different approach is to include a model of the underlying execution resources. This approach is taken in [21] and [28]. <p> Our approach to defining the semantics is inspired by recent research in formal specification languages for real-time systems, and the use of timed transition systems are borrowed from these languages. Often, the languages take the form of extended automata (Timed automata [6], Timed Graphs <ref> [6, 17] </ref>), or process algebras such as Timed CSP [25]. A different approach is to include a model of the underlying execution resources. This approach is taken in [21] and [28].
Reference: [7] <author> Philip A. Bernstein. </author> <title> Middleware | A Model for Distribuited System Services. </title> <journal> Communications of the ACM, </journal> <volume> 39(2) </volume> <pages> 86-98, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: In the light of more-stringent development requirements the priority should be shifted towards building modular and reusable components, which can be used in many applications. The components must then be integrated to form an application. Often middleware services (general purpose services located between platforms and applications <ref> [7] </ref>) can help significantly in this process. However, reusing real-time components is often problematic because application specific time and synchronization constraints are embedded in the internals of these com 2 ponents. This tight coupling makes components interdependent, and consequently unlikely to be reusable in other systems.
Reference: [8] <author> Gregory Cooper, Lisa Cingiser DiPippo, Levon Esibov, Roman Ginis, Russel Johnston, Peter Kortman, Peter Krupp, John Mauer, Michael Squadrito, Bha 27 vani Thuraisingham, Steven Wohlever, and Victor Fay Wolfe. </author> <title> Real-Time CORBA Development at MITRE, </title> <editor> NRaD, Tro-Pacific and URI. </editor> <booktitle> In Proceedings of IEEE Workshop on Middleware for Distributed Real-time Systems and Services, </booktitle> <pages> pages 69-74. </pages> <publisher> IEEE, </publisher> <address> December 1997. San Francisco, CA, USA. </address>
Reference-contexts: It also contains other communication services to facilitate building distributed applications. However, current ORBs are ill-suited for real-time systems as they lack 1) interfaces for specifying quality of service, 2) quality of service enforcement, 3) real-time programming facilities, and 4) performance optimizations [22]. The current proposals for real-time CORBA <ref> [22, 8, 9, 14] </ref> uses a quality of service metaphor for specifying real-time constraints. Typically, the interface definition language is extended with QoS-datatypes. In TAO [22] these parameters, which are necessary for guaranteeing schedulability according to rate monotonic scheduling, include worst case execution time, period, and importance. <p> Typically, the interface definition language is extended with QoS-datatypes. In TAO [22] these parameters, which are necessary for guaranteeing schedulability according to rate monotonic scheduling, include worst case execution time, period, and importance. In NRad/URI's proposal <ref> [8] </ref> for a dynamic CORBA, time constraints are specified in a structure containing importance, deadline and period. These specify timebounds on a clients method invocations on a server. Their proposed runtime system uses this information to compute dynamic scheduling and queuing priorities.
Reference: [9] <author> W. Feng, U. Syyid, and J. W.-S. Liu. </author> <title> Providing for an Open, Real-Time CORBA. </title> <booktitle> In Proceedings of IEEE Workshop on Middleware for Distributed Real-time Systems and Services, </booktitle> <pages> pages 75-80. </pages> <publisher> IEEE, </publisher> <address> December 1997. San Francisco, CA, USA. </address>
Reference-contexts: It also contains other communication services to facilitate building distributed applications. However, current ORBs are ill-suited for real-time systems as they lack 1) interfaces for specifying quality of service, 2) quality of service enforcement, 3) real-time programming facilities, and 4) performance optimizations [22]. The current proposals for real-time CORBA <ref> [22, 8, 9, 14] </ref> uses a quality of service metaphor for specifying real-time constraints. Typically, the interface definition language is extended with QoS-datatypes. In TAO [22] these parameters, which are necessary for guaranteeing schedulability according to rate monotonic scheduling, include worst case execution time, period, and importance.
Reference: [10] <author> Svend Frolund. </author> <title> Constraint-Based Synchronization of Distributed Activities. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana Cham-paign, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: Through a series of examples we indicated how separate specification is possible. Our operational semantics define exactly what constraints are and what their effect on given set of objects should be. The concept of separating functional behavior and interaction policies for Actors were first proposed by Frolund in <ref> [10] </ref>, but it only constrain the order of operations. Our work is a continuation of this line of research where we have emphasized real-time 24 systems and a formal treatment of the model.
Reference: [11] <author> Richard Gerber and Insup Lee. </author> <title> Communicating Shared Resources: A Model for Distributed Real-Time Systems. </title> <booktitle> In Proc. Real-Time Systems Symposium, </booktitle> <pages> pages 68-78, </pages> <address> Santa Monica, CA, USA, 1989. </address> <publisher> IEEE. </publisher>
Reference-contexts: This approach is taken in [21] and [28]. The resulting semantics includes an abstract model of the execution environment (number of CPU's, scheduler, execution time of assignments etc.). The process algebra Communicating Shared Resources (CSR) has been designed with the explicit purpose of modeling resources <ref> [11, 12] </ref>. A process always runs on some, possibly shared, resource. A set of processes can be mapped to different sets of resources, hence describing different implementations.
Reference: [12] <author> Richard Gerber and Insup Lee. </author> <title> A Layered Approach to Automating the Verification of Real-Time Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(9) </volume> <pages> 768-784, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: This approach is taken in [21] and [28]. The resulting semantics includes an abstract model of the execution environment (number of CPU's, scheduler, execution time of assignments etc.). The process algebra Communicating Shared Resources (CSR) has been designed with the explicit purpose of modeling resources <ref> [11, 12] </ref>. A process always runs on some, possibly shared, resource. A set of processes can be mapped to different sets of resources, hence describing different implementations.
Reference: [13] <institution> Object Management Group. </institution> <note> Realtime CORBA A White Paper Issue 1.0. Technical Report ORBOS/96-09-01, </note> <institution> Object Management Group, </institution> <month> December </month> <year> 1996. </year>
Reference-contexts: Thus, objects are being controlled by the middleware, rather than objects controlling themselves or each other. In this paper we propose a model to enable such separation. Real-time CORBA (common object request broker architecture) <ref> [13] </ref> is a highly visible research effort where practitioners are shifting towards component-based real-time systems. An object request broker can be viewed as middleware facilitating transparent client-server communication in a heterogeneous distributed system. It also contains other communication services to facilitate building distributed applications.
Reference: [14] <author> V. Kalogeraki, P.M. Melliar-Smith, and L.E. Moser. </author> <title> Soft Real-Time Resource Management in CORBA Distributed Systems. </title> <booktitle> In Proceedings of IEEE Workshop on Middleware for Distributed Real-time Systems and Services, </booktitle> <pages> pages 46-51. </pages> <publisher> IEEE, </publisher> <address> December 1997. San Francisco, CA, USA. </address>
Reference-contexts: It also contains other communication services to facilitate building distributed applications. However, current ORBs are ill-suited for real-time systems as they lack 1) interfaces for specifying quality of service, 2) quality of service enforcement, 3) real-time programming facilities, and 4) performance optimizations [22]. The current proposals for real-time CORBA <ref> [22, 8, 9, 14] </ref> uses a quality of service metaphor for specifying real-time constraints. Typically, the interface definition language is extended with QoS-datatypes. In TAO [22] these parameters, which are necessary for guaranteeing schedulability according to rate monotonic scheduling, include worst case execution time, period, and importance. <p> In NRad/URI's proposal [8] for a dynamic CORBA, time constraints are specified in a structure containing importance, deadline and period. These specify timebounds on a clients method invocations on a server. Their proposed runtime system uses this information to compute dynamic scheduling and queuing priorities. The Realize proposal <ref> [14] </ref> associates deadline, reliability, and importance attributes to application tasks, where a task is defined as a sequence of method invocations between an external input and the generation of an external result. That is, deadlines in Realize are true end-to-end deadlines.
Reference: [15] <author> Don Kiely. </author> <title> Are Components the Future of Software. </title> <journal> IEEE Computer, </journal> <volume> 32(2) </volume> <pages> 10-11, </pages> <month> February </month> <year> 1998. </year>
Reference: [16] <author> Brian Kirk, Lebero Nigro, and Francesco Pupo. </author> <title> Using Real Time Constraints for Modularisation. </title> <booktitle> In Joint Modular Language Conference, </booktitle> <address> March 1997. Linz. </address> <month> 28 </month>
Reference-contexts: It can generate code (similar to remote-procedure-call stubs) which can be linked with the objects. This code implements the time constraints by manipulating timers, setting priorities and/or instructing the scheduler about method 23 call deadlines etc. A recent result is <ref> [16] </ref> where certain aspects of RT-Synchronizers are implemented in their DART framework where constraints are used to dynamically instruct the sched-uler about delays and deadlines of messages. However the paper gives no systematic (automatic) translation of of constraints to scheduling information.
Reference: [17] <author> Xavier Nicollin, Joseph Sifakis, and Sergio Yovine. </author> <title> Compiling Real-Time Speci--fications into Extended Automata. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(9) </volume> <pages> 805-816, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: The idea is that system execution can be observed by alternatingly observing a set instantaneous transitions and observing a delay. In <ref> [17] </ref> this idea was termed the two-phase functioning principle: System state evolves alternatingly by performing a sequence of instantaneous actions and by letting time pass. By adding the rule: ffff "(d) ! ff j ffff , we extend the ! transition relation with the ability of letting time pass. <p> Our approach to defining the semantics is inspired by recent research in formal specification languages for real-time systems, and the use of timed transition systems are borrowed from these languages. Often, the languages take the form of extended automata (Timed automata [6], Timed Graphs <ref> [6, 17] </ref>), or process algebras such as Timed CSP [25]. A different approach is to include a model of the underlying execution resources. This approach is taken in [21] and [28].
Reference: [18] <author> Shangping Ren. </author> <title> An Actor-Based Framework for Real-Time Coordination. </title> <type> PhD thesis, </type> <institution> Department Computer Science. University of Illinois at Urbana-Champaign, </institution> <year> 1997. </year> <type> PhD. Thesis. </type>
Reference-contexts: An actual language implementation may not always be able to give this guarantee, neither statically nor dynamically, due to the computational complexity of finding feasible schedules for general constraints. Conflicting constraints that have no solutions should be detected as part of the compilers static program check. Ren <ref> [18] </ref> showed how RT-Synchronizers -constraints can be mapped to linear inequality systems for which polynomial time algorithms exist for detecting solvability. <p> We propose to let the compiler compute a conservative version of the call graph annotated with worst case execution time and message propagation delays, and include a copy of it at runtime <ref> [18] </ref>. The runtime system then has the information necessary to propagate constraints automatically, when this cannot be done statically by the compiler. Also, we expect that in many cases, the compiler would be able to compile away synchronizers entirely.
Reference: [19] <author> Shangping Ren and Gul Agha. RT-Synchronizer: </author> <title> Language Support for Real-Time Specifications in Distributed Systems. </title> <journal> ACM Sigplan Notices, </journal> <volume> 30(11), </volume> <month> November </month> <year> 1995. </year> <booktitle> Proceedings of the ACM Sigplan 1995 Workshop on Languages, Compilers, and Tools for Real-Time Systems. </booktitle>
Reference: [20] <author> M. Saksena, P. Freedman, and P. Rodziewicz. </author> <title> Guidelines for Automated Implementation of Executable Object Oriented Models for Real-Time Embedded Control Software. </title> <booktitle> In 18th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 240-251. </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1997. </year>
Reference-contexts: No formal treatment of composition filters appears to be available in the computer science literature. The Real-time Object-Oriented Modeling method (ROOM) [26], which has many notions in common with the actor-model, has recently been extended with notions for specifying real-time properties <ref> [20] </ref>: Message sequence charts with annotated timing information can be used to express activation periods of methods or end-to-end deadlines on sequences of message invocations. With these two kinds of constraints and a few design guidelines the authors show how scheduling theory can be applied to ROOM-models.
Reference: [21] <author> Ichiro Satoh and Mario Tokoro. </author> <title> Semantics for a Real-Time Object-Oriented Programming Language. </title> <booktitle> In Int. Conf. on Computer Languages, </booktitle> <pages> pages 159-170, </pages> <address> Toulouse, France, 1994. </address> <publisher> IEEE. </publisher>
Reference-contexts: Often, the languages take the form of extended automata (Timed automata [6], Timed Graphs [6, 17]), or process algebras such as Timed CSP [25]. A different approach is to include a model of the underlying execution resources. This approach is taken in <ref> [21] </ref> and [28]. The resulting semantics includes an abstract model of the execution environment (number of CPU's, scheduler, execution time of assignments etc.). The process algebra Communicating Shared Resources (CSR) has been designed with the explicit purpose of modeling resources [11, 12].
Reference: [22] <author> Douglas C. Schmidt, Rajeev Bector, and David L. Levine. </author> <title> An ORB Endsystem Architecture for Statically Scheduled Real-time Applications. </title> <booktitle> In Proceedings of IEEE Workshop on Middleware for Distributed Real-time Systems and Services, </booktitle> <pages> pages 52-60. </pages> <publisher> IEEE, </publisher> <address> December 1997. San Francisco, CA, USA. </address>
Reference-contexts: It also contains other communication services to facilitate building distributed applications. However, current ORBs are ill-suited for real-time systems as they lack 1) interfaces for specifying quality of service, 2) quality of service enforcement, 3) real-time programming facilities, and 4) performance optimizations <ref> [22] </ref>. The current proposals for real-time CORBA [22, 8, 9, 14] uses a quality of service metaphor for specifying real-time constraints. Typically, the interface definition language is extended with QoS-datatypes. In TAO [22] these parameters, which are necessary for guaranteeing schedulability according to rate monotonic scheduling, include worst case execution time, <p> It also contains other communication services to facilitate building distributed applications. However, current ORBs are ill-suited for real-time systems as they lack 1) interfaces for specifying quality of service, 2) quality of service enforcement, 3) real-time programming facilities, and 4) performance optimizations [22]. The current proposals for real-time CORBA <ref> [22, 8, 9, 14] </ref> uses a quality of service metaphor for specifying real-time constraints. Typically, the interface definition language is extended with QoS-datatypes. In TAO [22] these parameters, which are necessary for guaranteeing schedulability according to rate monotonic scheduling, include worst case execution time, period, and importance. <p> for specifying quality of service, 2) quality of service enforcement, 3) real-time programming facilities, and 4) performance optimizations <ref> [22] </ref>. The current proposals for real-time CORBA [22, 8, 9, 14] uses a quality of service metaphor for specifying real-time constraints. Typically, the interface definition language is extended with QoS-datatypes. In TAO [22] these parameters, which are necessary for guaranteeing schedulability according to rate monotonic scheduling, include worst case execution time, period, and importance. In NRad/URI's proposal [8] for a dynamic CORBA, time constraints are specified in a structure containing importance, deadline and period.
Reference: [23] <author> Douglas C. Schmidt and Mohamed E. Fayad. </author> <title> Lessons Learned Building Reusable OO Frameworks for Distributed Software. </title> <journal> Communications of the ACM, </journal> <volume> 40(10) </volume> <pages> 85-87, </pages> <month> October </month> <year> 1997. </year>
Reference: [24] <author> Douglas C. Schmidt and Mohamed E. Fayad. </author> <title> Object-Oriented Application Frameworks. </title> <journal> Communications of the ACM, </journal> <volume> 40(10) </volume> <pages> 32-38, </pages> <month> October </month> <year> 1997. </year>
Reference: [25] <author> Steve Schneider. </author> <title> An Operational Semantics for Timed CSP. </title> <journal> Information and Computation, </journal> <volume> 116 </volume> <pages> 193-213, </pages> <year> 1995. </year> <month> 29 </month>
Reference-contexts: Often, the languages take the form of extended automata (Timed automata [6], Timed Graphs [6, 17]), or process algebras such as Timed CSP <ref> [25] </ref>. A different approach is to include a model of the underlying execution resources. This approach is taken in [21] and [28]. The resulting semantics includes an abstract model of the execution environment (number of CPU's, scheduler, execution time of assignments etc.).
Reference: [26] <author> Bran Selic, Garth Gullekson, and Paul T. Ward. </author> <title> Real-time Object-oriented Mod--eling. </title> <publisher> Wiley Professional Computing. John Wiley & Sons, Inc., </publisher> <address> New York, </address> <year> 1994. </year> <note> ISBN 0-471-59917-4. </note>
Reference-contexts: Among many, one difference is that RT-Synchronizers takes a global view of a collection of objects rather than of a single object. No formal treatment of composition filters appears to be available in the computer science literature. The Real-time Object-Oriented Modeling method (ROOM) <ref> [26] </ref>, which has many notions in common with the actor-model, has recently been extended with notions for specifying real-time properties [20]: Message sequence charts with annotated timing information can be used to express activation periods of methods or end-to-end deadlines on sequences of message invocations.
Reference: [27] <author> Lua Sha, Ragunathan Rajkumar, and Shirish S. Sathaye. </author> <title> Generalized Rate-Monotonic Scheduling Theory: A Framework for Developing Real-Time Systems. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 82(1) </volume> <pages> 68-82, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Additionally, a full verification of the implemented system is rarely practical. To make schedulability analysis practical one often restricts the types of constraints to periodic constraints. Similar restrictions can be made to RT-Synchronizers . With 22 simple dependencies between periodic tasks generalized rate-monotonic analysis can be utilized <ref> [27] </ref>. Constraint directed scheduling is an implementation technique that dynamically uses the information of the fired constraints in the synchronizers to assign deadline and release times to messages, see Figure 16. Synchronizer objects are thus maintained at run time as data-objects, whose state can be inspected by the scheduler.
Reference: [28] <author> P. Zhou and J. Hooman. </author> <title> A Proof Theory for Asynchronously Communicating Real-Time Systems. </title> <booktitle> In Proc. Real-Time Systems Symposium, </booktitle> <pages> pages 177-186, </pages> <address> Phoenix, AZ, USA, </address> <year> 1992. </year> <journal> IEEE. </journal> <volume> 30 </volume>
Reference-contexts: Often, the languages take the form of extended automata (Timed automata [6], Timed Graphs [6, 17]), or process algebras such as Timed CSP [25]. A different approach is to include a model of the underlying execution resources. This approach is taken in [21] and <ref> [28] </ref>. The resulting semantics includes an abstract model of the execution environment (number of CPU's, scheduler, execution time of assignments etc.). The process algebra Communicating Shared Resources (CSR) has been designed with the explicit purpose of modeling resources [11, 12]. A process always runs on some, possibly shared, resource.
References-found: 28

