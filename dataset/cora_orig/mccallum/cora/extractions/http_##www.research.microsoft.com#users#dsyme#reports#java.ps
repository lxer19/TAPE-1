URL: http://www.research.microsoft.com/users/dsyme/reports/java.ps
Refering-URL: http://www.research.microsoft.com/users/dsyme/publications.html
Root-URL: http://www.research.microsoft.com
Email: email: drs1004@cl.cam.ac.uk  
Title: Proving Java Type Soundness  
Author: Don Syme 
Note: Contents  
Date: June 17, 1997  
Abstract: This technical report describes a machine checked proof of the type soundness of a subset of the Java language called Java S . A formal semantics for this subset has been developed by Drossopoulou and Eisenbach, and they have sketched an outline of the type soundness proof. The formulation developed here complements their written semantics and proof by correcting and clarifying significant details; and it demonstrates the utility of formal, machine checking when exploring a large and detailed proof based on operational semantics. The development also serves as a case study in the application of `declarative' proof techniques to a major property of an operational system. 
Abstract-found: 1
Intro-found: 1
Reference: [CM92] <author> J. Camilleri and T.F Melham. </author> <title> Reasoning with inductively defined relations in the HOL theorem prover. </title> <type> Technical Report 265, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: Inductive relations are formulated by specifying a set of rules, and giving a name to each. When treated as a logical specification, DECLARE generates the appropriate axioms for the least fixed point of the set of rules (these axioms could be derived conservatively by well-known techniques <ref> [CM92, Pau94] </ref>).
Reference: [Coh97] <author> Richard Cohen. </author> <title> Defensive Java Virtual Machine, </title> <note> version 0.5 alpha release, June 1997. Published on the WWW at http://www.cli.com/software/djvm. </note>
Reference-contexts: Isabelle is a mature system and has complementary strengths to DECLARE, notably strong generic automation and manifest soundness. A tool which unites these based on such concrete experience is an exciting prospect. Computational Logic, Inc. have released a formal model of a subset of the Java Virtual Machine (JVM) <ref> [Coh97] </ref>. The model is called the `defensive' JVM (or dJVM) because it includes sufficient run-time checks to assure type-safe execution (or at least to detect and prevent any unsafe execution). In the standard JVM these checks are not present.
Reference: [DE97a] <author> Sophia Drossopolou and Susan Eisenbach. </author> <title> Is the Java type system sound? June 1997. </title> <note> Submitted to special edition of Theory and Practive of Object Systems. </note>
Reference-contexts: We are grateful to Drossopoulou and Eisenbach for the opportunity to discuss these points, and they have incorporated many suggestions into their latest version <ref> [DE97a] </ref>. 2.1 Syntax of Java S Java S programs consist of a sequence of classes (see Figure 2). Each class has a name, a super-class, a set of super-interfaces, a sequence of field declarations and a sequence of method bodies. Fields have a name and a type.
Reference: [DE97b] <author> Sophia Drossopolou and Susan Eisenbach. </author> <title> Java is type safe probably. </title> <booktitle> In 11th European Conference on Object Oriented Programming. </booktitle> <month> June </month> <year> 1997. </year> <note> To be published. </note>
Reference-contexts: Finally we summarize and discuss related work in Section 9. 2 The Semantics of Java S In this section we present an operational semantics for Java S , based heavily on that developed by Drossopoulou and Eisenbach in version 2.01 of their paper <ref> [DE97b] </ref>. The specification we present is the result of several iterations through the waterfall model of formal development that we will outline in the next section. The description of the semantics will necessarily be brief in places: for more details consult [DE97b]. <p> Drossopoulou and Eisenbach in version 2.01 of their paper <ref> [DE97b] </ref>. The specification we present is the result of several iterations through the waterfall model of formal development that we will outline in the next section. The description of the semantics will necessarily be brief in places: for more details consult [DE97b]. We define: * A subset of Java containing the features listed in Section 1.1; * A small-step term rewriting system to describe the dynamic execution of Java S programs; * A type inference system to describe compile-time type checking. <p> To be well formed (` TE 3 tyenv ), every class declaration in an environment must satisfy the following constraints, based on those in <ref> [DE97b] </ref>: * The class Object must be defined and have no superclass, superinterfaces or fields. * Its superclass and implemented interfaces must be defined and no circularities can occur in the hierarchy; * No two methods can have the same name and argument types (ensured by construction); * Any methods that <p> : type The typing rule for method calls in the unannotated language are: ` obj : C ` MostSpec (C; m; at) = f (at 0 ! rt)g ` obj:m (arg 1 ; : : : ; arg n ) : rt The definition of MostSpec can be found in <ref> [DE97b] </ref>: it determines the set of `most special' applicable methods given the static types of the arguments. Only one such method should exist, otherwise a typing error occurs. Note that the resolution of methods based on static argument types means that unique typing is essential in Java. <p> We omit the rules for field dereferencing, variable lookup, class creation, field assignment, local variable assignment and conditionals as they are straight forward and are covered in <ref> [DE97b] </ref>. <p> The definitions are a corrected version of those found in <ref> [DE97b] </ref>. <p> The reader should keep in mind that when this proof was begun, the only guide available was the rough proof outline in <ref> [DE97b] </ref>, and this was based on a formulation of the problem that was subsequently found to be flawed. Thus the process is very much one of proof discovery rather than proof transcription.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: This process is described in detail in <ref> [GJS96] </ref> 4 . 2.3.4 Runtime typechecking Java performs runtime typechecks at just two places: during array assignment, and when casting reference values. Runtime typechecking is needed for array assignment because of the well-known problem with a covariant array typing rule. Casts are not covered in this report. <p> Validity is a harder question: we have to measure this against the Java language standard <ref> [GJS96] </ref>, in addition to our own understanding of the meaning of constructs in the subset. We use three techniques to validate the specification: 1. Eye-balling; 2. Type checking of higher order logic; 3. <p> There is no analogue of the class Object for interfaces; that is, while every class is an extension of class Object, there is no single interface of which all interfaces are extensions. <ref> [GJS96] </ref>, pages 87 and 185 9 Summary This report has presented corrections to the semantics of Java S , a machine formalization of this semantics, a technique to partially validate the semantics, and an example of the use of new mechanized proof techniques to prove the type soundness property for that
Reference: [GM93] <author> M.J.C Gordon and T.F Melham. </author> <title> Introduction to HOL: A Theorem Proving Assistant for Higher Order Logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference: [Har97] <author> John R. Harrison. </author> <title> Proof style. </title> <type> Technical Report 410, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> January </month> <year> 1997. </year> <month> 31 </month>
References-found: 7

