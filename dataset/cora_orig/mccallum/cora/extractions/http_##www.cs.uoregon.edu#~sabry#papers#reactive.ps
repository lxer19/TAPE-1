URL: http://www.cs.uoregon.edu/~sabry/papers/reactive.ps
Refering-URL: http://www.cs.uoregon.edu/~sabry/papers/index.html
Root-URL: http://www.cs.uoregon.edu
Email: f rjmh, pareto, sabry g@cs.chalmers.se  
Title: Proving the Correctness of Reactive Systems Using Sized Types  
Author: John Hughes Lars Pareto Amr Sabry 
Address: 412 96 Goteborg  
Affiliation: Department of Computer Science Chalmers University  
Abstract: We have designed and implemented a type-based analysis for proving some basic properties of reactive systems. The analysis manipulates rich type expressions that contain information about the sizes of recursively defined data structures. Sized types are useful for detecting deadlocks, non-termination, and other errors in embedded programs. To establish the soundness of the analysis we have developed an appropriate semantic model of sized types. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aiken, A. S., and Wimmers, E. L. </author> <title> Type inclusion constraints and type inference. In Functional Programming & Computer Architecture (June 1993), </title> <publisher> ACM Press, </publisher> <pages> pp. 31-41. </pages>
Reference-contexts: Now, if we simplify our constraints before generalisation, we will avoid unnecessary constraint instantiations. This is a good thing as constraint manipulation is costly. Although many polymorphic subtype systems have expression forms for bounded quantification, for example where C where C is a constraint system <ref> [1] </ref>, our type system does not.
Reference: [2] <editor> Broy, M., et al. </editor> <title> The design of distributed systems| an introduction to focus. </title> <type> Tech. Rep. </type> <institution> SFB-Bericht Nr. 342/2-2/92 A, Technische Universitat Munchen, </institution> <year> 1992. </year>
Reference-contexts: 1 Embedded Functional Programs In a reactive system, the control software must continuously react to inputs from the environment. We distinguish a class of systems where the embedded programs can be naturally expressed as functional programs manipulating streams. This class of programs appears to be large enough for many purposes <ref> [2] </ref> and is the core of more expressive formalisms that accommodate asynchronous events, non-determinism, etc. The fundamental criterion for the correctness of programs embedded in reactive systems is liveness. <p> Moreover our analysis can sometimes detect space leaks. Our immediate goal is to use the analysis to reason about realistic reactive systems written in realistic functional languages for real-time programming <ref> [2, 18] </ref>. The analysis is based on a new notion of sized types and its associated semantic model which we expect to be applicable in other contexts such as array bounds checking.
Reference: [3] <author> Cartwright, R. </author> <title> Types as intervals. </title> <type> Tech. Rep. </type> <institution> TR84-5, Rice University, </institution> <year> 1984. </year>
Reference-contexts: is that not all types include ?, which immediately invalidates the standard seman 3 In the definition, we omit the clause for case-expressions as well as the explicit isomorphisms mapping elements of the summands into the universe and vice-versa. 3 tics of types based on ideals [11, 12], or intervals <ref> [3] </ref>. 4 In contrast to these systems, we define the universe of types U T to be the collection of all upward -closed subsets of U. A set T is upward-closed if whenever x 2 T then for every y w x, we have y 2 T .
Reference: [4] <author> Davey, B. A., and Priestley, H. A. </author> <title> Introduction to Lattices and Order. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference: [5] <author> Dijkstra, E. W. </author> <title> On the productivity of recursive definitions. </title> <type> Personal note EWD 749, </type> <institution> University of Texas at Austin, </institution> <year> 1980. </year>
Reference-contexts: In other words, for any natural number i, a request for the first i elements of the stream is guaranteed to be processed in finite time: the program is productive <ref> [5, 17] </ref>. A slight modification of the program to: letrec ones' = Mk 1 (tail ones' ) in ones' is not productive; it cannot compute the first i elements of the stream for any i &gt; 1.
Reference: [6] <author> Hallgren, T., and Carlsson, M. </author> <title> Programming with Fudgets. </title> <booktitle> In Advanced Functional Programming (1995), </booktitle> <editor> J. Jeuring and E. Meijer, Eds., </editor> <publisher> Springer Verlag, LNCS 925, </publisher> <pages> pp. 137-182. </pages>
Reference-contexts: The datatype Sp is the datatype of stream processors from the Fudgets library <ref> [6] </ref>.
Reference: [7] <author> Hudak, P., Peyton Jones, S., and Wadler, P. </author> <title> Report on the programming language Haskell, a non-strict purely functional language (version 1.2). </title> <journal> Sigplan Notices (1992). </journal>
Reference-contexts: Remaining is the bottom check. The 0-instantiated type is List 0 a ! List l+1 a ! List l a for which the bottom check holds as the domain type is empty. 7 Using the Implementation The concrete syntax of our language is similar to the syntax of Haskell <ref> [7] </ref>. To express our richer set of type expressions, we use $ to refer to ! and # to index both data and codata declaration names. 7.1 Modularity As with all type-based analyses, our analysis need not manipulate the entire program at once.
Reference: [8] <author> Huelsbergen, L., Larus, J. R., and Aiken, A. </author> <title> Using the run-time sizes of data structures to guide parallel-thread creation. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1994), </booktitle> <pages> pp. 79-90. </pages>
Reference-contexts: He presents a calculus for proving the productivity of recursive 13 definitions of streams but no automatic analysis. The closest analyses to ours are two recent ones for the estimation of execution times in parallel languages <ref> [8, 14] </ref>. Both our system and Reistad and Gifford's [14] include similar notions of size and subtyping but nevertheless differ significantly regarding our two main technical contributions. First, our system is the only one that includes a semantic interpretation of the sizes and a proof of soundness.
Reference: [9] <author> Kelly, W., et al. </author> <title> The Omega Library (version 0.91): Interface Guide. </title> <institution> University of Maryland at College Park, </institution> <year> 1995. </year>
Reference-contexts: Nothing in our semantic model stops us from using arbitrarily complicated constraint languages. The restriction lies in our abilities to solve the corresponding constraint systems. Our work does not address the problem of constraint solving. Instead, we exploit recent developments in constraint solving technology via the omega calculator <ref> [9, 13] </ref>. The formulation of our constraint systems is to a large extent determined by the capabilities of the omega calculator. <p> Constraint solving The constraint systems emerging from our proofs are linear inequalities on natural numbers. The core of our constraint solving pass is the omega calculator <ref> [9, 13] </ref>, a tool for manipulating Presburger formulas. Given a constraint system of integer linear inequations it solves the system and rejects it if unsolvable. The constraint solving pass has 7 stages: Translation Coercions between types are translated to size constraints using a straightforward implementation of the relation fl.
Reference: [10] <author> Lewerentz, C., and Lindner, T. </author> <title> Formal Development of Reactive Systems: Case Study Production Cell. </title> <booktitle> Lecture Notes in Computer Science 891. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: In contrast the extension to imperative constructs appears to be straightforward. Our system is also related to several approaches for the formal development of reactive systems using synchronous languages, temporal logics, process calculi, etc <ref> [10] </ref>. Our system is distinguished by two major properties: productivity and modularity. Indeed in a recent comparison of 18 formal methods for the development of a simple production cell [10], only 6 or 7 implementors could prove the liveness (productivity) of the production cell and only 3 or 4 used a <p> is also related to several approaches for the formal development of reactive systems using synchronous languages, temporal logics, process calculi, etc <ref> [10] </ref>. Our system is distinguished by two major properties: productivity and modularity. Indeed in a recent comparison of 18 formal methods for the development of a simple production cell [10], only 6 or 7 implementors could prove the liveness (productivity) of the production cell and only 3 or 4 used a modular solution.
Reference: [11] <author> MacQueen, D., Plotkin, G., and Sethi, R. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control 71, </journal> <volume> 1/2 (1986), </volume> <pages> 95-130. </pages>
Reference-contexts: consequence of this property is that not all types include ?, which immediately invalidates the standard seman 3 In the definition, we omit the clause for case-expressions as well as the explicit isomorphisms mapping elements of the summands into the universe and vice-versa. 3 tics of types based on ideals <ref> [11, 12] </ref>, or intervals [3]. 4 In contrast to these systems, we define the universe of types U T to be the collection of all upward -closed subsets of U.
Reference: [12] <author> MacQueen, D., and Sethi, R. </author> <title> A semantic model of types for applicative languages. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1982), </booktitle> <pages> pp. 243-252. </pages>
Reference-contexts: consequence of this property is that not all types include ?, which immediately invalidates the standard seman 3 In the definition, we omit the clause for case-expressions as well as the explicit isomorphisms mapping elements of the summands into the universe and vice-versa. 3 tics of types based on ideals <ref> [11, 12] </ref>, or intervals [3]. 4 In contrast to these systems, we define the universe of types U T to be the collection of all upward -closed subsets of U.
Reference: [13] <author> Pugh, W. </author> <title> The Omega test: A fast and practical integer programming algorithm for dependence analysis. </title> <booktitle> Communications of the ACM 8 (1992), </booktitle> <pages> 102-114. </pages>
Reference-contexts: Nothing in our semantic model stops us from using arbitrarily complicated constraint languages. The restriction lies in our abilities to solve the corresponding constraint systems. Our work does not address the problem of constraint solving. Instead, we exploit recent developments in constraint solving technology via the omega calculator <ref> [9, 13] </ref>. The formulation of our constraint systems is to a large extent determined by the capabilities of the omega calculator. <p> Constraint solving The constraint systems emerging from our proofs are linear inequalities on natural numbers. The core of our constraint solving pass is the omega calculator <ref> [9, 13] </ref>, a tool for manipulating Presburger formulas. Given a constraint system of integer linear inequations it solves the system and rejects it if unsolvable. The constraint solving pass has 7 stages: Translation Coercions between types are translated to size constraints using a straightforward implementation of the relation fl.
Reference: [14] <author> Reidstad, B., and Gifford, D. K. </author> <title> Static dependent costs for estimating execution time. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1994), </booktitle> <pages> pp. 65-78. </pages>
Reference-contexts: He presents a calculus for proving the productivity of recursive 13 definitions of streams but no automatic analysis. The closest analyses to ours are two recent ones for the estimation of execution times in parallel languages <ref> [8, 14] </ref>. Both our system and Reistad and Gifford's [14] include similar notions of size and subtyping but nevertheless differ significantly regarding our two main technical contributions. First, our system is the only one that includes a semantic interpretation of the sizes and a proof of soundness. <p> He presents a calculus for proving the productivity of recursive 13 definitions of streams but no automatic analysis. The closest analyses to ours are two recent ones for the estimation of execution times in parallel languages [8, 14]. Both our system and Reistad and Gifford's <ref> [14] </ref> include similar notions of size and subtyping but nevertheless differ significantly regarding our two main technical contributions. First, our system is the only one that includes a semantic interpretation of the sizes and a proof of soundness. Second, the languages supported by the two systems are different.
Reference: [15] <author> Royer, J. S., and Case, J. </author> <title> Subrecursive Programming Systems: Complexity and Succinctness. </title> <address> Boston: </address> <publisher> Birkhauser, </publisher> <year> 1994. </year>
Reference-contexts: On the mathematical side, our approximations to sizes of recursive data structures are apparently related to some hierarchies of recursive functions <ref> [15] </ref> though the connection is not evident at this point. 9 Conclusion We have designed and implemented an analysis that guarantees termination and liveness of embedded functional programs. Moreover our analysis can sometimes detect space leaks.
Reference: [16] <author> Scott, D. </author> <title> Data types as lattices. </title> <journal> SIAM Journal on Computing 5, </journal> <volume> 3 (1976), </volume> <pages> 522-587. </pages>
Reference-contexts: The functionals are easily derivable from the declarations using a function D whose definition is omitted. D Nat = F n D Sp T 1 T 2 = F p 4 Semantic models based on retracts <ref> [16] </ref> are not appropriate for another reason; they do not support the form of implicit polymorphism common in the programming languages that we are using. where: F n (T ) = fZerog + (fSuccg fi T ) F s (T ) = fMkg fi Nat fi T F p (T )
Reference: [17] <author> Sijtsma, B. </author> <title> On the productivity of recursive list definitions. </title> <journal> ACM Transactions on Programming Languages and Systems 11, </journal> <volume> 4 (1989), </volume> <pages> 633-649. </pages>
Reference-contexts: In other words, for any natural number i, a request for the first i elements of the stream is guaranteed to be processed in finite time: the program is productive <ref> [5, 17] </ref>. A slight modification of the program to: letrec ones' = Mk 1 (tail ones' ) in ones' is not productive; it cannot compute the first i elements of the stream for any i &gt; 1. <p> Finally the program will not work unless the environment supplies at least three elements of the input stream. 8 Related Work The formal notion of productivity is due to Sijtsma <ref> [17] </ref>. He presents a calculus for proving the productivity of recursive 13 definitions of streams but no automatic analysis. The closest analyses to ours are two recent ones for the estimation of execution times in parallel languages [8, 14].
Reference: [18] <author> Truv e, S. </author> <title> A new H for real-time programming. </title> <type> Unpublished Manuscript, </type> <year> 1995. </year> <month> 14 </month>
Reference-contexts: Moreover our analysis can sometimes detect space leaks. Our immediate goal is to use the analysis to reason about realistic reactive systems written in realistic functional languages for real-time programming <ref> [2, 18] </ref>. The analysis is based on a new notion of sized types and its associated semantic model which we expect to be applicable in other contexts such as array bounds checking.
References-found: 18

