URL: http://ftp.eecs.umich.edu/people/vbl/CSE-TR-176-93.ps.Z
Refering-URL: http://ftp.eecs.umich.edu/people/vbl/
Root-URL: http://www.eecs.umich.edu
Phone: (313) 763-0391  
Title: Semaphore Queue Priority Assignment for Real-Time Multiprocessor Synchronization  
Author: Victor B. Lortz Kang G. Shin 
Keyword: real-time scheduling, priority assignment, multiprocessor synchronization, con currency control  
Date: September 21, 1993  
Note: fvbl,kgshing@eecs.umich.edu  
Abstract: Technical Report CSE-TR-176-93 Real-Time Computing Laboratory Computer Science and Engineering Division Department of Electrical Engineering and Computer Science The University of Michigan Ann Arbor, Michigan 48109-2122 ABSTRACT Prior work on real-time multiprocessor synchronization minimizes the blocking of high-priority tasks at the expense of lower-priority tasks. In this paper, we show that substantial improvement in real-time multiprocessor schedulability can be achieved if global semaphore queue priorities are explicitly assigned according to the blocking tolerance (the maximum amount of blocking a task can tolerate without missing its deadline) rather than according to task execution priorities or simple FIFO policy. We also prove that this priority assignment problem is NP-complete and present a heuristic bin packing algorithm that finds a good solution for most task sets. Furthermore, our experiments suggest that if a fixed priority assignment strategy is used, it is usually better to use a FIFO (all priorities equal) rather than task execution priorities. This surprising result underscores some of the differences between multiprocessor and uniprocessor real-time synchronization. The work reported in this paper was supported in part by the Office of Naval Research under Grant N00014-92-J-1080 and by the National Science Foundation under Grant MIP-9203895. Any opinions, findings, and conclusions or recommendations expressed in this paper are those of the authors and do not necessarily reflect the view of the funding agencies. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Baker, </author> <title> "A stack-based resource allocation policy for real-time processes," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 191-200, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Given such a bound, traditional scheduling strategies such as rate monotonic scheduling or earliest deadline scheduling can be used to guarantee task deadlines <ref> [1, 9] </ref>. The most common approach to bounding semaphore wait times is to use variants of 1 the priority inheritance protocol (e.g., basic priority inheritance, priority ceiling protocol, semaphore control protocol, kernel priority protocol [8]) to limit wait times due to lower-priority tasks [3, 7, 9, 10].
Reference: [2] <author> M. R. Garey and D. S. Johnson, </author> <title> Computer and intractability: A guide to the theory of NP-completeness, </title> <publisher> Freeman, </publisher> <address> San Francisco, </address> <year> 1979. </year>
Reference-contexts: Checking whether task deadlines are guaranteed can be performed in polynomial time by calculating the blocking factors for each task o i using fP i;S g, as described in Section 3, and applying Eq. (2.1) or critical zone analysis. We now show that SQPA-RMS is NP-hard by reducing PARTITION <ref> [2] </ref> to an instance of SQPA-RMS. Suppose that we have a multiprocessor with 3 processors. Processor -1 will be assigned a task that uses all n global semaphores but has a low utilization so that it can always tolerate the lowest semaphore queue priority (priority 1). <p> In reality, one often needs to solve both problems: first task allocation and then semaphore queue priority assignment. Since the problem of allocating tasks to processors on a multiprocessor is known to be NP-complete <ref> [2] </ref> even when no resource sharing (other than processors) is considered, there is no computationally efficient solution for this problem (unless P=NP). The potential for blocking on semaphore queues adds another level of complexity to an 10 already very difficult problem.
Reference: [3] <author> Y. Ishikawa, H. Tokuda, and C. W. Mercer, </author> <title> "An object-oriented real-time programming language," </title> <journal> IEEE Computer, </journal> <volume> vol. 25, no. 10, </volume> <pages> pp. 66-73, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The most common approach to bounding semaphore wait times is to use variants of 1 the priority inheritance protocol (e.g., basic priority inheritance, priority ceiling protocol, semaphore control protocol, kernel priority protocol [8]) to limit wait times due to lower-priority tasks <ref> [3, 7, 9, 10] </ref>. These protocols temporarily boost the priorities of tasks that are executing critical sections to ensure that they can complete the critical sections within a short, predictable time. This in turn bounds the blocking delays of other tasks that wait for the resources. <p> These task sets were generated in groups of 50 sets for each combination of <ref> [3, 6, or 10 processors] </ref>, [3, 6 or 10 tasks per processor], [5, 10, or 20 global semaphores], [processor utilizations of 0.6 or 0.7], and [constant or varying critical section times for semaphores]. <p> These task sets were generated in groups of 50 sets for each combination of [3, 6, or 10 processors], <ref> [3, 6 or 10 tasks per processor] </ref>, [5, 10, or 20 global semaphores], [processor utilizations of 0.6 or 0.7], and [constant or varying critical section times for semaphores].
Reference: [4] <author> J. P. Lehoczky, L. Sha, and J. K. Strosnider, </author> <title> "Enhanced aperiodic responsiveness in hard real-time environments," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 261-270, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: A job corresponds to a sequence of instructions that would continuously use the processor until the job finishes if the job were running alone on the processor. Aperiodic tasks can be accommodated within this framework through use of a periodic server <ref> [4] </ref>. In general, deadline-driven scheduling protocols, which determine execution priorities dynamically, can guarantee higher utilizations than rate monotonic scheduling. However, dynamic priority algorithms are more complex to implement and less stable under overload conditions.
Reference: [5] <author> C. L. Liu and J. W. Layland, </author> <title> "Scheduling algorithms for multiprogramming in a hard real-time environment," </title> <journal> Journal of the ACM, </journal> <volume> vol. 20, no. 1, </volume> <pages> pp. 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: We also prove that this priority assignment problem is NP-complete and present a heuristic bin packing algorithm that finds a good solution for most task sets. Early work on scheduling hard real-time systems assumed independence between the tasks to be scheduled <ref> [5] </ref>. However, most real-time systems require inter-task data sharing that violates the independence assumption of early scheduling algorithms. Furthermore, Mok [6] showed that if tasks make unrestricted use of binary semaphores to enforce mutually exclusive access to shared resources, the problem of determining their schedulability is NP-complete. <p> The C i =T i components represent the utilization, or fraction of computation time consumed by task o i . The number i (2 1=i 1) represents a bound on the utilization of the processor below which task deadlines are guaranteed <ref> [5] </ref>. As the number of tasks increases, this bound converges to ln 2, or about 70% utilization. This utilization bound provides only a sufficient condition for schedulability; for most task sets, a more complex method called "critical zone analysis" is able to guarantee higher utilizations with rate monotonic scheduling. <p> These task sets were generated in groups of 50 sets for each combination of [3, 6, or 10 processors], [3, 6 or 10 tasks per processor], <ref> [5, 10, or 20 global semaphores] </ref>, [processor utilizations of 0.6 or 0.7], and [constant or varying critical section times for semaphores]. For our schedulability analysis, we used critical zone analysis rather than Eq. (2.1) because it is a more accurate method for determining schedulability.
Reference: [6] <author> A. K. Mok, </author> <title> "Fundamental design problems of distributed systems for the hard real-time environment," </title> <type> Ph.D thesis, </type> <year> 1983. </year>
Reference-contexts: Early work on scheduling hard real-time systems assumed independence between the tasks to be scheduled [5]. However, most real-time systems require inter-task data sharing that violates the independence assumption of early scheduling algorithms. Furthermore, Mok <ref> [6] </ref> showed that if tasks make unrestricted use of binary semaphores to enforce mutually exclusive access to shared resources, the problem of determining their schedulability is NP-complete. This is because unrestricted semaphore use can force a high-priority task to wait while a low-priority task holds the lock on a resource. <p> These task sets were generated in groups of 50 sets for each combination of <ref> [3, 6, or 10 processors] </ref>, [3, 6 or 10 tasks per processor], [5, 10, or 20 global semaphores], [processor utilizations of 0.6 or 0.7], and [constant or varying critical section times for semaphores].
Reference: [7] <author> R. Rajkumar, </author> <title> "Real-time synchronization protocols for shared memory multiprocessors," </title> <booktitle> in Proc. Int'l Conf. on Distributed Computing Systems, </booktitle> <pages> pp. 116-123, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Prior work on real-time multiprocessor synchronization minimizes the global blocking of high-priority tasks at the expense of lower-priority tasks <ref> [7, 9] </ref>. Global blocking in a multiprocessor system is blocking on semaphores that are shared across processor boundaries. In this paper, we examine the relationship between global semaphore queue wait times and the schedulability of periodic tasks using rate monotonic scheduling on multiprocessors. <p> The most common approach to bounding semaphore wait times is to use variants of 1 the priority inheritance protocol (e.g., basic priority inheritance, priority ceiling protocol, semaphore control protocol, kernel priority protocol [8]) to limit wait times due to lower-priority tasks <ref> [3, 7, 9, 10] </ref>. These protocols temporarily boost the priorities of tasks that are executing critical sections to ensure that they can complete the critical sections within a short, predictable time. This in turn bounds the blocking delays of other tasks that wait for the resources. <p> The priority ceiling protocol and the semaphore control protocol further bound blocking delays and avoid deadlocks by preventing tasks from attempting to acquire semaphores under certain conditions. These "real-time" synchronization protocols were first developed for uniprocessors and then extended to multiprocessors <ref> [7, 9, 10] </ref>. Some uniprocessor protocols, such as the priority ceiling protocol, do not use explicit semaphore queues. However, real-time multiprocessor synchronization requires queues for the global semaphores. In multiprocessors, the blocking delays also depend on the distribution of tasks that share semaphores across processor boundaries. <p> By allocating blocking delays in this way, it is possible to improve the overall schedulability of the system. Now let us consider the RMSS semaphore queue priority assignment proposed in <ref> [7, 9] </ref>. As we have seen, lower-priority tasks can be less tolerant of blocking delays than higher-priority tasks. If task execution priorities are used for semaphore queues, as much blocking as possible is assigned to the lower-priority tasks. <p> If T max is bounded, the algorithm is essentially O (k lg k). Otherwise, it is quadratic in T max . In either case, this is a relatively efficient algorithm. Now, consider the priority assignment method of <ref> [7, 9] </ref>: assign lowest semaphore queue priorities to the lowest-priority tasks. This is a constant time algorithm, but it is essentially a bin packing strategy in which the largest k items are assigned to a predetermined set of bins, which could be the smallest bins. <p> If this priority assignment overflows a bin's capacity, the algorithm returns failure. Clearly, the bin packing algorithm we propose should perform much better than the method used in <ref> [7, 9] </ref>. By performing better, we mean that given some population of task sets, more will be schedulable with our algorithm. To verify this claim, we have implemented our algorithm and conducted extensive experiments comparing our approach with the previous approach and with simple FIFO queues.
Reference: [8] <author> R. Rajkumar, </author> <title> SYNCHRONIZATION IN REAL-TIME SYSTEMS A Priority Inheritance Approach, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year> <month> 22 </month>
Reference-contexts: The most common approach to bounding semaphore wait times is to use variants of 1 the priority inheritance protocol (e.g., basic priority inheritance, priority ceiling protocol, semaphore control protocol, kernel priority protocol <ref> [8] </ref>) to limit wait times due to lower-priority tasks [3, 7, 9, 10]. These protocols temporarily boost the priorities of tasks that are executing critical sections to ensure that they can complete the critical sections within a short, predictable time.
Reference: [9] <author> R. Rajkumar, L. Sha, and J. P. Lehoczky, </author> <title> "Real-time synchronization protocols for mul-tiprocessors," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 259-269, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Prior work on real-time multiprocessor synchronization minimizes the global blocking of high-priority tasks at the expense of lower-priority tasks <ref> [7, 9] </ref>. Global blocking in a multiprocessor system is blocking on semaphores that are shared across processor boundaries. In this paper, we examine the relationship between global semaphore queue wait times and the schedulability of periodic tasks using rate monotonic scheduling on multiprocessors. <p> Given such a bound, traditional scheduling strategies such as rate monotonic scheduling or earliest deadline scheduling can be used to guarantee task deadlines <ref> [1, 9] </ref>. The most common approach to bounding semaphore wait times is to use variants of 1 the priority inheritance protocol (e.g., basic priority inheritance, priority ceiling protocol, semaphore control protocol, kernel priority protocol [8]) to limit wait times due to lower-priority tasks [3, 7, 9, 10]. <p> The most common approach to bounding semaphore wait times is to use variants of 1 the priority inheritance protocol (e.g., basic priority inheritance, priority ceiling protocol, semaphore control protocol, kernel priority protocol [8]) to limit wait times due to lower-priority tasks <ref> [3, 7, 9, 10] </ref>. These protocols temporarily boost the priorities of tasks that are executing critical sections to ensure that they can complete the critical sections within a short, predictable time. This in turn bounds the blocking delays of other tasks that wait for the resources. <p> The priority ceiling protocol and the semaphore control protocol further bound blocking delays and avoid deadlocks by preventing tasks from attempting to acquire semaphores under certain conditions. These "real-time" synchronization protocols were first developed for uniprocessors and then extended to multiprocessors <ref> [7, 9, 10] </ref>. Some uniprocessor protocols, such as the priority ceiling protocol, do not use explicit semaphore queues. However, real-time multiprocessor synchronization requires queues for the global semaphores. In multiprocessors, the blocking delays also depend on the distribution of tasks that share semaphores across processor boundaries. <p> Section 7 discusses various implementation issues, and the paper concludes with Section 8. 2 2 Blocking Delays and Schedulability Guarantees Given rate monotonic scheduling of n periodic tasks with blocking for synchronization, Rajkumar et al. <ref> [9] </ref> proved that satisfaction of the following equation on each processor provides sufficient conditions for schedulability: 8i; 1 i n T 1 C 2 + + T i B i i (2 1=i 1) (2.1) In this equation (set of equations, actually), lower-numbered subscripts correspond to higher-priority tasks. <p> In particular, the blocking times of other tasks do not affect the schedulability of a given task. This makes intuitive sense because it is the processor utilizations of other (higher-priority) tasks that reduce the schedulability of a task. Prior work <ref> [9] </ref> on real-time synchronization for multiprocessors states: "Another fundamental goal of our synchronization protocol is that whenever possible, we would let a lower-priority job wait for a higher-priority job". <p> This is accomplished for global semaphores by using priority queues to ensure that the highest-priority blocked job will be granted the semaphore next. The justification given in <ref> [9] </ref> for making lower-priority jobs wait is that the longer periods (T i ) of lower-priority tasks results in less schedulability loss B=T for a given blocking duration B. However, the statement "a given blocking duration B" does not take into account an important characteristic of the problem. <p> Therefore, our goal is to calculate B i;S , the blocking time for job J i associated with waiting for global semaphore S. To simplify the analysis, we assume that global critical sections are non-preemptible, which approximates the behavior of the modified priority ceiling protocol proposed for multiprocessor synchronization <ref> [9] </ref>. We define the following notation. Note that J i might contain multiple critical sections guarded by S. Furthermore, unlike Eq. (2.1), 5 0 4 8 12 J 1 2 J remote blocking remote blocking the task numbers in our notation do not correlate with priorities. <p> By allocating blocking delays in this way, it is possible to improve the overall schedulability of the system. Now let us consider the RMSS semaphore queue priority assignment proposed in <ref> [7, 9] </ref>. As we have seen, lower-priority tasks can be less tolerant of blocking delays than higher-priority tasks. If task execution priorities are used for semaphore queues, as much blocking as possible is assigned to the lower-priority tasks. <p> If T max is bounded, the algorithm is essentially O (k lg k). Otherwise, it is quadratic in T max . In either case, this is a relatively efficient algorithm. Now, consider the priority assignment method of <ref> [7, 9] </ref>: assign lowest semaphore queue priorities to the lowest-priority tasks. This is a constant time algorithm, but it is essentially a bin packing strategy in which the largest k items are assigned to a predetermined set of bins, which could be the smallest bins. <p> If this priority assignment overflows a bin's capacity, the algorithm returns failure. Clearly, the bin packing algorithm we propose should perform much better than the method used in <ref> [7, 9] </ref>. By performing better, we mean that given some population of task sets, more will be schedulable with our algorithm. To verify this claim, we have implemented our algorithm and conducted extensive experiments comparing our approach with the previous approach and with simple FIFO queues.
Reference: [10] <author> L. Sha, R. Rajkumar, and J. P. Lehoczky, </author> <title> "Priority inheritance protocols: An approach to real-time synchronization," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 39, no. 9, </volume> <pages> pp. 1175-1185, </pages> <month> September </month> <year> 1990. </year> <month> 23 </month>
Reference-contexts: The most common approach to bounding semaphore wait times is to use variants of 1 the priority inheritance protocol (e.g., basic priority inheritance, priority ceiling protocol, semaphore control protocol, kernel priority protocol [8]) to limit wait times due to lower-priority tasks <ref> [3, 7, 9, 10] </ref>. These protocols temporarily boost the priorities of tasks that are executing critical sections to ensure that they can complete the critical sections within a short, predictable time. This in turn bounds the blocking delays of other tasks that wait for the resources. <p> The priority ceiling protocol and the semaphore control protocol further bound blocking delays and avoid deadlocks by preventing tasks from attempting to acquire semaphores under certain conditions. These "real-time" synchronization protocols were first developed for uniprocessors and then extended to multiprocessors <ref> [7, 9, 10] </ref>. Some uniprocessor protocols, such as the priority ceiling protocol, do not use explicit semaphore queues. However, real-time multiprocessor synchronization requires queues for the global semaphores. In multiprocessors, the blocking delays also depend on the distribution of tasks that share semaphores across processor boundaries. <p> For the purposes of this paper, we analyze the blocking associated with waiting on a single global semaphore in a multiprocessor. Our analysis applies only to global semaphores; local semaphores should be managed by one of the near-optimal uniprocessor protocols such as the priority ceiling protocol <ref> [10] </ref>. It is easy to extend our results to derive the total blocking associated with all semaphores. Therefore, our goal is to calculate B i;S , the blocking time for job J i associated with waiting for global semaphore S. <p> These task sets were generated in groups of 50 sets for each combination of [3, 6, or 10 processors], [3, 6 or 10 tasks per processor], <ref> [5, 10, or 20 global semaphores] </ref>, [processor utilizations of 0.6 or 0.7], and [constant or varying critical section times for semaphores]. For our schedulability analysis, we used critical zone analysis rather than Eq. (2.1) because it is a more accurate method for determining schedulability.
References-found: 10

