URL: http://www.cis.ohio-state.edu/~neelam/papers/pcompl.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~neelam/papers/research.html
Root-URL: 
Email: e-mail: fneelam,fridellag@cis.ohio-state.edu  
Title: Managing Specification Inconsistency in Object Oriented Systems  
Author: Neelam Soundarajan and Stephen Fridella 
Keyword: Specification inconsistency, Incremental system design, Incremental reasoning,  
Date: September 12, 1997  
Address: Columbus, OH 43210  
Affiliation: Computer and Information Science The Ohio State University  
Abstract: One of the important sources of inconsistency in large software systems is changes in specifications. In Object-Oriented systems such an inconsistency will typically manifest itself as a class B that meets its original specification but not the modified specification. Often this inconsistency can be resolved by treating B as a base class and using inheritance to define a derived class D that meets the modified specification; the important point being that in defining the derived class, we can inherit the portions of B that are satisfactory, and need only implement the changes necessary to meet the modified requirements. But in order for this approach to be truly powerful, we must have appropriate reasoning procedures that allow us to establish, in an incremental manner, that the derived class D meets the modified specification, so that we do not need to reanalyze the portions of B that are inherited without change. We present a system that allows for such incremental reasoning and demonstrate its usefulness with a simple example. Abstract and concrete specifications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. </author> <title> America. Designing an object oriented programming language with behavioral subtyping. </title> <booktitle> In Foundations of Object-Oriented Languages, REX School/Workshop, </booktitle> <volume> LNCS 489, </volume> <pages> pages 69-90. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Finally, much work in the OO specification and literature has focussed on the notion of behavioral subtype (see <ref> [1, 7, 5] </ref>); this has to do with the question, `what relation needs to hold between the abstract specifications of two classes in order for us to consider one as a behavioral subtype of the other?'.
Reference: [2] <author> J. Guttag, J. Horning, and J. Wing. </author> <title> The larch family of specification languages. </title> <journal> IEEE Software, </journal> <volume> 2, </volume> <year> 1985. </year>
Reference-contexts: The abstract specification A will be the usual ADT-type specification <ref> [2] </ref>, consisting of a conceptual, mathematical model M of B, and the specifications of the individual methods of B in terms of pre- and post-conditions in this model.
Reference: [3] <author> C. Horstmann. </author> <title> Mastering Object-Oriented Design in C++. </title> <publisher> Wiley, </publisher> <year> 1995. </year>
Reference-contexts: Second, the use of inheritance for this purpose has been criticized (see <ref> [3] </ref>), since we might `break the class' by, for instance, violating some invariant that the unchanged functions depend upon to work correctly; it is precisely for this reason that we need formalisms such as the one presented in this paper to check that the derived class does indeed meet the changed <p> The number of intersections in a StreetMap object is fixed at the time the object is constructed and cannot be changed thereafter. 8 We assume these templates, 2dArray and 1dArray are available; see <ref> [3] </ref> for details. 6 two-way street between intersections i and j, but this requires the client to make two separate calls to the AddStreet method, one with parameters i and j, another with j and i.
Reference: [4] <author> C. Jones. </author> <title> Systematic Software Development Using VDM. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: The goal of this paper is to present a system that allows for such incremental reasoning and demonstrate its usefulness with a simple example. 2 The standard approach (see, for example, <ref> [4] </ref>) to specifying a class B in an OO language is to describe the functionality of B's operations 3 using pre- and post-conditions in terms of a conceptual model of B. <p> Interestingly, the concrete specification is also used in some of the standard approaches such as that of Jones <ref> [4] </ref>, although for a different purpose. Consider the class B. How do we establish that it meets its abstract specification? The actual bodies of B's operations are of course written in terms of the internal data members of B and operate on those members, not on a `conceptual' entity.
Reference: [5] <author> G. Leavens and W. Weihl. </author> <title> Specification and verification of object-oriented programs using supertype abstraction. </title> <journal> Acta Informatica, </journal> <volume> 32 </volume> <pages> 705-778, </pages> <year> 1995. </year>
Reference-contexts: Finally, much work in the OO specification and literature has focussed on the notion of behavioral subtype (see <ref> [1, 7, 5] </ref>); this has to do with the question, `what relation needs to hold between the abstract specifications of two classes in order for us to consider one as a behavioral subtype of the other?'.
Reference: [6] <author> B. Liskov and J. Wing. </author> <title> A new definition of the subtype relation. </title> <booktitle> In ECOOP, </booktitle> <year> 1993. </year>
Reference-contexts: In formalisms like that of <ref> [6, 7] </ref>, A would essentially be the complete specification of B. <p> We should also reiterate a point we briefly mentioned earlier. The work on behavioral subtyping, see for example <ref> [6, 7] </ref>, is unrelated to the problem we are addressing and the solution we have proposed.
Reference: [7] <author> B. Liskov and J. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM TOPLAS, </journal> <volume> 16 </volume> <pages> 1811-1841, </pages> <year> 1994. </year>
Reference-contexts: Finally, much work in the OO specification and literature has focussed on the notion of behavioral subtype (see <ref> [1, 7, 5] </ref>); this has to do with the question, `what relation needs to hold between the abstract specifications of two classes in order for us to consider one as a behavioral subtype of the other?'. <p> In formalisms like that of <ref> [6, 7] </ref>, A would essentially be the complete specification of B. <p> We should also reiterate a point we briefly mentioned earlier. The work on behavioral subtyping, see for example <ref> [6, 7] </ref>, is unrelated to the problem we are addressing and the solution we have proposed.
Reference: [8] <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: In the current paper, we will generally assume C++-like conventions (see [12]; the changes necessary to deal with other languages such as Eiffel <ref> [8] </ref> are straightforward. 3 We will use the terms functions, operations, and methods, interchangeably. 4 Following standard practice, we use `he', `his', etc. as abbreviations for `he or she', `his or her' etc. 2 that operations of the class have on its internal data members. 5 Armed with the information in <p> Before concluding this section it may be useful to address a possible misunderstanding: In formalisms such as those of Meyer <ref> [8] </ref>, the invariant is often used to specify clauses that appear in the (concrete) pre- and post-conditions of all the methods of the class, so that they don't have to be repeated in the individual pre- and post-conditions. Our invariant is not used for this purpose.
Reference: [9] <author> N. Soundarajan. </author> <title> Understanding frameworks. </title> <type> Technical report, </type> <institution> Ohio State University, </institution> <year> 1997. </year>
Reference-contexts: some information identifying the functions that f invokes; this information can then be combined with information about the behavior of g when it is redefined in the derived class, to obtain the new behavior of f; the details are somewhat complex, for some preliminary ideas on such a system, see <ref> [9] </ref>. 17 would behave (as seen by the client) somewhat differently, in response to the change in requirements, from the base class; clearly such a derived class would not be a behavioral subtype of the base class.
Reference: [10] <author> N. Soundarajan and S. Fridella. </author> <title> Inheriting and modifying behavior. </title> <booktitle> In TOOLS, </booktitle> <year> 1997. </year>
Reference-contexts: In most examples, however, the models are similar to each other, and much of the abstract specification of B can also be inherited by D. 12 We consider how our approach can be extended to handle private members in <ref> [10] </ref>. Eiffel has no private members, only public and protected; thus all members of a class are accessible in derived classes. Java allows not only derived classes, but all other classes that are in the same `package' as B to access all members of B except those declared private. <p> are available; and code that uses StreetMap is unaffected by OneWayStreetMap. 21 In C++, g would have to be declared virtual; otherwise f will always invoke the original g; in Eiffel all methods are virtual. 22 Systems that handle limited versions of this problem have been considered (see, for example, <ref> [10, 11] </ref>).
Reference: [11] <author> R. Stata and J.V. Guttag. </author> <title> Modular reasoning in the presence of subclassing. </title> <booktitle> In OOPSLA. </booktitle> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: are available; and code that uses StreetMap is unaffected by OneWayStreetMap. 21 In C++, g would have to be declared virtual; otherwise f will always invoke the original g; in Eiffel all methods are virtual. 22 Systems that handle limited versions of this problem have been considered (see, for example, <ref> [10, 11] </ref>).
Reference: [12] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year> <month> 19 </month>
Reference-contexts: The specific changes allowed in the derived class do vary slightly from one OO language to another and so the details of the reasoning procedure and our formalism also depend somewhat on the programming language. In the current paper, we will generally assume C++-like conventions (see <ref> [12] </ref>; the changes necessary to deal with other languages such as Eiffel [8] are straightforward. 3 We will use the terms functions, operations, and methods, interchangeably. 4 Following standard practice, we use `he', `his', etc. as abbreviations for `he or she', `his or her' etc. 2 that operations of the class
References-found: 12

