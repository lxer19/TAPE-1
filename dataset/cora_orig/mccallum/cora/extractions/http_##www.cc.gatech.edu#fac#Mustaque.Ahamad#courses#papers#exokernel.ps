URL: http://www.cc.gatech.edu/fac/Mustaque.Ahamad/courses/papers/exokernel.ps
Refering-URL: http://www.cs.gatech.edu/computing/classes/cs6420_97_fall/reading.html
Root-URL: 
Email: fengler, kaashoek, jamesg@lcs.mit.edu  
Title: Exokernel: An Operating System Architecture for Application-Level Resource Management  
Author: Dawson R. Engler, M. Frans Kaashoek, and James O'Toole Jr. 
Address: Cambridge, MA 02139, U.S.A  
Affiliation: M.I.T. Laboratory for Computer Science  
Abstract: We have implemented a prototype exokernel operating system. Measurements show that most primitive kernel operations (such as exception handling and protected control transfer) are ten to 100 times faster than in Ultrix, a mature monolithic UNIX operating system. In addition, we demonstrate that an exokernel allows applications to control machine resources in ways not possible in traditional operating systems. For instance, virtual memory and interprocess communication abstractions are implemented entirely within an application-level library. Measurements show that application-level virtual memory and interprocess communication primitives are five to 40 times faster than Ultrix's kernel primitives. Compared to state-of-the-art implementations from the literature, the prototype exokernel system is at least five times faster on operations such as exception dispatching and interprocess communication. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. B. Abbot and L. L. Peterson. </author> <title> Increasing network throughput by integrating protocol layers. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(5) </volume> <pages> 600-610, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Direct, dynamic message vectoring. An ASH controls where messages are copied in memory, and can therefore eliminate all intermediate copies, which are the bane of fast networking systems. 2. Dynamic integrated layer processing (ILP) <ref> [1, 16] </ref>.
Reference: [2] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: a new kernel foundation for UNIX development. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference, </booktitle> <pages> pages 93-112, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Aegis's efficient protected control transfer allows applications to construct a wide array of efficient IPC primitives by trading performance for additional functionality. In contrast, microkernel systems such as Amoeba [48], Chorus [43], Mach <ref> [2] </ref>, and V [15] do not allow untrusted application software to define specialized IPC primitives because virtual memory and message passing services are implemented by the kernel and trusted servers. Similarly, many other abstractions, such as page-table structures and process abstractions, cannot be modified in micro-kernels. <p> Revocation can either be visible or invisible to applications. Traditionally, operating systems have performed revocation invisibly, deallocating resources without application involvement. For example, with the exception of some external pagers <ref> [2, 43] </ref>, most operating systems deallocate (and allocate) physical memory without informing applications. This form of revocation has lower latency than visible revocation since it requires no application involvement. Its disadvantages are that library operating systems cannot guide deallocation and have no knowledge that resources are scarce. <p> Modern revisitations of microkernels have argued for kernel extensibility <ref> [2, 43, 48] </ref>. Like microkernels, exokernels are designed to increase extensibility. Unlike traditional microkernels, an exok-ernel pushes the kernel interface much closer to the hardware, which allows for greater flexibility. An exokernel allows application-level libraries to define virtual memory and IPC abstractions.
Reference: [3] <author> T.E. Anderson. </author> <title> The case for application-specific operating systems. </title> <booktitle> In Third Workshop on Workstation Operating Systems, </booktitle> <pages> pages 92-94, </pages> <year> 1992. </year>
Reference-contexts: Its close coupling to the architecture makes it similar in many ways to an exokernel, but we have not been able to make detailed comparisons because its design methodology and performance have not yet been published. Anderson <ref> [3] </ref> makes a clear argument for application-specific library operating systems and proposes that the kernel concentrate solely on the adjudication of hardware resources. The exokernel design addresses how to provide secure multiplexing of physical resources in such a system, and moves the kernel interface to a lower level of abstraction.
Reference: [4] <author> T.E. Anderson, B.N. Bershad, E.D. Lazowska, and H.M. Levy. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 95-109, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Traditional operating systems attempt to provide all the features needed by all applications. As previously noted by Lampson and Sproul [32], Anderson et al. <ref> [4] </ref> and Massalin and Pu [36], general-purpose implementations of abstractions force applications that do not need a given feature to pay substantial overhead costs. This longstanding problem has become more important with explosive improvements in raw hardware performance and enormous growth in diversity of the application software base. <p> For example, database implementors must struggle to emulate random-access record storage on top of file systems [47]. As another example, implementing lightweight threads on top of heavyweight processes usually requires compromises in correctness and performance, because the operating system hides page faults and timer interrupts <ref> [4] </ref>. In such cases, application complexity increases because of the difficulty of getting good performance from high-level abstractions. Fixed high-level abstractions limit the functionality of applications, because they are the only available interface between applications and hardware resources. <p> Because all applications must share one set of abstractions, changes to these abstractions occur rarely, if ever. This may explain why few good ideas from the last decade of operating systems research have been adopted into widespread use: how many production operating systems support scheduler activations <ref> [4] </ref>, multiple protection domains within a single address space [11], efficient IPC [33], or efficient and flexible virtual memory primitives [5, 26, 30]? 2.2 Exokernels: An End-to-End Argument The familiar end-to-end argument applies as well to low-level operating system software as it does to low-level communication protocols [44]. <p> The application's handlers are responsible for general-purpose context switching: saving and restoring live registers, releasing locks, etc. This framework gives applications a large degree of control over context switching. For example, it can be used to implement scheduler activations <ref> [4] </ref>. Fairness is achieved by bounding the time an application takes to save its context: each subsequent timer interrupt (which demarcates a time slice) is recorded in an excess time counter. Applications pay 7 for each excess time slice consumed by forfeiting a subsequent time slice.
Reference: [5] <author> A.W. Appel and K. Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In Fourth International Conference on Architecture Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 96-107, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Application writers select libraries or implement their own. New implementations of library operating systems are incorporated by simply relinking application executables. Substantial evidence exists that applications can benefit greatly from having more control over how machine resources are used to implement higher-level abstractions. Appel and Li <ref> [5] </ref> reported that the high cost of general-purpose virtual memory primitives reduces the performance of persistent stores, garbage collectors, and distributed shared memory systems. Cao et al. [10] reported that application-level control over file caching can reduce application running time by 45%. <p> This may explain why few good ideas from the last decade of operating systems research have been adopted into widespread use: how many production operating systems support scheduler activations [4], multiple protection domains within a single address space [11], efficient IPC [33], or efficient and flexible virtual memory primitives <ref> [5, 26, 30] </ref>? 2.2 Exokernels: An End-to-End Argument The familiar end-to-end argument applies as well to low-level operating system software as it does to low-level communication protocols [44]. <p> For example, it performs two to three times better than Mach 3.0 in a set of I/O benchmarks [38]. Also, its virtual memory performance is approximately twice that of Mach 2.5 and three times that of Mach 3.0 <ref> [5] </ref>. In addition, we attempt to assess Aegis's and ExOS's performance in the light of recent advances in operating systems research. These advances have typically been evaluated on different hardware and frequently use experimental software, making head-to-head comparisons impossible. <p> Fast exceptions enable a number of intriguing applications: efficient page-protection traps can be used by applications such as distributed shared memory systems, persistent object stores, and garbage collectors <ref> [5, 50] </ref>. Table 5 shows exception dispatch times for unaligned pointer accesses (unalign), arithmetic overflow (overflow), attempted use of the floating point co-processor when it is disabled (coproc) and access to protected pages (prot). <p> Of course, this is hardly a conclusive proof. Table 10 compares Aegis and ExOS to Ultrix on seven virtual memory experiments based on those used by Appel and Li <ref> [5] </ref>. These experiments are of particular interest, since they measure the cost of VM operations that are crucial for the construction of ambitious systems, such as page-based distributed shared memory systems and garbage collectors. Note that Ultrix's VM performance is quite good compared to other systems [5]. <p> by Appel and Li <ref> [5] </ref>. These experiments are of particular interest, since they measure the cost of VM operations that are crucial for the construction of ambitious systems, such as page-based distributed shared memory systems and garbage collectors. Note that Ultrix's VM performance is quite good compared to other systems [5]. The operations measured are the following: dirty: time to query whether a page is dirty. Since it does not require examination of the TLB, this experiment measures the base cost of looking up a virtual address in ExOS's page-table structure. <p> time to read-protect 100 pages. unprot100: time to remove read-protections on 100 pages. trap: time to handle a page-protection trap. appel1: time to access a random protected page and, in the fault handler, protect some other page and unprotect the faulting page (this benchmark is prot1+trap+unprot in Appel and Li <ref> [5] </ref>). appel2: time to protect 100 pages, then access each page in a random sequence and, in the fault-handler, unprotect the faulting page (this benchmark is protN+trap+unprot in Appel and Li [5]). <p> fault handler, protect some other page and unprotect the faulting page (this benchmark is prot1+trap+unprot in Appel and Li <ref> [5] </ref>). appel2: time to protect 100 pages, then access each page in a random sequence and, in the fault-handler, unprotect the faulting page (this benchmark is protN+trap+unprot in Appel and Li [5]). Note that appel2 requires less time than appel1 since appel1 must both unprotect and protect different pages in the fault handler. The dirty benchmark measures the average time to parse the page-table for a random entry. This operation illustrates two consequences of the exokernel architecture.
Reference: [6] <author> M. L. Bailey, B. Gopal, M. A. Pagels, L. L. Peterson, and P. Sarkar. PATHFINDER: </author> <title> A pattern-based packet classifier. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 115-123, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: We briefly discuss some key features of this system. A complete discussion can be found in [22]. Message demultiplexing is the process of determining which application an incoming message should be delivered to. Packet filters are a well-known technique used to implement extensible kernel demultiplexing <ref> [6, 56] </ref>. Traditionally, packet filters are interpreted, which entails a high computational cost. Aegis uses Dynamic Packet Filter (DPF), a new packet filter system that is over an order of magnitude more efficient than previous systems. The key in our approach to making filters run fast is dynamic code generation. <p> We measured DPF's time to classify packets destined for one of ten TCP/IP filters, and compare its times to times for MPF [56] (a widely used packet filter engine) and PATHFINDER <ref> [6] </ref> (the fastest packet filter engine in the literature). To ensure meaningful comparisons between the systems, we ran our DPF experiments on the same hardware (a DECstation 5000/200) in user space. <p> Table 7 presents the time to perform this message classification; it was derived from the average of one million trials. This experiment and the numbers for both MPF and PATHFINDER are taken from <ref> [6] </ref>. On this experiment DPF is 20 times faster than MPF and 10 times faster than PATHFINDER. The bulk of this performance improvement is due to the use of dynamic code generation, 5.7 Summary The main conclusion we draw from these experiments is that an exokernel can be implemented efficiently.
Reference: [7] <author> K. Bala, M.F. Kaashoek, and W.E. Weihl. </author> <title> Software prefetch-ing and caching for translation lookaside buffers. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 243-253, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: The application can access the frame buffer hardware directly, because the hardware checks the ownership tag when I/O takes place. Secure bindings can be cached in an exokernel. For instance, an exokernel can use a large software TLB <ref> [7, 28] </ref> to cache address 4 translations that do not fit in the hardware TLB. The software TLB can be viewed as a cache of frequently-used secure bindings. Secure bindings can be implemented by downloading code into the kernel. <p> In order to support application-level virtual memory efficiently, TLB refills must be fast. To this end, Aegis caches TLB entries (a form of secure bindings) in the kernel by overlaying the hardware TLB with a large software TLB (STLB) to absorb capacity misses <ref> [7, 28] </ref>. On a TLB miss, Aegis first checks to see whether the required mapping is in the STLB. If so, Aegis installs it and resumes execution; otherwise, the miss is forwarded to the application. The STLB contains 4096 entries of 8 bytes each.
Reference: [8] <author> B. N. Bershad, T. E. Anderson, E. D. Lazowska, and H. M. Levy. </author> <title> Lightweight remote procedure call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 37-55, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: This section demonstrates that basic system abstractions can be implemented at application level in a direct and efficient manner. Due to space constraints we focus on IPC, virtual memory, and remote communication. 6.1 IPC Abstractions Fast interprocess communication is crucial for building efficient and decoupled systems <ref> [8, 27, 33] </ref>. As described in Section 5, the Aegis protected control transfer mechanism is an efficient substrate for implementing IPC abstractions. This section describes experiments used to measure the performance of ExOS's IPC abstractions on top of the Aegis primitives.
Reference: [9] <author> B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. Fiuczyn-ski, D. Becker, S. Eggers, and C. Chambers. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Downloading code into the kernel allows an application thread of control to be immediately executed on kernel events. The advantages of downloading code are that potentially expensive crossings can be avoided and that this code can run without requiring the application itself to be scheduled. Type-safe languages <ref> [9, 42] </ref>, interpretation, and sandboxing [52] can be used to execute untrusted application code safely [21]. We provide examples of each of these three techniques below and discuss how secure bindings apply to the secure multiplexing of physical memory and network devices. <p> However, since these systems do not employ secure bindings, visible resource revocation, and abort protocols, they give less control of resources to application-level software. The SPIN project is building a microkernel system that allows applications to make policy decisions <ref> [9] </ref> by safely downloading extensions into the kernel. Unlike SPIN, the focus in the exoker-nel architecture is to obtain flexibility and performance by securely exposing low-level hardware primitives rather than extending a traditional operating system in a secure way.
Reference: [10] <author> P. Cao, E. W. Felten, and K. Li. </author> <title> Implementation and performance of application-controlled file caching. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 165-178, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Appel and Li [5] reported that the high cost of general-purpose virtual memory primitives reduces the performance of persistent stores, garbage collectors, and distributed shared memory systems. Cao et al. <ref> [10] </ref> reported that application-level control over file caching can reduce application running time by 45%. Harty and Cheriton [26] and Krueger et al. [30] showed how application-specific virtual memory policies can increase application performance. <p> For example, relational databases and garbage collectors sometimes have very predictable data access patterns, and their performance suffers when a general-purpose page replacement strategy such as LRU is imposed by the operating system. The performance improvements of such application-specific policies can be substantial; Cao et al. <ref> [10] </ref> measured that application-controlled file caching can reduce application running time by as much as 45%. Fixed high-level abstractions hide information from applications. For instance, most current systems do not make low-level exceptions, timer interrupts, or raw device I/O directly available to application-level software.
Reference: [11] <author> J. S. Chase, H. M. Levy, M. J. Feeley, and E. D. Lazowska. </author> <title> Sharing and protection in a single-address-space operating system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12(4) </volume> <pages> 271-308, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: This may explain why few good ideas from the last decade of operating systems research have been adopted into widespread use: how many production operating systems support scheduler activations [4], multiple protection domains within a single address space <ref> [11] </ref>, efficient IPC [33], or efficient and flexible virtual memory primitives [5, 26, 30]? 2.2 Exokernels: An End-to-End Argument The familiar end-to-end argument applies as well to low-level operating system software as it does to low-level communication protocols [44].
Reference: [12] <author> D. L. Chaum and R. S. Fabry. </author> <title> Implementing capability-based protection using encryption. </title> <type> Technical Report UCB/ERL M78/46, </type> <institution> University of California at Berkeley, </institution> <month> July </month> <year> 1978. </year>
Reference-contexts: We provide examples of each of these three techniques below and discuss how secure bindings apply to the secure multiplexing of physical memory and network devices. Multiplexing Physical Memory Secure bindings to physical memory are implemented in our prototype exokernel using self-authenticating capabilities <ref> [12] </ref> and address translation hardware. When a library operating system allocates a physical memory page, the exokernel creates a secure binding for that page by recording the owner and the read and write capabilities specified by the library operating system.
Reference: [13] <author> D. Cheriton and K. Duda. </author> <title> A caching model of operating system kernel functionality. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 179-193, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: In addition, Aegis and ExOS demonstrate that low-level secure multiplexing and library operating systems can offer excellent performance. Like Aegis, the Cache Kernel <ref> [13] </ref> provides a low-level kernel that can support multiple application-level operating systems. To the best of our knowledge ExOS and the Cache Kernel are the first general-purpose library operating systems implemented in a multiprogramming environment. The difference between the Cache Kernel and Aegis is mainly one of high-level philosophy.
Reference: [14] <author> D. R. Cheriton. </author> <title> An experiment using registers for fast message-based interprocess communication. </title> <journal> Operating Systems Review, </journal> <volume> 18 </volume> <pages> 12-20, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: First, to applications, a protected control transfer is atomic: once initiated it will reach the callee. Second, Aegis will not overwrite any application-visible register. These two properties allow the large register sets of modern processors to be used as a temporary message buffer <ref> [14] </ref>. Currently, our synchronous protected control transfer operation takes 30 instructions. Roughly ten of these instructions are used to distinguish the system call exception from other hardware exceptions on the MIPS architecture. Setting the status, co-processor, and address-tag registers consumes the remaining 20 instructions, and could benefit from additional optimizations.
Reference: [15] <author> D. R. Cheriton. </author> <title> The V kernel: A software base for distributed systems. </title> <journal> IEEE Software, </journal> <volume> 1(2) </volume> <pages> 19-42, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: Aegis's efficient protected control transfer allows applications to construct a wide array of efficient IPC primitives by trading performance for additional functionality. In contrast, microkernel systems such as Amoeba [48], Chorus [43], Mach [2], and V <ref> [15] </ref> do not allow untrusted application software to define specialized IPC primitives because virtual memory and message passing services are implemented by the kernel and trusted servers. Similarly, many other abstractions, such as page-table structures and process abstractions, cannot be modified in micro-kernels.
Reference: [16] <author> D. D. Clark and D. L. Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In ACM Communication Architectures, Protocols, and Applications (SIGCOMM) 1990, </booktitle> <month> September </month> <year> 1990. </year>
Reference-contexts: Direct, dynamic message vectoring. An ASH controls where messages are copied in memory, and can therefore eliminate all intermediate copies, which are the bane of fast networking systems. 2. Dynamic integrated layer processing (ILP) <ref> [1, 16] </ref>.
Reference: [17] <author> R. J. Creasy. </author> <title> The origin of the VM/370 time-sharing system. </title> <journal> IBM J. Research and Development, </journal> <volume> 25(5) </volume> <pages> 483-490, </pages> <month> Septem-ber </month> <year> 1981. </year>
Reference-contexts: For instance, an exokernel should protect framebuffers without understanding windowing systems and disks without understanding file systems. One approach is to give each application its own virtual machine <ref> [17] </ref>. As we discuss in Section 8, virtual machines can have severe performance penalties. Therefore, an exokernel uses a different approach: it exports hardware resources rather than emulating them, which allows an efficient and simple implementation. An exokernel employs three techniques to export resources securely. <p> This process is motivated by the insight that mechanism is policy, albeit with one less layer of indirection. For instance, a page-table is a very detailed policy that controls how to translate, store and delete mappings and what actions to take on invalid addresses and accesses. VM/370 <ref> [17] </ref> exports the ideal exokernel interface: the hardware interface. On top of this hardware interface, VM/370 supports a number of virtual machines on top of which radically different operating systems can be implemented. However, the important difference is that VM/370 provides this flexibility by virtualizing the entire base-machine.
Reference: [18] <author> P. Deutsch and C. A. Grant. </author> <title> A flexible measurement tool for software systems. </title> <booktitle> Information Processing 71, </booktitle> <year> 1971. </year>
Reference-contexts: Downloading code into the kernel has two main performance advantages. The first is obvious: elimination of kernel crossings. The second is more subtle: the execution time of downloaded code can be readily bounded <ref> [18] </ref>. The crucial importance of tamed code is that it can be executed when the application is not scheduled. This decoupling allows downloaded code to be executed in situations where context switching to the application itself is infeasible (e.g., when only a few microseconds of free processing time is available). <p> Downloading code thus allows applications to decouple latency-critical operations such as message reply from process scheduling. We examine these issues using application-specific handlers (ASHs). ASHs are untrusted application-level message-handlers that are downloaded into the kernel, made safe by a combination of code inspection <ref> [18] </ref> and sandboxing [52], and executed upon message arrival. The issues in other contexts (e.g., disk I/O) are similar. An ASH can perform general computation. We have augmented this ability with a set of message primitives that enable the following four useful abilities: 1. Direct, dynamic message vectoring.
Reference: [19] <author> P. Druschel, L. L. Peterson, and B. S. Davie. </author> <title> Experiences with a high-speed network adaptor: A software perspective. </title> <booktitle> In ACM Communication Architectures, Protocols, and Applications (SIGCOMM) 1994, </booktitle> <pages> pages 2-13, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Support for network demultiplexing can be provided either in software or hardware. An example of a hardware-based mechanism is the use of the virtual circuit in ATM cells to securely bind streams to applications <ref> [19] </ref>. Software support for message demultiplexing can be provided by packet filters [37]. Packet filters can be viewed as an implementation of secure bindings in which application codethe filters are downloaded into the kernel. <p> Sharing the network interface for outgoing messages is easy. Messages are simply copied from application space into a transmit buffer. In fact, with appropriate hardware support, transmission buffers can be mapped into application space just as easily as physical memory pages <ref> [19] </ref>. 3.2.1 Downloading Code In addition to implementing secure bindings, downloading code can be used to improve performance. Downloading code into the kernel has two main performance advantages. The first is obvious: elimination of kernel crossings.
Reference: [20] <author> D. R. Engler. </author> <title> VCODE: a very fast, retargetable, and extensible dynamic code generation substrate. Technical Memorandum MIT/LCS/TM534, </title> <publisher> MIT, </publisher> <month> July </month> <year> 1995. </year>
Reference-contexts: To gain portability, DPF compiles filters using VCODE, a portable, very fast, dynamic code generation system <ref> [20] </ref>. VCODE generates machine code in approximately 10 instructions per generated instruction and runs on a number of machines (e.g., MIPS, Alpha and SPARC).
Reference: [21] <author> D. R. Engler, M. F. Kaashoek, and J. O'Toole. </author> <title> The operating system kernel as a secure programmable machine. </title> <booktitle> In Proceedings of the Sixth SIGOPS European Workshop, </booktitle> <pages> pages 62-67, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: The advantages of downloading code are that potentially expensive crossings can be avoided and that this code can run without requiring the application itself to be scheduled. Type-safe languages [9, 42], interpretation, and sandboxing [52] can be used to execute untrusted application code safely <ref> [21] </ref>. We provide examples of each of these three techniques below and discuss how secure bindings apply to the secure multiplexing of physical memory and network devices. Multiplexing Physical Memory Secure bindings to physical memory are implemented in our prototype exokernel using self-authenticating capabilities [12] and address translation hardware.
Reference: [22] <author> D. R. Engler, D. Wallach, and M. F. Kaashoek. </author> <title> Efficient, safe, application-specific message processing. Technical Memorandum MIT/LCS/TM533, </title> <publisher> MIT, </publisher> <month> March </month> <year> 1995. </year>
Reference-contexts: One of the distinguishing features of the packet filter engine used by our prototype exokernel is that it compiles packet filters to machine code at runtime, increasing demultiplexing performance by more than an order of magnitude <ref> [22] </ref>. The one problem with the use of a packet filter is ensuring that that a filter does not lie and accept packets destined to another process. Simple security precautions such as only allowing a trusted server to install filters can be used to address this problem. <p> We briefly discuss some key features of this system. A complete discussion can be found in <ref> [22] </ref>. Message demultiplexing is the process of determining which application an incoming message should be delivered to. Packet filters are a well-known technique used to implement extensible kernel demultiplexing [6, 56]. Traditionally, packet filters are interpreted, which entails a high computational cost. <p> Therefore, by downloading code into the kernel, applications can integrate operations such as checksumming during the copy of the message from these buffers to user space. Such integration can improve performance on a DECsta-tion5000/200 by almost a factor of two <ref> [22] </ref>. Second, if the runtime of downloaded code is bounded, it can be run in situations when performing a full context switch to an unscheduled application is impractical. Downloading code thus allows applications to decouple latency-critical operations such as message reply from process scheduling.
Reference: [23] <author> R. P. Goldberg. </author> <title> Survey of virtual machine research. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 34-45, </pages> <month> June </month> <year> 1974. </year>
Reference-contexts: However, the important difference is that VM/370 provides this flexibility by virtualizing the entire base-machine. Since the base machine can be quite complicated, virtualization can be expensive and difficult. Often, this approach requires additional hardware support <ref> [23, 40] </ref>. Additionally, since much of the actual machine is intentionally hidden from application-level software, such software has little control over the actual resources and may manage the virtual resources in a counterproductive way. <p> For instance, the LRU policy of pagers on top of the virtual machine can conflict with the paging strategy used by the virtual machine monitor <ref> [23] </ref>.
Reference: [24] <author> P. Brinch Hansen. </author> <title> The nucleus of a multiprogramming system. </title> <journal> Communications of the ACM, </journal> <volume> 13(4) </volume> <pages> 238-241, </pages> <month> April </month> <year> 1970. </year>
Reference-contexts: By constructing a domain-specific scheduler, these applications can now effectively and accurately schedule sub-processes, greatly improving fault isolation and independence. 8 Related work Many early operating system papers discussed the need for extendible, flexible kernels [32, 42]. Lampson's description of CAL-TSS [31] and Brinch Hansen's microkernel paper <ref> [24] </ref> are two classic rationales. Hydra was the most ambitious early system to have the separation of kernel policy and mechanism as one of its central tenets [55]. An exokernel takes the elimination of policy one step further by removing mechanism wherever possible.
Reference: [25] <author> J.H. Hartman, A.B. Montz, D. Mosberger, S.W. O'Malley, L.L. Peterson, and T.A. Proebsting. </author> <title> Scout: A communication-oriented operating system. </title> <type> Technical Report TR 94-20, </type> <institution> University of Arizona, </institution> <address> Tucson, AZ, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Because the exokernel low-level primitives are simple compared to traditional kernel interfaces, they can be made very fast. Therefore, the exokernel has less use for kernel extensions. Scout <ref> [25] </ref> and Vino [46] are other current extensible operating systems. These systems are just beginning to be constructed, so it is difficult to determine their relationship to exokernels in general and Aegis in particular.
Reference: [26] <author> K. Harty and D.R. Cheriton. </author> <title> Application-controlled physical memory using external page-cache management. </title> <booktitle> In Fifth International Conference on Architecture Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 187-199, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Appel and Li [5] reported that the high cost of general-purpose virtual memory primitives reduces the performance of persistent stores, garbage collectors, and distributed shared memory systems. Cao et al. [10] reported that application-level control over file caching can reduce application running time by 45%. Harty and Cheriton <ref> [26] </ref> and Krueger et al. [30] showed how application-specific virtual memory policies can increase application performance. Stonebraker [47] argued that inappropriate file-system implementation decisions can have a dramatic impact on the performance of databases. <p> This may explain why few good ideas from the last decade of operating systems research have been adopted into widespread use: how many production operating systems support scheduler activations [4], multiple protection domains within a single address space [11], efficient IPC [33], or efficient and flexible virtual memory primitives <ref> [5, 26, 30] </ref>? 2.2 Exokernels: An End-to-End Argument The familiar end-to-end argument applies as well to low-level operating system software as it does to low-level communication protocols [44].
Reference: [27] <author> W.C. Hsieh, M.F. Kaashoek, and W.E. Weihl. </author> <title> The persistent relevance of IPC performance: New techniques for reducing the IPC penalty. </title> <booktitle> In Fourth Workshop on Workstation Operating Systems, </booktitle> <pages> pages 186-190, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: This section demonstrates that basic system abstractions can be implemented at application level in a direct and efficient manner. Due to space constraints we focus on IPC, virtual memory, and remote communication. 6.1 IPC Abstractions Fast interprocess communication is crucial for building efficient and decoupled systems <ref> [8, 27, 33] </ref>. As described in Section 5, the Aegis protected control transfer mechanism is an efficient substrate for implementing IPC abstractions. This section describes experiments used to measure the performance of ExOS's IPC abstractions on top of the Aegis primitives. <p> We show that these extensions can have dramatic performance benefits. These different versions of ExOS can coexist on the same machine and are fully protected by Aegis. 7.1 Extensible RPC Most RPC systems do not trust the server to save and restore registers <ref> [27] </ref>. We implemented a version of lrpc (see Section 6.1) that trusts the server to save and restore callee-saved registers. We call this version tlrpc (trusted LRPC). Table 12 compares tlrpc to ExOS's more general IPC mechanism,lrpc, which saves all general-purpose callee-saved registers.
Reference: [28] <author> J. Huck and J. Hays. </author> <title> Architectural support for translation table management in large address space machines. </title> <booktitle> In Proceedings of the 19th International Symposium on Computer Architecture, </booktitle> <pages> pages 39-51, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: The application can access the frame buffer hardware directly, because the hardware checks the ownership tag when I/O takes place. Secure bindings can be cached in an exokernel. For instance, an exokernel can use a large software TLB <ref> [7, 28] </ref> to cache address 4 translations that do not fit in the hardware TLB. The software TLB can be viewed as a cache of frequently-used secure bindings. Secure bindings can be implemented by downloading code into the kernel. <p> In order to support application-level virtual memory efficiently, TLB refills must be fast. To this end, Aegis caches TLB entries (a form of secure bindings) in the kernel by overlaying the hardware TLB with a large software TLB (STLB) to absorb capacity misses <ref> [7, 28] </ref>. On a TLB miss, Aegis first checks to see whether the required mapping is in the STLB. If so, Aegis installs it and resumes execution; otherwise, the miss is forwarded to the application. The STLB contains 4096 entries of 8 bytes each.
Reference: [29] <author> R. E. Kessler and M. D. Hill. </author> <title> Page placement algorithms for large real-index caches. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(4) </volume> <pages> 338-359, </pages> <month> November </month> <year> 1992. </year> <month> 15 </month>
Reference-contexts: Subsequent principles deal with the details of achieving this goal. Expose allocation. An exokernel should allow library operating systems to request specific physical resources. For instance, if a library operating system can request specific physical pages, it can reduce cache conflicts among the pages in its working set <ref> [29] </ref>. Furthermore, resources should not be implicitly allocated; the library operating system should participate in every allocation decision. The next principle aids the effectiveness of this participation. Expose Names. An exokernel should export physical names.
Reference: [30] <author> K. Krueger, D. Loftesness, A. Vahdat, and T. Anderson. </author> <title> Tools for development of application-specific virtual memory management. </title> <booktitle> In Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA) 1993, </booktitle> <pages> pages 48-64, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Cao et al. [10] reported that application-level control over file caching can reduce application running time by 45%. Harty and Cheriton [26] and Krueger et al. <ref> [30] </ref> showed how application-specific virtual memory policies can increase application performance. Stonebraker [47] argued that inappropriate file-system implementation decisions can have a dramatic impact on the performance of databases. Thekkath and Levy [50] demonstrated that exceptions can be made an order of magnitude faster by deferring signal handling to applications. <p> This may explain why few good ideas from the last decade of operating systems research have been adopted into widespread use: how many production operating systems support scheduler activations [4], multiple protection domains within a single address space [11], efficient IPC [33], or efficient and flexible virtual memory primitives <ref> [5, 26, 30] </ref>? 2.2 Exokernels: An End-to-End Argument The familiar end-to-end argument applies as well to low-level operating system software as it does to low-level communication protocols [44]. <p> Extending or specializing a library operating system might be considerably simplified by modular design. It is possible that object-oriented programming methods, overloading, and inheritance can provide useful operating system service implementations that can be easily specialized and extended, as in the VM++ library <ref> [30] </ref>. To reduce the space required by these libraries, support for shared libraries and dynamic linking will be an essential part of a complete exokernel-based system.
Reference: [31] <author> B.W. Lampson. </author> <title> On reliable and extendable operating systems. State of the Art Report, </title> <journal> Infotech, </journal> <volume> 1, </volume> <year> 1971. </year>
Reference-contexts: By constructing a domain-specific scheduler, these applications can now effectively and accurately schedule sub-processes, greatly improving fault isolation and independence. 8 Related work Many early operating system papers discussed the need for extendible, flexible kernels [32, 42]. Lampson's description of CAL-TSS <ref> [31] </ref> and Brinch Hansen's microkernel paper [24] are two classic rationales. Hydra was the most ambitious early system to have the separation of kernel policy and mechanism as one of its central tenets [55]. An exokernel takes the elimination of policy one step further by removing mechanism wherever possible.
Reference: [32] <author> B.W. Lampson and R.F. Sproull. </author> <title> An open operating system for a single-user machine. </title> <booktitle> Proceedings of the Seventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 98-105, </pages> <month> December </month> <year> 1979. </year>
Reference-contexts: Traditional operating systems attempt to provide all the features needed by all applications. As previously noted by Lampson and Sproul <ref> [32] </ref>, Anderson et al. [4] and Massalin and Pu [36], general-purpose implementations of abstractions force applications that do not need a given feature to pay substantial overhead costs. <p> By constructing a domain-specific scheduler, these applications can now effectively and accurately schedule sub-processes, greatly improving fault isolation and independence. 8 Related work Many early operating system papers discussed the need for extendible, flexible kernels <ref> [32, 42] </ref>. Lampson's description of CAL-TSS [31] and Brinch Hansen's microkernel paper [24] are two classic rationales. Hydra was the most ambitious early system to have the separation of kernel policy and mechanism as one of its central tenets [55].
Reference: [33] <author> J. Liedtke. </author> <title> Improving IPC by kernel design. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 175-188, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: In practice, our prototype exokernel system provides applications with greater flexibility and better performance than monolithic and microkernel systems. Aegis's low-level interface allows application-level software such as ExOS to manipulate resources very efficiently. Aegis's protected control transfer is almost seven times faster than the best reported implementation <ref> [33] </ref>. Aegis's exception dispatch is five times faster than the best reported implementation [50]. On identical hardware, Aegis's exception dispatch and control transfer are roughly two orders of magnitude faster than in Ultrix 4.2, a mature monolithic system. <p> This may explain why few good ideas from the last decade of operating systems research have been adopted into widespread use: how many production operating systems support scheduler activations [4], multiple protection domains within a single address space [11], efficient IPC <ref> [33] </ref>, or efficient and flexible virtual memory primitives [5, 26, 30]? 2.2 Exokernels: An End-to-End Argument The familiar end-to-end argument applies as well to low-level operating system software as it does to low-level communication protocols [44]. <p> However, due to our measurement code, the time includes the overhead of incrementing a counter and performing a branch. We attempt a crude comparison of our protected control transfer operation to the equivalent operation on L3 <ref> [33] </ref>. The L3 implementation is the fastest published result, but it runs on an Intel 486 DX-50 (50 MHz). For Table 6, we scaled the published L3 results (5 microseconds) by the SPECint92 rating of Aegis's DEC5000 and L3's 486 (16.1 vs. 30.1). <p> This section demonstrates that basic system abstractions can be implemented at application level in a direct and efficient manner. Due to space constraints we focus on IPC, virtual memory, and remote communication. 6.1 IPC Abstractions Fast interprocess communication is crucial for building efficient and decoupled systems <ref> [8, 27, 33] </ref>. As described in Section 5, the Aegis protected control transfer mechanism is an efficient substrate for implementing IPC abstractions. This section describes experiments used to measure the performance of ExOS's IPC abstractions on top of the Aegis primitives.
Reference: [34] <author> J. Liedtke. </author> <title> On micro-kernel construction. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: For example, it is difficult to change the buffer management policy of a shared file server. In many ways, servers can be viewed as fixed kernel subsystems that run in user-space. Some newer microker-nels push the kernel interface closer to the hardware <ref> [34] </ref>, obtaining better performance than previous microkernels. However, since these systems do not employ secure bindings, visible resource revocation, and abort protocols, they give less control of resources to application-level software.
Reference: [35] <author> K. Mackenzie, J. Kubiatowicz, A. Agarwal, and M. F. Kaashoek. FUGU: </author> <title> Implementing translation and protection in a multiuser, multimodel multiprocessor. Technical Memorandum MIT/LCS/TM503, </title> <publisher> MIT, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: Another prototype exokernel, Glaze, is being built for an experimental SPARC-based shared-memory multiprocessor <ref> [35] </ref>, along with PhOS, a parallel operating system library. Aegis and ExOS are implemented on MIPS-based DECstations. Aegis exports the processor, physical memory, TLB, exceptions, and interrupts. In addition, it securely exports the network interface using a packet filter system that employs dynamic code generation.
Reference: [36] <author> H. Massalin and C. Pu. </author> <title> Threads and input/output in the Synthesis kernel. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201, </pages> <year> 1989. </year>
Reference-contexts: Traditional operating systems attempt to provide all the features needed by all applications. As previously noted by Lampson and Sproul [32], Anderson et al. [4] and Massalin and Pu <ref> [36] </ref>, general-purpose implementations of abstractions force applications that do not need a given feature to pay substantial overhead costs. This longstanding problem has become more important with explosive improvements in raw hardware performance and enormous growth in diversity of the application software base.
Reference: [37] <author> J.C. Mogul, R.F. Rashid, and M.J. Accetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Another example is the packet filter <ref> [37] </ref>, which allows predicates to be downloaded into the kernel (bind time) and then run on every incoming packet to determine which application the packet is for (access time). <p> Support for network demultiplexing can be provided either in software or hardware. An example of a hardware-based mechanism is the use of the virtual circuit in ATM cells to securely bind streams to applications [19]. Software support for message demultiplexing can be provided by packet filters <ref> [37] </ref>. Packet filters can be viewed as an implementation of secure bindings in which application codethe filters are downloaded into the kernel. Protocol knowledge is limited to the application, while the protection checks required to determine packet ownership are couched in a language understood by the kernel. <p> Packet filters are an example of this feature: since the packet-filter runtime is bounded, the kernel can use it to demultiplex messages irrespective of what application is scheduled; without a packet filter the operating system would have to schedule each potential consumer of the packet <ref> [37] </ref>. Application-specific Safe Handlers (ASHs) are a more interesting example of downloading code into our prototype exokernel. These application handlers can be downloaded into the kernel to participate in message processing. An ASH is associated with a packet filter and runs on packet reception.
Reference: [38] <author> D. Nagle, R. Uhlig, T. Stanley, S. Sechrest, T. Mudge, and R. Brown. </author> <title> Design tradeoffs for software-managed TLBs. </title> <booktitle> In 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 27-38, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Ultrix, despite its poor performance relative to Aegis, is not a poorly tuned system; it is a mature monolithic system that performs quite well in comparison to other operating systems [39]. For example, it performs two to three times better than Mach 3.0 in a set of I/O benchmarks <ref> [38] </ref>. Also, its virtual memory performance is approximately twice that of Mach 2.5 and three times that of Mach 3.0 [5]. In addition, we attempt to assess Aegis's and ExOS's performance in the light of recent advances in operating systems research.
Reference: [39] <author> J. K. Ousterhout. </author> <booktitle> Why aren't operating systems getting faster as fast as hardware? In Proceedings of the Summer 1990 USENIX Conference, </booktitle> <pages> pages 247-256, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Second, they provide a well-known, easily-accessible point of reference for understanding Aegis's and ExOS's performance. Ultrix, despite its poor performance relative to Aegis, is not a poorly tuned system; it is a mature monolithic system that performs quite well in comparison to other operating systems <ref> [39] </ref>. For example, it performs two to three times better than Mach 3.0 in a set of I/O benchmarks [38]. Also, its virtual memory performance is approximately twice that of Mach 2.5 and three times that of Mach 3.0 [5].
Reference: [40] <author> G. J. Popek and C. S. Kline. </author> <title> The PDP-11 virtual machine architecture. </title> <booktitle> In Proceedings of the Fifth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 97-105, </pages> <month> November </month> <year> 1975. </year>
Reference-contexts: However, the important difference is that VM/370 provides this flexibility by virtualizing the entire base-machine. Since the base machine can be quite complicated, virtualization can be expensive and difficult. Often, this approach requires additional hardware support <ref> [23, 40] </ref>. Additionally, since much of the actual machine is intentionally hidden from application-level software, such software has little control over the actual resources and may manage the virtual resources in a counterproductive way.
Reference: [41] <author> D. Probert, J.L. Bruno, and M. Karzaorman. </author> <title> SPACE: A new approach to operating system abstraction. </title> <booktitle> In International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 133-137, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: These systems are just beginning to be constructed, so it is difficult to determine their relationship to exokernels in general and Aegis in particular. SPACE is a submicro-kernel that provides only low-level kernel abstractions defined by the trap and architecture interface <ref> [41] </ref>. Its close coupling to the architecture makes it similar in many ways to an exokernel, but we have not been able to make detailed comparisons because its design methodology and performance have not yet been published.
Reference: [42] <author> D.D. Redell, Y.K. Dalal, T.R. Horsley, H.C. Lauer, W.C. Lynch, P.R. McJones, H.G. Murray, </author> <title> and S.C. Purcell. Pilot: An operating system for a personal computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: Downloading code into the kernel allows an application thread of control to be immediately executed on kernel events. The advantages of downloading code are that potentially expensive crossings can be avoided and that this code can run without requiring the application itself to be scheduled. Type-safe languages <ref> [9, 42] </ref>, interpretation, and sandboxing [52] can be used to execute untrusted application code safely [21]. We provide examples of each of these three techniques below and discuss how secure bindings apply to the secure multiplexing of physical memory and network devices. <p> By constructing a domain-specific scheduler, these applications can now effectively and accurately schedule sub-processes, greatly improving fault isolation and independence. 8 Related work Many early operating system papers discussed the need for extendible, flexible kernels <ref> [32, 42] </ref>. Lampson's description of CAL-TSS [31] and Brinch Hansen's microkernel paper [24] are two classic rationales. Hydra was the most ambitious early system to have the separation of kernel policy and mechanism as one of its central tenets [55].
Reference: [43] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> Chorus distributed operating system. </title> <journal> Computing Systems, </journal> <volume> 1(4) </volume> <pages> 305-370, </pages> <year> 1988. </year>
Reference-contexts: Aegis's efficient protected control transfer allows applications to construct a wide array of efficient IPC primitives by trading performance for additional functionality. In contrast, microkernel systems such as Amoeba [48], Chorus <ref> [43] </ref>, Mach [2], and V [15] do not allow untrusted application software to define specialized IPC primitives because virtual memory and message passing services are implemented by the kernel and trusted servers. Similarly, many other abstractions, such as page-table structures and process abstractions, cannot be modified in micro-kernels. <p> Revocation can either be visible or invisible to applications. Traditionally, operating systems have performed revocation invisibly, deallocating resources without application involvement. For example, with the exception of some external pagers <ref> [2, 43] </ref>, most operating systems deallocate (and allocate) physical memory without informing applications. This form of revocation has lower latency than visible revocation since it requires no application involvement. Its disadvantages are that library operating systems cannot guide deallocation and have no knowledge that resources are scarce. <p> Modern revisitations of microkernels have argued for kernel extensibility <ref> [2, 43, 48] </ref>. Like microkernels, exokernels are designed to increase extensibility. Unlike traditional microkernels, an exok-ernel pushes the kernel interface much closer to the hardware, which allows for greater flexibility. An exokernel allows application-level libraries to define virtual memory and IPC abstractions.
Reference: [44] <author> J.H. Saltzer, D.P. Reed, and D.D. Clark. </author> <title> End-to-end arguments in system design. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(4) </volume> <pages> 277-288, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: support scheduler activations [4], multiple protection domains within a single address space [11], efficient IPC [33], or efficient and flexible virtual memory primitives [5, 26, 30]? 2.2 Exokernels: An End-to-End Argument The familiar end-to-end argument applies as well to low-level operating system software as it does to low-level communication protocols <ref> [44] </ref>. Applications know better than operating systems what the goal of their resource management decisions should be and therefore, they should be given as much control as possible over 2 exokernel veneer that exports resources to library operating systems through secure bindings.
Reference: [45] <author> R. L. </author> <title> Sites. Alpha AXP architecture. </title> <journal> Communications of the ACM, </journal> <volume> 36(2), </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: Aegis also supports a set of primitive operations that encapsulate privileged instructions and are guaranteed not to alter application-visible registers (see Table 3 for some typical examples). These primitive operations can be viewed as pseudo-instructions (similar to the Alpha's use of PALcode <ref> [45] </ref>). In this subsection we examine how Aegis protects time slices and processor environments; other resources are protected as described in Section 3. 5.1.1 Processor Time Slices Aegis represents the CPU as a linear vector, where each element corresponds to a time slice.
Reference: [46] <author> C. Small and M. Seltzer. Vino: </author> <title> an integrated platform for operating systems and database research. </title> <type> Technical Report TR-30-94, </type> <institution> Harvard, </institution> <year> 1994. </year>
Reference-contexts: Because the exokernel low-level primitives are simple compared to traditional kernel interfaces, they can be made very fast. Therefore, the exokernel has less use for kernel extensions. Scout [25] and Vino <ref> [46] </ref> are other current extensible operating systems. These systems are just beginning to be constructed, so it is difficult to determine their relationship to exokernels in general and Aegis in particular. SPACE is a submicro-kernel that provides only low-level kernel abstractions defined by the trap and architecture interface [41].
Reference: [47] <author> M. Stonebraker. </author> <title> Operating system support for database management. </title> <journal> Communications of the ACM, </journal> <volume> 24(7) </volume> <pages> 412-418, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: Cao et al. [10] reported that application-level control over file caching can reduce application running time by 45%. Harty and Cheriton [26] and Krueger et al. [30] showed how application-specific virtual memory policies can increase application performance. Stonebraker <ref> [47] </ref> argued that inappropriate file-system implementation decisions can have a dramatic impact on the performance of databases. Thekkath and Levy [50] demonstrated that exceptions can be made an order of magnitude faster by deferring signal handling to applications. <p> Unfortunately, hiding this information makes it difficult or impossible for applications to implement their own resource management abstractions. For example, database implementors must struggle to emulate random-access record storage on top of file systems <ref> [47] </ref>. As another example, implementing lightweight threads on top of heavyweight processes usually requires compromises in correctness and performance, because the operating system hides page faults and timer interrupts [4]. In such cases, application complexity increases because of the difficulty of getting good performance from high-level abstractions.
Reference: [48] <author> A.S. Tanenbaum, R. van Renesse, H. van Staveren, G. Sharp, S.J. Mullender, A. Jansen, and G. van Rossum. </author> <title> Experiences with the Amoeba distributed operating system. </title> <journal> Communications of the ACM, </journal> <volume> 33(12) </volume> <pages> 46-63, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Aegis's efficient protected control transfer allows applications to construct a wide array of efficient IPC primitives by trading performance for additional functionality. In contrast, microkernel systems such as Amoeba <ref> [48] </ref>, Chorus [43], Mach [2], and V [15] do not allow untrusted application software to define specialized IPC primitives because virtual memory and message passing services are implemented by the kernel and trusted servers. Similarly, many other abstractions, such as page-table structures and process abstractions, cannot be modified in micro-kernels. <p> Modern revisitations of microkernels have argued for kernel extensibility <ref> [2, 43, 48] </ref>. Like microkernels, exokernels are designed to increase extensibility. Unlike traditional microkernels, an exok-ernel pushes the kernel interface much closer to the hardware, which allows for greater flexibility. An exokernel allows application-level libraries to define virtual memory and IPC abstractions.
Reference: [49] <author> C. A. Thekkath and H. M. Levy. </author> <title> Limits to low-latency communication on high-speed networks. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(2) </volume> <pages> 179-203, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Capturing the same expressiveness within a statically defined protocol is difficult. Table 11 shows the roundtrip latency over Ethernet of ASH-based network messaging and compares it to ExOS without ASHs, Ultrix, and FRPC <ref> [49] </ref> (the fastest RPC in the literature on comparable hardware). Roundtrip latency for Aegis and Ultrix was measured by ping-ponging a counter in a 60-byte UDP/IP packet 4096 times between two processes in user-space on DECstation5000/125s. The FRPC numbers are taken from the literature [49]. <p> ExOS without ASHs, Ultrix, and FRPC <ref> [49] </ref> (the fastest RPC in the literature on comparable hardware). Roundtrip latency for Aegis and Ultrix was measured by ping-ponging a counter in a 60-byte UDP/IP packet 4096 times between two processes in user-space on DECstation5000/125s. The FRPC numbers are taken from the literature [49]. They were measured on a DECstation5000/200, which is approximately 1.2 times faster than a DECstation5000/125 on SPECint92. <p> In comparison to a complete application-level implementation, ASHs save 61 microseconds. active processes on receiver. Despite being measured on a slower machine, ExOS/ASH is 81 microseconds faster than a high-performance implementation of RPC for Ultrix (FRPC) running on DECstation5000/200s and using a specialized transport protocol <ref> [49] </ref>. In fact, ExOS/ASH is only 6 microseconds slower than the lower bound for cross-machine communication on Ethernet, measured on DECstation5000/200s [49]. ASHs can be used to decouple latency-critical operations such as message reply from the scheduling of processes. <p> being measured on a slower machine, ExOS/ASH is 81 microseconds faster than a high-performance implementation of RPC for Ultrix (FRPC) running on DECstation5000/200s and using a specialized transport protocol <ref> [49] </ref>. In fact, ExOS/ASH is only 6 microseconds slower than the lower bound for cross-machine communication on Ethernet, measured on DECstation5000/200s [49]. ASHs can be used to decouple latency-critical operations such as message reply from the scheduling of processes.
Reference: [50] <author> C. A. Thekkath and H. M. Levy. </author> <title> Hardware and software support for efficient exception handling. </title> <booktitle> In Sixth International Conference on Architecture Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 110-121, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Harty and Cheriton [26] and Krueger et al. [30] showed how application-specific virtual memory policies can increase application performance. Stonebraker [47] argued that inappropriate file-system implementation decisions can have a dramatic impact on the performance of databases. Thekkath and Levy <ref> [50] </ref> demonstrated that exceptions can be made an order of magnitude faster by deferring signal handling to applications. To provide applications control over machine resources, an ex-okernel defines a low-level interface. <p> Aegis's low-level interface allows application-level software such as ExOS to manipulate resources very efficiently. Aegis's protected control transfer is almost seven times faster than the best reported implementation [33]. Aegis's exception dispatch is five times faster than the best reported implementation <ref> [50] </ref>. On identical hardware, Aegis's exception dispatch and control transfer are roughly two orders of magnitude faster than in Ultrix 4.2, a mature monolithic system. Aegis also gives ExOS (and other application-level software) flexibility that is not available in microkernel-based systems. <p> We expect this to be the common case with exokernels. 5.3 Exceptions Aegis dispatches all hardware exceptions to applications (save for system calls) using techniques similar to those described in Thekkath and Levy <ref> [50] </ref>. To dispatch an exception, Aegis performs the following actions: 1. It saves three scratch registers into an agreed-upon save area. (To avoid TLB exceptions, Aegis does this operation using physical addresses.) 2. <p> Currently, Aegis dispatches exceptions in 18 instructions. The low-level nature of Aegis allows an extremely efficient implementation: the time for exception dispatching on a DECstation5000/125 is 1.5 microseconds. This time is over five times faster than the most highly-tuned implementation in the literature (8 microseconds on DECstation5000/200 <ref> [50] </ref>, a machine that is 1.2 faster on SPECint92 than our DECstation5000/125). <p> Fast exceptions enable a number of intriguing applications: efficient page-protection traps can be used by applications such as distributed shared memory systems, persistent object stores, and garbage collectors <ref> [5, 50] </ref>. Table 5 shows exception dispatch times for unaligned pointer accesses (unalign), arithmetic overflow (overflow), attempted use of the floating point co-processor when it is disabled (coproc) and access to protected pages (prot).
Reference: [51] <author> T. von Eicken, D.E. Culler, S.C. Goldstein, and K.E. Schauser. </author> <title> Active messages: a mechanism for integrated communication and computation. </title> <booktitle> In Proceedings of the 19th International Symposium on Computer Architecture, </booktitle> <pages> pages 256-267, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Message initiation. ASHs can initiate message sends, allow ing for low-latency message replies. 4. Control initiation. ASHs perform general computation. This ability allows them to perform control operations at message reception time, implementing such computational actions as traditional active messages <ref> [51] </ref> or remote lock acquisition. It is important to note the power of the ASH computational model.
Reference: [52] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: The advantages of downloading code are that potentially expensive crossings can be avoided and that this code can run without requiring the application itself to be scheduled. Type-safe languages [9, 42], interpretation, and sandboxing <ref> [52] </ref> can be used to execute untrusted application code safely [21]. We provide examples of each of these three techniques below and discuss how secure bindings apply to the secure multiplexing of physical memory and network devices. <p> Downloading code thus allows applications to decouple latency-critical operations such as message reply from process scheduling. We examine these issues using application-specific handlers (ASHs). ASHs are untrusted application-level message-handlers that are downloaded into the kernel, made safe by a combination of code inspection [18] and sandboxing <ref> [52] </ref>, and executed upon message arrival. The issues in other contexts (e.g., disk I/O) are similar. An ASH can perform general computation. We have augmented this ability with a set of message primitives that enable the following four useful abilities: 1. Direct, dynamic message vectoring.
Reference: [53] <author> C. A. Waldspurger and W. E. Weihl. </author> <title> Lottery scheduling: Flexible proportional-share resource management. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 1-11, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Applications can use this simple mechanism to implement their own scheduling algorithms. To demonstrate this, we have built an application-level scheduler that implements stride scheduling [54], a deterministic, proportional-share scheduling mechanism that improves on recent work <ref> [53] </ref>. The ExOS implementation maintains a list of processes for which it is responsible, along with the proportional share they are to receive of its time slice (s). On every time slice wakeup, the scheduler calculates which process is to be scheduled and yields to it directly.
Reference: [54] <author> C. A. Waldspurger and W. E. Weihl. </author> <title> Stride scheduling: deterministic proportional-share resource management. Technical Memorandum MIT/LCS/TM528, </title> <publisher> MIT, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: Applications can use this simple mechanism to implement their own scheduling algorithms. To demonstrate this, we have built an application-level scheduler that implements stride scheduling <ref> [54] </ref>, a deterministic, proportional-share scheduling mechanism that improves on recent work [53]. The ExOS implementation maintains a list of processes for which it is responsible, along with the proportional share they are to receive of its time slice (s).
Reference: [55] <author> W. Wulf, E. Cohen, W. Corwin, A. Jones, R. Levin, C. Pierson, and F. Pollack. HYDRA: </author> <title> The kernel of a multiprocessing operating system. </title> <journal> Communications of the ACM, </journal> <volume> 17(6) </volume> <pages> 337-345, </pages> <month> July </month> <year> 1974. </year>
Reference-contexts: Lampson's description of CAL-TSS [31] and Brinch Hansen's microkernel paper [24] are two classic rationales. Hydra was the most ambitious early system to have the separation of kernel policy and mechanism as one of its central tenets <ref> [55] </ref>. An exokernel takes the elimination of policy one step further by removing mechanism wherever possible. This process is motivated by the insight that mechanism is policy, albeit with one less layer of indirection.
Reference: [56] <author> M. Yahara, B. Bershad, C. Maeda, and E. Moss. </author> <title> Efficient packet demultiplexing for multiple endpoints and large messages. </title> <booktitle> In Proceedings of the Winter 1994 USENIX Conference, </booktitle> <year> 1994. </year>
Reference-contexts: A salient issue in downloading code is the level at which the code is specified. High-level languages have more semantic information, which provides more information for optimizations. For example, our packet-filter language is a high-level declarative language. As a result packet filters can be merged <ref> [56] </ref> in situations 5 where merging a lower-level, imperative language would be infea-sible. <p> We briefly discuss some key features of this system. A complete discussion can be found in [22]. Message demultiplexing is the process of determining which application an incoming message should be delivered to. Packet filters are a well-known technique used to implement extensible kernel demultiplexing <ref> [6, 56] </ref>. Traditionally, packet filters are interpreted, which entails a high computational cost. Aegis uses Dynamic Packet Filter (DPF), a new packet filter system that is over an order of magnitude more efficient than previous systems. The key in our approach to making filters run fast is dynamic code generation. <p> VCODE generates machine code in approximately 10 instructions per generated instruction and runs on a number of machines (e.g., MIPS, Alpha and SPARC). We measured DPF's time to classify packets destined for one of ten TCP/IP filters, and compare its times to times for MPF <ref> [56] </ref> (a widely used packet filter engine) and PATHFINDER [6] (the fastest packet filter engine in the literature). To ensure meaningful comparisons between the systems, we ran our DPF experiments on the same hardware (a DECstation 5000/200) in user space.
References-found: 56

