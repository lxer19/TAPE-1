URL: ftp://ftp.cs.utexas.edu/pub/mooney/papers/ilpgp-ml-98.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/ml/abstracts.html
Root-URL: 
Email: Email (rupert,mecaliff,mooney)@cs.utexas.edu  
Title: An Experimental Comparison of Genetic Programming and Inductive Logic Programming on Learning Recursive List Functions  
Author: Lappoon R. Tang Mary Elaine Califf Raymond J. Mooney 
Date: March 3, 1998  
Address: Austin, TX 78712-1188  
Affiliation: Department of Computer Sciences University of Texas  
Abstract: This paper experimentally compares three approaches to program induction: inductive logic programming (ILP), genetic programming (GP), and genetic logic programming (GLP) (a variant of GP for inducing Pro-log programs). Each of these methods was used to induce four simple, recursive, list-manipulation functions. The results indicate that ILP is the most likely to induce a correct program from small sets of random examples, while GP is generally less accurate. GLP performs the worst, and is rarely able to induce a correct program. Interpretations of these results in terms of differences in search methods and inductive biases are presented. Keywords: Genetic Programming, Inductive Logic Programming, Empiri cal Comparison This paper will also be submitted to the 8th Int. Workshop on Inductive Logic Programming, 1998. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Begadano and D. Gunetti. </author> <title> Inductive Logic Programming: From Machine Learning to Software Engineering. </title> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: 1 Introduction In recent years, two paradigms for inducing programs from examples have become popular. One is inductive logic programming (ILP), in which rule-learning methods have been generalized to induce first-order Horn clauses (Prolog programs) from positive and negative examples of tuples satisfying a given target predicate <ref> [11, 7, 1] </ref>. The other is genetic programming (GP) [5, 6] in which genetic (evolutionary) algorithms are applied to tree structures instead of strings and used to induce programs in a functional language such as Lisp from input/output pairs.
Reference: [2] <author> F. Bergadano and D. Gunetti. </author> <title> An interactive system to learn functional logic programs. </title> <booktitle> In Proceedings of the Thirteenth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 1044-1049, </pages> <address> Chambery, France, </address> <year> 1993. </year>
Reference-contexts: Since GP does generally not utilize negative examples, fairly comparing it to such ILP methods is difficult. However, several ILP systems have recently been developed that induce functions from only positive examples of I/O pairs <ref> [2, 9, 13] </ref>. Consequently, we selected several of these methods, Foidl, IFoil, and FFoil, to allow for a direct comparison to GP.
Reference: [3] <author> I. Bratko. </author> <title> Prolog Programming for Artificial Intelligence. </title> <publisher> Addison Wesley, </publisher> <address> Reading:MA, </address> <year> 1990. </year>
Reference-contexts: These are a series of list-processing examples and exercises from Chapter 3 of the Bratko's text on Prolog <ref> [3] </ref> previously used to evaluate ILP systems [14]; however, such list processing functions are standard examples in both Lisp and Prolog. For each problem, the background knowledge provided consists of the list functions encountered previously in the text, which are guaranteed to be sufficient but may include irrelevant functions.
Reference: [4] <author> M. E. Califf and R. J. Mooney. </author> <title> Advantages of decision lists and implicit negatives in inductive logic programming. </title> <journal> New Generation Computing, </journal> <note> 16(3), to appear 1998. </note>
Reference-contexts: Consequently, we selected several of these methods, Foidl, IFoil, and FFoil, to allow for a direct comparison to GP. Further comparison of these three ILP system is presented in <ref> [4] </ref>. 2.1 FOIL Since all of these systems are variations on Foil [15], we first present a brief overview of this system. Foil learns a function-free, first-order, Horn-clause definition of a target predicate in terms of itself and other background predicates.
Reference: [5] <author> J. R. Koza. </author> <title> Genetic Programming: On the Programming of Computers by means of Natural Selection. </title> <publisher> MIT Press, MIT, </publisher> <year> 1992. </year>
Reference-contexts: One is inductive logic programming (ILP), in which rule-learning methods have been generalized to induce first-order Horn clauses (Prolog programs) from positive and negative examples of tuples satisfying a given target predicate [11, 7, 1]. The other is genetic programming (GP) <ref> [5, 6] </ref> in which genetic (evolutionary) algorithms are applied to tree structures instead of strings and used to induce programs in a functional language such as Lisp from input/output pairs. <p> Since choosing arbitrary points for crossover may not necessarily result in syntactically legal programs, a test on the validity of offspring is performed after each crossover. The GP code we used for all the experiments is that provided as a supplement to <ref> [5] </ref>. 4 Genetic Logic Programming Genetic logic programming was apparently first suggested in [16] as an alternative approach to ILP. The idea is to use genetic search on the space of logic programs. We have implemented our own version of GLP for inducing Pro-log programs.
Reference: [6] <author> J. R. Koza. </author> <title> Genetic Programming II: Automatic Discovery of Reusable Programs. </title> <publisher> MIT Press, MIT, </publisher> <year> 1994. </year>
Reference-contexts: One is inductive logic programming (ILP), in which rule-learning methods have been generalized to induce first-order Horn clauses (Prolog programs) from positive and negative examples of tuples satisfying a given target predicate [11, 7, 1]. The other is genetic programming (GP) <ref> [5, 6] </ref> in which genetic (evolutionary) algorithms are applied to tree structures instead of strings and used to induce programs in a functional language such as Lisp from input/output pairs.
Reference: [7] <author> N. Lavrac and S. Dzeroski. </author> <title> Inductive Logic Programming: Techniques and Applications. </title> <publisher> Ellis Horwood, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction In recent years, two paradigms for inducing programs from examples have become popular. One is inductive logic programming (ILP), in which rule-learning methods have been generalized to induce first-order Horn clauses (Prolog programs) from positive and negative examples of tuples satisfying a given target predicate <ref> [11, 7, 1] </ref>. The other is genetic programming (GP) [5, 6] in which genetic (evolutionary) algorithms are applied to tree structures instead of strings and used to induce programs in a functional language such as Lisp from input/output pairs.
Reference: [8] <author> T. Mitchell. </author> <title> Machine Learning. </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1997. </year>
Reference-contexts: The combination of greedy covering and general-to-specific search was apparently more effective at finding consistent programs than the more general evolutionary search. Standard genetic approaches do not take advantage of the general-to-specific ordering on hypotheses <ref> [8] </ref> and therefore their search is less directed. Also, the current GP system was less robust at tolerating irrelevant background knowledge.
Reference: [9] <author> R. J. Mooney and M. E. Califf. </author> <title> Induction of first-order decision lists: Results on learning the past tense of English verbs. </title> <journal> Journal of Artificial Intelligence Research, </journal> <volume> 3 </volume> <pages> 1-24, </pages> <year> 1995. </year>
Reference-contexts: Since GP does generally not utilize negative examples, fairly comparing it to such ILP methods is difficult. However, several ILP systems have recently been developed that induce functions from only positive examples of I/O pairs <ref> [2, 9, 13] </ref>. Consequently, we selected several of these methods, Foidl, IFoil, and FFoil, to allow for a direct comparison to GP. <p> The algorithm terminates when the set of positive examples are completely covered by the set of learned clauses. 2.2 FOIDL and IFOIL Foidl <ref> [9] </ref> is based on Foil but adds three important features: 1. Background knowledge is represented intensionally as a logic program. 3 2. No explicit negative examples need be supplied or constructed.
Reference: [10] <author> S. Muggleton and C. Feng. </author> <title> Efficient induction of logic programs. </title> <booktitle> In Proceedings of the First Conference on Algorithmic Learning Theory, </booktitle> <address> Tokyo, Japan, 1990. </address> <publisher> Ohmsha. </publisher>
Reference-contexts: When ILP is used to induce functions (represented by predicates with arguments for both input and output), most systems must also be given explicit negative examples of I/O pairs, i.e. 2 tuples of arguments that do not satisfy the predicate <ref> [10, 15] </ref>. Since GP does generally not utilize negative examples, fairly comparing it to such ILP methods is difficult. However, several ILP systems have recently been developed that induce functions from only positive examples of I/O pairs [2, 9, 13].
Reference: [11] <editor> S. H. Muggleton, editor. </editor> <booktitle> Inductive Logic Programming. </booktitle> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction In recent years, two paradigms for inducing programs from examples have become popular. One is inductive logic programming (ILP), in which rule-learning methods have been generalized to induce first-order Horn clauses (Prolog programs) from positive and negative examples of tuples satisfying a given target predicate <ref> [11, 7, 1] </ref>. The other is genetic programming (GP) [5, 6] in which genetic (evolutionary) algorithms are applied to tree structures instead of strings and used to induce programs in a functional language such as Lisp from input/output pairs.
Reference: [12] <author> Peter Norvig. </author> <title> Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1992. </year>
Reference-contexts: This probability was measured by running 20 independent trials in which each system is trained on the same set of random positive examples of a given size and 2 The Prolog interpreter we used was that provided with <ref> [12] </ref>. 7 determining the percentage of trials in which the system learns a completely correct definition (as determined by a manual inspection of the resulting programs). 5.2 Experimental Results The results are shown in Figure 2.
Reference: [13] <author> J. R. Quinlan. </author> <title> Learning first-order definitions of functions. </title> <journal> Journal of Artificial Intelligence Research, </journal> <volume> 5 </volume> <pages> 139-161, </pages> <year> 1996. </year>
Reference-contexts: Since GP does generally not utilize negative examples, fairly comparing it to such ILP methods is difficult. However, several ILP systems have recently been developed that induce functions from only positive examples of I/O pairs <ref> [2, 9, 13] </ref>. Consequently, we selected several of these methods, Foidl, IFoil, and FFoil, to allow for a direct comparison to GP. <p> IFoil (Intensional Foil) is just Foidl without the use of decision lists. The code for these systems is available at http://www.cs.utexas.edu/users/ml. 2.3 FFOIL FFoil <ref> [13] </ref> is a descendant of Foil with modifications similar to Foidl's, that specialize it for learning functional relations. First, FFoil assumes that the final argument of the relation is an output argument and that the other arguments of the relation uniquely determine the output argument.
Reference: [14] <author> J. R. Quinlan and R. M. Cameron-Jones. </author> <title> FOIL: A midterm report. </title> <booktitle> In Proceedings of the European Conference on Machine Learning, </booktitle> <pages> pages 3-20, </pages> <address> Vienna, </address> <year> 1993. </year>
Reference-contexts: These are a series of list-processing examples and exercises from Chapter 3 of the Bratko's text on Prolog [3] previously used to evaluate ILP systems <ref> [14] </ref>; however, such list processing functions are standard examples in both Lisp and Prolog. For each problem, the background knowledge provided consists of the list functions encountered previously in the text, which are guaranteed to be sufficient but may include irrelevant functions.
Reference: [15] <author> J.R. Quinlan. </author> <title> Learning logical definitions from relations. </title> <journal> Machine Learning, </journal> <volume> 5(3) </volume> <pages> 239-266, </pages> <year> 1990. </year>
Reference-contexts: When ILP is used to induce functions (represented by predicates with arguments for both input and output), most systems must also be given explicit negative examples of I/O pairs, i.e. 2 tuples of arguments that do not satisfy the predicate <ref> [10, 15] </ref>. Since GP does generally not utilize negative examples, fairly comparing it to such ILP methods is difficult. However, several ILP systems have recently been developed that induce functions from only positive examples of I/O pairs [2, 9, 13]. <p> Consequently, we selected several of these methods, Foidl, IFoil, and FFoil, to allow for a direct comparison to GP. Further comparison of these three ILP system is presented in [4]. 2.1 FOIL Since all of these systems are variations on Foil <ref> [15] </ref>, we first present a brief overview of this system. Foil learns a function-free, first-order, Horn-clause definition of a target predicate in terms of itself and other background predicates.
Reference: [16] <author> P. A. Whigham and R. I. McKay. </author> <title> Genetic programming and inductive logic. </title> <type> Technical Report CS14/94, </type> <institution> University College, University of New South Wales, </institution> <year> 1994. </year> <month> 14 </month>
Reference-contexts: The GP code we used for all the experiments is that provided as a supplement to [5]. 4 Genetic Logic Programming Genetic logic programming was apparently first suggested in <ref> [16] </ref> as an alternative approach to ILP. The idea is to use genetic search on the space of logic programs. We have implemented our own version of GLP for inducing Pro-log programs. Function sufficiency is maintained straightwardly by using the background predicates provided to ILP and the target predicate itself. <p> Using more specialized genetic operators could also help. For example, one could possibly experiment with crossover operators that are attempt to select "good" crossover points. As originally suggested by <ref> [16] </ref>, perhaps the right combination of GP and ILP search techniques could prove the most effective. ILP systems generally employ very directed (e.g. greedy) search that frequently works quite well, but can get stuck at local minima.
References-found: 16

