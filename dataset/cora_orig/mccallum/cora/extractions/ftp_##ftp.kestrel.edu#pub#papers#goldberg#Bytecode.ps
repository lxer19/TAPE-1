URL: ftp://ftp.kestrel.edu/pub/papers/goldberg/Bytecode.ps
Refering-URL: http://www.kestrel.edu/~goldberg/Bytecode.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: goldberg@kestrel.edu  
Title: A Specification of Java Loading and Bytecode Verification  
Author: Allen Goldberg 
Date: December 22, 1997  
Address: 3260 Hillview Av. Palo Alto, CA 94304  
Affiliation: Kestrel Institute  
Abstract: This paper gives a mathematical specification the Java Virtual Machine (JVM) bytecode verifier. The specification is an axiomatic description of the verifier that makes precise subtle aspects of the JVM semantics and the verifier. We focus on the use of data flow analysis to verify type-correctness and the use of typing contexts to insure global type consistency in the context of an arbitrary strategy for dynamic class loading. The specification types interfaces with sufficient accuracy to eliminate runtime type checks. Our approach is to specify a generic dataflow architecture and formalize the JVM verifier as an instance of this architecture. The emphasis in this paper is on readability of the specification and mathematical clarity. The specification given is consistent with the descriptions in the Lindholms and Yellins The Java Virtual Machine Specification. It less committed to certain implementation choices than Suns version 1.1 implementation. In particular, the specification does not commit an implementation to any loading strategy, and detects all type errors as early as possible. 
Abstract-found: 1
Intro-found: 1
Reference: [CP88] <author> Cai, J., and Paige, R., </author> <title> Program derivation by Fixed-Point Computation, </title> <booktitle> Science of Computer Programming Vol. </booktitle> <volume> 11, 1988/89, </volume> <pages> pp. 197-261. </pages>
Reference-contexts: The required theories and proofs are currently under development. Implementing the specification is largely a matter on selecting data structures and refining the dataflow algorithm into more efficient forms, for example by maintaining a workset of the vertices that require updating <ref> [CP88] </ref>. 7 Related Work The application of dataflow analysis to type inference is an old idea, used in SETL, a weakly-typed, high level language with sets, maps, sequences, etc. as data types [Te74].
Reference: [D97] <author> Dean, D. </author> <title> The Security of Static Typing with Dynamic Linking, </title> <booktitle> Proceedings of the Fourth ACM Conference on Computer and Communications Security, </booktitle> <month> April, </month> <year> 1997. </year> <note> http://www.cs.princeton.edu/sip/ </note>
Reference-contexts: One reason for this is that classes may reference the other recursively. More fundamentally, the JVM specification permits a class to be loaded at the latest possible momentwhen a method of the class is invoked. Dean <ref> [D97] </ref> considers how to insure global type consistency in a dynamically loaded environment. The key condition is monotonicity of the global typing context. Intuitively, this means that only consistent additions are made to the typing context as classes are loaded. <p> Saraswat in his paper Java is not type safe [S97] describes a bug in the JVM due to class name spoofing. It suggests that a formal specification of namespaces management and loading, particularly in a muti-threaded environment, should be pursued. Dean initiated such a study in <ref> [D97] </ref>. The Kimera project [K97] has uncovered bugs in the JVM using mutation analysis. They have written their own bytecode verifier. They take JVM programs mutate them and run both verifiers. If they get different results then a potential bug site has been exposed.
Reference: [C97] <author> Cohen, R. </author> <title> The Defensive Virtual Machine Specification 0.5, </title> <address> http://www.cli.com/software/djvm/index.html </address>
Reference-contexts: We treat arrays and all primitive types, and are explicit about stack overflow. He treats the jsr/ret instructions. The dJVM <ref> [C97] </ref> defines an interpreter for the JVM using ACL2, a functional language with an associated proof system. The dJVM insures type safety at runtime using type tags and so does not yet address the bytecode verifier.
Reference: [K73] <author> Kildall, G. </author> <title> A unified Approach to Global Program Optimization, </title> <booktitle> POPL, </booktitle> <year> 1973. </year>
Reference-contexts: See [Mu97] and <ref> [K73] </ref>.
Reference: [K97] <institution> The Kimera project, </institution> <note> http://kimera.cs.washington.edu/ </note>
Reference-contexts: It suggests that a formal specification of namespaces management and loading, particularly in a muti-threaded environment, should be pursued. Dean initiated such a study in [D97]. The Kimera project <ref> [K97] </ref> has uncovered bugs in the JVM using mutation analysis. They have written their own bytecode verifier. They take JVM programs mutate them and run both verifiers. If they get different results then a potential bug site has been exposed. This testing approach nicely complements formal method approaches.
Reference: [LY97] <author> Lindholm, T. and Yellin, F. </author> <title> The Java Virtual Machine Specification, </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: We then discuss our plans to implement the specified verifier using the Specware system. This is followed 3 by a discussion of related work and some conclusions. The paper assumes familiarity with the JVM. The reader is referred to Lindholms and Yellins The Java Virtual Machine Specification <ref> [LY97] </ref>. 2 The JVM Type System The JVM type system is largely derived from the Java language, but it also differs from Java in significant ways. 2.1 Primitive Types The complexity surrounding the primitive types derives from low-level efficiency and portability issues.
Reference: [Mu97] <editor> Muchnick, S., </editor> <booktitle> Advanced Compiler Design & Implementation, </booktitle> <address> Margan-Kaufmann, </address> <year> 1997. </year>
Reference-contexts: The following algorithm converges and computes the meet-over-all paths to the dataflow problem: 2fl fl Yif v = init then i else while there exist an edge e=(v, w) such that TF e (O (v))fl O (w) do O (w) 2ffZfifl flTF e (O (v)); return O; Proof. See <ref> [Mu97] </ref> and [K73].
Reference: [N97] <author> Nipkow, T. and von Oheimb, D. </author> <note> Java-light is TypeSafe Definitely To appear POPL98, http://www4.informatik.tu-muenchen.de/~nipkow/pubs/popl98.html </note>
Reference-contexts: They have written their own bytecode verifier. They take JVM programs mutate them and run both verifiers. If they get different results then a potential bug site has been exposed. This testing approach nicely complements formal method approaches. Nipkow in his paper Java-light is type safe definitely <ref> [N97] </ref> presents a formalization of the Java type system, an operational semantics for a significant subset of Java, and a proof of type soundness using Isabelle/HOL. We have not considered an operational semantics for the JVM and have not proved a type safety result.
Reference: [Q97] <author> Qian, </author> <title> Zhenyu A Formal Specification of Java Virtual Machine Instructions, </title> <type> (Draft), </type> <note> http://www.informatik.uni-bremen.de/~qian/abs-fsjvm.html </note>
Reference-contexts: Most closely related to our work is the work of Qian <ref> [Q97] </ref> who is also formalizing JVM semantics and the behavior of the bytecode verifier. We believe our formulation is crisper; for example, ours makes it clear 14 how type information from different control flow paths is merged and the requirement of distributivity of transfer functions. <p> Of course, it doesnt. The verifier lets this case through and runtime checks are used to insure type safety. Both this paper and Qian <ref> [Q97] </ref> recognized that if the bytecode verifier uses sets of types to characterize the possible types of local variables, then runtime checks can be avoided.
Reference: [S97] <author> Saraswat, V. </author> <title> Java is not type safe, </title> <address> http://www.research.att.com/~vj/bug.html </address>
Reference-contexts: Each object and interface type is uniquely named by its fully qualified name together and the name of its class loader <ref> [S97] </ref>. For the purposes of this paper, the structure of the name space of classes is not relevant. <p> The type test corresponds to searching the table but not finding a name/signature match. Saraswat in his paper Java is not type safe <ref> [S97] </ref> describes a bug in the JVM due to class name spoofing. It suggests that a formal specification of namespaces management and loading, particularly in a muti-threaded environment, should be pursued. Dean initiated such a study in [D97].
Reference: [SJ95] <author> Srinivas, Y. V. and Jllig R., Specware: </author> <title> Formal Support for Composing Software, </title> <booktitle> Proceedings of the Conference on Mathematics of Program Construction, </booktitle> <address> Kloster Irsee, Germany, </address> <month> July </month> <year> 1995. </year> <note> Kestrel Institute Technical Report KES.U.94.5, http://www.kestrel.edu/HTML/publications.html </note>
Reference-contexts: It has only loosely described functions that extract from a class file a control flow graph, and transfer functions. We plan to specify all of this using the Specware system available from Kestrel Institute. Specware <ref> [SJ95] </ref> supports the formal development of programs from specifications. In Specware, basic specifications are theories in high-order logic. Complex specifications are composed from basic specifications using high-level module operations that include parameterization.
Reference: [Te74] <author> Tennenbaum, </author> <title> Automatic Type Analysis in a Very High Level Language, </title> <type> Thesis, </type> <address> New York University 1974. </address>
Reference-contexts: dataflow algorithm into more efficient forms, for example by maintaining a workset of the vertices that require updating [CP88]. 7 Related Work The application of dataflow analysis to type inference is an old idea, used in SETL, a weakly-typed, high level language with sets, maps, sequences, etc. as data types <ref> [Te74] </ref>. Most closely related to our work is the work of Qian [Q97] who is also formalizing JVM semantics and the behavior of the bytecode verifier.
Reference: [V97] <author> Volpano, D., </author> <title> A Type-Based Approach to Program Security, </title> <booktitle> Int'l Joint Conference on the Theory and Practice of Software Development, LNCS 1214, </booktitle> <address> Lille France, </address> <month> April </month> <year> 1997, </year> <pages> pp. 607-621. </pages>
Reference-contexts: These interface requirements can be verified by an extended bytecode verifier. Finer type analysis for security or other applications. Type systems are a good vehicle to specify security models. Dataflow analysis is an effective mechanism to statically verify conformance to these models. <ref> [V97] </ref> Thus, it is desirable to design a bytecode verifier that permits extension. Our specification and the code that derives from it have the necessary modularity and locality to support such extensions.
References-found: 13

