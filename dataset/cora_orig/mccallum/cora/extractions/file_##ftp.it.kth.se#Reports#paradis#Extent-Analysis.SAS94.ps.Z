URL: file://ftp.it.kth.se/Reports/paradis/Extent-Analysis.SAS94.ps.Z
Refering-URL: http://www.it.kth.se/~lisper/
Root-URL: http://www.it.kth.se
Phone: 2  
Title: Extent Analysis of Data Fields  
Author: Bjorn Lisper and Jean-Francois Collard 
Address: S-164 40 Kista, SWEDEN  46 Allee d'Italie, 69364 LYON CEDEX 07, FRANCE  
Affiliation: 1 Department of Teleinformatics, Royal Institute of Technology, Electrum 204,  LIP, ENS Lyon,  
Abstract: Data parallelism means operating on distributed tables, data fields, in parallel. An abstract model of data parallelism, developed in [10], treats data fields as functions explicitly restricted to a finite set. Data parallel functional languages based on this view would reach a very high level of abstraction. Here we consider two static analyses that, when successful, give information about the extent of a data field with recursively defined elements, in the form of a predicate that is true wherever the data field is defined. This information can be used to preallocate the elements and map them efficiently to distributed memory, and to aid the static scheduling of operations. The predicates can be seen as extensions, providing more detail, of classical data dependency notions like strictness. The analyses are cast in the framework of abstract interpretation: a forward analysis which propagates restrictions on inputs to restrictions on outputs, and a backward analysis which propagates restrictions the other way. For both analyses, fixpoint iteration can sometimes be used to solve the equations that arise. In particular, when the predicates are linear inequalities, integer linear programming methods can be used to detect termination of fixpoint iteration. Keywords: data parallelism, functional programming, abstract interpretation, arrays. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Anderson and P. Hudak. </author> <title> Compilation of Haskell array comprehensions for scientific computing. </title> <booktitle> In Proceedings of the ACM SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 137-149. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: An example of its use is to make an array A [1 . . . n] out of a function A: Z ? ! C (where C is some cpo and Z ? is the flat cpo of integers): A n (i:1 i n): Cf. array comprehensions in Haskell <ref> [1] </ref>. The "data fields as functions" approach is, however, not implementable in its general form: to decide where f (x) 6= ?, or even whether dom (f ) is finite, amounts to solving the halting problem. For some combinations of data types and explicit where-restriction, finiteness is, however, decidable. <p> Data fields over integer tuples restricted by linear inequalities are akin to array comprehensions in Haskell, with the exception that an array comprehension must have its extent specified explicitly (and thus it need not be derived by extent analysis). Ander-son and Hudak <ref> [1] </ref> apply dependence tests to array comprehensions in order to schedule them for thunkless evaluation: the same applies to the corresponding class of data fields if the extent analysis succeeds. Optimizing affine space-time mappings should also often be possible to apply in this case, see, for instance, [13].
Reference: 2. <author> G. E. Blelloch, S. Chatterjee, J. C. Hardwick, J. Sipelstein, and M. Zagha. </author> <title> Implementation of a portable nested data-parallel language. </title> <booktitle> In Proceedings 4th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 102-111, </pages> <address> San Diego, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Especially, it offers a semantically clean way to define arrays and operations on them. The approach is, however, not limited to arrays, but applies to other proposed carriers of data parallel entities as well, such as lists [16], nested finite sequences <ref> [2, 3] </ref>, or the "xappings" in CM Lisp [17]. Operations on data fields can be expressed as second order operations on functions.
Reference: 3. <author> G. E. Blelloch and G. W. Sabot. </author> <title> Compiling Collection-Oriented Languages onto Massively Parallel Computers. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 8 </volume> <pages> 119-134, </pages> <year> 1990. </year>
Reference-contexts: Especially, it offers a semantically clean way to define arrays and operations on them. The approach is, however, not limited to arrays, but applies to other proposed carriers of data parallel entities as well, such as lists [16], nested finite sequences <ref> [2, 3] </ref>, or the "xappings" in CM Lisp [17]. Operations on data fields can be expressed as second order operations on functions.
Reference: 4. <author> S. Chatterjee, G. E. Blelloch, and A. L. Fisher. </author> <title> Size and access inference for data-parallel programs. </title> <booktitle> In Proc. ACM SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 130-144, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Some analyses on graph based intermediate forms for array-based eager functional languages can be seen more or less as special cases of our input-output analysis. In particular, this applies to the Size Inference for vectors in VCODE <ref> [4] </ref> and the Build-in-Place Analysis of the SISAL compiler described by Feo, Cann and Oldehoeft [8]. For imperative programs, we would like to mention the array reference analysis by fixed point iteration by Duesterwald, Gupta and Soffa [6].
Reference: 5. <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1976. </year>
Reference-contexts: Optimization of array bounds checking [9] is also related to our work: in fact, our analyses could be used for this purpose. Finally, it is interesting to compare the output-input analysis with Dijkstra's predicate transformers for imperative programs <ref> [5] </ref>. 8 Conclusion and Future Work We have presented two methods to perform extent analysis on recursively defined data fields. Input-output analysis finds where a data field is (possibly) defined given that we know where the inputs are defined. This is a forwards analysis.
Reference: 6. <author> E. Duesterwald, R. Gupta, and M.-L. Soffa. </author> <title> A practical data flow framework for array reference analysis and its use in optimization. </title> <booktitle> In Proc. ACM SIGPLAN'93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 68-77, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: In particular, this applies to the Size Inference for vectors in VCODE [4] and the Build-in-Place Analysis of the SISAL compiler described by Feo, Cann and Oldehoeft [8]. For imperative programs, we would like to mention the array reference analysis by fixed point iteration by Duesterwald, Gupta and Soffa <ref> [6] </ref>. Optimization of array bounds checking [9] is also related to our work: in fact, our analyses could be used for this purpose.
Reference: 7. <author> P. Feautrier. </author> <title> Parametric integer programming. </title> <journal> RAIRO Recherche Operationnelle, </journal> <volume> 22 </volume> <pages> 243-268, </pages> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: Finiteness can be decided by solving a number of integer linear programming problems. Interestingly, this can be done even when b contains symbolic parameters, e.g. through Feautrier's "Parametric Integer Programming" algo rithm <ref> [7] </ref>. Thus, there are instances where this approach to data parallelism is implementable. Especially, it offers a semantically clean way to define arrays and operations on them.
Reference: 8. <author> J. T. Feo, D. C. Cann, and R. R. Oldehoeft. </author> <title> A report on the SISAL language project. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 10 </volume> <pages> 349-366, </pages> <year> 1990. </year>
Reference-contexts: In particular, this applies to the Size Inference for vectors in VCODE [4] and the Build-in-Place Analysis of the SISAL compiler described by Feo, Cann and Oldehoeft <ref> [8] </ref>. For imperative programs, we would like to mention the array reference analysis by fixed point iteration by Duesterwald, Gupta and Soffa [6]. Optimization of array bounds checking [9] is also related to our work: in fact, our analyses could be used for this purpose.
Reference: 9. <author> R. Gupta. </author> <title> A fresh look at optimizing array bound checking. </title> <booktitle> In Proc. ACM SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 272-282, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: For imperative programs, we would like to mention the array reference analysis by fixed point iteration by Duesterwald, Gupta and Soffa [6]. Optimization of array bounds checking <ref> [9] </ref> is also related to our work: in fact, our analyses could be used for this purpose.
Reference: 10. <author> P. Hammarlund and B. Lisper. </author> <title> On the relation between functional and data parallel programming languages. </title> <booktitle> In Proc. Sixth Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 210-222. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: Especially, data parallelism has been found to be a suitable paradigm for programming massively parallel, data- and computation-intensive applications, which do not necessarily have a regular structure. In <ref> [10] </ref>, the approach was taken to consider data fields as functions over finite sets, tabulated in a distributed fashion. Operations on data fields are then simply second order operations on functions. All commonly occurring data parallel operations have side-effect free forms that are conveniently expressed in this way, see [10]. <p> In <ref> [10] </ref>, the approach was taken to consider data fields as functions over finite sets, tabulated in a distributed fashion. Operations on data fields are then simply second order operations on functions. All commonly occurring data parallel operations have side-effect free forms that are conveniently expressed in this way, see [10]. A higher order functional language can be extended with a single second order operation for explicit restriction of functions to certain arguments. <p> Extent analysis will therefore be an interesting program analysis in a compiler for a functional data parallel language along the lines described above. Sciences 2 Data Fields Following <ref> [10] </ref>, we define a data field to be a function f : C ! C 0 , where C and C 0 are complete partial orders (cpo's). Furthermore, we define dom (f ) = f x j f (x) 6= ? g. <p> More complex operations, like reduction and scan (parallel prefix), can be defined in terms of these primitive operations and recursion. See <ref> [10] </ref>. Let us finally mention an identity (slightly adapted from [10, corollary 1]), that will be of importance here: Proposition 1. <p> More complex operations, like reduction and scan (parallel prefix), can be defined in terms of these primitive operations and recursion. See [10]. Let us finally mention an identity (slightly adapted from <ref> [10, corollary 1] </ref>), that will be of importance here: Proposition 1.
Reference: 11. <author> W. D. Hillis and G. L. Steele, Jr. </author> <title> Data parallel algorithms. </title> <journal> Comm. ACM, </journal> <volume> 29(12) </volume> <pages> 1170-1183, </pages> <month> Dec. </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Data parallelism <ref> [11] </ref> is a programming paradigm where operations are made in parallel over a "data field". The term was first coined by Yang and Choo [19]; we adopt it since it is not tied to any specific "data parallel data type".
Reference: 12. <author> J. Hughes. </author> <title> Compile-time analysis of functional programs. </title> <editor> In D. A. Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, The UT Year of Programming Series, chapter 5, </booktitle> <pages> pages 117-153. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: The first analysis is cast as a traditional forwards analysis in the spirit of Mycroft [15]. The second analysis is formulated as a backwards analysis, see e.g. <ref> [12, 18] </ref>. We will define our analyses over a simple language of terms x:t where t is a term over a many-sorted signature. Any sort o in the signature is then a simple type with an interpretation [[o ]] that is a cpo. <p> So a predicate can be seen as an environment telling in which points a function is to be called. The analysis is presented in the spirit of Hughes <ref> [12] </ref>. Propagation of a constraint b through an expression t to a (data field) variable f is denoted by b t ! f: this is a predicate that tells which points of f that can be evaluated, given that the expression t is evaluated in the points defined by b.
Reference: 13. <author> B. Lisper. </author> <title> Linear programming methods for minimizing execution time of indexed computations. </title> <booktitle> In Proc. Int. Workshop on Compilers for Parallel Computers, </booktitle> <pages> pages 131-142, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Optimizing affine space-time mappings should also often be possible to apply in this case, see, for instance, <ref> [13] </ref>. Some analyses on graph based intermediate forms for array-based eager functional languages can be seen more or less as special cases of our input-output analysis.
Reference: 14. <author> B. Lisper and J.-F. Collard. </author> <title> Extent analysis of data fields. </title> <type> Research report, </type> <institution> LIP, ENS Lyon, France, </institution> <year> 1994. </year> <note> ftp: lip.ens-lyon.fr. </note>
Reference-contexts: In order to decide equality of two predicates b, b 0 of the form above, we can use ILP methods to decide whether P and P 0 , the subsets of Z n defined by b and b 0 respectively, are equal <ref> [14] </ref>. Thus, proposition 2 can be applied when, for all i greater than some j, f # a predicate formed from linear inequalities. <p> The situation for the output-input analysis is more problematic, however. Since the abstractions are predicate transformers rather than predicates, it seems less likely that there will be interesting cases that can be handled symbolically. An example which displays some of the problems is developed in <ref> [14] </ref>. Even if the cpo's under consideration are finite, the higher order function lattice for the abstract values will be prohibitively large for all but trivial cases. Yet, it seems of interest to continue pursuing analysis methods for "compile-time demand propagation", especially for languages with lazy semantics.
Reference: 15. <author> A. Mycroft. </author> <title> Abstract interpretation and optimizing transformations for applicative programs. </title> <type> PhD thesis, </type> <institution> Computer Science Dept,. Univ. of Edinburgh, </institution> <year> 1981. </year>
Reference-contexts: The second is an "output to input"-analysis that given a request for outputs derives what parts of the inputs will eventually be needed. The first analysis is cast as a traditional forwards analysis in the spirit of Mycroft <ref> [15] </ref>. The second analysis is formulated as a backwards analysis, see e.g. [12, 18]. We will define our analyses over a simple language of terms x:t where t is a term over a many-sorted signature. <p> Related work thus exists for both functional languages and imperative languages. The formulation of the input-output analysis is influenced by My-croft's thesis <ref> [15] </ref>, and the output-input analysis is inspired by the work by Wadler and Hughes on projections for backwards analysis [18].
Reference: 16. <author> D. B. Skillicorn. </author> <title> Architecture-independent parallel computation. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 38-50, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Thus, there are instances where this approach to data parallelism is implementable. Especially, it offers a semantically clean way to define arrays and operations on them. The approach is, however, not limited to arrays, but applies to other proposed carriers of data parallel entities as well, such as lists <ref> [16] </ref>, nested finite sequences [2, 3], or the "xappings" in CM Lisp [17]. Operations on data fields can be expressed as second order operations on functions.
Reference: 17. <author> G. L. Steele Jr. and W. D. Hillis. </author> <title> Connection Machine Lisp: Fine-Grained Paral- lel Symbolic Processing. </title> <type> Technical Report PL86-2, </type> <institution> Thinking Machine Corpora tion, Thinking Machines Corporation, </institution> <address> 245 First Street, Cambridge, Massachusetts 02142, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: Especially, it offers a semantically clean way to define arrays and operations on them. The approach is, however, not limited to arrays, but applies to other proposed carriers of data parallel entities as well, such as lists [16], nested finite sequences [2, 3], or the "xappings" in CM Lisp <ref> [17] </ref>. Operations on data fields can be expressed as second order operations on functions.
Reference: 18. <author> P. Wadler and R. J. M. Hughes. </author> <title> Projections for strictness analysis. </title> <editor> In G. Kahn, editor, </editor> <booktitle> Proc. Functional Programming Lang. and Computer Arch., </booktitle> <pages> pages 385-407, </pages> <address> Berlin, </address> <month> Sept. </month> <year> 1987. </year> <booktitle> Volume 274 of Lecture Notes in Comput. </booktitle> <publisher> Sci., Springer-Verlag. </publisher>
Reference-contexts: The first analysis is cast as a traditional forwards analysis in the spirit of Mycroft [15]. The second analysis is formulated as a backwards analysis, see e.g. <ref> [12, 18] </ref>. We will define our analyses over a simple language of terms x:t where t is a term over a many-sorted signature. Any sort o in the signature is then a simple type with an interpretation [[o ]] that is a cpo. <p> OR it). The framework is that of backwards analysis. Backwards analysis can be thought of as an environment being propagated from a function call to its arguments. Formally, the environments can be defined as projections <ref> [18] </ref>: a projection over a cpo C is a continuous function p: C ! C such that: - p v ID (ID is the identity function). - p ffi p = p. (idempotence) Note that for every predicate b: C ! B, f:(f n b) defines a projection over each function <p> Related work thus exists for both functional languages and imperative languages. The formulation of the input-output analysis is influenced by My-croft's thesis [15], and the output-input analysis is inspired by the work by Wadler and Hughes on projections for backwards analysis <ref> [18] </ref>. Data fields over integer tuples restricted by linear inequalities are akin to array comprehensions in Haskell, with the exception that an array comprehension must have its extent specified explicitly (and thus it need not be derived by extent analysis).
Reference: 19. <author> J. A. Yang and Y. Choo. </author> <title> Data fields as parallel programs. </title> <booktitle> In Proceedings of the Second International Workshop on Array Structures, </booktitle> <address> Montreal, Canada, </address> <month> June/July </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Data parallelism [11] is a programming paradigm where operations are made in parallel over a "data field". The term was first coined by Yang and Choo <ref> [19] </ref>; we adopt it since it is not tied to any specific "data parallel data type". Arrays are examples of data fields, but the concept can also cover more unstructured collections of data.
References-found: 19

