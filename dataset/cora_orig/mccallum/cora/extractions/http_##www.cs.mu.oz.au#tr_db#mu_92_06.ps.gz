URL: http://www.cs.mu.oz.au/tr_db/mu_92_06.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: Declarative debugging of lazy functional programs prototype system is based on NUE-Prolog, which supports a
Author: Lee Naish 
Keyword: functional programming, lazy evaluation, declarative debugging, logic programming.  
Note: The  also.  1  
Address: Parkville, Victoria 3052 Australia  
Affiliation: Department of Computer Science University of Melbourne  
Pubnum: Technical Report 92/6  
Email: (lee@cs.mu.OZ.AU)  
Abstract: We show how declarative (or algorithmic) debugging can be applied to lazy functional programming and describe a prototype implementation. We first present a declarative debugger for logic programs which relies on three primitives that determine if an atom is valid in the intended interpretation, return the successful clause instance used by a call and return single atoms from a conjunction of atoms. By simply using different interpretations and versions of these three primitives the debugger can be used to locate errors in strict and non-strict functional programs. Debugging strict code is essentially the same as debugging Horn clause programs. Debugging non-strict code can result in questions containing unevaluated expressions. These questions can be simplified by using quantified variables. 
Abstract-found: 1
Intro-found: 1
Reference: [DL87] <author> Nachum Dershowitz and Yuh-Jeng Lee. </author> <title> Deductive debugging. </title> <booktitle> In Proceedings of the Fourth IEEE Symposium on Logic Programming, </booktitle> <pages> pages 298-306, </pages> <address> San Fran-cisco, California, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Declarative debugging (also called algorithmic, rational and deductive debugging) <ref> [Sha83, Per86, SS86, DL87, Llo87] </ref> is a debugging methodology which was originally developed for logic programming. Bugs can be located using only declarative knowledge of the program (what results returned by procedures are correct) rather than procedural knowledge (the sequence of operations performed during execution).
Reference: [DNTM88] <author> Wlodek Drabent, Simin Nadjm-Tehrani, and Jan Maluszynski. </author> <title> The use of assertions in algorithmic debugging. </title> <booktitle> In Proceedings of the 1988 International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 573-581, </pages> <address> Tokyo, Japan, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: Note that there may be calls to valid in which the argument is (the representation of) a non-ground atom such as append ([A],[B],[A,B]). As in <ref> [DNTM88] </ref>, the user is asked if the universal closure of the atom is valid (the user can simply be told that all variables in questions are implicitly universally quantified). <p> An alternative would be to return a special value, bottom, from failed functional computations and use wrong answer diagnosis. A final obvious area for research is the search strategy used by the debugger. Some work has already been done for debugging Prolog <ref> [Sha83, Per86, DNTM88, PC88] </ref> and this should be easy to apply to debuggers for functional languages. It may be that there are additional benefits in the functional case. For example, the debugger described in [Per86] allows users to specify what subterms of an answer are wrong.
Reference: [Llo87] <author> J.W. Lloyd. </author> <title> Declarative error diagnosis. </title> <journal> New Generation Computing, </journal> <volume> 5(2) </volume> <pages> 133-154, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Declarative debugging (also called algorithmic, rational and deductive debugging) <ref> [Sha83, Per86, SS86, DL87, Llo87] </ref> is a debugging methodology which was originally developed for logic programming. Bugs can be located using only declarative knowledge of the program (what results returned by procedures are correct) rather than procedural knowledge (the sequence of operations performed during execution). <p> As in [DNTM88], the user is asked if the universal closure of the atom is valid (the user can simply be told that all variables in questions are implicitly universally quantified). This contrasts with <ref> [Llo87] </ref> in which valid returns all valid instances of a satisfiable atom. 3 A simple strict functional programming language NUE-Prolog [Nai91] allows evaluable functions to be defined by sets of mutually exclusive equations. The definitions are converted to NU-Prolog by a preprocessor which implements the "flattening" transformation.
Reference: [Nai86] <author> Lee Naish. </author> <title> Negation and quantifiers in NU-prolog. </title> <editor> In Ehud Shapiro, editor, </editor> <booktitle> Proceedings of the Third International Conference on Logic Programming, </booktitle> <pages> pages 624-634, </pages> <institution> Imperial College of Science and Technology, </institution> <address> London, England, </address> <month> July </month> <year> 1986. </year> <note> published as Lecture Notes in Computer Science 225 by Springer-Verlag. </note>
Reference-contexts: It is essentially the same as the top down debugger of [SS86] but is refined so as to avoid using concrete data structures and non-logical primitives such as cut. The if-then-else construct of NU-Prolog <ref> [Nai86] </ref> (which has well defined declarative semantics) is used. The code relies on three additional procedures: valid/1, successful clause/2 and c member/2.
Reference: [Nai91] <author> Lee Naish. </author> <title> Adding equations to NU-Prolog. </title> <booktitle> Proceedings of The Third International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 15-26, </pages> <month> August, </month> <year> 1991. </year> <type> Technical Report 91/2, </type> <institution> Department of Computer Science, University of Melbourne. </institution>
Reference-contexts: This contrasts with [Llo87] in which valid returns all valid instances of a satisfiable atom. 3 A simple strict functional programming language NUE-Prolog <ref> [Nai91] </ref> allows evaluable functions to be defined by sets of mutually exclusive equations. The definitions are converted to NU-Prolog by a preprocessor which implements the "flattening" transformation. This takes an evaluable function with N arguments and - 4 - converts it into a predicate with N+1 arguments.
Reference: [Nai92] <author> Lee Naish. </author> <title> Declarative diagnosis of missing answers. </title> <journal> New Generation Computing, </journal> <note> to appear, 1992. Technical Report 88/9 (revised), </note> <institution> Department of Computer Science, University of Melbourne. </institution>
Reference-contexts: That is, the body of the clause instance is valid in the intended interpretation but the head is not. This can be formalised by the logic below (written in Prolog syntax; a generalisation of the logic presented in <ref> [Nai92] </ref>). The variables range over representations of atoms and conjunctions in the program being debugged. valid (A) is true if A is the representation of a formula which is valid in the intended interpretation. This can be implemented by querying the user or using a runnable specification.
Reference: [NF92] <author> Henrik Nilsson and Peter Fritzson. </author> <title> Algorithmic debugging of lazy functional languages. </title> <booktitle> Proceedings of The Fourth International Symposium on Programming Language Implementation and Logic Programming, to appear, </booktitle> <month> August, </month> <year> 1992. </year>
Reference-contexts: The instance of the equation to be returned is formed as before (but now may contain variables). 9 Related work The only other attempt at applying declarative debugging to functional programming that we know of is <ref> [NF92] </ref>. An earlier version of this paper actually inspired our work. It gave an algorithm which results in unacceptably complex questions to the user. <p> In contrast, the debugging method we use asks questions about single atoms in the Prolog case and equations with one evaluable function symbol in the functional case. The algorithm presented in <ref> [NF92] </ref> is very similar to our algorithm. The evaluated versions of subterms are used wherever possible in questions. Underscores and elipsis (...) are used, though quantification is not mentioned explicitly. The starting point for their work was a debugger with a specified and somewhat "smart" search strategy.
Reference: [PC88] <author> Luis Moniz Pereira and Miguel Calejo. </author> <title> A framework for prolog debugging. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Proceedings of the Fifth International Conference/Symposium on Logic Programming, </booktitle> <pages> pages 481-495, </pages> <address> Seat-tle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: An alternative would be to return a special value, bottom, from failed functional computations and use wrong answer diagnosis. A final obvious area for research is the search strategy used by the debugger. Some work has already been done for debugging Prolog <ref> [Sha83, Per86, DNTM88, PC88] </ref> and this should be easy to apply to debuggers for functional languages. It may be that there are additional benefits in the functional case. For example, the debugger described in [Per86] allows users to specify what subterms of an answer are wrong.
Reference: [Per86] <author> Luis Moniz Pereira. </author> <title> Rational debugging in logic programming. </title> <editor> In Ehud Shapiro, editor, </editor> <booktitle> Proceedings of the Third International Conference on Logic Programming, </booktitle> - <pages> 12 - pages 203-210, </pages> <address> London, England, </address> <month> July </month> <year> 1986. </year> <note> published as Lecture Notes in Com--puter Science 225 by Springer-Verlag. </note>
Reference-contexts: 1 Introduction Declarative debugging (also called algorithmic, rational and deductive debugging) <ref> [Sha83, Per86, SS86, DL87, Llo87] </ref> is a debugging methodology which was originally developed for logic programming. Bugs can be located using only declarative knowledge of the program (what results returned by procedures are correct) rather than procedural knowledge (the sequence of operations performed during execution). <p> An alternative would be to return a special value, bottom, from failed functional computations and use wrong answer diagnosis. A final obvious area for research is the search strategy used by the debugger. Some work has already been done for debugging Prolog <ref> [Sha83, Per86, DNTM88, PC88] </ref> and this should be easy to apply to debuggers for functional languages. It may be that there are additional benefits in the functional case. For example, the debugger described in [Per86] allows users to specify what subterms of an answer are wrong. <p> Some work has already been done for debugging Prolog [Sha83, Per86, DNTM88, PC88] and this should be easy to apply to debuggers for functional languages. It may be that there are additional benefits in the functional case. For example, the debugger described in <ref> [Per86] </ref> allows users to specify what subterms of an answer are wrong. Information concerning what procedures produced what variable bindings is then used to locate the bug more directly.
Reference: [Sha83] <author> Ehud Y. Shapiro. </author> <title> Algorithmic program debugging. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1983. </year>
Reference-contexts: 1 Introduction Declarative debugging (also called algorithmic, rational and deductive debugging) <ref> [Sha83, Per86, SS86, DL87, Llo87] </ref> is a debugging methodology which was originally developed for logic programming. Bugs can be located using only declarative knowledge of the program (what results returned by procedures are correct) rather than procedural knowledge (the sequence of operations performed during execution). <p> An alternative would be to return a special value, bottom, from failed functional computations and use wrong answer diagnosis. A final obvious area for research is the search strategy used by the debugger. Some work has already been done for debugging Prolog <ref> [Sha83, Per86, DNTM88, PC88] </ref> and this should be easy to apply to debuggers for functional languages. It may be that there are additional benefits in the functional case. For example, the debugger described in [Per86] allows users to specify what subterms of an answer are wrong.
Reference: [SS86] <author> Leon Sterling and Ehud Shapiro. </author> <title> The art of Prolog: </title> <booktitle> advanced programming techniques. Logic Programming series. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: 1 Introduction Declarative debugging (also called algorithmic, rational and deductive debugging) <ref> [Sha83, Per86, SS86, DL87, Llo87] </ref> is a debugging methodology which was originally developed for logic programming. Bugs can be located using only declarative knowledge of the program (what results returned by procedures are correct) rather than procedural knowledge (the sequence of operations performed during execution). <p> The debugger below returns an incorrect clause instance as before but uses an additional input: the representation of a goal which has succeeded incorrectly (the incorrect answer substitution has been applied). It is essentially the same as the top down debugger of <ref> [SS86] </ref> but is refined so as to avoid using concrete data structures and non-logical primitives such as cut. The if-then-else construct of NU-Prolog [Nai86] (which has well defined declarative semantics) is used. The code relies on three additional procedures: valid/1, successful clause/2 and c member/2.
References-found: 11

