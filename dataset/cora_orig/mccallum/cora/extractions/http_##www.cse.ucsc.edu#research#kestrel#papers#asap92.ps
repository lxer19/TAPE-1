URL: http://www.cse.ucsc.edu/research/kestrel/papers/asap92.ps
Refering-URL: http://www.cse.ucsc.edu/research/kestrel/papers.html
Root-URL: http://www.cse.ucsc.edu
Email: rph@ce.ucsc.edu  
Title: Programming Systolic Arrays  
Author: Richard Hughey 
Address: Santa Cruz, CA 95064  
Affiliation: Computer Engineering Board University of California  
Date: Aug. 4-7, 1992.  
Note: Proc. Int. Conf. Aplication-Specific Array Processors, IEEE Computer Society,  
Abstract: This paper presents the New Systolic Language as a general solution to the problem systolic programming. The language provides a simple programming interface for systolic algorithms suitable for different hardware platforms and software simulators. The New Systolic Language hides the details and potential hazards of inter-processor communication, allowing data flow only via abstract systolic data streams. Data flows and systolic cell programs for the co-processor are integrated with host functions, enabling a single file to specify a complete systolic program.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. M. Chandy and J. Misra, </author> <title> "Systolic algorithms as programs," </title> <journal> Distributed Computing, </journal> <volume> no. 1, </volume> <pages> pp. 177-183, </pages> <year> 1986. </year>
Reference-contexts: Because of the close relationship between recurrence equations and systolic algorithms, functional or rule-based languages are one of the most precise ways to specify a systolic algorithm. Chandy and Misra's language, for example, provides a direct means of expressing an indexed recurrence and its initial conditions <ref> [1] </ref>. As they readily admit, however, their language does not address the problem of systolic mapping, dealing primarily with formal algorithm development and verification. Combining the language with a mapping methodology [4, 14, 17, 25] could eliminate this problem. <p> Table 1: SStream member functions. notation, indexing the systolic data stream relative to the current input or output. Thus, the expression Cost [0] is equivalent to both Cost.in () and Cost as an rvalue, all of which refer to the stream input value d i1;j1 . Cost <ref> [1] </ref> retrieves the value one time unit down the systolic stream, or d i1;j (produced by F j last time step). Similarly, negative indices retrieve values upstream, so Cost [-1] retrieves the value one time unit up the systolic stream, or d i;j1 (produced by F j1 last time step).
Reference: [2] <author> M. C. Chen and C. A. Mead, </author> <title> "Concurrent algorithms as space-time recursion equations," in VLSI and Modern Signal Processing (S. </title> <editor> Y. Kung, H. J. Whitehouse, and T. Kailath, eds.), ch. </editor> <volume> 13, </volume> <pages> pp. 224-240, </pages> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: Combining the language with a mapping methodology [4, 14, 17, 25] could eliminate this problem. Chen and Mead also present a syntactic means of expressing systolic programs as recursive functions <ref> [2] </ref>. Luk and Jones have developed a functional language for deriving and evaluating systolic mappings [15]. The language can not only define algorithms, but can also define the hardware structure of the circuit implementation. This is particularly helpful for evaluating space-time tradeoffs and connecting subarrays to solve multi-stage problems.
Reference: [3] <author> C. DeLisi, </author> <title> "Computers in molecular biology: </title> <booktitle> Current applications and emerging trends," Science, </booktitle> <volume> vol. 246, </volume> <pages> pp. 47-51, </pages> <month> 6 Apr. </month> <year> 1988. </year>
Reference-contexts: Code::run (&horner, &Coeff, &X, &Y); - 5 Programming Example The SSRA and the Brown Systolic Array implementation were greatly influenced (and indeed targeted for) the sequence comparison problems of the Human Genome Project <ref> [3] </ref>. As the 3-billion-character string of human DNA is transcribed, the availability of fast data analysis tools and co-processors will become critical. The architectural parameters of B-SYS (in particular, bits per word and registers per register bank) were determined in a large part by the requirements of these algorithms.
Reference: [4] <author> V. V. Dongen, </author> <title> "Quasi-regular arrays: definition and design methodology," in Systolic Array Processors (J. </title> <editor> McCanny, J. McWhirter, and J. Earl Swartzlander, </editor> <booktitle> eds.), </booktitle> <pages> pp. 126-135, </pages> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: As they readily admit, however, their language does not address the problem of systolic mapping, dealing primarily with formal algorithm development and verification. Combining the language with a mapping methodology <ref> [4, 14, 17, 25] </ref> could eliminate this problem. Chen and Mead also present a syntactic means of expressing systolic programs as recursive functions [2]. Luk and Jones have developed a functional language for deriving and evaluating systolic mappings [15].
Reference: [5] <author> M. A. Ellis and B. Stroustrup, </author> <title> The Annotated C++ Reference Manual. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Cell programs can call user-defined routines which process NSL data types (registers, flags, and data streams) as well as a large number of standard operators and functions. The NSL prototype system was developed in the object-oriented C ++ language which provided the ability to overload operators <ref> [5] </ref>. Thus, common operations have been defined for all basic systolic data types (e.g., when X and Y are systolic streams, the operation X+Y is evaluated by NSL to generate co-processor instructions). C ++ has greatly simplified the evolution and evaluation of the language. <p> Constant parameters can be specified with the const keyword <ref> [5] </ref>. 611 Register min (const Register& r1, const Register& r2) - return (select ((r1 &lt; r2), r1, r2)); - Register bridge_test (void) - Register result; int i = 0; for ( ; i &lt; Config::word; i+= 2) - result &lt;< 2; result++; - return (result); - flows. 4.3 Main Programs The
Reference: [6] <author> B. R. Engstrom and P. R. Capello, </author> <title> "The SDEF systolic programming system," in Concurrent Computations (S. </title> <editor> K. Tewksbury, B. W. Dickinson, and S. C. Schwartz, eds.), ch. </editor> <volume> 15, </volume> <pages> pp. 263-301, </pages> <address> New York: </address> <publisher> Plenum Press, </publisher> <year> 1988. </year>
Reference-contexts: As the semantics of these two paradigms are so closely related, it is often difficult to categorize a given language. Engstrom and Capello's SDEF systolic design environment <ref> [6] </ref> is a dependency mapping system that has greatly influenced the specification requirements of the New Systolic Language. SDEF cleanly separates systolic cell programs from the macroscopic systolic data movement, as can be seen in Figure 1.
Reference: [7] <author> M. J. Foster and H. T. Kung, </author> <title> "The design of special-purpose VLSI chips," </title> <booktitle> Computer, </booktitle> <pages> pp. 26-40, </pages> <month> Jan. </month> <year> 1980. </year>
Reference-contexts: Systolic algorithms are perhaps the most efficient class of algorithm for massively parallel implementation, using regular data flow through a processor network to harness the inherent parallelism of a problem and to avoid communication bottlenecks in the parallel processor <ref> [7] </ref>. A systolic algorithm has two major parts: a cell program and a data flow specification. The cell program defines the local operations of each processing element, while the data flow describes the communication network and its use.
Reference: [8] <author> M. Gokhale et al., </author> <title> "Building and using a highly parallel programmable logic array," </title> <journal> Computer, </journal> <volume> vol. 24, </volume> <pages> pp. 81-89, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: both of length n, is the solution d n;n of the recurrence: d 0;0 = 0 d 0;j = d 0;j1 + 1 8 : d i1;j1 if a i = b j , otherwise d i;j1 +1 Several more complicated variations of this problem are discussed in the literature <ref> [8, 9, 11, 19] </ref>. One way of mapping this recurrence to a programmable systolic array is to let each processing element F correspond to a specific j value, letting d i;j and d i+1;j be computed in F j separated by one unit of time.
Reference: [9] <author> R. Hughey, </author> <title> Programmable Systolic Arrays. </title> <type> PhD thesis, </type> <institution> Dept. Computer Science, Brown University, Providence, RI, </institution> <year> 1991. </year> <type> Tech. Rep. </type> <institution> CS-91-34. </institution>
Reference-contexts: instruction E 0 min (W 0 ; W 1 ) not only performs a minimization but also moves data eastward. (The registers are addressed relative to the functional units, east or west in the linear case.) The SSRA design readily extends to other topologies, including square and octagonal mesh architectures <ref> [9] </ref>. 607 P i1 P i P i+1 The Brown Systolic Array is an 8-bit linear SSRA machine designed for sequence comparison and other combinatorial applications (Figure 2b). Each 6.9 mm fi 6.8 mm 2-CMOS chip contains 47 functional units and 48 register banks (85 000 transistors). <p> both of length n, is the solution d n;n of the recurrence: d 0;0 = 0 d 0;j = d 0;j1 + 1 8 : d i1;j1 if a i = b j , otherwise d i;j1 +1 Several more complicated variations of this problem are discussed in the literature <ref> [8, 9, 11, 19] </ref>. One way of mapping this recurrence to a programmable systolic array is to let each processing element F correspond to a specific j value, letting d i;j and d i+1;j be computed in F j separated by one unit of time. <p> Functional units can look short distances upstream and downstream as they compute values to place in in streams. The shared registers of the SSRA design greatly simplify the implementation of this feature. 615 a 0 b 2 [0] b 2 [10] b 2 [19] b 1 <ref> [9] </ref> b 1 [0] b 1 [19] b 1 [10] b 2 [9] 6 Enhancements The most obvious future development issue is the extension of NSL to topologies of two or more dimensions. <p> The shared registers of the SSRA design greatly simplify the implementation of this feature. 615 a 0 b 2 [0] b 2 [10] b 2 [19] b 1 <ref> [9] </ref> b 1 [0] b 1 [19] b 1 [10] b 2 [9] 6 Enhancements The most obvious future development issue is the extension of NSL to topologies of two or more dimensions. In concert with this, stream direction specifications to access arbitrary processing elements within these topologies should be added.
Reference: [10] <author> R. Hughey and D. P. Lopresti, "B-SYS: </author> <title> A 470-processor programmable systolic array," </title> <booktitle> in Proc. Int. Conf. Parallel Processing (C. </booktitle> <editor> lin Wu, ed.), </editor> <volume> vol. 1, </volume> <pages> pp. 580-583, </pages> <publisher> CRC Press, </publisher> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: The programmer should not have to specify the physical names of queues, ports, registers, or bits. 3 The Systolic Shared Register Architecture A previous paper <ref> [10] </ref> presented the Systolic Shared Register Architecture (SSRA) for programmable systolic computation (Figure 2a). SSRA machines have four distinguishing features: regular topology, SIMD broadcast instructions, shared register banks, and stream oriented communication. <p> Functional units can look short distances upstream and downstream as they compute values to place in in streams. The shared registers of the SSRA design greatly simplify the implementation of this feature. 615 a 0 b 2 [0] b 2 <ref> [10] </ref> b 2 [19] b 1 [9] b 1 [0] b 1 [19] b 1 [10] b 2 [9] 6 Enhancements The most obvious future development issue is the extension of NSL to topologies of two or more dimensions. <p> The shared registers of the SSRA design greatly simplify the implementation of this feature. 615 a 0 b 2 [0] b 2 <ref> [10] </ref> b 2 [19] b 1 [9] b 1 [0] b 1 [19] b 1 [10] b 2 [9] 6 Enhancements The most obvious future development issue is the extension of NSL to topologies of two or more dimensions. In concert with this, stream direction specifications to access arbitrary processing elements within these topologies should be added.
Reference: [11] <author> S. Karlin and S. F. Altschul, </author> <title> "Methods for assessing the statistical significance of molecular sequence features by using general scoring schemes," </title> <journal> Proc. Natl. Acad. Sci. USA, </journal> <volume> vol. 87, </volume> <pages> pp. 2264-2268, </pages> <year> 1990. </year>
Reference-contexts: both of length n, is the solution d n;n of the recurrence: d 0;0 = 0 d 0;j = d 0;j1 + 1 8 : d i1;j1 if a i = b j , otherwise d i;j1 +1 Several more complicated variations of this problem are discussed in the literature <ref> [8, 9, 11, 19] </ref>. One way of mapping this recurrence to a programmable systolic array is to let each processing element F correspond to a specific j value, letting d i;j and d i+1;j be computed in F j separated by one unit of time.
Reference: [12] <author> S. Y. Kung, </author> <title> VLSI Array Processors. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Hearts, logical data connections are defined in an external table and graph (i.e., not in the textual programming language of the cell program), while data movement is the result of the cell program's port or channel input and output instructions, a typical problem of shared asynchronous variables and similar constructs <ref> [12] </ref>. The Apply system on the iWarp multiprocessor features localized cell programs but, being designed specifically for multiprocessor image processing, does not provide general flow directives [24].
Reference: [13] <author> M. S. Lam, </author> <title> A Systolic Array Optimizing Compiler. </title> <address> Dordrecht, The Netherlands: </address> <publisher> Kluwer Academic Publishers, </publisher> <year> 1989. </year>
Reference-contexts: For example, W2 and Hearts provide for the replication of a cell program but still require the programmer to access the communication links within the cell program <ref> [13, 20] </ref>. W2 cell programs include send and receive statements for placing data on one or the other of Warp's physical queues.
Reference: [14] <author> P. Lee and Z. Kedem, </author> <title> "Synthesizing linear array algorithms from nested FOR loop algorithms," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 37, </volume> <pages> pp. 1578-1598, </pages> <month> Dec. </month> <year> 1988. </year>
Reference-contexts: As they readily admit, however, their language does not address the problem of systolic mapping, dealing primarily with formal algorithm development and verification. Combining the language with a mapping methodology <ref> [4, 14, 17, 25] </ref> could eliminate this problem. Chen and Mead also present a syntactic means of expressing systolic programs as recursive functions [2]. Luk and Jones have developed a functional language for deriving and evaluating systolic mappings [15].
Reference: [15] <author> W. Luk and G. Jones, </author> <title> "The derivation of regular synchronous circuits," </title> <booktitle> in Proc. First Int. Conf. </booktitle> <editor> Systolic Arrays (K. Bromley, S. Y. Kung, and E. Swartzlander, </editor> <booktitle> eds.), </booktitle> <pages> pp. 305-314, </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1988. </year>
Reference-contexts: Combining the language with a mapping methodology [4, 14, 17, 25] could eliminate this problem. Chen and Mead also present a syntactic means of expressing systolic programs as recursive functions [2]. Luk and Jones have developed a functional language for deriving and evaluating systolic mappings <ref> [15] </ref>. The language can not only define algorithms, but can also define the hardware structure of the circuit implementation. This is particularly helpful for evaluating space-time tradeoffs and connecting subarrays to solve multi-stage problems.
Reference: [16] <author> D. May and R. Taylor, </author> <title> "OCCAM|an overview," </title> <journal> Microprocessors and Microsystems, </journal> <pages> pp. 73-79, </pages> <month> Mar. </month> <year> 1984. </year>
Reference-contexts: General-purpose parallel programming languages such as Paris or C * on the Connection Machine and Occam on Transputer arrays can also be used for systolic programming, but often require the programmer to be even more concerned with low-level architectural details <ref> [16, 23] </ref>. One advantage of these languages, however, is that both the systolic program and the host or main program can be expressed in a common language, simplifying the interface between the systolic algorithm and the rest of the computer. Systolic design languages have many advantages over hardware-specific languages.
Reference: [17] <author> D. Moldovan, </author> <title> "On the analysis and synthesis of VLSI algorithms," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 31, </volume> <pages> pp. 1121-1126, </pages> <month> Nov. </month> <year> 1982. </year>
Reference-contexts: As they readily admit, however, their language does not address the problem of systolic mapping, dealing primarily with formal algorithm development and verification. Combining the language with a mapping methodology <ref> [4, 14, 17, 25] </ref> could eliminate this problem. Chen and Mead also present a syntactic means of expressing systolic programs as recursive functions [2]. Luk and Jones have developed a functional language for deriving and evaluating systolic mappings [15].
Reference: [18] <author> D. I. Moldovan and J. A. B. Fortes, </author> <title> "Partitioning and mapping algorithms into fixed size systolic arrays," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 35, </volume> <pages> pp. 1-12, </pages> <month> Jan. </month> <year> 1986. </year>
Reference-contexts: Thus, by the sequence comparison algorithm, these processing elements will not affect the cost values exiting the array. Similarly, padding strings with null characters will have an entirely predictable effect on the distance computation. Performing functions on undersized arrays is a more complicated, though still achievable, goal <ref> [18] </ref>.
Reference: [19] <author> D. Sankoff and J. B. Kruskal, </author> <title> Time Warps, String Edits, and Macromolecules: The Theory and Practice of Sequence Comparison. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: both of length n, is the solution d n;n of the recurrence: d 0;0 = 0 d 0;j = d 0;j1 + 1 8 : d i1;j1 if a i = b j , otherwise d i;j1 +1 Several more complicated variations of this problem are discussed in the literature <ref> [8, 9, 11, 19] </ref>. One way of mapping this recurrence to a programmable systolic array is to let each processing element F correspond to a specific j value, letting d i;j and d i+1;j be computed in F j separated by one unit of time. <p> Functional units can look short distances upstream and downstream as they compute values to place in in streams. The shared registers of the SSRA design greatly simplify the implementation of this feature. 615 a 0 b 2 [0] b 2 [10] b 2 <ref> [19] </ref> b 1 [9] b 1 [0] b 1 [19] b 1 [10] b 2 [9] 6 Enhancements The most obvious future development issue is the extension of NSL to topologies of two or more dimensions. <p> The shared registers of the SSRA design greatly simplify the implementation of this feature. 615 a 0 b 2 [0] b 2 [10] b 2 <ref> [19] </ref> b 1 [9] b 1 [0] b 1 [19] b 1 [10] b 2 [9] 6 Enhancements The most obvious future development issue is the extension of NSL to topologies of two or more dimensions. In concert with this, stream direction specifications to access arbitrary processing elements within these topologies should be added.
Reference: [20] <author> L. Snyder, </author> <title> "Hearts: A dialect of the Poker programming environment specialised to systolic computation," in Systolic Arrays (W. </title> <editor> Moore et. al., </editor> <booktitle> eds.), </booktitle> <pages> pp. 71-80, </pages> <address> Boston, MA: Adam Hilger, </address> <year> 1987. </year>
Reference-contexts: For example, W2 and Hearts provide for the replication of a cell program but still require the programmer to access the communication links within the cell program <ref> [13, 20] </ref>. W2 cell programs include send and receive statements for placing data on one or the other of Warp's physical queues.
Reference: [21] <author> J. T. Stasko, </author> <title> "Tango: A framework and system for algorithm animation," </title> <journal> Computer, </journal> <volume> vol. 23, </volume> <pages> pp. 27-39, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: The prototype NSL system generates B-SYS assembly code which can either be printed out for inspection or sent to the B-SYS simulator and animator (based on the xtango algorithm animation package <ref> [21] </ref>). Interfaces to a B-SYS system and to a general-purpose massively parallel machine are under development, as are many enhancements to and refinements of the language.
Reference: [22] <author> J. A. Storer, </author> <title> Data Compression. </title> <address> Rockville, MD: </address> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: The entire algorithm requires n 3 n 2 time to complete, at which point the C matrix is read out of the array. Other future work includes support for wavefront programming. Some algorithms, such as systolic data compression <ref> [22] </ref>, do not have a fixed relationship between input to and output from the array: the delay between input and output depends on how compactly the text can be compressed. Methods for automatically providing sentinels or other mechanisms which implement wavefront programming should be evaluated.
Reference: [23] <institution> Thinking Machines Corporation, </institution> <address> Cambridge, MA, </address> <note> Paris Release Notes (version 5.1), </note> <month> June </month> <year> 1989. </year>
Reference-contexts: General-purpose parallel programming languages such as Paris or C * on the Connection Machine and Occam on Transputer arrays can also be used for systolic programming, but often require the programmer to be even more concerned with low-level architectural details <ref> [16, 23] </ref>. One advantage of these languages, however, is that both the systolic program and the host or main program can be expressed in a common language, simplifying the interface between the systolic algorithm and the rest of the computer. Systolic design languages have many advantages over hardware-specific languages.
Reference: [24] <author> J. A. Webb, </author> <title> "Steps toward architecture-independent image processing," </title> <journal> Computer, </journal> <volume> vol. 25, </volume> <pages> pp. 21-31, </pages> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: The Apply system on the iWarp multiprocessor features localized cell programs but, being designed specifically for multiprocessor image processing, does not provide general flow directives <ref> [24] </ref>. General-purpose parallel programming languages such as Paris or C * on the Connection Machine and Occam on Transputer arrays can also be used for systolic programming, but often require the programmer to be even more concerned with low-level architectural details [16, 23].
Reference: [25] <author> Y. Yaacoby and P. R. Capello, </author> <title> "Scheduling a system of affine recurrence equations onto a systolic array," </title> <booktitle> in Proc. First Int. Conf. </booktitle> <editor> Systolic Arrays (K. Bromley, S. Y. Kung, and E. Swartzlander, </editor> <booktitle> eds.), </booktitle> <pages> pp. 373-382, </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1988. </year> <month> 618 </month>
Reference-contexts: As they readily admit, however, their language does not address the problem of systolic mapping, dealing primarily with formal algorithm development and verification. Combining the language with a mapping methodology <ref> [4, 14, 17, 25] </ref> could eliminate this problem. Chen and Mead also present a syntactic means of expressing systolic programs as recursive functions [2]. Luk and Jones have developed a functional language for deriving and evaluating systolic mappings [15].
References-found: 25

