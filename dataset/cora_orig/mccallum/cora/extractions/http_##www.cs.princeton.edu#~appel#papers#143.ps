URL: http://www.cs.princeton.edu/~appel/papers/143.ps
Refering-URL: http://www.cs.princeton.edu/~appel/papers/
Root-URL: http://www.cs.princeton.edu
Title: Simple Generational Garbage Collection and Fast Allocation a garbage collector can be so efficient that
Author: Andrew W. Appel 
Keyword: garbage collection, dynamic memory allocation  
Note: Such  
Date: March 1988 revised September 1988  
Address: Princeton, NJ 08544  
Affiliation: Department of Computer Science Princeton University  
Abstract: Generational garbage collection algorithms achieve efficiency because newer records point to older records; the only way an older record can point to a newer record is by a store operation to a previously-created record, and such operations are rare in many languages. A garbage collector that concentrates just on recently allocated records can take advantage of this fact. This paper presents a simple, efficient, low-overhead version of generational garbage collection with fast allocation, suitable for implementation in a Unix environment. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> John McCarthy, </author> <title> ``Recursive functions of symbolic expressions and their computation by machine - I,'' </title> <journal> Communications of the ACM, </journal> <volume> vol. 3, no. 1, </volume> <pages> pp. 184-195, </pages> <publisher> ACM, </publisher> <year> 1960. </year>
Reference-contexts: The ``mark-and-sweep'' algorithm <ref> [1] </ref> first traverses and marks using depth-first search all of the records reachable from root pointers. <p> In the ``destination region'' there are two pointers, scan and next that are initially at the begining of the region. For each root pointer R, we perform the following procedure, replacing R by forward ( R): forward (R) = if R points into the source region then if R <ref> [1] </ref> points into the destination region then return R [1] else copy the record pointed to by R to location NEXT assign NEXT into R [1] increment NEXT to point past the copy of the record return R [1] else return R In this program, R [1] means the first field <p> For each root pointer R, we perform the following procedure, replacing R by forward ( R): forward (R) = if R points into the source region then if R <ref> [1] </ref> points into the destination region then return R [1] else copy the record pointed to by R to location NEXT assign NEXT into R [1] increment NEXT to point past the copy of the record return R [1] else return R In this program, R [1] means the first field of the record pointed to by R. <p> R, we perform the following procedure, replacing R by forward ( R): forward (R) = if R points into the source region then if R <ref> [1] </ref> points into the destination region then return R [1] else copy the record pointed to by R to location NEXT assign NEXT into R [1] increment NEXT to point past the copy of the record return R [1] else return R In this program, R [1] means the first field of the record pointed to by R. <p> (R) = if R points into the source region then if R <ref> [1] </ref> points into the destination region then return R [1] else copy the record pointed to by R to location NEXT assign NEXT into R [1] increment NEXT to point past the copy of the record return R [1] else return R In this program, R [1] means the first field of the record pointed to by R. The forward procedure copies the source record to the destination, and returns a pointer to the destination; unless the record has been previously copied, in which case R [1] points to <p> region then if R <ref> [1] </ref> points into the destination region then return R [1] else copy the record pointed to by R to location NEXT assign NEXT into R [1] increment NEXT to point past the copy of the record return R [1] else return R In this program, R [1] means the first field of the record pointed to by R. The forward procedure copies the source record to the destination, and returns a pointer to the destination; unless the record has been previously copied, in which case R [1] points to the copy, and R [1] is returned without <p> return R <ref> [1] </ref> else return R In this program, R [1] means the first field of the record pointed to by R. The forward procedure copies the source record to the destination, and returns a pointer to the destination; unless the record has been previously copied, in which case R [1] points to the copy, and R [1] is returned without making a new copy. - 6 - After the procedure forward is applied to each root, it is then applied to each word in the destination region. <p> this program, R <ref> [1] </ref> means the first field of the record pointed to by R. The forward procedure copies the source record to the destination, and returns a pointer to the destination; unless the record has been previously copied, in which case R [1] points to the copy, and R [1] is returned without making a new copy. - 6 - After the procedure forward is applied to each root, it is then applied to each word in the destination region.
Reference: 2. <author> Robert R. Fenichel and Jerome C. Yochelson, </author> <title> ``A LISP garbage-collector for virtual-memory computer systems,'' </title> <journal> Communications of the ACM, </journal> <volume> vol. 12, no. 11, </volume> <pages> pp. 611-612, </pages> <publisher> ACM, </publisher> <year> 1969. </year>
Reference-contexts: Then all the records in memory are examined in order of their - 2 - addresses, and the unmarked records are put onto a free list, to be re-used when the user's program (called the mutator*) allocates new records. The ``copying'' algorithm <ref> [2] </ref> traverses the records reachable from root pointers, copying these records to another area of memory (the destination space) unused by the mutator. Any pointers to these records will be replaced by pointers to the copies in the destination space.
Reference: 3. <author> A. W. Appel, </author> <title> ``Garbage collection can be faster than stack allocation,'' </title> <journal> Information Processing Letters, </journal> <volume> vol. 25, no. 4, </volume> <pages> pp. 275-279, </pages> <year> 1987. </year>
Reference-contexts: As memories get larger, the ratio of reachable records to garbage decreases, so that copying algorithms perform more efficiently than mark-and-sweep algorithms <ref> [3] </ref>. In some programming languages, when a record is allocated it is immediately initialized (as part of the allocation procedure) to point to other records, and the contents of existing records are only rarely altered. <p> Fast allocation With copying or generational garbage collection, there is no lower bound on the cost of freeing a record by garbage collection <ref> [3] </ref>, primarily because the garbage collector never touches the garbage (just the live records). The cost of garbage-collecting a record can be less than one instruction, on an amortized basis. In that case, it is worthwhile ensuring that allocating a record is also cheap.
Reference: 4. <author> Henry Lieberman and Carl Hewitt, </author> <title> ``A real-time garbage collector based on the lifetimes of objects,'' </title> <journal> Communications of the ACM, </journal> <volume> vol. 23, no. 6, </volume> <pages> pp. 419-429, </pages> <publisher> ACM, </publisher> <year> 1983. </year>
Reference-contexts: In some programming languages, when a record is allocated it is immediately initialized (as part of the allocation procedure) to point to other records, and the contents of existing records are only rarely altered. Two observations can be made about such languages <ref> [4] </ref> that lead to an improvement of the copying garbage collection algorithm: 1. <p> relatively new, it's likely to be a temporary structure holding an intermediate result. hhhhhhhhhhhhhhhhhh *In the perverse jargon of garbage collection, the user's process is called the mutator because it is busy changing all the data that the garbage collector has just cleaned up. - 3 - Generational garbage collection <ref> [4, 5] </ref> is a variant of copying garbage collection that takes advantage of these observations. <p> This algorithm depends on the fact that records contain pointers only to older records. In the presence of assignments to fields of old records, this acyclic condition will not hold. Lieberman and Hewitt <ref> [4] </ref> handle this problem by making such fields point indirectly through an ``assignment table.'' If a record in area A i has been assigned into, then that field instead of pointing directly to its referent points to an element - 4 - of a table associated with area A i .
Reference: 5. <author> David Ungar, </author> <title> ``Generation scavenging: a non-disruptive high performance storage reclamation algorithm,'' </title> <booktitle> SIGPLAN Notices (Proc. ACM SIGSOFT/SIGPLAN Software Eng. Symp. on Practical Software Development Environments), </booktitle> <volume> vol. 19, no. 5, </volume> <pages> pp. 157-167, </pages> <publisher> ACM, </publisher> <year> 1984. </year> <title> hhhhhhhhhhhhhhhhhh *On some machines (like the MC68020), the program counter saved by the kernel won't be pointing to the beginning of the trapping instruction, and the trap-handler routine must adjust the program counter. </title> - <type> 16 </type> - 
Reference-contexts: relatively new, it's likely to be a temporary structure holding an intermediate result. hhhhhhhhhhhhhhhhhh *In the perverse jargon of garbage collection, the user's process is called the mutator because it is busy changing all the data that the garbage collector has just cleaned up. - 3 - Generational garbage collection <ref> [4, 5] </ref> is a variant of copying garbage collection that takes advantage of these observations. <p> In the original Lieberman-Hewitt scheme, all records ever stored into are examined. The use of low-overhead ephemeral garbage collection produces a noticeable improvement in garbage-collector efficiency [6]. Ungar's method <ref> [5] </ref> is to keep a list or vector of all the old objects that point to new objects. Whenever an assignment is executed, the compiled code checks to see whether the assigned-into object is old and the assigned value is a pointer to a new object.
Reference: 6. <author> David A. Moon, </author> <title> ``Garbage collection in a large LISP system,'' </title> <booktitle> ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pp. 235-246, </pages> <publisher> ACM, </publisher> <year> 1984. </year>
Reference-contexts: Even though we make the assumption that assignment operations are rare, this does not prevent the cumulative number of assignments from becoming large. The overhead of searching the assignment tables can be ameliorated by Moon's ``ephemeral garbage collection'' algorithm <ref> [6] </ref>. This is a variant of the Lieberman-Hewitt scheme that manages the assignments differently. It uses special hardware in the virtual memory manager to detect all assignments of references to ``ephemeral'' objects objects in area A n (or A n - k , for small k). <p> In the original Lieberman-Hewitt scheme, all records ever stored into are examined. The use of low-overhead ephemeral garbage collection produces a noticeable improvement in garbage-collector efficiency <ref> [6] </ref>. Ungar's method [5] is to keep a list or vector of all the old objects that point to new objects. Whenever an assignment is executed, the compiled code checks to see whether the assigned-into object is old and the assigned value is a pointer to a new object.
Reference: 7. <author> Andrew W. Appel, John R. Ellis, and Kai Li, </author> <title> ``Real-time concurrent collection on stock multiprocessors,'' </title> <booktitle> Proc. ACM SIGPLAN '88 Conf. on Prog. Lang. Design & Implementation,, </booktitle> <pages> pp. 11-20, </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: Ungar's method is not incremental, but requires no special hardware. Most of the fastest and cheapest computers available today, however, are general-purpose computers without any special garbage-collection hardware, so Ungar's method is preferable in most circumstances. There is an incremental algorithm that doesn't require special hardware <ref> [7] </ref>, but it requires more sophisticated operating systems than are commonly available. Therefore, it won't be described in the present paper, which is meant to provide a easy-to-implement ``recipe'' for efficient and portable garbage collection.
Reference: 8. <author> C. J. </author> <title> Cheney, ``A nonrecursive list compacting algorithm,'' </title> <journal> Comm. ACM, </journal> <volume> vol. 13, no. 11, </volume> <pages> pp. 677-678, </pages> <year> 1970. </year>
Reference-contexts: The copying algorithm The heart of a generational garbage collector is a mechanism to copy the live data of one region of memory to a contiguous group of records in another region. This can be done without an auxiliary stack or queue; Cheney's algorithm <ref> [8] </ref> uses the destination region as the queue of a breadth-first search: We start with a set of ``root pointers.'' Any record in the ``source region'' that is reachable from a root pointer will be copied.
Reference: 9. <author> Dianne E. Britton, </author> <title> ``Heap Storage Management for the Programming Language Pascal,'' </title> <type> Masters Thesis, </type> <institution> University of Arizona, </institution> <year> 1975. </year>
Reference-contexts: In languages with static type systems (like Pascal or ML), the compiler can provide the garbage col lector with a map of the type system, which will explain the format of run-time data <ref> [9, 10] </ref>. In this paper, the record-tagging scheme will be used, as this simplifies the layout of records in memory.* When there are variable-sized records, it is slightly more complicated to allocate records.
Reference: 10. <author> Andrew W. Appel, </author> <title> ``Runtime Tags Aren't Necessary,'' </title> <institution> CS-TR-142-88, Princeton University, </institution> <year> 1988. </year>
Reference-contexts: In languages with static type systems (like Pascal or ML), the compiler can provide the garbage col lector with a map of the type system, which will explain the format of run-time data <ref> [9, 10] </ref>. In this paper, the record-tagging scheme will be used, as this simplifies the layout of records in memory.* When there are variable-sized records, it is slightly more complicated to allocate records.
Reference: 11. <author> Andrew W. Appel and David B. MacQueen, </author> <title> ``A Standard ML compiler,'' </title> <booktitle> in Functional Programming Languages and Computer Architecture (LNCS 274), </booktitle> <pages> pp. 301-324, </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: When g is less than 2, the algorithm will run out of space; when g is near 2, its performance degrades. For good performance, g should be 3 or more. In the Standard ML of New Jersey compiler <ref> [11] </ref>, which makes extremely heavy use of the allocator, setting g = 3 gives a garbage-collection overhead of about 11%, and g = 7 reduces the overhead to about 6%. <p> It is simple enough to modify the copies on the stack and let the kernel copy the modified values back to the original registers. hhhhhhhhhhhhhhhhhh * In the run-time system for Standard ML of New Jersey <ref> [11] </ref> it is particularly easy to handle global variables and the run-time stack, because neither exists! All records are accessible from registers. - 14 - Some registers are not pushed by the kernel, but it is simple enough for the user's function to push them and pop them. <p> This paper has presented a simple, efficient arrangement of a generational garbage collector, and has described a way of chopping several instructions out of the allocation overhead. In the runtime system for Standard ML of New Jersey <ref> [11] </ref> this garbage collector is a C program of about 500 lines.
Reference: 12. <author> G. V. Cormack, </author> <title> ``A micro-kernel for concurrency in C,'' </title> <journal> Software Practice/Experience, </journal> <volume> vol. 18, no. 5, </volume> <pages> pp. 485-492. </pages>
Reference-contexts: Finally, the trap-handler returns. The saved registers are popped back into the machine registers, and the - 15 - mutator resumes at the beginning of the instruction that trapped.* This time it succeeds. Cormack <ref> [12] </ref> describes another good scheme for access to registers by user processes. Conclusion Generational garbage collection is a great thing for languages that don't have too many assignments.
References-found: 12

