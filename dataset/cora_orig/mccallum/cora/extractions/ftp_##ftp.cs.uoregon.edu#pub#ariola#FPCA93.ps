URL: ftp://ftp.cs.uoregon.edu/pub/ariola/FPCA93.ps
Refering-URL: http://www.cs.uoregon.edu/~ariola/publications.html
Root-URL: http://www.cs.uoregon.edu
Email: email: [sastry, will, ariola]@cs.uoregon.edu  
Title: Order-of-evaluation Analysis for Destructive Updates in Strict Functional Languages with Flat Aggregates  
Author: A.V.S. Sastry, William Clinger and Zena Ariola 
Address: Eugene, OR, 97403  
Affiliation: Department of Computer Science University of Oregon  
Abstract: The aggregate update problem in functional languages is concerned with detecting cases where a functional array update operation can be implemented destructively in constant time. Previous work on this problem has assumed a fixed order of evaluation of expressions. In this paper, we devise a simple analysis, for strict functional languages with flat aggregates, that derives a good order of evaluation for making the updates destructive. Our work improves Hudak's work [14] on abstract reference counting, which assumes fixed order of evaluation and uses the domain of sticky reference counts. Our abstract reference counting uses a 2-point domain. We show that for programs with no aliasing, our analysis is provably more precise than Hudak's approach (even if the fixed order of evaluation chosen by Hudak happens to be the right order). We also show that our analysis algorithm runs in polynomial time. To the best of our knowledge, no previous work shows polynomial time complexity. We suggest a technique for avoiding excessive copying even in those cases where the analysis determines that an update cannot be made destructively. We have implemented the algorithm and tested it on some common example programs. The results show that a good choice of the order of evaluation determined by the analyzer indeed makes most of the updates destructive. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> S. Abramsky, editor. </editor> <title> Abstract Interpretation of Declarative Languages. </title> <publisher> Ellis Horwood Ltd., </publisher> <year> 1987. </year>
Reference-contexts: In conclusion, in order to devise a good order of evaluation we need to collect the following information: propagation of variables, aliasing and variables selected and updated. To collect all of the above information we will use the technique of abstract interpretation <ref> [7, 1] </ref>. We can then augment the dependency graph associated with an expression with additional edges, which are called interference edges. An expression e 2 is said to interfere with another expression e 1 if e 2 updates an aggregate that is selected or updated by e 1 .
Reference: [2] <author> A. Aho, J. Hopcroft, and J. Ullman. </author> <title> Design and Analysis of Computer Algorithms. </title> <publisher> Addison Wesley Publishing Company, </publisher> <year> 1974. </year>
Reference-contexts: The graph so obtained is called precedence graph. The interferes predicate is defined in Figure 6. We find the strongly connected components of the precedence graph using the algorithm given in <ref> [2] </ref>. We construct a new graph whose nodes are the strongly connected components of the precedence graph.
Reference: [3] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers : Principles, Techniques and Tools. </booktitle> <publisher> Addison Wesley Publishing Company, </publisher> <year> 1986. </year>
Reference-contexts: e 2 j Let [t 1 = e 1 ; : : : ; t n = e n ] In t i End pr 2 IProg ::= ff 1 x 1 1 x m 1 = e 1 ; . . . of as a compiler generated temporary variable <ref> [3] </ref>. As we will see shortly, the analysis will distinguish these temporary variables from other identifiers. The syntax of the intermediate language is given in Figure 2. Notice that the only way an expression appears inside another expression is through a conditional or a let-expression.
Reference: [4] <author> A. Bloss. </author> <title> Path Analysis and Optimization of Non-strict Functional Languages. </title> <type> PhD thesis, </type> <institution> Yale University, Dept. of Computer Science, </institution> <year> 1989. </year>
Reference-contexts: Our analysis derives this order whereas Bloss <ref> [4] </ref> assumes that the Upd operator is evaluated from right to left. Similarly, in the gaussian elimination program, which takes arrays A and B and computes X such that AX = B, the order of evaluation of expressions in recursive calls is important for destructive updating. <p> Again, this work also does not consider reordering expressions. The SAL language has other array creation operators like cat, the array concatenation operator, which we haven't considered in our language. Bloss <ref> [4, 5] </ref> extended the work on update analysis to first-order lazy functional languages which are more difficult to analyze because the order of evaluation of expressions cannot be completely determined at compile-time. <p> Bloss [4, 5] extended the work on update analysis to first-order lazy functional languages which are more difficult to analyze because the order of evaluation of expressions cannot be completely determined at compile-time. She defines a non-standard semantics called path semantics <ref> [4, 6] </ref> which gives the information about all possible orders of the evaluation of variables in a program. Path semantics is used for checking whether an update can be performed destructively. Computing the abstract path semantics is very expensive because of the size of the abstract domain of paths [4]. <p> Path semantics is used for checking whether an update can be performed destructively. Computing the abstract path semantics is very expensive because of the size of the abstract domain of paths <ref> [4] </ref>. This work also assumes a fixed order of evaluation of strict operators. Draghichescu's [9] work on the update analysis of lazy languages improves the abstract complexity but is still exponential. Deutch [8] describes an analysis based on abstract interpretation, for determining the lifetime and aliasing information for higher-order languages.
Reference: [5] <author> A. Bloss. </author> <title> Update analysis and efficient implementation of functional aggregates. </title> <booktitle> In The Fourth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 26-38, </pages> <year> 1989. </year>
Reference-contexts: Again, this work also does not consider reordering expressions. The SAL language has other array creation operators like cat, the array concatenation operator, which we haven't considered in our language. Bloss <ref> [4, 5] </ref> extended the work on update analysis to first-order lazy functional languages which are more difficult to analyze because the order of evaluation of expressions cannot be completely determined at compile-time.
Reference: [6] <author> A. Bloss and P. Hudak. </author> <title> Path semantics. </title> <booktitle> In Third Workshop On Mathematical Foundations of Programming Language Semantics, </booktitle> <pages> pages 476-489, </pages> <year> 1988. </year>
Reference-contexts: Bloss [4, 5] extended the work on update analysis to first-order lazy functional languages which are more difficult to analyze because the order of evaluation of expressions cannot be completely determined at compile-time. She defines a non-standard semantics called path semantics <ref> [4, 6] </ref> which gives the information about all possible orders of the evaluation of variables in a program. Path semantics is used for checking whether an update can be performed destructively. Computing the abstract path semantics is very expensive because of the size of the abstract domain of paths [4].
Reference: [7] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation : A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In 4th ACM POPL, </booktitle> <year> 1977. </year>
Reference-contexts: In conclusion, in order to devise a good order of evaluation we need to collect the following information: propagation of variables, aliasing and variables selected and updated. To collect all of the above information we will use the technique of abstract interpretation <ref> [7, 1] </ref>. We can then augment the dependency graph associated with an expression with additional edges, which are called interference edges. An expression e 2 is said to interfere with another expression e 1 if e 2 updates an aggregate that is selected or updated by e 1 .
Reference: [8] <author> A. Deutch. </author> <title> On determining the lifetime and aliasing of dynamically allocated data in higher-order functional specifications. </title> <booktitle> In Proceedings of the 1990 POPL, </booktitle> <pages> pages 157-168, </pages> <year> 1990. </year>
Reference-contexts: The problem with fixing an order a priori is that several opportunities for destructive updating may be lost. Moreover, we show that our algorithm has polynomial time complexity. None of the previous works on strict languages <ref> [8, 14, 12] </ref> give polynomial time complexity bounds. We present a simple abstract reference counting analysis that exploits the syntactic information available in a program for determining the liveness of a variable. Our abstract reference count domain uses a 2-point domain. <p> This work also assumes a fixed order of evaluation of strict operators. Draghichescu's [9] work on the update analysis of lazy languages improves the abstract complexity but is still exponential. Deutch <ref> [8] </ref> describes an analysis based on abstract interpretation, for determining the lifetime and aliasing information for higher-order languages. This analysis is based on the abstraction of the operational semantics of a very low level intermediate language. Our work differs from this work in two ways.
Reference: [9] <author> M. Draghicescu and S. Purushothaman. </author> <title> A compositional analysis of evaluation-order and its applications. </title> <booktitle> In ACM conference on Lisp and Functional Programming, </booktitle> <pages> pages 242-249, </pages> <year> 1990. </year>
Reference-contexts: Path semantics is used for checking whether an update can be performed destructively. Computing the abstract path semantics is very expensive because of the size of the abstract domain of paths [4]. This work also assumes a fixed order of evaluation of strict operators. Draghichescu's <ref> [9] </ref> work on the update analysis of lazy languages improves the abstract complexity but is still exponential. Deutch [8] describes an analysis based on abstract interpretation, for determining the lifetime and aliasing information for higher-order languages.
Reference: [10] <author> P. Fradet. </author> <title> Syntactic detection of single-threading using continuations. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 241-258. </pages> <publisher> ACM, Springer Verlag, </publisher> <month> August </month> <year> 1991. </year> <note> LNCS 523., </note> <year> 1991. </year>
Reference-contexts: Schmidt [18] gave the syntactic criteria for converting the store argument of the direct semantics of an imperative language into a global variable. This work was generalized as the globalization of function parameters by Sestoft [20, 11]. It also assumes a fixed order of evaluation of expressions. Fradet <ref> [10] </ref> gave a simple syntactic criteria, based on the types of the variables, for detecting single threadedness in programs written in continuation passing style. The initial work on call-by-value functional languages is Hudak's abstract reference counting technique for a first-order language with flat aggregates [14].
Reference: [11] <author> C. Gomard and P. Sestoft. </author> <title> Globalization and live variables. </title> <booktitle> In Proceedings of the Symposium on Partial Evaluation and Semantic Based Program Manipulation (PEPM), </booktitle> <pages> pages 166-176, </pages> <year> 1991. </year>
Reference-contexts: The other research work in the area of storage optimization is globalization of variables. Schmidt [18] gave the syntactic criteria for converting the store argument of the direct semantics of an imperative language into a global variable. This work was generalized as the globalization of function parameters by Sestoft <ref> [20, 11] </ref>. It also assumes a fixed order of evaluation of expressions. Fradet [10] gave a simple syntactic criteria, based on the types of the variables, for detecting single threadedness in programs written in continuation passing style.
Reference: [12] <author> K. Gopinath. </author> <title> Copy Elimination in Single Assignment Languages. </title> <type> PhD thesis, </type> <institution> Stanford University, Computer Systems Laboratory, </institution> <year> 1988. </year>
Reference-contexts: The problem with fixing an order a priori is that several opportunities for destructive updating may be lost. Moreover, we show that our algorithm has polynomial time complexity. None of the previous works on strict languages <ref> [8, 14, 12] </ref> give polynomial time complexity bounds. We present a simple abstract reference counting analysis that exploits the syntactic information available in a program for determining the liveness of a variable. Our abstract reference count domain uses a 2-point domain. <p> We have already given a comparison of our work to this work. Our analysis can be thought of as a generalization of Hudak's work since we derive an order of evaluation. Our abstraction functions are much simpler than the ones used in [14]. Gopinath <ref> [12] </ref> considers copy elimination in the single assignment language SAL, which has constructs for specifying for loops. His work involves computing the target address of an object returned by an expression using a syntactic index analysis and assuming the liveness analysis of [14].
Reference: [13] <author> J. Hicks Jr. </author> <title> Compiler Directed Storage Reclamation using Object Lifetime Analysis. </title> <type> PhD thesis, </type> <institution> Electrical Engineering and Computer Science, MIT, </institution> <year> 1992. </year>
Reference-contexts: This work does not address the issue of complexity of the analysis so it is not clear if their work restricted to the first-order case is efficient. Moreover, this work also assumes a fixed order of evaluation of expressions. James Hicks <ref> [13] </ref> derives the lifetime information of objects in Id, a parallel single assignment language developed at MIT [16]. Lifetime information is used for validating the deallocate instructions in the program or automatically inserting deallocate instructions for reclaiming the storage.
Reference: [14] <author> P. Hudak. </author> <title> A semanitc model of reference counting and its abstraction. </title> <booktitle> In Proceedings of the 1986 Conference on Lisp and Functional Programming, </booktitle> <year> 1986. </year>
Reference-contexts: In this paper we present an update analysis algorithm for first-order strict functional languages with flat aggregates. The analysis, in contrast to previous work <ref> [14] </ref>, does not assume any fixed order of evaluation of arguments of any function. The problem with fixing an order a priori is that several opportunities for destructive updating may be lost. Moreover, we show that our algorithm has polynomial time complexity. <p> The problem with fixing an order a priori is that several opportunities for destructive updating may be lost. Moreover, we show that our algorithm has polynomial time complexity. None of the previous works on strict languages <ref> [8, 14, 12] </ref> give polynomial time complexity bounds. We present a simple abstract reference counting analysis that exploits the syntactic information available in a program for determining the liveness of a variable. Our abstract reference count domain uses a 2-point domain. <p> Our abstract reference count domain uses a 2-point domain. We show that for programs without aliasing our analysis is provably more precise than Hudak's abstract reference counting <ref> [14] </ref>. In the cases where the analysis determines that an update cannot be made destructive, we present a simple heuristic for copy avoidance. We have designed and implemented an abstract interpreter to perform the update analysis. <p> Our analysis safely concludes that the update cannot be made destructive. 9 Comparison with Hudak's Work Hudak described an abstraction of reference counting for update analysis in <ref> [14] </ref>. In this section, we show that our analysis is more precise. We first summarize Hudak's approach and show the sources of imprecision and discuss how we avoid these imprecisions. <p> Fradet [10] gave a simple syntactic criteria, based on the types of the variables, for detecting single threadedness in programs written in continuation passing style. The initial work on call-by-value functional languages is Hudak's abstract reference counting technique for a first-order language with flat aggregates <ref> [14] </ref>. This work assumes a fixed order of evaluation of expressions. We have already given a comparison of our work to this work. Our analysis can be thought of as a generalization of Hudak's work since we derive an order of evaluation. <p> We have already given a comparison of our work to this work. Our analysis can be thought of as a generalization of Hudak's work since we derive an order of evaluation. Our abstraction functions are much simpler than the ones used in <ref> [14] </ref>. Gopinath [12] considers copy elimination in the single assignment language SAL, which has constructs for specifying for loops. His work involves computing the target address of an object returned by an expression using a syntactic index analysis and assuming the liveness analysis of [14]. <p> simpler than the ones used in <ref> [14] </ref>. Gopinath [12] considers copy elimination in the single assignment language SAL, which has constructs for specifying for loops. His work involves computing the target address of an object returned by an expression using a syntactic index analysis and assuming the liveness analysis of [14]. Again, this work also does not consider reordering expressions. The SAL language has other array creation operators like cat, the array concatenation operator, which we haven't considered in our language.
Reference: [15] <author> T. Johnsson. </author> <title> Transforming programs to recursive equations. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <address> Nancy, France. </address> <publisher> Springer Verlag LNCS 523, </publisher> <month> September </month> <year> 1985. </year>
Reference-contexts: In our language nested function definitions are not permitted. This is not a serious restriction because it is always possible to eliminate all nested function definitions by "lambda lifting" <ref> [15] </ref>.
Reference: [16] <author> R. Nikhil. </author> <title> Id (version 90.0) reference manual. </title> <type> Technical Report CSG Memo 284-1, </type> <institution> 545 Technology Square, </institution> <address> Cambridge, MA 02139, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Moreover, this work also assumes a fixed order of evaluation of expressions. James Hicks [13] derives the lifetime information of objects in Id, a parallel single assignment language developed at MIT <ref> [16] </ref>. Lifetime information is used for validating the deallocate instructions in the program or automatically inserting deallocate instructions for reclaiming the storage. This work does not address the aggregate update problem because Id does not provide update as a language construct (although update operation can be defined in Id).
Reference: [17] <author> A. Sastry and W. Clinger. </author> <title> Order-of-evaluation analysis for destructive updates in strict functional languages with flat-aggregates. </title> <type> Technical report, </type> <institution> University of Oregon, 1992. Dept. of Computer Science, TR-92-14. </institution>
Reference-contexts: The complexity of R p is O (mk 3 ). The details of the complexity analysis are available in <ref> [17] </ref>. 8 Results We have implemented the above algorithm in Standard ML and tested several examples that use flat aggregates. Two dimensional arrays are represented as one dimensional arrays.
Reference: [18] <author> D. Schmidt. </author> <title> Detecting global variables in denotational specifications. </title> <journal> ACM TOPLAS, </journal> <volume> 7(2):299:310, </volume> <year> 1985. </year>
Reference-contexts: We assume arbitrary functions as operators, which necessitates our interprocedural analysis. After deriving the interprocedural information, we derive an order locally in essentially the same way as Sethi. The other research work in the area of storage optimization is globalization of variables. Schmidt <ref> [18] </ref> gave the syntactic criteria for converting the store argument of the direct semantics of an imperative language into a global variable. This work was generalized as the globalization of function parameters by Sestoft [20, 11]. It also assumes a fixed order of evaluation of expressions.
Reference: [19] <author> D. A. Schmidt. </author> <title> Denotational Semantics : A Methodology for Language Development. </title> <publisher> Boston : Allyn and Bacon, </publisher> <year> 1986. </year>
Reference-contexts: We use f ix as the least fixpoint operator. All the abstract domains are finite and the abstraction functions are monotonic, therefore least fixpoints exist and are computable <ref> [19] </ref>. Environments are finite maps from the syntactic domain of identifiers to some other domain of interest. The empty environment, which is the least element in the domain of environments, is denoted by ?. The value of an identifier x in an environment is represented as [x]. <p> function below: f x y z = If g (x) then x else f (y; z; x) its H-meaning is defined as : f x y z = x [ f (y; z; x) The least fixpoint of the functional associated with the above equation is computed by successive approximations <ref> [19] </ref>.
Reference: [20] <author> P. Sestoft. </author> <title> Replacing function parameters by global variables. </title> <booktitle> In The Fourth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 39-53, </pages> <year> 1989. </year>
Reference-contexts: The other research work in the area of storage optimization is globalization of variables. Schmidt [18] gave the syntactic criteria for converting the store argument of the direct semantics of an imperative language into a global variable. This work was generalized as the globalization of function parameters by Sestoft <ref> [20, 11] </ref>. It also assumes a fixed order of evaluation of expressions. Fradet [10] gave a simple syntactic criteria, based on the types of the variables, for detecting single threadedness in programs written in continuation passing style.
Reference: [21] <author> R. Sethi. </author> <title> Pebble games for studying storage sharing. </title> <journal> Theoretical Computer Science, </journal> <volume> 19(1) </volume> <pages> 69-84, </pages> <month> July </month> <year> 1982. </year> <month> 9 </month>
Reference-contexts: and Future Research The earliest work on storage optimization found a linear order of evaluation of the nodes of a labeled dag where the labels represent identifiers, nodes represent assignment statements, and the edges represent data dependencies; it was formalized by Sethi as a pebble game on graphs with labels <ref> [21] </ref>. Sethi's work applies to basic blocks with only primitive operators. We assume arbitrary functions as operators, which necessitates our interprocedural analysis. After deriving the interprocedural information, we derive an order locally in essentially the same way as Sethi.
References-found: 21

