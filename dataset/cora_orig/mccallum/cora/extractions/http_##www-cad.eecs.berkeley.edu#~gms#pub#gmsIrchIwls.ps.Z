URL: http://www-cad.eecs.berkeley.edu/~gms/pub/gmsIrchIwls.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu:80/~gms/projects/research.html
Root-URL: 
Title: Incremental Methods for FSM Traversal  
Author: Gitanjali M. Swamy Vigyan Singhal Robert K. Brayton 
Address: Berkeley, CA 94720  
Affiliation: Department of Electrical Engineering and Computer Science. University of California at Berkeley  
Abstract: Computing the set of reachable states of a finite state machine, is an important component of many problems in the synthesis, and formal verification of digital systems. Computing the reachable states is computationally expensive due to the "explosion" in the number of states in real designs. However, the process of design is usually iterative, and the designer may modify and recompute information many times. Unfortunately, the reachability computation is called each time the designer modifies the system, because current methods for reachability analysis are not incremental. The representation of the reachable states that is currently used [1] in synthesis and verification, is inherently non-updatable; in addition it tends to have a large representation, even when the finite state machine itself has a compact representation. We solve all these problems by presenting alternate ways to represent the reachable set, and incremental algorithms that can update the new representation each time the designer changes the system. The incremental algorithms use the reachable set computed at a previous iteration, and information about the changes to the system to update it, rather than compute the reachable set from the beginning. This results in considerable savings in time, as demonstrated by the results 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> O. Coudert and J. C. Madre, </author> <title> "A Unified Framework for the Formal Verification of Sequential Circuits," </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 126-129, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: This traversal may be breadth first, or depth first. Touati [6] et al, and Coudert and Madre <ref> [1] </ref> independently extended this concept to handle reachability in larger systems, by using implicit methods.
Reference: [2] <author> H. Touati, R. K. Brayton, and R. P. Kurshan, </author> <title> "Checking Language Containment using BDDs," </title> <booktitle> in Proc. of Intl. Workshop on Formal Methods in VLSI Design, </booktitle> <address> (Miami, FL), </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Reachability is an essential computation in both formal verification <ref> [2] </ref> as well as sequential synthesis [3] & [4]. Given a directed graph, and a set of initial nodes in the graph, reachability computes the set of nodes on some path from the initial nodes.
Reference: [3] <author> E. M. Sentovich, K. J. Singh, C. Moon, H. Savoj, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> "Sequential Circuit Design Using Synthesis and Optimization," </title> <booktitle> in Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pp. 328-333, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Reachability is an essential computation in both formal verification [2] as well as sequential synthesis <ref> [3] </ref> & [4]. Given a directed graph, and a set of initial nodes in the graph, reachability computes the set of nodes on some path from the initial nodes. A finite state machine (or FSM) can be represented by a directed graph, which is also called a state transition graph.
Reference: [4] <author> H. Cho, G. D. Hachtel, and F. Somenzi, </author> <title> "Redundancy Identification and Removal Based on Implicit State Enumeration," </title> <booktitle> in Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pp. 77-80, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Reachability is an essential computation in both formal verification [2] as well as sequential synthesis [3] & <ref> [4] </ref>. Given a directed graph, and a set of initial nodes in the graph, reachability computes the set of nodes on some path from the initial nodes. A finite state machine (or FSM) can be represented by a directed graph, which is also called a state transition graph.
Reference: [5] <author> R. Bryant, </author> <title> "Graph-based Algorithms for Boolean Function Manipulation," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. C-35, </volume> <pages> pp. 677-691, </pages> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: Unfortunately this computation explodes when the number of states in the finite state machine becomes very large. This is often called the state explosion problem. To overcome this problem, an implicit representation called a binary decision diagram or BDD <ref> [5] </ref>, is sometimes used to represent all the required quantities. e.g. the transition relation, which implicitly represents the FSM's state transition graph, and any set of states (initial, reachable etc.). <p> An additional bonus of using this way of storing the reachable states is that the BDD variable ordering <ref> [5] </ref> for a finite state machine is often chosen according to the transition relation. There is particular reason why this ordering should work well for the reachable states.
Reference: [6] <author> H. Touati, H. Savoj, B. Lin, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> "Implicit State Enumeration of Finite State Machines using BDD's," </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 130-133, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: When BDD's are used, the steps in the BFS traversal of the state transition graph, can be written as fixed point computations of propositional formulae on the transition relation, initial states etc (Touati et al <ref> [6] </ref>). The process of design is incremental, and the designer may modify the design many times. The current techniques for reachability require that each time the designer modifies the design, the set of reachable states must be re-computed from the beginning. <p> This traversal may be breadth first, or depth first. Touati <ref> [6] </ref> et al, and Coudert and Madre [1] independently extended this concept to handle reachability in larger systems, by using implicit methods.
Reference: [7] <author> G. M. Swamy, V. Singhal, and R. K. Brayton, </author> <title> "Incremental methods for Fsm Traversal," </title> <type> Tech. Rep. </type> <institution> UCB/ERL M95/, Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1995. </year>
Reference-contexts: We present some results in section 5. Finally, we conclude our paper by presenting our conclusions, and future directions for this work. For brevity, details of proofs of theorems have been omitted; they may be found in <ref> [7] </ref>. 2 Definitions Definition 1 Finite State Machine: A finite state machine or finite automaton M is a 5-tuple (Q; ; ; T ; I) where * Q is a finite set of states * is a finite set of input values * is a finite set of output values *
Reference: [8] <author> E. A. Emerson, </author> <title> "Temporal and Modal Logic," in Formal Models and Semantics (J. </title> <editor> van Leeuwen, ed.), </editor> <volume> vol. </volume> <booktitle> B of Handbook of Theoretical Computer Science, </booktitle> <pages> pp. 996-1072, </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year> <month> 14 </month>
Reference-contexts: Fixed point Let f (x) be a monotone (increasing or decreasing) function, the fixedpoint F P of f given I is given by the set f i , where f (f i (I ) = f i (I)) (refer to <ref> [8] </ref>). If f is monotonically increasing, then the fixed point is called the least fixed point or LF P , and if f is monotonically decreasing, it is called the greatest fixed point or GF P .
Reference: [9] <author> G. M. Swamy and R. K. Brayton, </author> <title> "Incremental Formal Design Verification," </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 458-465, </pages> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: Figure 3 illustrates this point. A similar statement can be made about GFP computations, as shown by Swamy, and Brayton <ref> [9] </ref>. 2. Cproject Operator [10]: The cproject project operator, when supplied a general acyclic graph, can be used to extract a tree graph that is a subset of the original input graph. <p> If = input + output , and input is the change in the input to the program, output is the change that results in the output, then the complexity is O (f ()). This criterion for incrementality is too stringent for our purposes. In Swamy and Brayton <ref> [9] </ref>, incremental algorithms for methods of formal verification are described. Although reachability is an essential part of any formal verification procedure, the issue of how the reachability computation might be made incremental is not discussed; we intend to address this issue here.
Reference: [10] <author> B. Lin and F. Somenzi, </author> <title> "Minimization of Symbolic Relations," </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 88-91, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: Figure 3 illustrates this point. A similar statement can be made about GFP computations, as shown by Swamy, and Brayton [9]. 2. Cproject Operator <ref> [10] </ref>: The cproject project operator, when supplied a general acyclic graph, can be used to extract a tree graph that is a subset of the original input graph.
Reference: [11] <author> G. Ramalingam and T. Reps, </author> <title> "On the Computational Complexity of Incremental Algorithms," </title> <type> Tech. Rep. TR 1033, </type> <institution> University of Wisconsion, Madison, University of Wisconsion, Madison, </institution> <year> 1991. </year>
Reference-contexts: Incremental algorithms for certain graph problems were examined by Ramalingam et-al <ref> [11] </ref>. They defined incremental algorithms as algorithms, whose complexity was a function of the size of the change to the system alone.
Reference: [12] <author> R. Brayton et al., "HSIS: </author> <title> A BDD-Based Environment for Formal Verification," </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <pages> pp. 454-459, </pages> <month> June </month> <year> 1994. </year> <month> 15 </month>
Reference-contexts: (T new (x; y); P 0+ (x; y)) Here P 0 (x; y) denotes the spanning graph before the change, T new is the new transition relation, and I (x) the initial set of states. 5 Results We have implemented the algorithms described in the previous sections, in the HSIS <ref> [12] </ref> environment, and tested these on some ISCAS 89 benchmarks. Each example was modified, and the new reachable set was computed for a general change consisting of both addition, and subtraction of a large set of edges. This is iterated many times.
References-found: 12

