URL: http://www.cse.ogi.edu/~jl/Papers/dfs.ps
Refering-URL: http://www.cse.ogi.edu/~jl/biblio-functional.html
Root-URL: http://www.cse.ogi.edu
Email: gnik@dcs.gla.ac.uk  jl@cse.ogi.edu  
Title: Structuring Depth-First Search Algorithms in Haskell  
Author: David J. King John Launchbury 
Keyword: Classifications: Computing Paradigms (functional programming); Environments, Implementations, and Experience (programming, graph algorithms).  
Address: Glasgow G12 8QQ, UK  97006-1999, USA  
Affiliation: Department of Computing Science University of Glasgow  Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology Beaverton, Oregon  
Abstract: Depth-first search is the key to a wide variety of graph algorithms. In this paper we express depth-first search in a lazy functional language, obtaining a linear-time implementation. Unlike traditional imperative presentations, we use the structuring methods of functional languages to construct algorithms from individual reusable components. This style of algorithm construction turns out to be quite amenable to formal proof, which we exemplify through a calculational-style proof of a far from obvious strongly-connected components algorithm. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Barth, P. S., Nikhil, R. S. and Arvind (1991), M-structures: </author> <title> Extending a parallel, non-strict, functional language with state, </title> <editor> in J. Hughes, ed., </editor> <booktitle> `Conference on Functional Programming Languages and Computer Architecture', </booktitle> <publisher> LNCS 523, Springer-Verlag, Cambridge, Mas-sachusetts, </publisher> <pages> pp. 538-568. </pages>
Reference: <author> Burton, F. W. and Yang, H.-K. </author> <year> (1990), </year> <title> `Manipulating mul-tilinked data structures in a pure functional language', </title> <journal> Software|Practice and Experience 20, </journal> <pages> 1167-1185. </pages>
Reference: <author> Corman, T. H., Leiserson, C. E. and Rivest, R. L. </author> <year> (1990), </year> <title> Introduction to Algorithms, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts. </address>
Reference: <author> Erwig, M. </author> <year> (1992), </year> <title> Graph algorithms = iteration + data structures? The structure of graph algorithms and a style of programming, </title> <editor> in E. Mayr, ed., </editor> <booktitle> `Graph-Theoretic Concepts in Computer Science', </booktitle> <publisher> LNCS 657, Springer-Verlag, </publisher> <pages> pp. 277-292. </pages>
Reference: <author> Harrison, R. </author> <year> (1993), </year> <title> Abstract data types in Standard ML, </title> <publisher> John Wiley and Sons. </publisher>
Reference: <author> Holyer, I. </author> <year> (1991), </year> <title> Functional programming with Miranda, </title> <publisher> Pitman, London. </publisher>
Reference: <author> Hopcroft, J. E. and Tarjan, R. E. </author> <year> (1973), </year> <title> `Algorithm 447: Efficient algorithms for graph manipulation', </title> <journal> Communications of the ACM 16(6), </journal> <pages> 372-378. </pages>
Reference: <author> Hudak, P., Peyton Jones, S. L., Wadler, P., Arvind, Boutel, B., Fairbairn, J., Fasel, J., Guzman, M. M., Hammond, K., Hughes, J., Johnsson, T., Kieburtz, R., Nikhil, R. S., Partain, W. and Peterson, J. </author> <year> (1992), </year> <title> `Report on the functional programming language Haskell, Version 1.2', </title> <journal> ACM SIGPLAN Notices 27(5). </journal>
Reference-contexts: We make use of recent advances in lazy functional languages which use monads to provide updatable state, as implemented within the Glasgow Haskell compiler. The compiler provides extensions to the language Haskell <ref> (Hudak et al. 1992) </ref> providing updatable arrays (Launchbury and Peyton Jones 1994), and allows these state-based actions to be encapsulated so that their external behaviour is purely functional.
Reference: <author> Kashiwagi, Y. and Wise, D. S. </author> <year> (1991), </year> <title> Graph algorithms in a lazy functional programming language, </title> <booktitle> in `Proceedings of the 4'th International Symposium on Lucid and Intensional Programming', </booktitle> <pages> pp. 35-46. </pages> <note> Also available as Technical Report Number 330, </note> <institution> Computer Science Department, Indiana University. 11 Launchbury, J. </institution> <year> (1993), </year> <title> Lazy imperative programming, </title> <booktitle> in `Workshop on State in Programming Languages', ACM SIGPLAN, Copenhagen, Denmark, </booktitle> <pages> pp. 46-56. </pages>
Reference: <author> Launchbury, J. and Peyton Jones, S. L. </author> <year> (1994), </year> <title> Lazy functional state threads, </title> <booktitle> in `Conference on Programming Language Design and Implementation', ACM SIG-PLAN, </booktitle> <address> Orlando, Florida. </address>
Reference-contexts: We make use of recent advances in lazy functional languages which use monads to provide updatable state, as implemented within the Glasgow Haskell compiler. The compiler provides extensions to the language Haskell (Hudak et al. 1992) providing updatable arrays <ref> (Launchbury and Peyton Jones 1994) </ref>, and allows these state-based actions to be encapsulated so that their external behaviour is purely functional. Consequently we obtain linear algorithms and yet retain the ability to perform purely functional reasoning on all but one fixed and reusable component.
Reference: <author> Manber, U. </author> <year> (1989), </year> <title> Introduction to Algorithms|A Creative Approach, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts. </address>
Reference: <author> Moggi, E. </author> <year> (1989), </year> <title> Computational lambda-calculus and mon-ads, </title> <booktitle> in `Symposium on Logic in Computer Science', IEEE, Asilomar, </booktitle> <address> California. </address>
Reference: <author> Paulson, L. C. </author> <year> (1991), </year> <title> ML for the working programmer, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge. </address>
Reference: <author> Peyton Jones, S. L. and Wadler, P. </author> <year> (1993), </year> <title> Imperative functional programming, </title> <booktitle> in `20'th Symposium on Principles of Programming Languages', ACM, </booktitle> <address> Charleston, </address> <publisher> North Carolina. </publisher>
Reference: <author> Reif, J. H. </author> <year> (1985), </year> <title> `Depth-first search is inherently sequential', </title> <journal> Information Processing Letters 20, </journal> <pages> 229-234. </pages>
Reference: <author> Sands, D. </author> <year> (1993), </year> <title> A nave time analysis and its theory of cost equivalence, </title> <type> TOPPS report D-173, </type> <institution> DIKU, University of Copenhagen, Denmark. </institution>
Reference: <author> Sharir, M. </author> <year> (1981), </year> <title> `A strong-connectivity algorithm and its applications in data flow analysis', </title> <booktitle> Computers and mathematics with applications 7(1), </booktitle> <pages> 67-72. </pages>
Reference: <author> Tarjan, R. E. </author> <year> (1972), </year> <title> `Depth-first search and linear graph algorithms', </title> <journal> SIAM Journal of Computing 1(2), </journal> <pages> 146-160. </pages>
Reference: <author> Wadler, P. </author> <year> (1990), </year> <title> Comprehending monads, </title> <booktitle> in `Conference on Lisp and Functional Programming', ACM, Nice, France, </booktitle> <pages> pp. 61-78. 12 </pages>
References-found: 19

