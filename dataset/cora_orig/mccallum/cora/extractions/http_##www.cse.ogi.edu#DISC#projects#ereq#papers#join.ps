URL: http://www.cse.ogi.edu/DISC/projects/ereq/papers/join.ps
Refering-URL: http://www.cse.ogi.edu/DISC/projects/ereq/papers/bennet-papers.html
Root-URL: http://www.cse.ogi.edu
Email: bennet@cse.ogi.edu  maier@cse.ogi.edu  
Title: Rapid Bushy Join-order Optimization with Cartesian Products  
Author: Bennet Vance David Maier 
Web: http://www.cse.ogi.edu/DISC  http://www.cse.ogi.edu/DISC  
Affiliation: Oregon Graduate Institute of Science Technology  Oregon Graduate Institute of Science Technology  
Abstract: Query optimizers often limit the search space for join orderings, for example by excluding Cartesian products in subplans or by restricting plan trees to left-deep vines. Such exclusions are widely assumed to reduce optimization effort while minimally affecting plan quality. However, we show that searching the complete space of plans is more affordable than has been previously recognized, and that the common exclusions may be of little benefit. We start by presenting a Cartesian product optimizer that requires at most a few seconds of workstation time to search the space of bushy plans for products of up to 15 relations. Building on this result, we present a join-order optimizer that achieves a similar level of performance, and retains the ability to include Cartesian products in subplans wherever appropriate. The main contribution of the paper is in fully separating join-order enumeration from predicate analysis, and in showing that the former problem in particular can be solved swiftly by novel implementation techniques. A secondary contribution is to initiate a systematic approach to the benchmarking of join-order optimization, which we apply to the evaluation of our method. 
Abstract-found: 1
Intro-found: 1
Reference: [CM95] <author> Sophie Cluet and Guido Moerkotte. </author> <title> On the complexity of generating optimal left-deep processing trees with cross products. </title> <booktitle> In Proceedings of the 5th International Conference on Database Theory, volume 893 of Lecture Notes in Computer Science, </booktitle> <pages> pages 54-67, </pages> <address> Prague, Czech Republic, </address> <month> January </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: The work described here assumes that predicates are uncorrelated, and the cost models we consider are relatively simple. (Such simplifications are not unusual in the research literature <ref> [CM95, GLPK94] </ref>.) The paper proceeds as follows. Section 2 discusses related work. Section 3 presents an algorithm for Carte 35 sian product optimization and analyzes its complexity. Section 4 shows how that algorithm can be efficiently implemented. Section 5 revises the algorithm to incorporate join predicates. <p> When Cartesian products are considered, the number of joins enumerated is O (n2 n ) for left-deep search, and O (3 n ) for bushy search, regardless of the join graph. However, the underlying worst-case complexity of the enumerator itself is O (4 n ). Cluet and Moerkotte <ref> [CM95] </ref> study the feasibility of optimization with Cartesian products from a theoretical standpoint. Their work, which considers only left-deep plan spaces, addresses the question of extending a join-optimization result from Ibaraki and Kameda [IK84].
Reference: [GLPK94] <author> Cesar Galindo-Legaria, Arjan Pellenkoft, and Martin Kersten. </author> <title> Fast, </title> <booktitle> randomized join-order selection|why use transformations? In Proceedings of the 20th International Conference on Very Large Data Bases, </booktitle> <pages> pages 85-95, </pages> <address> Santiago, Chile, September 1994. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: The work described here assumes that predicates are uncorrelated, and the cost models we consider are relatively simple. (Such simplifications are not unusual in the research literature <ref> [CM95, GLPK94] </ref>.) The paper proceeds as follows. Section 2 discusses related work. Section 3 presents an algorithm for Carte 35 sian product optimization and analyzes its complexity. Section 4 shows how that algorithm can be efficiently implemented. Section 5 revises the algorithm to incorporate join predicates. <p> Like Starburst, Volcano adapts to the join-graph topology. In the worst case, Volcano optimizes joins in O (3 n ) time and O (3 n ) space. Galindo-Legaria, Pellenkoft, and Kersten <ref> [GLPK94] </ref> propose an unconventional stochastic approach to join-order optimization.
Reference: [GM93] <author> Goetz Graefe and William J. McKenna. </author> <title> The Volcano optimizer generator: Extensibility and efficient search. </title> <booktitle> In Proceedings of the IEEE Conference on Data Engineering, </booktitle> <pages> pages 209-218, </pages> <address> Vienna, Austria, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: But even with these restrictions, optimization again becomes NP-complete when Cartesian products are allowed in subplans. Thus, some join-optimization problems are fundamentally harder with Cartesian products than without. Graefe and McKenna <ref> [GM93] </ref> describe the extensible, rule-based Volcano optimizer. Their test runs allow bushy plans but not Cartesian products, and yield timings that, to our knowledge, reflect the state of the art in rule-based optimization. Like Starburst, Volcano adapts to the join-graph topology.
Reference: [HS93] <author> Joseph M. Hellerstein and Michael Stonebraker. </author> <title> Predicate migration: Optimizing queries with expensive predicates. </title> <booktitle> In Proceedings of the 1993 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 267-276, </pages> <address> Wash-ington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: However, if we wish to take advantage of dynamic programming 5 This assertion rests on the assumption that predicate evaluation is cheap; most other optimizers make the same assumption. However, Hellerstein and Stonebraker <ref> [HS93] </ref> describe a cost-based predicate-placement technique that achieves huge gains when expensive predicates are deferred. 40 W Z B C V S D to perform this computation more easily, we need a way to compute the join cardinality of S in terms of the join cardinalities of subsets of S.
Reference: [IK84] <author> Toshihide Ibaraki and Tiko Kameda. </author> <title> On the optimal nesting order for computing N -relational joins. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(3) </volume> <pages> 482-502, </pages> <month> September </month> <year> 1984. </year>
Reference-contexts: 1 Introduction Because join-order optimization is NP-complete <ref> [IK84] </ref>, practical solutions to the problem typically involve engineering trade-offs. This paper presents a new perspective on the engineering trade-offs that arise when join orders are optimized by exhaustive search. One way that optimizers cope with the intractability of join optimization is to exclude some classes of plans from consideration. <p> Cluet and Moerkotte [CM95] study the feasibility of optimization with Cartesian products from a theoretical standpoint. Their work, which considers only left-deep plan spaces, addresses the question of extending a join-optimization result from Ibaraki and Kameda <ref> [IK84] </ref>. That result showed polynomial complexity for optimization of queries with acyclic graphs under a restricted class of cost models. But even with these restrictions, optimization again becomes NP-complete when Cartesian products are allowed in subplans. Thus, some join-optimization problems are fundamentally harder with Cartesian products than without.
Reference: [IK91] <author> Yannis E. Ioannidis and Younkyung Cha Kang. </author> <title> Left-deep vs. bushy trees: An analysis of strategy spaces and its implications for query optimization. </title> <booktitle> In Proceedings of the 1991 ACM SIG-MOD International Conference on Management of Data, </booktitle> <pages> pages 168-177, </pages> <address> Denver, Colorado, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Plans with Cartesian products are frequently excluded on the grounds that they are unlikely to be optimal, and so it is not worth expending effort in analyzing such plans. Many optimizers also restrict their attention to the space of left-deep plans <ref> [IK91] </ref>, on the grounds that (a) the space of bushy plans is vastly larger, and hence much more expensive to search; and (b) there are nonetheless plenty of left-deep plans to choose from, and so the best among them will likely suffice.
Reference: [Knu73] <author> Donald E. Knuth. </author> <title> Fundamental Algorithms, </title> <booktitle> volume 1 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> second edition, </address> <year> 1973. </year>
Reference-contexts: In aggregate, the number of executions of this code across all calls to find best split is cond count = P n n Using the fact H k ln k + fl where fl = 0:57721 : : : <ref> [Knu73] </ref>, we obtain cond count P n n P n n fl = (ln 2=2)n2 n + fl2 n . Let us disregard the fl2 n term and view the net contribution of the conditionally executed code as (ln 2=2)n2 n T cond for some constant T cond .
Reference: [MO] <author> O. Martin and S. Otto. </author> <title> Combining simulated annealing with local search heuristics. </title> <note> To appear as a chapter of Metaheuristics in Combinatorial Optimization, volume 60 in the series Annals of Operations Research, </note> <editor> edited by G. Laporte and I. </editor> <publisher> Osman. </publisher>
Reference-contexts: Stochastic methods offer a way around both these problems. We are currently experimenting with a hybrid method inspired by the Chained Local Optimization technique of Martin and Otto <ref> [MO] </ref>. Our hybrid combines dynamic programming with randomized search, and will be the subject of a future paper. Acknowledgments We are grateful for helpful feedback from Roberto Bayardo, Goetz Graefe, Joe Hellerstein, Bala Iyer, Guy Lohman, Guido Moerkotte, Len Shapiro, and the referees.
Reference: [OL90] <author> Kiyoshi Ono and Guy M. Lohman. </author> <title> Measuring the complexity of join enumeration in query optimization. </title> <booktitle> In Proceedings of the 16th International Conference on Very Large Data Bases, </booktitle> <pages> pages 314-325, </pages> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: We conclude in Section 7. 2 Related Work Selinger et al. [SAC + 79] applied dynamic programming to join-order optimization in the System R optimizer. Their optimizer focused on left-deep plans and excluded (or deferred) Cartesian products, but searched exhaustively subject to those restrictions. Ono and Lohman <ref> [OL90] </ref> point out that the optimal plan for a multiway join may contain Cartesian products, and note that it is desirable for an optimizer to permit flexibility in optimization trade-offs.
Reference: [SAC + 79] <author> P. Griffiths Selinger, M. M. Astrahan, D. D. Chamberlin, R. A. Lorie, and T. G. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proceedings of the ACM-SIGMOD 1979 International Conference on Management of Data, </booktitle> <pages> pages 23-34, </pages> <address> Boston, Massachusetts, </address> <month> May </month> <year> 1979. </year>
Reference-contexts: Section 4 shows how that algorithm can be efficiently implemented. Section 5 revises the algorithm to incorporate join predicates. Section 6 reports on performance measurements. We conclude in Section 7. 2 Related Work Selinger et al. <ref> [SAC + 79] </ref> applied dynamic programming to join-order optimization in the System R optimizer. Their optimizer focused on left-deep plans and excluded (or deferred) Cartesian products, but searched exhaustively subject to those restrictions. <p> On completion of optimization, a single traversal of the optimal plan suffices to attach the appropriate algorithm to each join node. The issue of physical properties (e.g., "interesting" sort orders <ref> [SAC + 79] </ref>) is trickier.
Reference: [SMK93] <author> Michael Steinbrunn, Guido Moerkotte, and Al-fons Kemper. </author> <title> Optimizing join orders. </title> <type> Technical Report MIP-9307, </type> <institution> Universitat Passau, </institution> <year> 1993. </year>
Reference: [Ste96] <author> M. Steinbrunn. </author> <title> Heuristic and Randomised Optimisation Techniques in Object-Oriented Database Systems. </title> <address> infix-Verlag, Ringstrae 32, 53757 St. Augustin, Germany, </address> <year> 1996. </year> <type> Dissertation, </type> <institution> Universitat Passau. </institution>
Reference-contexts: In the worst case, Volcano optimizes joins in O (3 n ) time and O (3 n ) space. Galindo-Legaria, Pellenkoft, and Kersten [GLPK94] propose an unconventional stochastic approach to join-order optimization. Whereas previous stochastic techniques (e.g., simulated annealing and iterated improve ment <ref> [Ste96] </ref>) used transformations on plan trees to move from one state of the plan space to a neighboring state, the method of Galindo-Legaria et al. instead probes points of the plan space at random, avoiding the expense of navigating the space by applying transformations. <p> The technique reportedly outperforms its predecessors, but as presented is applicable only to queries with acyclic graphs. Steinbrunn <ref> [Ste96] </ref> surveys a variety of heuristic and stochastic techniques, and includes extensive empirical measurements. The stochastic searches appear to converge on plans of high quality, but the time it takes them to do so is often substantial.
References-found: 12

