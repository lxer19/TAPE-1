URL: http://www.cs.columbia.edu/~dalal/papers/dood89.ps.gz
Refering-URL: http://www.cs.columbia.edu/~dalal/papers.html
Root-URL: http://www.cs.columbia.edu
Email: net: dalal@aramis.rutgers.edu  net: dipayan@ibm.com  
Title: OOLP: A Translation Approach to Object-Oriented Logic Programming  
Author: Mukesh Dalal and Dipayan Gangopadhyay 
Address: New Brunswick, NJ 08903, USA  P.O. Box 704, Yorktown Heights, NY 10598, USA  
Affiliation: Dept. of Computer Science, Rutgers University,  I.B.M. Thomas J. Watson Research Center,  
Date: December 1989.  
Note: 1 In Proceedings of the First International Conference on Deductive and Object-Oriented Databases (DOOD-89), pages 555-568, Kyoto, Japan,  
Abstract: OOLP integrates the superior modeling capabilities of object-oriented paradigm in the declarative framework of logic programming. Method invocation in OOLP is given a precise model theoretic semantics which is consistent with that of logic programming. OOLP is extended to a practical object-oriented database language OOLP+ by adding some extra-logical features. OOLP+ allows object identity, multiple inheritance, method overriding and dynamic updating among other features. OOLP+ is implemented by translating it to Prolog. The translated programs executes without meta-interpretation. This allows the use of all Prolog or Datalog optimization techniques. In this respect OOLP+ is unique among alternative proposals presented in the literature.
Abstract-found: 1
Intro-found: 1
Reference: [AN86] <author> H. Ait-Kaci and R. Nasr. </author> <title> Login: a logic programming language with built-in inheritance. </title> <journal> Journal of Logic Programming, </journal> <volume> 3(3) </volume> <pages> 185-215, </pages> <year> 1986. </year>
Reference-contexts: He also allows selective overriding of methods from multiple superclasses. While the approach has certain appeal of simplicity, inability to distinguish between actual instances present and possible instances, leads to unintuitive successes of messages to non-existing instances. There has been another stream of work <ref> [Zan85, AN86, Mai86] </ref>, which also aim to provide logical languages for "complex object" databases. In these work, the objects in the database are treated as structured terms, possibly organized in an inheritance hierarchy. Horn clauses, having such structured terms as arguments, are then used to define views over the objects.
Reference: [Ban86] <editor> F. Bancilhon. A logic-programming/object-oriented cocktail. </editor> <booktitle> SIGMOD record, </booktitle> <volume> 15(3) </volume> <pages> 11-21, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: His method lookup procedure is similar to that in a conventional object oriented language like Smalltalk. His implementation uses meta-interpretation in Prolog. While his language is more flexible in selective overriding from multiple superclasses, it does not have the capability to backtrack across classes while processing a message. Bancilhon <ref> [Ban86] </ref> is the first to provide precise relational semantics of sending and receiving messages. He does not provide unique identifiers to objects (although he does use surrogates for them which are not visible to the user).
Reference: [Bea87] <author> J. Banerjee and et. al. </author> <title> Data model issues for object oriented applications. </title> <journal> ACM | Transactions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 3-36, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Correspondence about this paper should be sent to the second author. 1 language for data definition and data manipulation of object oriented databases. Data manipulation languages of the current object oriented database prototypes <ref> [MSOP86, HZ87, Bea87, Fea87, KBC*88] </ref> do not have the declarative query capability enjoyed by relational systems [Ull87]. This is because they follow the procedural and deterministic computational model of conventional object oriented languages such as Smalltalk [GR84]. Conventional object oriented languages are deterministic and procedural.
Reference: [BMSU86] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proc. 5th. ACM SIGMOD-SIGACT Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <year> 1986. </year>
Reference-contexts: All this is achieved by a simple and compact translation of OOLP+ programs to Prolog programs, which are executable without any meta-interpretation. Translatability of OOLP+ programs into ordinary Prolog programs makes it possible to take advantage of existing logical query optimization techniques <ref> [SZ87, BMSU86] </ref> and build object oriented deductive databases on top of existing relational databases. Messages of a OOLP+ program to query the instances, can be globally optimized by using a logical query compiler such as [KZ88].
Reference: [CW89] <author> W. Chen, and D. S. Warren. </author> <title> C-Logic of Complex Objects. </title> <booktitle> In Proc. 8th. ACM SIGMOD-SIGACT Symposium on Principles of Database Systems, </booktitle> <pages> pages 369-378, </pages> <year> 1989. </year>
Reference-contexts: We believe that treating objects as a named collection of relational assertions, as is the case with OOLP, results in a simple implementation, leading to direct utilization of existing Datalog query optimizations. We have recently noticed that <ref> [CW89] </ref> independently arrived at similar conclusions. 5 Conclusions In this paper, we presented the semantics and implementation of a database language OOLP+. It gives relational interpretation of the object oriented concepts of classes, instances, messages and multiple inheritance.
Reference: [Fea87] <author> D. H. Fishman and et. al. </author> <title> Iris: an object-oriented database management system. </title> <journal> ACM | Transactions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 48-69, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Correspondence about this paper should be sent to the second author. 1 language for data definition and data manipulation of object oriented databases. Data manipulation languages of the current object oriented database prototypes <ref> [MSOP86, HZ87, Bea87, Fea87, KBC*88] </ref> do not have the declarative query capability enjoyed by relational systems [Ull87]. This is because they follow the procedural and deterministic computational model of conventional object oriented languages such as Smalltalk [GR84]. Conventional object oriented languages are deterministic and procedural.
Reference: [FH86] <author> Koichi Fukunaga and Shin-ichi Hirose. </author> <title> An experience with a Prolog-based object-oriented language. </title> <booktitle> In Proc. </booktitle> <address> OOPSLA-86, Portland, Oregon, </address> <month> September, </month> <pages> pages 224-231, </pages> <year> 1986. </year>
Reference-contexts: Programmers thus have considerable control over message processing. The main difficulty in integrating object oriented paradigm with logic programming is to decide how much of such control can be provided within the declarative and success/failure based framework of logic programming. Existing proposals <ref> [Zan84, FH86, Gal86] </ref> which provide many deterministic controls, do so only at the expense of losing consistency with the declarative nature of logic programming and are usually implemented by meta-interpretation. <p> Gallaire [Gal86] provides multiple answers, and success/failure semantics of messages. He has two types of methods | default methods and deterministic methods; only the default methods could be over-ridden by subclasses. His method lookup rules are complex requiring more complex implementation than that of OOLP+. The SPOOL language <ref> [FH86] </ref> distinguishes between classes and instances, provides logical variables enumerating over instances and uses meta-interpretation for implementation.
Reference: [Gal86] <author> H. Gallaire. </author> <title> Merging object and logic programming: relational semantics. </title> <booktitle> In Proceedings of AAAI-86, </booktitle> <pages> pages 754-758, </pages> <address> Philadelphia, PA, </address> <year> 1986. </year> <month> 12 </month>
Reference-contexts: Programmers thus have considerable control over message processing. The main difficulty in integrating object oriented paradigm with logic programming is to decide how much of such control can be provided within the declarative and success/failure based framework of logic programming. Existing proposals <ref> [Zan84, FH86, Gal86] </ref> which provide many deterministic controls, do so only at the expense of losing consistency with the declarative nature of logic programming and are usually implemented by meta-interpretation. <p> Our translation is however more compact than his, by not requiring to repeat method definitions for every instance. This compactness enabled us to use the same translation for providing the semantics as well as a fast implementation. Gallaire <ref> [Gal86] </ref> provides multiple answers, and success/failure semantics of messages. He has two types of methods | default methods and deterministic methods; only the default methods could be over-ridden by subclasses. His method lookup rules are complex requiring more complex implementation than that of OOLP+.
Reference: [GH89] <author> D. Gangopadhyay and A. R. Helm. </author> <title> A model driven approach for the reuse of classes from domain specific object-oriented class repositories. </title> <institution> Research Report RC14510, IBM Research Division, </institution> <month> March </month> <year> 1989. </year>
Reference-contexts: Current implementation on top of an existing Prolog system and a graphics toolkit, has required only 900 lines of Prolog and 600 lines of C++ programming. OOLP+ have been applied in building a knowledge base system for selecting appropriate components from a large library of reusable software <ref> [GH89] </ref>. Experiences from this application suggest that built-in query capability and the modeling capabilities of OOLP+ indeed makes it a very useful language for knowledge representation.
Reference: [GR84] <author> A. Goldberg and D. Robson. </author> <title> SMALLTALK-80 : The Language and Its Implementation, chapter 17. </title> <publisher> Addison-Wesley, </publisher> <year> 1984. </year>
Reference-contexts: Data manipulation languages of the current object oriented database prototypes [MSOP86, HZ87, Bea87, Fea87, KBC*88] do not have the declarative query capability enjoyed by relational systems [Ull87]. This is because they follow the procedural and deterministic computational model of conventional object oriented languages such as Smalltalk <ref> [GR84] </ref>. Conventional object oriented languages are deterministic and procedural. They provide features such as selective lookup of methods from superclasses and method overriding. Programmers thus have considerable control over message processing.
Reference: [HZ87] <author> Mark F. Hornick and Stanley B. Zodnik. </author> <title> A shared, segmented memory system for an object-oriented database. </title> <journal> ACM | Transactions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 70-95, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Correspondence about this paper should be sent to the second author. 1 language for data definition and data manipulation of object oriented databases. Data manipulation languages of the current object oriented database prototypes <ref> [MSOP86, HZ87, Bea87, Fea87, KBC*88] </ref> do not have the declarative query capability enjoyed by relational systems [Ull87]. This is because they follow the procedural and deterministic computational model of conventional object oriented languages such as Smalltalk [GR84]. Conventional object oriented languages are deterministic and procedural.
Reference: [KBC*88] <author> Won Kim, Nat Ballou, Hong-Tai Chou, Jorge F. Garza, Darrell Woelk, and Jay Banerjee. </author> <title> Integrating an object-oriented programming system with a database system. </title> <booktitle> In Proc. </booktitle> <address> OOPSLA-88, San Diego, California, </address> <month> September, </month> <pages> pages 142-152, </pages> <year> 1988. </year>
Reference-contexts: Correspondence about this paper should be sent to the second author. 1 language for data definition and data manipulation of object oriented databases. Data manipulation languages of the current object oriented database prototypes <ref> [MSOP86, HZ87, Bea87, Fea87, KBC*88] </ref> do not have the declarative query capability enjoyed by relational systems [Ull87]. This is because they follow the procedural and deterministic computational model of conventional object oriented languages such as Smalltalk [GR84]. Conventional object oriented languages are deterministic and procedural.
Reference: [KZ88] <author> Ravi Krishnamurthy and Carlo Zaniolo. </author> <title> Optimizations in a logic based language for knowledge and data intensive applications. </title> <editor> In Schmidt, Ceri, and Missikoff, editors, </editor> <booktitle> Advances in Database Technology, </booktitle> <address> EDBT'88, </address> <year> 1988. </year>
Reference-contexts: Messages of a OOLP+ program to query the instances, can be globally optimized by using a logical query compiler such as <ref> [KZ88] </ref>. Thus, OOLP+ enables the use of known technology to build object oriented deductive databases (OODDBs). This distinguishes it from alternative proposals in the literature. Detailed comparison with previous work is deferred until Section 4 of this paper. The rest of the paper is organized as follows.
Reference: [Lea85] <author> R. Lorie and et. al. </author> <title> Supporting complex objects in a relational system for engineering databases. </title> <booktitle> In Query Processing in Database Systems, </booktitle> <pages> pages 145-155, </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Second, when objects with structured subcomponents are to be represented, the OOLP translation will split the subcomponents into different relations, accessible using object ids from the relation corresponding to the parent object. Retrieving such subcomponents is better accomplished if the DBMS provides pointers as data types (as in <ref> [Lea85] </ref>), thereby avoiding joins. OOLP+ language and its programming environment with graphical class browsers have been implemented. Current implementation on top of an existing Prolog system and a graphics toolkit, has required only 900 lines of Prolog and 600 lines of C++ programming.
Reference: [Mai86] <author> David Maier. </author> <title> A logic for objects. </title> <booktitle> In Preprints of Workshop Foundations of Logic Programming and Deductive Databases, </booktitle> <address> Washington, DC, </address> <year> 1986. </year>
Reference-contexts: He also allows selective overriding of methods from multiple superclasses. While the approach has certain appeal of simplicity, inability to distinguish between actual instances present and possible instances, leads to unintuitive successes of messages to non-existing instances. There has been another stream of work <ref> [Zan85, AN86, Mai86] </ref>, which also aim to provide logical languages for "complex object" databases. In these work, the objects in the database are treated as structured terms, possibly organized in an inheritance hierarchy. Horn clauses, having such structured terms as arguments, are then used to define views over the objects. <p> For example, if set constructors are used to construct terms, one has to worry about associativity and commutativity in defining unification algorithms [Sie84]. The problem of unification becomes even more complicated in presence of inheritance, as observed in <ref> [Mai86] </ref>. We believe that treating objects as a named collection of relational assertions, as is the case with OOLP, results in a simple implementation, leading to direct utilization of existing Datalog query optimizations.
Reference: [McC88] <author> F.G. McCabe. </author> <title> Logic and Objects. Part one: The Language. </title> <type> Technical Report Research Report DOC 86/9, </type> <institution> Department of Computing, Imperial College, </institution> <address> London, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: A shortcoming of their method lookup procedure is that it is based upon only unification of the head of a method clause with the body of a message, rather 10 than success of the method clause. The same shortcoming applies also to Zaniolo's proposal. McCabe <ref> [McC88] </ref> uses, like Zaniolo, parameterized theories for class and instance definitions without explicitly distinguishing among the two concepts. He also allows selective overriding of methods from multiple superclasses.
Reference: [MSOP86] <author> D. Maier, J. Stein, A. Otis, and A. Purdy. </author> <title> Development of an object-oriented dbms. </title> <booktitle> In Proc. </booktitle> <address> OOPSLA-86, Portland, Oregon, </address> <month> September, </month> <pages> pages 472-482, </pages> <year> 1986. </year>
Reference-contexts: Correspondence about this paper should be sent to the second author. 1 language for data definition and data manipulation of object oriented databases. Data manipulation languages of the current object oriented database prototypes <ref> [MSOP86, HZ87, Bea87, Fea87, KBC*88] </ref> do not have the declarative query capability enjoyed by relational systems [Ull87]. This is because they follow the procedural and deterministic computational model of conventional object oriented languages such as Smalltalk [GR84]. Conventional object oriented languages are deterministic and procedural.
Reference: [SB86] <author> Mark Stefik and Daniel G. Bobrow. </author> <title> Object-oriented programming: themes and variations. </title> <journal> The AI Magazine, </journal> <volume> 6(4) </volume> <pages> 40-62, </pages> <month> Winter </month> <year> 1986. </year>
Reference: [Sie84] <author> J. H. Siekman. </author> <title> Universal unification. </title> <editor> In R. E. Shostak, editor, </editor> <booktitle> Proceedings of 7th. International Conference on Automated Deduction, Lecture Notes in Computer Science 170, </booktitle> <pages> pages 293-322, </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Moreover, introducing structured terms leads to more complex logic with worse computational properties such as difficulties due to special unification algorithms. For example, if set constructors are used to construct terms, one has to worry about associativity and commutativity in defining unification algorithms <ref> [Sie84] </ref>. The problem of unification becomes even more complicated in presence of inheritance, as observed in [Mai86]. We believe that treating objects as a named collection of relational assertions, as is the case with OOLP, results in a simple implementation, leading to direct utilization of existing Datalog query optimizations.
Reference: [SZ87] <author> D. Sacca and C. Zaniolo. </author> <title> Implementation of recursive queries for data language based on pure Horn logic. </title> <booktitle> In Logic Programming Proc. of the Fourth International Conference, </booktitle> <pages> pages 104-135, </pages> <year> 1987. </year>
Reference-contexts: All this is achieved by a simple and compact translation of OOLP+ programs to Prolog programs, which are executable without any meta-interpretation. Translatability of OOLP+ programs into ordinary Prolog programs makes it possible to take advantage of existing logical query optimization techniques <ref> [SZ87, BMSU86] </ref> and build object oriented deductive databases on top of existing relational databases. Messages of a OOLP+ program to query the instances, can be globally optimized by using a logical query compiler such as [KZ88].
Reference: [Ull87] <author> J. D. Ullman. </author> <title> Database theory past and future. </title> <booktitle> In Proc. 6th. ACM SIGMOD-SIGACT Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-10, </pages> <year> 1987. </year> <month> 13 </month>
Reference-contexts: Correspondence about this paper should be sent to the second author. 1 language for data definition and data manipulation of object oriented databases. Data manipulation languages of the current object oriented database prototypes [MSOP86, HZ87, Bea87, Fea87, KBC*88] do not have the declarative query capability enjoyed by relational systems <ref> [Ull87] </ref>. This is because they follow the procedural and deterministic computational model of conventional object oriented languages such as Smalltalk [GR84]. Conventional object oriented languages are deterministic and procedural. They provide features such as selective lookup of methods from superclasses and method overriding.
Reference: [Zan84] <author> Carlo Zaniolo. </author> <title> Object-oriented programming in Prolog. </title> <booktitle> In Proc. 1984 International Symposium on Logic Programming, </booktitle> <address> Atlantic City, </address> <month> February, </month> <pages> pages 265-270, </pages> <year> 1984. </year>
Reference-contexts: Programmers thus have considerable control over message processing. The main difficulty in integrating object oriented paradigm with logic programming is to decide how much of such control can be provided within the declarative and success/failure based framework of logic programming. Existing proposals <ref> [Zan84, FH86, Gal86] </ref> which provide many deterministic controls, do so only at the expense of losing consistency with the declarative nature of logic programming and are usually implemented by meta-interpretation. <p> The cut for override is then inserted into that single clause. For example, the following overriding method declaration p (Args) body1: p (Args) body2: is converted to p (X; Args) c (X); !; p 0 (Args): p 0 (Args) body1: p 0 (Args) body2: before translation. A classic example <ref> [Zan84] </ref> to illustrate the use of override methods is shown below. class bird has methods transport-mode (fly). class wingless-bird has super class bird and methodo transport-mode (walk) . Here bird is a class with a method transport- mode which succeeds only if the argument is flying. <p> These are compared to our work in this section. The first major approach was reported by Zaniolo <ref> [Zan84] </ref>. He views objects as parameterized theories with no distinction made between objects and classes. His method lookup procedure is similar to that in a conventional object oriented language like Smalltalk. His implementation uses meta-interpretation in Prolog.
Reference: [Zan85] <author> Carlo Zaniolo. </author> <title> The representation and deductive retrieval of complex objects. </title> <booktitle> In Proceedings of VLDB 85, Stockholm, </booktitle> <pages> pages 458-469, </pages> <year> 1985. </year> <month> 14 </month>
Reference-contexts: He also allows selective overriding of methods from multiple superclasses. While the approach has certain appeal of simplicity, inability to distinguish between actual instances present and possible instances, leads to unintuitive successes of messages to non-existing instances. There has been another stream of work <ref> [Zan85, AN86, Mai86] </ref>, which also aim to provide logical languages for "complex object" databases. In these work, the objects in the database are treated as structured terms, possibly organized in an inheritance hierarchy. Horn clauses, having such structured terms as arguments, are then used to define views over the objects.
References-found: 23

