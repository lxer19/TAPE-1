URL: ftp://ftp.cs.arizona.edu/reports/1996/TR96-12.ps.Z
Refering-URL: http://www.cs.arizona.edu/people/hiltunen/hiltunen.html
Root-URL: http://www.cs.arizona.edu
Title: CONFIGURABLE FAULT-TOLERANT DISTRIBUTED SERVICES  
Author: Matti Aarno Hiltunen 
Degree: (Ph.D. Dissertation)  
Note: This research was supported by NFS grant CCR-9003161, ONR grants N00014-91-J-1015, N00014-94-1 0015, and N00014-96-0207, and grants from Suomen Kulttuurirahasto and Suomen Akatemia.  
Address: Tucson, Arizona 85721  
Affiliation: Department of Computer Science The University of Arizona  
Date: July 11, 1996  
Pubnum: TR96-12  
Abstract-found: 0
Intro-found: 1
Reference: [ACBMT95] <author> E. Anceaume, B. Charron-Bost, P. Minet, and S. Toueg. </author> <title> On the formal specification of group membership services. </title> <type> Technical Report TR95-1534, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> Aug </month> <year> 1995. </year>
Reference-contexts: However, live detection is necessary but not sufficient to guarantee live service. For example, the membership protocol in Isis [RB91] that uses live detection based on timeouts has been shown not to be live in all situations <ref> [ACBMT95] </ref>. In synchronous systems, membership services are typically accurate and live [Cri91, KGR91]. In membership services in which change detection is inaccurate, the level of confidence indicates how certain it is that the suspected change has actually occurred. <p> The Isis membership service has live failure detection based on single site suspicion. Although the service was assumed to be live [RB91], it has later shown not to be live in all cases <ref> [ACBMT95] </ref>. Since GBCAST messages are totally ordered, the service realizes both total ordering of membership changes and virtual synchrony.
Reference: [AD76] <author> P. Alsberg and J. Day. </author> <title> A principle for resilient sharing of distributed resources. </title> <booktitle> In Proceedings of the 2nd International Conference on Software Engineering, </booktitle> <pages> pages 562-570, </pages> <month> Oct </month> <year> 1976. </year>
Reference-contexts: This approach is an example of active replication, where every replica executes the same operations. In the primary/backup paradigm, only one of the replicas actively executes client requests <ref> [AD76, BJRA85, BMST92] </ref>, with the state of the other backup replicas being updated periodically. This approach is an example of passive replication. In the object/action paradigm, the system is constructed of passive objects that export actions, i.e., operations, that modify the state of objects [Gra86].
Reference: [ADKM92a] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. </author> <title> Membership algorithms for multicast communication groups. </title> <booktitle> In Proceedings of the 6th International Workshop on Distributed Algorithms (Lecture Notes in Computer Science 647), </booktitle> <pages> pages 292-312, </pages> <address> Haifa, Israel, </address> <month> Nov </month> <year> 1992. </year>
Reference-contexts: here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis <ref> [ADKM92b, ADKM92a] </ref>, and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those that have fault-tolerance requirements [Bir85a, BJ87, BC91, BSS91, BR94]. <p> Furthermore, membership services are not uniform in how they interact with the application. In our approach, a service signals membership changes by forwarding membership change messages to the application in the regular message stream. We call services that follow this approach, including ISIS [BSS91], Consul [MPS92], and Transis <ref> [ADKM92a, ADKM92b] </ref>, delta-based services since they deliver the changes (deltas) to the application. Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs. We call services that follow this approach, including [Cri91, AMMS + 93, RFJ93, SR93], set-based services.
Reference: [ADKM92b] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. Transis: </author> <title> A communication sub-system for high availability. </title> <booktitle> In Proceedings of the 22nd Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 76-84, </pages> <address> Boston, </address> <month> Jul </month> <year> 1992. </year>
Reference-contexts: Therefore, the corresponding state changes occur in the same order. Other multicast or broadcast services provide different sets of properties. The V-system [CZ85] provides only unreliable multicast. Consul [MPS93a, MPS93b], Isis [BSS91], and Transis <ref> [ADKM92b, DM96] </ref> provide multicast with the atomicity property and various ordering properties, but no timeliness properties. The Mars system [KO87, KDK + 89] provides atomicity, ordering, and timeliness properties. The existing multicast implementations cover only a small subset of all possible combinations of multicast properties, however. <p> here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis <ref> [ADKM92b, ADKM92a] </ref>, and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those that have fault-tolerance requirements [Bir85a, BJ87, BC91, BSS91, BR94]. <p> Finally, note that the concept of a graph of messages is very appealing as an implementation tool as well. For example, this technique is closely related to the causality graphs used in Psync [PBS89] and Transis <ref> [ADKM92b] </ref>, which capture the causal ordering relation between messages. 3.1.2 Relations between Properties Examining existing implementations of a service results in a set of properties for each implementation. <p> Furthermore, membership services are not uniform in how they interact with the application. In our approach, a service signals membership changes by forwarding membership change messages to the application in the regular message stream. We call services that follow this approach, including ISIS [BSS91], Consul [MPS92], and Transis <ref> [ADKM92a, ADKM92b] </ref>, delta-based services since they deliver the changes (deltas) to the application. Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs. We call services that follow this approach, including [Cri91, AMMS + 93, RFJ93, SR93], set-based services. <p> The various approaches for accomplishing this can be classified into three major categories: (1) broadcast based (e.g., <ref> [MPS93a, ADKM92b] </ref>), (2) coordinator based (e.g., [RB91, RFJ93]), and (3) token based (e.g., [RM89]). In examining each approach in light of our requirements, we selected the third based on the resulting simplicity of the micro-protocols.
Reference: [AFM92] <author> S. Armstrong, A. Freier, and K. Marzullo. </author> <title> Multicast transport protocol. Request for Comments (Informational) RFC 1301, </title> <institution> Internet Engineering Task Force, </institution> <month> Feb </month> <year> 1992. </year>
Reference-contexts: Schemes based on logical rings or token passing are used by many multicast, membership, and system diagnosis protocols. For example, token passing is used as a means of implementing reliable totally ordered multicast in the Reliable Broadcast Protocol [CM84], Token-Passing Multicast (TPM) protocol [RM89], Multicasting Transport Protocol (MTP) <ref> [AFM92] </ref>, Totem [AMMS + 95], Pinwheel [CM95], and Reliable Multicast Protocol (RMP) [WMK95]. In these protocols, the site possessing the token is either the only site that is allowed to send a message or the site that assigns a global ordering to messages sent by all sites. <p> In this scheme, messages are first sent directly to the ordering server, which then retransmits them in some total order to all receivers. Alternatively, messages can be multicast directly to the receivers, with the central ordering service only sending ordering messages <ref> [AFM92] </ref>. Like any centralized service, a total ordering service of this type suffers from the problem of how to handle the failure of the central authority.
Reference: [AGH + 91] <author> H-R. Aschmann, N. Giger, E. Hoepli, P. Janak, and H. Kirrmann. Alphorn: </author> <title> A remote procedure call environment for fault-tolerant, heterogeneous, </title> <journal> distributed systems. IEEE Micro, </journal> <volume> 11(5) 16-19,60-67, </volume> <month> Oct </month> <year> 1991. </year>
Reference-contexts: With RPC, a request for service from a client to a server process is structured to give synchronization semantics at the client similar to normal procedure call. Numerous examples of different RPC services and implementations exist, including Firefly RPC [SB90], Alphorn <ref> [AGH + 91] </ref>, lightweight RPC [BALL90], Peregrine [JZ93], [RSV94], and SUPRA-RPC [Sto94]. Among the commercial RPC packages released have been Courier from Xerox [Xer81], Sun RPC [Sun88], Netwise RPC from Novell Netware, and NCA from Apollo [Apo89]. [TA90] gives a survey of work in this area.
Reference: [AMMS + 93] <author> Y. Amir, L. Moser, P. Melliar-Smith, D. Agarwal, and P. Ciarfella. </author> <title> Fast message ordering and membership using a logical token-passing ring. </title> <booktitle> In Proceedings of the 13th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 551-560, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem <ref> [AMMS + 93, AMMS + 95, MMSA + 96] </ref>, Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those that have fault-tolerance requirements [Bir85a, BJ87, BC91, BSS91, BR94]. <p> This is acceptable in cases where the actual membership of the destination group is not important, but stronger guarantees are useful in some cases. Extended virtual synchrony extends virtual synchrony by guaranteeing that all messages sent under the old membership are also delivered before the membership change message <ref> [AMMS + 93] </ref>. Extended virtual synchrony can be defined more formally as follows. <p> Figure 4.11 illustrates this property; the shaded circles represent messages that were sent before the sender received the membership change message M (C). 86 Extended virtual synchrony has been explored in a number of papers, especially <ref> [AMMS + 93] </ref> and [MAMSA94]. <p> Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs. We call services that follow this approach, including <ref> [Cri91, AMMS + 93, RFJ93, SR93] </ref>, set-based services. Although properties for the two types of services are typically stated differently, mappings between them can usually be constructed in a straightforward manner. <p> Although not guaranteed by the basic algorithm, agreement on successors and predecessors is easy to implement given the communication system and failure assumptions. 4.4.6 Totem The Totem message ordering and membership protocol is described in <ref> [AMMS + 93, AMMS + 95] </ref>. The protocol is based on a logical token passing scheme, where the token is used for total ordering of messages, reliable message transmission, flow control, and membership. All messages in Totem are totally ordered reliable multicasts. <p> Furthermore, as will be discussed in the following sections, the algorithm could be augmented to provide ordering and other properties. Although the algorithm uses similar ideas as some published membership algorithms 150 for example, using a logical ring structure <ref> [AMMS + 93, HS94a, RFJ93] </ref>the complete algorithm is different from any of which we are aware. In terms of message complexity it is very attractive.
Reference: [AMMS + 95] <author> Y. Amir, L. Moser, P. Melliar-Smith, D. Agarwal, and P. Ciarfella. </author> <title> The Totem single-ring ordering and membership protocol. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 13(4) </volume> <pages> 311-342, </pages> <month> Nov </month> <year> 1995. </year>
Reference-contexts: A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem <ref> [AMMS + 93, AMMS + 95, MMSA + 96] </ref>, Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those that have fault-tolerance requirements [Bir85a, BJ87, BC91, BSS91, BR94]. <p> The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties [RFJ93, GT92, Hil95] to others that guarantee strong properties <ref> [BSS91, AMMS + 95, DMS95] </ref>. The tradeoff is the strength of the guarantee versus the execution cost. <p> One common approach is simply to assume they will not occur [Cri91, KGR91, MPS92]. This can be justified by increasing the connectivity of the network or by using other architectural assumptions. If this assumption is not valid, there are a number of ways to deal with multiple partitions <ref> [AMMS + 95, DMS94, DMS95, MAMSA94, RFJ93, RB91, SM94] </ref>. <p> Although not guaranteed by the basic algorithm, agreement on successors and predecessors is easy to implement given the communication system and failure assumptions. 4.4.6 Totem The Totem message ordering and membership protocol is described in <ref> [AMMS + 93, AMMS + 95] </ref>. The protocol is based on a logical token passing scheme, where the token is used for total ordering of messages, reliable message transmission, flow control, and membership. All messages in Totem are totally ordered reliable multicasts. <p> For example, token passing is used as a means of implementing reliable totally ordered multicast in the Reliable Broadcast Protocol [CM84], Token-Passing Multicast (TPM) protocol [RM89], Multicasting Transport Protocol (MTP) [AFM92], Totem <ref> [AMMS + 95] </ref>, Pinwheel [CM95], and Reliable Multicast Protocol (RMP) [WMK95]. In these protocols, the site possessing the token is either the only site that is allowed to send a message or the site that assigns a global ordering to messages sent by all sites. <p> It also has the potential to improve application performance by giving the designer explicit control over the tradeoff between the strength of the guarantees provided and the performance; rather than having to accept guarantees stronger than needed and 2 Totem uses a commit token for a similar purpose <ref> [AMMS + 95] </ref>. 137 thereby incur extra execution costs, the designer can selectand pay foronly those guarantees that are truly required. The approach is based on mapping abstract properties to individual micro-protocols, which are then configured together with a standard runtime system to form a composite protocol.
Reference: [AO93] <author> G. Andrews and R. Olsson. </author> <title> The SR programming language:Concurrency in Practice. </title> <publisher> The Benjamin/Cummings Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: We also examine issues that affect which combinations of properties and micro-protocols result in operational services. Finally, we briefly describe three prototype implementations of the model: one using the SR programming language <ref> [AO93, AOC + 88] </ref>, a second using the x-kernel, and a third using C++. <p> For example, sequential blocking events can be implemented using only ordinary procedure calls. Here, we provide an overview of three prototype systems that support this model. 3.4.2 SR Prototype Initial experimentation was done using the SR concurrent programming language <ref> [AO93, AOC + 88] </ref> in the context of a reliable ordered group oriented multicast service [HS93]. In this prototype, each logical site hosting members of the multicast group is implemented as an SR virtual machine.
Reference: [AOC + 88] <author> G. Andrews, R. Olsson, M. Coffin, I. Elshoff, K. Nilsen, T. Purdin, and G. Townsend. </author> <title> An overview of the SR language and implementation. </title> <journal> 204 ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(1) </volume> <pages> 51-86, </pages> <month> Jan </month> <year> 1988. </year>
Reference-contexts: We also examine issues that affect which combinations of properties and micro-protocols result in operational services. Finally, we briefly describe three prototype implementations of the model: one using the SR programming language <ref> [AO93, AOC + 88] </ref>, a second using the x-kernel, and a third using C++. <p> For example, sequential blocking events can be implemented using only ordinary procedure calls. Here, we provide an overview of three prototype systems that support this model. 3.4.2 SR Prototype Initial experimentation was done using the SR concurrent programming language <ref> [AO93, AOC + 88] </ref> in the context of a reliable ordered group oriented multicast service [HS93]. In this prototype, each logical site hosting members of the multicast group is implemented as an SR virtual machine.
Reference: [AOG92] <author> D. P. Anderson, Y. Osawa, and R. Govindan. </author> <title> A file system for continuous media. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(4) </volume> <pages> 311-337, </pages> <month> Nov </month> <year> 1992. </year>
Reference-contexts: Traditional file systems are also less than ideal for multimedia applications. In particular, multimedia requires high I/O throughput rates and quality of service guarantees such as constant minimum data rates not typically provided by file systems <ref> [AOG92] </ref>. Typical file systems also do not support easy addition of new services, such as compression or encryption [HP94]. Many of these problems have been addressed in research projects that study configurable or extensible file systems.
Reference: [Apo89] <author> Apollo Computer Inc. </author> <title> Network computing system (NCS) reference. </title> <type> Technical report, </type> <institution> Apollo Computer Inc., </institution> <year> 1989. </year>
Reference-contexts: Among the commercial RPC packages released have been Courier from Xerox [Xer81], Sun RPC [Sun88], Netwise RPC from Novell Netware, and NCA from Apollo <ref> [Apo89] </ref>. [TA90] gives a survey of work in this area. On the surface, the semantics of RPC seem very simple, yet the reality is that there are subtleties and variations. For example, there are many ways to define how an RPC service deals with server and communication failures. <p> In this chapter, we apply our approach of constructing configurable fault-tolerant distributed services to group RPC. To simplify the presentation, we concentrate on RPC features related to distribution and fault tolerance. Other issues, although important, are not addressed here. These include stub generation and heterogeneity <ref> [Sun88, Gib87, HS87, Apo89, TB90, WSG91] </ref>, binding [BN84, LT91, BALL90], performance or performance optimizations [PA88, RST89, SB90, BALL90], and security issues [Bir85b].
Reference: [ATK91] <author> A.L. Ananda, B.H. Tay, and E.K. Koh. </author> <title> ASTRA An asynchronous remote procedure call facility. </title> <booktitle> In Proceedings of the 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 172-179, </pages> <address> Arlington, Texas, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: In the latter case, the RPC system may include another system call that allows the thread to retrieve results later. Although synchronous is most commonly used, a number of systems provide an asynchronous option as well (e.g., <ref> [ATK91] </ref>). Orphan handling semantics specify how orphansthat is, server computations associated with clients that have failedare dealt with. Orphans not only waste computing resources, but may also interfere with new calls issued by a recovered client.
Reference: [Avi85] <author> A. Avizienis. </author> <title> The N-Version approach to fault-tolerant software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(12):1491-1501, </volume> <month> Dec </month> <year> 1985. </year>
Reference-contexts: Furthermore, as noted above, adaptive systems are important in the area of dependable computing [GGL93]. An example in this area is the SCOP (Self-Configuring Optimistic Programming) scheme [BDGX93], an adaptive version of N-version programming <ref> [Avi85] </ref>. In this scheme, multiple alternative algorithms are executed, with the actual number of alternatives used being determined at runtime based on the level of confidence desired. Adaptive algorithms have also been used to diagnose faulty processors in distributed systems [KH83, BB91, LYS93].
Reference: [BALL90] <author> B. Bershad, T. Anderson, E. Lazokska, and H. Levy. </author> <title> Lightweight remote procedure call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 37-55, </pages> <month> Feb </month> <year> 1990. </year>
Reference-contexts: With RPC, a request for service from a client to a server process is structured to give synchronization semantics at the client similar to normal procedure call. Numerous examples of different RPC services and implementations exist, including Firefly RPC [SB90], Alphorn [AGH + 91], lightweight RPC <ref> [BALL90] </ref>, Peregrine [JZ93], [RSV94], and SUPRA-RPC [Sto94]. Among the commercial RPC packages released have been Courier from Xerox [Xer81], Sun RPC [Sun88], Netwise RPC from Novell Netware, and NCA from Apollo [Apo89]. [TA90] gives a survey of work in this area. <p> To simplify the presentation, we concentrate on RPC features related to distribution and fault tolerance. Other issues, although important, are not addressed here. These include stub generation and heterogeneity [Sun88, Gib87, HS87, Apo89, TB90, WSG91], binding <ref> [BN84, LT91, BALL90] </ref>, performance or performance optimizations [PA88, RST89, SB90, BALL90], and security issues [Bir85b]. <p> To simplify the presentation, we concentrate on RPC features related to distribution and fault tolerance. Other issues, although important, are not addressed here. These include stub generation and heterogeneity [Sun88, Gib87, HS87, Apo89, TB90, WSG91], binding [BN84, LT91, BALL90], performance or performance optimizations <ref> [PA88, RST89, SB90, BALL90] </ref>, and security issues [Bir85b].
Reference: [BB91] <author> R. Bianchini and R. Buskens. </author> <title> An adaptive distributed system-level diagnosis algorithm and its implementation. </title> <booktitle> In Proceedings of the 21st Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 222-229, </pages> <month> Jun </month> <year> 1991. </year>
Reference-contexts: Furthermore, system diagnosis [PMC67], which deals with the problem of detecting faulty processors, is closely related to membership. System diagnosis assumes a failure model where faulty processors can be detected by executing a test program on the processor <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties [RFJ93, GT92, Hil95] to others that guarantee strong properties [BSS91, AMMS + 95, DMS95]. <p> Once a failure or recovery is detected, however, a membership protocol that employs a coordinator process is employed rather than using the ring. Some system diagnosis protocols, such as the Adaptive DSD protocol <ref> [BB91] </ref>, use a logical ring for failure monitoring and information propagation. <p> On the basis of the responses, the outcome of the test is classified as pass or fail. In either case, the testing unit evaluates the tested unit as either fault-free or faulty. Numerous papers on system diagnosis have followed <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. Despite the close resemblance of the system diagnosis problem and the membership problem discussed in chapters 4 and 5, little has been done to compare or contrast these two fields. <p> It is shown that this property requires that any node be tested by at least t p + 1 nodes. For example, D 1t is t p self-diagnosable if t = t p + 1. More recent work on distributed diagnosis can be found in <ref> [BGN90, BB91, BB93, SA89, WHS95] </ref>. The first attempt at probabilistic diagnosis is in [MH76], which proposes assigning a reliability to each subunit in the network. This reliability measure is simply the probability of a fault occurring in a given subunit. <p> Traditional system diagnosis algorithms have fixed testing assignments and can therefore tolerate a fixed number of failures, whereas most membership algorithms are prepared to tolerate any number of failures. However, lately this distinction appears to be disappearing since some recent system diagnosis algorithms, for example <ref> [BB91] </ref>, can tolerate any number of failures. In contrast with most system diagnosis algorithms, membership algorithms acknowledge that the detection mechanism may give false detectionsespecially those designed for asynchronous systems where it is impossible to tell the difference between a failed processor and a slow communication link. <p> A suggestion was made that techniques from membership algorithms could be used in system diagnosis algorithms to detect time domain failures and similarly techniques from system diagnosis algorithms could be used in membership algorithms to detect failures in the data domain. However, in practical system diagnosis algorithms, such as <ref> [BB91, BB93, WHS95] </ref>, lack of response is considered a failure, i.e., time domain failures are essentially detected as well. <p> between the service guarantees or possible transformations between membership and system diagnosis algorithms were not addressed in [BMD93]. 6.3 From System Diagnosis to Membership In this section, we apply the observations above and show how typical distributed system diagnosis algorithms NEW SELF [HKR84], EVENT SELF [BGN90], and Adaptive DSD 144 <ref> [BB91] </ref> can be transformed into membership algorithms. The transformation is based on changing the failure model and thereby the testing method. <p> Similar changes can be made to EVENT SELF to derive a new membership algorithm more efficient than the one derived from NEW SELF. 6.3.3 Adaptive DSD System Diagnosis Algorithm Adaptive DSD <ref> [BB91] </ref> is a variation of the NEW SELF algorithm where testing assignments change adaptively during the execution of the system diagnosis. Adaptive DSD assumes a distributed network, in which nodes perform tests of other nodes and determine them to be faulty or fault-free. Test results conform to the PMC model. <p> As a result of this process the fault-free processors will form a directed cycle. After N testing rounds every fault-free processor knows about every other fault-free processor in the system. The detailed algorithm and correctness proofs can be found in <ref> [BB91] </ref>. As noted above, the Adaptive DSD algorithm is optimal in terms of the total number of tests required. The algorithm can be improved, however, with respect to total number of messages and diagnostic latency. <p> In this scheme, multiple alternative algorithms are executed, with the actual number of alternatives used being determined at runtime based on the level of confidence desired. Adaptive algorithms have also been used to diagnose faulty processors in distributed systems <ref> [KH83, BB91, LYS93] </ref>. This chapter focuses on the adaptive aspect of configurability and use of the event-driven execution model in this context. We first describe a general model for adaptive systems.
Reference: [BB93] <author> R. Buskens and R. Bianchini. </author> <title> Distributed on-line diagnosis in the presence of arbitrary faults. </title> <booktitle> In Proceedings of the 23rd Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 470-479, </pages> <month> Jun </month> <year> 1993. </year>
Reference-contexts: Furthermore, system diagnosis [PMC67], which deals with the problem of detecting faulty processors, is closely related to membership. System diagnosis assumes a failure model where faulty processors can be detected by executing a test program on the processor <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties [RFJ93, GT92, Hil95] to others that guarantee strong properties [BSS91, AMMS + 95, DMS95]. <p> On the basis of the responses, the outcome of the test is classified as pass or fail. In either case, the testing unit evaluates the tested unit as either fault-free or faulty. Numerous papers on system diagnosis have followed <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. Despite the close resemblance of the system diagnosis problem and the membership problem discussed in chapters 4 and 5, little has been done to compare or contrast these two fields. <p> It is shown that this property requires that any node be tested by at least t p + 1 nodes. For example, D 1t is t p self-diagnosable if t = t p + 1. More recent work on distributed diagnosis can be found in <ref> [BGN90, BB91, BB93, SA89, WHS95] </ref>. The first attempt at probabilistic diagnosis is in [MH76], which proposes assigning a reliability to each subunit in the network. This reliability measure is simply the probability of a fault occurring in a given subunit. <p> A suggestion was made that techniques from membership algorithms could be used in system diagnosis algorithms to detect time domain failures and similarly techniques from system diagnosis algorithms could be used in membership algorithms to detect failures in the data domain. However, in practical system diagnosis algorithms, such as <ref> [BB91, BB93, WHS95] </ref>, lack of response is considered a failure, i.e., time domain failures are essentially detected as well.
Reference: [BBG + 88] <author> D. Batory, J. Barnett, J. Garza, K. Smith, K. Tsukuda, B. Twichell, and T. Wise. </author> <title> GENESIS: An extensible database management system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-14(11):1711-1729, </volume> <month> Nov </month> <year> 1988. </year>
Reference-contexts: Naturally, different systems use different protocols to realize the properties, mostly for performance reasons. However, when database systems are used in certain specific application areas, such as CAD, engineering, and artificial intelligence, some of the ACID properties have been found to be too restrictive <ref> [BBG + 88] </ref>. Similarly, subsets of the ACID properties have been found to be useful for transactions in an operating system context [SMK + 94]. <p> Extensible database systems, where the properties or their implementations can be adjusted to specific application requirements and execution 27 environments, have been developed to address some of these needs <ref> [SR86, SCF + 86, CD87, BBG + 88] </ref>. 1.2.4 Meeting Application Requirements Different fault-tolerant distributed applications have different requirements for the underlying services, so they should be able to select which properties are enforced. <p> In the latter case, we call it an adaptive service. Extensibility has been explored in the database community since the early 1980s, and has recently started to gain interest in the operating systems and networking communities. In databases, well-known examples include Genesis <ref> [BBG + 88] </ref> and Raid [BFHR90]. In operating systems, examples of configurable or extensible systems are Synthesis [PMI88], SPIN [BCE + 94], Scout [MMO + 94a], and V++ [CD94]. <p> be moved to a secondary, slower, storage device, can be replaced by writing a new policy within the derived class. 2.2.4 Database Systems Many important database applications, such as statistical databases, CAD and engineering databases, textual databases, and databases for artificial intelligence, are not well served by traditional database technology <ref> [BBG + 88] </ref>. Although specialized databases have been developed for these different application areas, exploiting configurability is an appealing alternative. Here, we outline two different configurable or extensible database systems. <p> For example, the con-currency control component implements timestamp ordering, two-phase locking, generic timestamp ordering, generic locking, and a generic optimistic algorithm as options for concurrency control. Genesis <ref> [BBG + 88] </ref> supports fast construction of complex and customized database systems from prefabricated components in libraries. New components can be added to the libraries, making the system extensible. A system is constructed as a hierarchical composition of components in predefined realms [BO92].
Reference: [BC91] <author> K. Birman and R. Cooper. </author> <title> The Isis project: Real experience with a fault-tolerant programming system. </title> <journal> Operating Systems Review, </journal> <volume> 25(2):103 107, </volume> <month> Apr </month> <year> 1991. </year>
Reference-contexts: Here, we examine the basic outline of some of these systems, without addressing in detail any of the particular services provided. Since the emphasis is on configurable systems, only two static systems are described: Isis <ref> [Bir85a, BJ87, BC91, BSS91, BR94] </ref> and Mars [KM85, KDK + 89, KG94]. The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. <p> 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those that have fault-tolerance requirements <ref> [Bir85a, BJ87, BC91, BSS91, BR94] </ref>. The toolkit is structured around the concepts of a process group, a group of processes cooperating to implement a service, and virtual synchrony, an abstraction that 34 enables the writing of applications as if the execution of the system was synchronous.
Reference: [BCE + 94] <author> B. Bershad, C. Chambers, S. Eggers, C. Maeda, D. McNamee, P. Pardyak, S. Savage, and E. Sirer. </author> <title> Spin an extensible microkernel for application specific operating system services. </title> <type> Technical Report 94-03-03, </type> <institution> University of Washington, </institution> <month> Feb </month> <year> 1994. </year>
Reference-contexts: In databases, well-known examples include Genesis [BBG + 88] and Raid [BFHR90]. In operating systems, examples of configurable or extensible systems are Synthesis [PMI88], SPIN <ref> [BCE + 94] </ref>, Scout [MMO + 94a], and V++ [CD94]. Also, in file systems, configura-bility has been used to enable new application types, such as databases and multimedia, to make use of file systems efficiently for their storage needs [HP94, KN93, Maf94]. <p> Numerous others, such as Choices [CJK + 87, CIM92], the Kernel Tool Kit (KTK) [GMSS94, MS96], Kea [VH96], and Apertos [Yok92, Yok93, TYT92, IY94], are not addressed here. The SPIN operating system is based on an extensible microkernel <ref> [BCE + 94, BSS + 95] </ref>. The microkernel exports interfaces that offer applications fine-grained control over a few fundamental system abstractions, such as threads and virtual address spaces.
Reference: [BDGX93] <author> A. Bondavalli, F. Di Giandomenico, and J. Xu. </author> <title> A cost-effective and flexible scheme for software fault tolerance. </title> <journal> Journal of Computer Systems Science and Engineering, </journal> <volume> 8 </volume> <pages> 234-244, </pages> <year> 1993. </year> <month> 205 </month>
Reference-contexts: Other examples include concurrency control of database transactions [BFHR90], real-time parallel systems [BS91, SBB87], operating systems [MS96], and high-speed communication protocols [SBS93]. Furthermore, as noted above, adaptive systems are important in the area of dependable computing [GGL93]. An example in this area is the SCOP (Self-Configuring Optimistic Programming) scheme <ref> [BDGX93] </ref>, an adaptive version of N-version programming [Avi85]. In this scheme, multiple alternative algorithms are executed, with the actual number of alternatives used being determined at runtime based on the level of confidence desired. Adaptive algorithms have also been used to diagnose faulty processors in distributed systems [KH83, BB91, LYS93].
Reference: [BDM95] <author> O. Babaoglu, R. Davoli, and A. Montresor. </author> <title> Failure detectors, group membership and view-synchronous communication in partitionable asynchronous systems. </title> <type> Technical Report UBLCS-95-18, </type> <institution> Department of Computer Sciences, University of Bologna, Bologna, Italy, </institution> <month> Nov </month> <year> 1995. </year>
Reference: [Bec94] <author> T. Becker. </author> <title> Application-transparent fault tolerance in distributed systems. </title> <booktitle> In Proceedings of the 2nd International Workshop on Configurable Distributed Systems, </booktitle> <pages> pages 36-45, </pages> <address> Pittsburgh, PE, </address> <year> 1994. </year>
Reference-contexts: An approach 39 resembling the ANSA approach is described in <ref> [Bec94] </ref>. Here, a separate software layer completely hides the fault-tolerance aspects from applications. 2.1.2.4 Adaptive Parallel Real-time System Configurability and adaptability are explored in the context of reliable parallel and distributed real-time systems in [BS91, SBB87].
Reference: [Ber96] <author> P. Bernstein. </author> <title> Middleware: A model for distributed system services. </title> <journal> Communications of the ACM, </journal> <volume> 39(2) </volume> <pages> 86-98, </pages> <month> Feb </month> <year> 1996. </year>
Reference-contexts: The abstraction of reliable communication hides events that designers would otherwise have to deal with, thereby simplifying development. Although reliable communication is essential for building fault-tolerant distributed applications, more powerful services, often called middleware <ref> [Ber96] </ref>, can further simplify the task. For example, an atomic ordered multicast or broadcast service with atomic-ity and message ordering guarantees makes it easy to send messages to a collection of processes [CM84, CZ85, CASD85, VM90, BSS91].
Reference: [BFG + 85] <author> J. Banino, J. Fabre, M. Guillemont, G. Morisset, and M. Rozier. </author> <title> Some fault-tolerant aspects of the Chorus distributed system. </title> <booktitle> In Proceedings of the 5th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 430-437, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus <ref> [BFG + 85] </ref>, Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to
Reference: [BFHR90] <author> B. Bhargava, K. Friesen, A. Helal, and J. Riedl. </author> <title> Adaptability experiments in the RAID distributed database system. </title> <booktitle> In Proceedings of the 9th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 76-85, </pages> <year> 1990. </year>
Reference-contexts: In the latter case, we call it an adaptive service. Extensibility has been explored in the database community since the early 1980s, and has recently started to gain interest in the operating systems and networking communities. In databases, well-known examples include Genesis [BBG + 88] and Raid <ref> [BFHR90] </ref>. In operating systems, examples of configurable or extensible systems are Synthesis [PMI88], SPIN [BCE + 94], Scout [MMO + 94a], and V++ [CD94]. <p> Here, we outline two different configurable or extensible database systems. Numerous others, including Postgres [SR86], Starburst [SCF + 86], Exodus [CD87], Gral [Gut89], Ream [KNKH89], and P2 [TB95], are not addressed here. The RAID system <ref> [BFHR90] </ref> has been used to study adaptive concurrency control. RAID is configurable in the sense that six componentsthe user interface, action driver, access manager, atomicity controller, concurrency controller, and replication controller provide a choice of algorithms for implementing their functionality. <p> The Transmission Control Protocol (TCP) of the Internet protocol suite uses adaptive mechanisms for flow control, retransmission, and congestion control [Jac88]. Other examples include concurrency control of database transactions <ref> [BFHR90] </ref>, real-time parallel systems [BS91, SBB87], operating systems [MS96], and high-speed communication protocols [SBS93]. Furthermore, as noted above, adaptive systems are important in the area of dependable computing [GGL93]. An example in this area is the SCOP (Self-Configuring Optimistic Programming) scheme [BDGX93], an adaptive version of N-version programming [Avi85]. <p> By design, optimistic algorithms work well if the system is lightly loaded whereas pessimistic ones are better when the system is heavily loaded. Therefore, it is advantageous to design an adaptive concurrency control protocol that changes between optimistic and pessimistic depending on the load. See, for example, <ref> [BFHR90] </ref> for more discussion on adaptive concurrency control. 8.3 Adapting to Failures This section examines examples of adaptive algorithms where the change in the environment is a processor or communication link failure. Changes to be adapted to here typically cause the system to stop until an adaptation is made.
Reference: [BG93] <author> K. Birman and B. Glade. </author> <title> Consistent failure reporting in reliable communication systems. </title> <type> Technical Report 93-1349, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: An accurate membership service is one that reports a change only if the change has indeed occurred (i.e., no false detections), while a live membership service is one that is guaranteed to report all changes eventually <ref> [BG93] </ref>. A special case of liveness is bounded liveness, where the failure or recovery is reported within a known bounded time. Accuracy and liveness can be defined more formally in terms of ordering graphs.
Reference: [BGN90] <author> R. Bianchini, K. Goodwin, and D. Nydick. </author> <title> Practical application and implementation of distributed system-level diagnosis theory. </title> <booktitle> In Proceedings of the 20th Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 332-339, </pages> <month> Jun </month> <year> 1990. </year>
Reference-contexts: Furthermore, system diagnosis [PMC67], which deals with the problem of detecting faulty processors, is closely related to membership. System diagnosis assumes a failure model where faulty processors can be detected by executing a test program on the processor <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties [RFJ93, GT92, Hil95] to others that guarantee strong properties [BSS91, AMMS + 95, DMS95]. <p> On the basis of the responses, the outcome of the test is classified as pass or fail. In either case, the testing unit evaluates the tested unit as either fault-free or faulty. Numerous papers on system diagnosis have followed <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. Despite the close resemblance of the system diagnosis problem and the membership problem discussed in chapters 4 and 5, little has been done to compare or contrast these two fields. <p> It is shown that this property requires that any node be tested by at least t p + 1 nodes. For example, D 1t is t p self-diagnosable if t = t p + 1. More recent work on distributed diagnosis can be found in <ref> [BGN90, BB91, BB93, SA89, WHS95] </ref>. The first attempt at probabilistic diagnosis is in [MH76], which proposes assigning a reliability to each subunit in the network. This reliability measure is simply the probability of a fault occurring in a given subunit. <p> The differences between the service guarantees or possible transformations between membership and system diagnosis algorithms were not addressed in [BMD93]. 6.3 From System Diagnosis to Membership In this section, we apply the observations above and show how typical distributed system diagnosis algorithms NEW SELF [HKR84], EVENT SELF <ref> [BGN90] </ref>, and Adaptive DSD 144 [BB91] can be transformed into membership algorithms. The transformation is based on changing the failure model and thereby the testing method. <p> As noted above, D 1t is t p self-diagnosable when t = t p + 1. The theoretically optimal NEW SELF algorithm has been found to be too expensive for practical systems, so a modified algorithm named EVENT SELF was developed <ref> [BGN90] </ref>. The original algorithm requires a high number of diagnostic messages to be forwarded through the network. This message count is significant and can exceed network capacity for testing networks with even a small number of nodes.
Reference: [Bha96] <author> N. T. Bhatti. </author> <title> A System for Constructing Configurable High-Level Protocols. </title> <type> PhD thesis, </type> <institution> Dept of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <year> 1996. </year> <note> In preparation. </note>
Reference-contexts: Initial experiments with a group RPC micro-protocol suite show modest execution overhead [BS95]. The prototype executes on DecStation 5000/240s connected by a 10 Mbit Ethernet network running the Mach operating system. Details of this implementation can be found in <ref> [BS95, Bha96] </ref>. 3.4.4 C++ Prototype A prototype of the event-driven execution model has also been implemented using C++.
Reference: [BHG87] <author> P. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: one. 8.2.3 Adaptive Concurrency Control Protocol The problem of concurrency control in database systems is to ensure that two or more concurrent transactions do not leave the database in an inconsistent state, that is, a state that could not have been reached by executing the transactions in some serial order <ref> [BHG87] </ref>. There are numerous such concurrency control algorithms, which can be broadly classified as pessimistic versus optimistic. The pessimistic algorithms are based on preventing conflicts that can lead to inconsistencies using locking or some other technique.
Reference: [BHV + 90] <author> P. Barrett, A. Hilborne, P. Verissimo, L. Rodrigues, P. Bond, D. Seaton, and N. Speirs. </author> <title> The Delta-4 extra performance architecture (XPA). </title> <booktitle> In Proceedings of the Twentieth Symposium on Fault Tolerant Computing, </booktitle> <pages> pages 481-488, </pages> <address> Newcastle-upon-tyne, </address> <month> Jun </month> <year> 1990. </year>
Reference-contexts: A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 <ref> [PSB + 88, BHV + 90, Pow91] </ref>, Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those
Reference: [Bir85a] <author> K. Birman. </author> <title> Replication and fault-tolerance in the Isis system. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 79-86, </pages> <address> Orcas Island, WA, </address> <month> Dec </month> <year> 1985. </year> <month> 206 </month>
Reference-contexts: Similarly, a membership service provides consistent information about which computers are functioning and which have failed at any given time in a distributed system, thereby simplifying the problems associated with failures <ref> [Cri91, Bir85a, EL90, KGR91, MPS92] </ref>. <p> Here, we examine the basic outline of some of these systems, without addressing in detail any of the particular services provided. Since the emphasis is on configurable systems, only two static systems are described: Isis <ref> [Bir85a, BJ87, BC91, BSS91, BR94] </ref> and Mars [KM85, KDK + 89, KG94]. The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. <p> 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those that have fault-tolerance requirements <ref> [Bir85a, BJ87, BC91, BSS91, BR94] </ref>. The toolkit is structured around the concepts of a process group, a group of processes cooperating to implement a service, and virtual synchrony, an abstraction that 34 enables the writing of applications as if the execution of the system was synchronous. <p> Similar problems were encountered in a project attempting a modular implementation of the xAMP atomic broadcast protocol suite in the x-kernel [RV92, Fon94]. 2.1.2.2 Horus Horus [RHB95, RBG + 95, RB95, RBM96] is a successor to the Isis system <ref> [Bir85a] </ref>. It is generally targeted for the same type of applications as Isis, but adds extensibility and 37 configurability. The composition model in Horus is linear, that is, a system is constructed as a stack of protocols. can be stacked at runtime like Lego tm blocks.
Reference: [Bir85b] <author> A. Birrell. </author> <title> Secure communication using remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 1-14, </pages> <month> Feb </month> <year> 1985. </year>
Reference-contexts: Other issues, although important, are not addressed here. These include stub generation and heterogeneity [Sun88, Gib87, HS87, Apo89, TB90, WSG91], binding [BN84, LT91, BALL90], performance or performance optimizations [PA88, RST89, SB90, BALL90], and security issues <ref> [Bir85b] </ref>. Our design assumes unreliable asynchronous communication and crash failure model. 7.1 Properties of RPC Services The construction of any configurable service starts from identifying the abstract properties of the service, as was described in chapter 3 and illustrated for the membership service in chapter 4.
Reference: [BJ87] <author> K. Birman and T. Joseph. </author> <title> Reliable communication in the presence of failures. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(1) </volume> <pages> 47-76, </pages> <month> Feb </month> <year> 1987. </year>
Reference-contexts: Here, we examine the basic outline of some of these systems, without addressing in detail any of the particular services provided. Since the emphasis is on configurable systems, only two static systems are described: Isis <ref> [Bir85a, BJ87, BC91, BSS91, BR94] </ref> and Mars [KM85, KDK + 89, KG94]. The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. <p> 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those that have fault-tolerance requirements <ref> [Bir85a, BJ87, BC91, BSS91, BR94] </ref>. The toolkit is structured around the concepts of a process group, a group of processes cooperating to implement a service, and virtual synchrony, an abstraction that 34 enables the writing of applications as if the execution of the system was synchronous. <p> The tradeoff is the strength of the guarantee versus the execution cost. For example, the property called virtual synchrony <ref> [BJ87] </ref> guarantees that messages reflecting membership change events are delivered to the application by the membership layer at every site at precisely the same point in the message stream. <p> The service also guarantees agreement on first and last messages, as well as agreement on successors. 4.4.3 Isis The membership service of Isis described in <ref> [BJ87] </ref> consists of a distributed site view management component and an ordered multicast primitive (GBCAST) that is used to multicast and order membership change messages to ensure virtual synchrony. Site failures are detected by sending Hello messages between sites.
Reference: [BJRA85] <author> K. Birman, T. Joseph, T. Raeuchle, and A. Abbadi. </author> <title> Implementing fault-tolerant distributed objects. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(6):502-508, </volume> <month> Jun </month> <year> 1985. </year>
Reference-contexts: This approach is an example of active replication, where every replica executes the same operations. In the primary/backup paradigm, only one of the replicas actively executes client requests <ref> [AD76, BJRA85, BMST92] </ref>, with the state of the other backup replicas being updated periodically. This approach is an example of passive replication. In the object/action paradigm, the system is constructed of passive objects that export actions, i.e., operations, that modify the state of objects [Gra86].
Reference: [Bla91] <author> A. Black. </author> <title> Understanding transactions in an operating system context. </title> <journal> ACM Operating Systems Review, </journal> <volume> 20(1) </volume> <pages> 73-76, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: The properties defined for transactions are another example of abstract properties of a service. A transaction is a collection of operations that is executed as a unit despite concurrency and potential failures during the execution. Typically, transactions have the following four, so-called ACID, properties <ref> [HR83, Bla91] </ref>: * Atomicity or All-or-nothing: Either the transaction completes or it has no effect, despite failures of some of the components involved in the transaction. * Consistency: A transaction takes the database from one consistent state to another. * Isolation: The intermediate states of the data manipulated by a transaction
Reference: [Blo77] <author> M. Blount. </author> <title> Probabilistic treatment of diagnosis in digital systems. </title> <booktitle> In Proceedings of the 7th Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 72 - 77, </pages> <year> 1977. </year>
Reference-contexts: A probabilistically t-diagnosable (p-t-diagnosable) system is defined as one having, for every allowable syndrome, a unique, consistent fault set whose probability of occurrence is greater than p. Assigning a probability of correctness to each test rather than to the subunits themselves is proposed in <ref> [Blo77] </ref>. Procedures are given for determining the probability of correct diagnosis for a particular fault set, and for the entire system. The general problem is to diagnose a system that suffers from intermittent failures and with tests that have imperfect coverage.
Reference: [BM86] <author> B. Bose and J. Metzner. </author> <title> Coding theory for fault-tolerant systems. </title> <editor> In D. Pradham, editor, </editor> <booktitle> Fault-Tolerant Computing: Theory and Techniques, </booktitle> <volume> Volume I, </volume> <pages> pages 265 - 335. </pages> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Error detecting codes are an example of redundancy where additional bits of information are added to data, such as memory, disks, or messages transmitted over a network, to detect errors <ref> [BM86, Toh86] </ref>. Redundancy can be divided into time and space redundancy. Time redundancy is based on using extra execution time, whereas space redundancy is based on using extra physical resources, such as extra memory, processors, disks, or communication links.
Reference: [BMD93] <author> M. Barborak, M. Malek, and A. Dahbura. </author> <title> The consensus problem in fault-tolerant computing. </title> <journal> ACM Computing Survey, </journal> <volume> 25(2) </volume> <pages> 171-220, </pages> <month> Jun </month> <year> 1993. </year>
Reference-contexts: Furthermore, system diagnosis [PMC67], which deals with the problem of detecting faulty processors, is closely related to membership. System diagnosis assumes a failure model where faulty processors can be detected by executing a test program on the processor <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties [RFJ93, GT92, Hil95] to others that guarantee strong properties [BSS91, AMMS + 95, DMS95]. <p> On the basis of the responses, the outcome of the test is classified as pass or fail. In either case, the testing unit evaluates the tested unit as either fault-free or faulty. Numerous papers on system diagnosis have followed <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. Despite the close resemblance of the system diagnosis problem and the membership problem discussed in chapters 4 and 5, little has been done to compare or contrast these two fields. <p> Despite the close resemblance of the system diagnosis problem and the membership problem discussed in chapters 4 and 5, little has been done to compare or contrast these two fields. An important exception is <ref> [BMD93] </ref>, which reviewed the field of system diagnosis thoroughly and compared it to membership. Unfortunately the emphasis was heavily on system diagnosis and the comparison brief. A number of other papers, for example [EL95, KGR91], acknowledge the relationship between these problems but do not explore it any further. <p> Fairly strict assumptions are made about the behavior of faulty subunits: all faults are permanent, a fault-free subunit is always able to determine accurately the condition of a subunit it is testing, and no more than t subunits may be faulty. As noted in <ref> [BMD93] </ref>, these assumptions are not necessarily valid or desired in a fault-tolerant distributed network, and later work has dealt with removing these restrictions. The first problem is supervisor-controlled diagnosis. <p> We make assumptions about how the processors fail (failure model), if the communication is synchronous or asynchronous, and partially dictated by these facts, what kind of fault coverage the tests have and if false detections may occur. In <ref> [BMD93] </ref> the problems of system diagnosis and membership are reviewed and the problems compared. The major difference noted in this paper is that membership algorithms mostly test for failures in the time domain whereas system diagnosis algorithms usually test for failures in the data domain. <p> However, in practical system diagnosis algorithms, such as [BB91, BB93, WHS95], lack of response is considered a failure, i.e., time domain failures are essentially detected as well. The differences between the service guarantees or possible transformations between membership and system diagnosis algorithms were not addressed in <ref> [BMD93] </ref>. 6.3 From System Diagnosis to Membership In this section, we apply the observations above and show how typical distributed system diagnosis algorithms NEW SELF [HKR84], EVENT SELF [BGN90], and Adaptive DSD 144 [BB91] can be transformed into membership algorithms.
Reference: [BMST92] <author> N. Budhiraja, K. Marzullo, F. Schneider, and S. Toueg. </author> <title> Primary-backup protocols: Lower bounds and optimal implementations. </title> <booktitle> In Proceedings of the 3rd IFIP Working Conference on Dependable Computing for Critical Applications, </booktitle> <pages> pages 187-198. </pages> <publisher> Springer-Verlag, Wien, </publisher> <year> 1992. </year>
Reference-contexts: This approach is an example of active replication, where every replica executes the same operations. In the primary/backup paradigm, only one of the replicas actively executes client requests <ref> [AD76, BJRA85, BMST92] </ref>, with the state of the other backup replicas being updated periodically. This approach is an example of passive replication. In the object/action paradigm, the system is constructed of passive objects that export actions, i.e., operations, that modify the state of objects [Gra86].
Reference: [BN84] <author> A. Birrell and B. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> Feb </month> <year> 1984. </year>
Reference-contexts: In particular, the failure model chosen would dictate which failure detection module is used and which information exchange module is used for communication between sites to ensure that the expected failure model cannot corrupt the data that is exchanged. 155 CHAPTER 7 GROUP REMOTE PROCEDURE CALL Remote Procedure Call (RPC) <ref> [BN84, Nel81] </ref> is a communication abstraction designed to simplify the writing of distributed programs. With RPC, a request for service from a client to a server process is structured to give synchronization semantics at the client similar to normal procedure call. <p> To simplify the presentation, we concentrate on RPC features related to distribution and fault tolerance. Other issues, although important, are not addressed here. These include stub generation and heterogeneity [Sun88, Gib87, HS87, Apo89, TB90, WSG91], binding <ref> [BN84, LT91, BALL90] </ref>, performance or performance optimizations [PA88, RST89, SB90, BALL90], and security issues [Bir85b]. <p> This combination of semantics can be realized using micro-protocols RPCMain, SynchronousCall, ReliableCommunication, Acceptance (1), BoundedTer-mination, and Collation (fid), where fid is a function that returns the latest response. 169 It is also easy to configure RPC services that realize the same set of properties as existing services. For example, <ref> [BN84] </ref> corresponds to a service configured with RPC-Main, SynchronousCall, Acceptance (1), Collation (id), ReliableCommunication, and UniqueExecution. Rajdoot [PS88] corresponds to the same set, plus BoundedTermi-nation and TerminateOrphans.
Reference: [BO92] <author> D. Batory and S. O'Malley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology,, </journal> <volume> 1(4) </volume> <pages> 355-398, </pages> <month> Oct </month> <year> 1992. </year>
Reference-contexts: Genesis [BBG + 88] supports fast construction of complex and customized database systems from prefabricated components in libraries. New components can be added to the libraries, making the system extensible. A system is constructed as a hierarchical composition of components in predefined realms <ref> [BO92] </ref>. These realms range from those that define access methods and physical record allocation to those that define data models and their data access languages and query processing components. Realms are typed, with the type system restricting how components can be combined, as follows.
Reference: [BP90a] <author> P. Berman and A. Pelc. </author> <title> Distributed probabilistic fault-diagnosis for multiprocessor systems. </title> <booktitle> In Proceedings of the 20th Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 340 - 346, </pages> <month> Jun </month> <year> 1990. </year>
Reference-contexts: Furthermore, system diagnosis [PMC67], which deals with the problem of detecting faulty processors, is closely related to membership. System diagnosis assumes a failure model where faulty processors can be detected by executing a test program on the processor <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties [RFJ93, GT92, Hil95] to others that guarantee strong properties [BSS91, AMMS + 95, DMS95]. <p> On the basis of the responses, the outcome of the test is classified as pass or fail. In either case, the testing unit evaluates the tested unit as either fault-free or faulty. Numerous papers on system diagnosis have followed <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. Despite the close resemblance of the system diagnosis problem and the membership problem discussed in chapters 4 and 5, little has been done to compare or contrast these two fields. <p> This system model avoids many of the pitfalls of the PMC model, including the need for the complete tests, the permanent nature of faults, off-line testing, and an upper bound on the number of simultaneously faulty subunits. More recent work on probabilistic diagnosis can be found in <ref> [BP90a, BSM89, BP90b, LYS93, Pel93] </ref>. 6.2 Comparison We argue that the major differences between algorithms traditionally viewed as system diagnosis or membership are in the failure model and the strength of the properties provided by the service.
Reference: [BP90b] <author> D. Blough and A. Pelc. </author> <title> Reliable diagnosis and repair in constant-degree multiprocessor systems. </title> <booktitle> In Proceedings of the 20th Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 316 - 323, </pages> <month> Jun </month> <year> 1990. </year> <month> 207 </month>
Reference-contexts: Furthermore, system diagnosis [PMC67], which deals with the problem of detecting faulty processors, is closely related to membership. System diagnosis assumes a failure model where faulty processors can be detected by executing a test program on the processor <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties [RFJ93, GT92, Hil95] to others that guarantee strong properties [BSS91, AMMS + 95, DMS95]. <p> On the basis of the responses, the outcome of the test is classified as pass or fail. In either case, the testing unit evaluates the tested unit as either fault-free or faulty. Numerous papers on system diagnosis have followed <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. Despite the close resemblance of the system diagnosis problem and the membership problem discussed in chapters 4 and 5, little has been done to compare or contrast these two fields. <p> This system model avoids many of the pitfalls of the PMC model, including the need for the complete tests, the permanent nature of faults, off-line testing, and an upper bound on the number of simultaneously faulty subunits. More recent work on probabilistic diagnosis can be found in <ref> [BP90a, BSM89, BP90b, LYS93, Pel93] </ref>. 6.2 Comparison We argue that the major differences between algorithms traditionally viewed as system diagnosis or membership are in the failure model and the strength of the properties provided by the service.
Reference: [BR94] <author> K. Birman and R. van Renesse. </author> <title> Reliable Distributed Computing with the Isis Toolkit. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1994. </year>
Reference-contexts: Here, we examine the basic outline of some of these systems, without addressing in detail any of the particular services provided. Since the emphasis is on configurable systems, only two static systems are described: Isis <ref> [Bir85a, BJ87, BC91, BSS91, BR94] </ref> and Mars [KM85, KDK + 89, KG94]. The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. <p> 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those that have fault-tolerance requirements <ref> [Bir85a, BJ87, BC91, BSS91, BR94] </ref>. The toolkit is structured around the concepts of a process group, a group of processes cooperating to implement a service, and virtual synchrony, an abstraction that 34 enables the writing of applications as if the execution of the system was synchronous.
Reference: [BS91] <author> T. Bihari and K. Schwan. </author> <title> Dynamic adaptation of real-time software. </title> <journal> ACM Transaction on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 143-174, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: An approach 39 resembling the ANSA approach is described in [Bec94]. Here, a separate software layer completely hides the fault-tolerance aspects from applications. 2.1.2.4 Adaptive Parallel Real-time System Configurability and adaptability are explored in the context of reliable parallel and distributed real-time systems in <ref> [BS91, SBB87] </ref>. The goal is to build systems that change their structure, both offline and during operation, to maintain good performance in response to such events as failures and changes in request latencies and utilization. <p> The Transmission Control Protocol (TCP) of the Internet protocol suite uses adaptive mechanisms for flow control, retransmission, and congestion control [Jac88]. Other examples include concurrency control of database transactions [BFHR90], real-time parallel systems <ref> [BS91, SBB87] </ref>, operating systems [MS96], and high-speed communication protocols [SBS93]. Furthermore, as noted above, adaptive systems are important in the area of dependable computing [GGL93]. An example in this area is the SCOP (Self-Configuring Optimistic Programming) scheme [BDGX93], an adaptive version of N-version programming [Avi85].
Reference: [BS95] <author> N. T. Bhatti and R. D. Schlichting. </author> <title> A system for constructing configurable high-level protocols. </title> <booktitle> In Proceedings of SIGCOMM '95, </booktitle> <pages> pages 138-150, </pages> <address> Cambridge, MA, </address> <month> Aug </month> <year> 1995. </year>
Reference-contexts: An initial prototype of the runtime framework has been completed, with a number of micro-protocol suites currently under development. Initial experiments with a group RPC micro-protocol suite show modest execution overhead <ref> [BS95] </ref>. The prototype executes on DecStation 5000/240s connected by a 10 Mbit Ethernet network running the Mach operating system. Details of this implementation can be found in [BS95, Bha96]. 3.4.4 C++ Prototype A prototype of the event-driven execution model has also been implemented using C++. <p> Initial experiments with a group RPC micro-protocol suite show modest execution overhead [BS95]. The prototype executes on DecStation 5000/240s connected by a 10 Mbit Ethernet network running the Mach operating system. Details of this implementation can be found in <ref> [BS95, Bha96] </ref>. 3.4.4 C++ Prototype A prototype of the event-driven execution model has also been implemented using C++.
Reference: [BSM89] <author> D. Blough, G. Sullivan, and G. </author> <title> Masson. Fault diagnosis for sparsely interconnected multiprocessor systems. </title> <booktitle> In Proceedings of the 19th Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 62 - 69, </pages> <month> Jun </month> <year> 1989. </year>
Reference-contexts: This system model avoids many of the pitfalls of the PMC model, including the need for the complete tests, the permanent nature of faults, off-line testing, and an upper bound on the number of simultaneously faulty subunits. More recent work on probabilistic diagnosis can be found in <ref> [BP90a, BSM89, BP90b, LYS93, Pel93] </ref>. 6.2 Comparison We argue that the major differences between algorithms traditionally viewed as system diagnosis or membership are in the failure model and the strength of the properties provided by the service.
Reference: [BSS91] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> Aug </month> <year> 1991. </year>
Reference-contexts: Although reliable communication is essential for building fault-tolerant distributed applications, more powerful services, often called middleware [Ber96], can further simplify the task. For example, an atomic ordered multicast or broadcast service with atomic-ity and message ordering guarantees makes it easy to send messages to a collection of processes <ref> [CM84, CZ85, CASD85, VM90, BSS91] </ref>. Similarly, a membership service provides consistent information about which computers are functioning and which have failed at any given time in a distributed system, thereby simplifying the problems associated with failures [Cri91, Bir85a, EL90, KGR91, MPS92]. <p> Therefore, the corresponding state changes occur in the same order. Other multicast or broadcast services provide different sets of properties. The V-system [CZ85] provides only unreliable multicast. Consul [MPS93a, MPS93b], Isis <ref> [BSS91] </ref>, and Transis [ADKM92b, DM96] provide multicast with the atomicity property and various ordering properties, but no timeliness properties. The Mars system [KO87, KDK + 89] provides atomicity, ordering, and timeliness properties. The existing multicast implementations cover only a small subset of all possible combinations of multicast properties, however. <p> Here, we examine the basic outline of some of these systems, without addressing in detail any of the particular services provided. Since the emphasis is on configurable systems, only two static systems are described: Isis <ref> [Bir85a, BJ87, BC91, BSS91, BR94] </ref> and Mars [KM85, KDK + 89, KG94]. The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. <p> 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those that have fault-tolerance requirements <ref> [Bir85a, BJ87, BC91, BSS91, BR94] </ref>. The toolkit is structured around the concepts of a process group, a group of processes cooperating to implement a service, and virtual synchrony, an abstraction that 34 enables the writing of applications as if the execution of the system was synchronous. <p> The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties [RFJ93, GT92, Hil95] to others that guarantee strong properties <ref> [BSS91, AMMS + 95, DMS95] </ref>. The tradeoff is the strength of the guarantee versus the execution cost. <p> An example of an accurate detection that is not live is that of Mach, where the failed site notifies others about its own failure upon recovery [OIOP93]. Most membership services for asynchronous systems have chosen live but not accurate detection, for example, Isis <ref> [BSS91] </ref> and Consul [MPS93a]. The lack of accuracy in such systems comes from the use of timeouts to suspect the failure of a site, a technique that may trigger false suspicions. <p> the second definition may be more appropriate. 4.2.3.7 Virtual Synchrony Virtual synchrony restricts the delivery order of application and membership change messages in such a way that it appears to the application as if events are occurring synchronously even though they are actually occurring on different sites at different times <ref> [BSS91] </ref>. Virtual synchrony is easy to explain in the ordering graph, as illustrated in Figure 4.10. <p> Furthermore, membership services are not uniform in how they interact with the application. In our approach, a service signals membership changes by forwarding membership change messages to the application in the regular message stream. We call services that follow this approach, including ISIS <ref> [BSS91] </ref>, Consul [MPS92], and Transis [ADKM92a, ADKM92b], delta-based services since they deliver the changes (deltas) to the application. Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs.
Reference: [BSS + 95] <author> B. Bershad, P. Savage, S.and Pardyak, E. Sirer, M. Fiuczynski, D. Becker, C. Chambers, and S. Eggers. </author> <title> Extensibility, safety, and performance in the SPIN operating system. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 267-284, </pages> <address> Copper Mountain Resort, Colorado, </address> <month> Dec </month> <year> 1995. </year>
Reference-contexts: Numerous others, such as Choices [CJK + 87, CIM92], the Kernel Tool Kit (KTK) [GMSS94, MS96], Kea [VH96], and Apertos [Yok92, Yok93, TYT92, IY94], are not addressed here. The SPIN operating system is based on an extensible microkernel <ref> [BCE + 94, BSS + 95] </ref>. The microkernel exports interfaces that offer applications fine-grained control over a few fundamental system abstractions, such as threads and virtual address spaces.
Reference: [BY87] <author> F. Bastani and I. Yen. </author> <title> A fault-tolerant replicated storage system. </title> <booktitle> In Proceedings of the IEEE International Conference on Data Engineering, </booktitle> <pages> pages 449-454, </pages> <address> Los Angeles, CA, </address> <month> Feb </month> <year> 1987. </year>
Reference-contexts: Other important service abstractions are atomic actions, a collection of operations whose execution is indivisible despite concurrency and failures [Lam81, Lis85, SDP89]; and stable storage, storage whose contents is guaranteed to survive failures <ref> [Lam81, BY87] </ref>. Paradigms for structuring fault-tolerant software further simplify developing applications. The replicated state machine approach is a paradigm for building fault-tolerant services using replication [Sch90].
Reference: [CASD85] <author> F. Cristian, H. Aghili, R. Strong, and D. Dolev. </author> <title> Atomic broadcast: From simple message diffusion to Byzantine agreement. </title> <booktitle> In Proceedings of the 15th Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 200-206, </pages> <address> Ann Arbor, MI, </address> <month> Jun </month> <year> 1985. </year>
Reference-contexts: The goal of this research is to simplify the difficult task of writing fault-tolerant distributed applications by providing powerful underlying communication services. A number of these services, such as atomic multicast <ref> [CASD85] </ref>, have been proposed and implemented. Although such services are useful, each provides a fixed set of guarantees even though different applications often have different requirements. <p> This assumption substantially simplifies the problem. The incorrect computation failure model is one where a component, given a correct input, produces an incorrect output [LMJ91]. The timing or performance failure model assumes a component will respond with the correct value, but not necessarily within a given time specification <ref> [CASD85] </ref>. The omission failure model assumes a component may never respond to an input [CASD85]. The crash or fail-silent failure model assumes that the only way a component can fail is by ceasing to operate without making any incorrect state transitions [PSB + 88]. <p> The timing or performance failure model assumes a component will respond with the correct value, but not necessarily within a given time specification <ref> [CASD85] </ref>. The omission failure model assumes a component may never respond to an input [CASD85]. The crash or fail-silent failure model assumes that the only way a component can fail is by ceasing to operate without making any incorrect state transitions [PSB + 88]. <p> Although reliable communication is essential for building fault-tolerant distributed applications, more powerful services, often called middleware [Ber96], can further simplify the task. For example, an atomic ordered multicast or broadcast service with atomic-ity and message ordering guarantees makes it easy to send messages to a collection of processes <ref> [CM84, CZ85, CASD85, VM90, BSS91] </ref>. Similarly, a membership service provides consistent information about which computers are functioning and which have failed at any given time in a distributed system, thereby simplifying the problems associated with failures [Cri91, Bir85a, EL90, KGR91, MPS92]. <p> Properties can be defined in terms of constraints on the service, that is, if a service satisfies the constraints of property p, then we say that it has property p. Properties can be illustrated using the atomic ordered multicast service in <ref> [CASD85] </ref> as an example. <p> Timing Policy: Immediately. Note that the solution is not much cheaper than running negative acks to begin with. One advantage, however, is that it reduces the number of unnecessary nacks and retrans-missions. 8.4.2 Synchronous Atomic Broadcast In <ref> [CASD85] </ref>, a set of broadcast protocols for different failure models is described.
Reference: [CD87] <author> M. Carey and D. DeWitt. </author> <title> An overview of the EXODUS project. </title> <journal> Database Engineering, </journal> <volume> 6, </volume> <year> 1987. </year>
Reference-contexts: Extensible database systems, where the properties or their implementations can be adjusted to specific application requirements and execution 27 environments, have been developed to address some of these needs <ref> [SR86, SCF + 86, CD87, BBG + 88] </ref>. 1.2.4 Meeting Application Requirements Different fault-tolerant distributed applications have different requirements for the underlying services, so they should be able to select which properties are enforced. <p> Although specialized databases have been developed for these different application areas, exploiting configurability is an appealing alternative. Here, we outline two different configurable or extensible database systems. Numerous others, including Postgres [SR86], Starburst [SCF + 86], Exodus <ref> [CD87] </ref>, Gral [Gut89], Ream [KNKH89], and P2 [TB95], are not addressed here. The RAID system [BFHR90] has been used to study adaptive concurrency control.
Reference: [CD94] <author> D. Cheriton and K. Duda. </author> <title> A caching model of operating system kernel functionality. </title> <booktitle> In Proceedings of the 1st USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 179-193, </pages> <month> Nov </month> <year> 1994. </year>
Reference-contexts: In databases, well-known examples include Genesis [BBG + 88] and Raid [BFHR90]. In operating systems, examples of configurable or extensible systems are Synthesis [PMI88], SPIN [BCE + 94], Scout [MMO + 94a], and V++ <ref> [CD94] </ref>. Also, in file systems, configura-bility has been used to enable new application types, such as databases and multimedia, to make use of file systems efficiently for their storage needs [HP94, KN93, Maf94]. <p> The traditional operating system services are provided in an application-level library. The V++ operating system is based on the abstraction of a cache <ref> [CD94] </ref>. Unlike conventional operating systems, where a cache is used to store memory data, the abstraction is extended in V++ to store operating system objects, such as threads and address spaces.
Reference: [CDD90] <author> F. Cristian, B. Dancey, and J. Dehn. </author> <title> Fault-tolerance in the Advanced Automation System. </title> <booktitle> In Proceedings of the 20th Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 6-17, </pages> <address> Newcastle-upon-Tyne, UK, </address> <month> Jun </month> <year> 1990. </year> <month> 208 </month>
Reference-contexts: Therefore, goals are usually set for reliability and availability that depend on the purpose of a system. For example, for the design of the AAS (Advanced Automation System) air-traffic control system, the availability goal of critical components was established at no more than 3 seconds of down-time a year <ref> [CDD90] </ref>. For telephone switching systems, the availability goal is 99.4%, which translates to 3 minutes of system down-time a year, and the reliability goal is to sustain at least 99.9875% of all established calls, which translates to inadvertently disconnecting no more than 1.25 calls out of 10,000 [Kec91]. <p> A distributed architecture by itself is, of course, only a starting point; fault-tolerance techniques need to be applied so that the application can continue operating despite the failures. An example of the use of distributed architecture for fault tolerance is the previously mentioned AAS air-traffic control system <ref> [CDD90] </ref>; the high availability goals are to be met by replicating critical applications on 3 or 4 computers structured as a distributed system. 1.2 Building Fault-Tolerant Distributed Software Although fault tolerance is important, constructing distributed fault-tolerant software is hard.
Reference: [CFL94] <author> P. Cao, E. Felten, and K. Li. </author> <title> Implementation and performance of application-controlled file caching. </title> <booktitle> In Proceedings of the 1st USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 165-178, </pages> <month> Nov </month> <year> 1994. </year>
Reference-contexts: The work has also been extended to support construction of configurable network daemons [SS94]. 2.2.2 Operating Systems Several research projects in the area of operating systems are based on the premise that traditional operating system structuring limits the performance, flexibility, and functionality of applications. For example, <ref> [CFL94] </ref> demonstrates that application-level control of file cashing reduces application running time by 45%. Similarly, application-specific virtual memory policies increase application performance [HC92, KLVA93], while exception handling is an order of magnitude faster if the signal handling is deferred to applications [TL94].
Reference: [CGR88] <author> R. Cmelik, N. Gehani, and W. Roome. </author> <title> Fault Tolerant Concurrent C: A tool for writing fault tolerant distributed programs. </title> <booktitle> In Proceedings of the 18th Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 55-61, </pages> <address> Tokyo, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: Group RPC has numerous applications. For example, it can be used to implement replicated servers to increase availability of the service in the event of failures, to implement parallel computation, or to improve response time. Examples of group or multicast RPC include <ref> [CGR88, Coo85, WZZ93, YJT88] </ref>. Here, we consider only one-to-many group RPC, in which one client uses RPC to invoke a procedure implemented by a server group.
Reference: [CIM92] <author> R. Campbell, N. Islam, and P. Madany. </author> <title> Choices, frameworks and refinements. </title> <journal> Computing Systems, </journal> <volume> 5(3) </volume> <pages> 217-257, </pages> <year> 1992. </year>
Reference-contexts: Recently, the work on configurable operating systems has concentrated on adjusting the operating system abstractions to fit the specific needs of application [CL95]. In the following, we take a closer look at a number of these projects. Numerous others, such as Choices <ref> [CJK + 87, CIM92] </ref>, the Kernel Tool Kit (KTK) [GMSS94, MS96], Kea [VH96], and Apertos [Yok92, Yok93, TYT92, IY94], are not addressed here. The SPIN operating system is based on an extensible microkernel [BCE + 94, BSS + 95].
Reference: [CJK + 87] <author> R. Campbell, G. Johnston, K. Kenny, G. Murakami, and V. Russo. </author> <title> Choices (Class Hierarchical Open Interface for Custom Embedded Systems). </title> <booktitle> In Proceedings of the 4th Workshop on Real-Time Operating Systems, </booktitle> <pages> pages 12-18, </pages> <month> Jul </month> <year> 1987. </year>
Reference-contexts: Recently, the work on configurable operating systems has concentrated on adjusting the operating system abstractions to fit the specific needs of application [CL95]. In the following, we take a closer look at a number of these projects. Numerous others, such as Choices <ref> [CJK + 87, CIM92] </ref>, the Kernel Tool Kit (KTK) [GMSS94, MS96], Kea [VH96], and Apertos [Yok92, Yok93, TYT92, IY94], are not addressed here. The SPIN operating system is based on an extensible microkernel [BCE + 94, BSS + 95].
Reference: [CL95] <author> W. Cheung and A. Loong. </author> <title> Exploring issues of operating systems structuring: from microkernels to extensible systems. </title> <journal> Operating Systems Review, </journal> <volume> 29(4) </volume> <pages> 4-16, </pages> <month> Oct </month> <year> 1995. </year>
Reference-contexts: Synthesis, therefore, is an example of adjusting or configuring the implementation to improve performance without modifications to the high-level operating system abstractions provided for the applications. Recently, the work on configurable operating systems has concentrated on adjusting the operating system abstractions to fit the specific needs of application <ref> [CL95] </ref>. In the following, we take a closer look at a number of these projects. Numerous others, such as Choices [CJK + 87, CIM92], the Kernel Tool Kit (KTK) [GMSS94, MS96], Kea [VH96], and Apertos [Yok92, Yok93, TYT92, IY94], are not addressed here.
Reference: [CM84] <author> J. Chang and N. Maxemchuk. </author> <title> Reliable broadcast protocols. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 251-273, </pages> <month> Aug </month> <year> 1984. </year>
Reference-contexts: Although reliable communication is essential for building fault-tolerant distributed applications, more powerful services, often called middleware [Ber96], can further simplify the task. For example, an atomic ordered multicast or broadcast service with atomic-ity and message ordering guarantees makes it easy to send messages to a collection of processes <ref> [CM84, CZ85, CASD85, VM90, BSS91] </ref>. Similarly, a membership service provides consistent information about which computers are functioning and which have failed at any given time in a distributed system, thereby simplifying the problems associated with failures [Cri91, Bir85a, EL90, KGR91, MPS92]. <p> Schemes based on logical rings or token passing are used by many multicast, membership, and system diagnosis protocols. For example, token passing is used as a means of implementing reliable totally ordered multicast in the Reliable Broadcast Protocol <ref> [CM84] </ref>, Token-Passing Multicast (TPM) protocol [RM89], Multicasting Transport Protocol (MTP) [AFM92], Totem [AMMS + 95], Pinwheel [CM95], and Reliable Multicast Protocol (RMP) [WMK95].
Reference: [CM95] <author> F. Cristian and S. Mishra. </author> <title> The Pinwheel asynchronous atomic broadcast protocols. </title> <booktitle> In Proceedings of the 2nd International Symposium on Autonomous Decentralized Systems, </booktitle> <pages> pages 215-221, </pages> <address> Phoenix, AZ, </address> <year> 1995. </year>
Reference-contexts: For example, token passing is used as a means of implementing reliable totally ordered multicast in the Reliable Broadcast Protocol [CM84], Token-Passing Multicast (TPM) protocol [RM89], Multicasting Transport Protocol (MTP) [AFM92], Totem [AMMS + 95], Pinwheel <ref> [CM95] </ref>, and Reliable Multicast Protocol (RMP) [WMK95]. In these protocols, the site possessing the token is either the only site that is allowed to send a message or the site that assigns a global ordering to messages sent by all sites.
Reference: [Coo85] <author> E. Cooper. </author> <title> Replicated distributed programs. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-78, </pages> <address> Orcas Island, WA, </address> <year> 1985. </year>
Reference-contexts: Group RPC has numerous applications. For example, it can be used to implement replicated servers to increase availability of the service in the event of failures, to implement parallel computation, or to improve response time. Examples of group or multicast RPC include <ref> [CGR88, Coo85, WZZ93, YJT88] </ref>. Here, we consider only one-to-many group RPC, in which one client uses RPC to invoke a procedure implemented by a server group. <p> For example, [BN84] corresponds to a service configured with RPC-Main, SynchronousCall, Acceptance (1), Collation (id), ReliableCommunication, and UniqueExecution. Rajdoot [PS88] corresponds to the same set, plus BoundedTermi-nation and TerminateOrphans. Among group RPC services, the one-to-many RPC described in <ref> [Coo85] </ref> corresponds to the set RPCMain, SynchronousCall, Acceptance (N), Collation with a function consisting of identity and comparison to detect inconsistencies at the server processes, ReliableCommunication, UniqueExecution, and TotalOrder. As an example of a very simple group RPC, lookup RPC [WZZ93] corresponds to RPCMain, SynchronousCall, Acceptance (1), and Collation (fid).
Reference: [Cri91] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 175-187, </pages> <year> 1991. </year>
Reference-contexts: Similarly, a membership service provides consistent information about which computers are functioning and which have failed at any given time in a distributed system, thereby simplifying the problems associated with failures <ref> [Cri91, Bir85a, EL90, KGR91, MPS92] </ref>. <p> Membership services have proven to be fundamental for constructing systems and applications. The existing work can be classified based on the assumptions about the system model. In particular, some membership services assume a synchronous system where bounds are placed on network transmission time <ref> [Cri91, KGR91, KG94, EL90, LE90, SCA94] </ref>, whereas other assume an asynchronous system where no such assumption is made [MSMA94, MAMSA94, DMS94, DMS95, EL95, AMMS + 93, MPS93a, RB91, SR93, ADKM92a, GT92, RFJ93, Bir85a, SM94, BDM95, CS95]. Distinctions can also be made based on the failure model. <p> However, live detection is necessary but not sufficient to guarantee live service. For example, the membership protocol in Isis [RB91] that uses live detection based on timeouts has been shown not to be live in all situations [ACBMT95]. In synchronous systems, membership services are typically accurate and live <ref> [Cri91, KGR91] </ref>. In membership services in which change detection is inaccurate, the level of confidence indicates how certain it is that the suspected change has actually occurred. The typical way to increase confidence is to compare information from different sites before making a final decision. <p> by guaranteeing that all sites share the same view of the membership or are knowingly in a transition state. 4.2.4.2 Timebound Synchrony Timebound synchrony is a property of membership services in synchronous systems in which every site delivers a given membership change message within some known interval of real time <ref> [KGR91, Cri91] </ref>. The property has the same general applicability as external synchrony, but reduces the synchronization overhead by shrinking the window during which the membership is not identical on all sites. <p> Partitions may be caused by disconnection of the underlying network or by problems such as network congestion or an overloaded gateway processor. A number of different approaches are used in membership services to deal with partitions. One common approach is simply to assume they will not occur <ref> [Cri91, KGR91, MPS92] </ref>. This can be justified by increasing the connectivity of the network or by using other architectural assumptions. If this assumption is not valid, there are a number of ways to deal with multiple partitions [AMMS + 95, DMS94, DMS95, MAMSA94, RFJ93, RB91, SM94]. <p> Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs. We call services that follow this approach, including <ref> [Cri91, AMMS + 93, RFJ93, SR93] </ref>, set-based services. Although properties for the two types of services are typically stated differently, mappings between them can usually be constructed in a straightforward manner. <p> Isis deals with partitions by allowing computation to continue in at most one partition, an approach supported by the majority status property described in section 4.2.6.3. 4.4.4 Cristian's Synchronous Membership Protocols In <ref> [Cri91] </ref>, Cristian presents three group membership protocols built on the assumption that the underlying system provides synchronous reliable atomic broadcast primitives. The protocols handle faulty sites leaving the membership and fault-free or repaired processors joining. <p> Another protocol, the attendance list protocol, reduces message overhead in the absence of joins and failures by circulating an attendance list through all sites once per period instead of using Present messages. The protocols proposed by Cristian guarantee a number of properties. In the terminology of <ref> [Cri91] </ref>, these include the following: * Agreement on group membership: Any two sites in the same group have identical membership views. 107 * Reflexivity: A site that has joined the group belongs to the membership (excludes the trivial solution of an empty membership list). * Bounded join delay: The time for <p> This micro-protocol is distinct from ExtendedVirtualSynchrony since the predecessor sets of such messages are different in the sites in the two merging partitions. Other partition handling micro-protocols. In numerous membership services <ref> [Cri91, HS95, KT91, KGR91, MSMA94, MPS93a, RB91] </ref>, it is simply assumed that partitions will not occur, or that only one partition will continue to operate. The OnePartition micro-protocol implements a simple strategy that approximates this behavior. <p> Some of the work has been based on a synchronous system model, where bounds are placed on the network transmission time <ref> [Cri91, EL90, KGR91, LE90, SCA94] </ref>. Other work assumes an asynchronous model similar to that used in this chapter [ADKM92a, AMMS + 95, DMS94, EL95, GT92, MPS92, MPS93a, MAMSA94, RB91, SM94].
Reference: [Cri96] <author> F. Cristian. </author> <title> Synchronous and asynchronous group communication. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 88-97, </pages> <month> Apr </month> <year> 1996. </year>
Reference-contexts: Naturally, issues such as synchronization and priority inversion have to be addressed. Related to timeliness are issues about the system model, such as whether the system is synchronous, asynchronous, or something in between, such as timed-asynchronous <ref> [Cri96] </ref>. The work on adaptive systems presented in chapter 8 is just a beginning. The general model and the implementation using the event-driven approach appear promising, but we have to apply the ideas to real implementations to gain a better understanding of the performance tradeoffs.
Reference: [CS95] <author> F. Cristian and F. Schmuck. </author> <title> Agreeing on processor group membership in asynchronous distributed systems. </title> <type> Technical Report CSE95-428, </type> <institution> University of California, </institution> <address> San Diego, </address> <year> 1995. </year>
Reference: [CT91] <author> T. Chandra and S. Toueg. </author> <title> Unreliable failure detectors for asynchronous systems. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 325-340, </pages> <month> Aug </month> <year> 1991. </year> <month> 209 </month>
Reference-contexts: The change detection phase can be live, accurate, or both depending on the system model and the algorithm used. In asynchronous systems, it is impossible to have change detection that is both live and accurate <ref> [CT91, FLP85] </ref>. An example of an accurate detection that is not live is that of Mach, where the failed site notifies others about its own failure upon recovery [OIOP93]. Most membership services for asynchronous systems have chosen live but not accurate detection, for example, Isis [BSS91] and Consul [MPS93a].
Reference: [CZ85] <author> D. Cheriton and W. Zwaenepoel. </author> <title> Distributed process groups in the V kernel. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 77-107, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: Although reliable communication is essential for building fault-tolerant distributed applications, more powerful services, often called middleware [Ber96], can further simplify the task. For example, an atomic ordered multicast or broadcast service with atomic-ity and message ordering guarantees makes it easy to send messages to a collection of processes <ref> [CM84, CZ85, CASD85, VM90, BSS91] </ref>. Similarly, a membership service provides consistent information about which computers are functioning and which have failed at any given time in a distributed system, thereby simplifying the problems associated with failures [Cri91, Bir85a, EL90, KGR91, MPS92]. <p> Finally, if two or more nodes send a multicast at approximately the same time, these messages will be delivered in the same order on all nodes. Therefore, the corresponding state changes occur in the same order. Other multicast or broadcast services provide different sets of properties. The V-system <ref> [CZ85] </ref> provides only unreliable multicast. Consul [MPS93a, MPS93b], Isis [BSS91], and Transis [ADKM92b, DM96] provide multicast with the atomicity property and various ordering properties, but no timeliness properties. The Mars system [KO87, KDK + 89] provides atomicity, ordering, and timeliness properties. <p> KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel <ref> [CZ85] </ref>. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those that have fault-tolerance requirements [Bir85a, BJ87, BC91, BSS91, BR94].
Reference: [DFF + 90] <author> Y. Deswarte, J.-C. Fabre, J.-M. Fray, D. Powell, and P.-G. Ranea. Saturne: </author> <title> A distributed computing system which tolerates faults and intrusions. </title> <booktitle> In Proceedings of the Workshop on Future Trends of Distributed Computing Systems, </booktitle> <pages> pages 329-338, </pages> <address> Hong Kong, </address> <month> Sep </month> <year> 1990. </year>
Reference-contexts: A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne <ref> [DFF + 90] </ref>, Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those that have fault-tolerance requirements [Bir85a, BJ87, BC91, BSS91,
Reference: [DHW88] <author> D. Detlefs, M. Herlihy, and J. Wing. </author> <title> Inheritance of synchronization and recovery properties in Avalon/c++. </title> <journal> IEEE Computer, </journal> <volume> 21(12) </volume> <pages> 57-69, </pages> <month> Dec </month> <year> 1988. </year>
Reference-contexts: The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon <ref> [DHW88] </ref>, Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit
Reference: [Dij68] <author> E. W. Dijkstra. </author> <title> The structure of the THE multiprogramming system. </title> <journal> Communications of the ACM, </journal> <volume> 11(5) </volume> <pages> 341-346, </pages> <month> May </month> <year> 1968. </year>
Reference-contexts: This approach has been used frequently in operating systems, where the layers range from hardware to the user interface. For example, the THE operating system was designed with six layers: hardware, CPU scheduling, memory management, operator console device driver, buffering for I/O, and 24 user programs <ref> [Dij68] </ref>. This approach also has a traditional role in communication systems. For example, the seven layer ISO OSI model consists of physical, data link, network, transport, session, presentation, and application layers [DZ83].
Reference: [DLA88] <author> P. Dasgupta, R. LeBlanc, and W. Appelbe. </author> <title> The Clouds distributed operating system: Functional description, implementation details and related work. </title> <booktitle> In Proceedings of the 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 2-9, </pages> <month> Jun </month> <year> 1988. </year>
Reference-contexts: The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds <ref> [DLA88, DLAR91] </ref>, Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed
Reference: [DLAR91] <author> P. Dasgupta, R. LeBlanc, M. Ahamad, and U. Ramachandran. </author> <title> The Clouds distributed operating system. </title> <journal> IEEE Computer, </journal> <volume> 24(11) </volume> <pages> 34-44, </pages> <month> Nov </month> <year> 1991. </year>
Reference-contexts: The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds <ref> [DLA88, DLAR91] </ref>, Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed
Reference: [DM96] <author> D. Dolev and D. Malki. </author> <title> The Transis approach to high availability cluster communication. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 64-70, </pages> <month> Apr </month> <year> 1996. </year>
Reference-contexts: Therefore, the corresponding state changes occur in the same order. Other multicast or broadcast services provide different sets of properties. The V-system [CZ85] provides only unreliable multicast. Consul [MPS93a, MPS93b], Isis [BSS91], and Transis <ref> [ADKM92b, DM96] </ref> provide multicast with the atomicity property and various ordering properties, but no timeliness properties. The Mars system [KO87, KDK + 89] provides atomicity, ordering, and timeliness properties. The existing multicast implementations cover only a small subset of all possible combinations of multicast properties, however.
Reference: [DMS94] <author> D. Dolev, D. Malki, and R. </author> <title> Strong. An asynchronous membership protocol that tolerates partitions. </title> <type> Technical Report CS94-6, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, </institution> <month> Mar </month> <year> 1994. </year>
Reference-contexts: One common approach is simply to assume they will not occur [Cri91, KGR91, MPS92]. This can be justified by increasing the connectivity of the network or by using other architectural assumptions. If this assumption is not valid, there are a number of ways to deal with multiple partitions <ref> [AMMS + 95, DMS94, DMS95, MAMSA94, RFJ93, RB91, SM94] </ref>.
Reference: [DMS95] <author> D. Dolev, D. Malki, and R. </author> <title> Strong. A framework for partitionable membership service. </title> <type> Technical Report CS95-4, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, </institution> <year> 1995. </year>
Reference-contexts: The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties [RFJ93, GT92, Hil95] to others that guarantee strong properties <ref> [BSS91, AMMS + 95, DMS95] </ref>. The tradeoff is the strength of the guarantee versus the execution cost. <p> One common approach is simply to assume they will not occur [Cri91, KGR91, MPS92]. This can be justified by increasing the connectivity of the network or by using other architectural assumptions. If this assumption is not valid, there are a number of ways to deal with multiple partitions <ref> [AMMS + 95, DMS94, DMS95, MAMSA94, RFJ93, RB91, SM94] </ref>.
Reference: [DSK87] <author> A. Dahbura, K. Sabnani, and L. King. </author> <title> The comparison approach to multiprocessor fault diagnosis. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(3):373 - 378, </volume> <month> Mar </month> <year> 1987. </year>
Reference-contexts: The general problem is to diagnose a system that suffers from intermittent failures and with tests that have imperfect coverage. The problem using probabilistic diagnosis under the comparison approach is first studied in <ref> [DSK87] </ref>. This system model avoids many of the pitfalls of the PMC model, including the need for the complete tests, the permanent nature of faults, off-line testing, and an upper bound on the number of simultaneously faulty subunits.
Reference: [DZ83] <author> J. Day and H. Zimmermann. </author> <title> The OSI reference model. </title> <booktitle> In Proceedings of the IEEE, </booktitle> <volume> volume 71, </volume> <pages> pages 1334-1340, </pages> <month> Dec </month> <year> 1983. </year>
Reference-contexts: This approach also has a traditional role in communication systems. For example, the seven layer ISO OSI model consists of physical, data link, network, transport, session, presentation, and application layers <ref> [DZ83] </ref>. In the layered approach, each layer provides a service to the layer above it using one or more protocols to implement the service. A service is defined by the set of operations that the layer supports, while a protocol defines one implementation of the service. <p> Communication software has typically been viewed as consisting of logical layers, each of which builds on the layers below and adds functionality or properties to the service. An example of this view is the ISO OSI model <ref> [DZ83] </ref>, which, although just a specification, is a good example of modular design of such services. In this model, lower levels are typically implemented in hardware, while higher levels are implemented in one or more software modules.
Reference: [EKO94a] <author> D. Engler, M. Kaashoek, and J. O'Toole. </author> <title> The exokernel approach to extensibility. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> page 198, </pages> <month> Nov </month> <year> 1994. </year> <month> 210 </month>
Reference-contexts: The Exokernel operating system architecture takes the approach of moving the physical resource management to the application level, thereby making it easy for each application to modify the resource management to best satisfy its requirements <ref> [EKO94a, EKO94b, EKO95] </ref>. The design of Exokernel is based on the argument that abstraction overhead is the root of inefficiency in most modern operating systems. Therefore, its goal is to eliminate all abstractions from an operating system and allow applications to craft their own.
Reference: [EKO94b] <author> D. Engler, M. Kaashoek, and J. O'Toole. </author> <title> The operating system kernel as a secure programmable machine. </title> <booktitle> In Proceedings of the 6th SIGOPS European Workshop, </booktitle> <year> 1994. </year>
Reference-contexts: The Exokernel operating system architecture takes the approach of moving the physical resource management to the application level, thereby making it easy for each application to modify the resource management to best satisfy its requirements <ref> [EKO94a, EKO94b, EKO95] </ref>. The design of Exokernel is based on the argument that abstraction overhead is the root of inefficiency in most modern operating systems. Therefore, its goal is to eliminate all abstractions from an operating system and allow applications to craft their own.
Reference: [EKO95] <author> D. Engler, M. Kaashoek, and J. O'Toole. Exokernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 251-266, </pages> <address> Copper Mountain Resort, Colorado, </address> <month> Dec </month> <year> 1995. </year>
Reference-contexts: The Exokernel operating system architecture takes the approach of moving the physical resource management to the application level, thereby making it easy for each application to modify the resource management to best satisfy its requirements <ref> [EKO94a, EKO94b, EKO95] </ref>. The design of Exokernel is based on the argument that abstraction overhead is the root of inefficiency in most modern operating systems. Therefore, its goal is to eliminate all abstractions from an operating system and allow applications to craft their own.
Reference: [EL90] <author> P. Ezhilchelvan and R. Lemos. </author> <title> A robust group membership algorithm for distributed real-time system. </title> <booktitle> In Proceedings of the 11th Real-Time Systems Symposium, </booktitle> <pages> pages 173-179, </pages> <address> Lake Buena Vista, Florida, </address> <month> Dec </month> <year> 1990. </year>
Reference-contexts: Similarly, a membership service provides consistent information about which computers are functioning and which have failed at any given time in a distributed system, thereby simplifying the problems associated with failures <ref> [Cri91, Bir85a, EL90, KGR91, MPS92] </ref>. <p> Membership services have proven to be fundamental for constructing systems and applications. The existing work can be classified based on the assumptions about the system model. In particular, some membership services assume a synchronous system where bounds are placed on network transmission time <ref> [Cri91, KGR91, KG94, EL90, LE90, SCA94] </ref>, whereas other assume an asynchronous system where no such assumption is made [MSMA94, MAMSA94, DMS94, DMS95, EL95, AMMS + 93, MPS93a, RB91, SR93, ADKM92a, GT92, RFJ93, Bir85a, SM94, BDM95, CS95]. Distinctions can also be made based on the failure model. <p> Some of the work has been based on a synchronous system model, where bounds are placed on the network transmission time <ref> [Cri91, EL90, KGR91, LE90, SCA94] </ref>. Other work assumes an asynchronous model similar to that used in this chapter [ADKM92a, AMMS + 95, DMS94, EL95, GT92, MPS92, MPS93a, MAMSA94, RB91, SM94].
Reference: [EL95] <author> K. Echtle and M. Leu. </author> <title> Fault-detecting network membership protocols for unknown topologies. </title> <editor> In F. Cristian, G. Le Lann, and T. Lunt, editors, </editor> <booktitle> Dependable Computing for Critical Applications 4, </booktitle> <pages> pages 69-90. </pages> <publisher> Springer-Verlag, Wien, </publisher> <year> 1995. </year>
Reference-contexts: An important exception is [BMD93], which reviewed the field of system diagnosis thoroughly and compared it to membership. Unfortunately the emphasis was heavily on system diagnosis and the comparison brief. A number of other papers, for example <ref> [EL95, KGR91] </ref>, acknowledge the relationship between these problems but do not explore it any further. In this chapter, we introduce system diagnosis, contrast it with the membership problem, and show that they can be viewed as essentially the same problem with slightly different assumptions.
Reference: [FLP85] <author> M. Fischer, N. Lynch, and M. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> Apr </month> <year> 1985. </year>
Reference-contexts: The change detection phase can be live, accurate, or both depending on the system model and the algorithm used. In asynchronous systems, it is impossible to have change detection that is both live and accurate <ref> [CT91, FLP85] </ref>. An example of an accurate detection that is not live is that of Mach, where the failed site notifies others about its own failure upon recovery [OIOP93]. Most membership services for asynchronous systems have chosen live but not accurate detection, for example, Isis [BSS91] and Consul [MPS93a]. <p> As a result, Step 2 guarantees that all operational sites have the same values in their value vectors. Thus, if all sites use the same deterministic function to calculate the result, consensus will be reached. However, reaching consensus conflicts with the impossibility result presented in <ref> [FLP85] </ref>, which implies that the original assumption about having failure detection that is both live and accurate must be false. 2 Theorem: 7 Collective join and asymmetric join conflict. Proof: In this case, the conflict is due to having mutually contradictory choices for dealing with a situation.
Reference: [Fon94] <author> H. Fonseca. </author> <title> Support environments for the modularization, implementation, and execution of communication protocols. </title> <type> Master's thesis, </type> <institution> Instituto Superior Tecnico, Lisboa, Portugal, </institution> <month> Jun </month> <year> 1994. </year> <note> In Portuguese. </note>
Reference-contexts: Similar problems were encountered in a project attempting a modular implementation of the xAMP atomic broadcast protocol suite in the x-kernel <ref> [RV92, Fon94] </ref>. 2.1.2.2 Horus Horus [RHB95, RBG + 95, RB95, RBM96] is a successor to the Isis system [Bir85a]. It is generally targeted for the same type of applications as Isis, but adds extensibility and 37 configurability.
Reference: [GBB + 95] <author> D. O. Guedes, D. E. Bakken, N. T. Bhatti, M. A. Hiltunen, and R. D. Schlichting. </author> <title> A customized communication subsystem for FT-Linda. </title> <booktitle> In Proceedings of the 13th Brazilian Symposium on Computer Networks, </booktitle> <pages> pages 319-338, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Although our approach has been successfully applied to membership and RPC services, the work could be expanded to many other interesting fault-tolerant services. For example, 191 the work on multicast services in <ref> [HS93, GBB + 95] </ref> could be expanded. In particular, the properties of multicast services can be specified using message ordering graphs as done in chapter 4 for membership services.
Reference: [GGL93] <author> J. Goldberg, I. Greenberg, and T. Lawrence. </author> <title> Adaptive fault tolerance. </title> <booktitle> In Proceedings of the IEEE Workshop on Advances in Parallel and Distributed Systems, </booktitle> <pages> pages 127-132, </pages> <address> Princeton, NJ, </address> <month> Oct </month> <year> 1993. </year>
Reference-contexts: Other examples include concurrency control of database transactions [BFHR90], real-time parallel systems [BS91, SBB87], operating systems [MS96], and high-speed communication protocols [SBS93]. Furthermore, as noted above, adaptive systems are important in the area of dependable computing <ref> [GGL93] </ref>. An example in this area is the SCOP (Self-Configuring Optimistic Programming) scheme [BDGX93], an adaptive version of N-version programming [Avi85]. In this scheme, multiple alternative algorithms are executed, with the actual number of alternatives used being determined at runtime based on the level of confidence desired.
Reference: [Gib87] <author> P. Gibbons. </author> <title> A stub generator for multilanguage RPC in heterogeneous environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(1) </volume> <pages> 77-87, </pages> <month> Jan </month> <year> 1987. </year>
Reference-contexts: In this chapter, we apply our approach of constructing configurable fault-tolerant distributed services to group RPC. To simplify the presentation, we concentrate on RPC features related to distribution and fault tolerance. Other issues, although important, are not addressed here. These include stub generation and heterogeneity <ref> [Sun88, Gib87, HS87, Apo89, TB90, WSG91] </ref>, binding [BN84, LT91, BALL90], performance or performance optimizations [PA88, RST89, SB90, BALL90], and security issues [Bir85b].
Reference: [GJS92] <author> N. Gehani, H. Jagadish, and O. Shumeli. </author> <title> Event specification in an active object-oriented database. </title> <booktitle> In Proceedings of the 19th ACM SIGMOD Conference on the Management of Data, </booktitle> <address> San Diego, CA, </address> <month> Jun </month> <year> 1992. </year> <month> 211 </month>
Reference-contexts: For example, an x-kernel protocol can be seen as an event-driven entity with handlers for events such as push, pop, open, and close. Recent work also includes event services <ref> [GJS92, SB95, MSS96] </ref>, event-based programming [Ous96], and an event-based structuring approach where an application is constructed by customizing a standard framework with user-supplied handlers [Lew96].
Reference: [GMSS94] <author> A. Gheith, B. Mukherjee, D. Silva, and K. Schwan. KTK: </author> <title> Kernel support for configurable objects and invocations. </title> <booktitle> In Proceedings of the 2nd International Workshop on Configurable Distributed Systems, </booktitle> <pages> pages 92-103, </pages> <address> Pittsburgh, PE, </address> <year> 1994. </year>
Reference-contexts: In the following, we take a closer look at a number of these projects. Numerous others, such as Choices [CJK + 87, CIM92], the Kernel Tool Kit (KTK) <ref> [GMSS94, MS96] </ref>, Kea [VH96], and Apertos [Yok92, Yok93, TYT92, IY94], are not addressed here. The SPIN operating system is based on an extensible microkernel [BCE + 94, BSS + 95].
Reference: [Gol92] <author> R. Golding. </author> <title> Weak-Consistency Group Communication and Membership. </title> <type> PhD thesis, </type> <institution> Dept of Computer Science, University of California, </institution> <address> Santa Cruz, Santa Cruz, CA, </address> <month> Dec </month> <year> 1992. </year>
Reference-contexts: Finally, although the communication between objects is reconfigurable, only existing communication can be redirected and it can only be directed to one object unless extra multicast type objects are added. 2.1.2.5 Group Communication Framework A modular framework for group communication systems is proposed in <ref> [Gol92] </ref>. The framework has four fixed components: application, message delivery, message ordering, 40 and group membership. Each component may have different implementations. For example, different ordering components can implement different variations, such as unordered, FIFO, causal, and total order. <p> This component also processes outgoing messages so that the matching components of other members have enough information to order messages properly. The framework components and their interactions are illustrated in Figure 2.3. Two applications of the framework are also presented in <ref> [Gol92] </ref>: a bibliographic database (Refdbms) and a distributed host reliability monitor (Tattler). These applications have different requirements for reliability and ordering of communication. All elements of the general framework are not explicitly present in all implementations. <p> The interactions between functions, including who interacts with whom and the type of the interaction, are typically hardwired in the backplane. Examples of this approach are Adaptive, RAID, the group communication framework <ref> [Gol92] </ref>, and most of the configurable operating systems. A good example of this approach is the concurrency control function in RAID, which can be implemented using different predefined or user-implemented modules.
Reference: [Gra86] <author> J. Gray. </author> <title> An approach to decentralized computer systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(6):684-692, </volume> <month> Jun </month> <year> 1986. </year>
Reference-contexts: This approach is an example of passive replication. In the object/action paradigm, the system is constructed of passive objects that export actions, i.e., operations, that modify the state of objects <ref> [Gra86] </ref>. Applications of this approach to reliable computing are discussed in [Whe89]. In all these paradigms, communication-oriented services such as multicast and membership are key components of the supporting infrastructure. 1.2.3 Properties of Services Existing services can be characterized by the execution guarantees, or properties, they provide to their users. <p> Therefore, it appears that the group communication framework is more of a conceptual framework than an actual implementation framework. 41 2.1.2.6 Arjuna The Arjuna system provides tools for constructing reliable distributed object-oriented applications [SDP91]. Arjuna is based on the object/action paradigm <ref> [Gra86] </ref>, where applications are structured as atomic actions operating on persistent objects, i.e., objects that survive site crashes. Arjuna is implemented using C++, and uses the inheritance mechanism provided by the language extensively.
Reference: [GT91] <author> A. Gopal and S. Toueg. </author> <title> Inconsistency and contamination. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 257-272, </pages> <year> 1991. </year>
Reference-contexts: This can cause one or more sites to enter an inconsistent state relative to other sites, and raises the possibility of system contamination should a site in an inconsistent state send a message <ref> [GT91] </ref>. Adaptivity can be used to address such a scenario and increase the overall dependability by allowing the system to continue providing message ordering despite the change in the environment. <p> Similarly, to deal with loss of k-connectivity, the system can change to using a reliability protocol for asynchronous networks, such as the use of negative acknowledgments. Detection of such changes can be implemented using a scheme similar to the one presented in <ref> [GT91] </ref>. Assume the sender of a message, say site p, includes the sequence of messages delivered to the user at site p, DEL p , in the header of each message sent. 183 Now, a site q that receives this message can check its DEL q against DEL p . <p> If this is not the case, the total order must have been violated. This basic idea can be optimized to cut down the overhead on each message either by using the approach taken in <ref> [GT91] </ref> of sending message counts instead of the complete history, or by using the fact that stable messagesthat is, messages received by every sitecan be removed from the message delivery history. With either of these approaches, the space overhead can be cut on average to O (n) per message.
Reference: [GT92] <author> R. Golding and K. Taylor. </author> <title> Group membership in the epidemic style. </title> <type> Technical Report UCSC-CRL-92-13, </type> <institution> University of California, Santa Cruz, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: System diagnosis assumes a failure model where faulty processors can be detected by executing a test program on the processor [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95]. The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties <ref> [RFJ93, GT92, Hil95] </ref> to others that guarantee strong properties [BSS91, AMMS + 95, DMS95]. The tradeoff is the strength of the guarantee versus the execution cost.
Reference: [Gut89] <author> R. Guting. </author> <title> Gral: An extensible relational database system for geometric applications. </title> <booktitle> In Proceedings of the 15th Conference on Very Large Databases, </booktitle> <month> Aug </month> <year> 1989. </year>
Reference-contexts: Although specialized databases have been developed for these different application areas, exploiting configurability is an appealing alternative. Here, we outline two different configurable or extensible database systems. Numerous others, including Postgres [SR86], Starburst [SCF + 86], Exodus [CD87], Gral <ref> [Gut89] </ref>, Ream [KNKH89], and P2 [TB95], are not addressed here. The RAID system [BFHR90] has been used to study adaptive concurrency control.
Reference: [HA74] <author> S. Hakimi and A. Amin. </author> <title> Characterization of connection assignment of diagnosable systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-23(1):86-88, </volume> <month> Jan </month> <year> 1974. </year>
Reference-contexts: Moreover, each subunit must be tested by at least t distinct other subunits. In the special case where no two subunits test each other, these necessary conditions are also sufficient for t-diagnosability <ref> [HA74] </ref>. In addition to the general model, [PMC67] gives a convenient testing subnetwork formulation for t-diagnosable systems that is used widely in later papers.
Reference: [HC92] <author> K. Harty and D. Cheriton. </author> <title> Application-controlled physical memory using external page-cache management. </title> <booktitle> In Proceedings of the 5th International Conference on Architecture Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 187-199, </pages> <month> Oct </month> <year> 1992. </year>
Reference-contexts: For example, [CFL94] demonstrates that application-level control of file cashing reduces application running time by 45%. Similarly, application-specific virtual memory policies increase application performance <ref> [HC92, KLVA93] </ref>, while exception handling is an order of magnitude faster if the signal handling is deferred to applications [TL94].
Reference: [Her89] <author> A. Herbert. </author> <title> ANSA Project and Standards. </title> <editor> In S. Mullender, editor, </editor> <booktitle> Distributed Systems, chapter 17., </booktitle> <pages> pages 391-438. </pages> <publisher> Academic Press, </publisher> <year> 1989. </year>
Reference-contexts: Also, while the standard interface syntactically allows protocols to be stacked in any order, most protocols require certain semantics from protocols below, imposing a partial order on the possible configurations [RHB95]. 2.1.2.3 ANSA ANSA (Advanced Networked Systems Architecture) is a software architecture for building distributed systems <ref> [Her89, Tea91, Her94] </ref>. ANSA provides a general computational model that defines how objects in a distributed system are specified and how objects interact.
Reference: [Her94] <author> A. Herbert. </author> <title> An ANSA overview. </title> <journal> IEEE Network, </journal> <volume> 8(1), </volume> <month> Jan </month> <year> 1994. </year>
Reference-contexts: Also, while the standard interface syntactically allows protocols to be stacked in any order, most protocols require certain semantics from protocols below, imposing a partial order on the possible configurations [RHB95]. 2.1.2.3 ANSA ANSA (Advanced Networked Systems Architecture) is a software architecture for building distributed systems <ref> [Her89, Tea91, Her94] </ref>. ANSA provides a general computational model that defines how objects in a distributed system are specified and how objects interact.
Reference: [Hil95] <author> M. A. Hiltunen. </author> <title> Membership and system diagnosis. </title> <booktitle> In Proceedings of the 14th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 208-217, </pages> <address> Bad Neuenahr, Germany, </address> <month> Sept </month> <year> 1995. </year>
Reference-contexts: System diagnosis assumes a failure model where faulty processors can be detected by executing a test program on the processor [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95]. The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties <ref> [RFJ93, GT92, Hil95] </ref> to others that guarantee strong properties [BSS91, AMMS + 95, DMS95]. The tradeoff is the strength of the guarantee versus the execution cost.
Reference: [HKR84] <author> S. Hosseini, J. Kuhl, and S. Reddy. </author> <title> A diagnosis algorithm for distributed computing systems with dynamic failure and repair. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-33(3):223-233, </volume> <month> Mar </month> <year> 1984. </year> <month> 212 </month>
Reference-contexts: The resulting syndrome can be analyzed as in PMC model. More recently, work in the system diagnosis field has concentrated on distributed diagnosis and probabilistic diagnosis. The concept of t p self-diagnosable systems was introduced in <ref> [HKR84] </ref> for distributed systems where there is no central coordinator that executes the diagnosis. <p> The differences between the service guarantees or possible transformations between membership and system diagnosis algorithms were not addressed in [BMD93]. 6.3 From System Diagnosis to Membership In this section, we apply the observations above and show how typical distributed system diagnosis algorithms NEW SELF <ref> [HKR84] </ref>, EVENT SELF [BGN90], and Adaptive DSD 144 [BB91] can be transformed into membership algorithms. The transformation is based on changing the failure model and thereby the testing method. <p> The transformation is based on changing the failure model and thereby the testing method. The last example generates a new membership algorithm that appears to be competitive with published membership algorithms due to its simplicity and low message and execution overhead. 6.3.1 NEW SELF System Diagnosis Algorithm NEW SELF <ref> [HKR84] </ref> assumes that each processor in the distributed system is capable of testing its neighbors. Correctly operating processors pass on results of these tests to other processors in the network. No assumptions are made about faulty processors.
Reference: [HP91] <author> N. Hutchinson and L. Peterson. </author> <title> The x-kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: Also, in file systems, configura-bility has been used to enable new application types, such as databases and multimedia, to make use of file systems efficiently for their storage needs [HP94, KN93, Maf94]. In networking, the x-kernel <ref> [HP91] </ref> and Adaptive [SBS93] are examples of systems that support construction of customized communication protocols out of modules. All these systems are described further in chapter 2. Although numerous projects have investigated issues related to communication services for fault-tolerant distributed computing, only a few have explored modularity and configurability. <p> The main emphasis of the OSI model is interoperability and configurability is mostly limited to choosing some execution parameters. Other projects in the communication field have taken more interest in configurability in addition to modularity. The x-kernel is a system for constructing networking subsystems <ref> [HP91, OP92] </ref>. As discussed in the context of Consul (section 2.1.2.1), the x-kernel supports hierarchical composition of communication protocols, such as the standard Internet protocols IP, TCP, and UDP, where each protocol is implemented as an independent module. <p> The x-kernel work has demonstrated that modular implementation can be efficient. For example, user-to-user communication latency in the x-kernel has been shown to be much less, often less than half, than that of Unix on identical hardware <ref> [HP91] </ref>. The Adaptive system [SBS93] proposes a configurable and adaptive framework for building communication protocols for applications like multi-media that have special requirements for quality of service. The model used by Adaptive is based on dividing the communication service into functions, with each function being implemented by a chosen protocol.
Reference: [HP94] <author> J. Heidemann and G. Popek. </author> <title> File-system development with stackable layers. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12(1) </volume> <pages> 58-89, </pages> <month> Feb </month> <year> 1994. </year>
Reference-contexts: Also, in file systems, configura-bility has been used to enable new application types, such as databases and multimedia, to make use of file systems efficiently for their storage needs <ref> [HP94, KN93, Maf94] </ref>. In networking, the x-kernel [HP91] and Adaptive [SBS93] are examples of systems that support construction of customized communication protocols out of modules. All these systems are described further in chapter 2. <p> In particular, multimedia requires high I/O throughput rates and quality of service guarantees such as constant minimum data rates not typically provided by file systems [AOG92]. Typical file systems also do not support easy addition of new services, such as compression or encryption <ref> [HP94] </ref>. Many of these problems have been addressed in research projects that study configurable or extensible file systems. The stackable file system described in [HP94, HP95] allows the system to be augmented with new properties by adding layers to an existing file system. <p> Typical file systems also do not support easy addition of new services, such as compression or encryption [HP94]. Many of these problems have been addressed in research projects that study configurable or extensible file systems. The stackable file system described in <ref> [HP94, HP95] </ref> allows the system to be augmented with new properties by adding layers to an existing file system. Examples of new layers might be encryption, compression, selective file replication, extended directory services, remote access, undo, undelete, or better support for transactions. <p> Other examples are the function-based systems, since each module typically has a function-specific interface and can therefore only be used in one slot. A few systems, such as the stackable file system <ref> [HP94] </ref>, support an extensible standard interface, which would fall somewhere between the two general approaches. 2.4 Conclusions The different configurable services discussed in this chapter illustrate the different approaches taken to configurability. Most of these approaches can be characterized as being hierarchical or function-based.
Reference: [HP95] <author> J. Heidemann and G. Popek. </author> <title> Performance of cache coherence in stackable filing. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 127-142, </pages> <address> Copper Mountain Resort, Colorado, </address> <month> Dec </month> <year> 1995. </year>
Reference-contexts: Typical file systems also do not support easy addition of new services, such as compression or encryption [HP94]. Many of these problems have been addressed in research projects that study configurable or extensible file systems. The stackable file system described in <ref> [HP94, HP95] </ref> allows the system to be augmented with new properties by adding layers to an existing file system. Examples of new layers might be encryption, compression, selective file replication, extended directory services, remote access, undo, undelete, or better support for transactions.
Reference: [HPOA89] <author> N. Hutchinson, L. Peterson, S. O'Malley, and M. Abbott. </author> <title> RPC in the x-kernel: Evaluating new design techniques. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 91-101, </pages> <address> Litch-field Park, AZ, </address> <month> Dec </month> <year> 1989. </year>
Reference-contexts: Although, the presentation was not as detailed as in chapters 4 and 5, this chapter shows again the general design steps and application of the event-driven execution model described in chapter 3. Other researchers have also proposed modular implementations of RPC. For example, in <ref> [HPOA89] </ref> a modular implementation of RPC service based on the x-kernel is described.
Reference: [HR83] <author> T. Haerder and A. Reuter. </author> <title> Principles of transaction-oriented database recovery. </title> <journal> ACM Computing Surveys, </journal> <volume> 15(4) </volume> <pages> 287-317, </pages> <month> Dec </month> <year> 1983. </year>
Reference-contexts: The properties defined for transactions are another example of abstract properties of a service. A transaction is a collection of operations that is executed as a unit despite concurrency and potential failures during the execution. Typically, transactions have the following four, so-called ACID, properties <ref> [HR83, Bla91] </ref>: * Atomicity or All-or-nothing: Either the transaction completes or it has no effect, despite failures of some of the components involved in the transaction. * Consistency: A transaction takes the database from one consistent state to another. * Isolation: The intermediate states of the data manipulated by a transaction
Reference: [HR94] <author> Y-M. Huang and C. Ravishankar. </author> <title> Designing an agent synthesis system for cross-RPC communication. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(3) </volume> <pages> 188-198, </pages> <month> Mar </month> <year> 1994. </year>
Reference-contexts: In contrast with our emphasis on configurability and modularization based on abstract properties, however, that paper describes a modularization of an RPC service implementing one chosen semantics where the modules are syntactic components rather than implementations of abstract properties. The work on an agent-synthesis system for Cross-RPC communication in <ref> [HR94] </ref> is relatively closely related to our goals. Although its primary goal is to allow heterogeneous RPC systems to communicate with one another, 170 the system also offers the possibility for designing and prototyping new variants of RPC.
Reference: [HS87] <author> R. Hayes and R.D. Schlichting. </author> <title> Facilitating mixed language programming in distributed systems. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 13(12) </volume> <pages> 1254-1264, </pages> <month> Dec </month> <year> 1987. </year>
Reference-contexts: In this chapter, we apply our approach of constructing configurable fault-tolerant distributed services to group RPC. To simplify the presentation, we concentrate on RPC features related to distribution and fault tolerance. Other issues, although important, are not addressed here. These include stub generation and heterogeneity <ref> [Sun88, Gib87, HS87, Apo89, TB90, WSG91] </ref>, binding [BN84, LT91, BALL90], performance or performance optimizations [PA88, RST89, SB90, BALL90], and security issues [Bir85b].
Reference: [HS93] <author> M. A. Hiltunen and R. D. Schlichting. </author> <title> An approach to constructing modular fault-tolerant protocols. </title> <booktitle> In Proceedings of the 12th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 105-114, </pages> <address> Princeton, NJ, </address> <month> Oct </month> <year> 1993. </year>
Reference-contexts: Here, we provide an overview of three prototype systems that support this model. 3.4.2 SR Prototype Initial experimentation was done using the SR concurrent programming language [AO93, AOC + 88] in the context of a reliable ordered group oriented multicast service <ref> [HS93] </ref>. In this prototype, each logical site hosting members of the multicast group is implemented as an SR virtual machine. A composite protocol is implemented as an SR resource, an object that contains local variables, procedures, and processes, and exports operations for use by other resources. <p> Although our approach has been successfully applied to membership and RPC services, the work could be expanded to many other interesting fault-tolerant services. For example, 191 the work on multicast services in <ref> [HS93, GBB + 95] </ref> could be expanded. In particular, the properties of multicast services can be specified using message ordering graphs as done in chapter 4 for membership services.
Reference: [HS94a] <author> M. A. Hiltunen and R. D. Schlichting. </author> <title> A configurable membership service. </title> <type> Technical Report 94-37, </type> <institution> Department of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <month> Dec </month> <year> 1994. </year>
Reference-contexts: Some membership algorithms include some type of distributed vote that compares local information from different group members about the status of a suspected processor before a failure is declared <ref> [HS94a, MPS92] </ref>. Even in this case, there is a possibility of false failure detection, so membership algorithms are prepared to deal with this eventuality by forcing a member suspected to have failed to fail before it is allowed to recover and rejoin the group. <p> Furthermore, as will be discussed in the following sections, the algorithm could be augmented to provide ordering and other properties. Although the algorithm uses similar ideas as some published membership algorithms 150 for example, using a logical ring structure <ref> [AMMS + 93, HS94a, RFJ93] </ref>the complete algorithm is different from any of which we are aware. In terms of message complexity it is very attractive.
Reference: [HS94b] <author> M. A. Hiltunen and R. D. Schlichting. </author> <title> Constructing a configurable group RPC service. </title> <type> Technical Report 94-28, </type> <institution> Department of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <month> Oct </month> <year> 1994. </year>
Reference-contexts: All major micro-protocols are described, with pseudo-code for several shorter micro-protocols given to illustrate the programming style. Detailed pseudo-code for all micro-protocols can be found in <ref> [HS94b] </ref>.
Reference: [HS95] <author> M. A. Hiltunen and R. D. Schlichting. </author> <title> Properties of membership services. </title> <booktitle> In Proceedings of the 2nd International Symposium on Autonomous Decentralized Systems, </booktitle> <pages> pages 200-207, </pages> <address> Phoenix, AZ, </address> <month> Apr </month> <year> 1995. </year>
Reference-contexts: Given this view, the properties of a membership service can be defined in terms of what membership change messages it generates and when they are delivered to the application with respect to other messages and real time <ref> [HS95] </ref>. ordering graph. Although we separate them here logically, in practice the two components are often tightly interrelated, with dependencies between them. The communication component is responsible for realizing the required properties of the application level communication between group members. <p> This micro-protocol is distinct from ExtendedVirtualSynchrony since the predecessor sets of such messages are different in the sites in the two merging partitions. Other partition handling micro-protocols. In numerous membership services <ref> [Cri91, HS95, KT91, KGR91, MSMA94, MPS93a, RB91] </ref>, it is simply assumed that partitions will not occur, or that only one partition will continue to operate. The OnePartition micro-protocol implements a simple strategy that approximates this behavior.
Reference: [IM84] <author> H. Ihara and M. Mori. </author> <title> Autonomous decentralized computer control systems. </title> <journal> IEEE Computer, </journal> <volume> 17(8) </volume> <pages> 57-66, </pages> <month> Aug </month> <year> 1984. </year> <month> 213 </month>
Reference-contexts: The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. A large number of other projects are not addressed in detail here, including ADS <ref> [IM84] </ref>, Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the
Reference: [IY94] <author> J-I. Itoh and Y. Yokote. </author> <title> Concurrent object-oriented device driver programming in Apertos operating system. </title> <type> Technical Report SCSL-TR-94-005, </type> <institution> Sony Computer Science Laboratory Inc., </institution> <month> Jun </month> <year> 1994. </year>
Reference-contexts: In the following, we take a closer look at a number of these projects. Numerous others, such as Choices [CJK + 87, CIM92], the Kernel Tool Kit (KTK) [GMSS94, MS96], Kea [VH96], and Apertos <ref> [Yok92, Yok93, TYT92, IY94] </ref>, are not addressed here. The SPIN operating system is based on an extensible microkernel [BCE + 94, BSS + 95]. The microkernel exports interfaces that offer applications fine-grained control over a few fundamental system abstractions, such as threads and virtual address spaces.
Reference: [Jac88] <author> V. Jacobson. </author> <title> Congestion avoidance and control. </title> <booktitle> In Proceedings of the SIGCOMM '88 Symposium, </booktitle> <pages> pages 314-332, </pages> <month> Aug </month> <year> 1988. </year>
Reference-contexts: Thus, a system can be viewed as consisting of layers of abstractions. 1.2.2 Service Abstractions A number of useful services and abstractions for distributed computing have evolved over the years. One of the most widely used is the TCP/IP protocol <ref> [Jac88] </ref>, which provides the abstraction of a reliable pipe between two computers where bytes are delivered in the same order as they were sent. <p> The ability to adapt in this way reduces the number of collisions and thereby improves the overall throughput of the system. The Transmission Control Protocol (TCP) of the Internet protocol suite uses adaptive mechanisms for flow control, retransmission, and congestion control <ref> [Jac88] </ref>. Other examples include concurrency control of database transactions [BFHR90], real-time parallel systems [BS91, SBB87], operating systems [MS96], and high-speed communication protocols [SBS93]. Furthermore, as noted above, adaptive systems are important in the area of dependable computing [GGL93].
Reference: [JZ93] <author> D. Johnson and W. Zwaenepoel. </author> <title> The Peregrine high-performance RPC system. </title> <journal> Software Practice & Experience, </journal> <volume> 23(2) </volume> <pages> 201-222, </pages> <year> 1993. </year>
Reference-contexts: With RPC, a request for service from a client to a server process is structured to give synchronization semantics at the client similar to normal procedure call. Numerous examples of different RPC services and implementations exist, including Firefly RPC [SB90], Alphorn [AGH + 91], lightweight RPC [BALL90], Peregrine <ref> [JZ93] </ref>, [RSV94], and SUPRA-RPC [Sto94]. Among the commercial RPC packages released have been Courier from Xerox [Xer81], Sun RPC [Sun88], Netwise RPC from Novell Netware, and NCA from Apollo [Apo89]. [TA90] gives a survey of work in this area.
Reference: [KDK + 89] <author> H. Kopetz, A. Damm, C. Koza, M. Mulazzani, W. Schwabl, C. Senft, and R. Zainlinger. </author> <title> Distributed fault-tolerant real-time systems: The Mars approach. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 25-40, </pages> <month> Feb </month> <year> 1989. </year>
Reference-contexts: Other multicast or broadcast services provide different sets of properties. The V-system [CZ85] provides only unreliable multicast. Consul [MPS93a, MPS93b], Isis [BSS91], and Transis [ADKM92b, DM96] provide multicast with the atomicity property and various ordering properties, but no timeliness properties. The Mars system <ref> [KO87, KDK + 89] </ref> provides atomicity, ordering, and timeliness properties. The existing multicast implementations cover only a small subset of all possible combinations of multicast properties, however. <p> Here, we examine the basic outline of some of these systems, without addressing in detail any of the particular services provided. Since the emphasis is on configurable systems, only two static systems are described: Isis [Bir85a, BJ87, BC91, BSS91, BR94] and Mars <ref> [KM85, KDK + 89, KG94] </ref>. The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. <p> The services provided by Isis are not configurable, but the system includes a collection of multicast services with different ordering and reliability semantics. 2.1.1.2 Mars Mars is a system for building fault-tolerant distributed real-time applications <ref> [KM85, KDK + 89, KG94] </ref>. Mars is targeted for hard real-time applications, where missing a deadline can be catastrophic. Therefore, Mars places extremely strict requirements on the timeliness of communication and task execution, as well as the overall reliability of the system.
Reference: [Kea90] <author> H. Kopetz and et al. </author> <title> Tolerating transient faults in Mars. </title> <booktitle> In Proceedings of the 20th Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 466-473, </pages> <month> Jun </month> <year> 1990. </year>
Reference-contexts: The exact value of k depends on the assumptions about the underlying network and the reliability requirements of the application. Computation failures such as crashes are tolerated by executing each task on redundant computers and/or executing each task more than once on a single machine <ref> [Kea90] </ref>. Configurability in Mars is limited to adjusting the degree of communication and computation redundancy to reach the dependability goals. 2.1.2 Configurable Systems 2.1.2.1 Consul Consul is a collection of communication services developed for implementing fault-tolerant distributed programs based on the state machine approach [MPS93a, MPS93b].
Reference: [Kec91] <author> D. Kececioglu. </author> <title> Reliability Engineering Handbook. </title> <publisher> Prentice Hall, </publisher> <address> En-glewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: Both techniques apply both time and space redundancy to achieve their goals. 21 1.1.1 Measures of Dependability Important measures of system dependability are availability and reliability, which are defined as follows <ref> [Kec91] </ref>: * Availability, in particular instantaneous availability, is the probability that a system will be available for use at any random time t after the start of operation. * Reliability is the probability that parts, components, products, or systems will perform their designed-for functions without failure in specified environments for desired <p> For telephone switching systems, the availability goal is 99.4%, which translates to 3 minutes of system down-time a year, and the reliability goal is to sustain at least 99.9875% of all established calls, which translates to inadvertently disconnecting no more than 1.25 calls out of 10,000 <ref> [Kec91] </ref>. In the manufacturing industry, information about the reliability of a product is used, for example, to determine the optimal guarantee periods. Finally, reliability and availability are even beginning to be used to advertise consumer goods and services.
Reference: [KG94] <author> H. Kopetz and G. Grunsteidl. </author> <title> TTP A protocol for fault-tolerant real-time systems. </title> <journal> Computer, </journal> <volume> 27(1) </volume> <pages> 14-23, </pages> <month> Jan </month> <year> 1994. </year>
Reference-contexts: Here, we examine the basic outline of some of these systems, without addressing in detail any of the particular services provided. Since the emphasis is on configurable systems, only two static systems are described: Isis [Bir85a, BJ87, BC91, BSS91, BR94] and Mars <ref> [KM85, KDK + 89, KG94] </ref>. The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. <p> The services provided by Isis are not configurable, but the system includes a collection of multicast services with different ordering and reliability semantics. 2.1.1.2 Mars Mars is a system for building fault-tolerant distributed real-time applications <ref> [KM85, KDK + 89, KG94] </ref>. Mars is targeted for hard real-time applications, where missing a deadline can be catastrophic. Therefore, Mars places extremely strict requirements on the timeliness of communication and task execution, as well as the overall reliability of the system. <p> Membership services have proven to be fundamental for constructing systems and applications. The existing work can be classified based on the assumptions about the system model. In particular, some membership services assume a synchronous system where bounds are placed on network transmission time <ref> [Cri91, KGR91, KG94, EL90, LE90, SCA94] </ref>, whereas other assume an asynchronous system where no such assumption is made [MSMA94, MAMSA94, DMS94, DMS95, EL95, AMMS + 93, MPS93a, RB91, SR93, ADKM92a, GT92, RFJ93, Bir85a, SM94, BDM95, CS95]. Distinctions can also be made based on the failure model.
Reference: [KGR91] <author> H. Kopetz, G. Grunsteidl, and J. Reisinger. </author> <title> Fault-tolerant membership service in a synchronous distributed real-time system. </title> <editor> In A. Avizienis and J.C. Laprie, editors, </editor> <booktitle> Dependable Computing for Critical Applications, </booktitle> <pages> pages 411-429. </pages> <publisher> Springer-Verlag, Wien, </publisher> <year> 1991. </year>
Reference-contexts: Similarly, a membership service provides consistent information about which computers are functioning and which have failed at any given time in a distributed system, thereby simplifying the problems associated with failures <ref> [Cri91, Bir85a, EL90, KGR91, MPS92] </ref>. <p> Membership services have proven to be fundamental for constructing systems and applications. The existing work can be classified based on the assumptions about the system model. In particular, some membership services assume a synchronous system where bounds are placed on network transmission time <ref> [Cri91, KGR91, KG94, EL90, LE90, SCA94] </ref>, whereas other assume an asynchronous system where no such assumption is made [MSMA94, MAMSA94, DMS94, DMS95, EL95, AMMS + 93, MPS93a, RB91, SR93, ADKM92a, GT92, RFJ93, Bir85a, SM94, BDM95, CS95]. Distinctions can also be made based on the failure model. <p> As a result, if this assumption is violated, a change detection algorithm that is intended to be live and accurate will lose its accuracy characteristics. This scenario is acknowledged and handled, for example, in the design of Mars <ref> [KGR91] </ref>. Although, in principle, it would be possible to have a change detection that is neither accurate nor live, in this chapter we only consider change detection that is at least live or accurate. <p> However, live detection is necessary but not sufficient to guarantee live service. For example, the membership protocol in Isis [RB91] that uses live detection based on timeouts has been shown not to be live in all situations [ACBMT95]. In synchronous systems, membership services are typically accurate and live <ref> [Cri91, KGR91] </ref>. In membership services in which change detection is inaccurate, the level of confidence indicates how certain it is that the suspected change has actually occurred. The typical way to increase confidence is to compare information from different sites before making a final decision. <p> This information can be exploited to construct a variant of atomic multicast similar to those described in <ref> [KGR91, VM90] </ref> in which a message is only delivered to the application if it can be guaranteed to have been received at all sites to which it was addressed. <p> by guaranteeing that all sites share the same view of the membership or are knowingly in a transition state. 4.2.4.2 Timebound Synchrony Timebound synchrony is a property of membership services in synchronous systems in which every site delivers a given membership change message within some known interval of real time <ref> [KGR91, Cri91] </ref>. The property has the same general applicability as external synchrony, but reduces the synchronization overhead by shrinking the window during which the membership is not identical on all sites. <p> Partitions may be caused by disconnection of the underlying network or by problems such as network congestion or an overloaded gateway processor. A number of different approaches are used in membership services to deal with partitions. One common approach is simply to assume they will not occur <ref> [Cri91, KGR91, MPS92] </ref>. This can be justified by increasing the connectivity of the network or by using other architectural assumptions. If this assumption is not valid, there are a number of ways to deal with multiple partitions [AMMS + 95, DMS94, DMS95, MAMSA94, RFJ93, RB91, SM94]. <p> Note that these protocols do not attempt to order membership changes with respect to application messages. 4.4.5 Mars The membership service in the Mars system is another example of a synchronous protocol <ref> [KGR91] </ref>. Mars builds on a physical ring architecture in which the network is accessed using a time division multiple access (TDMA) strategy based on common global time, i.e., access to the physical medium is divided into dedicated time slots that are allocated a priori to sites in a round-robin fashion. <p> This micro-protocol is distinct from ExtendedVirtualSynchrony since the predecessor sets of such messages are different in the sites in the two merging partitions. Other partition handling micro-protocols. In numerous membership services <ref> [Cri91, HS95, KT91, KGR91, MSMA94, MPS93a, RB91] </ref>, it is simply assumed that partitions will not occur, or that only one partition will continue to operate. The OnePartition micro-protocol implements a simple strategy that approximates this behavior. <p> Some of the work has been based on a synchronous system model, where bounds are placed on the network transmission time <ref> [Cri91, EL90, KGR91, LE90, SCA94] </ref>. Other work assumes an asynchronous model similar to that used in this chapter [ADKM92a, AMMS + 95, DMS94, EL95, GT92, MPS92, MPS93a, MAMSA94, RB91, SM94]. <p> An important exception is [BMD93], which reviewed the field of system diagnosis thoroughly and compared it to membership. Unfortunately the emphasis was heavily on system diagnosis and the comparison brief. A number of other papers, for example <ref> [EL95, KGR91] </ref>, acknowledge the relationship between these problems but do not explore it any further. In this chapter, we introduce system diagnosis, contrast it with the membership problem, and show that they can be viewed as essentially the same problem with slightly different assumptions.
Reference: [KH83] <author> S. Kreutzer and S. Hakimi. </author> <title> Adaptive fault identification in two new diagnostic models. </title> <booktitle> In Proceedings of the 21st Allerton Conference on Communication, Control, and Computing, </booktitle> <pages> pages 353-362, </pages> <year> 1983. </year>
Reference-contexts: In this scheme, multiple alternative algorithms are executed, with the actual number of alternatives used being determined at runtime based on the level of confidence desired. Adaptive algorithms have also been used to diagnose faulty processors in distributed systems <ref> [KH83, BB91, LYS93] </ref>. This chapter focuses on the adaptive aspect of configurability and use of the event-driven execution model in this context. We first describe a general model for adaptive systems.
Reference: [KLVA93] <author> K. Krueger, D. Loftessness, A. Vahdat, and T. Anderson. </author> <title> Tools for development of application-specific virtual memory management. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming, Systems, Languages, and Applications 1993, </booktitle> <pages> pages 48-64, </pages> <month> Oct </month> <year> 1993. </year>
Reference-contexts: For example, [CFL94] demonstrates that application-level control of file cashing reduces application running time by 45%. Similarly, application-specific virtual memory policies increase application performance <ref> [HC92, KLVA93] </ref>, while exception handling is an order of magnitude faster if the signal handling is deferred to applications [TL94].
Reference: [KM85] <author> H. Kopetz and W. Merker. </author> <title> The architecture of Mars. </title> <booktitle> In Proceedings of the 15th Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 274-279, </pages> <address> Ann Arbor, MI, </address> <month> Jun </month> <year> 1985. </year>
Reference-contexts: Here, we examine the basic outline of some of these systems, without addressing in detail any of the particular services provided. Since the emphasis is on configurable systems, only two static systems are described: Isis [Bir85a, BJ87, BC91, BSS91, BR94] and Mars <ref> [KM85, KDK + 89, KG94] </ref>. The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. <p> The services provided by Isis are not configurable, but the system includes a collection of multicast services with different ordering and reliability semantics. 2.1.1.2 Mars Mars is a system for building fault-tolerant distributed real-time applications <ref> [KM85, KDK + 89, KG94] </ref>. Mars is targeted for hard real-time applications, where missing a deadline can be catastrophic. Therefore, Mars places extremely strict requirements on the timeliness of communication and task execution, as well as the overall reliability of the system.
Reference: [KN93] <author> Y. Khalidi and M. Nelson. </author> <title> Extensible file systems in Spring. </title> <booktitle> In Proceedings of the 14th Symposium on Operating Systems Principles, </booktitle> <address> Asheville, NC, </address> <month> Dec </month> <year> 1993. </year> <month> 214 </month>
Reference-contexts: Also, in file systems, configura-bility has been used to enable new application types, such as databases and multimedia, to make use of file systems efficiently for their storage needs <ref> [HP94, KN93, Maf94] </ref>. In networking, the x-kernel [HP91] and Adaptive [SBS93] are examples of systems that support construction of customized communication protocols out of modules. All these systems are described further in chapter 2. <p> The approach chosen is to have an extensible standard interface, where a layer typically just passes through operations that it does not support. The extensible file system described in <ref> [KN93] </ref> addresses the same issues but takes a slightly different approach. This file system is designed for the Spring operating system, which is a distributed, multi-threaded operating system built using objects and interface inheritance.
Reference: [KNKH89] <author> S. Kawakami, T. Nakayama, K. Kashiwabara, and S. Hikita. REAM: </author> <title> An SQL based and extensible relational database management system. </title> <booktitle> In Proceedings of the 1st International Symposium on Database Systems for Advanced Applications, </booktitle> <month> Apr </month> <year> 1989. </year>
Reference-contexts: Although specialized databases have been developed for these different application areas, exploiting configurability is an appealing alternative. Here, we outline two different configurable or extensible database systems. Numerous others, including Postgres [SR86], Starburst [SCF + 86], Exodus [CD87], Gral [Gut89], Ream <ref> [KNKH89] </ref>, and P2 [TB95], are not addressed here. The RAID system [BFHR90] has been used to study adaptive concurrency control.
Reference: [KO87] <author> H. Kopetz and W. Ochsenreiter. </author> <title> Clock synchronization in distributed, real-time systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(8):933-940, </volume> <month> Aug </month> <year> 1987. </year>
Reference-contexts: A time service provides consistent information about time in a distributed system, either in the form of logical or virtual time that can be used to reason about the relative order of events [Lam78, Sch82, 25 Mat89] or real time from synchronized clocks <ref> [KO87, WL88, RSB90, VR92] </ref>. Other important service abstractions are atomic actions, a collection of operations whose execution is indivisible despite concurrency and failures [Lam81, Lis85, SDP89]; and stable storage, storage whose contents is guaranteed to survive failures [Lam81, BY87]. Paradigms for structuring fault-tolerant software further simplify developing applications. <p> Other multicast or broadcast services provide different sets of properties. The V-system [CZ85] provides only unreliable multicast. Consul [MPS93a, MPS93b], Isis [BSS91], and Transis [ADKM92b, DM96] provide multicast with the atomicity property and various ordering properties, but no timeliness properties. The Mars system <ref> [KO87, KDK + 89] </ref> provides atomicity, ordering, and timeliness properties. The existing multicast implementations cover only a small subset of all possible combinations of multicast properties, however.
Reference: [KT91] <author> M. Kaashoek and A. Tanenbaum. </author> <title> Group communication in the Amoeba distributed operating system. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 222-230, </pages> <address> Arlington, TX, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba <ref> [RST89, KT91] </ref>, AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel <p> This micro-protocol is distinct from ExtendedVirtualSynchrony since the predecessor sets of such messages are different in the sites in the two merging partitions. Other partition handling micro-protocols. In numerous membership services <ref> [Cri91, HS95, KT91, KGR91, MSMA94, MPS93a, RB91] </ref>, it is simply assumed that partitions will not occur, or that only one partition will continue to operate. The OnePartition micro-protocol implements a simple strategy that approximates this behavior.
Reference: [KTHB89] <author> M. Kaashoek, A. Tanenbaum, S. Hummel, and H. Bal. </author> <title> An efficient reliable broadcast protocol. </title> <journal> Operating Systems Review, </journal> <volume> 23(4) </volume> <pages> 5-19, </pages> <month> Oct </month> <year> 1989. </year>
Reference-contexts: This example is treated in more detail later in this chapter. 8.3.3 Centralized Total Ordering A simple and straightforward way to achieve a consistent total ordering of messages in a distributed system is to use a central ordering server <ref> [KTHB89] </ref>. In this scheme, messages are first sent directly to the ordering server, which then retransmits them in some total order to all receivers. Alternatively, messages can be multicast directly to the receivers, with the central ordering service only sending ordering messages [AFM92].
Reference: [LAKS93] <author> B. Lindgren, M. Ammar, B. Krupczak, and K. Schwan. </author> <title> Parallel and configurable protocols: Experiences with a prototype and an architectural framework. </title> <type> Technical Report GIT-CC-93/22, </type> <institution> College of Computing, Georgia Institute of Technology, Atlanta, GE, </institution> <month> Mar </month> <year> 1993. </year>
Reference-contexts: A prototype implementation of the system has been constructed that places special emphasis of parallel execution of the underlying communication protocols <ref> [LAKS93] </ref>. In this model, a protocol consists of a set of protocol objects, each of which performs an isolated protocol processing task. Objects communicate with each other by asynchronous invocations implemented as messages delivered via shared memory mailboxes. Protocol objects cooperate in the processing of protocol packets. <p> Examples of this approach are Adaptive, RAID, the group communication framework [Gol92], and most of the configurable operating systems. A good example of this approach is the concurrency control function in RAID, which can be implemented using different predefined or user-implemented modules. The object/message model <ref> [LAKS93] </ref> and class-hierarchy based models like Arjuna and the configurable mixed-media file system [Maf94] can be viewed as somewhat generalized versions of the function-based approach.
Reference: [Lam78] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> Jul </month> <year> 1978. </year>
Reference-contexts: A time service provides consistent information about time in a distributed system, either in the form of logical or virtual time that can be used to reason about the relative order of events <ref> [Lam78, Sch82, 25 Mat89] </ref> or real time from synchronized clocks [KO87, WL88, RSB90, VR92]. Other important service abstractions are atomic actions, a collection of operations whose execution is indivisible despite concurrency and failures [Lam81, Lis85, SDP89]; and stable storage, storage whose contents is guaranteed to survive failures [Lam81, BY87]. <p> We also show how the algorithm can be augmented to deal with false failure detections. One option for implementing a total order is to use a leader process like above. Here, however, we outline an implementation that relies on logical clock based timestamp ordering <ref> [Lam78] </ref>. Assume that the communication between processors is FIFO ordered and that each processor uses its local logical clock to timestamp the information it passes on about failures and recoveries that it has detected.
Reference: [Lam81] <author> B. Lampson. </author> <title> Atomic transactions. </title> <booktitle> In Distributed SystemsArchitecture and Implementation, </booktitle> <pages> pages 246-265. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: Other important service abstractions are atomic actions, a collection of operations whose execution is indivisible despite concurrency and failures <ref> [Lam81, Lis85, SDP89] </ref>; and stable storage, storage whose contents is guaranteed to survive failures [Lam81, BY87]. Paradigms for structuring fault-tolerant software further simplify developing applications. The replicated state machine approach is a paradigm for building fault-tolerant services using replication [Sch90]. <p> Other important service abstractions are atomic actions, a collection of operations whose execution is indivisible despite concurrency and failures [Lam81, Lis85, SDP89]; and stable storage, storage whose contents is guaranteed to survive failures <ref> [Lam81, BY87] </ref>. Paradigms for structuring fault-tolerant software further simplify developing applications. The replicated state machine approach is a paradigm for building fault-tolerant services using replication [Sch90].
Reference: [Lap92] <author> J. C. Laprie, </author> <title> editor. Dependability: Basic Concepts and Terminology. </title> <publisher> Springer-Verlag, </publisher> <address> Vienna, </address> <year> 1992. </year>
Reference-contexts: Using computer systems to control airplanes and power stations requires high levels of dependability, which means that reliance can justifiably be placed on the service it delivers <ref> [Lap92] </ref>. One important aspect of dependability is fault tolerance, which means the ability of the system to continue providing its specified service despite component failures. <p> In this dissertation, we present a new approach to constructing configurable fault-tolerant distributed services in which fine-grained modules called micro-protocols can be configured together to give different variants of the desired service. 1.1 Fault Tolerance and Distributed Systems Fault, failure, and error are the fundamental concepts of fault tolerance <ref> [Lap92] </ref>: * A failure occurs when the delivered service of a system or a component deviates from its specification. * An error is the part of the system state that is liable to lead to a failure. * A fault is the hypothesized cause of an error. <p> A more thorough classification of failure models and their relations can be found in [Pow92]; numerous other classifications based on factors such as duration and cause have also been proposed <ref> [Lap92] </ref>. In general, the more inclusive the failure model, the higher the probability that it covers all failures that are encountered, but at a cost of increased processing time and communication. 1.1.3 Distributed Systems As already noted, distributed systems and fault tolerance are inherently linked.
Reference: [LE90] <author> R. Lemos and P. Ezhilchelvan. </author> <title> Agreement on the group membership in synchronous distributed systems. </title> <booktitle> In Proceedings of the 4th International Workshop on Distributed Algorithms, </booktitle> <address> Otranto, Italy, </address> <month> Sep </month> <year> 1990. </year>
Reference-contexts: Membership services have proven to be fundamental for constructing systems and applications. The existing work can be classified based on the assumptions about the system model. In particular, some membership services assume a synchronous system where bounds are placed on network transmission time <ref> [Cri91, KGR91, KG94, EL90, LE90, SCA94] </ref>, whereas other assume an asynchronous system where no such assumption is made [MSMA94, MAMSA94, DMS94, DMS95, EL95, AMMS + 93, MPS93a, RB91, SR93, ADKM92a, GT92, RFJ93, Bir85a, SM94, BDM95, CS95]. Distinctions can also be made based on the failure model. <p> Some of the work has been based on a synchronous system model, where bounds are placed on the network transmission time <ref> [Cri91, EL90, KGR91, LE90, SCA94] </ref>. Other work assumes an asynchronous model similar to that used in this chapter [ADKM92a, AMMS + 95, DMS94, EL95, GT92, MPS92, MPS93a, MAMSA94, RB91, SM94].
Reference: [Lew96] <author> T. Lewis. </author> <title> The next 10; 000 2 years: Part II. </title> <journal> Computer, </journal> <volume> 29(5) </volume> <pages> 78-86, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Recent work also includes event services [GJS92, SB95, MSS96], event-based programming [Ous96], and an event-based structuring approach where an application is constructed by customizing a standard framework with user-supplied handlers <ref> [Lew96] </ref>. Examples of this approach are Java AWT [Yu96], Taligent's CommonPoint [Tal96], and NeXT's OpenStep [Ne94]. 73 CHAPTER 4 PROPERTIES OF MEMBERSHIP SERVICES It is vital to maintain information about which computers are functioning and which have failed at any given time to build dependable distributed applications.
Reference: [LG85] <author> K. Lin and J. Gannon. </author> <title> Atomic remote procedure call. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(10):1126-1135, </volume> <month> Oct </month> <year> 1985. </year>
Reference-contexts: For example, it is the semantics chosen in Rajdoot [PS88], Courier RPC [Xer81], OSI RPC [LH94]. Some systems guarantee at least once, such as [Mar89]. At most once is rare because of the cost of implementation, although it is provided in both Atomic RPC <ref> [LG85] </ref> and Arjuna [SDP91]. 7.1.2 Group RPC Group RPC is any RPC service where the request is sent to more than one server that is, a server groupusing either multicast or point-to-point communication. Group RPC has numerous applications.
Reference: [LH94] <author> Y. Liu and D. Hoang. </author> <title> OSI RPC model and protocol. </title> <journal> Computer communications, </journal> <volume> 17(1) </volume> <pages> 53-66, </pages> <month> Jan </month> <year> 1994. </year> <month> 215 </month>
Reference-contexts: Exactly once appears to be the most popular in implemented systems. For example, it is the semantics chosen in Rajdoot [PS88], Courier RPC [Xer81], OSI RPC <ref> [LH94] </ref>. Some systems guarantee at least once, such as [Mar89].
Reference: [Lis85] <author> B. Liskov. </author> <title> The Argus language and system. </title> <editor> In M. Paul and H.J. Siegert, editors, </editor> <title> Distributed Systems: Methods and Tools for Specification, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 190, chapter 7, </volume> <pages> pages 343-430. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: Other important service abstractions are atomic actions, a collection of operations whose execution is indivisible despite concurrency and failures <ref> [Lam81, Lis85, SDP89] </ref>; and stable storage, storage whose contents is guaranteed to survive failures [Lam81, BY87]. Paradigms for structuring fault-tolerant software further simplify developing applications. The replicated state machine approach is a paradigm for building fault-tolerant services using replication [Sch90]. <p> The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus <ref> [Lis85, Lis88] </ref>, Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system
Reference: [Lis88] <author> B. Liskov. </author> <title> Distributed programming in Argus. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 300-312, </pages> <month> Mar </month> <year> 1988. </year>
Reference-contexts: The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus <ref> [Lis85, Lis88] </ref>, Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system
Reference: [LMJ91] <author> L. Laranjeira, M. Malek, and R. Jenevein. </author> <title> On tolerating faults in naturally redundant algorithms. </title> <booktitle> In Proceedings of the 10th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 118-127, </pages> <month> Sep </month> <year> 1991. </year>
Reference-contexts: This assumption substantially simplifies the problem. The incorrect computation failure model is one where a component, given a correct input, produces an incorrect output <ref> [LMJ91] </ref>. The timing or performance failure model assumes a component will respond with the correct value, but not necessarily within a given time specification [CASD85]. The omission failure model assumes a component may never respond to an input [CASD85]. <p> The best characterization of this failure model is incorrect computation failure, which occurs when a processor fails to produce the correct result in response to the correct inputs <ref> [LMJ91] </ref>. Note, however, that if we define the test result to be fail in 142 case no response arrives or the response arrives too late, the failure model employed by most membership algorithms is a subset of that used in system diagnosis.
Reference: [LS83] <author> B. Liskov and R. Scheifler. </author> <title> Guardians and actions: Linguistic support for robust distributed programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 381-404, </pages> <month> Jul </month> <year> 1983. </year>
Reference-contexts: At most once is the same as exactly once if the invocation 157 terminates normally, while if the invocation terminates abnormally, the execution of the remote procedure is guaranteed to be atomic, that is, either executed completely or not at all <ref> [LS83] </ref>. In our classification, each of these semantics can be realized as some combination of the unique and atomic execution properties, as illustrated in Table 7.1.
Reference: [LSM82] <author> L. Lamport, R. Shostak, and Pease M. </author> <title> The Byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> Jul </month> <year> 1982. </year>
Reference-contexts: A hierarchy of failure models has been developed for use in different application areas. The broadest failure model is the Byzantine or arbitrary failure model where components fail in arbitrary way <ref> [LSM82] </ref>. This model accommodates all possible causes of failures, including malicious failures where a machine actively tries to interfere with the progress of a computation. Naturally, the algorithms based on this failure model are extremely complicated and expensive to execute. <p> System diagnosis, on the other hand, seems, in most cases, to deal with a somewhat obscure failure model, namely one that can be detected by whichever test is employed by the system diagnosis algorithm. This failure model is strictly smaller than Byzantine failures <ref> [LSM82] </ref>, since faulty processors suffering from such a failure could fool any test. The best characterization of this failure model is incorrect computation failure, which occurs when a processor fails to produce the correct result in response to the correct inputs [LMJ91].
Reference: [LT91] <author> H. Levy and E. Tempero. </author> <title> Modules, objects and distributed programming: Issues in RPC and remote object invocation. </title> <journal> Software Practice & Experience, </journal> <volume> 21(1) </volume> <pages> 77-90, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: To simplify the presentation, we concentrate on RPC features related to distribution and fault tolerance. Other issues, although important, are not addressed here. These include stub generation and heterogeneity [Sun88, Gib87, HS87, Apo89, TB90, WSG91], binding <ref> [BN84, LT91, BALL90] </ref>, performance or performance optimizations [PA88, RST89, SB90, BALL90], and security issues [Bir85b].
Reference: [LYS93] <author> J. Lee, H. Youn, and A. Singh. </author> <title> Adaptive voting for faulty (VFF) node scheme for distributed self-diagnosis. </title> <booktitle> In Proceedings of the 23rd Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 480-489, </pages> <month> Jun </month> <year> 1993. </year>
Reference-contexts: Furthermore, system diagnosis [PMC67], which deals with the problem of detecting faulty processors, is closely related to membership. System diagnosis assumes a failure model where faulty processors can be detected by executing a test program on the processor <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties [RFJ93, GT92, Hil95] to others that guarantee strong properties [BSS91, AMMS + 95, DMS95]. <p> On the basis of the responses, the outcome of the test is classified as pass or fail. In either case, the testing unit evaluates the tested unit as either fault-free or faulty. Numerous papers on system diagnosis have followed <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. Despite the close resemblance of the system diagnosis problem and the membership problem discussed in chapters 4 and 5, little has been done to compare or contrast these two fields. <p> This system model avoids many of the pitfalls of the PMC model, including the need for the complete tests, the permanent nature of faults, off-line testing, and an upper bound on the number of simultaneously faulty subunits. More recent work on probabilistic diagnosis can be found in <ref> [BP90a, BSM89, BP90b, LYS93, Pel93] </ref>. 6.2 Comparison We argue that the major differences between algorithms traditionally viewed as system diagnosis or membership are in the failure model and the strength of the properties provided by the service. <p> In this scheme, multiple alternative algorithms are executed, with the actual number of alternatives used being determined at runtime based on the level of confidence desired. Adaptive algorithms have also been used to diagnose faulty processors in distributed systems <ref> [KH83, BB91, LYS93] </ref>. This chapter focuses on the adaptive aspect of configurability and use of the event-driven execution model in this context. We first describe a general model for adaptive systems.
Reference: [Maf94] <author> S. Maffeis. </author> <title> Design and implementation of a configurable mixed-media file system. </title> <journal> Operating Systems Review, </journal> <volume> 28(4) </volume> <pages> 4-10, </pages> <month> Oct </month> <year> 1994. </year>
Reference-contexts: Also, in file systems, configura-bility has been used to enable new application types, such as databases and multimedia, to make use of file systems efficiently for their storage needs <ref> [HP94, KN93, Maf94] </ref>. In networking, the x-kernel [HP91] and Adaptive [SBS93] are examples of systems that support construction of customized communication protocols out of modules. All these systems are described further in chapter 2. <p> The implementation of each layer is written using the underlying file system. Unlike the stackable file system, all layers have an identical interface, and therefore, it is not possible to add new file operations. The configurable mixed-media file system described in <ref> [Maf94] </ref> is another approach to configurability in file systems. This system is configurable in two different aspects. First, features such as the file replacement and space-allocation policies can be changed. <p> A good example of this approach is the concurrency control function in RAID, which can be implemented using different predefined or user-implemented modules. The object/message model [LAKS93] and class-hierarchy based models like Arjuna and the configurable mixed-media file system <ref> [Maf94] </ref> can be viewed as somewhat generalized versions of the function-based approach. In the object/message model, the operation of the system is divided into functions, each of which is implemented by an object that interacts with other objects using messages.
Reference: [Mal80] <author> M. Malek. </author> <title> A comparison connection assignment for diagnosis of multiprocessor systems. </title> <booktitle> In Proceedings of the 7th Annual Symposium on Computer Architecture, </booktitle> <pages> pages 31-36, </pages> <year> 1980. </year>
Reference-contexts: For example, when ffi = 1, unit u i tests u i+1 , u i+2 , : : :, u i+t . An interesting variant to the testing used by the PMC model is comparison testing <ref> [Mal80] </ref>. In comparison testing, tests are based on comparing computation results of productive tasks from different units in the system. In case the size of the result is too large, a function of the result such as checksum can be used instead.
Reference: [MAMSA94] <author> L. Moser, Y. Amir, P. Melliar-Smith, and D. Agarwal. </author> <title> Extended virtual synchrony. </title> <booktitle> In Proceedings of the 14th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 56-65, </pages> <address> Poznan, Poland, </address> <month> Jun </month> <year> 1994. </year>
Reference-contexts: Figure 4.11 illustrates this property; the shaded circles represent messages that were sent before the sender received the membership change message M (C). 86 Extended virtual synchrony has been explored in a number of papers, especially [AMMS + 93] and <ref> [MAMSA94] </ref>. <p> One common approach is simply to assume they will not occur [Cri91, KGR91, MPS92]. This can be justified by increasing the connectivity of the network or by using other architectural assumptions. If this assumption is not valid, there are a number of ways to deal with multiple partitions <ref> [AMMS + 95, DMS94, DMS95, MAMSA94, RFJ93, RB91, SM94] </ref>. <p> Of course, the difficult semantic problems associated with merging application states remain. Our extended virtual synchrony with partitions property is derived from extended virtual synchrony as described in <ref> [MAMSA94] </ref>. <p> It also triggers the event RECOVERY EV. Finally, the ExtendedWithPartition micro-protocol implements extended virtual syn 130 chrony between application messages and membership change messages reporting partition merges, similar to that defined in <ref> [MAMSA94] </ref>. This micro-protocol is distinct from ExtendedVirtualSynchrony since the predecessor sets of such messages are different in the sites in the two merging partitions. Other partition handling micro-protocols.
Reference: [Mar89] <author> P. Martin. </author> <title> Remote procedure call facility for a PC environment. </title> <journal> Computer communications, </journal> <volume> 12(1) </volume> <pages> 31-38, </pages> <month> Feb </month> <year> 1989. </year>
Reference-contexts: Exactly once appears to be the most popular in implemented systems. For example, it is the semantics chosen in Rajdoot [PS88], Courier RPC [Xer81], OSI RPC [LH94]. Some systems guarantee at least once, such as <ref> [Mar89] </ref>.
Reference: [Mat89] <author> F. Mattern. </author> <title> Time and global states in distributed system. </title> <booktitle> In Proceedings of the International Workshop on Parallel and Distributed Algorithms, </booktitle> <publisher> North-Holland, </publisher> <year> 1989. </year> <month> 216 </month>
Reference: [MH76] <author> S. Maheshwari and S. Hakimi. </author> <title> On models for diagnosable systems and probabilistic fault diagnosis. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-25:228 - 236, </volume> <month> Mar </month> <year> 1976. </year>
Reference-contexts: For example, D 1t is t p self-diagnosable if t = t p + 1. More recent work on distributed diagnosis can be found in [BGN90, BB91, BB93, SA89, WHS95]. The first attempt at probabilistic diagnosis is in <ref> [MH76] </ref>, which proposes assigning a reliability to each subunit in the network. This reliability measure is simply the probability of a fault occurring in a given subunit.
Reference: [MMO + 94a] <author> A. Montz, D. Mosberger, S. O'Malley, L. Peterson, T. Proebsting, and J. Hartman. </author> <title> Scout: a communications-oriented operating system. </title> <booktitle> In Proceedings of the 1st Symposium on Operating Design and Implementation (OSDI), </booktitle> <pages> page 200, </pages> <month> Nov </month> <year> 1994. </year>
Reference-contexts: In databases, well-known examples include Genesis [BBG + 88] and Raid [BFHR90]. In operating systems, examples of configurable or extensible systems are Synthesis [PMI88], SPIN [BCE + 94], Scout <ref> [MMO + 94a] </ref>, and V++ [CD94]. Also, in file systems, configura-bility has been used to enable new application types, such as databases and multimedia, to make use of file systems efficiently for their storage needs [HP94, KN93, Maf94]. <p> A number of standard application kernels are provided for different types of applications, but a customized kernel can be constructed if desired. Scout, a communication oriented operating system, is based on the concept of a path, which is the extension of a network connection into the host operating system <ref> [MMO + 94a, MMO + 94b, MP96] </ref>. Scout makes the path its primary abstraction, with resource allocation, scheduling, and fault isolation done on a per-path basis. <p> The next major step for the x-kernel prototype is to port it to a version of the Mach operating system with features for supporting real time [TNR90, TN91]; this would make it feasible to deal with timeliness properties. Porting this prototype to the Scout operating system <ref> [MMO + 94a, MP96] </ref> might further improve performance over the current Mach implementation. Although many experimental projects have successfully applied configurability in areas such as operating systems and networking, the idea have not yet gained widespread commercial acceptance.
Reference: [MMO + 94b] <author> A. Montz, D. Mosberger, S. O'Malley, L. Peterson, T. Proebsting, and J. Hartman. </author> <title> Scout: a communications-oriented operating system. </title> <type> Technical Report 94-20, </type> <institution> Department of Computer Science, University of Ari-zona, </institution> <address> Tucson, AZ, </address> <month> Jun </month> <year> 1994. </year>
Reference-contexts: A number of standard application kernels are provided for different types of applications, but a customized kernel can be constructed if desired. Scout, a communication oriented operating system, is based on the concept of a path, which is the extension of a network connection into the host operating system <ref> [MMO + 94a, MMO + 94b, MP96] </ref>. Scout makes the path its primary abstraction, with resource allocation, scheduling, and fault isolation done on a per-path basis.
Reference: [MMSA + 96] <author> L. Moser, P. Melliar-Smith, D. Agarwal, R. Budhia, and C. Lingley-Papadopoulos. Totem: </author> <title> A fault-tolerant multicast group communication system. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 54-63, </pages> <month> Apr </month> <year> 1996. </year>
Reference-contexts: A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem <ref> [AMMS + 93, AMMS + 95, MMSA + 96] </ref>, Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those that have fault-tolerance requirements [Bir85a, BJ87, BC91, BSS91, BR94].
Reference: [Mos86] <author> J.E.B. Moss. </author> <title> Getting the operating system out of the way. </title> <journal> IEEE Data Engineering, </journal> <volume> 5, </volume> <year> 1986. </year>
Reference-contexts: For example, the poor performance of traditional file systems for database applications has forced many database systems to 46 bypass the file system and implement their own storage system directly on the physical devices <ref> [Sto81, Mos86] </ref>. Traditional file systems are also less than ideal for multimedia applications. In particular, multimedia requires high I/O throughput rates and quality of service guarantees such as constant minimum data rates not typically provided by file systems [AOG92].
Reference: [MP96] <author> D. Mosberger and L. Peterson. </author> <title> Making paths explicit in the Scout operating system. </title> <type> Technical Report 96-05, </type> <institution> Department of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: A number of standard application kernels are provided for different types of applications, but a customized kernel can be constructed if desired. Scout, a communication oriented operating system, is based on the concept of a path, which is the extension of a network connection into the host operating system <ref> [MMO + 94a, MMO + 94b, MP96] </ref>. Scout makes the path its primary abstraction, with resource allocation, scheduling, and fault isolation done on a per-path basis. <p> The next major step for the x-kernel prototype is to port it to a version of the Mach operating system with features for supporting real time [TNR90, TN91]; this would make it feasible to deal with timeliness properties. Porting this prototype to the Scout operating system <ref> [MMO + 94a, MP96] </ref> might further improve performance over the current Mach implementation. Although many experimental projects have successfully applied configurability in areas such as operating systems and networking, the idea have not yet gained widespread commercial acceptance.
Reference: [MPS89] <author> S. Mishra, L. Peterson, and R. D. Schlichting. </author> <title> Implementing replicated objects using Psync. </title> <booktitle> In Proceedings of the 8th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 42-52, </pages> <address> Seattle, Washington, </address> <month> Oct </month> <year> 1989. </year>
Reference-contexts: These services are then summarized in tabular form in section 4.4.8. 105 4.4.2 Consul The membership service of the Consul system [MPS92, MPS93a] assumes asynchronous communication and sites that experience crash failures. The service is built using Psync <ref> [PBS89, MPS89] </ref>, a multicast service that preserves the causal ordering of messages using a context graph abstraction. Psync guarantees reliable multicast communication, so that context graphs on various sites are identical except for transmission delays.
Reference: [MPS92] <author> S. Mishra, L. Peterson, and R. D. Schlichting. </author> <title> A membership protocol based on partial order. </title> <editor> In J. F. Meyer and R. D. Schlichting, editors, </editor> <booktitle> Dependable Computing for Critical Applications 2, </booktitle> <pages> pages 309-331. </pages> <publisher> Springer-Verlag, Wien, </publisher> <year> 1992. </year>
Reference-contexts: Similarly, a membership service provides consistent information about which computers are functioning and which have failed at any given time in a distributed system, thereby simplifying the problems associated with failures <ref> [Cri91, Bir85a, EL90, KGR91, MPS92] </ref>. <p> Thus, different levels of confidence can be defined by specifying how many sites must agree that a suspected change has occurred before a change indication is forwarded to the application. The possibilities range from a single site [RB91, RFJ93, SM94] to all functioning sites <ref> [MPS92] </ref>. In the following, single site suspicion is used to denote the former and consensus the latter. Any option between these two extremes is referred to as a voted decision. In general, the use of voted decisions has not been explored widely in the context of membership services. <p> Partitions may be caused by disconnection of the underlying network or by problems such as network congestion or an overloaded gateway processor. A number of different approaches are used in membership services to deal with partitions. One common approach is simply to assume they will not occur <ref> [Cri91, KGR91, MPS92] </ref>. This can be justified by increasing the connectivity of the network or by using other architectural assumptions. If this assumption is not valid, there are a number of ways to deal with multiple partitions [AMMS + 95, DMS94, DMS95, MAMSA94, RFJ93, RB91, SM94]. <p> Furthermore, membership services are not uniform in how they interact with the application. In our approach, a service signals membership changes by forwarding membership change messages to the application in the regular message stream. We call services that follow this approach, including ISIS [BSS91], Consul <ref> [MPS92] </ref>, and Transis [ADKM92a, ADKM92b], delta-based services since they deliver the changes (deltas) to the application. Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs. <p> This section gives an overview of several existing membership services and characterizes their properties using the terminology defined in this chapter. These services are then summarized in tabular form in section 4.4.8. 105 4.4.2 Consul The membership service of the Consul system <ref> [MPS92, MPS93a] </ref> assumes asynchronous communication and sites that experience crash failures. The service is built using Psync [PBS89, MPS89], a multicast service that preserves the causal ordering of messages using a context graph abstraction. <p> Some membership algorithms include some type of distributed vote that compares local information from different group members about the status of a suspected processor before a failure is declared <ref> [HS94a, MPS92] </ref>. Even in this case, there is a possibility of false failure detection, so membership algorithms are prepared to deal with this eventuality by forcing a member suspected to have failed to fail before it is allowed to recover and rejoin the group. <p> If an algorithm like this is taken as a starting point, an explicit test must be added. However, if the membership algorithm is such that any member can suspect the failure of any other member, such as in Consul <ref> [MPS92] </ref>, implementing corresponding semantics in the system diagnosis algorithm by means of explicit tests may be too expensive for a practical system. As was shown, the validation step can be fairly simple given leader-based information distribution.
Reference: [MPS93a] <author> S. Mishra, L. Peterson, and R. D. Schlichting. </author> <title> Consul: A communication substrate for fault-tolerant distributed programs. </title> <journal> Distributed System Engineering, </journal> <volume> 1 </volume> <pages> 87-103, </pages> <month> Dec </month> <year> 1993. </year>
Reference-contexts: Therefore, the corresponding state changes occur in the same order. Other multicast or broadcast services provide different sets of properties. The V-system [CZ85] provides only unreliable multicast. Consul <ref> [MPS93a, MPS93b] </ref>, Isis [BSS91], and Transis [ADKM92b, DM96] provide multicast with the atomicity property and various ordering properties, but no timeliness properties. The Mars system [KO87, KDK + 89] provides atomicity, ordering, and timeliness properties. <p> The most notable of these are the Consul and Horus systems. Consul is a collection of protocols developed for implementing fault-tolerant distributed programs based on the state-machine approach <ref> [MPS93a, MPS93b] </ref>. It provides support for ordered multicast, membership, and recovery, where the different services are implemented as modules using the x-kernel. Although configurable, the different choices available for the application builder are limited to different message-ordering properties. <p> Configurability in Mars is limited to adjusting the degree of communication and computation redundancy to reach the dependability goals. 2.1.2 Configurable Systems 2.1.2.1 Consul Consul is a collection of communication services developed for implementing fault-tolerant distributed programs based on the state machine approach <ref> [MPS93a, MPS93b] </ref>. <p> An example of an accurate detection that is not live is that of Mach, where the failed site notifies others about its own failure upon recovery [OIOP93]. Most membership services for asynchronous systems have chosen live but not accurate detection, for example, Isis [BSS91] and Consul <ref> [MPS93a] </ref>. The lack of accuracy in such systems comes from the use of timeouts to suspect the failure of a site, a technique that may trigger false suspicions. <p> Collective startup is generally easier to handle since sites are known a priori, and can have implementation advantages if the initial membership is also assumed to be the maximum set of sites that might be group members <ref> [MPS93a] </ref>. Individual startup is more general, but also more complex. For example, this approach requires some known external mechanism for locating other sites, such as a shared name server. <p> This section gives an overview of several existing membership services and characterizes their properties using the terminology defined in this chapter. These services are then summarized in tabular form in section 4.4.8. 105 4.4.2 Consul The membership service of the Consul system <ref> [MPS92, MPS93a] </ref> assumes asynchronous communication and sites that experience crash failures. The service is built using Psync [PBS89, MPS89], a multicast service that preserves the causal ordering of messages using a context graph abstraction. <p> The various approaches for accomplishing this can be classified into three major categories: (1) broadcast based (e.g., <ref> [MPS93a, ADKM92b] </ref>), (2) coordinator based (e.g., [RB91, RFJ93]), and (3) token based (e.g., [RM89]). In examining each approach in light of our requirements, we selected the third based on the resulting simplicity of the micro-protocols. <p> This micro-protocol is distinct from ExtendedVirtualSynchrony since the predecessor sets of such messages are different in the sites in the two merging partitions. Other partition handling micro-protocols. In numerous membership services <ref> [Cri91, HS95, KT91, KGR91, MSMA94, MPS93a, RB91] </ref>, it is simply assumed that partitions will not occur, or that only one partition will continue to operate. The OnePartition micro-protocol implements a simple strategy that approximates this behavior.
Reference: [MPS93b] <author> S. Mishra, L. Peterson, and R. D. Schlichting. </author> <title> Experience with modularity in Consul. </title> <journal> Software Practice & Experience, </journal> <volume> 23(10) </volume> <pages> 1059-1075, </pages> <month> Oct </month> <year> 1993. </year>
Reference-contexts: Therefore, the corresponding state changes occur in the same order. Other multicast or broadcast services provide different sets of properties. The V-system [CZ85] provides only unreliable multicast. Consul <ref> [MPS93a, MPS93b] </ref>, Isis [BSS91], and Transis [ADKM92b, DM96] provide multicast with the atomicity property and various ordering properties, but no timeliness properties. The Mars system [KO87, KDK + 89] provides atomicity, ordering, and timeliness properties. <p> The most notable of these are the Consul and Horus systems. Consul is a collection of protocols developed for implementing fault-tolerant distributed programs based on the state-machine approach <ref> [MPS93a, MPS93b] </ref>. It provides support for ordered multicast, membership, and recovery, where the different services are implemented as modules using the x-kernel. Although configurable, the different choices available for the application builder are limited to different message-ordering properties. <p> Configurability in Mars is limited to adjusting the degree of communication and computation redundancy to reach the dependability goals. 2.1.2 Configurable Systems 2.1.2.1 Consul Consul is a collection of communication services developed for implementing fault-tolerant distributed programs based on the state machine approach <ref> [MPS93a, MPS93b] </ref>. <p> The Consul project was successful in demonstrating the feasibility of modular construction of fault-tolerant services and provided configurability features beyond most similar systems at that time. Another important contribution, however, was in identifying the limitations of the x-kernel for construction of communication services for fault-tolerant systems <ref> [MPS93b] </ref>. First, the x-kernel defines a simple interface between protocols that includes only operations for opening and closing connections, and for sending and receiving 36 messages; additional operations, if needed, must be encapsulated as control operations.
Reference: [MS96] <author> B. Mukherjee and K. Schwan. </author> <title> Evaluation of the adaptation techniques in kernel tool kit (KTK). </title> <booktitle> In Proceedings of the 3rd International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 228-235, </pages> <institution> Annapolis, Maryland, </institution> <month> May </month> <year> 1996. </year> <month> 217 </month>
Reference-contexts: In the following, we take a closer look at a number of these projects. Numerous others, such as Choices [CJK + 87, CIM92], the Kernel Tool Kit (KTK) <ref> [GMSS94, MS96] </ref>, Kea [VH96], and Apertos [Yok92, Yok93, TYT92, IY94], are not addressed here. The SPIN operating system is based on an extensible microkernel [BCE + 94, BSS + 95]. <p> The Transmission Control Protocol (TCP) of the Internet protocol suite uses adaptive mechanisms for flow control, retransmission, and congestion control [Jac88]. Other examples include concurrency control of database transactions [BFHR90], real-time parallel systems [BS91, SBB87], operating systems <ref> [MS96] </ref>, and high-speed communication protocols [SBS93]. Furthermore, as noted above, adaptive systems are important in the area of dependable computing [GGL93]. An example in this area is the SCOP (Self-Configuring Optimistic Programming) scheme [BDGX93], an adaptive version of N-version programming [Avi85].
Reference: [MSMA94] <author> P. Melliar-Smith, L. Moser, and V. Agarwala. </author> <title> Processor membership in asynchronous distributed systems. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 5(5) </volume> <pages> 459-473, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: This micro-protocol is distinct from ExtendedVirtualSynchrony since the predecessor sets of such messages are different in the sites in the two merging partitions. Other partition handling micro-protocols. In numerous membership services <ref> [Cri91, HS95, KT91, KGR91, MSMA94, MPS93a, RB91] </ref>, it is simply assumed that partitions will not occur, or that only one partition will continue to operate. The OnePartition micro-protocol implements a simple strategy that approximates this behavior.
Reference: [MSS96] <author> M. Mansouri-Samani and M. Sloman. </author> <title> A configurable event service for distributed systems. </title> <booktitle> In Proceedings of the 3rd International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 210-217, </pages> <address> Annapolis, Mary-land, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: For example, an x-kernel protocol can be seen as an event-driven entity with handlers for events such as push, pop, open, and close. Recent work also includes event services <ref> [GJS92, SB95, MSS96] </ref>, event-based programming [Ous96], and an event-based structuring approach where an application is constructed by customizing a standard framework with user-supplied handlers [Lew96].
Reference: [Ne94] <institution> NeXT Computer, Inc. OpenStep Specification, </institution> <month> Oct </month> <year> 1994. </year>
Reference-contexts: Recent work also includes event services [GJS92, SB95, MSS96], event-based programming [Ous96], and an event-based structuring approach where an application is constructed by customizing a standard framework with user-supplied handlers [Lew96]. Examples of this approach are Java AWT [Yu96], Taligent's CommonPoint [Tal96], and NeXT's OpenStep <ref> [Ne94] </ref>. 73 CHAPTER 4 PROPERTIES OF MEMBERSHIP SERVICES It is vital to maintain information about which computers are functioning and which have failed at any given time to build dependable distributed applications. This is often called the membership problem.
Reference: [Nel81] <author> B.J. Nelson. </author> <title> Remote Procedure Call. </title> <type> PhD thesis, </type> <institution> Dept of Computer Science, Carnegie-Mellon University, </institution> <address> Pittsburgh, PA, </address> <year> 1981. </year>
Reference-contexts: In particular, the failure model chosen would dictate which failure detection module is used and which information exchange module is used for communication between sites to ensure that the expected failure model cannot corrupt the data that is exchanged. 155 CHAPTER 7 GROUP REMOTE PROCEDURE CALL Remote Procedure Call (RPC) <ref> [BN84, Nel81] </ref> is a communication abstraction designed to simplify the writing of distributed programs. With RPC, a request for service from a client to a server process is structured to give synchronization semantics at the client similar to normal procedure call. <p> Simple RPC can be seen as a special case in this implementation, although in practice it would likely be implemented separately to obtain a more compact and efficient protocol. 7.2.1 Outline RPC services are typically structured along the lines described in Nelson's thesis <ref> [Nel81] </ref> consisting of the user (or client), user-stub (or client stub), the RPC communication package (RPC runtime), the server-stub and the server. The user (client) and server look like regular non-distributed programs, with the stubs masking the distribution and communication from the user and server.
Reference: [OIOP93] <author> H. Orman, E. Menze III, S. O'Malley, and L. Peterson. </author> <title> A fast and general implementation of Mach IPC in a network. </title> <booktitle> In Proceedings of the 3rd Usenix Mach Conference, </booktitle> <pages> pages 75-88, </pages> <month> Apr </month> <year> 1993. </year>
Reference-contexts: In asynchronous systems, it is impossible to have change detection that is both live and accurate [CT91, FLP85]. An example of an accurate detection that is not live is that of Mach, where the failed site notifies others about its own failure upon recovery <ref> [OIOP93] </ref>. Most membership services for asynchronous systems have chosen live but not accurate detection, for example, Isis [BSS91] and Consul [MPS93a]. The lack of accuracy in such systems comes from the use of timeouts to suspect the failure of a site, a technique that may trigger false suspicions. <p> Live detection is based on lack of response from a site, i.e., timeouts. Accurate detection, on the other hand, cannot be based on communication since the network is assumed to be asynchronous. As a result, our implementation, like that described in <ref> [OIOP93] </ref> for Mach, detects a site failure only when the failed site recovers and reestablishes communication. Similarly, accurate recovery detectionthe only kind possible in asynchronous systemsis implemented by the recovering site contacting other sites upon recovery as described in the previous section.
Reference: [OMG95a] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <year> 1995. </year>
Reference-contexts: The next major step for the C++ prototype is a distributed implementation, either based on UDP or distributed computing environments such as DCE [RKF93] or Corba <ref> [OMG95a, OMG95b] </ref>. The next major step for the x-kernel prototype is to port it to a version of the Mach operating system with features for supporting real time [TNR90, TN91]; this would make it feasible to deal with timeliness properties.
Reference: [OMG95b] <institution> Object Management Group. </institution> <month> CORBAservices: </month> <title> Common Object Services Specification, </title> <year> 1995. </year>
Reference-contexts: The next major step for the C++ prototype is a distributed implementation, either based on UDP or distributed computing environments such as DCE [RKF93] or Corba <ref> [OMG95a, OMG95b] </ref>. The next major step for the x-kernel prototype is to port it to a version of the Mach operating system with features for supporting real time [TNR90, TN91]; this would make it feasible to deal with timeliness properties.
Reference: [OP92] <author> S. O'Malley and L. Peterson. </author> <title> A dynamic network architecture. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(2) </volume> <pages> 110-143, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: The main emphasis of the OSI model is interoperability and configurability is mostly limited to choosing some execution parameters. Other projects in the communication field have taken more interest in configurability in addition to modularity. The x-kernel is a system for constructing networking subsystems <ref> [HP91, OP92] </ref>. As discussed in the context of Consul (section 2.1.2.1), the x-kernel supports hierarchical composition of communication protocols, such as the standard Internet protocols IP, TCP, and UDP, where each protocol is implemented as an independent module.
Reference: [Ous96] <author> J. Ousterhout. </author> <title> Why threads are a bad idea (for most purposes). </title> <booktitle> In 1996 USENIX Technical Conference, </booktitle> <month> Jan </month> <year> 1996. </year> <type> Invited Talk. </type>
Reference-contexts: For example, an x-kernel protocol can be seen as an event-driven entity with handlers for events such as push, pop, open, and close. Recent work also includes event services [GJS92, SB95, MSS96], event-based programming <ref> [Ous96] </ref>, and an event-based structuring approach where an application is constructed by customizing a standard framework with user-supplied handlers [Lew96].
Reference: [PA88] <author> M. Pucci and J. Alberi. </author> <title> Optimized communication in an extended remote procedure call model. </title> <journal> Computer architecture news, </journal> <volume> 16(4) </volume> <pages> 37-44, </pages> <month> Sep </month> <year> 1988. </year>
Reference-contexts: To simplify the presentation, we concentrate on RPC features related to distribution and fault tolerance. Other issues, although important, are not addressed here. These include stub generation and heterogeneity [Sun88, Gib87, HS87, Apo89, TB90, WSG91], binding [BN84, LT91, BALL90], performance or performance optimizations <ref> [PA88, RST89, SB90, BALL90] </ref>, and security issues [Bir85b].
Reference: [PBS89] <author> L. Peterson, N. Buchholz, and R. D. Schlichting. </author> <title> Preserving and using context information in interprocess communication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(3) </volume> <pages> 217-246, </pages> <month> Aug </month> <year> 1989. </year>
Reference-contexts: Psync <ref> [PBS89] </ref> realizes the functionality of a partially (or causally) ordered reliable multicast, while Order transforms that into either a total or semantic-dependent order. <p> Finally, note that the concept of a graph of messages is very appealing as an implementation tool as well. For example, this technique is closely related to the causality graphs used in Psync <ref> [PBS89] </ref> and Transis [ADKM92b], which capture the causal ordering relation between messages. 3.1.2 Relations between Properties Examining existing implementations of a service results in a set of properties for each implementation. <p> (M (C)) ^ IsCut (succ A (M (C)); O A ) ^ IsCut (succ B (M (C)); O B ) Among other things, this property is useful for determining message stability, where a message is stable at the sending site once it has been acknowledged by every other operational site <ref> [PBS89] </ref>. <p> Perhaps the simplest solution is to deliver such messages only to sites that were in the partition in which they were sent. This strategy is, however, contrary to the semantics implemented by systems such as Psync <ref> [PBS89] </ref>, which automatically propagates messages of this type to all sites for recovery purposes by virtue of its negative acknowledgment scheme for retransmitting lost messages. Extended virtual synchrony is an example of a stronger property that can be augmented to include partition handling messages. <p> These services are then summarized in tabular form in section 4.4.8. 105 4.4.2 Consul The membership service of the Consul system [MPS92, MPS93a] assumes asynchronous communication and sites that experience crash failures. The service is built using Psync <ref> [PBS89, MPS89] </ref>, a multicast service that preserves the causal ordering of messages using a context graph abstraction. Psync guarantees reliable multicast communication, so that context graphs on various sites are identical except for transmission delays.
Reference: [Pel93] <author> A. Pelc. </author> <title> Efficient distributed diagnosis in the presence of random faults. </title> <booktitle> In Proceedings of the 23rd Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 462 - 469, </pages> <month> Jun </month> <year> 1993. </year>
Reference-contexts: Furthermore, system diagnosis [PMC67], which deals with the problem of detecting faulty processors, is closely related to membership. System diagnosis assumes a failure model where faulty processors can be detected by executing a test program on the processor <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties [RFJ93, GT92, Hil95] to others that guarantee strong properties [BSS91, AMMS + 95, DMS95]. <p> On the basis of the responses, the outcome of the test is classified as pass or fail. In either case, the testing unit evaluates the tested unit as either fault-free or faulty. Numerous papers on system diagnosis have followed <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. Despite the close resemblance of the system diagnosis problem and the membership problem discussed in chapters 4 and 5, little has been done to compare or contrast these two fields. <p> This system model avoids many of the pitfalls of the PMC model, including the need for the complete tests, the permanent nature of faults, off-line testing, and an upper bound on the number of simultaneously faulty subunits. More recent work on probabilistic diagnosis can be found in <ref> [BP90a, BSM89, BP90b, LYS93, Pel93] </ref>. 6.2 Comparison We argue that the major differences between algorithms traditionally viewed as system diagnosis or membership are in the failure model and the strength of the properties provided by the service.
Reference: [PMC67] <author> F. Preparata, G. Metze, and R. Chien. </author> <title> On the connection assignment problem of diagnosable systems. </title> <journal> IEEE Transactions on Electronic Computer, </journal> <volume> EC-16(6):848-854, </volume> <month> Dec </month> <year> 1967. </year> <month> 218 </month>
Reference-contexts: Distinctions can also be made based on the failure model. A majority of the work is based on the assumption that only crash failures will occur, while [Rei96] is based on the Byzantine failure model. Furthermore, system diagnosis <ref> [PMC67] </ref>, which deals with the problem of detecting faulty processors, is closely related to membership. System diagnosis assumes a failure model where faulty processors can be detected by executing a test program on the processor [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95]. <p> modules and the event-driven model supported by the runtime system both enhance the overall configurability of the resulting system. 138 139 CHAPTER 6 MEMBERSHIP AND SYSTEM DIAGNOSIS System diagnosis is the problem of keeping track of which processing elements in a computing system are functioning correctly and which have failed <ref> [PMC67] </ref>. That paper stated that a system operating in a tightly or loosely coupled distributed environment must avoid giving tasks to or using results from faulty processing elements. <p> the conclusions, we outline how these observations could be utilized to construct a general configurable change detection and reporting service that could be configured to provide service guarantees similar to traditional membership and system diagnosis services. 140 6.1 System Diagnosis The so-called PMC model for system diagnosis was introduced in <ref> [PMC67] </ref>. The model uses a graph G (V,E) to model the system's testing convention. Subunits make up the set V, and directed edges in E represent one subunit applying a test to another subunit, i.e., the directed edge (A,B) denotes that A tests B. <p> Moreover, each subunit must be tested by at least t distinct other subunits. In the special case where no two subunits test each other, these necessary conditions are also sufficient for t-diagnosability [HA74]. In addition to the general model, <ref> [PMC67] </ref> gives a convenient testing subnetwork formulation for t-diagnosable systems that is used widely in later papers. <p> P i validates information from all fault-free P j 2 TESTED BY (P i ); 5. P i forwards the validated information and the results of all its tests to TESTERS OF (P i ). A good testing subnetwork for this algorithm is D 1t <ref> [PMC67] </ref>, since it minimizes the required tests and keeps the majority of the tests between local processors. As noted above, D 1t is t p self-diagnosable when t = t p + 1.
Reference: [PMI88] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The Synthesis kernel. </title> <journal> Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <year> 1988. </year>
Reference-contexts: Extensibility has been explored in the database community since the early 1980s, and has recently started to gain interest in the operating systems and networking communities. In databases, well-known examples include Genesis [BBG + 88] and Raid [BFHR90]. In operating systems, examples of configurable or extensible systems are Synthesis <ref> [PMI88] </ref>, SPIN [BCE + 94], Scout [MMO + 94a], and V++ [CD94]. Also, in file systems, configura-bility has been used to enable new application types, such as databases and multimedia, to make use of file systems efficiently for their storage needs [HP94, KN93, Maf94]. <p> Therefore, configurability and extensibility of both the abstractions provided by the operating systems and their implementations have recently been the targets of active research efforts. 44 The Synthesis system <ref> [PMI88] </ref> was one of the first projects to explore configurability and extensibility in the context of operating systems. Perhaps the key contribution of Synthesis is its use of optimization techniques from the area of dynamic code generation in its kernel design.
Reference: [Pow91] <editor> D. Powell, editor. Delta-4: </editor> <title> A Generic Architecture for Dependable Computing. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 <ref> [PSB + 88, BHV + 90, Pow91] </ref>, Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those
Reference: [Pow92] <author> D. Powell. </author> <title> Failure mode assumptions and assumption coverage. </title> <booktitle> In Proceedings of the 22nd IEEE Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 386-395, </pages> <year> 1992. </year>
Reference-contexts: Finally, the fail-stop failure model adds to the crash model the assumption that the component fails in a way that is detectable by other components [SS83]. A more thorough classification of failure models and their relations can be found in <ref> [Pow92] </ref>; numerous other classifications based on factors such as duration and cause have also been proposed [Lap92].
Reference: [PS88] <author> F. Panzieri and S. Shrivastava. Rajdoot: </author> <title> A remote procedure call mechanism supporting orphan detection and killing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-14(1):30-37, </volume> <month> Jan </month> <year> 1988. </year>
Reference-contexts: Options for dealing with orphans include interference avoidance, where the orphans finish their computation before the recovered client is allowed to issue new requests, and orphan termination, where orphans are terminated upon detection <ref> [PS88, Shr83] </ref>. Communication semantics specify properties about the communication between the client and server. Here, we concentrate on reliable communication, which can be implemented by message acknowledgments and retransmissions. <p> If the server has not responded by the deadline, the call returns with an indication of failure. Note that our classification of failure semantics subsumes more traditional distinctions, which can be summarized as follows <ref> [PS88] </ref>. At least once guarantees that if the invocation terminates normally, the remote procedure has been executed one or more times, and if it terminates abnormally, no conclusion is possible [Spe82]. <p> Exactly once appears to be the most popular in implemented systems. For example, it is the semantics chosen in Rajdoot <ref> [PS88] </ref>, Courier RPC [Xer81], OSI RPC [LH94]. Some systems guarantee at least once, such as [Mar89]. <p> For example, [BN84] corresponds to a service configured with RPC-Main, SynchronousCall, Acceptance (1), Collation (id), ReliableCommunication, and UniqueExecution. Rajdoot <ref> [PS88] </ref> corresponds to the same set, plus BoundedTermi-nation and TerminateOrphans. Among group RPC services, the one-to-many RPC described in [Coo85] corresponds to the set RPCMain, SynchronousCall, Acceptance (N), Collation with a function consisting of identity and comparison to detect inconsistencies at the server processes, ReliableCommunication, UniqueExecution, and TotalOrder.
Reference: [PSB + 88] <author> D. Powell, D. Seaton, G. Bonn, P. Verissimo, and F. Waeselynk. </author> <title> The Delta-4 approach to dependability in open distributed computing systems. </title> <booktitle> In Proceedings of the Eighteenth Symposium on Fault-Tolerant Computing, </booktitle> <address> Tokyo, </address> <month> Jun </month> <year> 1988. </year>
Reference-contexts: The omission failure model assumes a component may never respond to an input [CASD85]. The crash or fail-silent failure model assumes that the only way a component can fail is by ceasing to operate without making any incorrect state transitions <ref> [PSB + 88] </ref>. Finally, the fail-stop failure model adds to the crash model the assumption that the component fails in a way that is detectable by other components [SS83]. <p> A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 <ref> [PSB + 88, BHV + 90, Pow91] </ref>, Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 Isis The Isis system is a toolkit developed to support construction of distributed applications, including those
Reference: [RB91] <author> A. Ricciardi and K. Birman. </author> <title> Using process groups to implement failure detection in asynchronous environments. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 341-353, </pages> <address> Montreal, Quebec, Canada, </address> <month> Aug </month> <year> 1991. </year>
Reference-contexts: Note that ordering graphs are only one method for defining, describing, or illustrating properties of distributed systems. Another approach, used for example in <ref> [RB91] </ref>, is based on describing system behavior by process histories, where the history for process p is a sequence of events including send events, receive events, and internal events. A system run is a set of process histories, one for each process in the set of processes. <p> Typically, given an accurate detection, membership services do not generate spurious membership changes during the agreement phase, so accuracy is preserved. However, live detection is necessary but not sufficient to guarantee live service. For example, the membership protocol in Isis <ref> [RB91] </ref> that uses live detection based on timeouts has been shown not to be live in all situations [ACBMT95]. In synchronous systems, membership services are typically accurate and live [Cri91, KGR91]. <p> Thus, different levels of confidence can be defined by specifying how many sites must agree that a suspected change has occurred before a change indication is forwarded to the application. The possibilities range from a single site <ref> [RB91, RFJ93, SM94] </ref> to all functioning sites [MPS92]. In the following, single site suspicion is used to denote the former and consensus the latter. Any option between these two extremes is referred to as a voted decision. <p> One common approach is simply to assume they will not occur [Cri91, KGR91, MPS92]. This can be justified by increasing the connectivity of the network or by using other architectural assumptions. If this assumption is not valid, there are a number of ways to deal with multiple partitions <ref> [AMMS + 95, DMS94, DMS95, MAMSA94, RFJ93, RB91, SM94] </ref>. <p> The inconsistency can be avoided by requiring that computation continue only in one partition, such as the one with the majority of sites. We call this the majority operation policy. This approach has been chosen, for example, in <ref> [RB91, SM94] </ref>. The drawback of this approach, of course, is that it halts the application's execution in the rest of the system, thereby potentially affecting the progress or availability of the application. <p> Because of these properties, informing the application about a membership change is just a matter of multicasting the appropriate message using GBCAST. The Isis membership service has live failure detection based on single site suspicion. Although the service was assumed to be live <ref> [RB91] </ref>, it has later shown not to be live in all cases [ACBMT95]. Since GBCAST messages are totally ordered, the service realizes both total ordering of membership changes and virtual synchrony. <p> The various approaches for accomplishing this can be classified into three major categories: (1) broadcast based (e.g., [MPS93a, ADKM92b]), (2) coordinator based (e.g., <ref> [RB91, RFJ93] </ref>), and (3) token based (e.g., [RM89]). In examining each approach in light of our requirements, we selected the third based on the resulting simplicity of the micro-protocols. <p> This micro-protocol is distinct from ExtendedVirtualSynchrony since the predecessor sets of such messages are different in the sites in the two merging partitions. Other partition handling micro-protocols. In numerous membership services <ref> [Cri91, HS95, KT91, KGR91, MSMA94, MPS93a, RB91] </ref>, it is simply assumed that partitions will not occur, or that only one partition will continue to operate. The OnePartition micro-protocol implements a simple strategy that approximates this behavior.
Reference: [RB95] <author> R. van Renesse and K. Birman. </author> <title> Protocol composition in Horus. </title> <type> Technical Report TR95-1505, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> Mar </month> <year> 1995. </year>
Reference-contexts: Although configurable, the different choices available for the application builder are limited to different message-ordering properties. The Horus system provides similar services for distributed applications but with a higher degree of 29 configurability than Consul <ref> [RBG + 95, RB95, RBM96] </ref>. Both systems are oriented around hierarchical composition of code modules. 1.3 A New Model for Configurable Fault-Tolerant Services This dissertation presents a new approach to constructing configurable fault-tolerant services. <p> Similar problems were encountered in a project attempting a modular implementation of the xAMP atomic broadcast protocol suite in the x-kernel [RV92, Fon94]. 2.1.2.2 Horus Horus <ref> [RHB95, RBG + 95, RB95, RBM96] </ref> is a successor to the Isis system [Bir85a]. It is generally targeted for the same type of applications as Isis, but adds extensibility and 37 configurability. <p> A large number of other protocols exist, including ones that implement clock synchronization, remote procedure call, message logging, and encryption. The composition model is strongly motivated by that of x-kernel <ref> [RB95] </ref>, with the issue of the limited interface between protocols being addressed by expanding the standard interface to 16 downcalls and 14 upcalls.
Reference: [RBG + 95] <author> R. van Renesse, K. Birman, B. Glade, K. Guo, M. Hayden, T. Hickey, D. Malki, A. Vaysburd, and W. Vogels. Horus: </author> <title> A flexible group communications system. </title> <type> Technical Report TR95-1500, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1995. </year>
Reference-contexts: Although configurable, the different choices available for the application builder are limited to different message-ordering properties. The Horus system provides similar services for distributed applications but with a higher degree of 29 configurability than Consul <ref> [RBG + 95, RB95, RBM96] </ref>. Both systems are oriented around hierarchical composition of code modules. 1.3 A New Model for Configurable Fault-Tolerant Services This dissertation presents a new approach to constructing configurable fault-tolerant services. <p> Similar problems were encountered in a project attempting a modular implementation of the xAMP atomic broadcast protocol suite in the x-kernel [RV92, Fon94]. 2.1.2.2 Horus Horus <ref> [RHB95, RBG + 95, RB95, RBM96] </ref> is a successor to the Isis system [Bir85a]. It is generally targeted for the same type of applications as Isis, but adds extensibility and 37 configurability.
Reference: [RBM96] <author> R. van Renesse, K. Birman, and S Maffeis. Horus, </author> <title> a flexible group communication system. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 76-83, </pages> <month> Apr </month> <year> 1996. </year>
Reference-contexts: Although configurable, the different choices available for the application builder are limited to different message-ordering properties. The Horus system provides similar services for distributed applications but with a higher degree of 29 configurability than Consul <ref> [RBG + 95, RB95, RBM96] </ref>. Both systems are oriented around hierarchical composition of code modules. 1.3 A New Model for Configurable Fault-Tolerant Services This dissertation presents a new approach to constructing configurable fault-tolerant services. <p> Similar problems were encountered in a project attempting a modular implementation of the xAMP atomic broadcast protocol suite in the x-kernel [RV92, Fon94]. 2.1.2.2 Horus Horus <ref> [RHB95, RBG + 95, RB95, RBM96] </ref> is a successor to the Isis system [Bir85a]. It is generally targeted for the same type of applications as Isis, but adds extensibility and 37 configurability.
Reference: [Rei96] <author> M. Reiter. </author> <title> A secure group membership protocol. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(1) </volume> <pages> 31-42, </pages> <month> Jan </month> <year> 1996. </year>
Reference-contexts: Distinctions can also be made based on the failure model. A majority of the work is based on the assumption that only crash failures will occur, while <ref> [Rei96] </ref> is based on the Byzantine failure model. Furthermore, system diagnosis [PMC67], which deals with the problem of detecting faulty processors, is closely related to membership. <p> Any option between these two extremes is referred to as a voted decision. In general, the use of voted decisions has not been explored widely in the context of membership services. One exception is <ref> [Rei96] </ref>, where voting is used to handle Byzantine failures. 78 Note that detecting failure can be dealt with separately from detecting recovery. A typical solution in asynchronous systems is to have failure detection be live but not accurate, with recovery detection being accurate but not live. <p> Since membership algorithms typically are distributed by nature, the comparison here is concentrated on distributed system diagnosis. The failure model assumed by membership algorithms is in most cases either fail-stop, crash, or performance failures, although recently some work has been done assuming Byzantine failures <ref> [Rei96] </ref>. System diagnosis, on the other hand, seems, in most cases, to deal with a somewhat obscure failure model, namely one that can be detected by whichever test is employed by the system diagnosis algorithm.
Reference: [RFJ93] <author> R. Rajkumar, S. Fakhouri, and F. Jahanian. </author> <title> Processor group membership protocols: Specification, </title> <booktitle> design, and implementation. In Proceedings of the 12th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <address> Prince-ton, NJ, </address> <month> Oct </month> <year> 1993. </year> <month> 219 </month>
Reference-contexts: Also, in contrast to process histories, ordering graphs model more closely the execution of the system and allow the expression of all legal orderings of message receptions in one graph instead of stating them as properties of linear histories. Numerous other methods are also possible. For example, in <ref> [RFJ93] </ref> membership properties are stated in terms of membership runs, which are defined as sequences of global membership states consisting of each site's view of the global membership. Transitions from one global membership state to the next occur whenever a site changes its view of the global membership. <p> System diagnosis assumes a failure model where faulty processors can be detected by executing a test program on the processor [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95]. The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties <ref> [RFJ93, GT92, Hil95] </ref> to others that guarantee strong properties [BSS91, AMMS + 95, DMS95]. The tradeoff is the strength of the guarantee versus the execution cost. <p> Thus, different levels of confidence can be defined by specifying how many sites must agree that a suspected change has occurred before a change indication is forwarded to the application. The possibilities range from a single site <ref> [RB91, RFJ93, SM94] </ref> to all functioning sites [MPS92]. In the following, single site suspicion is used to denote the former and consensus the latter. Any option between these two extremes is referred to as a voted decision. <p> This property, although implemented by certain weak protocols such as <ref> [RFJ93] </ref>, is insufficient for implementing message ordering properties. Hence, for the remaining properties, we assume that regular agreement is guaranteed. <p> change properties extends ordering by adding bounds on when such changes must be applied. 4.2.4.1 External Synchrony External synchrony guarantees that if a site delivers a given membership change message, all other sites have either already delivered the message or are in a transition state in which delivery is imminent <ref> [RFJ93] </ref>. Having this property ensures that sites move into a new membership state with some degree of coordination, and that all sites have consistent membership information, modulo sites undergoing a transition. <p> The idea is, in fact, related to the concept of barrier synchronization in parallel programs, in which execution at all sites must reach the barrieri.e., move into the transition statebefore any site can proceed i.e., make the membership change. Following <ref> [RFJ93] </ref>, we denote this transition state as state 0. Since underlying layers interact with the application only through messages, any protocol implementing external synchrony requires an extra message to generate a transition into state 0. <p> One common approach is simply to assume they will not occur [Cri91, KGR91, MPS92]. This can be justified by increasing the connectivity of the network or by using other architectural assumptions. If this assumption is not valid, there are a number of ways to deal with multiple partitions <ref> [AMMS + 95, DMS94, DMS95, MAMSA94, RFJ93, RB91, SM94] </ref>. <p> Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs. We call services that follow this approach, including <ref> [Cri91, AMMS + 93, RFJ93, SR93] </ref>, set-based services. Although properties for the two types of services are typically stated differently, mappings between them can usually be constructed in a straightforward manner. <p> It also guarantees FIFO ordering of membership messages, extended virtual synchrony, and extended virtual synchrony with partitions. 4.4.7 Weak, Strong, and Hybrid Membership Protocols A family of three membership protocols labeled as weak, strong, and hybrid is described in <ref> [RFJ93] </ref>. All three deal only with ordering membership views and establishing agreement between views on different sites, with no attempt made to order membership changes with respect to application messages. <p> The various approaches for accomplishing this can be classified into three major categories: (1) broadcast based (e.g., [MPS93a, ADKM92b]), (2) coordinator based (e.g., <ref> [RB91, RFJ93] </ref>), and (3) token based (e.g., [RM89]). In examining each approach in light of our requirements, we selected the third based on the resulting simplicity of the micro-protocols. <p> Furthermore, our design emphasizes configurability and facilitates the construction of customized membership services, rather than implementing a single set of properties as does TMP. A number of membership and system diagnosis protocols organize sites into a logical ring structure without using a token. For example, the protocols in <ref> [RFJ93] </ref> use a ring to detect membership changes by having each site monitor its neighbor. Once a failure or recovery is detected, however, a membership protocol that employs a coordinator process is employed rather than using the ring. <p> Furthermore, as will be discussed in the following sections, the algorithm could be augmented to provide ordering and other properties. Although the algorithm uses similar ideas as some published membership algorithms 150 for example, using a logical ring structure <ref> [AMMS + 93, HS94a, RFJ93] </ref>the complete algorithm is different from any of which we are aware. In terms of message complexity it is very attractive. <p> This makes it easier for an application that utilizes the information from the system diagnosis service to deal with failures in the environment. 6.4.1 Family of Membership Algorithms As an example, we take the family of membership algorithms consisting of weak, strong, and hybrid described in <ref> [RFJ93] </ref> and briefly outlined in section 4.4.7. All the algorithms in this family assume an asynchronous communication network and processors that experience only crash failures.
Reference: [RHB95] <author> R. van Renesse, T. Hickey, and K. Birman. </author> <title> Design and performance of Horus: A lightweight group communications system. </title> <type> Technical Report TR94-1442, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> Aug </month> <year> 1995. </year>
Reference-contexts: Similar problems were encountered in a project attempting a modular implementation of the xAMP atomic broadcast protocol suite in the x-kernel [RV92, Fon94]. 2.1.2.2 Horus Horus <ref> [RHB95, RBG + 95, RB95, RBM96] </ref> is a successor to the Isis system [Bir85a]. It is generally targeted for the same type of applications as Isis, but adds extensibility and 37 configurability. <p> Also, while the standard interface syntactically allows protocols to be stacked in any order, most protocols require certain semantics from protocols below, imposing a partial order on the possible configurations <ref> [RHB95] </ref>. 2.1.2.3 ANSA ANSA (Advanced Networked Systems Architecture) is a software architecture for building distributed systems [Her89, Tea91, Her94]. ANSA provides a general computational model that defines how objects in a distributed system are specified and how objects interact.
Reference: [RKF93] <author> W. Rosenberry, D. Kenney, and G. Fisher. </author> <title> OSF Distributed Computing Environment: Understanding DCE. </title> <address> O'Reilly, </address> <year> 1993. </year>
Reference-contexts: The next major step for the C++ prototype is a distributed implementation, either based on UDP or distributed computing environments such as DCE <ref> [RKF93] </ref> or Corba [OMG95a, OMG95b]. The next major step for the x-kernel prototype is to port it to a version of the Mach operating system with features for supporting real time [TNR90, TN91]; this would make it feasible to deal with timeliness properties.
Reference: [RM89] <author> B. Rajagopalan and P. McKinley. </author> <title> A token-based protocol for reliable, ordered multicast communication. </title> <booktitle> In Proceedings of the 8th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 84-93, </pages> <address> Seattle, WA, </address> <month> Oct </month> <year> 1989. </year>
Reference-contexts: The various approaches for accomplishing this can be classified into three major categories: (1) broadcast based (e.g., [MPS93a, ADKM92b]), (2) coordinator based (e.g., [RB91, RFJ93]), and (3) token based (e.g., <ref> [RM89] </ref>). In examining each approach in light of our requirements, we selected the third based on the resulting simplicity of the micro-protocols. The basic idea behind this approach is to organize the group members into a (logical) ring and then have a token that circulates around the ring. <p> Schemes based on logical rings or token passing are used by many multicast, membership, and system diagnosis protocols. For example, token passing is used as a means of implementing reliable totally ordered multicast in the Reliable Broadcast Protocol [CM84], Token-Passing Multicast (TPM) protocol <ref> [RM89] </ref>, Multicasting Transport Protocol (MTP) [AFM92], Totem [AMMS + 95], Pinwheel [CM95], and Reliable Multicast Protocol (RMP) [WMK95].
Reference: [RSB90] <author> P. Ramanathan, K. G. Shin, and R. W. Butler. </author> <title> Fault-tolerant clock synchronization in distributed systems. </title> <journal> IEEE Computer, </journal> <volume> 23(10) </volume> <pages> 33-42, </pages> <month> Oct </month> <year> 1990. </year>
Reference-contexts: A time service provides consistent information about time in a distributed system, either in the form of logical or virtual time that can be used to reason about the relative order of events [Lam78, Sch82, 25 Mat89] or real time from synchronized clocks <ref> [KO87, WL88, RSB90, VR92] </ref>. Other important service abstractions are atomic actions, a collection of operations whose execution is indivisible despite concurrency and failures [Lam81, Lis85, SDP89]; and stable storage, storage whose contents is guaranteed to survive failures [Lam81, BY87]. Paradigms for structuring fault-tolerant software further simplify developing applications.
Reference: [RST89] <author> R. van Renesse, H. van Staveren, and A. Tanenbaum. </author> <title> Performance of the Amoeba distributed operating system. </title> <journal> Software Practice & Experience, </journal> <volume> 19 </volume> <pages> 223-234, </pages> <month> Mar </month> <year> 1989. </year>
Reference-contexts: The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba <ref> [RST89, KT91] </ref>, AMp and xAMp [VRB89, RV91, RV92], Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel <p> To simplify the presentation, we concentrate on RPC features related to distribution and fault tolerance. Other issues, although important, are not addressed here. These include stub generation and heterogeneity [Sun88, Gib87, HS87, Apo89, TB90, WSG91], binding [BN84, LT91, BALL90], performance or performance optimizations <ref> [PA88, RST89, SB90, BALL90] </ref>, and security issues [Bir85b].
Reference: [RSV94] <author> L. Rodrigues, E. Siegel, and P. Verissimo. </author> <title> A replication-transparent remote invocation protocol. </title> <booktitle> In Proceedings of the 13th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 160-169, </pages> <publisher> Dana Point, </publisher> <address> CA, </address> <month> Oct </month> <year> 1994. </year>
Reference-contexts: With RPC, a request for service from a client to a server process is structured to give synchronization semantics at the client similar to normal procedure call. Numerous examples of different RPC services and implementations exist, including Firefly RPC [SB90], Alphorn [AGH + 91], lightweight RPC [BALL90], Peregrine [JZ93], <ref> [RSV94] </ref>, and SUPRA-RPC [Sto94]. Among the commercial RPC packages released have been Courier from Xerox [Xer81], Sun RPC [Sun88], Netwise RPC from Novell Netware, and NCA from Apollo [Apo89]. [TA90] gives a survey of work in this area.
Reference: [RV91] <author> L. Rodrigues and P. Verissimo. xAMp: </author> <title> A multi-primitive group communications service. </title> <type> Technical report, </type> <institution> INESC, Lisboa, Portugal, </institution> <month> Sep </month> <year> 1991. </year>
Reference-contexts: The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp <ref> [VRB89, RV91, RV92] </ref>, Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1
Reference: [RV92] <author> L. Rodrigues and P. Verissimo. xAMP: </author> <title> a multi-primitive group communication service. </title> <booktitle> In Proceedings of the 11th Symposium on Reliable Distributed Systems, </booktitle> <address> Houston, TX, </address> <month> Oct </month> <year> 1992. </year>
Reference-contexts: The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp <ref> [VRB89, RV91, RV92] </ref>, Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1 <p> Similar problems were encountered in a project attempting a modular implementation of the xAMP atomic broadcast protocol suite in the x-kernel <ref> [RV92, Fon94] </ref>. 2.1.2.2 Horus Horus [RHB95, RBG + 95, RB95, RBM96] is a successor to the Isis system [Bir85a]. It is generally targeted for the same type of applications as Isis, but adds extensibility and 37 configurability.
Reference: [SA89] <author> A. Somani and V. Agarwal. </author> <title> Distributed syndrome decoding for regular interconnected structures. </title> <booktitle> In Proceedings of the 19th Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 70-77, </pages> <month> Jun </month> <year> 1989. </year>
Reference-contexts: It is shown that this property requires that any node be tested by at least t p + 1 nodes. For example, D 1t is t p self-diagnosable if t = t p + 1. More recent work on distributed diagnosis can be found in <ref> [BGN90, BB91, BB93, SA89, WHS95] </ref>. The first attempt at probabilistic diagnosis is in [MH76], which proposes assigning a reliability to each subunit in the network. This reliability measure is simply the probability of a fault occurring in a given subunit.
Reference: [SB90] <author> M. Schroeder and M. Burrows. </author> <title> Performance of Firefly RPC. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 1-17, </pages> <month> Feb </month> <year> 1990. </year>
Reference-contexts: With RPC, a request for service from a client to a server process is structured to give synchronization semantics at the client similar to normal procedure call. Numerous examples of different RPC services and implementations exist, including Firefly RPC <ref> [SB90] </ref>, Alphorn [AGH + 91], lightweight RPC [BALL90], Peregrine [JZ93], [RSV94], and SUPRA-RPC [Sto94]. Among the commercial RPC packages released have been Courier from Xerox [Xer81], Sun RPC [Sun88], Netwise RPC from Novell Netware, and NCA from Apollo [Apo89]. [TA90] gives a survey of work in this area. <p> To simplify the presentation, we concentrate on RPC features related to distribution and fault tolerance. Other issues, although important, are not addressed here. These include stub generation and heterogeneity [Sun88, Gib87, HS87, Apo89, TB90, WSG91], binding [BN84, LT91, BALL90], performance or performance optimizations <ref> [PA88, RST89, SB90, BALL90] </ref>, and security issues [Bir85b].
Reference: [SB95] <author> M. Spezialetti and S. Bernberg. EVEREST: </author> <title> An event recognition testbed. </title> <booktitle> In Proceedings of the 15th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 377-385, </pages> <address> Vancouver, BC, Canada, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: For example, an x-kernel protocol can be seen as an event-driven entity with handlers for events such as push, pop, open, and close. Recent work also includes event services <ref> [GJS92, SB95, MSS96] </ref>, event-based programming [Ous96], and an event-based structuring approach where an application is constructed by customizing a standard framework with user-supplied handlers [Lew96].
Reference: [SBB87] <author> K. Schwan, T. Bihari, and B. Blake. </author> <title> Adaptive, reliable software for distributed and parallel real-time systems. </title> <booktitle> In Proceedings of the 6th IEEE Symposium on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 32-42, </pages> <month> Mar </month> <year> 1987. </year> <month> 220 </month>
Reference-contexts: An approach 39 resembling the ANSA approach is described in [Bec94]. Here, a separate software layer completely hides the fault-tolerance aspects from applications. 2.1.2.4 Adaptive Parallel Real-time System Configurability and adaptability are explored in the context of reliable parallel and distributed real-time systems in <ref> [BS91, SBB87] </ref>. The goal is to build systems that change their structure, both offline and during operation, to maintain good performance in response to such events as failures and changes in request latencies and utilization. <p> The Transmission Control Protocol (TCP) of the Internet protocol suite uses adaptive mechanisms for flow control, retransmission, and congestion control [Jac88]. Other examples include concurrency control of database transactions [BFHR90], real-time parallel systems <ref> [BS91, SBB87] </ref>, operating systems [MS96], and high-speed communication protocols [SBS93]. Furthermore, as noted above, adaptive systems are important in the area of dependable computing [GGL93]. An example in this area is the SCOP (Self-Configuring Optimistic Programming) scheme [BDGX93], an adaptive version of N-version programming [Avi85].
Reference: [SBS93] <author> D. Schmidt, D. Box, and T. Suda. </author> <title> ADAPTIVE: A dynamically assembled protocol transformation, integration, and evaluation environment. </title> <journal> Con-currency: Practice and Experience, </journal> <volume> 5(4) </volume> <pages> 269-286, </pages> <month> Jun </month> <year> 1993. </year>
Reference-contexts: Also, in file systems, configura-bility has been used to enable new application types, such as databases and multimedia, to make use of file systems efficiently for their storage needs [HP94, KN93, Maf94]. In networking, the x-kernel [HP91] and Adaptive <ref> [SBS93] </ref> are examples of systems that support construction of customized communication protocols out of modules. All these systems are described further in chapter 2. Although numerous projects have investigated issues related to communication services for fault-tolerant distributed computing, only a few have explored modularity and configurability. <p> The x-kernel work has demonstrated that modular implementation can be efficient. For example, user-to-user communication latency in the x-kernel has been shown to be much less, often less than half, than that of Unix on identical hardware [HP91]. The Adaptive system <ref> [SBS93] </ref> proposes a configurable and adaptive framework for building communication protocols for applications like multi-media that have special requirements for quality of service. The model used by Adaptive is based on dividing the communication service into functions, with each function being implemented by a chosen protocol. <p> The Transmission Control Protocol (TCP) of the Internet protocol suite uses adaptive mechanisms for flow control, retransmission, and congestion control [Jac88]. Other examples include concurrency control of database transactions [BFHR90], real-time parallel systems [BS91, SBB87], operating systems [MS96], and high-speed communication protocols <ref> [SBS93] </ref>. Furthermore, as noted above, adaptive systems are important in the area of dependable computing [GGL93]. An example in this area is the SCOP (Self-Configuring Optimistic Programming) scheme [BDGX93], an adaptive version of N-version programming [Avi85].
Reference: [SCA94] <author> P. van der Stok, M. Claessen, and D. Alstein. </author> <title> A hierarchical membership protocol for synchronous distributed systems. </title> <editor> In K. Echtle, D. Hammer, and D. Powell, editors, </editor> <booktitle> Proceedings of the 1st European Dependable Computing Conference (Lecture Notes in Computer Science 852), </booktitle> <pages> pages 599-616, </pages> <address> Berlin, Germany, </address> <month> Oct </month> <year> 1994. </year>
Reference-contexts: Membership services have proven to be fundamental for constructing systems and applications. The existing work can be classified based on the assumptions about the system model. In particular, some membership services assume a synchronous system where bounds are placed on network transmission time <ref> [Cri91, KGR91, KG94, EL90, LE90, SCA94] </ref>, whereas other assume an asynchronous system where no such assumption is made [MSMA94, MAMSA94, DMS94, DMS95, EL95, AMMS + 93, MPS93a, RB91, SR93, ADKM92a, GT92, RFJ93, Bir85a, SM94, BDM95, CS95]. Distinctions can also be made based on the failure model. <p> Some of the work has been based on a synchronous system model, where bounds are placed on the network transmission time <ref> [Cri91, EL90, KGR91, LE90, SCA94] </ref>. Other work assumes an asynchronous model similar to that used in this chapter [ADKM92a, AMMS + 95, DMS94, EL95, GT92, MPS92, MPS93a, MAMSA94, RB91, SM94].
Reference: [SCF + 86] <author> P. Schwarz, W. Chang, J. Freytag, G. Lohman, J. McPherson, C. Mohan, and H. Pirahesh. </author> <title> Extensibility in the Starburst database system. </title> <booktitle> In Proceedings of the International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 85-93, </pages> <address> Asilomar, CA, </address> <month> Sep </month> <year> 1986. </year>
Reference-contexts: Extensible database systems, where the properties or their implementations can be adjusted to specific application requirements and execution 27 environments, have been developed to address some of these needs <ref> [SR86, SCF + 86, CD87, BBG + 88] </ref>. 1.2.4 Meeting Application Requirements Different fault-tolerant distributed applications have different requirements for the underlying services, so they should be able to select which properties are enforced. <p> Although specialized databases have been developed for these different application areas, exploiting configurability is an appealing alternative. Here, we outline two different configurable or extensible database systems. Numerous others, including Postgres [SR86], Starburst <ref> [SCF + 86] </ref>, Exodus [CD87], Gral [Gut89], Ream [KNKH89], and P2 [TB95], are not addressed here. The RAID system [BFHR90] has been used to study adaptive concurrency control.
Reference: [Sch82] <author> F. Schneider. </author> <title> Synchronization in distributed programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(2) </volume> <pages> 125-148, </pages> <month> Apr </month> <year> 1982. </year>
Reference-contexts: A time service provides consistent information about time in a distributed system, either in the form of logical or virtual time that can be used to reason about the relative order of events <ref> [Lam78, Sch82, 25 Mat89] </ref> or real time from synchronized clocks [KO87, WL88, RSB90, VR92]. Other important service abstractions are atomic actions, a collection of operations whose execution is indivisible despite concurrency and failures [Lam81, Lis85, SDP89]; and stable storage, storage whose contents is guaranteed to survive failures [Lam81, BY87].
Reference: [Sch90] <author> F. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-319, </pages> <month> Dec </month> <year> 1990. </year>
Reference-contexts: Paradigms for structuring fault-tolerant software further simplify developing applications. The replicated state machine approach is a paradigm for building fault-tolerant services using replication <ref> [Sch90] </ref>. A service is constructed using a collection of identical deterministic state machines, with client requests being sent to all replicas for execution using atomic ordered multicast. This approach is an example of active replication, where every replica executes the same operations. <p> This is especially true for applications that can be viewed as replicated state machines that change their state when they receive application messages and membership changes <ref> [Sch90] </ref>. 85 Note that, although virtual synchrony is closely related to agreement on successors and predecessors, it is not identical to combining these two properties. This follows because the combination does not require that every message be in one set or the other, whereas virtual synchrony does.
Reference: [SDP89] <author> S. Shrivastava, G. Dixon, and G. Parrington. </author> <title> An overview of Arjuna: A programming system for reliable distributed computing. </title> <type> Technical Report 298, </type> <institution> Computing Laboratory, University of Newcastle upon Tyne, </institution> <month> Nov </month> <year> 1989. </year>
Reference-contexts: Other important service abstractions are atomic actions, a collection of operations whose execution is indivisible despite concurrency and failures <ref> [Lam81, Lis85, SDP89] </ref>; and stable storage, storage whose contents is guaranteed to survive failures [Lam81, BY87]. Paradigms for structuring fault-tolerant software further simplify developing applications. The replicated state machine approach is a paradigm for building fault-tolerant services using replication [Sch90].
Reference: [SDP91] <author> S. Shrivastava, G. Dixon, and G. Parrington. </author> <title> An overview of the Arjuna distributed programming system. </title> <journal> IEEE Software, </journal> <volume> 8(1) </volume> <pages> 66-73, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: Therefore, it appears that the group communication framework is more of a conceptual framework than an actual implementation framework. 41 2.1.2.6 Arjuna The Arjuna system provides tools for constructing reliable distributed object-oriented applications <ref> [SDP91] </ref>. Arjuna is based on the object/action paradigm [Gra86], where applications are structured as atomic actions operating on persistent objects, i.e., objects that survive site crashes. Arjuna is implemented using C++, and uses the inheritance mechanism provided by the language extensively. <p> For example, it is the semantics chosen in Rajdoot [PS88], Courier RPC [Xer81], OSI RPC [LH94]. Some systems guarantee at least once, such as [Mar89]. At most once is rare because of the cost of implementation, although it is provided in both Atomic RPC [LG85] and Arjuna <ref> [SDP91] </ref>. 7.1.2 Group RPC Group RPC is any RPC service where the request is sent to more than one server that is, a server groupusing either multicast or point-to-point communication. Group RPC has numerous applications.
Reference: [Shr83] <author> S. Shrivastava. </author> <title> On the treatment of orphans in a distributed system. </title> <booktitle> In Proceedings of 3rd Symposium on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 155-162, </pages> <address> Florida, </address> <month> Oct </month> <year> 1983. </year>
Reference-contexts: Options for dealing with orphans include interference avoidance, where the orphans finish their computation before the recovered client is allowed to issue new requests, and orphan termination, where orphans are terminated upon detection <ref> [PS88, Shr83] </ref>. Communication semantics specify properties about the communication between the client and server. Here, we concentrate on reliable communication, which can be implemented by message acknowledgments and retransmissions.
Reference: [SM94] <author> L. Sabel and K. Marzullo. </author> <title> Simulating fail-stop in asynchronous distributed systems. </title> <booktitle> In Proceedings of the 13th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 138-147, </pages> <publisher> Dana Point, </publisher> <address> CA, </address> <month> Oct </month> <year> 1994. </year>
Reference-contexts: Thus, different levels of confidence can be defined by specifying how many sites must agree that a suspected change has occurred before a change indication is forwarded to the application. The possibilities range from a single site <ref> [RB91, RFJ93, SM94] </ref> to all functioning sites [MPS92]. In the following, single site suspicion is used to denote the former and consensus the latter. Any option between these two extremes is referred to as a voted decision. <p> One common approach is simply to assume they will not occur [Cri91, KGR91, MPS92]. This can be justified by increasing the connectivity of the network or by using other architectural assumptions. If this assumption is not valid, there are a number of ways to deal with multiple partitions <ref> [AMMS + 95, DMS94, DMS95, MAMSA94, RFJ93, RB91, SM94] </ref>. <p> The inconsistency can be avoided by requiring that computation continue only in one partition, such as the one with the majority of sites. We call this the majority operation policy. This approach has been chosen, for example, in <ref> [RB91, SM94] </ref>. The drawback of this approach, of course, is that it halts the application's execution in the rest of the system, thereby potentially affecting the progress or availability of the application.
Reference: [SMK + 94] <author> M. Satyanarayanan, H. Mashburn, P. Kumar, D. Steere, and J. Kistler. </author> <title> Lightweight recoverable virtual memory. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12(1) </volume> <pages> 33-57, </pages> <month> Feb </month> <year> 1994. </year>
Reference-contexts: Similarly, subsets of the ACID properties have been found to be useful for transactions in an operating system context <ref> [SMK + 94] </ref>.
Reference: [Spe82] <author> A. Spector. </author> <title> Performing remote operations efficiently on a local computer network. </title> <journal> Communications of the ACM, </journal> <volume> 25(17) </volume> <pages> 246-260, </pages> <month> Apr </month> <year> 1982. </year> <month> 221 </month>
Reference-contexts: Note that our classification of failure semantics subsumes more traditional distinctions, which can be summarized as follows [PS88]. At least once guarantees that if the invocation terminates normally, the remote procedure has been executed one or more times, and if it terminates abnormally, no conclusion is possible <ref> [Spe82] </ref>. Exactly once guarantees that if the invocation terminates normally, the remote procedure has been executed exactly one time, and if it terminates abnormally, no conclusion is possible other than that it has not been executed more than once.
Reference: [SR86] <author> M. Stonebraker and L. Rowe. </author> <title> The design of Postgres. </title> <booktitle> In Proceedings, ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 340-355, </pages> <year> 1986. </year>
Reference-contexts: Extensible database systems, where the properties or their implementations can be adjusted to specific application requirements and execution 27 environments, have been developed to address some of these needs <ref> [SR86, SCF + 86, CD87, BBG + 88] </ref>. 1.2.4 Meeting Application Requirements Different fault-tolerant distributed applications have different requirements for the underlying services, so they should be able to select which properties are enforced. <p> Although specialized databases have been developed for these different application areas, exploiting configurability is an appealing alternative. Here, we outline two different configurable or extensible database systems. Numerous others, including Postgres <ref> [SR86] </ref>, Starburst [SCF + 86], Exodus [CD87], Gral [Gut89], Ream [KNKH89], and P2 [TB95], are not addressed here. The RAID system [BFHR90] has been used to study adaptive concurrency control.
Reference: [SR93] <author> A. Schiper and A. Ricciardi. </author> <title> Virtually-synchronous communication based on a weak failure suspector. </title> <booktitle> In Proceedings of the 23rd Conference on Fault-Tolerant Computing, </booktitle> <pages> pages 534-543, </pages> <month> Jun </month> <year> 1993. </year>
Reference-contexts: Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs. We call services that follow this approach, including <ref> [Cri91, AMMS + 93, RFJ93, SR93] </ref>, set-based services. Although properties for the two types of services are typically stated differently, mappings between them can usually be constructed in a straightforward manner. <p> The way in which properties relate to one another was illustrated using dependency graphs. As noted in section 4.4, existing membership services can be characterized in terms of these properties. With the exception of <ref> [SR93] </ref>, however, membership papers concentrate on describing the properties of a particular algorithm or system, rather than providing a more global view. [SR93] gives a decomposition of membership services into three components: Failure Suspector, Multicast Component, and View Component. <p> As noted in section 4.4, existing membership services can be characterized in terms of these properties. With the exception of <ref> [SR93] </ref>, however, membership papers concentrate on describing the properties of a particular algorithm or system, rather than providing a more global view. [SR93] gives a decomposition of membership services into three components: Failure Suspector, Multicast Component, and View Component. The Failure Suspector is responsible for detecting membership changes and propagating changes that it has detected to other Failure Suspectors. In our framework, this corresponds to change detection properties.
Reference: [SS83] <author> R. D. Schlichting and F. B. Schneider. </author> <title> Fail-stop processors: An approach to designing fault tolerant computing systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 1(3) </volume> <pages> 222-238, </pages> <month> Aug </month> <year> 1983. </year>
Reference-contexts: Finally, the fail-stop failure model adds to the crash model the assumption that the component fails in a way that is detectable by other components <ref> [SS83] </ref>. A more thorough classification of failure models and their relations can be found in [Pow92]; numerous other classifications based on factors such as duration and cause have also been proposed [Lap92].
Reference: [SS94] <author> D. Schmidt and T. Suda. </author> <title> The service configurator framework: An extensible architecture for dynamically configuring concurrent, multi-service network daemons. </title> <booktitle> In Proceedings of the 2nd International Workshop on Configurable Distributed Systems, </booktitle> <pages> pages 190-201, </pages> <address> Pittsburgh, PE, </address> <year> 1994. </year>
Reference-contexts: Configuration is based on automatic selection of library modules that satisfy user requirementsexpressed either at compile time or during executionand the status of the underlying network. The work has also been extended to support construction of configurable network daemons <ref> [SS94] </ref>. 2.2.2 Operating Systems Several research projects in the area of operating systems are based on the premise that traditional operating system structuring limits the performance, flexibility, and functionality of applications. For example, [CFL94] demonstrates that application-level control of file cashing reduces application running time by 45%.
Reference: [Sto81] <author> M. Stonebraker. </author> <title> Operating system support for database management. </title> <journal> Communications of the ACM, </journal> <volume> 14(7), </volume> <month> Jul </month> <year> 1981. </year>
Reference-contexts: For example, the poor performance of traditional file systems for database applications has forced many database systems to 46 bypass the file system and implement their own storage system directly on the physical devices <ref> [Sto81, Mos86] </ref>. Traditional file systems are also less than ideal for multimedia applications. In particular, multimedia requires high I/O throughput rates and quality of service guarantees such as constant minimum data rates not typically provided by file systems [AOG92].
Reference: [Sto94] <author> A. Stoyenko. SUPRA-RPC: </author> <title> SUbprogram PaRAmeters in Remote Procedure Calls. </title> <journal> Software Practice & Experience, </journal> <volume> 24(1) </volume> <pages> 27-49, </pages> <month> Jan </month> <year> 1994. </year>
Reference-contexts: Numerous examples of different RPC services and implementations exist, including Firefly RPC [SB90], Alphorn [AGH + 91], lightweight RPC [BALL90], Peregrine [JZ93], [RSV94], and SUPRA-RPC <ref> [Sto94] </ref>. Among the commercial RPC packages released have been Courier from Xerox [Xer81], Sun RPC [Sun88], Netwise RPC from Novell Netware, and NCA from Apollo [Apo89]. [TA90] gives a survey of work in this area.
Reference: [Sun88] <author> Sun Microsystems. </author> <title> RPC: Remote procedure call protocol specification. </title> <type> Technical Report RFC-1057, </type> <institution> Sun Microsystems, </institution> <month> Jun </month> <year> 1988. </year>
Reference-contexts: Numerous examples of different RPC services and implementations exist, including Firefly RPC [SB90], Alphorn [AGH + 91], lightweight RPC [BALL90], Peregrine [JZ93], [RSV94], and SUPRA-RPC [Sto94]. Among the commercial RPC packages released have been Courier from Xerox [Xer81], Sun RPC <ref> [Sun88] </ref>, Netwise RPC from Novell Netware, and NCA from Apollo [Apo89]. [TA90] gives a survey of work in this area. On the surface, the semantics of RPC seem very simple, yet the reality is that there are subtleties and variations. <p> In this chapter, we apply our approach of constructing configurable fault-tolerant distributed services to group RPC. To simplify the presentation, we concentrate on RPC features related to distribution and fault tolerance. Other issues, although important, are not addressed here. These include stub generation and heterogeneity <ref> [Sun88, Gib87, HS87, Apo89, TB90, WSG91] </ref>, binding [BN84, LT91, BALL90], performance or performance optimizations [PA88, RST89, SB90, BALL90], and security issues [Bir85b].
Reference: [TA90] <author> B. Tay and A. Ananda. </author> <title> A survey of remote procedure calls. </title> <journal> ACM Operating Systems Review, </journal> <volume> 24(3) </volume> <pages> 68-79, </pages> <month> Jul </month> <year> 1990. </year>
Reference-contexts: Among the commercial RPC packages released have been Courier from Xerox [Xer81], Sun RPC [Sun88], Netwise RPC from Novell Netware, and NCA from Apollo [Apo89]. <ref> [TA90] </ref> gives a survey of work in this area. On the surface, the semantics of RPC seem very simple, yet the reality is that there are subtleties and variations. For example, there are many ways to define how an RPC service deals with server and communication failures.
Reference: [Tal96] <author> Taligent, Inc. </author> <title> CommonPoint Application System 1.0. </title> <address> http://www.- taligent.com/cpappsys/cpappsys.html, </address> <year> 1996. </year>
Reference-contexts: Recent work also includes event services [GJS92, SB95, MSS96], event-based programming [Ous96], and an event-based structuring approach where an application is constructed by customizing a standard framework with user-supplied handlers [Lew96]. Examples of this approach are Java AWT [Yu96], Taligent's CommonPoint <ref> [Tal96] </ref>, and NeXT's OpenStep [Ne94]. 73 CHAPTER 4 PROPERTIES OF MEMBERSHIP SERVICES It is vital to maintain information about which computers are functioning and which have failed at any given time to build dependable distributed applications. This is often called the membership problem.
Reference: [Tan88] <author> A. Tanenbaum. </author> <title> Computer Networks. </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1988. </year>
Reference-contexts: For example, in the case of communication protocols, the protocol defines the rules governing the format and meaning of the messages that are exchanged by peer layers residing on different machines to implement the service <ref> [Tan88] </ref>. Naturally, a service may be implemented using a number of different protocols as long as each can guarantee the specified service. The term service is also often used to denote the software that provides the particular service.
Reference: [TB90] <author> Y. Tham and S. Bhonsle. </author> <title> Retargetable stub generator for a remote procedure call facility. </title> <journal> Computer communications, </journal> <volume> 13(6) </volume> <pages> 323-330, </pages> <month> Jul </month> <year> 1990. </year>
Reference-contexts: In this chapter, we apply our approach of constructing configurable fault-tolerant distributed services to group RPC. To simplify the presentation, we concentrate on RPC features related to distribution and fault tolerance. Other issues, although important, are not addressed here. These include stub generation and heterogeneity <ref> [Sun88, Gib87, HS87, Apo89, TB90, WSG91] </ref>, binding [BN84, LT91, BALL90], performance or performance optimizations [PA88, RST89, SB90, BALL90], and security issues [Bir85b].
Reference: [TB95] <author> J. Thomas and D. Batory. P2: </author> <title> An extensible lightweight DBMS. </title> <type> Technical Report UTEXAS.CS//CS-TR-95-04, </type> <institution> The University of Texas at Austin, Department of Computer Sciences, </institution> <month> Feb </month> <year> 1995. </year>
Reference-contexts: Although specialized databases have been developed for these different application areas, exploiting configurability is an appealing alternative. Here, we outline two different configurable or extensible database systems. Numerous others, including Postgres [SR86], Starburst [SCF + 86], Exodus [CD87], Gral [Gut89], Ream [KNKH89], and P2 <ref> [TB95] </ref>, are not addressed here. The RAID system [BFHR90] has been used to study adaptive concurrency control. RAID is configurable in the sense that six componentsthe user interface, action driver, access manager, atomicity controller, concurrency controller, and replication controller provide a choice of algorithms for implementing their functionality.
Reference: [Tea91] <author> ISA Project Core Team. </author> <title> ANSA: Assumptions, </title> <booktitle> principles, and structures. In Proceedings of the Conference on Software Engineering Environments, </booktitle> <institution> University College of Wales, Aberystwyth, Wales, </institution> <month> Mar </month> <year> 1991. </year> <month> 222 </month>
Reference-contexts: Also, while the standard interface syntactically allows protocols to be stacked in any order, most protocols require certain semantics from protocols below, imposing a partial order on the possible configurations [RHB95]. 2.1.2.3 ANSA ANSA (Advanced Networked Systems Architecture) is a software architecture for building distributed systems <ref> [Her89, Tea91, Her94] </ref>. ANSA provides a general computational model that defines how objects in a distributed system are specified and how objects interact. <p> The transparency services in ANSA are not standalone building blocks such as the modules in some of the configurable services discussed so far. However, a given transparency can be added to an application level service by replacing the original service by a new service that includes the chosen transparency <ref> [Tea91] </ref>. Some mechanisms provided by ANSA, such as replication and transactions, make it easier to construct services enhanced with the chosen transparencies, but in general, the transparencies are not provided as configurable modules that could be combined with any arbitrary service.
Reference: [TL94] <author> C. Thekkath and H. Levy. </author> <title> Hardware and software support for efficient exception handling. </title> <booktitle> In Proceedings of the 6th International Conference on Architecture Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 110-121, </pages> <month> Oct </month> <year> 1994. </year>
Reference-contexts: For example, [CFL94] demonstrates that application-level control of file cashing reduces application running time by 45%. Similarly, application-specific virtual memory policies increase application performance [HC92, KLVA93], while exception handling is an order of magnitude faster if the signal handling is deferred to applications <ref> [TL94] </ref>. Therefore, configurability and extensibility of both the abstractions provided by the operating systems and their implementations have recently been the targets of active research efforts. 44 The Synthesis system [PMI88] was one of the first projects to explore configurability and extensibility in the context of operating systems.
Reference: [TN91] <author> H. Tokuda and T. Nakajima. </author> <title> Evaluation of real-time synchronization in Real-Time Mach. </title> <booktitle> In Proceedings of the USENIX 1991 Mach Workshop, </booktitle> <month> Oct </month> <year> 1991. </year>
Reference-contexts: The next major step for the x-kernel prototype is to port it to a version of the Mach operating system with features for supporting real time <ref> [TNR90, TN91] </ref>; this would make it feasible to deal with timeliness properties. Porting this prototype to the Scout operating system [MMO + 94a, MP96] might further improve performance over the current Mach implementation.
Reference: [TNR90] <author> H. Tokuda, T. Nakajima, and P. Rao. </author> <title> Real-Time Mach: Towards predictable real-time systems. </title> <booktitle> In Proceedings of the USENIX 1990 Mach Workshop, </booktitle> <month> Oct </month> <year> 1990. </year>
Reference-contexts: The next major step for the x-kernel prototype is to port it to a version of the Mach operating system with features for supporting real time <ref> [TNR90, TN91] </ref>; this would make it feasible to deal with timeliness properties. Porting this prototype to the Scout operating system [MMO + 94a, MP96] might further improve performance over the current Mach implementation.
Reference: [Toh86] <author> Y. Tohma. </author> <title> Coding techniques in fault-tolerant, self-checking, and failsafe circuits. </title> <editor> In D. Pradham, editor, </editor> <booktitle> Fault-Tolerant Computing: Theory and Techniques, </booktitle> <volume> Volume I, </volume> <pages> pages 336-416. </pages> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Error detecting codes are an example of redundancy where additional bits of information are added to data, such as memory, disks, or messages transmitted over a network, to detect errors <ref> [BM86, Toh86] </ref>. Redundancy can be divided into time and space redundancy. Time redundancy is based on using extra execution time, whereas space redundancy is based on using extra physical resources, such as extra memory, processors, disks, or communication links.
Reference: [TYT92] <author> T. Tenma, Y. Yokote, and M. Tokoro. </author> <title> Implementing persistent objects in the Apertos operating system. </title> <booktitle> In Proceedings of the 2nd International Workshop on Object Orientation in Operating Systems, </booktitle> <month> Sep </month> <year> 1992. </year>
Reference-contexts: In the following, we take a closer look at a number of these projects. Numerous others, such as Choices [CJK + 87, CIM92], the Kernel Tool Kit (KTK) [GMSS94, MS96], Kea [VH96], and Apertos <ref> [Yok92, Yok93, TYT92, IY94] </ref>, are not addressed here. The SPIN operating system is based on an extensible microkernel [BCE + 94, BSS + 95]. The microkernel exports interfaces that offer applications fine-grained control over a few fundamental system abstractions, such as threads and virtual address spaces.
Reference: [VH96] <author> A. Veitch and N Hutchinson. </author> <title> Kea a dynamically extensible and configurable operating system kernel. </title> <booktitle> In Proceedings of the 3rd International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 236-242, </pages> <address> Annapo-lis, Maryland, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: In the following, we take a closer look at a number of these projects. Numerous others, such as Choices [CJK + 87, CIM92], the Kernel Tool Kit (KTK) [GMSS94, MS96], Kea <ref> [VH96] </ref>, and Apertos [Yok92, Yok93, TYT92, IY94], are not addressed here. The SPIN operating system is based on an extensible microkernel [BCE + 94, BSS + 95]. The microkernel exports interfaces that offer applications fine-grained control over a few fundamental system abstractions, such as threads and virtual address spaces.
Reference: [VM90] <author> P. Verissimo and J. Marques. </author> <title> Reliable broadcast for fault-tolerance on local computer networks. </title> <booktitle> In Proceedings of the 9th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 54-63, </pages> <address> Huntsville, AL, </address> <month> Oct </month> <year> 1990. </year>
Reference-contexts: Although reliable communication is essential for building fault-tolerant distributed applications, more powerful services, often called middleware [Ber96], can further simplify the task. For example, an atomic ordered multicast or broadcast service with atomic-ity and message ordering guarantees makes it easy to send messages to a collection of processes <ref> [CM84, CZ85, CASD85, VM90, BSS91] </ref>. Similarly, a membership service provides consistent information about which computers are functioning and which have failed at any given time in a distributed system, thereby simplifying the problems associated with failures [Cri91, Bir85a, EL90, KGR91, MPS92]. <p> This information can be exploited to construct a variant of atomic multicast similar to those described in <ref> [KGR91, VM90] </ref> in which a message is only delivered to the application if it can be guaranteed to have been received at all sites to which it was addressed.
Reference: [VR92] <author> P. Verissimo and L. Rodrigues. </author> <title> A posteriori agreement for fault-tolerant clock synchronization on broadcast networks. </title> <booktitle> In Proceedings of the 22nd Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 527-536, </pages> <address> Boston, MA, </address> <month> Jul </month> <year> 1992. </year>
Reference-contexts: A time service provides consistent information about time in a distributed system, either in the form of logical or virtual time that can be used to reason about the relative order of events [Lam78, Sch82, 25 Mat89] or real time from synchronized clocks <ref> [KO87, WL88, RSB90, VR92] </ref>. Other important service abstractions are atomic actions, a collection of operations whose execution is indivisible despite concurrency and failures [Lam81, Lis85, SDP89]; and stable storage, storage whose contents is guaranteed to survive failures [Lam81, BY87]. Paradigms for structuring fault-tolerant software further simplify developing applications.
Reference: [VRB89] <author> P. Verissimo, L. Rodrigues, and M. Baptista. </author> <title> Amp: A highly parallel atomic multicast protocol. </title> <booktitle> In SIGCOMM'89, </booktitle> <pages> pages 83-93, </pages> <address> Austin, TX, </address> <month> Sep </month> <year> 1989. </year>
Reference-contexts: The configurable systems presented illustrate different approaches taken towards customization in fault-tolerant computing. A large number of other projects are not addressed in detail here, including ADS [IM84], Amoeba [RST89, KT91], AMp and xAMp <ref> [VRB89, RV91, RV92] </ref>, Argus [Lis85, Lis88], Avalon [DHW88], Chorus [BFG + 85], Clouds [DLA88, DLAR91], Delta-4 [PSB + 88, BHV + 90, Pow91], Saturne [DFF + 90], Totem [AMMS + 93, AMMS + 95, MMSA + 96], Transis and Lansis [ADKM92b, ADKM92a], and the V kernel [CZ85]. 2.1.1 Static Systems 2.1.1.1
Reference: [Whe89] <author> S. Wheater. </author> <title> Constructing Reliable Distributed Applications using Actions and Objects. </title> <type> PhD thesis, </type> <institution> The University of Newcastle upon Tyne Computing Laboratory, Newcastle upon Tyne, </institution> <address> England, </address> <month> Sept </month> <year> 1989. </year>
Reference-contexts: This approach is an example of passive replication. In the object/action paradigm, the system is constructed of passive objects that export actions, i.e., operations, that modify the state of objects [Gra86]. Applications of this approach to reliable computing are discussed in <ref> [Whe89] </ref>. In all these paradigms, communication-oriented services such as multicast and membership are key components of the supporting infrastructure. 1.2.3 Properties of Services Existing services can be characterized by the execution guarantees, or properties, they provide to their users. <p> Mechanisms needed for constructing reliable distributed applications are presented to users of Arjuna as objects. A predefined class hierarchy, shown in Figure 2.4, specifies system services such as atomic actions and locks, which can be manipulated using operations like any other object <ref> [Whe89] </ref>. New classes can be defined as derived classes of existing ones, thereby inheriting the properties of the parent class. Arjuna provides a service, called the ObjectStore, for storing objects persistently.
Reference: [WHS95] <author> C. Walter, M. Hugue, and N. Suri. </author> <title> Continual on-line diagnosis of hybrid faults. </title> <editor> In F. Cristian, G. Le Lann, and T. Lunt, editors, </editor> <booktitle> Dependable 223 Computing for Critical Applications 4, </booktitle> <pages> pages 233-249. </pages> <publisher> Springer-Verlag, Wien, </publisher> <year> 1995. </year>
Reference-contexts: Furthermore, system diagnosis [PMC67], which deals with the problem of detecting faulty processors, is closely related to membership. System diagnosis assumes a failure model where faulty processors can be detected by executing a test program on the processor <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. The different membership services provide a wide variety of different properties, ranging from ones that offer weak properties [RFJ93, GT92, Hil95] to others that guarantee strong properties [BSS91, AMMS + 95, DMS95]. <p> On the basis of the responses, the outcome of the test is classified as pass or fail. In either case, the testing unit evaluates the tested unit as either fault-free or faulty. Numerous papers on system diagnosis have followed <ref> [BMD93, BP90a, BGN90, BB91, BP90b, BB93, LYS93, Pel93, WHS95] </ref>. Despite the close resemblance of the system diagnosis problem and the membership problem discussed in chapters 4 and 5, little has been done to compare or contrast these two fields. <p> It is shown that this property requires that any node be tested by at least t p + 1 nodes. For example, D 1t is t p self-diagnosable if t = t p + 1. More recent work on distributed diagnosis can be found in <ref> [BGN90, BB91, BB93, SA89, WHS95] </ref>. The first attempt at probabilistic diagnosis is in [MH76], which proposes assigning a reliability to each subunit in the network. This reliability measure is simply the probability of a fault occurring in a given subunit. <p> A suggestion was made that techniques from membership algorithms could be used in system diagnosis algorithms to detect time domain failures and similarly techniques from system diagnosis algorithms could be used in membership algorithms to detect failures in the data domain. However, in practical system diagnosis algorithms, such as <ref> [BB91, BB93, WHS95] </ref>, lack of response is considered a failure, i.e., time domain failures are essentially detected as well.
Reference: [WL88] <author> J. Welch and N. Lynch. </author> <title> A new fault-tolerant algorithm for clock synchronization. </title> <journal> Information and Computation, </journal> <volume> 77(1) </volume> <pages> 1-36, </pages> <year> 1988. </year>
Reference-contexts: A time service provides consistent information about time in a distributed system, either in the form of logical or virtual time that can be used to reason about the relative order of events [Lam78, Sch82, 25 Mat89] or real time from synchronized clocks <ref> [KO87, WL88, RSB90, VR92] </ref>. Other important service abstractions are atomic actions, a collection of operations whose execution is indivisible despite concurrency and failures [Lam81, Lis85, SDP89]; and stable storage, storage whose contents is guaranteed to survive failures [Lam81, BY87]. Paradigms for structuring fault-tolerant software further simplify developing applications.
Reference: [WMK95] <author> B. Whetten, T. Montgomery, and S. Kaplan. </author> <title> A high performance totally ordered multicast protocol. </title> <editor> In K. Birman, F. Mattern, and A. Schiper, editors, </editor> <booktitle> Theory and Practice in Distributed Systems (Lecture Notes in Computer Science 938), </booktitle> <pages> pages 33-57. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: For example, token passing is used as a means of implementing reliable totally ordered multicast in the Reliable Broadcast Protocol [CM84], Token-Passing Multicast (TPM) protocol [RM89], Multicasting Transport Protocol (MTP) [AFM92], Totem [AMMS + 95], Pinwheel [CM95], and Reliable Multicast Protocol (RMP) <ref> [WMK95] </ref>. In these protocols, the site possessing the token is either the only site that is allowed to send a message or the site that assigns a global ordering to messages sent by all sites.
Reference: [WSG91] <author> Y.-H. Wei, A. Stoyenko, and G. Goldszmidt. </author> <title> The design of a stub generator for heterogeneous RPC systems. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 11(3) </volume> <pages> 188-197, </pages> <month> Mar </month> <year> 1991. </year>
Reference-contexts: In this chapter, we apply our approach of constructing configurable fault-tolerant distributed services to group RPC. To simplify the presentation, we concentrate on RPC features related to distribution and fault tolerance. Other issues, although important, are not addressed here. These include stub generation and heterogeneity <ref> [Sun88, Gib87, HS87, Apo89, TB90, WSG91] </ref>, binding [BN84, LT91, BALL90], performance or performance optimizations [PA88, RST89, SB90, BALL90], and security issues [Bir85b].
Reference: [WZZ93] <author> X. Wang, H. Zhao, and J. Zhu. GRPC: </author> <title> A communication cooperation mechanism in distributed systems. </title> <journal> Operating Systems Review, </journal> <volume> 27(3) </volume> <pages> 75-86, </pages> <month> Jul </month> <year> 1993. </year>
Reference-contexts: Group RPC has numerous applications. For example, it can be used to implement replicated servers to increase availability of the service in the event of failures, to implement parallel computation, or to improve response time. Examples of group or multicast RPC include <ref> [CGR88, Coo85, WZZ93, YJT88] </ref>. Here, we consider only one-to-many group RPC, in which one client uses RPC to invoke a procedure implemented by a server group. <p> This semantics is useful for getting one read-only response quickly and is used, for example, in the lookup RPC of GRPC <ref> [WZZ93] </ref>. At least once on all semantics is defined similarly, except that the invocation must have been executed on all server sites. Note that the number of sites where the call must succeed can be anything between one and all. <p> Among group RPC services, the one-to-many RPC described in [Coo85] corresponds to the set RPCMain, SynchronousCall, Acceptance (N), Collation with a function consisting of identity and comparison to detect inconsistencies at the server processes, ReliableCommunication, UniqueExecution, and TotalOrder. As an example of a very simple group RPC, lookup RPC <ref> [WZZ93] </ref> corresponds to RPCMain, SynchronousCall, Acceptance (1), and Collation (fid). Finally, note that the configuration graph does not map directly to the dependency graph of the properties given in Figure 7.1. One cause for differences are the typical transformations of dependencies into inclusion relations.
Reference: [Xer81] <author> Xerox. Courier: </author> <title> The remote procedure call protocol. </title> <type> Technical Report XSIS 038112, </type> <institution> Xerox System Integration Standard, Stamford, CT, </institution> <month> Dec </month> <year> 1981. </year>
Reference-contexts: Numerous examples of different RPC services and implementations exist, including Firefly RPC [SB90], Alphorn [AGH + 91], lightweight RPC [BALL90], Peregrine [JZ93], [RSV94], and SUPRA-RPC [Sto94]. Among the commercial RPC packages released have been Courier from Xerox <ref> [Xer81] </ref>, Sun RPC [Sun88], Netwise RPC from Novell Netware, and NCA from Apollo [Apo89]. [TA90] gives a survey of work in this area. On the surface, the semantics of RPC seem very simple, yet the reality is that there are subtleties and variations. <p> Exactly once appears to be the most popular in implemented systems. For example, it is the semantics chosen in Rajdoot [PS88], Courier RPC <ref> [Xer81] </ref>, OSI RPC [LH94]. Some systems guarantee at least once, such as [Mar89].
Reference: [YJT88] <author> K. Yap, P. Jalote, and S. Tripathi. </author> <title> Fault tolerant remote procedure call. </title> <booktitle> In Proceedings of the 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 48-54, </pages> <month> Jun </month> <year> 1988. </year>
Reference-contexts: Group RPC has numerous applications. For example, it can be used to implement replicated servers to increase availability of the service in the event of failures, to implement parallel computation, or to improve response time. Examples of group or multicast RPC include <ref> [CGR88, Coo85, WZZ93, YJT88] </ref>. Here, we consider only one-to-many group RPC, in which one client uses RPC to invoke a procedure implemented by a server group.
Reference: [Yok92] <author> Y. Yokote. </author> <title> The Apertos reflective operating system: The concepts and its implementation. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming, Systems, Languages, and Applications 1992, </booktitle> <address> Vancouver, BC, </address> <month> Oct </month> <year> 1992. </year>
Reference-contexts: In the following, we take a closer look at a number of these projects. Numerous others, such as Choices [CJK + 87, CIM92], the Kernel Tool Kit (KTK) [GMSS94, MS96], Kea [VH96], and Apertos <ref> [Yok92, Yok93, TYT92, IY94] </ref>, are not addressed here. The SPIN operating system is based on an extensible microkernel [BCE + 94, BSS + 95]. The microkernel exports interfaces that offer applications fine-grained control over a few fundamental system abstractions, such as threads and virtual address spaces.
Reference: [Yok93] <author> Y. Yokote. </author> <title> Kernel structuring for object-oriented operating systems: The Apertos approach. </title> <booktitle> In Proceedings of the International Symposium on Object Technologies for Advanced Software (ISOTAS), </booktitle> <month> Nov </month> <year> 1993. </year>
Reference-contexts: In the following, we take a closer look at a number of these projects. Numerous others, such as Choices [CJK + 87, CIM92], the Kernel Tool Kit (KTK) [GMSS94, MS96], Kea [VH96], and Apertos <ref> [Yok92, Yok93, TYT92, IY94] </ref>, are not addressed here. The SPIN operating system is based on an extensible microkernel [BCE + 94, BSS + 95]. The microkernel exports interfaces that offer applications fine-grained control over a few fundamental system abstractions, such as threads and virtual address spaces.
Reference: [Yu96] <author> N. Yu. </author> <title> The AWT tutorial. </title> <address> http://ugweb.cs.ualberta.ca/ nelson/java/- AWT.Tutorial.html, </address> <year> 1996. </year>
Reference-contexts: Recent work also includes event services [GJS92, SB95, MSS96], event-based programming [Ous96], and an event-based structuring approach where an application is constructed by customizing a standard framework with user-supplied handlers [Lew96]. Examples of this approach are Java AWT <ref> [Yu96] </ref>, Taligent's CommonPoint [Tal96], and NeXT's OpenStep [Ne94]. 73 CHAPTER 4 PROPERTIES OF MEMBERSHIP SERVICES It is vital to maintain information about which computers are functioning and which have failed at any given time to build dependable distributed applications. This is often called the membership problem.
References-found: 240

