URL: http://www.cs.tamu.edu/faculty/rwerger/MiniPolaris/1317.ps.gz
Refering-URL: http://www.cs.tamu.edu/faculty/rwerger/MiniPolaris/intro.html
Root-URL: http://www.cs.tamu.edu
Title: The Polaris Internal Representation  
Author: Keith A. Faigin Jay P. Hoeflinger David A. Padua Paul M. Petersen Stephen A. Weatherford 
Address: Urbana, Illinois, 61801  
Affiliation: Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign  
Date: February 18, 1994  
Abstract: The Polaris Program Manipulation System is a production quality tool for source-to-source transformations and complex analysis of Fortran code. In this paper we describe the motivations for and the design of Polaris' internal representation. The internal representation is composed of a basic abstract syntax tree on top of which exist many layers of functionality. This functionality allows complex operations on the data structure as well as allowing it to emulate other internal representations. Further, the internal representation is designed to enforce the consistency of the state of the internal structure in terms of both the correctness of the data structure and the correctness of the Fortran code being manipulated. In addition, operations on the internal representation result in the automatic updating of affected data structures such as flow information. We describe how the system's philosophies developed from its predecessor, the Delta prototyping system, and how they were implemented in Polaris' internal representation. We also provide a number of examples of using the Polaris system.
Abstract-found: 1
Intro-found: 1
Reference: [BBGN93] <author> F. Bodin, P. Beckman, D. Gannon, S. Narayana, S. Srinivas. Sage++: </author> <title> A Class Library for Building Fortran 90 and C ++ Restructuring Tools|DRAFT 0.1. </title> <year> 1993. </year>
Reference-contexts: Polaris has been used, so far, to implement passes for array privatization, induction variable substitution, forward substitution and inlining. Also, we are 2 Another object-oriented transformation system is the Sage++ system <ref> [BBGN93] </ref>.
Reference: [EHJL91] <author> Rudolph Eigenmann, Jay Hoeflinger, Greg Jaxon, Zhiyuan Li, and David Padua. </author> <title> Restructuring Fortran Programs for Cedar. </title> <booktitle> Proc. of the 1991 Int'l Conf. on Parallel Processing, </booktitle> <month> August, </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The goal of the Polaris system is to provide a new parallelizing compiler that is able to efficiently parallelize Fortran programs for a variety of machines, including massively parallel systems and parallel workstations [PEHP93]. Polaris is based on our past experiences with the Cedar Fortran project <ref> [EHJL91] </ref>. This project showed us that real programs can be parallelized efficiently and that the techniques needed to achieve good performance are natural extensions of technology available in current parallelizing compilers.
Reference: [KAII93] <author> Kuck and Associates. </author> <title> KAP for SPARC Fortran User's Guide. Beta Version 1.0, Document #9308006, </title> <year> 1993. </year>
Reference-contexts: Through an intermediate communication language, Polaris can capitalize on the strengths of other systems, such as Delta and KAP <ref> [KAII93] </ref>. Polaris has been used, so far, to implement passes for array privatization, induction variable substitution, forward substitution and inlining. Also, we are 2 Another object-oriented transformation system is the Sage++ system [BBGN93].
Reference: [Padu89] <author> David A. Padua. </author> <title> The Delta Program Manipulation system | Preliminary design. </title> <type> CSRD Report no. 808, </type> <institution> University of Illinois at Urbana-Champaign, Center for Supercomp. Res. & Dev., </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: This allows us to capitalize on our previous experiences with the KAP/Cedar parallelizing compiler and the Delta program manipulation system (Delta) <ref> [Padu89] </ref>. The implementation of Polaris is based on Delta which was created as an "open experimental laboratory" [PeJP92] in which to prototype, develop and test new source-to-source transformations for Fortran 77 parallelizing compilers. While Delta succeeded in providing an excellent research environment, it was not practical as a production compiler.
Reference: [PEHP93] <author> D. Padua, R. Eigenmann, J. Hoeflinger, P. Petersen, Peng Tu, S. Weatherford, and K. Faigin. </author> <title> Polaris: A New Generation Parallelizing Compiler for MPPs. </title> <type> CSRD Report No. 1306, </type> <institution> University of Illinois at Urbana-Champaign, Center for Supercomp. Res. & Dev., </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction The goal of the Polaris system is to provide a new parallelizing compiler that is able to efficiently parallelize Fortran programs for a variety of machines, including massively parallel systems and parallel workstations <ref> [PEHP93] </ref>. Polaris is based on our past experiences with the Cedar Fortran project [EHJL91]. This project showed us that real programs can be parallelized efficiently and that the techniques needed to achieve good performance are natural extensions of technology available in current parallelizing compilers.
Reference: [PeJP92] <author> Paul M. Petersen, Greg P. Jaxon, and David A. Padua. </author> <title> A Gentle Introduction to Delta. </title> <institution> University of Illinois at Urbana-Champaign, Center for Supercomp. Res. & Dev., </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: This allows us to capitalize on our previous experiences with the KAP/Cedar parallelizing compiler and the Delta program manipulation system (Delta) [Padu89]. The implementation of Polaris is based on Delta which was created as an "open experimental laboratory" <ref> [PeJP92] </ref> in which to prototype, develop and test new source-to-source transformations for Fortran 77 parallelizing compilers. While Delta succeeded in providing an excellent research environment, it was not practical as a production compiler.
Reference: [SDDS86] <author> J.T. Schwartz, R.B.K. Dewar, E. Dubinsky, and E. Schonberg. </author> <title> Programming with Sets: An Introduction to Setl. </title> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <month> 32 </month>
Reference-contexts: On top of this simple structure, however, we can build layers of functionality which allow the IR to emulate more complex forms. Specifically, such forms could include the constructs we found most useful in Delta and the language we used, SETL <ref> [SDDS86] </ref>. Delta, as an open system, provided the user with complete access to the internal representation. This was because the SETL implementation we used did not have a good data-abstraction mechanism.
References-found: 7

