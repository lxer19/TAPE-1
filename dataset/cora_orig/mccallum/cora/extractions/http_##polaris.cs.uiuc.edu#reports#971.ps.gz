URL: http://polaris.cs.uiuc.edu/reports/971.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/tech_reports.html
Root-URL: http://www.cs.uiuc.edu
Title: A Review of HDLs  
Author: Jose Eduardo Moreira Wilson Vicente Ruggiero Departamento de Engenharia de Eletricidade, Escola Politecnica da 
Note: This work was supported in part by the Interamerican Development Bank/University of S~ao Paulo project, and the U. S. Department of Energy under Grant No. DE-FG02-85ER25001. Jose E. Moreira is with Laboratorio de Sistemas Integraveis, and Wilson V. Ruggiero is with Laboratorio  
Date: February 1990  971  
Address: S~ao Paulo, Brasil  USA  
Affiliation: Universidade de  Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign,  de Sistemas Digitais  
Pubnum: CSRD Report No.  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Benhamin Atlas and Zary Segall. </author> <title> Behavior Analysis of ISPS Oriented Architecture, The RTMachine A Case Study. </title> <booktitle> In Proceedings of the IFIP WG 10.2 Sixth International Conference on Computer Hardware Description Languages and their Applications, </booktitle> <pages> pages 213-224, </pages> <address> Amsterdan, May 1983. </address> <publisher> North-Holland. </publisher>
Reference-contexts: We shall see that as we move towards higher 18 level of abstraction, we can no more count on such precise information. Most tools for RT level analysis are software programs for conventional computers, with some research in the area of specialized architectures <ref> [23, 1] </ref>. The arsenal of tools is not vast, but there are a myriad of languages for RT level description.
Reference: [2] <author> Jean-Loup Baer. </author> <title> Computer Systems Architecture. </title> <publisher> Computer Science Press, Inc, </publisher> <address> Rockville, Maryland, </address> <year> 1980. </year>
Reference-contexts: There is a well established notation for describing the ISP level, and it is called ISPS (Instruction Set Processor Specification). The language is well described in <ref> [37, 2, 6] </ref>. We will go back to ISPS in its own section. 5.2.7 Low and High Programming Level After one describes the machine language of a computer (in the ISP level), a series of abstractions can be built in the programming level. <p> The medium being processed is information, through events and transactions that take place in the components we mentioned. It is well known that is at this level that starts the conception of computing system, although in a rather informal way. The PMS notation, which is described in <ref> [37, 2] </ref> has been used for descriptions at this level, but it is mainly an structural notation, without the ability to specify transactions, events or actions in general. <p> It is presented here for its historical value, for its representativeness of a non-procedural class of 23 languages, and to be compared with more recent languages. Additional information (other than presented here) about CDL can be found in <ref> [11, 12, 2] </ref>; * AHPL A Hardware Description Language and ISPS Instruction Set Processor Specification. These two languages have successfully survived, and evolved, through a period of approximately 20 years. <p> They were chosen for this and for they are the two languages that most influenced LIDEX (a part from its direct antecedent, LIDER ). Additional Information about AHPL can be found in [21, 22, 20], and about ISPS in <ref> [6, 37, 2] </ref>; * VHDL - VHSIC Hardware Description Language. This one needs no justification. It is enforced by DoD, and it is becoming an industry standard. <p> It was one of the most successful languages of its time, and in 1975 both a simulator and a Boolean translator had been implemented [4]. CDL was more noted for its pedagogical properties than for its use in industrial environments <ref> [2] </ref>. And the reason might well be the lack of technology for implementing useful tools during the life-span of the language. <p> It does describe the ISP level successfully, but it does not go down to the RT level, so that details of execution timing are not available. ISPS has some ability of describing concurrent activities, but only at a particular step in the instruction interpretation algorithm. As Baer <ref> [2] </ref> has noticed, ISPS cannot describe overlapping of operations by different hardware units, which occurs so often and is so critical to performance of computers. In short, a "pure" ISPS description does not carry sufficient information for detailed performance analysis of the machine.
Reference: [3] <author> Kenneth Bakalar. </author> <title> Hardware Description Language Scuplts Comples Circuits. </title> <booktitle> Electronic Design, </booktitle> <pages> pages 119-124, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Fortunately, the scene is changing: VHDL brought some standardization (even if it was forced, it was beneficial)[30], allowed reasonably wide-spread automation at higher level of design than gate-level <ref> [3, 34, 30] </ref>, and new tools assure that complex systems, built of many VLSI chips work correctly [17]. <p> The development of VHDL began in 1983, sponsored by the Air Force. By the the end of 1985, a draft specification of VHDL version 7.2 was available, after participation of government, industry and universities in the process <ref> [3] </ref>. In January of 1986, the IEEE organized the VHDL Analysis and Standardization Group (VASG), with the mission of creating a standard hardware description language based on VHDL 7.2. In December 1987, after an extensive industry involvement, the IEEE ratified the final standard, designated VHDL 1076-1987. <p> variable Temp:Bit; begin Temp := '1'; for i in Inputs'Range loop if Inputs (i) = '0' then Temp := '0'; 37 exit; end if; end loop; Result &lt;= Temp after 10ns; end process; end Behavior; We are going to explore a few more concepts of VHDL through an example from <ref> [3] </ref>. The example is the description of a memory board, with 64 kwords (8-bit) of ROM.
Reference: [4] <author> Mario R. Barbacci. </author> <title> A Comparison of Register Transfer Languages for Describing Computers and Digital Systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-24(2):137-150, </volume> <month> February </month> <year> 1975. </year>
Reference-contexts: Nowadays any tool that is not computer assisted is of little worth discussing. The urge for a break-through of HDL use in design practice has been recognized several times, recently [18] and not so recently <ref> [4] </ref>. The RT level was recognized as a valid design level back in the early 50's, and by 1975 there were a few implemented and operational HDLs [4]. <p> The urge for a break-through of HDL use in design practice has been recognized several times, recently [18] and not so recently <ref> [4] </ref>. The RT level was recognized as a valid design level back in the early 50's, and by 1975 there were a few implemented and operational HDLs [4]. By 1987, several hundred of these languages had been published and a dozen new were added every year, even though most of them do not survive long, due to lack of good implementation (or no implementation at all), or other reasons [19]. <p> Indeed, conventional programming languages can be used to describe digital systems. Fortran can be used <ref> [4] </ref>, Ada has been used [7], as Occam [28] and APL, notably at IBM [4], have, and VALID uses Pascal or C to describe digital systems at a higher-abstraction level than it is possible with its schematic-capture language [40]. <p> Indeed, conventional programming languages can be used to describe digital systems. Fortran can be used <ref> [4] </ref>, Ada has been used [7], as Occam [28] and APL, notably at IBM [4], have, and VALID uses Pascal or C to describe digital systems at a higher-abstraction level than it is possible with its schematic-capture language [40]. Nevertheless, special notations should be used for HDLs, for digital systems have their own particularities which must be observed and easily represented in the notation. <p> Nevertheless, special notations should be used for HDLs, for digital systems have their own particularities which must be observed and easily represented in the notation. As we already commented, the notation a designer uses to express a design has a strong influence upon him or her. According to Barbacci <ref> [4] </ref>, the main motivation is that: "Complexity 9 diminishes and clarity increases to a marked degree if algorithms are described in a language in which appropriate control structures are primitive or easily expressible" [16]. This is a general requirement for programming languages. <p> Hartenstein [18] and Barbacci <ref> [4] </ref> define the following requirements for HDLs: 1. Readability and Comprehensibility: An HDL is to be used as a means of transmitting information between human and machine, among humans and among machines. Machines usually don't care much about the style of a language, but humans do. <p> Actually, instead of registers, the more general concept of carrier <ref> [4] </ref> (which includes wires and busses) is used (the register transfer level is further explained in the section Characterization of the RT Level. At the RT level, the system undergoes discrete operations, by which values stored in registers are transformed and combined, and the resulting values again stored in registers. <p> It was one of the most successful languages of its time, and in 1975 both a simulator and a Boolean translator had been implemented <ref> [4] </ref>. CDL was more noted for its pedagogical properties than for its use in industrial environments [2]. And the reason might well be the lack of technology for implementing useful tools during the life-span of the language. <p> This counter executes the functions of counting up, clearing, and loading. The AHPL description of this counter is as follows (from [20]): FUNCTREG: COUNTER (load, enp, ent, clear; DATA) begin declarations DATA INPUT: DATA <ref> [4] </ref> CONTROL INPUTS: load, enp, ent, clear OUTPUTS: COUNTER [5] MEMORY: D [4] CLUNITS: INC [4] end declarations begin D * ((enp ^ ent) _ load) (INC (D)!DATA)*((enp ^ ent ^ load), load); D * clear 0, 0, 0, 0; COUNTER = ent ^ (^ /D),D end The body is a <p> This counter executes the functions of counting up, clearing, and loading. The AHPL description of this counter is as follows (from [20]): FUNCTREG: COUNTER (load, enp, ent, clear; DATA) begin declarations DATA INPUT: DATA <ref> [4] </ref> CONTROL INPUTS: load, enp, ent, clear OUTPUTS: COUNTER [5] MEMORY: D [4] CLUNITS: INC [4] end declarations begin D * ((enp ^ ent) _ load) (INC (D)!DATA)*((enp ^ ent ^ load), load); D * clear 0, 0, 0, 0; COUNTER = ent ^ (^ /D),D end The body is a list of three statements that take place each clock cycle, provided that <p> This counter executes the functions of counting up, clearing, and loading. The AHPL description of this counter is as follows (from [20]): FUNCTREG: COUNTER (load, enp, ent, clear; DATA) begin declarations DATA INPUT: DATA <ref> [4] </ref> CONTROL INPUTS: load, enp, ent, clear OUTPUTS: COUNTER [5] MEMORY: D [4] CLUNITS: INC [4] end declarations begin D * ((enp ^ ent) _ load) (INC (D)!DATA)*((enp ^ ent ^ load), load); D * clear 0, 0, 0, 0; COUNTER = ent ^ (^ /D),D end The body is a list of three statements that take place each clock cycle, provided that the necessary condition <p> The original ISP notation [9] was initially developed to describe the primitives of the programming level of design <ref> [4] </ref>, that is, how the computer executes its machine instructions. The notation evolved first into the language ISPL [5] and then into the more powerful ISPS [6]. ISPS supports a wide range of applications areas, rather than a wide range of abstraction levels.
Reference: [5] <author> Mario R. Barbacci. </author> <title> The ISPL Compiler and Simulator User's Manual. </title> <type> Technical report, </type> <institution> Carnegie Mellon University, Department of Computer Science, </institution> <address> Pittsburgh, PA, </address> <year> 1976. </year>
Reference-contexts: This counter executes the functions of counting up, clearing, and loading. The AHPL description of this counter is as follows (from [20]): FUNCTREG: COUNTER (load, enp, ent, clear; DATA) begin declarations DATA INPUT: DATA [4] CONTROL INPUTS: load, enp, ent, clear OUTPUTS: COUNTER <ref> [5] </ref> MEMORY: D [4] CLUNITS: INC [4] end declarations begin D * ((enp ^ ent) _ load) (INC (D)!DATA)*((enp ^ ent ^ load), load); D * clear 0, 0, 0, 0; COUNTER = ent ^ (^ /D),D end The body is a list of three statements that take place each clock <p> The original ISP notation [9] was initially developed to describe the primitives of the programming level of design [4], that is, how the computer executes its machine instructions. The notation evolved first into the language ISPL <ref> [5] </ref> and then into the more powerful ISPS [6]. ISPS supports a wide range of applications areas, rather than a wide range of abstraction levels. Indeed, its applications [6] includes automated design, simulation (for both software development and hardware debugging, and automatic generation of machine related software (in particular, compiler-compilers).
Reference: [6] <author> Mario R. Barbacci. </author> <title> Instruction Set Processor Specification (ISPS): The Notation and Its Applications. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-30(1):24-40, </volume> <month> January </month> <year> 1981. </year>
Reference-contexts: There is a well established notation for describing the ISP level, and it is called ISPS (Instruction Set Processor Specification). The language is well described in <ref> [37, 2, 6] </ref>. We will go back to ISPS in its own section. 5.2.7 Low and High Programming Level After one describes the machine language of a computer (in the ISP level), a series of abstractions can be built in the programming level. <p> They were chosen for this and for they are the two languages that most influenced LIDEX (a part from its direct antecedent, LIDER ). Additional Information about AHPL can be found in [21, 22, 20], and about ISPS in <ref> [6, 37, 2] </ref>; * VHDL - VHSIC Hardware Description Language. This one needs no justification. It is enforced by DoD, and it is becoming an industry standard. <p> Even for computer organization design, the language is convenient for a well-refined, near switching circuit level, description. 30 8.3 Instruction Set Processor Specifications (ISPS) 8.3.1 Introduction The development of ISPS is part of the research on the Symbolic Manipulation of Computer Descriptions effort at Carnegie Mellon University, Pittsburgh, PA <ref> [6] </ref>. The original ISP notation [9] was initially developed to describe the primitives of the programming level of design [4], that is, how the computer executes its machine instructions. The notation evolved first into the language ISPL [5] and then into the more powerful ISPS [6]. <p> Carnegie Mellon University, Pittsburgh, PA <ref> [6] </ref>. The original ISP notation [9] was initially developed to describe the primitives of the programming level of design [4], that is, how the computer executes its machine instructions. The notation evolved first into the language ISPL [5] and then into the more powerful ISPS [6]. ISPS supports a wide range of applications areas, rather than a wide range of abstraction levels. Indeed, its applications [6] includes automated design, simulation (for both software development and hardware debugging, and automatic generation of machine related software (in particular, compiler-compilers). <p> The notation evolved first into the language ISPL [5] and then into the more powerful ISPS <ref> [6] </ref>. ISPS supports a wide range of applications areas, rather than a wide range of abstraction levels. Indeed, its applications [6] includes automated design, simulation (for both software development and hardware debugging, and automatic generation of machine related software (in particular, compiler-compilers). <p> We will discuss aspects of the kernel language ISPS, without regard for the application-specific information, as it is presented in <ref> [6] </ref>. 8.3.2 Major Language Structures ISPS describes the structure and behavior of of hardware units (called entities in the language), with emphasis on the behavioral aspects. The structure of an entity is represented as a set of carriers, which are registers or registers arrays.
Reference: [7] <author> Mario R. Barbacci et al. </author> <title> Ada as a Hardware Description Language: An Initial Report. </title> <booktitle> In Proceedings of the IFIP WG 10.2 Seventh International Conference on Computer Hardware Description Languages and their Applications, </booktitle> <pages> pages 272-302, </pages> <address> Amsterdan, </address> <month> August </month> <year> 1985. </year> <pages> North-Holland. </pages>
Reference-contexts: Indeed, conventional programming languages can be used to describe digital systems. Fortran can be used [4], Ada has been used <ref> [7] </ref>, as Occam [28] and APL, notably at IBM [4], have, and VALID uses Pascal or C to describe digital systems at a higher-abstraction level than it is possible with its schematic-capture language [40].
Reference: [8] <author> Daniel K. Beece et al. </author> <title> The IBM Engineering Verification Engine. </title> <booktitle> In Proceedings of the 25th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 218-224, </pages> <address> Anaheim Convention Center, June 1988. </address> <publisher> Computer Society Press. </publisher>
Reference-contexts: One can make use of a special simulator machine, like the IBM Engineering Verification Engine <ref> [8] </ref>, which will deliver a few billion gate-evaluations per second, but this is not a cheap or wise (is it the same thing?) way to solve the problem, and it does not solve at all, it merely postpones it to the time a more complex evaluation is necessary. <p> The analysis of gate level models of digital systems has available the largest resource of automation tools, which range from software programs for gate level simulation and timing analysis (notably for workstations [40]), to special hardware accelerators for workstations [33] and dedicated computer architectures <ref> [8] </ref>. <p> We will not go into the details of the processor and memory modules. STRUCTURE: DISTRIBUTED PROCESS begin declarations FOR i = 0 TO 3 MODULES: Processor_i; Ram_i. COMBUS: DBUSP_i <ref> [8] </ref>; DBUSM_i [8]. ROF end declarations begin definitions MODULE: Processor begin declarations OUTPUTS: readwriteP; ADDRP [16]. COMBUS: DBUSP_i [8]. end declarations end module MODULE: RAM begin declarations INPUTS: ADDRM [14]; readwriteM. COMBUS: DBUSM [8]. end declaration end module end definitions 29 begin FOR i = 0 TO 3 CONSTRUCT DBUSM_i :=: <p> We will not go into the details of the processor and memory modules. STRUCTURE: DISTRIBUTED PROCESS begin declarations FOR i = 0 TO 3 MODULES: Processor_i; Ram_i. COMBUS: DBUSP_i <ref> [8] </ref>; DBUSM_i [8]. ROF end declarations begin definitions MODULE: Processor begin declarations OUTPUTS: readwriteP; ADDRP [16]. COMBUS: DBUSP_i [8]. end declarations end module MODULE: RAM begin declarations INPUTS: ADDRM [14]; readwriteM. COMBUS: DBUSM [8]. end declaration end module end definitions 29 begin FOR i = 0 TO 3 CONSTRUCT DBUSM_i :=: DBUSP_i ROF <p> We will not go into the details of the processor and memory modules. STRUCTURE: DISTRIBUTED PROCESS begin declarations FOR i = 0 TO 3 MODULES: Processor_i; Ram_i. COMBUS: DBUSP_i <ref> [8] </ref>; DBUSM_i [8]. ROF end declarations begin definitions MODULE: Processor begin declarations OUTPUTS: readwriteP; ADDRP [16]. COMBUS: DBUSP_i [8]. end declarations end module MODULE: RAM begin declarations INPUTS: ADDRM [14]; readwriteM. COMBUS: DBUSM [8]. end declaration end module end definitions 29 begin FOR i = 0 TO 3 CONSTRUCT DBUSM_i :=: DBUSP_i ROF FOR i = 0 TO 3 CONSTRUCT ADDRM_i = ADDRP_i [2:15] ROF FOR i = 0 <p> STRUCTURE: DISTRIBUTED PROCESS begin declarations FOR i = 0 TO 3 MODULES: Processor_i; Ram_i. COMBUS: DBUSP_i <ref> [8] </ref>; DBUSM_i [8]. ROF end declarations begin definitions MODULE: Processor begin declarations OUTPUTS: readwriteP; ADDRP [16]. COMBUS: DBUSP_i [8]. end declarations end module MODULE: RAM begin declarations INPUTS: ADDRM [14]; readwriteM. COMBUS: DBUSM [8]. end declaration end module end definitions 29 begin FOR i = 0 TO 3 CONSTRUCT DBUSM_i :=: DBUSP_i ROF FOR i = 0 TO 3 CONSTRUCT ADDRM_i = ADDRP_i [2:15] ROF FOR i = 0 TO 3 CONSTRUCT ADDRM_0 = ADDRP_i [2:15] ROF FOR i = 0 TO 3 CONSTRUCT
Reference: [9] <author> C. Gordon Bell and Allen Newell. </author> <title> Computer Structures: Readings and Examples. </title> <publisher> McGraw-Hill Book Company, </publisher> <address> New York, </address> <year> 1971. </year>
Reference-contexts: The original ISP notation <ref> [9] </ref> was initially developed to describe the primitives of the programming level of design [4], that is, how the computer executes its machine instructions. The notation evolved first into the language ISPL [5] and then into the more powerful ISPS [6].
Reference: [10] <institution> Center for Supercomputing Research and Development. Computational Science and Engineering at the University of Illinois at Urbana-Champaign, </institution> <year> 1989. </year>
Reference-contexts: In spite of this fast evolution, the fields of computer science, computer engineering and the new emerging field of computational science and engineering, which encompasses the the effective use of software, hardware and mathematics to solve real problems <ref> [10] </ref>, still have a long way to go, for although advanced computer systems are used today to solve very complex engineering and scientific problems, performance is usually bad, the machines are hard to use, costs of high-performance computers are in the millions of dollars, and the time to design a new <p> level, must be brought to existence and use to higher and more practical levels, to "allow better, faster, easier-to-use computer systems to be designed and built more quickly and straightforwardly than they are today, and to ensure that these systems are used effectively in all areas of science and engineering <ref> [10] </ref>." 2 The Need for HDLs Last year (1989) a few 1-million transistors CPUs chips were announced: the i860 and i486 (both already in commercial use) and the MC68040 (expected for the first semester of this year). <p> However, there aren't up to now many applications of HDLs in this field, for architectural experimentation is extremely expensive in computer resources. With the ever increasing performance of computer systems and the ability to use them effectively <ref> [10] </ref> we can hope that in the near future we will be able to play, in front of a workstation, with several different alternatives for a computer. 4 Requirements for HDLs HDLs are programming languages. Indeed, conventional programming languages can be used to describe digital systems.
Reference: [11] <author> Y. Chu. </author> <title> An Algol-like Computer Design Language. </title> <journal> Communications of the ACM, </journal> <volume> 8(10) </volume> <pages> 607-615, </pages> <month> October </month> <year> 1965. </year>
Reference-contexts: It is presented here for its historical value, for its representativeness of a non-procedural class of 23 languages, and to be compared with more recent languages. Additional information (other than presented here) about CDL can be found in <ref> [11, 12, 2] </ref>; * AHPL A Hardware Description Language and ISPS Instruction Set Processor Specification. These two languages have successfully survived, and evolved, through a period of approximately 20 years. <p> This one needs no justification. It is enforced by DoD, and it is becoming an industry standard. More information on VHDL from [25]. 8.1 Computer Design Language (CDL) 8.1.1 Introduction CDL <ref> [11, 12] </ref> is one of the oldest HDLs, dating back to 1965. It was one of the most successful languages of its time, and in 1975 both a simulator and a Boolean translator had been implemented [4].
Reference: [12] <author> Y. Chu. </author> <title> Introducing the Computer Design Language. </title> <booktitle> In Proceedings of the IEEE Computer Conference, COMPCON 72, </booktitle> <pages> pages 215-218, </pages> <address> San Francisco, </address> <month> September </month> <year> 1972. </year>
Reference-contexts: It is presented here for its historical value, for its representativeness of a non-procedural class of 23 languages, and to be compared with more recent languages. Additional information (other than presented here) about CDL can be found in <ref> [11, 12, 2] </ref>; * AHPL A Hardware Description Language and ISPS Instruction Set Processor Specification. These two languages have successfully survived, and evolved, through a period of approximately 20 years. <p> This one needs no justification. It is enforced by DoD, and it is becoming an industry standard. More information on VHDL from [25]. 8.1 Computer Design Language (CDL) 8.1.1 Introduction CDL <ref> [11, 12] </ref> is one of the oldest HDLs, dating back to 1965. It was one of the most successful languages of its time, and in 1975 both a simulator and a Boolean translator had been implemented [4]. <p> Instead, each statement is associated with a "condition" for activation (execution). CDL provides few primitive operators (the only arithmetic ones are add and sub, and the only conditional operators are = and 6=). 24 As an example, taken from <ref> [12] </ref>, we shall consider a small microprogrammed computer. The processor has a word size of 24 bits and 32 kwords of main memory. The microprogram is 24 bits wide by 1 kword deep.
Reference: [13] <author> P. Civera et al. </author> <title> Petri Net Models for the Description and Verification of Parallel Bus Protocols. </title> <booktitle> In Proceedings of the IFIP WG 10.2 Eighth International Conference on Computer Hardware Description Languages and their Applications, </booktitle> <pages> pages 309-326, </pages> <address> Amsterdan, April 1987. </address> <publisher> North-Holland. </publisher>
Reference-contexts: The PMS notation, which is described in [37, 2] has been used for descriptions at this level, but it is mainly an structural notation, without the ability to specify transactions, events or actions in general. Petri nets can be used to well represent control actions <ref> [29, 13] </ref>, but not so much for describing the transformations that information is subject. The UCLA Graph Model of Behavior (GMB) has been used in some projects [41, 24].
Reference: [14] <author> Bernard C. Cole. </author> <title> In Chips, the Demand Stays Strong. </title> <publisher> Electronics, </publisher> <pages> pages 82-84, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The following table is a summary of a forecast for the 1990 American market of major computer-related products <ref> [15, 36, 32, 31, 14] </ref>: area market forecast 90 millions of US$ data processing 102,228 software 30,053 communications 28,346 semiconductors 17,405 test & measurement 7,379 Electronics CAD/CAE 1,270 total 186,681 6 What the table above says is that only 0.7% of the total computer market is of tools to design computers, <p> STRUCTURE: DISTRIBUTED PROCESS begin declarations FOR i = 0 TO 3 MODULES: Processor_i; Ram_i. COMBUS: DBUSP_i [8]; DBUSM_i [8]. ROF end declarations begin definitions MODULE: Processor begin declarations OUTPUTS: readwriteP; ADDRP [16]. COMBUS: DBUSP_i [8]. end declarations end module MODULE: RAM begin declarations INPUTS: ADDRM <ref> [14] </ref>; readwriteM.
Reference: [15] <author> Lawrence Curran. </author> <title> It's Becoming a Buyer's Market. </title> <publisher> Electronics, </publisher> <pages> pages 57-59, </pages> <month> Jan-uary </month> <year> 1990. </year>
Reference-contexts: The following table is a summary of a forecast for the 1990 American market of major computer-related products <ref> [15, 36, 32, 31, 14] </ref>: area market forecast 90 millions of US$ data processing 102,228 software 30,053 communications 28,346 semiconductors 17,405 test & measurement 7,379 Electronics CAD/CAE 1,270 total 186,681 6 What the table above says is that only 0.7% of the total computer market is of tools to design computers,
Reference: [16] <author> D. A. Fisher. </author> <title> Control structures for programming languages. </title> <type> PhD thesis, </type> <institution> Dep. of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1970. </year>
Reference-contexts: According to Barbacci [4], the main motivation is that: "Complexity 9 diminishes and clarity increases to a marked degree if algorithms are described in a language in which appropriate control structures are primitive or easily expressible" <ref> [16] </ref>. This is a general requirement for programming languages. Whereas in the software field only now the need to describe concurrent activities has become common, in the hardware field, parallel operations have been the rule for long time. HDLs must provide a natural way to describe parallelism and concurrency. <p> We will not go into the details of the processor and memory modules. STRUCTURE: DISTRIBUTED PROCESS begin declarations FOR i = 0 TO 3 MODULES: Processor_i; Ram_i. COMBUS: DBUSP_i [8]; DBUSM_i [8]. ROF end declarations begin definitions MODULE: Processor begin declarations OUTPUTS: readwriteP; ADDRP <ref> [16] </ref>. COMBUS: DBUSP_i [8]. end declarations end module MODULE: RAM begin declarations INPUTS: ADDRM [14]; readwriteM.
Reference: [17] <author> Bill Harding. </author> <title> System Simulation Assures that Chips Play Together. </title> <booktitle> Computer Design, </booktitle> <pages> pages 70-84, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Fortunately, the scene is changing: VHDL brought some standardization (even if it was forced, it was beneficial)[30], allowed reasonably wide-spread automation at higher level of design than gate-level [3, 34, 30], and new tools assure that complex systems, built of many VLSI chips work correctly <ref> [17] </ref>.
Reference: [18] <author> Reiner W. Hartenstein. </author> <title> Hardware Description Languages, </title> <booktitle> volume 7 of Advances in CAD for VLSI, chapter 1. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1987. </year>
Reference-contexts: Nowadays any tool that is not computer assisted is of little worth discussing. The urge for a break-through of HDL use in design practice has been recognized several times, recently <ref> [18] </ref> and not so recently [4]. The RT level was recognized as a valid design level back in the early 50's, and by 1975 there were a few implemented and operational HDLs [4]. <p> Hartenstein classifies the scene of HDLs as confusing [19], and complains about the non-use of HDLs in real designs and of Universities not teaching it <ref> [18] </ref>. Fortunately, the scene is changing: VHDL brought some standardization (even if it was forced, it was beneficial)[30], allowed reasonably wide-spread automation at higher level of design than gate-level [3, 34, 30], and new tools assure that complex systems, built of many VLSI chips work correctly [17]. <p> Hartenstein <ref> [18] </ref> and Barbacci [4] define the following requirements for HDLs: 1. Readability and Comprehensibility: An HDL is to be used as a means of transmitting information between human and machine, among humans and among machines. Machines usually don't care much about the style of a language, but humans do.
Reference: [19] <author> Reiner W. Hartenstein. </author> <title> Hardware Description Languages, </title> <booktitle> volume 7 of Advances in CAD for VLSI, chapter 2. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1987. </year>
Reference-contexts: By 1987, several hundred of these languages had been published and a dozen new were added every year, even though most of them do not survive long, due to lack of good implementation (or no implementation at all), or other reasons <ref> [19] </ref>. Hartenstein classifies the scene of HDLs as confusing [19], and complains about the non-use of HDLs in real designs and of Universities not teaching it [18]. <p> By 1987, several hundred of these languages had been published and a dozen new were added every year, even though most of them do not survive long, due to lack of good implementation (or no implementation at all), or other reasons <ref> [19] </ref>. Hartenstein classifies the scene of HDLs as confusing [19], and complains about the non-use of HDLs in real designs and of Universities not teaching it [18]. <p> There are four main criteria for classification <ref> [19] </ref>: * abstraction level which of the many abstraction levels of digital systems does the language represents well (see the subsection Levels of Abstraction); * dimensions of notation which of the 3 axis of design of digital systems does the language represents well (see the subsection Design Dimensions); * application area <p> It has been observed <ref> [19] </ref> that the structural ingredients of a description are not very sensitive to the level of abstraction of a description. <p> Most tools for RT level analysis are software programs for conventional computers, with some research in the area of specialized architectures [23, 1]. The arsenal of tools is not vast, but there are a myriad of languages for RT level description. As Hartenstein has noticed <ref> [19] </ref>, this shows a lack of continuity in the associated research projects. 5.2.6 Instruction Set Processor Level The instruction set processor level is concerned with the description of the interpretation of instructions (machine instructions) by the computer. <p> If one is working at the lower levels, mainly circuit level, graphic representations really are a great improvement. Experiences with languages for IC design, both in textual and graphic form show that improvement of about a factor of five can be reached when one uses the graphic form <ref> [19] </ref>. <p> Also, no language should be too specific, so that the designer has the ability to "move around" abstraction levels and design axis without changing languages excessively. Languages that can describe digital systems in more than one abstraction level are called multi level languages <ref> [19] </ref>. Here we emphasize that a language has to cover not only multi levels, but also multi dimensions and multi applications. We call languages which span over more than one level, one axis an one application, multiple attribute languages. It is clear that any effective language should be multiple attribute.
Reference: [20] <author> Fredrick J. Hill and Z. Navabi. </author> <title> Extending Second Generation AHPL Software to Ac-comodate AHPL III. </title> <booktitle> In Proceedings of the 4th Interational Symposium on Computer Hardware Description Languages, </booktitle> <month> October </month> <year> 1979. </year>
Reference-contexts: These two languages have successfully survived, and evolved, through a period of approximately 20 years. They were chosen for this and for they are the two languages that most influenced LIDEX (a part from its direct antecedent, LIDER ). Additional Information about AHPL can be found in <ref> [21, 22, 20] </ref>, and about ISPS in [6, 37, 2]; * VHDL - VHSIC Hardware Description Language. This one needs no justification. It is enforced by DoD, and it is becoming an industry standard. <p> The language was originally designed by Fredrick Hill and Gerald Peterson as a design tool. A primary motivation was to provide a language which could be translated into hardware by a completely defined set of rules <ref> [20] </ref>. The reference for the first version of AHPL is the first edition of the book "Digital Systems: Hardware Organization and Design", by Hill and Peterson [21]. <p> The language evolved first into AHPL II, for which the reference is the second edition of their book [22] and finally into AHPL III <ref> [20] </ref>. A good explanation of the processes of translating AHPL descriptions into hardware implementations is found in [22]. Here we intended to just give a flavor of the language in its AHPL III form. <p> Transfers may take place inside the functional register. As an example of a description of a functional register, consider the 74163 four-bit counter [39]. This counter executes the functions of counting up, clearing, and loading. The AHPL description of this counter is as follows (from <ref> [20] </ref>): FUNCTREG: COUNTER (load, enp, ent, clear; DATA) begin declarations DATA INPUT: DATA [4] CONTROL INPUTS: load, enp, ent, clear OUTPUTS: COUNTER [5] MEMORY: D [4] CLUNITS: INC [4] end declarations begin D * ((enp ^ ent) _ load) (INC (D)!DATA)*((enp ^ ent ^ load), load); D * clear 0, 0, <p> There are facilities for the declaration of repetitive structures. As an example of a structure, let us consider the description of a multiprocessor system, with 4 processor and 4 memory banks, a simplified version of the example presented in <ref> [20] </ref>. We will not go into the details of the processor and memory modules. STRUCTURE: DISTRIBUTED PROCESS begin declarations FOR i = 0 TO 3 MODULES: Processor_i; Ram_i. COMBUS: DBUSP_i [8]; DBUSM_i [8]. ROF end declarations begin definitions MODULE: Processor begin declarations OUTPUTS: readwriteP; ADDRP [16].
Reference: [21] <author> Fredrick J. Hill and Gerald R.Peterson. </author> <title> Digital Systems: Hardware Organization and Design. </title> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1973. </year>
Reference-contexts: These two languages have successfully survived, and evolved, through a period of approximately 20 years. They were chosen for this and for they are the two languages that most influenced LIDEX (a part from its direct antecedent, LIDER ). Additional Information about AHPL can be found in <ref> [21, 22, 20] </ref>, and about ISPS in [6, 37, 2]; * VHDL - VHSIC Hardware Description Language. This one needs no justification. It is enforced by DoD, and it is becoming an industry standard. <p> A primary motivation was to provide a language which could be translated into hardware by a completely defined set of rules [20]. The reference for the first version of AHPL is the first edition of the book "Digital Systems: Hardware Organization and Design", by Hill and Peterson <ref> [21] </ref>. The language evolved first into AHPL II, for which the reference is the second edition of their book [22] and finally into AHPL III [20]. A good explanation of the processes of translating AHPL descriptions into hardware implementations is found in [22].
Reference: [22] <author> Fredrick J. Hill and Gerald R.Peterson. </author> <title> Digital Systems: Hardware Organization and Design, Second Edition. </title> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: These two languages have successfully survived, and evolved, through a period of approximately 20 years. They were chosen for this and for they are the two languages that most influenced LIDEX (a part from its direct antecedent, LIDER ). Additional Information about AHPL can be found in <ref> [21, 22, 20] </ref>, and about ISPS in [6, 37, 2]; * VHDL - VHSIC Hardware Description Language. This one needs no justification. It is enforced by DoD, and it is becoming an industry standard. <p> The reference for the first version of AHPL is the first edition of the book "Digital Systems: Hardware Organization and Design", by Hill and Peterson [21]. The language evolved first into AHPL II, for which the reference is the second edition of their book <ref> [22] </ref> and finally into AHPL III [20]. A good explanation of the processes of translating AHPL descriptions into hardware implementations is found in [22]. Here we intended to just give a flavor of the language in its AHPL III form. <p> The language evolved first into AHPL II, for which the reference is the second edition of their book <ref> [22] </ref> and finally into AHPL III [20]. A good explanation of the processes of translating AHPL descriptions into hardware implementations is found in [22]. Here we intended to just give a flavor of the language in its AHPL III form. AHPL can be well classified as centered in the RT level of abstraction, and spanning the structural and behavioral axis of design.
Reference: [23] <author> Mark Hirsch. </author> <title> An Arithmetic Logic Unit for an ISP Simulator. </title> <booktitle> In Proceedings of the IFIP WG 10.2 Sixth International Conference on Computer Hardware Description Languages and their Applications, </booktitle> <pages> pages 199-211, </pages> <address> Amsterdan, May 1983. </address> <publisher> North-Holland. </publisher>
Reference-contexts: We shall see that as we move towards higher 18 level of abstraction, we can no more count on such precise information. Most tools for RT level analysis are software programs for conventional computers, with some research in the area of specialized architectures <ref> [23, 1] </ref>. The arsenal of tools is not vast, but there are a myriad of languages for RT level description.
Reference: [24] <author> J. T. Hsieh, A. R. Plezkun, and M. K. Vernon. </author> <title> Performance Evaluation of a Pipelined VLSI Architecture using the Graph Model of Behavior (GMB). </title> <booktitle> In Proceedings of the IFIP WG 10.2 Seventh International Conference on Computer Hardware Description Languages and their Applications, </booktitle> <pages> pages 192-205, </pages> <address> Amsterdan, </address> <month> August </month> <year> 1985. </year> <pages> North-Holland. </pages>
Reference-contexts: Petri nets can be used to well represent control actions [29, 13], but not so much for describing the transformations that information is subject. The UCLA Graph Model of Behavior (GMB) has been used in some projects <ref> [41, 24] </ref>. Good notations and good tools are still missing for this abstraction level. 5.3 The Source Medium A language for describing digital systems can have either a graphic or a textual form of presentation.
Reference: [25] <institution> The Institute of Electrical and Electronics Engineers, Inc, </institution> <address> New York. </address> <note> IEEE Stan-dandard VHDL 7.2 Language Reference Manual, 1988. 44 </note>
Reference-contexts: Additional Information about AHPL can be found in [21, 22, 20], and about ISPS in [6, 37, 2]; * VHDL - VHSIC Hardware Description Language. This one needs no justification. It is enforced by DoD, and it is becoming an industry standard. More information on VHDL from <ref> [25] </ref>. 8.1 Computer Design Language (CDL) 8.1.1 Introduction CDL [11, 12] is one of the oldest HDLs, dating back to 1965. It was one of the most successful languages of its time, and in 1975 both a simulator and a Boolean translator had been implemented [4]. <p> In December 1987, after an extensive industry involvement, the IEEE ratified the final standard, designated VHDL 1076-1987. The reference manual for it is <ref> [25] </ref>. Industry involvement was a key for the fast adoption of VHDL by many CAE-systems companies [30]. The other reason is that the military now requires design documentation using VHDL in every contract, so they are a major sponsor of VHDL development [34]. <p> An entity declaration can potentially represent a class of design entities, such as different speed versions of a TTL component or different version of a microprocessor, that have the same interface. Examples of entity declarations, from <ref> [25] </ref> (VHDL keywords in bold-face): entity Full Adder is port (X, Y, Cin: in Bit; Cout, Sum: out Bit); end Full Adder; entity AndGate is generic ( N: Natural := 2); port ( Inputs: in Bit Vector (1 to N); Result: out Bit); end AndGate; 36 entity ROM is port ( <p> Different architecture bodies for the same entity declaration defines different design entities with the same interface. Examples of architecture bodies, from <ref> [25] </ref> (VHDL keywords in bold-face): architecture DataFlow of Full Adder is signal A, B: Bit; begin A &lt;= X xor Y; Sum &lt;= A xor Cin; Cout &lt;= B or (X and Y); end DataFlow; architecture Behavior of AndGate is begin process (Inputs) variable Temp:Bit; begin Temp := '1'; for i
Reference: [26] <author> Kathleen Jensen and Niklaus Wirth. </author> <title> Pascal User Manual and Report. </title> <publisher> Springer--Verlag, </publisher> <address> New York, </address> <year> 1975. </year>
Reference: [27] <author> Glen G. Langdon, Jr. </author> <title> Computer Design. </title> <publisher> Computeach Press Inc., </publisher> <address> San Jose, </address> <year> 1982. </year>
Reference-contexts: There are however certain general benefits of working with a HDL that allows the designer to think (at least) at the RT level: 7 * reduction of complexity this is exactly what one seeks when one moves from one abstraction level to a higher one. Langdon <ref> [27] </ref> has commented on the large conceptual gap that exists between a full computer and its most basically components, which usually are gates (sometimes transistors) for those who design their own CPU, and that several intermediate levels of abstractions are needed to cross this gap, with complexity increasing as we move <p> Experimenting with alternative architectures and organizations is probably the most exciting field of application for HDLs, and the most needed today. Back in 1982, when most computers had a CISC and serial architecture, and when the semiconductor market had much less variety to offer, Langdon <ref> [27] </ref> noted the large number of alternatives that appear during the process of computer design. The situation today are even worse, for the large variety of parallel processing options, the advent of RISC alternatives, new effective semiconductor alternatives, etc. <p> Partitioning makes it possible to use the design strategies of divide and conquer, top-down and bottom-up <ref> [27] </ref>; * Interfacing: Interfacing specifies the external view of a module, how it is used to built larger modules, or more specifically, what are its connection ports for input and output; 13 * Interconnect: Interconnect specifies the wiring network that interconnects the ports of the several modules composing the system. <p> This should not be so, specially when one considers the importance of correct PCB layout, packaging and power distribution to the success of supercomputers [35]. 5.2 Levels of Abstraction Creating several levels of abstractions in order to represent something is a strategy for efficient design. The giant conceptual gap <ref> [27] </ref> that exists between an operating computer system and its most basic components (gates, transistors), can only be effective crossed through the use of sufficient intermediate steps. That is the reason for creating so many levels of abstractions for a computer system.
Reference: [28] <author> Tamio Mano et al. </author> <title> Occam to CMOS: Experimental Logic Design Support System. </title> <booktitle> In Proceedings of the IFIP WG 10.2 Seventh International Conference on Computer Hardware Description Languages and their Applications, </booktitle> <pages> pages 381-390, </pages> <address> Amsterdan, </address> <month> August </month> <year> 1985. </year> <pages> North-Holland. </pages>
Reference-contexts: Indeed, conventional programming languages can be used to describe digital systems. Fortran can be used [4], Ada has been used [7], as Occam <ref> [28] </ref> and APL, notably at IBM [4], have, and VALID uses Pascal or C to describe digital systems at a higher-abstraction level than it is possible with its schematic-capture language [40].
Reference: [29] <author> M. Ajmone Marsan, G. Balbo, and G. Conte. </author> <title> Performance Models of Multiprocessor Systems. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: The PMS notation, which is described in [37, 2] has been used for descriptions at this level, but it is mainly an structural notation, without the ability to specify transactions, events or actions in general. Petri nets can be used to well represent control actions <ref> [29, 13] </ref>, but not so much for describing the transformations that information is subject. The UCLA Graph Model of Behavior (GMB) has been used in some projects [41, 24].
Reference: [30] <author> Jonah McLeod. </author> <title> A Giant Leap for Simulation. </title> <publisher> Electronics, </publisher> <pages> pages 73-80, </pages> <year> 1989. </year>
Reference-contexts: Fortunately, the scene is changing: VHDL brought some standardization (even if it was forced, it was beneficial)[30], allowed reasonably wide-spread automation at higher level of design than gate-level <ref> [3, 34, 30] </ref>, and new tools assure that complex systems, built of many VLSI chips work correctly [17]. <p> In December 1987, after an extensive industry involvement, the IEEE ratified the final standard, designated VHDL 1076-1987. The reference manual for it is [25]. Industry involvement was a key for the fast adoption of VHDL by many CAE-systems companies <ref> [30] </ref>. The other reason is that the military now requires design documentation using VHDL in every contract, so they are a major sponsor of VHDL development [34]. <p> original reason for VHDL was design documentation, it forced the development of simulators (as a tool for checking the design), synthesis systems (the DoD theory is that having a description in VHDL, it can go to any vendor and have it 34 successfully duplicate the chip or board or system <ref> [30] </ref>), and its use in the design process in general. VHDL is expected to become a de facto standard for hardware design, and substantially change the way most designs are done today [30, 34]. <p> VHDL is expected to become a de facto standard for hardware design, and substantially change the way most designs are done today <ref> [30, 34] </ref>. <p> Right now there are few engineers trained to use VHDL, and some industry experts say it will be hard to get hardware-oriented engineers to change their design thinking process (based on schematics, block diagrams, gates, transistors and netlists) to use VHDL (which is similar to writing software programs) <ref> [30] </ref>. Meanwhile, University of Illinois at Urbana-Champaign is already using VHDL in some courses, and Mentor Graphics Corp. is offering customers training programs on its new VHDL system. In the beginning of 1989, two companies, Intermetrics and Vantage, already had VHDL simulators [30]. <p> VHDL (which is similar to writing software programs) <ref> [30] </ref>. Meanwhile, University of Illinois at Urbana-Champaign is already using VHDL in some courses, and Mentor Graphics Corp. is offering customers training programs on its new VHDL system. In the beginning of 1989, two companies, Intermetrics and Vantage, already had VHDL simulators [30]. Vantage also has a graphical interface to VHDL, its "Electronic Spreadsheet", that provides a front end through which design is entered as schematics and translated to VHDL [30, 34]. Intermetrics has an agreement with Valid towards providing a full VHDL design environment [34]. <p> In the beginning of 1989, two companies, Intermetrics and Vantage, already had VHDL simulators [30]. Vantage also has a graphical interface to VHDL, its "Electronic Spreadsheet", that provides a front end through which design is entered as schematics and translated to VHDL <ref> [30, 34] </ref>. Intermetrics has an agreement with Valid towards providing a full VHDL design environment [34]. More companies are moving towards VHDL design environments, notably Mentor Graphics and Zycad [30]. Mentor's System 1076 provides full VHDL language capability and a graphics interface is expected for 1990. <p> Intermetrics has an agreement with Valid towards providing a full VHDL design environment [34]. More companies are moving towards VHDL design environments, notably Mentor Graphics and Zycad <ref> [30] </ref>. Mentor's System 1076 provides full VHDL language capability and a graphics interface is expected for 1990. Zycad had alpha versions of its simulator available in the beginning of 1989, and beta versions were expected before the middle of that year. <p> Ikos Systems, which manufactures hardware accelerators for gate-level simulation, is building a hardware product that converts high-level VHDL statements into detailed simulation vectors for the gate-level simulator and vice-versa <ref> [30] </ref>. Model libraries are another very important part in the process of simulating systems, for it is virtually impossible for every design engineer to model every component himself [34].
Reference: [31] <author> Jonah McLeod. </author> <title> It Looks Like Another Goog Year. </title> <publisher> Electronics, </publisher> <pages> page 70, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The following table is a summary of a forecast for the 1990 American market of major computer-related products <ref> [15, 36, 32, 31, 14] </ref>: area market forecast 90 millions of US$ data processing 102,228 software 30,053 communications 28,346 semiconductors 17,405 test & measurement 7,379 Electronics CAD/CAE 1,270 total 186,681 6 What the table above says is that only 0.7% of the total computer market is of tools to design computers, <p> That is, much more money is spent in test tools than in design ones. However, the market for Electronics CAD/CAE is growing fast, at a rate of approximately 25% a year, according to the following table, summarized from <ref> [31] </ref>: area millions of US$ 1988 1989 1990 workstations total 263 355 434 PC based 40 60 84 32-bit platforms 223 295 350 software total 569 727 836 schematic capture 119 158 158 simulators 170 226 282 logic synthesizers 10 20 40 model libraries 15 16 22 IC design 108 125
Reference: [32] <author> Jonah McLeod. </author> <title> Microprocessor Boom Fuels Growth. </title> <publisher> Electronics, </publisher> <pages> pages 67-68, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The following table is a summary of a forecast for the 1990 American market of major computer-related products <ref> [15, 36, 32, 31, 14] </ref>: area market forecast 90 millions of US$ data processing 102,228 software 30,053 communications 28,346 semiconductors 17,405 test & measurement 7,379 Electronics CAD/CAE 1,270 total 186,681 6 What the table above says is that only 0.7% of the total computer market is of tools to design computers, <p> And from <ref> [32] </ref> we know that the market for IC testers only is estimated in US$ 1,597 million. That is, much more money is spent in test tools than in design ones.
Reference: [33] <author> Jean P. Mermet. </author> <title> Electronic Design Automation at a Glance. </title> <booktitle> In Proceedings of the IFIP WG 10.2 Eighth International Conference on Computer Hardware Description Languages and their Applications, </booktitle> <pages> pages 383-404, </pages> <address> Amsterdan, April 1987. </address> <publisher> North-Holland. </publisher>
Reference-contexts: The analysis of gate level models of digital systems has available the largest resource of automation tools, which range from software programs for gate level simulation and timing analysis (notably for workstations [40]), to special hardware accelerators for workstations <ref> [33] </ref> and dedicated computer architectures [8].
Reference: [34] <author> Ernest Meyer. </author> <title> VHDL Opens the Road to Top-Down Design. </title> <booktitle> Computer Design, </booktitle> <pages> pages 57-62, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Fortunately, the scene is changing: VHDL brought some standardization (even if it was forced, it was beneficial)[30], allowed reasonably wide-spread automation at higher level of design than gate-level <ref> [3, 34, 30] </ref>, and new tools assure that complex systems, built of many VLSI chips work correctly [17]. <p> The reference manual for it is [25]. Industry involvement was a key for the fast adoption of VHDL by many CAE-systems companies [30]. The other reason is that the military now requires design documentation using VHDL in every contract, so they are a major sponsor of VHDL development <ref> [34] </ref>. <p> VHDL is expected to become a de facto standard for hardware design, and substantially change the way most designs are done today <ref> [30, 34] </ref>. <p> In the beginning of 1989, two companies, Intermetrics and Vantage, already had VHDL simulators [30]. Vantage also has a graphical interface to VHDL, its "Electronic Spreadsheet", that provides a front end through which design is entered as schematics and translated to VHDL <ref> [30, 34] </ref>. Intermetrics has an agreement with Valid towards providing a full VHDL design environment [34]. More companies are moving towards VHDL design environments, notably Mentor Graphics and Zycad [30]. Mentor's System 1076 provides full VHDL language capability and a graphics interface is expected for 1990. <p> Vantage also has a graphical interface to VHDL, its "Electronic Spreadsheet", that provides a front end through which design is entered as schematics and translated to VHDL [30, 34]. Intermetrics has an agreement with Valid towards providing a full VHDL design environment <ref> [34] </ref>. More companies are moving towards VHDL design environments, notably Mentor Graphics and Zycad [30]. Mentor's System 1076 provides full VHDL language capability and a graphics interface is expected for 1990. <p> Model libraries are another very important part in the process of simulating systems, for it is virtually impossible for every design engineer to model every component himself <ref> [34] </ref>. Logic Modeling Systems is providing VHDL capability in its "third-generation" hardware modeler, and Logic Automation and Quadtree are transferring their existing model libraries into VHDL. <p> It is quite a complete language, but there are some deficiencies, that must be corrected, and probably will, in order to "complete" VHDL: 41 * VHDL by itself doesn't support software development. But, two vendors, JRS Laboratories and Zycad, are working on it <ref> [34] </ref>; * The strong typing and highly distinct views of a system provided by VHDL are very important in documentation and debugging, but they could be "loosed" a little during the initial phases of a design, when no one has a clear view of it; * A standard graphics interface must
Reference: [35] <author> Richard M. Russell. </author> <title> The Cray-1 Computer System. </title> <journal> Communications of the ACM, </journal> <volume> 21(1) </volume> <pages> 63-72, </pages> <month> January </month> <year> 1978. </year>
Reference-contexts: The geometry of a design is well considered by chip designers, but often overlooked by system designers. This should not be so, specially when one considers the importance of correct PCB layout, packaging and power distribution to the success of supercomputers <ref> [35] </ref>. 5.2 Levels of Abstraction Creating several levels of abstractions in order to represent something is a strategy for efficient design.
Reference: [36] <author> Jack Shandle. </author> <title> A Maturing Market Remains Robust. </title> <publisher> Electronics, </publisher> <pages> pages 62-64, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The following table is a summary of a forecast for the 1990 American market of major computer-related products <ref> [15, 36, 32, 31, 14] </ref>: area market forecast 90 millions of US$ data processing 102,228 software 30,053 communications 28,346 semiconductors 17,405 test & measurement 7,379 Electronics CAD/CAE 1,270 total 186,681 6 What the table above says is that only 0.7% of the total computer market is of tools to design computers,
Reference: [37] <author> Daniel P. Siewiorek, C. Gordon Bell, and Allen Newell. </author> <title> Computer Structures: Principles and Examples. </title> <publisher> McGraw-Hill Book Company, </publisher> <address> New York, </address> <year> 1982. </year>
Reference-contexts: That is the reason for creating so many levels of abstractions for a computer system. Since the abstractions levels for a computer system were introduced by designers as a means of managing the complexity of the system, they often coincide with actual boundaries of the system <ref> [37] </ref>. We here classify the abstraction levels for digital systems in a way very similar to that used by Siewiorek [37]. Each level presented below has an associated manner of describing structure and behavior. <p> the abstractions levels for a computer system were introduced by designers as a means of managing the complexity of the system, they often coincide with actual boundaries of the system <ref> [37] </ref>. We here classify the abstraction levels for digital systems in a way very similar to that used by Siewiorek [37]. Each level presented below has an associated manner of describing structure and behavior. <p> There is a well established notation for describing the ISP level, and it is called ISPS (Instruction Set Processor Specification). The language is well described in <ref> [37, 2, 6] </ref>. We will go back to ISPS in its own section. 5.2.7 Low and High Programming Level After one describes the machine language of a computer (in the ISP level), a series of abstractions can be built in the programming level. <p> This trend may change, for parallel machines are noticeably sensitive to the way programs are written. 5.2.8 The PMS Level The PMS level of abstraction corresponds to a chemical engineering view of computing <ref> [37] </ref>. The components of the plant are processors, memories, switches, links, controls, transducers, and data-operators. The medium being processed is information, through events and transactions that take place in the components we mentioned. <p> The medium being processed is information, through events and transactions that take place in the components we mentioned. It is well known that is at this level that starts the conception of computing system, although in a rather informal way. The PMS notation, which is described in <ref> [37, 2] </ref> has been used for descriptions at this level, but it is mainly an structural notation, without the ability to specify transactions, events or actions in general. <p> They were chosen for this and for they are the two languages that most influenced LIDEX (a part from its direct antecedent, LIDER ). Additional Information about AHPL can be found in [21, 22, 20], and about ISPS in <ref> [6, 37, 2] </ref>; * VHDL - VHSIC Hardware Description Language. This one needs no justification. It is enforced by DoD, and it is becoming an industry standard. <p> As an example of an ISPS description, we here reproduce part of the PDP-8 description that appears in chapter 4 of <ref> [37] </ref>. Comments in an ISPS description start with the "!" symbol and go to the end of the line.
Reference: [38] <author> Stephen Y. H. Su. </author> <title> Introduction. </title> <booktitle> In Proceedings of the 1975 Interational Symposium on Computer Hardware Description Languages and their Applications, </booktitle> <month> September </month> <year> 1975. </year>
Reference-contexts: The Computer is optional, and was used 5 in the primeval of design automation to mean that the language was to be processed by computer <ref> [38] </ref>. Nowadays any tool that is not computer assisted is of little worth discussing. The urge for a break-through of HDL use in design practice has been recognized several times, recently [18] and not so recently [4].
Reference: [39] <author> Texas Instuments. </author> <title> Standard TTL Data Book, </title> <year> 1985. </year>
Reference-contexts: Functional registers contain memory, but no internal control. A functional register has data inputs, control inputs, a clock input and outputs. Transfers may take place inside the functional register. As an example of a description of a functional register, consider the 74163 four-bit counter <ref> [39] </ref>. This counter executes the functions of counting up, clearing, and loading.
Reference: [40] <institution> Valid Logic Systems, Incorporated, </institution> <address> San Jose, CA. </address> <note> ValidSIM Reference Manual, </note> <year> 1988. </year>
Reference-contexts: These tools are widely used to validate a particular design, even for the most complex systems, but they lack the performance to do real experimentation, or simply play with different and alternatives architectures and organizations. VALID Logic is a supplier of a well-known simulation software for gate-level simulation <ref> [40] </ref>. According to VALID, the performance of their simulator is 1000 gate-evaluations/s/MIPS of the host machine. This means that a brand-new 10-MIPS Sparcstation will do 10,000 gate-evaluations/s. On the average, for each clock cycle of the system being simulated, each of its gates must be evaluated twice. <p> Fortran can be used [4], Ada has been used [7], as Occam [28] and APL, notably at IBM [4], have, and VALID uses Pascal or C to describe digital systems at a higher-abstraction level than it is possible with its schematic-capture language <ref> [40] </ref>. Nevertheless, special notations should be used for HDLs, for digital systems have their own particularities which must be observed and easily represented in the notation. As we already commented, the notation a designer uses to express a design has a strong influence upon him or her. <p> The analysis of gate level models of digital systems has available the largest resource of automation tools, which range from software programs for gate level simulation and timing analysis (notably for workstations <ref> [40] </ref>), to special hardware accelerators for workstations [33] and dedicated computer architectures [8].
Reference: [41] <author> M. K. Vernon and G. Estrin. </author> <title> The UCLA Graph Model of Behavior: Support for Performance-Oriented Design. </title> <booktitle> In Proceedings of the IFIP WG 10.1 Working Conference on Methodologies for Computer System Design, </booktitle> <address> Lille, France, </address> <month> September </month> <year> 1983. </year> <note> North-Holland. 46 </note>
Reference-contexts: Petri nets can be used to well represent control actions [29, 13], but not so much for describing the transformations that information is subject. The UCLA Graph Model of Behavior (GMB) has been used in some projects <ref> [41, 24] </ref>. Good notations and good tools are still missing for this abstraction level. 5.3 The Source Medium A language for describing digital systems can have either a graphic or a textual form of presentation.
References-found: 41

