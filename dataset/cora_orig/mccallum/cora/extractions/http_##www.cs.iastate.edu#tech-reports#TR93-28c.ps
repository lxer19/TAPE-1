URL: http://www.cs.iastate.edu/tech-reports/TR93-28c.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: An Operational Semantics of Firing Rules for Structured Analysis Style Data Flow Diagrams Keywords: structured
Author: Gary T. Leavens, Tim Wahls, Albert L. Baker, and Kari Lyle TR #-c 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Date: December 1993 (revised Dec. 1993, Sept. 1994, June 1996)  
Abstract: 1993 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications | languages, methodologies, tools; D.2.2 [Software Engineering] Tools and Techniques | structured analysis, data flow diagrams, D.2.10 [Software Engineering] Design | methodologies, representation; D.3.1 [Programming Languages] Formal Definitions and Theory | semantics, syntax; F.3.2 [Logics and Meanings of Programs] Specifying and Verifying and Reasoning about Programs | specification techniques; F.3.2 [Logics and Meanings of Programs] Semantics of Programming Languages | operational semantics. Copyright c fl Gary T. Leavens, Tim Wahls, Albert L. Baker, and Kari Lyle 1993, 1994, 1996. All rights reserved; this report will be submitted for publication, and the copyright will be transferred to the publisher. 
Abstract-found: 1
Intro-found: 1
Reference: [AR91] <author> E. Astesiano and G. Reggio. </author> <title> SMoLCS Driven Concurrent Calculi. </title> <editor> In Hart-mut Ehrig et al., editors, TAPSOFT'87, </editor> <booktitle> Proceedings of the International Joint Conference on Theory and Practice of Software Development, Pisa, Italy, Volume 1, volume 245 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year> <month> 30 </month>
Reference-contexts: Our model is arguably simpler in that both of his types of bubbles and flows can be translated into ours. France's operational semantics of extended DFDs use a framework similar to ours: algebraic state transition systems (ASTSs) <ref> [AR91] </ref> [Ast91]. The main difference in the formal framework is that France's semantics use transition systems to model all parts of a DFD, not just the firing rules. This gives the semantics a nicely compositional flavor, and allows an easy treatment of hierarchical DFDs [Fra92, page 333].
Reference: [Ast91] <author> Edigio Astesiano. </author> <title> Inductive and Operational Semantics. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts, IFIP State-of-the-Art Reports, </booktitle> <pages> pages 51-136. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: Our model is arguably simpler in that both of his types of bubbles and flows can be translated into ours. France's operational semantics of extended DFDs use a framework similar to ours: algebraic state transition systems (ASTSs) [AR91] <ref> [Ast91] </ref>. The main difference in the formal framework is that France's semantics use transition systems to model all parts of a DFD, not just the firing rules. This gives the semantics a nicely compositional flavor, and allows an easy treatment of hierarchical DFDs [Fra92, page 333].
Reference: [BB93] <author> Jorgen P. Bansler and Keld Bodker. </author> <title> A Reappraisal of Structured Analysis: Design in an Organizational Context. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 11(2) </volume> <pages> 165-193, </pages> <year> 1993. </year>
Reference-contexts: Within SA one specifies a data model using an Entity-Relationship Diagram (ERD) and a data dictionary, and the process by a Data Flow Diagram (DFD) [Fra93]. Because DFDs are widely-used <ref> [BB93] </ref>, many tools support their development. There are at least three attributes of DFDs that are appealing to software engineers: * they have a graphical representation, * they are hierarchical, thereby supporting the kind of modular decomposition that programmers view as essential, and * they are informal.
Reference: [BJ82] <author> Dines Bjorner and Cliff B. Jones. </author> <title> Formal Specification and Software Development. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> London, </address> <year> 1982. </year>
Reference-contexts: Baker's work was supported in part by a grant from Rockwell International. 1 of making them more precise. For example, Fraser, Kumar, and Vaishnavi [FKV91] and Larsen, et al. [LvKP + 91] extract a VDM <ref> [BJ82] </ref> [Jon90] specification from a DFD and a data dictionary. As another example, Semmens and Allen [SA91] extract a Z [Hay93] [Spi92] [Spi89] specification from an application's ERD and DFD. See [FLP94] for a survey that includes other such examples.
Reference: [Chu41] <author> A. Church. </author> <title> The Calculi of Lambda Conversion, </title> <booktitle> volume 6 of Annals of Mathematics Studies. </booktitle> <publisher> Princeton University Press, </publisher> <address> Princeton, N.J., </address> <year> 1941. </year> <title> Reprinted by Klaus Reprint Corp., </title> <address> New York in 1965. </address>
Reference-contexts: ask readers familiar with such notational conventions to bear with us as we try to make this paper accessible to a wider audience. 4 The notation f : e denotes a function that takes an argument, and returns the value of the expression e with the argument substituted for f <ref> [Chu41] </ref> [Sch86]. 9 The function r e describes part of a configuration where the bubble Bill-Customer has read the order co from the flow f creditBC (see Table 1), and where Collections has read the payment pmt from f payment and an empty list from f log . 3.3 Information on
Reference: [CJ91] <author> Soren Christensen and Leif Obel Jepsen. </author> <title> Modelling and Simulation of a Network Management System using Hierarchical Coloured Petri Nets (extended version). </title> <type> Technical Report DAIMI PB 349, </type> <institution> Computer Science Department, Aarhus University, </institution> <month> Apr </month> <year> 1991. </year>
Reference-contexts: Nevertheless, it would be useful to have an operational semantics of DFDs that took the hierarchy into account (as in the semantics of hierarchical colored petri nets [HJS90] <ref> [CJ91] </ref>). 8.1.2 Ward Ward [War86] distinguishes discrete from continuous data flows; that is between discrete and analog data, which he defines as "a set of values defined continuously over a time interval" [War86, page 199]. Hatley and Pirbhai have a similar notion of continuity [HP87] [Col91, Section 5.3.2].
Reference: [Col91] <author> David L. Coleman. </author> <title> Formalized structured analysis specifications. </title> <type> PhD thesis, </type> <institution> Iowa State University, Ames, Iowa, </institution> <month> 50011, </month> <year> 1991. </year>
Reference-contexts: Neither the flow name nor the type alone are sufficient to uniquely identify a flow in our example; having both labels eliminates a common source of ambiguity <ref> [Col91] </ref>. 1 In SA, DeMarco [DeM78] and others (e.g., [War86]) make a distinction between "discrete" and "continuous" flows. However, some authors seem to consider continuous flows as continuous in the sense of calculus (i.e., real-valued, differentiable). <p> DeMarco and Ward seem to think of them as continuously existing (i.e., like a shared variable) even when read. We adopt this latter interpretation, but to avoid confusion, we use different terminology <ref> [Col91] </ref>. Flows labeled with a double arrowhead are called persistent flows, which can be considered to be shared variables; flows with a single arrowhead are a consumable flows, which can be considered to be unbounded FIFO queues. <p> In a persistent flow, the shared variable that the flow represents can be written by the bubble at the source of the flow, and read by the target bubble <ref> [Col91] </ref>. Reading from a persistent flow does not change the information in the flow. The only persistent flows in our example go from bubbles to themselves; we use them to model stores. For example, f custs is used to model the store that would be attached to the bubble Generate-Sales-Order. <p> We have not described this translation formally because we did not want to go into the details of the graphical syntax of DFDs <ref> [Col91] </ref> [Tse91], although we have given an example of one such translation. Another aspect of the semantics of an (extended) DFD specification is its initial configuration. <p> What can be done, however, is to extract from the sequence of configurations a sequence of values presented to the sinks of a DFD. We leave the investigation of this alternative as future work. 6 Adding Stores In traditional SA, a store is a passive holder of data [DeM78] <ref> [Col91] </ref>. Multiple bubbles can access a single store for both reading and writing, but the store itself does not transform data. In fact, a store is usually thought of simply as a file, which is a rather low level of abstraction for a specification. <p> To summarize, the main advantage of our work is greater rigor, greater expressive power, and the ability to model dynamic behavior. 8.1.1 De Marco and Yourdon DFDs used in traditional structured analysis [DeM78] <ref> [Col91, page 15] </ref> have a very informal flavor and some features that are not directly present in our models. For example, De Marco has graphical notations on flows for "conjunction" (*) and "disjunction" () that are not a part of our formal model of the syntax of DFDs. <p> For example, De Marco has graphical notations on flows for "conjunction" (*) and "disjunction" () that are not a part of our formal model of the syntax of DFDs. Similarly, Yourdon makes graphical distinctions between "data" and "control" flows [You89] <ref> [Col91, pages 27-28] </ref>. However, our formal model can encode this kind of information in a general way. <p> However, their semantics is ambiguous. A converging flow may mean either that: * there are several flows which all have their sinks in the same bubble, or 25 * several "elementary packets of data" are to be joined "to form a complex packet" (such as a tuple) <ref> [Col91, page 16] </ref>. In our model one can express the first by having several separate flows, with a flow having several sources as in Section 6. <p> Hatley and Pirbhai have a similar notion of continuity [HP87] <ref> [Col91, Section 5.3.2] </ref>. Since such data can only be modeled in a computer by discrete data, there seems to be no good reason to model this distinction. Instead, we have adopted Ward's semantics for continuous flows as shared variables [War86, page 203] as a feature of flows in our model. <p> Instead, we have adopted Ward's semantics for continuous flows as shared variables [War86, page 203] as a feature of flows in our model. This feature of flows is orthogonal to the type of data on the flow. This is the distinction between consumable and persistent flows <ref> [Col91, Section 5.3.4] </ref>. The traditional view of stores is that they represent files [War86, page 199]. We model stores as persistent flows (shared variables), but as discussed in Section 6, the notion of a store containing a single value and a shared variable are equivalent. <p> However, as described in Section 3.1, such a semantics is inadequate for capturing the dynamic behavior of a DFD. 8.1.5 Coleman The static semantics of SA specifications (including notational issues) are treated in a recent dissertation by Coleman <ref> [Col91] </ref>. <p> Coleman describes a notation for P-specs based on first-order logic <ref> [Col91, Chapter 7] </ref>, which inspired parts of our model; his notation could be translated into our model. <p> Coleman describes a notation for P-specs based on first-order logic [Col91, Chapter 7], which inspired parts of our model; his notation could be translated into our model. Coleman also describes how one could give an operational semantics of SA specifications <ref> [Col91, Section 9.2] </ref> using what amounts to colored Petri nets (values are used instead of Ward's tokens) and first-order logical assertions for the transition firing rules. As described above in the section on colored Petri nets, however, such a semantics is inadequate for modeling the dynamic behavior of DFDs.
Reference: [DeM78] <author> Tom DeMarco. </author> <title> Structured Analysis and System Specification. </title> <publisher> Yourdon , Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1978. </year>
Reference-contexts: 1 Introduction An approach to the development of software systems which has enjoyed wide-spread use in the software engineering community is Structured Analysis (SA) <ref> [DeM78] </ref> [GS78] [WM85] [You89]. Within SA one specifies a data model using an Entity-Relationship Diagram (ERD) and a data dictionary, and the process by a Data Flow Diagram (DFD) [Fra93]. Because DFDs are widely-used [BB93], many tools support their development. <p> Neither the flow name nor the type alone are sufficient to uniquely identify a flow in our example; having both labels eliminates a common source of ambiguity [Col91]. 1 In SA, DeMarco <ref> [DeM78] </ref> and others (e.g., [War86]) make a distinction between "discrete" and "continuous" flows. However, some authors seem to consider continuous flows as continuous in the sense of calculus (i.e., real-valued, differentiable). DeMarco and Ward seem to think of them as continuously existing (i.e., like a shared variable) even when read. <p> What can be done, however, is to extract from the sequence of configurations a sequence of values presented to the sinks of a DFD. We leave the investigation of this alternative as future work. 6 Adding Stores In traditional SA, a store is a passive holder of data <ref> [DeM78] </ref> [Col91]. Multiple bubbles can access a single store for both reading and writing, but the store itself does not transform data. In fact, a store is usually thought of simply as a file, which is a rather low level of abstraction for a specification. <p> To summarize, the main advantage of our work is greater rigor, greater expressive power, and the ability to model dynamic behavior. 8.1.1 De Marco and Yourdon DFDs used in traditional structured analysis <ref> [DeM78] </ref> [Col91, page 15] have a very informal flavor and some features that are not directly present in our models. For example, De Marco has graphical notations on flows for "conjunction" (*) and "disjunction" () that are not a part of our formal model of the syntax of DFDs. <p> Our formal model can express control flows in a variety of ways; for example, by using a persistent flow that transmits boolean values, or by using a consumable flow that transmits values of a one-element type (a signal). De Marco's DFDs feature converging and diverging flows <ref> [DeM78] </ref>. However, their semantics is ambiguous.
Reference: [FKV91] <author> M. D. Fraser, K. Kumar, and V. K. Vaishnavi. </author> <title> Informal and Foraml Requirements Specification Languages: Bridging the Gap. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(5) </volume> <pages> 454-466, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Wahls's work was supported in part by a research assistantship provided by the College of Liberal Arts and Sciences, Iowa State University. Baker's work was supported in part by a grant from Rockwell International. 1 of making them more precise. For example, Fraser, Kumar, and Vaishnavi <ref> [FKV91] </ref> and Larsen, et al. [LvKP + 91] extract a VDM [BJ82] [Jon90] specification from a DFD and a data dictionary. As another example, Semmens and Allen [SA91] extract a Z [Hay93] [Spi92] [Spi89] specification from an application's ERD and DFD.
Reference: [FLP94] <author> Robert B. France and Maria M. Larrondo-Petrie. </author> <title> From Structured Analysis to Formal Specifications: State of the Theory. </title> <booktitle> In Proceedings of the ACM Computer Science Conference, </booktitle> <address> Phoenix, AZ, </address> <pages> pages 249-256. </pages> <publisher> ACM, </publisher> <month> Mar </month> <year> 1994. </year>
Reference-contexts: For example, Fraser, Kumar, and Vaishnavi [FKV91] and Larsen, et al. [LvKP + 91] extract a VDM [BJ82] [Jon90] specification from a DFD and a data dictionary. As another example, Semmens and Allen [SA91] extract a Z [Hay93] [Spi92] [Spi89] specification from an application's ERD and DFD. See <ref> [FLP94] </ref> for a survey that includes other such examples. For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques. For example, Wing and Zaremski [WZ91] augment SA specifications (especially the data dictionary), with specifications in the Larch Shared Language [GHG + 93]. <p> This precise use of DFDs would certainly come after the imprecise, informal use, but one should not have to completely change notations in order to formally describe systems. Instead, we look forward to an integration of informal and formal specifications spanning a wide range of needs <ref> [FLP94] </ref> [FLP95]. The advantage of formal and precise DFD specifications would be that the work done in requirements analysis would not have to be thrown away when more precision is required. Acknowledgements Thanks to Juergen Symanzik for helpful suggestions and corrections, especially about strictness in the semantics.
Reference: [FLP95] <author> Robert B. France and Maria M. Larrondo-Petrie. </author> <title> A Two-Dimensional View of Integrated Formal and Informal Specifications Techniques. </title> <editor> In Jonathan P. Bowen and Michael G. Hinchey, editors, </editor> <title> ZUM '95: The Z Formal Specification Notation, </title> <booktitle> 9th International Conference of Z Users, Limerick, Ireland, volume 967 of Lecture Notes in Computer Science, </booktitle> <pages> pages 434-448. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques. For example, Wing and Zaremski [WZ91] augment SA specifications (especially the data dictionary), with specifications in the Larch Shared Language [GHG + 93]. As another example, France [Fra93] <ref> [FLP95] </ref>, has specified the types in a data dictionary using Z notation, and has used Z to augment the specifications of data stores and global state invariants. These extensions are relevant, because they indicate that there is a desire for integration of DFDs and formal methods. <p> This precise use of DFDs would certainly come after the imprecise, informal use, but one should not have to completely change notations in order to formally describe systems. Instead, we look forward to an integration of informal and formal specifications spanning a wide range of needs [FLP94] <ref> [FLP95] </ref>. The advantage of formal and precise DFD specifications would be that the work done in requirements analysis would not have to be thrown away when more precision is required. Acknowledgements Thanks to Juergen Symanzik for helpful suggestions and corrections, especially about strictness in the semantics.
Reference: [Fra92] <author> Robert B. </author> <title> France. Semantically Extended Data Flow Diagrams: A Formal Specification Tool. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(4) </volume> <pages> 329-346, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Nevertheless, our model is derived from his initial work. Coleman also gives several different possible models of stores, one of which [Col91, semantics of DFDs. Coleman does not treat a bubble firing concurrently with itself. 8.1.6 France In the two works <ref> [Fra92] </ref> [Fra93] that we discuss below, France describes variants of DFDs, specification notations, and their semantics. <p> In summary, the major difference is that France presents specific specification notations 27 and their semantics, while we have explored what kinds of semantics for extended DFD specification are sensible, with a special focus on modeling the dynamic behavior of DFDs. Semantically Extended DFDs In <ref> [Fra92] </ref> France works with DFDs that have several additional features, and he also gives a formal semantics. France's "queued flows" are what we call consumable flows, and his "variables" are our persistent flows. <p> The main difference in the formal framework is that France's semantics use transition systems to model all parts of a DFD, not just the firing rules. This gives the semantics a nicely compositional flavor, and allows an easy treatment of hierarchical DFDs <ref> [Fra92, page 333] </ref>. France gives an explicit notation for P-specs, which could be given an alternative semantics using our model. All of his additional graphical conventions for DFDs can be translated into our model in ways similar to those discussed above for other related work. <p> For example, each bubble must have an output flow (page 330) and nested loops are not allowed inside infinite loops in his P-spec statement language (page 337). France treats stores the same as he treats other parts of a DFD, as ASTSs <ref> [Fra92, pages 336-337] </ref>; hence his stores need more description than necessary in our model, where stores are modeled as persistent flows. <p> Since he does not treat them in his formal semantics, his notions appear to suffer the same problems (no precise description of how the splitting or aggregation is done). France does not allow bubbles to fire concurrently with themselves because each bubble has only one copy of its variables <ref> [Fra92, pages 344-345] </ref>. Firing in a DFD is apparently an atomic step, since "outputs are solely dependent on current inputs" [Fra92, page 342]; so France's model includes explicit ways to make bubbles concurrent. <p> France does not allow bubbles to fire concurrently with themselves because each bubble has only one copy of its variables [Fra92, pages 344-345]. Firing in a DFD is apparently an atomic step, since "outputs are solely dependent on current inputs" <ref> [Fra92, page 342] </ref>; so France's model includes explicit ways to make bubbles concurrent.
Reference: [Fra93] <author> R. B. </author> <title> France. A predicative basis for structured analysis specification tools. </title> <journal> Information and Software Technology, </journal> <volume> 35(2) </volume> <pages> 67-77, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: Within SA one specifies a data model using an Entity-Relationship Diagram (ERD) and a data dictionary, and the process by a Data Flow Diagram (DFD) <ref> [Fra93] </ref>. Because DFDs are widely-used [BB93], many tools support their development. <p> For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques. For example, Wing and Zaremski [WZ91] augment SA specifications (especially the data dictionary), with specifications in the Larch Shared Language [GHG + 93]. As another example, France <ref> [Fra93] </ref> [FLP95], has specified the types in a data dictionary using Z notation, and has used Z to augment the specifications of data stores and global state invariants. These extensions are relevant, because they indicate that there is a desire for integration of DFDs and formal methods. <p> In addition to the modeling of dynamic behavior, we believe that the following aspects of our semantics are interesting in the sense of finding a smaller theoretical core for DFDs. 1. DFD terminators (external entities) have a specified behavior, which is unusual (although found in <ref> [Fra93] </ref>); however, if no constraints on the terminators are desired, then the specification can simply permit arbitrary behaviors. 2. DFD stores, which are often seen as abstractions for files, can be modeled using only data flows that hold a single (possibly compound) value. <p> Nevertheless, our model is derived from his initial work. Coleman also gives several different possible models of stores, one of which [Col91, semantics of DFDs. Coleman does not treat a bubble firing concurrently with itself. 8.1.6 France In the two works [Fra92] <ref> [Fra93] </ref> that we discuss below, France describes variants of DFDs, specification notations, and their semantics. <p> A Predicative Basis for SA Specification Tools In <ref> [Fra93] </ref> France gives a different formalization of the semantics of DFDs, this one geared towards composition and decomposition of DFDs. In this work France uses a variant of DFDs he calls PDFDs, along with ERDs, and data dictionaries with ADT specifications. His PDFDs include terminators (external entities), as do ours. <p> In this work France uses a variant of DFDs he calls PDFDs, along with ERDs, and data dictionaries with ADT specifications. His PDFDs include terminators (external entities), as do ours. In <ref> [Fra93] </ref>, the behavior of a bubble is specified with an input/output predicate, which can be represented in our model as the functions that tell what a bubble produces and 28 consumes. However, his language is not able to express conditions on when a bubble is enabled.
Reference: [GHG + 93] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year> <month> 31 </month>
Reference-contexts: See [FLP94] for a survey that includes other such examples. For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques. For example, Wing and Zaremski [WZ91] augment SA specifications (especially the data dictionary), with specifications in the Larch Shared Language <ref> [GHG + 93] </ref>. As another example, France [Fra93] [FLP95], has specified the types in a data dictionary using Z notation, and has used Z to augment the specifications of data stores and global state invariants.
Reference: [GS78] <author> C. Gane and E. Sarson. </author> <title> Structured Systems Analysis: tools and techniques. </title> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference-contexts: 1 Introduction An approach to the development of software systems which has enjoyed wide-spread use in the software engineering community is Structured Analysis (SA) [DeM78] <ref> [GS78] </ref> [WM85] [You89]. Within SA one specifies a data model using an Entity-Relationship Diagram (ERD) and a data dictionary, and the process by a Data Flow Diagram (DFD) [Fra93]. Because DFDs are widely-used [BB93], many tools support their development.
Reference: [Hay93] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: For example, Fraser, Kumar, and Vaishnavi [FKV91] and Larsen, et al. [LvKP + 91] extract a VDM [BJ82] [Jon90] specification from a DFD and a data dictionary. As another example, Semmens and Allen [SA91] extract a Z <ref> [Hay93] </ref> [Spi92] [Spi89] specification from an application's ERD and DFD. See [FLP94] for a survey that includes other such examples. For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques.
Reference: [Hen90] <author> Matthew Hennessy. </author> <title> The Semantics of Programming Languages: an Elementary Introduction using Structural Operational Semantics. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: The conditions above the horizontal line must hold for the transition to be taken; they should be thought of as a hypothesis. That is, if the conditions above horizontal line hold, then the transition below the line may take place <ref> [Hen90] </ref>. bm (b) = idle; Enabled (b)(fs) = true; bm 0 = [b 7! working]bm; (fs 0 ; r 0 ) 2 Consume (b)(fs; r) (bm; r; fs) ! (bm 0 ; r 0 ; fs 0 ) The following transition rule states that if b is working, then it may <p> One might wish to abstract away from the sequences of configurations, in order to focus on the "answer" returned by a DFD. Indeed, this is often done in the semantics of programming languages given in Plotkin's structural style [Plo77] <ref> [Hen90] </ref>. To do this, one would identify a set of terminal configurations, from which no transitions are possible. However, such an attempt seems of little value for DFDs, because the sources may always be able to fire, as in our example.
Reference: [HJS90] <author> Peter Huber, Kurt Jensen, and Robert M. Shapiro. </author> <title> Hierarchies in Coloured Petri Nets. </title> <editor> In G. Rosenberg, editor, </editor> <booktitle> Advances in Petra nets 1990, volume 483 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: Nevertheless, it would be useful to have an operational semantics of DFDs that took the hierarchy into account (as in the semantics of hierarchical colored petri nets <ref> [HJS90] </ref> [CJ91]). 8.1.2 Ward Ward [War86] distinguishes discrete from continuous data flows; that is between discrete and analog data, which he defines as "a set of values defined continuously over a time interval" [War86, page 199]. Hatley and Pirbhai have a similar notion of continuity [HP87] [Col91, Section 5.3.2]. <p> Tse's work [Tse91] only deals with the syntax of DFDs, not their semantics. 8.1.4 Colored Petri Nets One can imagine giving a fuller account of the dynamic behavior of DFDs by extending Ward and Tse and Pong's approach with colored Petri nets [Jen91] <ref> [HJS90] </ref>. (The different "colors" on tokens can stand for different values being passed in a DFD.) However, because the firing rules of Petri nets are atomic, each bubble in a DFD would have to be either modeled by a complex Petri net, or the semantics of a bubble's firing would be
Reference: [HP87] <author> D. J. Hatley and I. Pirbhai. </author> <title> Strategies for Real-Time System Specification. </title> <publisher> Dorset House, </publisher> <address> New York, N.Y., </address> <year> 1987. </year>
Reference-contexts: Hatley and Pirbhai have a similar notion of continuity <ref> [HP87] </ref> [Col91, Section 5.3.2]. Since such data can only be modeled in a computer by discrete data, there seems to be no good reason to model this distinction.
Reference: [Jen91] <author> Kurt Jensen. </author> <title> Coloured Petri Nets: A High Level Language for System Analysis and Design. </title> <editor> In G. Rozenberg, editor, </editor> <booktitle> Advances in Petri Nets 1990, volume 483 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> Also a technical report from the CS Dept, </note> <institution> Aarhus University, DAIMI PB-338, </institution> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: Tse's work [Tse91] only deals with the syntax of DFDs, not their semantics. 8.1.4 Colored Petri Nets One can imagine giving a fuller account of the dynamic behavior of DFDs by extending Ward and Tse and Pong's approach with colored Petri nets <ref> [Jen91] </ref> [HJS90]. (The different "colors" on tokens can stand for different values being passed in a DFD.) However, because the firing rules of Petri nets are atomic, each bubble in a DFD would have to be either modeled by a complex Petri net, or the semantics of a bubble's firing would
Reference: [Jon90] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: Baker's work was supported in part by a grant from Rockwell International. 1 of making them more precise. For example, Fraser, Kumar, and Vaishnavi [FKV91] and Larsen, et al. [LvKP + 91] extract a VDM [BJ82] <ref> [Jon90] </ref> specification from a DFD and a data dictionary. As another example, Semmens and Allen [SA91] extract a Z [Hay93] [Spi92] [Spi89] specification from an application's ERD and DFD. See [FLP94] for a survey that includes other such examples.
Reference: [LvKP + 91] <author> Peter Gorm Larsen, Jan van Katwijk, Nico Plat, Kees Pronk, and Hans Toetenel. SVDM: </author> <title> An integrated combination of SA and VDM. In Methods Integration Conference. </title> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1991. </year>
Reference-contexts: Baker's work was supported in part by a grant from Rockwell International. 1 of making them more precise. For example, Fraser, Kumar, and Vaishnavi [FKV91] and Larsen, et al. <ref> [LvKP + 91] </ref> extract a VDM [BJ82] [Jon90] specification from a DFD and a data dictionary. As another example, Semmens and Allen [SA91] extract a Z [Hay93] [Spi92] [Spi89] specification from an application's ERD and DFD. See [FLP94] for a survey that includes other such examples.
Reference: [Lyl92] <author> Kari Ann Lyle. </author> <title> Refinement in Data Flow Diagrams. </title> <type> Master's thesis, </type> <institution> Iowa State University, Ames, Iowa 50011, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: While this is clearly a contrived example, this situation can arise any time one bubble is refined by multiple bubbles. If the bubble H could somehow hold the first value it consumes while consuming and producing output with the second, then the two DFDs would behave identically <ref> [Lyl92] </ref>. <p> However, there is no way to make a bubble concurrent with itself, and so no way to specify a bubble that may be refined into as system of bubbles that may process inputs in slightly different orders, which we permit by allowing a bubble to fire concurrently with itself <ref> [Lyl92] </ref>. A Predicative Basis for SA Specification Tools In [Fra93] France gives a different formalization of the semantics of DFDs, this one geared towards composition and decomposition of DFDs. In this work France uses a variant of DFDs he calls PDFDs, along with ERDs, and data dictionaries with ADT specifications.
Reference: [Pet77] <author> J. L. Peterson. </author> <title> Petri Nets. </title> <journal> ACM Computing Surveys, </journal> <volume> 9(3) </volume> <pages> 221-252, </pages> <month> September </month> <year> 1977. </year>
Reference-contexts: We call a snapshot at certain well-defined points of such an execution a configuration; it is similar to a marking of a Petri net <ref> [Pet77] </ref>.
Reference: [Plo77] <author> G. D. Plotkin. </author> <title> LCF Considered as a Programming Language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5 </volume> <pages> 223-255, </pages> <year> 1977. </year>
Reference-contexts: One might wish to abstract away from the sequences of configurations, in order to focus on the "answer" returned by a DFD. Indeed, this is often done in the semantics of programming languages given in Plotkin's structural style <ref> [Plo77] </ref> [Hen90]. To do this, one would identify a set of terminal configurations, from which no transitions are possible. However, such an attempt seems of little value for DFDs, because the sources may always be able to fire, as in our example.
Reference: [SA91] <author> L. Semmens and P. Allen. </author> <title> Using Yourdon and Z: An Approach to Formal Specification. In Z User Workshop. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: For example, Fraser, Kumar, and Vaishnavi [FKV91] and Larsen, et al. [LvKP + 91] extract a VDM [BJ82] [Jon90] specification from a DFD and a data dictionary. As another example, Semmens and Allen <ref> [SA91] </ref> extract a Z [Hay93] [Spi92] [Spi89] specification from an application's ERD and DFD. See [FLP94] for a survey that includes other such examples. For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques.
Reference: [Sch86] <author> David A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, Inc., </publisher> <address> Boston, Mass., </address> <year> 1986. </year>
Reference-contexts: readers familiar with such notational conventions to bear with us as we try to make this paper accessible to a wider audience. 4 The notation f : e denotes a function that takes an argument, and returns the value of the expression e with the argument substituted for f [Chu41] <ref> [Sch86] </ref>. 9 The function r e describes part of a configuration where the bubble Bill-Customer has read the order co from the flow f creditBC (see Table 1), and where Collections has read the payment pmt from f payment and an empty list from f log . 3.3 Information on a <p> The pair follows the in of the let in notation <ref> [Sch86] </ref>, with the first element of the pair before the comma, and the second after. 14 flows.
Reference: [Spi89] <author> J. Spivey. </author> <title> An Introduction to Z and Formal Specifications. </title> <journal> Software Engineering Journal, </journal> <month> January </month> <year> 1989. </year>
Reference-contexts: For example, Fraser, Kumar, and Vaishnavi [FKV91] and Larsen, et al. [LvKP + 91] extract a VDM [BJ82] [Jon90] specification from a DFD and a data dictionary. As another example, Semmens and Allen [SA91] extract a Z [Hay93] [Spi92] <ref> [Spi89] </ref> specification from an application's ERD and DFD. See [FLP94] for a survey that includes other such examples. For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques.
Reference: [Spi92] <author> J. Michael Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: For example, Fraser, Kumar, and Vaishnavi [FKV91] and Larsen, et al. [LvKP + 91] extract a VDM [BJ82] [Jon90] specification from a DFD and a data dictionary. As another example, Semmens and Allen [SA91] extract a Z [Hay93] <ref> [Spi92] </ref> [Spi89] specification from an application's ERD and DFD. See [FLP94] for a survey that includes other such examples. For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques.
Reference: [TP89] <author> T. H. Tse and L. Pong. </author> <title> Towards a Formal Foundation for Demarco Data Flow Diagrams. </title> <journal> The Computer Journal, </journal> <volume> 32(1) </volume> <pages> 1-12, </pages> <month> February </month> <year> 1989. </year> <month> 32 </month>
Reference-contexts: Our semantics can be regarded as a cleaned-up version of this idea. 26 8.1.3 Tse and Pong Tse and Pong recognize that: "Transitions and places of Petri nets correspond, respectively, to processes and data flows of DFDs" <ref> [TP89, page 1] </ref>. They also give an algebraic model of DFDs. However, their semantics using Petri nets also ignores the values on the flows and so cannot describe the full behavior of a DFD.
Reference: [Tse91] <author> T. H. Tse. </author> <title> A Unifying Framework for Structured Analysis and Design Models, </title> <booktitle> volume 11 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge Univerity Press, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: We have not described this translation formally because we did not want to go into the details of the graphical syntax of DFDs [Col91] <ref> [Tse91] </ref>, although we have given an example of one such translation. Another aspect of the semantics of an (extended) DFD specification is its initial configuration. <p> They also give an algebraic model of DFDs. However, their semantics using Petri nets also ignores the values on the flows and so cannot describe the full behavior of a DFD. Tse's work <ref> [Tse91] </ref> only deals with the syntax of DFDs, not their semantics. 8.1.4 Colored Petri Nets One can imagine giving a fuller account of the dynamic behavior of DFDs by extending Ward and Tse and Pong's approach with colored Petri nets [Jen91] [HJS90]. (The different "colors" on tokens can stand for different
Reference: [War86] <author> Paul T. Ward. </author> <title> The Transformation Schema: An Extension of the Data Flow Diagram to Represent Control and Timing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(2), </volume> <month> February </month> <year> 1986. </year>
Reference-contexts: Neither the flow name nor the type alone are sufficient to uniquely identify a flow in our example; having both labels eliminates a common source of ambiguity [Col91]. 1 In SA, DeMarco [DeM78] and others (e.g., <ref> [War86] </ref>) make a distinction between "discrete" and "continuous" flows. However, some authors seem to consider continuous flows as continuous in the sense of calculus (i.e., real-valued, differentiable). DeMarco and Ward seem to think of them as continuously existing (i.e., like a shared variable) even when read. <p> Again our model does not suffer from the ambiguity inherent in De Marco's DFDs. Ward, in <ref> [War86] </ref> gives notation to disambiguate these two senses of converging and diverging flows, but leaves the process by which tupling and splitting of data is achieved implicit. Similarly, our model can represent "dialogue flows" by two separate flows. <p> Nevertheless, it would be useful to have an operational semantics of DFDs that took the hierarchy into account (as in the semantics of hierarchical colored petri nets [HJS90] [CJ91]). 8.1.2 Ward Ward <ref> [War86] </ref> distinguishes discrete from continuous data flows; that is between discrete and analog data, which he defines as "a set of values defined continuously over a time interval" [War86, page 199]. Hatley and Pirbhai have a similar notion of continuity [HP87] [Col91, Section 5.3.2]. <p> of DFDs that took the hierarchy into account (as in the semantics of hierarchical colored petri nets [HJS90] [CJ91]). 8.1.2 Ward Ward [War86] distinguishes discrete from continuous data flows; that is between discrete and analog data, which he defines as "a set of values defined continuously over a time interval" <ref> [War86, page 199] </ref>. Hatley and Pirbhai have a similar notion of continuity [HP87] [Col91, Section 5.3.2]. Since such data can only be modeled in a computer by discrete data, there seems to be no good reason to model this distinction. <p> Hatley and Pirbhai have a similar notion of continuity [HP87] [Col91, Section 5.3.2]. Since such data can only be modeled in a computer by discrete data, there seems to be no good reason to model this distinction. Instead, we have adopted Ward's semantics for continuous flows as shared variables <ref> [War86, page 203] </ref> as a feature of flows in our model. This feature of flows is orthogonal to the type of data on the flow. This is the distinction between consumable and persistent flows [Col91, Section 5.3.4]. The traditional view of stores is that they represent files [War86, page 199]. <p> This feature of flows is orthogonal to the type of data on the flow. This is the distinction between consumable and persistent flows [Col91, Section 5.3.4]. The traditional view of stores is that they represent files <ref> [War86, page 199] </ref>. We model stores as persistent flows (shared variables), but as discussed in Section 6, the notion of a store containing a single value and a shared variable are equivalent. <p> Ward also includes in his extension of DFDs something called a "buffer", which is highly ambiguous. He says that a "buffer is an abstraction on a stack or a queue" <ref> [War86, page 200] </ref>. Stacks and (LIFO) queues certainly have different behavior. Ward gives a semantics of DFDs based "loosely on the execution of a Petri net" [War86, pages 203-205]. However, his semantics are somewhat informal and ambiguous. <p> He says that a "buffer is an abstraction on a stack or a queue" [War86, page 200]. Stacks and (LIFO) queues certainly have different behavior. Ward gives a semantics of DFDs based "loosely on the execution of a Petri net" <ref> [War86, pages 203-205] </ref>. However, his semantics are somewhat informal and ambiguous. For example, he does not clear up the ambiguity in the potential behavior of buffers.
Reference: [WBL93] <author> Tim Wahls, Albert L. Baker, and Gary T. Leavens. </author> <title> An Executable Semantics for a Formalized Data Flow Diagram Specification Language. </title> <type> Technical Report 93-27, </type> <institution> Department of Computer Science, Iowa State University, 226 Atanasoff Hall, Ames, Iowa 50011, </institution> <month> November </month> <year> 1993. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu or by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Due to space considerations, we will not give the details of an example extended DFD specification language (some preliminary ideas are, however, found in <ref> [WBL93] </ref>), or a translation from such a language into our semantic model. What we offer is a definition of the target of such a translation (the semantic model), and examples of translations which the reader can use to judge the suitability of our model.
Reference: [WM85] <author> Paul T. Ward and Stephen J. Mellor. </author> <title> Structured Development for Real-Time Systems, volume 1: Introduction and Tools. </title> <publisher> Yourdon, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1985. </year>
Reference-contexts: 1 Introduction An approach to the development of software systems which has enjoyed wide-spread use in the software engineering community is Structured Analysis (SA) [DeM78] [GS78] <ref> [WM85] </ref> [You89]. Within SA one specifies a data model using an Entity-Relationship Diagram (ERD) and a data dictionary, and the process by a Data Flow Diagram (DFD) [Fra93]. Because DFDs are widely-used [BB93], many tools support their development.
Reference: [WZ91] <author> Jeannette M. Wing and Amy Moormann Zaremski. </author> <title> Unintrusive Ways to Integrate Formal Specifications in Practice. </title> <editor> In S. Prehn and W. J. Toetenel, editors, </editor> <booktitle> VDM '91 Formal Software Development Methods 4th International Symposium of VDM Europe Noordwijkerhout, The Netherlands, Volume 1: Conference Contributions, volume 551 of Lecture Notes in Computer Science, </booktitle> <pages> pages 545-569. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> October </month> <year> 1991. </year>
Reference-contexts: See [FLP94] for a survey that includes other such examples. For this paper, the more relevant techniques are those that use formal notations to supplement SA techniques. For example, Wing and Zaremski <ref> [WZ91] </ref> augment SA specifications (especially the data dictionary), with specifications in the Larch Shared Language [GHG + 93]. As another example, France [Fra93] [FLP95], has specified the types in a data dictionary using Z notation, and has used Z to augment the specifications of data stores and global state invariants.
Reference: [You89] <author> Edward Yourdon. </author> <title> Modern Structured Analysis. </title> <publisher> Yourdon Press computing series. Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1989. </year> <month> 33 </month>
Reference-contexts: 1 Introduction An approach to the development of software systems which has enjoyed wide-spread use in the software engineering community is Structured Analysis (SA) [DeM78] [GS78] [WM85] <ref> [You89] </ref>. Within SA one specifies a data model using an Entity-Relationship Diagram (ERD) and a data dictionary, and the process by a Data Flow Diagram (DFD) [Fra93]. Because DFDs are widely-used [BB93], many tools support their development. <p> For example, De Marco has graphical notations on flows for "conjunction" (*) and "disjunction" () that are not a part of our formal model of the syntax of DFDs. Similarly, Yourdon makes graphical distinctions between "data" and "control" flows <ref> [You89] </ref> [Col91, pages 27-28]. However, our formal model can encode this kind of information in a general way.
References-found: 36

