URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/hypotheticals/naclp89.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@paul.rutgers.edu  
Title: Expressing Database Queries with Intuitionistic Logic  
Author: Anthony J. Bonner L. Thorne McCarty Kumar Vadaparty 
Date: October 16-20 1989.  
Note: Appears in Proceedings of the North American Conference on Logic Programming (NACLP), pages 831-850. MIT press. Conference held in Cleveland, Ohio,  
Address: New Brunswick, NJ 08903  
Affiliation: Rutgers University Department of Computer Science  
Abstract: This paper develops a declarative language with intuitionistic semantics which expresses exactly the generic database queries. Syntactically, the language is an extension of Datalog (function-free Horn logic) which allows rules themselves to appear in the bodies of other rules. Such rules are called embedded implications. Several researchers have studied restricted versions of these rules, but in their full incarnation, universal quantifiers may appear in the premises, as in the rule A 8 x [B(x) C(x)]. This paper focuses on these embedded universal quantifiers. It is shown, for instance, that such quantifiers give the logic the ability to create new constant symbols hypothetically during inference. This, in turn, allows the logic to simulate unbounded counters and arbitrary Turing machines. In addition, when the logic is augmented with negation-as-failure, it becomes expressively complete, that is, it can express any database query which is typed and generic. Similar results exist for other languages, but the novelty of this work is that expressive completeness is achieved with a declarative language based on a well-established semantics, i.e., intuitionistic semantics. Indeed, the paper presents a simple proof of the intuitionistic completeness of the logic. This paper is available at the following URL: ftp://db.toronto.edu/pub/bonner/papers/hypotheticals/naclp89.ps.gz 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and V. Vianu. </author> <title> A Transaction Language Complete for Database Update Specification. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 260-268, </pages> <year> 1987. </year> <note> Published in expanded form as Rapports de Recherche no. 715, </note> <institution> INRIA, </institution> <address> 78153 Le Chesnay Cedex, France. </address> <month> 23 </month>
Reference-contexts: A central result of this paper is that the augmented language is expressively complete; that is, it can express any database query which is typed and generic. Furthermore, with simple syntactic restrictions, the logic expresses exactly these queries, and no more. Similar results exist for other languages <ref> [7, 1, 2] </ref>, but the novelty of the present work is that expressive completeness is achieved with a declarative language based on a well-established semantics, i.e., in-tuitionistic semantics. <p> In their ability to create and manipulate new constant symbols, embedded implications are similar to other database query languages. Abiteboul and Vianu, in particular, have developed a family of procedural and declarative languages with such capabilities <ref> [1, 2] </ref>. The language presented in this paper is comparable to their Deterministic Declarative Language detDL in that constant symbols created during inference will not appear in the answer to a query.
Reference: [2] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <type> Technical Report 900, </type> <institution> Institut National de Recherche en Informatique et en Automatique (INRIA), </institution> <address> Le Chesnay Cedex, France, </address> <year> 1988. </year>
Reference-contexts: A central result of this paper is that the augmented language is expressively complete; that is, it can express any database query which is typed and generic. Furthermore, with simple syntactic restrictions, the logic expresses exactly these queries, and no more. Similar results exist for other languages <ref> [7, 1, 2] </ref>, but the novelty of the present work is that expressive completeness is achieved with a declarative language based on a well-established semantics, i.e., in-tuitionistic semantics. <p> In their ability to create and manipulate new constant symbols, embedded implications are similar to other database query languages. Abiteboul and Vianu, in particular, have developed a family of procedural and declarative languages with such capabilities <ref> [1, 2] </ref>. The language presented in this paper is comparable to their Deterministic Declarative Language detDL in that constant symbols created during inference will not appear in the answer to a query.
Reference: [3] <author> A.J. Bonner. </author> <title> A Logic for Hypothetical Reasoning. </title> <booktitle> In Proceedings of the Seventh National Conference on Artificial Intelligence, </booktitle> <pages> pages 480-484, </pages> <address> Saint Paul, MN, </address> <month> August 21-26 </month> <year> 1988. </year> <note> Published in expanded form as Technical Report TR-DCS-230, </note> <institution> Department of Computer Science, Rutgers University, </institution> <address> New Brunswick, NJ 08903. </address>
Reference-contexts: Syntactic restrictions have also been identified which express the database queries at each level in the polynomial time hierarchy [6]. Furthermore, there is a precise sense in which some low-complexity queries can be expressed with intuition-istic embedded implications but not with classical logic, even full first-order classical logic <ref> [3] </ref>. Theoretical research into the restricted case thus appears well developed. In contrast, research into the unrestricted case is still in progress. McCarty has developed a fixpoint semantics for embedded impli 2 cations based on intuitionistic logic [15] as well as a practical proof procedure [16]. <p> Note that the premise of the first rule is a query similar to the one in example 2. <ref> [3] </ref> gives a precise sense in which such rules cannot be expressed in Datalog.
Reference: [4] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Complexity and Expressibility. </title> <booktitle> In Proceedings of the International Conference on Database Theory (ICDT), </booktitle> <pages> pages 144-160. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <note> Published as volume 326 of Lecture Notes in Computer Science. </note>
Reference-contexts: Bonner has shown that query evaluation in such systems is data-complete for PSPACE in the function-free case <ref> [4] </ref>. Furthermore, when this logic is augmented with negation-as-failure, any database query whose graph is in PSPACE can be expressed [4]. Syntactic restrictions have also been identified which express the database queries at each level in the polynomial time hierarchy [6]. <p> Bonner has shown that query evaluation in such systems is data-complete for PSPACE in the function-free case <ref> [4] </ref>. Furthermore, when this logic is augmented with negation-as-failure, any database query whose graph is in PSPACE can be expressed [4]. Syntactic restrictions have also been identified which express the database queries at each level in the polynomial time hierarchy [6]. Furthermore, there is a precise sense in which some low-complexity queries can be expressed with intuition-istic embedded implications but not with classical logic, even full first-order classical logic [3]. <p> In contrast, when embedded implications do not have this ability, they can only implement counters of polynomial range and can only simulate PSPACE-machines <ref> [4] </ref>. Finally, when embedded implications are augmented with negation-as-failure, they acquire the ability to express non-monotonic queries. A central result of this paper is that the augmented language is expressively complete; that is, it can express any database query which is typed and generic. <p> In section 5, this ability is used to simulate unbounded counters and arbitrary Turing machines. Without the ability to create new constant symbols, it would only be possible to simulate Turing machines that use a polynomial amount of space, i.e., PSPACE-machines <ref> [4] </ref>. Example 7. <p> The main idea is to construct a rulebase which encodes the transition function of an arbitrary Turing machine. Besides establishing undecidability, these encodings are the basis of the expressibility results in the next section. The encodings themselves are an adaptation of those used in <ref> [4] </ref> to encode PSPACE machines. <p> By 18 augmenting the logic with negation-as-failure, non-monotonic queries can be expressed as well. In fact, this augmented logic is expressively complete; that is, it can express any typed, generic query. This is the main result of this section. The proof itself is an adaptation of proofs found in <ref> [4] </ref> and [6]. In [4] it is shown that when universal quantifiers are not allowed in the premise of a rule, then embedded implications express exactly the typed, generic queries in PSPACE. <p> In fact, this augmented logic is expressively complete; that is, it can express any typed, generic query. This is the main result of this section. The proof itself is an adaptation of proofs found in <ref> [4] </ref> and [6]. In [4] it is shown that when universal quantifiers are not allowed in the premise of a rule, then embedded implications express exactly the typed, generic queries in PSPACE. <p> Semantically, this amounts to a hypothetical expansion of the data domain. The investigation of embedded implications is a natural continuation of other work on hypothetical reasoning. In particular, in <ref> [4, 6] </ref>, the language Hypothetical Datalog is developed, in which entries can be hypothetically added or removed from a database during inference. This paper has augmented this work by studying the hypothetical expansion of the data domain as well as the hypothetical addition of arbitrary rules.
Reference: [5] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Complexity and Expressibility. </title> <type> Technical Report DCS-TR-231, </type> <institution> Department of Computer Science, Rut-gers university, </institution> <address> New Brunswick, NJ 08903, </address> <year> 1988. </year> <note> Also published in volume 76 (1990) of Theoretical Computer Science (TCS), pages 3-51. </note>
Reference-contexts: Such rules are necessary because we are representing time explicitly and must therefore copy the unchanged portion of an id from one instant of time to the next. The rules themselves are straightforward. Details may be found in <ref> [5] </ref>. These rules complete the definition of the rulebase R (M ), thereby estab lishing formula (4), and thus formula (3). 6 Expressive Completeness This section views our inference system as a query language for relational databases and investigates its expressibility. <p> Theorem 4, however, is more difficult and relies on the encodings of Turing machines developed in section 5. 6.2 Sketch of Proof This section outlines the proof of theorem 4. The proof is a simple adaptation of that in <ref> [5] </ref>, to which the interested reader is referred for details. The first step is to reduce the problem of expressing typed queries to that of expressing yes/no queries. Whereas a typed query returns a set of tuples, a yes/no query simply returns true or false. <p> Embedded implications and negation-as-failure are essential to these rules. It is not necessary, however, to use universal quantifiers in the rule bodies, and consequently, the rules are similar to those found in <ref> [5] </ref>. The interested reader is thus referred to this report for details. 22 7 Discussion This paper has identified a subset of intuitionistic logic which expresses exactly the generic database queries. Syntactically, it is an extension of Datalog in which rules themselves may appear in the bodies of other rules.
Reference: [6] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Negation and Linear Recursion. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 286-300, </pages> <address> Philadelphia, PA, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: Furthermore, when this logic is augmented with negation-as-failure, any database query whose graph is in PSPACE can be expressed [4]. Syntactic restrictions have also been identified which express the database queries at each level in the polynomial time hierarchy <ref> [6] </ref>. Furthermore, there is a precise sense in which some low-complexity queries can be expressed with intuition-istic embedded implications but not with classical logic, even full first-order classical logic [3]. Theoretical research into the restricted case thus appears well developed. <p> In fact, this augmented logic is expressively complete; that is, it can express any typed, generic query. This is the main result of this section. The proof itself is an adaptation of proofs found in [4] and <ref> [6] </ref>. In [4] it is shown that when universal quantifiers are not allowed in the premise of a rule, then embedded implications express exactly the typed, generic queries in PSPACE. In [6], syntactic restrictions are identified which enable embedded implications to express exactly the queries in NP and the queries in <p> The proof itself is an adaptation of proofs found in [4] and <ref> [6] </ref>. In [4] it is shown that when universal quantifiers are not allowed in the premise of a rule, then embedded implications express exactly the typed, generic queries in PSPACE. In [6], syntactic restrictions are identified which enable embedded implications to express exactly the queries in NP and the queries in each level of the polynomial time hierarchy. The interested reader is referred to these papers for details which, for reasons of space, have not been included in this paper. <p> Semantically, this amounts to a hypothetical expansion of the data domain. The investigation of embedded implications is a natural continuation of other work on hypothetical reasoning. In particular, in <ref> [4, 6] </ref>, the language Hypothetical Datalog is developed, in which entries can be hypothetically added or removed from a database during inference. This paper has augmented this work by studying the hypothetical expansion of the data domain as well as the hypothetical addition of arbitrary rules.
Reference: [7] <author> A.K. Chandra and D. Harel. </author> <title> Computable Queries for Relational Databases. </title> <journal> Journal of Computer and System Sciences (JCSS), </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: A central result of this paper is that the augmented language is expressively complete; that is, it can express any database query which is typed and generic. Furthermore, with simple syntactic restrictions, the logic expresses exactly these queries, and no more. Similar results exist for other languages <ref> [7, 1, 2] </ref>, but the novelty of the present work is that expressive completeness is achieved with a declarative language based on a well-established semantics, i.e., in-tuitionistic semantics. <p> Central to this result are the notions of typed databases and of generic database queries. These notions have been defined precisely by Chandra and Harel <ref> [7, 8] </ref>, and the definitions are repeated here. Syntactic restrictions are then developed which guarantee that a set of embedded implications will implement a generic database query. Finally, a precise statement of the main result is given. Informally, this result provides a syntactic characterization of the generic database queries.
Reference: [8] <author> A.K. Chandra and D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <booktitle> In Proceedings of the Symposium on the Foundations of Computer Science (FOCS), </booktitle> <pages> pages 333-347, </pages> <year> 1980. </year>
Reference-contexts: This is sufficient to make inference complete while keeping it within re. The following example demonstrates some of the expressive power of embedded implications. In particular, it uses embedded implications with negation to implement the query EVEN , a query which cannot be expressed in Datalog with negation <ref> [8] </ref>. Example 8. Suppose that DB is a set of ground atomic formulas of the form A (x). <p> Central to this result are the notions of typed databases and of generic database queries. These notions have been defined precisely by Chandra and Harel <ref> [7, 8] </ref>, and the definitions are repeated here. Syntactic restrictions are then developed which guarantee that a set of embedded implications will implement a generic database query. Finally, a precise statement of the main result is given. Informally, this result provides a syntactic characterization of the generic database queries.
Reference: [9] <author> M.C. </author> <title> Fitting. Intuitionistic Logic, Model Theory and Forcing. </title> <publisher> North-Holland, </publisher> <year> 1969. </year>
Reference-contexts: We now show that it is intuitionistic; that is, the inference system is both sound and complete with respect to intuitionistic semantics. 8 4.1 Intuitionistic Logic This section defines the semantics of first-order intuitionistic logic in the function-free case. A more extensive treatment may be found in <ref> [9] </ref>. Recall that the syntax of the logic is first-order and that it includes three infinte sets: a set of variables x; y; z; :::, a set of constant symbols a; b; c; :::, and a set of predicate symbols A; B; C; :::. <p> Note that unlike classical logic, intuitionistic implication is not defined in terms of disjunction and negation. Rather, it has an independent semantic definition. An intuitive interpretation of this semantics may be found in [13] and <ref> [9] </ref>. The following basic result is an immediate consequence of the above definitions. Lemma 5 s; M j= iff r; M j= for all r s. Definition 6 (Models) M j= iff s; M j= for all substates s of M such that 2 F (s). <p> The proofs of these five statements are not difficult. The first four follow in a straightforward way from the definitions of intuitionistic satisfaction and entailment. The fifth statement is closely related to theorems given in <ref> [9] </ref> and can be proved along similar lines. 4.3 Completeness This section establishes the completeness of the inference system defined above using a construction inspired by the Henkin constructions of modal logic [12]. <p> Neither of these properties is true of intuitionistic entailment in general. Indeed, the possibility of variable domains is the source of some interesting differences between classical and intuitionistic logic <ref> [9] </ref>. Many of these differences do not appear when reasoning only with embedded implications. 5 Semi-Decidability This section shows that the inference system defined in section 3 is semi-decidable. That is, the problem of determining whether the expression R ` can be derived is in re but is non-recursive.
Reference: [10] <author> D.M. Gabbay. N-Prolog: </author> <title> an Extension of Prolog with Hypothetical Implications. II. Logical Foundations and Negation as Failure. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 2(4) </volume> <pages> 251-283, </pages> <year> 1985. </year>
Reference-contexts: Thus, we are considering the most general extension of Datalog in which rules themselves may appear in the bodies of other rules. Interesting theoretical results have been established for embedded implications in the restricted case: Gabbay has shown that such rules have an intuitionistic semantics <ref> [10] </ref>, and Miller has developed a fixpoint semantics for the predicate case [18]. Bonner has shown that query evaluation in such systems is data-complete for PSPACE in the function-free case [4]. <p> Proof theoretically, the creation of hypothetical objects means creating new constant symbols to represent them. The next section describes an inference system which does exactly this. 3 Inference This section defines a logical inference system for embedded implications. Such systems have been developed by several researchers <ref> [11, 10, 14, 16, 18] </ref>. The one presented in this section is different from most in that it allows universal quantifiers in the body of a rule. In the logic programming context, such rules were originally treated by McCarty [15, 16].
Reference: [11] <editor> D.M. Gabbay and U. Reyle. N-Prolog: </editor> <title> an Extension of Prolog with Hypothetical Implications. I. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 1(4) </volume> <pages> 319-355, </pages> <year> 1984. </year>
Reference-contexts: The legal domain has inspired much work into embedded implications. Gabbay, for instance, has reported a need to augment Prolog with such rules in order to encode the British Nationality Act <ref> [11] </ref>, and McCarty has used such rules as the foundation of a general "Language for Legal Discourse" [17]. Most research so far has focussed on a subset of embedded implications in which universal quantifiers do not appear in the bodies of rules. <p> Proof theoretically, the creation of hypothetical objects means creating new constant symbols to represent them. The next section describes an inference system which does exactly this. 3 Inference This section defines a logical inference system for embedded implications. Such systems have been developed by several researchers <ref> [11, 10, 14, 16, 18] </ref>. The one presented in this section is different from most in that it allows universal quantifiers in the body of a rule. In the logic programming context, such rules were originally treated by McCarty [15, 16].
Reference: [12] <author> G.E. Hughes and M.J. Cresswell. </author> <title> An Introduction to Modal Logic. </title> <publisher> Methuen and Co. Ltd., </publisher> <address> London, </address> <year> 1968. </year>
Reference-contexts: The fifth statement is closely related to theorems given in [9] and can be proved along similar lines. 4.3 Completeness This section establishes the completeness of the inference system defined above using a construction inspired by the Henkin constructions of modal logic <ref> [12] </ref>. Given a set R of embedded implications, we define an intuitionistic structure M R called the canonical model of R. This structure, defined proof-theoretically, provides the necessary link between inference and semantics.
Reference: [13] <author> S. Kripke. </author> <title> Semantical Analysis of Intuitionistic Logic. </title> <editor> I. In J.N. Cross-ley and M.A.E. Dummett, editors, </editor> <booktitle> Formal Systems and Recursive Functions, </booktitle> <pages> pages 92-130. </pages> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1965. </year> <month> 24 </month>
Reference-contexts: Note that unlike classical logic, intuitionistic implication is not defined in terms of disjunction and negation. Rather, it has an independent semantic definition. An intuitive interpretation of this semantics may be found in <ref> [13] </ref> and [9]. The following basic result is an immediate consequence of the above definitions. Lemma 5 s; M j= iff r; M j= for all r s. Definition 6 (Models) M j= iff s; M j= for all substates s of M such that 2 F (s).
Reference: [14] <author> Sanjay Manchanda. </author> <title> A Dynamic Logic Programming Language for Re--lational Updates. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, State University of New York at Stony Brook, Stony Brook, </institution> <address> New York, </address> <month> De-cember </month> <year> 1987. </year> <note> Also published as Technical Report TR 88-2, </note> <institution> Department of Computer Science, The University of Arizona, Tuscon, Arizona 85721, </institution> <month> January, </month> <year> 1988. </year>
Reference-contexts: Miller, for instance, has shown that such rules can structure the runtime environment of a logic program [18]; and Warren and Manchanda have proposed such logics for reasoning about database updates <ref> [20, 14] </ref>. The legal domain has inspired much work into embedded implications. <p> Proof theoretically, the creation of hypothetical objects means creating new constant symbols to represent them. The next section describes an inference system which does exactly this. 3 Inference This section defines a logical inference system for embedded implications. Such systems have been developed by several researchers <ref> [11, 10, 14, 16, 18] </ref>. The one presented in this section is different from most in that it allows universal quantifiers in the body of a rule. In the logic programming context, such rules were originally treated by McCarty [15, 16].
Reference: [15] <author> L.T. McCarty. </author> <title> Clausal Intuitionistic Logic. I. Fixed-Point Semantics. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 5(1) </volume> <pages> 1-31, </pages> <year> 1988. </year>
Reference-contexts: Thus rules of the form A (x) [B (x) C (x)] have been considered, while rules of the form A 8 x [B (x) C (x)] have not, one exception being the work of McCarty <ref> [15, 16] </ref>. An embedded implication in which universal quantifiers do not appear in the rule body shall be said to have restricted universal quantification. This paper examines the unrestricted case. In addition, to maintain a database emphasis, attention is focussed on the function-free case. <p> Theoretical research into the restricted case thus appears well developed. In contrast, research into the unrestricted case is still in progress. McCarty has developed a fixpoint semantics for embedded impli 2 cations based on intuitionistic logic <ref> [15] </ref> as well as a practical proof procedure [16]. Nadathur and Miller have also investigated the unrestricted case, using it as the basis for an extension of Prolog called Prolog [19]. But the complexity and expressiblity of unrestricted embedded implications have not yet been addressed. <p> Such systems have been developed by several researchers [11, 10, 14, 16, 18]. The one presented in this section is different from most in that it allows universal quantifiers in the body of a rule. In the logic programming context, such rules were originally treated by McCarty <ref> [15, 16] </ref>. <p> The one presented in this section is different from most in that it allows universal quantifiers in the body of a rule. In the logic programming context, such rules were originally treated by McCarty [15, 16]. In particular, <ref> [15] </ref> develops an intuitionistic fixpoint semantics for embedded implications, and [16] provides a practical proof-procedure. 5 The inference system below assumes the existence of three infinite, enu-merable sets: a set of variables x; y; z; :::, a set of constant symbols a; b; c; :::, and a set of predicate symbols
Reference: [16] <author> L.T. McCarty. </author> <title> Clausal Intuitionistic Logic. II. Tableau Proof Procedures. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 5(2) </volume> <pages> 93-132, </pages> <year> 1988. </year>
Reference-contexts: Thus rules of the form A (x) [B (x) C (x)] have been considered, while rules of the form A 8 x [B (x) C (x)] have not, one exception being the work of McCarty <ref> [15, 16] </ref>. An embedded implication in which universal quantifiers do not appear in the rule body shall be said to have restricted universal quantification. This paper examines the unrestricted case. In addition, to maintain a database emphasis, attention is focussed on the function-free case. <p> Theoretical research into the restricted case thus appears well developed. In contrast, research into the unrestricted case is still in progress. McCarty has developed a fixpoint semantics for embedded impli 2 cations based on intuitionistic logic [15] as well as a practical proof procedure <ref> [16] </ref>. Nadathur and Miller have also investigated the unrestricted case, using it as the basis for an extension of Prolog called Prolog [19]. But the complexity and expressiblity of unrestricted embedded implications have not yet been addressed. This is the main subject of the present paper. <p> Proof theoretically, the creation of hypothetical objects means creating new constant symbols to represent them. The next section describes an inference system which does exactly this. 3 Inference This section defines a logical inference system for embedded implications. Such systems have been developed by several researchers <ref> [11, 10, 14, 16, 18] </ref>. The one presented in this section is different from most in that it allows universal quantifiers in the body of a rule. In the logic programming context, such rules were originally treated by McCarty [15, 16]. <p> Such systems have been developed by several researchers [11, 10, 14, 16, 18]. The one presented in this section is different from most in that it allows universal quantifiers in the body of a rule. In the logic programming context, such rules were originally treated by McCarty <ref> [15, 16] </ref>. <p> The one presented in this section is different from most in that it allows universal quantifiers in the body of a rule. In the logic programming context, such rules were originally treated by McCarty [15, 16]. In particular, [15] develops an intuitionistic fixpoint semantics for embedded implications, and <ref> [16] </ref> provides a practical proof-procedure. 5 The inference system below assumes the existence of three infinite, enu-merable sets: a set of variables x; y; z; :::, a set of constant symbols a; b; c; :::, and a set of predicate symbols A; B; C; :::. <p> In particular, it is created when rule 5 is invoked in a top-down mode. The ability to create constants in this way is crucial to the inference system. 7 Indeed, it is the basis of the top-down proof procedure given in <ref> [16] </ref>. In section 5, this ability is used to simulate unbounded counters and arbitrary Turing machines. Without the ability to create new constant symbols, it would only be possible to simulate Turing machines that use a polynomial amount of space, i.e., PSPACE-machines [4]. Example 7.
Reference: [17] <author> L.T. McCarty. </author> <title> A Language for Legal Discourse. I. Basic Features. </title> <booktitle> In Proceedings of the Second International Conference on Artificial Intelligence and Law, </booktitle> <pages> pages 180-189. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: The legal domain has inspired much work into embedded implications. Gabbay, for instance, has reported a need to augment Prolog with such rules in order to encode the British Nationality Act [11], and McCarty has used such rules as the foundation of a general "Language for Legal Discourse" <ref> [17] </ref>. Most research so far has focussed on a subset of embedded implications in which universal quantifiers do not appear in the bodies of rules.
Reference: [18] <author> D. Miller. </author> <title> A Logical Analysis of Modules in Logic Programming. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 6 </volume> <pages> 79-108, </pages> <year> 1989. </year>
Reference-contexts: Such rules are called embedded implications. Several researchers in the logic-programming and database communities have pointed out the utility of embedded implications, and have developed inference systems for them. Miller, for instance, has shown that such rules can structure the runtime environment of a logic program <ref> [18] </ref>; and Warren and Manchanda have proposed such logics for reasoning about database updates [20, 14]. The legal domain has inspired much work into embedded implications. <p> Interesting theoretical results have been established for embedded implications in the restricted case: Gabbay has shown that such rules have an intuitionistic semantics [10], and Miller has developed a fixpoint semantics for the predicate case <ref> [18] </ref>. Bonner has shown that query evaluation in such systems is data-complete for PSPACE in the function-free case [4]. Furthermore, when this logic is augmented with negation-as-failure, any database query whose graph is in PSPACE can be expressed [4]. <p> Proof theoretically, the creation of hypothetical objects means creating new constant symbols to represent them. The next section describes an inference system which does exactly this. 3 Inference This section defines a logical inference system for embedded implications. Such systems have been developed by several researchers <ref> [11, 10, 14, 16, 18] </ref>. The one presented in this section is different from most in that it allows universal quantifiers in the body of a rule. In the logic programming context, such rules were originally treated by McCarty [15, 16].
Reference: [19] <author> G. Nadathur and D. Miller. </author> <title> An Overview of Prolog. </title> <editor> In R.A. Kowalski and K.A. Bowen, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <pages> pages 810-827, </pages> <address> Cambridge, MA, 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: McCarty has developed a fixpoint semantics for embedded impli 2 cations based on intuitionistic logic [15] as well as a practical proof procedure [16]. Nadathur and Miller have also investigated the unrestricted case, using it as the basis for an extension of Prolog called Prolog <ref> [19] </ref>. But the complexity and expressiblity of unrestricted embedded implications have not yet been addressed. This is the main subject of the present paper. When interpreted intuitionistically, the presence of universal quantifiers in rule bodies gives embedded implications the ability to create new constant symbols during inference.
Reference: [20] <author> D.S. Warren. </author> <title> Database Updates in Pure Prolog. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 244-253, </pages> <year> 1984. </year>
Reference-contexts: Miller, for instance, has shown that such rules can structure the runtime environment of a logic program [18]; and Warren and Manchanda have proposed such logics for reasoning about database updates <ref> [20, 14] </ref>. The legal domain has inspired much work into embedded implications.
References-found: 20

