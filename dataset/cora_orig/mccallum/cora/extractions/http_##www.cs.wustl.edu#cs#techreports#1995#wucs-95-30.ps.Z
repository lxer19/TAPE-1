URL: http://www.cs.wustl.edu/cs/techreports/1995/wucs-95-30.ps.Z
Refering-URL: http://www.cs.wustl.edu/~gokhale/vita.html
Root-URL: 
Title: Design of a Tool for Rapid Prototyping of Communication Protocols  
Author: Aniruddha Gokhale (gokhale@cs.wustl.edu) Ron Cytron George Varghese 
Keyword: Communication Protocols, Prototyping, Tools, Compiler Technology.  
Address: Box 1045 St. Louis, MO 63130  
Affiliation: Department of Computer Science Washington University  
Email: (cytron@cs.wustl.edu)  (varghese@cs.wustl.edu)  
Phone: Phone: (314)935-6160 Fax: (314)935-7302  
Date: October 16, 1995  
Abstract: We present a new tool for automatically generating prototypes of communication protocols on a wide variety of platforms. Our goal is to reduce design time, enhance portability, and accommodate optimizations automatically. Users of the tool are required to provide an abstract implementation of the protocol in C++ without worrying about the underlying operating system specific system calls. Instead, the user employs high-level interface functions provided by the tool to interact with the underlying operating system. Users also need not worry about complex packet formats that involve fields of various bit and byte lengths. Instead, they use simple C/C++ struct declarations to describe the packets and provide mapping rules in the form of Extended Regular Expressions to the tool. The tool uses these rules to convert between the network format and the user defined format. Experience with TFTP and SMTP prototypes indicate that the performance achieved is almost comparable to that of the standard BSD implementations; at the same time the code size requirements of the abstract implementation is roughly 3 times less than the BSD implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abbott and L. Peterson. </author> <title> Increasing Network Throughput by Integrating Protocol Layers. </title> <journal> ACM Transactions on Networking, </journal> <volume> 1(5), </volume> <month> October </month> <year> 1993. </year>
Reference-contexts: In particular, we have a strategy for automating header prediction, in which tests for the expected case are optimized. * Automatically customize common protocol functions like lookups to the reference patterns of particular environments [5]. * Extend existing work in compiler optimizations <ref> [3, 1] </ref> applied to network protocol implemen tations. * Apply existing techniques from the work on optimizing compilers to unify various ad hoc techniques. Our vision is that the writing of network software should become an engineering discipline, one that can be easily taught to and mastered by undergraduates.
Reference: [2] <author> D. Bacon, A. Dupuy, J. Schwartz, and Y. Yemini. </author> <title> Nest: A Network Simulation and Prototyping Tool. </title> <booktitle> In Proceedings of the Winter 1988 Usenix Conference, Dallas, 1988. USENIX. </booktitle>
Reference-contexts: The user has to provide the abstract implementation and the network topology, and the tool outputs a discrete event simulation of the protocol on the given topology. The literature on network protocol simulation is too prolific to report here. For example, the Nest <ref> [2] </ref> tool provides a tool for simulating distributed systems. However, most simulators that we know of are not capable of producing prototypes. 1.5 Organization This paper discusses the design considerations and protocol prototyping experiences with such a tool. <p> 0.24 _recvfrom [9] 13.2 16.45 2.96 11957 0.25 0.25 _write [11] 13.0 19.37 2.92 47750 0.06 0.06 _setitimer [12] 5.1 20.52 1.15 11947 0.10 0.10 _read [13] Profile for Our tftp % cumulative self self total time seconds seconds calls ms/call ms/call name 24.0 10.36 10.36 26280 0.39 0.39 _sendto <ref> [2] </ref> 9.5 14.45 4.09 52526 0.08 0.08 _select [7] 9.1 18.37 3.92 14351 0.27 0.27 _write [9] 8.2 21.91 3.54 26274 0.13 0.13 _recvfrom [10] 6.0 24.49 2.58 131347 0.02 0.02 _gettimeofday [13] 4.3 26.35 1.86 _char2byte__6BUFFERRci [16] 4.3 28.20 1.85 11948 0.15 0.15 _read [17] 3.8 29.85 1.65 _byte2char__6BUFFERiRc [18]
Reference: [3] <author> D. D. Clark and D. L. Tennenhouse. </author> <title> Architectural Considerations for a New Generation of Protocols. </title> <booktitle> In SIGCOMM Symposium on Communications Architectures and Protocols, </booktitle> <address> Philadelphia, Pennsylvania, </address> <month> September </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: In particular, we have a strategy for automating header prediction, in which tests for the expected case are optimized. * Automatically customize common protocol functions like lookups to the reference patterns of particular environments [5]. * Extend existing work in compiler optimizations <ref> [3, 1] </ref> applied to network protocol implemen tations. * Apply existing techniques from the work on optimizing compilers to unify various ad hoc techniques. Our vision is that the writing of network software should become an engineering discipline, one that can be easily taught to and mastered by undergraduates.
Reference: [4] <author> N. C. Hutchinson and L. Peterson. </author> <title> The x-Kernel: An Architecture for Implementing Network Protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1), </volume> <month> January </month> <year> 1991. </year>
Reference-contexts: Related Work A number of tools for protocol prototyping or simulation appear in the literature. We first distinguish our approach (compiling abstract implementations) from what we call the virtual machine approach. The virtual machine approach, as exemplified by the x-Kernel <ref> [4] </ref>, raises the level of abstraction of network-level programming without taking advantage of compile-time analysis. This is done by providing a suite of useful library functions for many common protocol tasks. Our approach is more general because it allows compile-time analysis based on a complete scan of the program text.
Reference: [5] <author> Raj Jain. </author> <title> Packet Trains: Measurements and a New Model for Computer Traffic. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 4(6) </volume> <pages> 1162-1167, </pages> <month> May </month> <year> 1986. </year> <month> 17 </month>
Reference-contexts: In particular, we have a strategy for automating header prediction, in which tests for the expected case are optimized. * Automatically customize common protocol functions like lookups to the reference patterns of particular environments <ref> [5] </ref>. * Extend existing work in compiler optimizations [3, 1] applied to network protocol implemen tations. * Apply existing techniques from the work on optimizing compilers to unify various ad hoc techniques.
Reference: [6] <author> SUN Microsystems. XDR: </author> <title> External Data Representation Standard. </title> <type> Technical Report RFC 1014, </type> <institution> Sun Microsystems, Inc, </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: Also our abstract implementations are authored in C++. From our experience, most implementors are more comfortable in C/C++ than in Estelle. Some work related to encoding packet formats is also reported in the literature. The External Data representation (XDR) standard <ref> [6] </ref> is used for the description and encoding of data and is used in the RPC protocol. The Universal Stub Generator (USC) [8] describes a stub compiler that generates stubs to perform many data conversion operations. However, they do not provide a complete tool that meets all our goals.
Reference: [7] <author> Stefan Naher, Kurt Mehlhorn, and Christian Uhrig. </author> <title> The LEDA User Manual Version R3.2, </title> <month> July </month> <year> 1995. </year>
Reference-contexts: ACE-ASX is developed in C++ and hence C++ was the language choice we made. * Object-oriented languages such as C++ offer type secure class interfaces. * A number of sophisticated class libraries built in C++ are available in the public domain. We use the LEDA <ref> [7] </ref> class library that provides a number of data structures and efficient algorithms in our tool implementation. 7 * Sophisticated debugging tools such as dbx or gdb are readily available for C/C++ and hence the debugging task is simpler. 2. <p> 0.25 _write [11] 13.0 19.37 2.92 47750 0.06 0.06 _setitimer [12] 5.1 20.52 1.15 11947 0.10 0.10 _read [13] Profile for Our tftp % cumulative self self total time seconds seconds calls ms/call ms/call name 24.0 10.36 10.36 26280 0.39 0.39 _sendto [2] 9.5 14.45 4.09 52526 0.08 0.08 _select <ref> [7] </ref> 9.1 18.37 3.92 14351 0.27 0.27 _write [9] 8.2 21.91 3.54 26274 0.13 0.13 _recvfrom [10] 6.0 24.49 2.58 131347 0.02 0.02 _gettimeofday [13] 4.3 26.35 1.86 _char2byte__6BUFFERRci [16] 4.3 28.20 1.85 11948 0.15 0.15 _read [17] 3.8 29.85 1.65 _byte2char__6BUFFERiRc [18] 3.7 31.45 1.61 26262 0.06 0.06 _ExtractPDU__10DataPacketP 6BUFFER
Reference: [8] <author> Sean O'Malley, Todd Proebsting, and Allen Brady Montz. </author> <title> USC: A Universal Stub Generator. </title> <booktitle> In SIGCOMM 94, </booktitle> <address> London, UK, </address> <month> August </month> <year> 1994. </year> <month> SIGS. </month>
Reference-contexts: Some work related to encoding packet formats is also reported in the literature. The External Data representation (XDR) standard [6] is used for the description and encoding of data and is used in the RPC protocol. The Universal Stub Generator (USC) <ref> [8] </ref> describes a stub compiler that generates stubs to perform many data conversion operations. However, they do not provide a complete tool that meets all our goals. One aspect of our tool that is extremely useful is the ability to also build simulations from the abstract implementation. <p> We show relevant parts of the profile information obtained using GNU gprof. Profile for BSD tftp % cumulative self self total time seconds seconds calls ms/call ms/call name 34.3 7.72 7.72 23938 0.32 0.32 _sendto <ref> [8] </ref> 25.7 13.49 5.77 23933 0.24 0.24 _recvfrom [9] 13.2 16.45 2.96 11957 0.25 0.25 _write [11] 13.0 19.37 2.92 47750 0.06 0.06 _setitimer [12] 5.1 20.52 1.15 11947 0.10 0.10 _read [13] Profile for Our tftp % cumulative self self total time seconds seconds calls ms/call ms/call name 24.0 10.36
Reference: [9] <author> J. Postel. </author> <title> SIMPLE MAIL TRANSFER PROTOCOL. </title> <type> Technical Report RFC 821, </type> <institution> Information Sciences Institute, </institution> <month> August </month> <year> 1982. </year>
Reference-contexts: However, most simulators that we know of are not capable of producing prototypes. 1.5 Organization This paper discusses the design considerations and protocol prototyping experiences with such a tool. Simplified versions of the TFTP protocol [15] and SMTP protocol <ref> [9] </ref> have been chosen as examples for this paper. The rest of the paper is organized as follows. Section 2 describes the system overview and design methodology. In Section 3, our experiences implementing the TFTP and SMTP protocol have been reported. <p> We show relevant parts of the profile information obtained using GNU gprof. Profile for BSD tftp % cumulative self self total time seconds seconds calls ms/call ms/call name 34.3 7.72 7.72 23938 0.32 0.32 _sendto [8] 25.7 13.49 5.77 23933 0.24 0.24 _recvfrom <ref> [9] </ref> 13.2 16.45 2.96 11957 0.25 0.25 _write [11] 13.0 19.37 2.92 47750 0.06 0.06 _setitimer [12] 5.1 20.52 1.15 11947 0.10 0.10 _read [13] Profile for Our tftp % cumulative self self total time seconds seconds calls ms/call ms/call name 24.0 10.36 10.36 26280 0.39 0.39 _sendto [2] 9.5 14.45 <p> 0.06 _setitimer [12] 5.1 20.52 1.15 11947 0.10 0.10 _read [13] Profile for Our tftp % cumulative self self total time seconds seconds calls ms/call ms/call name 24.0 10.36 10.36 26280 0.39 0.39 _sendto [2] 9.5 14.45 4.09 52526 0.08 0.08 _select [7] 9.1 18.37 3.92 14351 0.27 0.27 _write <ref> [9] </ref> 8.2 21.91 3.54 26274 0.13 0.13 _recvfrom [10] 6.0 24.49 2.58 131347 0.02 0.02 _gettimeofday [13] 4.3 26.35 1.86 _char2byte__6BUFFERRci [16] 4.3 28.20 1.85 11948 0.15 0.15 _read [17] 3.8 29.85 1.65 _byte2char__6BUFFERiRc [18] 3.7 31.45 1.61 26262 0.06 0.06 _ExtractPDU__10DataPacketP 6BUFFER [19] Our implementation of the client uses an
Reference: [10] <author> Douglas C. Schmidt. </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services. </title> <type> C++ Report, </type> <month> November/December </month> <year> 1992. </year>
Reference-contexts: Our approach is more general because it allows compile-time analysis based on a complete scan of the program text. We note also that environments such as the x-Kernel can serve as targets of our work. Another example of the virtual machine approach is the ACE-ASX <ref> [12, 11, 10] </ref> framework, which provides an environment for constructing application-level protocols. It provides many features to incorporate operating system synchronization features into the protocol implementation separately. <p> 0.10 _read [13] Profile for Our tftp % cumulative self self total time seconds seconds calls ms/call ms/call name 24.0 10.36 10.36 26280 0.39 0.39 _sendto [2] 9.5 14.45 4.09 52526 0.08 0.08 _select [7] 9.1 18.37 3.92 14351 0.27 0.27 _write [9] 8.2 21.91 3.54 26274 0.13 0.13 _recvfrom <ref> [10] </ref> 6.0 24.49 2.58 131347 0.02 0.02 _gettimeofday [13] 4.3 26.35 1.86 _char2byte__6BUFFERRci [16] 4.3 28.20 1.85 11948 0.15 0.15 _read [17] 3.8 29.85 1.65 _byte2char__6BUFFERiRc [18] 3.7 31.45 1.61 26262 0.06 0.06 _ExtractPDU__10DataPacketP 6BUFFER [19] Our implementation of the client uses an additional system call select which is not used
Reference: [11] <author> Douglas C. Schmidt. </author> <title> The ADAPTIVE Communication Environment: Object-Oriented Network Programming Components for Developing Client/Server Applications. </title> <booktitle> In Proceedings of the 11 th Annual Sun Users Group Conference, </booktitle> <address> San Jose, CA, </address> <month> December </month> <year> 1993. </year> <month> SUG. </month>
Reference-contexts: Our approach is more general because it allows compile-time analysis based on a complete scan of the program text. We note also that environments such as the x-Kernel can serve as targets of our work. Another example of the virtual machine approach is the ACE-ASX <ref> [12, 11, 10] </ref> framework, which provides an environment for constructing application-level protocols. It provides many features to incorporate operating system synchronization features into the protocol implementation separately. <p> Profile for BSD tftp % cumulative self self total time seconds seconds calls ms/call ms/call name 34.3 7.72 7.72 23938 0.32 0.32 _sendto [8] 25.7 13.49 5.77 23933 0.24 0.24 _recvfrom [9] 13.2 16.45 2.96 11957 0.25 0.25 _write <ref> [11] </ref> 13.0 19.37 2.92 47750 0.06 0.06 _setitimer [12] 5.1 20.52 1.15 11947 0.10 0.10 _read [13] Profile for Our tftp % cumulative self self total time seconds seconds calls ms/call ms/call name 24.0 10.36 10.36 26280 0.39 0.39 _sendto [2] 9.5 14.45 4.09 52526 0.08 0.08 _select [7] 9.1 18.37
Reference: [12] <author> Douglas C. Schmidt. ASX: </author> <title> an Object-Oriented Framework for Developing Distributed Applications. </title> <booktitle> In Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> Cambridge, Massachusetts, </address> <month> April </month> <year> 1994. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: Our approach is more general because it allows compile-time analysis based on a complete scan of the program text. We note also that environments such as the x-Kernel can serve as targets of our work. Another example of the virtual machine approach is the ACE-ASX <ref> [12, 11, 10] </ref> framework, which provides an environment for constructing application-level protocols. It provides many features to incorporate operating system synchronization features into the protocol implementation separately. <p> Profile for BSD tftp % cumulative self self total time seconds seconds calls ms/call ms/call name 34.3 7.72 7.72 23938 0.32 0.32 _sendto [8] 25.7 13.49 5.77 23933 0.24 0.24 _recvfrom [9] 13.2 16.45 2.96 11957 0.25 0.25 _write [11] 13.0 19.37 2.92 47750 0.06 0.06 _setitimer <ref> [12] </ref> 5.1 20.52 1.15 11947 0.10 0.10 _read [13] Profile for Our tftp % cumulative self self total time seconds seconds calls ms/call ms/call name 24.0 10.36 10.36 26280 0.39 0.39 _sendto [2] 9.5 14.45 4.09 52526 0.08 0.08 _select [7] 9.1 18.37 3.92 14351 0.27 0.27 _write [9] 8.2 21.91
Reference: [13] <author> R. Sijelmassi and B. Strausser. </author> <title> The Distributed Implementation Generator: an overview and user guide. </title> <type> NCSL/SNA Technical Report 91-3, </type> <institution> National Institute of Standards and Technology, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: These wrappers provide a generic interface to the underlying operating system. 4 Another approach is to build tools that compile protocol specifications into implementations. An example is the PET-DINGO tool suite <ref> [14, 13] </ref> that build prototype implementations of protocols from specifications provided in the Formal Description Technique - Estelle. Our approach differs from the Pet-Dingo approach in that our tool produces prototypes from abstract implementations as opposed to specifications. Also our abstract implementations are authored in C++. <p> cumulative self self total time seconds seconds calls ms/call ms/call name 34.3 7.72 7.72 23938 0.32 0.32 _sendto [8] 25.7 13.49 5.77 23933 0.24 0.24 _recvfrom [9] 13.2 16.45 2.96 11957 0.25 0.25 _write [11] 13.0 19.37 2.92 47750 0.06 0.06 _setitimer [12] 5.1 20.52 1.15 11947 0.10 0.10 _read <ref> [13] </ref> Profile for Our tftp % cumulative self self total time seconds seconds calls ms/call ms/call name 24.0 10.36 10.36 26280 0.39 0.39 _sendto [2] 9.5 14.45 4.09 52526 0.08 0.08 _select [7] 9.1 18.37 3.92 14351 0.27 0.27 _write [9] 8.2 21.91 3.54 26274 0.13 0.13 _recvfrom [10] 6.0 24.49 <p> cumulative self self total time seconds seconds calls ms/call ms/call name 24.0 10.36 10.36 26280 0.39 0.39 _sendto [2] 9.5 14.45 4.09 52526 0.08 0.08 _select [7] 9.1 18.37 3.92 14351 0.27 0.27 _write [9] 8.2 21.91 3.54 26274 0.13 0.13 _recvfrom [10] 6.0 24.49 2.58 131347 0.02 0.02 _gettimeofday <ref> [13] </ref> 4.3 26.35 1.86 _char2byte__6BUFFERRci [16] 4.3 28.20 1.85 11948 0.15 0.15 _read [17] 3.8 29.85 1.65 _byte2char__6BUFFERiRc [18] 3.7 31.45 1.61 26262 0.06 0.06 _ExtractPDU__10DataPacketP 6BUFFER [19] Our implementation of the client uses an additional system call select which is not used by the BSD implementation.
Reference: [14] <author> R. Sijelmassi and B. Strausser. </author> <title> The Portable Estelle Translator: an overview and user guide. </title> <type> NCSL/SNA Technical Report 91-2, </type> <institution> National Institute of Standards and Technology, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: These wrappers provide a generic interface to the underlying operating system. 4 Another approach is to build tools that compile protocol specifications into implementations. An example is the PET-DINGO tool suite <ref> [14, 13] </ref> that build prototype implementations of protocols from specifications provided in the Formal Description Technique - Estelle. Our approach differs from the Pet-Dingo approach in that our tool produces prototypes from abstract implementations as opposed to specifications. Also our abstract implementations are authored in C++.
Reference: [15] <author> K. Sollins. </author> <title> The TFTP Protocol (Revision 2). </title> <type> Technical Report RFC 1350, </type> <institution> Massachusetts Institute of Technology, </institution> <month> July </month> <year> 1992. </year> <month> 18 </month>
Reference-contexts: For example, the Nest [2] tool provides a tool for simulating distributed systems. However, most simulators that we know of are not capable of producing prototypes. 1.5 Organization This paper discusses the design considerations and protocol prototyping experiences with such a tool. Simplified versions of the TFTP protocol <ref> [15] </ref> and SMTP protocol [9] have been chosen as examples for this paper. The rest of the paper is organized as follows. Section 2 describes the system overview and design methodology. In Section 3, our experiences implementing the TFTP and SMTP protocol have been reported.
References-found: 15

