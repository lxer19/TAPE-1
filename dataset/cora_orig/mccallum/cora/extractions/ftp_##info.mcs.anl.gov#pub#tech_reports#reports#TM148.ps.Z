URL: ftp://info.mcs.anl.gov/pub/tech_reports/reports/TM148.ps.Z
Refering-URL: http://www.mcs.anl.gov/publications/abstracts/abstracts91.htm
Root-URL: http://www.mcs.anl.gov
Title: Utilities for Building and Optimizing a Computational Graph for Algorithmic Decomposition  
Author: Christian Bischof James Hu 
Date: January 1991  
Address: Argonne, IL 60439  
Affiliation: Mathematics and Computer Science Division Argonne National Laboratory  
Pubnum: MCS-TM-148  
Abstract: This document describes a utility to construct and evaluate an optimized execution graph from the tapefile generated by the ADOL-C automatic differentiation software. It describes the format of the ADOL-C tapefile, the data structures used in building and storing the graph, and the optimizations performed in transforming the computation trace stored in the tape into an efficient graph representation. In particular, we eliminate assignments, increase granularity by "hoisting" chains of unary operations, and remove so-called dead roots intermediate values that have no influence on the dependent. Examples show that the optimized graphs contain up to 50% fewer nodes than a graph that would be an exact analogue of the ADOL-C tape. We also describe an attempt at generating compiled code for the graph evaluation as an alternative to interpretative approaches to evaluating the graph. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Christian Bischof, Andreas Griewank, and David Juedes. </author> <title> Exploiting parallelism in automatic differentiation. </title> <type> Preprint MCS-P204-0191, </type> <institution> Argonne National Laboratory, Mathematics and Computer Sciences Division, </institution> <year> 1991. </year>
Reference-contexts: fi 80 grid of the chamber section, yielding 3,200 independent variables and 3,200 dependent variables. 18 printf ("root (%d) = %e;"n", 1, root [0]); do_level_0 (); do_level_1 (); do_level_2 (); do_level_3 (); (c) (a) root [0] = t [0]; void do_level_3 () - - t [0] = exp (r_plus (t <ref> [1] </ref>, t [2])); void do_level_2 () - - t [1] = r_plus (1.0, t [0]); void do_level_1 () - - void do_level_0 () - - int main () - double root [1]; double t [3]; #define r_divide (x, y) ((x) / (y)) #define r_times (x, y) ((x) * (y)) #define r_minus <p> independent variables and 3,200 dependent variables. 18 printf ("root (%d) = %e;"n", 1, root [0]); do_level_0 (); do_level_1 (); do_level_2 (); do_level_3 (); (c) (a) root [0] = t [0]; void do_level_3 () - - t [0] = exp (r_plus (t <ref> [1] </ref>, t [2])); void do_level_2 () - - t [1] = r_plus (1.0, t [0]); void do_level_1 () - - void do_level_0 () - - int main () - double root [1]; double t [3]; #define r_divide (x, y) ((x) / (y)) #define r_times (x, y) ((x) * (y)) #define r_minus (x, y) ((x) - (y)) #define r_plus (x, y) <p> (); (c) (a) root [0] = t [0]; void do_level_3 () - - t [0] = exp (r_plus (t <ref> [1] </ref>, t [2])); void do_level_2 () - - t [1] = r_plus (1.0, t [0]); void do_level_1 () - - void do_level_0 () - - int main () - double root [1]; double t [3]; #define r_divide (x, y) ((x) / (y)) #define r_times (x, y) ((x) * (y)) #define r_minus (x, y) ((x) - (y)) #define r_plus (x, y) ((x) + (y)) #include &lt;stdio.h&gt; #include &lt;math.h&gt; /* code generated by readtape */ = cos1+ y = t3; t2 += t1; t1
Reference: [2] <author> Andreas Griewank. </author> <title> On automatic differentiation. </title> <booktitle> In Mathematical Programming: Recent Developments and Applications, </booktitle> <pages> pages 83-108. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1989. </year>
Reference-contexts: When we read a new record from the tape, we write out the graph node corresponding to the live variable slot that is being reused, and construct a new graph node that will be hooked up to that slot. For example, when we read the record corresponding to store <ref> [2] </ref> := store [6] + store [7], we know that the value represented by the node (a, say) hanging off location 2 in the live node table (call this location live [2]), will not be used any more. This situation is shown in Figure ??. <p> For example, when we read the record corresponding to store <ref> [2] </ref> := store [6] + store [7], we know that the value represented by the node (a, say) hanging off location 2 in the live node table (call this location live [2]), will not be used any more. This situation is shown in Figure ??. We copy the opcode list of node a into the opcode storage array (the opcode fields in the opcode list hanging off live [2] are set to UNUSED, indicated by NOP in the figure, so that they <p> hanging off location 2 in the live node table (call this location live <ref> [2] </ref>), will not be used any more. This situation is shown in Figure ??. We copy the opcode list of node a into the opcode storage array (the opcode fields in the opcode list hanging off live [2] are set to UNUSED, indicated by NOP in the figure, so that they can be reused). (At this point we could try to perform some optimizations on node a; We return to this subject later.) We then allocate a new graph node (d, say), hook it up to live [2], <p> <ref> [2] </ref> are set to UNUSED, indicated by NOP in the figure, so that they can be reused). (At this point we could try to perform some optimizations on node a; We return to this subject later.) We then allocate a new graph node (d, say), hook it up to live [2], copy its opcode into the opcode list off live [2], and make the nodes b and c pointed to by live [6] and live [7] the children of the new node. This is shown in Figure ??. <p> figure, so that they can be reused). (At this point we could try to perform some optimizations on node a; We return to this subject later.) We then allocate a new graph node (d, say), hook it up to live <ref> [2] </ref>, copy its opcode into the opcode list off live [2], and make the nodes b and c pointed to by live [6] and live [7] the children of the new node. This is shown in Figure ??. <p> The subtree for the computation of the integrand that is hanging off live [deriv_loc] will later be removed as a spurious root. Uninitialized variables create problems with building the graph, in the sense that if store <ref> [2] </ref> is an uninitialized variable, then live [2] does not point to any node, but nonetheless it can happen that in the user program this value is used as input for a later operation. <p> The subtree for the computation of the integrand that is hanging off live [deriv_loc] will later be removed as a spurious root. Uninitialized variables create problems with building the graph, in the sense that if store <ref> [2] </ref> is an uninitialized variable, then live [2] does not point to any node, but nonetheless it can happen that in the user program this value is used as input for a later operation. <p> grid of the chamber section, yielding 3,200 independent variables and 3,200 dependent variables. 18 printf ("root (%d) = %e;"n", 1, root [0]); do_level_0 (); do_level_1 (); do_level_2 (); do_level_3 (); (c) (a) root [0] = t [0]; void do_level_3 () - - t [0] = exp (r_plus (t [1], t <ref> [2] </ref>)); void do_level_2 () - - t [1] = r_plus (1.0, t [0]); void do_level_1 () - - void do_level_0 () - - int main () - double root [1]; double t [3]; #define r_divide (x, y) ((x) / (y)) #define r_times (x, y) ((x) * (y)) #define r_minus (x, y)
Reference: [3] <author> Andreas Griewank, David Juedes, and Jay Srinivasan. ADOL-C, </author> <title> a package for the automatic differentiation of algorithms written in C/C++. </title> <type> Preprint MCS-P180-1190, </type> <institution> Argonne National Laboratory, Mathematics and Computer Sciences Division, </institution> <year> 1990. </year>
Reference-contexts: Tape record 7,for example, encodes the operation store [7] := store [1]/store <ref> [3] </ref>, when store is the array allocated for the storage of intermediate variables. <p> The mechanism is easiest to understand with an example as shown in Figure ??. Assume that the operation we read off the tape is a binary operation, e.g., store <ref> [3] </ref> = store [8] - store [10]. We then generate a new node new to represent this operation and have its children pointers point to the nodes off live [8] and live [10]. For the nodes off live [8] and live [10], we make their parent pointer point to new. <p> We then generate a new node new to represent this operation and have its children pointers point to the nodes off live [8] and live [10]. For the nodes off live [8] and live [10], we make their parent pointer point to new. Before having live <ref> [3] </ref> point to new, we check node n (which is about to be unlinked from live [3]) for hoistability. Now assume that the node n currently pointed to by live [3] is hoistable into node p as is shown in the left half of Figure ??. <p> For the nodes off live [8] and live [10], we make their parent pointer point to new. Before having live <ref> [3] </ref> point to new, we check node n (which is about to be unlinked from live [3]) for hoistability. Now assume that the node n currently pointed to by live [3] is hoistable into node p as is shown in the left half of Figure ??. <p> Before having live <ref> [3] </ref> point to new, we check node n (which is about to be unlinked from live [3]) for hoistability. Now assume that the node n currently pointed to by live [3] is hoistable into node p as is shown in the left half of Figure ??. <p> Thereafter n can be removed; that is, its address in a node storage area will be put on the free list. Lastly, we connect new to live <ref> [3] </ref>. The resulting situation is shown on the right side of Figure ??. <p> The situation may be more complicated with unary operators since the new node that is being generated can be the parent of the node to be hoisted (this cannot happen for binary operators since we will never hoist into a binary node). For example, assume that we read store <ref> [3] </ref> = store [3] * 2.0 off the ADOL-C tape. <p> For example, assume that we read store <ref> [3] </ref> = store [3] * 2.0 off the ADOL-C tape. <p> a new node new to represent the new operation, and make its left 14 new from node 8 from node 10 3 3 c1 c2 n a-a Live Node Table Live Node Table from node 10 from node 8 new child pointer point to the node pointed to by live <ref> [3] </ref> (call it n, say), and set n's parent pointer to new. This situation is shown on the left side of Figure ??. Now we want to hoist n into new. <p> root [0] = t [0]; void do_level_3 () - - t [0] = exp (r_plus (t [1], t [2])); void do_level_2 () - - t [1] = r_plus (1.0, t [0]); void do_level_1 () - - void do_level_0 () - - int main () - double root [1]; double t <ref> [3] </ref>; #define r_divide (x, y) ((x) / (y)) #define r_times (x, y) ((x) * (y)) #define r_minus (x, y) ((x) - (y)) #define r_plus (x, y) ((x) + (y)) #include &lt;stdio.h&gt; #include &lt;math.h&gt; /* code generated by readtape */ = cos1+ y = t3; t2 += t1; t1 = 1 +
References-found: 3

