URL: http://www.cs.gatech.edu/computing/Database/students/vibby/papers/rel-index-consist.ps.Z
Refering-URL: http://www.cs.gatech.edu/computing/Database/students/vibby/vibby.html
Root-URL: 
Email: fvibby,edwardo,ramag@cc.gatech.edu  
Title: Relaxed Index Consistency for a Client-Server Database  
Author: Vibby Gottemukkala Edward Omiecinski Umakishore Ramachandran 
Affiliation: College of Computing Georgia Institute of Technology  
Abstract: Client-Server systems cache data in client buffers to deliver good performance. Several efficient protocols have been proposed to maintain the coherence of the cached data. However, none of the protocols distinguish between index pages and data pages. We propose a new coherence protocol, called Relaxed Index Consistency, that exploits the inherent differences in the coherence and concurrency-control (C&CC) requirements for index and data pages. The key idea is to incur a small increase in computation time at the clients to gain a significant reduction in the number of messages exchanged between the clients and the servers. The protocol uses the concurrency control on data pages to maintain coherence of index pages. C&CC for the data pages is enforced using a traditional protocol such as Callback Locking. A performance-conscious implementation of the protocol that makes judicious use of version numbers is proposed. We show, through both qualitative and quantitative analysis, the performance benefits of making the distinction between index pages and data pages for the purposes of C&CC. Our simulation studies show that the Relaxed Index Consistency protocol improves system throughput by as much as 15% to 88%, based on the workload. 
Abstract-found: 1
Intro-found: 1
Reference: [CFLS91] <author> M. J. Carey, M. J. Franklin, M. Livny, and E. J. Shekita. </author> <title> Data Caching Tradeoffs in Client-Server DBMS Architectures. </title> <booktitle> In Proceedings of the 1991 ACM SIGMOD Conference, </booktitle> <pages> pages 357-366, </pages> <year> 1991. </year>
Reference-contexts: of an index when an index item is locked using data-only locking thus combining coherence actions on index pages with C&CC of data pages. 2.4 Related Work There is an extremely large body of work in the literature regarding coherence and consistency maintenance of data in various data sharing environments <ref> [DIRY89, WN90, WR91, CFLS91, MN92] </ref>. However, this entire body of work treats all the data uniformly, i.e., the same protocol is used for both data and non-data pages, which leads to unnecessary inter-node interactions in the case of non-data pages. <p> These workloads are based on the workloads described in <ref> [CFLS91, CFZ94] </ref>. The experiments test the performance of the coherence protocols as the need for coherence changes by varying the percentage of write accesses to the database. In the following we discuss each workload and discuss the relevant results.
Reference: [CFZ94] <author> M.J. Carey, M.J. Franklin, and M. Zaharioudakis. </author> <title> Fine-Grained Sharing in a Page Server OODBMS. </title> <booktitle> In Proceedings of the 1994 ACM SIGMOD Conference, </booktitle> <pages> pages 359-370, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: We use the Callback Locking (CBL) scheme for the sake of comparison. The reason we chose CBL is the general acceptance of its performance advantages, both in the literature and its implementation in systems <ref> [FC92, LLOW91, CFZ94] </ref>. 4.1 Modification followed by read Let us consider the case where a client modifies an index page and later some client reads that index page. This case tests coherence maintenance schemes well because modifications are what cause cached data to become inconsistent. <p> These workloads are based on the workloads described in <ref> [CFLS91, CFZ94] </ref>. The experiments test the performance of the coherence protocols as the need for coherence changes by varying the percentage of write accesses to the database. In the following we discuss each workload and discuss the relevant results. <p> In our future work we would also like to explore the usage of multiple-writer semantics, and fine-granularity locking, as suggested in <ref> [CFZ94] </ref>, in the RIC protocol, and their impact on the throughput and scalability of the system.
Reference: [DIRY89] <author> D. M. Dias, B. R. Iyer, J. T. Robinson, and P. S. Yu. </author> <title> Integrated Concurrency-Coherency Controls for Multisystem Data Sharing. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 15(4) </volume> <pages> 437-448, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: of an index when an index item is locked using data-only locking thus combining coherence actions on index pages with C&CC of data pages. 2.4 Related Work There is an extremely large body of work in the literature regarding coherence and consistency maintenance of data in various data sharing environments <ref> [DIRY89, WN90, WR91, CFLS91, MN92] </ref>. However, this entire body of work treats all the data uniformly, i.e., the same protocol is used for both data and non-data pages, which leads to unnecessary inter-node interactions in the case of non-data pages.
Reference: [FC92] <author> M. Franklin and M. Carey. </author> <title> Client-Server Caching Revisited. </title> <booktitle> In Proceedings of the International Workshop on Distributed Object Management, </booktitle> <month> August </month> <year> 1992. </year>
Reference-contexts: This form of pessimism requires global C&CC operations for all data accesses. Despite these apparent drawbacks, it has been shown that pessimistic C&CC protocols that cache C&CC information across transaction boundaries (e.g. callback locking) deliver the best performance <ref> [FC92, WR91] </ref> for a wide range of workloads. Using a straightforward pessimistic C&CC protocol for both index and data pages would make coherence maintenance for index pages expensive because of their high frequency of access and degree of replication. <p> In fact, the server does not even keep track of clients that cache index pages in shared mode. As for data pages, the server uses an enhanced Callback Locking (CBL) protocol <ref> [WR91, FC92] </ref> to grant a client's page request. Furthermore, the CBL protocol is extended for RIC so that the server, in addition to granting the requested data page, sends coherence information for the indexes relevant to the requested data page (see the grant request step in Figure 1). <p> The Callback Locking protocol used for data locking in RIC was originally proposed for file caching in AFS [H + 88]. This protocol was enhanced and adapted for caching in transactional systems in <ref> [LLOW91, WR91, FC92] </ref>. In the implementation of CBL that we use for the RIC protocol, when a transaction requests an exclusive data lock, upon its release the client downgrades the lock to a shared lock in order to avoid excessive callbacks, because caching exclusive locks causes lock conflicts. <p> We use the Callback Locking (CBL) scheme for the sake of comparison. The reason we chose CBL is the general acceptance of its performance advantages, both in the literature and its implementation in systems <ref> [FC92, LLOW91, CFZ94] </ref>. 4.1 Modification followed by read Let us consider the case where a client modifies an index page and later some client reads that index page. This case tests coherence maintenance schemes well because modifications are what cause cached data to become inconsistent.
Reference: [FZT + 92] <author> M. Franklin, M. Zwilling, C. K. Tan, M. Carey, and D. DeWitt. </author> <title> Crash Recovery in Client-Server EXODUS. </title> <booktitle> In Proceeding of the 1992 ACM SIGMOD Conference, </booktitle> <pages> pages 165-174, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: However, the server follows a no-force policy, i.e., the server does not have to write back the dirty pages to disk at commit time <ref> [FZT + 92] </ref>. Furthermore, we assume that index operations release physical locks acquired on index pages as soon as the operation is done using the page instead of holding the locks until commit time as is done in the case of logical locks (data locks in our case). <p> However, with this form of optimistic execution it is difficult to eventually merge the pages because of shared information such as space management data [Moh92b]. In this paper, we have not considered the recovery implications of RIC. However, we expect that recovery protocols, such as those described in <ref> [FZT + 92, MN94] </ref>, would be adequate because all writes under RIC are serialized and no transactions are aborted or rolled back due to inconsistent index accesses.
Reference: [GR93] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1993. </year>
Reference-contexts: This isolation level has also been referred to as Degree 3 consistency in the literature. The consistency requirements of Isolation Level 4 require index operations to support repeatable reads (RR) and avoid phantoms <ref> [GR93, Moh90] </ref>. 7 One way of meeting this requirement is to use key-range locking. <p> However, transactions that scan data under Isolation Levels 2 and 3 (also known as `Read Committed' and `Repeatable Read,' respectively) are not required to perform adjacent key locking to meet their consistency requirements <ref> [GR93] </ref>. But, as we saw from the example in Section 2.3, acquiring adjacent locks is a crucial component in the correct execution of index operations under the RIC protocol.
Reference: [H + 88] <author> J. Howard et al. </author> <title> Scale and Performance in a Distributed File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1), </volume> <month> February </month> <year> 1988. </year> <month> 29 </month>
Reference-contexts: The RIC protocol uses data-only locking to reduce communication and recognizes the relationship between data and indexes and uses it to maintain the coherence of indexes. The Callback Locking protocol used for data locking in RIC was originally proposed for file caching in AFS <ref> [H + 88] </ref>. This protocol was enhanced and adapted for caching in transactional systems in [LLOW91, WR91, FC92].
Reference: [JC92] <author> T. Johnson and A. Colbrook. </author> <title> A Distributed Data-balanced Dictionary based on the B--link Tree. </title> <booktitle> In Proceedings of the International Parallel Processing Symposium, </booktitle> <pages> pages 319-325, </pages> <year> 1992. </year>
Reference-contexts: Furthermore, explicit locks have to be obtained on each of the leaf nodes. Both these restrictions are eliminated in our scheme where we exploit the semantics of the concurrency control operations that are used to enforce transaction consistency. In <ref> [JC92, JK93] </ref> the authors propose index maintenance schemes in a distributed memory environment.
Reference: [JK93] <author> T. Johnson and P. Krishna. </author> <title> Lazy Updates for Distributed Search Structure. </title> <booktitle> In Proceedings of the 1993 ACM SIGMOD Conference, </booktitle> <pages> pages 337-346, </pages> <year> 1993. </year>
Reference-contexts: Furthermore, explicit locks have to be obtained on each of the leaf nodes. Both these restrictions are eliminated in our scheme where we exploit the semantics of the concurrency control operations that are used to enforce transaction consistency. In <ref> [JC92, JK93] </ref> the authors propose index maintenance schemes in a distributed memory environment.
Reference: [LLOW91] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The ObjectStore Database System. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The Callback Locking protocol used for data locking in RIC was originally proposed for file caching in AFS [H + 88]. This protocol was enhanced and adapted for caching in transactional systems in <ref> [LLOW91, WR91, FC92] </ref>. In the implementation of CBL that we use for the RIC protocol, when a transaction requests an exclusive data lock, upon its release the client downgrades the lock to a shared lock in order to avoid excessive callbacks, because caching exclusive locks causes lock conflicts. <p> We use the Callback Locking (CBL) scheme for the sake of comparison. The reason we chose CBL is the general acceptance of its performance advantages, both in the literature and its implementation in systems <ref> [FC92, LLOW91, CFZ94] </ref>. 4.1 Modification followed by read Let us consider the case where a client modifies an index page and later some client reads that index page. This case tests coherence maintenance schemes well because modifications are what cause cached data to become inconsistent.
Reference: [MN91] <author> C. Mohan and I. Narang. </author> <title> Recovery and Coherency-Control Protocols for Fast Inter-system Page Transfer and Fine-Granularity Locking in a Shared Disks Transaction Environment. </title> <booktitle> In Proceedings of the 17th VLDB Conference, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: Furthermore, the algorithms present the index page access in isolation from the data page access and hence do not consider the possibility of the integration of C&CC as our scheme does. In <ref> [MN91] </ref> C&CC protocols that allow multiple readers and a single writer simultaneously are presented, but these protocols do not distinguish between index pages and data pages. The coherence of a page is enforced when a logical lock on an item in that page is acquired.
Reference: [MN92] <author> C. Mohan and I. Narang. </author> <title> Efficient Locking and Caching of Data in the Multisystem Shared Disks Transactions Envrionment. </title> <booktitle> In Proceedings of the 3rd International Conference on Extending Database Technology, </booktitle> <pages> pages 453-468, </pages> <year> 1992. </year>
Reference-contexts: of an index when an index item is locked using data-only locking thus combining coherence actions on index pages with C&CC of data pages. 2.4 Related Work There is an extremely large body of work in the literature regarding coherence and consistency maintenance of data in various data sharing environments <ref> [DIRY89, WN90, WR91, CFLS91, MN92] </ref>. However, this entire body of work treats all the data uniformly, i.e., the same protocol is used for both data and non-data pages, which leads to unnecessary inter-node interactions in the case of non-data pages.
Reference: [MN94] <author> C. Mohan and I. Narang. ARIES/CSA: </author> <title> A Method for Database Recovery in Client-Server Architectures. </title> <booktitle> In Proceedings of the 1994 SIGMOD Conference, </booktitle> <pages> pages 55-66, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: However, with this form of optimistic execution it is difficult to eventually merge the pages because of shared information such as space management data [Moh92b]. In this paper, we have not considered the recovery implications of RIC. However, we expect that recovery protocols, such as those described in <ref> [FZT + 92, MN94] </ref>, would be adequate because all writes under RIC are serialized and no transactions are aborted or rolled back due to inconsistent index accesses.
Reference: [Moh90] <author> C. Mohan. ARIES/KVL: </author> <title> A Key-Value Locking Method for Concurrency Control of Multiaction Transactions Operation on B-Tree Indexes. </title> <booktitle> In Proceedings of the 16th VLDB Conference, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: This isolation level has also been referred to as Degree 3 consistency in the literature. The consistency requirements of Isolation Level 4 require index operations to support repeatable reads (RR) and avoid phantoms <ref> [GR93, Moh90] </ref>. 7 One way of meeting this requirement is to use key-range locking.
Reference: [Moh92a] <author> C. Mohan. </author> <title> Interactions Between Query Optimization and Concurrency Control. </title> <booktitle> In Proceedings of the International Workshop on Research Issues on Data Engineering: Transaction and Query Processing, </booktitle> <pages> pages 26-35, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: Data-only locking implies that when an index item is locked, the lock is actually acquired on the referred-to data item (page or record lock based on lock granularity). Data-only locking significantly reduces the actual number of locks that have to be acquired by a transaction <ref> [Moh92a] </ref> because transactions that access an index item (and lock it) typically also access the referred-to data item (and have to lock it, too). This reduction in lock acquisitions directly contributes to a reduction in the number of messages in the system.
Reference: [Moh92b] <author> C. Mohan. </author> <title> Less Optimism About Optimistic Concurrency Control. </title> <editor> In P. S. Yu, editor, </editor> <booktitle> Proceedings of the International Workshop on Research Issues on Data Engineering: Transaction and Query Processing, </booktitle> <pages> pages 199-204. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> February </month> <year> 1992. </year>
Reference-contexts: However, as pointed out in <ref> [Moh92b] </ref>, there are several practical problems in implementing optimistic protocols, such as space management, access path maintenance. Pessimistic C&CC protocols, on the other hand, allow transactions to access data only if the access will not violate the consistency requirements for the transaction. <p> It could be potentially beneficial to even allow multiple writers to exist simultaneously. However, with this form of optimistic execution it is difficult to eventually merge the pages because of shared information such as space management data <ref> [Moh92b] </ref>. In this paper, we have not considered the recovery implications of RIC.
Reference: [MS93] <author> J. Melton and A. R. Simon. </author> <title> Understanding the New SQL: A Complete Guide. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: We assume, for the sake of this discussion, that the transactions execute at Isolation Level 4 (`Seri-alizable') as specified in the SQL-92 standard <ref> [MS93] </ref>. This isolation level has also been referred to as Degree 3 consistency in the literature. The consistency requirements of Isolation Level 4 require index operations to support repeatable reads (RR) and avoid phantoms [GR93, Moh90]. 7 One way of meeting this requirement is to use key-range locking.
Reference: [Sch90] <author> H. Schwetman. </author> <title> CSIM Users' Guide, </title> <month> March </month> <year> 1990. </year>
Reference-contexts: capacity 128 entries Data segment size 2048/4096 pages (8/16MB) Index segment size 256/512 pages Table 2: System and database configuration for the simulation In order to quantitatively study the performance characteristics of relaxed index consistency and compare it with callback locking, we developed a process-oriented simulation model based on CSIM <ref> [Sch90] </ref>. In this section, we briefly discuss the system and workload aspects of our simulation. The client-server system we model has a single server with attached stable storage and a number of clients.
Reference: [WN90] <author> K. Wilkinson and M-A. Neimat. </author> <title> Maintaining Consistency of Client-Cached Data. </title> <booktitle> In Proceedings of the 16th VLDB Conference, </booktitle> <pages> pages 122-133, </pages> <year> 1990. </year>
Reference-contexts: of an index when an index item is locked using data-only locking thus combining coherence actions on index pages with C&CC of data pages. 2.4 Related Work There is an extremely large body of work in the literature regarding coherence and consistency maintenance of data in various data sharing environments <ref> [DIRY89, WN90, WR91, CFLS91, MN92] </ref>. However, this entire body of work treats all the data uniformly, i.e., the same protocol is used for both data and non-data pages, which leads to unnecessary inter-node interactions in the case of non-data pages.
Reference: [WR91] <author> Y. Wang and L. A. Rowe. </author> <title> Cache Consistency and Concurrency Control in a Client/Server DBMS Architecture. </title> <booktitle> In Proceedings of the 1991 ACM SIGMOD Conference, </booktitle> <year> 1991. </year>
Reference-contexts: This form of pessimism requires global C&CC operations for all data accesses. Despite these apparent drawbacks, it has been shown that pessimistic C&CC protocols that cache C&CC information across transaction boundaries (e.g. callback locking) deliver the best performance <ref> [FC92, WR91] </ref> for a wide range of workloads. Using a straightforward pessimistic C&CC protocol for both index and data pages would make coherence maintenance for index pages expensive because of their high frequency of access and degree of replication. <p> In fact, the server does not even keep track of clients that cache index pages in shared mode. As for data pages, the server uses an enhanced Callback Locking (CBL) protocol <ref> [WR91, FC92] </ref> to grant a client's page request. Furthermore, the CBL protocol is extended for RIC so that the server, in addition to granting the requested data page, sends coherence information for the indexes relevant to the requested data page (see the grant request step in Figure 1). <p> of an index when an index item is locked using data-only locking thus combining coherence actions on index pages with C&CC of data pages. 2.4 Related Work There is an extremely large body of work in the literature regarding coherence and consistency maintenance of data in various data sharing environments <ref> [DIRY89, WN90, WR91, CFLS91, MN92] </ref>. However, this entire body of work treats all the data uniformly, i.e., the same protocol is used for both data and non-data pages, which leads to unnecessary inter-node interactions in the case of non-data pages. <p> The Callback Locking protocol used for data locking in RIC was originally proposed for file caching in AFS [H + 88]. This protocol was enhanced and adapted for caching in transactional systems in <ref> [LLOW91, WR91, FC92] </ref>. In the implementation of CBL that we use for the RIC protocol, when a transaction requests an exclusive data lock, upon its release the client downgrades the lock to a shared lock in order to avoid excessive callbacks, because caching exclusive locks causes lock conflicts.
Reference: [WW90] <author> W. E. Weihl and P. Wang. </author> <title> Multi-Version Memory: Software Cache Management for Concurrent B-Trees. </title> <booktitle> In Proceedings of the IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 650-655, </pages> <year> 1990. </year> <month> 30 </month>
Reference-contexts: There is also a large body of work regarding coherence and consistency maintenance of indexes in a distributed setting. In <ref> [WW90] </ref> the general dictionary lookup/maintenance algorithm for coherent shared memory is transformed to run on a software cache coherence scheme called multi-version memory which provides weaker semantics than coherent shared memory.
References-found: 21

