URL: http://www.cse.ogi.edu/DISC/DIOM/online_pub/tech/TR95-17.ps
Refering-URL: http://www.cse.ogi.edu/DISC/DIOM/publication.html
Root-URL: http://www.cse.ogi.edu
Email: email: lingliu@cs.ualberta.ca  email: calton,roger,tong@cse.ogi.edu  
Title: Differential Evaluation of Continual Queries  
Author: Ling Liu Calton Pu, Roger Barga, Tong Zhou 
Keyword: Information Superhighways, Internet, information monitoring, continual queries, differential data, incremental query processing, epsilon serializability.  
Address: GSB 615, Edmonton, Alberta T6G 2H1 Canada  P.O.Box 91000 Portland Oregon 97291-1000 USA  
Affiliation: University of Alberta Department of Computing Science  Oregon Graduate Institute of Science and Technology Department of Computer Science  
Abstract: Information Superhighway environments such as the Internet have brought us ready access to large amount of information. However, Internet data is notoriously unorganized and autonomously managed in a distributed fashion. Large scale information monitoring in the Internet environment requires support beyond traditional database techniques. Two of the key issues are the increasing reward in monitoring a fast growing information base and the similarly increasing processing cost. To improve the expressiveness of queries for information monitoring, we define continual queries as a useful tool for monitoring of updated information. Continual queries are standing queries that monitor the source data and notify the users whenever new data matches the query. In addition to periodic refresh [27], continual queries include Epsilon Transaction [18, 19] concepts to allow users to specify query refresh based on the magnitude of updates. To support efficient processing of continual queries, we propose a differential re-evaluation algorithm (DRA), which exploits the structure and information contained in both the query expressions and the database update operations. The DRA design can be seen as a synthesis of previous research on differential files, incremental view maintenance, and active databases. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alonso, D. Barbara, and H. Garcia-Molina. </author> <title> Data caching issues in an information retrieval system. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(3) </volume> <pages> 359-384, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: This is similar to the specification of update propagation in quasi-copies <ref> [1] </ref>. A recent paper [29] has identified the problem of using incremental view maintenance approaches in a data warehousing environment, 1 where the materialized view and its base relations are loosely coupled. While the warehouse attempts to update a view, the base data at source may keep changing.
Reference: [2] <author> D. Barbara and R. Alonso. </author> <title> Processing continuous queries in general environments. </title> <type> Technical report, </type> <institution> Mat-sushita Information Technology Laboratory, Princeton, NJ, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: First, we describe continual queries with epsilon specification, namely epsilon continual queries (ECQ), to simplify continual query formulation on the user side. In addition to triggering query refresh periodically as proposed in previous work <ref> [27, 2] </ref>, ECQs allow the users to 1 specify and activate query refresh based on the magnitude of updates. <p> The first such assumption is the limitation of database updates to append-only, disallowing deletions and 2 modifications. Since this assumption is used in their query transformation algorithm, it has been difficult to relax it <ref> [2] </ref>, when following their definition of continuous queries. This is one of the motivations for our new definition in Section 3 under a new name, continual queries. <p> Our design builds on the research in differential files [25], hypothetical relations [8, 26], and incremental updating materialized views [3, 23, 29], and offers several advantages over the previous solutions <ref> [27, 2] </ref>. The basic idea is to compute the result of the current execution of a continual query by combining the result produced by the most recent execution with the updates occurred in between these two consecutive executions.
Reference: [3] <author> J. Blakeley, P. Larson, and F. Tompa. </author> <title> Efficiently updating materialized views. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 61-71, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: Therefore, the support for flexible and efficient monitoring of information updates is an important goal when accessing data in the Internet. Traditional database techniques such as view materialization <ref> [3, 8] </ref>, active databases [22], and query optimization cannot be directly applied in distributed interoperable environments such as the Internet. The reasons include the lack of integration of information sources, autonomy and heterogeneity in the Internet, and the relatively unorganized storage and management of data, such as WWW pages [5]. <p> In contrast, incremental update algorithms are believed to carry lower execution cost if changes to the database are moderate [8, 11]. Three approaches have been described previously. The first approach refreshes the view immediately after each update to the base table <ref> [3] </ref>. The second defers the refresh until a query is issued against the view [21]. The third refreshes the view periodically [11]. The main tradeoff in choosing among these approaches is the staleness of the view data vs. the cost of updating it. <p> The second defers the refresh until a query is issued against the view [21]. The third refreshes the view periodically [11]. The main tradeoff in choosing among these approaches is the staleness of the view data vs. the cost of updating it. Most of the algorithms in the literature <ref> [3, 11, 8, 10, 7] </ref> work in a centralized database environment, in which the materialized view and its base tables co-reside. <p> The solution we promote avoids the overhead of recomputing the query from scratch, and relaxes the restrictions of append-only database and monotonic-transformable queries. Our design builds on the research in differential files [25], hypothetical relations [8, 26], and incremental updating materialized views <ref> [3, 23, 29] </ref>, and offers several advantages over the previous solutions [27, 2]. The basic idea is to compute the result of the current execution of a continual query by combining the result produced by the most recent execution with the updates occurred in between these two consecutive executions. <p> We define an operator that computes differential relations for arbitrary SPJ expressions. The concept of differential relations is, to some extent, similar to the concept of hypothetical relations used for incremental updating materialized views <ref> [3, 8] </ref>. The difference lies in the usage and the detailed structure. <p> The goal for defining differential relations, instead of using hypothetical relations described in <ref> [3, 8] </ref>, is to provide a unified treatment of changes, not separate treatments of insertions, deletions, and modifications resulting in several algorithms for generating and combining individual results. <p> This mechanism works effectively when n is larger than k. The idea of using the truth table to facilitate the combination of possible joins was borrowed from the research in updating materialized view <ref> [3, 8] </ref>.
Reference: [4] <author> C. Bowman, P. Danzig, D. Hardy, U. Manber, and M. F. Schwartz. </author> <title> The harvest information discovery and access system. </title> <booktitle> In Proceedings of the Second International World Wide Web Conference, </booktitle> <pages> pages 763-771, </pages> <address> Chicago, Illinois, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: 1 Introduction The exponential growth of the Internet <ref> [4] </ref> makes an unprecedented amount of new information available. Large scale information monitoring has become tantalizingly close to reality. However, this flood of information can easily overwhelm the users, if queries are formulated naively. Furthermore, naive query processing can easily overload the database system and network.
Reference: [5] <author> C. Bowman, P. Danzig, D. Hardy, U. Manber, M. F. Schwartz, and D. P. Wessels. Harvest: </author> <title> A scalable, customizable discovery and access system. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Colorado, </institution> <type> Technical Report CU-CS-732-94, </type> <month> August </month> <year> 1994. </year>
Reference-contexts: The reasons include the lack of integration of information sources, autonomy and heterogeneity in the Internet, and the relatively unorganized storage and management of data, such as WWW pages <ref> [5] </ref>. A promising proposal is Terry et al's continuous queries [27], which can be processed incrementally to reduce both system overhead and user overload. <p> The triggering condition T CQ is a specification of when the query Q should be executed. It can take several forms: * A direct specification of time. For example, Q should be executed once every Monday. This is the policy adopted by the Harvest information gatherers <ref> [5] </ref>. * A specification of time interval from a previous query result. For example, "a week since Q (S n1 ) was produced". (This can be interpreted as a time specification relative to an event.) * A condition on the database state.
Reference: [6] <author> S. Chakravarthy. </author> <title> Architectures and monitoring techniques for active databases: An evaluation. </title> <note> In Technical Report TR-92-041, </note> <institution> University of Florida, </institution> <address> Gainesville, FL, </address> <year> 1992. </year>
Reference-contexts: Other advantages of our semantics will be discussed in Section 3. 2.2 Active Databases Active databases <ref> [6, 15, 20, 22] </ref> allow users to specify, in the form of rules, actions to be performed following changes of database state.
Reference: [7] <author> A. Gupta, I. Mumick, and V. Subrahmanian. </author> <title> Maintaining views incrementally. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 157-166, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The second defers the refresh until a query is issued against the view [21]. The third refreshes the view periodically [11]. The main tradeoff in choosing among these approaches is the staleness of the view data vs. the cost of updating it. Most of the algorithms in the literature <ref> [3, 11, 8, 10, 7] </ref> work in a centralized database environment, in which the materialized view and its base tables co-reside.
Reference: [8] <author> E. N. Hanson. </author> <title> A performance analysis of view materialization strategies. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 440-453, </pages> <address> San Francisco, CA, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: Therefore, the support for flexible and efficient monitoring of information updates is an important goal when accessing data in the Internet. Traditional database techniques such as view materialization <ref> [3, 8] </ref>, active databases [22], and query optimization cannot be directly applied in distributed interoperable environments such as the Internet. The reasons include the lack of integration of information sources, autonomy and heterogeneity in the Internet, and the relatively unorganized storage and management of data, such as WWW pages [5]. <p> As a database is updated, the materialized view must be refreshed to reflect the updates. A naive solution is to rematerialize the view from the base data. In contrast, incremental update algorithms are believed to carry lower execution cost if changes to the database are moderate <ref> [8, 11] </ref>. Three approaches have been described previously. The first approach refreshes the view immediately after each update to the base table [3]. The second defers the refresh until a query is issued against the view [21]. The third refreshes the view periodically [11]. <p> The second defers the refresh until a query is issued against the view [21]. The third refreshes the view periodically [11]. The main tradeoff in choosing among these approaches is the staleness of the view data vs. the cost of updating it. Most of the algorithms in the literature <ref> [3, 11, 8, 10, 7] </ref> work in a centralized database environment, in which the materialized view and its base tables co-reside. <p> The solution we promote avoids the overhead of recomputing the query from scratch, and relaxes the restrictions of append-only database and monotonic-transformable queries. Our design builds on the research in differential files [25], hypothetical relations <ref> [8, 26] </ref>, and incremental updating materialized views [3, 23, 29], and offers several advantages over the previous solutions [27, 2]. <p> We define an operator that computes differential relations for arbitrary SPJ expressions. The concept of differential relations is, to some extent, similar to the concept of hypothetical relations used for incremental updating materialized views <ref> [3, 8] </ref>. The difference lies in the usage and the detailed structure. <p> The goal for defining differential relations, instead of using hypothetical relations described in <ref> [3, 8] </ref>, is to provide a unified treatment of changes, not separate treatments of insertions, deletions, and modifications resulting in several algorithms for generating and combining individual results. <p> This mechanism works effectively when n is larger than k. The idea of using the truth table to facilitate the combination of possible joins was borrowed from the research in updating materialized view <ref> [3, 8] </ref>.
Reference: [9] <institution> Informix Software, Inc. </institution> <note> Informix Guide to SQL: Syntax (Version 6.0), </note> <year> 1994. </year>
Reference-contexts: Despite their conceptual generality, rules have been so far supported in a fairly restrictive form in practical systems, for example, by triggers <ref> [9] </ref> in relational database management systems such as Oracle, Sybase, and Informix. A trigger is an event-condition-action (ECA) rule in a restrictive form. Typically, triggers can be specified only on a single base table.
Reference: [10] <author> B. Kahler and O. Risnes. </author> <title> Extending logging for database snapshot refresh. </title> <booktitle> In Proceedings of the International Conference on Very Large Data Bases, </booktitle> <pages> pages 389-398, </pages> <address> Brighton, England, </address> <month> September </month> <year> 1987. </year>
Reference-contexts: The second defers the refresh until a query is issued against the view [21]. The third refreshes the view periodically [11]. The main tradeoff in choosing among these approaches is the staleness of the view data vs. the cost of updating it. Most of the algorithms in the literature <ref> [3, 11, 8, 10, 7] </ref> work in a centralized database environment, in which the materialized view and its base tables co-reside.
Reference: [11] <author> B. Lindsay, L. Haas, and C. Mohan. </author> <title> A snapshot differential refresh algorithm. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 53-60, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: As a database is updated, the materialized view must be refreshed to reflect the updates. A naive solution is to rematerialize the view from the base data. In contrast, incremental update algorithms are believed to carry lower execution cost if changes to the database are moderate <ref> [8, 11] </ref>. Three approaches have been described previously. The first approach refreshes the view immediately after each update to the base table [3]. The second defers the refresh until a query is issued against the view [21]. The third refreshes the view periodically [11]. <p> Three approaches have been described previously. The first approach refreshes the view immediately after each update to the base table [3]. The second defers the refresh until a query is issued against the view [21]. The third refreshes the view periodically <ref> [11] </ref>. The main tradeoff in choosing among these approaches is the staleness of the view data vs. the cost of updating it. Most of the algorithms in the literature [3, 11, 8, 10, 7] work in a centralized database environment, in which the materialized view and its base tables co-reside. <p> The second defers the refresh until a query is issued against the view [21]. The third refreshes the view periodically [11]. The main tradeoff in choosing among these approaches is the staleness of the view data vs. the cost of updating it. Most of the algorithms in the literature <ref> [3, 11, 8, 10, 7] </ref> work in a centralized database environment, in which the materialized view and its base tables co-reside.
Reference: [12] <author> L. Liu and C. Pu. </author> <title> The distributed interoperable object model and its application to large-scale interoperable database systems. </title> <type> Technical report, </type> <address> Portland, OR, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: Further refinements include approximate queries, partial matching and correlations, and other deep information semantics. In this paper, we focus our attention on the first two issues. We make two contributions towards flexible and efficient monitoring of information updates, motivated by a distributed interoperable environment such as DIOM <ref> [12] </ref>. First, we describe continual queries with epsilon specification, namely epsilon continual queries (ECQ), to simplify continual query formulation on the user side.
Reference: [13] <author> L. Liu and C. Pu. </author> <title> The distributed interoperable object model and its application to large-scale interoperable database systems. </title> <type> Technical Report OGI-CSE-95-003, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: Rather, these techniques have been proposed primarily for "data-centric" environments, where data is well organized and controlled. When applied to an Information Superhighway environment (for brevity and concreteness we refer to this environment as the Internet), these assumptions no longer hold (see <ref> [13] </ref> for a summary of desired system properties in the Internet). <p> We have proved that, for any SPJ expression, using differential re-evaluation method is functionally equivalent to the complete re-evaluation of the query. In this section we will discuss a number of issues related to the implementation of continual queries in the Diorama project <ref> [13] </ref>. 6.1 Improving Performance in Compilation and Execution Our differential algorithm for query refresh does not automatically provide the most efficient way of processing CQs. There are a number of possibilities to further improve the performance of differential processing of continual queries.
Reference: [14] <author> D. Maier. </author> <title> The Theory of Relational Databases. </title> <publisher> Computer Science Press, </publisher> <year> 1983. </year>
Reference-contexts: We assume that the reader is familiar with the basic concepts and notation concerning relational database, as described in <ref> [14] </ref>. In this paper we refer to relational selection, projection, join, outerjoin, union, and difference operators by , , ./, Outerjoin 2 , S , and respectively. <p> In the eager mechanism for materialized view update, a hypothetical relation represents the net changes made by a single transaction 2 Outerjoin keeps all tuples in both the left and right relations when no matching tuples are found, padding them with null values as needed <ref> [14] </ref>. 8 to a base relation and can be dropped after the transaction is committed and the materialized view is updated. In the continual query refresh method, a differential relation actually maintains changes made by several transactions to a base relation.
Reference: [15] <author> D. McCarthy and U. Dayal. </author> <title> The architecture of an active database management system. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 215-224, </pages> <month> May </month> <year> 1989. </year> <month> 25 </month>
Reference-contexts: Other advantages of our semantics will be discussed in Section 3. 2.2 Active Databases Active databases <ref> [6, 15, 20, 22] </ref> allow users to specify, in the form of rules, actions to be performed following changes of database state.
Reference: [16] <author> C. Pu and S. Chen. </author> <title> ACID properties need fast relief: Relaxing consistency using epsilon serializability. </title> <booktitle> In Proceedings of Fifth International Workshop on High Performance Transaction Systems, Asilomar, </booktitle> <address> Califor-nia, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: The specification of the error tolerance, in the above example, i.e., half a million dollars, is called an epsilon specification (*-spec). A formal characterization of ESR is presented in [19]. Divergence control algorithms that guarantee ESR efficiently have been devised [28, 17], and a prototype implementation <ref> [16] </ref> done on top of Transarc Encina, a commercial transaction processing monitor. Although ESR was originally proposed for transaction processing, we have found an interesting application of epsilon queries in the context of CQs.
Reference: [17] <author> C. Pu, W. Hseush, G. Kaiser, K.-L. Wu, and P. Yu. </author> <title> Divergence control for distributed database systems. </title> <journal> International Journal on Distributed and Parallel Databases, </journal> <volume> 3(1) </volume> <pages> 85-109, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: In Section 5 we describe a strategy to generate Q (S n ) from Q (S n1 ) incrementally, thus reducing both processing time and network transmission bandwidth. 3.2 Epsilon Specifications Epsilon specifications have been introduced as part of the work on Epsilon Serializability (ESR) <ref> [17, 18, 19] </ref>. ESR was originally proposed as a correctness criterion to generalize concurrency control in extended transaction processing. <p> The specification of the error tolerance, in the above example, i.e., half a million dollars, is called an epsilon specification (*-spec). A formal characterization of ESR is presented in [19]. Divergence control algorithms that guarantee ESR efficiently have been devised <ref> [28, 17] </ref>, and a prototype implementation [16] done on top of Transarc Encina, a commercial transaction processing monitor. Although ESR was originally proposed for transaction processing, we have found an interesting application of epsilon queries in the context of CQs. <p> This way, we can define an ECQ from an epsilon query plus a termination condition. Intuitively, the original epsilon query was defined to allow a bounded amount of inconsistency to be introduced into the query result. For example, divergence control algorithms <ref> [28, 17] </ref> allow limited non-serializable conflicts between updates and the epsilon query to happen, to increase system execution flexibility and concurrency.
Reference: [18] <author> C. Pu and A. Leff. </author> <title> Replica control in distributed systems: An asynchronous approach. </title> <booktitle> In Proceedings of the 1991 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 377-386, </pages> <address> Denver, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: In Section 5 we describe a strategy to generate Q (S n ) from Q (S n1 ) incrementally, thus reducing both processing time and network transmission bandwidth. 3.2 Epsilon Specifications Epsilon specifications have been introduced as part of the work on Epsilon Serializability (ESR) <ref> [17, 18, 19] </ref>. ESR was originally proposed as a correctness criterion to generalize concurrency control in extended transaction processing. <p> Our triggering conditions are more expressive than previous proposals such as continuous queries [27], since T CQ can describe time of day, intervals of time, the magnitude of updates, or accumulated updates, in a way similar to epsilon transactions <ref> [18, 19] </ref>. These new CQs are called Epsilon CQs (ECQs). Second, we describe a differential re-evaluation algorithm to support efficient processing of ECQs. Given the distributed nature of Internet, complete reprocessing of the ECQ query each time it is triggered would be prohibitively expensive.
Reference: [19] <author> K. Ramamrithan and C. Pu. </author> <title> A formal characterization of epsilon serializability. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> June </month> <year> 1995. </year>
Reference-contexts: In Section 5 we describe a strategy to generate Q (S n ) from Q (S n1 ) incrementally, thus reducing both processing time and network transmission bandwidth. 3.2 Epsilon Specifications Epsilon specifications have been introduced as part of the work on Epsilon Serializability (ESR) <ref> [17, 18, 19] </ref>. ESR was originally proposed as a correctness criterion to generalize concurrency control in extended transaction processing. <p> The specification of the error tolerance, in the above example, i.e., half a million dollars, is called an epsilon specification (*-spec). A formal characterization of ESR is presented in <ref> [19] </ref>. Divergence control algorithms that guarantee ESR efficiently have been devised [28, 17], and a prototype implementation [16] done on top of Transarc Encina, a commercial transaction processing monitor. <p> Our triggering conditions are more expressive than previous proposals such as continuous queries [27], since T CQ can describe time of day, intervals of time, the magnitude of updates, or accumulated updates, in a way similar to epsilon transactions <ref> [18, 19] </ref>. These new CQs are called Epsilon CQs (ECQs). Second, we describe a differential re-evaluation algorithm to support efficient processing of ECQs. Given the distributed nature of Internet, complete reprocessing of the ECQ query each time it is triggered would be prohibitively expensive.
Reference: [20] <author> A. Rosenthal, S. Chakravarthy, B. Blaustein, and J. Blakely. </author> <title> Situation monitoring for active databases. </title> <booktitle> In Proceedings of the 15th International Conference on Very Large Data Bases, </booktitle> <pages> pages 469-478, </pages> <address> Amsterdam, Holland, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: Other advantages of our semantics will be discussed in Section 3. 2.2 Active Databases Active databases <ref> [6, 15, 20, 22] </ref> allow users to specify, in the form of rules, actions to be performed following changes of database state.
Reference: [21] <author> N. Roussopoulos and H. Kang. </author> <title> Preliminary design of adms+: A workstation-mainframe integrated architecture fopr database management systems. </title> <booktitle> In Proceedings of the 12th International Conference on Very Large Data Bases, </booktitle> <pages> pages 355-364, </pages> <address> Kyoto, Japan, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: Three approaches have been described previously. The first approach refreshes the view immediately after each update to the base table [3]. The second defers the refresh until a query is issued against the view <ref> [21] </ref>. The third refreshes the view periodically [11]. The main tradeoff in choosing among these approaches is the staleness of the view data vs. the cost of updating it.
Reference: [22] <author> U. Schreier, H. Pirahesh, R. Agrawal, and C. Mohan. Alert: </author> <title> An architecture for transforming a passive dbms into an active dbms. </title> <booktitle> In Proceedings of the International Conference on Very Large Data Bases, </booktitle> <pages> pages 469-478, </pages> <address> Barcelona, Spain, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: Therefore, the support for flexible and efficient monitoring of information updates is an important goal when accessing data in the Internet. Traditional database techniques such as view materialization [3, 8], active databases <ref> [22] </ref>, and query optimization cannot be directly applied in distributed interoperable environments such as the Internet. The reasons include the lack of integration of information sources, autonomy and heterogeneity in the Internet, and the relatively unorganized storage and management of data, such as WWW pages [5]. <p> Other advantages of our semantics will be discussed in Section 3. 2.2 Active Databases Active databases <ref> [6, 15, 20, 22] </ref> allow users to specify, in the form of rules, actions to be performed following changes of database state. <p> A trigger is an event-condition-action (ECA) rule in a restrictive form. Typically, triggers can be specified only on a single base table. Active query, introduced in Alert <ref> [22] </ref>, is yet another form of ECA rules, similar to continuous queries (Section 2.1), and usually assumed to work in an append-only environment. Active queries are more sophisticated than triggers, since they can be defined on multiple tables, on views, and can be nested within other active queries.
Reference: [23] <author> A. Segev and W. Fang. </author> <title> Currency-based updates to distributed materialized views. </title> <booktitle> In Proceedings of the 6th International Conference on Data Engineering, </booktitle> <pages> pages 512-520, </pages> <address> Los Alamitos, </address> <month> February </month> <year> 1990. </year>
Reference-contexts: The study on distributed materialized view management has been primarily focused on determining the optimal refresh sources and timing for multiple views defined on the same base data <ref> [24, 23] </ref>. In contrast to database view work, which assumes well organized data and schema, as well as system-defined periodic refresh, continual queries should give users more flexibility in specifying the conditions for refresh and tighter control over the distance between "view result" and the current database state. <p> The solution we promote avoids the overhead of recomputing the query from scratch, and relaxes the restrictions of append-only database and monotonic-transformable queries. Our design builds on the research in differential files [25], hypothetical relations [8, 26], and incremental updating materialized views <ref> [3, 23, 29] </ref>, and offers several advantages over the previous solutions [27, 2]. The basic idea is to compute the result of the current execution of a continual query by combining the result produced by the most recent execution with the updates occurred in between these two consecutive executions.
Reference: [24] <author> A. Segev and J. Park. </author> <title> Maintaining materialized views in distributed databases. </title> <booktitle> In Proceedings of the 5th International Conference on Data Engineering, </booktitle> <pages> pages 262-270, </pages> <address> Los Angeles, </address> <month> February </month> <year> 1989. </year>
Reference-contexts: The study on distributed materialized view management has been primarily focused on determining the optimal refresh sources and timing for multiple views defined on the same base data <ref> [24, 23] </ref>. In contrast to database view work, which assumes well organized data and schema, as well as system-defined periodic refresh, continual queries should give users more flexibility in specifying the conditions for refresh and tighter control over the distance between "view result" and the current database state.
Reference: [25] <author> D. G. Severance and G. M. Lohman. </author> <title> Differential files: Their application to the maintenance of large databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1(3) </volume> <pages> 256-267, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: The solution we promote avoids the overhead of recomputing the query from scratch, and relaxes the restrictions of append-only database and monotonic-transformable queries. Our design builds on the research in differential files <ref> [25] </ref>, hypothetical relations [8, 26], and incremental updating materialized views [3, 23, 29], and offers several advantages over the previous solutions [27, 2].
Reference: [26] <author> M. Stonebreaker, A. Jhingran, J. Goh, and S. Potamianos. </author> <title> On rules, procedures, caching and views in database systems. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 281-290, </pages> <address> Barcelona, Spain, </address> <year> 1990. </year>
Reference-contexts: The solution we promote avoids the overhead of recomputing the query from scratch, and relaxes the restrictions of append-only database and monotonic-transformable queries. Our design builds on the research in differential files [25], hypothetical relations <ref> [8, 26] </ref>, and incremental updating materialized views [3, 23, 29], and offers several advantages over the previous solutions [27, 2].
Reference: [27] <author> D. Terry, D. Goldberg, D. Nichols, and B. </author> <title> Oki. Continuous queries over append-only databases. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 321-330, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: The reasons include the lack of integration of information sources, autonomy and heterogeneity in the Internet, and the relatively unorganized storage and management of data, such as WWW pages [5]. A promising proposal is Terry et al's continuous queries <ref> [27] </ref>, which can be processed incrementally to reduce both system overhead and user overload. However, the severe assumptions they made about their environment, such as append-only databases with no deletions, render their work unsuitable for many kinds of queries and information sources in the Internet. <p> First, we describe continual queries with epsilon specification, namely epsilon continual queries (ECQ), to simplify continual query formulation on the user side. In addition to triggering query refresh periodically as proposed in previous work <ref> [27, 2] </ref>, ECQs allow the users to 1 specify and activate query refresh based on the magnitude of updates. <p> This differential re-evaluation algorithm reduces data transmission by processing the query primarily on the changed data, rather than re-evaluating the entire database. Furthermore, differential re-evaluation supports general updates, including insertions, deletions, and modifications. This is a significant improvement over the no-deletion assumption in <ref> [27] </ref>. The rest of the paper is organized as follows. In Section 2, we discuss the motivations of our work and the related research. Section 3 presents the semantics of continual queries with epsilon specification. Section 4 summarizes the notations and terminology used in the processing of continual queries. <p> Therefore, we discuss these assumptions before we launch into our definition of continual queries (Section 3) and a technique (Section 5) for efficient processing of continual queries. 2.1 Continuous Queries Terry et al <ref> [27] </ref> proposed continuous queries for monitoring information change. However, their proposal made several assumptions that seriously restricted the applicability of their technique to the Internet. The first such assumption is the limitation of database updates to append-only, disallowing deletions and 2 modifications. <p> Since this assumption is used in their query transformation algorithm, it has been difficult to relax it [2], when following their definition of continuous queries. This is one of the motivations for our new definition in Section 3 under a new name, continual queries. Another problem discussed in <ref> [27] </ref> is the non-determinism in continuous query results, where two users with exactly the same continuous query expression could be presented with different results. <p> Active queries are more sophisticated than triggers, since they can be defined on multiple tables, on views, and can be nested within other active queries. However, like continuous queries <ref> [27] </ref>, the append-only assumption seriously restricts the applicability of active queries to the Internet environment where data is appended, removed, or replaced constantly. 3 2.3 Maintenance of Materialized Views Another related area of research is the incremental maintenance of materialized views, which store a snapshot of selected database state. <p> Our design builds on the research in differential files [25], hypothetical relations [8, 26], and incremental updating materialized views [3, 23, 29], and offers several advantages over the previous solutions <ref> [27, 2] </ref>. The basic idea is to compute the result of the current execution of a continual query by combining the result produced by the most recent execution with the updates occurred in between these two consecutive executions. <p> The sequence is started at CQ submission time, refreshed from time to time by a triggering condition T CQ , and terminated by a stopping condition. Our triggering conditions are more expressive than previous proposals such as continuous queries <ref> [27] </ref>, since T CQ can describe time of day, intervals of time, the magnitude of updates, or accumulated updates, in a way similar to epsilon transactions [18, 19]. These new CQs are called Epsilon CQs (ECQs). Second, we describe a differential re-evaluation algorithm to support efficient processing of ECQs.
Reference: [28] <author> K. Wu, P. S. Yu, and C. Pu. </author> <title> Divergence control for epsilon-serializability. </title> <booktitle> In Proceedings of Eighth International Conference on Data Engineering, </booktitle> <pages> pages 506-515, </pages> <address> Phoenix, </address> <month> February </month> <year> 1992. </year> <journal> IEEE/Computer Society. </journal>
Reference-contexts: The specification of the error tolerance, in the above example, i.e., half a million dollars, is called an epsilon specification (*-spec). A formal characterization of ESR is presented in [19]. Divergence control algorithms that guarantee ESR efficiently have been devised <ref> [28, 17] </ref>, and a prototype implementation [16] done on top of Transarc Encina, a commercial transaction processing monitor. Although ESR was originally proposed for transaction processing, we have found an interesting application of epsilon queries in the context of CQs. <p> This way, we can define an ECQ from an epsilon query plus a termination condition. Intuitively, the original epsilon query was defined to allow a bounded amount of inconsistency to be introduced into the query result. For example, divergence control algorithms <ref> [28, 17] </ref> allow limited non-serializable conflicts between updates and the epsilon query to happen, to increase system execution flexibility and concurrency.
Reference: [29] <author> Y. Zhuge, H. Garcia-Molina, J. Hammer, and J. Widom. </author> <title> View maintenance in a warehousing environment. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> San Jose, CA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: This is similar to the specification of update propagation in quasi-copies [1]. A recent paper <ref> [29] </ref> has identified the problem of using incremental view maintenance approaches in a data warehousing environment, 1 where the materialized view and its base relations are loosely coupled. While the warehouse attempts to update a view, the base data at source may keep changing. <p> An anomaly may occur whenever the warehouse performs view update operations using a state of the base relations which differs from the state at which this view update was issued. An eager compensating algorithm is developed in <ref> [29] </ref> to address this problem. <p> The solution we promote avoids the overhead of recomputing the query from scratch, and relaxes the restrictions of append-only database and monotonic-transformable queries. Our design builds on the research in differential files [25], hypothetical relations [8, 26], and incremental updating materialized views <ref> [3, 23, 29] </ref>, and offers several advantages over the previous solutions [27, 2]. The basic idea is to compute the result of the current execution of a continual query by combining the result produced by the most recent execution with the updates occurred in between these two consecutive executions.
References-found: 29

