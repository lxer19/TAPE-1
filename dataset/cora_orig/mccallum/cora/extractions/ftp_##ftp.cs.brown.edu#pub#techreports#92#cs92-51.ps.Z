URL: ftp://ftp.cs.brown.edu/pub/techreports/92/cs92-51.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-92-51.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Marshall P. Cline and Doug Lea. </author> <title> The Behavior of C++ Classes. </title> <booktitle> In Proceedings of the Symposium on Object-Oriented Programming Emphasizing Practical Applications (SOOPPA), </booktitle> <pages> pages 81-91, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: are unable to modify the conditions detected by lint. 5 Related Work Support for formal design constraints in the form of assertions or annotations was designed into Eiffel [10], has been grafted onto Ada in the language Anna [9], and has been proposed for C++ in the form of A++ <ref> [2, 1] </ref>. This work, however, has grown out of the theory of abstract data types [8], and has tended to limit itself to formally specifying the semantics of individual functions and/or collections of functions (e.g., how the member functions within a class relate to one another).
Reference: [2] <author> Marshall P. Cline and Doug Lea. </author> <booktitle> Using Annotated C++ . In Proceedings of C++ at Work - '90, </booktitle> <pages> pages 65-71, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: are unable to modify the conditions detected by lint. 5 Related Work Support for formal design constraints in the form of assertions or annotations was designed into Eiffel [10], has been grafted onto Ada in the language Anna [9], and has been proposed for C++ in the form of A++ <ref> [2, 1] </ref>. This work, however, has grown out of the theory of abstract data types [8], and has tended to limit itself to formally specifying the semantics of individual functions and/or collections of functions (e.g., how the member functions within a class relate to one another).
Reference: [3] <author> Premkumar T. Devanbu. </author> <title> GENOA a customizable, language- and front-end independent code analyzer. </title> <booktitle> In Proceedings of the International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: As such, it is able to constrain relationships between classes, which Eiffel, A++, and Anna are unable to do. CCEL can also express constraints on the concrete syntax of C++ source code (e.g., CCEL class-specific naming conventions); this is also outside the purview of semantics-based constraint systems. GENOA <ref> [3] </ref> is a language-independent application generator that can be used to generate a wide variety of code analysis tools. GENOA specifications consist of actions to be performed at nodes of an attributed parse tree. Unlike CCEL, which is specifically designed for C++ programmers, GENOA is designed for compiler writers.
Reference: [4] <author> Keith E. Gorlen, Sanford M. Orlow, and Perry S. Plexico. </author> <title> Data Abstraction and Object-Oriented Programming in C++. </title> <publisher> John Wiley & Sons, </publisher> <year> 1990. </year>
Reference-contexts: This applies to both direct and indirect subclasses, so declaring M as a pure virtual function in C does not satisfactorily enforce the constraint. This kind of constraint is common in general-purpose class libraries. For example, NIHCL <ref> [4] </ref> contains many such functions for the top-level Object class. * Implementation Constraint: If a class declares a pointer member, it must also declare an assignment operator and a copy constructor. Failure to adhere to this constraint almost always leads to incorrect program behavior [12, Item 11]. <p> Variables are denoted by f . . . g. For instance, when using NIHCL <ref> [4] </ref>, a programmer would want require that every class derived from "Object" declare the isA function with the constraint: // The member function Object::isA must be redefined in all // subclasses of class Object RedefineisA ( Class B | (B.name () == "Object"); Class D | (D.is_descendant (B)); MemberFunction B::f1 |
Reference: [5] <author> Judith E. Grass and Yih-Farn Chen. </author> <title> The C++ Information Abstractor. </title> <booktitle> In USENIX C++ Conference Proceedings, </booktitle> <pages> pages 265-277, </pages> <year> 1990. </year>
Reference: [6] <author> Moises Lejter, Scott Meyers, and Steven P. Reiss. </author> <title> Adding Semantic Information To C++ Development Environments. </title> <booktitle> In Proceedings of C++ at Work-'90, </booktitle> <pages> pages 103-108, </pages> <month> September </month> <year> 1990. </year>
Reference: [7] <author> Moises Lejter, Scott Meyers, and Steven P. Reiss. </author> <title> Support for Maintaining Object-Oriented Programs. </title> <booktitle> In Proceedings of the Conference on Software Maintenance, </booktitle> <month> October </month> <year> 1991. </year> <note> This paper is largely drawn from two other papers [11, 6]. </note>
Reference-contexts: The capture program parses the C++ files and places their semantic structure in the C++ repository. There are several existing systems that can capture the structure and semantics of C++ programs. Such systems include REPRISE [14], CIA++[5], and XREFDB <ref> [7] </ref>. Of these, REPRISE seems most suited for use with CCEL, and our prototype implementation uses REPRISE for the database portion of Clean++. For comparison purposes, the dotted lines in Figure 2 enclose the functionality of the lint tool for C programs.
Reference: [8] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: This work, however, has grown out of the theory of abstract data types <ref> [8] </ref>, and has tended to limit itself to formally specifying the semantics of individual functions and/or collections of functions (e.g., how the member functions within a class relate to one another). CCEL has a different focus.
Reference: [9] <author> D. Luckham, F. von Henke, B. Krieg-Bruckner, and O. Owe. Anna, </author> <title> A Language for Annotating Ada Programs: Reference Manual, </title> <booktitle> volume 260 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: (i.e., the set of constraints to be enforced), while users of lint are unable to modify the conditions detected by lint. 5 Related Work Support for formal design constraints in the form of assertions or annotations was designed into Eiffel [10], has been grafted onto Ada in the language Anna <ref> [9] </ref>, and has been proposed for C++ in the form of A++ [2, 1].
Reference: [10] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: In particular, CCEL users can modify the CCEL source (i.e., the set of constraints to be enforced), while users of lint are unable to modify the conditions detected by lint. 5 Related Work Support for formal design constraints in the form of assertions or annotations was designed into Eiffel <ref> [10] </ref>, has been grafted onto Ada in the language Anna [9], and has been proposed for C++ in the form of A++ [2, 1].
Reference: [11] <author> Scott Meyers. </author> <title> Working with Object-Oriented Programs: The View from the Trenches is Not Always Pretty. </title> <booktitle> In Proceedings of the Symposium on Object-Oriented Programming Emphasizing Practical Applications (SOOPPA), </booktitle> <pages> pages 51-65, </pages> <month> September </month> <year> 1990. </year>
Reference: [12] <author> Scott Meyers. </author> <title> Effective C++: 50 Specific Ways to Improve Your Programs and Designs. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: For example, NIHCL [4] contains many such functions for the top-level Object class. * Implementation Constraint: If a class declares a pointer member, it must also declare an assignment operator and a copy constructor. Failure to adhere to this constraint almost always leads to incorrect program behavior <ref> [12, Item 11] </ref>. A number of similar constraints was presented at last year's USENIX C++ conference [13]. * Stylistic Constraint: All class names must begin with an upper case letter.
Reference: [13] <author> Scott Meyers and Moises Lejter. </author> <title> Automatic Detection of C++ Programming Errors: Initial Thoughts on a lint++. </title> <booktitle> In USENIX C++ Conference Proceedings, </booktitle> <pages> pages 29-40, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Failure to adhere to this constraint almost always leads to incorrect program behavior [12, Item 11]. A number of similar constraints was presented at last year's USENIX C++ conference <ref> [13] </ref>. * Stylistic Constraint: All class names must begin with an upper case letter. Most software development teams adopt some type of naming convention for identifiers; violations are irritating at best, confusing and misleading at worst. fl Current affiliation: Cadre Technologies, Inc., 222 Richmond Street, Providence, RI 02903.
Reference: [14] <author> David S. Rosenblum and Alexander L. Wolf. </author> <title> Representing Semantically Analyzed C++ Code with Reprise. </title> <booktitle> In USENIX C++ Conference Proceedings, </booktitle> <pages> pages 119 - 134, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: The ccel evaluator program executes the queries and outputs any violations of the constraints. The capture program parses the C++ files and places their semantic structure in the C++ repository. There are several existing systems that can capture the structure and semantics of C++ programs. Such systems include REPRISE <ref> [14] </ref>, CIA++[5], and XREFDB [7]. Of these, REPRISE seems most suited for use with CCEL, and our prototype implementation uses REPRISE for the database portion of Clean++. For comparison purposes, the dotted lines in Figure 2 enclose the functionality of the lint tool for C programs.
References-found: 14

