URL: http://www.cs.dartmouth.edu/~jasonliu/courses/sim188/biblio/atom-ref.ps.gz
Refering-URL: http://www.cs.dartmouth.edu/~jasonliu/courses/sim188/
Root-URL: http://www.cs.dartmouth.edu
Title: ATOM Reference Manual  
Affiliation: Digital Equipment Corporation Maynard, Massachusetts  
Date: December 1993  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Anant Agarwal, Richard Sites, and Mark Horwitz ATUM: </author> <title> A New Technique for Capturing Address Traces Using Microcode, </title> <booktitle> Proceedings of the 13th International Symposium on Computer Architecture, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: Mahler was used for generating address traces on Titans [3]. This system used a more efficient method for communicating information than Pixie but required operating system modifications. MPTRACE [4] is also similar to Pixie but it collects traces for multiprocessors by instrumenting assembly code. ATUM <ref> [1] </ref> generates address traces by modifying microcode. ATUM performs trace compression and saves the trace in a file that is analyzed offline. The third class of tools are based on simulation. Tango Lite [6] is a multiprocessor simulator that instruments assembly language code.
Reference: [2] <author> Eric A. Brewer, Chrysanthos N. Dellarocas, Adrian Colbrook, and William E. Weihl, PROTEUS: </author> <title> A High-Performance Parallel-Architecture Simulator, </title> <publisher> MIT/LCS/TR-516, MIT, </publisher> <year> 1991. </year>
Reference-contexts: ATUM [1] generates address traces by modifying microcode. ATUM performs trace compression and saves the trace in a file that is analyzed offline. The third class of tools are based on simulation. Tango Lite [6] is a multiprocessor simulator that instruments assembly language code. PROTEUS <ref> [2] </ref> is also a multiprocessor simulator but instrumentation is done by the compiler. Shade [5] is an efficient instruction-set simulator that can generate selective instruction traces. These existing tools have several drawbacks. First, most tools are designed to compute fixed data.
Reference: [3] <author> Anita Borg, R.E. Kessler, Georgia Lazana, and David Wall, </author> <title> Long Address Traces from RISC Machines: Generation and Analysis, </title> <booktitle> Proceedings of the 17th Annual Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1990, </year> <note> also available as WRL RR 89/14, </note> <month> Sep </month> <year> 1989. </year>
Reference-contexts: The second class of tools are address tracing tools that generate data and instruction traces. Pixie and QPT can generate traces and can communicate to analysis routines through inter-process communication. Mahler was used for generating address traces on Titans <ref> [3] </ref>. This system used a more efficient method for communicating information than Pixie but required operating system modifications. MPTRACE [4] is also similar to Pixie but it collects traces for multiprocessors by instrumenting assembly code. ATUM [1] generates address traces by modifying microcode.
Reference: [4] <author> Susan J. Eggers, David R. Keppel, Eric J. Koldinger, and Henry M. Levy, </author> <title> Techniques for Efficient Inline Tracing on a Shared-Memory Multiprocessor, </title> <booktitle> SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <volume> vol 8, no 1, </volume> <month> May </month> <year> 1990. </year>
Reference-contexts: Pixie and QPT can generate traces and can communicate to analysis routines through inter-process communication. Mahler was used for generating address traces on Titans [3]. This system used a more efficient method for communicating information than Pixie but required operating system modifications. MPTRACE <ref> [4] </ref> is also similar to Pixie but it collects traces for multiprocessors by instrumenting assembly code. ATUM [1] generates address traces by modifying microcode. ATUM performs trace compression and saves the trace in a file that is analyzed offline. The third class of tools are based on simulation.
Reference: [5] <author> Robert F. Cmelik and David Keppel, Shade: </author> <title> A Fast Instruction-Set Simulator for Execution Profiling, </title> <type> Technical Report UWCSE 93-06-06, </type> <institution> University of Washington. </institution>
Reference-contexts: The third class of tools are based on simulation. Tango Lite [6] is a multiprocessor simulator that instruments assembly language code. PROTEUS [2] is also a multiprocessor simulator but instrumentation is done by the compiler. Shade <ref> [5] </ref> is an efficient instruction-set simulator that can generate selective instruction traces. These existing tools have several drawbacks. First, most tools are designed to compute fixed data. It is not easy for a user to modify such tools to compute more or less data.
Reference: [6] <author> Stephen R. Goldschmidt and John L. Hennessy, </author> <title> The Accuracy of Trace-Driven Simulations of Multiprocessors, </title> <institution> CSL-TR-92-546, Computer Systems Laboratory, Stanford University, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: ATUM [1] generates address traces by modifying microcode. ATUM performs trace compression and saves the trace in a file that is analyzed offline. The third class of tools are based on simulation. Tango Lite <ref> [6] </ref> is a multiprocessor simulator that instruments assembly language code. PROTEUS [2] is also a multiprocessor simulator but instrumentation is done by the compiler. Shade [5] is an efficient instruction-set simulator that can generate selective instruction traces. These existing tools have several drawbacks.
Reference: [7] <author> James R. Larus and Thomas Ball. </author> <title> Rewriting executable files to measure program behavior. </title> <institution> University of Wisconsin Computer Sciences Tech. </institution> <type> Report 1083, </type> <month> March </month> <year> 1992. </year>
Reference-contexts: Over the past decade many tools for different machines and applications have been developed. We briefly describe these tools by grouping them into three classes. The first class consists of basic block counting tools like Pixie [8], Epoxie [12] and QPT <ref> [7] </ref> that count the number of times each basic block is executed. The second class of tools are address tracing tools that generate data and instruction traces. Pixie and QPT can generate traces and can communicate to analysis routines through inter-process communication.
Reference: [8] <institution> MIPS Computer Systems, Inc. Language Programmers's Guide, </institution> <year> 1986. </year> <month> 14 </month>
Reference-contexts: Over the past decade many tools for different machines and applications have been developed. We briefly describe these tools by grouping them into three classes. The first class consists of basic block counting tools like Pixie <ref> [8] </ref>, Epoxie [12] and QPT [7] that count the number of times each basic block is executed. The second class of tools are address tracing tools that generate data and instruction traces. Pixie and QPT can generate traces and can communicate to analysis routines through inter-process communication.
Reference: [9] <author> Amitabh Srivastava and David W. Wall, </author> <title> A Practical System for Intermodule Code Optimization at Link-Time, </title> <journal> Journal of Programming Language, </journal> <volume> vol 1, </volume> <month> March </month> <year> 1993, </year> <pages> pp 1-18. </pages> <note> Also available as WRL RR 92/6, </note> <month> December </month> <year> 1992. </year>
Reference-contexts: Section 4 describes how ATOM computes the precise information. ATOM is independent of any compiler and language as it operates on object modules that make up the complete program. It uses the OM <ref> [9] </ref> link-time technology to conveniently modify an executable. 3 Building Customized Tools: An Example In this section we show how to build a simple tool that counts how many times each conditional branch in the program is taken and how many times it is not taken. <p> ATOM builds the customized tool which takes as input the application program and outputs the instrumented program executable. When this instrumented program is executed the branch statistics are produced as a side effect of the normal program execution. 4 Implementation of ATOM ATOM is built using OM <ref> [9, 10, 11] </ref>, a link-time code modification system. OM takes as input a collection of object files and libraries that make up a complete program, builds a symbolic intermediate representation, applies instrumentation and optimizations to the intermediate representation, and finally outputs an executable. <p> Only these registers need to be saved and restored. The number of registers that need to be saved may be further reduced by computing live registers in the application program. OM can do interprocedural live variable analysis <ref> [9] </ref> and compute all registers live at a point. Only the live registers need to be saved and restored to preserve the state of the program execution.
Reference: [10] <author> Amitabh Srivastava and David W. Wall, </author> <title> Link-Time Optimization of Address Calculation on a 64-bit Architecture, </title> <address> WRL TN-35, </address> <month> June </month> <year> 1993, </year> <note> submitted to PLDI '94. </note>
Reference-contexts: ATOM builds the customized tool which takes as input the application program and outputs the instrumented program executable. When this instrumented program is executed the branch statistics are produced as a side effect of the normal program execution. 4 Implementation of ATOM ATOM is built using OM <ref> [9, 10, 11] </ref>, a link-time code modification system. OM takes as input a collection of object files and libraries that make up a complete program, builds a symbolic intermediate representation, applies instrumentation and optimizations to the intermediate representation, and finally outputs an executable.
Reference: [11] <author> Amitabh Srivastava. </author> <title> Unreachable procedures in object-oriented programming, </title> <note> to appear in ACM LOPLAS Vol 1, #4. Also available as WRL RR 93/4, </note> <month> August </month> <year> 1993. </year>
Reference-contexts: ATOM builds the customized tool which takes as input the application program and outputs the instrumented program executable. When this instrumented program is executed the branch statistics are produced as a side effect of the normal program execution. 4 Implementation of ATOM ATOM is built using OM <ref> [9, 10, 11] </ref>, a link-time code modification system. OM takes as input a collection of object files and libraries that make up a complete program, builds a symbolic intermediate representation, applies instrumentation and optimizations to the intermediate representation, and finally outputs an executable.

References-found: 11

