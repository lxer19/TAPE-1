URL: http://graphics.stanford.edu/~slusallek/Papers/wppg95.ps.gz
Refering-URL: http://graphics.stanford.edu/~slusallek/cv.html
Root-URL: http://www.cs.stanford.edu
Title: Object-Oriented Design for Image Synthesis  
Author: Philipp Slusallek Hans-Peter Seidel 
Abstract: The structure of the image synthesis process naturally leads to the use of object-oriented software design and many existing rendering systems are based on some kind of object-oriented approach. However, some areas in image synthesis, such as global illumination, were considered to violate some fundamental principles of object-orientation. In this paper, we suggest a design approach which overcomes this apparent inconsistencies and allows for a uniform use of object-oriented techniques in image synthesis. The second part of the paper discusses attributes in hierarchical scene descriptions using a new object-oriented approach.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> James Arvo and David Kirk. </author> <title> Particle transport and image synthesis. </title> <booktitle> Computer Graphics (SIGGRAPH '90 Proceedings), </booktitle> <volume> 24(4) </volume> <pages> 63-66, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Its main responsibility is to compute the amount of light reflected into a given outgoing direction based on a suitable description of the incoming illumination. In addition it offers access to several other aspects of the interaction of light with a surface. For Monte-Carlo like global illumination algorithms <ref> [11, 16, 1, 14] </ref> the Shader subsystem offers the possibility to obtain the importance information for illu mination. Thus, the Shader can provide information about how important illu-mination from different directions is for its computation of the reflected light.
Reference: [2] <author> Ekkehard Beier. </author> <title> Object-oriented design of graphical attributes. </title> <booktitle> In Fourth Euro-graphics Workshop on Object-Oriented Graphics, </booktitle> <pages> pages 41-50. </pages> <address> Sintra, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Direct Association With direct association, a particular attribute is asso-ciated with a subgraph of the scene by directly storing references with each primitive in the subgraph, i.e. each object carries a list of all its attributes. This approach is used in many rendering systems, e.g. <ref> [21, 2] </ref>. In this approach the renderer looses much of the coherence information of a hierarchical scene description. Thus, we end up rendering 1000 transformed triangles instead of a single transformed chair made of many triangles. This coherence information can be very important for optimized rendering of animations. <p> No overhead is introduced for standard attributes. We should also note that this scheme cannot be modeled with other object-oriented attribute schemes as presented in <ref> [25, 2] </ref>. However, this scheme does not solve the problem of changing member variables of multiply instantiated objects.
Reference: [3] <author> Grady Booch. </author> <title> Object-Oriented Analysis and Design with Applications. </title> <publisher> Ben-jamin/Cummings Publishing, </publisher> <address> 2. edition, </address> <year> 1994. </year>
Reference-contexts: This forms the basis for our later discussions. A basic idea behind object-oriented design is the modeling of a software system based on real world objects <ref> [3] </ref>. For image synthesis these real world objects describe the geometric objects in a scene and their optical attributes, such as emission and reflection of light. <p> This separation is discussed in detail in Section 4. 3 Lighting The problem of global illumination, which is at the heart of a physically-based rendering architecture, is the requirement for global knowledge about participating objects and details about their interaction with light. Using object-oriented Fig. 1: A class diagram <ref> [3] </ref> of the subsystems of the major Vision rendering architecture and their "uses"-relation.
Reference: [4] <author> Michael Cohen, Shenchang E. Chen, John R. Wallace, and Donald P. Greenberg. </author> <title> A progressive refinement approach to fast radiosity image generation. </title> <booktitle> Computer Graphics (SIGGRAPH '88 Proceedings), </booktitle> <volume> 22(4) </volume> <pages> 75-84, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Thus, the Shader can provide information about how important illu-mination from different directions is for its computation of the reflected light. This interface is essential in order to implement efficient importance sampling techniques [12]. For finite-element style algorithms, such as radiosity <ref> [4, 9] </ref>, the Shader subsystems offers access to the mean reflectance and transmittance of a surface over a given surface element. <p> To compute a solution, global knowledge must be maintained by at least one object in the architecture. Explicit global knowledge can be avoided when using local propagation methods, in which only direct communication between the entities is allowed. Methods like progressive radiosity <ref> [4] </ref> seem to use local propagation, because they only propagate radiosity from one patch to another. However, the computation of the exchange coefficients or form-factors involves all other patches in the environment for visibility computation.
Reference: [5] <author> Parris K. Egbert and Travis L. Hilton. </author> <title> Mixed paradigm graphics. </title> <booktitle> In Fourth EUROGRAPHICS Workshop on Object-Oriented Graphics, </booktitle> <address> Sintra, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Based on the physical description and the requirements of the two basic global illumination techniques, Monte-Carlo and finite elements, we have developed a very general and flexible set of interface methods for these local descriptions [19, 18]. As a result of this design, and in contrast to other statements <ref> [5] </ref>, we believe that it is not necessary to break the object-oriented approach due to the nature of the image synthesis process. 3.2 Active Versus Passive Objects Another aspect of our architecture is that the Lighting object is the only active object in the computation of illumination. <p> Using this design approach eliminates many of the problems that appeared in other systems, e.g. the question, whether the Light Source or the Shader class is responsible for computing illumination <ref> [8, 6, 10, 5] </ref> 4 Separation of Geometry and Attributes Attributes in our context are objects that describe certain properties of the scene, but which are not bound to a particular geometric primitive (e.g. like the radius of the sphere). <p> We discussed a solution to the problem of computing the global illumination in a scene. In contrast to other papers, e.g. <ref> [5] </ref>, we demonstrated that no violation of object-oriented principles occurs using after introducing a new Lighting class and suitably general interfaces between subsystems. We also discussed the use of attributes in an object-oriented rendering system.
Reference: [6] <author> Dieter W. Fellner. </author> <title> Extensible image synthesis. </title> <booktitle> In Fourth EUROGRAPHICS Workshop on Object-Oriented Graphics, </booktitle> <address> Sintra, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Using this design approach eliminates many of the problems that appeared in other systems, e.g. the question, whether the Light Source or the Shader class is responsible for computing illumination <ref> [8, 6, 10, 5] </ref> 4 Separation of Geometry and Attributes Attributes in our context are objects that describe certain properties of the scene, but which are not bound to a particular geometric primitive (e.g. like the radius of the sphere).
Reference: [7] <author> B. N. Freeman-Benson and A. Boring. </author> <title> Integrating constraints with object-oriented programming. </title> <editor> In O. L. Madsen, editor, </editor> <booktitle> Proceedings ECOOP'92 - European Conference on Object-Oriented Programming, </booktitle> <pages> pages 268-286, </pages> <address> Utrecht, </address> <year> 1992. </year>
Reference-contexts: This problem is closely related to the problem of computing a global solution to constraints in a system, which also requires global access to objects <ref> [7, 22] </ref>. In Section 3 we propose a solution to this problem, by making the description of reflection and emission passive entities and by introducing a special subsystem that is responsible for the calculation of a global solution. <p> Furthermore, these algorithms use global control, e.g. for selecting the brightest patch as the next sender of radiosity. The problem of global solutions is similar to the well-known problem of using constraints in object-oriented systems <ref> [7, 22] </ref>. There, each constraint is a purely local description of some interaction between two objects, but a solution meeting all constraints over all objects can be computed best if global information about all constraints is available.
Reference: [8] <author> Andrew Glassner. </author> <title> Spectrum: An architecture for image synthesis, research, education, and practice. </title> <editor> In Paul S. Strauss, editor, </editor> <title> Developing Large-scale Graphics Software Toolkits, </title> <booktitle> (SIGGRAPH '93 Course Notes 3), pages 1.1-1.44. SIGGRAPH, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Object-oriented techniques have been successfully used in many disciplines of computer graphics, especially in the design and the implementation of rendering systems <ref> [13, 25, 21, 8, 17] </ref>. However, there have been several areas, in which the application of object-oriented techniques has been unsatisfactory. The problems encountered were mostly related to the problem of expressing relationships between objects. There are several occurrences of this problem in image synthesis. <p> Depending on the implementation of the Lighting object, different algorithms can be used to fulfill this request. In contrast, many other rendering architectures use active objects in their scene description, especially for shaders, e.g. <ref> [21, 8] </ref>. In ray tracing based architectures the shaders actively send out rays to sample incident illumination, while in finite element systems they actively distribute light energy to related patches. <p> Using this design approach eliminates many of the problems that appeared in other systems, e.g. the question, whether the Light Source or the Shader class is responsible for computing illumination <ref> [8, 6, 10, 5] </ref> 4 Separation of Geometry and Attributes Attributes in our context are objects that describe certain properties of the scene, but which are not bound to a particular geometric primitive (e.g. like the radius of the sphere).
Reference: [9] <author> Steven J. Gortler, Peter Schroder, Michael Cohen, and Pat M. Hanrahan. </author> <title> Wavelet radiosity. </title> <booktitle> Computer Graphics (SIGGRAPH '93 Proceedings), </booktitle> <volume> 27 </volume> <pages> 221-230, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Thus, the Shader can provide information about how important illu-mination from different directions is for its computation of the reflected light. This interface is essential in order to implement efficient importance sampling techniques [12]. For finite-element style algorithms, such as radiosity <ref> [4, 9] </ref>, the Shader subsystems offers access to the mean reflectance and transmittance of a surface over a given surface element.
Reference: [10] <author> Alwin Grone. </author> <title> RayVis a visualization system based on object-orientation. </title> <booktitle> In Fourth EUROGRAPHICS Workshop on Object-Oriented Graphics, </booktitle> <address> Sintra, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Using this design approach eliminates many of the problems that appeared in other systems, e.g. the question, whether the Light Source or the Shader class is responsible for computing illumination <ref> [8, 6, 10, 5] </ref> 4 Separation of Geometry and Attributes Attributes in our context are objects that describe certain properties of the scene, but which are not bound to a particular geometric primitive (e.g. like the radius of the sphere).
Reference: [11] <author> James T. Kajiya. </author> <title> The rendering equation. </title> <booktitle> Computer Graphics (SIGGRAPH '86 Proceedings), </booktitle> <volume> 20(4) </volume> <pages> 143-150, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Its main responsibility is to compute the amount of light reflected into a given outgoing direction based on a suitable description of the incoming illumination. In addition it offers access to several other aspects of the interaction of light with a surface. For Monte-Carlo like global illumination algorithms <ref> [11, 16, 1, 14] </ref> the Shader subsystem offers the possibility to obtain the importance information for illu mination. Thus, the Shader can provide information about how important illu-mination from different directions is for its computation of the reflected light.
Reference: [12] <author> Malvin H. Kalos and Paula A. Whitlock. </author> <title> Monte Carlo Methods. </title> <publisher> John Wiley & Sons, </publisher> <year> 1986. </year>
Reference-contexts: Thus, the Shader can provide information about how important illu-mination from different directions is for its computation of the reflected light. This interface is essential in order to implement efficient importance sampling techniques <ref> [12] </ref>. For finite-element style algorithms, such as radiosity [4, 9], the Shader subsystems offers access to the mean reflectance and transmittance of a surface over a given surface element.
Reference: [13] <author> David Kirk and James Arvo. </author> <title> The ray tracing kernel. </title> <booktitle> In Proceedings of Ausgraph, </booktitle> <pages> pages 75-82, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Object-oriented techniques have been successfully used in many disciplines of computer graphics, especially in the design and the implementation of rendering systems <ref> [13, 25, 21, 8, 17] </ref>. However, there have been several areas, in which the application of object-oriented techniques has been unsatisfactory. The problems encountered were mostly related to the problem of expressing relationships between objects. There are several occurrences of this problem in image synthesis. <p> The responsibility for handling the transformation is moved from each object to the central scene management. Thus, it simplifies the implementation of geometric primitives and allows for optimizing the code at a single location. Similar to the approach suggested in <ref> [13] </ref> we use Container objects, which are also derived from the GeoObject class, to build a hierarchical scene description. A Container object may contain other geometric objects and forwards requests through its interface to them. In that sense a Container object represents a compound geometric object.
Reference: [14] <author> S. N. Pattanaik. </author> <title> Computational Methods for Global Illumination and Visualization of Complex 3D Environments. </title> <type> PhD thesis, </type> <institution> Birla Institute of Technology & Science, Pilani, India, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Its main responsibility is to compute the amount of light reflected into a given outgoing direction based on a suitable description of the incoming illumination. In addition it offers access to several other aspects of the interaction of light with a surface. For Monte-Carlo like global illumination algorithms <ref> [11, 16, 1, 14] </ref> the Shader subsystem offers the possibility to obtain the importance information for illu mination. Thus, the Shader can provide information about how important illu-mination from different directions is for its computation of the reflected light.
Reference: [15] <author> Peter Schroder. </author> <title> Wavelet Algorithms for Illumination Computations. </title> <type> PhD thesis, </type> <institution> Princeton University, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: For optical attributes this separation is also motivated by the mathematical structure of the operator describing the interaction of light with surfaces, which can be split into a purely geometric and a purely optical operator <ref> [18, 15] </ref>. In the Vision architecture LightSourceShader and Shader objects are simply attributes that are associated with geometric primitives through the scene graph subsystem. Due to the very general interfaces of these subsystems the same attribute object can apply to any of the surface primitives.
Reference: [16] <author> Peter Shirley. </author> <title> Physically Based Lighting Calculations for Computer Graphics. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, U. of Illinois, Urbana-Champaign, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: Its main responsibility is to compute the amount of light reflected into a given outgoing direction based on a suitable description of the incoming illumination. In addition it offers access to several other aspects of the interaction of light with a surface. For Monte-Carlo like global illumination algorithms <ref> [11, 16, 1, 14] </ref> the Shader subsystem offers the possibility to obtain the importance information for illu mination. Thus, the Shader can provide information about how important illu-mination from different directions is for its computation of the reflected light.
Reference: [17] <author> Peter Shirley and Kelvin Sung. </author> <title> A ray tracing framework for global illumination systems. </title> <booktitle> In Proceedings Graphics Interface '91, </booktitle> <pages> pages 117-128, </pages> <address> Calgary, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Object-oriented techniques have been successfully used in many disciplines of computer graphics, especially in the design and the implementation of rendering systems <ref> [13, 25, 21, 8, 17] </ref>. However, there have been several areas, in which the application of object-oriented techniques has been unsatisfactory. The problems encountered were mostly related to the problem of expressing relationships between objects. There are several occurrences of this problem in image synthesis.
Reference: [18] <author> Philipp Slusallek. </author> <title> Vision AnArchitecture for Physically Based Rendering. </title> <type> PhD thesis, </type> <institution> University of Erlangen, IMMD IX, Computer Graphics Group, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: The Vision architecture has successfully integrated almost all state-of-the-art rendering techniques into a uniform and consistent image synthesis system [19]. 2 A Physically-Based Rendering Architecture In this section we give a brief overview of the design of the Vision renderig architecture <ref> [18] </ref> and its object-oriented decomposition into subsystems. This forms the basis for our later discussions. A basic idea behind object-oriented design is the modeling of a software system based on real world objects [3]. <p> For each of the major subsystems we briefly describe its set of responsibilities. The details of the derivation of this object-oriented decomposition and the interfaces offered by these subsystems can be found in <ref> [18] </ref>. For the following discussion we use the term "subsystem" [23] instead of the more common term "class" in order to better express that many of these subsystems will be implemented by a set of related classes. <p> Based on the physical description and the requirements of the two basic global illumination techniques, Monte-Carlo and finite elements, we have developed a very general and flexible set of interface methods for these local descriptions <ref> [19, 18] </ref>. <p> In contrast, our interface to obtain illumination for a Shader object request this information from the Lighting object in general terms. This request also indicates how important illumination from different directions is to a Shader <ref> [19, 18] </ref>. Based on this description of what information is important to a Shader, a particular implementation of the Lighting object can then decide how this illumination is computed. <p> For optical attributes this separation is also motivated by the mathematical structure of the operator describing the interaction of light with surfaces, which can be split into a purely geometric and a purely optical operator <ref> [18, 15] </ref>. In the Vision architecture LightSourceShader and Shader objects are simply attributes that are associated with geometric primitives through the scene graph subsystem. Due to the very general interfaces of these subsystems the same attribute object can apply to any of the surface primitives. <p> We also described how this separation can be implemented uniformly for a rendering architecture and discussed implementation issues. The presented object-oriented design approaches has been successfully used for the design and the implementation of the Vision rendering architecture <ref> [19, 18] </ref>.
Reference: [19] <author> Philipp Slusallek and Hans-Peter Seidel. </author> <title> Vision: An architecture for global illumination calculations. </title> <journal> IEEE Transactions on Visualization and Computer Graphics, </journal> <volume> 1(1) </volume> <pages> 77-96, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Together with suitably general interfaces to the local descriptions, this approach is not in conflict with object-oriented restrictions. In this paper we concentrate on the object-oriented aspects of this approach <ref> [19] </ref>. Another problem is the association of attributes with objects. A general rendering architecture requires that arbitrary attributes can be associated with objects. However, it is not immediately clear how such attributes can be managed by objects they apply to. <p> This rendering architecture uses the underlying physical description of light propagation to derive an object-oriented decomposition of the rendering process. The Vision architecture has successfully integrated almost all state-of-the-art rendering techniques into a uniform and consistent image synthesis system <ref> [19] </ref>. 2 A Physically-Based Rendering Architecture In this section we give a brief overview of the design of the Vision renderig architecture [18] and its object-oriented decomposition into subsystems. This forms the basis for our later discussions. <p> Based on the physical description and the requirements of the two basic global illumination techniques, Monte-Carlo and finite elements, we have developed a very general and flexible set of interface methods for these local descriptions <ref> [19, 18] </ref>. <p> In contrast, our interface to obtain illumination for a Shader object request this information from the Lighting object in general terms. This request also indicates how important illumination from different directions is to a Shader <ref> [19, 18] </ref>. Based on this description of what information is important to a Shader, a particular implementation of the Lighting object can then decide how this illumination is computed. <p> We also described how this separation can be implemented uniformly for a rendering architecture and discussed implementation issues. The presented object-oriented design approaches has been successfully used for the design and the implementation of the Vision rendering architecture <ref> [19, 18] </ref>.
Reference: [20] <author> Paul S. Strauss and Rikk Carey. </author> <title> An object-oriented 3D graphics toolkit. </title> <booktitle> Computer Graphics (SIGGRAPH '92 Proceedings), </booktitle> <volume> 26(2) </volume> <pages> 341-349, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Because the scene object corresponds to a unique path through the DAG the particular attribute applying to the object can easily be located. The SGI Inventor toolkit <ref> [20] </ref> applies attributes to all objects that follow in a depth first traversal of the DAG, unless this behavior is explicitly isolated by special "Separator" nodes in the graph. As a result, the association of attributes with an object also depends on the order of the objects in the graph.
Reference: [21] <author> Ben Trumbore, Wayne Lytle, and Donald P. Greenberg. </author> <title> A testbed for image synthesis. </title> <editor> In Paul S. Strauss and Ben Trumbore, editors, </editor> <booktitle> Developing Large-Scale Graphics Software Toolkits (SIGGRAPH '93 Course Notes 3), pages 4.7-4.17, </booktitle> <address> Anaheim, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Object-oriented techniques have been successfully used in many disciplines of computer graphics, especially in the design and the implementation of rendering systems <ref> [13, 25, 21, 8, 17] </ref>. However, there have been several areas, in which the application of object-oriented techniques has been unsatisfactory. The problems encountered were mostly related to the problem of expressing relationships between objects. There are several occurrences of this problem in image synthesis. <p> Depending on the implementation of the Lighting object, different algorithms can be used to fulfill this request. In contrast, many other rendering architectures use active objects in their scene description, especially for shaders, e.g. <ref> [21, 8] </ref>. In ray tracing based architectures the shaders actively send out rays to sample incident illumination, while in finite element systems they actively distribute light energy to related patches. <p> Direct Association With direct association, a particular attribute is asso-ciated with a subgraph of the scene by directly storing references with each primitive in the subgraph, i.e. each object carries a list of all its attributes. This approach is used in many rendering systems, e.g. <ref> [21, 2] </ref>. In this approach the renderer looses much of the coherence information of a hierarchical scene description. Thus, we end up rendering 1000 transformed triangles instead of a single transformed chair made of many triangles. This coherence information can be very important for optimized rendering of animations.
Reference: [22] <author> Remco C. Veltkamp and Edwin Blake. Event-based.constraints: Coordinate.satisfaction ! object.solution. </author> <booktitle> In Fourth EUROGRAPHICS Workshop on Object-Oriented Graphics (Part. Edition), </booktitle> <pages> pages 251-261, </pages> <address> Sintra, Portugal, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: This problem is closely related to the problem of computing a global solution to constraints in a system, which also requires global access to objects <ref> [7, 22] </ref>. In Section 3 we propose a solution to this problem, by making the description of reflection and emission passive entities and by introducing a special subsystem that is responsible for the calculation of a global solution. <p> Furthermore, these algorithms use global control, e.g. for selecting the brightest patch as the next sender of radiosity. The problem of global solutions is similar to the well-known problem of using constraints in object-oriented systems <ref> [7, 22] </ref>. There, each constraint is a purely local description of some interaction between two objects, but a solution meeting all constraints over all objects can be computed best if global information about all constraints is available.
Reference: [23] <author> Rebecca Wirfs-Brock and Ralf Johnson. </author> <title> Surveying current research in object-oriented design. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 104-123, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: For each of the major subsystems we briefly describe its set of responsibilities. The details of the derivation of this object-oriented decomposition and the interfaces offered by these subsystems can be found in [18]. For the following discussion we use the term "subsystem" <ref> [23] </ref> instead of the more common term "class" in order to better express that many of these subsystems will be implemented by a set of related classes. GeoObject, Surface, and Volume: The Surface and Volume subsystems describe the geometric objects in our scene based on an abstract base class GeoObject.
Reference: [24] <author> Rebecca Wirfs-Brock and Brian Wilkerson. </author> <title> Object-oriented design: A responsibility-driven approach. </title> <booktitle> In OOPSLA 89 Conference Proceedings, </booktitle> <pages> pages 71-75, </pages> <address> New Orleans, </address> <year> 1989. </year>
Reference-contexts: A basic idea behind object-oriented design is the modeling of a software system based on real world objects [3]. For image synthesis these real world objects describe the geometric objects in a scene and their optical attributes, such as emission and reflection of light. A responsibility-driven analysis and design <ref> [24] </ref> of image synthesis based on the physical process of light propagation in a scene suggests a decomposition into the following set of high-level subsystems. For each of the major subsystems we briefly describe its set of responsibilities.
Reference: [25] <author> P. Wisskirchen. </author> <title> GEO++ a system for both modelling and display. </title> <booktitle> In EURO-GRAPHICS '89 Proceedings. </booktitle> <address> Hamburg, </address> <month> September </month> <year> 1989. </year> <title> Fig. 3: Image of a glossy reflection in the metal plate on the table calculated with Monte-Carlo path tracing. </title>
Reference-contexts: 1 Introduction Object-oriented techniques have been successfully used in many disciplines of computer graphics, especially in the design and the implementation of rendering systems <ref> [13, 25, 21, 8, 17] </ref>. However, there have been several areas, in which the application of object-oriented techniques has been unsatisfactory. The problems encountered were mostly related to the problem of expressing relationships between objects. There are several occurrences of this problem in image synthesis. <p> No overhead is introduced for standard attributes. We should also note that this scheme cannot be modeled with other object-oriented attribute schemes as presented in <ref> [25, 2] </ref>. However, this scheme does not solve the problem of changing member variables of multiply instantiated objects.
References-found: 25

