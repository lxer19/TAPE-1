URL: http://www.cs.cornell.edu/jyh/papers/fool3.ps
Refering-URL: http://www.cs.cornell.edu/jyh/cornell-papers.html
Root-URL: 
Title: Formal Objects in Type Theory Using Very Dependent Types  
Author: Jason J. Hickey 
Affiliation: Department of Computer Science, Cornell University  
Abstract: In this paper we present an extension to basic type theory to allow a uniform construction of abstract data types (ADTs) having many of the properties of objects, including abstraction, subtyping, and inheritance. The extension relies on allowing type dependencies for function types to range over a well-founded domain. Using the propositions-as-types correspondence, abstract data types can be identified with logical theories, and proofs of the theories are the objects that inhabit the corresponding ADT.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer, Forthcoming. </publisher>
Reference-contexts: Another line of research has been followed to provide an object-oriented calculus, for instance in Mitchell [22] and Abadi and Cardelli <ref> [1] </ref>. Record calculi with subtyping are key features of these systems. In this paper we present an extension to constructive type theory to allow a uniform construction of abstract data types (ADTs) having many of the properties of objects, including abstraction, subtyping, and inheritance. <p> Before object types can be developed, the concept of "Self" needs to be explored. In much of the current work on objects, for example Mitchell, Honsell, and Fisher [22], Abadi and Cardelli <ref> [1] </ref>, Amadio and Cardelli [3], Harper and Pierce [13], and Bruce [7], the self-application of method selection is handled directly, and the interpretation often use a recursive type to represent the type for "Self." To illustrate this point, we use the standard example of a one-dimensional movable point having two methods: <p> Instead, we adopt the existential interpretation of Pierce and Turner [23] (this is the "state-application semantics" of Abadi and Cardelli <ref> [1] </ref>), in which each object has a state, and updates are allowed only to the state.
Reference: [2] <author> Stuart F. Allen. </author> <title> The Semantics of Type Theoretic Languages. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> August </month> <year> 1986. </year>
Reference-contexts: There are several reasons to develop an account of objects within the type theory. The type theory already has several semantics, including set theoretic [16], PER models <ref> [2, 21] </ref>, denotational models [25], and others. By developing our account within the type theory, we provide a solid mathematical foundation for objects. In addition, we can draw on mathematical techniques, especially those of abstract algebra, to contribute toward the understanding and development of object-oriented languages. <p> The semantic account we provide for the very-dependent function types is based on the predicative PER semantics of Allen <ref> [2] </ref>. In Allen's framework, the semantics for a term T is described by defining when T is a type and specifying what its equivalence relation on members is. Since the type theory is specified as a fixed-point, typehood judgments are only allowed to occur positively in the semantic definition.
Reference: [3] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <booktitle> In 18th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 104-118. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: Before object types can be developed, the concept of "Self" needs to be explored. In much of the current work on objects, for example Mitchell, Honsell, and Fisher [22], Abadi and Cardelli [1], Amadio and Cardelli <ref> [3] </ref>, Harper and Pierce [13], and Bruce [7], the self-application of method selection is handled directly, and the interpretation often use a recursive type to represent the type for "Self." To illustrate this point, we use the standard example of a one-dimensional movable point having two methods: the getX method retrieves
Reference: [4] <author> David Aspinall and Adriana Compagnoni. </author> <title> Subtyping dependent types. </title> <note> Unpublished at this time (available at http://www.dcs.ed.ac.uk/home/da/psub.ps.gz). </note>
Reference-contexts: Jackson [17] has developed these techniques in the Nuprl [12] system to implement a considerable amount of constructive abstract algebra. Subtyping is key to modeling inheritance and reuse, and Aspinali and Compagnoni <ref> [4] </ref>, and Sannella et. al. [26] have analyzed subtyping in the presence of type dependencies in order to model formal programming in-the-large. Jackson [17] has developed subtyping in Nuprl for use in his account of constructive algebra.
Reference: [5] <author> R. Breu. </author> <title> Algebraic Specification Techniques in Object Oriented Programming Environments. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: During the same decade, the body of formal mathematics has been steadily increasing, and proof development systems have also been attacking the problem of scale. Algebraic specification techniques are a basis for many approaches, including Breu <ref> [5] </ref> who uses them to develop an object calculus for software systems. Jackson [17] has developed these techniques in the Nuprl [12] system to implement a considerable amount of constructive abstract algebra.
Reference: [6] <author> Kim Bruce, Luca Cardelli, Giuseppe Castagna, the Hopkins Objects Group (Jonathan Eifrig, Scott Smith, Valery Trifonov), Gary Leavens, and Benjamin Pierce. </author> <title> On binary methods. </title> <journal> Theory and Practice of Object Systems, </journal> <note> 1996. To appear. Also available electronically and as a technical report from ENS, DEC SRC, </note> <institution> Williams, and Iowa State. </institution>
Reference-contexts: Since a method in one object doesn't have any information about the representation type for any other object, it is not possible to write binary methods of this form. A more complete discussion of binary methods is given in Bruce et.al. <ref> [6] </ref>. Proper handling of binary methods requires the use of an explicit representation type, as we describe in the following section for a description of monoids.
Reference: [7] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design, static typing, and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 127-206, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Before object types can be developed, the concept of "Self" needs to be explored. In much of the current work on objects, for example Mitchell, Honsell, and Fisher [22], Abadi and Cardelli [1], Amadio and Cardelli [3], Harper and Pierce [13], and Bruce <ref> [7] </ref>, the self-application of method selection is handled directly, and the interpretation often use a recursive type to represent the type for "Self." To illustrate this point, we use the standard example of a one-dimensional movable point having two methods: the getX method retrieves the position of the point (an integer),
Reference: [8] <author> Kim B. Bruce and Leaf Peterson. </author> <title> Subtyping is not a good "Match" for object-oriented languages. </title> <type> Technical report, </type> <institution> Williams College, </institution> <year> 1996. </year> <note> (extended abstract). </note>
Reference-contexts: Our version is stronger because we also require that the representation types of subobjects be subtypes. A more complete treatment of objects would require a more extensional definition of equality over the behavior of objects, excluding their states and representation types. A similar subtyping restriction is given by Bruce <ref> [8] </ref>, who addresses this problem in PolyTOIL by defining "matching," where an object "matches" another if any method that can be invoked on the first object can also be invoked on the second.
Reference: [9] <author> Thierry Coquand, Bengt Nordstrom, Jan M. Smith, and Bjorn von Sydow. </author> <title> Type Theory and Programming. </title> <note> EATCS, February 1994. bulletin no 52. </note>
Reference-contexts: Although we use the Nuprl type theory (based on Martin-Lof's [19, 20] type theory) and the Nuprl terminology in this paper, our results should carry over to other proof systems that use dependent types, including Coq [11], lego [18], Alf <ref> [9] </ref>, and pvs [10].
Reference: [10] <author> Judy Crow, Sam Owre, John Rushby, Natarajan Shankar, and Mandayam Srivas. </author> <title> A Tutorial Introduction to PVS. </title> <booktitle> In WIFT '95: Workshop on Industrial-Strength Formal Specification Techniques, </booktitle> <month> April </month> <year> 1995. </year> <note> http://www.csl.sri.com/sri-csl-fm.html. 13 </note>
Reference-contexts: Although we use the Nuprl type theory (based on Martin-Lof's [19, 20] type theory) and the Nuprl terminology in this paper, our results should carry over to other proof systems that use dependent types, including Coq [11], lego [18], Alf [9], and pvs <ref> [10] </ref>.
Reference: [11] <author> Gilles Dowek, Amy Felty, Hugo Herbelin, Gerard Huet, Chet Murthy, Catherine Par-ent, Christine Paulin-Mohring, and Benjamin Werner. </author> <title> The coq proof assistant user's guide. </title> <type> Technical Report Rapport Techniques 154, </type> <institution> INRIA, Rocquencourt, France, </institution> <year> 1993. </year> <note> Version 5.8. </note>
Reference-contexts: Although we use the Nuprl type theory (based on Martin-Lof's [19, 20] type theory) and the Nuprl terminology in this paper, our results should carry over to other proof systems that use dependent types, including Coq <ref> [11] </ref>, lego [18], Alf [9], and pvs [10].
Reference: [12] <author> R.L. Constable et.al. </author> <title> Implementing Mathematics in the NuPRL Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Algebraic specification techniques are a basis for many approaches, including Breu [5] who uses them to develop an object calculus for software systems. Jackson [17] has developed these techniques in the Nuprl <ref> [12] </ref> system to implement a considerable amount of constructive abstract algebra. Subtyping is key to modeling inheritance and reuse, and Aspinali and Compagnoni [4], and Sannella et. al. [26] have analyzed subtyping in the presence of type dependencies in order to model formal programming in-the-large.
Reference: [13] <author> Robert Harper and Benjamin Pierce. </author> <title> A record calculus based on symmetric concate-nation. </title> <booktitle> In 18th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 131-142. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: Before object types can be developed, the concept of "Self" needs to be explored. In much of the current work on objects, for example Mitchell, Honsell, and Fisher [22], Abadi and Cardelli [1], Amadio and Cardelli [3], Harper and Pierce <ref> [13] </ref>, and Bruce [7], the self-application of method selection is handled directly, and the interpretation often use a recursive type to represent the type for "Self." To illustrate this point, we use the standard example of a one-dimensional movable point having two methods: the getX method retrieves the position of the
Reference: [14] <author> Jason J. Hickey. </author> <title> A semantics of objects in type theory. </title> <note> Online formalization available through Cornell CS. </note>
Reference-contexts: Using recursive types, the type for the point might be described as follows: Point = (X:[getX : Z; setX : Z! X]) Although an account of these calculi in the type theory is reasonable (without the use of recursive types <ref> [14] </ref>), the interaction of self-application and method override with the predicativity of the type theory can be complex enough to obscure the interpretation.
Reference: [15] <author> Martin Hofmann and Benjamin Pierce. </author> <title> Positive subtyping. </title> <booktitle> In Proceedings of TwentySecond Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 186197. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1995. </year> <note> Full version available as University of Edinburgh technical report ECS-LFCS-94-303, September 1994. To appear in Information and Computation, </note> <year> 1996. </year>
Reference-contexts: This requirement is a stronger version of the "positive subtyping" of Hofmann and Pierce <ref> [15] </ref>. In their formulation, the rules for subtyping are constrained so that all subtypes must obey this "update" restriction. In our case, subtyping retains its original mathematical meaning, but if A B, then A B.
Reference: [16] <author> Douglas J. Howe. </author> <title> Semantic foundations for embedding HOL in Nuprl. </title> <booktitle> In AMAST '96, </booktitle> <year> 1996. </year>
Reference-contexts: There are several reasons to develop an account of objects within the type theory. The type theory already has several semantics, including set theoretic <ref> [16] </ref>, PER models [2, 21], denotational models [25], and others. By developing our account within the type theory, we provide a solid mathematical foundation for objects. In addition, we can draw on mathematical techniques, especially those of abstract algebra, to contribute toward the understanding and development of object-oriented languages.
Reference: [17] <author> Paul Bernard Jackson. </author> <title> Enhancing the NuPRL Proof Development System and Applying it to Computational Abstract Algebra. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: During the same decade, the body of formal mathematics has been steadily increasing, and proof development systems have also been attacking the problem of scale. Algebraic specification techniques are a basis for many approaches, including Breu [5] who uses them to develop an object calculus for software systems. Jackson <ref> [17] </ref> has developed these techniques in the Nuprl [12] system to implement a considerable amount of constructive abstract algebra. <p> Subtyping is key to modeling inheritance and reuse, and Aspinali and Compagnoni [4], and Sannella et. al. [26] have analyzed subtyping in the presence of type dependencies in order to model formal programming in-the-large. Jackson <ref> [17] </ref> has developed subtyping in Nuprl for use in his account of constructive algebra.
Reference: [18] <author> Zhaohui Luo and Randy Pollack. </author> <title> LEGO Proof Development System: User's Manual. </title> <type> Technical Report ECS-LFCS-92-202, </type> <institution> University of Edinburgh, </institution> <year> 1992. </year>
Reference-contexts: Reus and Streicher [24] have translated the laws of module algebra into laws of "deliverables" that can be proved correct in type theory, which they have performed using the Extended Calculus of Constructions on the lego <ref> [18] </ref> system. Another line of research has been followed to provide an object-oriented calculus, for instance in Mitchell [22] and Abadi and Cardelli [1]. Record calculi with subtyping are key features of these systems. <p> Although we use the Nuprl type theory (based on Martin-Lof's [19, 20] type theory) and the Nuprl terminology in this paper, our results should carry over to other proof systems that use dependent types, including Coq [11], lego <ref> [18] </ref>, Alf [9], and pvs [10].
Reference: [19] <author> Per Martin-Lof. </author> <title> An intuitionistic theory of types: Predicative part. </title> <booktitle> In Logic Colloquium '73, </booktitle> <pages> pages 73-118. </pages> <publisher> North-Holland, </publisher> <year> 1975. </year>
Reference-contexts: We have implemented an object calculus using the very-dependent function types in the Nuprl system. Although we use the Nuprl type theory (based on Martin-Lof's <ref> [19, 20] </ref> type theory) and the Nuprl terminology in this paper, our results should carry over to other proof systems that use dependent types, including Coq [11], lego [18], Alf [9], and pvs [10].
Reference: [20] <author> Per Martin-Lof. </author> <title> Intutionistic Type Theory. </title> <type> Bibliopolis, </type> <institution> Napoli, </institution> <year> 1984. </year>
Reference-contexts: We have implemented an object calculus using the very-dependent function types in the Nuprl system. Although we use the Nuprl type theory (based on Martin-Lof's <ref> [19, 20] </ref> type theory) and the Nuprl terminology in this paper, our results should carry over to other proof systems that use dependent types, including Coq [11], lego [18], Alf [9], and pvs [10].
Reference: [21] <author> Paul Francis Mendler. </author> <title> Inductive Definition in Type Theory. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> September </month> <year> 1987. </year> <pages> 87-870. </pages>
Reference-contexts: There are several reasons to develop an account of objects within the type theory. The type theory already has several semantics, including set theoretic [16], PER models <ref> [2, 21] </ref>, denotational models [25], and others. By developing our account within the type theory, we provide a solid mathematical foundation for objects. In addition, we can draw on mathematical techniques, especially those of abstract algebra, to contribute toward the understanding and development of object-oriented languages.
Reference: [22] <author> John C. Mitchell, Furio Honsell, and Kathleen Fisher. </author> <title> A lambda calculus of objects and method specialization. </title> <booktitle> In IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: Another line of research has been followed to provide an object-oriented calculus, for instance in Mitchell <ref> [22] </ref> and Abadi and Cardelli [1]. Record calculi with subtyping are key features of these systems. In this paper we present an extension to constructive type theory to allow a uniform construction of abstract data types (ADTs) having many of the properties of objects, including abstraction, subtyping, and inheritance. <p> Before object types can be developed, the concept of "Self" needs to be explored. In much of the current work on objects, for example Mitchell, Honsell, and Fisher <ref> [22] </ref>, Abadi and Cardelli [1], Amadio and Cardelli [3], Harper and Pierce [13], and Bruce [7], the self-application of method selection is handled directly, and the interpretation often use a recursive type to represent the type for "Self." To illustrate this point, we use the standard example of a one-dimensional movable
Reference: [23] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for objectoriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Instead, we adopt the existential interpretation of Pierce and Turner <ref> [23] </ref> (this is the "state-application semantics" of Abadi and Cardelli [1]), in which each object has a state, and updates are allowed only to the state. <p> A more general rule for update could be derived for multiple simultaneous updates if desired. 4 Object Interpretation The record calculus presented in the previous section provides the basis for an existential interpretation of objects. Following the account of Pierce and Turner <ref> [23] </ref>, we require that objects have method descriptions parameterized by the type of the internal state representation.
Reference: [24] <author> Bernhard Reus and Thomas Streicher. </author> <title> Verifying Properties of Modules Construction in Type Theroy. </title> <booktitle> In 18th International Symposium on Mathematical Foundations of Computer Science, </booktitle> <pages> pages 660-670. </pages> <publisher> Springer, </publisher> <month> Aug/Sept </month> <year> 1993. </year>
Reference-contexts: Jackson [17] has developed subtyping in Nuprl for use in his account of constructive algebra. Reus and Streicher <ref> [24] </ref> have translated the laws of module algebra into laws of "deliverables" that can be proved correct in type theory, which they have performed using the Extended Calculus of Constructions on the lego [18] system.
Reference: [25] <author> Adrian Rezus. </author> <title> Semantics of constructive type theory. </title> <type> Technical Report 70, </type> <institution> Nijmegen University, </institution> <address> The Netherlands, </address> <month> September </month> <year> 1985. </year>
Reference-contexts: There are several reasons to develop an account of objects within the type theory. The type theory already has several semantics, including set theoretic [16], PER models [2, 21], denotational models <ref> [25] </ref>, and others. By developing our account within the type theory, we provide a solid mathematical foundation for objects. In addition, we can draw on mathematical techniques, especially those of abstract algebra, to contribute toward the understanding and development of object-oriented languages.
Reference: [26] <author> Donald T. Sannella, Stefan Sokolowski, and Andrzej Tarlecki. </author> <title> Toward formal devel-opment of programs from algebraic specifications: Parameterisation revisited. </title> <journal> Acta Informatica, </journal> <volume> 29 </volume> <pages> 689-736, </pages> <year> 1992. </year> <month> 14 </month>
Reference-contexts: Jackson [17] has developed these techniques in the Nuprl [12] system to implement a considerable amount of constructive abstract algebra. Subtyping is key to modeling inheritance and reuse, and Aspinali and Compagnoni [4], and Sannella et. al. <ref> [26] </ref> have analyzed subtyping in the presence of type dependencies in order to model formal programming in-the-large. Jackson [17] has developed subtyping in Nuprl for use in his account of constructive algebra.
References-found: 26

