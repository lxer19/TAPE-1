URL: http://www.cs.ucsd.edu/users/atkinson/FElt/felt.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/atkinson/FElt/other_docs.html
Root-URL: http://www.cs.ucsd.edu
Title: User's Guide and Reference Manual The FElt System:  
Author: Jason I. Gobat Darren C. Atkinson 
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> David S. Burnett. </author> <title> Finite Element Analysis: From Concepts to Applications. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: There is of course some very basic information on just how these models work in the context of FEA, but we really do suggest that you try some of the excellent textbooks ( <ref> [9, 16, 13, 1, 14] </ref>) that are out there if you want any sort of real background information. 2.2 Static structural analysis The basic equation for static structural analysis can be seen as a generalization of Hooke's law for the deformation of a linear spring, f = kx. <p> Gobat and Darren C. Atkinson. 9.2. USING BURLAP 113 This is free software, and you are welcome to redistribute it under certain conditions, but there is absolutely no warranty. Type help ("copyright") for details. Use the -q option to suppress this message. <ref> [1] </ref> _ If burlap was compiled with the GNU readline library, then you have complete command-line editing and history, as in bash. (A complete discussion of the editing capabilities can be found in the documentation of the readline library.) At the prompt, you can enter expressions to be evaluated. [1] 1 <p> message. <ref> [1] </ref> _ If burlap was compiled with the GNU readline library, then you have complete command-line editing and history, as in bash. (A complete discussion of the editing capabilities can be found in the documentation of the readline library.) At the prompt, you can enter expressions to be evaluated. [1] 1 + 2 [2] write (1 + 2) 3 [4] write (a) 3 [5] write ([1, 2, 3]) 1 2 3 [6] write ([1; 2; 3]) 1 3 [7] write ([1, 2, 3] + [4, 5, 6]) 5 7 9 As illustrated above, write () is used to print results <p> In short, burlap works just like most other interactive programs including csh, gdb, gnuplot, matlab, octave, and gs. 9.3 burlap and FElt You can load a FElt file into burlap by either specifying the file on the command line with the -felt flag or by using the felt () function. <ref> [1] </ref> felt ("truss.flt") If everything goes okay, then the function should simply return silently. Several variables are now automatically defined, as shown in Table 9.1. <p> A component of a force may be assigned a string value which will be interpreted by burlap as an expression. Note that evaluating the component will evaluate the expression at time t=0. There is currently no way to determine if a component is assigned a time-varying expression. <ref> [1] </ref> f.Fx = "cos (t)" [2] write (f.Fx) 1 9.3.5 Constraint objects Constraint objects also allow the various information to be accessed as vectors or as individual components, as shown in Table 9.6. <p> Therefore, the first, second, and third dofs are active. The entire call to add definition () is: add definition ("truss", truss set up, truss stress, &linear, 2, 2, 1, <ref> [1, 2, 3, 0, 0, 0] </ref>) We have neglected to pass a value for the last argument, which indicates whether the local stiffness matrix should be retained after assembly into the global stiffness matrix. The default value for this argument is &false, which is fine for our purposes. <p> Functions are best created with an editor as a file which is then included. <ref> [1] </ref> system ("vi foo.b") [2] include ("foo.b") [3] system ("vi foo.b") [4] include ("foo.b") It soon becomes tedious to retype the same expressions. If burlap is compiled with the readline library, then you can use the built-in history mechanism. [1] system ("vi foo.b") [2] include ("foo.b") [3] !s For those not <p> created with an editor as a file which is then included. <ref> [1] </ref> system ("vi foo.b") [2] include ("foo.b") [3] system ("vi foo.b") [4] include ("foo.b") It soon becomes tedious to retype the same expressions. If burlap is compiled with the readline library, then you can use the built-in history mechanism. [1] system ("vi foo.b") [2] include ("foo.b") [3] !s For those not familiar with csh or bash, !s executes the last line that begins with s. Similarly, !i executes the last line that begins with i. <p> You can save yourself more typing by using the word completion abilities of the readline library. Pressing the tab key will complete the current word. If there is not a unique completion, then you will hear a bell and pressing the tab key again will list the completions. <ref> [1] </ref> sy &lt;Tab&gt; symmetric? system [1] system ("vi foo.b") [2] in &lt;Tab&gt; in integrate_hyperbolic inv include integrate_parabolic [2] include ("foo.b") The default set of built-in completions includes all keywords such as function and return, intrinsic functions such as include and sin, and enumeration constants such as &linear and &null. <p> Pressing the tab key will complete the current word. If there is not a unique completion, then you will hear a bell and pressing the tab key again will list the completions. <ref> [1] </ref> sy &lt;Tab&gt; symmetric? system [1] system ("vi foo.b") [2] in &lt;Tab&gt; in integrate_hyperbolic inv include integrate_parabolic [2] include ("foo.b") The default set of built-in completions includes all keywords such as function and return, intrinsic functions such as include and sin, and enumeration constants such as &linear and &null. <p> Inside a quoted string, the default set of completions is not used; instead, file names are completed. 9.5. TIPS ON USING INTERACTIVE MODE 127 <ref> [1] </ref> include ("Examples/f &lt;Tab&gt; fe.b find-dofs.b foo.flt foo_d.flt [1] include ("Examples/f Using the completion mechanism can save a lot of typing, especially when referring to file names. Another trick is to define your own aliases for common lines. [1] alias v system ("vi foo.b") [2] alias vi system ("vi !$") [3] <p> Inside a quoted string, the default set of completions is not used; instead, file names are completed. 9.5. TIPS ON USING INTERACTIVE MODE 127 <ref> [1] </ref> include ("Examples/f &lt;Tab&gt; fe.b find-dofs.b foo.flt foo_d.flt [1] include ("Examples/f Using the completion mechanism can save a lot of typing, especially when referring to file names. Another trick is to define your own aliases for common lines. [1] alias v system ("vi foo.b") [2] alias vi system ("vi !$") [3] alias print write (!*) [4] vi foo.b The <p> TIPS ON USING INTERACTIVE MODE 127 <ref> [1] </ref> include ("Examples/f &lt;Tab&gt; fe.b find-dofs.b foo.flt foo_d.flt [1] include ("Examples/f Using the completion mechanism can save a lot of typing, especially when referring to file names. Another trick is to define your own aliases for common lines. [1] alias v system ("vi foo.b") [2] alias vi system ("vi !$") [3] alias print write (!*) [4] vi foo.b The first alias defines v to be system ("vi foo.b"). The second is more general and defines vi to be system ("vi !$"). <p> Special enumeration constants begin with an ampersand, as in &local x. Variable names are a sequence of letters, digits, and the underscore character. Finally, comments are enclosed within /* */; a pound sign (#) may also be used to indicate a comment until the end of the current line. <ref> [1] </ref> a = 3.14159 [2] b = "hello" [3] c = [1, 2, 3; 4, 5, 6] [4] write (a) 3.14159 [5] write (b) hello [6] write (c) 1 2 3 The following sections discuss the operators and functions of burlap in detail. <p> Variable names are a sequence of letters, digits, and the underscore character. Finally, comments are enclosed within /* */; a pound sign (#) may also be used to indicate a comment until the end of the current line. [1] a = 3.14159 [2] b = "hello" [3] c = <ref> [1, 2, 3; 4, 5, 6] </ref> [4] write (a) 3.14159 [5] write (b) hello [6] write (c) 1 2 3 The following sections discuss the operators and functions of burlap in detail. <p> An important thing to realize when writing matrices is that burlap may automatically insert a semicolon at the end of line. In particular, a semicolon is inserted at the end of a line in interactive mode when the last literal or operator on the line can end an expression. <ref> [1] </ref> a = [1, 2, 3 [3] write (a) 1 2 3 [4] a = [1, 2, 3 + [5] write (a) 1 2 7 5 6 Note that since an expression cannot end with +, the next line is taken to be a continuation of the previous line. <p> In particular, a semicolon is inserted at the end of a line in interactive mode when the last literal or operator on the line can end an expression. [1] a = <ref> [1, 2, 3 [3] </ref> write (a) 1 2 3 [4] a = [1, 2, 3 + [5] write (a) 1 2 7 5 6 Note that since an expression cannot end with +, the next line is taken to be a continuation of the previous line. <p> In particular, a semicolon is inserted at the end of a line in interactive mode when the last literal or operator on the line can end an expression. [1] a = [1, 2, 3 [3] write (a) 1 2 3 [4] a = <ref> [1, 2, 3 + [5] </ref> write (a) 1 2 7 5 6 Note that since an expression cannot end with +, the next line is taken to be a continuation of the previous line. <p> A matrix element may be an arbitrary expression; however, all expressions on the same row must have the same height. Additionally, all rows must have the same number of columns. 132 CHAPTER 10. THE BURLAP SYNTAX <ref> [1] </ref> x = 1 [3] write (a) 0 1 2 [5] write (b) 0 1 2 [6] write ([b, b]) 0 1 2 0 1 2 [7] write ([b, a]) stdin:7: inconsistent number of rows 10.2 Variables Variables are named by a sequence of letters, digits, the underscore character, and the <p> When reading from a file, if the last token on the line may end an expression and the first token on the next line may begin an expression then a semicolon will be inserted. A line can be explicitly continued by ending the line with a backslash character. <ref> [1] </ref> write ("hello"); write ("there") hello there [2] a = 1 + [3] write (a) 6 4&gt; + 2 [5] write (b) 3 [7] 4, 5, 6] [8] write (x) 1 2 3 Although these semantics may sound complicated, they are designed so that 99.9% of the time you don't need <p> For example, a matrix cannot be assigned to the component of a force. Some fields are also read-only, such as the name of a constraint or the number of a node or element. <ref> [1] </ref> a = [1, 2, 3] [2] write (a) 1 2 3 [4] write (a, " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = <p> For example, a matrix cannot be assigned to the component of a force. Some fields are also read-only, such as the name of a constraint or the number of a node or element. [1] a = <ref> [1, 2, 3] </ref> [2] write (a) 1 2 3 [4] write (a, " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] <p> a = <ref> [1, 2, 3] </ref> [2] write (a) 1 2 3 [4] write (a, " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = [1, 2, 3; 4, 5, 6] [11] write (a) 1 2 3 [12] a (1, 2) = 0 [13] write (a) 1 0 3 10.4.3 Logical or operator x or y; x || y The logical or <p> " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = <ref> [1, 2, 3; 4, 5, 6] </ref> [11] write (a) 1 2 3 [12] a (1, 2) = 0 [13] write (a) 1 0 3 10.4.3 Logical or operator x or y; x || y The logical or operator has two equivalent forms and groups from left-to-right. <p> Two such ways are provided by the any?() and every?() functions discussed in Section 10.5.3. X Y Z Z = X or Y scalar scalar scalar z = x or y Table 10.2: Type table for the logical or operator. <ref> [1] </ref> write (1 &lt; 2 or 5 &gt; 6) 1 [2] write (1 &gt; 2 or 5 &gt; 6) 0 [3] write (1 or 1 / 0) 1 [4] write (0 or 1 / 0) stdin:4: exception in expression: right division by zero [5] a = [1, 2, 3] [6] write <p> the logical or operator. [1] write (1 &lt; 2 or 5 &gt; 6) 1 [2] write (1 &gt; 2 or 5 &gt; 6) 0 [3] write (1 or 1 / 0) 1 [4] write (0 or 1 / 0) stdin:4: exception in expression: right division by zero [5] a = <ref> [1, 2, 3] </ref> [6] write (a or 1) stdin:6: type error in expression: matrix in conditional context [7] write (any? (a) or 1) 1 10.4.4 Logical and operator x and y; x && y The logical and operator has two equivalent forms and groups from left-to-right. <p> Two such ways are provided by the any?() and every?() functions discussed in Section 10.5.3. X Y Z Z = X and Y scalar scalar scalar z = x and y Table 10.3: Type table for the logical and operator. <ref> [1] </ref> write (1 &lt; 2 and 3 &lt; 4) 1 [2] write (1 &lt; 2 and 3 &gt; 4) 0 [3] write (0 and 1 / 0) 0 [4] write (1 and 1 / 0) stdin:4: exception in expression: right division by zero 10.4.5 Equality operators X == Y The equality <p> Essentially, burlap does element-by-element comparison for matrices and scalars, string (i.e., lexicographic) comparison for strings, and identity (i.e., pointer) comparison on all other type objects. When comparing two matrices, their dimensions must be identical. <ref> [1] </ref> write ([1, 2, 3] == 2) 0 1 0 [2] write (2 != [1, 2, 3]) 1 0 1 [3] write ([1, 2, 3] == [3, 2, 3]) 0 1 1 [4] write ("hello" == "hello") 1 [5] write ("hello" == "there") 0 [6] write (nodes (1) == nodes (1)) <p> Essentially, burlap does element-by-element comparison for matrices and scalars, string (i.e., lexicographic) comparison for strings, and identity (i.e., pointer) comparison on all other type objects. When comparing two matrices, their dimensions must be identical. [1] write (<ref> [1, 2, 3] </ref> == 2) 0 1 0 [2] write (2 != [1, 2, 3]) 1 0 1 [3] write ([1, 2, 3] == [3, 2, 3]) 0 1 1 [4] write ("hello" == "hello") 1 [5] write ("hello" == "there") 0 [6] write (nodes (1) == nodes (1)) 1 [7] write (nodes (1) == elements (1)) stdin:7: type error in expression: node <p> The result of the expression is 1 if the expression is true, and 0 if the expression is false. If two matrices are compared, then their dimensions must be identical. <ref> [1] </ref> write ([1, 2, 3] &lt; 3) 1 1 0 [2] write ([1, 2, 3] &gt;= [3, 2, 1]) 0 1 1 [3] write ("aardvark" &lt; "aardwolf") 1 10.4.7 Range operator x : z 140 CHAPTER 10. <p> The result of the expression is 1 if the expression is true, and 0 if the expression is false. If two matrices are compared, then their dimensions must be identical. [1] write ([1, 2, 3] &lt; 3) 1 1 0 [2] write ([1, 2, 3] &gt;= <ref> [3, 2, 1] </ref>) 0 1 1 [3] write ("aardvark" &lt; "aardwolf") 1 10.4.7 Range operator x : z 140 CHAPTER 10. <p> Each of x, y, and z must be scalar expressions, as shown in Table 10.6. X Y Z W W = X : Y : Z scalar scalar scalar matrix (as defined above) Table 10.6: Type table for the range operator. <ref> [1] </ref> write (1:3) 1 2 3 [2] write (3:1) null [3] write (1:2:10) 1 3 5 7 9 [4] write (10:-2:1) 10 8 6 4 2 As illustrated above, if the range is improperly specified then a null value is returned. <p> Like the equality and relational operators, the additive operators associate from left-to-right. Also, two matrices must have identical dimensions for addition or sub traction. <ref> [1] </ref> write (1 + 2) 3 [2] write (1 + [2, 3, 4]) 3 4 5 [3] write ([3, 4, 5] - 1) 2 3 4 [4] write ([1, 2] + [3, 4]) 4 6 [5] write ([1, 2, 3] + [4, 5]) stdin:5: size mismatch in expression: (1 x 3) <p> As illustrated in Table 10.8, multiplying two scalars results in scalar multiplication, multiplying a matrix by a scalar is equivalent to scaling the matrix by the scalar, and multiplying two matrices results in standard matrix multiplication. In matrix multiplication the inner dimensions must agree. <ref> [1] </ref> write (2 * 3) 6 [2] write (2 * [1, 2, 3]) 2 4 6 [3] write ([1, 2, 3] * [1; 2; 3]) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * [3, 4]) stdin:5: size mismatch <p> In matrix multiplication the inner dimensions must agree. [1] write (2 * 3) 6 [2] write (2 * <ref> [1, 2, 3] </ref>) 2 4 6 [3] write ([1, 2, 3] * [1; 2; 3]) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * [3, 4]) stdin:5: size mismatch in expression: (1 x 2) * (1 x 2) burlap <p> In matrix multiplication the inner dimensions must agree. [1] write (2 * 3) 6 [2] write (2 * [1, 2, 3]) 2 4 6 [3] write ([1, 2, 3] * <ref> [1; 2; 3] </ref>) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * [3, 4]) stdin:5: size mismatch in expression: (1 x 2) * (1 x 2) burlap supports two forms of division: left division and right division. <p> In matrix multiplication the inner dimensions must agree. [1] write (2 * 3) 6 [2] write (2 * <ref> [1, 2, 3] </ref>) 2 4 6 [3] write ([1, 2, 3] * [1; 2; 3]) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * [3, 4]) stdin:5: size mismatch in expression: (1 x 2) * (1 x 2) burlap supports two forms of division: left division and right division. <p> In all cases, the number of rows of X must equal the number of columns of Y . Z = X=Y Z = XY 1 (Y T Z T ) T = (X T ) T <ref> [1] </ref> write (1 / 2) 0.5 [2] write (1 / 0) stdin:2: exception in expression: right division by zero [3] write ([1, 2, 3] / 10) 0.1 0.2 0.3 The left division of X and Y is (approximately) equivalent to the inverse of X multiplied by Y . <p> The number of columns of X must equal the number of rows of Y . <ref> [1] </ref> write (2 " 1) 0.5 [2] write (0 " 1) stdin:2: exception in expression: left division by zero [3] write (10 " [1, 2, 3]) 0.1 0.2 0.3 [4] write ([1, 2; 3, 4] " [5, 6]) stdin:4: size mismatch in expression: (2 x 2) " (1 x 2) [5] <p> The number of columns of X must equal the number of rows of Y . [1] write (2 " 1) 0.5 [2] write (0 " 1) stdin:2: exception in expression: left division by zero [3] write (10 " <ref> [1, 2, 3] </ref>) 0.1 0.2 0.3 [4] write ([1, 2; 3, 4] " [5, 6]) stdin:4: size mismatch in expression: (2 x 2) " (1 x 2) [5] write ([1, 2; 3, 4] " [5; 6]) -4 Finally, burlap also supports a remainder operation as shown in Table 10.11. <p> Additionally, x must be non-negative or y must be an integer; otherwise a math ematical exception will result. <ref> [1] </ref> write (2 ** 3) 8 [2] write (2 ** .5) 1.41421 [3] write (-2 ** .5) stdin:3: exception in expression: illegal base and exponent 10.4.11 Transposition operator X' The transposition operator returns the transpose of its operand and associates from left-to-right. <p> However, if X is a vector then X (i) is its ith element. Since a scalar is a matrix with one row and one column, it may also be indexed. <ref> [1] </ref> A = [1, 2, 3; 4, 5, 6] [3] y = [1, 2, 3] [4] write (A) 1 2 3 10.4. <p> However, if X is a vector then X (i) is its ith element. Since a scalar is a matrix with one row and one column, it may also be indexed. [1] A = <ref> [1, 2, 3; 4, 5, 6] </ref> [3] y = [1, 2, 3] [4] write (A) 1 2 3 10.4. <p> However, if X is a vector then X (i) is its ith element. Since a scalar is a matrix with one row and one column, it may also be indexed. [1] A = [1, 2, 3; 4, 5, 6] [3] y = <ref> [1, 2, 3] </ref> [4] write (A) 1 2 3 10.4. <p> element of X non-zero? compact? (X) Is X a compact-column matrix? every? (X) Is every element of X non-zero? null? (X) Is X null? matrix? (X) Is X a matrix? scalar? (X) Is X a scalar? symmetric? (X) Is X a symmetric matrix? Table 10.17: Predicate functions available in burlap. <ref> [1] </ref> x = [1, 2, 3] [3] write (scalar? (x), " ", scalar? (y)) 0 1 [4] write (matrix? (x), " ", matrix? (y)) 1 0 [6] write (symmetric? (z), " ", compact? (z)) 1 0 [7] write (compact? (compact (z))) 1 10.5.4 Finite element functions The finite element functions provide <p> non-zero? compact? (X) Is X a compact-column matrix? every? (X) Is every element of X non-zero? null? (X) Is X null? matrix? (X) Is X a matrix? scalar? (X) Is X a scalar? symmetric? (X) Is X a symmetric matrix? Table 10.17: Predicate functions available in burlap. [1] x = <ref> [1, 2, 3] </ref> [3] write (scalar? (x), " ", scalar? (y)) 0 1 [4] write (matrix? (x), " ", matrix? (y)) 1 0 [6] write (symmetric? (z), " ", compact? (z)) 1 0 [7] write (compact? (compact (z))) 1 10.5.4 Finite element functions The finite element functions provide an interface to <p> An assignment to one is implicitly an assignment to both. burlap uses this ability in several intrinsic functions (e.g., lu (), eig ()) to "return" more than one value from a function. function swap (x, y) t = x; x = y; y = t <ref> [1] </ref> a = 1; b = 2 [2] swap (a, b) [3] write (a, " ", b) 1 2 The values are not swapped as desired since they are passed by value. <p> For the swap () function to work correctly the data of the formal and actual parameters must be shared. function swap (shared x, shared y) t = x; x = y; y = t <ref> [1] </ref> a = 1; b = 2 [2] swap (a, b) [3] write (a, " ", b) 2 1 This type of parameter passing is also known as call-by-reference or var-parameters. Fortran passes all parameters by reference; C passes all parameters by 10.7. <p> Similarly, if the final else is missing and none of the if expressions evaluated to non-zero, the result of the entire if expression will be null. function max (x, y) 162 CHAPTER 10. THE BURLAP SYNTAX if x &gt; y then x else y end end <ref> [1] </ref> write (max (1, 2)) 2 In this example, the if expression returns x if x &gt; y and returns y if x y. <p> The break expression of Section 10.7.4 may be used to alter the result of the while. The while expression must evaluate to a scalar. function sum_of_first (n) i = 0 while i &lt;= n do s = s + i end return s end 10.7. CONTROL-FLOW CONSTRUCTS 163 <ref> [1] </ref> write (sum_of_first (3)) 6 [2] write (sum_of_first (10)) 55 [3] write (while 0 do end) null This example uses a while expression to compute the sum of the first n integers. The last write () function illustrates the result of the while loop. <p> If it is scalar then the scalar is assigned, and the expression-list is evaluated only once. If the in expression is null, then the expression-list is not executed. function sum_of_first (n) s = 0 s = s + i return s end <ref> [1] </ref> write (sum_of_first (3)) 6 164 CHAPTER 10. <p> If x is simply 3 then v is simply 3 and i is also 3. If x is the vector <ref> [1, 2, 3] </ref> then v is successively assigned 1, 2, and 3 and i is simply assigned each value of v. <p> If x is simply 3 then v is simply 3 and i is also 3. If x is the vector [1, 2, 3] then v is successively assigned 1, 2, and 3 and i is simply assigned each value of v. If x is the matrix <ref> [1, 2, 3; 4, 5, 6] </ref> then v is successively assigned the column vectors [1; 4], [2; 5], and [3; 6] and i is assigned the values 1, 4, 2, 5, 3, and 6 in that order. 10.7.4 break, next, and return expressions return [ expression ] break [ expression ] <p> If x is the vector [1, 2, 3] then v is successively assigned 1, 2, and 3 and i is simply assigned each value of v. If x is the matrix [1, 2, 3; 4, 5, 6] then v is successively assigned the column vectors <ref> [1; 4] </ref>, [2; 5], and [3; 6] and i is assigned the values 1, 4, 2, 5, 3, and 6 in that order. 10.7.4 break, next, and return expressions return [ expression ] break [ expression ] next The return expression may be used to return a value from a function. <p> It is probably our ignorance, but we are not aware of any definitive texts on the algorithmic implementation of the finite element method. Texts that have been recommended, but that we have not really worked with include Segerlind [14], a very well-recommended introductory text by Burnett <ref> [1] </ref> and a book by Hinton and Owen [8]. 11.2 Elementary C programming The advantages to coding FElt entirely in C rather than the more traditional (at least for finite element analysis) choice of Fortran are: 1. keeping the package consistent the system and graphical interface stuff required working in C, <p> code references a structure it is actually referencing the address of that structure in memory ... this is something you shouldn't need to worry about to simply read and understand the mathematics), the usual way that you will see code that refers to elements is like this: element -&gt; node <ref> [1] </ref> -&gt; x, or element -&gt; material -&gt; E. The first of these examples gets the value of the x-coordinate of the element's first node (not necessarily globally numbered node 1). The second gets the value of the Young's modulus of the material assigned to this element. <p> The second gets the value of the Young's modulus of the material assigned to this element. If the array of elements is under consideration, you might seem something 168 CHAPTER 11. THE ALGORITHMS BEHIND FELT like this: element [3] -&gt; stress <ref> [1] </ref> -&gt; values [1] . This will be the value of the first stress component at the first integration point on element 3. <p> The second gets the value of the Young's modulus of the material assigned to this element. If the array of elements is under consideration, you might seem something 168 CHAPTER 11. THE ALGORITHMS BEHIND FELT like this: element [3] -&gt; stress <ref> [1] </ref> -&gt; values [1] . This will be the value of the first stress component at the first integration point on element 3. <p> A DETAILED EXAMPLE 193 element -&gt; ninteg = 2; /* * Fill out a vector with the element's nodal displacements. * These are in global coordinates of course. We need to * do a transformation to get them into local coordinates. */ VectorData (d) <ref> [1] </ref> = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [2] = element -&gt; node [1] -&gt; dx [Ty]; VectorData (d) [3] = element -&gt; node [1] -&gt; dx [Rz]; VectorData (d) [4] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [5] = element -&gt; node [2] -&gt; <p> A DETAILED EXAMPLE 193 element -&gt; ninteg = 2; /* * Fill out a vector with the element's nodal displacements. * These are in global coordinates of course. We need to * do a transformation to get them into local coordinates. */ VectorData (d) <ref> [1] </ref> = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [2] = element -&gt; node [1] -&gt; dx [Ty]; VectorData (d) [3] = element -&gt; node [1] -&gt; dx [Rz]; VectorData (d) [4] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [5] = element -&gt; node [2] -&gt; dx [Ty]; VectorData (d) [6] <p> We need to * do a transformation to get them into local coordinates. */ VectorData (d) <ref> [1] </ref> = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [2] = element -&gt; node [1] -&gt; dx [Ty]; VectorData (d) [3] = element -&gt; node [1] -&gt; dx [Rz]; VectorData (d) [4] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [5] = element -&gt; node [2] -&gt; dx [Ty]; VectorData (d) [6] = element -&gt; node [2] -&gt; dx [Rz]; T = TransformMatrix <p> We need to * do a transformation to get them into local coordinates. */ VectorData (d) <ref> [1] </ref> = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [2] = element -&gt; node [1] -&gt; dx [Ty]; VectorData (d) [3] = element -&gt; node [1] -&gt; dx [Rz]; VectorData (d) [4] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [5] = element -&gt; node [2] -&gt; dx [Ty]; VectorData (d) [6] = element -&gt; node [2] -&gt; dx [Rz]; T = TransformMatrix (element); MultiplyMatrices (dlocal, T, d); /* * We already have the <p> do a transformation to get them into local coordinates. */ VectorData (d) <ref> [1] </ref> = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [2] = element -&gt; node [1] -&gt; dx [Ty]; VectorData (d) [3] = element -&gt; node [1] -&gt; dx [Rz]; VectorData (d) [4] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [5] = element -&gt; node [2] -&gt; dx [Ty]; VectorData (d) [6] = element -&gt; node [2] -&gt; dx [Rz]; T = TransformMatrix (element); MultiplyMatrices (dlocal, T, d); /* * We already have the element stiffness matrix because we * set element -&gt; retainK = <p> This particular loop * only works because there are two stress points and two * stress values at each point. */ element -&gt; stress [i] -&gt; x = element -&gt; node [i] -&gt; x; element -&gt; stress [i] -&gt; y = element -&gt; node [i] -&gt; y; element -&gt; stress <ref> [1] </ref> -&gt; values [i] = VectorData (f)[i]; element -&gt; stress [2] -&gt; values [i] = VectorData (f)[i+2]; - return 0; - Now we get into the few routines that are local to this file (i.e., private routines which we would only call when we were defining Timoshenko beam elements). <p> (4,6); if (T == NullMatrix) AllocationError (element, "transform matrix"); - * This is a pretty sparse matrix so we'll just zero it out * then fill in the few relevant entries. */ ZeroMatrix (T); L = ElementLength (element, 2); c = (element -&gt; node [2] -&gt; x element -&gt; node <ref> [1] </ref> -&gt; x) / L; s = (element -&gt; node [2] -&gt; y element -&gt; node [1] -&gt; y) / L; MatrixData (T) [1][1] = -s; MatrixData (T) [1][2] = c; MatrixData (T) [2][3] = 1.0; MatrixData (T) [3][4] = -s; MatrixData (T) [3][5] = c; MatrixData (T) [4][6] = 1.0; <p> matrix so we'll just zero it out * then fill in the few relevant entries. */ ZeroMatrix (T); L = ElementLength (element, 2); c = (element -&gt; node [2] -&gt; x element -&gt; node <ref> [1] </ref> -&gt; x) / L; s = (element -&gt; node [2] -&gt; y element -&gt; node [1] -&gt; y) / L; MatrixData (T) [1][1] = -s; MatrixData (T) [1][2] = c; MatrixData (T) [2][3] = 1.0; MatrixData (T) [3][4] = -s; MatrixData (T) [3][5] = c; MatrixData (T) [4][6] = 1.0; return T; - Now we need two local functions to create the two different kinds of <p> These are just enumerated * so that they expand to 2 and 6 ... no real magic there, it * is just little more intuitive to look at. */ MultiplyMatrices (eq_global, Tt, equiv); element -&gt; node <ref> [1] </ref> -&gt; eq_force [Tx] += VectorData (eq_global) [1]; element -&gt; node [1] -&gt; eq_force [Ty] += VectorData (eq_global) [2]; element -&gt; node [1] -&gt; eq_force [Rz] += VectorData (eq_global) [3]; element -&gt; node [2] -&gt; eq_force [Tx] += VectorData (eq_global) [4]; element -&gt; node [2] -&gt; eq_force [Ty] += VectorData (eq_global) <p> These are just enumerated * so that they expand to 2 and 6 ... no real magic there, it * is just little more intuitive to look at. */ MultiplyMatrices (eq_global, Tt, equiv); element -&gt; node <ref> [1] </ref> -&gt; eq_force [Tx] += VectorData (eq_global) [1]; element -&gt; node [1] -&gt; eq_force [Ty] += VectorData (eq_global) [2]; element -&gt; node [1] -&gt; eq_force [Rz] += VectorData (eq_global) [3]; element -&gt; node [2] -&gt; eq_force [Tx] += VectorData (eq_global) [4]; element -&gt; node [2] -&gt; eq_force [Ty] += VectorData (eq_global) [5]; element -&gt; node [2] -&gt; eq_force <p> These are just enumerated * so that they expand to 2 and 6 ... no real magic there, it * is just little more intuitive to look at. */ MultiplyMatrices (eq_global, Tt, equiv); element -&gt; node <ref> [1] </ref> -&gt; eq_force [Tx] += VectorData (eq_global) [1]; element -&gt; node [1] -&gt; eq_force [Ty] += VectorData (eq_global) [2]; element -&gt; node [1] -&gt; eq_force [Rz] += VectorData (eq_global) [3]; element -&gt; node [2] -&gt; eq_force [Tx] += VectorData (eq_global) [4]; element -&gt; node [2] -&gt; eq_force [Ty] += VectorData (eq_global) [5]; element -&gt; node [2] -&gt; eq_force [Rz] += VectorData (eq_global) <p> expand to 2 and 6 ... no real magic there, it * is just little more intuitive to look at. */ MultiplyMatrices (eq_global, Tt, equiv); element -&gt; node <ref> [1] </ref> -&gt; eq_force [Tx] += VectorData (eq_global) [1]; element -&gt; node [1] -&gt; eq_force [Ty] += VectorData (eq_global) [2]; element -&gt; node [1] -&gt; eq_force [Rz] += VectorData (eq_global) [3]; element -&gt; node [2] -&gt; eq_force [Tx] += VectorData (eq_global) [4]; element -&gt; node [2] -&gt; eq_force [Ty] += VectorData (eq_global) [5]; element -&gt; node [2] -&gt; eq_force [Rz] += VectorData (eq_global) [6]; return 0; - Now that we have written the source
Reference: [2] <author> G.R. Cowper. </author> <title> The shear coefficient in Timoshenko's beam theory. </title> <journal> ASME Journal of Applied Mechanics, </journal> <volume> 33 </volume> <pages> 335-340, </pages> <year> 1966. </year>
Reference-contexts: Cowper <ref> [2] </ref> provides an approximation for based on Poisson's ratio, = 12 + 11 if a better estimate is not available. This approximation will automatically be assumed if you provide nu rather than kappa in the material property for a Timoshenko beam element. <p> burlap was compiled with the GNU readline library, then you have complete command-line editing and history, as in bash. (A complete discussion of the editing capabilities can be found in the documentation of the readline library.) At the prompt, you can enter expressions to be evaluated. [1] 1 + 2 <ref> [2] </ref> write (1 + 2) 3 [4] write (a) 3 [5] write ([1, 2, 3]) 1 2 3 [6] write ([1; 2; 3]) 1 3 [7] write ([1, 2, 3] + [4, 5, 6]) 5 7 9 As illustrated above, write () is used to print results and = is the <p> In general the field names are the same as the names used in the FElt input file. For example, constraint is the field name for accessing the constraint object assigned to a node with the constraint= syntax in the FElt file. <ref> [2] </ref> write (nodes) array of node [3] write (elements) array of element [4] write (nodes (1)) node (1) [5] write (nodes (1).constraint) constraint (free) [6] write (elements (1).material.A) 0.0004 [7] m = elements (1).material [8] write ("A = ", m.A, " E = ", m.E) A = 0.0004 E = 2.1e+11 <p> Note that evaluating the component will evaluate the expression at time t=0. There is currently no way to determine if a component is assigned a time-varying expression. [1] f.Fx = "cos (t)" <ref> [2] </ref> write (f.Fx) 1 9.3.5 Constraint objects Constraint objects also allow the various information to be accessed as vectors or as individual components, as shown in Table 9.6. <p> Therefore, the first, second, and third dofs are active. The entire call to add definition () is: add definition ("truss", truss set up, truss stress, &linear, 2, 2, 1, <ref> [1, 2, 3, 0, 0, 0] </ref>) We have neglected to pass a value for the last argument, which indicates whether the local stiffness matrix should be retained after assembly into the global stiffness matrix. The default value for this argument is &false, which is fine for our purposes. <p> Functions are best created with an editor as a file which is then included. [1] system ("vi foo.b") <ref> [2] </ref> include ("foo.b") [3] system ("vi foo.b") [4] include ("foo.b") It soon becomes tedious to retype the same expressions. If burlap is compiled with the readline library, then you can use the built-in history mechanism. [1] system ("vi foo.b") [2] include ("foo.b") [3] !s For those not familiar with csh or <p> as a file which is then included. [1] system ("vi foo.b") <ref> [2] </ref> include ("foo.b") [3] system ("vi foo.b") [4] include ("foo.b") It soon becomes tedious to retype the same expressions. If burlap is compiled with the readline library, then you can use the built-in history mechanism. [1] system ("vi foo.b") [2] include ("foo.b") [3] !s For those not familiar with csh or bash, !s executes the last line that begins with s. Similarly, !i executes the last line that begins with i. You can save yourself more typing by using the word completion abilities of the readline library. <p> Pressing the tab key will complete the current word. If there is not a unique completion, then you will hear a bell and pressing the tab key again will list the completions. [1] sy &lt;Tab&gt; symmetric? system [1] system ("vi foo.b") <ref> [2] </ref> in &lt;Tab&gt; in integrate_hyperbolic inv include integrate_parabolic [2] include ("foo.b") The default set of built-in completions includes all keywords such as function and return, intrinsic functions such as include and sin, and enumeration constants such as &linear and &null. <p> Pressing the tab key will complete the current word. If there is not a unique completion, then you will hear a bell and pressing the tab key again will list the completions. [1] sy &lt;Tab&gt; symmetric? system [1] system ("vi foo.b") <ref> [2] </ref> in &lt;Tab&gt; in integrate_hyperbolic inv include integrate_parabolic [2] include ("foo.b") The default set of built-in completions includes all keywords such as function and return, intrinsic functions such as include and sin, and enumeration constants such as &linear and &null. Inside a quoted string, the default set of completions is not used; instead, file names are completed. 9.5. <p> Another trick is to define your own aliases for common lines. [1] alias v system ("vi foo.b") <ref> [2] </ref> alias vi system ("vi !$") [3] alias print write (!*) [4] vi foo.b The first alias defines v to be system ("vi foo.b"). The second is more general and defines vi to be system ("vi !$"). The string !$ will be replaced with the last word on the line. <p> Variable names are a sequence of letters, digits, and the underscore character. Finally, comments are enclosed within /* */; a pound sign (#) may also be used to indicate a comment until the end of the current line. [1] a = 3.14159 <ref> [2] </ref> b = "hello" [3] c = [1, 2, 3; 4, 5, 6] [4] write (a) 3.14159 [5] write (b) hello [6] write (c) 1 2 3 The following sections discuss the operators and functions of burlap in detail. <p> Variable names are a sequence of letters, digits, and the underscore character. Finally, comments are enclosed within /* */; a pound sign (#) may also be used to indicate a comment until the end of the current line. [1] a = 3.14159 [2] b = "hello" [3] c = <ref> [1, 2, 3; 4, 5, 6] </ref> [4] write (a) 3.14159 [5] write (b) hello [6] write (c) 1 2 3 The following sections discuss the operators and functions of burlap in detail. <p> In particular, a semicolon is inserted at the end of a line in interactive mode when the last literal or operator on the line can end an expression. [1] a = <ref> [1, 2, 3 [3] </ref> write (a) 1 2 3 [4] a = [1, 2, 3 + [5] write (a) 1 2 7 5 6 Note that since an expression cannot end with +, the next line is taken to be a continuation of the previous line. <p> In particular, a semicolon is inserted at the end of a line in interactive mode when the last literal or operator on the line can end an expression. [1] a = [1, 2, 3 [3] write (a) 1 2 3 [4] a = <ref> [1, 2, 3 + [5] </ref> write (a) 1 2 7 5 6 Note that since an expression cannot end with +, the next line is taken to be a continuation of the previous line. <p> A line can be explicitly continued by ending the line with a backslash character. [1] write ("hello"); write ("there") hello there <ref> [2] </ref> a = 1 + [3] write (a) 6 4&gt; + 2 [5] write (b) 3 [7] 4, 5, 6] [8] write (x) 1 2 3 Although these semantics may sound complicated, they are designed so that 99.9% of the time you don't need to worry about when to add a <p> For example, a matrix cannot be assigned to the component of a force. Some fields are also read-only, such as the name of a constraint or the number of a node or element. [1] a = <ref> [1, 2, 3] </ref> [2] write (a) 1 2 3 [4] write (a, " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] <p> For example, a matrix cannot be assigned to the component of a force. Some fields are also read-only, such as the name of a constraint or the number of a node or element. [1] a = [1, 2, 3] <ref> [2] </ref> write (a) 1 2 3 [4] write (a, " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error <p> a = <ref> [1, 2, 3] </ref> [2] write (a) 1 2 3 [4] write (a, " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = [1, 2, 3; 4, 5, 6] [11] write (a) 1 2 3 [12] a (1, 2) = 0 [13] write (a) 1 0 3 10.4.3 Logical or operator x or y; x || y The logical or <p> " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = <ref> [1, 2, 3; 4, 5, 6] </ref> [11] write (a) 1 2 3 [12] a (1, 2) = 0 [13] write (a) 1 0 3 10.4.3 Logical or operator x or y; x || y The logical or operator has two equivalent forms and groups from left-to-right. <p> X Y Z Z = X or Y scalar scalar scalar z = x or y Table 10.2: Type table for the logical or operator. [1] write (1 &lt; 2 or 5 &gt; 6) 1 <ref> [2] </ref> write (1 &gt; 2 or 5 &gt; 6) 0 [3] write (1 or 1 / 0) 1 [4] write (0 or 1 / 0) stdin:4: exception in expression: right division by zero [5] a = [1, 2, 3] [6] write (a or 1) stdin:6: type error in expression: matrix in <p> the logical or operator. [1] write (1 &lt; 2 or 5 &gt; 6) 1 [2] write (1 &gt; 2 or 5 &gt; 6) 0 [3] write (1 or 1 / 0) 1 [4] write (0 or 1 / 0) stdin:4: exception in expression: right division by zero [5] a = <ref> [1, 2, 3] </ref> [6] write (a or 1) stdin:6: type error in expression: matrix in conditional context [7] write (any? (a) or 1) 1 10.4.4 Logical and operator x and y; x && y The logical and operator has two equivalent forms and groups from left-to-right. <p> X Y Z Z = X and Y scalar scalar scalar z = x and y Table 10.3: Type table for the logical and operator. [1] write (1 &lt; 2 and 3 &lt; 4) 1 <ref> [2] </ref> write (1 &lt; 2 and 3 &gt; 4) 0 [3] write (0 and 1 / 0) 0 [4] write (1 and 1 / 0) stdin:4: exception in expression: right division by zero 10.4.5 Equality operators X == Y The equality (==) and inequality (!= or &lt;&gt;) operators associate from left-to-right. <p> Essentially, burlap does element-by-element comparison for matrices and scalars, string (i.e., lexicographic) comparison for strings, and identity (i.e., pointer) comparison on all other type objects. When comparing two matrices, their dimensions must be identical. [1] write ([1, 2, 3] == 2) 0 1 0 <ref> [2] </ref> write (2 != [1, 2, 3]) 1 0 1 [3] write ([1, 2, 3] == [3, 2, 3]) 0 1 1 [4] write ("hello" == "hello") 1 [5] write ("hello" == "there") 0 [6] write (nodes (1) == nodes (1)) 1 [7] write (nodes (1) == elements (1)) stdin:7: type <p> Essentially, burlap does element-by-element comparison for matrices and scalars, string (i.e., lexicographic) comparison for strings, and identity (i.e., pointer) comparison on all other type objects. When comparing two matrices, their dimensions must be identical. [1] write (<ref> [1, 2, 3] </ref> == 2) 0 1 0 [2] write (2 != [1, 2, 3]) 1 0 1 [3] write ([1, 2, 3] == [3, 2, 3]) 0 1 1 [4] write ("hello" == "hello") 1 [5] write ("hello" == "there") 0 [6] write (nodes (1) == nodes (1)) 1 [7] write (nodes (1) == elements (1)) stdin:7: type error in expression: node <p> When comparing two matrices, their dimensions must be identical. [1] write ([1, 2, 3] == 2) 0 1 0 [2] write (2 != [1, 2, 3]) 1 0 1 [3] write ([1, 2, 3] == <ref> [3, 2, 3] </ref>) 0 1 1 [4] write ("hello" == "hello") 1 [5] write ("hello" == "there") 0 [6] write (nodes (1) == nodes (1)) 1 [7] write (nodes (1) == elements (1)) stdin:7: type error in expression: node == element 10.4. <p> The result of the expression is 1 if the expression is true, and 0 if the expression is false. If two matrices are compared, then their dimensions must be identical. [1] write ([1, 2, 3] &lt; 3) 1 1 0 <ref> [2] </ref> write ([1, 2, 3] &gt;= [3, 2, 1]) 0 1 1 [3] write ("aardvark" &lt; "aardwolf") 1 10.4.7 Range operator x : z 140 CHAPTER 10. <p> The result of the expression is 1 if the expression is true, and 0 if the expression is false. If two matrices are compared, then their dimensions must be identical. [1] write ([1, 2, 3] &lt; 3) 1 1 0 [2] write ([1, 2, 3] &gt;= <ref> [3, 2, 1] </ref>) 0 1 1 [3] write ("aardvark" &lt; "aardwolf") 1 10.4.7 Range operator x : z 140 CHAPTER 10. <p> Each of x, y, and z must be scalar expressions, as shown in Table 10.6. X Y Z W W = X : Y : Z scalar scalar scalar matrix (as defined above) Table 10.6: Type table for the range operator. [1] write (1:3) 1 2 3 <ref> [2] </ref> write (3:1) null [3] write (1:2:10) 1 3 5 7 9 [4] write (10:-2:1) 10 8 6 4 2 As illustrated above, if the range is improperly specified then a null value is returned. <p> Like the equality and relational operators, the additive operators associate from left-to-right. Also, two matrices must have identical dimensions for addition or sub traction. [1] write (1 + 2) 3 <ref> [2] </ref> write (1 + [2, 3, 4]) 3 4 5 [3] write ([3, 4, 5] - 1) 2 3 4 [4] write ([1, 2] + [3, 4]) 4 6 [5] write ([1, 2, 3] + [4, 5]) stdin:5: size mismatch in expression: (1 x 3) + (1 x 2) 10.4.9 Multiplicative <p> Like the equality and relational operators, the additive operators associate from left-to-right. Also, two matrices must have identical dimensions for addition or sub traction. [1] write (1 + 2) 3 [2] write (1 + <ref> [2, 3, 4] </ref>) 3 4 5 [3] write ([3, 4, 5] - 1) 2 3 4 [4] write ([1, 2] + [3, 4]) 4 6 [5] write ([1, 2, 3] + [4, 5]) stdin:5: size mismatch in expression: (1 x 3) + (1 x 2) 10.4.9 Multiplicative operators X * Y <p> In matrix multiplication the inner dimensions must agree. [1] write (2 * 3) 6 <ref> [2] </ref> write (2 * [1, 2, 3]) 2 4 6 [3] write ([1, 2, 3] * [1; 2; 3]) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * [3, 4]) stdin:5: size mismatch in expression: (1 x 2) * <p> In matrix multiplication the inner dimensions must agree. [1] write (2 * 3) 6 [2] write (2 * <ref> [1, 2, 3] </ref>) 2 4 6 [3] write ([1, 2, 3] * [1; 2; 3]) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * [3, 4]) stdin:5: size mismatch in expression: (1 x 2) * (1 x 2) burlap <p> In matrix multiplication the inner dimensions must agree. [1] write (2 * 3) 6 [2] write (2 * [1, 2, 3]) 2 4 6 [3] write ([1, 2, 3] * <ref> [1; 2; 3] </ref>) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * [3, 4]) stdin:5: size mismatch in expression: (1 x 2) * (1 x 2) burlap supports two forms of division: left division and right division. <p> In matrix multiplication the inner dimensions must agree. [1] write (2 * 3) 6 [2] write (2 * <ref> [1, 2, 3] </ref>) 2 4 6 [3] write ([1, 2, 3] * [1; 2; 3]) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * [3, 4]) stdin:5: size mismatch in expression: (1 x 2) * (1 x 2) burlap supports two forms of division: left division and right division. <p> In all cases, the number of rows of X must equal the number of columns of Y . Z = X=Y Z = XY 1 (Y T Z T ) T = (X T ) T [1] write (1 / 2) 0.5 <ref> [2] </ref> write (1 / 0) stdin:2: exception in expression: right division by zero [3] write ([1, 2, 3] / 10) 0.1 0.2 0.3 The left division of X and Y is (approximately) equivalent to the inverse of X multiplied by Y . <p> The number of columns of X must equal the number of rows of Y . [1] write (2 " 1) 0.5 <ref> [2] </ref> write (0 " 1) stdin:2: exception in expression: left division by zero [3] write (10 " [1, 2, 3]) 0.1 0.2 0.3 [4] write ([1, 2; 3, 4] " [5, 6]) stdin:4: size mismatch in expression: (2 x 2) " (1 x 2) [5] write ([1, 2; 3, 4] " <p> The number of columns of X must equal the number of rows of Y . [1] write (2 " 1) 0.5 [2] write (0 " 1) stdin:2: exception in expression: left division by zero [3] write (10 " <ref> [1, 2, 3] </ref>) 0.1 0.2 0.3 [4] write ([1, 2; 3, 4] " [5, 6]) stdin:4: size mismatch in expression: (2 x 2) " (1 x 2) [5] write ([1, 2; 3, 4] " [5; 6]) -4 Finally, burlap also supports a remainder operation as shown in Table 10.11. <p> Additionally, x must be non-negative or y must be an integer; otherwise a math ematical exception will result. [1] write (2 ** 3) 8 <ref> [2] </ref> write (2 ** .5) 1.41421 [3] write (-2 ** .5) stdin:3: exception in expression: illegal base and exponent 10.4.11 Transposition operator X' The transposition operator returns the transpose of its operand and associates from left-to-right. <p> However, if X is a vector then X (i) is its ith element. Since a scalar is a matrix with one row and one column, it may also be indexed. [1] A = <ref> [1, 2, 3; 4, 5, 6] </ref> [3] y = [1, 2, 3] [4] write (A) 1 2 3 10.4. <p> However, if X is a vector then X (i) is its ith element. Since a scalar is a matrix with one row and one column, it may also be indexed. [1] A = [1, 2, 3; 4, 5, 6] [3] y = <ref> [1, 2, 3] </ref> [4] write (A) 1 2 3 10.4. <p> non-zero? compact? (X) Is X a compact-column matrix? every? (X) Is every element of X non-zero? null? (X) Is X null? matrix? (X) Is X a matrix? scalar? (X) Is X a scalar? symmetric? (X) Is X a symmetric matrix? Table 10.17: Predicate functions available in burlap. [1] x = <ref> [1, 2, 3] </ref> [3] write (scalar? (x), " ", scalar? (y)) 0 1 [4] write (matrix? (x), " ", matrix? (y)) 1 0 [6] write (symmetric? (z), " ", compact? (z)) 1 0 [7] write (compact? (compact (z))) 1 10.5.4 Finite element functions The finite element functions provide an interface to <p> to one is implicitly an assignment to both. burlap uses this ability in several intrinsic functions (e.g., lu (), eig ()) to "return" more than one value from a function. function swap (x, y) t = x; x = y; y = t [1] a = 1; b = 2 <ref> [2] </ref> swap (a, b) [3] write (a, " ", b) 1 2 The values are not swapped as desired since they are passed by value. <p> For the swap () function to work correctly the data of the formal and actual parameters must be shared. function swap (shared x, shared y) t = x; x = y; y = t [1] a = 1; b = 2 <ref> [2] </ref> swap (a, b) [3] write (a, " ", b) 2 1 This type of parameter passing is also known as call-by-reference or var-parameters. Fortran passes all parameters by reference; C passes all parameters by 10.7. <p> The while expression must evaluate to a scalar. function sum_of_first (n) i = 0 while i &lt;= n do s = s + i end return s end 10.7. CONTROL-FLOW CONSTRUCTS 163 [1] write (sum_of_first (3)) 6 <ref> [2] </ref> write (sum_of_first (10)) 55 [3] write (while 0 do end) null This example uses a while expression to compute the sum of the first n integers. The last write () function illustrates the result of the while loop. <p> If the in expression is null, then the expression-list is not executed. function sum_of_first (n) s = 0 s = s + i return s end [1] write (sum_of_first (3)) 6 164 CHAPTER 10. THE BURLAP SYNTAX <ref> [2] </ref> write (sum_of_first (10)) 55 [3] write (sum_of_first (-1)) 0 This last write () expression works correctly since the range 1 : -1 produces a null value and thus the body of the for expression is not executed. function sum (x) s = 0 for i in v do end return <p> If x is simply 3 then v is simply 3 and i is also 3. If x is the vector <ref> [1, 2, 3] </ref> then v is successively assigned 1, 2, and 3 and i is simply assigned each value of v. <p> If x is simply 3 then v is simply 3 and i is also 3. If x is the vector [1, 2, 3] then v is successively assigned 1, 2, and 3 and i is simply assigned each value of v. If x is the matrix <ref> [1, 2, 3; 4, 5, 6] </ref> then v is successively assigned the column vectors [1; 4], [2; 5], and [3; 6] and i is assigned the values 1, 4, 2, 5, 3, and 6 in that order. 10.7.4 break, next, and return expressions return [ expression ] break [ expression ] <p> If x is the vector [1, 2, 3] then v is successively assigned 1, 2, and 3 and i is simply assigned each value of v. If x is the matrix [1, 2, 3; 4, 5, 6] then v is successively assigned the column vectors [1; 4], <ref> [2; 5] </ref>, and [3; 6] and i is assigned the values 1, 4, 2, 5, 3, and 6 in that order. 10.7.4 break, next, and return expressions return [ expression ] break [ expression ] next The return expression may be used to return a value from a function. <p> We need to * do a transformation to get them into local coordinates. */ VectorData (d) [1] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) <ref> [2] </ref> = element -&gt; node [1] -&gt; dx [Ty]; VectorData (d) [3] = element -&gt; node [1] -&gt; dx [Rz]; VectorData (d) [4] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [5] = element -&gt; node [2] -&gt; dx [Ty]; VectorData (d) [6] = element -&gt; node [2] -&gt; <p> (d) [1] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) <ref> [2] </ref> = element -&gt; node [1] -&gt; dx [Ty]; VectorData (d) [3] = element -&gt; node [1] -&gt; dx [Rz]; VectorData (d) [4] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [5] = element -&gt; node [2] -&gt; dx [Ty]; VectorData (d) [6] = element -&gt; node [2] -&gt; dx [Rz]; T = TransformMatrix (element); MultiplyMatrices (dlocal, T, d); /* * We already have the element stiffness matrix because we * set element -&gt; retainK = 1 in the definition structure. <p> (d) <ref> [2] </ref> = element -&gt; node [1] -&gt; dx [Ty]; VectorData (d) [3] = element -&gt; node [1] -&gt; dx [Rz]; VectorData (d) [4] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [5] = element -&gt; node [2] -&gt; dx [Ty]; VectorData (d) [6] = element -&gt; node [2] -&gt; dx [Rz]; T = TransformMatrix (element); MultiplyMatrices (dlocal, T, d); /* * We already have the element stiffness matrix because we * set element -&gt; retainK = 1 in the definition structure. <p> stress points and two * stress values at each point. */ element -&gt; stress [i] -&gt; x = element -&gt; node [i] -&gt; x; element -&gt; stress [i] -&gt; y = element -&gt; node [i] -&gt; y; element -&gt; stress [1] -&gt; values [i] = VectorData (f)[i]; element -&gt; stress <ref> [2] </ref> -&gt; values [i] = VectorData (f)[i+2]; - return 0; - Now we get into the few routines that are local to this file (i.e., private routines which we would only call when we were defining Timoshenko beam elements). <p> == NULL) - T = CreateMatrix (4,6); if (T == NullMatrix) AllocationError (element, "transform matrix"); - * This is a pretty sparse matrix so we'll just zero it out * then fill in the few relevant entries. */ ZeroMatrix (T); L = ElementLength (element, 2); c = (element -&gt; node <ref> [2] </ref> -&gt; x element -&gt; node [1] -&gt; x) / L; s = (element -&gt; node [2] -&gt; y element -&gt; node [1] -&gt; y) / L; MatrixData (T) [1][1] = -s; MatrixData (T) [1][2] = c; MatrixData (T) [2][3] = 1.0; MatrixData (T) [3][4] = -s; MatrixData (T) [3][5] = <p> * This is a pretty sparse matrix so we'll just zero it out * then fill in the few relevant entries. */ ZeroMatrix (T); L = ElementLength (element, 2); c = (element -&gt; node <ref> [2] </ref> -&gt; x element -&gt; node [1] -&gt; x) / L; s = (element -&gt; node [2] -&gt; y element -&gt; node [1] -&gt; y) / L; MatrixData (T) [1][1] = -s; MatrixData (T) [1][2] = c; MatrixData (T) [2][3] = 1.0; MatrixData (T) [3][4] = -s; MatrixData (T) [3][5] = c; MatrixData (T) [4][6] = 1.0; return T; - Now we need two local functions to <p> * so that they expand to 2 and 6 ... no real magic there, it * is just little more intuitive to look at. */ MultiplyMatrices (eq_global, Tt, equiv); element -&gt; node [1] -&gt; eq_force [Tx] += VectorData (eq_global) [1]; element -&gt; node [1] -&gt; eq_force [Ty] += VectorData (eq_global) <ref> [2] </ref>; element -&gt; node [1] -&gt; eq_force [Rz] += VectorData (eq_global) [3]; element -&gt; node [2] -&gt; eq_force [Tx] += VectorData (eq_global) [4]; element -&gt; node [2] -&gt; eq_force [Ty] += VectorData (eq_global) [5]; element -&gt; node [2] -&gt; eq_force [Rz] += VectorData (eq_global) [6]; return 0; - Now that we <p> * is just little more intuitive to look at. */ MultiplyMatrices (eq_global, Tt, equiv); element -&gt; node [1] -&gt; eq_force [Tx] += VectorData (eq_global) [1]; element -&gt; node [1] -&gt; eq_force [Ty] += VectorData (eq_global) <ref> [2] </ref>; element -&gt; node [1] -&gt; eq_force [Rz] += VectorData (eq_global) [3]; element -&gt; node [2] -&gt; eq_force [Tx] += VectorData (eq_global) [4]; element -&gt; node [2] -&gt; eq_force [Ty] += VectorData (eq_global) [5]; element -&gt; node [2] -&gt; eq_force [Rz] += VectorData (eq_global) [6]; return 0; - Now that we have written the source file timoshenko.c in the directory lib/Elements we need to change the <p> (eq_global, Tt, equiv); element -&gt; node [1] -&gt; eq_force [Tx] += VectorData (eq_global) [1]; element -&gt; node [1] -&gt; eq_force [Ty] += VectorData (eq_global) <ref> [2] </ref>; element -&gt; node [1] -&gt; eq_force [Rz] += VectorData (eq_global) [3]; element -&gt; node [2] -&gt; eq_force [Tx] += VectorData (eq_global) [4]; element -&gt; node [2] -&gt; eq_force [Ty] += VectorData (eq_global) [5]; element -&gt; node [2] -&gt; eq_force [Rz] += VectorData (eq_global) [6]; return 0; - Now that we have written the source file timoshenko.c in the directory lib/Elements we need to change the OBJS= line in Makefile in this directory to include our new <p> VectorData (eq_global) [1]; element -&gt; node [1] -&gt; eq_force [Ty] += VectorData (eq_global) <ref> [2] </ref>; element -&gt; node [1] -&gt; eq_force [Rz] += VectorData (eq_global) [3]; element -&gt; node [2] -&gt; eq_force [Tx] += VectorData (eq_global) [4]; element -&gt; node [2] -&gt; eq_force [Ty] += VectorData (eq_global) [5]; element -&gt; node [2] -&gt; eq_force [Rz] += VectorData (eq_global) [6]; return 0; - Now that we have written the source file timoshenko.c in the directory lib/Elements we need to change the OBJS= line in Makefile in this directory to include our new file.
Reference: [3] <author> E. Cuthill and J. McKee. </author> <title> Reducing the bandwidth of sparse symmetric matrices. </title> <booktitle> In Proceedings of the 24th National Conference of the ACM, ACM Publ P-69, </booktitle> <pages> pages 157-172, </pages> <address> New York, </address> <year> 1969. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: In general the field names are the same as the names used in the FElt input file. For example, constraint is the field name for accessing the constraint object assigned to a node with the constraint= syntax in the FElt file. [2] write (nodes) array of node <ref> [3] </ref> write (elements) array of element [4] write (nodes (1)) node (1) [5] write (nodes (1).constraint) constraint (free) [6] write (elements (1).material.A) 0.0004 [7] m = elements (1).material [8] write ("A = ", m.A, " E = ", m.E) A = 0.0004 E = 2.1e+11 9.3.1 Element objects Elements have the <p> Therefore, the first, second, and third dofs are active. The entire call to add definition () is: add definition ("truss", truss set up, truss stress, &linear, 2, 2, 1, <ref> [1, 2, 3, 0, 0, 0] </ref>) We have neglected to pass a value for the last argument, which indicates whether the local stiffness matrix should be retained after assembly into the global stiffness matrix. The default value for this argument is &false, which is fine for our purposes. <p> Functions are best created with an editor as a file which is then included. [1] system ("vi foo.b") [2] include ("foo.b") <ref> [3] </ref> system ("vi foo.b") [4] include ("foo.b") It soon becomes tedious to retype the same expressions. If burlap is compiled with the readline library, then you can use the built-in history mechanism. [1] system ("vi foo.b") [2] include ("foo.b") [3] !s For those not familiar with csh or bash, !s executes <p> which is then included. [1] system ("vi foo.b") [2] include ("foo.b") <ref> [3] </ref> system ("vi foo.b") [4] include ("foo.b") It soon becomes tedious to retype the same expressions. If burlap is compiled with the readline library, then you can use the built-in history mechanism. [1] system ("vi foo.b") [2] include ("foo.b") [3] !s For those not familiar with csh or bash, !s executes the last line that begins with s. Similarly, !i executes the last line that begins with i. You can save yourself more typing by using the word completion abilities of the readline library. <p> Another trick is to define your own aliases for common lines. [1] alias v system ("vi foo.b") [2] alias vi system ("vi !$") <ref> [3] </ref> alias print write (!*) [4] vi foo.b The first alias defines v to be system ("vi foo.b"). The second is more general and defines vi to be system ("vi !$"). The string !$ will be replaced with the last word on the line. <p> Variable names are a sequence of letters, digits, and the underscore character. Finally, comments are enclosed within /* */; a pound sign (#) may also be used to indicate a comment until the end of the current line. [1] a = 3.14159 [2] b = "hello" <ref> [3] </ref> c = [1, 2, 3; 4, 5, 6] [4] write (a) 3.14159 [5] write (b) hello [6] write (c) 1 2 3 The following sections discuss the operators and functions of burlap in detail. <p> Variable names are a sequence of letters, digits, and the underscore character. Finally, comments are enclosed within /* */; a pound sign (#) may also be used to indicate a comment until the end of the current line. [1] a = 3.14159 [2] b = "hello" [3] c = <ref> [1, 2, 3; 4, 5, 6] </ref> [4] write (a) 3.14159 [5] write (b) hello [6] write (c) 1 2 3 The following sections discuss the operators and functions of burlap in detail. <p> In particular, a semicolon is inserted at the end of a line in interactive mode when the last literal or operator on the line can end an expression. [1] a = [1, 2, 3 <ref> [3] </ref> write (a) 1 2 3 [4] a = [1, 2, 3 + [5] write (a) 1 2 7 5 6 Note that since an expression cannot end with +, the next line is taken to be a continuation of the previous line. <p> A matrix element may be an arbitrary expression; however, all expressions on the same row must have the same height. Additionally, all rows must have the same number of columns. 132 CHAPTER 10. THE BURLAP SYNTAX [1] x = 1 <ref> [3] </ref> write (a) 0 1 2 [5] write (b) 0 1 2 [6] write ([b, b]) 0 1 2 0 1 2 [7] write ([b, a]) stdin:7: inconsistent number of rows 10.2 Variables Variables are named by a sequence of letters, digits, the underscore character, and the question mark symbol. <p> A line can be explicitly continued by ending the line with a backslash character. [1] write ("hello"); write ("there") hello there [2] a = 1 + <ref> [3] </ref> write (a) 6 4&gt; + 2 [5] write (b) 3 [7] 4, 5, 6] [8] write (x) 1 2 3 Although these semantics may sound complicated, they are designed so that 99.9% of the time you don't need to worry about when to add a semicolon. <p> For example, a matrix cannot be assigned to the component of a force. Some fields are also read-only, such as the name of a constraint or the number of a node or element. [1] a = <ref> [1, 2, 3] </ref> [2] write (a) 1 2 3 [4] write (a, " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] <p> a = <ref> [1, 2, 3] </ref> [2] write (a) 1 2 3 [4] write (a, " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = [1, 2, 3; 4, 5, 6] [11] write (a) 1 2 3 [12] a (1, 2) = 0 [13] write (a) 1 0 3 10.4.3 Logical or operator x or y; x || y The logical or <p> " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = <ref> [1, 2, 3; 4, 5, 6] </ref> [11] write (a) 1 2 3 [12] a (1, 2) = 0 [13] write (a) 1 0 3 10.4.3 Logical or operator x or y; x || y The logical or operator has two equivalent forms and groups from left-to-right. <p> X Y Z Z = X or Y scalar scalar scalar z = x or y Table 10.2: Type table for the logical or operator. [1] write (1 &lt; 2 or 5 &gt; 6) 1 [2] write (1 &gt; 2 or 5 &gt; 6) 0 <ref> [3] </ref> write (1 or 1 / 0) 1 [4] write (0 or 1 / 0) stdin:4: exception in expression: right division by zero [5] a = [1, 2, 3] [6] write (a or 1) stdin:6: type error in expression: matrix in conditional context [7] write (any? (a) or 1) 1 10.4.4 <p> the logical or operator. [1] write (1 &lt; 2 or 5 &gt; 6) 1 [2] write (1 &gt; 2 or 5 &gt; 6) 0 [3] write (1 or 1 / 0) 1 [4] write (0 or 1 / 0) stdin:4: exception in expression: right division by zero [5] a = <ref> [1, 2, 3] </ref> [6] write (a or 1) stdin:6: type error in expression: matrix in conditional context [7] write (any? (a) or 1) 1 10.4.4 Logical and operator x and y; x && y The logical and operator has two equivalent forms and groups from left-to-right. <p> X Y Z Z = X and Y scalar scalar scalar z = x and y Table 10.3: Type table for the logical and operator. [1] write (1 &lt; 2 and 3 &lt; 4) 1 [2] write (1 &lt; 2 and 3 &gt; 4) 0 <ref> [3] </ref> write (0 and 1 / 0) 0 [4] write (1 and 1 / 0) stdin:4: exception in expression: right division by zero 10.4.5 Equality operators X == Y The equality (==) and inequality (!= or &lt;&gt;) operators associate from left-to-right. <p> Essentially, burlap does element-by-element comparison for matrices and scalars, string (i.e., lexicographic) comparison for strings, and identity (i.e., pointer) comparison on all other type objects. When comparing two matrices, their dimensions must be identical. [1] write (<ref> [1, 2, 3] </ref> == 2) 0 1 0 [2] write (2 != [1, 2, 3]) 1 0 1 [3] write ([1, 2, 3] == [3, 2, 3]) 0 1 1 [4] write ("hello" == "hello") 1 [5] write ("hello" == "there") 0 [6] write (nodes (1) == nodes (1)) 1 [7] write (nodes (1) == elements (1)) stdin:7: type error in expression: node <p> When comparing two matrices, their dimensions must be identical. [1] write ([1, 2, 3] == 2) 0 1 0 [2] write (2 != [1, 2, 3]) 1 0 1 <ref> [3] </ref> write ([1, 2, 3] == [3, 2, 3]) 0 1 1 [4] write ("hello" == "hello") 1 [5] write ("hello" == "there") 0 [6] write (nodes (1) == nodes (1)) 1 [7] write (nodes (1) == elements (1)) stdin:7: type error in expression: node == element 10.4. <p> When comparing two matrices, their dimensions must be identical. [1] write ([1, 2, 3] == 2) 0 1 0 [2] write (2 != [1, 2, 3]) 1 0 1 [3] write ([1, 2, 3] == <ref> [3, 2, 3] </ref>) 0 1 1 [4] write ("hello" == "hello") 1 [5] write ("hello" == "there") 0 [6] write (nodes (1) == nodes (1)) 1 [7] write (nodes (1) == elements (1)) stdin:7: type error in expression: node == element 10.4. <p> The result of the expression is 1 if the expression is true, and 0 if the expression is false. If two matrices are compared, then their dimensions must be identical. [1] write ([1, 2, 3] &lt; 3) 1 1 0 [2] write ([1, 2, 3] &gt;= <ref> [3, 2, 1] </ref>) 0 1 1 [3] write ("aardvark" &lt; "aardwolf") 1 10.4.7 Range operator x : z 140 CHAPTER 10. <p> If two matrices are compared, then their dimensions must be identical. [1] write ([1, 2, 3] &lt; 3) 1 1 0 [2] write ([1, 2, 3] &gt;= [3, 2, 1]) 0 1 1 <ref> [3] </ref> write ("aardvark" &lt; "aardwolf") 1 10.4.7 Range operator x : z 140 CHAPTER 10. <p> X Y Z W W = X : Y : Z scalar scalar scalar matrix (as defined above) Table 10.6: Type table for the range operator. [1] write (1:3) 1 2 3 [2] write (3:1) null <ref> [3] </ref> write (1:2:10) 1 3 5 7 9 [4] write (10:-2:1) 10 8 6 4 2 As illustrated above, if the range is improperly specified then a null value is returned. <p> Like the equality and relational operators, the additive operators associate from left-to-right. Also, two matrices must have identical dimensions for addition or sub traction. [1] write (1 + 2) 3 [2] write (1 + <ref> [2, 3, 4] </ref>) 3 4 5 [3] write ([3, 4, 5] - 1) 2 3 4 [4] write ([1, 2] + [3, 4]) 4 6 [5] write ([1, 2, 3] + [4, 5]) stdin:5: size mismatch in expression: (1 x 3) + (1 x 2) 10.4.9 Multiplicative operators X * Y <p> Like the equality and relational operators, the additive operators associate from left-to-right. Also, two matrices must have identical dimensions for addition or sub traction. [1] write (1 + 2) 3 [2] write (1 + [2, 3, 4]) 3 4 5 <ref> [3] </ref> write ([3, 4, 5] - 1) 2 3 4 [4] write ([1, 2] + [3, 4]) 4 6 [5] write ([1, 2, 3] + [4, 5]) stdin:5: size mismatch in expression: (1 x 3) + (1 x 2) 10.4.9 Multiplicative operators X * Y X " Y 142 CHAPTER 10. <p> Also, two matrices must have identical dimensions for addition or sub traction. [1] write (1 + 2) 3 [2] write (1 + [2, 3, 4]) 3 4 5 [3] write ([3, 4, 5] - 1) 2 3 4 [4] write ([1, 2] + <ref> [3, 4] </ref>) 4 6 [5] write ([1, 2, 3] + [4, 5]) stdin:5: size mismatch in expression: (1 x 3) + (1 x 2) 10.4.9 Multiplicative operators X * Y X " Y 142 CHAPTER 10. <p> In matrix multiplication the inner dimensions must agree. [1] write (2 * 3) 6 [2] write (2 * <ref> [1, 2, 3] </ref>) 2 4 6 [3] write ([1, 2, 3] * [1; 2; 3]) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * [3, 4]) stdin:5: size mismatch in expression: (1 x 2) * (1 x 2) burlap <p> In matrix multiplication the inner dimensions must agree. [1] write (2 * 3) 6 [2] write (2 * [1, 2, 3]) 2 4 6 <ref> [3] </ref> write ([1, 2, 3] * [1; 2; 3]) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * [3, 4]) stdin:5: size mismatch in expression: (1 x 2) * (1 x 2) burlap supports two forms of division: left <p> In matrix multiplication the inner dimensions must agree. [1] write (2 * 3) 6 [2] write (2 * [1, 2, 3]) 2 4 6 [3] write ([1, 2, 3] * <ref> [1; 2; 3] </ref>) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * [3, 4]) stdin:5: size mismatch in expression: (1 x 2) * (1 x 2) burlap supports two forms of division: left division and right division. <p> In matrix multiplication the inner dimensions must agree. [1] write (2 * 3) 6 [2] write (2 * <ref> [1, 2, 3] </ref>) 2 4 6 [3] write ([1, 2, 3] * [1; 2; 3]) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * [3, 4]) stdin:5: size mismatch in expression: (1 x 2) * (1 x 2) burlap supports two forms of division: left division and right division. <p> inner dimensions must agree. [1] write (2 * 3) 6 [2] write (2 * [1, 2, 3]) 2 4 6 [3] write ([1, 2, 3] * [1; 2; 3]) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * <ref> [3, 4] </ref>) stdin:5: size mismatch in expression: (1 x 2) * (1 x 2) burlap supports two forms of division: left division and right division. The right division of X and Y is (approximately) equivalent to multiplying X by the inverse of Y . <p> Z = X=Y Z = XY 1 (Y T Z T ) T = (X T ) T [1] write (1 / 2) 0.5 [2] write (1 / 0) stdin:2: exception in expression: right division by zero <ref> [3] </ref> write ([1, 2, 3] / 10) 0.1 0.2 0.3 The left division of X and Y is (approximately) equivalent to the inverse of X multiplied by Y . <p> The number of columns of X must equal the number of rows of Y . [1] write (2 " 1) 0.5 [2] write (0 " 1) stdin:2: exception in expression: left division by zero <ref> [3] </ref> write (10 " [1, 2, 3]) 0.1 0.2 0.3 [4] write ([1, 2; 3, 4] " [5, 6]) stdin:4: size mismatch in expression: (2 x 2) " (1 x 2) [5] write ([1, 2; 3, 4] " [5; 6]) -4 Finally, burlap also supports a remainder operation as shown in <p> The number of columns of X must equal the number of rows of Y . [1] write (2 " 1) 0.5 [2] write (0 " 1) stdin:2: exception in expression: left division by zero [3] write (10 " <ref> [1, 2, 3] </ref>) 0.1 0.2 0.3 [4] write ([1, 2; 3, 4] " [5, 6]) stdin:4: size mismatch in expression: (2 x 2) " (1 x 2) [5] write ([1, 2; 3, 4] " [5; 6]) -4 Finally, burlap also supports a remainder operation as shown in Table 10.11. <p> Additionally, x must be non-negative or y must be an integer; otherwise a math ematical exception will result. [1] write (2 ** 3) 8 [2] write (2 ** .5) 1.41421 <ref> [3] </ref> write (-2 ** .5) stdin:3: exception in expression: illegal base and exponent 10.4.11 Transposition operator X' The transposition operator returns the transpose of its operand and associates from left-to-right. The transpose of a scalar is defined to be itself, as shown in Table 10.13. <p> However, if X is a vector then X (i) is its ith element. Since a scalar is a matrix with one row and one column, it may also be indexed. [1] A = <ref> [1, 2, 3; 4, 5, 6] </ref> [3] y = [1, 2, 3] [4] write (A) 1 2 3 10.4. <p> However, if X is a vector then X (i) is its ith element. Since a scalar is a matrix with one row and one column, it may also be indexed. [1] A = [1, 2, 3; 4, 5, 6] <ref> [3] </ref> y = [1, 2, 3] [4] write (A) 1 2 3 10.4. <p> However, if X is a vector then X (i) is its ith element. Since a scalar is a matrix with one row and one column, it may also be indexed. [1] A = [1, 2, 3; 4, 5, 6] [3] y = <ref> [1, 2, 3] </ref> [4] write (A) 1 2 3 10.4. <p> non-zero? compact? (X) Is X a compact-column matrix? every? (X) Is every element of X non-zero? null? (X) Is X null? matrix? (X) Is X a matrix? scalar? (X) Is X a scalar? symmetric? (X) Is X a symmetric matrix? Table 10.17: Predicate functions available in burlap. [1] x = <ref> [1, 2, 3] </ref> [3] write (scalar? (x), " ", scalar? (y)) 0 1 [4] write (matrix? (x), " ", matrix? (y)) 1 0 [6] write (symmetric? (z), " ", compact? (z)) 1 0 [7] write (compact? (compact (z))) 1 10.5.4 Finite element functions The finite element functions provide an interface to <p> Is X a compact-column matrix? every? (X) Is every element of X non-zero? null? (X) Is X null? matrix? (X) Is X a matrix? scalar? (X) Is X a scalar? symmetric? (X) Is X a symmetric matrix? Table 10.17: Predicate functions available in burlap. [1] x = [1, 2, 3] <ref> [3] </ref> write (scalar? (x), " ", scalar? (y)) 0 1 [4] write (matrix? (x), " ", matrix? (y)) 1 0 [6] write (symmetric? (z), " ", compact? (z)) 1 0 [7] write (compact? (compact (z))) 1 10.5.4 Finite element functions The finite element functions provide an interface to the functions in <p> an assignment to both. burlap uses this ability in several intrinsic functions (e.g., lu (), eig ()) to "return" more than one value from a function. function swap (x, y) t = x; x = y; y = t [1] a = 1; b = 2 [2] swap (a, b) <ref> [3] </ref> write (a, " ", b) 1 2 The values are not swapped as desired since they are passed by value. <p> For the swap () function to work correctly the data of the formal and actual parameters must be shared. function swap (shared x, shared y) t = x; x = y; y = t [1] a = 1; b = 2 [2] swap (a, b) <ref> [3] </ref> write (a, " ", b) 2 1 This type of parameter passing is also known as call-by-reference or var-parameters. Fortran passes all parameters by reference; C passes all parameters by 10.7. <p> The while expression must evaluate to a scalar. function sum_of_first (n) i = 0 while i &lt;= n do s = s + i end return s end 10.7. CONTROL-FLOW CONSTRUCTS 163 [1] write (sum_of_first (3)) 6 [2] write (sum_of_first (10)) 55 <ref> [3] </ref> write (while 0 do end) null This example uses a while expression to compute the sum of the first n integers. The last write () function illustrates the result of the while loop. <p> If the in expression is null, then the expression-list is not executed. function sum_of_first (n) s = 0 s = s + i return s end [1] write (sum_of_first (3)) 6 164 CHAPTER 10. THE BURLAP SYNTAX [2] write (sum_of_first (10)) 55 <ref> [3] </ref> write (sum_of_first (-1)) 0 This last write () expression works correctly since the range 1 : -1 produces a null value and thus the body of the for expression is not executed. function sum (x) s = 0 for i in v do end return s end This example correctly <p> If x is simply 3 then v is simply 3 and i is also 3. If x is the vector <ref> [1, 2, 3] </ref> then v is successively assigned 1, 2, and 3 and i is simply assigned each value of v. <p> If x is simply 3 then v is simply 3 and i is also 3. If x is the vector [1, 2, 3] then v is successively assigned 1, 2, and 3 and i is simply assigned each value of v. If x is the matrix <ref> [1, 2, 3; 4, 5, 6] </ref> then v is successively assigned the column vectors [1; 4], [2; 5], and [3; 6] and i is assigned the values 1, 4, 2, 5, 3, and 6 in that order. 10.7.4 break, next, and return expressions return [ expression ] break [ expression ] <p> If x is the matrix [1, 2, 3; 4, 5, 6] then v is successively assigned the column vectors [1; 4], [2; 5], and <ref> [3; 6] </ref> and i is assigned the values 1, 4, 2, 5, 3, and 6 in that order. 10.7.4 break, next, and return expressions return [ expression ] break [ expression ] next The return expression may be used to return a value from a function. <p> The second gets the value of the Young's modulus of the material assigned to this element. If the array of elements is under consideration, you might seem something 168 CHAPTER 11. THE ALGORITHMS BEHIND FELT like this: element <ref> [3] </ref> -&gt; stress [1] -&gt; values [1] . This will be the value of the first stress component at the first integration point on element 3. <p> The one that we use in FElt is popularly known as Gibbs-King [6], the profile reduction variant of the Gibbs-Poole-Stockmeyer algorithm [7] which primarily tries to minimize bandwidth. Other popular algorithms include Cuthill-Mckee <ref> [3] </ref> and Reverse Cuthill-McKee [5]. 11.4.3 Assembling the global stiffness matrix This step of the process in FElt actually accomplishes three things. For each element, this routine calls an element setup routine based on element type. <p> We need to * do a transformation to get them into local coordinates. */ VectorData (d) [1] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [2] = element -&gt; node [1] -&gt; dx [Ty]; VectorData (d) <ref> [3] </ref> = element -&gt; node [1] -&gt; dx [Rz]; VectorData (d) [4] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [5] = element -&gt; node [2] -&gt; dx [Ty]; VectorData (d) [6] = element -&gt; node [2] -&gt; dx [Rz]; T = TransformMatrix (element); MultiplyMatrices (dlocal, T, d); /* <p> real magic there, it * is just little more intuitive to look at. */ MultiplyMatrices (eq_global, Tt, equiv); element -&gt; node [1] -&gt; eq_force [Tx] += VectorData (eq_global) [1]; element -&gt; node [1] -&gt; eq_force [Ty] += VectorData (eq_global) [2]; element -&gt; node [1] -&gt; eq_force [Rz] += VectorData (eq_global) <ref> [3] </ref>; element -&gt; node [2] -&gt; eq_force [Tx] += VectorData (eq_global) [4]; element -&gt; node [2] -&gt; eq_force [Ty] += VectorData (eq_global) [5]; element -&gt; node [2] -&gt; eq_force [Rz] += VectorData (eq_global) [6]; return 0; - Now that we have written the source file timoshenko.c in the directory lib/Elements we
Reference: [4] <author> Z. Friedman and John B. Kosmatka. </author> <title> An improved two-node Timoshenko beam finite element. </title> <journal> Computers and Structures, </journal> <volume> 47 </volume> <pages> 473-481, </pages> <year> 1993. </year>
Reference-contexts: It is limited to in-plane behavior and does not support an axial degree of freedom. There are lots of approaches to defining an element using Timoshenko beam theory. Classic examples can be found in [10, 15]. The formulation we use is from <ref> [4] </ref>. <p> The definition of the consistent mass matrix varies from one formulation of Timoshenko theory to the next. 4.2. STRUCTURAL ANALYSIS ELEMENTS 51 The definition in the formulation that we are using is considerably more complicated than the Euler-Bernoulli formulation; see <ref> [4] </ref> for details. Distributed loads on timoshenko elements can only be directed in the perpendicular (equivalent to LocalY) direction. (There are no axial DOF after all). The sign conventions for these loads and for internal forces is the same as that for the standard beam element. <p> readline library, then you have complete command-line editing and history, as in bash. (A complete discussion of the editing capabilities can be found in the documentation of the readline library.) At the prompt, you can enter expressions to be evaluated. [1] 1 + 2 [2] write (1 + 2) 3 <ref> [4] </ref> write (a) 3 [5] write ([1, 2, 3]) 1 2 3 [6] write ([1; 2; 3]) 1 3 [7] write ([1, 2, 3] + [4, 5, 6]) 5 7 9 As illustrated above, write () is used to print results and = is the assignment operator. <p> documentation of the readline library.) At the prompt, you can enter expressions to be evaluated. [1] 1 + 2 [2] write (1 + 2) 3 [4] write (a) 3 [5] write ([1, 2, 3]) 1 2 3 [6] write ([1; 2; 3]) 1 3 [7] write ([1, 2, 3] + <ref> [4, 5, 6] </ref>) 5 7 9 As illustrated above, write () is used to print results and = is the assignment operator. Also notice from the first expression that burlap does not print the result of every expression like matlab does. <p> For example, constraint is the field name for accessing the constraint object assigned to a node with the constraint= syntax in the FElt file. [2] write (nodes) array of node [3] write (elements) array of element <ref> [4] </ref> write (nodes (1)) node (1) [5] write (nodes (1).constraint) constraint (free) [6] write (elements (1).material.A) 0.0004 [7] m = elements (1).material [8] write ("A = ", m.A, " E = ", m.E) A = 0.0004 E = 2.1e+11 9.3.1 Element objects Elements have the same field names as those used <p> Functions are best created with an editor as a file which is then included. [1] system ("vi foo.b") [2] include ("foo.b") [3] system ("vi foo.b") <ref> [4] </ref> include ("foo.b") It soon becomes tedious to retype the same expressions. <p> Another trick is to define your own aliases for common lines. [1] alias v system ("vi foo.b") [2] alias vi system ("vi !$") [3] alias print write (!*) <ref> [4] </ref> vi foo.b The first alias defines v to be system ("vi foo.b"). The second is more general and defines vi to be system ("vi !$"). The string !$ will be replaced with the last word on the line. <p> Variable names are a sequence of letters, digits, and the underscore character. Finally, comments are enclosed within /* */; a pound sign (#) may also be used to indicate a comment until the end of the current line. [1] a = 3.14159 [2] b = "hello" [3] c = <ref> [1, 2, 3; 4, 5, 6] </ref> [4] write (a) 3.14159 [5] write (b) hello [6] write (c) 1 2 3 The following sections discuss the operators and functions of burlap in detail. <p> Finally, comments are enclosed within /* */; a pound sign (#) may also be used to indicate a comment until the end of the current line. [1] a = 3.14159 [2] b = "hello" [3] c = [1, 2, 3; 4, 5, 6] <ref> [4] </ref> write (a) 3.14159 [5] write (b) hello [6] write (c) 1 2 3 The following sections discuss the operators and functions of burlap in detail. They are intended to be the definitive word on the semantics of the operators, functions, matrix formers, etc. 130 10.1. <p> In particular, a semicolon is inserted at the end of a line in interactive mode when the last literal or operator on the line can end an expression. [1] a = [1, 2, 3 [3] write (a) 1 2 3 <ref> [4] </ref> a = [1, 2, 3 + [5] write (a) 1 2 7 5 6 Note that since an expression cannot end with +, the next line is taken to be a continuation of the previous line. <p> For example, a matrix cannot be assigned to the component of a force. Some fields are also read-only, such as the name of a constraint or the number of a node or element. [1] a = [1, 2, 3] [2] write (a) 1 2 3 <ref> [4] </ref> write (a, " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] <p> " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = <ref> [1, 2, 3; 4, 5, 6] </ref> [11] write (a) 1 2 3 [12] a (1, 2) = 0 [13] write (a) 1 0 3 10.4.3 Logical or operator x or y; x || y The logical or operator has two equivalent forms and groups from left-to-right. <p> Z = X or Y scalar scalar scalar z = x or y Table 10.2: Type table for the logical or operator. [1] write (1 &lt; 2 or 5 &gt; 6) 1 [2] write (1 &gt; 2 or 5 &gt; 6) 0 [3] write (1 or 1 / 0) 1 <ref> [4] </ref> write (0 or 1 / 0) stdin:4: exception in expression: right division by zero [5] a = [1, 2, 3] [6] write (a or 1) stdin:6: type error in expression: matrix in conditional context [7] write (any? (a) or 1) 1 10.4.4 Logical and operator x and y; x && <p> Z = X and Y scalar scalar scalar z = x and y Table 10.3: Type table for the logical and operator. [1] write (1 &lt; 2 and 3 &lt; 4) 1 [2] write (1 &lt; 2 and 3 &gt; 4) 0 [3] write (0 and 1 / 0) 0 <ref> [4] </ref> write (1 and 1 / 0) stdin:4: exception in expression: right division by zero 10.4.5 Equality operators X == Y The equality (==) and inequality (!= or &lt;&gt;) operators associate from left-to-right. <p> When comparing two matrices, their dimensions must be identical. [1] write ([1, 2, 3] == 2) 0 1 0 [2] write (2 != [1, 2, 3]) 1 0 1 [3] write ([1, 2, 3] == [3, 2, 3]) 0 1 1 <ref> [4] </ref> write ("hello" == "hello") 1 [5] write ("hello" == "there") 0 [6] write (nodes (1) == nodes (1)) 1 [7] write (nodes (1) == elements (1)) stdin:7: type error in expression: node == element 10.4. <p> X Y Z W W = X : Y : Z scalar scalar scalar matrix (as defined above) Table 10.6: Type table for the range operator. [1] write (1:3) 1 2 3 [2] write (3:1) null [3] write (1:2:10) 1 3 5 7 9 <ref> [4] </ref> write (10:-2:1) 10 8 6 4 2 As illustrated above, if the range is improperly specified then a null value is returned. <p> Like the equality and relational operators, the additive operators associate from left-to-right. Also, two matrices must have identical dimensions for addition or sub traction. [1] write (1 + 2) 3 [2] write (1 + <ref> [2, 3, 4] </ref>) 3 4 5 [3] write ([3, 4, 5] - 1) 2 3 4 [4] write ([1, 2] + [3, 4]) 4 6 [5] write ([1, 2, 3] + [4, 5]) stdin:5: size mismatch in expression: (1 x 3) + (1 x 2) 10.4.9 Multiplicative operators X * Y <p> Also, two matrices must have identical dimensions for addition or sub traction. [1] write (1 + 2) 3 [2] write (1 + [2, 3, 4]) 3 4 5 [3] write ([3, 4, 5] - 1) 2 3 4 <ref> [4] </ref> write ([1, 2] + [3, 4]) 4 6 [5] write ([1, 2, 3] + [4, 5]) stdin:5: size mismatch in expression: (1 x 3) + (1 x 2) 10.4.9 Multiplicative operators X * Y X " Y 142 CHAPTER 10. <p> Also, two matrices must have identical dimensions for addition or sub traction. [1] write (1 + 2) 3 [2] write (1 + [2, 3, 4]) 3 4 5 [3] write ([3, 4, 5] - 1) 2 3 4 [4] write ([1, 2] + <ref> [3, 4] </ref>) 4 6 [5] write ([1, 2, 3] + [4, 5]) stdin:5: size mismatch in expression: (1 x 3) + (1 x 2) 10.4.9 Multiplicative operators X * Y X " Y 142 CHAPTER 10. <p> must have identical dimensions for addition or sub traction. [1] write (1 + 2) 3 [2] write (1 + [2, 3, 4]) 3 4 5 [3] write ([3, 4, 5] - 1) 2 3 4 [4] write ([1, 2] + [3, 4]) 4 6 [5] write ([1, 2, 3] + <ref> [4, 5] </ref>) stdin:5: size mismatch in expression: (1 x 3) + (1 x 2) 10.4.9 Multiplicative operators X * Y X " Y 142 CHAPTER 10. <p> In matrix multiplication the inner dimensions must agree. [1] write (2 * 3) 6 [2] write (2 * [1, 2, 3]) 2 4 6 [3] write ([1, 2, 3] * [1; 2; 3]) 14 <ref> [4] </ref> write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * [3, 4]) stdin:5: size mismatch in expression: (1 x 2) * (1 x 2) burlap supports two forms of division: left division and right division. <p> inner dimensions must agree. [1] write (2 * 3) 6 [2] write (2 * [1, 2, 3]) 2 4 6 [3] write ([1, 2, 3] * [1; 2; 3]) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 [5] write ([1, 2] * <ref> [3, 4] </ref>) stdin:5: size mismatch in expression: (1 x 2) * (1 x 2) burlap supports two forms of division: left division and right division. The right division of X and Y is (approximately) equivalent to multiplying X by the inverse of Y . <p> The number of columns of X must equal the number of rows of Y . [1] write (2 " 1) 0.5 [2] write (0 " 1) stdin:2: exception in expression: left division by zero [3] write (10 " [1, 2, 3]) 0.1 0.2 0.3 <ref> [4] </ref> write ([1, 2; 3, 4] " [5, 6]) stdin:4: size mismatch in expression: (2 x 2) " (1 x 2) [5] write ([1, 2; 3, 4] " [5; 6]) -4 Finally, burlap also supports a remainder operation as shown in Table 10.11. <p> However, if X is a vector then X (i) is its ith element. Since a scalar is a matrix with one row and one column, it may also be indexed. [1] A = <ref> [1, 2, 3; 4, 5, 6] </ref> [3] y = [1, 2, 3] [4] write (A) 1 2 3 10.4. <p> However, if X is a vector then X (i) is its ith element. Since a scalar is a matrix with one row and one column, it may also be indexed. [1] A = [1, 2, 3; 4, 5, 6] [3] y = [1, 2, 3] <ref> [4] </ref> write (A) 1 2 3 10.4. <p> of X non-zero? null? (X) Is X null? matrix? (X) Is X a matrix? scalar? (X) Is X a scalar? symmetric? (X) Is X a symmetric matrix? Table 10.17: Predicate functions available in burlap. [1] x = [1, 2, 3] [3] write (scalar? (x), " ", scalar? (y)) 0 1 <ref> [4] </ref> write (matrix? (x), " ", matrix? (y)) 1 0 [6] write (symmetric? (z), " ", compact? (z)) 1 0 [7] write (compact? (compact (z))) 1 10.5.4 Finite element functions The finite element functions provide an interface to the functions in the FElt library. <p> If x is simply 3 then v is simply 3 and i is also 3. If x is the vector [1, 2, 3] then v is successively assigned 1, 2, and 3 and i is simply assigned each value of v. If x is the matrix <ref> [1, 2, 3; 4, 5, 6] </ref> then v is successively assigned the column vectors [1; 4], [2; 5], and [3; 6] and i is assigned the values 1, 4, 2, 5, 3, and 6 in that order. 10.7.4 break, next, and return expressions return [ expression ] break [ expression ] <p> If x is the vector [1, 2, 3] then v is successively assigned 1, 2, and 3 and i is simply assigned each value of v. If x is the matrix [1, 2, 3; 4, 5, 6] then v is successively assigned the column vectors <ref> [1; 4] </ref>, [2; 5], and [3; 6] and i is assigned the values 1, 4, 2, 5, 3, and 6 in that order. 10.7.4 break, next, and return expressions return [ expression ] break [ expression ] next The return expression may be used to return a value from a function. <p> the following: Element - unsigned number; /* this element's global number */ Node node [ ]; /* array of pointers to element's nodes */ Matrix K; /* element stiffness matrix */ Definition definition; /* definition structure (type) of element */ Material material; /* pointer to material property */ Distributed distributed <ref> [4] </ref>; /* array of distributed loads */ unsigned numdistributed; /* number of distributed loads assigned */ Stress stress [ ]; /* element stresses */ unsigned ninteg; /* number of integration points */ - Several of these members are structures themselves: Node, Matrix, Distributed, Definition, Material and Stress are other structures used <p> VarExpr force [7]; /* force vector */ VarExpr spectrum [7]; /* vector of input spectra */ - *Force; /* A constraint */ typedef struct constraint - char *name; /* name of constraint */ char constraint [7]; /* constraint vector */ double ix [7]; /* initial displacement vector */ double ax <ref> [4] </ref>; /* initial acceleration vector */ double vx [4]; /* initial velocity vector */ VarExpr dx [7]; /* boundary displacement vector */ - *Constraint; /* A material */ typedef struct material - char *name; /* name of material */ double E; /* Young's modulus */ double Ix; /* moment of inertia <p> spectrum [7]; /* vector of input spectra */ - *Force; /* A constraint */ typedef struct constraint - char *name; /* name of constraint */ char constraint [7]; /* constraint vector */ double ix [7]; /* initial displacement vector */ double ax <ref> [4] </ref>; /* initial acceleration vector */ double vx [4]; /* initial velocity vector */ VarExpr dx [7]; /* boundary displacement vector */ - *Constraint; /* A material */ typedef struct material - char *name; /* name of material */ double E; /* Young's modulus */ double Ix; /* moment of inertia about x-x axis */ double Iy; /* moment <p> This is a very simple element. We only consider bending and shear deformation (no axial stiffness is taken into account) and we don't allow distributed loads applied in the global DOF. For some basic mathematical details for this element refer to section 4.2.3. More details are available in <ref> [4, 10, 15] </ref>. In general, all the code for a given element type will be contained in one source file. Hopefully the routines in this file will be completely specific to that element type. In a perfect world, common functionality would be available as convenience functions. <p> We need to * do a transformation to get them into local coordinates. */ VectorData (d) [1] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [2] = element -&gt; node [1] -&gt; dx [Ty]; VectorData (d) [3] = element -&gt; node [1] -&gt; dx [Rz]; VectorData (d) <ref> [4] </ref> = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [5] = element -&gt; node [2] -&gt; dx [Ty]; VectorData (d) [6] = element -&gt; node [2] -&gt; dx [Rz]; T = TransformMatrix (element); MultiplyMatrices (dlocal, T, d); /* * We already have the element stiffness matrix because we * <p> look at. */ MultiplyMatrices (eq_global, Tt, equiv); element -&gt; node [1] -&gt; eq_force [Tx] += VectorData (eq_global) [1]; element -&gt; node [1] -&gt; eq_force [Ty] += VectorData (eq_global) [2]; element -&gt; node [1] -&gt; eq_force [Rz] += VectorData (eq_global) [3]; element -&gt; node [2] -&gt; eq_force [Tx] += VectorData (eq_global) <ref> [4] </ref>; element -&gt; node [2] -&gt; eq_force [Ty] += VectorData (eq_global) [5]; element -&gt; node [2] -&gt; eq_force [Rz] += VectorData (eq_global) [6]; return 0; - Now that we have written the source file timoshenko.c in the directory lib/Elements we need to change the OBJS= line in Makefile in this directory
Reference: [5] <author> J.A. George. </author> <title> Computer implementation of the finite element method. </title> <type> Technical Report Tech. Rep. </type> <institution> STAN-CS-71-208, Computer Science Department, Stanford University, Stanford, </institution> <address> CA, </address> <year> 1971. </year>
Reference-contexts: have complete command-line editing and history, as in bash. (A complete discussion of the editing capabilities can be found in the documentation of the readline library.) At the prompt, you can enter expressions to be evaluated. [1] 1 + 2 [2] write (1 + 2) 3 [4] write (a) 3 <ref> [5] </ref> write ([1, 2, 3]) 1 2 3 [6] write ([1; 2; 3]) 1 3 [7] write ([1, 2, 3] + [4, 5, 6]) 5 7 9 As illustrated above, write () is used to print results and = is the assignment operator. <p> documentation of the readline library.) At the prompt, you can enter expressions to be evaluated. [1] 1 + 2 [2] write (1 + 2) 3 [4] write (a) 3 [5] write ([1, 2, 3]) 1 2 3 [6] write ([1; 2; 3]) 1 3 [7] write ([1, 2, 3] + <ref> [4, 5, 6] </ref>) 5 7 9 As illustrated above, write () is used to print results and = is the assignment operator. Also notice from the first expression that burlap does not print the result of every expression like matlab does. <p> For example, constraint is the field name for accessing the constraint object assigned to a node with the constraint= syntax in the FElt file. [2] write (nodes) array of node [3] write (elements) array of element [4] write (nodes (1)) node (1) <ref> [5] </ref> write (nodes (1).constraint) constraint (free) [6] write (elements (1).material.A) 0.0004 [7] m = elements (1).material [8] write ("A = ", m.A, " E = ", m.E) A = 0.0004 E = 2.1e+11 9.3.1 Element objects Elements have the same field names as those used in the FElt file with additional <p> Variable names are a sequence of letters, digits, and the underscore character. Finally, comments are enclosed within /* */; a pound sign (#) may also be used to indicate a comment until the end of the current line. [1] a = 3.14159 [2] b = "hello" [3] c = <ref> [1, 2, 3; 4, 5, 6] </ref> [4] write (a) 3.14159 [5] write (b) hello [6] write (c) 1 2 3 The following sections discuss the operators and functions of burlap in detail. <p> Finally, comments are enclosed within /* */; a pound sign (#) may also be used to indicate a comment until the end of the current line. [1] a = 3.14159 [2] b = "hello" [3] c = [1, 2, 3; 4, 5, 6] [4] write (a) 3.14159 <ref> [5] </ref> write (b) hello [6] write (c) 1 2 3 The following sections discuss the operators and functions of burlap in detail. They are intended to be the definitive word on the semantics of the operators, functions, matrix formers, etc. 130 10.1. <p> In particular, a semicolon is inserted at the end of a line in interactive mode when the last literal or operator on the line can end an expression. [1] a = [1, 2, 3 [3] write (a) 1 2 3 [4] a = [1, 2, 3 + <ref> [5] </ref> write (a) 1 2 7 5 6 Note that since an expression cannot end with +, the next line is taken to be a continuation of the previous line. A matrix element may be an arbitrary expression; however, all expressions on the same row must have the same height. <p> A matrix element may be an arbitrary expression; however, all expressions on the same row must have the same height. Additionally, all rows must have the same number of columns. 132 CHAPTER 10. THE BURLAP SYNTAX [1] x = 1 [3] write (a) 0 1 2 <ref> [5] </ref> write (b) 0 1 2 [6] write ([b, b]) 0 1 2 0 1 2 [7] write ([b, a]) stdin:7: inconsistent number of rows 10.2 Variables Variables are named by a sequence of letters, digits, the underscore character, and the question mark symbol. <p> A line can be explicitly continued by ending the line with a backslash character. [1] write ("hello"); write ("there") hello there [2] a = 1 + [3] write (a) 6 4&gt; + 2 <ref> [5] </ref> write (b) 3 [7] 4, 5, 6] [8] write (x) 1 2 3 Although these semantics may sound complicated, they are designed so that 99.9% of the time you don't need to worry about when to add a semicolon. <p> " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = <ref> [1, 2, 3; 4, 5, 6] </ref> [11] write (a) 1 2 3 [12] a (1, 2) = 0 [13] write (a) 1 0 3 10.4.3 Logical or operator x or y; x || y The logical or operator has two equivalent forms and groups from left-to-right. <p> Type table for the logical or operator. [1] write (1 &lt; 2 or 5 &gt; 6) 1 [2] write (1 &gt; 2 or 5 &gt; 6) 0 [3] write (1 or 1 / 0) 1 [4] write (0 or 1 / 0) stdin:4: exception in expression: right division by zero <ref> [5] </ref> a = [1, 2, 3] [6] write (a or 1) stdin:6: type error in expression: matrix in conditional context [7] write (any? (a) or 1) 1 10.4.4 Logical and operator x and y; x && y The logical and operator has two equivalent forms and groups from left-to-right. <p> When comparing two matrices, their dimensions must be identical. [1] write ([1, 2, 3] == 2) 0 1 0 [2] write (2 != [1, 2, 3]) 1 0 1 [3] write ([1, 2, 3] == [3, 2, 3]) 0 1 1 [4] write ("hello" == "hello") 1 <ref> [5] </ref> write ("hello" == "there") 0 [6] write (nodes (1) == nodes (1)) 1 [7] write (nodes (1) == elements (1)) stdin:7: type error in expression: node == element 10.4. <p> Also, two matrices must have identical dimensions for addition or sub traction. [1] write (1 + 2) 3 [2] write (1 + [2, 3, 4]) 3 4 5 [3] write ([3, 4, 5] - 1) 2 3 4 [4] write ([1, 2] + [3, 4]) 4 6 <ref> [5] </ref> write ([1, 2, 3] + [4, 5]) stdin:5: size mismatch in expression: (1 x 3) + (1 x 2) 10.4.9 Multiplicative operators X * Y X " Y 142 CHAPTER 10. <p> must have identical dimensions for addition or sub traction. [1] write (1 + 2) 3 [2] write (1 + [2, 3, 4]) 3 4 5 [3] write ([3, 4, 5] - 1) 2 3 4 [4] write ([1, 2] + [3, 4]) 4 6 [5] write ([1, 2, 3] + <ref> [4, 5] </ref>) stdin:5: size mismatch in expression: (1 x 3) + (1 x 2) 10.4.9 Multiplicative operators X * Y X " Y 142 CHAPTER 10. <p> In matrix multiplication the inner dimensions must agree. [1] write (2 * 3) 6 [2] write (2 * [1, 2, 3]) 2 4 6 [3] write ([1, 2, 3] * [1; 2; 3]) 14 [4] write ([1; 2; 3] * [1, 2, 3]) 1 2 3 3 6 9 <ref> [5] </ref> write ([1, 2] * [3, 4]) stdin:5: size mismatch in expression: (1 x 2) * (1 x 2) burlap supports two forms of division: left division and right division. The right division of X and Y is (approximately) equivalent to multiplying X by the inverse of Y . <p> number of columns of X must equal the number of rows of Y . [1] write (2 " 1) 0.5 [2] write (0 " 1) stdin:2: exception in expression: left division by zero [3] write (10 " [1, 2, 3]) 0.1 0.2 0.3 [4] write ([1, 2; 3, 4] " <ref> [5, 6] </ref>) stdin:4: size mismatch in expression: (2 x 2) " (1 x 2) [5] write ([1, 2; 3, 4] " [5; 6]) -4 Finally, burlap also supports a remainder operation as shown in Table 10.11. <p> [1] write (2 " 1) 0.5 [2] write (0 " 1) stdin:2: exception in expression: left division by zero [3] write (10 " [1, 2, 3]) 0.1 0.2 0.3 [4] write ([1, 2; 3, 4] " [5, 6]) stdin:4: size mismatch in expression: (2 x 2) " (1 x 2) <ref> [5] </ref> write ([1, 2; 3, 4] " [5; 6]) -4 Finally, burlap also supports a remainder operation as shown in Table 10.11. <p> write (0 " 1) stdin:2: exception in expression: left division by zero [3] write (10 " [1, 2, 3]) 0.1 0.2 0.3 [4] write ([1, 2; 3, 4] " [5, 6]) stdin:4: size mismatch in expression: (2 x 2) " (1 x 2) [5] write ([1, 2; 3, 4] " <ref> [5; 6] </ref>) -4 Finally, burlap also supports a remainder operation as shown in Table 10.11. <p> However, if X is a vector then X (i) is its ith element. Since a scalar is a matrix with one row and one column, it may also be indexed. [1] A = <ref> [1, 2, 3; 4, 5, 6] </ref> [3] y = [1, 2, 3] [4] write (A) 1 2 3 10.4. <p> Since a scalar is a matrix with one row and one column, it may also be indexed. [1] A = [1, 2, 3; 4, 5, 6] [3] y = [1, 2, 3] [4] write (A) 1 2 3 10.4. OPERATORS 147 <ref> [5] </ref> write (A (2)) 2 [6] write (A (2,3)) 6 [7] write (x) 1 3 [8] write (x (2)) 2 [9] write (y) 1 2 3 [10] write (y (1)) 1 [11] write (A (:,[2,3])) 2 3 Thus, there is some ambiguity in using X (i) since if X is a <p> If x is simply 3 then v is simply 3 and i is also 3. If x is the vector [1, 2, 3] then v is successively assigned 1, 2, and 3 and i is simply assigned each value of v. If x is the matrix <ref> [1, 2, 3; 4, 5, 6] </ref> then v is successively assigned the column vectors [1; 4], [2; 5], and [3; 6] and i is assigned the values 1, 4, 2, 5, 3, and 6 in that order. 10.7.4 break, next, and return expressions return [ expression ] break [ expression ] <p> If x is the vector [1, 2, 3] then v is successively assigned 1, 2, and 3 and i is simply assigned each value of v. If x is the matrix [1, 2, 3; 4, 5, 6] then v is successively assigned the column vectors [1; 4], <ref> [2; 5] </ref>, and [3; 6] and i is assigned the values 1, 4, 2, 5, 3, and 6 in that order. 10.7.4 break, next, and return expressions return [ expression ] break [ expression ] next The return expression may be used to return a value from a function. <p> The one that we use in FElt is popularly known as Gibbs-King [6], the profile reduction variant of the Gibbs-Poole-Stockmeyer algorithm [7] which primarily tries to minimize bandwidth. Other popular algorithms include Cuthill-Mckee [3] and Reverse Cuthill-McKee <ref> [5] </ref>. 11.4.3 Assembling the global stiffness matrix This step of the process in FElt actually accomplishes three things. For each element, this routine calls an element setup routine based on element type. <p> into local coordinates. */ VectorData (d) [1] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [2] = element -&gt; node [1] -&gt; dx [Ty]; VectorData (d) [3] = element -&gt; node [1] -&gt; dx [Rz]; VectorData (d) [4] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) <ref> [5] </ref> = element -&gt; node [2] -&gt; dx [Ty]; VectorData (d) [6] = element -&gt; node [2] -&gt; dx [Rz]; T = TransformMatrix (element); MultiplyMatrices (dlocal, T, d); /* * We already have the element stiffness matrix because we * set element -&gt; retainK = 1 in the definition structure. <p> -&gt; eq_force [Tx] += VectorData (eq_global) [1]; element -&gt; node [1] -&gt; eq_force [Ty] += VectorData (eq_global) [2]; element -&gt; node [1] -&gt; eq_force [Rz] += VectorData (eq_global) [3]; element -&gt; node [2] -&gt; eq_force [Tx] += VectorData (eq_global) [4]; element -&gt; node [2] -&gt; eq_force [Ty] += VectorData (eq_global) <ref> [5] </ref>; element -&gt; node [2] -&gt; eq_force [Rz] += VectorData (eq_global) [6]; return 0; - Now that we have written the source file timoshenko.c in the directory lib/Elements we need to change the OBJS= line in Makefile in this directory to include our new file.
Reference: [6] <author> Norman E. Gibbs. </author> <title> A hybrid profile reduction algorithm. </title> <journal> Assoc. for Computing Machinery Trans. on Math. Software, </journal> <volume> 2 </volume> <pages> 378-387, </pages> <year> 1976. </year>
Reference-contexts: bash. (A complete discussion of the editing capabilities can be found in the documentation of the readline library.) At the prompt, you can enter expressions to be evaluated. [1] 1 + 2 [2] write (1 + 2) 3 [4] write (a) 3 [5] write ([1, 2, 3]) 1 2 3 <ref> [6] </ref> write ([1; 2; 3]) 1 3 [7] write ([1, 2, 3] + [4, 5, 6]) 5 7 9 As illustrated above, write () is used to print results and = is the assignment operator. <p> documentation of the readline library.) At the prompt, you can enter expressions to be evaluated. [1] 1 + 2 [2] write (1 + 2) 3 [4] write (a) 3 [5] write ([1, 2, 3]) 1 2 3 [6] write ([1; 2; 3]) 1 3 [7] write ([1, 2, 3] + <ref> [4, 5, 6] </ref>) 5 7 9 As illustrated above, write () is used to print results and = is the assignment operator. Also notice from the first expression that burlap does not print the result of every expression like matlab does. <p> For example, constraint is the field name for accessing the constraint object assigned to a node with the constraint= syntax in the FElt file. [2] write (nodes) array of node [3] write (elements) array of element [4] write (nodes (1)) node (1) [5] write (nodes (1).constraint) constraint (free) <ref> [6] </ref> write (elements (1).material.A) 0.0004 [7] m = elements (1).material [8] write ("A = ", m.A, " E = ", m.E) A = 0.0004 E = 2.1e+11 9.3.1 Element objects Elements have the same field names as those used in the FElt file with additional fields for holding the computed matrices <p> Variable names are a sequence of letters, digits, and the underscore character. Finally, comments are enclosed within /* */; a pound sign (#) may also be used to indicate a comment until the end of the current line. [1] a = 3.14159 [2] b = "hello" [3] c = <ref> [1, 2, 3; 4, 5, 6] </ref> [4] write (a) 3.14159 [5] write (b) hello [6] write (c) 1 2 3 The following sections discuss the operators and functions of burlap in detail. <p> comments are enclosed within /* */; a pound sign (#) may also be used to indicate a comment until the end of the current line. [1] a = 3.14159 [2] b = "hello" [3] c = [1, 2, 3; 4, 5, 6] [4] write (a) 3.14159 [5] write (b) hello <ref> [6] </ref> write (c) 1 2 3 The following sections discuss the operators and functions of burlap in detail. They are intended to be the definitive word on the semantics of the operators, functions, matrix formers, etc. 130 10.1. <p> Additionally, all rows must have the same number of columns. 132 CHAPTER 10. THE BURLAP SYNTAX [1] x = 1 [3] write (a) 0 1 2 [5] write (b) 0 1 2 <ref> [6] </ref> write ([b, b]) 0 1 2 0 1 2 [7] write ([b, a]) stdin:7: inconsistent number of rows 10.2 Variables Variables are named by a sequence of letters, digits, the underscore character, and the question mark symbol. A variable must begin with a letter or the underscore character. <p> Some fields are also read-only, such as the name of a constraint or the number of a node or element. [1] a = [1, 2, 3] [2] write (a) 1 2 3 [4] write (a, " ", b) 0 0 <ref> [6] </ref> write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = [1, 2, 3; 4, 5, 6] <p> " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = <ref> [1, 2, 3; 4, 5, 6] </ref> [11] write (a) 1 2 3 [12] a (1, 2) = 0 [13] write (a) 1 0 3 10.4.3 Logical or operator x or y; x || y The logical or operator has two equivalent forms and groups from left-to-right. <p> operator. [1] write (1 &lt; 2 or 5 &gt; 6) 1 [2] write (1 &gt; 2 or 5 &gt; 6) 0 [3] write (1 or 1 / 0) 1 [4] write (0 or 1 / 0) stdin:4: exception in expression: right division by zero [5] a = [1, 2, 3] <ref> [6] </ref> write (a or 1) stdin:6: type error in expression: matrix in conditional context [7] write (any? (a) or 1) 1 10.4.4 Logical and operator x and y; x && y The logical and operator has two equivalent forms and groups from left-to-right. <p> matrices, their dimensions must be identical. [1] write ([1, 2, 3] == 2) 0 1 0 [2] write (2 != [1, 2, 3]) 1 0 1 [3] write ([1, 2, 3] == [3, 2, 3]) 0 1 1 [4] write ("hello" == "hello") 1 [5] write ("hello" == "there") 0 <ref> [6] </ref> write (nodes (1) == nodes (1)) 1 [7] write (nodes (1) == elements (1)) stdin:7: type error in expression: node == element 10.4. <p> number of columns of X must equal the number of rows of Y . [1] write (2 " 1) 0.5 [2] write (0 " 1) stdin:2: exception in expression: left division by zero [3] write (10 " [1, 2, 3]) 0.1 0.2 0.3 [4] write ([1, 2; 3, 4] " <ref> [5, 6] </ref>) stdin:4: size mismatch in expression: (2 x 2) " (1 x 2) [5] write ([1, 2; 3, 4] " [5; 6]) -4 Finally, burlap also supports a remainder operation as shown in Table 10.11. <p> write (0 " 1) stdin:2: exception in expression: left division by zero [3] write (10 " [1, 2, 3]) 0.1 0.2 0.3 [4] write ([1, 2; 3, 4] " [5, 6]) stdin:4: size mismatch in expression: (2 x 2) " (1 x 2) [5] write ([1, 2; 3, 4] " <ref> [5; 6] </ref>) -4 Finally, burlap also supports a remainder operation as shown in Table 10.11. <p> However, if X is a vector then X (i) is its ith element. Since a scalar is a matrix with one row and one column, it may also be indexed. [1] A = <ref> [1, 2, 3; 4, 5, 6] </ref> [3] y = [1, 2, 3] [4] write (A) 1 2 3 10.4. <p> Since a scalar is a matrix with one row and one column, it may also be indexed. [1] A = [1, 2, 3; 4, 5, 6] [3] y = [1, 2, 3] [4] write (A) 1 2 3 10.4. OPERATORS 147 [5] write (A (2)) 2 <ref> [6] </ref> write (A (2,3)) 6 [7] write (x) 1 3 [8] write (x (2)) 2 [9] write (y) 1 2 3 [10] write (y (1)) 1 [11] write (A (:,[2,3])) 2 3 Thus, there is some ambiguity in using X (i) since if X is a column vector then the result <p> Is X a matrix? scalar? (X) Is X a scalar? symmetric? (X) Is X a symmetric matrix? Table 10.17: Predicate functions available in burlap. [1] x = [1, 2, 3] [3] write (scalar? (x), " ", scalar? (y)) 0 1 [4] write (matrix? (x), " ", matrix? (y)) 1 0 <ref> [6] </ref> write (symmetric? (z), " ", compact? (z)) 1 0 [7] write (compact? (compact (z))) 1 10.5.4 Finite element functions The finite element functions provide an interface to the functions in the FElt library. <p> If x is simply 3 then v is simply 3 and i is also 3. If x is the vector [1, 2, 3] then v is successively assigned 1, 2, and 3 and i is simply assigned each value of v. If x is the matrix <ref> [1, 2, 3; 4, 5, 6] </ref> then v is successively assigned the column vectors [1; 4], [2; 5], and [3; 6] and i is assigned the values 1, 4, 2, 5, 3, and 6 in that order. 10.7.4 break, next, and return expressions return [ expression ] break [ expression ] <p> If x is the matrix [1, 2, 3; 4, 5, 6] then v is successively assigned the column vectors [1; 4], [2; 5], and <ref> [3; 6] </ref> and i is assigned the values 1, 4, 2, 5, 3, and 6 in that order. 10.7.4 break, next, and return expressions return [ expression ] break [ expression ] next The return expression may be used to return a value from a function. <p> There are numerous algorithms available to try to optimize node numbering with just such a goal in mind. The one that we use in FElt is popularly known as Gibbs-King <ref> [6] </ref>, the profile reduction variant of the Gibbs-Poole-Stockmeyer algorithm [7] which primarily tries to minimize bandwidth. Other popular algorithms include Cuthill-Mckee [3] and Reverse Cuthill-McKee [5]. 11.4.3 Assembling the global stiffness matrix This step of the process in FElt actually accomplishes three things. <p> [1] -&gt; dx [Tx]; VectorData (d) [2] = element -&gt; node [1] -&gt; dx [Ty]; VectorData (d) [3] = element -&gt; node [1] -&gt; dx [Rz]; VectorData (d) [4] = element -&gt; node [1] -&gt; dx [Tx]; VectorData (d) [5] = element -&gt; node [2] -&gt; dx [Ty]; VectorData (d) <ref> [6] </ref> = element -&gt; node [2] -&gt; dx [Rz]; T = TransformMatrix (element); MultiplyMatrices (dlocal, T, d); /* * We already have the element stiffness matrix because we * set element -&gt; retainK = 1 in the definition structure. <p> -&gt; eq_force [Ty] += VectorData (eq_global) [2]; element -&gt; node [1] -&gt; eq_force [Rz] += VectorData (eq_global) [3]; element -&gt; node [2] -&gt; eq_force [Tx] += VectorData (eq_global) [4]; element -&gt; node [2] -&gt; eq_force [Ty] += VectorData (eq_global) [5]; element -&gt; node [2] -&gt; eq_force [Rz] += VectorData (eq_global) <ref> [6] </ref>; return 0; - Now that we have written the source file timoshenko.c in the directory lib/Elements we need to change the OBJS= line in Makefile in this directory to include our new file.
Reference: [7] <author> Norman E. Gibbs, William G. Poole, and Paul K. Stockmeyer. </author> <title> An algorithm for reducing the bandwidth and profile of a sparse matrix. </title> <journal> SIAM Journal of Numerical Analysis, </journal> <volume> 13 </volume> <pages> 236-249, </pages> <year> 1976. </year>
Reference-contexts: capabilities can be found in the documentation of the readline library.) At the prompt, you can enter expressions to be evaluated. [1] 1 + 2 [2] write (1 + 2) 3 [4] write (a) 3 [5] write ([1, 2, 3]) 1 2 3 [6] write ([1; 2; 3]) 1 3 <ref> [7] </ref> write ([1, 2, 3] + [4, 5, 6]) 5 7 9 As illustrated above, write () is used to print results and = is the assignment operator. Also notice from the first expression that burlap does not print the result of every expression like matlab does. <p> is the field name for accessing the constraint object assigned to a node with the constraint= syntax in the FElt file. [2] write (nodes) array of node [3] write (elements) array of element [4] write (nodes (1)) node (1) [5] write (nodes (1).constraint) constraint (free) [6] write (elements (1).material.A) 0.0004 <ref> [7] </ref> m = elements (1).material [8] write ("A = ", m.A, " E = ", m.E) A = 0.0004 E = 2.1e+11 9.3.1 Element objects Elements have the same field names as those used in the FElt file with additional fields for holding the computed matrices and stress values, as shown <p> Additionally, all rows must have the same number of columns. 132 CHAPTER 10. THE BURLAP SYNTAX [1] x = 1 [3] write (a) 0 1 2 [5] write (b) 0 1 2 [6] write ([b, b]) 0 1 2 0 1 2 <ref> [7] </ref> write ([b, a]) stdin:7: inconsistent number of rows 10.2 Variables Variables are named by a sequence of letters, digits, the underscore character, and the question mark symbol. A variable must begin with a letter or the underscore character. <p> A line can be explicitly continued by ending the line with a backslash character. [1] write ("hello"); write ("there") hello there [2] a = 1 + [3] write (a) 6 4&gt; + 2 [5] write (b) 3 <ref> [7] </ref> 4, 5, 6] [8] write (x) 1 2 3 Although these semantics may sound complicated, they are designed so that 99.9% of the time you don't need to worry about when to add a semicolon. <p> Some fields are also read-only, such as the name of a constraint or the number of a node or element. [1] a = [1, 2, 3] [2] write (a) 1 2 3 [4] write (a, " ", b) 0 0 [6] write (a, " ", b) 3 2 <ref> [7] </ref> nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = [1, 2, 3; 4, 5, 6] [11] write (a) 1 2 3 [12] a <p> &gt; 2 or 5 &gt; 6) 0 [3] write (1 or 1 / 0) 1 [4] write (0 or 1 / 0) stdin:4: exception in expression: right division by zero [5] a = [1, 2, 3] [6] write (a or 1) stdin:6: type error in expression: matrix in conditional context <ref> [7] </ref> write (any? (a) or 1) 1 10.4.4 Logical and operator x and y; x && y The logical and operator has two equivalent forms and groups from left-to-right. It returns 1 if both of its operands compare unequal to zero, and 0 otherwise. <p> ([1, 2, 3] == 2) 0 1 0 [2] write (2 != [1, 2, 3]) 1 0 1 [3] write ([1, 2, 3] == [3, 2, 3]) 0 1 1 [4] write ("hello" == "hello") 1 [5] write ("hello" == "there") 0 [6] write (nodes (1) == nodes (1)) 1 <ref> [7] </ref> write (nodes (1) == elements (1)) stdin:7: type error in expression: node == element 10.4. <p> OPERATORS 147 [5] write (A (2)) 2 [6] write (A (2,3)) 6 <ref> [7] </ref> write (x) 1 3 [8] write (x (2)) 2 [9] write (y) 1 2 3 [10] write (y (1)) 1 [11] write (A (:,[2,3])) 2 3 Thus, there is some ambiguity in using X (i) since if X is a column vector then the result will be its ith element <p> symmetric? (X) Is X a symmetric matrix? Table 10.17: Predicate functions available in burlap. [1] x = [1, 2, 3] [3] write (scalar? (x), " ", scalar? (y)) 0 1 [4] write (matrix? (x), " ", matrix? (y)) 1 0 [6] write (symmetric? (z), " ", compact? (z)) 1 0 <ref> [7] </ref> write (compact? (compact (z))) 1 10.5.4 Finite element functions The finite element functions provide an interface to the functions in the FElt library. The functions can all be written in burlap itself, but the built-in functions will execute faster. add definition (...) Adds a new element definition. <p> stress computation function */ Shape shape; /* element dimensional shape */ unsigned numnodes; /* number of nodes in element */ unsigned shapenodes; /* number of nodes which define shape */ unsigned numstresses; /* number of computed stress values */ unsigned numdofs; /* number of degrees of freedom */ unsigned dofs <ref> [7] </ref>; /* degrees of freedom */ unsigned retainK; /* retain element K after assemblage */ - *Definition; /* A distributed load */ typedef struct distributed - char *name; /* name of distributed load */ Direction direction; /* direction of load */ unsigned nvalues; /* number of values */ Pair value [ <p> ELEMENTARY C PROGRAMMING 169 /* A force */ typedef struct force - char *name; /* name of force */ VarExpr force <ref> [7] </ref>; /* force vector */ VarExpr spectrum [7]; /* vector of input spectra */ - *Force; /* A constraint */ typedef struct constraint - char *name; /* name of constraint */ char constraint [7]; /* constraint vector */ double ix [7]; /* initial displacement vector */ double ax [4]; /* initial <p> ELEMENTARY C PROGRAMMING 169 /* A force */ typedef struct force - char *name; /* name of force */ VarExpr force <ref> [7] </ref>; /* force vector */ VarExpr spectrum [7]; /* vector of input spectra */ - *Force; /* A constraint */ typedef struct constraint - char *name; /* name of constraint */ char constraint [7]; /* constraint vector */ double ix [7]; /* initial displacement vector */ double ax [4]; /* initial acceleration vector */ double vx [4]; /* <p> /* A force */ typedef struct force - char *name; /* name of force */ VarExpr force <ref> [7] </ref>; /* force vector */ VarExpr spectrum [7]; /* vector of input spectra */ - *Force; /* A constraint */ typedef struct constraint - char *name; /* name of constraint */ char constraint [7]; /* constraint vector */ double ix [7]; /* initial displacement vector */ double ax [4]; /* initial acceleration vector */ double vx [4]; /* initial velocity vector */ VarExpr dx [7]; /* boundary displacement vector */ - *Constraint; /* A material */ typedef struct material - char *name; /* name <p> - char *name; /* name of force */ VarExpr force <ref> [7] </ref>; /* force vector */ VarExpr spectrum [7]; /* vector of input spectra */ - *Force; /* A constraint */ typedef struct constraint - char *name; /* name of constraint */ char constraint [7]; /* constraint vector */ double ix [7]; /* initial displacement vector */ double ax [4]; /* initial acceleration vector */ double vx [4]; /* initial velocity vector */ VarExpr dx [7]; /* boundary displacement vector */ - *Constraint; /* A material */ typedef struct material - char *name; /* name of material */ double E; /* Young's <p> - *Force; /* A constraint */ typedef struct constraint - char *name; /* name of constraint */ char constraint <ref> [7] </ref>; /* constraint vector */ double ix [7]; /* initial displacement vector */ double ax [4]; /* initial acceleration vector */ double vx [4]; /* initial velocity vector */ VarExpr dx [7]; /* boundary displacement vector */ - *Constraint; /* A material */ typedef struct material - char *name; /* name of material */ double E; /* Young's modulus */ double Ix; /* moment of inertia about x-x axis */ double Iy; /* moment of inertia about y-y axis */ double Iz; <p> THE ALGORITHMS BEHIND FELT typedef struct node - unsigned number; /* node number */ Constraint constraint; /* constrained degrees of freedom */ Force force; /* force acting on node */ double m; /* lumped mass at this node */ double eq_force [ ]; /* equivalent force */ double dx <ref> [7] </ref>; /* displacement */ double x; /* x coordinate */ double y; /* y coordinate */ double z; /* z coordinate */ - *Node; Hopefully the organization of the data structures is intuitive enough to someone familiar with finite elements that a detailed understanding of the mechanics of the C language <p> There are numerous algorithms available to try to optimize node numbering with just such a goal in mind. The one that we use in FElt is popularly known as Gibbs-King [6], the profile reduction variant of the Gibbs-Poole-Stockmeyer algorithm <ref> [7] </ref> which primarily tries to minimize bandwidth. Other popular algorithms include Cuthill-Mckee [3] and Reverse Cuthill-McKee [5]. 11.4.3 Assembling the global stiffness matrix This step of the process in FElt actually accomplishes three things. For each element, this routine calls an element setup routine based on element type. <p> stress computation function */ Shape shape; /* element dimensional shape */ unsigned numnodes; /* number of nodes in element */ unsigned shapenodes; /* number of nodes which define shape */ unsigned numstresses; /* number of computed stress values */ unsigned numdofs; /* number of degrees of freedom */ unsigned dofs <ref> [7] </ref>; /* degrees of freedom */ unsigned retainK; /* retain element K after assemblage */ - *Definition; For an arbitrary element, foo, the definition structure might be filled out to look something like this: struct definition fooDefinition = - "foo", fooEltSetup, fooEltStress, 12.2. <p> Besides the general finite element type data structures, FElt makes available a Matrix and a Vector type. Because these types are really structures, a reliable way to get at the data is MatrixData (a) [1][1] or VectorData (a) <ref> [7] </ref>. These macros simply expand to a -&gt; data [1][1] and a -&gt; data [7][1]. The macro method is preferrable simply because the actual definition of the types may change as FElt develops and the macros will make any such changes transparent.
Reference: [8] <author> Ernest Hinton and D. R. J. Owen. </author> <title> Finite Element Programming. </title> <publisher> Academic Press, </publisher> <year> 1977. </year>
Reference-contexts: accessing the constraint object assigned to a node with the constraint= syntax in the FElt file. [2] write (nodes) array of node [3] write (elements) array of element [4] write (nodes (1)) node (1) [5] write (nodes (1).constraint) constraint (free) [6] write (elements (1).material.A) 0.0004 [7] m = elements (1).material <ref> [8] </ref> write ("A = ", m.A, " E = ", m.E) A = 0.0004 E = 2.1e+11 9.3.1 Element objects Elements have the same field names as those used in the FElt file with additional fields for holding the computed matrices and stress values, as shown in Table 9.2. <p> A line can be explicitly continued by ending the line with a backslash character. [1] write ("hello"); write ("there") hello there [2] a = 1 + [3] write (a) 6 4&gt; + 2 [5] write (b) 3 [7] 4, 5, 6] <ref> [8] </ref> write (x) 1 2 3 Although these semantics may sound complicated, they are designed so that 99.9% of the time you don't need to worry about when to add a semicolon. <p> or the number of a node or element. [1] a = [1, 2, 3] [2] write (a) 1 2 3 [4] write (a, " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable <ref> [8] </ref> nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = [1, 2, 3; 4, 5, 6] [11] write (a) 1 2 3 [12] a (1, 2) = 0 [13] write (a) 1 0 3 10.4.3 Logical or operator <p> OPERATORS 147 [5] write (A (2)) 2 [6] write (A (2,3)) 6 [7] write (x) 1 3 <ref> [8] </ref> write (x (2)) 2 [9] write (y) 1 2 3 [10] write (y (1)) 1 [11] write (A (:,[2,3])) 2 3 Thus, there is some ambiguity in using X (i) since if X is a column vector then the result will be its ith element and if X is a <p> Texts that have been recommended, but that we have not really worked with include Segerlind [14], a very well-recommended introductory text by Burnett [1] and a book by Hinton and Owen <ref> [8] </ref>. 11.2 Elementary C programming The advantages to coding FElt entirely in C rather than the more traditional (at least for finite element analysis) choice of Fortran are: 1. keeping the package consistent the system and graphical interface stuff required working in C, having all of the mathematics in C made
Reference: [9] <author> Thomas J. R. Hughes. </author> <title> The Finite Element Method: Linear Static and Dynamic Finite Element Analysis. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1987. </year>
Reference-contexts: There is of course some very basic information on just how these models work in the context of FEA, but we really do suggest that you try some of the excellent textbooks ( <ref> [9, 16, 13, 1, 14] </ref>) that are out there if you want any sort of real background information. 2.2 Static structural analysis The basic equation for static structural analysis can be seen as a generalization of Hooke's law for the deformation of a linear spring, f = kx. <p> node or element. [1] a = [1, 2, 3] [2] write (a) 1 2 3 [4] write (a, " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 <ref> [9] </ref> nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = [1, 2, 3; 4, 5, 6] [11] write (a) 1 2 3 [12] a (1, 2) = 0 [13] write (a) 1 0 3 10.4.3 Logical or operator x or y; x || <p> OPERATORS 147 [5] write (A (2)) 2 [6] write (A (2,3)) 6 [7] write (x) 1 3 [8] write (x (2)) 2 <ref> [9] </ref> write (y) 1 2 3 [10] write (y (1)) 1 [11] write (A (:,[2,3])) 2 3 Thus, there is some ambiguity in using X (i) since if X is a column vector then the result will be its ith element and if X is a matrix then the result will <p> So why is it that good books on computational techniques are hard to come by and good books on the underlying theory and mathematics abound? Go figure. As we mentioned in chapter 2, if you need some references to the latter we like Hughes' <ref> [9] </ref> and Zienkiewicz and Taylor's [16] "classic" textbooks. Logan's [13] book is a good introductory text. He approaches the method from the same direction that many of us come to finite elements, through classical matrix structural analysis. <p> Setting ff = 0 reduces the problem to a standard Newmark method. Choosing ff 2 [ 1 3 ; 0], fl = (1 2ff)=2 and fi = (1 ff) 2 =4 results in an unconditionally stable, second-order accurate algorithm <ref> [9] </ref>.
Reference: [10] <author> Thomas J.R. Hughes, Robert L. Taylor, and Worsak Kanoknukulchai. </author> <title> A simple and efficient finite element for plate bending. </title> <booktitle> International Journal for Numerical Methods in Enginerring, </booktitle> <volume> 11 </volume> <pages> 1529-1543, </pages> <year> 1977. </year> <note> 222 BIBLIOGRAPHY 223 </note>
Reference-contexts: It is limited to in-plane behavior and does not support an axial degree of freedom. There are lots of approaches to defining an element using Timoshenko beam theory. Classic examples can be found in <ref> [10, 15] </ref>. The formulation we use is from [4]. <p> The classic reference for this approach is <ref> [10] </ref>. The effect is achieved simply by using one-point Gaussian quadrature to under-integrate the shear contribution to the stiffness where two-point quadrature is used on the bending contributions. htk elements must exist entirely in the x-y plane; the three DOF at each node each represent out of plane deformation. <p> [4] write (a, " ", b) 0 0 [6] write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix <ref> [10] </ref> a = [1, 2, 3; 4, 5, 6] [11] write (a) 1 2 3 [12] a (1, 2) = 0 [13] write (a) 1 0 3 10.4.3 Logical or operator x or y; x || y The logical or operator has two equivalent forms and groups from left-to-right. <p> OPERATORS 147 [5] write (A (2)) 2 [6] write (A (2,3)) 6 [7] write (x) 1 3 [8] write (x (2)) 2 [9] write (y) 1 2 3 <ref> [10] </ref> write (y (1)) 1 [11] write (A (:,[2,3])) 2 3 Thus, there is some ambiguity in using X (i) since if X is a column vector then the result will be its ith element and if X is a matrix then the result will be its ith column. <p> This is a very simple element. We only consider bending and shear deformation (no axial stiffness is taken into account) and we don't allow distributed loads applied in the global DOF. For some basic mathematical details for this element refer to section 4.2.3. More details are available in <ref> [4, 10, 15] </ref>. In general, all the code for a given element type will be contained in one source file. Hopefully the routines in this file will be completely specific to that element type. In a perfect world, common functionality would be available as convenience functions.
Reference: [11] <author> Barry Joe and R. B. Simpson. </author> <title> Triangular meshes for regions of complicated shape. </title> <booktitle> International Journal for Numerical Methods in Enginerring, </booktitle> <volume> 23 </volume> <pages> 751-778, </pages> <year> 1986. </year>
Reference-contexts: Automated element generation for a FElt problem is provided for both simple grids of line, quadrilateral and brick elements and arbitrary meshes of triangular planar elements. The latter capability is derived from Barry Joe's Geompack mesh generation routines <ref> [11] </ref>. You can interface this functionality either graphically through velvet or through a separate command line application called corduroy that has its own input 20 CHAPTER 1. INTRODUCTION TO THE FELT SYSTEM file syntax much like the regular syntax for FElt problems. <p> When triangles are being generated a form will pop-up (Figure 6.12) for you to define the parameters of the generation. The Geompack parameters are best understood either by experimentation or by taking a look at the Geompack references <ref> [11] </ref>. <p> These brief descriptions are also available by clicking on the label next to the text field for each parameter (much like the help for individual material properties in the material dialog). Most of the features of Geompack that are implemented in velvet are described more fully in <ref> [11] </ref>. Geompack is powerful and flexible enough that it can usually generate a good mesh if it is given the right parameters. Once the parameters are defined, click okay to begin defining the boundaries of your problem. <p> start = (0,0,0) end = (8,12,6) x-number = 4 y-number = 6 z-number=3 The result would be a three-dimensional solid region three elements deep, four elements wide, and six elements tall. 8.2.6 Generating a triangular mesh The triangular mesh generation capabilities of corduroy are based on Barry Joe's Ge-ompack routines <ref> [11] </ref>. In addition to specifications that describe the boundary and 108 CHAPTER 8. THE CORDUROY APPLICATION the holes of your two-dimensional region, there are also several numerical parameters which control how Geompack actually generates a mesh. <p> Most of the features of Geompack that are implemented in corduroy are described more fully in <ref> [11] </ref>. The default parameters (shown in the following example, except for min= and max= which have default values of 50 and 100, respectively) can usually produce a good mesh, but they may need some tweaking at times and for maximum flexibility. <p> write (a, " ", b) 3 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = [1, 2, 3; 4, 5, 6] <ref> [11] </ref> write (a) 1 2 3 [12] a (1, 2) = 0 [13] write (a) 1 0 3 10.4.3 Logical or operator x or y; x || y The logical or operator has two equivalent forms and groups from left-to-right. <p> OPERATORS 147 [5] write (A (2)) 2 [6] write (A (2,3)) 6 [7] write (x) 1 3 [8] write (x (2)) 2 [9] write (y) 1 2 3 [10] write (y (1)) 1 <ref> [11] </ref> write (A (:,[2,3])) 2 3 Thus, there is some ambiguity in using X (i) since if X is a column vector then the result will be its ith element and if X is a matrix then the result will be its ith column.
Reference: [12] <author> Brian W. Kernhigan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, </address> <note> second edition, </note> <year> 1989. </year>
Reference-contexts: 2 [7] nodes (1).number = 3 stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = [1, 2, 3; 4, 5, 6] [11] write (a) 1 2 3 <ref> [12] </ref> a (1, 2) = 0 [13] write (a) 1 0 3 10.4.3 Logical or operator x or y; x || y The logical or operator has two equivalent forms and groups from left-to-right. It returns 1 if either of its operands compares unequal to zero, and 0 otherwise. <p> If you're unfamiliar with the C programming language, you should probably start there. You might be able to get away with just hacking something together based on existing elements, but efficiency and elegance will probably suffer. The material in <ref> [12] </ref> is considered by many to be the definitive word on C; you may want to start there. Other good books on C undoubtedly abound. Another simple starting point for C novices would be section 11.2 on understanding the data structures used in FElt. 177 178 CHAPTER 12.
Reference: [13] <author> Daryl L. Logan. </author> <title> A First Course in the Finite Element Method. </title> <address> PWS-Kent, Boston, </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: There is of course some very basic information on just how these models work in the context of FEA, but we really do suggest that you try some of the excellent textbooks ( <ref> [9, 16, 13, 1, 14] </ref>) that are out there if you want any sort of real background information. 2.2 Static structural analysis The basic equation for static structural analysis can be seen as a generalization of Hooke's law for the deformation of a linear spring, f = kx. <p> can read (i.e., the allowable input formats are) DXF files, standard FElt files, and data files formatted for use in graphing applications like gnuplot; patchwork can write (i.e., allowable output formats are) FElt, DXF, gnuplot, and files formatted for the software that is distributed with Logan's introductory finite element text <ref> [13] </ref>. Capabilities for additional formats will be added as time permits and demand warrants. Note that the DXF handling routines are limited to line and polygonal polyline entities. When invoking patchwork, the input format and file always come first. <p> Any introductory text on finite element analysis (for mechanics at least) probably starts out by deriving the stiffness matrix for just such an element; see Chapter 3 of <ref> [13] </ref> for instance. The stiffness matrix for this type of element in the local element two-dimensional reference frame is the familiar ^ k = EA=L EA=L # 46 CHAPTER 4. <p> The lumped formulation includes entries at every DOF (i.e., there is an inertia entry at rotational DOF) just like the two-dimensional beam. The local coordinate system used for the FElt 3-d beam element is based on the element geometry presented in <ref> [13] </ref>. Positive ^x points from node 1 to node 2. Then, ^y is defined by the cross product of z and ^x (global z and local x), i.e., ^y = z fi ^x. ^z is selected such that it is orthogonal to the ^x-^y plane, ^z = ^x fi ^y. <p> stdin:7: type error in expression: changing a read-only variable [8] nodes (1).force.Fx = 4 [9] nodes (1).force.Fy = [1, 2, 3] stdin:9: type error in expression: scalar = matrix [10] a = [1, 2, 3; 4, 5, 6] [11] write (a) 1 2 3 [12] a (1, 2) = 0 <ref> [13] </ref> write (a) 1 0 3 10.4.3 Logical or operator x or y; x || y The logical or operator has two equivalent forms and groups from left-to-right. It returns 1 if either of its operands compares unequal to zero, and 0 otherwise. The 136 CHAPTER 10. <p> As we mentioned in chapter 2, if you need some references to the latter we like Hughes' [9] and Zienkiewicz and Taylor's [16] "classic" textbooks. Logan's <ref> [13] </ref> book is a good introductory text. He approaches the method from the same direction that many of us come to finite elements, through classical matrix structural analysis. He's a bit lean on the mathematical basis and theory, but that's probably why it makes a good introductory text. <p> Logan <ref> [13] </ref> gives the following summary of the methods that result from various choices of ff: ff = 0, simple forward difference scheme which is only conditionally stable; ff = 1 2 Crank-Nicolson or trapezoidal rule which is unconditionally stable; ff = 2 3 , Galerkin which is also unconditionally stable; ff
Reference: [14] <author> Larry J. Segerlind. </author> <title> Applied Finite Element Analysis. </title> <publisher> Wiley, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1986. </year>
Reference-contexts: There is of course some very basic information on just how these models work in the context of FEA, but we really do suggest that you try some of the excellent textbooks ( <ref> [9, 16, 13, 1, 14] </ref>) that are out there if you want any sort of real background information. 2.2 Static structural analysis The basic equation for static structural analysis can be seen as a generalization of Hooke's law for the deformation of a linear spring, f = kx. <p> It is probably our ignorance, but we are not aware of any definitive texts on the algorithmic implementation of the finite element method. Texts that have been recommended, but that we have not really worked with include Segerlind <ref> [14] </ref>, a very well-recommended introductory text by Burnett [1] and a book by Hinton and Owen [8]. 11.2 Elementary C programming The advantages to coding FElt entirely in C rather than the more traditional (at least for finite element analysis) choice of Fortran are: 1. keeping the package consistent the system
Reference: [15] <author> A. Tessler and S.B. Dong. </author> <title> On a hierarchy of conforming Timoshenko beam elements. </title> <journal> Computers and Structures, </journal> <volume> 14 </volume> <pages> 335-344, </pages> <year> 1981. </year>
Reference-contexts: It is limited to in-plane behavior and does not support an axial degree of freedom. There are lots of approaches to defining an element using Timoshenko beam theory. Classic examples can be found in <ref> [10, 15] </ref>. The formulation we use is from [4]. <p> This is a very simple element. We only consider bending and shear deformation (no axial stiffness is taken into account) and we don't allow distributed loads applied in the global DOF. For some basic mathematical details for this element refer to section 4.2.3. More details are available in <ref> [4, 10, 15] </ref>. In general, all the code for a given element type will be contained in one source file. Hopefully the routines in this file will be completely specific to that element type. In a perfect world, common functionality would be available as convenience functions.
Reference: [16] <author> O. C. Zienkiewicz and Robert L. Taylor. </author> <title> The Finite Element Method: Basic Formulations and Linear Problems, volume 1. </title> <publisher> McGraw-Hill, </publisher> <address> London, </address> <note> fourth edition, </note> <year> 1988. </year>
Reference-contexts: There is of course some very basic information on just how these models work in the context of FEA, but we really do suggest that you try some of the excellent textbooks ( <ref> [9, 16, 13, 1, 14] </ref>) that are out there if you want any sort of real background information. 2.2 Static structural analysis The basic equation for static structural analysis can be seen as a generalization of Hooke's law for the deformation of a linear spring, f = kx. <p> So why is it that good books on computational techniques are hard to come by and good books on the underlying theory and mathematics abound? Go figure. As we mentioned in chapter 2, if you need some references to the latter we like Hughes' [9] and Zienkiewicz and Taylor's <ref> [16] </ref> "classic" textbooks. Logan's [13] book is a good introductory text. He approaches the method from the same direction that many of us come to finite elements, through classical matrix structural analysis.
References-found: 16

