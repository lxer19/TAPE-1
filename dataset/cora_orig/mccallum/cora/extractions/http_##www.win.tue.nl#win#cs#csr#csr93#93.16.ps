URL: http://www.win.tue.nl/win/cs/csr/csr93/93.16.ps
Refering-URL: http://www.win.tue.nl/win/cs/csr/csr93.html
Root-URL: http://www.win.tue.nl
Title: A Trace-Based Compositional Proof Theory for Fault Tolerant Distributed Systems  
Author: Henk Schepers Jozef Hooman 
Keyword: Key words: Compositional proof theory, failure hypothesis, fault tolerance, relative network completeness, safety, soundness, specification, verification.  
Address: P.O. Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Department of Mathematics and Computing Science Eindhoven University of Technology  
Abstract: We present a compositional network proof theory to specify and verify safety properties of fault tolerant distributed systems. We abstract from the precise nature and occurrence of faults, but model their effect on the externally visible input and output behaviour. To this end a failure hypothesis is formalized as a relation between the normal behaviour (i.e. the behaviour when no faults occur) of a system and its acceptable behaviour, that is, the normal behaviour together with the exceptional behaviour (i.e. the behaviour whose abnormality should be tolerated). The method is compositional to allow reasoning with the specifications of processes while ignoring their implementation details. A compositional formalism to reason about the normal behaviour is extended with a single rule by which a specification of the acceptable behaviour can be obtained from the specification of the normal behaviour and a predicate characterizing the failure hypothesis. Soundness and relative network completeness are proved. Our approach is illustrated by applying it to a triple modular redundant system and the alternating bit protocol. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Lamport, </author> <title> An old-fashioned recipe for real time, </title> <booktitle> in: Proc. REX Workshop on Real-Time: Theory in Practice, Lecture Notes in Computer Science 600 (Springer-Verlag, </booktitle> <year> 1992) </year> <month> 1-27. </month>
Reference-contexts: The extended model enables deadlock to be taken into account. Also, since it consists of infinite observations, it allows liveness and fairness issues to be considered. To exclude unrealistic behaviour, the extended model incorporates finite variability [3], also called non-Zeno-ness (cf. <ref> [1] </ref>), by guaranteeing that each action has a fixed minimal duration. Acknowledgement We would like to thank the reviewers for their many appropriate remarks.
Reference: [2] <author> A. Avizienis and J.C. Laprie, </author> <title> Dependable computing: from concepts to design diversity, </title> <note> Proceedings of the IEEE 74(5) (May 1986) 629-638. </note>
Reference-contexts: The discriminating factor between exceptional and catastrophic behaviour is the failure hypothesis which stipulates how faults affect the normal behaviour. Relative to the failure hypothesis an exceptional behaviour exhibits an abnormality which should be tolerated. A catastrophic behaviour has an abnormality that was not anticipated (cf. <ref> [2, 15, 21] </ref>). In general, the catastrophic behaviour of a component cannot be tolerated by a system. Under a particular failure hypothesis for each of its components, a system is designed to tolerate (only) the anticipated component failures (see, e.g., [22] for some design examples).
Reference: [3] <author> H. Barringer, R. Kuiper, A. Pnueli, </author> <title> A really abstract concurrent model and its temporal logic, </title> <booktitle> in: Proc. 13th ACM Symposium on Principles of Programming Languages (ACM, </booktitle> <year> 1986) </year> <month> 173-183. </month>
Reference-contexts: The extended model enables deadlock to be taken into account. Also, since it consists of infinite observations, it allows liveness and fairness issues to be considered. To exclude unrealistic behaviour, the extended model incorporates finite variability <ref> [3] </ref>, also called non-Zeno-ness (cf. [1]), by guaranteeing that each action has a fixed minimal duration. Acknowledgement We would like to thank the reviewers for their many appropriate remarks.
Reference: [4] <author> K.A. Bartlett, R.A. Scantlebury and P.T. Wilkinson, </author> <title> A note on reliable full-duplex transmission over half-duplex links, </title> <booktitle> Communications of the ACM 12(5) (1969) 260-261. </booktitle>
Reference-contexts: (Ink ((C 1 kC 2 kC 3 )oCor 1 )kVoter) n fin 1 ; in 2 ; in 3 ; out 1 ; out 2 ; out 3 g sat 8i : out (i) = f (in (i)) 2 7 Example II: The Alternating Bit Protocol The alternating bit protocol <ref> [4] </ref>, extended with timers, is a simple way to achieve communication over a medium that may lose messages. Consider the duplex communication medium of Figure 2, where A and M are media with failure hypothesis Loss as already discussed in Example 5.
Reference: [5] <author> J. Coenen and J. Hooman, </author> <title> Parameterized semantics for fault tolerant real-time systems, </title> <editor> in: J. Vytopil, ed., </editor> <title> Formal Techniques in Real-Time and Fault Tolerant Systems (Kluwer Academic Publishers, </title> <year> 1993) </year> <month> 51-78. </month>
Reference-contexts: In the formalisms that have been proposed in the more recent literature to deal with the occurrence of faults during execution (cf. <ref> [5, 12, 13, 17, 20, 27] </ref>) the occurrence of a fault is modeled explicitly. In contrast, we want to model the effects of faults on the externally visible input and output behaviour and let the syntactic interface of a process remain unchanged.
Reference: [6] <author> S.A. Cook, </author> <title> Soundness and completeness of an axiom system for program verification, </title> <note> SIAM Journal on Computing 7(1) (February 1978) 70-90. </note>
Reference-contexts: Theorem 1 (Soundness) The proof system of Section 5 is sound. Proof. See Appendix D. As usual when proving completeness, we assume that we can prove any valid formula of the underlying (trace) logic (cf. <ref> [6] </ref>). Thus, using ` OE to denote that assertion OE is derivable, we add the following axiom to our proof theory.
Reference: [7] <author> F. Cristian, </author> <title> A rigorous approach to fault tolerant programming, </title> <journal> IEEE Trans. </journal> <note> on Software Engineering SE-11(1) (1985) 23 - 31. </note>
Reference-contexts: 1 Introduction It is difficult to prove the properties of a distributed system composed of failure prone processes, as such proofs must take into account the effects of faults occurring at any point in the execution of the individual processes. In the Hoare style formalism of <ref> [7] </ref> Cristian deals with the effects of faults that have occurred by partitioning the initial state space into disjoint subspaces, and providing a separate specification for each part.
Reference: [8] <author> F. Cristian, </author> <title> Understanding fault tolerant distributed systems, </title> <booktitle> Communications of the ACM 34(2) (1991) 56 - 78. </booktitle>
Reference-contexts: related to its predecessor by stating which state variables have changed, transient memory faults can easily be formalized as the insertion of a state at an arbitrary position in the sequence. 17 Finding a logic to express failure hypotheses more elegantly, e.g. using the classification of failures that appears in <ref> [8] </ref>, is a subject of future investigation. Another continuation of the research described in this paper is the introduction of time to the formalism, to allow reasoning about properties of fault tolerant real-time distributed systems.
Reference: [9] <author> C.A.R. Hoare, </author> <title> Communicating Sequential Processes, </title> <booktitle> Communications of the ACM 21(8) (1978) 666-677. </booktitle>
Reference-contexts: IIN denotes the set of natural numbers (including 0). We assume a programming language, such as CSP <ref> [9] </ref> or occam [11], which can be used to define networks of processes that communicate synchronously via directed channels.
Reference: [10] <author> J. Hooman, </author> <title> Specification and Compositional Verification of Real-Time Systems, </title> <booktitle> Lecture Notes in Computer Science 558 (Springer-Verlag, </booktitle> <year> 1992). </year>
Reference-contexts: Hence, chan (OE) consists of the channels to which references to h in OE are restricted rather than the channels occurring syntactically in OE (cf. <ref> [10, 29] </ref>). Note that the value of a logical variable is not affected by any communication. <p> 1 ) " chan (FP 2 ) chan (FP 1 ) and chan (OE 2 ) " chan (FP 1 ) chan (FP 2 ), i.e. if the assertion that holds for one process refers to channels of the other process then this concerns channels connecting the two processes (cf. <ref> [10, 29] </ref>). Note that, as a consequence of this restriction, any occurrence of h in specification OE i of process FP i should be projected onto a subset of chan (FP i ). Recall that we do not allow shared variables.
Reference: [11] <author> INMOS Limited, </author> <title> occam 2 Reference Manual (Prentice Hall, </title> <year> 1988). </year>
Reference-contexts: IIN denotes the set of natural numbers (including 0). We assume a programming language, such as CSP [9] or occam <ref> [11] </ref>, which can be used to define networks of processes that communicate synchronously via directed channels.
Reference: [12] <author> H. </author> <title> Jifeng and C.A.R. Hoare, Algebraic specification and proof of a distributed recovery algorithm, </title> <booktitle> Distributed Computing 2 (1987) 1-12. </booktitle>
Reference-contexts: In the formalisms that have been proposed in the more recent literature to deal with the occurrence of faults during execution (cf. <ref> [5, 12, 13, 17, 20, 27] </ref>) the occurrence of a fault is modeled explicitly. In contrast, we want to model the effects of faults on the externally visible input and output behaviour and let the syntactic interface of a process remain unchanged.
Reference: [13] <author> M. Joseph, A. Moitra and N. Soundararajan, </author> <title> Proof rules for fault tolerant distributed programs, </title> <booktitle> Science of Computer Programming 8 (1987) 43-67. </booktitle>
Reference-contexts: In the formalisms that have been proposed in the more recent literature to deal with the occurrence of faults during execution (cf. <ref> [5, 12, 13, 17, 20, 27] </ref>) the occurrence of a fault is modeled explicitly. In contrast, we want to model the effects of faults on the externally visible input and output behaviour and let the syntactic interface of a process remain unchanged.
Reference: [14] <author> L. Lamport, </author> <title> What good is temporal logic, in: R.E. Manson, </title> <editor> ed., </editor> <booktitle> Information Processing (North-Holland, </booktitle> <year> 1983) </year> <month> 657-668. 18 </month>
Reference-contexts: Our framework is restricted to the specification and verification of safety properties of fault tolerant distributed systems. Safety properties are important for reliability because, in the characterization by Lamport <ref> [14] </ref>, they express that `nothing bad will happen'. Consider, for instance, a simple 1-place first-in first-out buffer B that has two observable channels in and out, with the obvious interpretation.
Reference: [15] <author> P.A Lee and T. Anderson, </author> <title> Fault Tolerance: </title> <booktitle> Principles and Practice (Springer-Verlag, </booktitle> <year> 1990). </year>
Reference-contexts: Since we abstract from the sequential details of programs, termination and divergence are not observable in our framework. Because we do not consider liveness properties, no fairness assumptions are needed. In fault tolerant systems, three forms of behaviour are distinguished: normal, exceptional and catastrophic <ref> [15] </ref>. Normal behaviour is the behaviour when no faults occur. The discriminating factor between exceptional and catastrophic behaviour is the failure hypothesis which stipulates how faults affect the normal behaviour. Relative to the failure hypothesis an exceptional behaviour exhibits an abnormality which should be tolerated. <p> The discriminating factor between exceptional and catastrophic behaviour is the failure hypothesis which stipulates how faults affect the normal behaviour. Relative to the failure hypothesis an exceptional behaviour exhibits an abnormality which should be tolerated. A catastrophic behaviour has an abnormality that was not anticipated (cf. <ref> [2, 15, 21] </ref>). In general, the catastrophic behaviour of a component cannot be tolerated by a system. Under a particular failure hypothesis for each of its components, a system is designed to tolerate (only) the anticipated component failures (see, e.g., [22] for some design examples).
Reference: [16] <author> Z. Liu and M. Joseph, </author> <title> Specification and verification of recovery in asynchronous communicating systems, </title> <editor> in: J. Vytopil, ed., </editor> <title> Formal Techniques in Real-Time and Fault Tolerant Systems (Kluwer Academic Publishers, </title> <year> 1993) </year> <month> 137-165. </month>
Reference-contexts: For instance, we do not separate the observable actions generated by the regular execution of the program from those that are attributed to faults. The incorporation of a recovery algorithm into a program has been investigated in <ref> [16, 19] </ref>. There, the occurrence of a fault is again modeled explicitly and causes the program to enter an erroneous state. Once in an erroneous state the program may exhibit arbitrary behaviour and this distinction suffices in case of recovery.
Reference: [17] <author> J. Nordahl, </author> <title> Design for dependability, </title> <booktitle> in: Proc. 3rd IFIP Int. Working Conference on Dependable Computing for Critical Applications, Dependable Computing and Fault Tolerant Systems 8 (Springer-Verlag, </booktitle> <year> 1993) </year> <month> 65-89. </month>
Reference-contexts: In the formalisms that have been proposed in the more recent literature to deal with the occurrence of faults during execution (cf. <ref> [5, 12, 13, 17, 20, 27] </ref>) the occurrence of a fault is modeled explicitly. In contrast, we want to model the effects of faults on the externally visible input and output behaviour and let the syntactic interface of a process remain unchanged.
Reference: [18] <author> K. Paliwoda and J.W. Sanders, </author> <title> An incremental specification of the sliding window protocol, </title> <booktitle> Distributed Computing 5 (1991) 83-94. </booktitle>
Reference-contexts: We illustrated our method by proving safety of a triple modular redundant system and the alternating bit protocol, using only the specifications of the components. The proof of correctness of the alternating bit protocol that appears in <ref> [18] </ref> is also based on traces. There, a less natural specification of the receiver, which contains the requirement that non-duplicate input messages have alternating bits, evades the necessity to prove the property of persistency. In this paper we only considered safety properties, ignoring liveness issues.
Reference: [19] <author> D. Peled and M. Joseph, </author> <title> A compositional approach for fault tolerance using specification transformation, </title> <booktitle> in: Proc. Parallel Architectures and Languages Europe (PARLE) '93 , Lecture Notes in Computer Science 694 (Springer-Verlag, </booktitle> <year> 1993) </year> <month> 173-184. </month>
Reference-contexts: For instance, we do not separate the observable actions generated by the regular execution of the program from those that are attributed to faults. The incorporation of a recovery algorithm into a program has been investigated in <ref> [16, 19] </ref>. There, the occurrence of a fault is again modeled explicitly and causes the program to enter an erroneous state. Once in an erroneous state the program may exhibit arbitrary behaviour and this distinction suffices in case of recovery.
Reference: [20] <author> J. Peleska, </author> <title> Design and verification of fault tolerant systems with CSP, </title> <booktitle> Distributed Computing 5 (1991) 95-106. </booktitle>
Reference-contexts: In the formalisms that have been proposed in the more recent literature to deal with the occurrence of faults during execution (cf. <ref> [5, 12, 13, 17, 20, 27] </ref>) the occurrence of a fault is modeled explicitly. In contrast, we want to model the effects of faults on the externally visible input and output behaviour and let the syntactic interface of a process remain unchanged.
Reference: [21] <author> B. Randell, </author> <title> P.A. Lee and P.C. Treleaven, Reliability issues in computing system design, </title> <note> ACM Computing Surveys 10(2) (June 1978) 123-165. </note>
Reference-contexts: The discriminating factor between exceptional and catastrophic behaviour is the failure hypothesis which stipulates how faults affect the normal behaviour. Relative to the failure hypothesis an exceptional behaviour exhibits an abnormality which should be tolerated. A catastrophic behaviour has an abnormality that was not anticipated (cf. <ref> [2, 15, 21] </ref>). In general, the catastrophic behaviour of a component cannot be tolerated by a system. Under a particular failure hypothesis for each of its components, a system is designed to tolerate (only) the anticipated component failures (see, e.g., [22] for some design examples).
Reference: [22] <author> H. Schepers, </author> <title> Terminology and paradigms for fault tolerance, </title> <editor> in: J. Vytopil, ed., </editor> <title> Formal Techniques in Real-Time and Fault Tolerant Systems (Kluwer Academic Publishers, </title> <year> 1993) </year> <month> 3-31. </month>
Reference-contexts: There, the occurrence of a fault is again modeled explicitly and causes the program to enter an erroneous state. Once in an erroneous state the program may exhibit arbitrary behaviour and this distinction suffices in case of recovery. To allow a general treatment of paradigms for fault tolerance <ref> [22] </ref> we prefer to reason with more nuance about the effects of faults. To support top-down program design we wish to reason with the specifications of processes without considering their implementation and the precise nature and occurrence of faults in such an implementation. <p> In general, the catastrophic behaviour of a component cannot be tolerated by a system. Under a particular failure hypothesis for each of its components, a system is designed to tolerate (only) the anticipated component failures (see, e.g., <ref> [22] </ref> for some design examples). The exceptional behaviour together with the normal behaviour constitutes the acceptable behaviour. Given this classification of behaviour, we investigate whether an existing compositional proof theory for reasoning about the normal behaviour of a system can be adapted to deal with its acceptable beha-viour.
Reference: [23] <author> H. Schepers, </author> <title> Tracing fault tolerance, </title> <booktitle> in: Proc. 3rd IFIP Int. Working Conference on Dependable Computing for Critical Applications, Dependable Computing and Fault Tolerant Systems 8 (Springer-Verlag, </booktitle> <year> 1993) </year> <month> 91-110. </month>
Reference-contexts: As in <ref> [23] </ref>, the construct Square oStuckAtZero indicates execution of process Square under failure hypothesis StuckAtZero.
Reference: [24] <author> H. Schepers and R. Gerth, </author> <title> A compositional proof theory for fault tolerant real-time distributed systems, </title> <booktitle> in: Proc. 12th Symp. on Reliable Distributed Systems (IEEE Computer Society Press, </booktitle> <year> 1993) </year> <month> 34-43. </month>
Reference-contexts: Another continuation of the research described in this paper is the introduction of time to the formalism, to allow reasoning about properties of fault tolerant real-time distributed systems. This is investigated in <ref> [24] </ref> where the finite trace model is replaced by a model in which timed infinite traces are decorated with timed refusal sets. The extended model enables deadlock to be taken into account. Also, since it consists of infinite observations, it allows liveness and fairness issues to be considered.
Reference: [25] <author> H. Schepers and J. Hooman, </author> <title> Trace-based compositional reasoning about fault tolerant systems, </title> <booktitle> in: Proc. Parallel Architectures and Languages Europe (PARLE) '93 , Lecture Notes in Computer Science 694 (Springer-Verlag, </booktitle> <year> 1993) </year> <month> 197-208. </month>
Reference-contexts: In Section 8 we prove that the proof theory of Section 5 is sound and complete. A conclusion and suggestions for future research can be found in Section 9. An extended abstract of this paper appeared in <ref> [25] </ref>. 2 Model of Computation Let VAR be a nonempty set of program variables, CHAN a nonempty set of channel names, and let VAL be a denumerable domain of values. IIN denotes the set of natural numbers (including 0).
Reference: [26] <author> H. Schepers and J. Hooman, </author> <title> A trace-based compositional proof theory for fault tolerant distributed systems, </title> <note> Computing Science Note 93/16, </note> <institution> Department of Mathematics and Computing Science, Eindhoven University of Technology, </institution> <year> 1993. </year>
Reference-contexts: using a programming language in which processes communicate synchronously via directed channels it is quite standard, using the above defined operations, to give the prefix closed set H [[P ]] of possible finite traces that can be observed up to any point in an execution of P (see for instance <ref> [26, 29] </ref>). For infinite executions of P the set H [[P ]] contains all finite approximations, which is justified since we only deal with safety properties [29]. The set H [[P ]] represents the normal behaviour of process P . <p> We only give the most interesting cases of this definition; the rest can easily be defined by structural induction (see <ref> [26] </ref>). * chan (c) = chan () = chan (v) = chan (t) = chan (hi) = O * chan (h) = CHAN * chan (texp "cset) = chan (texp) " cset 3 Next we define the meaning of assertions. <p> We give a few cases of these definitions (the full interpretation can be found in <ref> [26] </ref>): * V [[v]](; fl) = fl (v) * R [[texp (vexp)]](; fl) = 8 : (c; ) iff there exist 1 and 2 such that len ( 1 ) = V [[vexp]](; fl) 1 and T [[texp]](; fl) = 1 ^ (c; ) ^ 2 otherwise * T [[t]](; fl)
Reference: [27] <author> D.G. Weber, </author> <title> Formal specification of fault-tolerance and its relation to computer security, </title> <booktitle> ACM Software Engineering Notes 14(3) (1989) 273-277. </booktitle>
Reference-contexts: In the formalisms that have been proposed in the more recent literature to deal with the occurrence of faults during execution (cf. <ref> [5, 12, 13, 17, 20, 27] </ref>) the occurrence of a fault is modeled explicitly. In contrast, we want to model the effects of faults on the externally visible input and output behaviour and let the syntactic interface of a process remain unchanged.
Reference: [28] <author> J. Widom, D. Gries and F. Schneider, </author> <title> Trace-based network proof systems: expressiveness and completeness, </title> <journal> ACM Trans. </journal> <note> on Programming Languages and Systems 14(3) (July 1992) 396-416. </note>
Reference-contexts: The usefulness of our method is illustrated by applying it to a triple modular redundant system and the alternating bit protocol, where, indeed, we only use the specifications of the components. Finally, we show that our proof theory is sound and obtain a completeness result by establishing preciseness preservation <ref> [28] </ref>. The remainder of this paper is organized as follows. Section 2 introduces the model of computation. In Section 3 we present the assertion language and associated correctness formulae. In Section 4 we incorporate failure hypotheses into our formalism. <p> Definition 21 (Preciseness) An assertion OE is precise for failure prone process FP iff (i) j= FP sat OE. (ii) if chan () chan (FP ) and, for some fl, (; fl) j= OE then 2 H [[FP ]]. (iii) chan (OE) chan (FP ). 3 As in <ref> [28] </ref>, we use the preciseness preservation property to achieve relative completeness. The intuition is that, as long as the specifications of the individual processes are precise, so are the deduced specifications of systems composed of such processes.
Reference: [29] <author> J. Zwiers, </author> <title> Compositionality, Concurrency and Partial Correctness, </title> <booktitle> Lecture Notes in Computer Science 321 (Springer-Verlag, </booktitle> <year> 1989). </year>
Reference-contexts: using a programming language in which processes communicate synchronously via directed channels it is quite standard, using the above defined operations, to give the prefix closed set H [[P ]] of possible finite traces that can be observed up to any point in an execution of P (see for instance <ref> [26, 29] </ref>). For infinite executions of P the set H [[P ]] contains all finite approximations, which is justified since we only deal with safety properties [29]. The set H [[P ]] represents the normal behaviour of process P . <p> For infinite executions of P the set H [[P ]] contains all finite approximations, which is justified since we only deal with safety properties <ref> [29] </ref>. The set H [[P ]] represents the normal behaviour of process P . <p> Hence, chan (OE) consists of the channels to which references to h in OE are restricted rather than the channels occurring syntactically in OE (cf. <ref> [10, 29] </ref>). Note that the value of a logical variable is not affected by any communication. <p> Such rules could be formulated by using an extended assertion language which includes program variables and a denotation to indicate termination (e.g. <ref> [29] </ref>). <p> 1 ) " chan (FP 2 ) chan (FP 1 ) and chan (OE 2 ) " chan (FP 1 ) chan (FP 2 ), i.e. if the assertion that holds for one process refers to channels of the other process then this concerns channels connecting the two processes (cf. <ref> [10, 29] </ref>). Note that, as a consequence of this restriction, any occurrence of h in specification OE i of process FP i should be projected onto a subset of chan (FP i ). Recall that we do not allow shared variables. <p> Such a relation enables one to abstract from the precise nature of a fault and to focus on the abnormal behaviour it causes. Comparing our proof system with trace-based formalisms for normal behaviour (see e.g. <ref> [29] </ref>), only one new rule, viz. the failure hypothesis introduction rule, has been added to capture acceptable executions. We illustrated our method by proving safety of a triple modular redundant system and the alternating bit protocol, using only the specifications of the components.
References-found: 29

