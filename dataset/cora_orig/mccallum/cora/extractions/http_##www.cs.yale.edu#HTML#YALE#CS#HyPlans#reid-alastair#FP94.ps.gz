URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/reid-alastair/FP94.ps.gz
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/reid-alastair/
Root-URL: http://www.cs.yale.edu
Title: Malloc Pointers and Stable Pointers: Improving Haskell's Foreign Language Interface  
Author: Alastair Reid 
Date: September 26, 1994  
Address: Glasgow G12 8QQ, Scotland  
Affiliation: Computing Science Department, University of Glasgow  
Abstract: The Glasgow Haskell compiler provides a foreign language interface which allows Haskell programs to call arbitrary C functions. This has been used both to implement the standard Haskell IO system and a variety of applications including an arcade game [8], and a graphical user interface to a database [19]. The theoretical problems associated with using impure functions from pure functional languages are avoided through the use of monads [17]; and the mismatch between strict languages with no garbage collection and lazy languages with garbage collection is tackled by unboxing (that is, forcing evaluation of arguments and stripping off any header information) [15]. Whilst this works well for simple examples, it is unsuitable when one wants to pass arguments (or results) which are lazy, polymorphic or very large. We describe two extensions to the garbage collector which solve these problems by allowing better interaction between the Haskell garbage collector and memory allocation in the imperative world.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> AW Appel, </author> <title> Simple generational garbage collection and fast allocation, </title> <journal> Software | Practice and Experience 19, </journal> <pages> 171-183, </pages> <month> Feb. </month> <year> 1989. </year>
Reference-contexts: Collection Glasgow Haskell supports four different garbage collectors: * a 2-space copying collector [6]; * a 1-space compacting collector [11]; * a "dual mode" collector which operates either as a two space collector or a compacting collector depending on the amount of live data [20]; and * a generational collector <ref> [1, 21] </ref>. This collector maintains just two generations: the new generation is collected using a two-space collector; and the old generation is collected using a one-space collector. To allow separate collection of the generations, a list of pointers from the old generation to the new generation is maintained.
Reference: [2] <author> JF Bartlett, </author> <title> Compacting garbage collection with ambiguous roots, </title> <booktitle> Lisp Pointers 1, </booktitle> <volume> 6, </volume> <pages> 3-12, </pages> <month> Apr. </month> <year> 1988. </year> <title> ToDo: Check that this reference describes weak pointers </title>
Reference: [3] <author> HJ Boehm, </author> <title> Space efficient conservative garbage collection, </title> <booktitle> in Proc. ACM Comference on Programming Language Design and Implementation, Al-buquerque, </booktitle> <pages> 197-206, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: If the garbage collector is unaware that the imperative world has a reference to a Haskell heap object, it might be deallocated when references still exist. * Since most C implementations do not have automatic garbage collection (see, for example, <ref> [3] </ref> for an exception), it is necessary to explicitly deallocate heap-allocated objects as the last reference to the object is deleted. This is hard to do correctly in an imperative language; it is virtually impossible in a lazy functional language.
Reference: [4] <author> L Cardelli, J Donahue, L Glassman, M Jordan, B Kalsow, G Nelson, </author> <title> Modula-3 Language Definition, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27, 8, </volume> <pages> 15-42, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: Thus, the only overhead of repeatedly calling the collector are the tests that the low-numbered generations are indeed empty. 6 Related Work Our "malloc pointers" mechanisms bear some resemblance to the "weak references" and "weak arrays" of (the DEC SRC implementation of) Modula 3 <ref> [4] </ref> and the ObjectworksnSmalltalk implementation [13] respectively. Both provide a method of associating a "cleanup procedure" to an object which is called when the associated object "dies". An essential difference is that the cleanup procedure is written in Modula 3 (respectively Smalltalk).
Reference: [5] <author> M Carlsson and T Hallgren, Fudgets: </author> <title> a graphical user interface in a lazy functional language, </title> <booktitle> in Proc. Conference on Functional Programming and Computer Architecture, </booktitle> <year> 1993. </year>
Reference-contexts: The (lazy) pure functional world is beginning to demonstrate that pure functional languages are also good for writing programs traditionally considered to be outside their domain. A good example is Carlson and Hallgren's Fudget system <ref> [5] </ref> | an efficient library of "functional widgets" which can be used to implement graphical user interfaces. fl email: areid@uk.ac.glasgow.dcs; http: //www.dcs.gla.ac.uk/~areid 1 It is therefore technically possible to discard most (or all?) existing imper-ative libraries and reimplement them all in a (pure) functional language but there are compelling reasons why
Reference: [6] <author> CJ Cheney, </author> <title> A nonrecursive list compacting algorithm, </title> <journal> Communications of the ACM 13, </journal> <pages> 677-678, </pages> <month> Nov. </month> <year> 1970. </year>
Reference-contexts: For example, with n = 4 and pointers 0 and 3 in use (pointing to p1 and p2 respectively), the table might look like this: 4 p1 ? ? p2 2 1 2 ? ? 4.3 Garbage Collection Glasgow Haskell supports four different garbage collectors: * a 2-space copying collector <ref> [6] </ref>; * a 1-space compacting collector [11]; * a "dual mode" collector which operates either as a two space collector or a compacting collector depending on the amount of live data [20]; and * a generational collector [1, 21].
Reference: [7] <institution> CLX Common Lisp X Interface, Texas Intruments Incorporated, </institution> <year> 1989. </year>
Reference-contexts: 1 Introduction The LISP and Standard ML communities have known for some time that impure functional languages are useful for more than just symbolic manipulation and toy programs | functional programs can also provide sophisticated user interfaces <ref> [9, 7] </ref> and can be used for systems programming tasks such as implementing communications protocols [10]. The (lazy) pure functional world is beginning to demonstrate that pure functional languages are also good for writing programs traditionally considered to be outside their domain.
Reference: [8] <author> D Fraser, </author> <title> Haskell Defender: implementing arcade games in lazy functional languages, Senior Honours Project, </title> <institution> Computing Science Department, University of Glasgow, </institution> <year> 1994. </year>
Reference: [9] <author> ER Gansner, JH Reppy, eXene, </author> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The LISP and Standard ML communities have known for some time that impure functional languages are useful for more than just symbolic manipulation and toy programs | functional programs can also provide sophisticated user interfaces <ref> [9, 7] </ref> and can be used for systems programming tasks such as implementing communications protocols [10]. The (lazy) pure functional world is beginning to demonstrate that pure functional languages are also good for writing programs traditionally considered to be outside their domain.
Reference: [10] <author> R Harper and P Lee, </author> <title> Advanced languages for systems software: the Fox project in 1994, </title> <institution> CMU-CS-94-104, Department of Computing Science, Carnegie Mellon University, </institution> <month> Jan </month> <year> 1994. </year>
Reference-contexts: The LISP and Standard ML communities have known for some time that impure functional languages are useful for more than just symbolic manipulation and toy programs | functional programs can also provide sophisticated user interfaces [9, 7] and can be used for systems programming tasks such as implementing communications protocols <ref> [10] </ref>. The (lazy) pure functional world is beginning to demonstrate that pure functional languages are also good for writing programs traditionally considered to be outside their domain.
Reference: [11] <author> HBM Jonkers, </author> <title> A fast garbage compaction algorithm, </title> <journal> Information Processing Letters 9, </journal> <pages> 26-30, </pages> <month> July </month> <year> 1979. </year>
Reference-contexts: and pointers 0 and 3 in use (pointing to p1 and p2 respectively), the table might look like this: 4 p1 ? ? p2 2 1 2 ? ? 4.3 Garbage Collection Glasgow Haskell supports four different garbage collectors: * a 2-space copying collector [6]; * a 1-space compacting collector <ref> [11] </ref>; * a "dual mode" collector which operates either as a two space collector or a compacting collector depending on the amount of live data [20]; and * a generational collector [1, 21].
Reference: [12] <author> JT O'Donnell, </author> <title> Data parallel implementation of Extensible Sparse Functional Arrays, </title> <booktitle> Parallel Architectures and Languages Europe, </booktitle> <publisher> LNCS 694, Springer-Verlag, </publisher> <pages> 68-79, </pages> <year> 1993. </year>
Reference-contexts: This standard approach is restricted in a number of ways: Laziness: Since all arguments are evaluated before calling the C function, one cannot write lazy functions. Given that C is a strict language, this seems perfectly reasonable. However, O'Donnell <ref> [12] </ref> describes a hardware implementation of arrays which provides extensible, sparse functional arrays (called "ESF arrays"). By exploiting the parallelism inherent in hardware, O'Donnell is able to perform both update and lookup in constant time.
Reference: [13] <author> ParcPlace Systems, </author> <title> ObjectworksnSmalltalk User's Guide (Release 4), </title> <address> 1550 Plymouth Street, Mountain View, California 94043. </address> <year> 1990. </year>
Reference-contexts: Thus, the only overhead of repeatedly calling the collector are the tests that the low-numbered generations are indeed empty. 6 Related Work Our "malloc pointers" mechanisms bear some resemblance to the "weak references" and "weak arrays" of (the DEC SRC implementation of) Modula 3 [4] and the ObjectworksnSmalltalk implementation <ref> [13] </ref> respectively. Both provide a method of associating a "cleanup procedure" to an object which is called when the associated object "dies". An essential difference is that the cleanup procedure is written in Modula 3 (respectively Smalltalk).
Reference: [14] <author> SL Peyton Jones and J Launchbury, </author> <title> Lazy imperative programming, </title> <booktitle> ACM SIGPLAN Workshop in State in Programming Languages, </booktitle> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: The theoretical and practical problems arising from calling impure functions from a pure functional language are avoided by using a monad to force strict sequencing of _ccall_s. We refer the reader to <ref> [17, 14, 16] </ref> for a detailed discussion of the monadic approach but note that the type PrimIO and functions thenPrimIO, returnPrimIO and unsafePerformPrimIO were called IO, thenIO, returnIO and performIO respectively in [17].
Reference: [15] <author> SL Peyton Jones and J Launchbury, </author> <title> Unboxed values as first class citizens in a non-strict functional language, </title> <booktitle> in Proc. 1991 Conference on Functional Programming and Computer Architecture, </booktitle> <address> Cambridge, </address> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: In most cases, imperative functions must be passed the value of a "thunk" rather than the "thunk" itself. The necessary conversions could be made explicit through the use of "un-boxed types" <ref> [15] </ref> but ghc automatically performs these conversions on the following basic data types: Char, Int, Float and Double.
Reference: [16] <author> SL Peyton Jones and J Launchbury, </author> <title> Lazy functional state threads, </title> <booktitle> in Proc. ACM Comference on Programming Language Design and Implementation, </booktitle> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The theoretical and practical problems arising from calling impure functions from a pure functional language are avoided by using a monad to force strict sequencing of _ccall_s. We refer the reader to <ref> [17, 14, 16] </ref> for a detailed discussion of the monadic approach but note that the type PrimIO and functions thenPrimIO, returnPrimIO and unsafePerformPrimIO were called IO, thenIO, returnIO and performIO respectively in [17].
Reference: [17] <editor> SL Peyton Jones and PL Wadler, </editor> <title> Imperative functional programming, </title> <booktitle> in Proc. 20th ACM Symposium on Principles of Programming Languages, Charlotte, ACM, </booktitle> <month> Jan </month> <year> 1993. </year>
Reference-contexts: are heap allocated and automatically deallocated through garbage collection. (A lifetime analysis is also possible | allowing the compiler to decides where to allocate an object or to perform "compile-time" garbage collection.) Issues of control flow can be dealt with by writing programs in continuation passing style or monadic style <ref> [17] </ref>; therefore this paper is primarily concerned with issues associated with passing data to and from an imperative language. Section 2 describes the Glasgow Haskell Compiler's foreign language interface. Section 3 describes problems in passing arguments that are: polymorphic; lazy; large; persistent from one call to another; or functions. <p> The theoretical and practical problems arising from calling impure functions from a pure functional language are avoided by using a monad to force strict sequencing of _ccall_s. We refer the reader to <ref> [17, 14, 16] </ref> for a detailed discussion of the monadic approach but note that the type PrimIO and functions thenPrimIO, returnPrimIO and unsafePerformPrimIO were called IO, thenIO, returnIO and performIO respectively in [17]. <p> We refer the reader to [17, 14, 16] for a detailed discussion of the monadic approach but note that the type PrimIO and functions thenPrimIO, returnPrimIO and unsafePerformPrimIO were called IO, thenIO, returnIO and performIO respectively in <ref> [17] </ref>.
Reference: [18] <author> I Poole and D Charleston, </author> <title> Experience of developing a cervical cytology scanning system using Gofer and Haskell, </title> <booktitle> this volume, </booktitle> <month> September </month> <year> 1994. </year>
Reference: [19] <author> AD Reid and S Singh, </author> <title> Implementing fudgets with standard widget sets, </title> <booktitle> in Proc. Glasgow Workshop on Functional Programming, Workshops in Computing Series, </booktitle> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1993. </year>
Reference-contexts: If one wishes to write graphical user interfaces in Haskell, the natural way of defining which callback to call in response to a given event is to store the address of the (possibly heap-allocated) callback routine in the Widget | almost exactly as one does for C. (Our earlier paper <ref> [19] </ref> describes a rather ad hoc approach which avoids the need to extend the garbage collector.) * The Haskell 1.3 IO proposal defines a function setInterrupt :: IO () -&gt; IO (IO ()) which allows a monadic program to specify an "interrupt handler" to be executed when a console interrupt occurs.
Reference: [20] <author> PM Sansom, </author> <title> Combining copying and compacting garbage collection, </title> <booktitle> in Proc. Glasgow Workshop on Functional Programming, Workshops in Computing Series, </booktitle> <publisher> Springer-Verlag, </publisher> <month> Aug </month> <year> 1991. </year>
Reference-contexts: 1 2 ? ? 4.3 Garbage Collection Glasgow Haskell supports four different garbage collectors: * a 2-space copying collector [6]; * a 1-space compacting collector [11]; * a "dual mode" collector which operates either as a two space collector or a compacting collector depending on the amount of live data <ref> [20] </ref>; and * a generational collector [1, 21]. This collector maintains just two generations: the new generation is collected using a two-space collector; and the old generation is collected using a one-space collector.
Reference: [21] <editor> PM Sansom and SL Peyton Jones, </editor> <title> Generational garbage collection for Haskell, </title> <booktitle> in Proceedings of the 1993 Conference on Functional Programming and Computer Architecture. </booktitle>
Reference-contexts: Collection Glasgow Haskell supports four different garbage collectors: * a 2-space copying collector [6]; * a 1-space compacting collector [11]; * a "dual mode" collector which operates either as a two space collector or a compacting collector depending on the amount of live data [20]; and * a generational collector <ref> [1, 21] </ref>. This collector maintains just two generations: the new generation is collected using a two-space collector; and the old generation is collected using a one-space collector. To allow separate collection of the generations, a list of pointers from the old generation to the new generation is maintained.
References-found: 21

