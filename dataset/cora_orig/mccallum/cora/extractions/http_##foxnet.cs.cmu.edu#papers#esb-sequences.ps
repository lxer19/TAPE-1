URL: http://foxnet.cs.cmu.edu/papers/esb-sequences.ps
Refering-URL: http://foxnet.cs.cmu.edu/papers.html
Root-URL: 
Title: Sequence Types for Functional Languages  
Author: Edoardo S. Biagioni 
Note: Also published as Fox Memorandum CMU-CS-FOX-95-06 This research was sponsored by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No. C533, issued by ESC/ENS under Contract No. F19628-95-C-0050. The views and conclusions contained in this document are those of the author and should not be interpreted as representing official policies, either expressed or implied, of the Advanced Research Projects Agency or the U.S. Government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: August 1995  
Pubnum: CMU-CS-95-180  
Abstract: The use of types such as arrays, lazy lists, and other sequential types in Standard ML and other advanced languages can be made as natural and useful as the use of lists. These types are collectively referred to as sequences. This report presents a sequence interface which can be satisfied by every sequence type regardless of the details of representation, laziness or eagerness, extensibility, and mutability of the specific data structure implementing the type. In addition, an implementation of a sequence type can satisfy more detailed, specific interfaces, some of which are presented. The report also introduces operations for mutating arrays that allow the same style of looping as the conventional list operations and can be implemented efficiently on conventional architectures. The array interface is extended and specialized to allow a efficient implementations of byte arrays. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Aditya, C. H. Flood, and J. E. Hicks. </author> <title> Garbage collection for strongly-typed languages using run-time type reconstruction. </title> <booktitle> In Proc. 1994 Lisp and Functional Programming, </booktitle> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Algorithms for tagless (type-directed) garbage collection have been described in detail elsewhere <ref> [2, 24, 1] </ref>, and may be useful in addressing this issue. 5 Background 5.1 Programming Languages with Arrays Fortran arrays are described by John Backus in his history of Fortran [7]. Language support for arrays in Fortran includes convenient iterative constructs, and (unsafe) array subscripting and update using special syntax.
Reference: [2] <author> Andrew A. Appel. </author> <title> Runtime tags aren't necessary. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2, </volume> <year> 1989. </year>
Reference-contexts: Algorithms for tagless (type-directed) garbage collection have been described in detail elsewhere <ref> [2, 24, 1] </ref>, and may be useful in addressing this issue. 5 Background 5.1 Programming Languages with Arrays Fortran arrays are described by John Backus in his history of Fortran [7]. Language support for arrays in Fortran includes convenient iterative constructs, and (unsafe) array subscripting and update using special syntax.
Reference: [3] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In J. Maluszynski and M. Wirsing, editors, </editor> <booktitle> Third International Symposium on Programming Languages Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: Arrays in SML are not part of the standard, but where implemented, such as by SML of New Jersey <ref> [3] </ref> (SML/NJ), share the same interface as LISP arrays, again with the distinction that all elements of an SML array must have the same type. Arrays in SML are generally polymorphic.
Reference: [4] <institution> AT&T Bell Laboratories. Standard ML of New Jersey Base Environment, </institution> <month> February 15 </month> <year> 1993. </year>
Reference-contexts: Arrays in SML are generally polymorphic. In recognition of the greater efficiency of storage possible with monomorphic arrays, the current draft for the SML/NJ standard library [5] includes a definition of monomorphic arrays; this is a generalization of earlier versions of the library <ref> [4] </ref> in which the only monomorphic arrays supported were arrays of bytes and of reals. The Common Lisp function make-array likewise allows the specification of a type for elements of an array, presumably with similar benefits. The Haskell language [15] is a purely functional, lazy (normal-order evaluation) language.
Reference: [5] <institution> A New Initial Basis for Standard ML, </institution> <month> April 12 </month> <year> 1995. </year> <note> unpublished. </note>
Reference-contexts: Arrays in SML are generally polymorphic. In recognition of the greater efficiency of storage possible with monomorphic arrays, the current draft for the SML/NJ standard library <ref> [5] </ref> includes a definition of monomorphic arrays; this is a generalization of earlier versions of the library [4] in which the only monomorphic arrays supported were arrays of bytes and of reals.
Reference: [6] <author> John Backus. </author> <title> Can programming be liberated from the von Neumann style? a functional style and its algebra of programs. </title> <journal> Communications of the ACM, </journal> <volume> 16(8) </volume> <pages> 613-641, </pages> <month> August </month> <year> 1978. </year> <note> Turing Award Lecture. </note>
Reference-contexts: Array subscripting is conventional, while array update allows updating multiple elements at once and is purely functional, returning a new array with the specified elements changed. 11 5.4 Other Aggregate Types The FP language <ref> [6] </ref> provides vectors that resemble the sequences described in this report in allowing both array-like indexing and list-like extension and looping.
Reference: [7] <author> John Backus. </author> <title> The history of FORTRAN I, II, and III. </title> <editor> In Richard L. Wexelblat, editor, </editor> <booktitle> History of Programming Languages. Proc. ACM SIGPLAN conference, </booktitle> <pages> pages 25-74. </pages> <publisher> Academic Press, </publisher> <month> June </month> <year> 1978. </year>
Reference-contexts: Algorithms for tagless (type-directed) garbage collection have been described in detail elsewhere [2, 24, 1], and may be useful in addressing this issue. 5 Background 5.1 Programming Languages with Arrays Fortran arrays are described by John Backus in his history of Fortran <ref> [7] </ref>. Language support for arrays in Fortran includes convenient iterative constructs, and (unsafe) array subscripting and update using special syntax. Arrays in C are described by Kernighan and Ritchie in the original C language manual [16].
Reference: [8] <author> Edoardo Biagioni. </author> <title> A structured TCP in Standard ML. </title> <booktitle> In Proc. SIGComm '94, </booktitle> <pages> pages 36-45, </pages> <address> London, England, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: The Fox Project develops systems software in SML in order to improve both the practice of systems programming and advanced language support for systems programs. Specifically, the Fox Project has built an implementation of the standard TCP/IP networking protocol stack <ref> [9, 8] </ref> entirely in SML 4 . One of the tasks of a protocol stack is to strip headers from incoming packets, which are represented as byte arrays.
Reference: [9] <author> Edoardo Biagioni, Robert Harper, Peter Lee, and Brian Milnes. </author> <title> Signatures for a network protocol stack a systems application of Standard ML. </title> <booktitle> In Proc. 1994 Lisp and Functional Programming, </booktitle> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The value of a data structure which can only be shrunk and not extended can be seen by the fact that an entire implementation of the Fox Net TCP/IP protocol stack <ref> [9] </ref> relies on such shrinkable, non-extensible arrays to store incoming and outgoing data; for this application, the efficiency of the array representation is more important than the inability to extend the array. <p> The Fox Project develops systems software in SML in order to improve both the practice of systems programming and advanced language support for systems programs. Specifically, the Fox Project has built an implementation of the standard TCP/IP networking protocol stack <ref> [9, 8] </ref> entirely in SML 4 . One of the tasks of a protocol stack is to strip headers from incoming packets, which are represented as byte arrays.
Reference: [10] <author> Edoardo S. Biagioni. Fpc: </author> <title> A translator for fp. </title> <type> Technical Report TR88-027, </type> <institution> Dept. of Computer Science, UNC-Chapel Hill, Chapel Hill, North Carolina, </institution> <month> 27599-3175, May </month> <year> 1988. </year>
Reference-contexts: The word array interface extends the possibility of high-performance implementation to arrays of bytes, supporting safe access at different word sizes to allow the highest possible performance. 3 In previous work the author produced an implementation <ref> [10] </ref> of the FP language that uses arrays to implement sequences, accepting the corresponding high cost of prefixing. 4 This implementation runs in user space and is therefore layered above an operating system and its device driver. 12 Finally, this report describes a new programming interface for modifying the contents of
Reference: [11] <author> Edoardo S. Biagioni. </author> <title> Program verification for optimized byte copy. </title> <type> Technical Report CMU-CS-94-172, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: Word arrays were developed as more elegant and convenient (and potentially faster) replacement for sub and update. It should be noted that SML/NJ provides primitives for unsafe access to byte arrays. Experience <ref> [11] </ref> with this "feature" of the language was part of the original motivation for the development of safe high-performance array access interfaces. 6 Summary and Contributions The concept of sequences is not new; what this report describes that is new is the use of sequences to express the common features of
Reference: [12] <author> K. Hammond, J. Peterson, L. Augustsson, B. Boutel, W. Burton, J. Fairbairn, J. Fasel, A. Gor-don, M. M. Guzman, J. Hughes, P. Hudak, T. Johnsson, M. Jones, D. Kieburtz, R. Nikhil, W. Partain, J. Mattson, S. Loosemore, S. Peyton-Jones, A. Reid, and P. Wadler. </author> <title> Standard Libraries for the Programming Language Haskell. </title> <journal> ftp://haskell.systemsz.cs.yale.edu/- pub/haskell/report/draft-libraries-1.3.dvi, </journal> <note> version 1.3 edition, </note> <month> June </month> <year> 1995. </year>
Reference-contexts: The Haskell language [15] is a purely functional, lazy (normal-order evaluation) language. Haskell defines lazy lists, which are equivalent to the stream type of an eager languages, and the preliminary definition of standard libraries <ref> [12] </ref> defines lazy arrays.
Reference: [13] <author> Robert Harper and Peter Lee. </author> <title> Advanced languages for systems software: The fox project in 1994. </title> <type> Technical Report CMU-CS-94-104, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> January </month> <year> 1994. </year> <month> 13 </month>
Reference-contexts: the development of the sequence interface described in this report, though the inspiration was somewhat indirect since the sequence trait described by Moormann Zaremski and Wing differs substantially from the sequence interface in this report. 5.5 Motivation: The Fox Project The original motivation for sequences came from the Fox Project <ref> [13] </ref>. The Fox Project develops systems software in SML in order to improve both the practice of systems programming and advanced language support for systems programs. Specifically, the Fox Project has built an implementation of the standard TCP/IP networking protocol stack [9, 8] entirely in SML 4 .
Reference: [14] <author> J. Horning and J. Guttag. </author> <title> LARCH: Languages and Tools for Formal Specification. </title> <publisher> Springer--Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The generic sequence interface presented in this report allows but does not require that a sequence be capable of extension, and this makes it possible to use it as an interface to both lists and arrays. Larch <ref> [14] </ref> is a formal specification system for programs.
Reference: [15] <author> P. Hudak, S. Peyton-Jones, P. Wadler, B. Boutel, J. Fairbairn, J. Fasel, M. Guzman, K. Ham-mond, J. Hughes, T. Johnsson, D. Kieburtz, R. Nikhil, W. Partain, and J. Peterson. </author> <title> Report on the Programming Language Haskell. </title> <journal> ftp://haskell.systemsz.cs.yale.edu/pub/haskell/report/- report-1.2.dvi.Z, </journal> <note> version 1.2 edition, </note> <month> March </month> <year> 1992. </year>
Reference-contexts: The Common Lisp function make-array likewise allows the specification of a type for elements of an array, presumably with similar benefits. The Haskell language <ref> [15] </ref> is a purely functional, lazy (normal-order evaluation) language. Haskell defines lazy lists, which are equivalent to the stream type of an eager languages, and the preliminary definition of standard libraries [12] defines lazy arrays.
Reference: [16] <author> B. W. Kernighan and D. M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference-contexts: Language support for arrays in Fortran includes convenient iterative constructs, and (unsafe) array subscripting and update using special syntax. Arrays in C are described by Kernighan and Ritchie in the original C language manual <ref> [16] </ref>. C arrays have the same operations as Fortran arrays, and in addition provide the ability to maintain a pointer into the middle of an array and arithmetic on such pointers, allowing (unsafe) array access and update without the need for explicit integer arithmetic and subscripting.
Reference: [17] <author> John McCarthy. </author> <title> The history of LISP. </title> <editor> In Richard L. Wexelblat, editor, </editor> <booktitle> History of Programming Languages. Proc. ACM SIGPLAN conference, </booktitle> <pages> pages 173-197. </pages> <publisher> Academic Press, </publisher> <month> June </month> <year> 1978. </year>
Reference-contexts: As in the case of SML arrays, this safety comes at a cost in performance, and Modula-3 lets programmers turn off bounds checks when access performance is crucial. 5.2 LISP and Scheme The properties of LISP lists are described by John McCarty in his history of LISP <ref> [17] </ref>; modern versions of LISP include Common Lisp [23] and Scheme [21].
Reference: [18] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: to be implemented as either vectors or lists, whereas the sequence interface described in this report is specifically designed to be implemented by a variety of different data structures, including user-defined data structures. 5.3 Standard ML and Haskell The Standard ML language is defined formally by Milner, Tofte, and Harper <ref> [18] </ref>. The language is distinct from LISP in providing static types and a rich module system, including interface inheritance.
Reference: [19] <author> Greg Nelson. </author> <title> Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: C also provides dynamic allocation and deallocation of memory, allowing the implementation of lists, trees, and other dynamic data structures. Modula-3 <ref> [19] </ref> is another modern language with arrays as the fundamental aggregate data type. Unlike C or Fortran, Modula-3 array accesses are safe, that is, the indices are always checked against the bounds of the array before the access is performed.
Reference: [20] <author> Chris Okasaki. </author> <title> Purely functional random-access lists. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 86-95, </pages> <year> 1995. </year>
Reference-contexts: they are a single type, so that any actually implementation of the language has to choose between list-like performance and array-like performance, i.e. accepting O (n) cost for either the prefixing or the indexing operation, or must employ some other data structure (e.g. the purely functional random-access lists of Okasaki <ref> [20] </ref>) with at best O (log n) for indexing 3 . The generic sequence interface presented in this report allows but does not require that a sequence be capable of extension, and this makes it possible to use it as an interface to both lists and arrays.
Reference: [21] <author> J. Rees, W. Clinger, H. Abelson, IV N. I. Adams, D. H. Bartley, H. Brooks, R. K. Dybvig, D. P. Friedman, R. Halstead, C. Hanson, C. T Haynes, E. Kohlbeker, D. Oxley, K. M. Pitman, G. J. Rozas, G. J. Sussman, and M. Wand. </author> <title> Revised report on the algorithmic language scheme. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(12), </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: safety comes at a cost in performance, and Modula-3 lets programmers turn off bounds checks when access performance is crucial. 5.2 LISP and Scheme The properties of LISP lists are described by John McCarty in his history of LISP [17]; modern versions of LISP include Common Lisp [23] and Scheme <ref> [21] </ref>. Language support for lists in LISP includes accessing the first element of a list and obtaining a list with all but the first element, and also modifying the first element of a list and the spine of a list.
Reference: [22] <author> John H. Reppy. </author> <title> CML: A higer-order concurrent language. </title> <booktitle> In Programming Language Design Implementation, </booktitle> <pages> pages 294-305, </pages> <month> June </month> <year> 1991. </year> <note> also appears in SIGPLAN Notices, 26(6). </note>
Reference-contexts: The former is strictly sequential, the latter does not define access order and therefore permits strictly sequential implementation. The sequence interface can therefore be efficiently implemented by any implementation that allows efficient sequential access, including lists, arrays, streams, and CML (concurrent) channels <ref> [22] </ref>. Unlike list types in conventional functional languages, array types are mutable. This report describes a set of operations for mutating arrays that allow the same style of looping as the conventional list operations and also can be implemented efficiently on conventional architectures.
Reference: [23] <author> Guy L. Steele Jr. </author> <title> Common LISP: The Language (Second Edition). </title> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference-contexts: has been reached. 3 Monomorphic Sequences and Word Arrays 3.1 Monomorphic Sequences The sequences described in the previous section are polymorphic, that is, the source code of the implementation of any one of the sequence operations will not make any assumptions about the 2 The vector-push operation in Common Lisp <ref> [23] </ref> is similar to update, but differs in that the return value is not a new updatable array; furthermore, the return value cannot be tested easily to check for the end of the array until after an update has failed. 5 representation of data. <p> SML arrays, this safety comes at a cost in performance, and Modula-3 lets programmers turn off bounds checks when access performance is crucial. 5.2 LISP and Scheme The properties of LISP lists are described by John McCarty in his history of LISP [17]; modern versions of LISP include Common Lisp <ref> [23] </ref> and Scheme [21]. Language support for lists in LISP includes accessing the first element of a list and obtaining a list with all but the first element, and also modifying the first element of a list and the spine of a list. <p> Common Lisp and Scheme both support arrays (called vectors in Scheme) by providing access and update operations and looping constructs. Common Lisp, in particular, has a sequence type, described in Chapter 14 of the Common Lisp book <ref> [23] </ref>: The type sequence encompasses both lists and vectors (one-dimensional arrays). While these are different data structures with different structural properties leading to different algorithmic uses, they do have a common property: each contains an ordered set of elements.
Reference: [24] <author> Andrew Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proc. 1994 Lisp and Functional Programming, </booktitle> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Algorithms for tagless (type-directed) garbage collection have been described in detail elsewhere <ref> [2, 24, 1] </ref>, and may be useful in addressing this issue. 5 Background 5.1 Programming Languages with Arrays Fortran arrays are described by John Backus in his history of Fortran [7]. Language support for arrays in Fortran includes convenient iterative constructs, and (unsafe) array subscripting and update using special syntax.
Reference: [25] <author> Richard C. Waters. </author> <title> Obviously synchronizable series expressions: Part I: User's manual for the OSS macro package. </title> <type> Technical Report AI Memo 958a, </type> <institution> MIT A.I. Lab, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Likewise, the Obviously Synchronizable Series Expressions developed by Waters <ref> [27, 25, 26] </ref>) provide aggregate operations only, with the explicit goal of optimizing loops. Obviously Synchronizable Series Expressions go beyond the work presented in this report in that storage for intermediate results is automatically eliminated where possible. No such result is claimed for sequence types.
Reference: [26] <author> Richard C. Waters. </author> <title> Obviously synchronizable series expressions: Part II: Overview of the theory and implementation. </title> <type> Technical Report AI Memo 958b, </type> <institution> MIT A.I. Lab, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Likewise, the Obviously Synchronizable Series Expressions developed by Waters <ref> [27, 25, 26] </ref>) provide aggregate operations only, with the explicit goal of optimizing loops. Obviously Synchronizable Series Expressions go beyond the work presented in this report in that storage for intermediate results is automatically eliminated where possible. No such result is claimed for sequence types.
Reference: [27] <author> Richard C. Waters. </author> <title> Automatic transformation of series expressions into loops. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 52-98, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Likewise, the Obviously Synchronizable Series Expressions developed by Waters <ref> [27, 25, 26] </ref>) provide aggregate operations only, with the explicit goal of optimizing loops. Obviously Synchronizable Series Expressions go beyond the work presented in this report in that storage for intermediate results is automatically eliminated where possible. No such result is claimed for sequence types.
Reference: [28] <author> Amy Moormann Zaremski and Jeannette M. Wing. </author> <title> Specification matching of software components. </title> <type> Technical Report CMU-CS-95-127, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> March </month> <year> 1995. </year> <note> 14 7 Appendices </note>
Reference-contexts: Larch [14] is a formal specification system for programs. The sequence specification given by Moormann Zaremski and Wing <ref> [28] </ref> was one of the inspirations for the development of the sequence interface described in this report, though the inspiration was somewhat indirect since the sequence trait described by Moormann Zaremski and Wing differs substantially from the sequence interface in this report. 5.5 Motivation: The Fox Project The original motivation for
References-found: 28

