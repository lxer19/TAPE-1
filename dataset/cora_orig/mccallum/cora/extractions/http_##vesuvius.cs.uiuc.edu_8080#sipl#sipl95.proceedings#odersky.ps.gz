URL: http://vesuvius.cs.uiuc.edu:8080/sipl/sipl95.proceedings/odersky.ps.gz
Refering-URL: http://vesuvius.cs.uiuc.edu:8080/sipl/sipl95.proceedings.html
Root-URL: http://www.cs.uiuc.edu
Email: odersky@ira.uka.de  
Title: Applying Towards a Basis for Concurrent Imperative Programming  
Author: Martin Odersky 
Keyword: Church-encodings in lambda calculus.  
Date: December 22, 1994  
Address: 76128 Karlsruhe, Germany  
Affiliation: Universitat Karlsruhe  
Abstract: We study an extension of asynchronous -calculus where names can be returned from processes. We show that with this simple extension an extensive range of functional, state-based and control-based programming constructs can be expressed by macro expansions, similar to 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Samson Abramsky. </author> <title> Computational interpretations of linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 111 </volume> <pages> 3-57, </pages> <year> 1993. </year>
Reference-contexts: First, applied 's abstractions can be used only once, unless they are prefixed by a (!) replicator. This is similar to the role of abstractions in linear -calculus <ref> [1] </ref>. Second, an abstraction and its argument are matched by name rather than by position. Fresh local names are introduced by a restriction prefix -x (this has also been studied in the context of -calculus [22, 18]).
Reference: [2] <author> Dave Berry, Robin Milner, and David N. Turner. </author> <title> A semantics for ML concurrency primitives. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 119-129, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Traditionally, formal foundations for languages with concurrency constructs come in one of two styles. Most commonly, one combines a semantic description for the sequential base language with another one for the concurrency primitives. For instance, semantic descriptions of Facile [7] or CML <ref> [2] </ref> define a structured operational semantics for the base language as a special case of a larger labeled transition system that also models the concurrent aspects of the language.
Reference: [3] <author> Gerard Boudol. </author> <title> Towards a lambda-calculus for concurrent and communicating systems. </title> <editor> In J. Daz and F. Orejas, editors, </editor> <booktitle> Proceedings TAPSOFT '1989, </booktitle> <pages> pages 149-161, </pages> <address> New York, </address> <month> March </month> <year> 1989. </year> <note> Springer-Verlag. Lecture Notes in Computer Science 351. </note>
Reference-contexts: Sangiorgi has argued that the higher-order calculus improves on first-order calculus as a foundation for functional programming [24]. In a sense, applied 's ability to return a name from a process is an alternative to higher-order processes, since -abstractions can be represented. Boudol's fl-calculus <ref> [3] </ref> tries to generalize both CCS and -calculus. Like in | and unlike in applied | communicating agents are matched by position rather than just channel name. Our process equivalence relation is based on Milner's and Sangiorgi's barbed bisimulation [17].
Reference: [4] <author> Gerard Boudol. </author> <title> Asynchrony and the pi-calculus. </title> <type> Research Report 1702, </type> <institution> INRIA, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Alternatively, one can use a standard process calculus such as CCS [13] or -calculus [16] to reason about both the base language and the concurrency primitives. An example of this approach is the PICT programming language [21] that was designed with asynchronous -calculus <ref> [4] </ref> as a basis. PICT stays fairly close to the underlying calculus and consequently does not fully support sequential programming constructs such as functions or sequential composition. <p> There, one is transformed to the other via Church-encodings, which are pure macro expansions. In this paper we show that a modest change to a standard process calculus is sufficient to capture both call-by-value functional programming and imperative programming via similar encodings. The applied calculus augments asynchronous calculus <ref> [4] </ref> (which is essentially equivalent to --calculus [10]) with the ability to return a name from a process. Together with standard name restriction this gives us a way to model anonymous values in the calculus. <p> Section 7 concludes. 2 The Core Calculus Syntactic Domains Variables x; y; z Preterms M; N; P = x Variable j -x:M Restriction j x ? y:M Abstraction (Input) j xM Application (Output) j M j N Parallel Composition j !M Replication j 0 Identity We build on asynchronous -calculus <ref> [4] </ref>, modulo some minor notational modifications that are introduced for making the treatment of function application smoother. There is one extension: Processes may evaluate to names, and an arbitrary term instead of a single name may appear as the argument of an application.
Reference: [5] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <title> Modula-3 language definition. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(8) </volume> <pages> 15-42, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Most programming languages in use today have some way to express concurrent execution of processes either in the language itself (e.g. Ada [20], Modula-3 <ref> [5] </ref>, Facile [7], CML [23]) or by means of a library (e.g. Modula-2's Process module [28], C++'s thread library [25]). This paper proposes a formal basis for reasoning about such languages. Traditionally, formal foundations for languages with concurrency constructs come in one of two styles.
Reference: [6] <author> Matthias Felleisen and Robert Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 103 </volume> <pages> 235-271, </pages> <year> 1992. </year>
Reference-contexts: It turns out that this is all that is needed to encode essentially all sequential programming constructs in a concise and straightforward manner. Interestingly, with just seven term formation rules and one reduction rule, applied is more compact than calculi for sequential state-based languages <ref> [12, 6, 19] </ref>. This comparison is not completely fair, however, since the encoding into applied gives us only an operational understanding of functional and imperative constructs. Much less is known at present about the observational properties of the encodings. In general, process contexts discriminate more terms than sequential contexts.
Reference: [7] <author> Alessandro Giacalone, Prateek Mishra, and Sanjiva Prasad. </author> <title> Facile: A symmetric integration of concurrent and functional programming. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 18(2) </volume> <pages> 121-160, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Most programming languages in use today have some way to express concurrent execution of processes either in the language itself (e.g. Ada [20], Modula-3 [5], Facile <ref> [7] </ref>, CML [23]) or by means of a library (e.g. Modula-2's Process module [28], C++'s thread library [25]). This paper proposes a formal basis for reasoning about such languages. Traditionally, formal foundations for languages with concurrency constructs come in one of two styles. <p> Traditionally, formal foundations for languages with concurrency constructs come in one of two styles. Most commonly, one combines a semantic description for the sequential base language with another one for the concurrency primitives. For instance, semantic descriptions of Facile <ref> [7] </ref> or CML [2] define a structured operational semantics for the base language as a special case of a larger labeled transition system that also models the concurrent aspects of the language.
Reference: [8] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1985. </year>
Reference-contexts: We can force a wait for all M i 's by defining a blocking parallel composition ( jjj ) of independent subcomputations | this is essentially Hoare's interleave operator <ref> [8] </ref>.
Reference: [9] <author> Keiho Honda and Nobuko Yoshida. </author> <title> On reduction-based process semantics. </title> <booktitle> In Proc. 13th Conf. on Foundations of Softawre Technology and Theoretical Computer Science, </booktitle> <pages> pages 373-387, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Like in | and unlike in applied | communicating agents are matched by position rather than just channel name. Our process equivalence relation is based on Milner's and Sangiorgi's barbed bisimulation [17]. We adapt their definitions in a straightforward way to the asynchronous and applied case. Honda and Yoshida <ref> [9] </ref> have shown for an asynchronous calculus that barbed bisimulation has a tractable characterization that does not depend on a quantification over contexts. The rest of this paper is organized as follows. Section 2 presents an operational semantics for applied .
Reference: [10] <author> Kohei Honda and Mario Tokoro. </author> <title> An object calculus for asynchronous communication. </title> <booktitle> In Proc. 5th European Conference on Object-Oriented Programming, </booktitle> <pages> pages 133-147, </pages> <month> July </month> <year> 1991. </year> <note> Springer LNCS 512. </note>
Reference-contexts: In this paper we show that a modest change to a standard process calculus is sufficient to capture both call-by-value functional programming and imperative programming via similar encodings. The applied calculus augments asynchronous calculus [4] (which is essentially equivalent to --calculus <ref> [10] </ref>) with the ability to return a name from a process. Together with standard name restriction this gives us a way to model anonymous values in the calculus. <p> by: [[x]]r = rx [[x ? y:M ]]r = x ? (y; s):[[M ]]s [[M j N ]]r = [[M ]]r j [[N ]]r We use for brevity polyadic inputs x ? (y; z):M and outputs x (y; z) which can be expanded with Honda and Tokoro's "zip-lock" technique 2 <ref> [10] </ref>: x ? (y; z):M = x ? u:-v:(uv j v ? y:-w:(uw j w ? z:M )) def To show that this encoding is well-defined, have have to verify that it is insensitive to the preterm chosen to represent a term. Proposition 6.1 Let r be a name.
Reference: [11] <author> C.B. Jones. </author> <title> Process-algebraic foundations for an object-based design notation. </title> <type> Technical Report UMCS-93-10-1, </type> <institution> University of Manchester, </institution> <year> 1993. </year>
Reference-contexts: In effect, this leads to function definitions in PICT being CPS-converted one at a time. 1 [15] for the case of functions and by Walker [27] or Jones <ref> [11] </ref> for the case of objects. If our aim is to reason about source programs such encodings are undesirable since they are all-or-nothing propositions: To reason about one part of a program one must encode everything.
Reference: [12] <author> Ian Mason and Carolyn Talcott. </author> <title> Equivalence in functional languages with side effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(3) </volume> <pages> 287-327, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: It turns out that this is all that is needed to encode essentially all sequential programming constructs in a concise and straightforward manner. Interestingly, with just seven term formation rules and one reduction rule, applied is more compact than calculi for sequential state-based languages <ref> [12, 6, 19] </ref>. This comparison is not completely fair, however, since the encoding into applied gives us only an operational understanding of functional and imperative constructs. Much less is known at present about the observational properties of the encodings. In general, process contexts discriminate more terms than sequential contexts.
Reference: [13] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1989. </year>
Reference-contexts: This style of description has the advantage that a semantics of the sequential part of the language can be obtained by subsetting. However, the resulting formal systems tend to be large. Alternatively, one can use a standard process calculus such as CCS <ref> [13] </ref> or -calculus [16] to reason about both the base language and the concurrency primitives. An example of this approach is the PICT programming language [21] that was designed with asynchronous -calculus [4] as a basis.
Reference: [14] <author> Robin Milner. </author> <title> The polyadic -calculus: A tutorial. </title> <type> Report ECS-LFCS-91-180, </type> <institution> Laboratory for Foundations of Computer Science, Edinburgh University, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: Another open question concerns the relationship between the process equivalence theory of applied and the corresponding theory of the pure asynchronous calculus. Finally, it should be possible to define a typed version of applied by generalizing Milner's sorting approach for calculus <ref> [14] </ref>. Acknowledgments I'd like to thank John Maraist, for reading and commenting on previous drafts of this work, and Benjamin Pierce, for his thorough review, which was a great help in improving the paper.
Reference: [15] <author> Robin Milner. </author> <title> Functions as processes. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(2) </volume> <pages> 119-141, </pages> <year> 1992. </year>
Reference-contexts: In effect, this leads to function definitions in PICT being CPS-converted one at a time. 1 <ref> [15] </ref> for the case of functions and by Walker [27] or Jones [11] for the case of objects. If our aim is to reason about source programs such encodings are undesirable since they are all-or-nothing propositions: To reason about one part of a program one must encode everything.
Reference: [16] <author> Robin Milner, Joachim Parrow, and David Walker. </author> <title> A calculus of mobile processes, I + II. </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference-contexts: This style of description has the advantage that a semantics of the sequential part of the language can be obtained by subsetting. However, the resulting formal systems tend to be large. Alternatively, one can use a standard process calculus such as CCS [13] or -calculus <ref> [16] </ref> to reason about both the base language and the concurrency primitives. An example of this approach is the PICT programming language [21] that was designed with asynchronous -calculus [4] as a basis.
Reference: [17] <author> Robin Milner and D. Sangiorgi. </author> <title> Barbed bisimulation. </title> <booktitle> In Automata, Languages, and Programming, 19th International Colloquium, 1992. Lecture Notes in Computer Science 623. </booktitle>
Reference-contexts: Boudol's fl-calculus [3] tries to generalize both CCS and -calculus. Like in | and unlike in applied | communicating agents are matched by position rather than just channel name. Our process equivalence relation is based on Milner's and Sangiorgi's barbed bisimulation <ref> [17] </ref>. We adapt their definitions in a straightforward way to the asynchronous and applied case. Honda and Yoshida [9] have shown for an asynchronous calculus that barbed bisimulation has a tractable characterization that does not depend on a quantification over contexts. The rest of this paper is organized as follows. <p> For processes whose operational semantics is defined by means of a reduction relation, a particularly simple form of bisimulation can be devised, which tests only the possibility of interacting on a channel, but disregards what is communicated over it. This relation is called barbed bisimulation <ref> [17] </ref>. For applied , barbed bisimulation can be simplified further in that only the action of returning a name, but not input or output actions, can be observed. This is formalized in the following definitions. Definition.
Reference: [18] <author> Martin Odersky. </author> <title> A functional theory of local names. </title> <booktitle> In Proc. 21st ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 48-59, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: This is similar to the role of abstractions in linear -calculus [1]. Second, an abstraction and its argument are matched by name rather than by position. Fresh local names are introduced by a restriction prefix -x (this has also been studied in the context of -calculus <ref> [22, 18] </ref>).
Reference: [19] <author> Martin Odersky, Dan Rabin, and Paul Hudak. </author> <title> Call-by-name, assignment, and the lambda calculus. </title> <booktitle> In Proc. 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 43-56, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: It turns out that this is all that is needed to encode essentially all sequential programming constructs in a concise and straightforward manner. Interestingly, with just seven term formation rules and one reduction rule, applied is more compact than calculi for sequential state-based languages <ref> [12, 6, 19] </ref>. This comparison is not completely fair, however, since the encoding into applied gives us only an operational understanding of functional and imperative constructs. Much less is known at present about the observational properties of the encodings. In general, process contexts discriminate more terms than sequential contexts.
Reference: [20] <author> United States Department of Defense. </author> <title> The Programming Language Ada Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: 1 Introduction Most programming languages in use today have some way to express concurrent execution of processes either in the language itself (e.g. Ada <ref> [20] </ref>, Modula-3 [5], Facile [7], CML [23]) or by means of a library (e.g. Modula-2's Process module [28], C++'s thread library [25]). This paper proposes a formal basis for reasoning about such languages. Traditionally, formal foundations for languages with concurrency constructs come in one of two styles.
Reference: [21] <author> Benjamin C. Pierce, Didier Remy, and David N. Turner. </author> <title> A typed higher-order programming language based on the Pi-calculus. Draft report; available in the PICT distribution, </title> <month> July </month> <year> 1993. </year>
Reference-contexts: However, the resulting formal systems tend to be large. Alternatively, one can use a standard process calculus such as CCS [13] or -calculus [16] to reason about both the base language and the concurrency primitives. An example of this approach is the PICT programming language <ref> [21] </ref> that was designed with asynchronous -calculus [4] as a basis. PICT stays fairly close to the underlying calculus and consequently does not fully support sequential programming constructs such as functions or sequential composition.
Reference: [22] <author> Andrew Pitts and Ian Stark. </author> <title> On the observable properties of higher order functions that dynamically create local names. </title> <booktitle> In SIPL '93 ACM SIGPLAN Workshop on State in Programming Languages, Copenhagen, Denmark, </booktitle> <pages> pages 31-45, </pages> <month> June </month> <year> 1993. </year> <institution> Yale University Research Report YALEU/DCS/RR-968. </institution>
Reference-contexts: This is similar to the role of abstractions in linear -calculus [1]. Second, an abstraction and its argument are matched by name rather than by position. Fresh local names are introduced by a restriction prefix -x (this has also been studied in the context of -calculus <ref> [22, 18] </ref>).
Reference: [23] <author> John H. Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 293-305, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Most programming languages in use today have some way to express concurrent execution of processes either in the language itself (e.g. Ada [20], Modula-3 [5], Facile [7], CML <ref> [23] </ref>) or by means of a library (e.g. Modula-2's Process module [28], C++'s thread library [25]). This paper proposes a formal basis for reasoning about such languages. Traditionally, formal foundations for languages with concurrency constructs come in one of two styles.
Reference: [24] <author> Davide Sangiorgi. </author> <title> An investigation into functions as processes. </title> <booktitle> In Proc. 9th International Conference on the Mathematical Foundation of Programming Semantics, </booktitle> <address> New Orleans, </address> <publisher> Lousiana, </publisher> <pages> pages 143-159, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Related work. We have already mentioned the work on PICT and the encodings by Milner, Walker, and Jones. Sangiorgi has argued that the higher-order calculus improves on first-order calculus as a foundation for functional programming <ref> [24] </ref>. In a sense, applied 's ability to return a name from a process is an alternative to higher-order processes, since -abstractions can be represented. Boudol's fl-calculus [3] tries to generalize both CCS and -calculus.
Reference: [25] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction Most programming languages in use today have some way to express concurrent execution of processes either in the language itself (e.g. Ada [20], Modula-3 [5], Facile [7], CML [23]) or by means of a library (e.g. Modula-2's Process module [28], C++'s thread library <ref> [25] </ref>). This paper proposes a formal basis for reasoning about such languages. Traditionally, formal foundations for languages with concurrency constructs come in one of two styles. Most commonly, one combines a semantic description for the sequential base language with another one for the concurrency primitives.
Reference: [26] <author> Vipin Swarup, Uday S. Reddy, and Evan Ireland. </author> <title> Assignments for applicative languages. </title> <editor> In John Hugh-es, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 192-214. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year> <note> Lecture Notes in Computer Science 523. </note>
Reference: [27] <author> David Walker. </author> <title> -calculus semantics of object-oriented programming languages. </title> <editor> In Takayasu Ito and Albert R. Meyer, editors, </editor> <booktitle> Proc. Theoretical Aspects of Computer Software, </booktitle> <pages> pages 532-547. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1991. </year> <note> LNCS 526. </note>
Reference-contexts: In effect, this leads to function definitions in PICT being CPS-converted one at a time. 1 [15] for the case of functions and by Walker <ref> [27] </ref> or Jones [11] for the case of objects. If our aim is to reason about source programs such encodings are undesirable since they are all-or-nothing propositions: To reason about one part of a program one must encode everything.
Reference: [28] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer Verlag, </publisher> <address> 2nd edition, </address> <year> 1983. </year>
Reference-contexts: 1 Introduction Most programming languages in use today have some way to express concurrent execution of processes either in the language itself (e.g. Ada [20], Modula-3 [5], Facile [7], CML [23]) or by means of a library (e.g. Modula-2's Process module <ref> [28] </ref>, C++'s thread library [25]). This paper proposes a formal basis for reasoning about such languages. Traditionally, formal foundations for languages with concurrency constructs come in one of two styles. Most commonly, one combines a semantic description for the sequential base language with another one for the concurrency primitives.
References-found: 28

