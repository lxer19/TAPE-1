URL: ftp://ftp.eecs.umich.edu/people/rundenst/papers/r-94-1.ps
Refering-URL: http://www.eecs.umich.edu/~rundenst/group/papers.html
Root-URL: http://www.cs.umich.edu
Title: Schema Evolution for Real-Time Object-Oriented Databases 1  
Author: Lei Zhou, Elke A. Rundensteiner, and Kang G. Shin 
Keyword: Key words: Object-oriented database, real-time data model, performance polymorphism, letter class hierarchy, schema evolution.  
Address: Ann Arbor, Michigan 48105-2122  
Affiliation: Department of Electrical Engineering and Computer Science The University of Michigan  
Pubnum: Technical Report CSE-TR-199-94,  
Email: -lzhou, rundenst, kgshin-@eecs.umich.edu  
Phone: Fax: (313) 763-4617  
Date: March 1994  
Abstract: It has been shown that the database schemata often experience considerable changes during the development and initial use phases of database systems for advanced applications, such as automated manufacturing and computer-aided design. An automated schema evolution system can significantly reduce the amount of work and potential errors related to schema changes. Although schema evolution for non-real-time databases was the subject of some previous research, its impact on real-time database systems remains unexplored. Since these advanced applications typically utilize object-oriented models to handle complex data types and there exists no agreed-upon real-time object model that can be used as foundation to define a schema evolution framework, we first design a conceptual real-time object-oriented data model, called ROMPP. It captures the key characteristics of real-time applications, namely, timing constraints and performance polymorphism. It uses specialization dimensions to model timing specifications and letter class hierarchies to capture performance polymorphism. We then re-evaluate previous (non-real-time) schema evolution support in the context of real-time databases, which results in several modifications to the semantics of schema changes and to the needs of schema change resolution rules and schema invariants. Furthermore, we expand the schema change framework with new constructsincluding new schema change operators, new resolution rules, and new invariantsfor handling additional features of the real-time object model. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Anderson, </author> <title> Next Generation Workstation/Machine Controller (NGC), </title> <booktitle> Proc. </booktitle> <address> IPC92, </address> <month> April </month> <year> 1992, </year> <pages> pages xix-xxvi. </pages>
Reference-contexts: In particular, each directed edge from to , denoted by , represents the is-a relationship ( is-a ). 2.2 Key Characteristics Based on our evaluation of existing real-time systems [3, 9, 12, 14, 16, 20, 31] and real-time manufacturing applications <ref> [1, 4, 19] </ref>, we have identified two key characteristics for real-time data models: timing constraints and performance polymorphism. 2.2.1 Timing Constraints The first key characteristic is the concept of timing constraints.
Reference: [2] <author> Jay Banerjee, et al., </author> <title> Semantics and Implementation of Schema Evolution in Object-Oriented Databases, </title> <booktitle> SIGMOD 1987, </booktitle> <pages> pages 311-322. </pages>
Reference-contexts: It uses specialization dimensions to model timing specifications and letter class hierarchies to capture performance polymorphism. We then develop a framework for changes to schemata of real-time OODBs based on the typical schema change taxonomy <ref> [2] </ref>. Schema evolution has been defined for simple (non-real-time) object-oriented models [2, 22, 24, 32]. <p> It uses specialization dimensions to model timing specifications and letter class hierarchies to capture performance polymorphism. We then develop a framework for changes to schemata of real-time OODBs based on the typical schema change taxonomy [2]. Schema evolution has been defined for simple (non-real-time) object-oriented models <ref> [2, 22, 24, 32] </ref>. We now re-evaluate this work in the context of real-time databases, which, as we will show, results in several modifications to the semantics of schema changes and to the needs of schema change resolution rules and schema invariants. <p> Having designed the real-time object model, we can now proceed with our task of defining schema evolution. For this purpose, we need to expand the typical steps of schema evolution <ref> [2] </ref> to the real-time object model: 1. Identify a schema change taxonomy. We need to determine which schema changes are meaningful, given the new definition of a RTOODB schema. 2. Identify schema change invariants. <p> The effect of each schema change identified in step 1 on the rest of the schema is investigated and its impact on the underlying data is also considered. 3.1 Schema Change Taxonomy One of the first object-oriented schema change approaches has been proposed by Banerjee et al. <ref> [2] </ref> for ORION. 5 Note that this taxonomy, adopted in most other schema evolution research for OODBs [22, 24, 32], still corresponds to the most frequently used set of schema changes. <p> a class C (2.3) Change the order of superclasses of a class C (3) Changes to a node (3.1) Add a new class (3.2) Drop an existing class (3.3) Change the name of a class Although a number of schema changes in our taxonomy are the same as those in <ref> [2] </ref>, we show in Section 3.4 that the semantics of these changes are quite different. In order to support changes of our model, we now must evaluate changes on both letter class and envelope class hierarchies. <p> We thus need schema invariants to define the correctness of schema properties. We have adopted the invariants proposed in <ref> [2] </ref> with some modifications: 1. Class Hierarchy Invariant. The class hierarchy is a rooted and connected directed acyclic graph with uniquely named nodes (classes) and unlabeled edges (subclass relationships) (see Definition 4). 2. Distinct Name (Signature) Invariant. All instance variables of a class must have distinct names. <p> Each specialization dimension has a unique identifier, which is specified for a method in an envelope class. The identifier can only be referenced with the same method of the letter classes associated with the envelope class. 3.3 Schema Change Rules We adopt rules similar to those defined in <ref> [2] </ref> and enhance them for our real-time object model. They apply to both envelope class hierarchies and letter class hierarchies. 1. <p> This name change may need to be registered with the corresponding envelope class. It may require its subclasses to change their parents name. 3.4.2 Schema Changes to an Envelope Class Hierarchy In general, changes to an envelope class hierarchy have similar semantics to those defined in <ref> [2] </ref>. In addition, the changes must be propagated to the corresponding letter classes, if any, as defined above, since letter class hierarchies are dependents of their corresponding envelope classes. They may cause reorganizations of the specialization spaces associated with letter class hierarchies. <p> Examples are schema evolution for ORION <ref> [2] </ref>, O 2 [32], GemStone [24], and GOOSE [22]. However, to the best of our knowledge, there has not been any work on defining schema evolution in the context of real-time OODBs.
Reference: [3] <author> Thomas E. Bihari, and Prabha Gopinath, </author> <title> Object-Oriented Real-Time Systems: Concepts and Examples, </title> <journal> IEEE Computers, </journal> <month> December </month> <year> 1992, </year> <pages> pages 25-32. </pages>
Reference-contexts: Real-time database research often uses the object-oriented paradigm. However, no agreed-upon real-time object-oriented data model is available at this time. Therefore, we first need to define a real-time data model, based on which we can develop a schema evolution framework. We have evaluated existing models used for real-time applications <ref> [3, 9, 12, 14, 16, 20, 31] </ref>. Based on this evaluation, we extract a simple yet powerful real-time object model that explicitly captures important characteristics of RTDB applications, especially in the manufacturing application domain, namely, timing constraints and performance polymorphism. <p> In particular, each directed edge from to , denoted by , represents the is-a relationship ( is-a ). 2.2 Key Characteristics Based on our evaluation of existing real-time systems <ref> [3, 9, 12, 14, 16, 20, 31] </ref> and real-time manufacturing applications [1, 4, 19], we have identified two key characteristics for real-time data models: timing constraints and performance polymorphism. 2.2.1 Timing Constraints The first key characteristic is the concept of timing constraints. <p> In this paper, we show that timing constraints and performance polymorphism are two key characteristics for the real-time applications and should be explicitly supported by an real-time data model. CHAOS (Concurrent Hierarchical Adaptable Object System) <ref> [3, 25] </ref> is an object-based language and programming/execution system designed for dynamic real-time applications. One of its key components is a C-based run-time library for the real-time kernel. CHAOS supports a limited form of dynamic parameterization of generic classes to allow easy development of different implementations of objects.
Reference: [4] <author> Sushil Birla, </author> <title> A Conceptual Framework for Modeling Manufacturing Automation, Directed Study Report, </title> <institution> Department of Electrical Engineering and Computer Science, The University of Michigan, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: In particular, each directed edge from to , denoted by , represents the is-a relationship ( is-a ). 2.2 Key Characteristics Based on our evaluation of existing real-time systems [3, 9, 12, 14, 16, 20, 31] and real-time manufacturing applications <ref> [1, 4, 19] </ref>, we have identified two key characteristics for real-time data models: timing constraints and performance polymorphism. 2.2.1 Timing Constraints The first key characteristic is the concept of timing constraints.
Reference: [5] <author> Grady Booch, </author> <title> Object-Oriented Design with Applications, </title> <address> Benjamin/Cummings, </address> <year> 1991. </year>
Reference-contexts: 1 INTRODUCTION The object-oriented approach has been shown to be an effective way to manage the development and maintenance of large complex systems, including real-time systems <ref> [5, 7] </ref>. Many advanced real-time applications, such as manufacturing workstations/cells and air traffic control systems, require a built-in database management system (DBMS) to support concurrent data access and provide well-defined interfaces between different software entities (tasks, processes, and modules).
Reference: [6] <author> Paul Butterworth, Allen Otis, and Jacob Stein, </author> <title> The Gemstone Object Database Management System, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 34, No. 10, </volume> <month> October </month> <year> 1991, </year> <pages> pages 64-77. </pages>
Reference-contexts: ROMPP adopts basic object-oriented concepts, such as class and inheritance, as can be found in most object-oriented models <ref> [6, 10, 15] </ref>. These concepts are defined below as needed for the remainder of this paper. 3 Definition 1.
Reference: [7] <author> R.G.G. Cattell, </author> <title> Object Data Management: Object-Oriented and Extended Relational Database Systems, </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: 1 INTRODUCTION The object-oriented approach has been shown to be an effective way to manage the development and maintenance of large complex systems, including real-time systems <ref> [5, 7] </ref>. Many advanced real-time applications, such as manufacturing workstations/cells and air traffic control systems, require a built-in database management system (DBMS) to support concurrent data access and provide well-defined interfaces between different software entities (tasks, processes, and modules).
Reference: [8] <author> James Coplien, </author> <title> Advanced C++ Programming Styles and Idioms, </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Should the performance requirements of an application change, the mechanism would transparently rebind the requested service with the most appropriate implementation. Performance polymorphism in ROMPP is captured by the letter class hierarchy, which is based on an object-oriented programming techniquethe envelope/letter structure <ref> [8] </ref>. Definition 8. An envelope/letter structure is a composite object structure formed by a pair of classes that act as one: an outer class (envelope class, or EC) that is the visible part to the user, and an inner class (letter class, or LC) that buries implementation details. Definition 9.
Reference: [9] <author> U. Dayal, et al., </author> <title> The HiPAC Project: Combining Active Databases and Timing Constraints, </title> <journal> SIG-MOD Record, </journal> <volume> Vol. 17, No. 1, </volume> <month> March </month> <year> 1988, </year> <pages> pages 51-70. </pages>
Reference-contexts: Real-time database research often uses the object-oriented paradigm. However, no agreed-upon real-time object-oriented data model is available at this time. Therefore, we first need to define a real-time data model, based on which we can develop a schema evolution framework. We have evaluated existing models used for real-time applications <ref> [3, 9, 12, 14, 16, 20, 31] </ref>. Based on this evaluation, we extract a simple yet powerful real-time object model that explicitly captures important characteristics of RTDB applications, especially in the manufacturing application domain, namely, timing constraints and performance polymorphism. <p> In particular, each directed edge from to , denoted by , represents the is-a relationship ( is-a ). 2.2 Key Characteristics Based on our evaluation of existing real-time systems <ref> [3, 9, 12, 14, 16, 20, 31] </ref> and real-time manufacturing applications [1, 4, 19], we have identified two key characteristics for real-time data models: timing constraints and performance polymorphism. 2.2.1 Timing Constraints The first key characteristic is the concept of timing constraints. <p> Also, the knowledge about the characteristics of the letter classes may be stored in individual envelope classes, such that different binding procedures may be chosen for different letter class hierarchies. HiPAC (High Performance ACtive database System) <ref> [9] </ref> combines databases with rule capabilities. Rules in HiPAC are first-class objects. A rule, among other features, allows the specification of its timing and other properties. When instances of the same class of rules are applied to different situations or objects, they may have different timing specifications.
Reference: [10] <editor> O. Deux, et al., </editor> <title> The O 2 System, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 34, No. 10, </volume> <month> October </month> <year> 1991, </year> <pages> pages 34-48. </pages>
Reference-contexts: ROMPP adopts basic object-oriented concepts, such as class and inheritance, as can be found in most object-oriented models <ref> [6, 10, 15] </ref>. These concepts are defined below as needed for the remainder of this paper. 3 Definition 1. <p> In fact, most commercial OODB systems have implemented a subset of this taxonomy as their schema change support <ref> [10, 13, 24] </ref>. None of these approaches considers real-time models. We adopt a similar schema change taxonomy, however, with extensions necessary for changes on real-time constructs of the schema.
Reference: [11] <author> Marc H. Graham, </author> <title> Issues in Real-Time Data Management, </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 4, </volume> <year> 1992, </year> <pages> pages 185-202. </pages>
Reference-contexts: Such inadequacy has recently spawned the field of real-time databases <ref> [11, 23, 26, 27, 30] </ref>. The requirements of a real-time system, like most other systems, are likely to change during its life cycle. The system must be able to evolve smoothly in order to improve its performance or to introduce new functionality, without disrupting existing services.
Reference: [12] <author> Yutaka Ishikawa, Hideyuki Tokuda, and Clifford W. Mercer, </author> <title> An Object-Oriented Real-Time Programming Language, </title> <booktitle> IEEE Computer, </booktitle> <month> October </month> <year> 1992, </year> <pages> pages 66-73. </pages>
Reference-contexts: Real-time database research often uses the object-oriented paradigm. However, no agreed-upon real-time object-oriented data model is available at this time. Therefore, we first need to define a real-time data model, based on which we can develop a schema evolution framework. We have evaluated existing models used for real-time applications <ref> [3, 9, 12, 14, 16, 20, 31] </ref>. Based on this evaluation, we extract a simple yet powerful real-time object model that explicitly captures important characteristics of RTDB applications, especially in the manufacturing application domain, namely, timing constraints and performance polymorphism. <p> In particular, each directed edge from to , denoted by , represents the is-a relationship ( is-a ). 2.2 Key Characteristics Based on our evaluation of existing real-time systems <ref> [3, 9, 12, 14, 16, 20, 31] </ref> and real-time manufacturing applications [1, 4, 19], we have identified two key characteristics for real-time data models: timing constraints and performance polymorphism. 2.2.1 Timing Constraints The first key characteristic is the concept of timing constraints. <p> These letter classes are specialized along several dimensionsthe parameterized attributes in CHAOS. ARTS (Advanced Real-time Technology) [20, 29] is a distributed real-time operating system kernel. RTC++ <ref> [12] </ref> is an extension of C++. Both of them are based on the same real-time object model, which describes real-time properties in systems and encapsulates rigid timing constraints in an object. Each object is composed of data, one or more threads of execution, and a set of exported operations.
Reference: [13] <institution> Itasca Systems, Inc., ITASCA System Overview, Unisys, Minneapolis, Minnesota, </institution> <year> 1990. </year>
Reference-contexts: In fact, most commercial OODB systems have implemented a subset of this taxonomy as their schema change support <ref> [10, 13, 24] </ref>. None of these approaches considers real-time models. We adopt a similar schema change taxonomy, however, with extensions necessary for changes on real-time constructs of the schema. <p> ORION is an OODB system built at MCC in Austin, Texas. A commercial product version of ORION is being mar keted as ITASCA <ref> [13] </ref>. 10 (2.2) Remove a class S from the superclass list of a class C (2.3) Change the order of superclasses of a class C (3) Changes to a node (3.1) Add a new class (3.2) Drop an existing class (3.3) Change the name of a class Although a number of
Reference: [14] <author> Kevin B. Kenny, and Kwei-Jay Lin, </author> <title> Building Flexible Real-Time Systems Using the Flex Language, </title> <booktitle> IEEE Computer, </booktitle> <month> May </month> <year> 1991, </year> <pages> pages 70-78. </pages>
Reference-contexts: Real-time database research often uses the object-oriented paradigm. However, no agreed-upon real-time object-oriented data model is available at this time. Therefore, we first need to define a real-time data model, based on which we can develop a schema evolution framework. We have evaluated existing models used for real-time applications <ref> [3, 9, 12, 14, 16, 20, 31] </ref>. Based on this evaluation, we extract a simple yet powerful real-time object model that explicitly captures important characteristics of RTDB applications, especially in the manufacturing application domain, namely, timing constraints and performance polymorphism. <p> In particular, each directed edge from to , denoted by , represents the is-a relationship ( is-a ). 2.2 Key Characteristics Based on our evaluation of existing real-time systems <ref> [3, 9, 12, 14, 16, 20, 31] </ref> and real-time manufacturing applications [1, 4, 19], we have identified two key characteristics for real-time data models: timing constraints and performance polymorphism. 2.2.1 Timing Constraints The first key characteristic is the concept of timing constraints. <p> As discussed in Section 2.2.2, this is an undesirable solution in comparison with direct support of performance polymorphism. In ROMPP, we address this issue by explicitly supporting performance polymorphism, using the letter class hierarchy concept. Flex <ref> [14] </ref> is a derivative of C++. It supports two modes of exible real-time programs, designed to adjust execution times so that all important deadlines are guaranteed to be met. First, it allows computations to return imprecise results.
Reference: [15] <author> Won Kim, et al., </author> <title> Architecture of the ORION Next-Generation Database System, </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> Vol. 2, No. 1, </volume> <month> March </month> <year> 1990, </year> <pages> pages 109-124. </pages>
Reference-contexts: ROMPP adopts basic object-oriented concepts, such as class and inheritance, as can be found in most object-oriented models <ref> [6, 10, 15] </ref>. These concepts are defined below as needed for the remainder of this paper. 3 Definition 1.
Reference: [16] <author> Victor B. Lortz, </author> <title> An Object-Oriented Real-Time Database System for Multiprocessors, </title> <type> Ph.D. dissertation, </type> <institution> Department of Electrical Engineering and Computer Science, The University of Michigan, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: Real-time database research often uses the object-oriented paradigm. However, no agreed-upon real-time object-oriented data model is available at this time. Therefore, we first need to define a real-time data model, based on which we can develop a schema evolution framework. We have evaluated existing models used for real-time applications <ref> [3, 9, 12, 14, 16, 20, 31] </ref>. Based on this evaluation, we extract a simple yet powerful real-time object model that explicitly captures important characteristics of RTDB applications, especially in the manufacturing application domain, namely, timing constraints and performance polymorphism. <p> In particular, each directed edge from to , denoted by , represents the is-a relationship ( is-a ). 2.2 Key Characteristics Based on our evaluation of existing real-time systems <ref> [3, 9, 12, 14, 16, 20, 31] </ref> and real-time manufacturing applications [1, 4, 19], we have identified two key characteristics for real-time data models: timing constraints and performance polymorphism. 2.2.1 Timing Constraints The first key characteristic is the concept of timing constraints. <p> Wolfe et al. [31] propose an object-oriented model that supports the explicit specification of timing constraints, however, performance polymorphism is again not provided. MDARTS (Multiprocessor Database Architecture for Real-Time Systems) <ref> [16, 17] </ref>, developed at the University of Michigan, supports explicit declarations of real-time requirements and semantic constraints within application code. It examines these declarations during application initialization and dynamically adjusts its data management strategy accordingly. The research reported in this paper is an integral part of the ongoing MDARTS project. <p> In particular, we want to discuss how it can be used to build real-time applications. The key concepts of ROMPP, namely, using specialization dimensions to characterize timing constraints and using letter class hierarchies to capture performance polymorphism are incorporated in MDARTS <ref> [16, 17] </ref>. MDARTS is a multiprocessor database architecture for real-time systems, being built in C++ in the Unix environment at the University of Michigan.
Reference: [17] <author> Victor B. Lortz, and Kang G. Shin, MDARTS: </author> <title> A Multiprocessor Database Architecture for Real-Time Systems, </title> <type> Technical Report CSE-TR-155-93, </type> <institution> Department of Electrical Engineering and Computer Science, The University of Michigan, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Wolfe et al. [31] propose an object-oriented model that supports the explicit specification of timing constraints, however, performance polymorphism is again not provided. MDARTS (Multiprocessor Database Architecture for Real-Time Systems) <ref> [16, 17] </ref>, developed at the University of Michigan, supports explicit declarations of real-time requirements and semantic constraints within application code. It examines these declarations during application initialization and dynamically adjusts its data management strategy accordingly. The research reported in this paper is an integral part of the ongoing MDARTS project. <p> In particular, we want to discuss how it can be used to build real-time applications. The key concepts of ROMPP, namely, using specialization dimensions to characterize timing constraints and using letter class hierarchies to capture performance polymorphism are incorporated in MDARTS <ref> [16, 17] </ref>. MDARTS is a multiprocessor database architecture for real-time systems, being built in C++ in the Unix environment at the University of Michigan.
Reference: [18] <author> S. Marche, </author> <title> Measuring the Stability of Data Models, </title> <journal> European Journal of Information Systems, </journal> <volume> Vol. 2, No. 1, </volume> <year> 1993, </year> <pages> pages 37-47. </pages>
Reference-contexts: There was an increase of 139% in the number of relations and 274% in the number of attributes in the system during the nineteen-month period of study. In <ref> [18] </ref>, significant changes (about 59% of attributes on the average) were reported for seven applications. These applications varied from project tracking, real estate inventory and accounting and sales management, to government administration of the skill trades and apprenticeship programs.
Reference: [19] <author> Martin Marietta Astronautics Group, </author> <title> Next Generation Workstation/Machine Controller Specification for an Open System Architecture Standard, </title> <address> NGC-0001-13-000-SYS edition, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: In particular, each directed edge from to , denoted by , represents the is-a relationship ( is-a ). 2.2 Key Characteristics Based on our evaluation of existing real-time systems [3, 9, 12, 14, 16, 20, 31] and real-time manufacturing applications <ref> [1, 4, 19] </ref>, we have identified two key characteristics for real-time data models: timing constraints and performance polymorphism. 2.2.1 Timing Constraints The first key characteristic is the concept of timing constraints.
Reference: [20] <author> Clifford W. Mercer, and Hideyuki Tokuda, </author> <title> The ARTS Real-Time Object Model, </title> <booktitle> Proceedings of the 11th Real-Time Systems Symposium, </booktitle> <year> 1990, </year> <pages> pages 2-10. </pages>
Reference-contexts: Real-time database research often uses the object-oriented paradigm. However, no agreed-upon real-time object-oriented data model is available at this time. Therefore, we first need to define a real-time data model, based on which we can develop a schema evolution framework. We have evaluated existing models used for real-time applications <ref> [3, 9, 12, 14, 16, 20, 31] </ref>. Based on this evaluation, we extract a simple yet powerful real-time object model that explicitly captures important characteristics of RTDB applications, especially in the manufacturing application domain, namely, timing constraints and performance polymorphism. <p> In particular, each directed edge from to , denoted by , represents the is-a relationship ( is-a ). 2.2 Key Characteristics Based on our evaluation of existing real-time systems <ref> [3, 9, 12, 14, 16, 20, 31] </ref> and real-time manufacturing applications [1, 4, 19], we have identified two key characteristics for real-time data models: timing constraints and performance polymorphism. 2.2.1 Timing Constraints The first key characteristic is the concept of timing constraints. <p> The parameterization of generic classes in CHAOS can be directly modeled by ROMPP, where envelope classes can represent generic classes and letter classes correspond to different implementations. These letter classes are specialized along several dimensionsthe parameterized attributes in CHAOS. ARTS (Advanced Real-time Technology) <ref> [20, 29] </ref> is a distributed real-time operating system kernel. RTC++ [12] is an extension of C++. Both of them are based on the same real-time object model, which describes real-time properties in systems and encapsulates rigid timing constraints in an object.
Reference: [21] <author> Simon Monk, and Ian Sommerville, </author> <title> Schema Evolution in OODBs Using Class Versioning, </title> <journal> SIG-MOD Record, </journal> <volume> Vol. 22, No. 3, </volume> <month> September </month> <year> 1993, </year> <pages> pages 16-22. </pages>
Reference-contexts: One approach of converting existing instances of the affected letter class to instances of the new letter class is to provide forward mapping functions or update methods <ref> [21] </ref>. 3.4.1 Schema Changes to a Letter Class Hierarchy (1) Changes to the contents of a node (a class) (1.1) Changes to an instance variable (1.1.1) Add a new instance variable to a class The descendants of the class are informed of the change in order to adjust their memory allocation.
Reference: [22] <author> Magdi M.A. Morsi, Shamkant B. Navathe, and Hyoung-Joo Kim, </author> <title> A Schema Management and 20 Prototyping Interface for an Object-Oriented Database Environment, </title> <editor> in F. Van Assche, B. Mou-lin, and C. Rolland (Editors), </editor> <title> Object Oriented Approach in Information Systems, </title> <publisher> Elsevier Science Publishers B.V., </publisher> <year> 1991, </year> <pages> pages 157-180. </pages>
Reference-contexts: It uses specialization dimensions to model timing specifications and letter class hierarchies to capture performance polymorphism. We then develop a framework for changes to schemata of real-time OODBs based on the typical schema change taxonomy [2]. Schema evolution has been defined for simple (non-real-time) object-oriented models <ref> [2, 22, 24, 32] </ref>. We now re-evaluate this work in the context of real-time databases, which, as we will show, results in several modifications to the semantics of schema changes and to the needs of schema change resolution rules and schema invariants. <p> the schema is investigated and its impact on the underlying data is also considered. 3.1 Schema Change Taxonomy One of the first object-oriented schema change approaches has been proposed by Banerjee et al. [2] for ORION. 5 Note that this taxonomy, adopted in most other schema evolution research for OODBs <ref> [22, 24, 32] </ref>, still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems have implemented a subset of this taxonomy as their schema change support [10, 13, 24]. None of these approaches considers real-time models. <p> Examples are schema evolution for ORION [2], O 2 [32], GemStone [24], and GOOSE <ref> [22] </ref>. However, to the best of our knowledge, there has not been any work on defining schema evolution in the context of real-time OODBs. We adopt the typical steps of schema evolution and expand them for the real-time object model (see Section 3).
Reference: [23] <author> Krithi Ramamritham, </author> <title> Real-Time Databases, Distributed and Parallel Databases, </title> <type> 1, </type> <year> 1993, </year> <pages> pages 199-226. </pages>
Reference-contexts: Such inadequacy has recently spawned the field of real-time databases <ref> [11, 23, 26, 27, 30] </ref>. The requirements of a real-time system, like most other systems, are likely to change during its life cycle. The system must be able to evolve smoothly in order to improve its performance or to introduce new functionality, without disrupting existing services.
Reference: [24] <author> J. Penney, and J. Stein, </author> <title> Class Modification in the GemStore Object-Oriented Database System, </title> <booktitle> Proceedings of the 2nd International Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <month> October </month> <year> 1987. </year>
Reference-contexts: It uses specialization dimensions to model timing specifications and letter class hierarchies to capture performance polymorphism. We then develop a framework for changes to schemata of real-time OODBs based on the typical schema change taxonomy [2]. Schema evolution has been defined for simple (non-real-time) object-oriented models <ref> [2, 22, 24, 32] </ref>. We now re-evaluate this work in the context of real-time databases, which, as we will show, results in several modifications to the semantics of schema changes and to the needs of schema change resolution rules and schema invariants. <p> the schema is investigated and its impact on the underlying data is also considered. 3.1 Schema Change Taxonomy One of the first object-oriented schema change approaches has been proposed by Banerjee et al. [2] for ORION. 5 Note that this taxonomy, adopted in most other schema evolution research for OODBs <ref> [22, 24, 32] </ref>, still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems have implemented a subset of this taxonomy as their schema change support [10, 13, 24]. None of these approaches considers real-time models. <p> In fact, most commercial OODB systems have implemented a subset of this taxonomy as their schema change support <ref> [10, 13, 24] </ref>. None of these approaches considers real-time models. We adopt a similar schema change taxonomy, however, with extensions necessary for changes on real-time constructs of the schema. <p> Examples are schema evolution for ORION [2], O 2 [32], GemStone <ref> [24] </ref>, and GOOSE [22]. However, to the best of our knowledge, there has not been any work on defining schema evolution in the context of real-time OODBs. We adopt the typical steps of schema evolution and expand them for the real-time object model (see Section 3).
Reference: [25] <author> Karsten Schwan, Prabha Gopinath, </author> <title> and Win Bo, CHAOS-Kernel Support for Objects in the Real-Time Domain, </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. C-36, No. 8, </volume> <month> August </month> <year> 1987, </year> <pages> pages 904-916. </pages>
Reference-contexts: In this paper, we show that timing constraints and performance polymorphism are two key characteristics for the real-time applications and should be explicitly supported by an real-time data model. CHAOS (Concurrent Hierarchical Adaptable Object System) <ref> [3, 25] </ref> is an object-based language and programming/execution system designed for dynamic real-time applications. One of its key components is a C-based run-time library for the real-time kernel. CHAOS supports a limited form of dynamic parameterization of generic classes to allow easy development of different implementations of objects.
Reference: [26] <author> Kang G. Shin, and Parameswaran Ramanathan, </author> <title> Real-Time Computing: A New Discipline of Computer Science and Engineering, </title> <journal> IEEE Proceedings, </journal> <volume> Vol. 82, No. 1, </volume> <month> January </month> <year> 1994, </year> <pages> pages 6-24. </pages>
Reference-contexts: They typically are subject to a range of timing constraints, which require the DBMS to provide timing guarantees, sometimes, under complex conditions. The deadlines of real-time tasks can be classified as hard, firm, or soft <ref> [26] </ref>. A deadline is said to be hard if the consequences of not meeting it can be catastrophic, such as in a nuclear reactor controller. <p> Such inadequacy has recently spawned the field of real-time databases <ref> [11, 23, 26, 27, 30] </ref>. The requirements of a real-time system, like most other systems, are likely to change during its life cycle. The system must be able to evolve smoothly in order to improve its performance or to introduce new functionality, without disrupting existing services.
Reference: [27] <author> Mukesh Singhal, </author> <title> Issues and Approaches to Design of Real-Time Database Systems, </title> <booktitle> SIGMOD Record, </booktitle> <volume> Vol. 17, No. 1, </volume> <month> March </month> <year> 1988, </year> <pages> pages 19-33. </pages>
Reference-contexts: Such inadequacy has recently spawned the field of real-time databases <ref> [11, 23, 26, 27, 30] </ref>. The requirements of a real-time system, like most other systems, are likely to change during its life cycle. The system must be able to evolve smoothly in order to improve its performance or to introduce new functionality, without disrupting existing services.
Reference: [28] <author> Dag Sjberg, </author> <title> Quantifying Schema Evolution, </title> <journal> Information and Software Technology, </journal> <volume> Vol. 35, No. 1, </volume> <month> January </month> <year> 1993, </year> <pages> pages 35-54. </pages>
Reference-contexts: The system must be able to evolve smoothly in order to improve its performance or to introduce new functionality, without disrupting existing services. The extent of changes in a typical working relational database system is illustrated in <ref> [28] </ref>, which documents the measurement of schema evolution in the development and initial use of a health management system used in several hospitals. There was an increase of 139% in the number of relations and 274% in the number of attributes in the system during the nineteen-month period of study.
Reference: [29] <author> Hideyuki Tokuda, and Clifford W. Mercer, </author> <title> ARTS: A Distributed Real-Time Kernel, </title> <journal> ACM Operating Systems Review, </journal> <volume> 23(3), </volume> <month> July </month> <year> 1989, </year> <pages> pages 29-53. </pages>
Reference-contexts: The parameterization of generic classes in CHAOS can be directly modeled by ROMPP, where envelope classes can represent generic classes and letter classes correspond to different implementations. These letter classes are specialized along several dimensionsthe parameterized attributes in CHAOS. ARTS (Advanced Real-time Technology) <ref> [20, 29] </ref> is a distributed real-time operating system kernel. RTC++ [12] is an extension of C++. Both of them are based on the same real-time object model, which describes real-time properties in systems and encapsulates rigid timing constraints in an object.
Reference: [30] <author> Ozgur Ulusoy, </author> <booktitle> Current Research on Real-Time Databases, SIGMOD Record, </booktitle> <volume> Vol. 21, No. 4, </volume> <month> December </month> <year> 1992, </year> <pages> pages 16-21. </pages>
Reference-contexts: Such inadequacy has recently spawned the field of real-time databases <ref> [11, 23, 26, 27, 30] </ref>. The requirements of a real-time system, like most other systems, are likely to change during its life cycle. The system must be able to evolve smoothly in order to improve its performance or to introduce new functionality, without disrupting existing services.
Reference: [31] <author> Victor F. Wolfe, et al., </author> <title> A Model For Real-Time Object-Oriented Databases, </title> <booktitle> Proceedings of the Tenth IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <month> May </month> <year> 1993, </year> <pages> pages 57-63. </pages>
Reference-contexts: Real-time database research often uses the object-oriented paradigm. However, no agreed-upon real-time object-oriented data model is available at this time. Therefore, we first need to define a real-time data model, based on which we can develop a schema evolution framework. We have evaluated existing models used for real-time applications <ref> [3, 9, 12, 14, 16, 20, 31] </ref>. Based on this evaluation, we extract a simple yet powerful real-time object model that explicitly captures important characteristics of RTDB applications, especially in the manufacturing application domain, namely, timing constraints and performance polymorphism. <p> In particular, each directed edge from to , denoted by , represents the is-a relationship ( is-a ). 2.2 Key Characteristics Based on our evaluation of existing real-time systems <ref> [3, 9, 12, 14, 16, 20, 31] </ref> and real-time manufacturing applications [1, 4, 19], we have identified two key characteristics for real-time data models: timing constraints and performance polymorphism. 2.2.1 Timing Constraints The first key characteristic is the concept of timing constraints. <p> Obviously, the letter class hierarchy can be used to model this characteristic of rules, where an envelope class represents a generic rule (or a class of rules) and letter classes represent the same rule with different timing specifications, which may require different implementations. Wolfe et al. <ref> [31] </ref> propose an object-oriented model that supports the explicit specification of timing constraints, however, performance polymorphism is again not provided. MDARTS (Multiprocessor Database Architecture for Real-Time Systems) [16, 17], developed at the University of Michigan, supports explicit declarations of real-time requirements and semantic constraints within application code.
Reference: [32] <author> Roberto Zicari, </author> <title> Primitives for schema updates in an Object-Oriented Database System: A proposal, </title> <journal> Computer Standards & Interfaces, </journal> <volume> 13, </volume> <year> 1991, </year> <pages> pages 271-284. </pages>
Reference-contexts: It uses specialization dimensions to model timing specifications and letter class hierarchies to capture performance polymorphism. We then develop a framework for changes to schemata of real-time OODBs based on the typical schema change taxonomy [2]. Schema evolution has been defined for simple (non-real-time) object-oriented models <ref> [2, 22, 24, 32] </ref>. We now re-evaluate this work in the context of real-time databases, which, as we will show, results in several modifications to the semantics of schema changes and to the needs of schema change resolution rules and schema invariants. <p> the schema is investigated and its impact on the underlying data is also considered. 3.1 Schema Change Taxonomy One of the first object-oriented schema change approaches has been proposed by Banerjee et al. [2] for ORION. 5 Note that this taxonomy, adopted in most other schema evolution research for OODBs <ref> [22, 24, 32] </ref>, still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems have implemented a subset of this taxonomy as their schema change support [10, 13, 24]. None of these approaches considers real-time models. <p> If it is organized as an ordered list, then it will have to be re-inserted in the correct position of the list, depending on the new performance value. 8. The impact of schema changes on behaviors of objects is referred to as the behavior consistency problem in <ref> [32] </ref>. 13 overridden some method that would now cause a performance change for other methods that use it. If the method is private, the change is not visible to the descendants of the class. <p> Examples are schema evolution for ORION [2], O 2 <ref> [32] </ref>, GemStone [24], and GOOSE [22]. However, to the best of our knowledge, there has not been any work on defining schema evolution in the context of real-time OODBs. We adopt the typical steps of schema evolution and expand them for the real-time object model (see Section 3).
References-found: 32

