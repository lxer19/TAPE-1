URL: http://http.cs.berkeley.edu/~zhendong/cs263/pta.ps
Refering-URL: http://http.cs.berkeley.edu/~zhendong/cs263/cs263.html
Root-URL: 
Title: An Algorithm for Composing Pointer Tree Automata  
Author: Zhendong Su 
Date: May 8, 1996  
Address: Berkeley, CA 94720  
Affiliation: EECS Department University of California at Berkeley  
Abstract: Pointer Tree Automata (PTA's) are a new formalism invented for the ease of data conversion. Each PTA takes an input tree and produces an output tree. The desired format of the data is obtained by a sequence of applications of PTA's. The multiple passes through the data limits the performance of this conversion. In this paper, we describe an algorithm for eliminating this cost by transforming the composition of the PTA's to an equivalent PTA. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken and M. </author> <title> Jacoby. Data format conversion using pointer tree automata. </title> <type> Draft, </type> <year> 1996. </year>
Reference-contexts: 1 Introduction Aiken and Jacoby <ref> [1] </ref> propose a new approach to data format conversion. This new approach is based on Pointer Tree Automata (PTA's), a new form of tree automata. Format conversion is achieved through the application of a sequence of primitive transformations encoded as PTA's. Tree automata are a generalization of finite automata. <p> The other two rules can be transformed similarly. When the program terminates, we get a valid PTA N ewS such that N ewS map id ffi split a 5 Future Work An system for data format conversion has been implemented based on the computational model of PTA's <ref> [1] </ref>. In the current implementation of the system, the primitive PTA's are applied in sequence to generate the desired format. We plan to implement the algorithm discussed in this paper on the system, thus to eliminate the multiple passes through the data in many cases.
Reference: [2] <author> A. Gill, J. Launchbury, and S. L. P. Jones. </author> <title> A short cut to deforestation (functional programming). </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 223-232, </pages> <year> 1993. </year>
Reference-contexts: In the paper, Wadler [6] characterizes a form of function definition, treeless form, that uses no intermediate trees. This algorithm can transform any linear term, containing only occurrences of functions with treeless definitions into an equivalent treeless term. [4], [5], [3], and <ref> [2] </ref> studied extensions to and applications of the algorithm.
Reference: [3] <author> A. J. Gill and S. L. P. Jones. </author> <title> Cheap deforestation in practice: an optimiser for haskell. </title> <booktitle> In Technology and Foundations Information Processing, IFIP 13th World Computer Congress, </booktitle> <volume> volume A-51, </volume> <pages> pages 581-586, </pages> <year> 1994. </year>
Reference-contexts: In the paper, Wadler [6] characterizes a form of function definition, treeless form, that uses no intermediate trees. This algorithm can transform any linear term, containing only occurrences of functions with treeless definitions into an equivalent treeless term. [4], [5], <ref> [3] </ref>, and [2] studied extensions to and applications of the algorithm.
Reference: [4] <author> G. W. Hamilton and S. B. Jones. </author> <title> Extending deforestation for first order functional programs. </title> <booktitle> In Proceedings of the 1991 Glasgow Workshop on Functional Programming, </booktitle> <pages> pages 134-145, </pages> <year> 1991. </year>
Reference-contexts: In the paper, Wadler [6] characterizes a form of function definition, treeless form, that uses no intermediate trees. This algorithm can transform any linear term, containing only occurrences of functions with treeless definitions into an equivalent treeless term. <ref> [4] </ref>, [5], [3], and [2] studied extensions to and applications of the algorithm.
Reference: [5] <author> S. Marlow and P. Wadler. </author> <title> Deforestation for higher-order functions (functional programming). </title> <booktitle> In Proceedings of the 1992 Glasgow Workshop on Functional Programming, </booktitle> <pages> pages 154-165, </pages> <year> 1992. </year>
Reference-contexts: In the paper, Wadler [6] characterizes a form of function definition, treeless form, that uses no intermediate trees. This algorithm can transform any linear term, containing only occurrences of functions with treeless definitions into an equivalent treeless term. [4], <ref> [5] </ref>, [3], and [2] studied extensions to and applications of the algorithm.
Reference: [6] <author> P. Wadler. </author> <title> Deforestation: transforming programs to eliminate trees. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 73(no.2):231-248, </address> <year> 1990. </year>
Reference-contexts: The algorithm takes two PTA's F and G and tries to compute an equivalent PTA H such that H F ffi G The remainder of the paper is organized as follows. Section 2 describes some of the related work. Section 3 extends an existing algorithm <ref> [6] </ref> to compose a class of PTA's which satisfies a syntactic property. Section 4 presents the composition algorithm and sketches a proof of its correctness. Section 5 discusses some future work that may be interesting. Section 6 concludes. 2 Related Work Wadler [6] presents an algorithm for eliminating intermediate trees in <p> Section 3 extends an existing algorithm <ref> [6] </ref> to compose a class of PTA's which satisfies a syntactic property. Section 4 presents the composition algorithm and sketches a proof of its correctness. Section 5 discusses some future work that may be interesting. Section 6 concludes. 2 Related Work Wadler [6] presents an algorithm for eliminating intermediate trees in a first-order lazy functional language called the Deforestation Algorithm. In the paper, Wadler [6] characterizes a form of function definition, treeless form, that uses no intermediate trees. <p> Section 5 discusses some future work that may be interesting. Section 6 concludes. 2 Related Work Wadler <ref> [6] </ref> presents an algorithm for eliminating intermediate trees in a first-order lazy functional language called the Deforestation Algorithm. In the paper, Wadler [6] characterizes a form of function definition, treeless form, that uses no intermediate trees. This algorithm can transform any linear term, containing only occurrences of functions with treeless definitions into an equivalent treeless term. [4], [5], [3], and [2] studied extensions to and applications of the algorithm. Wadler [6] uses the <p> paper, Wadler <ref> [6] </ref> characterizes a form of function definition, treeless form, that uses no intermediate trees. This algorithm can transform any linear term, containing only occurrences of functions with treeless definitions into an equivalent treeless term. [4], [5], [3], and [2] studied extensions to and applications of the algorithm. Wadler [6] uses the following first order language: t ::= v variable j c t 1 : : : t k constructor application j f t 1 : : : t k function application j case t 0 of p 1 : t 1 j : : : jp n : t <p> Theorem 2.1 (Deforestation Theorem) Every linear term, containing only occu-rences of functions with treeless definitions, can be effectively transformed to an equivalent treeless term, without loss of efficiency. An algorithm is given to construct an equivalent treeless term. For more detail, refer to <ref> [6] </ref>. 3 A First Attempt In this section, we show how to extend the Deforestation Algorithm in [6] to compose a subclass of PTA's which corresponds to functions with treeless defintions in the first-order language used in [6]. <p> An algorithm is given to construct an equivalent treeless term. For more detail, refer to <ref> [6] </ref>. 3 A First Attempt In this section, we show how to extend the Deforestation Algorithm in [6] to compose a subclass of PTA's which corresponds to functions with treeless defintions in the first-order language used in [6]. <p> For more detail, refer to <ref> [6] </ref>. 3 A First Attempt In this section, we show how to extend the Deforestation Algorithm in [6] to compose a subclass of PTA's which corresponds to functions with treeless defintions in the first-order language used in [6]. Theorem 3.1 Every function with treeless definitions can be transformed to an equivalent PTA with only one output in its transition rules and vice versa, i.e., the two classes are equivalent. <p> For tt of the other two forms, f can be similarly transformed to a PTA p 2 P. In particular, if tt is a case term, we create a rule for each pattern of tt. 2 Therefore, by Theorem 3.1 and the Deforestation Theorem in <ref> [6] </ref>, we can compose any PTA's with only one output in their definitions. However, this is not adequate, since PTA's allow multiple output trees. <p> We anticipate an increase in the performance of the system if the algorithm is implemented efficiently. In addition, we plan to investigate more closely the relationship between the functional model used in <ref> [6] </ref> and the tree automata based model that we use. 6 Conclusions In this paper, we have presented a rather general algorithm for composing Pointer Tree Automata. It can be used to eliminate the multiple passes through data to achieve increased efficiency.
References-found: 6

