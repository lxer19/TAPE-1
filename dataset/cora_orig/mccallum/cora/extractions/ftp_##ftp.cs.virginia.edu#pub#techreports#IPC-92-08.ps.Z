URL: ftp://ftp.cs.virginia.edu/pub/techreports/IPC-92-08.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Abstract-found: 0
Intro-found: 0
Reference: [AbK89] <author> S. Abiteboul and P. C. Kanellakis, </author> <title> Object Identity as a Query Language Primitive, </title> <booktitle> Proc. 1989 ACM SIGMOD Conf. </booktitle> <month> 18,2 (June </month> <year> 1989), </year> <pages> 159-173. </pages>
Reference-contexts: If "5" is to be a constant name, a bit string denoting the value 5 must be enumerated on the tape, hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 10 A good example of such naming can be found in <ref> [AbK89] </ref> which develops a functional model of object oriented query languages that reaches some of the same conclusions found in this report.
Reference: [AgG89] <author> R. Agrawal and N. H. Gehani, </author> <title> ODE (Object Database and Environment): The Language and the Data Model, </title> <booktitle> Proc. 1989 ACM SIGMOD Conf. </booktitle> <month> 18,2 (June </month> <year> 1989), </year> <pages> 36-45. </pages>
Reference-contexts: This accounts for the natural extensions of Pascal to Pascal/R [Sch77] and C++ to EXODUS [RiC87, RiC89] or ODE <ref> [AgG89] </ref>. While the relational model, as originally formulated by Codd [Cod70] is purely value based, it need not be. Both the domain and tuple calculi have been shown to be equivalent to the relational algebra, e.g. Chapter 10 [Mai83]. <p> Persistent data can not be identified by an addressing concept. It must be identified by an immutable symbolic element identifier. These uid 's may be bound to memory locations, virtual addresses, or disk sector addresses. But such bindings can be transient 21 , the hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 20 In ODE <ref> [AgG89] </ref>, persistent data is accommodated by simply designating two different kinds of pointers ordinary pointers (to objects allocated in either a heap or stack) and persistent pointers, together with dual persistent constructors and destructors.
Reference: [AhU79] <author> A. V. Aho and J. D. Ullman, </author> <title> Principles of Compiler Design, </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year>
Reference-contexts: In higher level languages, the variable name is also bound to a storage location, say loc; but denotes, in the language, its contents or loc.bits. This leads to the delightful confusion in compiler theory of l-values and r-values <ref> [AhU79] </ref>, or location and value [Pra84] of a variable name, say x, when used in an assignment x = x + 5. (1.2.1) On the right side, the expression is evaluated as "r value (x ) + 5", while we want l value (x ) for the left hand x in
Reference: [AtB87] <author> M. P. Atkinson and O. P. Buneman, </author> <title> Types and Persistence in Database Programming Languages, </title> <journal> Computing Surveys 19,2 (June 1987), </journal> <pages> 105-190. </pages>
Reference: [Bee90] <author> C. Beeri, </author> <title> Formal Models for Object Oriented Databases, in Deductive and Object-Oriented Databases, </title> <editor> W. Kim, J. M. Nicolas and S. Nishio (editors), </editor> <publisher> Elsevier Science Publ., North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: Moreover, since we wish to examine multiple processes that operate on common data, perhaps concurrently, we will assume that all such processes/Turing machines can read and write this common data tape, DS. Each may have additional tapes to represent local memory. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 3 Both Beeri <ref> [Bee90] </ref> and Hull [HWW91] have made this observation, although the latter then asserts that "the distinguishing feature of [uid]'s is that they uniquely identify objects from the real world the objects being identified", while Beeri dismisses them as "an implementation concept".
Reference: [Bra83] <author> R. J. Brachman, </author> <title> What IS-A Is and Isn't: An Analysis of Taxonomic Links in Semantic Networks, </title> <booktitle> COMPUTER 16,10 (Oct. </booktitle> <year> 1983), </year> <pages> 30-36. </pages>
Reference-contexts: It is more difficult to define inheritance concepts on bit strings whose interpretation is environment dependent. In mathematics, the integers are a subset of the reals; an integer is a real hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 26 Brachman <ref> [Bra83] </ref> correctly notes that inheritance as defined by the IS_A construct is really little more than a convenient syntactic shorthand for incrementally creating subclasses. We, too, will treat it in just this fashion.
Reference: [BOS91] <author> P. Butterworth, A. Otis and J. Stein, </author> <title> The Gemstone Object Database Management System, </title> <journal> Comm. of the ACM 34,10 (Oct. </journal> <year> 1991), </year> <month> 64-77. </month> <title> hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 37 While element classes must be persistent, they need not be static. But providing dynamic class declarations is very implementation dependent, and beyond the scope of this report. For details, </title> <note> see [PFG92]. 41 </note>
Reference-contexts: Nevertheless, hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 27 We should emphasize that in our semantics, a class is not a set. We regard a class to be a only a pattern defining the structure of instantiated elements that could belong to the class. In object-oriented systems based on the smalltalk paradigm [GoR83], e.g. <ref> [BOS91, CoM84] </ref> the class denotes, and also manages, all its instantiated elements.
Reference: [CaW85] <author> L. Cardelli and P. Wegner, </author> <title> On Understanding Types, Data Abstraction, and Polymorphism, </title> <journal> Computing Surveys 17,4 (1985), </journal> <pages> 471-522. </pages>
Reference-contexts: Thus uid.bits and uid must be regarded as being of a fundamentally different nature. 3 In programming languages which support pointer types the latter is called a pointer which denotes a datum; the former is treated as a data value which may be typed in the manner of <ref> [CaW85] </ref>. Given a pointer value, or uid, in C or Pascal for example, one must functionally dereference it, as in *uid or uid- to denote the referenced bit string. Readily, the converse need not be true; the same sequence of bits could occur repeatedly in the enumeration. <p> That is, the data element uid i persists after all processes which were initiated before uid i was enumerated have terminated. 1.2. Identifiers, Data, and Data Names In <ref> [CaW85] </ref>, Cardelli and Wegner assume an initially untyped data space. One must approach this assumption with caution in our Turing machine interpretation. We also assume that the data elements, or bit strings, themselves are untyped.
Reference: [CaG89] <author> N. Carriero and D. Gelernter, </author> <title> Linda in Context, </title> <journal> Comm. of the ACM 32,4 (Apr. </journal> <year> 1989), </year> <pages> 444-458. </pages>
Reference-contexts: are: (1) allow arbitrarily long symbolic names; (2) partition the name space so that the same name in different partitions may have different denotational bindings; (3) subscript names; and (4) parameterize names so that the same name with different parameters may be bound to dif ferent elements. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 31 Linda <ref> [CaG89, Gel85] </ref> is a programming language that operates over a persistent data space according to our definition. It is one that is concerned with global naming [FlH89].
Reference: [Cod70] <author> E. F. Codd, </author> <title> A Relational Model for Large Shared Data Banks, </title> <journal> Comm. of the ACM 13,6 (June 1970), </journal> <pages> 377-387. </pages>
Reference-contexts: This accounts for the natural extensions of Pascal to Pascal/R [Sch77] and C++ to EXODUS [RiC87, RiC89] or ODE [AgG89]. While the relational model, as originally formulated by Codd <ref> [Cod70] </ref> is purely value based, it need not be. Both the domain and tuple calculi have been shown to be equivalent to the relational algebra, e.g. Chapter 10 [Mai83].
Reference: [Com79] <author> D. Comer, </author> <title> The Ubiquitous B-Tree, </title> <journal> Computing Surveys 11,2 (June 1979), </journal> <pages> 121-137. </pages>
Reference-contexts: If symbolic access by name is hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 11 In fact, it is an ordered set, not unlike the Turing machine's tape. 10 desired, 12 it is frequently implemented by a B-tree index <ref> [Com79] </ref>, which binds the set of sym-bolic names to file addresses in a persistent structure. Our treatment is completely conformable to these traditional usages. But, files and their indexes are usually regarded as auxiliary to the programming language itself.
Reference: [CoM84] <author> G. Copeland and D. Maier, </author> <title> Making Smalltalk a Database System, </title> <booktitle> Proc. SIGMOD Conf., </booktitle> <address> Boston, </address> <month> June </month> <year> 1984, </year> <pages> 316-325. </pages>
Reference-contexts: Nevertheless, hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 27 We should emphasize that in our semantics, a class is not a set. We regard a class to be a only a pattern defining the structure of instantiated elements that could belong to the class. In object-oriented systems based on the smalltalk paradigm [GoR83], e.g. <ref> [BOS91, CoM84] </ref> the class denotes, and also manages, all its instantiated elements.
Reference: [FlH89] <author> C. J. Fleckenstein and D. Hemmendinger, </author> <title> Using a Global Name Space for Parallel Execution of UNIX Tools, </title> <journal> Comm. of the ACM 32,9 (Sep. </journal> <year> 1989), </year> <pages> 1085-1091. </pages>
Reference-contexts: It is one that is concerned with global naming <ref> [FlH89] </ref>. However, it does not have a name space that is conceptually separate from its data space; individual tuples of the tuple space cannot be explicitly named. Instead, it employs content based identity to denote desired tuples. 32 The first two techniques are embodied in an operating system's directory structure.
Reference: [Gel85] <author> D. Gelernter, </author> <title> Generative Communication in Linda, </title> <journal> Trans. Prog. Lang and Systems 7,1 (Jan. </journal> <year> 1985), </year> <pages> 80-112. </pages>
Reference-contexts: are: (1) allow arbitrarily long symbolic names; (2) partition the name space so that the same name in different partitions may have different denotational bindings; (3) subscript names; and (4) parameterize names so that the same name with different parameters may be bound to dif ferent elements. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 31 Linda <ref> [CaG89, Gel85] </ref> is a programming language that operates over a persistent data space according to our definition. It is one that is concerned with global naming [FlH89].
Reference: [GoR83] <author> A. Goldberg and D. Robson, </author> <title> Smalltalk-80: The Language and Its Implementation, </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: Nevertheless, hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 27 We should emphasize that in our semantics, a class is not a set. We regard a class to be a only a pattern defining the structure of instantiated elements that could belong to the class. In object-oriented systems based on the smalltalk paradigm <ref> [GoR83] </ref>, e.g. [BOS91, CoM84] the class denotes, and also manages, all its instantiated elements.
Reference: [GrL90] <author> A. S. Grimshaw and E. Loyot, </author> <title> The Mentat Programming Language: Users Manual and Tutorial, </title> <institution> Dpt. of Computer Science TR-90-08, Univ. of Virginia, </institution> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: A more important issue in the design of languages is whether the semantic model can be effectively implemented. ADAMS has been implemented over a loosely coupled network of heterogeneous SUN workstations and over a tightly coupled Intel iPSC/2 using the run-time support provided by the Mentat concurrent processing system <ref> [GrL90, Gri90] </ref>.
Reference: [Gri90] <author> A. S. Grimshaw, </author> <title> The Mentat Run-Time System: Support for Medium Grain Parallel Computation, </title> <booktitle> Proc. 5th Distributed Memory Computing Conf., </booktitle> <address> Charleston, SC, </address> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: A more important issue in the design of languages is whether the semantic model can be effectively implemented. ADAMS has been implemented over a loosely coupled network of heterogeneous SUN workstations and over a tightly coupled Intel iPSC/2 using the run-time support provided by the Mentat concurrent processing system <ref> [GrL90, Gri90] </ref>.
Reference: [GrG83] <author> R. E. Griswold and M. T. Griswold, </author> <title> The Icon Programming Language, </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1983. </year>
Reference-contexts: Semantically, they are really only fixed length bit strings with Boolean operators defined on them. SETL [SDD86] is a complete set-based language, but it has not gained wide acceptance. Icon <ref> [GrG83] </ref> too, may be regarded as a set language, although its generators (which are in many ways analogous to our enumerator) really generate sequences, or ordered sets. 23 A relation is a set of values; the relational model employs value based set semantics. 17 For us, a set will always means
Reference: [HeP90] <author> J. L. Hennessy and D. A. Patterson, </author> <title> Computer Architecture: A Quantitative Approach, </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: 5 (00...101) on a SPARC will be quite different from that on a Intel 80x86 (00000101...00). 14 The bit string that will be interpreted as the character 'a' in an ASCII hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 14 This is simply an example of the byte order difference between its big and little Endian representations <ref> [HeP90] </ref>. 13 environment (01100001) is a different bit string in an EBCIDC environment (10000001). And Fortran character strings have a different representation than C character strings in any architecture.
Reference: [Hoa78] <author> C. A. R. Hoare, </author> <title> Communicating Sequential Processes, </title> <journal> Comm. of the ACM 21,8 (Aug. </journal> <year> 1978), </year> <pages> 666-677. </pages>
Reference-contexts: 1 While persistent data must be capable of being shared by several processes, this property by itself is not sufficient to characterize persistence. Data may also be shared between processes by a variety of argument passing mechanisms in procedure calls, or by explicit message passing, e.g. <ref> [Hoa78] </ref>; none of these need imply persistence. of fundamental concepts based on it. Although it is not our purpose, this development can also serve to describe the semantics of object-oriented databases as well.
Reference: [HoU79] <author> J. E. Hopcroft and J. D. Ullman, </author> <title> Introduction to Automata Theory, Languages, and Computation, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year>
Reference-contexts: The implications above are then simply those associated with functional dependence [Mai83]. The fundamental assumption of computation is that every process can be modeled by a Tur-ing machine <ref> [HoU79] </ref>. We will use the symbolism P i to denote processes, or their equivalent Turing machines. Moreover, since we wish to examine multiple processes that operate on common data, perhaps concurrently, we will assume that all such processes/Turing machines can read and write this common data tape, DS.
Reference: [HuK87] <author> R. Hull and R. King, </author> <title> Semantic Database Modeling: Survey, Applications, and Research Issues, </title> <journal> Computing Surveys 19,3 (Sep. </journal> <year> 1987), </year> <pages> 201-260. </pages>
Reference-contexts: We, too, will treat it in just this fashion. This way of incrementally creating subclasses has also been called "specialization" <ref> [HuK87] </ref>. number, and can therefore serve as an operand wherever a real is expected. This inheritance pro-perty is not reflected in the bit string representations of these types. One may not use an integer bit string where a real bit string is expected. <p> The creation of such most general upper bounds in the subclass hierarchy has been called "generalization" <ref> [HuK87] </ref>. While it leads to a consistent semantic interpretation, it appears to be fairly difficult to implement in practice. The intersection operation presents different problems.
Reference: [HWW91] <author> R. Hull, S. Widjojo, D. Wile and M. Yoshikawa, </author> <title> On Data Restructuring and Merging with Object Identity, </title> <journal> IEEE Trans. on Data Engineering 14,2 (June 1991), </journal> <pages> 18-22. </pages>
Reference-contexts: Moreover, since we wish to examine multiple processes that operate on common data, perhaps concurrently, we will assume that all such processes/Turing machines can read and write this common data tape, DS. Each may have additional tapes to represent local memory. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 3 Both Beeri [Bee90] and Hull <ref> [HWW91] </ref> have made this observation, although the latter then asserts that "the distinguishing feature of [uid]'s is that they uniquely identify objects from the real world the objects being identified", while Beeri dismisses them as "an implementation concept". In our model, a uid only identifies a bit string.
Reference: [KhC86] <author> S. N. Khoshafian and G. P. Copeland, </author> <title> Object Identity, </title> <booktitle> OOPSLA '86, Conf. Proc., </booktitle> <month> Sep. </month> <year> 1986, </year> <pages> 406-416. </pages>
Reference-contexts: In this report we are concerned with ways of denoting elements of the persistent data space, DS, with symbolic strings, or names. Naming is not the only mechanism for identifying persistent data elements <ref> [KhC86] </ref>, but it is a primary one. As in any programming language, a symbolic data name must be bound to the element it denotes, or equivalently in our model to its uid .
Reference: [Kim90] <author> W. Kim, </author> <title> Object-Oriented Approach to Managing Statistical and Scientific Databases, in Statistical and Scientific Database Management, </title> <editor> Z. Michalewicz (editor), </editor> <publisher> Springer-Verlag, </publisher> <address> Berlin-Heidelberg-New York, </address> <month> Apr. </month> <year> 1990, </year> <pages> 1-13. </pages>
Reference-contexts: However, the latter are frequently said to belong to a "primitive class", and "for performance reasons, if the domain of an attribute is a primitive class, the values of the attribute are directly represented; that is, instances of a primitive class have no identifiers associated with them" <ref> [Kim90] </ref>. That is, they are actually implemented according to our model. 15 With this formulation, a C array declaration such as int count [20]; combines both a type and a class declaration.
Reference: [KoS86] <author> H. F. Korth and A. Silberschatz, </author> <title> Database System Concepts, </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: Our goal is to investigate what must be involved if they are to be included as an integral part of a programming language that can access persistent data as its operands. 1.3. The Relational Model We now briefly examine the relational database model <ref> [KoS86, Mai83] </ref>. Unlike the model of persistent data we have been developing, the pure relational model is completely value based. A relation is a set of bit strings (of equal length) called tuples.
Reference: [Lam86] <author> B. W. Lampson, </author> <title> Designing a Global Name Service, </title> <booktitle> Proc. on Distributed Computing, </booktitle> <year> 1986, </year> <pages> 1-10. </pages>
Reference-contexts: The same "name" or symbolic suffix will denote different files if their complete path names have different prefixes. Moreover, certain prefix strings may be reserved for specific users or for specific groups of users through familiar protection mechanisms. Name servers in distributed systems employ both these techniques <ref> [Lam86] </ref>, but so may a language designed to operate over a persistent data space.
Reference: [Mai83] <author> D. Maier, </author> <title> The Theory of Relational Databases, </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1983. </year>
Reference-contexts: If the reader prefers the more restrictive relational model, he can replace uid i with key i in much of what follows. The implications above are then simply those associated with functional dependence <ref> [Mai83] </ref>. The fundamental assumption of computation is that every process can be modeled by a Tur-ing machine [HoU79]. We will use the symbolism P i to denote processes, or their equivalent Turing machines. <p> Our goal is to investigate what must be involved if they are to be included as an integral part of a programming language that can access persistent data as its operands. 1.3. The Relational Model We now briefly examine the relational database model <ref> [KoS86, Mai83] </ref>. Unlike the model of persistent data we have been developing, the pure relational model is completely value based. A relation is a set of bit strings (of equal length) called tuples. <p> While the relational model, as originally formulated by Codd [Cod70] is purely value based, it need not be. Both the domain and tuple calculi have been shown to be equivalent to the relational algebra, e.g. Chapter 10 <ref> [Mai83] </ref>. The tuple calculus makes extensive use of tuple identifiers, as in the formula - x usedon | ($y instock ) [ x.part_nbr = y.part_nbr y.quantity 100 ] - (1.3.1) which corresponds to the algebraic expression usedon s quantity 100 (instock ) found in that chapter. <p> This question constitutes the heart of the issue regarding safe queries in relational database theory <ref> [Mai83] </ref>. 18 Given the power to create set expressions, we would expect an assignment operator, such as result - x in set1 union set2 | x.a1 = 17 - This assignment is semantically valid, whereas the assignment (1.2.3) is not, because result denotes a set and we assume that the set <p> Doesn't a set semantics based on the element bit string, or content, make more sense? Possibly. However, implementing the union, , operator which is known to be required in a complete query system, c.f. (p. 242) <ref> [Mai83] </ref>, turns out to be quite difficult in a distributed environment, as shown by the following example. We may assume that there exist at least two relations r 1 and r 2 with the same schema, R .
Reference: [PFW88] <author> J. L. Pfaltz, J. C. French and J. L. Whitlatch, </author> <title> Scoping Persistent Name Spaces in ADAMS, </title> <institution> IPC TR-88-003, Institute for Parallel Computation, Univ. of Virginia, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: Name servers in distributed systems employ both these techniques [Lam86], but so may a language designed to operate over a persistent data space. If the language provides for a partitioned persistent name space, then one need not be constrained to a strictly tree-structured configuration <ref> [PFW88] </ref>, and, perhaps more importantly, one can write processes within the language itself to search the common name space. In the database literature this is sometimes called "browsing". Mathematicians routinely use subscripting to distinguish between similar, but distinct, elements. So too, do all familiar programming languages.
Reference: [PSF88] <author> J. L. Pfaltz, S. H. Son and J. C. </author> <title> French, The ADAMS Interface Language, </title> <booktitle> Proc. 3th Conf. on Hypercube Concurrent Computers and Applications, </booktitle> <address> Pasadena, CA, </address> <month> Jan. </month> <year> 1988, </year> <pages> 1382-1389. </pages>
Reference-contexts: Syntax and Implementation A consistent syntax for the semantic model proposed in the preceding sections can be created. All of the code fragments found in Section 2 were drawn from a working database system, called ADAMS <ref> [PSF88, PFG91] </ref>, that is largely based on this model.
Reference: [PfF90] <author> J. L. Pfaltz and J. C. </author> <title> French, Implementing Subscripted Identifiers in Scientific Databases, in Statistical and Scientific Database Management, </title> <editor> Z. Michalewicz (editor), </editor> <publisher> Springer-Verlag, </publisher> <address> Berlin-Heidelberg-New York, </address> <month> Apr. </month> <year> 1990, </year> <pages> 80-91. </pages>
Reference-contexts: But, subscripting in traditional programming languages has come to be limited to array structures. One can conceive of languages in which all user generated names, such as those of processes, can be arbitrarily subscripted in order to distinguish between different instantiations. Such general subscripting facilities can be effectively implemented <ref> [PfF90] </ref>, but the development of any particular syntax or implementational semantics is not the point of this report.
Reference: [PFG91] <author> J. L. Pfaltz, J. C. French and A. Grimshaw, </author> <title> An Introduction to the ADAMS Interface Language: Part I, </title> <institution> IPC TR-91-06, Institute for Parallel Computation, Univ. of Virginia, </institution> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: Syntax and Implementation A consistent syntax for the semantic model proposed in the preceding sections can be created. All of the code fragments found in Section 2 were drawn from a working database system, called ADAMS <ref> [PSF88, PFG91] </ref>, that is largely based on this model.
Reference: [PFG92] <author> J. L. Pfaltz, J. C. French, A. S. Grimshaw and R. D. McElrath, </author> <booktitle> Functional Data Representation in Scientific Information Systems, Intern'l Space Year Conf. on Earth and Space Science Information Systems (ESSIS), </booktitle> <address> Pasadena, CA, </address> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: However, all of the assertions of this and the following section will be true for these more general extensions of the class concept. 16 A tuple need not be represented as a single bit string, and attributes need not be substrings or fields, c.f. <ref> [PFG92] </ref>. But visualizing it this way provides a clear semantic interpretation; and it can serve as the basis of an implementation. 14 attribute domain, type, or interpretation. <p> The various applications that have been coded in this environment establish that the semantic model presented here can, in fact, be implemented to provide a shared, distributed, persistent data space with reasonable storage and processing overhead costs <ref> [PFG92] </ref>. 38 We might, however, add in postscript that many individuals find programming over per-sistent data spaces quite foreign. There can be a considerable period of adjustment. It is the persistent binding of names and other program constructs that gives the most difficulty.
Reference: [PfF92] <author> J. L. Pfaltz and J. C. </author> <title> French, Multiple Inheritance and the Closure of Set Operators in Class Hierarchies, </title> <institution> IPC TR-92-004, Institute for Parallel Computation, Univ. of Virginia, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: In most relational languages, the declaration of an attribute name also establishes its hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 15 One can extend the meaning of a class to include predicates which must be true for all instances of the class <ref> [PfF92] </ref>, or to methods which are defined on these instances [Str87]. For the purposes of this report they will not be needed. <p> However, it can be demonstrated, under much more general definitions of the class concept than we have introduced here <ref> [PfF92] </ref>, that if S [C i ] is a sub-class of S [C k ] then C i must be a sub-class of C k , or equivalently Assertion 2.4: If sets of elements belonging to a specific class can be constructed, then a sub-lattice (sub-semi-lattice) of the set hierarchy must
Reference: [Pra84] <author> T. W. Pratt, </author> <title> Programming Languages: Design and Implementation, 2nd Ed., </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1984. </year>
Reference-contexts: In higher level languages, the variable name is also bound to a storage location, say loc; but denotes, in the language, its contents or loc.bits. This leads to the delightful confusion in compiler theory of l-values and r-values [AhU79], or location and value <ref> [Pra84] </ref> of a variable name, say x, when used in an assignment x = x + 5. (1.2.1) On the right side, the expression is evaluated as "r value (x ) + 5", while we want l value (x ) for the left hand x in order to generate an operation <p> A more important programming language issue is whether these bindings should be allowed to change. In the assignment (1.2.1), there are two different kinds of names. The name "5" is a constant in that the name is permanently bound to its value for the duration of its life <ref> [Pra84] </ref>. <p> But, as Pratt points out <ref> [Pra84] </ref>, there can be many equivalent programming syntaxes for the same semantic model; the virtual equivalence of the standard procedural programming languages demonstrate this. The existence of ADAMS only establishes that this semantic model can be made linguistically consistent.
Reference: [RiC87] <author> J. E. Richardson and M. J. Carey, </author> <title> Programming Constructs for Database System Implementation in EXODUS, </title> <booktitle> Proc. ACM SIGMOD Conf. </booktitle> <address> 16,3 (Dec. </address> <year> 1987), </year> <pages> 208-219. </pages>
Reference-contexts: This accounts for the natural extensions of Pascal to Pascal/R [Sch77] and C++ to EXODUS <ref> [RiC87, RiC89] </ref> or ODE [AgG89]. While the relational model, as originally formulated by Codd [Cod70] is purely value based, it need not be. Both the domain and tuple calculi have been shown to be equivalent to the relational algebra, e.g. Chapter 10 [Mai83].
Reference: [RiC89] <author> J. E. Richardson and M. J. Carey, </author> <title> Persistence in the E language: Issues and implementation, </title> <note> SoftwarePractice & Experience 19,12 (Dec. </note> <year> 1989), </year> <pages> 1115-1150. </pages>
Reference-contexts: This accounts for the natural extensions of Pascal to Pascal/R [Sch77] and C++ to EXODUS <ref> [RiC87, RiC89] </ref> or ODE [AgG89]. While the relational model, as originally formulated by Codd [Cod70] is purely value based, it need not be. Both the domain and tuple calculi have been shown to be equivalent to the relational algebra, e.g. Chapter 10 [Mai83].
Reference: [SaG90] <author> K. Salem and H. Garcia-Molina, </author> <title> System M: A Transaction Processing Testbed for Memory Resident Data, </title> <journal> IEEE Trans. on Knowledge and Data Engineering 2,1 (Mar. </journal> <year> 1990), </year> <pages> 161-172. </pages>
Reference: [ScY89] <author> P. Scheuermann and C. Yu, </author> <title> editors. Report of the Workshop on Heterogeneous Database Systems, </title> <type> NSF Report, </type> <institution> Northwestern Univ., </institution> <address> Evanston, IL, </address> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: This constitutes the heart of the data heterogeneity problem that has hindered the development of widely shared databases <ref> [ScY89, SeL90, TTC90] </ref>.
Reference: [Sch77] <author> J. W. Schmidt, </author> <title> Some High Level Language Constructs for Data of Type Relation, </title> <journal> Trans. Database Systems 2,3 (Sep. </journal> <year> 1977), </year> <pages> 247-261. </pages>
Reference-contexts: Tuples are easily visualized as formatted records in a sequential file, in which case attributes can be interpreted as fields, or visualized as record structures in Pascal, C, or C++, in which case the attributes name structure members. This accounts for the natural extensions of Pascal to Pascal/R <ref> [Sch77] </ref> and C++ to EXODUS [RiC87, RiC89] or ODE [AgG89]. While the relational model, as originally formulated by Codd [Cod70] is purely value based, it need not be. Both the domain and tuple calculi have been shown to be equivalent to the relational algebra, e.g. Chapter 10 [Mai83].
Reference: [SDD86] <author> J. Schwartz, R. B. K. Dewar, E. Dubinsky and E. Schonberg, </author> <title> Programming with Sets: An Introduction to SETL, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: Semantically, they are really only fixed length bit strings with Boolean operators defined on them. SETL <ref> [SDD86] </ref> is a complete set-based language, but it has not gained wide acceptance.
Reference: [SeL90] <author> A. P. Seth and J. A. Larson, </author> <title> Federated Database Systems for Managing Distributed, Heterogeneous, and Autonomous Databases, </title> <journal> Computing Surveys 22,3 (Sep. </journal> <year> 1990), </year> <pages> 183-236. </pages>
Reference-contexts: This constitutes the heart of the data heterogeneity problem that has hindered the development of widely shared databases <ref> [ScY89, SeL90, TTC90] </ref>.
Reference: [Son89] <author> S. H. Son, </author> <title> Recovery in Main Memory Database Systems for Engineering Design Applications, </title> <journal> Information and Software Technology 31(Mar. </journal> <year> 1989), </year> <pages> 85-90. </pages>
Reference: [Str87] <author> B. Stroustrup, </author> <title> The C++ Programming Language, </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year> <note> (Second edition, </note> <year> 1991). </year>
Reference-contexts: In most relational languages, the declaration of an attribute name also establishes its hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 15 One can extend the meaning of a class to include predicates which must be true for all instances of the class [PfF92], or to methods which are defined on these instances <ref> [Str87] </ref>. For the purposes of this report they will not be needed. <p> Even if physical storage were not a hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 32 Either the extensive literature on garbage collection in LISP systems, or the detailed discussion of the delete operators and destructors in C++ where one encounters expressions such as "...the deletion of an object may change its value" <ref> [Str87] </ref> (p. 500) can be regarded as cases in point. 34 constraint, what seems to inexorably force consideration of data deletion is the psychological finiteness of a user's name space.
Reference: [TTC90] <author> G. Thomas, G. R. Thompson, G. Chung, E. Barkmeyer, F. Carter, M. Templeton, S. Fox and B. Hartman, </author> <title> Heterogeneous Distributed Database Systems for Production Use, </title> <journal> Computing Surveys 22,3 (Sep. </journal> <year> 1990), </year> <pages> 237-266. </pages>
Reference-contexts: This constitutes the heart of the data heterogeneity problem that has hindered the development of widely shared databases <ref> [ScY89, SeL90, TTC90] </ref>.
Reference: [Wei63] <author> J. Weizenbaum, </author> <title> Symmetric List Processor, </title> <journal> Comm. of the ACM 6,8 (Sep. </journal> <year> 1963), </year> <month> 524-536. </month> <title> Table of Contents 1. Basic Concepts .............................................................................................. 2 1.1. The Concept of Persistence .................................................................... 5 1.2. Identifiers, Data, and Data Names ......................................................... 6 1.3. The Relational Model ............................................................................ 11 2. Categories of Data ......................................................................................... 12 2.1. Types and Classes .................................................................................. 13 2.2. Sets and Set Operations ......................................................................... 17 2.3. Class Inheritance .................................................................................... 21 3. Persistent Name Spaces ................................................................................ 32 4. Data Deletion ................................................................................................ 34 5. Summary ....................................................................................................... 36 6. Syntax and Implementation .......................................................................... 38 7. </title> <type> References ..................................................................................................... 41 44 </type>
Reference-contexts: Indeed, no element to which there is a valid reference in either the data space DS, or name space NS, should be deleted. One mechanism for controlling unwanted deletion is by means of reference counters. These are an old device, which the author first encountered in 1963 <ref> [Wei63] </ref>, although their use may predate even this.
References-found: 46

