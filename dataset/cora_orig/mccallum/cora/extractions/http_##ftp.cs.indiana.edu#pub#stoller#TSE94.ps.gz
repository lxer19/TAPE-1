URL: http://ftp.cs.indiana.edu/pub/stoller/TSE94.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/stoller.html
Root-URL: http://www.cs.indiana.edu
Email: (stoller@cs.cornell.edu)  
Title: Addendum to "Proof Rules for Flush Channels" k P 2 receive (t1; x1) from F
Author: Scott Stoller Scott Stoller m oe F m OE F MTEXT m ae F 
Address: Ithaca, NY  
Affiliation: Department of Computer Science, Cornell University,  
Note: For example, consider the following program: cobegin P 1 send (2F; 0) on F send (2F; 0) on F send (2F; 1) on F  copies of m 0 sent by P 1 must be  is with the  14853. He is currently supported by an IBM Graduate Fellowship. (8m  
Abstract: The logic presented in [1] for processes that communicate using flush channels is inadequate for reasoning about processes that send multiple identical messages along a channel. A modification to the logic and proof system that remedies this deficiency is described herein. The logic presented in [1] for systems of processes that communicate using flush channels is incomplete. The axiomatization given is adequate for reasoning about programs that never send two or more identical messages (i.e., messages with the same contents and the same F-channel message type) along a channel, but inadequate for reasoning about programs that do not satisfy this condition. The source of the weakness is that the mathematical model of flush channels on which the logic is based does not contain enough information to determine exactly the possible message delivery orderings, as defined by the operational semantics of flush channels. (The model of flush channels in [1] is defined implicitly by the choice of auxiliary variables and the updates to the auxiliary variables used to represent communication events.) If several identical messages are sent along a channel, the multiplicity is not taken into account in the ordering OE + F . Consequently, the assumption in the satisfaction axiom for receive statements is too weak: it corresponds to an operational semantics that allows a message m to be delivered after delivery of at least one copy of each message that should be delivered before m, even if multiple copies of some of those messages should be delivered before m. rules of [1]) for the second receive. One possible situation is that all three sends have been executed; in this case, oe F = fm 0 ; m 0 ; m 1 g, ae F = fm 0 g, and OE + F = f(m 0 ; m 1 )g. The antecedent of the satisfaction formula contains the predicate which is supposed to characterize which messages MTEXT in oe F ae F can be delivered next. This predicate holds for MTEXT = m 0 and MTEXT = m 1 , so the postcondition of this statement must hold if either of these messages is received by this statement. Thus, the strongest fact about x2 that can be proved in the postcondition of the second receive is (x2 = 0 _ x2 = 1). Consequently, the strongest fact about x2 and x3 that can be proved in the postcon-dition of this program, using the logic presented in [1], is (x2 = 0 ^ x3 = 1) _ (x2 = 1 ^ x3 = 0). There are various ways to remedy this deficiency, though at the cost of complicating the model and proof system. One approach is to keep track of multiplicities in OE and OE + by making them multisets. The interpretation is: if the multiplicity of (m; m 0 ) in OE + is i, then i copies of m must be received before m 0 . This approach fails because OE does not contain enough information to compute OE + (i.e., there is no definition of the "transitive closure" of OE that yields the correct multiplicities in OE + ). Similar difficulties arise if one tries to modify the proof rules to compute OE + directly. Another approach is to tag messages in a way that ensures that when a tagged message is added to oe F , it is not already contained in oe F ae F . The tagging occurs only in the mathematical model of the network, not in the user's program or in the implementation of flush channels. This approach permits "minimal" tagging schemes but complicates other aspects of the model; for example, it requires that pairs be deleted from OE F when a receive occurs. A simpler approach is to tag each message with an unique identifier. One natural choice for the unique identifier is the multiset of messages previously sent along the channel; another, which I use below, is the size of this multiset. In either case, every element added to oe F is unique, so oe F and ae F can be regarded as sets rather than multisets. The corresponding modifications to the proof rules follow. The changes to the send axioms are captured neatly by reinterpreting the "macro" m, which is used in these axioms as an abbreviation for htype; datai, as an abbreviation for hhtype; datai; joe F ji. In the satisfaction and noninterference rules, the substitutions of MTEXT for hmtype; mdatai 
Abstract-found: 1
Intro-found: 0
Reference: [1] <author> T. Camp, P. Kearns, and M. Ahuja, </author> <title> "Proof rules for flush channels," </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> vol. 19, no. 4, </volume> <pages> pp. 366-378, </pages> <year> 1993. </year>
References-found: 1

