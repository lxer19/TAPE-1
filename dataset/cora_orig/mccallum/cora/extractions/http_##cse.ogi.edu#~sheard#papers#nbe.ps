URL: http://cse.ogi.edu/~sheard/papers/nbe.ps
Refering-URL: http://www.cse.ogi.edu/~sheard/sheard.html
Root-URL: http://www.cse.ogi.edu
Email: sheard@cse.ogi.edu  
Title: Integrating Normalization-by-Evaluation into a Staged Programming Language  
Author: Tim Sheard 
Affiliation: Pacific Software Research Center Oregon Graduate Institute  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Olivier Danvy. </author> <title> Type-directed partial evaluation. </title> <booktitle> In Conference Record of POPL '96: The 23 rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 242-257, </pages> <address> St. Petersburg Beach, Florida, </address> <month> 21-24 January </month> <year> 1996. </year>
Reference-contexts: Second, because the program is not well typed under the typing rules of MetaML. Nevertheless, we have implemented several versions of NBE underneath the type-checker, as primitives functions, and built type-safe interfaces to them for the user. In <ref> [1] </ref> NBE is expressed as two mutually recursive functions reify and reflect. In Figure 3.2 we give continuation passing style versions of reify and reflect as two stage programs. This allows an implementation without the abstract control operators shift and reset [2, 4]. <p> Finally, apply the code-to-code continuation k to produce the answer (also a piece of code). When the continuation is the identity, this function behaves like the reify function of <ref> [1] </ref>. The function reflect has type T -&gt; &lt;'a&gt; -&gt; ('a -&gt; &lt;'a&gt;) -&gt; &lt;'a&gt;. It's purpose is to construct the body of the lambda expression being constructed in the function clause of reify. <p> Doing no analysis over v is important because it places few restrictions on an implementation. In particular NBE could be implemented in a compiled language such as Scheme or ML <ref> [1] </ref>. 4.3 Limitations of Figure 3.2 Our experience has been that reify and reflect as defined in Figure 3.2 work only for values derived from closed terms where base types (int, string, or real for example) only appear in covariant positions in the type represented by typ.
Reference: [2] <author> Olivier Danvy and Andrzej Filinski. </author> <title> Abstracting control. </title> <booktitle> In LISP, </booktitle> <pages> pages 151-160, </pages> <address> Nice, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: In [1] NBE is expressed as two mutually recursive functions reify and reflect. In Figure 3.2 we give continuation passing style versions of reify and reflect as two stage programs. This allows an implementation without the abstract control operators shift and reset <ref> [2, 4] </ref>. We introduce a datatype T which can be thought of as a representation of types, and reify and reflect functions whose control is guided by their T typed arguments. The function reify has type T -&gt; 'a -&gt; (&lt;'a&gt; -&gt; &lt;'a&gt;) -&gt; &lt;'a&gt;.
Reference: [3] <author> Olivier Danvy, Karoline Malmkjaer, and Jens Palsberg. </author> <title> The essence of eta-expansion in partial evaluation. </title> <journal> LISP and Symbolic Computation, </journal> <volume> 1(19), </volume> <year> 1995. </year>
Reference-contexts: Note that at a function type, generalized expansion is simply eta-expansion <ref> [3] </ref>. 4.2 Things to Note about Figure 3.2 Note that reify never does any analysis of its argument v. The context, provided by the analysis of the argument typ always "knows" what type v has. Reify uses v in its body at several different types.
Reference: [4] <author> Andrzej Filinski. </author> <title> Representing monads. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1994. </year>
Reference-contexts: In [1] NBE is expressed as two mutually recursive functions reify and reflect. In Figure 3.2 we give continuation passing style versions of reify and reflect as two stage programs. This allows an implementation without the abstract control operators shift and reset <ref> [2, 4] </ref>. We introduce a datatype T which can be thought of as a representation of types, and reify and reflect functions whose control is guided by their T typed arguments. The function reify has type T -&gt; 'a -&gt; (&lt;'a&gt; -&gt; &lt;'a&gt;) -&gt; &lt;'a&gt;.
Reference: [5] <author> Mark P. Jones. </author> <title> A system of constructor classes: overloading and implicit higher-order polymor-phism. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(1), </volume> <month> January </month> <year> 1995. </year>
Reference-contexts: A sample use of the function mp is: -| mp list (fn x =&gt; x+2) [1,2,3]; val it = [3,4,5] : int list 1 MetaML supports extensions to the ML type system with higher order type constructors and local polymorphic functions as arguments to data constructors <ref> [5, 7] </ref> 3 While elegant, it is not very efficient. The rolling and unrolling consumes at lot of resources (allocation of memory for the constructors of the V datatype), and time (spent walking over the V data structure).
Reference: [6] <author> Matthieu Martel and Tim Sheard. </author> <title> Introduction to multi-stage programming using metaml. </title> <type> Technical report, OGI, </type> <address> Portland, OR, </address> <month> September </month> <year> 1997. </year>
Reference-contexts: In MetaML we have combined the advantages of both, allowing a simple type-directed binding time analysis to coexist with the manual staging annotations. This integration is the subject of this paper. 2 MetaML, a multi-staged language This section introduces MetaML <ref> [9, 6] </ref>, a statically-typed, multi-stage programming language. Here, we describe each of the staging operators of MetaML. 2.1 The bracket operator: Building pieces of code In MetaML, a stage-1 expression is denoted by enclosing it between meta-brackets.
Reference: [7] <author> Martin Odersky and Konstantin Laufer. </author> <title> Putting type annotations to work. </title> <booktitle> In Proc. 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 54-67, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: A sample use of the function mp is: -| mp list (fn x =&gt; x+2) [1,2,3]; val it = [3,4,5] : int list 1 MetaML supports extensions to the ML type system with higher order type constructors and local polymorphic functions as arguments to data constructors <ref> [5, 7] </ref> 3 While elegant, it is not very efficient. The rolling and unrolling consumes at lot of resources (allocation of memory for the constructors of the V datatype), and time (spent walking over the V data structure).
Reference: [8] <author> Tim Sheard. </author> <title> A type-directed, on-line, partial evaluator for a polymorphic language. </title> <year> 1997. </year>
Reference-contexts: In MetaML, which is implemented as an inter-pretor in ML, we already have type tags on values. We have implemented both strategies. The second strategy can be strengthened to handle primitive operators, and open terms, but is considerably more complicated <ref> [8] </ref>.
Reference: [9] <author> Walid Taha and Tim Sheard. </author> <title> Multi-stage programming with explicit annotations. </title> <booktitle> In Proceedings of the ACM-SIGPLAN Symposium on Partial Evaluation and semantic based program manipulations PEPM'97, Amsterdam, </booktitle> <pages> pages 203-217. </pages> <publisher> ACM, </publisher> <year> 1997. </year> <month> 5 </month>
Reference-contexts: In MetaML we have combined the advantages of both, allowing a simple type-directed binding time analysis to coexist with the manual staging annotations. This integration is the subject of this paper. 2 MetaML, a multi-staged language This section introduces MetaML <ref> [9, 6] </ref>, a statically-typed, multi-stage programming language. Here, we describe each of the staging operators of MetaML. 2.1 The bracket operator: Building pieces of code In MetaML, a stage-1 expression is denoted by enclosing it between meta-brackets. <p> At run-time, when the expression &lt;z&gt; is evaluated, the system has to compute a piece of code related to the value of z. This piece of code will be a constant, because z is known to be 7. We call this phenomenon cross stage persistence <ref> [9] </ref>. The pretty printer for code prints all lexically captured constants with the annotation %, followed by the name of the free variable whose value was used to construct the constant. All free variables (regardless of type) inside meta brackets construct these constants.
References-found: 9

