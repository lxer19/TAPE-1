URL: ftp://ftp.cs.colorado.edu/users/alw/papers/CU-CS-858-98.ps.Z
Refering-URL: http://www.cs.colorado.edu/users/alw/RecentPubs.html
Root-URL: http://www.cs.colorado.edu
Email: fjudys,alwg@cs.colorado.edu djr@ics.uci.edu  
Title: Aladdin: A Tool for Architecture-Level Dependence Analysis of Software Systems  
Author: Judith A. Stafford Debra J. Richardson and Alexander L. Wolf 
Note: used to answer various questions one might pose of a Rapide architecture specification.  
Address: Boulder, CO 80309 USA Irvine, CA 92697 USA  
Affiliation: Department of Computer Science Dept. of Information and Computer Science University of Colorado University of California  
Abstract: University of Colorado Department of Computer Science Technical Report CU-CS-858-98 April 1998 ABSTRACT The emergence of formal architecture description languages provides an opportunity to perform analyses at high levels of abstraction, as well as early in the development process. Previous research has primarily focused on developing techniques such as algebraic and transition-system analysis to detect component mismatches or global behavioral incorrectness. In this paper, we present Aladdin, a tool that implements chaining, a static dependence analysis technique for use with architectural descriptions. Dependence analysis has been used widely at the implementation level to aid program optimization, anomaly checking, program understanding, testing, and debugging. We investigate the definition and application of dependence analysis at the architectural level. We illustrate the utility of chaining, through the use of Aladdin, by showing how the technique can be This work was supported in part by the National Science Foundation under grant CCR-97-10078 and by the Air Force Material Command, Rome Laboratory, and the Defense Advanced Research Projects Agency under Contract Number F30602-94-C-0253. The content of the information does not necessarily reflect the position or the policy of the U.S. Government and no official endorsement should be inferred. c fl 1998 Judith A. Stafford, Debra J. Richardson, and Alexander L. Wolf
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers principles, techniques, and tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Harrold and Soffa [11] have studied alias and interprocedural analysis of C and C++ programs. Representation schemes for program/system dependencies that are similar to our tabular representation have been used in program optimization and for system requirements analysis. Aho, Sethi, and Ullman <ref> [1] </ref> describe a program representation where bit vectors are used to compactly represent "gen" and "kill" sets for each statement in the program. Logical operations are performed on these bit sets to determine statement dependencies.
Reference: [2] <author> F.E. Allen. </author> <title> Control Flow Analysis. </title> <journal> SIGPLAN Notices, </journal> <pages> pages 1-19, </pages> <month> July </month> <year> 1970. </year>
Reference-contexts: The traditional view of dependence analysis is based on control and data flow relationships associated with functions and variables (e.g., [13, 21, 30]). This type of analysis was originally applied to program optimization <ref> [2] </ref> in order to determine safe code restructuring. The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., [4, 9]).
Reference: [3] <author> R. Allen and D. Garlan. </author> <title> A Formal Basis for Architectural Connection. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 6(3) </volume> <pages> 213-249, </pages> <month> July </month> <year> 1997. </year>
Reference-contexts: Formal software architecture description languages (ADLs) allow one to reason about the correctness of software systems at a correspondingly high level of abstraction. Techniques have been developed for architecture analysis that can reveal such problems as potential deadlock and component mismatches <ref> [3, 15, 18, 20] </ref> In general, there are many kinds of questions one might want to ask at an architectural level for purposes as varied as specification error detection, reuse, reengineering, reverse engineering, fault localization, impact analysis, regression testing, and workspace management. <p> Our research takes a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions. In particular, both the structural and the behavioral relationships among components expressed in current-day formal ADLs, such as Rapide [16] and Wright <ref> [3] </ref>, are considered. We are developing an architecture-level dependence analysis technique, called chaining, and implementing the technique in a tool called Aladdin. Aladdin is similar in concept to ProDAG [25], which is an implementation-level dependence analysis tool for Ada and C++ programs. <p> Future plans for Aladdin include improving the precision of the analysis by improving the intra-component behavior summarizations. We intend to incorporate more features of the Rapide language, to extend our definition of chaining to other languages (including CHAM [14], Acme [8], and Wright <ref> [3] </ref>), and to test our approach against more complex architectures. Historically, testing has concentrated on the implementation of the system, which has meant that it is considered fairly late in the development process.
Reference: [4] <author> D.F. Bacon, S.L. Graham, and O.J. Sharp. </author> <title> Compiler Transformations for High-Performance Computing. </title> <journal> ACM Computing Surveys, </journal> <volume> 26(4) </volume> <pages> 345-420, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: This type of analysis was originally applied to program optimization [2] in order to determine safe code restructuring. The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., <ref> [4, 9] </ref>). The application of dependence analysis techniques to aid program understanding and impact analysis has also been widely studied (e.g., [19, 22, 24]). Our research takes a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions.
Reference: [5] <author> J. Chang and D. J. Richardson. </author> <title> Static and Dynamic Specification Slicing. </title> <booktitle> In Proceedings of the Fourth Irvine Software Symposium, </booktitle> <address> Irvine, CA, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: Sloane and Holdsworth [26] suggest generalizing the concept of program slicing and show the potential in syntax-based slicing of non-imperative programs. We agree with the spirit of this work and are pursuing a similar goal, but in the particular context of software architectures. Chang and Richardson <ref> [5] </ref> introduced techniques for creating dynamic specification slices. This approach uses traditional slicing criteria, whereas our work involves exploring relationships at the architectural level, where additional criteria are defined. Zhao [32] is investigating the use of a system dependence net to slice architectural descriptions written in the Wright ADL.
Reference: [6] <author> J.R. Cordy and K.A. Schneider. </author> <title> Architectural Design Recovery Using Source Transformations. </title> <booktitle> In CASE'95: Workshop on Software Architecture, </booktitle> <address> Toronto, Canada, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: Architectural specifications and system implementations tend to drift apart if not carefully managed. Two approaches intended to support precise mappings are code generation [29, 31] and architecture recovery <ref> [6, 19] </ref>. 3 Chaining Chaining is a dependence analysis technique we propose for use at the architectural level. The individual chain links within a chain associate architectural elements that are directly related, 2 while a chain of dependencies includes associations among architectural elements that are indirectly related.
Reference: [7] <author> J. Ferrante, K.J. Ottenstein, and J.D. Warren. </author> <title> The Program Dependence Graph and Its Use in Optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Our approach applies this concept to architecture description languages and combines the information with behavioral dependencies. Considerable work has been done in the study and use of dependence relationships among variables and statements at the implementation level. For example, Ferrante, Ottenstein, and Warren <ref> [7] </ref> introduced the program dependence graph (PDG) for use in compiler optimization. Harrold and Soffa [11] have studied alias and interprocedural analysis of C and C++ programs. Representation schemes for program/system dependencies that are similar to our tabular representation have been used in program optimization and for system requirements analysis.
Reference: [8] <author> D. Garlan, R. Monroe, and D. Wile. ACME: </author> <title> An Architecture Description Interchange Language. </title> <booktitle> In Proceedings of CASCON '97, </booktitle> <pages> pages 169-183. </pages> <institution> IBM Center for Advanced Studies, </institution> <month> November </month> <year> 1997. </year>
Reference-contexts: We then review related work and conclude with a discussion of our future plans, which include the adaptation of Aladdin to specifications written in Acme <ref> [8] </ref> and extension to other ADLs. 2 Motivating Questions There are a variety of questions that should be answerable by an examination of a formal architecture description. Here we list a small number of those questions as motivation for the study of architecture-level dependence analysis. 1. <p> Future plans for Aladdin include improving the precision of the analysis by improving the intra-component behavior summarizations. We intend to incorporate more features of the Rapide language, to extend our definition of chaining to other languages (including CHAM [14], Acme <ref> [8] </ref>, and Wright [3]), and to test our approach against more complex architectures. Historically, testing has concentrated on the implementation of the system, which has meant that it is considered fairly late in the development process.
Reference: [9] <author> D.W. Goodwin. </author> <title> Interprocedural Dataflow Analysis in an Executable Optimizer. </title> <booktitle> In Proceedings of the ACM SIGPLAN '97 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 122-133, </pages> <address> Las Vegas, Nevada, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: This type of analysis was originally applied to program optimization [2] in order to determine safe code restructuring. The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., <ref> [4, 9] </ref>). The application of dependence analysis techniques to aid program understanding and impact analysis has also been widely studied (e.g., [19, 22, 24]). Our research takes a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions.
Reference: [10] <author> J.O. Grady. </author> <title> System Requirements Analysis. </title> <publisher> McGraw-Hill, Inc., </publisher> <year> 1993. </year>
Reference-contexts: Aho, Sethi, and Ullman [1] describe a program representation where bit vectors are used to compactly represent "gen" and "kill" sets for each statement in the program. Logical operations are performed on these bit sets to determine statement dependencies. Grady <ref> [10] </ref> uses an N-square representation to examine system coupling when assigning functionalities to components during initial system decomposition. Pomakis and Atlee [23] use a tabular notation similar to the one found in SCR [12] to specify feature behaviors.
Reference: [11] <author> M.J. Harrold and M.L. Soffa. </author> <title> Efficient Computation of Interprocedural Definition Use Chains. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(2) </volume> <pages> 175-204, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Considerable work has been done in the study and use of dependence relationships among variables and statements at the implementation level. For example, Ferrante, Ottenstein, and Warren [7] introduced the program dependence graph (PDG) for use in compiler optimization. Harrold and Soffa <ref> [11] </ref> have studied alias and interprocedural analysis of C and C++ programs. Representation schemes for program/system dependencies that are similar to our tabular representation have been used in program optimization and for system requirements analysis.
Reference: [12] <author> K. Heninger. </author> <title> Specifying Software Requirements for Complex Systems: New Techniques and Their Applications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 6(1) </volume> <pages> 2-12, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Logical operations are performed on these bit sets to determine statement dependencies. Grady [10] uses an N-square representation to examine system coupling when assigning functionalities to components during initial system decomposition. Pomakis and Atlee [23] use a tabular notation similar to the one found in SCR <ref> [12] </ref> to specify feature behaviors. This is used in conjunction with a graphical representation to study possible feature interactions. While all of these methods use a representation similar to our tabular representation, the analyses applied to the representations are different and are for different purposes.
Reference: [13] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural Slicing Using Dependence Graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 22(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The traditional view of dependence analysis is based on control and data flow relationships associated with functions and variables (e.g., <ref> [13, 21, 30] </ref>). This type of analysis was originally applied to program optimization [2] in order to determine safe code restructuring. The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., [4, 9]).
Reference: [14] <author> P. Inverardi and A.L. Wolf. </author> <title> Formal Specification and Analysis of Software Architectures using the Chemical Abstract Machine Model. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 373-386, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: The particular kinds of dependencies that can be established among components are heavily influenced by the primitive features of the ADL. For instance, in CHAM <ref> [14] </ref>, only behavioral relationships are modeled, and those relationships are based on synchronous input and output ports through which data flow. 2 As mentioned in Section 1, Rapide specifications can involve both structural and behavioral relationships and typically involve event-based interactions. 4 Aladdin Aladdin is a prototype tool for performing architecture-level <p> Future plans for Aladdin include improving the precision of the analysis by improving the intra-component behavior summarizations. We intend to incorporate more features of the Rapide language, to extend our definition of chaining to other languages (including CHAM <ref> [14] </ref>, Acme [8], and Wright [3]), and to test our approach against more complex architectures. Historically, testing has concentrated on the implementation of the system, which has meant that it is considered fairly late in the development process.
Reference: [15] <author> P. Inverardi, A.L. Wolf, and D. Yankelevich. </author> <title> Checking Assumptions in Component Dynamics at the Architectural Level. </title> <booktitle> In Proceedings of the Second International Conference on Coordination Models and Languages, number 1282 in Lecture Notes in Computer Science, </booktitle> <pages> pages 46-63. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1997. </year>
Reference-contexts: Formal software architecture description languages (ADLs) allow one to reason about the correctness of software systems at a correspondingly high level of abstraction. Techniques have been developed for architecture analysis that can reveal such problems as potential deadlock and component mismatches <ref> [3, 15, 18, 20] </ref> In general, there are many kinds of questions one might want to ask at an architectural level for purposes as varied as specification error detection, reuse, reengineering, reverse engineering, fault localization, impact analysis, regression testing, and workspace management.
Reference: [16] <author> D.C. Luckham, J.J. Kenney, L.M. Augustin, J. Vera, D. Bryan, and W. Mann. </author> <title> Specification and Analysis of System Architecture Using Rapide. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 336-355, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Our research takes a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions. In particular, both the structural and the behavioral relationships among components expressed in current-day formal ADLs, such as Rapide <ref> [16] </ref> and Wright [3], are considered. We are developing an architecture-level dependence analysis technique, called chaining, and implementing the technique in a tool called Aladdin. Aladdin is similar in concept to ProDAG [25], which is an implementation-level dependence analysis tool for Ada and C++ programs.
Reference: [17] <author> N. Madhav. </author> <title> Testing Ada 95 Programs for Conformance to Rapide Architectures. </title> <booktitle> In Proceedings of Ada-Europe '96, number 1088 in Lecture Notes in Computer Science, </booktitle> <pages> pages 123-134. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1996. </year>
Reference-contexts: There are also a number of critical anomalies evident only from the analysis result depicted in Figure 4. We discuss 1 It could be argued that the gas station problem is not representative of software architecture specifications, although it is widely used in the architecture literature (e.g. <ref> [17, 20] </ref>). It has the advantage of being well known and compact, and does in fact exhibit features that would appear in a "real" architecture specification. In general, there appears to be a dearth of good architecture specification examples, both large and small. 4 these anomalies in Section 4.
Reference: [18] <author> J. Magee, N. Dulay, S. Eisenbach, and J. Kramer. </author> <title> Distributed Software Architectures. </title> <booktitle> In Proceedings of the Fifth European Software Engineering Conference, number 989 in Lecture Notes in Computer Science, </booktitle> <pages> pages 137-153. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: Formal software architecture description languages (ADLs) allow one to reason about the correctness of software systems at a correspondingly high level of abstraction. Techniques have been developed for architecture analysis that can reveal such problems as potential deadlock and component mismatches <ref> [3, 15, 18, 20] </ref> In general, there are many kinds of questions one might want to ask at an architectural level for purposes as varied as specification error detection, reuse, reengineering, reverse engineering, fault localization, impact analysis, regression testing, and workspace management.
Reference: [19] <author> G.C. Murhpy and D.N. Notkin. </author> <title> Lightweight Lexical Source Model Extraction. </title> <journal> TOSEM, </journal> <volume> 5(3) </volume> <pages> 262-292, </pages> <month> July </month> <year> 1996. </year> <month> 15 </month>
Reference-contexts: The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., [4, 9]). The application of dependence analysis techniques to aid program understanding and impact analysis has also been widely studied (e.g., <ref> [19, 22, 24] </ref>). Our research takes a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions. <p> Architectural specifications and system implementations tend to drift apart if not carefully managed. Two approaches intended to support precise mappings are code generation [29, 31] and architecture recovery <ref> [6, 19] </ref>. 3 Chaining Chaining is a dependence analysis technique we propose for use at the architectural level. The individual chain links within a chain associate architectural elements that are directly related, 2 while a chain of dependencies includes associations among architectural elements that are indirectly related. <p> Structural dependencies are investigated at the implementation level for use in tools such as makedepend, which examines program source code to automatically derive the file dependencies used in Make files (e.g., #include in the C environment). Murphy and Notkin <ref> [19] </ref> use structural information, as well as call graphs, to extract a source model of a system. Our approach applies this concept to architecture description languages and combines the information with behavioral dependencies.
Reference: [20] <author> G. Naumovich, G.S. Avrunin, L.A. Clarke, and L.J. Osterweil. </author> <title> Applying Static Analysis to Software Architectures. </title> <booktitle> In Proceedings of the Sixth European Software Engineering Conference, number 1301 in Lecture Notes in Computer Science, </booktitle> <pages> pages 77-93. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Formal software architecture description languages (ADLs) allow one to reason about the correctness of software systems at a correspondingly high level of abstraction. Techniques have been developed for architecture analysis that can reveal such problems as potential deadlock and component mismatches <ref> [3, 15, 18, 20] </ref> In general, there are many kinds of questions one might want to ask at an architectural level for purposes as varied as specification error detection, reuse, reengineering, reverse engineering, fault localization, impact analysis, regression testing, and workspace management. <p> There are also a number of critical anomalies evident only from the analysis result depicted in Figure 4. We discuss 1 It could be argued that the gas station problem is not representative of software architecture specifications, although it is widely used in the architecture literature (e.g. <ref> [17, 20] </ref>). It has the advantage of being well known and compact, and does in fact exhibit features that would appear in a "real" architecture specification. In general, there appears to be a dearth of good architecture specification examples, both large and small. 4 these anomalies in Section 4. <p> The work described in this initial paper is similar in nature to our work on chaining, but is preliminary and the details of the method for determining related components are unstated. Naumovich et al. <ref> [20] </ref> apply INCA and FLAVERS, two static concurrency analysis tools used for proving behavioral properties of concurrent programs, to an Ada translation of a description of the gas station problem that was written in the Wright ADL.
Reference: [21] <author> H. Pande, W. Landi, and B. Ryder. </author> <title> Interprocedural Def-Use Associations for C Systems with Single Level Pointers. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(5) </volume> <pages> 385-403, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: The traditional view of dependence analysis is based on control and data flow relationships associated with functions and variables (e.g., <ref> [13, 21, 30] </ref>). This type of analysis was originally applied to program optimization [2] in order to determine safe code restructuring. The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., [4, 9]).
Reference: [22] <author> A. Podgurski and L.A. Clarke. </author> <title> A Formal Model of Program Dependencies and its Implications for Software Testing, Debugging, and Maintenance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 965-979, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., [4, 9]). The application of dependence analysis techniques to aid program understanding and impact analysis has also been widely studied (e.g., <ref> [19, 22, 24] </ref>). Our research takes a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions.
Reference: [23] <author> K.P. Pomakis and J.M. Atlee. </author> <title> Reachability Analysis of Feature Interactions: A Progress Report. </title> <booktitle> In Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA '96), </booktitle> <pages> pages 216-223. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: Logical operations are performed on these bit sets to determine statement dependencies. Grady [10] uses an N-square representation to examine system coupling when assigning functionalities to components during initial system decomposition. Pomakis and Atlee <ref> [23] </ref> use a tabular notation similar to the one found in SCR [12] to specify feature behaviors. This is used in conjunction with a graphical representation to study possible feature interactions.
Reference: [24] <author> D.J. Richardson. TAOS: </author> <title> Testing with Analysis and Oracle Support. </title> <booktitle> In Proceedings of the 1994 International Symposium on Software Testing and Analysis (ISSTA '94), </booktitle> <pages> pages 138-153. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., [4, 9]). The application of dependence analysis techniques to aid program understanding and impact analysis has also been widely studied (e.g., <ref> [19, 22, 24] </ref>). Our research takes a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions. <p> Historically, testing has concentrated on the implementation of the system, which has meant that it is considered fairly late in the development process. Eventually, we intend to incorporate chaining into a complete life cycle software analysis and testing environment, such as the TAOS environment <ref> [24] </ref>. TAOS provides dependence analysis and testing at the implementation level, with some support for specification-based test case generation and result checking. Integrating architecture analysis techniques such as chaining would round out the life cycle support for analysis and testing. 14
Reference: [25] <author> D.J. Richardson, </author> <title> T.O. O'Malley, C.T. Moore, and S.L. Aha. Developing and Integrating ProDAG in the Arcadia Environment. </title> <booktitle> In SIGSOFT '92: Proceedings of the Fifth Symposium on Software Development Environments, </booktitle> <pages> pages 109-119. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> December </month> <year> 1992. </year>
Reference-contexts: We are developing an architecture-level dependence analysis technique, called chaining, and implementing the technique in a tool called Aladdin. Aladdin is similar in concept to ProDAG <ref> [25] </ref>, which is an implementation-level dependence analysis tool for Ada and C++ programs. Dependence analysis is performed by both ProDAG and Aladdin in a two-step process. First, an intermediate representation is created, and then language-independent analysis is performed over this representation.
Reference: [26] <author> A.M. Sloane and J. Holdsworth. </author> <title> Beyond Traditional Program Slicing. </title> <booktitle> In Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA '96), </booktitle> <pages> pages 180-186. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: Our notion of chaining is intended to support a range of analysis applications, including what would amount to an architectural slice. Program slicing was originally introduced by Weiser [30] as an aid to program debugging. Sloane and Holdsworth <ref> [26] </ref> suggest generalizing the concept of program slicing and show the potential in syntax-based slicing of non-imperative programs. We agree with the spirit of this work and are pursuing a similar goal, but in the particular context of software architectures.
Reference: [27] <author> RAPIDE Design Team. </author> <title> Draft: Guide to the Rapide 1.0 Language Reference Manuals. </title> <month> July </month> <year> 1997. </year>
Reference-contexts: For purposes of this paper, we present only a brief overview of the language, and restrict ourselves to the features used in our example. A full description of the language is available in the Rapide language manuals <ref> [27] </ref>. Components are defined in terms of their interfaces. Three types of components are described in specify different aspects of the component's behavior and its interactions with other components. Two sections are of relevance here.
Reference: [28] <author> RAPIDE Design Team. </author> <title> Draft: Rapide 1.0 Pattern Language Reference Manual. </title> <month> July </month> <year> 1997. </year>
Reference-contexts: A behavior section, which may contain local declarations, describes the computation performed by the component, including how the component reacts to in actions and generates out actions. Computations are defined in an event pattern language <ref> [28] </ref>. Patterns are sets of events together with their partial ordering, which is represented by a so-called poset. Posets are the basis for the dynamic analyses, such as simulation, provided with the Rapide tool set. Thus, they nicely complement the static analyses provided by Aladdin.
Reference: [29] <author> S. Vestal. </author> <title> MetaH Programmer's Manual. Honeywell, </title> <publisher> Inc., </publisher> <address> Minneapolis, MN, </address> <year> 1996. </year>
Reference-contexts: Architectural specifications and system implementations tend to drift apart if not carefully managed. Two approaches intended to support precise mappings are code generation <ref> [29, 31] </ref> and architecture recovery [6, 19]. 3 Chaining Chaining is a dependence analysis technique we propose for use at the architectural level.
Reference: [30] <author> M. Weiser. </author> <title> Program Slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(4) </volume> <pages> 352-357, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: The traditional view of dependence analysis is based on control and data flow relationships associated with functions and variables (e.g., <ref> [13, 21, 30] </ref>). This type of analysis was originally applied to program optimization [2] in order to determine safe code restructuring. The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., [4, 9]). <p> Our notion of chaining is intended to support a range of analysis applications, including what would amount to an architectural slice. Program slicing was originally introduced by Weiser <ref> [30] </ref> as an aid to program debugging. Sloane and Holdsworth [26] suggest generalizing the concept of program slicing and show the potential in syntax-based slicing of non-imperative programs. We agree with the spirit of this work and are pursuing a similar goal, but in the particular context of software architectures.
Reference: [31] <author> G. Zelesnik. </author> <title> Unicon Reference Manual. </title> <type> Technical Report CMU-CS-97-TBD, </type> <institution> Carnagie Mellon Uni-veristy, </institution> <year> 1997. </year>
Reference-contexts: Architectural specifications and system implementations tend to drift apart if not carefully managed. Two approaches intended to support precise mappings are code generation <ref> [29, 31] </ref> and architecture recovery [6, 19]. 3 Chaining Chaining is a dependence analysis technique we propose for use at the architectural level.
Reference: [32] <author> J. Zhao. </author> <title> Using Dependence Analysis to Support Software Architecture Understanding. </title> <booktitle> New Technologies on Computer Software, </booktitle> <pages> pages 135-142, </pages> <month> September </month> <year> 1997. </year> <month> 16 </month>
Reference-contexts: Chang and Richardson [5] introduced techniques for creating dynamic specification slices. This approach uses traditional slicing criteria, whereas our work involves exploring relationships at the architectural level, where additional criteria are defined. Zhao <ref> [32] </ref> is investigating the use of a system dependence net to slice architectural descriptions written in the Wright ADL. The work described in this initial paper is similar in nature to our work on chaining, but is preliminary and the details of the method for determining related components are unstated.
References-found: 32

