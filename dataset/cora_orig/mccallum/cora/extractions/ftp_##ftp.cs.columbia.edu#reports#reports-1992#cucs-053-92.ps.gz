URL: ftp://ftp.cs.columbia.edu/reports/reports-1992/cucs-053-92.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1992.html
Root-URL: http://www.cs.columbia.edu
Title: Testing String Superprimitivity in Parallel  
Author: Dany Breslauer 
Address: CUCS-053-92  
Affiliation: Columbia University  
Abstract: A string w covers another string z if every symbol of z is within some occurrence of w in z. A string is called superprimitive if it is covered only by itself, and quasiperi-odic if it is covered by some shorter string. This paper presents an O(log log n) time n log n log log n -processor CRCW-PRAM algorithm that tests if a string is superprimitive. The algorithm is the fastest possible with this number of processors over a general alphabet.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Apostolico and D. Breslauer. </author> <title> An Optimal O(log log n) Time Parallel Algorithm for Detecting all Squares in a String. </title> <type> Technical Report CUCS-040-92, </type> <institution> Computer Science Dept., Columbia University, </institution> <year> 1992. </year>
Reference-contexts: Thus, the algorithm presented in this paper is a factor of log n processors away from optimality. Note that there exists a trivial constant time superprimitivity testing algorithm that uses n 2 processors. The superprimitivity testing algorithm follows techniques that were used in solving several other parallel string problems <ref> [1, 2, 6, 10] </ref>.
Reference: [2] <author> A. Apostolico, D. Breslauer, and Z. Galil. </author> <title> Optimal Parallel Algorithms for Periods, Palindromes and Squares. </title> <booktitle> In Proc. 19th International Colloquium on Automata, Languages, and Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1992. </year> <pages> 296-307. </pages>
Reference-contexts: Thus, the algorithm presented in this paper is a factor of log n processors away from optimality. Note that there exists a trivial constant time superprimitivity testing algorithm that uses n 2 processors. The superprimitivity testing algorithm follows techniques that were used in solving several other parallel string problems <ref> [1, 2, 6, 10] </ref>.
Reference: [3] <author> A. Apostolico and A. Ehrenfeucht. </author> <title> Efficient Detection of Quasiperiodicities in Strings. </title> <type> Technical Report 90.5, </type> <institution> The Leonadro Fibonacci Institute, Trento, Italy, </institution> <year> 1990. </year>
Reference-contexts: 1 Introduction Quasiperiodicity, as defined by Apostolico and Ehrenfeucht <ref> [3] </ref>, is an avoidable regularity of strings that is strongly related to other regularities such as periods and squares [12]. Apostolico, Farach and Iliopoulos [4] and Breslauer [7] gave linear-time sequential algorithms that tests if a string is superprimitive. Apostolico and Ehrenfeucht [3] presented an algorithm that finds all maximal quasiperiodic <p> Introduction Quasiperiodicity, as defined by Apostolico and Ehrenfeucht <ref> [3] </ref>, is an avoidable regularity of strings that is strongly related to other regularities such as periods and squares [12]. Apostolico, Farach and Iliopoulos [4] and Breslauer [7] gave linear-time sequential algorithms that tests if a string is superprimitive. Apostolico and Ehrenfeucht [3] presented an algorithm that finds all maximal quasiperiodic substrings of a string. This paper presents a parallel algorithm that tests if a string of length n is superprimitive in O (log log n) time on a n log n log log n -processor CRCW-PRAM.
Reference: [4] <author> A. Apostolico, M. Farach, and C. S. Iliopoulos. </author> <title> Optimal superprimitivity testing for strings. </title> <journal> Inform. Process. Lett., </journal> <volume> 39 </volume> <pages> 17-20, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Quasiperiodicity, as defined by Apostolico and Ehrenfeucht [3], is an avoidable regularity of strings that is strongly related to other regularities such as periods and squares [12]. Apostolico, Farach and Iliopoulos <ref> [4] </ref> and Breslauer [7] gave linear-time sequential algorithms that tests if a string is superprimitive. Apostolico and Ehrenfeucht [3] presented an algorithm that finds all maximal quasiperiodic substrings of a string. <p> Clearly, a string is always a border of itself. This border is called the trivial border. We describe next few simple facts which are used in the superprimitivity testing algorithm. Most of these facts were used in the sequential algorithms <ref> [4, 7] </ref> where their proofs can be found. Fact 2.1 A string z has a period of length , such that &lt; jzj, if and only if it has a non-trivial border of length jzj .
Reference: [5] <author> R. P. Brent. </author> <title> Evaluation of general arithmetic expressions. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 21 </volume> <pages> 201-206, </pages> <year> 1974. </year>
Reference-contexts: One of the major issues in the design of a PRAM algorithms is the assignment of proces sors to their tasks. We ignore this issue in this paper and use a general theorem that states that the assignment can be done. Theorem 3.1 (Brent <ref> [5] </ref>) Any synchronous parallel algorithm of time t that consists of a total of x elementary operations can be implemented on p processors in dx=pe + t time. 4 The Basic Step This section shows how to test efficiently whether a given string w covers another string z.
Reference: [6] <author> D. Breslauer. </author> <title> Efficient String Algorithmics. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Columbia University, </institution> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: Thus, the algorithm presented in this paper is a factor of log n processors away from optimality. Note that there exists a trivial constant time superprimitivity testing algorithm that uses n 2 processors. The superprimitivity testing algorithm follows techniques that were used in solving several other parallel string problems <ref> [1, 2, 6, 10] </ref>.
Reference: [7] <author> D. Breslauer. </author> <title> An On-Line String Superprimitivity Test. </title> <journal> Inform. Process. Lett., </journal> <note> to appear. </note>
Reference-contexts: 1 Introduction Quasiperiodicity, as defined by Apostolico and Ehrenfeucht [3], is an avoidable regularity of strings that is strongly related to other regularities such as periods and squares [12]. Apostolico, Farach and Iliopoulos [4] and Breslauer <ref> [7] </ref> gave linear-time sequential algorithms that tests if a string is superprimitive. Apostolico and Ehrenfeucht [3] presented an algorithm that finds all maximal quasiperiodic substrings of a string. <p> Clearly, a string is always a border of itself. This border is called the trivial border. We describe next few simple facts which are used in the superprimitivity testing algorithm. Most of these facts were used in the sequential algorithms <ref> [4, 7] </ref> where their proofs can be found. Fact 2.1 A string z has a period of length , such that &lt; jzj, if and only if it has a non-trivial border of length jzj .
Reference: [8] <author> D. Breslauer and Z. Galil. </author> <title> An optimal O(log log n) time parallel string matching algorithm. </title> <journal> SIAM J. Comput., </journal> <volume> 19(6) </volume> <pages> 1051-1058, </pages> <year> 1990. </year>
Reference-contexts: Note that there exists a trivial constant time superprimitivity testing algorithm that uses n 2 processors. The superprimitivity testing algorithm follows techniques that were used in solving several other parallel string problems [1, 2, 6, 10]. In particular, it uses the parallel string matching algorithm of Breslauer and Galil <ref> [8] </ref> as a procedure that solves several string matching problems simultaneously and then combines the results of the string matching problems into an answer to the superprimitivity problem. 1 The paper is organized as follow. Section 2 gives basic definitions and properties of strings. <p> We use the Breslauer and Galil <ref> [8] </ref> parallel string matching algorithm that takes O (log log m) time on a n log log m -processor CRCW-PRAM. This algorithm is the fastest optimal parallel string matching algorithm on a general alphabet as implied by a lower bound of Breslauer and Galil [9]. 2. <p> Theorem 4.1 Given two string z and w, there exists an algorithm that tests whether w covers z in O (log log jzj) time on a jzj log log jzj -processor CRCW-PRAM. Proof: The algorithm has two steps: 3 1. Using Breslauer and Galil's <ref> [8] </ref> string matching algorithm, find all occurrences of w in z. This step takes O (log log jzj) time and uses jzj log log jzj processors. 2. Using Fich, Ragde and Wigderson's [11] integer minima algorithm verify that each symbol of z is within an occurrence of w.
Reference: [9] <author> D. Breslauer and Z. Galil. </author> <title> A Lower Bound for Parallel String Matching. </title> <journal> SIAM J. Comput., </journal> <volume> 21(5) </volume> <pages> 856-862, </pages> <year> 1992. </year>
Reference-contexts: This algorithm is the fastest optimal parallel string matching algorithm on a general alphabet as implied by a lower bound of Breslauer and Galil <ref> [9] </ref>. 2. The parallel algorithm of Breslauer and Galil [10] that finds all periods of a string of length n in O (log log n) time on a n log log m -processor CRCW-PRAM. <p> The shortest border that was found to covers z is the quasiperiod of z. 2 4 6 The Lower Bound We prove a lower bound for testing if a string is superprimitive by a reduction to the lower bound for string matching by Breslauer and Galil <ref> [9] </ref>. That lower bound is on the number of comparison rounds an algorithm that computes the period of a string has to perform when there are p comparisons in each round. <p> The lower bounds holds for the CRCW-PRAM model in case of a general alphabet where the only access an algorithm has to the input strings is by pairwise comparisons of symbols. Breslauer and Galil <ref> [9] </ref> show that an adversary can fool any algorithm which claims to test if a string has a period which is shorter than half of its length in less than (d n p e + log log d1+p=ne 2p) rounds of p comparisons each. <p> Without going into the detail of that lower bound, we use the fact that the adversary of Breslauer and Galil <ref> [9] </ref> answers the comparisons in each round in such a way that after (d n p e + log log d1+p=ne 2p) rounds it is still possible that the input string has a period that is shorter than half of its length or that is does not have any such period. <p> In the latter case there is at least one symbol of the string that does not appear anywhere else. Lemma 6.1 The string generated by Breslauer and Galil's <ref> [9] </ref> adversary is superprimitive if and only if it does not have a period that is shorter than half of its length. <p> Proof: By Lemma 6.1 the lower bound of Breslauer and Galil <ref> [9] </ref> holds also for superprim itivity testing. 2 Corollary 6.3 The algorithm described in Section 5 is the fastest possible with the number of processors used.
Reference: [10] <author> D. Breslauer and Z. Galil. </author> <title> Finding all periods and initial palindromes of a string in parallel. </title> <type> Technical Report CUCS-017-92, </type> <institution> Computer Science Dept., Columbia University, </institution> <year> 1992. </year>
Reference-contexts: Thus, the algorithm presented in this paper is a factor of log n processors away from optimality. Note that there exists a trivial constant time superprimitivity testing algorithm that uses n 2 processors. The superprimitivity testing algorithm follows techniques that were used in solving several other parallel string problems <ref> [1, 2, 6, 10] </ref>. <p> This algorithm is the fastest optimal parallel string matching algorithm on a general alphabet as implied by a lower bound of Breslauer and Galil [9]. 2. The parallel algorithm of Breslauer and Galil <ref> [10] </ref> that finds all periods of a string of length n in O (log log n) time on a n log log m -processor CRCW-PRAM. <p> Theorem 5.1 There exists an algorithm that computes the quasiperiod of a string z in O (log log jzj) time on a jzj log jzj log log jzj -processors CRCW-PRAM. Proof: The algorithm consists of four steps. 1. Compute all borders of z using Breslauer and Galil's <ref> [10] </ref> algorithm that finds all periods of a string. Recall that by Fact 2.2 if w covers z then w must be a border of z and by Fact 2.1 there is a one-to-one correspondence between the borders and the periods of a string. 2.
Reference: [11] <author> F. E. Fich, R. L. Ragde, and A. Wigderson. </author> <title> Relations between concurrent-write models of parallel computation. </title> <booktitle> In Proc. 3rd ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 179-189, </pages> <year> 1984. </year>
Reference-contexts: The output of this algorithm is a Boolean array periods [1::n] that has a " true " value at each position which is a period of the input string. 3. The algorithm of Fich, Ragde and Wigderson <ref> [11] </ref> to compute the minimum of n integers between 1 and n in constant time using an n-processor CRCW-PRAM. One of the major issues in the design of a PRAM algorithms is the assignment of proces sors to their tasks. <p> Proof: The algorithm has two steps: 3 1. Using Breslauer and Galil's [8] string matching algorithm, find all occurrences of w in z. This step takes O (log log jzj) time and uses jzj log log jzj processors. 2. Using Fich, Ragde and Wigderson's <ref> [11] </ref> integer minima algorithm verify that each symbol of z is within an occurrence of w. This step takes constant time and uses jzj processors. It can be done as follows: The string jzj is partitioned into consecutive blocks of length jwj. The computation proceeds simultaneously in each block. <p> It can be done as follows: The string jzj is partitioned into consecutive blocks of length jwj. The computation proceeds simultaneously in each block. The position in z of the first and last occurrences of w in each block are found using the using Fich, Ragde and Wigderson's <ref> [11] </ref> integer minima algorithm. All symbols of z which are between the first and last occurrences of w in the same block are obviously covered. <p> By Fact 2.4 only the shortest border in each interval is a candidate for the quasiperiod of z. The shortest border in each interval can be found in constant time and jzj by using Fich, Ragde and Wigderson's <ref> [11] </ref> integer minima algorithm in each block simultaneously. 3. In each interval simultaneously, check if the shortest border in the interval covers z. 4.
Reference: [12] <author> M. </author> <title> Lothaire. Combinatorics on Words. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA., U.S.A., </address> <year> 1983. </year> <month> 6 </month>
Reference-contexts: 1 Introduction Quasiperiodicity, as defined by Apostolico and Ehrenfeucht [3], is an avoidable regularity of strings that is strongly related to other regularities such as periods and squares <ref> [12] </ref>. Apostolico, Farach and Iliopoulos [4] and Breslauer [7] gave linear-time sequential algorithms that tests if a string is superprimitive. Apostolico and Ehrenfeucht [3] presented an algorithm that finds all maximal quasiperiodic substrings of a string.
References-found: 12

