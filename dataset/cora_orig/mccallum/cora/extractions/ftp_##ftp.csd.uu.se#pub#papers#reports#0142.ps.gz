URL: ftp://ftp.csd.uu.se/pub/papers/reports/0142.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: e-mail: thomasl@csd.uu.se  
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: Impact of Structure Analysis on Prolog Compilation  
Author: Thomas Lindgren 
Address: Uppsala University  Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Computing Science Dept.,  
Note: The  
Abstract: UPMAIL Technical Report No. 142 May 6, 1996 ISSN 1100-0686 Abstract Structure analyses derive (possibly recursive) descriptions of the shape of data structures. We investigate the use of structure analysis in compiling Prolog. We implement a structure analyzer for Prolog by extending previous type graph analyses, and evaluate its precision and performance on a set of realistic benchmarks. We then attempt to quantify the use of the derived structure information for optimizing compilation.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Bigot, S.K. Debray, </author> <title> A simple approach to supporting untagged objects in dynamically typed languages, </title> <booktitle> in Proc. </booktitle> <address> ILPS'95. </address>
Reference-contexts: In particular, Common Lisp has an extensive system of type declarations which Python can use to strength-reduce arithmetic. It is unclear to which extent Python is capable of strength-reducing arithmetic without declarations. Bigot and Debray <ref> [1] </ref> consider how to optimize the use of untagged integers and floating point values in a logic programming context. They do not consider bignum arithmetic and concentrate on passing untagged accumulators.
Reference: [2] <author> C. Braem, B. Le Charlier, S. Modart, P. Van Hentenryck, </author> <title> Cardinality analysis of Prolog, </title> <booktitle> in Proc. </booktitle> <address> ILPS'94. </address>
Reference-contexts: We use redundant tests to propagate information between proof tree branches while retaining a simple analysis framework. This approach is quite limited in its scope and it might be useful to consider approaches such as the cardinality analysis of Braems et al <ref> [2] </ref> For instance, propagating assertions X &lt; Y through the program is orthogonal to our range arithmetic and may provide opportunities for further optimizations. 7 Conclusion and future work We proposed a simple structure analysis domain, type jungles.
Reference: [3] <author> A. Cortesi, B. Le Charlier, P. Van Hentenryck, </author> <title> Combinations of abstract domains for logic programming, </title> <booktitle> in Proc. </booktitle> <address> POPL'94. </address>
Reference-contexts: The disadvantage is obviously that type jungles are less precise; in particular, any-nodes may cause imprecise summaries. Our use of a pattern domain <ref> [3] </ref> appears to compensate for this disadvantage. Finally, we extended our analyzer to use a rich set of leaf nodes to retain precision in some useful cases. <p> An overview is shown in Figure 2. We extended this framework in a number of ways. We used a variation of Cortesi, Le Charlier and Van Hentenryck's PAT (&lt;) domain <ref> [3] </ref>, which tracks same-value and known-value information precisely through a clause. The analyzer only propagated same/known-value information within a clause. Our second extension was to use the clause selection rule and cuts of Prolog to improve precision.
Reference: [4] <author> P. Cousot, R. Cousot, </author> <title> Static determination of dynamic properties of programs, </title> <booktitle> in Proc. 2nd Intl. Symp. on Programming, </booktitle> <year> 1976. </year>
Reference-contexts: The float element represents the set of floating point numbers. We defined the abstract operations to conform with SICStus Prolog v3. For termination reasons, we introduced a widening on the integer ranges along the lines of Cousot and Cousot <ref> [4] </ref>. However, we do not use narrowing to subsequently improve precision.
Reference: [5] <author> S.K. Debray, </author> <title> Efficient dataflow analysis of logic programs, </title> <journal> Journal of the ACM, </journal> <year> 1992. </year>
Reference-contexts: A type graph is a structure description in the form of a disjunctive rational tree where nodes are function nodes labelled f =n (representing compound terms with functor f =n; n 0), OR-nodes, or leaf nodes (e.g., representing "any term"). A rigid type graph has only instantiation closed <ref> [5] </ref> nodes and so does not require aliasing information to remain correct. For instance, a type graph describing all lists of lists of atoms red, white or blue is shown in Figure 1 (a). The interested reader is directed to Refs. [9, 19] for further information on the algorithms used. <p> While it could have improved precision in some cases, it makes the algorithms more complex. Furthermore, it may be easier and/or more flexible to perform mode analysis with groundness as a separate analysis. 3 Analysis framework Our prototype analyzer is based on the static analysis framework proposed by Debray <ref> [5] </ref>. An overview is shown in Figure 2. We extended this framework in a number of ways. We used a variation of Cortesi, Le Charlier and Van Hentenryck's PAT (&lt;) domain [3], which tracks same-value and known-value information precisely through a clause.
Reference: [6] <author> T. Getzinger, </author> <title> Abstract interpretation for the compile-time analysis of logic programs, </title> <type> technical report ACAL-TR-93-09, </type> <institution> University of South California, </institution> <year> 1993. </year>
Reference-contexts: Our use of a pattern domain [3] appears to compensate for this disadvantage. Finally, we extended our analyzer to use a rich set of leaf nodes to retain precision in some useful cases. Getzinger's experience with type graph analysis for compilation <ref> [6] </ref> indicates that leaf nodes that can express properties such as nonvar or atom may be quite important, 2.3 Leaf nodes Previous implementations of type graphs [9, 19, 6] have provided only the any leaf node, representing any term. <p> Getzinger's experience with type graph analysis for compilation [6] indicates that leaf nodes that can express properties such as nonvar or atom may be quite important, 2.3 Leaf nodes Previous implementations of type graphs <ref> [9, 19, 6] </ref> have provided only the any leaf node, representing any term. We provided a variety of leaf nodes for three reasons: to express the outcome of type tests, to improve robustness of results and to enable optimizations that were otherwise impossible. <p> Nevertheless, it is clear that type information can aid a sophisticated compiler. Unsophisticated compilers, on the other hand, may not see great gains by putting their faith solely to type analysis. 6 Related work Several analyses for deriving structure information for Prolog or Lisp have been proposed previously <ref> [9, 8, 19, 22, 6, 22] </ref>. <p> Van Hentenryck et al provide call/success pattern precision for a number of benchmarks [19], but do not relate their results to compiler optimization. To our knowledge, only Getzinger <ref> [6] </ref> has studied the usefulness of type graphs for compilation.
Reference: [7] <author> T. Getzinger, </author> <title> The costs and benefits of abstract interpretation-driven Prolog optimization, </title> <booktitle> in Proc. </booktitle> <address> SAS'94. </address>
Reference: [8] <author> N. Heinze, </author> <title> Practical aspects of set based analysis, </title> <booktitle> in Proc. </booktitle> <address> JICSLP'92. </address>
Reference-contexts: At that point, type checking is deferred to runtime. Nevertheless, a number of analyses have been aimed at discovering structure information for logic programs <ref> [9, 19, 8, 10] </ref>. This paper is concerned with measuring the usefulness of type information for Prolog compilation, as derived by a structure analysis. Rather than considering call/success pattern precision, we attempt to quantify the effects that analysis information will have on compiled code. <p> Nevertheless, it is clear that type information can aid a sophisticated compiler. Unsophisticated compilers, on the other hand, may not see great gains by putting their faith solely to type analysis. 6 Related work Several analyses for deriving structure information for Prolog or Lisp have been proposed previously <ref> [9, 8, 19, 22, 6, 22] </ref>.
Reference: [9] <author> G. Janssens, M. Bruynooghe, </author> <title> Deriving descriptions of possible values of program variables by means of abstract interpretation, </title> <journal> Journal of Logic Programming, </journal> <year> 1992. </year>
Reference-contexts: At that point, type checking is deferred to runtime. Nevertheless, a number of analyses have been aimed at discovering structure information for logic programs <ref> [9, 19, 8, 10] </ref>. This paper is concerned with measuring the usefulness of type information for Prolog compilation, as derived by a structure analysis. Rather than considering call/success pattern precision, we attempt to quantify the effects that analysis information will have on compiled code. <p> A rigid type graph has only instantiation closed [5] nodes and so does not require aliasing information to remain correct. For instance, a type graph describing all lists of lists of atoms red, white or blue is shown in Figure 1 (a). The interested reader is directed to Refs. <ref> [9, 19] </ref> for further information on the algorithms used. Type graphs are powerful and flexible, but may in practice grow very large, sometimes to sizes of millions of words [17]. <p> Getzinger's experience with type graph analysis for compilation [6] indicates that leaf nodes that can express properties such as nonvar or atom may be quite important, 2.3 Leaf nodes Previous implementations of type graphs <ref> [9, 19, 6] </ref> have provided only the any leaf node, representing any term. We provided a variety of leaf nodes for three reasons: to express the outcome of type tests, to improve robustness of results and to enable optimizations that were otherwise impossible. <p> Nevertheless, it is clear that type information can aid a sophisticated compiler. Unsophisticated compilers, on the other hand, may not see great gains by putting their faith solely to type analysis. 6 Related work Several analyses for deriving structure information for Prolog or Lisp have been proposed previously <ref> [9, 8, 19, 22, 6, 22] </ref>. <p> To our knowledge, only Getzinger [6] has studied the usefulness of type graphs for compilation. He implemented a version of the type graphs of Janssens and Bruynooghe <ref> [9] </ref> in the context of Aquarius Prolog, and found (a) that the analyzer was too inefficient for general use (e.g., requiring several hours to analyze some small benchmarks and not terminating for several other programs) and (b) that the analysis results only provided a 1% improvement on the results of less
Reference: [10] <author> T. Kanamori, T. Kawamura, </author> <title> Analysing success patterns of logic programs by abstract hybrid interpretation, </title> <type> technical report, </type> <institution> ICOT, </institution> <year> 1987. </year>
Reference-contexts: At that point, type checking is deferred to runtime. Nevertheless, a number of analyses have been aimed at discovering structure information for logic programs <ref> [9, 19, 8, 10] </ref>. This paper is concerned with measuring the usefulness of type information for Prolog compilation, as derived by a structure analysis. Rather than considering call/success pattern precision, we attempt to quantify the effects that analysis information will have on compiled code.
Reference: [11] <author> A. Krall, T. Berger, </author> <title> Incremental global compilation of Prolog with the Vienna Abstract Machine, </title> <booktitle> in Proc. </booktitle> <address> ICLP'95. </address>
Reference: [12] <author> B. Le Charlier, S. Rossi, P. Van Hentenryck, </author> <title> An abstract interpretation framework which accurately handles Prolog search-rule and the cut, </title> <booktitle> in Proc. </booktitle> <address> ILPS'94. </address>
Reference-contexts: The analyzer only propagated same/known-value information within a clause. Our second extension was to use the clause selection rule and cuts of Prolog to improve precision. Usually, analysis frameworks work with Horn clauses rather than general Prolog clauses, and often discard information available from cuts. (One exception is Ref. <ref> [12] </ref>.) We used a simple extension of the standard analysis: insertion of redundant tests in the code. Consider the following predicate. p (X) :- ; r (X) 5 We can rewrite it into an equivalent predicate that performs a redundant test. p (X) :- ; nonvar (X), r (X) ).
Reference: [13] <author> T. Lindgren, </author> <title> Control flow analysis of Prolog (extended remix), </title> <type> Technical report 112, </type> <institution> Computing Science Dept., Uppsala University, </institution> <year> 1995. </year>
Reference-contexts: The introduced tests are later used to annotate the program, but are themselves deleted from the annotated program. For some experiments we introduced explicit code to perform indexing <ref> [13] </ref>, in the form of type tests and name tests.
Reference: [14] <author> T. Lindgren, P. Mildner, </author> <title> The precision of a simple structure analyzer, </title> <type> Technical Report 140, </type> <institution> Computing Science Department, Uppsala University, </institution> <year> 1997. </year>
Reference-contexts: Type information enabled no optimizations in this code, an unexpectedly poor result when we consider only the call/success precision. For this reason, we chose to evaluate the type jungle domain by looking at how individual primitive operations could be optimized by considering type information. (A companion paper <ref> [14] </ref> measures precision more conventionally, and also shows that analysis times are very good.) Measurements were done as follows. * The benchmark programs were analyzed and the annotated programs dumped on disk. * A second pass traverses the annotated programs and classifies each primitive operation according to a number of optimization
Reference: [15] <author> T. Lindgren, </author> <title> Polyvariant detection of uninitialized arguments of Prolog predicates, </title> <journal> Journal of Logic Programming, </journal> <month> Sep. </month> <year> 1997. </year>
Reference-contexts: This reduces the cost of procedure calls by reducing the size of the environment. We will not further consider this topic in this paper since there are simple and efficient analyses that detect uninitialized arguments, e.g. <ref> [15] </ref>. 7 4.2 Measurements We analyzed the Berkeley benchmark suite and classified the primitive operations therein. <p> Primitive operations were counted as follows: the program was subjected to indexing expressed in Prolog (which introduces type tests, unifications and functor tests), and all unifications normalized (i.e., broken up into sequences of simple unifications). Prior to type analysis, an uninitialized variable analysis <ref> [15] </ref> is performed, which may introduce several versions of each source-level predicate, and which also deletes unused predicates. After analysis, annotation deletes primitives that always fail as well as code depending on that primitive; failed and unexecuted primitives are not counted.
Reference: [16] <author> R.A. MacLachlan, </author> <title> The Python compiler for CMU Common Lisp, </title> <booktitle> in Proc. </booktitle> <address> LFP'92. </address>
Reference-contexts: In part, this was due to lacking struct, atom and similar leaf nodes, and thus being unable to express the results of type tests. The Python CMU Common Lisp compiler <ref> [16] </ref> uses type propagation to optimize the generic arithmetic of Common Lisp. In particular, Common Lisp has an extensive system of type declarations which Python can use to strength-reduce arithmetic. It is unclear to which extent Python is capable of strength-reducing arithmetic without declarations.
Reference: [17] <author> P. Mildner, T. Lindgren, </author> <title> Type graphs in practice, </title> <type> Technical Report 141, </type> <institution> Computing Science Department, Uppsala University, </institution> <year> 1997. </year>
Reference-contexts: The interested reader is directed to Refs. [9, 19] for further information on the algorithms used. Type graphs are powerful and flexible, but may in practice grow very large, sometimes to sizes of millions of words <ref> [17] </ref>. <p> Finally, the results should be verified in an optimizing compiler and be extended to a larger set of benchmarks. Structure analysis of very large programs is still a fairly open topic, though some work has been done <ref> [17] </ref>. An optimizing compiler can change these results in two directions: it can dampen their impact, by compiling imprecise cases well as compared to precise cases; or it can enhance our results by introducing new optimizations since so much useless code can be removed.
Reference: [18] <author> A. Taylor, </author> <title> High-Performance Prolog Implementation, </title> <type> Ph.D. Thesis, </type> <institution> University of Sydney, </institution> <year> 1991. </year>
Reference: [19] <author> P. Van Hentenryck, A. Cortesi, B. Le Charlier, </author> <title> Type analysis of Prolog using type graphs, </title> <journal> Journal of Logic Programming, </journal> <year> 1995. </year>
Reference-contexts: At that point, type checking is deferred to runtime. Nevertheless, a number of analyses have been aimed at discovering structure information for logic programs <ref> [9, 19, 8, 10] </ref>. This paper is concerned with measuring the usefulness of type information for Prolog compilation, as derived by a structure analysis. Rather than considering call/success pattern precision, we attempt to quantify the effects that analysis information will have on compiled code. <p> A rigid type graph has only instantiation closed [5] nodes and so does not require aliasing information to remain correct. For instance, a type graph describing all lists of lists of atoms red, white or blue is shown in Figure 1 (a). The interested reader is directed to Refs. <ref> [9, 19] </ref> for further information on the algorithms used. Type graphs are powerful and flexible, but may in practice grow very large, sometimes to sizes of millions of words [17]. <p> Getzinger's experience with type graph analysis for compilation [6] indicates that leaf nodes that can express properties such as nonvar or atom may be quite important, 2.3 Leaf nodes Previous implementations of type graphs <ref> [9, 19, 6] </ref> have provided only the any leaf node, representing any term. We provided a variety of leaf nodes for three reasons: to express the outcome of type tests, to improve robustness of results and to enable optimizations that were otherwise impossible. <p> Nevertheless, it is clear that type information can aid a sophisticated compiler. Unsophisticated compilers, on the other hand, may not see great gains by putting their faith solely to type analysis. 6 Related work Several analyses for deriving structure information for Prolog or Lisp have been proposed previously <ref> [9, 8, 19, 22, 6, 22] </ref>. <p> Benchmarks not shown did not call functor/3. 20 efficiently implementing the analysis operations and paid relatively little attention to the outcome of the analysis. Van Hentenryck et al provide call/success pattern precision for a number of benchmarks <ref> [19] </ref>, but do not relate their results to compiler optimization. To our knowledge, only Getzinger [6] has studied the usefulness of type graphs for compilation.
Reference: [20] <author> P.L. Van Roy, </author> <title> Can Logic Programming Execute as Fast as Imperative Programming?, </title> <type> Ph.D. Thesis, Report UCB/CSD-90-600, </type> <institution> UC Berkeley, </institution> <year> 1990. </year>
Reference: [21] <author> P.L. Van Roy, </author> <year> 1983-1993: </year> <title> The Wonder Years of Sequential Prolog Implementation, </title> <journal> Journal of Logic Programming, </journal> <year> 1995. </year>
Reference: [22] <author> E. Wang, P. Hilfinger, </author> <title> Analysis of recursive types in Lisp-like languages, </title> <booktitle> in Proc. LFP'92. </booktitle> <pages> 23 </pages>
Reference-contexts: Nevertheless, it is clear that type information can aid a sophisticated compiler. Unsophisticated compilers, on the other hand, may not see great gains by putting their faith solely to type analysis. 6 Related work Several analyses for deriving structure information for Prolog or Lisp have been proposed previously <ref> [9, 8, 19, 22, 6, 22] </ref>.
References-found: 22

