URL: http://www.cs.colostate.edu/~ftppub/TechReports/1993/tr-132.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Title: Uniqueness and Completeness Analysis of Array  
Author: Comprehensions 
Affiliation: Department of Computer Science  Colorado State University  
Abstract: David Garza and Wim Bohm Technical Report CS-93-132 December 15, 1993 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers. Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1986. </year>
Reference-contexts: Step 3 generates the constraints that check if there are any two overlapping regions. 3.2.1 Example We apply algorithm 3 to the following array comprehension: A=- 1D_array (1..2m) of | <ref> [1] </ref> = 1 %region 1 | [2*i] = i || i = 1 to m %region 2 | [2*j+1] = j || j = 1 to m-1- %region 3 Step 2 generates the following constraints: for region 1 step 2b generates no constraints, step 2c creates the constraint 1 x 1 <p> A = -1D_array ((1,2*n+1)) of | <ref> [1] </ref> = 1 | [2*n+1] = n | [2*k-1] = 1 || k &lt;- 2 to n Step 2 gets the size of the array space j A j= 2n + 1. <p> Another limitation of algorithm 4 can be illustrated with the following example: A = -1D_array ((1,m)) of | <ref> [1] </ref> = 2x+y | [n] = z Here our algorithm obtains j A j= m and j A (I) j= n and since j A (I) j j A j= m n, we conclude that the array is incomplete. However, if m = n then the array would be complete. <p> However, if m = n then the array would be complete. Currently, when analyzing the array comprehension in vacuo, we don't have enough information about m or n to conclude completeness. In our compiler, constant propagation and induction variable replacement optimizations <ref> [1] </ref> must be performed prior to our completeness analysis, allowing us to have as much information as possible regarding symbolic variables used in the array comprehension. When expanding the sums, the size of the integer coefficients in the multivariate polynomials grows very large very quickly.
Reference: [2] <author> Steven Anderson and Paul Hudak. </author> <title> Compilation of Haskell Array Comprehensions for Scientific Com puting. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 137-149, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Some functional languages, such as Haskell, Id, and Sisal [11, 14, 13], have been designed to be used for scientific computing, and should therefore have efficiently implementable array operations <ref> [8, 3, 9, 2] </ref>. An array comprehension is a functional monolithic array constructor, defining an array as a whole entity. Id and Haskell have incorporated recursive array comprehensions, where array elements can be defined in terms of other array elements of the same array. <p> Secondly they introduce a data structure called atom which contains information about the array references and is used to propagate this information to the calling procedure. Hudak and Anderson <ref> [2] </ref> propose the use of subscript analysis for functional monolithic arrays. They recognize the uniqueness problem which they call Detecting Write Collisions, and they propose the use of Banerjee Inequalities test to check for independence.
Reference: [3] <author> Arvind and Rishiyur S. Nikhil. I-Structures: </author> <title> Data Structures for Parallel Computing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 598-632, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Some functional languages, such as Haskell, Id, and Sisal [11, 14, 13], have been designed to be used for scientific computing, and should therefore have efficiently implementable array operations <ref> [8, 3, 9, 2] </ref>. An array comprehension is a functional monolithic array constructor, defining an array as a whole entity. Id and Haskell have incorporated recursive array comprehensions, where array elements can be defined in terms of other array elements of the same array.
Reference: [4] <author> Utpal Banerjee. </author> <title> Dependence Analysis for Supercomputing. </title> <publisher> Kluwer Academic Publishing, </publisher> <year> 1988. </year>
Reference-contexts: Checking for this error introduces run-time inefficiency, which can be avoided by compile time uniqueness analysis. Uniqueness analysis employs subscript analysis techniques, similar to those used in optimizing and parallelizing conventional language compilers [19]. A significant number of data dependence tests <ref> [4, 19, 7] </ref> assume a predefined "standard" order of computation [7]. In array comprehensions we do not have such predefined order. The Omega test [15, 16] is an exact data dependence test based on integer linear programming. It is free of assumptions on evaluation order.
Reference: [5] <author> Utpal Banerjee. </author> <title> Loop Transformations for Restructuring Compilers. The Foundations. </title> <publisher> Kluwer Academic Publishing, </publisher> <year> 1993. </year>
Reference: [6] <author> A.P.W. Bohm, D. C. Cann, J. T. Feo and R. R. Oldehoeft. </author> <title> SISAL 2.0 Reference Manual. </title> <type> Technical Re port CS-91-118, </type> <institution> Computer Science Department, Colorado State University, </institution> <address> Fort Collins, CO, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: Id and Haskell have incorporated recursive array comprehensions, where array elements can be defined in terms of other array elements of the same array. Id and Haskell arrays are non-strict, i.e., not all elements of the array need to be defined. Sisal 2 <ref> [6] </ref> has incorporated the simpler form of non-recursive array generator. Sisal arrays are strict, i.e., they must be completely defined. An example of an Id style array comprehension for part of the "pascal triangle" is given in figure 1.
Reference: [7] <author> Michael Burke and Ron Cytron. </author> <title> Interprocedural Analysis and Parallelization. </title> <booktitle> In ACM SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 162-175, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Checking for this error introduces run-time inefficiency, which can be avoided by compile time uniqueness analysis. Uniqueness analysis employs subscript analysis techniques, similar to those used in optimizing and parallelizing conventional language compilers [19]. A significant number of data dependence tests <ref> [4, 19, 7] </ref> assume a predefined "standard" order of computation [7]. In array comprehensions we do not have such predefined order. The Omega test [15, 16] is an exact data dependence test based on integer linear programming. It is free of assumptions on evaluation order. <p> Uniqueness analysis employs subscript analysis techniques, similar to those used in optimizing and parallelizing conventional language compilers [19]. A significant number of data dependence tests [4, 19, 7] assume a predefined "standard" order of computation <ref> [7] </ref>. In array comprehensions we do not have such predefined order. The Omega test [15, 16] is an exact data dependence test based on integer linear programming. It is free of assumptions on evaluation order. <p> Typical methods for testing data dependence in the presence of procedure calls base their analysis on obtaining a summary of the array references of each procedure and then testing for overlap between any of these array elements <ref> [18, 10, 7, 12] </ref>. One problem with these approaches is that except for [7] and [12] the approaches produce an approximate summary of the array references. For our problem we require precise information. <p> One problem with these approaches is that except for <ref> [7] </ref> and [12] the approaches produce an approximate summary of the array references. For our problem we require precise information. Burke and Cytron [7] propose to linearize the array space and to generate a list of array access information for each procedure. <p> One problem with these approaches is that except for <ref> [7] </ref> and [12] the approaches produce an approximate summary of the array references. For our problem we require precise information. Burke and Cytron [7] propose to linearize the array space and to generate a list of array access information for each procedure.
Reference: [8] <author> D. C. Cann. </author> <title> Compilation Techniques for High Performance Applicative Computation. </title> <type> Ph.D. thesis, </type> <institution> Colorado State University, Computer Science Department, </institution> <address> Fort Collins, CO, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction Some functional languages, such as Haskell, Id, and Sisal [11, 14, 13], have been designed to be used for scientific computing, and should therefore have efficiently implementable array operations <ref> [8, 3, 9, 2] </ref>. An array comprehension is a functional monolithic array constructor, defining an array as a whole entity. Id and Haskell have incorporated recursive array comprehensions, where array elements can be defined in terms of other array elements of the same array.
Reference: [9] <author> G. R. Gao and Robert Kim Yates. </author> <title> An Efficient Monolithic Array Constructor. </title> <type> ACAPS Technical Memo 19, </type> <institution> School of Computer Science, McGill University, Montreal, Canada, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Some functional languages, such as Haskell, Id, and Sisal [11, 14, 13], have been designed to be used for scientific computing, and should therefore have efficiently implementable array operations <ref> [8, 3, 9, 2] </ref>. An array comprehension is a functional monolithic array constructor, defining an array as a whole entity. Id and Haskell have incorporated recursive array comprehensions, where array elements can be defined in terms of other array elements of the same array.
Reference: [10] <author> Paul Havlak, Ken Kennedy. </author> <title> Experience with Interprocedural Analysis of Array Side Effects. </title> <booktitle> In Super computing '90, </booktitle> <pages> pages 952-962, </pages> <year> 1990. </year>
Reference-contexts: Typical methods for testing data dependence in the presence of procedure calls base their analysis on obtaining a summary of the array references of each procedure and then testing for overlap between any of these array elements <ref> [18, 10, 7, 12] </ref>. One problem with these approaches is that except for [7] and [12] the approaches produce an approximate summary of the array references. For our problem we require precise information.
Reference: [11] <editor> P. Hudak et. al. </editor> <title> Report on the programming Language Haskell A non-strict, Purely Functional Lan guage version 1.0, </title> <type> Technical report, </type> <institution> Yale University, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Some functional languages, such as Haskell, Id, and Sisal <ref> [11, 14, 13] </ref>, have been designed to be used for scientific computing, and should therefore have efficiently implementable array operations [8, 3, 9, 2]. An array comprehension is a functional monolithic array constructor, defining an array as a whole entity.
Reference: [12] <author> Zhiyuan Li and Pen-Chung Yew. </author> <title> Efficient Interprocedural Analysis for Program Parallelization and Restructuring. </title> <booktitle> In ACM SIGPLAN PPEALS, </booktitle> <pages> pages 85-99, </pages> <year> 1988. </year>
Reference-contexts: Subscript Expr: A pointer to a matrix similar to the atom data structure described in <ref> [12] </ref>, where each row corresponds to one dimension of the array and each column corresponds to one of the Num Vars loop variables of the region. There are two extra columns: one that indicates if the subscript expression is linear and the other for the constant term. <p> Typical methods for testing data dependence in the presence of procedure calls base their analysis on obtaining a summary of the array references of each procedure and then testing for overlap between any of these array elements <ref> [18, 10, 7, 12] </ref>. One problem with these approaches is that except for [7] and [12] the approaches produce an approximate summary of the array references. For our problem we require precise information. <p> One problem with these approaches is that except for [7] and <ref> [12] </ref> the approaches produce an approximate summary of the array references. For our problem we require precise information. Burke and Cytron [7] propose to linearize the array space and to generate a list of array access information for each procedure. <p> Li and Yew's <ref> [12] </ref> approach is similar to Burke and Cytron's since they also form a set of array references and then apply a standard dependence test to prove independence between any two pairs of references.
Reference: [13] <author> J. R. McGraw, S. K. Skedzielewski, S. J. Allan, R. R. Oldehoeft, J. Glauert, C. Kirkham, W. Noyce, and R. Thomas. </author> <title> SISAL: Streams and iteration in a single assignment language: Reference manual version 1.2., Manual M-146, </title> <type> Rev. 1, </type> <institution> Lawrence Livermore National Laboratory, Livermore, </institution> <address> CA, </address> <month> March </month> <year> 1985. </year>
Reference-contexts: 1 Introduction Some functional languages, such as Haskell, Id, and Sisal <ref> [11, 14, 13] </ref>, have been designed to be used for scientific computing, and should therefore have efficiently implementable array operations [8, 3, 9, 2]. An array comprehension is a functional monolithic array constructor, defining an array as a whole entity.
Reference: [14] <author> R.S. Nikhil, </author> <title> Id (version 90.0) Reference Manual. </title> <type> TR CSG Memo 284-1, </type> <institution> MIT LCS 1990. </institution>
Reference-contexts: 1 Introduction Some functional languages, such as Haskell, Id, and Sisal <ref> [11, 14, 13] </ref>, have been designed to be used for scientific computing, and should therefore have efficiently implementable array operations [8, 3, 9, 2]. An array comprehension is a functional monolithic array constructor, defining an array as a whole entity. <p> We say that an array is uniquely defined if none of its elements is defined more than once. In the current implementation of Id a redefinition of an array element will give rise to a run-time error <ref> [14] </ref>. Checking for this error introduces run-time inefficiency, which can be avoided by compile time uniqueness analysis. Uniqueness analysis employs subscript analysis techniques, similar to those used in optimizing and parallelizing conventional language compilers [19].
Reference: [15] <author> William Pugh. </author> <title> The Omega Test: a fast and practical integer programming algorithm for dependence analysis. </title> <booktitle> In Supercomputing 1991, </booktitle> <pages> pages 4-13, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Uniqueness analysis employs subscript analysis techniques, similar to those used in optimizing and parallelizing conventional language compilers [19]. A significant number of data dependence tests [4, 19, 7] assume a predefined "standard" order of computation [7]. In array comprehensions we do not have such predefined order. The Omega test <ref> [15, 16] </ref> is an exact data dependence test based on integer linear programming. It is free of assumptions on evaluation order. The Omega test can work with symbolic values, and it can also be used to simplify integer programming problems instead of just deciding them.
Reference: [16] <author> William Pugh. </author> <title> A Practical Algorithm for Exact Array Dependence Analysis. </title> <journal> Communications of the ACM, </journal> <volume> 35(8) </volume> <pages> 102-114, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Uniqueness analysis employs subscript analysis techniques, similar to those used in optimizing and parallelizing conventional language compilers [19]. A significant number of data dependence tests [4, 19, 7] assume a predefined "standard" order of computation [7]. In array comprehensions we do not have such predefined order. The Omega test <ref> [15, 16] </ref> is an exact data dependence test based on integer linear programming. It is free of assumptions on evaluation order. The Omega test can work with symbolic values, and it can also be used to simplify integer programming problems instead of just deciding them.
Reference: [17] <author> Alexander Schrijver. </author> <title> Theory of Linear and Integer Programming. </title> <publisher> John Wiley & Sons, </publisher> <address> New York, New York, </address> <year> 1987. </year>
Reference: [18] <author> Rimi Triolet, Francois Irigoin, and Paul Feautrier. </author> <title> Direct Parallelization of Call Statements. </title> <booktitle> In Proceed ings of the SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 176-185, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Typical methods for testing data dependence in the presence of procedure calls base their analysis on obtaining a summary of the array references of each procedure and then testing for overlap between any of these array elements <ref> [18, 10, 7, 12] </ref>. One problem with these approaches is that except for [7] and [12] the approaches produce an approximate summary of the array references. For our problem we require precise information.
Reference: [19] <author> Hans Zima with Barbara Chapman. </author> <title> Supercompilers for Parallel and Vector Computers. </title> <publisher> ACM Press, </publisher> <address> NY, </address> <year> 1990. </year>
Reference-contexts: Checking for this error introduces run-time inefficiency, which can be avoided by compile time uniqueness analysis. Uniqueness analysis employs subscript analysis techniques, similar to those used in optimizing and parallelizing conventional language compilers <ref> [19] </ref>. A significant number of data dependence tests [4, 19, 7] assume a predefined "standard" order of computation [7]. In array comprehensions we do not have such predefined order. The Omega test [15, 16] is an exact data dependence test based on integer linear programming. <p> Checking for this error introduces run-time inefficiency, which can be avoided by compile time uniqueness analysis. Uniqueness analysis employs subscript analysis techniques, similar to those used in optimizing and parallelizing conventional language compilers [19]. A significant number of data dependence tests <ref> [4, 19, 7] </ref> assume a predefined "standard" order of computation [7]. In array comprehensions we do not have such predefined order. The Omega test [15, 16] is an exact data dependence test based on integer linear programming. It is free of assumptions on evaluation order.
References-found: 19

