URL: http://www.cs.ucsd.edu/users/goguen/ps/subs.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/goguen/pubs/
Root-URL: http://www.cs.ucsd.edu
Title: What is Unification? A Categorical View of Substitution, Equation and Solution  
Author: Joseph A. Goguen 
Address: Menlo Park CA 94025  94305  
Affiliation: Programming Research Group, University of Oxford SRI International,  Center for the Study of Language and Information, Stanford University  
Abstract: From a general perspective, a substitution is a transformation from one space to another, an equation is a pair of such substitutions, and a solution to an equation is a substitution that yields the same value when composed with (i.e., when substituted into) the substitutions that constitute the given equation. In some special cases, solutions are called unifiers. Other examples include Scott domain equations, unification grammars, type inference, and differential equations. The intuition that the composition of substitutions should be associative when defined, and should have identities, motivates a general concept of substitution system based on category theory. Notions of morphism, congruence, and quotient are given for substitution systems, each with the expected properties, and some general cardinality bounds are proved for most general solution sets (which are minimal sets of solutions with the property that any other solution is a substitution instance of one in the set). The notions of equation and solution are also generalized to systems of equations, i.e., to constraint solving, and applied to clarify the notions of "compositionality" and "unification" in linguistic unification grammar. This paper is self-contained as regards category theory, and indeed, could be used as an introductory tutorial on that subject.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Takanori Adachi. </author> <title> Unification in categories. In Toshiaki Kurokawa, editor, Several Aspects of Unification, </title> <type> pages 35-43. ICOT, Technical Report TM-0029, </type> <year> 1984. </year> <month> 29 </month>
Reference-contexts: Siekmann [45] gives this classification for classical term unification modulo equations, and the present discussion lifts it to General Unification Theory; Adachi <ref> [1] </ref> applies similar results in a similar way. A nullary substitution system is given in Section 6.3.4 below. However, most substitution systems of practical interest are not nullary, by the following proposition. <p> Proof: Let Q denote S= in this proof. That the composition defined by (3) is really well-defined follows from (1), and is left to the reader, who should also check that Q has identities. Next, we check that Q has a final object. Since each S <ref> [S; 1] </ref> has just one element, namely !, each S= [S; 1] also has just one element, namely [!] = f!g. Using Proposition 7, it suffices to show that Q has binary products. <p> That the composition defined by (3) is really well-defined follows from (1), and is left to the reader, who should also check that Q has identities. Next, we check that Q has a final object. Since each S <ref> [S; 1] </ref> has just one element, namely !, each S= [S; 1] also has just one element, namely [!] = f!g. Using Proposition 7, it suffices to show that Q has binary products. <p> The end of Section 3 suggested generalizing the notion of equation to a set of morphisms having the same source and the same target. Adachi <ref> [1] </ref> suggests a different generalization: an equation is a pair of morphisms with the same target. <p> This framework also seems general enough to consider the Herbrand style of unification algorithm, which involves manipulating just such sets of equations. Adachi <ref> [1] </ref> also defines a notion of "kite" that generalizes Horn clauses, and gives a resolution algorithm that specializes to a Prolog-like interpreter. The above could be used to simplify this a bit.
Reference: [2] <author> Hassan A it-Kaci. </author> <title> An algebraic semantics approach to the effective resolution of type equations. </title> <journal> Theoretical Computer Science, </journal> <volume> 45 </volume> <pages> 293-351, </pages> <year> 1986. </year>
Reference-contexts: Ait-Kaci <ref> [2] </ref> gives a fixpoint-based approach to solving what he calls "type equations" for the semantics of a language called KBL.
Reference: [3] <author> Jean Benabou. </author> <title> Structures algebriques dans les categories. </title> <editor> Cahiers de Topologie et Geometrie Differentiel, </editor> <volume> 10 </volume> <pages> 1-126, </pages> <year> 1968. </year>
Reference-contexts: Essentially, we will follow the same path as for S ;E in Section 6.3, but using S-indexed families in the base category instead of just sets. (Similar work was done even earlier by Benabou <ref> [3] </ref>.) Let X s 0 ; x s 2 ; : : :g be an infinite set of "variable symbols" for each s 2 S, and let X S be the type system whose objects are S-indexed families fX s j s 2 Sg of subsets X s of X s
Reference: [4] <author> Rod Burstall, David MacQueen, and Donald Sannella. </author> <title> Hope: an experimental applicative language. </title> <booktitle> In Proceedings, First LISP Conference, </booktitle> <volume> volume 1, </volume> <pages> pages 136-143. </pages> <institution> Stanford University, </institution> <year> 1980. </year>
Reference-contexts: This section is devoted to the case of classical terms. 5.1 Terms We first define terms over a given fixed set of function symbols. Terms appear as a basic data structure in many functional and logic programming languages, for example, OBJ [23, 9, 10, 19], Hope <ref> [4] </ref>, and Prolog [6]. An unsorted (or one sorted) signature consists of a set whose elements are called function symbols and a function ff : ! ! assigning an arity to each symbol; 2 is a constant symbol when ff () = 0.
Reference: [5] <author> Alain Colmerauer. </author> <title> Prolog and infinite trees. </title> <editor> In Keith Clark and Sten -Ake Tarnlund, editors, </editor> <booktitle> Logic Programming, </booktitle> <pages> pages 231-251. </pages> <publisher> Academic, </publisher> <year> 1982. </year>
Reference-contexts: Consequently, what this section provides is little more than some sketches and relevant citations; there are probably also bugs. Readers are urged to work out further details. 7.1 Infinite Terms Infinite terms are important in many areas, including logic programming <ref> [5] </ref>, concurrency, and natural language processing [44]; Section 7.5 gives an example involving type inference. Our approach is to generalize the construction of S given in Section 5.3 above in such a way that both finite and infinitary unsorted terms will be special cases.
Reference: [6] <author> Alan Colmerauer, H. Kanoui, and M. van Caneghem. </author> <title> Etude et realisation d'un systeme Prolog. </title> <type> Technical report, </type> <institution> Groupe d'Intelligence Artificielle, U.E.R. de Luminy, Univer-site d'Aix-Marseille II, </institution> <year> 1979. </year>
Reference-contexts: This section is devoted to the case of classical terms. 5.1 Terms We first define terms over a given fixed set of function symbols. Terms appear as a basic data structure in many functional and logic programming languages, for example, OBJ [23, 9, 10, 19], Hope [4], and Prolog <ref> [6] </ref>. An unsorted (or one sorted) signature consists of a set whose elements are called function symbols and a function ff : ! ! assigning an arity to each symbol; 2 is a constant symbol when ff () = 0. Let n be f 2 j ff () = ng.
Reference: [7] <author> Douglas DeGroot and Gary Lindstrom. </author> <title> Logic Programming: Functions, Relations and Equations. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: A more recent approach combines logic and functional programming to extend the Prolog framework with features such as abstract data types, multiple inheritance, generic modules, and both forward and backward chaining; some recent work in this area is collected in <ref> [7] </ref>. For example, [20] describes the Eqlog language, which has a rigorous semantics based upon (order sorted) Horn clause logic with equality. Some still more recent work extends this approach with object-oriented features; for example, see the FOOPS and FOOPlog languages in [21].
Reference: [8] <author> Hans-Dieter Ehrich and Udo Lipeck. </author> <title> Algebraic domain equations. </title> <journal> Theoretical Computer Science, </journal> <volume> 27 </volume> <pages> 167-196, </pages> <year> 1983. </year>
Reference-contexts: However, the details are more complex than you might like, and I personally feel that an approach using a substitution system whose types are Cartesian closed categories would be more satisfactory; one would then take interpretations (algebras) into categories of domains. 7.4 Algebraic Domain Equations Ehrich and Lipeck <ref> [8] </ref> have developed an algebraic analog of Scott's domain equations.
Reference: [9] <author> Kokichi Futatsugi, Joseph Goguen, Jean-Pierre Jouannaud, and Jose Meseguer. </author> <title> Principles of OBJ2. </title> <editor> In Brian Reid, editor, </editor> <booktitle> Proceedings, Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 52-66. </pages> <institution> Association for Computing Machinery, </institution> <year> 1985. </year>
Reference-contexts: This section is devoted to the case of classical terms. 5.1 Terms We first define terms over a given fixed set of function symbols. Terms appear as a basic data structure in many functional and logic programming languages, for example, OBJ <ref> [23, 9, 10, 19] </ref>, Hope [4], and Prolog [6]. An unsorted (or one sorted) signature consists of a set whose elements are called function symbols and a function ff : ! ! assigning an arity to each symbol; 2 is a constant symbol when ff () = 0. <p> order sorted algebra accomplished this goal, but was more complex than necessary. [22] gives a thorough development of basic theory for our current approach, while [34] discuss unification; [47] gives a slightly different approach. [18] gives details about the operational semantics that is the basis for the OBJ2 programming language <ref> [9, 10] </ref>, and [28] does the same for OBJ3. Order sorted unification has interesting applications to knowledge representation with is-a hierarchies, and to polymorphic type inference where there are subtypes. Three essential ideas of order sorted algebra are: 1. Impose a partial ordering on the set S of sorts. 2.
Reference: [10] <author> Kokichi Futatsugi, Joseph Goguen, Jose Meseguer, and Koji Okada. </author> <title> Parameterized programming in OBJ2. </title> <editor> In Robert Balzer, editor, </editor> <booktitle> Proceedings, Ninth International Conference on Software Engineering, </booktitle> <pages> pages 51-60. </pages> <publisher> IEEE Computer Society, </publisher> <month> March </month> <year> 1987. </year>
Reference-contexts: This section is devoted to the case of classical terms. 5.1 Terms We first define terms over a given fixed set of function symbols. Terms appear as a basic data structure in many functional and logic programming languages, for example, OBJ <ref> [23, 9, 10, 19] </ref>, Hope [4], and Prolog [6]. An unsorted (or one sorted) signature consists of a set whose elements are called function symbols and a function ff : ! ! assigning an arity to each symbol; 2 is a constant symbol when ff () = 0. <p> order sorted algebra accomplished this goal, but was more complex than necessary. [22] gives a thorough development of basic theory for our current approach, while [34] discuss unification; [47] gives a slightly different approach. [18] gives details about the operational semantics that is the basis for the OBJ2 programming language <ref> [9, 10] </ref>, and [28] does the same for OBJ3. Order sorted unification has interesting applications to knowledge representation with is-a hierarchies, and to polymorphic type inference where there are subtypes. Three essential ideas of order sorted algebra are: 1. Impose a partial ordering on the set S of sorts. 2.
Reference: [11] <editor> Herve Gallaire and Jack Minker. </editor> <booktitle> Logic and Data Bases. </booktitle> <publisher> Plenum, </publisher> <year> 1978. </year>
Reference-contexts: exploring even more general notions of type inference. 7.6 Database Query and Logical Programming Languages There is a rather large body of work showing how unification, as embodied in Prolog and related languages, can be made the basic inference mechanism for sophisticated database query systems; for example, the papers in <ref> [11] </ref> represent an early stage in this evolution. I believe that it is very important to have a precise semantic foundation for any such endeavor.
Reference: [12] <author> Joseph Goguen. </author> <title> Mathematical representation of hierarchically organized systems. </title> <editor> In E. Attinger, editor, </editor> <booktitle> Global Systems Dynamics, </booktitle> <pages> pages 112-128. </pages> <editor> S. Karger, </editor> <year> 1971. </year>
Reference-contexts: It is also interesting to note that this approach is consistent with the "General Systems Theory" doctrine that the limit of a diagram solves an arbitrary system of constraints <ref> [12, 13, 16] </ref>.
Reference: [13] <author> Joseph Goguen. </author> <title> Categorical foundations for general systems theory. </title> <editor> In F. Pichler and R. Trappl, editors, </editor> <booktitle> Advances in Cybernetics and Systems Research, </booktitle> <pages> pages 121-130. </pages> <publisher> Transcripta Books, </publisher> <year> 1973. </year>
Reference-contexts: It is also interesting to note that this approach is consistent with the "General Systems Theory" doctrine that the limit of a diagram solves an arbitrary system of constraints <ref> [12, 13, 16] </ref>.
Reference: [14] <author> Joseph Goguen. </author> <title> Semantics of computation. </title> <editor> In Ernest G. Manes, editor, </editor> <booktitle> Proceedings, First International Symposium on Category Theory Applied to Computation and Control, </booktitle> <pages> pages 234-249. </pages> <institution> University of Massachusetts at Amherst, </institution> <year> 1974. </year> <booktitle> Also in Lecture Notes in Computer Science, </booktitle> <volume> Volume 25, </volume> <publisher> Springer, </publisher> <year> 1975, </year> <pages> pages 151-163. </pages>
Reference-contexts: the exact sense of compositionality involved is more general sense than that involved (for example) in Montague grammar [36], where meaning is compositional in the sense that it is given by the unique homomorphism from an initial algebra, i.e., it is given by "initial algebra semantics" in the sense of <ref> [14, 25] </ref> (see [50] for a general discussion of the relation between initial algebra semantics and compositionality in linguistics).
Reference: [15] <author> Joseph Goguen. </author> <title> Order sorted algebra. </title> <type> Technical Report 14, </type> <institution> UCLA Computer Science Department, </institution> <year> 1978. </year> <title> Semantics and Theory of Computation Series. </title> <type> 30 </type>
Reference-contexts: Order sorted algebra was created in 1978 <ref> [15] </ref> to solve an outstanding problem in algebraic specification: it is difficult to deal with exceptions and partially defined functions using many sorted algebra; the difficulties are spelled out in some detail in [24].
Reference: [16] <author> Joseph Goguen. </author> <title> Sheaf semantics for concurrent interacting objects. </title> <note> Mathematical Structures in Computer Science, to appear 1991. Given as lecture at U.K.-Japan Symposium on Concurrency, Oxford, September 1989; draft in Report CSLI-91-155, </note> <institution> Center for the Study of Language and Information, Stanford University, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: It is also interesting to note that this approach is consistent with the "General Systems Theory" doctrine that the limit of a diagram solves an arbitrary system of constraints <ref> [12, 13, 16] </ref>.
Reference: [17] <author> Joseph Goguen and Rod Burstall. </author> <title> Some fundamental algebraic tools for the semantics of computation, part 1: Comma categories, colimits, signatures and theories. </title> <journal> Theoretical Computer Science, </journal> <volume> 31(2) </volume> <pages> 175-209, </pages> <year> 1984. </year>
Reference-contexts: Moreover, these categories are cocomplete, i.e., Proposition 25 The categories SUBS B of substitution systems have all coproducts and coequalizers. 2 This follows by general nonsense, using the fact that the categories in question are comma categories (see [29] or <ref> [17] </ref> for this material; [17] also gives some computer science examples). <p> Moreover, these categories are cocomplete, i.e., Proposition 25 The categories SUBS B of substitution systems have all coproducts and coequalizers. 2 This follows by general nonsense, using the fact that the categories in question are comma categories (see [29] or <ref> [17] </ref> for this material; [17] also gives some computer science examples). The identity functor B ! B is of course initial in SUBS B . 21 It is worth noticing that substitution systems could equally well have been developed in a dual manner, as categories with finite coproducts and an initial object.
Reference: [18] <author> Joseph Goguen, Jean-Pierre Jouannaud, and Jose Meseguer. </author> <title> Operational semantics of order-sorted algebra. </title> <editor> In W. Brauer, editor, </editor> <booktitle> Proceedings, 1985 International Conference on Automata, Languages and Programming. Springer, 1985. Lecture Notes in Computer Science, </booktitle> <volume> Volume 194. </volume>
Reference-contexts: The 1978 approach to order sorted algebra accomplished this goal, but was more complex than necessary. [22] gives a thorough development of basic theory for our current approach, while [34] discuss unification; [47] gives a slightly different approach. <ref> [18] </ref> gives details about the operational semantics that is the basis for the OBJ2 programming language [9, 10], and [28] does the same for OBJ3. Order sorted unification has interesting applications to knowledge representation with is-a hierarchies, and to polymorphic type inference where there are subtypes.
Reference: [19] <author> Joseph Goguen, Claude Kirchner, HeleneKirchner, Aristide Megrelis, and Jose Mese-guer. </author> <title> An introduction to OBJ3. </title> <editor> In Jean-Pierre Jouannaud and Stephane Kaplan, editors, </editor> <booktitle> Proceedings, Conference on Conditional Term Rewriting, </booktitle> <pages> pages 258-263. </pages> <publisher> Springer, </publisher> <year> 1988. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 308. </volume>
Reference-contexts: This section is devoted to the case of classical terms. 5.1 Terms We first define terms over a given fixed set of function symbols. Terms appear as a basic data structure in many functional and logic programming languages, for example, OBJ <ref> [23, 9, 10, 19] </ref>, Hope [4], and Prolog [6]. An unsorted (or one sorted) signature consists of a set whose elements are called function symbols and a function ff : ! ! assigning an arity to each symbol; 2 is a constant symbol when ff () = 0.
Reference: [20] <author> Joseph Goguen and Jose Meseguer. </author> <title> Eqlog: Equality, types, and generic modules for logic programming. </title> <editor> In Douglas DeGroot and Gary Lindstrom, editors, </editor> <booktitle> Logic Programming: Functions, Relations and Equations, </booktitle> <pages> pages 295-363. </pages> <publisher> Prentice-Hall, </publisher> <year> 1986. </year> <title> An earlier version appears in Journal of Logic Programming, </title> <journal> Volume 1, </journal> <volume> Number 2, </volume> <pages> pages 179-210, </pages> <month> September </month> <year> 1984. </year>
Reference-contexts: A more recent approach combines logic and functional programming to extend the Prolog framework with features such as abstract data types, multiple inheritance, generic modules, and both forward and backward chaining; some recent work in this area is collected in [7]. For example, <ref> [20] </ref> describes the Eqlog language, which has a rigorous semantics based upon (order sorted) Horn clause logic with equality. Some still more recent work extends this approach with object-oriented features; for example, see the FOOPS and FOOPlog languages in [21]. <p> Such structures have nodes (or slots) that may contain "logical variables" (in the sense of Prolog, or more exactly, of Eqlog <ref> [20] </ref>) that can unify with fragments of other structures to represent complex relationships; moreover, cyclic graphs represent what amount to infinite structures. Order sorted algebra is useful in this context, providing so-called partiality, the possibility that further record fields can be added later.
Reference: [21] <author> Joseph Goguen and Jose Meseguer. </author> <title> Unifying functional, object-oriented and relational programming, with logical semantics. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477. </pages> <publisher> MIT, </publisher> <year> 1987. </year> <journal> Preliminary version in SIGPLAN Notices, </journal> <volume> Volume 21, Number 10, </volume> <pages> pages 153-162, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: For example, [20] describes the Eqlog language, which has a rigorous semantics based upon (order sorted) Horn clause logic with equality. Some still more recent work extends this approach with object-oriented features; for example, see the FOOPS and FOOPlog languages in <ref> [21] </ref>.
Reference: [22] <author> Joseph Goguen and Jose Meseguer. </author> <title> Order-sorted algebra I: Equational deduction for multiple inheritance, overloading, exceptions and partial operations. </title> <type> Technical Report SRI-CSL-89-10, </type> <institution> SRI International, Computer Science Lab, </institution> <month> July </month> <year> 1989. </year> <note> Given as lecture at Seminar on Types, Carnegie-Mellon University, June 1983; many draft versions exist. </note>
Reference-contexts: The 1978 approach to order sorted algebra accomplished this goal, but was more complex than necessary. <ref> [22] </ref> gives a thorough development of basic theory for our current approach, while [34] discuss unification; [47] gives a slightly different approach. [18] gives details about the operational semantics that is the basis for the OBJ2 programming language [9, 10], and [28] does the same for OBJ3. <p> Believe it or not, the exposition given in Section 6.6 goes through for this generalization without any change at all, except that signatures must satisfy a technical condition called regularity <ref> [22] </ref> to insure that terms always have a well-defined least parse: given w 0 w and 2 w;s there must be some w 2 S fl and s 2 S such that 2 w;s and w 0 w such that 2 w 0 ;s 0 and w 0 w 0 implies <p> Additional technical conditions are needed for some results, for example, that every connected component of S has a maximum element <ref> [22, 34] </ref>.
Reference: [23] <author> Joseph Goguen and Joseph Tardo. </author> <title> An introduction to OBJ: A language for writing and testing software specifications. </title> <editor> In Marvin Zelkowitz, editor, </editor> <booktitle> Specification of Reliable Software, </booktitle> <pages> pages 170-189. </pages> <publisher> IEEE, </publisher> <year> 1979. </year> <title> Reprinted in Software Specification Techniques, </title> <editor> Nehan Gehani and Andrew McGettrick, editors, </editor> <publisher> Addison-Wesley, </publisher> <year> 1985, </year> <pages> pages 391-420. </pages>
Reference-contexts: This section is devoted to the case of classical terms. 5.1 Terms We first define terms over a given fixed set of function symbols. Terms appear as a basic data structure in many functional and logic programming languages, for example, OBJ <ref> [23, 9, 10, 19] </ref>, Hope [4], and Prolog [6]. An unsorted (or one sorted) signature consists of a set whose elements are called function symbols and a function ff : ! ! assigning an arity to each symbol; 2 is a constant symbol when ff () = 0.
Reference: [24] <author> Joseph Goguen, James Thatcher, and Eric Wagner. </author> <title> An initial algebra approach to the specification, correctness and implementation of abstract data types. </title> <type> Technical Report RC 6487, </type> <institution> IBM T.J. Watson Research Center, </institution> <month> October </month> <year> 1976. </year> <title> In Current Trends in Programming Methodology, IV, </title> <editor> Raymond Yeh, editor, </editor> <publisher> Prentice-Hall, </publisher> <year> 1978, </year> <pages> pages 80-149. </pages>
Reference-contexts: Order sorted algebra was created in 1978 [15] to solve an outstanding problem in algebraic specification: it is difficult to deal with exceptions and partially defined functions using many sorted algebra; the difficulties are spelled out in some detail in <ref> [24] </ref>.
Reference: [25] <author> Joseph Goguen, James Thatcher, Eric Wagner, and Jesse Wright. </author> <title> Initial algebra semantics and continuous algebras. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 31 24(1) </volume> <pages> 68-95, </pages> <month> January </month> <year> 1977. </year> <title> An early version is "Initial Algebra Semantics", with James Thatcher, </title> <institution> IBM T.J. Watson Research Center Report RC 4865, </institution> <month> May </month> <year> 1974. </year>
Reference-contexts: In fact, S A is S if we take A to be the category of -algebras. But if we take A to be the category of continuous algebras <ref> [25] </ref> (or rational algebras, or some other variant), we will get various kinds of infinite terms as morphisms. If we want to avoid uncountable sets of variables, we can restrict to the full subcategory whose objects are just the subsets of X ! . <p> the exact sense of compositionality involved is more general sense than that involved (for example) in Montague grammar [36], where meaning is compositional in the sense that it is given by the unique homomorphism from an initial algebra, i.e., it is given by "initial algebra semantics" in the sense of <ref> [14, 25] </ref> (see [50] for a general discussion of the relation between initial algebra semantics and compositionality in linguistics).
Reference: [26] <author> Robert Goldblatt. </author> <title> Topoi, the Categorial Analysis of Logic. </title> <publisher> North-Holland, </publisher> <year> 1979. </year>
Reference-contexts: introduction to category theory is Mac Lane [29], while Goldblatt <ref> [26] </ref> provides a gentler approach that includes topoi; neither book discusses Lawvere theories, but (for example) Schubert [42] does. The only prerequisites for this paper are some elementary set theory and an interest in its subject matter. <p> Topoi, which were introduced by Lawvere and Tierney, are Cartesian closed categories with additional structure that captures set-like structures that arise in geometry, algebra and logic, thus providing a surprising unification of many areas of mathematics; <ref> [26] </ref> provides an introduction to these topics, and of course, we now know what it would mean to solve equations in topoi. 8 Summary This paper develops a very general approach to the solution of equations, starting from the simple example of polynomials with integer coefficients, and gradually working toward a
Reference: [27] <author> Jacques Herbrand. </author> <title> Recherches sur la theorie de la demonstration. </title> <institution> Travaux de la Societe des Sciences et des Lettres de Varsovie, Classe III, </institution> <month> 33(128), </month> <year> 1930. </year>
Reference-contexts: This material can be considered the beginnings of a General Unification Theory. Many sorted algebra and order sorted algebra are also considered. 6.1 Classical Term Unification Although term unification goes back at least 6 to Herbrand's 1930 thesis <ref> [27] </ref>, it rose to its present importance in computer science because of the close connections with mechanical theorem proving developed by Alan Robinson [39] and systematically exploited in so-called "logic" programming (for example, see [32]).
Reference: [28] <author> Claude Kirchner, HeleneKirchner, and Jose Meseguer. </author> <title> Operational semantics of OBJ3. </title> <booktitle> In Proceedings, 9th International Conference on Automata, Languages and Programming. Springer, 1988. Lecture Notes in Computer Science, </booktitle> <volume> Volume 241. </volume>
Reference-contexts: accomplished this goal, but was more complex than necessary. [22] gives a thorough development of basic theory for our current approach, while [34] discuss unification; [47] gives a slightly different approach. [18] gives details about the operational semantics that is the basis for the OBJ2 programming language [9, 10], and <ref> [28] </ref> does the same for OBJ3. Order sorted unification has interesting applications to knowledge representation with is-a hierarchies, and to polymorphic type inference where there are subtypes. Three essential ideas of order sorted algebra are: 1. Impose a partial ordering on the set S of sorts. 2.
Reference: [29] <author> Saunders Mac Lane. </author> <title> Categories for the Working Mathematician. </title> <publisher> Springer, </publisher> <year> 1971. </year>
Reference-contexts: introduction to category theory is Mac Lane <ref> [29] </ref>, while Goldblatt [26] provides a gentler approach that includes topoi; neither book discusses Lawvere theories, but (for example) Schubert [42] does. The only prerequisites for this paper are some elementary set theory and an interest in its subject matter. <p> Then a solution set for an equation hf; gi is a flooring in SOL (f; g), a most general solution set is a minimal flooring in SOL (f; g), and a final solution set is a uniquely minimal flooring in SOL (f; g). 2 The terminology of Mac Lane <ref> [29] </ref> would say weak final set instead of flooring. Lemma 15 A flooring F is minimal iff whenever there is a morphism F ! F 0 in C for F; F 0 2 F , then F = F 0 . <p> Lawvere's original formulation is perhaps less intuitive but more elegant: substitution systems with base type system N . But the choice of base system is inessential, since any substitution system with base X has an equivalent substitution system with base N (Mac Lane <ref> [29] </ref>, page 91 gives the precise definition of equivalence for categories); moreover, this system is unique up to isomorphism. <p> In particular, SUBS N is the category LAW of Lawvere theories. Moreover, these categories are cocomplete, i.e., Proposition 25 The categories SUBS B of substitution systems have all coproducts and coequalizers. 2 This follows by general nonsense, using the fact that the categories in question are comma categories (see <ref> [29] </ref> or [17] for this material; [17] also gives some computer science examples). <p> This gives a category SOL (D) of solutions of D, and a most general solution is a final object in it. These notions of solution and most general solution are actually identical with the usual notions of cone over a diagram D and limit cone of D; see <ref> [29] </ref>. Continuing along this line, a solution set for a diagram D is a flooring in SOL (D), i.e., a set F of solutions of D such that for any solution G of D, there is some F 2 F with a morphism G ! F . <p> The above could be used to simplify this a bit. It is well known in category theory that an arbitrary limit problem can be reduced to an equalizer problem, by first taking suitable products; for example, see <ref> [29] </ref>, page 109. This implies that the generalization of equation and solution developed above adds no expressive power, so long as the appropriate products can be formed in C. 7.8 Unification Grammars So-called "unification grammar" formalisms have recently become important in linguistics.
Reference: [30] <author> Jean-Louis Lassez, Michael Maher, and Kimbal Marriott. </author> <title> Unification revisited. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 587-625. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: Traditional syntactic approaches define a substitution to be something like a finite partial function from an infinite set of variables to the set of all terms on those variables; <ref> [30] </ref> gives a nice technical and historical survey of such approaches, also pointing out some of their difficulties. Our discussion above shows that algebra can greatly ease proofs about substitution; for example, it is simple to prove associativity by exploiting the freeness of term algebras (see Figure 6). <p> Moreover, many technical annoyances about "renaming away" variables, etc., disappear by making source and target variable sets explicit. Finally, many issues are clarified, such as most general unifiers and the sense in which they are unique (again, see <ref> [30] </ref> for some history and discussion of the problem). 6 What is Unification? This section contains the technical core of the paper. We first consider classical term unification, which is the inspiration for the whole subject.
Reference: [31] <author> F. William Lawvere. </author> <title> Functorial semantics of algebraic theories. </title> <booktitle> Proceedings, National Academy of Sciences, U.S.A., </booktitle> <volume> 50 </volume> <pages> 869-872, </pages> <year> 1963. </year> <title> Summary of Ph.D. </title> <type> Thesis, </type> <institution> Columbia University. </institution>
Reference-contexts: Theorem 23 Any substitution system with base X is isomorphic to some S ;E . 2 This is one of the main results about Lawvere theories; it is not trivial <ref> [31, 42] </ref>. 6.5 Categories and Algebras of Substitution Systems Actually, our definition of substitution system is not quite right, since the category of substitution systems with a given base type system does not have all coequalizers; the correct definition generalizes the inclusion of the base type system to a finite product
Reference: [32] <author> John Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer, </publisher> <year> 1984. </year>
Reference-contexts: 6.1 Classical Term Unification Although term unification goes back at least 6 to Herbrand's 1930 thesis [27], it rose to its present importance in computer science because of the close connections with mechanical theorem proving developed by Alan Robinson [39] and systematically exploited in so-called "logic" programming (for example, see <ref> [32] </ref>).
Reference: [33] <author> Ernest Manes. </author> <title> Algebraic Theories. </title> <publisher> Springer, </publisher> <year> 1976. </year> <title> Graduate Texts in Mathematics, </title> <booktitle> Volume 26. </booktitle>
Reference-contexts: Constructions of this kind have been rather thoroughly explored in category theory; for example, see <ref> [33] </ref>. 24 7.2 Fixpoint Equations Fixpoint equations are used in computer science to define many different structures, and least fixpoints are particularly used, because their existence can often be guaranteed by the well-known Tarski fixpoint theorem.
Reference: [34] <author> Jose Meseguer, Joseph Goguen, and Gert Smolka. </author> <title> Order-sorted unification. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 8 </volume> <pages> 383-413, </pages> <year> 1989. </year> <note> Preliminary version appeared as Report CSLI-87-86, </note> <institution> Center for the Study of Language and Information, Stanford University, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: Although most general solutions are not always final, there is always a closely related final solution in S . Following <ref> [34] </ref>, call a substitution f : X ! Y in S sober iff X = S y2Y vars (f y ) where f = ff y j y 2 Y g. Then, Proposition 12 A substitution h : X ! Y in S is monic iff it is sober. <p> A very nice categorical formulation of a unification algorithm is given by Rydeheard and Burstall [40], who also sketch a largely categorical proof of its correctness, and explain the obstacles that they found to a purely categorical proof. Meseguer, Goguen and Smolka <ref> [34] </ref> develop general categorical results about unification for application to the order sorted case. The results in this and the next subsection somewhat improve those, but unfortunately are still not quite sufficient to prove the classical Herbrand-Robinson Theorem. <p> I realized that most general unifiers can be seen as equalizers in 1972, but have only recently appreciated what could be done with the viewpoint implicit in this observation; this mostly arose from working on <ref> [34] </ref>, and from reading [40] and [45]. The usual definitions of unifier are (in my view) much too syntactic, since they depend on a notion of substitution that is too syntactic, e.g., an endo-function on the set of all terms in all variables, as in Schmidt-Schauss [41]. <p> For example, Walther [51] showed that most general unifiers only exist in order sorted algebra when the subsort graph is a forest; however, this result only holds for his notion of unifier, and is perhaps best seen as demonstrating the inadequacy of that notion; see <ref> [34] </ref> for further discussion of this point. <p> Such examples require a more general notion of most general solution. In keeping with our whole viewpoint and development, it is convenient to do this by generalizing the notion of final object. This material, which extends and clarifies aspects of <ref> [34] </ref>, is somewhat more difficult than what we have seen so far, and some readers may prefer to skip it the first time through. <p> The 1978 approach to order sorted algebra accomplished this goal, but was more complex than necessary. [22] gives a thorough development of basic theory for our current approach, while <ref> [34] </ref> discuss unification; [47] gives a slightly different approach. [18] gives details about the operational semantics that is the basis for the OBJ2 programming language [9, 10], and [28] does the same for OBJ3. <p> Additional technical conditions are needed for some results, for example, that every connected component of S has a maximum element <ref> [22, 34] </ref>. <p> Additional technical conditions are needed for some results, for example, that every connected component of S has a maximum element [22, 34]. In particular, we can have unification for order sorted algebra modulo equations. <ref> [34] </ref> shows that under some simple syntactic conditions, S is unitary and has a linear unification algorithm. 10 Viewing a signature as a family rather than as an arity function ff : ! S fl fi S has the advantage of allowing overloading of function symbols, since the same symbol can
Reference: [35] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17(3) </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Of course, we do not get all the expressive power of Scott domain equations, because there are no infinitary structures. However, it is possible to carry out the same constructions with S-sorted infinitary substitution systems. 7.5 Polymorphic Type Inference Milner's lovely paper on type polymorphism <ref> [35] </ref> shows how to infer the types of expressions in certain higher order programming languages by using classical term unification to solve systems of type equations; the key insight is to identify polymorphic types with ordinary first order terms that contain type variables. <p> This very general technique for viewing systems of inequations as systems of equations means that the techniques developed earlier in this paper can be applied to solving rather general systems of constraints. <ref> [35] </ref> also excludes types like Stream (ff), as defined by Stream (ff) = cons (ff; Stream (ff)), that (in some sense) are infinite.
Reference: [36] <author> Richard Montague. </author> <title> Formal Philosophy: Selected Papers of Richard Montague. </title> <publisher> Yale, </publisher> <year> 1974. </year> <title> Edited and with an introduction by Richard Thomason. </title>
Reference-contexts: This process is compositional, since the meaning of the whole is composed from the 28 meanings of the parts, but the exact sense of compositionality involved is more general sense than that involved (for example) in Montague grammar <ref> [36] </ref>, where meaning is compositional in the sense that it is given by the unique homomorphism from an initial algebra, i.e., it is given by "initial algebra semantics" in the sense of [14, 25] (see [50] for a general discussion of the relation between initial algebra semantics and compositionality in linguistics).
Reference: [37] <author> Kuniaki Mukai. </author> <title> Unification over complex indeterminates in Prolog. </title> <type> Technical Report TR-113, </type> <institution> ICOT, </institution> <year> 1985. </year>
Reference-contexts: To avoid commitment to any particular formalism, let us just assume that we are given a free meaning algebra M (X) for each set X of parameters; more general types than sets can also be used. Plausible choices for M are given in [46] and <ref> [37] </ref>, and others have been hinted at in this paper: We can now construct a substitution system whose objects are the parameter types, and whose morphisms are the (parameterized) meanings, by using the recipe of Section 7.1; let us denote this category M.
Reference: [38] <author> Gordon Plotkin. </author> <title> Building-in equational theories. </title> <journal> Machine Intelligence, </journal> <volume> 7 </volume> <pages> 73-90, </pages> <month> Novem-ber </month> <year> 1972. </year>
Reference-contexts: The next few subsections give examples of this construction. 6.3.1 Associative Unification This example assumes a signature containing a binary function symbol, say fl, satisfying the associative equation, x fl (y fl z) = (x fl y) fl z , where we have used infix notation for clarity. Plotkin <ref> [38] </ref> shows that this substitution system theory is infinitary, i.e., all solvable equations have a most general solution set, but some solvable equation has an infinite most general solution set. <p> if also has a binary function symbol f , then the two terms x fl f (a; b) have the following infinite most general solution set, ff (a; b) ) x; a ) yg ff (a; b) fl (f (a; b) fl f (a; b)) ) x; a ) yg <ref> [38] </ref> also gives a unification algorithm for this case. 19 6.3.2 AC Unification This case assumes that contains a binary function symbol fl satisfying not only the associative equation, but also the commutative equation, x fl y = y fl x .
Reference: [39] <author> J. Alan Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 12 </volume> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: Many sorted algebra and order sorted algebra are also considered. 6.1 Classical Term Unification Although term unification goes back at least 6 to Herbrand's 1930 thesis [27], it rose to its present importance in computer science because of the close connections with mechanical theorem proving developed by Alan Robinson <ref> [39] </ref> and systematically exploited in so-called "logic" programming (for example, see [32]).
Reference: [40] <author> David Rydeheard and Rod Burstall. </author> <title> Computational Category Theory. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: A very nice categorical formulation of a unification algorithm is given by Rydeheard and Burstall <ref> [40] </ref>, who also sketch a largely categorical proof of its correctness, and explain the obstacles that they found to a purely categorical proof. Meseguer, Goguen and Smolka [34] develop general categorical results about unification for application to the order sorted case. <p> I realized that most general unifiers can be seen as equalizers in 1972, but have only recently appreciated what could be done with the viewpoint implicit in this observation; this mostly arose from working on [34], and from reading <ref> [40] </ref> and [45]. The usual definitions of unifier are (in my view) much too syntactic, since they depend on a notion of substitution that is too syntactic, e.g., an endo-function on the set of all terms in all variables, as in Schmidt-Schauss [41].
Reference: [41] <author> Manfred Schmidt-Schauss. </author> <title> Unification in many-sorted equational theories. </title> <booktitle> In Proceed--ings, 8th International Conference on Automated Deduction, </booktitle> <pages> pages 538-552. </pages> <publisher> Springer, </publisher> <year> 1986. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 230. </volume>
Reference-contexts: The usual definitions of unifier are (in my view) much too syntactic, since they depend on a notion of substitution that is too syntactic, e.g., an endo-function on the set of all terms in all variables, as in Schmidt-Schauss <ref> [41] </ref>. Taking too syntactic a view of substitution can also give misleading results.
Reference: [42] <author> Horst Schubert. </author> <title> Categories. </title> <publisher> Springer, </publisher> <year> 1972. </year>
Reference-contexts: introduction to category theory is Mac Lane [29], while Goldblatt [26] provides a gentler approach that includes topoi; neither book discusses Lawvere theories, but (for example) Schubert <ref> [42] </ref> does. The only prerequisites for this paper are some elementary set theory and an interest in its subject matter. I thank Timothy Fernando and Peter Rathmann for their comments on this paper, and Dr. <p> Theorem 23 Any substitution system with base X is isomorphic to some S ;E . 2 This is one of the main results about Lawvere theories; it is not trivial <ref> [31, 42] </ref>. 6.5 Categories and Algebras of Substitution Systems Actually, our definition of substitution system is not quite right, since the category of substitution systems with a given base type system does not have all coequalizers; the correct definition generalizes the inclusion of the base type system to a finite product
Reference: [43] <author> Dana Scott. </author> <title> Lattice theory, data types and semantics. </title> <editor> In Randall Rustin, editor, </editor> <booktitle> Formal Semantics of Algorithmic Languages, </booktitle> <pages> pages 65-106. </pages> <publisher> Prentice Hall, </publisher> <year> 1972. </year>
Reference-contexts: by some elegant later work of Smolka and Ait-Kaci [46], reducing what they call "feature unification" to a kind of order sorted unification. 7.3 Scott Domain Equations The so-called "domain equations" introduced by Scott for the Scott-Strachey "denotational" model-oriented semantics are an important technique in the semantics of programming languages <ref> [43] </ref>. Smyth and Plotkin [48] have developed an attractive categorical generalization of the fixpoint approach and shown that it encompasses Scott's approach, perhaps even with some advantages.
Reference: [44] <author> Stuart Shieber. </author> <title> An Introduction to Unification-Based Approaches to Grammar. Center for the Study of Language and Information, </title> <year> 1986. </year>
Reference-contexts: Consequently, what this section provides is little more than some sketches and relevant citations; there are probably also bugs. Readers are urged to work out further details. 7.1 Infinite Terms Infinite terms are important in many areas, including logic programming [5], concurrency, and natural language processing <ref> [44] </ref>; Section 7.5 gives an example involving type inference. Our approach is to generalize the construction of S given in Section 5.3 above in such a way that both finite and infinitary unsorted terms will be special cases. <p> In these formalisms, a "meaning" is some kind of parameterized record structure, probably with sharing (i.e., a graph rather than a tree), and possibly with cycles; see <ref> [44] </ref> for a general overview. Of course, these structures are nothing like "meanings" in the sense that human beings experience meanings, or even in the sense that sentences in formal logic have meanings in models; they are purely syntactic, without any blood or any given denotation.
Reference: [45] <author> Jorg Siekmann. </author> <title> Unification theory. </title> <journal> In Journal of Symbolic Computation, </journal> <year> 1988. </year> <title> Preliminary Version in Proceedings, </title> <booktitle> European Conference on Artificial Intelligence, </booktitle> <address> Brighton, </address> <year> 1986. </year>
Reference-contexts: Using the framework of Section 5, let us define a most general unifier of two given terms f; g that only involve variables in X X ! to be a most general solution of the 6 According to <ref> [45] </ref>, suggestions can also be found in the notebooks of Emil Post. 14 equation f; g : X ! fx 0 g. Although most general solutions are not always final, there is always a closely related final solution in S . <p> I realized that most general unifiers can be seen as equalizers in 1972, but have only recently appreciated what could be done with the viewpoint implicit in this observation; this mostly arose from working on [34], and from reading [40] and <ref> [45] </ref>. The usual definitions of unifier are (in my view) much too syntactic, since they depend on a notion of substitution that is too syntactic, e.g., an endo-function on the set of all terms in all variables, as in Schmidt-Schauss [41]. <p> Siekmann <ref> [45] </ref> gives this classification for classical term unification modulo equations, and the present discussion lifts it to General Unification Theory; Adachi [1] applies similar results in a similar way. A nullary substitution system is given in Section 6.3.4 below.
Reference: [46] <author> Gert Smolka and Hassan A it-Kaci. </author> <title> Inheritance hierarchies: Semantics and unification. </title> <type> Technical Report Report AI-057-87, </type> <institution> MCC, </institution> <year> 1987. </year> <note> In Journal of Symbolic Computation, </note> <year> 1988. </year>
Reference-contexts: Ait-Kaci [2] gives a fixpoint-based approach to solving what he calls "type equations" for the semantics of a language called KBL. However, this approach seems a bit awkward since infinitary structures are not really needed, and it has been subsumed by some elegant later work of Smolka and Ait-Kaci <ref> [46] </ref>, reducing what they call "feature unification" to a kind of order sorted unification. 7.3 Scott Domain Equations The so-called "domain equations" introduced by Scott for the Scott-Strachey "denotational" model-oriented semantics are an important technique in the semantics of programming languages [43]. <p> Order sorted algebra is useful in this context, providing so-called partiality, the possibility that further record fields can be added later. These topics will be further explored in forthcoming work with Dr. Jose Meseguer; see also <ref> [46] </ref>. The ideas developed in this paper suffice to explain the meaning of "unification" in unification grammmar formalisms. <p> To avoid commitment to any particular formalism, let us just assume that we are given a free meaning algebra M (X) for each set X of parameters; more general types than sets can also be used. Plausible choices for M are given in <ref> [46] </ref> and [37], and others have been hinted at in this paper: We can now construct a substitution system whose objects are the parameter types, and whose morphisms are the (parameterized) meanings, by using the recipe of Section 7.1; let us denote this category M.
Reference: [47] <author> Gert Smolka, Werner Nutt, Joseph Goguen, and Jose Meseguer. </author> <title> Order-sorted equational computation. </title> <editor> In Maurice Nivat and Hassan A it-Kaci, editors, </editor> <title> Resolution of Equations in Algebraic Structures, Volume 2: Rewriting Techniques, page 299ff. </title> <publisher> Academic, </publisher> <year> 1989. </year> <title> Preliminary version in Proceedings, Colloquium on the Resolution of Equations in Algebraic Structures, </title> <note> held in Lakeway, Texas, May 1987; also appears as SEKI Report SR-87-14, </note> <institution> Universitat Kaiserslautern, </institution> <month> December </month> <year> 1987. </year>
Reference-contexts: The 1978 approach to order sorted algebra accomplished this goal, but was more complex than necessary. [22] gives a thorough development of basic theory for our current approach, while [34] discuss unification; <ref> [47] </ref> gives a slightly different approach. [18] gives details about the operational semantics that is the basis for the OBJ2 programming language [9, 10], and [28] does the same for OBJ3.
Reference: [48] <author> Michael Smyth and Gordon Plotkin. </author> <title> The category-theoretic solution of recursive domain equations. </title> <journal> SIAM Journal of Computation, </journal> <volume> 11 </volume> <pages> 761-783, </pages> <year> 1982. </year> <type> Also Technical Report D.A.I. 60, </type> <institution> University of Edinburgh, Department of Artificial Intelligence, </institution> <month> Decem-ber </month> <year> 1978. </year>
Reference-contexts: Smyth and Plotkin <ref> [48] </ref> have developed an attractive categorical generalization of the fixpoint approach and shown that it encompasses Scott's approach, perhaps even with some advantages. <p> Generalizing Section 7.2, least fixpoints correspond to initial objects in most general solution categories; this works nicely, because CAT has equalizers. The Smyth-Plotkin approach <ref> [48] </ref> uses an attractive generalization of the Tarski theorem, following Wand [52].
Reference: [49] <author> Mark Stickel. </author> <title> A unification algorithm for associative-commutative functions. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 28 </volume> <pages> 423-434, </pages> <year> 1981. </year>
Reference-contexts: This system is finitary, and Stickel <ref> [49] </ref> and others have given unification algorithms for it. 6.3.3 Polynomials Our ongoing polynomial example can now be developed rigorously, by giving a signature and some equations that define polynomials. Here both the signature and the equation set are infinite.
Reference: [50] <author> Peter van Emde Boas and Theo Janssen. </author> <title> The impact of frege's principle of composi-tionality for the semantics of programming and natural languages. </title> <type> Technical Report 79-07, </type> <institution> University of Amsterdam, Department of Mathematics, </institution> <year> 1979. </year>
Reference-contexts: of compositionality involved is more general sense than that involved (for example) in Montague grammar [36], where meaning is compositional in the sense that it is given by the unique homomorphism from an initial algebra, i.e., it is given by "initial algebra semantics" in the sense of [14, 25] (see <ref> [50] </ref> for a general discussion of the relation between initial algebra semantics and compositionality in linguistics). It is also interesting to note that this approach is consistent with the "General Systems Theory" doctrine that the limit of a diagram solves an arbitrary system of constraints [12, 13, 16].
Reference: [51] <author> Christoph Walther. </author> <title> A classification of many-sorted unification theories. </title> <booktitle> In Proceedings, 8th International Conference on Automated Deduction, </booktitle> <pages> pages 525-537. </pages> <publisher> Springer, </publisher> <year> 1986. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 230. </volume>
Reference-contexts: Taking too syntactic a view of substitution can also give misleading results. For example, Walther <ref> [51] </ref> showed that most general unifiers only exist in order sorted algebra when the subsort graph is a forest; however, this result only holds for his notion of unifier, and is perhaps best seen as demonstrating the inadequacy of that notion; see [34] for further discussion of this point.
Reference: [52] <author> Mitchell Wand. </author> <title> On the recursive specification of data types. </title> <editor> In Ernest Manes, editor, </editor> <booktitle> Proceedings, Symposium on Category Theory Applied to Computation and Control, </booktitle> <pages> pages 214-217. </pages> <publisher> Springer, </publisher> <year> 1975. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 25. </volume>
Reference-contexts: Generalizing Section 7.2, least fixpoints correspond to initial objects in most general solution categories; this works nicely, because CAT has equalizers. The Smyth-Plotkin approach [48] uses an attractive generalization of the Tarski theorem, following Wand <ref> [52] </ref>. Let us say a category C is !-continuous iff C has an initial object and every diagram of the form C 0 ! C 1 ! ::: C n ! ::: has an !-colimit in C (that is, an initial cone).
Reference: [53] <author> Kosaku Yosida. </author> <title> Functional Analysis. </title> <publisher> Springer, </publisher> <year> 1968. </year> <note> Second Edition. 33 </note>
Reference-contexts: Also note that ambiguity of meaning can arise naturally in this setting, exactly because unification is not necessarily unitary. 7.9 Differential Equations Standard techniques of functional analysis, such as differential operators on function spaces (e.g., see <ref> [53] </ref>), seem ideally suited for developing an exposition of differential equations within the framework of this paper.
References-found: 53

