URL: http://www2.cs.cornell.edu/faculty/home/jgm/papers/ip-popl.ps
Refering-URL: http://www2.cs.cornell.edu/faculty/home/jgm/home.html
Root-URL: http://www.cs.cornell.edu
Title: Compiling Polymorphism Using Intensional Type Analysis  
Author: Robert Harper Greg Morrisett 
Address: Pittsburgh, PA 15213-3891  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: Traditional techniques for implementing polymorphism use a universal representation for objects of unknown type. Often, this forces a compiler to use universal representations even if the types of objects are known. We examine an alternative approach for compiling polymorphism where types are passed as arguments to polymorphic routines in order to determine the representation of an object. This approach allows monomorphic code to use natural, efficient representations, supports separate compilation of polymorphic definitions and, unlike coercion-based implementations of poly-morphism, natural representations can be used for mutable objects such as refs and arrays. We are particularly interested in the typing properties of an intermediate language that allows run-time type analysis to be coded within the language. This allows us to compile many representation transformations and many language features without adding new primitive operations to the language. In this paper, we provide a core target language where type-analysis operators can be coded within the language and the types of such operators can be accurately tracked. The target language is powerful enough to code a variety of useful features, yet type checking remains decidable. We show how to translate an ML-like language into the target language so that primitive operators can analyze types to produce efficient representations. We demonstrate the power of the "user-level" operators by coding flattened tuples, marshalling, type classes, and a form of type dynamic within the language. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, B. Pierce, and G. Plotkin. </author> <title> Dynamic typing in a statically-typed language. </title> <booktitle> In Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin. </address> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: je ! je fi ) ,! v (trec-fn) ,! !( 1 ; 2 ) typerec 1 of [t:](e i je ! je fi ) ,! v 1 typerec 2 of [t:](e i je ! je fi ) ,! v 2 @ [ 2 =t] (@ [ 1 =t] (e ! <ref> [ 1 ] </ref>[ 2 ]) v 1 ) v 2 ,! v typerec of [t:](e i je ! je fi ) ,! v (trec-pair) ,! fi ( 1 ; 2 ) typerec 1 of [t:](e i je ! je fi ) ,! v 1 typerec 2 of [t:](e i je ! <p> ! je fi ) ,! v (trec-pair) ,! fi ( 1 ; 2 ) typerec 1 of [t:](e i je ! je fi ) ,! v 1 typerec 2 of [t:](e i je ! je fi ) ,! v 2 @ [ 2 =t] (@ [ 1 =t] (e fi <ref> [ 1 ] </ref>[ 2 ]) v 1 ) v 2 ,! v typerec of [t:](e i je ! je fi ) ,! v i where e i = 0 e fi = flt 1 :::flt 2 :::z 1 :T (t 1 ):z 2 :T (t 2 ):hz 1 ; z 2 <p> To simplify the presentation we usually define terms such as zero and sizeof using recursion equations, rather than as a typerec expression. The definitions of zero and sizeof are given in this form as follows: sizeof [Int] = 1 sizeof [fi ( 1 ; 2 )] = sizeof <ref> [ 1 ] </ref> + sizeof [ 2 ] sizeof [!( 1 ; 2 )] = 1 zero [Int] = 0 zero [fi ( 1 ; 2 )] = hzero [ 1 ]; zero [ 2 ]i zero [!( 1 ; 2 )] = x:T ( 1 ):zero [ 2 ] Whenever <p> sizeof are given in this form as follows: sizeof [Int] = 1 sizeof [fi ( 1 ; 2 )] = sizeof <ref> [ 1 ] </ref> + sizeof [ 2 ] sizeof [!( 1 ; 2 )] = 1 zero [Int] = 0 zero [fi ( 1 ; 2 )] = hzero [ 1 ]; zero [ 2 ]i zero [!( 1 ; 2 )] = x:T ( 1 ):zero [ 2 ] Whenever a definition is presented in this form we tacitly assert that it can be formalized using typerec. 2.3 Translating Mini-ML into ML i A compiler from Mini-ML to ML <p> rpc : 8t 1 ; t 2 :::(T (Tran [!(t 1 ; t 2 )])) ! T (Tran [t 1 ]) ! T (Tran [t 2 ]) where Tran is a constructor coded using Typerec as follows: Tran [Int] = Int Tran [!( 1 ; 2 )] = Id [!(Tran <ref> [ 1 ] </ref>; Tran [ 2 ])] Tran [fi ( 1 ; 2 )] = fi (Tran [ 1 ]; Tran [ 2 ]) Tran [Id []] = Id [] The constructor Tran [] maps to a constructor where each arrow is wrapped by an Id constructor. <p> (Tran [t 1 ]) ! T (Tran [t 2 ]) where Tran is a constructor coded using Typerec as follows: Tran [Int] = Int Tran [!( 1 ; 2 )] = Id [!(Tran <ref> [ 1 ] </ref>; Tran [ 2 ])] Tran [fi ( 1 ; 2 )] = fi (Tran [ 1 ]; Tran [ 2 ]) Tran [Id []] = Id [] The constructor Tran [] maps to a constructor where each arrow is wrapped by an Id constructor. Thus, values of type T (Tran []) do not contain functions and are therefore transmissible. <p> The types of these operations can be easily expressed in terms of Tran: M : 8t:::T (t) ! T (Tran [t]) U : 8t:::T (Tran [t]) ! T (t) The operations themselves can be defined as follows using the unofficial syntax of typerec: 3 M [Int] = x:int:x newid <ref> [ 1 ] </ref>[ 2 ] (x:T (Tran [ 1 ]): M [ 2 ](f (U [ 1 ] x))) hM [ 1 ]( 1 x); M [ 2 ]( 2 x)i U [Int] = x:int:x U [!( 1 ; 2 )] = f :T (Id [!(Tran [ 1 ]; Tran [ <p> be easily expressed in terms of Tran: M : 8t:::T (t) ! T (Tran [t]) U : 8t:::T (Tran [t]) ! T (t) The operations themselves can be defined as follows using the unofficial syntax of typerec: 3 M [Int] = x:int:x newid <ref> [ 1 ] </ref>[ 2 ] (x:T (Tran [ 1 ]): M [ 2 ](f (U [ 1 ] x))) hM [ 1 ]( 1 x); M [ 2 ]( 2 x)i U [Int] = x:int:x U [!( 1 ; 2 )] = f :T (Id [!(Tran [ 1 ]; Tran [ 2 ])]): x:T ( 1 ): U <p> : 8t:::T (t) ! T (Tran [t]) U : 8t:::T (Tran [t]) ! T (t) The operations themselves can be defined as follows using the unofficial syntax of typerec: 3 M [Int] = x:int:x newid <ref> [ 1 ] </ref>[ 2 ] (x:T (Tran [ 1 ]): M [ 2 ](f (U [ 1 ] x))) hM [ 1 ]( 1 x); M [ 2 ]( 2 x)i U [Int] = x:int:x U [!( 1 ; 2 )] = f :T (Id [!(Tran [ 1 ]; Tran [ 2 ])]): x:T ( 1 ): U [fi ( 1 ; 2 )] = x:T <p> (Tran [t]) U : 8t:::T (Tran [t]) ! T (t) The operations themselves can be defined as follows using the unofficial syntax of typerec: 3 M [Int] = x:int:x newid <ref> [ 1 ] </ref>[ 2 ] (x:T (Tran [ 1 ]): M [ 2 ](f (U [ 1 ] x))) hM [ 1 ]( 1 x); M [ 2 ]( 2 x)i U [Int] = x:int:x U [!( 1 ; 2 )] = f :T (Id [!(Tran [ 1 ]; Tran [ 2 ])]): x:T ( 1 ): U [fi ( 1 ; 2 )] = x:T (fi (Tran [ 1 ]; <p> [Int] = x:int:x newid <ref> [ 1 ] </ref>[ 2 ] (x:T (Tran [ 1 ]): M [ 2 ](f (U [ 1 ] x))) hM [ 1 ]( 1 x); M [ 2 ]( 2 x)i U [Int] = x:int:x U [!( 1 ; 2 )] = f :T (Id [!(Tran [ 1 ]; Tran [ 2 ])]): x:T ( 1 ): U [fi ( 1 ; 2 )] = x:T (fi (Tran [ 1 ]; Tran [ 2 ])): hU [ 1 ]( 1 x); U [ 2 ]( 2 x)i At arrow types, M converts the function to one that <p> x))) hM <ref> [ 1 ] </ref>( 1 x); M [ 2 ]( 2 x)i U [Int] = x:int:x U [!( 1 ; 2 )] = f :T (Id [!(Tran [ 1 ]; Tran [ 2 ])]): x:T ( 1 ): U [fi ( 1 ; 2 )] = x:T (fi (Tran [ 1 ]; Tran [ 2 ])): hU [ 1 ]( 1 x); U [ 2 ]( 2 x)i At arrow types, M converts the function to one that takes and returns transmissible types and then allocates and associates a new identifier with this function via newid. <p> [ 2 ]( 2 x)i U [Int] = x:int:x U [!( 1 ; 2 )] = f :T (Id [!(Tran <ref> [ 1 ] </ref>; Tran [ 2 ])]): x:T ( 1 ): U [fi ( 1 ; 2 )] = x:T (fi (Tran [ 1 ]; Tran [ 2 ])): hU [ 1 ]( 1 x); U [ 2 ]( 2 x)i At arrow types, M converts the function to one that takes and returns transmissible types and then allocates and associates a new identifier with this function via newid. <p> Definitional equality can be used to determine membership in the class. For example, the class of types that admit equality can be defined using Typerec as follows: Eq :: ! Eq [Bool] = Bool Eq [fi ( 1 ; 2 )] = fi (Eq <ref> [ 1 ] </ref>; Eq [ 2 ]) Eq [!( 1 ; 2 )] = Void Eq [Void] = Void 3 To compute M and U using the official syntax, we have to use a single typerec that returns a pair holding the two functions for that type. <p> The equality method can be coded using typerec as follows, where we assume primitive equality functions for int and bool and omit some type labels for simplicity: eq [Int] = eqint eq [Bool] = eqbool eq [fi ( 1 ; 2 )] = x:y:eq [Eq <ref> [ 1 ] </ref>]( 1 x)( 1 y) and eq [!( 1 ; 2 )] = x:void:y:void:false eq [Void] = x:void:y:void:false It is straightforward to verify that: eq : 8t:::T (Eq [t]) ! T (Eq [t]) ! bool Consequently, eq [] e 1 e 2 can be well typed only if e
Reference: [2] <author> M. Abadi, L. Cardelli, B. Pierce, and G. Plotkin. </author> <title> Dynamic typing in a statically-typed language. </title> <journal> ACM Transactions on Progamming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 237-268, </pages> <month> Apr. </month> <year> 1991. </year> <note> Revised version of [1]. </note>
Reference-contexts: The semantics uses an auxiliary judgment, ,! 0 , (not formally defined here) that determines the normal forms of constructors. During evaluation, we only need to determine normal forms of closed constructors of kind . This amounts to evaluating constructors of the form Typerec (:::) and ( 1 <ref> [ 2 ] </ref>) by orienting the equivalences of Figure 2 to the right and adding the appropriate congruences. The rest of the semantics is standard except for the evaluation of a typerec expression which proceeds as follows: First, the normal form of the constructor argument is determined. <p> The definitions of zero and sizeof are given in this form as follows: sizeof [Int] = 1 sizeof [fi ( 1 ; 2 )] = sizeof [ 1 ] + sizeof <ref> [ 2 ] </ref> sizeof [!( 1 ; 2 )] = 1 zero [Int] = 0 zero [fi ( 1 ; 2 )] = hzero [ 1 ]; zero [ 2 ]i zero [!( 1 ; 2 )] = x:T ( 1 ):zero [ 2 ] Whenever a definition is presented in <p> this form as follows: sizeof [Int] = 1 sizeof [fi ( 1 ; 2 )] = sizeof [ 1 ] + sizeof <ref> [ 2 ] </ref> sizeof [!( 1 ; 2 )] = 1 zero [Int] = 0 zero [fi ( 1 ; 2 )] = hzero [ 1 ]; zero [ 2 ]i zero [!( 1 ; 2 )] = x:T ( 1 ):zero [ 2 ] Whenever a definition is presented in this form we tacitly assert that it can be formalized using typerec. 2.3 Translating Mini-ML into ML i A compiler from Mini-ML to ML i is specified by <p> )] = sizeof [ 1 ] + sizeof <ref> [ 2 ] </ref> sizeof [!( 1 ; 2 )] = 1 zero [Int] = 0 zero [fi ( 1 ; 2 )] = hzero [ 1 ]; zero [ 2 ]i zero [!( 1 ; 2 )] = x:T ( 1 ):zero [ 2 ] Whenever a definition is presented in this form we tacitly assert that it can be formalized using typerec. 2.3 Translating Mini-ML into ML i A compiler from Mini-ML to ML i is specified by a relation ; . e s : t ) e t that carries the <p> ; t 2 :::(T (Tran [!(t 1 ; t 2 )])) ! T (Tran [t 1 ]) ! T (Tran [t 2 ]) where Tran is a constructor coded using Typerec as follows: Tran [Int] = Int Tran [!( 1 ; 2 )] = Id [!(Tran [ 1 ]; Tran <ref> [ 2 ] </ref>)] Tran [fi ( 1 ; 2 )] = fi (Tran [ 1 ]; Tran [ 2 ]) Tran [Id []] = Id [] The constructor Tran [] maps to a constructor where each arrow is wrapped by an Id constructor. <p> ! T (Tran [t 2 ]) where Tran is a constructor coded using Typerec as follows: Tran [Int] = Int Tran [!( 1 ; 2 )] = Id [!(Tran [ 1 ]; Tran <ref> [ 2 ] </ref>)] Tran [fi ( 1 ; 2 )] = fi (Tran [ 1 ]; Tran [ 2 ]) Tran [Id []] = Id [] The constructor Tran [] maps to a constructor where each arrow is wrapped by an Id constructor. Thus, values of type T (Tran []) do not contain functions and are therefore transmissible. <p> terms of Tran: M : 8t:::T (t) ! T (Tran [t]) U : 8t:::T (Tran [t]) ! T (t) The operations themselves can be defined as follows using the unofficial syntax of typerec: 3 M [Int] = x:int:x newid [ 1 ]<ref> [ 2 ] </ref> (x:T (Tran [ 1 ]): M [ 2 ](f (U [ 1 ] x))) hM [ 1 ]( 1 x); M [ 2 ]( 2 x)i U [Int] = x:int:x U [!( 1 ; 2 )] = f :T (Id [!(Tran [ 1 ]; Tran [ 2 ])]): x:T ( 1 ): U [fi ( 1 ; <p> [t]) ! T (t) The operations themselves can be defined as follows using the unofficial syntax of typerec: 3 M [Int] = x:int:x newid [ 1 ]<ref> [ 2 ] </ref> (x:T (Tran [ 1 ]): M [ 2 ](f (U [ 1 ] x))) hM [ 1 ]( 1 x); M [ 2 ]( 2 x)i U [Int] = x:int:x U [!( 1 ; 2 )] = f :T (Id [!(Tran [ 1 ]; Tran [ 2 ])]): x:T ( 1 ): U [fi ( 1 ; 2 )] = x:T (fi (Tran [ 1 ]; Tran [ 2 ])): hU [ <p> [ 1 ]<ref> [ 2 ] </ref> (x:T (Tran [ 1 ]): M [ 2 ](f (U [ 1 ] x))) hM [ 1 ]( 1 x); M [ 2 ]( 2 x)i U [Int] = x:int:x U [!( 1 ; 2 )] = f :T (Id [!(Tran [ 1 ]; Tran [ 2 ])]): x:T ( 1 ): U [fi ( 1 ; 2 )] = x:T (fi (Tran [ 1 ]; Tran [ 2 ])): hU [ 1 ]( 1 x); U [ 2 ]( 2 x)i At arrow types, M converts the function to one that takes and returns transmissible <p> ]( 1 x); M <ref> [ 2 ] </ref>( 2 x)i U [Int] = x:int:x U [!( 1 ; 2 )] = f :T (Id [!(Tran [ 1 ]; Tran [ 2 ])]): x:T ( 1 ): U [fi ( 1 ; 2 )] = x:T (fi (Tran [ 1 ]; Tran [ 2 ])): hU [ 1 ]( 1 x); U [ 2 ]( 2 x)i At arrow types, M converts the function to one that takes and returns transmissible types and then allocates and associates a new identifier with this function via newid. <p> [Int] = x:int:x U [!( 1 ; 2 )] = f :T (Id [!(Tran [ 1 ]; Tran <ref> [ 2 ] </ref>)]): x:T ( 1 ): U [fi ( 1 ; 2 )] = x:T (fi (Tran [ 1 ]; Tran [ 2 ])): hU [ 1 ]( 1 x); U [ 2 ]( 2 x)i At arrow types, M converts the function to one that takes and returns transmissible types and then allocates and associates a new identifier with this function via newid. <p> Definitional equality can be used to determine membership in the class. For example, the class of types that admit equality can be defined using Typerec as follows: Eq :: ! Eq [Bool] = Bool Eq [fi ( 1 ; 2 )] = fi (Eq [ 1 ]; Eq <ref> [ 2 ] </ref>) Eq [!( 1 ; 2 )] = Void Eq [Void] = Void 3 To compute M and U using the official syntax, we have to use a single typerec that returns a pair holding the two functions for that type. <p> However, the function resulting from evaluation of this expression can only be applied to values of type void. Since no such values exist, the function can never be applied. 3.4 Dynamics In the presence of intensional polymorphism a predicative form of the type dynamic <ref> [2] </ref> may be defined to be the existential type 9t:::T (t). <p> An empirical study of the relative performance of the two approaches is currently planned by the second author, and will be reported elsewhere. The combination of intensional polymorphism and existential types [35] raises some interesting questions. On the one hand, the type dynamic <ref> [2] </ref> may be defined in terms of existentials. On the other hand, data abstraction may be violated since a "client" of an abstraction may perform intensional analysis on the abstract type, which is replaced at run-time by the implementation type of the abstraction.
Reference: [3] <author> A. Aiken, E. Wimmers, and T. K. Lakshman. </author> <title> Soft typing with conditional types. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <address> Portland, OR, </address> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: All but the first of these approaches involve copying coercions. Of a broadly similar nature is the work on "soft" type systems <ref> [3, 10, 23, 49, 53] </ref> that seek to improve data representations through global analysis techniques. All of these methods are based on the use of program analysis techniques to reduce the overhead of box and tag manipulation incurred by the standard compilation method for polymorphic languages.
Reference: [4] <author> S. F. Allen, R. L. Constable, D. J. Howe, and W. E. Aitken. </author> <title> The semantics of reflected proof. </title> <booktitle> In Fifth Symposium on Logic in Computer Science, </booktitle> <pages> pages 95-106, </pages> <address> Philadelphia, PA, </address> <month> June </month> <year> 1990. </year> <note> IEEE. </note>
Reference-contexts: In this way parametricity and representation independence can be enforced by restricting the use of type analysis. The idea of intensional analysis of types bears some resemblance to the notion of reflection <ref> [44, 4] </ref> | we may think of type-passing as a "reification" of the meta-level notion of types. It is interesting to speculate that the type theory proposed here is but a special case of a fully reflective type theory.
Reference: [5] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Compiling polymorphism using intensional type analysis enables data representations that are impossible using type-free techniques. Setting aside the additional expressiveness of the present approach, it is interesting to consider the performance of a type-passing implementation of ML as compared to the type-free approach adopted in SML/NJ <ref> [5] </ref>. As pointed out by Tolmach [51], a type-passing implementation need not maintain tag bits on values for the sake of garbage collection. The only remaining use of tag bits in SML/NJ is for polymorphic equality, which can readily be implemented using intensional type analysis.
Reference: [6] <author> G. Blelloch, S. Chatterjee, J. C. Hardwick, J. Sipelstein, and M. Zagha. </author> <title> Implementation of a portable nested data-parallel language. </title> <booktitle> In Proceedings of the Fourth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 102-111, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Since the scope of a let is closed, it is possible to determine all of the instantiations of the polymorphic value at compile time and eliminate all polymorphism through duplication andd specialization. Such an approach is used, for instance, by Blelloch et al. in their NESL compiler <ref> [6] </ref> and more recently by Jones to eliminate Haskell overloading [27]. Furthermore, Jones reports that this approach does not lead to excessive code-blowup. Unfortunately, eliminating all of the polymorphism in a program is not always possible or pratical.
Reference: [7] <author> V. Breazu-Tannen, T. Coquand, C. A. Gunter, and A. Sce-drov. </author> <title> Inheritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 172-221, </pages> <year> 1991. </year>
Reference-contexts: Since the translation depends upon the typing derivation, it is possible to have many different translations of a given expression. However, all of the translation schemes we consider are coherent in the sense that any two typing derivations produce observationally equivalent translations <ref> [7, 26, 20] </ref>. 2 Here, we give a straightforward compiler whose purpose is to make types explicit so that the primitive operations such as pairing and projection can potentially analyze their types at run-time.
Reference: [8] <author> L. Cardelli. </author> <title> Phase distinctions in type theory. </title> <type> Unpublished manuscript. </type>
Reference-contexts: These forms may be thought of as eliminatory forms for the kind at the constructor and term level. (The introductory forms are the constructors of kind ; there are no introductory forms at the term level in order to preserve the phase distinction <ref> [8, 21] </ref>.) At the term level typerec may be thought of as a generalization of typecase that provides for the definition of a term by induction on the structure of a monotype.
Reference: [9] <author> L. Cardelli. </author> <title> Typeful programming. </title> <type> Technical Report 45, </type> <institution> DEC Systems Research Center, </institution> <year> 1989. </year>
Reference-contexts: This prevents us from separately compiling polymorphic libraries or polymorphic definitions entered at a top-level loop. Furthermore, in languages that allow polymorphic values to be "first-class" such as XML [21] and Quest <ref> [9] </ref>, it is impossible to eliminate all polymorphism at compile-time. <p> In particular, termination can no longer be guaranteed, which presents problems not only for optimization but also for type checking. The restriction to predicative polymorphism is sufficient for compiling ML programs. More recent languages such as Quest <ref> [9] </ref> extend the expressive power to admit impred-icative polymorphism, in which quantified types may be 4 However, types are passed independently as data and associated with code. instantiated by quantified types. (Both Girard's [16] and Reynolds's [42] calculi exhibit this kind of polymorphism.) It is natural to consider whether the methods
Reference: [10] <author> R. Cartwright and M. Fagan. </author> <title> Soft typing. </title> <booktitle> In Proc. SIG-PLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 278-292. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: All but the first of these approaches involve copying coercions. Of a broadly similar nature is the work on "soft" type systems <ref> [3, 10, 23, 49, 53] </ref> that seek to improve data representations through global analysis techniques. All of these methods are based on the use of program analysis techniques to reduce the overhead of box and tag manipulation incurred by the standard compilation method for polymorphic languages.
Reference: [11] <author> D. Clement, J. Despeyroux, T. Despeyroux, and G. Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In 1986 ACM Conf. on LISP and Functional Prog., </booktitle> <year> 1986. </year>
Reference-contexts: The source language is based on Mini-ML <ref> [11] </ref>, which captures many of the essential features of the ML core language. <p> The target language, ML i , is an extension of ML , also known as XML [21], a predicative variant of Girard's F ! [16, 17, 42], enriched with primitives for intensional type analysis. 2.1 Source Language: Mini-ML The source language for our translations is a variant of Mini-ML <ref> [11] </ref>.
Reference: [12] <author> R. L. Constable. </author> <title> Intensional analysis of functions and types. </title> <type> Technical Report CSR-118-82, </type> <institution> Computer Science Department, University of Edinburgh, </institution> <month> June </month> <year> 1982. </year>
Reference-contexts: This type theory was refined by Harper, Mitchell, and Moggi [21], and provides the basis for this work. The idea of intensional type analysis exploited here was inspired by the work of Constable <ref> [12, 13] </ref>, from which the term "intensional analysis" is taken. The rules for typerec, and the need for Typerec, are derived from the "universe elimination" rules in NuPRL (described only in unpublished work of Constable).
Reference: [13] <author> R. L. Constable and D. R. Zlatin. </author> <title> The type theory of PL/CV3. </title> <journal> ACM Transactions on Progamming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 72-93, </pages> <month> Jan. </month> <year> 1984. </year>
Reference-contexts: This type theory was refined by Harper, Mitchell, and Moggi [21], and provides the basis for this work. The idea of intensional type analysis exploited here was inspired by the work of Constable <ref> [12, 13] </ref>, from which the term "intensional analysis" is taken. The rules for typerec, and the need for Typerec, are derived from the "universe elimination" rules in NuPRL (described only in unpublished work of Constable).
Reference: [14] <author> D. Duggan and J. Ophel. </author> <title> Kinded parametric overloading. </title> <type> Technical Report CS-94-35, </type> <institution> University of Waterloo, Department of Computer Science, </institution> <month> September </month> <year> 1994. </year> <note> Supersedes CS-94-15 and CS-94-16, </note> <month> March </month> <year> 1994, </year> <editor> and CS-93-32, </editor> <month> August </month> <year> 1993. </year>
Reference-contexts: From a practical point of view it appears that both mechanisms can be used to solve similar problems, but the exact relationship between the two approaches is not clear. Recently Duggan and Ophel <ref> [14] </ref> and Thatte [50] have independently suggested semantics for type classes that are similar in spirit to our proposal. In particular both approaches represent the restriction of a class as a user-defined, possibly recursive, kind definition in a predicative language.
Reference: [15] <author> H. Friedman. </author> <title> Equality between functionals. </title> <editor> In R. Parikh, editor, </editor> <booktitle> Logic Colloquium '75, Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> pages 22-37. </pages> <publisher> North-Holland, </publisher> <year> 1975. </year>
Reference-contexts: Given a standard, call-by-value operational semantics for Mini-ML with the value restriction, and given the stratification between monotypes and polytypes in both Mini-ML and ML i , it is possible to modify a standard binary logical relations-style argument for the simply-typed lambda calculus <ref> [48, 15, 40, 45, 46] </ref> to show the correctness of the (var) ; ] fx : 8t 1 ; : : : ; t n :t g . x : [t n =t n ]( ([t 1 =t 1 ]t ) ) ) x [jt 1 j] [jt n j] (pair)
Reference: [16] <author> J.-Y. Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination des coupures dans l'analyse et la theorie des types. </title> <editor> In J. E. Fenstad, editor, </editor> <booktitle> Proceedings of the Second Scandinavian Logic Symposium, Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference-contexts: The source language is based on Mini-ML [11], which captures many of the essential features of the ML core language. The target language, ML i , is an extension of ML , also known as XML [21], a predicative variant of Girard's F ! <ref> [16, 17, 42] </ref>, enriched with primitives for intensional type analysis. 2.1 Source Language: Mini-ML The source language for our translations is a variant of Mini-ML [11]. <p> Let-bound expressions are restricted to values so that our translation, which makes type abstraction explicit, is correct (see below). 2.2 Target Language: ML i The target language of our translations, ML i , is based on ML [20], a predicative variant of Girard's F ! <ref> [16, 17, 42] </ref>. The essential departure from the impredicative systems of Girard and Reynolds is that the quantifier 8t: ranges only over "small" types, or "monotypes", which do not include the quantified types. <p> Note that in a parametric setting this type contains only constant functions. As another example, Girard's formulation of System F <ref> [16] </ref> includes a distinguished constant 0 t of type t for each type t (including variable types). <p> The possibilities for enriching ML i to admit impredicative quantifiers (and hence account for the full power of dynamic typing including non-termination) are discussed in the conclusion. 4 Related Work There are two traditional interpretations of polymorphism, the explicit style (due to Girard <ref> [16, 17] </ref> and Reynolds [42]), in which types are passed to polymorphic operations, and the implicit style (due to Milner [32]), in which types are erased prior to execution. <p> More recent languages such as Quest [9] extend the expressive power to admit impred-icative polymorphism, in which quantified types may be 4 However, types are passed independently as data and associated with code. instantiated by quantified types. (Both Girard's <ref> [16] </ref> and Reynolds's [42] calculi exhibit this kind of polymorphism.) It is natural to consider whether the methods proposed here may be extended to the impredicative case.
Reference: [17] <author> J.-Y. Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieure. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: The source language is based on Mini-ML [11], which captures many of the essential features of the ML core language. The target language, ML i , is an extension of ML , also known as XML [21], a predicative variant of Girard's F ! <ref> [16, 17, 42] </ref>, enriched with primitives for intensional type analysis. 2.1 Source Language: Mini-ML The source language for our translations is a variant of Mini-ML [11]. <p> Let-bound expressions are restricted to values so that our translation, which makes type abstraction explicit, is correct (see below). 2.2 Target Language: ML i The target language of our translations, ML i , is based on ML [20], a predicative variant of Girard's F ! <ref> [16, 17, 42] </ref>. The essential departure from the impredicative systems of Girard and Reynolds is that the quantifier 8t: ranges only over "small" types, or "monotypes", which do not include the quantified types. <p> The possibilities for enriching ML i to admit impredicative quantifiers (and hence account for the full power of dynamic typing including non-termination) are discussed in the conclusion. 4 Related Work There are two traditional interpretations of polymorphism, the explicit style (due to Girard <ref> [16, 17] </ref> and Reynolds [42]), in which types are passed to polymorphic operations, and the implicit style (due to Milner [32]), in which types are erased prior to execution.
Reference: [18] <author> K. </author> <title> Godel. Uber eine bisher noch nicht benutzte Erweiterung des finiten Standpunktes. </title> <journal> Dialectica, </journal> <volume> 12 </volume> <pages> 280-287, </pages> <year> 1958. </year>
Reference-contexts: Conceptually, Typerec selects i , fi , or ! according to the head-constructor of the normal form of and passes it the components of and the "unrolling" of the Typerec on the components. The level of constructors and kinds is a variation of Godel's T <ref> [18] </ref>. Every constructor, , has a unique normal form, NF (), with respect to the obvious notion of reduction derived from the equivalence rules of Figure 2 [47]. This reduction relation is confluent, from which it follows that constructor equivalence is decidable [47].
Reference: [19] <author> C. A. Gunter, E. L. Gunter, and D. B. MacQueen. </author> <title> Computing ML equality kinds using abstract interpretation. </title> <journal> Information and Computation, </journal> <volume> 107(2) </volume> <pages> 303-323, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: This calculus is sufficient for the interpretation of ML-style polymorphism (see Harper and Mitchell [20] for further discussion of this point.) The language ML i extends ML with intensional (or structural <ref> [19] </ref>) polymor phism, that allows non-parametric functions to be defined by intensional analysis of types. <p> The canonical example is the class of types that admit equality (also known as equality types in SML <ref> [33, 19] </ref>). Consider adding a distinguished type void (with associ ated constructor Void) to ML i in such a way that void is "empty". That is, no closed value has type void.
Reference: [20] <author> R. Harper and J. C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Transactions on Progamming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <month> April </month> <year> 1993. </year> <note> (See also [34].). </note>
Reference-contexts: we summa rize and suggest directions for future research. 2 Type-Directed Compilation In order to take full advantage of type information during compilation, we consider translations of typing derivations from the implicitly-typed ML core language to an explicitly-typed target language, following the interpretation of poly-morphism suggested by Harper and Mitchell <ref> [20] </ref>. The source language is based on Mini-ML [11], which captures many of the essential features of the ML core language. <p> Let-bound expressions are restricted to values so that our translation, which makes type abstraction explicit, is correct (see below). 2.2 Target Language: ML i The target language of our translations, ML i , is based on ML <ref> [20] </ref>, a predicative variant of Girard's F ! [16, 17, 42]. The essential departure from the impredicative systems of Girard and Reynolds is that the quantifier 8t: ranges only over "small" types, or "monotypes", which do not include the quantified types. <p> The essential departure from the impredicative systems of Girard and Reynolds is that the quantifier 8t: ranges only over "small" types, or "monotypes", which do not include the quantified types. This calculus is sufficient for the interpretation of ML-style polymorphism (see Harper and Mitchell <ref> [20] </ref> for further discussion of this point.) The language ML i extends ML with intensional (or structural [19]) polymor phism, that allows non-parametric functions to be defined by intensional analysis of types. <p> Since the translation depends upon the typing derivation, it is possible to have many different translations of a given expression. However, all of the translation schemes we consider are coherent in the sense that any two typing derivations produce observationally equivalent translations <ref> [7, 26, 20] </ref>. 2 Here, we give a straightforward compiler whose purpose is to make types explicit so that the primitive operations such as pairing and projection can potentially analyze their types at run-time. <p> In their study of the type theory of Standard ML Harper and Mitchell <ref> [20] </ref> argued that an explicitly-typed interpretation of ML polymorphism has better semantic properties and scales more easily to cover the full language.
Reference: [21] <author> R. Harper, J. C. Mitchell, and E. Moggi. </author> <title> Higher-order mod-ules and the phase distinction. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Fran-cisco, CA, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: This prevents us from separately compiling polymorphic libraries or polymorphic definitions entered at a top-level loop. Furthermore, in languages that allow polymorphic values to be "first-class" such as XML <ref> [21] </ref> and Quest [9], it is impossible to eliminate all polymorphism at compile-time. <p> The source language is based on Mini-ML [11], which captures many of the essential features of the ML core language. The target language, ML i , is an extension of ML , also known as XML <ref> [21] </ref>, a predicative variant of Girard's F ! [16, 17, 42], enriched with primitives for intensional type analysis. 2.1 Source Language: Mini-ML The source language for our translations is a variant of Mini-ML [11]. <p> These forms may be thought of as eliminatory forms for the kind at the constructor and term level. (The introductory forms are the constructors of kind ; there are no introductory forms at the term level in order to preserve the phase distinction <ref> [8, 21] </ref>.) At the term level typerec may be thought of as a generalization of typecase that provides for the definition of a term by induction on the structure of a monotype. <p> Harper and Mitchell formulated a pred-icative type theory, XML, a theory of dependent types augmented with a universe of small types, adequate for capturing many aspects of Standard ML. This type theory was refined by Harper, Mitchell, and Moggi <ref> [21] </ref>, and provides the basis for this work. The idea of intensional type analysis exploited here was inspired by the work of Constable [12, 13], from which the term "intensional analysis" is taken.
Reference: [22] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <type> Technical Report CMU-CS-94-185, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> September </month> <year> 1994. </year> <note> (Also published as Fox Memorandum CMU-CS-FOX-94-07). </note>
Reference-contexts: This reduction relation is confluent, from which it follows that constructor equivalence is decidable [47]. The type formation, type equivalence, and term formation rules for ML i are omitted due to lack of space, but can be found in a previous report <ref> [22] </ref>. The rules of type equivalence define the interpretation T () of the constructor as a type. For example, T (Int) int and T (!( 1 ; 2 )) T ( 1 ) ! T ( 2 ).
Reference: [23] <author> N. Heintze. </author> <title> Set-based analysis of ML programs. </title> <booktitle> In Proc. 1994 ACM Conf. on LISP and Functional Programming, </booktitle> <pages> pages 306-317, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: All but the first of these approaches involve copying coercions. Of a broadly similar nature is the work on "soft" type systems <ref> [3, 10, 23, 49, 53] </ref> that seek to improve data representations through global analysis techniques. All of these methods are based on the use of program analysis techniques to reduce the overhead of box and tag manipulation incurred by the standard compilation method for polymorphic languages.
Reference: [24] <author> F. Henglein and J. Jtrgensen. </author> <title> Formally optimal boxing. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 213-226, </pages> <address> Portland, OR, </address> <month> Jan. </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: Recent work by Leroy [30] and others <ref> [41, 24, 43] </ref> has suggested that the instantia-tion of a polymorphic value should correspond to a run-time coercion from the universal representation to the appropriate specialized representation. At function types, this requires the dual coercion (for the function argument) that converts specialized representations to the universal representation. <p> A number of authors have considered problems pertain ing to representation analysis in the presence of polymor-phism. The boxing interpretation of polymorphism has been studied by Peyton Jones and Launchbury [29], by Leroy [30], by Poulsen [41], by Henglein and Jtrgensen <ref> [24] </ref>, and by Shao [43] with the goal of minimizing the overhead of boxing and unboxing at run-time. All but the first of these approaches involve copying coercions.
Reference: [25] <author> P. Hudak, S. L. P. Jones, and P. Wadler. </author> <title> Report on the programming language Haskell, version 1.2. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: The M and U functions are used in the translation of client phrases that import a server's function and in the translation of server phrases that export functions. The reader is encouraged to consult Ohori and Kato's paper [39] for further details. 3.3 Type Classes The language Haskell <ref> [25] </ref> provides the ability to define a class of types with associated operations called methods. The canonical example is the class of types that admit equality (also known as equality types in SML [33, 19]).
Reference: [26] <author> M. Jones. </author> <title> Coherence for qualified types. </title> <institution> Research Report YALEU/DCS/RR-989, Yale University, </institution> <address> New Haven, Con-necticut, USA, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: Since the translation depends upon the typing derivation, it is possible to have many different translations of a given expression. However, all of the translation schemes we consider are coherent in the sense that any two typing derivations produce observationally equivalent translations <ref> [7, 26, 20] </ref>. 2 Here, we give a straightforward compiler whose purpose is to make types explicit so that the primitive operations such as pairing and projection can potentially analyze their types at run-time.
Reference: [27] <author> M. Jones. </author> <title> Partial evaluation for dictionary-free overloading. </title> <booktitle> In ACM Conference on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <year> 1994. </year>
Reference-contexts: Such an approach is used, for instance, by Blelloch et al. in their NESL compiler [6] and more recently by Jones to eliminate Haskell overloading <ref> [27] </ref>. Furthermore, Jones reports that this approach does not lead to excessive code-blowup. Unfortunately, eliminating all of the polymorphism in a program is not always possible or pratical.
Reference: [28] <author> M. P. Jones. </author> <title> Qualified Types: Theory and Practice. </title> <type> PhD thesis, </type> <institution> Programming Research Group, Oxford University Computing Laboratory, </institution> <month> July </month> <year> 1992. </year> <note> Currently available as Technical Monograph PRG-106, </note> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <address> 11 Keble Road, Oxford OX1 3QD, U.K. email: library@comlab.ox.ac.uk. </address>
Reference-contexts: Ohori's solution is ad hoc in the sense that no general type-theoretic framework is proposed, but many of the key ideas in his work are present here. Jones <ref> [28] </ref> has proposed a general framework for passing data derived from types to "qualified" polymorphic operations, called evidence passing.
Reference: [29] <author> S. P. Jones and J. Launchbury. </author> <title> Unboxed values as first-class citizens. </title> <booktitle> In Proc. Conf. on Functional Programming and Computer Architecture, volume 523 of Lecture Notes in Computer Science, </booktitle> <pages> pages 636-666. </pages> <publisher> ACM, Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: A number of authors have considered problems pertain ing to representation analysis in the presence of polymor-phism. The boxing interpretation of polymorphism has been studied by Peyton Jones and Launchbury <ref> [29] </ref>, by Leroy [30], by Poulsen [41], by Henglein and Jtrgensen [24], and by Shao [43] with the goal of minimizing the overhead of boxing and unboxing at run-time. All but the first of these approaches involve copying coercions.
Reference: [30] <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Albuquerque, </booktitle> <pages> pages 177-188. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: Recent work by Leroy <ref> [30] </ref> and others [41, 24, 43] has suggested that the instantia-tion of a polymorphic value should correspond to a run-time coercion from the universal representation to the appropriate specialized representation. At function types, this requires the dual coercion (for the function argument) that converts specialized representations to the universal representation. <p> Unfortunately, copying coercions are impractical for large data structures since the cost of making the copy often outweighs the benefits of the unboxed representation (as pointed out by Leroy <ref> [30, page 184] </ref>). More problematically, copying coercions do not work for mutable data structures such as arrays. <p> A number of authors have considered problems pertain ing to representation analysis in the presence of polymor-phism. The boxing interpretation of polymorphism has been studied by Peyton Jones and Launchbury [29], by Leroy <ref> [30] </ref>, by Poulsen [41], by Henglein and Jtrgensen [24], and by Shao [43] with the goal of minimizing the overhead of boxing and unboxing at run-time. All but the first of these approaches involve copying coercions.
Reference: [31] <author> P. Martin-Lof. </author> <title> About models for intuitionistic type theories and the notion of definitional equality. </title> <editor> In S. Kanger, editor, </editor> <booktitle> Proceedings of the Third Scandinavian Logic Symposium, Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> pages 81-109. </pages> <publisher> North-Holland, </publisher> <year> 1975. </year>
Reference-contexts: The constructor equivalence rules (see Figure 2) axiom-atize definitional equality <ref> [47, 31] </ref> of constructors to consist of fi-conversion together with recursion equations governing the Typerec form. Conceptually, Typerec selects i , fi , or ! according to the head-constructor of the normal form of and passes it the components of and the "unrolling" of the Typerec on the components.
Reference: [32] <author> R. Milner. </author> <title> A theory of type polymorphism in programming languages. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: for the full power of dynamic typing including non-termination) are discussed in the conclusion. 4 Related Work There are two traditional interpretations of polymorphism, the explicit style (due to Girard [16, 17] and Reynolds [42]), in which types are passed to polymorphic operations, and the implicit style (due to Milner <ref> [32] </ref>), in which types are erased prior to execution. In their study of the type theory of Standard ML Harper and Mitchell [20] argued that an explicitly-typed interpretation of ML polymorphism has better semantic properties and scales more easily to cover the full language.
Reference: [33] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The canonical example is the class of types that admit equality (also known as equality types in SML <ref> [33, 19] </ref>). Consider adding a distinguished type void (with associ ated constructor Void) to ML i in such a way that void is "empty". That is, no closed value has type void.
Reference: [34] <author> J. Mitchell and R. Harper. </author> <title> The essence of ML. </title> <booktitle> In Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, California, </address> <month> Jan. </month> <year> 1988. </year>
Reference: [35] <author> J. C. Mitchell and G. Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Progamming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <year> 1988. </year>
Reference-contexts: An empirical study of the relative performance of the two approaches is currently planned by the second author, and will be reported elsewhere. The combination of intensional polymorphism and existential types <ref> [35] </ref> raises some interesting questions. On the one hand, the type dynamic [2] may be defined in terms of existentials.
Reference: [36] <author> G. Morrisett, M. Felleisen, and R. Harper. </author> <title> Abstract models of memory management. </title> <note> In preparation, </note> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: Tolmach's results demonstrate that it is feasible to build a run-time system for ML in which no type information is associated with data in the heap 4 . Morrisett, Harper, and Felleisen <ref> [36] </ref> give a semantic framework for discussing garbage collection, and provide a proof of correctness of Tolmach's algorithm. 5 Summary and Future Directions We have presented a type-theoretic framework for expressing computations that analyze types at run-time.
Reference: [37] <author> R. Morrison, A. Dearle, R. C. H. Connor, and A. L. Brown. </author> <title> An ad hoc approach to the implementation of polymorphism. </title> <journal> ACM Transactions on Progamming Languages and Systems, </journal> <volume> 13(3) </volume> <pages> 342-371, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: If we make a copy of the value to box the components then updates to the copy will not be reflected in the original array and vice versa. 1.2 Type Passing An alternative approach to coercions, first suggested by the Napier '88 implementation <ref> [37] </ref>, is to pass the types that are unknown at compile-time to primitive operations at link-time or even run-time. Then the primitive operations can analyze the type in order to select the appropriate code to manipulate the natural representation of an object. <p> The rules for typerec, and the need for Typerec, are derived from the "universe elimination" rules in NuPRL (described only in unpublished work of Constable). The idea of passing types to polymorphic functions is exploited by Morrison et al. <ref> [37] </ref> in the implementation of Napier '88. Types are used at run-time to specialize data representations in roughly the manner described here. The authors do not, however, provide a rigorous account of the type theory underlying their implementation technique.
Reference: [38] <author> A. Ohori. </author> <title> A compilation method for ML-style polymorphic record calculi. </title> <booktitle> In Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 154-165, </pages> <address> Albuquerque, NM, </address> <month> Jan. </month> <year> 1992. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: Types are used at run-time to specialize data representations in roughly the manner described here. The authors do not, however, provide a rigorous account of the type theory underlying their implementation technique. The work of Ohori on compiling record operations <ref> [38] </ref> is similarly based on a type-passing interpretation of polymor-phism, and was an inspiration for the present work. Ohori's solution is ad hoc in the sense that no general type-theoretic framework is proposed, but many of the key ideas in his work are present here.
Reference: [39] <author> A. Ohori and K. Kato. </author> <title> Semantics for communication primitives in a polymorphic language. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 99-112, </pages> <address> Charleston, SC, </address> <month> Jan. </month> <year> 1993. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: A rigorous formulation of the target language ex tended with n-tuples is tedious, but appears to be straight forward. 3.2 Marshalling Ohori and Kato give an extension of ML with primitives for distributed computing in a heterogeneous environment <ref> [39] </ref>. Their extension has two essential features: one is a mechanism for generating globally unique names ("handles" or "capabilities") that are used as proxies for functions provided by servers. The other is a method for representing arbitrary values in a form suitable for transmission through a network. <p> The M and U functions are used in the translation of client phrases that import a server's function and in the translation of server phrases that export functions. The reader is encouraged to consult Ohori and Kato's paper <ref> [39] </ref> for further details. 3.3 Type Classes The language Haskell [25] provides the ability to define a class of types with associated operations called methods. The canonical example is the class of types that admit equality (also known as equality types in SML [33, 19]).
Reference: [40] <author> G. Plotkin. </author> <title> Lambda-definability in the full type hierarchy. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays in Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 363-373. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: Given a standard, call-by-value operational semantics for Mini-ML with the value restriction, and given the stratification between monotypes and polytypes in both Mini-ML and ML i , it is possible to modify a standard binary logical relations-style argument for the simply-typed lambda calculus <ref> [48, 15, 40, 45, 46] </ref> to show the correctness of the (var) ; ] fx : 8t 1 ; : : : ; t n :t g . x : [t n =t n ]( ([t 1 =t 1 ]t ) ) ) x [jt 1 j] [jt n j] (pair)
Reference: [41] <author> E. R. Poulsen. </author> <title> Representation analysis for efficient implementation of polymorphism. </title> <type> Technical report, </type> <institution> Department of Computer Science (DIKU), University of Copenhagen, </institution> <month> Apr. </month> <year> 1993. </year> <note> Master Dissertation. </note>
Reference-contexts: Recent work by Leroy [30] and others <ref> [41, 24, 43] </ref> has suggested that the instantia-tion of a polymorphic value should correspond to a run-time coercion from the universal representation to the appropriate specialized representation. At function types, this requires the dual coercion (for the function argument) that converts specialized representations to the universal representation. <p> A number of authors have considered problems pertain ing to representation analysis in the presence of polymor-phism. The boxing interpretation of polymorphism has been studied by Peyton Jones and Launchbury [29], by Leroy [30], by Poulsen <ref> [41] </ref>, by Henglein and Jtrgensen [24], and by Shao [43] with the goal of minimizing the overhead of boxing and unboxing at run-time. All but the first of these approaches involve copying coercions.
Reference: [42] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Colloq. sur la Programmation, volume 19 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408-423. </pages> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: The source language is based on Mini-ML [11], which captures many of the essential features of the ML core language. The target language, ML i , is an extension of ML , also known as XML [21], a predicative variant of Girard's F ! <ref> [16, 17, 42] </ref>, enriched with primitives for intensional type analysis. 2.1 Source Language: Mini-ML The source language for our translations is a variant of Mini-ML [11]. <p> Let-bound expressions are restricted to values so that our translation, which makes type abstraction explicit, is correct (see below). 2.2 Target Language: ML i The target language of our translations, ML i , is based on ML [20], a predicative variant of Girard's F ! <ref> [16, 17, 42] </ref>. The essential departure from the impredicative systems of Girard and Reynolds is that the quantifier 8t: ranges only over "small" types, or "monotypes", which do not include the quantified types. <p> The possibilities for enriching ML i to admit impredicative quantifiers (and hence account for the full power of dynamic typing including non-termination) are discussed in the conclusion. 4 Related Work There are two traditional interpretations of polymorphism, the explicit style (due to Girard [16, 17] and Reynolds <ref> [42] </ref>), in which types are passed to polymorphic operations, and the implicit style (due to Milner [32]), in which types are erased prior to execution. <p> More recent languages such as Quest [9] extend the expressive power to admit impred-icative polymorphism, in which quantified types may be 4 However, types are passed independently as data and associated with code. instantiated by quantified types. (Both Girard's [16] and Reynolds's <ref> [42] </ref> calculi exhibit this kind of polymorphism.) It is natural to consider whether the methods proposed here may be extended to the impredicative case. Since the universal quantifier may be viewed as a constant of kind ( ! ) ! , similar problems arise as for recursive types.
Reference: [43] <author> Z. Shao. </author> <title> Compiling Standard ML for Efficient Execution on Modern Machines. </title> <type> PhD thesis, </type> <institution> Princeton University, Prince-ton, NJ, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: Recent work by Leroy [30] and others <ref> [41, 24, 43] </ref> has suggested that the instantia-tion of a polymorphic value should correspond to a run-time coercion from the universal representation to the appropriate specialized representation. At function types, this requires the dual coercion (for the function argument) that converts specialized representations to the universal representation. <p> A number of authors have considered problems pertain ing to representation analysis in the presence of polymor-phism. The boxing interpretation of polymorphism has been studied by Peyton Jones and Launchbury [29], by Leroy [30], by Poulsen [41], by Henglein and Jtrgensen [24], and by Shao <ref> [43] </ref> with the goal of minimizing the overhead of boxing and unboxing at run-time. All but the first of these approaches involve copying coercions.
Reference: [44] <author> B. C. Smith. </author> <title> Reflection and semantics in LISP. </title> <booktitle> In Eleventh ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 23-35, </pages> <year> 1984. </year>
Reference-contexts: In this way parametricity and representation independence can be enforced by restricting the use of type analysis. The idea of intensional analysis of types bears some resemblance to the notion of reflection <ref> [44, 4] </ref> | we may think of type-passing as a "reification" of the meta-level notion of types. It is interesting to speculate that the type theory proposed here is but a special case of a fully reflective type theory.
Reference: [45] <author> R. Statman. </author> <title> Completeness, invariance, </title> <journal> and lambda-definability. Journal of Symbolic Logic, </journal> <volume> 47 </volume> <pages> 17-26, </pages> <year> 1982. </year>
Reference-contexts: Given a standard, call-by-value operational semantics for Mini-ML with the value restriction, and given the stratification between monotypes and polytypes in both Mini-ML and ML i , it is possible to modify a standard binary logical relations-style argument for the simply-typed lambda calculus <ref> [48, 15, 40, 45, 46] </ref> to show the correctness of the (var) ; ] fx : 8t 1 ; : : : ; t n :t g . x : [t n =t n ]( ([t 1 =t 1 ]t ) ) ) x [jt 1 j] [jt n j] (pair)
Reference: [46] <author> R. Statman. </author> <title> Logical relations and the typed -calculus. </title> <journal> Information and Control, </journal> <volume> 65 </volume> <pages> 85-97, </pages> <year> 1985. </year>
Reference-contexts: Given a standard, call-by-value operational semantics for Mini-ML with the value restriction, and given the stratification between monotypes and polytypes in both Mini-ML and ML i , it is possible to modify a standard binary logical relations-style argument for the simply-typed lambda calculus <ref> [48, 15, 40, 45, 46] </ref> to show the correctness of the (var) ; ] fx : 8t 1 ; : : : ; t n :t g . x : [t n =t n ]( ([t 1 =t 1 ]t ) ) ) x [jt 1 j] [jt n j] (pair)
Reference: [47] <author> S. Stenlund. </author> <title> Combinators, -terms and Proof Theory. </title> <address> D. </address> <publisher> Reidel, </publisher> <year> 1972. </year>
Reference-contexts: The constructor equivalence rules (see Figure 2) axiom-atize definitional equality <ref> [47, 31] </ref> of constructors to consist of fi-conversion together with recursion equations governing the Typerec form. Conceptually, Typerec selects i , fi , or ! according to the head-constructor of the normal form of and passes it the components of and the "unrolling" of the Typerec on the components. <p> The level of constructors and kinds is a variation of Godel's T [18]. Every constructor, , has a unique normal form, NF (), with respect to the obvious notion of reduction derived from the equivalence rules of Figure 2 <ref> [47] </ref>. This reduction relation is confluent, from which it follows that constructor equivalence is decidable [47]. The type formation, type equivalence, and term formation rules for ML i are omitted due to lack of space, but can be found in a previous report [22]. <p> Every constructor, , has a unique normal form, NF (), with respect to the obvious notion of reduction derived from the equivalence rules of Figure 2 <ref> [47] </ref>. This reduction relation is confluent, from which it follows that constructor equivalence is decidable [47]. The type formation, type equivalence, and term formation rules for ML i are omitted due to lack of space, but can be found in a previous report [22]. The rules of type equivalence define the interpretation T () of the constructor as a type.
Reference: [48] <author> W. W. Tait. </author> <title> Intensional interpretation of functionals of finite type. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 32(2) </volume> <pages> 187-199, </pages> <month> June </month> <year> 1967. </year>
Reference-contexts: Given a standard, call-by-value operational semantics for Mini-ML with the value restriction, and given the stratification between monotypes and polytypes in both Mini-ML and ML i , it is possible to modify a standard binary logical relations-style argument for the simply-typed lambda calculus <ref> [48, 15, 40, 45, 46] </ref> to show the correctness of the (var) ; ] fx : 8t 1 ; : : : ; t n :t g . x : [t n =t n ]( ([t 1 =t 1 ]t ) ) ) x [jt 1 j] [jt n j] (pair)
Reference: [49] <author> S. R. Thatte. </author> <title> Quasi-static typing. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 367-381, </pages> <address> San Francisco, CA, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: All but the first of these approaches involve copying coercions. Of a broadly similar nature is the work on "soft" type systems <ref> [3, 10, 23, 49, 53] </ref> that seek to improve data representations through global analysis techniques. All of these methods are based on the use of program analysis techniques to reduce the overhead of box and tag manipulation incurred by the standard compilation method for polymorphic languages.
Reference: [50] <author> S. R. Thatte. </author> <title> Semantics of type classes revisited. </title> <booktitle> In Proc. 1994 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 208-219, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: From a practical point of view it appears that both mechanisms can be used to solve similar problems, but the exact relationship between the two approaches is not clear. Recently Duggan and Ophel [14] and Thatte <ref> [50] </ref> have independently suggested semantics for type classes that are similar in spirit to our proposal. In particular both approaches represent the restriction of a class as a user-defined, possibly recursive, kind definition in a predicative language.
Reference: [51] <author> A. Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proc. 1994 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: The semantics uses meta-level substitution of closed val ues for variables and closed constructors for type variables. In a lower-level semantics where substitution is made ex plicit, an environment would be needed not only for value variables, but also for type variables. Tolmach <ref> [51] </ref> describes many of the issues involved in implementing such a language. Proposition 2.2 (Type Preservation) If ;; ; . e : and e ,! v, then ;; ; . v : . <p> Many (including the soft type systems, but not Leroy's system) rely on global analysis for their effectiveness. In contrast we propose a new approach to compiling polymorphism that affords control over data representation without compromising modularity. Finally, a type-passing interpretation of polymorphism is exploited by Tolmach <ref> [51] </ref> in his implementation of a tag-free garbage collection algorithm. Tolmach's results demonstrate that it is feasible to build a run-time system for ML in which no type information is associated with data in the heap 4 . <p> Setting aside the additional expressiveness of the present approach, it is interesting to consider the performance of a type-passing implementation of ML as compared to the type-free approach adopted in SML/NJ [5]. As pointed out by Tolmach <ref> [51] </ref>, a type-passing implementation need not maintain tag bits on values for the sake of garbage collection. The only remaining use of tag bits in SML/NJ is for polymorphic equality, which can readily be implemented using intensional type analysis.
Reference: [52] <author> A. K. Wright. </author> <title> Polymorphism for imperative languages without imperative types. </title> <type> Technical Report TR93-200, </type> <institution> Department of Computer Science, Rice University, Houston, TX, </institution> <month> Feb. </month> <year> 1993. </year> <note> To appear, Lisp and Symbolic Computation. </note>
Reference-contexts: Lazy languages such as Haskell satisfy this constraint, and Wright has determined empirically that such a restriction does not effect the vast majority of SML programs <ref> [52] </ref>. Languages like core-SML and Haskell only allow polymorphic values to arise as the result of a "let" binding and restrict the type of such values to be prenex-quantified.
Reference: [53] <author> A. K. Wright and R. Cartwright. </author> <title> A practical soft type system for Scheme. </title> <booktitle> In Proc 1994 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 250-262, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: All but the first of these approaches involve copying coercions. Of a broadly similar nature is the work on "soft" type systems <ref> [3, 10, 23, 49, 53] </ref> that seek to improve data representations through global analysis techniques. All of these methods are based on the use of program analysis techniques to reduce the overhead of box and tag manipulation incurred by the standard compilation method for polymorphic languages.
References-found: 53

