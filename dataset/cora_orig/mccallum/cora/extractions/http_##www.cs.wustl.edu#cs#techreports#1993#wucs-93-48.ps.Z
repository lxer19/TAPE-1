URL: http://www.cs.wustl.edu/cs/techreports/1993/wucs-93-48.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: http://www.cs.wustl.edu
Title: DNA Mapping Algorithms: Synchronized Double Digest Mapping  
Author: Jim Daues Will Gillett 
Note: This work was supported by the James S. McDonnell Foundation under Grant 87-24 and NIH under grant R01 HG00180.  
Address: Saint Louis, Missouri 63130 (314) 935-6160  
Affiliation: DEPARTMENT OF COMPUTER SCIENCE WASHINGTON UNIVERSITY  
Date: September 1993  
Pubnum: WUCS-93-48  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Maynard V. Olson, James E. Dutchik, Madge Y. G raham, Garret M. Brodeur, Cynthia Helms, Mark Frank, Mia MacCollin, Robert Scheinman, and Thomas Frank, </author> <title> Random-Clone Strategy for Genomic Restriction Mapping in Yeast, </title> <journal> Proc. Natl. Acad. Sci. (Genetics), </journal> <volume> Vol. 83, </volume> <pages> pp. </pages> <month> 7826-7830 (October, </month> <year> 1986). </year>
Reference-contexts: Consequently, 513 is chosen to match with 515, and 527 remains unmatched. Since there are no more fragments to consider, the mapping of Clone #1 with Clone #3 is complete. There is now a fragment matching or fragmat <ref> (i.e., 61986109, 40824087, 11501139, 10921078, 637630, 513515) </ref> which describes the matches which exist between the two clones. It is also known which fragments in each clone did not pair. Using these data, the two clones can be put together as shown in Figure 4. <p> ,vfs b ,vfs a b ; SEED seed LEFT ,seed RIGHT ; CSEQUENCE working_seq; - BOOLEAN ans; HELPER_FRAGMENT helper; SET unplaced a ,unplaced b ,unplaced a b ; ans TRUE; if (not (seq_is_empty (working_seq))) then if (seed LEFT =/ NULL) then helper helper_fragment_create (seed LEFT ); if (working_seq.seq a b <ref> [1] </ref> =/ helper or working_seq.leftmost_enzyme = seed LEFT .extending_enzyme) then ans FALSE; fi if (seed RIGHT =/ NULL) then helper helper_fragment_create (seed RIGHT ); if (working_seq.seq a b [| working_seq.seq a b |] =/ helper or working_seq.rightmost_enzyme = seed RIGHT .extending_enzyme) then ans FALSE; fi unplaced a vfs a - -vf <p> DNA Mapping - 48 - S DDM BOOLEAN permutation_hooks_to_working_seq (working_seq,p) CSEQUENCE working_seq; LIST p; - BOOLEAN ans; VIRTUAL_FRAGMENT vf 1 ,vf 2 ; if (working_seq.seq a b = []) then ans TRUE; else vf 1 working_seq.link; vf 2 p <ref> [1] </ref>; if (vf 1 = vf 2 ) then ans TRUE; else ans FALSE; fi fi return (ans); - BOOLEAN permutation_uses_vfrags_in_working_seq (working_seq,p) CSEQUENCE working_seq; LIST p; - INTEGER i; BOOLEAN ans; ans FALSE; if (working_seq.seq a b =/ []) then for i 2,...,|p| do if (vfrag_is_in_seq (working_seq,p [i])) then ans TRUE; <p> LIST vfs,d; CSEQUENCE core_seq; - INTEGER i; SET m,ans; LIST unplaced_vfs,singlets; VIRTUAL_FRAGMENT vf; ans ; unplaced_vfs []; singlets []; for i 1,...,|vfs| do if (not (vfrag_is_in_seq (core_seq,vfs [i]))) then unplaced_vfs unplaced_vfs || [vfs [i]]; singlets singlets || [-vf | -vf- d [i] and not (vfrag_is_in_seq (core_seq,vf))-]; fi for vf singlets <ref> [1] </ref> do m -(unplaced_vfs [1],vf)-; ans ans find_all_singlet_mappings_recurse (unplaced_vfs,singlets,2,m); rof return (ans); - DNA Mapping - 56 - S DDM SET find_all_singlet_mappings_recurse (unplaced_vfs,singlets,i,m) LIST unplaced_vfs,singlets; INTEGER i; SET m; SET m,ans; VIRTUAL_FRAGMENT vf 1 ,vf 2 ,vf 3 ; ans ; then for vf 1 singlets [i] do if (not (( <p> The seed to use from q 2,1 is s 3 and the seed to use from q 1,2 is s 2 . iddm_region ([[3900]],[],[],s 3 ,s 2 ) is called and returns -q 4,1 -, where q 4,1 is the sequence illustrated in Figure 95. good_seed LEFT <ref> [1] </ref> and good_seed RIGHT [2] are set to TRUE, indicating that these seeds produced a complete and consistent virtual fragment sequence. Then the function both_helper_update_seq_seed_dep_info (Figure 96) is called to update seqs, seeds and dep with information about this new sequence. <p> Since a sequence for x 5 was computed, the status of x 5 is marked OK. Because good_seed LEFT [2] is FALSE the sequence q 2,2 is incompatible, and remove_seq_seed_dep_info_of_unused_seed_and_relatives is called to remove the information associated with q 2,2 . Since good_seed RIGHT <ref> [1] </ref> is FALSE, the sequence q 1,1 is incompatible, but this was already known and the call to remove_seq_seed_dep_info_of_unused_seed_and_relatives has no q 4,1 3900 a b a DNA Mapping - 94 - S DDM TUPLE both_helper_update_seq_seed_dep_info (seqs,seeds,dep,n REG ,n REG_SEQ ,n LEFT_HELP ,n LEFT_HELP_SEQ ,n RIGHT_HELP ,n RIGHT_HELP_SEQ ,rseq) TUPLE seqs,seeds; <p> b ,ans a b ; ans a find_group_seqs_fixed_enzyme (m,regions,seqs,a ); ans b find_group_seqs_fixed_enzyme (m,regions,seqs,b ); ans a b find_group_seqs_fixed_enzyme (m,regions,seqs,a b ); ans (ans a ,ans b ,ans a b ); return (ans); - MREMAP find_best_mremap_from_group_seqs (m,t) MREMAP m; TUPLE t; - MREMAP ans; ans.map a find_best_sremap_from_group_seqs (m.map a ,t <ref> [1] </ref>); ans.map b find_best_sremap_from_group_seqs (m.map b ,t [2]); ans.map a b find_best_sremap_from_group_seqs (m.map a b ,t [3]); return (ans); - DNA Mapping - 98 - S DDM TUPLE find_group_seqs_fixed_enzyme (m,regions,seqs,enz) MREMAP m; LIST regions; TUPLE seqs; ENZYME enz; - INTEGER i,j,k,off,size,gl,gr; PAIR gut; LIST gseqs; TUPLE ans; SREMAP s; CSEQUENCE rseq; <p> At this point, s is the original a b SRE map and gseqs = ([], [[2050,1000,2000],[2000,1000,2050]], [[500,1500,600,1600]], [[1700,800,500]], [[800,2000]], []). Initially, groups is set to the empty list. Then the first call to find_best_groups_from_group_seqs (pseudocode in Figure 105) is made with n = 1. In find_best_groups_from_group_seqs, gseqs <ref> [1] </ref> is the empty list. If there are no virtual fragment sequences for a group then either (1) the group has no virtual fragments or (2) no complete and consistent sequences were found for the group. <p> find_best_groups_from_fixed_group_no_ces (gseqs [n]); lces ces_of (g,LEFT); rces ces_of (g,RIGHT); group_add_objects (ans [|ans|],lces); group_add_objects (ans <ref> [1] </ref>,rces); fi return (ans); - LIST find_best_groups_from_fixed_group_no_ces (fgseqs) LIST fgseqs; - INTEGER i,j,n; LIST ans,fgseqs; TUPLE sets; ans []; fgseqs fgseqs; n |fgseqs|; sets empty_tuple (n); for i 1,...,n do sets [i] ; rof while (fgseqs [1] =/ []) do for i 1,...,n do sets [i] sets [i] -fgseqs [i][1]-; fgseqs [i] fgseqs [i][2,...]; rof if (( "" // - i,j) (sets [i] = sets [j])) then ans ans || [group_create (sets [1])]; for i 1,...,n do sets [i] ; rof fi return (ans); - DNA Mapping <p> |fgseqs|; sets empty_tuple (n); for i 1,...,n do sets [i] ; rof while (fgseqs <ref> [1] </ref> =/ []) do for i 1,...,n do sets [i] sets [i] -fgseqs [i][1]-; fgseqs [i] fgseqs [i][2,...]; rof if (( "" // - i,j) (sets [i] = sets [j])) then ans ans || [group_create (sets [1])]; for i 1,...,n do sets [i] ; rof fi return (ans); - DNA Mapping - 101 - SDDM element of each list is extracted and the process is repeated. In this case there are two lists: [2050,1000,2000] and [2000,1000,2050].
Reference: 2. <author> Linda Riles, James E. Dutchik, Amara Baktha, Brigid K. McCauley, Edward C. Thayer, Mary P. Leckie, Valerie V. Braden, Julie E. Depke, and Maynard V. Olson, </author> <title> Physical maps of the six smallest chromosomes of Saccharomyces cerevisiae at a resolution of 2.6 kilobase pairs, </title> <journal> Genetics, </journal> <volume> Vol. 134, </volume> <pages> pp. </pages> <month> 81-150 (May </month> <year> 1993). </year>
Reference-contexts: seed to use from q 2,1 is s 3 and the seed to use from q 1,2 is s 2 . iddm_region ([[3900]],[],[],s 3 ,s 2 ) is called and returns -q 4,1 -, where q 4,1 is the sequence illustrated in Figure 95. good_seed LEFT [1] and good_seed RIGHT <ref> [2] </ref> are set to TRUE, indicating that these seeds produced a complete and consistent virtual fragment sequence. Then the function both_helper_update_seq_seed_dep_info (Figure 96) is called to update seqs, seeds and dep with information about this new sequence. <p> This results in the call iddm_region ([[3900]],[],[],s 1 ,s 2 ), which returns . Since a sequence for x 5 was computed, the status of x 5 is marked OK. Because good_seed LEFT <ref> [2] </ref> is FALSE the sequence q 2,2 is incompatible, and remove_seq_seed_dep_info_of_unused_seed_and_relatives is called to remove the information associated with q 2,2 . <p> find_group_seqs_fixed_enzyme (m,regions,seqs,a ); ans b find_group_seqs_fixed_enzyme (m,regions,seqs,b ); ans a b find_group_seqs_fixed_enzyme (m,regions,seqs,a b ); ans (ans a ,ans b ,ans a b ); return (ans); - MREMAP find_best_mremap_from_group_seqs (m,t) MREMAP m; TUPLE t; - MREMAP ans; ans.map a find_best_sremap_from_group_seqs (m.map a ,t [1]); ans.map b find_best_sremap_from_group_seqs (m.map b ,t <ref> [2] </ref>); ans.map a b find_best_sremap_from_group_seqs (m.map a b ,t [3]); return (ans); - DNA Mapping - 98 - S DDM TUPLE find_group_seqs_fixed_enzyme (m,regions,seqs,enz) MREMAP m; LIST regions; TUPLE seqs; ENZYME enz; - INTEGER i,j,k,off,size,gl,gr; PAIR gut; LIST gseqs; TUPLE ans; SREMAP s; CSEQUENCE rseq; s m.map enz ; ans empty_tuple (num_groups_of <p> In either case, the new SRE map should contain the group from the original SRE map. In this particular call to find_best_groups_from_group_seqs case 1 is true; the first group of the original SRE map is returned and groups = [-l A -]. In the next call to find_best_groups_from_group_seqs, gseqs <ref> [2] </ref> = [[2050,1000,2000], [2000,1000,2050]]. Since this is not an empty list, find_best_groups_from_fixed_group_no_ces (Figure 106) is called. This function is the heart of the Best MRE Map Phase.
Reference: 3. <author> Will Gillett, </author> <title> DNA Mapping Algorithms: Strategies for Single Restriction Enzyme and Multiple Restriction Enzyme Mapping, </title> <institution> Washington University, Dept. of Computer Science, </institution> <type> Technical Report WUCS-92-29, </type> <month> August </month> <year> 1992. </year>
Reference-contexts: However, the computational complexity of this solution makes it completely unacceptable, especially since the erroneous placement often occurs very early in the construction of the map. Instead a mechanism for reducing the uncertainty of placing a clone in a map is what is needed. MRE mapping <ref> [3] </ref> supplies just such a mechanism. <p> More precisely, this means that the following conditions are assumed to hold. (ic 1 ) There are no unregistered genomic fragments in any of the clones used in the MRE map. (ic 2 ) The SRE maps within the MRE map are consistent-order clone-end compatible with each other <ref> [3] </ref> (ic 3 ) The partial order of the virtual fragments and clone ends determined by the MRE map is not contradictory to the underlying reality. 2.1. <p> a b find_group_seqs_fixed_enzyme (m,regions,seqs,a b ); ans (ans a ,ans b ,ans a b ); return (ans); - MREMAP find_best_mremap_from_group_seqs (m,t) MREMAP m; TUPLE t; - MREMAP ans; ans.map a find_best_sremap_from_group_seqs (m.map a ,t [1]); ans.map b find_best_sremap_from_group_seqs (m.map b ,t [2]); ans.map a b find_best_sremap_from_group_seqs (m.map a b ,t <ref> [3] </ref>); return (ans); - DNA Mapping - 98 - S DDM TUPLE find_group_seqs_fixed_enzyme (m,regions,seqs,enz) MREMAP m; LIST regions; TUPLE seqs; ENZYME enz; - INTEGER i,j,k,off,size,gl,gr; PAIR gut; LIST gseqs; TUPLE ans; SREMAP s; CSEQUENCE rseq; s m.map enz ; ans empty_tuple (num_groups_of (s)); for i 1,...,num_groups_of (s) do ans [i] []; <p> Thus, find_best_groups_from_group_seqs returns [-l B ,1000,2000,2050-]. find_best_sremap_from_group_seqs appends this to groups, resulting in groups = [-l A -, -l B ,1000,2000,2050-]. In the next call to find_best_groups_from_group_seqs, gseqs <ref> [3] </ref> = [[500,1500,600,1600]]. Eventually find_best_groups_from_fixed_group_no_ces is called with [[500,1500,600,1600]] as input. Since there is only one list of virtual fragments, the elements of sets will always be equal to each other, because there will be only one element. This causes each virtual fragment to be placed in a separate group. <p> less than a known length MIN or greater than a known length MAX may exist in the clones used to construct the MRE map and will not appear in their fingerprints. (rc 2 ) The SRE maps within the MRE map are consistent-order clone-end compatible or phantom clone end compatible <ref> [3] </ref> (rc 3 ) The partial order of the virtual fragments determined by the MRE map is not contradictory to the underlying reality.
Reference: 4. <author> Eric S. Lander and Michael S. Waterman, </author> <title> Genomic Mapping By Fingerprinting Random Clones: </title>
References-found: 4

