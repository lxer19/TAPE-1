URL: http://www.daimi.aau.dk/~mis/sati.ps
Refering-URL: http://www.daimi.aau.dk/~mis/papers.html
Root-URL: http://www.daimi.aau.dk
Email: palsberg@daimi.aau.dk mis@daimi.aau.dk  
Title: Safety Analysis versus Type Inference  
Author: Jens Palsberg Michael I. Schwartzbach 
Address: Ny Munkegade, DK-8000 Arhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University  
Note: To appear in Information and Computation.  
Abstract: Safety analysis is an algorithm for determining if a term in an untyped lambda calculus with constants is safe, i.e., if it does not cause an error during evaluation. This ambition is also shared by algorithms for type inference. Safety analysis and type inference are based on rather different perspectives, however. Safety analysis is global in that it can only analyze a complete program. In contrast, type inference is local in that it can analyze pieces of a program in isolation. In this paper we prove that safety analysis is sound , relative to both a strict and a lazy operational semantics. We also prove that safety analysis accepts strictly more safe lambda terms than does type inference for simple types. The latter result demonstrates that global program analyses can be more precise than local ones. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew Ayers. </author> <title> Efficient closure analysis with reachability. </title> <booktitle> In Proc. WSA'92, Analyse Statique, </booktitle> <pages> pages 126-134, </pages> <year> 1992. </year>
Reference-contexts: Thus, closure information can always be obtained for a lambda term. In contrast, SA need not be solvable, since not all lambda terms are safe. Instead, as proved in the following subsection, if SA has a solution, then it has a minimal one. Ayers <ref> [1] </ref> has presented a cubic time algorithm that computes essentially the minimal solution of CA. It is straightforward to incorporate into his algorithm the checks yielded by our safety constraints. Ayers' algorithm also applies to the extension of safety analysis which we consider next. <p> We conjecture, however, that the basic form of safety analysis, without detection of dead code, is sound for fi-reduction. The algorithm for safety analysis can be implemented in cubic time, by a slight modification of Ayers' algorithm <ref> [1] </ref>. This shows that safety analysis realistically can be incorporated into a compiler for an untyped functional language. Type inference has been used as the basis of binding time analysis [9]; so has closure analysis [3].
Reference: [2] <editor> Henk Barendregt and Kees Hemerik. </editor> <booktitle> Types in lambda calculi and programming languages. In Proc. ESOP'90, European Symposium on Programming, </booktitle> <pages> pages 1-35. </pages> <publisher> Springer-Verlag (LNCS 432), </publisher> <year> 1990. </year>
Reference-contexts: All closure sets will be the maximal set lambda. Thus, the more fine-grained distinction between individual closures is lost. The results are still valid if we allow recursive types, as in the -calculus <ref> [2] </ref>. Here the TI constraints are exactly the same, but the type schemes are changed from finite to regular trees. This allows solutions to constraints such as X = X ! Int. Only lemma 5.4 is influenced, but the proof carries through with virtually no modifications.
Reference: [3] <author> Anders Bondorf. </author> <title> Automatic autoprojection of higher order recursive equations. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 17(1-3):3-34, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: We propose another technique which we shall simply call safety analysis; it is based on closure analysis (also called control flow analysis) <ref> [11, 19, 3, 20] </ref> and does not perform a type reconstruction. We prove that this new technique is sound and that it accepts strictly more safe lambda terms than does type inference for simple types. <p> That safety analysis can only analyze programs that take first-order values as inputs is of course a limitation. In practice, however, one can represent higher-order input as a first-order data structure. This is for example done in Bondorf's partial evaluator Similix <ref> [3, 4] </ref> and in Gomard and Jones' partial evaluator Lambda-mix [9]. The former partial evaluator is applicable to a higher-order subset of Scheme and the latter to a lambda calculus with constants. Similix for example contains a parser that transforms Scheme programs into a first-order representation. <p> running example in the following section. 4 Constraints: [[y:y0]] = [[x:x]] ! [[(y:y0)(x:x)]] [[x:x]] = [[x]] ! [[x]] [[y]] = [[0]] ! [[y0]] Solution: [[(y:y0)(x:x)]] = [[y0]] = [[0]] = [[x]] = Int [[y:y0]] = (Int ! Int) ! Int 3 Safety Analysis Safety analysis is based on closure analysis <ref> [19, 3] </ref> (also called control flow analysis by Jones [11] and Shivers [20]). The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate [11, 19, 3, 20]. <p> The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate <ref> [11, 19, 3, 20] </ref>. The basic form of safety analysis, which we present first, is simply a closure analysis that does appropriate safety checks. This safety analysis is essentially the one used in the Similix partial evaluator [3]. <p> The basic form of safety analysis, which we present first, is simply a closure analysis that does appropriate safety checks. This safety analysis is essentially the one used in the Similix partial evaluator <ref> [3] </ref>. Having presented this basic analysis, we proceed by extending it with detection of dead code. This involves the notion of a trace graph. The safety analysis algorithms share many similarities with that for type inference. First, the lambda term is ff-converted so that every -bound variable is distinct. <p> This shows that safety analysis realistically can be incorporated into a compiler for an untyped functional language. Type inference has been used as the basis of binding time analysis [9]; so has closure analysis <ref> [3] </ref>. We hope to use the techniques presented here to formally compare the quality of these analyses. There are other type systems for the lambda calculus, for which type inference is possible. In particular, we think of partial types [21, 17, 14] and simple intersection types [5].
Reference: [4] <author> Anders Bondorf. </author> <title> Similix 5.0 Manual. </title> <institution> DIKU, University of Copenhagen, Denmark, </institution> <month> April </month> <year> 1993. </year> <note> Included in Similix 5.0 distribution. </note>
Reference-contexts: That safety analysis can only analyze programs that take first-order values as inputs is of course a limitation. In practice, however, one can represent higher-order input as a first-order data structure. This is for example done in Bondorf's partial evaluator Similix <ref> [3, 4] </ref> and in Gomard and Jones' partial evaluator Lambda-mix [9]. The former partial evaluator is applicable to a higher-order subset of Scheme and the latter to a lambda calculus with constants. Similix for example contains a parser that transforms Scheme programs into a first-order representation.
Reference: [5] <author> Mario Coppo and Paola Giannini. </author> <title> A complete type inference algorithm for simple intersection types. </title> <booktitle> In Proc. CAAP'92, </booktitle> <pages> pages 102-123. </pages> <publisher> Springer-Verlag (LNCS 581), </publisher> <year> 1992. </year>
Reference-contexts: We hope to use the techniques presented here to formally compare the quality of these analyses. There are other type systems for the lambda calculus, for which type inference is possible. In particular, we think of partial types [21, 17, 14] and simple intersection types <ref> [5] </ref>. Neither encompasses constants in its present form, but this should be easy to remedy. We hope to extend figure 2 by proving more containment results involving these systems. Acknowledgements. The authors thank Mitchell Wand and the anonymous referees for a wealth of helpful comments on drafts of the paper. 24
Reference: [6] <author> Luis Damas and Robin Milner. </author> <title> Principle type-schemes for functional programs. </title> <booktitle> In Ninth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1982. </year>
Reference-contexts: If no solution exists, then the program is not typable. Soundness and syntactic completeness of this algorithm is well-known <ref> [10, 16, 6] </ref>. The TI constraint system for the term (y:y0)(x:x) is shown in figure 5.
Reference: [7] <author> Joelle Despeyroux. </author> <title> Proof of translation in natural semantics. </title> <booktitle> In LICS'86, First Symposium on Logic in Computer Science, </booktitle> <pages> pages 193-205, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Thus, the soundness with respect to one of the reduction strategies does not imply the soundness with respect to the other. 1) (x:err)(loop) 2) (x:loop)(err) where err = 00 and loop = , with = (x:xx) The two semantics of the untyped lambda calculus will be given as natural semantics <ref> [12, 7] </ref>, involving sequents and inference rules. The two proofs of soundness have the same structure, as follows. First, the soundness of environment lookup is proved by induction in the structure of derivation trees.
Reference: [8] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80|The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Safety analysis and type inference differ in the domain over which constraints are specified, and in the manner in which these are generated from the syntax. In a previous paper [18] we successfully applied safety analysis to a substantial subset of the object-oriented language Smalltalk <ref> [8] </ref>, demonstrating how to deal with inheritance, assignments, conditionals, late binding, etc. 3.1 The Basic Safety Analysis In the remaining we consider a fixed lambda term E 0 . We denote by lambda the finite set of all lambda tokens in E 0 .
Reference: [9] <author> Carsten K. Gomard and Neil D. Jones. </author> <title> A partial evaluator for the untyped lambda-calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(1) </volume> <pages> 21-69, </pages> <year> 1991. </year>
Reference-contexts: In practice, however, one can represent higher-order input as a first-order data structure. This is for example done in Bondorf's partial evaluator Similix [3, 4] and in Gomard and Jones' partial evaluator Lambda-mix <ref> [9] </ref>. The former partial evaluator is applicable to a higher-order subset of Scheme and the latter to a lambda calculus with constants. Similix for example contains a parser that transforms Scheme programs into a first-order representation. <p> The algorithm for safety analysis can be implemented in cubic time, by a slight modification of Ayers' algorithm [1]. This shows that safety analysis realistically can be incorporated into a compiler for an untyped functional language. Type inference has been used as the basis of binding time analysis <ref> [9] </ref>; so has closure analysis [3]. We hope to use the techniques presented here to formally compare the quality of these analyses. There are other type systems for the lambda calculus, for which type inference is possible.
Reference: [10] <author> J. Roger Hindley. </author> <title> The principal type scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathmatical Society, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <year> 1969. </year>
Reference-contexts: If no solution exists, then the program is not typable. Soundness and syntactic completeness of this algorithm is well-known <ref> [10, 16, 6] </ref>. The TI constraint system for the term (y:y0)(x:x) is shown in figure 5.
Reference: [11] <author> Neil D. Jones. </author> <title> Flow analysis of lambda expressions. </title> <booktitle> In Proc. Eighth Colloquium on Automata, Languages, and Programming, </booktitle> <pages> pages 114-128. </pages> <publisher> Springer-Verlag (LNCS 115), </publisher> <year> 1981. </year>
Reference-contexts: We propose another technique which we shall simply call safety analysis; it is based on closure analysis (also called control flow analysis) <ref> [11, 19, 3, 20] </ref> and does not perform a type reconstruction. We prove that this new technique is sound and that it accepts strictly more safe lambda terms than does type inference for simple types. <p> = [[x:x]] ! [[(y:y0)(x:x)]] [[x:x]] = [[x]] ! [[x]] [[y]] = [[0]] ! [[y0]] Solution: [[(y:y0)(x:x)]] = [[y0]] = [[0]] = [[x]] = Int [[y:y0]] = (Int ! Int) ! Int 3 Safety Analysis Safety analysis is based on closure analysis [19, 3] (also called control flow analysis by Jones <ref> [11] </ref> and Shivers [20]). The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate [11, 19, 3, 20]. <p> The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate <ref> [11, 19, 3, 20] </ref>. The basic form of safety analysis, which we present first, is simply a closure analysis that does appropriate safety checks. This safety analysis is essentially the one used in the Similix partial evaluator [3].
Reference: [12] <author> Gilles Kahn. </author> <title> Natural semantics. </title> <booktitle> In Proc. STACS'87, </booktitle> <pages> pages 22-39. </pages> <publisher> Springer-Verlag (LNCS 247), </publisher> <year> 1987. </year>
Reference-contexts: Thus, the soundness with respect to one of the reduction strategies does not imply the soundness with respect to the other. 1) (x:err)(loop) 2) (x:loop)(err) where err = 00 and loop = , with = (x:xx) The two semantics of the untyped lambda calculus will be given as natural semantics <ref> [12, 7] </ref>, involving sequents and inference rules. The two proofs of soundness have the same structure, as follows. First, the soundness of environment lookup is proved by induction in the structure of derivation trees.
Reference: [13] <author> Paris C. Kannellakis, Harry G. Mairson, and John C. Mitchell. </author> <title> Unification and ML type reconstruction. </title> <editor> In J.-L. Lassez and G. Plotkin, editors, </editor> <booktitle> Computational Logic, Essays in Honor of Alan J. Robinson, chapter 13. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Polymorphic let could be treated by doing syntactic expansion before the type inference. Kannellakis, Mairson, and Mitchell <ref> [13, 15] </ref> proved that although this expansion may exponentially increase the size of the program, no type inference algorithm for polymorphic let has better worst-case complexity.
Reference: [14] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient inference of partial types. </title> <journal> Journal of Computer and System Sciences. </journal> <note> To appear. Also in Proc. </note> <editor> FOCS'92, </editor> <booktitle> 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 363-371, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> October </month> <year> 1992. </year> <month> 25 </month>
Reference-contexts: We hope to use the techniques presented here to formally compare the quality of these analyses. There are other type systems for the lambda calculus, for which type inference is possible. In particular, we think of partial types <ref> [21, 17, 14] </ref> and simple intersection types [5]. Neither encompasses constants in its present form, but this should be easy to remedy. We hope to extend figure 2 by proving more containment results involving these systems. Acknowledgements.
Reference: [15] <author> Harry G. Mairson. </author> <title> Decidability of ML typing is complete for deterministic expo-nential time. </title> <booktitle> In Seventeenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 382-401. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: Polymorphic let could be treated by doing syntactic expansion before the type inference. Kannellakis, Mairson, and Mitchell <ref> [13, 15] </ref> proved that although this expansion may exponentially increase the size of the program, no type inference algorithm for polymorphic let has better worst-case complexity.
Reference: [16] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Safety is undecidable so any sound analysis algorithm must reject some safe programs. E :: = x j x:E j E 1 E 2 j 0 j succ E One way of achieving a safety guarantee is to perform type inference <ref> [16] </ref>; if a term is typable, then safety is guaranteed. We propose another technique which we shall simply call safety analysis; it is based on closure analysis (also called control flow analysis) [11, 19, 3, 20] and does not perform a type reconstruction. <p> If no solution exists, then the program is not typable. Soundness and syntactic completeness of this algorithm is well-known <ref> [10, 16, 6] </ref>. The TI constraint system for the term (y:y0)(x:x) is shown in figure 5.
Reference: [17] <author> Patrick M. O'Keefe and Mitchell Wand. </author> <title> Type inference for partial types is decidable. </title> <booktitle> In Proc. ESOP'92, European Symposium on Programming, </booktitle> <pages> pages 408-417. </pages> <publisher> Springer-Verlag (LNCS 582), </publisher> <year> 1992. </year>
Reference-contexts: We hope to use the techniques presented here to formally compare the quality of these analyses. There are other type systems for the lambda calculus, for which type inference is possible. In particular, we think of partial types <ref> [21, 17, 14] </ref> and simple intersection types [5]. Neither encompasses constants in its present form, but this should be easy to remedy. We hope to extend figure 2 by proving more containment results involving these systems. Acknowledgements.
Reference: [18] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proc. OOPSLA'91, ACM SIGPLAN Sixth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 146-161, </pages> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Third, a finite collection of constraints over these variables is generated from the syntax. Finally, these constraints are solved. Safety analysis and type inference differ in the domain over which constraints are specified, and in the manner in which these are generated from the syntax. In a previous paper <ref> [18] </ref> we successfully applied safety analysis to a substantial subset of the object-oriented language Smalltalk [8], demonstrating how to deal with inheritance, assignments, conditionals, late binding, etc. 3.1 The Basic Safety Analysis In the remaining we consider a fixed lambda term E 0 .
Reference: [19] <author> Peter Sestoft. </author> <title> Replacing function parameters by global variables. </title> <booktitle> In Proc. Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 39-53, </pages> <year> 1989. </year>
Reference-contexts: We propose another technique which we shall simply call safety analysis; it is based on closure analysis (also called control flow analysis) <ref> [11, 19, 3, 20] </ref> and does not perform a type reconstruction. We prove that this new technique is sound and that it accepts strictly more safe lambda terms than does type inference for simple types. <p> running example in the following section. 4 Constraints: [[y:y0]] = [[x:x]] ! [[(y:y0)(x:x)]] [[x:x]] = [[x]] ! [[x]] [[y]] = [[0]] ! [[y0]] Solution: [[(y:y0)(x:x)]] = [[y0]] = [[0]] = [[x]] = Int [[y:y0]] = (Int ! Int) ! Int 3 Safety Analysis Safety analysis is based on closure analysis <ref> [19, 3] </ref> (also called control flow analysis by Jones [11] and Shivers [20]). The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate [11, 19, 3, 20]. <p> The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate <ref> [11, 19, 3, 20] </ref>. The basic form of safety analysis, which we present first, is simply a closure analysis that does appropriate safety checks. This safety analysis is essentially the one used in the Similix partial evaluator [3].
Reference: [20] <author> Olin Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, CMU, </type> <month> May </month> <year> 1991. </year> <month> CMU-CS-91-145. </month>
Reference-contexts: We propose another technique which we shall simply call safety analysis; it is based on closure analysis (also called control flow analysis) <ref> [11, 19, 3, 20] </ref> and does not perform a type reconstruction. We prove that this new technique is sound and that it accepts strictly more safe lambda terms than does type inference for simple types. <p> [[(y:y0)(x:x)]] [[x:x]] = [[x]] ! [[x]] [[y]] = [[0]] ! [[y0]] Solution: [[(y:y0)(x:x)]] = [[y0]] = [[0]] = [[x]] = Int [[y:y0]] = (Int ! Int) ! Int 3 Safety Analysis Safety analysis is based on closure analysis [19, 3] (also called control flow analysis by Jones [11] and Shivers <ref> [20] </ref>). The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate [11, 19, 3, 20]. <p> The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate <ref> [11, 19, 3, 20] </ref>. The basic form of safety analysis, which we present first, is simply a closure analysis that does appropriate safety checks. This safety analysis is essentially the one used in the Similix partial evaluator [3].
Reference: [21] <author> Satish Thatte. </author> <title> Type inference with partial types. </title> <booktitle> In Proc. International Colloquium on Automata, Languages, and Programming 1988, </booktitle> <pages> pages 615-629. </pages> <publisher> Springer-Verlag (LNCS 317), </publisher> <year> 1988. </year>
Reference-contexts: We hope to use the techniques presented here to formally compare the quality of these analyses. There are other type systems for the lambda calculus, for which type inference is possible. In particular, we think of partial types <ref> [21, 17, 14] </ref> and simple intersection types [5]. Neither encompasses constants in its present form, but this should be easy to remedy. We hope to extend figure 2 by proving more containment results involving these systems. Acknowledgements.
Reference: [22] <author> Mitchell Wand. </author> <title> A simple algorithm and proof for type inference. </title> <journal> Fundamentae Informaticae, </journal> <volume> X:115-122, </volume> <year> 1987. </year> <month> 26 </month>
Reference-contexts: Such expansion could similarly be performed before a safety analysis. o :: = ff j Int j o 1 ! o 2 A straightforward presentation of simple type inference, due to Wand <ref> [22] </ref>, is as follows. First, the lambda term is ff-converted so that every -bound variable is distinct. Second, a type variable [[E]] is assigned to every subterm E; these variables range over type schemes, shown in figure 3.
References-found: 22

