URL: http://mml.cs.ucla.edu/~santos/dis-rt98.ps
Refering-URL: http://mml.cs.ucla.edu/~santos/
Root-URL: http://www.cs.ucla.edu
Email: muntz-@cs.ucla.edu  
Title: An Implicitly Scalable, Fully Interactive Multimedia Storage Server  
Author: Frank Fabbrocino, Jose Renato Santos and Richard Muntz frank, santos, 
Note: This research was supported by Intel Corporation, Microsoft Research, NSF Grant IRI-9527178, and Sun Microsystems. Also with the University of Sao Paulo, Brazil, his research is partially supported by a fellowship from CNPq.  
Affiliation: Multimedia Laboratory UCLA Computer Science Department  
Abstract: We are developing a next generation multimedia server that provides fully interactive access to tremendous amounts and varieties of real-time and non real-time multimedia data by hundreds of simultaneous clients. Current multimedia servers are inadequate for this task given their support of only basic multimedia data types, inherently noninteractive access semantics and/or intrinsic scaling limitations. Our solution abandons the common use of striping and object replication, and implements a random data allocation scheme across a cluster of commodity computers. This scheme provides implicit load balancing both within and among storage nodes of the cluster while supporting virtually any multimedia data type and application access pattern. This paper presents the essential background, design and implementation, and simulation studies of the storage server component of our system. Our results show that we can guarantee with high probability that an arbitrary I/O requests can be satisfied within a small delay bound while obtaining high system utilization. Although our specific application is a real-time multimedia storage server, techniques developed here can be applied to scalability in distributed systems in general. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. Jepson, R. Liggett, and S. Friedman, </author> <title> Virtual Modeling of Urban Environments, Presence: </title> <booktitle> Teleoperators and Virtual Environments, </booktitle> <volume> Vol. 5, No. 1, </volume> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: One such application allows clients to navigate a realistic model of an urban neighborhood combining relatively simple 3D models with aerial and street level photographs and video sequences <ref> [1] </ref>. Yet another application allows scientists and doctors to explore the dynamics of virtual aneurysms using complex image processing and fluid flow analysis [2].
Reference: [2] <author> W. Karplus and M. R. Harreld, </author> <title> The Role of Virtual Environments in Clinical Medicine: Scientific Visualization, </title> <booktitle> Proceedings First Joint Conference of International Simulation Studies (CISS), </booktitle> <address> Zurich, Switzerland, </address> <year> 1994. </year>
Reference-contexts: Yet another application allows scientists and doctors to explore the dynamics of virtual aneurysms using complex image processing and fluid flow analysis <ref> [2] </ref>. Common to all multimedia applications is that the retrieval and delivery of data is subject to real-time constraints, but the interactivity requirements of next generation multimedia applications adds the element of unpredictability since clients, rather than the system, direct access.
Reference: [3] <author> M. Buddhikot, G. Parulkar, and J. Cox, </author> <title> "Design of a Large Scale Multimedia Server", </title> <booktitle> Proceedings of The conference of the Internet Society and the Joint European Networking Conference (INET'94/JENC5), </booktitle> <year> 1994 </year>
Reference-contexts: Therefore, multimedia servers which assume predictable, sequential access patterns and optimize data layout and scheduling accordingly <ref> [3, 4, 5] </ref>, will be unable to support the dynamic workload that next generation multimedia applications create. What is needed is a server that can provide strong guarantees of performance for satisfying arbitrary requests without respect to any particular application's access pattern.
Reference: [4] <author> S. Ghandeharizadeh, R. Zimmermann, W. Shi, R. Rejaie, D. Ierardi, T. Li, "Mitra: </author> <title> A Scalable Continuous Media Server", Multimedia Tools and Applications Journal, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1997. </year>
Reference-contexts: Therefore, multimedia servers which assume predictable, sequential access patterns and optimize data layout and scheduling accordingly <ref> [3, 4, 5] </ref>, will be unable to support the dynamic workload that next generation multimedia applications create. What is needed is a server that can provide strong guarantees of performance for satisfying arbitrary requests without respect to any particular application's access pattern.
Reference: [5] <author> W. Bolosky, J. Barrera, R. Draves, R. Fitzgerald, G. Gibson, M. Jones, S. Levi, N. Myhrvold, and R. Rashid, </author> <title> "The Tiger Video Fileserver", </title> <booktitle> Sixth International Workshop on Network and Operating System Support for Digital Audio and Video (NOSDAV), </booktitle> <year> 1996. </year>
Reference-contexts: Therefore, multimedia servers which assume predictable, sequential access patterns and optimize data layout and scheduling accordingly <ref> [3, 4, 5] </ref>, will be unable to support the dynamic workload that next generation multimedia applications create. What is needed is a server that can provide strong guarantees of performance for satisfying arbitrary requests without respect to any particular application's access pattern.
Reference: [6] <author> G. P. Pfister, </author> <title> In Search of Clusters: The Ongoing Battle in Lowly Parallel Computing, </title> <publisher> Prentice Hall, </publisher> <year> 1998. </year>
Reference-contexts: For clustering, we briefly detail the specific challenges for building a scalable next generation multimedia server. For striping and object replication, we explain why they fail to provide the performance and scalability necessary under the increased and unpredictable workload of future multimedia applications. 2.1 Clustering Clustering <ref> [6] </ref> is an attempt to provide the equivalent computing power of larger computers through the combination of many smaller, relatively inexpensive computers.
Reference: [7] <author> D. A. Patterson, G. Gibson and R. H. Katz, </author> <title> A Case for Redundant Arrays of Inexpensive Disks (RAID), </title> <booktitle> SIGMOD 88, </booktitle> <year> 1988. </year>
Reference-contexts: In the same way that RAID <ref> [7] </ref> provides higher levels of performance and availability, clustered systems also have the potential to provide higher levels of performance and reliability well beyond their monolithic counterparts. From the clients perspective however, a clustered system presents a single system image and is indistinguishable from its single machine equivalent.
Reference: [8] <author> R. Friedman and D. Mosse, </author> <title> Load Balancing Schemes for High-Throughput Distributed Fault-Tolerant Servers, </title> <booktitle> Symposium on Reliable Distributed Systems, </booktitle> <year> 1997. </year>
Reference-contexts: Unfortunately, the communication latency between nodes in a cluster impacts the systems ability to efficiently balance the workload, accurately present a single system image to clients, and outperform and out-scale a monolithic system <ref> [8] </ref>.
Reference: [9] <author> B. Ozden, R. Rastogi and A. Silberschatz, </author> <title> "Disk Striping in Video Server Environments", </title> <booktitle> IEEE International Conference on Multimedia Computing and Systems, </booktitle> <year> 1996. </year>
Reference-contexts: implemented as a clustered system, it is crucial for performance and scalability that synchronization and communication between nodes be minimized, and that the workload be evenly distributed among nodes in the cluster. 2.2 Striping Most conventional multimedia systems stripe data across multiple disks for the aggregate bandwidth and load balancing <ref> [9] </ref>. Client requests are processed in cycles of constant duration, wherein data read in one cycle is transmitted to clients in the next. Furthermore, the system carefully schedules disk accesses to balance the load across all disks of the system.
Reference: [10] <author> S. Ghandeharizadeh, S. H. Kim, W. Shi, and R. Zimmermann, </author> <title> On Minimizing Startup Latency in Scalable Continuous Media Servers", </title> <booktitle> Multimedia Computing and Networking 1997, </booktitle> <month> February </month> <year> 1997. </year>
Reference-contexts: For example, most systems that utilize striping support only constant-bit-rate video, since variable-bit-rate video would introduce fluctuations in the resource utilization of each stream. Furthermore, client interactivity is limited since synchronized cycles can introduce potentially intolerable delays <ref> [10] </ref> under a dynamic workload. Finally, because of the variability of disk overhead, the length of a cycle is usually set large enough to ensure that all disk accesses are completed by the end of the cycle.
Reference: [11] <author> A. Bestavros, </author> <title> "Demand-Based Document Dissemination to Reduce Traffic and Balance Load in Distributed Information Systems", </title> <booktitle> Proceedings of SPDP'95: The 7th IEEE Symposium on Parallel and Distributed Processing, </booktitle> <address> San Antonio, Texas, </address> <year> 1995. </year>
Reference-contexts: Clients now have a choice of nodes to connect to and some amount of load balancing can be obtained. A few multimedia systems even incorporate dynamic/predictive object replication algorithms that try to ensure that only the most popular objects are replicated <ref> [11, 12] </ref>. Unfortunately, the benefit of object replication is limited because the popularity of an object is not constant.
Reference: [12] <author> C. Shahabi, M. H. Alshayeji and S. Wang, </author> <title> A Redundant Hierarchical Structure for a Distributed Continuous Media Server, </title> <booktitle> Proceedings of the IDMS'97, </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: Clients now have a choice of nodes to connect to and some amount of load balancing can be obtained. A few multimedia systems even incorporate dynamic/predictive object replication algorithms that try to ensure that only the most popular objects are replicated <ref> [11, 12] </ref>. Unfortunately, the benefit of object replication is limited because the popularity of an object is not constant.
Reference: [13] <author> S. Berson, R. R. Muntz and W. R. Wong, </author> <title> Randomized Data Allocation for Real-Time Disk I/O, </title> <booktitle> Compcon 96, </booktitle> <year> 1995. </year>
Reference-contexts: The foundation of our multimedia server provides us with implicit scalability independent of the multimedia data type and access pattern, while providing the dynamic real-time scheduling that interactivity requires. Somewhat paradoxically, our randomized data allocation scheme, or RIO for Randomized I/O <ref> [13, 14] </ref>, divides multimedia objects into blocks that are randomly distributed across all disks in the system so that the request workload will be balanced over time. Unfortunately, RIO provides good load balancing in the long term, but may not load balance well over small intervals of time.
Reference: [14] <author> R. Muntz, J. R. Santos and S. Berson, </author> <title> A Parallel Disk Storage System for Realtime Multimedia Applications, </title> <note> To appear in International Journal of Intelligent Sciences, Special Issue on Multimedia Computing Systems, </note> <year> 1998. </year>
Reference-contexts: The foundation of our multimedia server provides us with implicit scalability independent of the multimedia data type and access pattern, while providing the dynamic real-time scheduling that interactivity requires. Somewhat paradoxically, our randomized data allocation scheme, or RIO for Randomized I/O <ref> [13, 14] </ref>, divides multimedia objects into blocks that are randomly distributed across all disks in the system so that the request workload will be balanced over time. Unfortunately, RIO provides good load balancing in the long term, but may not load balance well over small intervals of time. <p> When a client requests a block that is replicated, the system retrieves the copy of the block that resides on the least-loaded of the two disks. Simulation studies in <ref> [14] </ref> show that with a properly chosen replication fraction, system utilization of over 90% can be obtained with a very low probabilityone in a million of violating the real-time continuous media requirement. <p> Two queues for provided for incoming requests, one for real-time requests and another for non real-time requests. Each StorageManager instance in parallel periodically processes a maximum number of requests from both queues by invoking operations on its StorageDevice. Requests are processed according to the RTSCAN <ref> [14] </ref> algorithm, where a group of requests are ordered in an alternating elevator scan sequence to amortize disk overhead. 4 4.3 StorageServer A StorageServer accepts and distributes incoming block I/O requests for all StorageManagers at a storage node and transmits read data blocks to the requesting SessionAgents. <p> Given the interactivity and scalability goals of the system, many system parameters have to be obtained empirically since we want to provide strong statistical guarantees of performance. To validate our simulator, we compared in <ref> [14] </ref> the performance results obtained with experimental performance data from our "monolithic" implementation. For brevity, we do not reproduce the results here. However, we observed that the simulation results are very close to the experimental results, confirming that our simulation is modeling the system performance and disk behavior adequately. <p> We thus estimate the delay bound from the histogram obtained in each simulation and plot this value as a function of the system load. 5.2 Single Node Performance In this section we summarize previous performance results obtained by simulating a single node system in <ref> [14] </ref> to provide a basis for studying the performance in our clustered implementation.
Reference: [15] <author> D. L. Eager, E. D. Lazowska and J. Zahorjan, </author> <title> Adaptive Load Sharing in Homogeneous Distributed Systems, </title> <journal> IEEE Transactions on Software Engineering, </journal> <year> 1986. </year>
Reference-contexts: We explore this topic more in Section 5.4. The problem of routing requests to the least loaded server for load balancing has been studied in the context of distributed systems <ref> [15, 16] </ref>. In [17], it is shown that most of the improvement in load balancing occurs when there are exactly two choices. Although our system provides two types of block replication, a block is replicated using either intra-node or internode replication.
Reference: [16] <author> R. Friedman and D. Mosse, </author> <title> Load Balancing Schemes for High-Throughput Distributed Fault-Tolerant Servers, </title> <booktitle> Symposium on Reliable Distributed Systems, </booktitle> <year> 1997. </year>
Reference-contexts: We explore this topic more in Section 5.4. The problem of routing requests to the least loaded server for load balancing has been studied in the context of distributed systems <ref> [15, 16] </ref>. In [17], it is shown that most of the improvement in load balancing occurs when there are exactly two choices. Although our system provides two types of block replication, a block is replicated using either intra-node or internode replication.
Reference: [17] <author> M. D. Mitzenmacher, </author> <title> The Power of Two Choices in Randomized Load Balancing, </title> <type> Ph.D. Dissertation, </type> <institution> University of California at Berkeley, Computer Science Department, </institution> <year> 1996. </year>
Reference-contexts: We explore this topic more in Section 5.4. The problem of routing requests to the least loaded server for load balancing has been studied in the context of distributed systems [15, 16]. In <ref> [17] </ref>, it is shown that most of the improvement in load balancing occurs when there are exactly two choices. Although our system provides two types of block replication, a block is replicated using either intra-node or internode replication.
Reference: [18] <author> Microsoft Corporation, </author> <title> The Component Object Model Specification, </title> <note> Version 0.9, </note> <month> October </month> <year> 1995. </year>
Reference-contexts: All high level components in the RIO Storage Server are implemented as COM <ref> [18] </ref> objects.
Reference: [19] <author> C. Yoshikawa, B. Chun, P. Eastham, A. Vahdat, T. Anderson, and D. Culler, </author> <title> Using Smart Clients to Build Scalable Services, </title> <booktitle> Proceedings of the USENIX 1997 Annual Technical Conference, </booktitle> <year> 1997. </year>
Reference-contexts: For the system to support new types of multimedia applications only a new implementation of the SessionAgent needs to be developedthe remainder of the system remains unchanged. Preferably, the SessionAgent instance runs on the client machine <ref> [19] </ref>, but may run on another node of the system if necessary. 5 5 Simulation Studies In this section we present simulation results for the clustered implementation of the RIO Storage Server.
Reference: [20] <author> R. Tewari, R. Mukherjee and D. Dias, </author> <title> Design and Performance Tradeoffs in Clustered Video Servers, </title> <booktitle> International Conference on Multimedia Computing and Systems, </booktitle> <year> 1996. </year>
Reference-contexts: However, <ref> [20] </ref> and [21] both present schemes for multimedia servers that utilize random data placement. In [20], issues in clustered storage servers are explored using queuing system models. <p> However, <ref> [20] </ref> and [21] both present schemes for multimedia servers that utilize random data placement. In [20], issues in clustered storage servers are explored using queuing system models. The authors note that although random placement provides long-term load balancing, short-term imbalance is possible, but they do not consider the use of replication as a means of addressing short-term imbalance.
Reference: [21] <author> J. Korst, </author> <title> Random Duplicated Assignment: An Alternative to Striping in Video Servers, </title> <booktitle> Proceedings of ACM Multimedia, </booktitle> <year> 1997. </year>
Reference-contexts: However, [20] and <ref> [21] </ref> both present schemes for multimedia servers that utilize random data placement. In [20], issues in clustered storage servers are explored using queuing system models. <p> The authors note that although random placement provides long-term load balancing, short-term imbalance is possible, but they do not consider the use of replication as a means of addressing short-term imbalance. Furthermore, they assume simple clients with sequential access semantics. In <ref> [21] </ref>, the author proposes the use of replicated, randomly distributed blocks as a means of obtaining higher performance, reliability and scalability. The system proposed proceeds in rounds wherein a set number of blocks are retrieved from each disk.
References-found: 21

