URL: ftp://ftp.cs.caltech.edu/tr/cs-tr-93-15.ps.Z
Refering-URL: ftp://ftp.cs.caltech.edu/tr/INDEX.html
Root-URL: http://www.cs.caltech.edu
Title: Multicomputer Programming  
Note: with Modula-3D  
Abstract: K. Rustan M. Leino Department of Computer Science California Institute of Technology Pasadena, CA 91125, U.S.A. rustan@cs.caltech.edu 4 June 1993 Abstract In this note, we extend an object-oriented language to support programming fine-grain multicomputers. The new constructs have a simple semantics and provide a nice way to write distributed programs. The semantics of the constructs are independent of how a program is distributed. We also show a set of simple conditions under which even the outcome of a program is independent of how its control and data are distributed. We show some strengths and weaknesses of the programming model, and describe and critique our implementation of the language. 
Abstract-found: 1
Intro-found: 1
Reference: [0] <author> Henri E. Bal, Andrew S. Tanenbaum, and M. Frans Kaashoek. Orca: </author> <title> A language for distributed programming. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(5) </volume> <pages> 17-24, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: This language does not provide inheritance, so one may argue that, in spite of its name, POOL is not really an object-oriented language. In POOL, every object corresponds to a process; here, we treat these two separately. Orca (see <ref> [0] </ref>) is another language that uses "shared data-objects". As with POOL, Orca does not feature inheritance, which we will demonstrate to be useful. <p> Invocations of a method are suspended while the method is in the passive state. This mechanism allows conditions to be used, but the conditions cannot be functions of the parameters of a particular method invocation. A more flexible approach is taken in Orca (see <ref> [0] </ref>), where a method (called an operation may contain a guard statement. The guard statement allows a programmer to specify the conditions under which the operation may be executed. When executed, the operation is executed atomically.
Reference: [1] <author> Nanette Boden. </author> <title> Run-time systems for fine-grain multi-computers. </title> <type> Technical Report Caltech-CS-TR-92-10, </type> <institution> California Institute of Technology, </institution> <year> 1993. </year> <type> PhD thesis. </type>
Reference-contexts: For example, if a NEW request is received by a processor with only a small amount of free memory, the request can be forwarded to some other processor with more memory. A related scheme is explored in Madre (see <ref> [1] </ref>). Chapter 4 Conclusion We have presented for an object-oriented language some extensions that support programming fine-grain multicomputers. We have applied these to Modula-3, creating a new language, Modula-3D. We presented the language definition, and remarked on some of the language definition decisions we made and on what we rejected.
Reference: [2] <author> Per Brinch Hansen. </author> <title> Structured multiprogramming. </title> <journal> Communications of the ACM, </journal> <volume> 15(7) </volume> <pages> 574-578, </pages> <month> July </month> <year> 1972. </year>
Reference-contexts: In POOL, every object corresponds to a process; here, we treat these two separately. Orca (see [0]) is another language that uses "shared data-objects". As with POOL, Orca does not feature inheritance, which we will demonstrate to be useful. Using a variation of conditional critical regions (see <ref> [12, 2, 3, 4] </ref>) instead of Modula-3D's monitor-like constructs (see [13, 4, 14, 5, 23]), Orca offers a simpler means of guarding atomic statements. However, the language does not allow interaction between objects to be done atomically, a feature we deem essential. <p> The guard statement allows a programmer to specify the conditions under which the operation may be executed. When executed, the operation is executed atomically. This, a form of conditional critical regions (see <ref> [12, 2, 3, 4] </ref>), is a nice feature. However, all operations in Orca are atomic, so performing complex tasks involving several objects is not possible.
Reference: [3] <author> Per Brinch Hansen. </author> <title> Concurrent programming concepts. </title> <journal> ACM Computing Surveys, </journal> <volume> 5(4) </volume> <pages> 223-245, </pages> <month> De-cember </month> <year> 1973. </year>
Reference-contexts: In POOL, every object corresponds to a process; here, we treat these two separately. Orca (see [0]) is another language that uses "shared data-objects". As with POOL, Orca does not feature inheritance, which we will demonstrate to be useful. Using a variation of conditional critical regions (see <ref> [12, 2, 3, 4] </ref>) instead of Modula-3D's monitor-like constructs (see [13, 4, 14, 5, 23]), Orca offers a simpler means of guarding atomic statements. However, the language does not allow interaction between objects to be done atomically, a feature we deem essential. <p> The guard statement allows a programmer to specify the conditions under which the operation may be executed. When executed, the operation is executed atomically. This, a form of conditional critical regions (see <ref> [12, 2, 3, 4] </ref>), is a nice feature. However, all operations in Orca are atomic, so performing complex tasks involving several objects is not possible.
Reference: [4] <author> Per Brinch Hansen. </author> <booktitle> Operating systems principles. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1973. </year>
Reference-contexts: In POOL, every object corresponds to a process; here, we treat these two separately. Orca (see [0]) is another language that uses "shared data-objects". As with POOL, Orca does not feature inheritance, which we will demonstrate to be useful. Using a variation of conditional critical regions (see <ref> [12, 2, 3, 4] </ref>) instead of Modula-3D's monitor-like constructs (see [13, 4, 14, 5, 23]), Orca offers a simpler means of guarding atomic statements. However, the language does not allow interaction between objects to be done atomically, a feature we deem essential. <p> Orca (see [0]) is another language that uses "shared data-objects". As with POOL, Orca does not feature inheritance, which we will demonstrate to be useful. Using a variation of conditional critical regions (see [12, 2, 3, 4]) instead of Modula-3D's monitor-like constructs (see <ref> [13, 4, 14, 5, 23] </ref>), Orca offers a simpler means of guarding atomic statements. However, the language does not allow interaction between objects to be done atomically, a feature we deem essential. Chapter 1 Language Extensions In this chapter, we present the language extensions. <p> DO Thread.Wait ( buf.mu, buf.notEmpty ) END; x := buf.a [ buf.nextGet ]; buf.nextGet := ( buf.nextGet + 1 ) MOD NUMBER ( buf.a^ ); DEC ( buf.n ); Thread.Signal ( buf.notFull ) END; RETURN x END Get; The Put and Get procedures use monitor mutex and condition variables (see <ref> [13, 4, 14, 5, 23] </ref>) to do the synchronization. Objects of type Buffer are used the same way, be they on the local or on a remote processor. The element type of this buffer implementation is INTEGER. For writing a general implementation of Buffer, Modula-3D features generics. <p> The guard statement allows a programmer to specify the conditions under which the operation may be executed. When executed, the operation is executed atomically. This, a form of conditional critical regions (see <ref> [12, 2, 3, 4] </ref>), is a nice feature. However, all operations in Orca are atomic, so performing complex tasks involving several objects is not possible. <p> However, all operations in Orca are atomic, so performing complex tasks involving several objects is not possible. Modula-3D provides synchronization in a more exposed way through the use of MUTEX and condition variables, a form of monitors (see <ref> [13, 4, 14, 5, 23] </ref>). Sometimes these constructs seem to involve writing more code than some of their more high-level counterparts described above. However, the step of going from a simple specification to a more involved one need not be as large as when using the counterpart features.
Reference: [5] <author> Per Brinch Hansen. </author> <title> The programming language Concurrent Pascal. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1(2):199-206, </volume> <month> June </month> <year> 1975. </year>
Reference-contexts: Orca (see [0]) is another language that uses "shared data-objects". As with POOL, Orca does not feature inheritance, which we will demonstrate to be useful. Using a variation of conditional critical regions (see [12, 2, 3, 4]) instead of Modula-3D's monitor-like constructs (see <ref> [13, 4, 14, 5, 23] </ref>), Orca offers a simpler means of guarding atomic statements. However, the language does not allow interaction between objects to be done atomically, a feature we deem essential. Chapter 1 Language Extensions In this chapter, we present the language extensions. <p> DO Thread.Wait ( buf.mu, buf.notEmpty ) END; x := buf.a [ buf.nextGet ]; buf.nextGet := ( buf.nextGet + 1 ) MOD NUMBER ( buf.a^ ); DEC ( buf.n ); Thread.Signal ( buf.notFull ) END; RETURN x END Get; The Put and Get procedures use monitor mutex and condition variables (see <ref> [13, 4, 14, 5, 23] </ref>) to do the synchronization. Objects of type Buffer are used the same way, be they on the local or on a remote processor. The element type of this buffer implementation is INTEGER. For writing a general implementation of Buffer, Modula-3D features generics. <p> However, all operations in Orca are atomic, so performing complex tasks involving several objects is not possible. Modula-3D provides synchronization in a more exposed way through the use of MUTEX and condition variables, a form of monitors (see <ref> [13, 4, 14, 5, 23] </ref>). Sometimes these constructs seem to involve writing more code than some of their more high-level counterparts described above. However, the step of going from a simple specification to a more involved one need not be as large as when using the counterpart features.
Reference: [6] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <title> Modula-3 language definition. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(8) </volume> <pages> 15-42, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Our language extensions involve types. Here, Modula-3 provides type safety. Last, but not least, for a language that provides object types and concurrency (and much more), Modula-3 is quite simple. The semantics of Modula-3 is concise and well defined. (See [23] or <ref> [6] </ref>, an exceptionally well-written report.) Since our goal is to provide something the programmer can understand, Modula-3 fits right in. An alternative starting point would have been C++. This route is chosen in, for example, Compositional C++ (see [8, 7]). <p> Chapter 1 Language Extensions In this chapter, we present the language extensions. First, we state our requirements and introduce the major ingredients of our extensions. Then, we give the precise Modula-3D definition, in terms of differences from Modula-3 (see <ref> [6] </ref> or Chapter 2 of [23]). <p> By following the conditions, a programmer can tweak the performance of a program, without changing the program's outcome, by changing the way network objects are distributed. 1.1 Modula-3D Definition In this section, we present the Modula-3D language definition in terms of the Modula-3 definition found in <ref> [6] </ref> and [23]. The section numbers shown refer to those in [6]; those in [23] are similar. 2.9 Objects After the second paragraph, add the paragraph: If the type is a subtype of NETWORK, it is said to be a network object type. <p> tweak the performance of a program, without changing the program's outcome, by changing the way network objects are distributed. 1.1 Modula-3D Definition In this section, we present the Modula-3D language definition in terms of the Modula-3 definition found in <ref> [6] </ref> and [23]. The section numbers shown refer to those in [6]; those in [23] are similar. 2.9 Objects After the second paragraph, add the paragraph: If the type is a subtype of NETWORK, it is said to be a network object type. Variables of such types are called network objects.
Reference: [7] <author> Peter Carlin, K. Mani Chandy, and Carl Kesselman. </author> <title> The CC++ language definition. </title> <type> Technical Report Caltech-CS-TR-92-02, </type> <institution> California Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: An alternative starting point would have been C++. This route is chosen in, for example, Compositional C++ (see <ref> [8, 7] </ref>). However, as C++ is, for one, not a simple language (see [10]), our results are not going to be simple either. A different version of network objects has been implemented at the DEC Systems Research Center (see [32]). <p> Using a select statement to implement such a buffer then requires a put and a get channel per stream. (If the channels are point-to-point, then every stream needs as many get and put channels as there are readers and writers.) Other languages like Compositional C++ <ref> [8, 7] </ref> feature atomic methods as a means of providing exclusive access to objects. This may reduce the complexity of some tasks as it provides an implicit MUTEX in every object and an implicit LOCK statement in each atomic method.
Reference: [8] <author> K. Mani Chandy and Carl Kesselman. </author> <title> CC++: A declarative concurrent object-oriented programming notation. </title> <type> Technical Report Caltech-CS-TR-92-01, </type> <institution> California Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: An alternative starting point would have been C++. This route is chosen in, for example, Compositional C++ (see <ref> [8, 7] </ref>). However, as C++ is, for one, not a simple language (see [10]), our results are not going to be simple either. A different version of network objects has been implemented at the DEC Systems Research Center (see [32]). <p> Using a select statement to implement such a buffer then requires a put and a get channel per stream. (If the channels are point-to-point, then every stream needs as many get and put channels as there are readers and writers.) Other languages like Compositional C++ <ref> [8, 7] </ref> feature atomic methods as a means of providing exclusive access to objects. This may reduce the complexity of some tasks as it provides an implicit MUTEX in every object and an implicit LOCK statement in each atomic method.
Reference: [9] <author> Dave Detlefs and Greg Nelson. </author> <title> Private communications on extended static checking, </title> <year> 1992, 1993. </year>
Reference-contexts: Hence, no instructions for writing back values stored in registers prior to the call are necessary. A more advanced feature of the compiler, or auxiliary tool, is to establish a proof of that some particular run-time checks are not needed. This is attempted in <ref> [9] </ref>, and would be a nice addition to the compiler. We have discussed that the entire run-time system is always present in memory, and that several parts of the run-time system are never used by some programs.
Reference: [10] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1990. </year>
Reference-contexts: An alternative starting point would have been C++. This route is chosen in, for example, Compositional C++ (see [8, 7]). However, as C++ is, for one, not a simple language (see <ref> [10] </ref>), our results are not going to be simple either. A different version of network objects has been implemented at the DEC Systems Research Center (see [32]). These are implemented in Modula-3, and are more general than those presented here; for example, objects may be shared between different programs.
Reference: [11] <author> Marcel R. van der Goot. </author> <title> Multicomputer C user manual. </title> <type> Technical Report Caltech-CS-TR-93-17, </type> <institution> California Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: As clustered communications cannot, in general, be detected by a compiler, it is nice if the programming language provides some construct with which to identify these. An example of a construct for this is parallel communication composition, written //, in mcc (see <ref> [11] </ref>). Modula-3D does not attempt to address this issue. To execute clustered communications in parallel, one needs to explicitly create one thread for each communication, and then join these threads, a clumsy solution indeed, and one in which the number of context switches has not decreased.
Reference: [12] <author> C.A.R. Hoare. </author> <title> Towards a theory of parallel programming. In C.A.R. Hoare and R.H. Perrott, editors, Operating Systems Techniques. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1972. </year> <note> 58 59- MCPwM3D BIBLIOGRAPHY </note>
Reference-contexts: In POOL, every object corresponds to a process; here, we treat these two separately. Orca (see [0]) is another language that uses "shared data-objects". As with POOL, Orca does not feature inheritance, which we will demonstrate to be useful. Using a variation of conditional critical regions (see <ref> [12, 2, 3, 4] </ref>) instead of Modula-3D's monitor-like constructs (see [13, 4, 14, 5, 23]), Orca offers a simpler means of guarding atomic statements. However, the language does not allow interaction between objects to be done atomically, a feature we deem essential. <p> The guard statement allows a programmer to specify the conditions under which the operation may be executed. When executed, the operation is executed atomically. This, a form of conditional critical regions (see <ref> [12, 2, 3, 4] </ref>), is a nice feature. However, all operations in Orca are atomic, so performing complex tasks involving several objects is not possible.
Reference: [13] <author> C.A.R. Hoare. </author> <title> A structured paging system. </title> <journal> Computer Journal, </journal> <volume> 16(3) </volume> <pages> 209-215, </pages> <year> 1973. </year>
Reference-contexts: Orca (see [0]) is another language that uses "shared data-objects". As with POOL, Orca does not feature inheritance, which we will demonstrate to be useful. Using a variation of conditional critical regions (see [12, 2, 3, 4]) instead of Modula-3D's monitor-like constructs (see <ref> [13, 4, 14, 5, 23] </ref>), Orca offers a simpler means of guarding atomic statements. However, the language does not allow interaction between objects to be done atomically, a feature we deem essential. Chapter 1 Language Extensions In this chapter, we present the language extensions. <p> DO Thread.Wait ( buf.mu, buf.notEmpty ) END; x := buf.a [ buf.nextGet ]; buf.nextGet := ( buf.nextGet + 1 ) MOD NUMBER ( buf.a^ ); DEC ( buf.n ); Thread.Signal ( buf.notFull ) END; RETURN x END Get; The Put and Get procedures use monitor mutex and condition variables (see <ref> [13, 4, 14, 5, 23] </ref>) to do the synchronization. Objects of type Buffer are used the same way, be they on the local or on a remote processor. The element type of this buffer implementation is INTEGER. For writing a general implementation of Buffer, Modula-3D features generics. <p> However, all operations in Orca are atomic, so performing complex tasks involving several objects is not possible. Modula-3D provides synchronization in a more exposed way through the use of MUTEX and condition variables, a form of monitors (see <ref> [13, 4, 14, 5, 23] </ref>). Sometimes these constructs seem to involve writing more code than some of their more high-level counterparts described above. However, the step of going from a simple specification to a more involved one need not be as large as when using the counterpart features.
Reference: [14] <author> C.A.R. Hoare. </author> <title> Monitors: an operating system structuring concept. </title> <journal> Communications of the ACM, </journal> <volume> 17(10) </volume> <pages> 549-557, </pages> <month> October </month> <year> 1974. </year>
Reference-contexts: Orca (see [0]) is another language that uses "shared data-objects". As with POOL, Orca does not feature inheritance, which we will demonstrate to be useful. Using a variation of conditional critical regions (see [12, 2, 3, 4]) instead of Modula-3D's monitor-like constructs (see <ref> [13, 4, 14, 5, 23] </ref>), Orca offers a simpler means of guarding atomic statements. However, the language does not allow interaction between objects to be done atomically, a feature we deem essential. Chapter 1 Language Extensions In this chapter, we present the language extensions. <p> DO Thread.Wait ( buf.mu, buf.notEmpty ) END; x := buf.a [ buf.nextGet ]; buf.nextGet := ( buf.nextGet + 1 ) MOD NUMBER ( buf.a^ ); DEC ( buf.n ); Thread.Signal ( buf.notFull ) END; RETURN x END Get; The Put and Get procedures use monitor mutex and condition variables (see <ref> [13, 4, 14, 5, 23] </ref>) to do the synchronization. Objects of type Buffer are used the same way, be they on the local or on a remote processor. The element type of this buffer implementation is INTEGER. For writing a general implementation of Buffer, Modula-3D features generics. <p> However, all operations in Orca are atomic, so performing complex tasks involving several objects is not possible. Modula-3D provides synchronization in a more exposed way through the use of MUTEX and condition variables, a form of monitors (see <ref> [13, 4, 14, 5, 23] </ref>). Sometimes these constructs seem to involve writing more code than some of their more high-level counterparts described above. However, the step of going from a simple specification to a more involved one need not be as large as when using the counterpart features.
Reference: [15] <author> C.A.R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference-contexts: Note that Buffer allows any number of threads to invoke the put and get methods of a Buffer object. Hence, this aspect of Buffer is more versatile than point-to-point channels provided by some other languages (see e.g. <ref> [15, 22, 16, 20] </ref>). The efficiency of a program that uses buffers may depend on the slack. Thus, using a different value for the size parameter to init provides a way to tune the performance of a program using Buffer. <p> The example we use is a standard parallel programming problem, namely that of generating prime numbers by means of the sieve of Eratosthenes (see, for example, <ref> [15] </ref>). We will make use of type Buffer as defined in Section 2.0. Specifically, the problem is to create a PrimeConsumer object, to invoke its consume method for each prime in the range 2..Max, where Max is a constant at least 2, and then to invoke its end method.
Reference: [16] <editor> INMOS Limited, </editor> <publisher> Prentice-Hall Int., </publisher> <address> Englewood Cliffs, NJ. </address> <note> Occam Programming Manual, </note> <year> 1984. </year>
Reference-contexts: Note that Buffer allows any number of threads to invoke the put and get methods of a Buffer object. Hence, this aspect of Buffer is more versatile than point-to-point channels provided by some other languages (see e.g. <ref> [15, 22, 16, 20] </ref>). The efficiency of a program that uses buffers may depend on the slack. Thus, using a different value for the size parameter to init provides a way to tune the performance of a program using Buffer.
Reference: [17] <author> M.F. Kaashoek. </author> <title> Group Communication in Distributed Computer Systems. </title> <type> PhD thesis, </type> <institution> Vrije Universiteit, </institution> <year> 1992. </year>
Reference-contexts: The scarce memory of a fine-grain multicomputer suggests keeping only one copy of the data record of each network object. This differs from, for example, <ref> [17] </ref>. As described earlier, this also avoids cache consistency related problems. Consequently, Modula-3D defines the notion of local and remote objects. To facilitate the creation of remote network objects, Modula-3D features a remote NEW call, NEW (T, Processor, Bindings) . Several choices were made in defining this call.
Reference: [18] <author> G. Le Lann. </author> <title> Distributed systems, towards a formal approach. </title> <booktitle> In IFIP Congress, </booktitle> <pages> pages 155-160, </pages> <year> 1977. </year>
Reference-contexts: However, when using a distributed memory machine, one may still want to implement mutual exclusion in a distributed way to avoid the bottleneck of having a MUTEX on one processor. One way to do this is in a token ring. We describe a solution, referred to as perpetuum mobile <ref> [21, 18] </ref>. The scenario is that of having some number of servers and an equal number of clients. The servers are connected in a ring, and each client is connected with a unique server.
Reference: [19] <author> K. Rustan M. Leino. </author> <title> Extensions to an object-oriented programming language for programming fine-grain multicomputers. </title> <type> Technical Report Caltech-CS-TR-92-26, </type> <institution> California Institute of Technology, </institution> <year> 1992. </year>
Reference: [20] <author> Johan J. Lukkien and Jan L.A. van de Snepscheut. </author> <title> A tutorial introduction to Mosaic Pascal. </title> <type> Technical Report Caltech-CS-TR-91-02, </type> <institution> California Institute of Technology, </institution> <year> 1991. </year>
Reference-contexts: Note that Buffer allows any number of threads to invoke the put and get methods of a Buffer object. Hence, this aspect of Buffer is more versatile than point-to-point channels provided by some other languages (see e.g. <ref> [15, 22, 16, 20] </ref>). The efficiency of a program that uses buffers may depend on the slack. Thus, using a different value for the size parameter to init provides a way to tune the performance of a program using Buffer.
Reference: [21] <author> Alain J. Martin. </author> <title> Distributed mutual exclusion on a ring of processes. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 5 </volume> <pages> 265-276, </pages> <year> 1985. </year>
Reference-contexts: However, when using a distributed memory machine, one may still want to implement mutual exclusion in a distributed way to avoid the bottleneck of having a MUTEX on one processor. One way to do this is in a token ring. We describe a solution, referred to as perpetuum mobile <ref> [21, 18] </ref>. The scenario is that of having some number of servers and an equal number of clients. The servers are connected in a ring, and each client is connected with a unique server.
Reference: [22] <author> David May. </author> <title> OCCAM. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 18(4) </volume> <pages> 69-79, </pages> <month> April </month> <year> 1983. </year>
Reference-contexts: Note that Buffer allows any number of threads to invoke the put and get methods of a Buffer object. Hence, this aspect of Buffer is more versatile than point-to-point channels provided by some other languages (see e.g. <ref> [15, 22, 16, 20] </ref>). The efficiency of a program that uses buffers may depend on the slack. Thus, using a different value for the size parameter to init provides a way to tune the performance of a program using Buffer.
Reference: [23] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Our language extensions involve types. Here, Modula-3 provides type safety. Last, but not least, for a language that provides object types and concurrency (and much more), Modula-3 is quite simple. The semantics of Modula-3 is concise and well defined. (See <ref> [23] </ref> or [6], an exceptionally well-written report.) Since our goal is to provide something the programmer can understand, Modula-3 fits right in. An alternative starting point would have been C++. This route is chosen in, for example, Compositional C++ (see [8, 7]). <p> Orca (see [0]) is another language that uses "shared data-objects". As with POOL, Orca does not feature inheritance, which we will demonstrate to be useful. Using a variation of conditional critical regions (see [12, 2, 3, 4]) instead of Modula-3D's monitor-like constructs (see <ref> [13, 4, 14, 5, 23] </ref>), Orca offers a simpler means of guarding atomic statements. However, the language does not allow interaction between objects to be done atomically, a feature we deem essential. Chapter 1 Language Extensions In this chapter, we present the language extensions. <p> Chapter 1 Language Extensions In this chapter, we present the language extensions. First, we state our requirements and introduce the major ingredients of our extensions. Then, we give the precise Modula-3D definition, in terms of differences from Modula-3 (see [6] or Chapter 2 of <ref> [23] </ref>). <p> By following the conditions, a programmer can tweak the performance of a program, without changing the program's outcome, by changing the way network objects are distributed. 1.1 Modula-3D Definition In this section, we present the Modula-3D language definition in terms of the Modula-3 definition found in [6] and <ref> [23] </ref>. The section numbers shown refer to those in [6]; those in [23] are similar. 2.9 Objects After the second paragraph, add the paragraph: If the type is a subtype of NETWORK, it is said to be a network object type. Variables of such types are called network objects. <p> of a program, without changing the program's outcome, by changing the way network objects are distributed. 1.1 Modula-3D Definition In this section, we present the Modula-3D language definition in terms of the Modula-3 definition found in [6] and <ref> [23] </ref>. The section numbers shown refer to those in [6]; those in [23] are similar. 2.9 Objects After the second paragraph, add the paragraph: If the type is a subtype of NETWORK, it is said to be a network object type. Variables of such types are called network objects. <p> DO Thread.Wait ( buf.mu, buf.notEmpty ) END; x := buf.a [ buf.nextGet ]; buf.nextGet := ( buf.nextGet + 1 ) MOD NUMBER ( buf.a^ ); DEC ( buf.n ); Thread.Signal ( buf.notFull ) END; RETURN x END Get; The Put and Get procedures use monitor mutex and condition variables (see <ref> [13, 4, 14, 5, 23] </ref>) to do the synchronization. Objects of type Buffer are used the same way, be they on the local or on a remote processor. The element type of this buffer implementation is INTEGER. For writing a general implementation of Buffer, Modula-3D features generics. <p> However, all operations in Orca are atomic, so performing complex tasks involving several objects is not possible. Modula-3D provides synchronization in a more exposed way through the use of MUTEX and condition variables, a form of monitors (see <ref> [13, 4, 14, 5, 23] </ref>). Sometimes these constructs seem to involve writing more code than some of their more high-level counterparts described above. However, the step of going from a simple specification to a more involved one need not be as large as when using the counterpart features.
Reference: [24] <author> Greg Nelson. </author> <title> Private communications, </title> <year> 1992. </year>
Reference-contexts: It turns out that Modula-3 allows for either extension, but we felt the former resulted in a language easier to understand for the programmer, so that is what we chose for Modula-3D. The rest of this section describes and discusses the latter of the two alternatives|a suggestion due to <ref> [24] </ref> and a solution similar to the one chosen in [32]. As the details of this alternative are quite intricate, a non-expert reader may want to skip the rest of this section on a first reading. <p> The client does not send this acknowledgement until the host has updated the reference count to include the new surrogate. This, in turn, is ensured by suspending the thread on the client until the host sends back an acknowledgement of the new-surrogate message. (This scheme is due to <ref> [24] </ref>.) Finally, when a local garbage collector reclaims the storage of a surrogate object, it notifies the host which then decrements the reference count. 3.1. MOSAIC MODULA-3D MCPwM3D -36 3.1 Mosaic Modula-3D Mosaic Modula-3D consists of a compiler, a (pre-)linker, and a run-time system.
Reference: [25] <author> E.A.M. Odijk. </author> <title> The DOOM system and its applications: a survey of ESPRIT 415 subproject A. </title> <booktitle> In PARLE 87, volume 258 of Lecture Notes in Computer Science, </booktitle> <pages> pages 461-479. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: For example, more types are needed, and network objects are created differently from other objects. Another attempt at combining object-oriented and concurrent programming is the Parallel Object-Oriented Language, POOL (see <ref> [25] </ref>). This language does not provide inheritance, so one may argue that, in spite of its name, POOL is not really an object-oriented language. In POOL, every object corresponds to a process; here, we treat these two separately. Orca (see [0]) is another language that uses "shared data-objects".
Reference: [26] <author> Charles L. Seitz. </author> <title> Concurrent VLSI architectures. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-33(12):1247-1265, </volume> <month> December </month> <year> 1984. </year>
Reference: [27] <author> Charles L. Seitz. </author> <title> The cosmic cube. </title> <journal> Communications of the ACM, </journal> <volume> 28(1) </volume> <pages> 22-33, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Typical interprocessor communication operations provided by languages used to program such machines are send and receive. Forcing the programmer to deal with the details of each communication, these operations hinder the programmer from thinking about good and nice solutions for the problem at hand. As <ref> [27] </ref> states it, "because we have tacked these primitives onto programming languages simply as external functions, the process code is unnecessarily baroque." Instead, by providing in a programming language a different means of doing interprocessor communication, one can return the programmer's attention to the problem at hand.
Reference: [28] <author> Charles L. Seitz. </author> <title> Mosaic C: an experimental fine-grain multicomputer. </title> <editor> In Alain Bensoussan and Jean-Pierre Verjus, editors, </editor> <booktitle> Future Tendencies in Computer Science, Control, and Applied Mathematics, volume 653 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <booktitle> Proceedings of the International Conference on the Occasion of the 25th Anniversary of INRIA. </booktitle>
Reference-contexts: When writing programs for a fine-grain multicomputer, memory management is of great concern. For example, in the Caltech Mosaic multicomputer with its designed 16 K nodes (256 of which are currently present), each node has only 64 KB RAM (see <ref> [28, 30, 29] </ref>). Therefore, it is convenient to have the language, rather than the programmer, assume responsibility of heap management. Modula-3 is geared to allow language implementations to feature a garbage collector. Our language extensions involve types. Here, Modula-3 provides type safety.
Reference: [29] <author> Charles L. Seitz. </author> <title> Submicron systems architecture, </title> <type> semiannual technical report. Technical Report Caltech-CS-TR-92-17, </type> <institution> California Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: When writing programs for a fine-grain multicomputer, memory management is of great concern. For example, in the Caltech Mosaic multicomputer with its designed 16 K nodes (256 of which are currently present), each node has only 64 KB RAM (see <ref> [28, 30, 29] </ref>). Therefore, it is convenient to have the language, rather than the programmer, assume responsibility of heap management. Modula-3 is geared to allow language implementations to feature a garbage collector. Our language extensions involve types. Here, Modula-3 provides type safety.
Reference: [30] <author> Charles L. Seitz, Nanette J. Boden, Jakov Seizovic, and Wen-King Su. </author> <title> The design of the Caltech Mosaic C multicomputer. </title> <booktitle> In University of Washington Symposium on Integrated Systems, </booktitle> <month> March </month> <year> 1993. </year>
Reference-contexts: When writing programs for a fine-grain multicomputer, memory management is of great concern. For example, in the Caltech Mosaic multicomputer with its designed 16 K nodes (256 of which are currently present), each node has only 64 KB RAM (see <ref> [28, 30, 29] </ref>). Therefore, it is convenient to have the language, rather than the programmer, assume responsibility of heap management. Modula-3 is geared to allow language implementations to feature a garbage collector. Our language extensions involve types. Here, Modula-3 provides type safety.
Reference: [31] <author> Jakov N. Seizovic. </author> <title> Architecture and programming of a fine-grain multicomputer. </title> <type> Technical Report Caltech-CS-TR-93-18, </type> <institution> California Institute of Technology, </institution> <year> 1993. </year> <type> PhD thesis. </type>
Reference-contexts: However, such mechanisms do not lend themselves to writing something like Buffer.put where a condition is involved. Adding to this some flexibility, the language C+- <ref> [31] </ref> features atomic methods that have one of two states, active and passive, changeable by programs. Invocations of a method are suspended while the method is in the passive state.
Reference: [32] <institution> DEC SRC. DEC SRC network objects. </institution> <note> To be published, </note> <year> 1993. </year>
Reference-contexts: This route is chosen in, for example, Compositional C++ (see [8, 7]). However, as C++ is, for one, not a simple language (see [10]), our results are not going to be simple either. A different version of network objects has been implemented at the DEC Systems Research Center (see <ref> [32] </ref>). These are implemented in Modula-3, and are more general than those presented here; for example, objects may be shared between different programs. However, the design goals and assumptions of the DEC SRC network objects differ from ours. <p> The rest of this section describes and discusses the latter of the two alternatives|a suggestion due to [24] and a solution similar to the one chosen in <ref> [32] </ref>. As the details of this alternative are quite intricate, a non-expert reader may want to skip the rest of this section on a first reading. When a remote object of type T is created, Modula-3D specifies that the allocated type of the object returned from NEW is T. <p> The typecode of the surrogate object is the same as for the concrete object, since the type of an object is not dependent on where it resides. (This deviates from the network objects in <ref> [32] </ref>.) However, the data record and method suite of the surrogate object differ from those of the concrete object. <p> In particular, the data record needs only contain the global identifier of the concrete object, and the entries of the method suite are procedures that will cause the methods to be executed remotely. (See <ref> [32] </ref> for a variation of these surrogates.) 34 35- MCPwM3D CHAPTER 3. IMPLEMENTATION Creating a remote network object involves communication between the requesting processor (called the client) and the host. The client sends a message to the host, passing an encoding of the parameters of the NEW call.
References-found: 33

