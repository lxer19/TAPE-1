URL: http://www.cs.umass.edu/~immerman/pub/similarity.ps
Refering-URL: http://www.cs.umass.edu/~landau/alg_alg.html
Root-URL: 
Title: The Similarities (and Differences) between Polynomials and Integers  
Author: Susan Landau and Neil Immerman 
Date: August 8, 1996  
Address: Amherst, Mass. 01003  
Affiliation: Department of Computer Science University of Massachusetts  
Abstract: The purpose of this paper is to examine the two domains of the integers and the polynomials, in an attempt to understand the nature of complexity in these very basic situations. Can we formalize the integer algorithms which shed light on the polynomial domain, and vice versa? When will the casting of one in the other speed up an existing algorithm? Why do some problems not lend themselves to this kind of speed-up? We give several simple and natural theorems that show how problems in one domain can be embedded in the other, and we examine the complexity-theoretic consequences of these embeddings. We also prove several results on the impossibility of solving integer problems by mimicking their polynomial counterparts. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Adleman, C. Pomerance, R. Rumely, </author> <title> "On Distinguishing Prime Numbers from Composites," </title> <journal> Math. Ann., </journal> <volume> Vol. 117 (1983), </volume> <pages> pp. 173-206. </pages>
Reference-contexts: : : : + a 0 a n1 x n1 + : : : + a 0 , ja i j &lt; 2 c multiplication (n) [31] (nc) [28] division (n) [15] (nc) [28, 32] gcd (n) log n [27] (nc) log n [3, 28] irreducibility n log log n <ref> [1, 13] </ref> polynomial in n; c [34] factorization 2 (1=4+*)n [26, 33] n 5+* c [23] There are a number of things to note in this table.
Reference: [2] <author> L. Adleman and A. Odlyzko, </author> <title> "Irreducibility Testing and Factorization of Polynomials," </title> <journal> Math. Comp., </journal> <volume> Vol. 41 (1983), </volume> <pages> pp. 699-709. </pages>
Reference-contexts: In 1982, shortly before the Lenstra, Lenstra, Lovasz [19] polynomial time algorithm for polynomial factorization, Adleman and Odlyzko gave a reduction from polynomial irreducibility testing and factorization to integer primality testing and factorization respectively <ref> [2] </ref>. More recently, Char, Geddes and Gonnet [12], and independently, Schonhage [30], gave a fast algorithm for computing polynomial gcds which relies on computing integer gcds, and then interpolating these values to find the polynomial gcd.
Reference: [3] <author> A. Aho, J. Hopcroft and J. Ullman, </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: (x) = a n1 10 n1 + : : : + a 0 a n1 x n1 + : : : + a 0 , ja i j &lt; 2 c multiplication (n) [31] (nc) [28] division (n) [15] (nc) [28, 32] gcd (n) log n [27] (nc) log n <ref> [3, 28] </ref> irreducibility n log log n [1, 13] polynomial in n; c [34] factorization 2 (1=4+*)n [26, 33] n 5+* c [23] There are a number of things to note in this table. <p> The idea is that even after divisions the coefficients remain less than half of the new value of m. Since the degree of R is less than the degree of D it follows that j (R)j &lt; j (D)j=2, as desired. The proof is: use the algorithm from <ref> [3] </ref> (see Figure 4.1) to compute the reciprocal of D: C = bx n =Dc. The polynomial reciprocal is computed using 2 log (degree (P )) additions and the same number of multiplications. Some truncations are also performed but these of course do not increase the size of any coefficients.
Reference: [4] <author> A. Avizienis, </author> <title> "Signed-Digit Number Representations for Fast Parallel Arithmetic," </title> <journal> IRE Transactions on Electronic Computers, </journal> <volume> Vol. 10 (1961), </volume> <pages> pp. 389-400. </pages>
Reference-contexts: We need to consider how to represent negative as well as positive coefficients of the polynomial. Fortunately there is some work by Avizienis <ref> [4] </ref> on signed digit representations of integers which handles this problem. Define the map m (a 0 ; : : : ; a n1 ) = n1 5 for ja i j m. We call the notation of the right balanced mary. <p> That the second diagram commutes is well-known from the work of Avizienis <ref> [4] </ref>. To show that the first diagram commutes, it will suffice to show that we have picked m sufficiently large that there are no carries in the balanced mary arithmetic, and thus that the coefficients are acting independently. Thus the map is one to one.
Reference: [5] <author> A. Borodin, S. Cook, and N. Pippenger, </author> <title> "Parallel Computation for Well-Endowed Rings and Space-Bounded Probabilistic Machines," </title> <journal> Information and Control, </journal> <volume> 58, </volume> <year> 1983, </year> <pages> (113-136). </pages>
Reference-contexts: To go the other way is a single subtraction of mary integers, thus it is in AC 0 . The advantage of balanced mary notation is that it gives very efficient implementations of +; ; fi: Theorem 3.4 (Borodin, Cook, Pippenger) <ref> [5] </ref> Under balanced mary notation, addition and negation of integers can be implemented in NC 0 , and multiplication in N C 1 . Balanced mary notation allows us to use integers to represent polynomials in a way that easily represents both positive and negative coefficients.
Reference: [6] <author> A. Borodin and R. Moenck, </author> <title> "Fast Modular Transforms," </title> <journal> J. Comput. Sys. Sci., </journal> <volume> Vol. 8 (1973), </volume> <pages> pp. 366-386. </pages>
Reference-contexts: In 1974, Borodin and Moenck <ref> [6] </ref>, extended examples of Cabay [11], Brown [10] and Collins [14], and examined the issue of fast modular transforms (evaluating mod p for integer problems, evaluating at integer points for polynomial problems) as a general technique for algorithmic speed-up in the two domains.
Reference: [7] <author> A. Borodin and I. Munro, </author> <title> The Computational Complexity of Algebraic and Numeric Problems, </title> <publisher> American Elsevier (1975). </publisher> <pages> 20 </pages>
Reference: [8] <author> J. Brillhart, M. Filaseta and A. Odlyzko, </author> <title> "On an Irreducibility Theorem of A. Cohn," Can. </title> <journal> J. Math, </journal> <volume> Vol. 33 (1981), </volume> <pages> pp. 1055-1059. </pages>
Reference-contexts: The Prime Number Theorem states: Theorem 5.2 Let (x) be the number of primes less than x. Then lim x!1 x = 1. A surprising fact is that sometimes integer irreducibility (primality) can carry over to polynomial irreducibility. Brillhart, Filaseta and Odlyzko <ref> [8] </ref> have shown: Theorem 5.3 If a prime p is expressed in the number system with base b 2 as p = n k=0 a k b k ; 0 a k b 1, then the polynomial n k=0 a k x k is irreducible.
Reference: [9] <author> J.Brillhart, D.H.Lehmer and J.L.Selfridge, </author> <title> "New Primality Criteria and Factorizations of 2 m 1," </title> <booktitle> Mathematics of Computation Vol 29 (1975), </booktitle> <volume> No. 130, </volume> <month> pp.620-647. </month>
Reference-contexts: Such an approach was actually used in <ref> [9] </ref> to check primality of certain integers. The difficulty with this approach is that it leads to an exponential number of possibilities. This is because one or more can be borrowed from each nonzero digit, independently of all the other digits.
Reference: [10] <author> W. Brown, </author> <title> "On Euclid's Algorithm and the computation of polynomial greatest common divisors," </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> Vol. 18, </volume> <pages> pp. 478-504. </pages>
Reference-contexts: In 1974, Borodin and Moenck [6], extended examples of Cabay [11], Brown <ref> [10] </ref> and Collins [14], and examined the issue of fast modular transforms (evaluating mod p for integer problems, evaluating at integer points for polynomial problems) as a general technique for algorithmic speed-up in the two domains.
Reference: [11] <author> S. Cabay, </author> <title> "Exact Solutions of Linear Equations," </title> <booktitle> Proc. of the Second Sympositum on Symbolic and Algebraic Manipulation, </booktitle> <year> 1971. </year>
Reference-contexts: In 1974, Borodin and Moenck [6], extended examples of Cabay <ref> [11] </ref>, Brown [10] and Collins [14], and examined the issue of fast modular transforms (evaluating mod p for integer problems, evaluating at integer points for polynomial problems) as a general technique for algorithmic speed-up in the two domains.
Reference: [12] <author> B. Char, K. Geddes, and G. Gonnet, "GCDHEU: </author> <title> Heuristic Polynomial GCD Algorithm Based on Integer GCD Computation," </title> <journal> J. Symb. </journal> <volume> Com-put., </volume> <year> (1989), </year> <pages> pp. 31-45. </pages>
Reference-contexts: In 1982, shortly before the Lenstra, Lenstra, Lovasz [19] polynomial time algorithm for polynomial factorization, Adleman and Odlyzko gave a reduction from polynomial irreducibility testing and factorization to integer primality testing and factorization respectively [2]. More recently, Char, Geddes and Gonnet <ref> [12] </ref>, and independently, Schonhage [30], gave a fast algorithm for computing polynomial gcds which relies on computing integer gcds, and then interpolating these values to find the polynomial gcd. The idea of embedding polynomial arithmetic is also the basis for Schonhage's fast algorithm for polynomial multiplication and division [28]. <p> The resulting data compression enables a speed-up of the algorithm. One can make use of the fast integer problem to develop a faster technique for the polynomial problem. For example, Char, Geddes and Gonnet <ref> [12] </ref>, and Schonhage [30] computed gcds of degree n polynomials by substituting n + 1 values into the polynomials, computing the integer gcds and interpolating to find the polynomial gcd. They did this via a probabilistic algorithm. <p> It would be interesting to compute the bounds necessary for Lemma 4.4 and compare them with the probabilistic bounds of <ref> [12] </ref> and [30] for polynomial gcds. 3. The set of questions we are asking here can be naturally extended to the questions of parallel complexity. Here one of the most striking examples is the N C algorithms for polynomial gcds using subresultants. No N C integer algorithm is known.
Reference: [13] <author> H. Cohen, A. Lenstra, </author> <title> "Implementation of a New Primality Test," </title> <journal> Math. Comp., </journal> <volume> Vol. 48 (1987), </volume> <pages> pp. 103-121. </pages>
Reference-contexts: : : : + a 0 a n1 x n1 + : : : + a 0 , ja i j &lt; 2 c multiplication (n) [31] (nc) [28] division (n) [15] (nc) [28, 32] gcd (n) log n [27] (nc) log n [3, 28] irreducibility n log log n <ref> [1, 13] </ref> polynomial in n; c [34] factorization 2 (1=4+*)n [26, 33] n 5+* c [23] There are a number of things to note in this table.
Reference: [14] <author> G. Collins, </author> <title> "The Calculation of Multivariate Polynomial Resultants," </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> Vol. 18, </volume> <pages> pp. 515-532. </pages>
Reference-contexts: In 1974, Borodin and Moenck [6], extended examples of Cabay [11], Brown [10] and Collins <ref> [14] </ref>, and examined the issue of fast modular transforms (evaluating mod p for integer problems, evaluating at integer points for polynomial problems) as a general technique for algorithmic speed-up in the two domains.
Reference: [15] <author> S. Cook, </author> <title> "On the Minimum Computation Time of Functions," Dissertation, </title> <publisher> Harvard University (1966). </publisher>
Reference-contexts: that c log (n + 1).) problem integer a = polynomial a (x) = a n1 10 n1 + : : : + a 0 a n1 x n1 + : : : + a 0 , ja i j &lt; 2 c multiplication (n) [31] (nc) [28] division (n) <ref> [15] </ref> (nc) [28, 32] gcd (n) log n [27] (nc) log n [3, 28] irreducibility n log log n [1, 13] polynomial in n; c [34] factorization 2 (1=4+*)n [26, 33] n 5+* c [23] There are a number of things to note in this table.
Reference: [16] <author> P. Gallagher, </author> <title> "The Large Sieve and Probabilistic Galois Theory," </title> <booktitle> Proc. Symp. in Pure Math. </booktitle> <year> (1972), </year> <pages> pp. 92-101. </pages>
Reference: [17] <author> G. H. Hardy and E. M. Wright, </author> <title> An Introduction to the Theory of Numbers, </title> <publisher> Oxford University Press, </publisher> <year> 1971. </year>
Reference: [18] <author> S. Landau, </author> <title> "Some Remarks on Computing the Square Parts of Integers," </title> <journal> Information and Computation , Vol. </journal> <volume> 78, No. 3 (1988), </volume> <pages> pp. 246-253. </pages>
Reference-contexts: But no similarly fast algorithm has been found for integers. We say an integer n is "squarefree" if all the prime factors of n have exponent 1. The present fastest algorithm to compute a squarefree decomposition of integers gives a reduction to '(n) <ref> [18] </ref>. This presently takes exponential time to compute. We have seen polynomial algorithms translate to integer algorithms, and vice versa. In its first blush, polynomial factorization appears to shed no light on integer factorization.
Reference: [19] <author> A.K. Lenstra, H. W. Lenstra, Jr., and L. Lovasz, </author> <title> "Factoring Polynomials with Rational Coefficients," </title> <journal> Mathematische Annelan, </journal> <volume> 261 (1982), </volume> <pages> pp. 513-534. </pages>
Reference-contexts: In 1982, shortly before the Lenstra, Lenstra, Lovasz <ref> [19] </ref> polynomial time algorithm for polynomial factorization, Adleman and Odlyzko gave a reduction from polynomial irreducibility testing and factorization to integer primality testing and factorization respectively [2].
Reference: [20] <author> Yishay Mansour, Baruch Schieber, Prason Tiwari, </author> <title> "Lower Bounds for Computations with the Floor Operation," </title> <journal> SIAM J. Comput. </journal> <volume> 20(2), </volume> <pages> 315-327. </pages>
Reference: [21] <author> Yishay Mansour, Baruch Schieber, Prason Tiwari, </author> <title> "A Lower Bound for Integer Greatest Common Divisor Computations," </title> <journal> J. Assoc. Com-put. Mach. </journal> <volume> 38(2) (1991), </volume> <pages> 453-471. </pages>
Reference: [22] <author> M. Mignotte, </author> <title> "An Inequality about Factors of Polynomials", </title> <journal> Math. Comp., </journal> <volume> Vol. 28 (1974), </volume> <pages> pp. 1153-1157. </pages>
Reference: [23] <author> V.S. Miller, </author> <title> "Factoring Polynomials via Relation-Finding," </title> <booktitle> Theory of Computing and Systems, Lecture Notes in Computer Science 601 (1992), </booktitle> <pages> pp. 115-121. </pages>
Reference-contexts: a 0 , ja i j &lt; 2 c multiplication (n) [31] (nc) [28] division (n) [15] (nc) [28, 32] gcd (n) log n [27] (nc) log n [3, 28] irreducibility n log log n [1, 13] polynomial in n; c [34] factorization 2 (1=4+*)n [26, 33] n 5+* c <ref> [23] </ref> There are a number of things to note in this table. For the first two problems (which happen to be the basic building blocks), the algorithms for the integer version of the problems have comparable running times with the algorithms for the polynomial versions.
Reference: [24] <author> A. Odlyzko, </author> <title> private communication. </title>
Reference-contexts: Let N n b be that subset of P n b whose leading and constant terms are both non-zero. Finally let I n b (x) be the subset of N n b which consists of irreducible polynomials. There is the following long-standing but unproved conjecture: Conjecture 5.1 <ref> [24] </ref> For all bases b 2, the lim n!1 jI n b (x)j=jN n By contrast "most" integers factor. The Prime Number Theorem states: Theorem 5.2 Let (x) be the number of primes less than x. Then lim x!1 x = 1.
Reference: [25] <author> Victor Pan, </author> <title> "Complexity of Computations with Matrices and Polynomials," </title> <booktitle> SIAM Review 34(2) (1992), </booktitle> <pages> 225-262. </pages>
Reference: [26] <author> J. Pollard, </author> <title> "Theorems on Factorization and Primality Testing," </title> <journal> Proc. Cambridge Philos. Soc., </journal> <volume> Vol. 76 (1974), </volume> <pages> pp. 521-528. </pages>
Reference-contexts: + : : : + a 0 , ja i j &lt; 2 c multiplication (n) [31] (nc) [28] division (n) [15] (nc) [28, 32] gcd (n) log n [27] (nc) log n [3, 28] irreducibility n log log n [1, 13] polynomial in n; c [34] factorization 2 (1=4+*)n <ref> [26, 33] </ref> n 5+* c [23] There are a number of things to note in this table. For the first two problems (which happen to be the basic building blocks), the algorithms for the integer version of the problems have comparable running times with the algorithms for the polynomial versions.
Reference: [27] <author> A. Schonhage, </author> <title> "Schnelle Berechnung von Kettenbruchentwilungen," </title> <journal> Acta Informatica, </journal> <volume> Vol. 1 (1971), </volume> <pages> pp. 139-144. </pages>
Reference-contexts: a = polynomial a (x) = a n1 10 n1 + : : : + a 0 a n1 x n1 + : : : + a 0 , ja i j &lt; 2 c multiplication (n) [31] (nc) [28] division (n) [15] (nc) [28, 32] gcd (n) log n <ref> [27] </ref> (nc) log n [3, 28] irreducibility n log log n [1, 13] polynomial in n; c [34] factorization 2 (1=4+*)n [26, 33] n 5+* c [23] There are a number of things to note in this table.
Reference: [28] <author> A. Schonhage, </author> <title> "Asymptotically Fast Algorithms for the Numerical Multiplication and Division of Polynomials with Complex Coefficients," </title> <booktitle> Lecture Notes in Computer Science Vol. 144 (1982), </booktitle> <pages> pp. 3-15. </pages>
Reference-contexts: The idea of embedding polynomial arithmetic is also the basis for Schonhage's fast algorithm for polynomial multiplication and division <ref> [28] </ref>. These ideas can only be carried so far, because of the problem with carries. <p> polynomial division assumes that c log (n + 1).) problem integer a = polynomial a (x) = a n1 10 n1 + : : : + a 0 a n1 x n1 + : : : + a 0 , ja i j &lt; 2 c multiplication (n) [31] (nc) <ref> [28] </ref> division (n) [15] (nc) [28, 32] gcd (n) log n [27] (nc) log n [3, 28] irreducibility n log log n [1, 13] polynomial in n; c [34] factorization 2 (1=4+*)n [26, 33] n 5+* c [23] There are a number of things to note in this table. <p> log (n + 1).) problem integer a = polynomial a (x) = a n1 10 n1 + : : : + a 0 a n1 x n1 + : : : + a 0 , ja i j &lt; 2 c multiplication (n) [31] (nc) [28] division (n) [15] (nc) <ref> [28, 32] </ref> gcd (n) log n [27] (nc) log n [3, 28] irreducibility n log log n [1, 13] polynomial in n; c [34] factorization 2 (1=4+*)n [26, 33] n 5+* c [23] There are a number of things to note in this table. <p> (x) = a n1 10 n1 + : : : + a 0 a n1 x n1 + : : : + a 0 , ja i j &lt; 2 c multiplication (n) [31] (nc) [28] division (n) [15] (nc) [28, 32] gcd (n) log n [27] (nc) log n <ref> [3, 28] </ref> irreducibility n log log n [1, 13] polynomial in n; c [34] factorization 2 (1=4+*)n [26, 33] n 5+* c [23] There are a number of things to note in this table.
Reference: [29] <author> A. Schonhage, </author> " <title> Factorization of Univariate Integer Polynomials by Diophantine Approximation and an Improved Basis Reduction Algorithm," </title> <booktitle> ICALP 1984, Lecture Notes in Computer Science Vol. 172 (1984), </booktitle> <pages> pp. 436-447. </pages>
Reference: [30] <author> A. Schonhage, </author> <title> "Probabilistic Computation of Integer Polynomial GCDs," </title> <journal> Journal of Algorithms, </journal> <volume> Vol. 9 (1988), </volume> <pages> pp. 365-371. </pages>
Reference-contexts: In 1982, shortly before the Lenstra, Lenstra, Lovasz [19] polynomial time algorithm for polynomial factorization, Adleman and Odlyzko gave a reduction from polynomial irreducibility testing and factorization to integer primality testing and factorization respectively [2]. More recently, Char, Geddes and Gonnet [12], and independently, Schonhage <ref> [30] </ref>, gave a fast algorithm for computing polynomial gcds which relies on computing integer gcds, and then interpolating these values to find the polynomial gcd. The idea of embedding polynomial arithmetic is also the basis for Schonhage's fast algorithm for polynomial multiplication and division [28]. <p> The resulting data compression enables a speed-up of the algorithm. One can make use of the fast integer problem to develop a faster technique for the polynomial problem. For example, Char, Geddes and Gonnet [12], and Schonhage <ref> [30] </ref> computed gcds of degree n polynomials by substituting n + 1 values into the polynomials, computing the integer gcds and interpolating to find the polynomial gcd. They did this via a probabilistic algorithm. <p> It would be interesting to compute the bounds necessary for Lemma 4.4 and compare them with the probabilistic bounds of [12] and <ref> [30] </ref> for polynomial gcds. 3. The set of questions we are asking here can be naturally extended to the questions of parallel complexity. Here one of the most striking examples is the N C algorithms for polynomial gcds using subresultants. No N C integer algorithm is known.
Reference: [31] <author> A. Schonhage and V. </author> <title> Strassen, </title> <journal> "Schnelle Multiplikation grosser Zahlen," Computing, </journal> <volume> Vol. 7 (1971), </volume> <pages> pp. 281-292. 22 </pages>
Reference-contexts: bound for polynomial division assumes that c log (n + 1).) problem integer a = polynomial a (x) = a n1 10 n1 + : : : + a 0 a n1 x n1 + : : : + a 0 , ja i j &lt; 2 c multiplication (n) <ref> [31] </ref> (nc) [28] division (n) [15] (nc) [28, 32] gcd (n) log n [27] (nc) log n [3, 28] irreducibility n log log n [1, 13] polynomial in n; c [34] factorization 2 (1=4+*)n [26, 33] n 5+* c [23] There are a number of things to note in this table.
Reference: [32] <author> M. Sieveking, </author> <title> "An Algorithm for Division of Power Series," </title> <journal> Computing, </journal> <volume> Vol. 10 (1972), </volume> <pages> pp. 153-156. </pages>
Reference-contexts: log (n + 1).) problem integer a = polynomial a (x) = a n1 10 n1 + : : : + a 0 a n1 x n1 + : : : + a 0 , ja i j &lt; 2 c multiplication (n) [31] (nc) [28] division (n) [15] (nc) <ref> [28, 32] </ref> gcd (n) log n [27] (nc) log n [3, 28] irreducibility n log log n [1, 13] polynomial in n; c [34] factorization 2 (1=4+*)n [26, 33] n 5+* c [23] There are a number of things to note in this table.
Reference: [33] <editor> V. Strassen, "Einege Resultate uber Berechnungskomplexitat", Jahres-ber. Deutch. Math.-Verein, </editor> <volume> Vol. </volume> <pages> 78 (1976-77), pp. 1-8. </pages>
Reference-contexts: + : : : + a 0 , ja i j &lt; 2 c multiplication (n) [31] (nc) [28] division (n) [15] (nc) [28, 32] gcd (n) log n [27] (nc) log n [3, 28] irreducibility n log log n [1, 13] polynomial in n; c [34] factorization 2 (1=4+*)n <ref> [26, 33] </ref> n 5+* c [23] There are a number of things to note in this table. For the first two problems (which happen to be the basic building blocks), the algorithms for the integer version of the problems have comparable running times with the algorithms for the polynomial versions.
Reference: [34] <author> P. Weinberger, </author> <title> "Finding the Number of Factors of a Polynomial," </title> <journal> J. Algorithms, </journal> <volume> vol. 5 (1984), </volume> <pages> pp. 180-186. 23 </pages>
Reference-contexts: a n1 x n1 + : : : + a 0 , ja i j &lt; 2 c multiplication (n) [31] (nc) [28] division (n) [15] (nc) [28, 32] gcd (n) log n [27] (nc) log n [3, 28] irreducibility n log log n [1, 13] polynomial in n; c <ref> [34] </ref> factorization 2 (1=4+*)n [26, 33] n 5+* c [23] There are a number of things to note in this table.
References-found: 34

