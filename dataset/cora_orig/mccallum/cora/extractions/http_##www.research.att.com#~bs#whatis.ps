URL: http://www.research.att.com/~bs/whatis.ps
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: What is ``Object-Oriented Programming''? (1991 revised version)  
Author: Bjarne Stroustrup 
Address: Murray Hill, New Jersey 07974  
Affiliation: AT&T Bell Laboratories  
Abstract: Object-Oriented Programming'' and ``Data Abstraction'' have become very common terms. Unfortunately, few people agree on what they mean. I will offer informal definitions that appear to make sense in the context of languages like Ada, C ++ , Modula-2, Simula, and Smalltalk. The general idea is to equate ``support for data abstraction'' with the ability to define and use new types and equate ``support for object-oriented programming'' with the ability to express type hierarchies. Features necessary to support these programming styles in a general purpose programming language will be discussed. The presentation centers around C ++ but is not limited to facilities provided by that language. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Birtwistle, Graham et.al.: </author> <title> SIMULA BEGIN. </title> <institution> Studentlitteratur, Lund, Sweden. 1971. Chartwell-Bratt ltd, UK. </institution> <year> 1980. </year>
Reference-contexts: There are many example to the contrary. The important issue is not so much what features a language possesses but that the features it does possess are sufficient to support the desired programming styles in the desired application areas: <ref> [1] </ref> All features must be cleanly and elegantly integrated into the language. [2] It must be possible to use features in combination to achieve solutions that would otherwise have required extra separate features. [3] There should be as few spurious and ``special purpose'' features as possible. [4] A feature should be <p> In particular, the techniques for designing ``good procedures'' are now applied for each procedure in a module. The most common example is a defi nition of a stack module. The main problems that have to be solved for a good solution are: <ref> [1] </ref> Provide a user interface for the stack (for example, functions push () and pop ()). [2] Ensure that the representation of the stack (for example, a vector of elements) can only be accessed through this user interface. [3] Ensure that the stack is initialized before its first use. <p> In languages such as C ++ and Simula, where static type checking is extensively used, the type system can be employed to select between different calling mechanisms. In C ++ , two alternatives are available: <ref> [1] </ref> A normal function call: the member function to be called is determined at compile time (through a lookup in the compiler's symbol tables) and called using the standard function call mechanism with an argument added to identify the object for which the function is called. <p> Smalltalk is the best example of this. 5 Limits to Perfection A major problem with a language defined to exploit the techniques of data hiding, data abstraction, and object-oriented programming is that to claim to be a general purpose programming language it must <ref> [1] </ref> Run on traditional machines. [2] Coexist with traditional operating systems. [3] Compete with traditional programming languages in terms of run time efficiency. [4] Cope with every major application area.
Reference: [2] <author> Bobrow, D. and Stefik, M.: </author> <title> The LOOPS Manual. </title> <note> Xerox Parc 1983. </note>
Reference-contexts: The important issue is not so much what features a language possesses but that the features it does possess are sufficient to support the desired programming styles in the desired application areas: [1] All features must be cleanly and elegantly integrated into the language. <ref> [2] </ref> It must be possible to use features in combination to achieve solutions that would otherwise have required extra separate features. [3] There should be as few spurious and ``special purpose'' features as possible. [4] A feature should be such that its implementation does not impose significant overheads on programs that <p> The most common example is a defi nition of a stack module. The main problems that have to be solved for a good solution are: [1] Provide a user interface for the stack (for example, functions push () and pop ()). <ref> [2] </ref> Ensure that the representation of the stack (for example, a vector of elements) can only be accessed through this user interface. [3] Ensure that the stack is initialized before its first use. <p> In this way, one can achieve the efficiency of a macro expansion without compromising the standard function semantics. This optimization is equally valuable as a support for data abstraction. <ref> [2] </ref> A virtual function call: The function to be called depends on the type of the object for which it is called. This type cannot in general be determined until run time. <p> Smalltalk is the best example of this. 5 Limits to Perfection A major problem with a language defined to exploit the techniques of data hiding, data abstraction, and object-oriented programming is that to claim to be a general purpose programming language it must [1] Run on traditional machines. <ref> [2] </ref> Coexist with traditional operating systems. [3] Compete with traditional programming languages in terms of run time efficiency. [4] Cope with every major application area.
Reference: [3] <author> Dahl, O-J. and Hoare, </author> <title> C.A.R.: Hierarchical Program Structures. In Structured Programming. </title> <publisher> Aca demic Press 1972. </publisher>
Reference-contexts: features it does possess are sufficient to support the desired programming styles in the desired application areas: [1] All features must be cleanly and elegantly integrated into the language. [2] It must be possible to use features in combination to achieve solutions that would otherwise have required extra separate features. <ref> [3] </ref> There should be as few spurious and ``special purpose'' features as possible. [4] A feature should be such that its implementation does not impose significant overheads on programs that do not require it. [5] A user need only know about the subset of the language explicitly used to write a <p> main problems that have to be solved for a good solution are: [1] Provide a user interface for the stack (for example, functions push () and pop ()). [2] Ensure that the representation of the stack (for example, a vector of elements) can only be accessed through this user interface. <ref> [3] </ref> Ensure that the stack is initialized before its first use. <p> In languages with weak static type checking a more elaborate mechanism must be employed. What is done in a language like Smalltalk is to store a list of the names of all member functions (methods) of a class so that they can be found at run time: <ref> [3] </ref> A method invocation: First the appropriate table of method names is found by examining the object pointed to by p. In this table (or set of tables) the string "f" is looked up to see if the object has an f (). <p> example of this. 5 Limits to Perfection A major problem with a language defined to exploit the techniques of data hiding, data abstraction, and object-oriented programming is that to claim to be a general purpose programming language it must [1] Run on traditional machines. [2] Coexist with traditional operating systems. <ref> [3] </ref> Compete with traditional programming languages in terms of run time efficiency. [4] Cope with every major application area.
Reference: [4] <author> Cargill, Tom A.: </author> <title> PI: A Case Study in Object-Oriented Programming. </title> <journal> SIGPLAN Notices, Novem ber 1986, </journal> <pages> pp 350-360. </pages>
Reference-contexts: the desired application areas: [1] All features must be cleanly and elegantly integrated into the language. [2] It must be possible to use features in combination to achieve solutions that would otherwise have required extra separate features. [3] There should be as few spurious and ``special purpose'' features as possible. <ref> [4] </ref> A feature should be such that its implementation does not impose significant overheads on programs that do not require it. [5] A user need only know about the subset of the language explicitly used to write a program. <p> For a case study in object-oriented programming see Cargill <ref> [4] </ref>. 3 Support for Data Abstraction The basic support for programming with data abstraction consists of facilities for defining a set of operations for a type and for restricting the access to objects of the type to that set of operations. <p> language defined to exploit the techniques of data hiding, data abstraction, and object-oriented programming is that to claim to be a general purpose programming language it must [1] Run on traditional machines. [2] Coexist with traditional operating systems. [3] Compete with traditional programming languages in terms of run time efficiency. <ref> [4] </ref> Cope with every major application area. This implies that facilities must be available for effective numerical work (floating point arithmetic without overheads that would make Fortran appear attractive), and that facilities must be available for access to memory in a way that allows device drivers to be written.
Reference: [5] <author> C.C.I.T.T Study Group XI: </author> <title> CHILL User's Manual. </title> <journal> CHILL Bulletin no 1. </journal> <volume> vol 4. </volume> <month> March </month> <year> 1984. </year>
Reference-contexts: to use features in combination to achieve solutions that would otherwise have required extra separate features. [3] There should be as few spurious and ``special purpose'' features as possible. [4] A feature should be such that its implementation does not impose significant overheads on programs that do not require it. <ref> [5] </ref> A user need only know about the subset of the language explicitly used to write a program. The last two principles can be summarized as ``what you don't know won't hurt you.'' If there are any doubts about the usefulness of a feature it is better left out.
Reference: [6] <author> Goldberg, A. and Robson, D.: </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison Wesley 1983. </publisher>
Reference: [7] <author> Ichbiah, J.D. et.al.: </author> <title> Rationale for the Design of the Ada Programming Language. </title> <journal> SIGPLAN Notices, </journal> <month> June </month> <year> 1979. </year>
Reference: [8] <author> Kernighan, B.W. and Ritchie, </author> <title> D.M.: The C Programming Language. </title> <publisher> Prentice-Hall 1978. </publisher>

References-found: 8

