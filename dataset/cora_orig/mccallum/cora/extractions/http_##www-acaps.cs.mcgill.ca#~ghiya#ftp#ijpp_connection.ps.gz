URL: http://www-acaps.cs.mcgill.ca/~ghiya/ftp/ijpp_connection.ps.gz
Refering-URL: http://www.csd.uu.se/~thomasl/wpo/alias-papers.html
Root-URL: 
Email: fghiya,hendreng@cs.mcgill.ca  
Title: Connection Analysis: A Practical Interprocedural Heap Analysis for C  
Author: Rakesh Ghiya and Laurie J. Hendren 
Date: April 4, 1996  
Address: Montreal, CANADA H3A 2A7  
Affiliation: School of Computer Science, McGill University  
Abstract: This paper presents a practical heap analysis technique, connection analysis, that can be used to disambiguate heap accesses in C programs. The technique is designed for analyzing programs that allocate many disjoint objects in the heap such as dynamically-allocated arrays in scientific programs. The method statically estimates connection matrices which encode the connection relationships between all heap-directed pointers at each program point. The results of the analysis can be used by parallelizing compilers to determine when two heap-allocated objects are guaranteed to be disjoint, and thus can be used to improve array dependence and interference analysis. The method has been implemented as a context-sensitive interprocedural analysis in the McCAT optimizing/parallelizing C compiler. Experimental results are given to compare the accuracy of connection analysis versus a conservative estimate based on points-to analysis. fl This work supported by NSERC, FCAR, and the EPPP project (financed by Industry Canada, Alex Parallel Computers, Digital Equipment Canada, IBM Canada and the Centre de recherche informatique de Montreal). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. D. Jones and S. S. Muchnick, </author> <title> Program Flow Analysis, Theory and Applications, ch. </title> <booktitle> 4, Flow Analysis and Optimization of LISP-like Structures, </booktitle> <pages> pp. 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: The basic approach was to approximate the structure of the heap in the form of a directed graph (with nodes as heap objects, and edges as links 40 between the objects). To keep the size of the graph finite, Jones and Muchnick <ref> [1] </ref> proposed the idea of k-limiting whereby all the nodes in the heap accessible from a variable after traversing k or more links, are coalesced into one summary node. Larus and Hilfinger [3] additionally labeled the nodes with access paths for dependence testing.
Reference: [2] <author> N. D. Jones and S. S. Muchnick, </author> <title> "A flexible approach to interprocedural data flow analysis and programs with recursive data structures," </title> <booktitle> in Conf. Rec. of the Ninth Ann. ACM Symp. on Principles of Programming Languages, </booktitle> <address> (Albuquerque, N. </address> <publisher> Mex.), </publisher> <pages> pp. 66-74, </pages> <month> Jan. </month> <year> 1982. </year>
Reference: [3] <author> J. R. Larus and P. N. Hilfinger, </author> <title> "Detecting conflicts between structure accesses," </title> <booktitle> in Proc. of the SIGPLAN '88 Conf. on Programming Language Design and Implementation, (Atlanta, Georgia), </booktitle> <pages> pp. 21-34, </pages> <month> Jun. </month> <year> 1988. </year>
Reference-contexts: To keep the size of the graph finite, Jones and Muchnick [1] proposed the idea of k-limiting whereby all the nodes in the heap accessible from a variable after traversing k or more links, are coalesced into one summary node. Larus and Hilfinger <ref> [3] </ref> additionally labeled the nodes with access paths for dependence testing. Chase et. al [8] proposed the storage shape graph (SSG) which contains a node for each (heap-directed) pointer variable, and a node for each allocation site in the program.
Reference: [4] <author> J. R. Larus, </author> <title> "Compiling Lisp programs for parallel execution," </title> <journal> Lisp and Symbolic Computation, </journal> <volume> vol. 4, </volume> <pages> pp. 29-99, </pages> <year> 1991. </year>
Reference: [5] <author> V. A. Guarna, Jr., </author> <title> "A technique for analyzing pointer and structure references in parallel restructuring compilers," </title> <booktitle> in Proc. of the 1988 Intl. Conf. on Parallel Processing, vol. II, </booktitle> <address> (St. Charles, </address> <publisher> Ill.), </publisher> <pages> pp. 212-220, </pages> <month> Aug. </month> <year> 1988. </year>
Reference: [6] <author> S. Horwitz, P. Pfeiffer, and T. Reps, </author> <title> "Dependence analysis for pointer variables," </title> <booktitle> in Proc. of the SIGPLAN '89 Conf. on Programming Language Design and Implementation, (Portland, Ore.), </booktitle> <pages> pp. 28-40, </pages> <month> Jun. </month> <year> 1989. </year>
Reference: [7] <author> W. L. Harrison III, </author> <title> "The interprocedural analysis and automatic parallelization of Scheme programs," </title> <journal> Lisp and Symbolic Computation, </journal> <volume> vol. 2, no. 3/4, </volume> <pages> pp. 179-396, </pages> <year> 1989. </year> <month> 46 </month>
Reference: [8] <author> D. R. Chase, M. Wegman, and F. K. Zadeck, </author> <title> "Analysis of pointers and structures," </title> <booktitle> in Proc. of the SIGPLAN '90 Conf. on Programming Language Design and Implementation, </booktitle> <address> (White Plains, N. </address> <publisher> Y.), </publisher> <pages> pp. 296-310, </pages> <month> Jun. </month> <year> 1990. </year>
Reference-contexts: Their access paths are similar to object names [10]. However, they do not use access paths to name heap objects. Instead, they use the place (statement) in the program, where an anonymous heap object is created, to name it, as in <ref> [8] </ref>. To avoid giving the same name to heap objects created at the same statement, but along different call-chains, they qualify the names with procedure strings. A recent approach for C is the implementation of a context-sensitive method for the SUIF compiler system [16]. <p> Larus and Hilfinger [3] additionally labeled the nodes with access paths for dependence testing. Chase et. al <ref> [8] </ref> proposed the storage shape graph (SSG) which contains a node for each (heap-directed) pointer variable, and a node for each allocation site in the program. An allocation-site node in the SSG represents all the heap objects that can be allocated at that allocation site. <p> Our points-to analysis uses only one abstract location heap to represent all heap objects. All 41 other methods use a variation of the allocation-site approach proposed by Chase et. al <ref> [8] </ref>. Landi and Ryder [10] and Ruf [17] simply name heap objects based on their allocation site (identified by calls to library routines like malloc).
Reference: [9] <author> L. J. Hendren and A. Nicolau, </author> <title> "Parallelizing programs with recursive data structures," </title> <journal> IEEE Trans. on Parallel and Distrib. Systems, </journal> <volume> vol. 1, </volume> <pages> pp. 35-47, </pages> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: An allocation-site node in the SSG represents all the heap objects that can be allocated at that allocation site. Hendren and Nicolau <ref> [9] </ref> departed from the graph-based approach, and proposed the path matrix abstraction, which captures the heap structure as path relationships between pointer variables (handles). Deutsch [12, 13] proposed a more powerful storeless model using pairs of symbolic access paths qualified by constraints that make them aliased.
Reference: [10] <author> W. Landi and B. G. Ryder, </author> <title> "A safe approximate algorithm for interprocedural pointer aliasing," </title> <booktitle> in Proc. of the ACM SIGPLAN '92 Conf. on Programming Language Design and Implementation, </booktitle> <address> (San Francisco, Calif.), </address> <pages> pp. 235-248, </pages> <month> Jun. </month> <year> 1992. </year>
Reference-contexts: There has been a considerable amount of work in both of these areas [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], although more attention has been paid to actually implementing methods that work well for stack-allocated objects <ref> [10, 11, 15, 16, 17] </ref>. A complete discussion and comparison of these methods can be found in [18]. Stack-directed pointers exhibit the important property that their targets always possess a name (the name of the variable allocated to that location on the stack). <p> It is interesting to examine three recently implemented strategies. Landi and Ryder have reported on an implementation of an interprocedural strategy for C that estimates alias information in terms of pairs of object names <ref> [10] </ref>. An object name consists of a variable and a (possibly empty) sequence of deref-erences and field accesses. Typical alias pairs are: (**a, *b), ( *(a-&gt;next), *(b-&gt;next) ). In the presence of recursive data structures, the number of object names is infinite. To avoid this, they k-limit object names. <p> To avoid this, they k-limit object names. Choi, Burke and Carini [11] have been implementing a method for FORTRAN90, and they also compute aliases of pairs of access paths. Their access paths are similar to object names <ref> [10] </ref>. However, they do not use access paths to name heap objects. Instead, they use the place (statement) in the program, where an anonymous heap object is created, to name it, as in [8]. <p> Both of these benchmarks are part of William Landi's test suite <ref> [10] </ref>, and have been obtained from him. * cholesky: It performs Cholesky factorization of a sparse positive definite matrix. It is part of the SPLASH [23] benchmark suite from Stanford. It implements the sparse matrix using structures with non-recursive pointer fields. <p> Our points-to analysis uses only one abstract location heap to represent all heap objects. All 41 other methods use a variation of the allocation-site approach proposed by Chase et. al [8]. Landi and Ryder <ref> [10] </ref> and Ruf [17] simply name heap objects based on their allocation site (identified by calls to library routines like malloc). With this approach, if the programmer uses his own routine my malloc with the malloc call embedded in it, all heap objects will get the same name.
Reference: [11] <author> J.-D. Choi, M. Burke, and P. Carini, </author> <title> "Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects," </title> <booktitle> in Conf. Rec. of the Twentieth Ann. ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <address> (Charleston, South Carolina), </address> <pages> pp. 232-245, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: There has been a considerable amount of work in both of these areas [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], although more attention has been paid to actually implementing methods that work well for stack-allocated objects <ref> [10, 11, 15, 16, 17] </ref>. A complete discussion and comparison of these methods can be found in [18]. Stack-directed pointers exhibit the important property that their targets always possess a name (the name of the variable allocated to that location on the stack). <p> Typical alias pairs are: (**a, *b), ( *(a-&gt;next), *(b-&gt;next) ). In the presence of recursive data structures, the number of object names is infinite. To avoid this, they k-limit object names. Choi, Burke and Carini <ref> [11] </ref> have been implementing a method for FORTRAN90, and they also compute aliases of pairs of access paths. Their access paths are similar to object names [10]. However, they do not use access paths to name heap objects. <p> With this approach, if the programmer uses his own routine my malloc with the malloc call embedded in it, all heap objects will get the same name. This would result in a similar scenario as our points-to analysis. To overcome this flaw, Choi et. al <ref> [11] </ref> proposed attaching procedure strings with the allocation site. Wilson and Lam [16] also follow the same approach. With this technique, heap objects allocated at the same allocation site but along different call-chains get distinct names.
Reference: [12] <author> A. Deutsch, </author> <title> "A storeless model of aliasing and its abstractions using finite representations of right-regular equivalence relations," </title> <booktitle> in Proc. of the 1992 Intl. Conf. on Computer Languages, (Oakland, Calif.), </booktitle> <pages> pp. 2-13, </pages> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: We further discuss related work in Section 5. Section 6 gives our conclusions and briefly describes our future work. 2 Connection Analysis Connection analysis uses a simple, storeless <ref> [12] </ref>, abstraction designed to disambiguate heap accesses at a coarse level, but in an efficient and cost-effective manner. For each program point the analysis computes a connection matrix, which is a boolean matrix summarizing the connectivity of heap objects. <p> An allocation-site node in the SSG represents all the heap objects that can be allocated at that allocation site. Hendren and Nicolau [9] departed from the graph-based approach, and proposed the path matrix abstraction, which captures the heap structure as path relationships between pointer variables (handles). Deutsch <ref> [12, 13] </ref> proposed a more powerful storeless model using pairs of symbolic access paths qualified by constraints that make them aliased. Recently, Sagiv et. al [25] have presented abstract storage graphs (ASGs) to accurately capture the heap structure in the presence of destructive updates.
Reference: [13] <author> A. Deutsch, </author> <title> "Interprocedural may-alias analysis for pointers: Beyond k-limiting," </title> <booktitle> in Proc. of the ACM SIGPLAN '94 Conf. on Programming Language Design and Implementation, </booktitle> <address> (Orlando, </address> <publisher> Flor.), </publisher> <pages> pp. 230-241, </pages> <month> Jun. </month> <year> 1994. </year>
Reference-contexts: An allocation-site node in the SSG represents all the heap objects that can be allocated at that allocation site. Hendren and Nicolau [9] departed from the graph-based approach, and proposed the path matrix abstraction, which captures the heap structure as path relationships between pointer variables (handles). Deutsch <ref> [12, 13] </ref> proposed a more powerful storeless model using pairs of symbolic access paths qualified by constraints that make them aliased. Recently, Sagiv et. al [25] have presented abstract storage graphs (ASGs) to accurately capture the heap structure in the presence of destructive updates.
Reference: [14] <author> J. Plevyak, A. Chien, and V. Karamcheti, </author> <title> "Analysis of dynamic structures for efficient parallel execution," </title> <booktitle> in Proc. of the 6th Intl. Work. on Languages and Compilers for Parallel Computing, no. 768 in Lec. Notes in Comp. Sci., (Portland, Ore.), </booktitle> <pages> pp. 37-56, </pages> <publisher> Springer-Verlag, </publisher> <month> Aug. </month> <year> 1993. </year> <note> Publ. in 1994. 47 </note>
Reference: [15] <author> M. Emami, R. Ghiya, and L. J. Hendren, </author> <title> "Context-sensitive interprocedural points-to analysis in the presence of function pointers," </title> <booktitle> in Proc. of the ACM SIGPLAN '94 Conf. on Programming Language Design and Implementation, </booktitle> <address> (Orlando, </address> <publisher> Flor.), </publisher> <pages> pp. 242-256, </pages> <month> Jun. </month> <year> 1994. </year>
Reference-contexts: There has been a considerable amount of work in both of these areas [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], although more attention has been paid to actually implementing methods that work well for stack-allocated objects <ref> [10, 11, 15, 16, 17] </ref>. A complete discussion and comparison of these methods can be found in [18]. Stack-directed pointers exhibit the important property that their targets always possess a name (the name of the variable allocated to that location on the stack). <p> Blocks of memory that are heap-allocated are labeled by their allocation context. In all three of these approaches the stack-directed and heap-directed pointer problems are solved together. In contrast, our approach is to decouple the problems and to first solve the stack-directed pointer problem using points-to analysis <ref> [15, 19] </ref>, and then use the result of points-to analysis as a starting point to solve the heap-directed pointer problem. <p> The analysis is performed on the SIMPLE intermediate representation which is a simplified, compositional subset of C [20, 21, 22]. The analysis is performed after points-to analysis and is implemented in a similar framework <ref> [19, 15] </ref>. The implementation of connection analysis is structured as a simple analysis for each 20 basic statement of the form presented in Section 2, a compositional rule for each control construct, and an interprocedural strategy that uses an unfolded invocation graph to capture all calling contexts.
Reference: [16] <author> R. P. Wilson and M. S. Lam, </author> <title> "Efficient context-sensitive pointer analysis for C programs," </title> <booktitle> in Proc. of the ACM SIGPLAN '95 Conf. on Programming Language Design and Implementation, </booktitle> <address> (La Jolla, Calif.), </address> <pages> pp. 1-12, </pages> <month> Jun. </month> <year> 1995. </year>
Reference-contexts: There has been a considerable amount of work in both of these areas [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], although more attention has been paid to actually implementing methods that work well for stack-allocated objects <ref> [10, 11, 15, 16, 17] </ref>. A complete discussion and comparison of these methods can be found in [18]. Stack-directed pointers exhibit the important property that their targets always possess a name (the name of the variable allocated to that location on the stack). <p> To avoid giving the same name to heap objects created at the same statement, but along different call-chains, they qualify the names with procedure strings. A recent approach for C is the implementation of a context-sensitive method for the SUIF compiler system <ref> [16] </ref>. In this approach, a points-to representation is used, however, they use the concept of location sets to specify both a block of memory, and a set of positions 4 within that block. Blocks of memory that are heap-allocated are labeled by their allocation context. <p> This would result in a similar scenario as our points-to analysis. To overcome this flaw, Choi et. al [11] proposed attaching procedure strings with the allocation site. Wilson and Lam <ref> [16] </ref> also follow the same approach. With this technique, heap objects allocated at the same allocation site but along different call-chains get distinct names. However this strategy sometimes results in a large set of names [16], which can slow down the analysis. <p> Wilson and Lam <ref> [16] </ref> also follow the same approach. With this technique, heap objects allocated at the same allocation site but along different call-chains get distinct names. However this strategy sometimes results in a large set of names [16], which can slow down the analysis. Further this approach can still give the same name to completely unrelated heap objects. Unlike the above methods, connection analysis is not sensitive to the location of allocation sites in the program.
Reference: [17] <author> E. Ruf, </author> <title> "Context-insensitive alias analysis reconsidered," </title> <booktitle> in Proc. of the ACM SIGPLAN '95 Conf. on Programming Language Design and Implementation, </booktitle> <address> (La Jolla, Calif.), </address> <pages> pp. 13-22, </pages> <month> Jun. </month> <year> 1995. </year>
Reference-contexts: There has been a considerable amount of work in both of these areas [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], although more attention has been paid to actually implementing methods that work well for stack-allocated objects <ref> [10, 11, 15, 16, 17] </ref>. A complete discussion and comparison of these methods can be found in [18]. Stack-directed pointers exhibit the important property that their targets always possess a name (the name of the variable allocated to that location on the stack). <p> Our points-to analysis uses only one abstract location heap to represent all heap objects. All 41 other methods use a variation of the allocation-site approach proposed by Chase et. al [8]. Landi and Ryder [10] and Ruf <ref> [17] </ref> simply name heap objects based on their allocation site (identified by calls to library routines like malloc). With this approach, if the programmer uses his own routine my malloc with the malloc call embedded in it, all heap objects will get the same name.
Reference: [18] <author> R. Ghiya, </author> <title> "Practical techniques for interprocedural heap analysis," </title> <type> Master's thesis, </type> <institution> School of Computer Science, McGill University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: A complete discussion and comparison of these methods can be found in <ref> [18] </ref>. Stack-directed pointers exhibit the important property that their targets always possess a name (the name of the variable allocated to that location on the stack). <p> For applications that use structures which are heavily linked, connection analysis is not effective, and our approach has been extended to provide a more expensive direction/interference/shape analysis that allows us to estimate the shape (tree/dag/graph) of each data structure allocated in the heap <ref> [18, 26] </ref> and disambiguate accesses to disjoint parts of the same data structure. Our overall strategy is to use the analysis that is most appropriate for the target application program.
Reference: [19] <author> M. Emami, </author> <title> "A practical interprocedural alias analysis for an optimizing/parallelizing C compiler," </title> <type> Master's thesis, </type> <institution> McGill U., Montreal, Que., </institution> <month> Jul. </month> <year> 1993. </year>
Reference-contexts: Blocks of memory that are heap-allocated are labeled by their allocation context. In all three of these approaches the stack-directed and heap-directed pointer problems are solved together. In contrast, our approach is to decouple the problems and to first solve the stack-directed pointer problem using points-to analysis <ref> [15, 19] </ref>, and then use the result of points-to analysis as a starting point to solve the heap-directed pointer problem. <p> The analysis is performed on the SIMPLE intermediate representation which is a simplified, compositional subset of C [20, 21, 22]. The analysis is performed after points-to analysis and is implemented in a similar framework <ref> [19, 15] </ref>. The implementation of connection analysis is structured as a simple analysis for each 20 basic statement of the form presented in Section 2, a compositional rule for each control construct, and an interprocedural strategy that uses an unfolded invocation graph to capture all calling contexts.
Reference: [20] <author> B. Sridharan, </author> <title> "An analysis framework for the McCAT compiler," </title> <type> Master's thesis, </type> <institution> McGill U., Montreal, Que., </institution> <month> Sep. </month> <year> 1992. </year>
Reference-contexts: The analysis is performed on the SIMPLE intermediate representation which is a simplified, compositional subset of C <ref> [20, 21, 22] </ref>. The analysis is performed after points-to analysis and is implemented in a similar framework [19, 15].
Reference: [21] <author> L. Hendren, C. Donawa, M. Emami, G. Gao, Justiani, and B. Sridharan, </author> <title> "Designing the McCAT compiler based on a family of structured intermediate representations," </title> <booktitle> in Proc. of the 5th Intl. Work. on Languages and Compilers for Parallel Computing, no. 757 in Lec. Notes in Comp. Sci., </booktitle> <address> (New Haven, Conn.), </address> <pages> pp. 406-420, </pages> <publisher> Springer-Verlag, </publisher> <month> Aug. </month> <year> 1992. </year> <note> Publ. in 1993. 48 </note>
Reference-contexts: The analysis is performed on the SIMPLE intermediate representation which is a simplified, compositional subset of C <ref> [20, 21, 22] </ref>. The analysis is performed after points-to analysis and is implemented in a similar framework [19, 15].
Reference: [22] <author> A. M. Erosa and L. J. Hendren, </author> <title> "Taming control flow: A structured approach to eliminat-ing goto statements," </title> <booktitle> in Proc. of the 1994 Intl. Conf. on Computer Languages, (Toulouse, France), </booktitle> <pages> pp. 229-240, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: The analysis is performed on the SIMPLE intermediate representation which is a simplified, compositional subset of C <ref> [20, 21, 22] </ref>. The analysis is performed after points-to analysis and is implemented in a similar framework [19, 15].
Reference: [23] <author> J. P. Singh, W.-D. Weber, and A. Gupta, </author> <title> "SPLASH: Stanford parallel applications for shared-memory," </title> <journal> Computer Arch. News, </journal> <volume> vol. 20, </volume> <pages> pp. 5-44, </pages> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: Both of these benchmarks are part of William Landi's test suite [10], and have been obtained from him. * cholesky: It performs Cholesky factorization of a sparse positive definite matrix. It is part of the SPLASH <ref> [23] </ref> benchmark suite from Stanford. It implements the sparse matrix using structures with non-recursive pointer fields. These pointers point to dynamic arrays of type int. * mp3d: This is another benchmark from the SPLASH suite related to rarefied fluid flow simulation used in aerospace research.
Reference: [24] <author> S. C. Woo, M. Ohara, E. Torrie, J. P. Singh, and A. Gupta, </author> <title> "The SPLASH-2 programs: Characterization and methodological considerations," </title> <booktitle> in Proc. of the 22nd Ann. Intl. Symp. on Computer Architecture, </booktitle> <address> (Santa Margherita Ligure, Italy), </address> <pages> pp. 24-36, </pages> <month> Jun. </month> <year> 1995. </year>
Reference-contexts: It is part of the new SPLASH benchmark suite called SPLASH-2 <ref> [24] </ref>, and we use the sequential version. The primary data structures used by this program are linked lists and dynamically-allocated arrays of pointers pointing to linked lists. * volrend: This benchmark renders a three-dimensional volume onto a two-dimensional plane using an optimized ray casting technique.
Reference: [25] <author> M. Sagiv, T. Reps, and R. Wilhelm, </author> <title> "Solving shape-analysis problems in languages with destructive updating," </title> <booktitle> in Conf. Rec. of the 23rd ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, (St. Petersburg, Flor.), </booktitle> <pages> pp. 16-31, </pages> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Deutsch [12, 13] proposed a more powerful storeless model using pairs of symbolic access paths qualified by constraints that make them aliased. Recently, Sagiv et. al <ref> [25] </ref> have presented abstract storage graphs (ASGs) to accurately capture the heap structure in the presence of destructive updates. The above approaches can provide a more refined estimation of heap structure as compared to connection analysis. For example, they can help identify `treeness' or `listness' of data structures.

References-found: 25

