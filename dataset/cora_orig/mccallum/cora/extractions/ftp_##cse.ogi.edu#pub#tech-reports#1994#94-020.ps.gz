URL: ftp://cse.ogi.edu/pub/tech-reports/1994/94-020.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Email: fbellegarg@cse.ogi.edu  
Title: Automating Synthesis by Completion  
Author: Fran~coise Bellegarde 
Date: April 26, 1994  
Address: PO Box 91000, Portland, Oregon 97291-1000, USA.  
Affiliation: Pacific Software Research Center Oregon Graduate Institute of Science Technology  
Abstract: When using a completion procedure, simple static analyses allow automatizing the manipulation of first-order functional programs. This paper shows how to apply these techniques in order to fully automatize program transformation by the two strategies: deforestation (eliminating useless intermediate data structures) and tupling (eliminating parallel traversals of identical data structures). These techniques enable us to transform a larger class of programs than the current deforestation algorithms. Programs are translated into a constructor-based rewrite system. Then, a completion procedure can be used for synthesis of the transformed rewrite system. Static analyses of the rewrite system are needed to automatize a given transformation strategy. They permit the following: (1) to automatically discover the specifications of the functions that need to be synthesized by completion in order to accommodate the strategy, (2) to control the production of critical pairs during the completion process according to the strategy, (3) to determine how and when to orient the critical pairs into rewrite rules without losing termination of the rewrite system, (4) to guarantee termination of the process, not only by ensuring termination of the completion, but also by ensuring that the transformation does not require infinitely many completions, and finally (5) to guarantee the effectiveness of the transformation. fl The author is supported in part by a contract with Air Force Material Command (F19628-93-C-0069).
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Bellegarde. </author> <title> Program Transformation and Rewriting. </title> <booktitle> Proc. 4th Int. Conf. on Rewriting Techniques and Applications, volume 488 of Lecture Notes in Computer Science, </booktitle> <pages> pages 226-239, </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Deforestation and tupling are particular instances of this strategy. In the Focus system [13], folding and unfolding are seen as rewritings. It has been pointed out by Dershowitz [11] that an unfold-fold strategy can be controlled by a completion procedure. Following this idea, the transformation system Astre <ref> [1, 2] </ref> is based on completion procedures. The first versions of Astre were highly interactive, requiring intervention of an expert user.
Reference: [2] <author> F. Bellegarde. Astre, </author> <title> a Transformation System using Completion. </title> <type> Technical Report, </type> <institution> Ore-gon Graduate Institute, </institution> <year> 1991. </year>
Reference-contexts: Deforestation and tupling are particular instances of this strategy. In the Focus system [13], folding and unfolding are seen as rewritings. It has been pointed out by Dershowitz [11] that an unfold-fold strategy can be controlled by a completion procedure. Following this idea, the transformation system Astre <ref> [1, 2] </ref> is based on completion procedures. The first versions of Astre were highly interactive, requiring intervention of an expert user.
Reference: [3] <author> F. Bellegarde. </author> <title> A transformation System Combining Partial Evaluation with Term Rewriting, </title> <booktitle> Proc. HOA'93: An international Workshop on Higher Order Algebra, Logic and Term Rewriting, to appear in a volume of Lecture Notes in Computer Science. </booktitle> <address> Amsterdam, </address> <month> Sept. 93. </month>
Reference-contexts: However, we are technically restricted to first-order terminating rewrite systems. Presently, we use a higher-order removal transformation performed by partial evaluation as a preprocessor of our system. Moreover, we can combine the partial evaluator Schism [8] with our system <ref> [3] </ref>. Partial evaluation, on the fly, transforms a given set of higher order laws into the first-order laws that facilitate a transformation. Acknowledgements I wish to thank Olivier Danvy for its encouragement and comments and Laura McKinney for her help in proof reading the paper.
Reference: [4] <author> F. Bellegarde. </author> <title> Automatic Transformation by Rewriting Techniques. </title> <type> Technical Report N o 94 009, </type> <institution> Oregon Graduate Institute, </institution> <year> 1994. </year>
Reference-contexts: The linearity ensures preservation of the termination of the union of the rewrite system R with the fusion rule as proved in <ref> [4] </ref>. As we will see later, the skip over recursive calls is required for ensuring the termination of the deforestation process. <p> It can be translated into : funf (x :: xs) = let val v = k (xs) in (x + v) :: (v :: []) end: Linearity and separability ensures that the introduction of the tupling rules preserves the termination of the rewrite system (see <ref> [4] </ref>). Note that fst, snd, pair are reserved symbols (i.e. 62 D [ C). <p> Such rules rewrite right-hand sides of the system R to get a system R fold . So doing, modulo the synthesis of the constructor-based rules R h , we perform the desired fusion or the desired tupling. Moreover we have proved in <ref> [4] </ref> that R fold is terminating when R is terminating. 4.1 Critical pair analysis Overlaps between a synthesis rule and a rule of R fold : l ! r happen, either when the top symbol f of l occurs as a producer in a fusion term left-hand side of the fusion <p> We proved in <ref> [4] </ref> that the process preserves the termination of the rewrite system. The termination of the completion which performs each synthesis is guaranteed because there can be only a finite number of overlaps that covers the inductive positions of a fresh symbol. <p> Moreover, a secondary fusion rule can be built, according to the process described in Section 4, by replacing the equality of symbols by ~. These criteria guarantee the termination of the process. A sketch of a proof for fusions without secondary rules is done in <ref> [4] </ref>. 5.2 Effectiveness The question we raise here, is about the effectiveness of our process.
Reference: [5] <author> W.H. </author> <title> Burge Recursive Programming Techniques, </title> <address> Addisson-Wesley, </address> <year> 1975. </year>
Reference-contexts: Although this compositional style of programming is attractive [14], it comes at the expense of efficiency. Compositions produce many intermediate data structures. One way to circumvent this problem is to perform fusion or deforestation on programs as advocated by Burge in <ref> [5] </ref> and by Wadler [18, 19]. Several approaches for eliminating useless intermediate data structures have been proposed. The algorithm proposed by Wadler [19] performs automatic deforestation on a restricted class of terms called treeless terms.
Reference: [6] <author> R. M. Burstall and J. Darlington. </author> <title> A Transformation System For Developing Recursive Programs. </title> <journal> J. of the Association for Computing Machinery, </journal> <volume> 24 </volume> <pages> 44-67, </pages> <year> 1977. </year>
Reference-contexts: These functions can be put together in a tuple as a single function that traverses the data structure only once. This is another way of transforming programs according to the tupling lemma [9]. General purpose program transformation systems are based on a unfold-fold method proposed by Burstall and Darlington <ref> [6] </ref>. Deforestation and tupling are particular instances of this strategy. In the Focus system [13], folding and unfolding are seen as rewritings. It has been pointed out by Dershowitz [11] that an unfold-fold strategy can be controlled by a completion procedure. <p> If for each rule l ! r 2 R, l, and r are irreducible by R, then R is interreduced. 2.2 Completion Procedure and Unfold-Fold Method In this paragraph, we illustrate by basic examples how a completion procedure interactively controls a fold-unfold method. The unfold-fold method <ref> [6] </ref> consists of 6 rules, namely Definition, Instantiation, Unfolding, Folding, Abstraction, and Law, that allow new identities to be introduced that are equational consequences of existing identities. Dershowitz [11] has shown how the combination of Instantiation and Folding is enabled by critical pair generation.
Reference: [7] <author> W. N. Chin. </author> <title> Safe fusion of Functional Expressions II: Further Improvements. </title> <journal> J. of Functional Programming, </journal> <volume> 11 </volume> <pages> 1-40, </pages> <year> 1994. </year>
Reference-contexts: Several approaches for eliminating useless intermediate data structures have been proposed. The algorithm proposed by Wadler [19] performs automatic deforestation on a restricted class of terms called treeless terms. Later, Chin's remarkable work on fusion <ref> [7] </ref> applies to a wider class of e-treeless terms and to higher-order programs in general. Sheard and Fegaras [16] utilizes laws about combinator compositions (Promotion theorems) to deforest programs written with combinators. <p> According to a vocabulary invented by Chin in <ref> [7] </ref>, the symbol @ is a consumer, and f (x) is a producer in the term t. Contrary to Chin, we do not consider g (t) as a producer. We say that @ can be a consumer only at inductive position 1. <p> We consider this case as another tactic for program manipulation which, from our point of view, is not a deforestation but a composition removal. This complementary tactic is also automatizable using completion and other kind of analyses. Chin in <ref> [7] </ref> has extended Wadler's work by refining the analysis.
Reference: [8] <author> C. Consel and O. Danvy. </author> <title> Tutorial Note on Partial Evaluation. </title> <booktitle> Conf. Record of the Twentieth Annual ACM Symposium on Principle of Programming Languages, </booktitle> <pages> pages 493-501. </pages> <note> ACM, 1993. Id: sas.tex,v 1.1 1994/03/01 23:29:43 bellegar Exp bellegar 22 </note>
Reference-contexts: However, we are technically restricted to first-order terminating rewrite systems. Presently, we use a higher-order removal transformation performed by partial evaluation as a preprocessor of our system. Moreover, we can combine the partial evaluator Schism <ref> [8] </ref> with our system [3]. Partial evaluation, on the fly, transforms a given set of higher order laws into the first-order laws that facilitate a transformation. Acknowledgements I wish to thank Olivier Danvy for its encouragement and comments and Laura McKinney for her help in proof reading the paper.
Reference: [9] <author> M. </author> <title> Fokkinga. </title> <journal> Tupling and Mutamorphisms. The Squiggolist, </journal> <volume> 1(4), </volume> <year> 1989. </year>
Reference-contexts: Such functions create a "parallel" traversal of a data structure. These functions can be put together in a tuple as a single function that traverses the data structure only once. This is another way of transforming programs according to the tupling lemma <ref> [9] </ref>. General purpose program transformation systems are based on a unfold-fold method proposed by Burstall and Darlington [6]. Deforestation and tupling are particular instances of this strategy. In the Focus system [13], folding and unfolding are seen as rewritings.
Reference: [10] <author> N. Dershowitz. </author> <title> Computing with rewrite systems, </title> <booktitle> Information and Control:65:122-157, </booktitle> <year> 1985. </year>
Reference-contexts: A transformation system must be automated to be effectively used as a tool in a transformational approach to software design. 1.2 This work Simple static analyses of first-order recursive equations allows us to automate both deforestation and tupling. We only consider terminating rewrite systems. Dershovitz has shown in <ref> [11, 10] </ref> that a completion procedure is good at synthesizing a constructor-based equational definition of a function h from a synthesis rule 1 which specifies how h is defined in terms of other functions.
Reference: [11] <author> N. Dershowitz. </author> <title> Completion and its Applications. Resolution of Equations in Algebraic Structures,, </title> <booktitle> 2 </booktitle> <pages> 31-86, </pages> <publisher> Academic Press, </publisher> <year> 1988. </year>
Reference-contexts: General purpose program transformation systems are based on a unfold-fold method proposed by Burstall and Darlington [6]. Deforestation and tupling are particular instances of this strategy. In the Focus system [13], folding and unfolding are seen as rewritings. It has been pointed out by Dershowitz <ref> [11] </ref> that an unfold-fold strategy can be controlled by a completion procedure. Following this idea, the transformation system Astre [1, 2] is based on completion procedures. The first versions of Astre were highly interactive, requiring intervention of an expert user. <p> A transformation system must be automated to be effectively used as a tool in a transformational approach to software design. 1.2 This work Simple static analyses of first-order recursive equations allows us to automate both deforestation and tupling. We only consider terminating rewrite systems. Dershovitz has shown in <ref> [11, 10] </ref> that a completion procedure is good at synthesizing a constructor-based equational definition of a function h from a synthesis rule 1 which specifies how h is defined in terms of other functions. <p> Moreover, a completion procedure is far too general. Its purpose is to generate critical pairs, equational consequences of a set of rules coming from overlapping left-hand sides of existing rules. What N. Dershowitz noticed in <ref> [11] </ref> is that it is possible that the completion generates the critical pairs which constitute a constructor-based definition of a function h. However this generation: (1) must be controlled by a suitable ordering, (2) can be explosive, and (3) can even loop by generating infinitely many critical pairs. <p> The unfold-fold method [6] consists of 6 rules, namely Definition, Instantiation, Unfolding, Folding, Abstraction, and Law, that allow new identities to be introduced that are equational consequences of existing identities. Dershowitz <ref> [11] </ref> has shown how the combination of Instantiation and Folding is enabled by critical pair generation. Unfolding and Law are simplifications by rewriting. Definition is the introduction of a synthesis rule by the user, Abstraction is used for a tupling tactic.
Reference: [12] <author> A. Gill, J. Launchbury and S.L. Peyton Jones. </author> <title> A short cut to Deforestation. </title> <booktitle> Proc. of the 6th Conf. on Functional Programming Languages and Computer Architecture, Copenhagen, </booktitle> <pages> pages 223-232, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: This technique is applicable to a class of potentially normalizable terms built with a special set of higher-order combinators. An automatic way to implement deforestation inside the Haskell's compiler has been shown in <ref> [12] </ref>. Also a widened deforestation algorithm is proposed in a recent paper [17]. Deforestation algorithms do not recognize that an expression contains two or more functions that consume the same data structure. Such functions create a "parallel" traversal of a data structure.
Reference: [13] <author> U. S. Reddy. </author> <title> Transformational derivation of programs using the Focus system. </title> <booktitle> Symp. Practical Software Development Environments, </booktitle> <pages> pages 163-172, </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1988. </year>
Reference-contexts: This is another way of transforming programs according to the tupling lemma [9]. General purpose program transformation systems are based on a unfold-fold method proposed by Burstall and Darlington [6]. Deforestation and tupling are particular instances of this strategy. In the Focus system <ref> [13] </ref>, folding and unfolding are seen as rewritings. It has been pointed out by Dershowitz [11] that an unfold-fold strategy can be controlled by a completion procedure. Following this idea, the transformation system Astre [1, 2] is based on completion procedures.
Reference: [14] <author> J. Hughes. </author> <title> Why Functional Programming Matters. </title> <journal> Computer Journal, </journal> <volume> 32(2) </volume> <pages> 98-107, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction 1.1 Deforestation and Functional Programming It has often been said that functional programs are constructed using only functions as pieces. Data structures such as lists and trees are the glue to hold them together. Although this compositional style of programming is attractive <ref> [14] </ref>, it comes at the expense of efficiency. Compositions produce many intermediate data structures. One way to circumvent this problem is to perform fusion or deforestation on programs as advocated by Burge in [5] and by Wadler [18, 19]. Several approaches for eliminating useless intermediate data structures have been proposed.
Reference: [15] <author> U. S. Reddy. </author> <title> Rewriting Techniques for Program Synthesis. </title> <booktitle> Proc. of the 3rd Conf. on Rewriting Techniques and Applications, volume 355 of Lecture Notes in Computer Science, </booktitle> <pages> pages 388-403, </pages> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: It is worthwhile to notice that this tactic can be applied to transform a function that computes the n th fibonacci number k in time proportional to k itself into a function that computes the same number in only n steps. This example has been used in <ref> [15] </ref> showing how a completion procedure produces useless explosion of critical pairs when controlling an unfold-fold transformation. Our way of automating the tupling and deforestation tactics always generates exactly the needed critical pairs.
Reference: [16] <author> T. Sheard and L. Fegaras. </author> <title> A fold for All Seasons. </title> <booktitle> 6th Conf. on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 233-242, </pages> <year> 1993. </year>
Reference-contexts: The algorithm proposed by Wadler [19] performs automatic deforestation on a restricted class of terms called treeless terms. Later, Chin's remarkable work on fusion [7] applies to a wider class of e-treeless terms and to higher-order programs in general. Sheard and Fegaras <ref> [16] </ref> utilizes laws about combinator compositions (Promotion theorems) to deforest programs written with combinators. This technique is applicable to a class of potentially normalizable terms built with a special set of higher-order combinators. An automatic way to implement deforestation inside the Haskell's compiler has been shown in [12].
Reference: [17] <author> M. H. Strensen, R. Gluck and N.D. Jones. </author> <title> Towards Unifying Deforestation, Supercom-pilation, Partial Evaluation and Generalized Partial Computation. </title> <booktitle> Proc. of Eureopean Symposium on Programming, Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: This technique is applicable to a class of potentially normalizable terms built with a special set of higher-order combinators. An automatic way to implement deforestation inside the Haskell's compiler has been shown in [12]. Also a widened deforestation algorithm is proposed in a recent paper <ref> [17] </ref>. Deforestation algorithms do not recognize that an expression contains two or more functions that consume the same data structure. Such functions create a "parallel" traversal of a data structure. These functions can be put together in a tuple as a single function that traverses the data structure only once. <p> It rejects fusions tails (x@y), length (f lat (x)), and length (rev (x)) as unsafe. Wadler's rejects all of them. These annotations permit the extended deforestation algorithm to track all the effective fusions that do not require laws or secondary fusions. A recent article <ref> [17] </ref> compares diverse transformation techniques: deforestation, supercom-pilation, partial evaluation, and generalized partial computation with respect to the amount of information propagation they enable. It proposes a widened deforestation algorithm which enables more information propagation than Chin's extended deforestation algorithm.
Reference: [18] <author> P. Wadler. </author> <title> Listlessness is better than laziness II: Composing listless functions. Workshop on Program as Data Objects, </title> <booktitle> volume 217 of Lecture Notes in Computer Science, </booktitle> <pages> pages 282-305. </pages> <publisher> Springer Verlag, </publisher> <address> Copenhagen, </address> <year> 1985. </year>
Reference-contexts: Although this compositional style of programming is attractive [14], it comes at the expense of efficiency. Compositions produce many intermediate data structures. One way to circumvent this problem is to perform fusion or deforestation on programs as advocated by Burge in [5] and by Wadler <ref> [18, 19] </ref>. Several approaches for eliminating useless intermediate data structures have been proposed. The algorithm proposed by Wadler [19] performs automatic deforestation on a restricted class of terms called treeless terms.
Reference: [19] <author> P. Wadler, </author> <title> Deforestation: Transforming programs to eliminate trees. </title> <booktitle> Proc. of European Symposium on Programming, volume 300 of Lecture Notes in Computer Science, </booktitle> <pages> pages 344-358. </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Although this compositional style of programming is attractive [14], it comes at the expense of efficiency. Compositions produce many intermediate data structures. One way to circumvent this problem is to perform fusion or deforestation on programs as advocated by Burge in [5] and by Wadler <ref> [18, 19] </ref>. Several approaches for eliminating useless intermediate data structures have been proposed. The algorithm proposed by Wadler [19] performs automatic deforestation on a restricted class of terms called treeless terms. <p> Compositions produce many intermediate data structures. One way to circumvent this problem is to perform fusion or deforestation on programs as advocated by Burge in [5] and by Wadler [18, 19]. Several approaches for eliminating useless intermediate data structures have been proposed. The algorithm proposed by Wadler <ref> [19] </ref> performs automatic deforestation on a restricted class of terms called treeless terms. Later, Chin's remarkable work on fusion [7] applies to a wider class of e-treeless terms and to higher-order programs in general. <p> Let us consider only the works which automatize deforestation of first-order functional programs. The ancestor is Wadler's deforestation algorithm in <ref> [19] </ref>. Fusion terms must be composed of treeless function symbols to be accepted by the algorithm. Using our terminology, a defined symbol f is treeless if the right-hand side of rules in R f are linear and built solely with constructors and calls of defined functions with variables as arguments.
References-found: 19

