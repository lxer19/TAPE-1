URL: http://swarm.cs.wustl.edu/~picco/papers/tse98.ps.gz
Refering-URL: http://swarm.cs.wustl.edu/~picco/listpub.html
Root-URL: http://www.cs.wustl.edu
Title: Understanding Code Mobility  
Author: Alfonso Fuggetta, Gian Pietro Picco, and Giovanni Vigna 
Keyword: Mobile code, mobile agent, distributed application, design paradigm.  
Date: 1998 1  
Note: IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 24, NO. XX, XXXXX  
Abstract: The technologies, architectures, and methodologies traditionally used to develop distributed applications exhibit a variety of limitations and drawbacks when applied to large scale distributed settings (e.g., the Internet). In particular, they fail in providing the desired degree of config-urability, scalability, and customizability. To address these issues, researchers are investigating a variety of innovative approaches. The most promising and intriguing ones are those based on the ability of moving code across the nodes of a network, exploiting the notion of mobile code. As an emerging research field, code mobility is generating a growing body of scientific literature and industrial developments. Nevertheless, the field is still characterized by the lack of a sound and comprehensive body of concepts and terms. As a consequence, it is rather difficult to understand, assess, and compare the existing approaches. In turn, this limits our ability to fully exploit them in practice, and to further promote the research work on mobile code. Indeed, a significant symptom of this situation is the lack of a commonly accepted and sound definition of the term "mobile code" itself. This paper presents a conceptual framework for understanding code mobility. The framework is centered around a classification that introduces three dimensions: technologies, design paradigms, and applications. The contribution of the paper is twofold. First, it provides a set of terms and concepts to understand and compare the approaches based on the notion of mobile code. Second, it introduces criteria and guidelines that support the developer in the identification of the classes of applications that can leverage off of mobile code, in the design of these applications, and, finally, in the selection of the most appropriate implementation technologies. The presentation of the classification is intertwined with a review of the state of the art in the field. Finally, the use of the classification is exemplified in a case study. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G.H. Forman and J. Zahorjan, </author> <title> "The Challenges of Mobile Computing," </title> <journal> IEEE Computer, </journal> <volume> vol. 27, no. 4, </volume> <pages> pp. 38-47, </pages> <year> 1994. </year>
Reference-contexts: These differences must be taken into account since the design stage. For instance, recent developments in mobile computing evidenced that low-bandwidth and low-reliable communication channels require new design methodologies for applications in a mobile setting <ref> [1] </ref>, [2]. In networks where some regions are connected through wireless links while others are connected through conventional links the design becomes complex. It is important to cope with frequent disconnections and avoid the generation of traffic over the low-bandwidth links as much as possible.
Reference: [2] <author> T. Imielinsky and B.R. Badrinath, </author> <title> "Wireless Computing: Challenges in Data Management," </title> <journal> Comm. of the ACM, </journal> <volume> vol. 37, no. 10, </volume> <pages> pp. 18-28, </pages> <year> 1994. </year>
Reference-contexts: These differences must be taken into account since the design stage. For instance, recent developments in mobile computing evidenced that low-bandwidth and low-reliable communication channels require new design methodologies for applications in a mobile setting [1], <ref> [2] </ref>. In networks where some regions are connected through wireless links while others are connected through conventional links the design becomes complex. It is important to cope with frequent disconnections and avoid the generation of traffic over the low-bandwidth links as much as possible.
Reference: [3] <institution> Object Management Group, CORBA: Architecture and Specification, </institution> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: When a service is invoked, there is no clue about the node of the network that will actually provide the service, and even about the presence of a network at all. As an example, CORBA <ref> [3] </ref> services can be regarded as TDS services since a CORBA programmer is usually unaware of the network topology and always interacts with a single well-known object broker. At least in principle, the TDS is built upon the services provided by the underlying NOS.
Reference: [4] <author> A. Carzaniga, G.P. Picco, and G. Vigna, </author> <title> "Designing Distributed Applications with Mobile Code Paradigms," </title> <booktitle> in Proc. of the 19 th Int. Conf. on Software Engineering (ICSE'97), </booktitle> <editor> R. Taylor, Ed. </editor> <year> 1997, </year> <pages> pp. 22-32, </pages> <publisher> ACM Press. </publisher>
Reference-contexts: We identify three main design paradigms exploiting code mobility: remote evaluation, code on demand, and mobile agent. These paradigms are characterized by the location 3 The reader interested in the original formulation of the paradigms described here is directed to <ref> [4] </ref>. <p> This type of application has been often considered "the killer application" motivating a design based on the MA paradigm. However, analysis to determine the network traffic in some typical cases evidenced that, according to the parameters of the application, the CS paradigm sometimes can still be the best choice <ref> [4] </ref>. B.2 Active Documents In active documents applications, traditionally passive data, like e-mail or Web pages, are enhanced with the capability of executing programs which are somewhat related with the document contents, enabling enhanced presentation and interaction. <p> Then, the tradeoffs among the various paradigms must be analyzed for each application functionality whose design could involve code mobility. To achieve this, in Section VI-C we build a model of the application functionality that enables quantitative analysis of the tradeoffs, along the lines of <ref> [4] </ref>. Finally, after the suitable paradigms have been chosen, the technology for implementation has to be selected by examining the tradeoffs highlighted in Section IV, e.g., trading ease of programming for lightweight implementation. This will be discussed in Section VI-D.
Reference: [5] <author> J.K. Boggs, </author> <title> "IBM Remote Job Entry Facility: Generalize Subsystem Remote Job Entry Facility," </title> <journal> IBM Technical Disclosure Bulletin 752, IBM, </journal> <month> Aug. </month> <year> 1973. </year>
Reference: [6] <author> Adobe Systems Incorporated, </author> <title> PostScript Language Reference Manual, </title> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference: [7] <author> M. Nuttall, </author> <title> "Survey of systems providing process or object migration," </title> <type> Tech. Rep. Doc 94/10, </type> <institution> Dept. of Computing, Imperial College, </institution> <month> May </month> <year> 1994. </year>
Reference: [8] <author> G. Thiel, </author> <title> "Locus operating system, a transparent system," </title> <journal> Computer Communications, </journal> <volume> vol. 14, no. 6, </volume> <pages> pp. 336-346, </pages> <year> 1991. </year>
Reference: [9] <author> E. Jul, H. Levy, N. Hutchinson, and A. Black, </author> <title> "Fine-grained Mobility in the Emerald System," </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> vol. 6, no. 2, </volume> <pages> pp. 109-133, </pages> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: Object migration makes it possible to move objects among address spaces, implementing a finer grained mobility with respect to process-level migration. For example, Emerald <ref> [9] </ref> provides object migration at any level of granularity ranging from small, atomic data to complex objects. Emerald does not provide complete transparency since the programmer can determine objects locations and may request explicitly the migration of an object to a particular node.
Reference: [10] <author> R. Lea, C. Jacquemont, and E. Pillevesse, </author> <title> "COOL: System Support for Distributed Object-Oriented Programming," </title> <journal> Comm. of the ACM, </journal> <volume> vol. 36, no. 9, </volume> <pages> pp. 37-46, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Emerald does not provide complete transparency since the programmer can determine objects locations and may request explicitly the migration of an object to a particular node. An example of system providing transparent migration is COOL <ref> [10] </ref>, an object-oriented extension of the Chorus operating system [11]. COOL is able to move objects among address spaces without user intervention or knowledge. Process and object migration address the issues that arise when code and state are moved among the hosts of a loosely coupled, small scale distributed system.
Reference: [11] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, P. Leonard, S. Langlois, and W. Neuhauser, </author> <title> "Chorus Distributed Operating Systems," </title> <journal> Computing Systems, </journal> <volume> vol. 1, </volume> <pages> pp. 305-379, </pages> <month> Oct. </month> <year> 1988. </year>
Reference-contexts: Emerald does not provide complete transparency since the programmer can determine objects locations and may request explicitly the migration of an object to a particular node. An example of system providing transparent migration is COOL [10], an object-oriented extension of the Chorus operating system <ref> [11] </ref>. COOL is able to move objects among address spaces without user intervention or knowledge. Process and object migration address the issues that arise when code and state are moved among the hosts of a loosely coupled, small scale distributed system.
Reference: [12] <author> C.G. Harrison, D.M. Chess, and A. Kershenbaum, </author> <title> "Mobile Agents: Are they a good idea?," </title> <booktitle> In Vitek and Tschudin [73], </booktitle> <pages> pp. 25-47, </pages> <note> Also available as IBM Technical Report. </note>
Reference-contexts: A first problem is the unclear distinction between implementation technologies, specific applications, and paradigms used to design these applications. In an early and yet valuable assessment of code mobility <ref> [12] </ref>, the authors analyze and compare issues and concepts that belong to different abstraction levels. <p> In [23], Knabe lists the essential characteristics of a mobile code language. They include support for manipulating, transmitting, receiving, and executing "code-containing objects". However, there is no discussion about how to manage the state of mobile components. Other contributions [24], <ref> [12] </ref> consider only the support for mobility of both code and state, without mentioning weaker forms of code mobility involving code migration alone|as we discuss later on in the paper. Certainly, confusion and disagreement are typical of a new and still immature research field.
Reference: [13] <author> L. Bic, M. Fukuda, and M. Dillencourt, </author> <title> "Distributed Computing Using Autonomous Objects," </title> <booktitle> IEEE Computer, </booktitle> <month> Aug. </month> <year> 1996. </year>
Reference-contexts: In an early and yet valuable assessment of code mobility [12], the authors analyze and compare issues and concepts that belong to different abstraction levels. Similarly, in a recent work about autonomous objects <ref> [13] </ref>, mechanisms like REV [14] and RPC [15] are compared to the Echo distributed algorithms [16], to applications like "intelligent e-mail" and Web browsers, and to paradigms for structuring distributed applications, like mobile agents. We argue that these different concepts and notions cannot be compared directly.
Reference: [14] <author> J.W. Stamos and D.K. Gifford, </author> <title> "Implementing Remote Evaluation," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 16, no. 7, </volume> <pages> pp. 710-722, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: In an early and yet valuable assessment of code mobility [12], the authors analyze and compare issues and concepts that belong to different abstraction levels. Similarly, in a recent work about autonomous objects [13], mechanisms like REV <ref> [14] </ref> and RPC [15] are compared to the Echo distributed algorithms [16], to applications like "intelligent e-mail" and Web browsers, and to paradigms for structuring distributed applications, like mobile agents. We argue that these different concepts and notions cannot be compared directly. <p> Consequently, A sends the service know-how to a computational component B located at the remote site. B, in turn, 4 Hereafter, by "remote evaluation" we will refer to the design paradigm presented in this section. Although it has been inspired by work on the REV system <ref> [14] </ref>, they have to be kept definitely distinct. Our REV is a design paradigm, while the REV system is a technology that may be used to actually implement an application designed using the REV paradigm. 12 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 24, NO.
Reference: [15] <author> A. Birrell and B. Nelson, </author> <title> "Implementing Remote Procedure Calls," </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> vol. 2, no. 1, </volume> <pages> pp. 29-59, </pages> <month> Feb. </month> <year> 1984. </year>
Reference-contexts: In an early and yet valuable assessment of code mobility [12], the authors analyze and compare issues and concepts that belong to different abstraction levels. Similarly, in a recent work about autonomous objects [13], mechanisms like REV [14] and RPC <ref> [15] </ref> are compared to the Echo distributed algorithms [16], to applications like "intelligent e-mail" and Web browsers, and to paradigms for structuring distributed applications, like mobile agents. We argue that these different concepts and notions cannot be compared directly.
Reference: [16] <author> E.J.H. Chang, </author> <title> "Echo Algorithms: Depth Parallel Operations on General Graphs," </title> <journal> IEEE Trans. on Software Engineering, </journal> <month> July </month> <year> 1982. </year>
Reference-contexts: In an early and yet valuable assessment of code mobility [12], the authors analyze and compare issues and concepts that belong to different abstraction levels. Similarly, in a recent work about autonomous objects [13], mechanisms like REV [14] and RPC [15] are compared to the Echo distributed algorithms <ref> [16] </ref>, to applications like "intelligent e-mail" and Web browsers, and to paradigms for structuring distributed applications, like mobile agents. We argue that these different concepts and notions cannot be compared directly.
Reference: [17] <author> D. Johansen, R. van Renesse, and F.B. Schneider, </author> <title> "An Introduction to the TACOMA Distributed System Version 1.0," </title> <type> Tech. Rep. 95-23, </type> <institution> Dept. of Computer Science, Univ. of Tromso and Cornell Univ., Tromso, Norway, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: We argue that these different concepts and notions cannot be compared directly. It is as inappropriate and misleading as trying to compare the emacs editor, the fork UNIX system call, and the client-server design paradigm. There is also confusion about terminology. For instance, several systems <ref> [17] </ref>, [18] claim to be able to move the state of a component along with its code. <p> This definition has actually different interpretations. For example, while in Telescript [19] an agent is represented by a thread that can migrate among different nodes carrying its execution state, in TACOMA <ref> [17] </ref> agents are just code fragments associated with initialization data that can be shipped to a remote host. They do not have the ability to migrate once they have started their execution. <p> Data space management in an object-group is always by move; bindings to migrated objects owned by EUs in the source CE are transformed into network references. C.11 TACOMA In TACOMA <ref> [17] </ref> (Tromso And COrnell Mobile Agents), the Tcl language is extended to include primitives that support weak mobility. Executing units, called agents, are implemented as Unix processes running the Tcl interpreter.
Reference: [18] <author> A.S. Park and S. Leuker, </author> <title> "A Multi-Agent Architecture Supporting Services Access," </title> <booktitle> In Rothermel and Popescu-Zeletin [72], </booktitle> <pages> pp. 62-73. </pages>
Reference-contexts: We argue that these different concepts and notions cannot be compared directly. It is as inappropriate and misleading as trying to compare the emacs editor, the fork UNIX system call, and the client-server design paradigm. There is also confusion about terminology. For instance, several systems [17], <ref> [18] </ref> claim to be able to move the state of a component along with its code.
Reference: [19] <author> J.E. White, </author> <title> "Telescript Technology: Mobile Agents," in Software Agents, </title> <editor> J. Bradshaw, Ed. </editor> <publisher> AAAI Press/MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: In the distributed system community the term "mobile agent" is used to denote a software component that is able to move between different execution environments. This definition has actually different interpretations. For example, while in Telescript <ref> [19] </ref> an agent is represented by a thread that can migrate among different nodes carrying its execution state, in TACOMA [17] agents are just code fragments associated with initialization data that can be shipped to a remote host. <p> In version 1.2, the system has been extended to support a number of interpreted languages, namely Python, Scheme, Perl, and C. C.12 Telescript Developed by General Magic, Telescript <ref> [19] </ref> is an object-oriented language conceived for the development of large distributed applications. Security has been one of the driving factors in the language design, together with a focus on strong mobility.
Reference: [20] <author> P. Maes, </author> <title> "Agents that Reduce Work and Information Overload," </title> <journal> Comm. of the ACM, </journal> <volume> vol. 37, no. 7, </volume> <month> July </month> <year> 1994. </year>
Reference-contexts: They do not have the ability to migrate once they have started their execution. On the other hand, in the artificial intelligence community the term "agent" denotes a software 2 component that is able to achieve a goal by performing actions and reacting to events in a dynamic environment <ref> [20] </ref>. The behavior of this component is determined by the knowledge of the relationships among events, actions, and goals. Moreover, knowledge can be exchanged with other agents, or increased by some inferential activity [21].
Reference: [21] <author> M. Genesereth and S. Ketchpel, </author> <title> "Software Agents," </title> <journal> Comm. of the ACM, </journal> <volume> vol. 37, no. 7, </volume> <month> July </month> <year> 1994. </year>
Reference-contexts: The behavior of this component is determined by the knowledge of the relationships among events, actions, and goals. Moreover, knowledge can be exchanged with other agents, or increased by some inferential activity <ref> [21] </ref>.
Reference: [22] <author> M. Wooldridge and N.R. Jennings, </author> <title> "Intelligent Agents: </title> <journal> Theory and Practice," Knowledge Engineering Review, </journal> <volume> vol. 10, no. 2, </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: The behavior of this component is determined by the knowledge of the relationships among events, actions, and goals. Moreover, knowledge can be exchanged with other agents, or increased by some inferential activity [21]. Although mobility is not the most characterizing aspect of these entities <ref> [22] </ref>, there is a tendency to blend this notion of intelligent agent with the one originating from distributed systems and thus assume implicitly that a mobile agent is also intelligent (and vice 2 In this paper we ignore the implications of broader notions of agent which are not restricted to the
Reference: [23] <author> F.C. Knabe, </author> <title> Language Support for Mobile Agents, </title> <type> Ph.D. thesis, </type> <institution> Carnegie Mellon Univ., </institution> <address> Pittsburgh, PA, USA, </address> <month> Dec. </month> <year> 1995, </year> <note> Also available as Carnegie Mellon School of Computer Science Technical Report CMU-CS-95-223 and European Computer Industry Centre Technical Report ECRC-95-36. </note>
Reference-contexts: This is actually generating confusion since there is a mix of concepts and notions that belong to two different layers, i.e., the layer providing code mobility and the one exploiting it. Finally, there is no definition or agreement about the distinguishing characteristics of languages supporting code mobility. In <ref> [23] </ref>, Knabe lists the essential characteristics of a mobile code language. They include support for manipulating, transmitting, receiving, and executing "code-containing objects". However, there is no discussion about how to manage the state of mobile components. <p> C.3 Facile Developed at ECRC in Munich, Facile [31] is a functional language that extends the Standard ML language with primitives for distribution, concurrency, and communication. The language has been extended further in <ref> [23] </ref> to support weak mobility. Executing units are implemented as threads that run in Facile CEs, called nodes. The channel abstraction is used for communication between threads. Channels can be used to communicate any legal value of the Facile language.
Reference: [24] <author> H. Peine and T. Stolpmann, </author> <title> "The Architecture of the Ara Platform for Mobile Agents," </title> <booktitle> In Rothermel and Popescu-Zeletin [72], </booktitle> <pages> pp. 50-61. </pages>
Reference-contexts: In [23], Knabe lists the essential characteristics of a mobile code language. They include support for manipulating, transmitting, receiving, and executing "code-containing objects". However, there is no discussion about how to manage the state of mobile components. Other contributions <ref> [24] </ref>, [12] consider only the support for mobility of both code and state, without mentioning weaker forms of code mobility involving code migration alone|as we discuss later on in the paper. Certainly, confusion and disagreement are typical of a new and still immature research field. <p> This mechanism is asynchronous and immediate. A copy of the variables belonging to the execution state of the EU invoking the submit may be passed as parameters of this operation in order to migrate these variables together with the Tcl script. C.2 Ara Developed at University of Kaiserslautern, Ara <ref> [24] </ref> is a multi-language MCS that supports strong mobility. Ara EUs, called agents, are managed by a language-independent system core plus interpreters for the languages supported|at the time of writing C, C++, and Tcl.
Reference: [25] <author> D. Wong, N. Paciorek, T. Walsh, J. DiCelie, M. Young, and B. Peet, </author> <title> "Concordia: An Infrastructure for Collaborating Mobile Agents," </title> <booktitle> In Rothermel and Popescu-Zeletin [72], </booktitle> <pages> pp. 86-97. </pages>
Reference-contexts: The set of technologies considered is not exhaustive, and is constrained by space and by the focus of the paper. However, the reader may actually verify the soundness of the classification by applying it to other MCSs not considered here, like the ones described in <ref> [25] </ref>, [26], [27]. Also, the reader interested in a more detailed analysis of the linguistic problems posed by the introduction of mobility in programming languages can refer to [28], [29]. A.
Reference: [26] <author> M. Fukuda, L. Bic, M. Dillencourt, and F. Merchant, </author> <title> "Intra-Inter-Object Coordination with MESSENGERS," </title> <booktitle> in 1 st Int. Conf. on Coordination Models and Languages (COORDINATION'96), </booktitle> <year> 1996. </year>
Reference-contexts: The set of technologies considered is not exhaustive, and is constrained by space and by the focus of the paper. However, the reader may actually verify the soundness of the classification by applying it to other MCSs not considered here, like the ones described in [25], <ref> [26] </ref>, [27]. Also, the reader interested in a more detailed analysis of the linguistic problems posed by the introduction of mobility in programming languages can refer to [28], [29]. A.
Reference: [27] <author> J. Kiniry and D. Zimmerman, </author> <title> "A Hands-On Look at Java Mobile Agents," </title> <journal> IEEE Internet Computing, </journal> <volume> vol. 1, no. 4, </volume> <pages> pp. 21-30, </pages> <year> 1997. </year>
Reference-contexts: The set of technologies considered is not exhaustive, and is constrained by space and by the focus of the paper. However, the reader may actually verify the soundness of the classification by applying it to other MCSs not considered here, like the ones described in [25], [26], <ref> [27] </ref>. Also, the reader interested in a more detailed analysis of the linguistic problems posed by the introduction of mobility in programming languages can refer to [28], [29]. A.
Reference: [28] <author> D. Volpano, </author> <title> "Provably-Secure Programming Languages for Remote Evaluation," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 28A, </volume> <month> Dec. </month> <year> 1996, </year> <booktitle> Participation statement for ACM Workshop on Strategic Directions in Computing Research. </booktitle>
Reference-contexts: Also, the reader interested in a more detailed analysis of the linguistic problems posed by the introduction of mobility in programming languages can refer to <ref> [28] </ref>, [29]. A. A Virtual Machine for Code Mobility Traditional distributed systems can be accommodated in the virtual machine shown on the left-hand side of Figure 1. The lowest layer, just upon the hardware, is constituted by the Core Operating System (COS).
Reference: [29] <author> G. Cugola, C. Ghezzi, G.P. Picco, and G. Vigna, </author> <title> "Analyzing Mobile Code Languages," </title> <booktitle> In Vitek and Tschudin [73], </booktitle> <pages> pp. 93-111. </pages>
Reference-contexts: Also, the reader interested in a more detailed analysis of the linguistic problems posed by the introduction of mobility in programming languages can refer to [28], <ref> [29] </ref>. A. A Virtual Machine for Code Mobility Traditional distributed systems can be accommodated in the virtual machine shown on the left-hand side of Figure 1. The lowest layer, just upon the hardware, is constituted by the Core Operating System (COS).
Reference: [30] <author> R.S. Gray, </author> <title> "Agent Tcl: A transportable agent system," </title> <booktitle> in Proc. of the CIKM Workshop on Intelligent Information Agents, </booktitle> <address> Baltimore, Md., </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: C. A Survey of Mobile Code Technologies Currently available technologies differ in the mechanisms they provide to support mobility. In this section we apply the classification of mobility mechanisms presented so far to a number of existing MCSs. C.1 Agent Tcl Developed at the University of Darthmouth, Agent Tcl <ref> [30] </ref> provides a Tcl interpreter extended with support for strong mobility. In Agent Tcl, an EU (called agent) is implemented by a Unix process running the language interpreter. Since EUs run in separate address spaces, they can share only resources provided by the underlying operating system, like files.
Reference: [31] <author> B. Thomsen, L. Leth, S. Prasad, T.-M. Kuo, A. Kramer, F.C. Knabe, and A. Giacalone, </author> <title> "Facile Antigua Release programming guide," </title> <type> Tech. Rep. </type> <institution> ECRC-93-20, European Computer Industry Research Centre, Munich, Germany, </institution> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: For each mechanism, the configuration of bindings before and after migration of the grayed EU is shown. and data space management is simplified by the fact that agents cannot share anything but system resources|whose bindings are always removed upon migration. C.3 Facile Developed at ECRC in Munich, Facile <ref> [31] </ref> is a functional language that extends the Standard ML language with primitives for distribution, concurrency, and communication. The language has been extended further in [23] to support weak mobility. Executing units are implemented as threads that run in Facile CEs, called nodes.
Reference: [32] <author> Sun Microsystems, </author> <title> "The Java Language: An Overview," </title> <type> Tech. Rep., </type> <institution> Sun Microsystems, </institution> <year> 1994. </year>
Reference-contexts: As for data space management, this takes place always by copy, except for special variables called ubiquitous values. They represent resources replicated in each Facile node and are always accessed with bindings by type, exploiting a re-binding mechanism. C.4 Java Developed by Sun Microsystems, Java <ref> [32] </ref> has triggered most of the attention and expectations on code mobility. The original goal of the language designers was to provide a portable, clean, easy-to-learn, and general-purpose object-oriented language, which has been subsequently re-targeted by the growth of Internet.
Reference: [33] <author> D.B. Lange, </author> <title> "Java Aglets Application Programming Interface (J-AAPI)," </title> <institution> IBM Corp. White Paper, </institution> <month> Feb. </month> <year> 1997. </year>
Reference-contexts: In this context, the downloading of applets can be regarded as a mechanism provided by the browser to support fetching of stand-alone code. C.5 Java Aglets The Java Aglets API (J-AAPI) <ref> [33] </ref>, developed by IBM Tokyo Research Laboratory in Japan, extends Java with support for weak mobility. Aglets [34], the EUs, are threads in a Java interpreter which constitutes the CE. The API provides the notion of context as an abstraction of the CE.
Reference: [34] <author> D.B. Lange and D.T. Chang, </author> <title> "IBM Aglets Workbench| Programming Mobile Agents in Java," </title> <institution> IBM Corp. White Paper, </institution> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: In this context, the downloading of applets can be regarded as a mechanism provided by the browser to support fetching of stand-alone code. C.5 Java Aglets The Java Aglets API (J-AAPI) [33], developed by IBM Tokyo Research Laboratory in Japan, extends Java with support for weak mobility. Aglets <ref> [34] </ref>, the EUs, are threads in a Java interpreter which constitutes the CE. The API provides the notion of context as an abstraction of the CE.
Reference: [35] <author> C. Tschudin, </author> <title> An Introduction to the M0 Messenger Language, </title> <institution> Univ. of Geneva, Switzerland, </institution> <year> 1994. </year>
Reference-contexts: The attribute values may contain references to resources, which are always managed by copy. Finally, being based on Java, the Aglets API supports Java mechanisms as well. C.6 M0 Implemented at the University of Geneva, M0 <ref> [35] </ref> is a stack-based interpreted language that implements the concept of messengers. Messengers|representing EUs| are sequences of instructions that are transmitted among platforms|representing CEs|and executed unconditionally upon receipt. Messengers [36], in turn, can submit the code of other messengers to remote platforms.
Reference: [36] <editor> C. Tschudin, "OO-Agents and Messengers," </editor> <booktitle> in ECOOP'95 Workshop W10 on Objects and Agents, </booktitle> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: C.6 M0 Implemented at the University of Geneva, M0 [35] is a stack-based interpreted language that implements the concept of messengers. Messengers|representing EUs| are sequences of instructions that are transmitted among platforms|representing CEs|and executed unconditionally upon receipt. Messengers <ref> [36] </ref>, in turn, can submit the code of other messengers to remote platforms. Re sources are always considered transferrable and fixed, and the submitting messenger may copy them in the message containing the submitted code to make them available at the destination CE.
Reference: [37] <author> M. Straer, J. Baumann, and F. Hohl, </author> <title> "Mole|A Java Based Mobile Agent System," </title> <booktitle> in Special Issues in Object-Oriented Programming: Workshop Reader of the 10 th European Conf. on Object-Oriented Programming ECOOP'96, </booktitle> <editor> M. Muhlauser, Ed. </editor> <month> July </month> <year> 1996, </year> <pages> pp. 327-334, </pages> <month> dpunkt. </month>
Reference-contexts: Therefore, M0 is a weak MCS providing shipping of stand-alone code (whose execution is asynchronous and immediate), and data space management is by copy. C.7 Mole Developed at University of Stuttgart, Mole <ref> [37] </ref>, [38] is a Java API that supports weak mobility. Mole agents are Java objects which run as threads of the JVM, which is abstracted into a place, the Mole CE.
Reference: [38] <author> J. Baumann, F. Hohl, N. Radouniklis, K. Rothermel, and M. Straer, </author> <title> "Communication Concepts for Mobile Agent Systems," </title> <booktitle> In Rothermel and Popescu-Zeletin [72], </booktitle> <pages> pp. 123-135. </pages>
Reference-contexts: Therefore, M0 is a weak MCS providing shipping of stand-alone code (whose execution is asynchronous and immediate), and data space management is by copy. C.7 Mole Developed at University of Stuttgart, Mole [37], <ref> [38] </ref> is a Java API that supports weak mobility. Mole agents are Java objects which run as threads of the JVM, which is abstracted into a place, the Mole CE. A place provides access to the underlying operating system through service agents which, differently from user agents, are always stationary.
Reference: [39] <author> J. Hogg, </author> <title> "Island: Aliasing Protection in Object-Oriented Languages," </title> <booktitle> in Proc. of OOPSLA '91, </booktitle> <year> 1991. </year>
Reference-contexts: A place provides access to the underlying operating system through service agents which, differently from user agents, are always stationary. Shipping of stand-alone code is provided with an asynchronous, immediate mechanism. The code and data to be sent are determined automatically upon migration using the notion of island <ref> [39] </ref>. An island is the transitive closure over all the objects referenced by the main agent object. Islands, which are generated automatically starting from the main agent object, cannot have object references to the outside; inter-agent references are symbolic and become void upon migration.
Reference: [40] <author> L. Cardelli, </author> <title> "A language with distributed scope," </title> <journal> Computing Systems, </journal> <volume> vol. 8, no. 1, </volume> <pages> pp. 27-59, </pages> <year> 1995. </year>
Reference-contexts: Islands, which are generated automatically starting from the main agent object, cannot have object references to the outside; inter-agent references are symbolic and become void upon migration. Hence, data space management by move is exploited. C.8 Obliq Developed at DEC, Obliq <ref> [40] </ref> is an untyped, object-based, lexically scoped, interpreted language. Obliq allows for remote execution of procedures by means of execution engines which implement the CE concept. A thread, the Obliq EU, can request the execution of a procedure on a remote execution engine.
Reference: [41] <author> N. Borenstein, </author> <title> "EMail With A Mind of Its Own: The Safe-Tcl Language for Enabled Mail," </title> <type> Tech. Rep., </type> <institution> First Virtual Holdings, Inc, </institution> <year> 1994. </year>
Reference-contexts: When an EU requests the execution of a procedure on a remote CE, the references to the local objects used by the procedure are automatically translated into network references. C.9 Safe-Tcl Initially developed by the authors of the Internet MIME standard, Safe-Tcl <ref> [41] </ref> is an extension of Tcl [42] conceived to support active e-mail. In active e-mail, messages may include code to be executed when the recipient receives or reads the message.
Reference: [42] <author> J. Ousterhout, </author> <title> Tcl and the Tk Toolkit, </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: When an EU requests the execution of a procedure on a remote CE, the references to the local objects used by the procedure are automatically translated into network references. C.9 Safe-Tcl Initially developed by the authors of the Internet MIME standard, Safe-Tcl [41] is an extension of Tcl <ref> [42] </ref> conceived to support active e-mail. In active e-mail, messages may include code to be executed when the recipient receives or reads the message. Hence, in Safe-Tcl there are no mobility or communication mechanisms at the language level|they must be achieved using some external support, like e-mail.
Reference: [43] <author> J. Ousterhout, J. Levy, and B. Welch, </author> <title> "The Safe-Tcl Security Model," </title> <type> Tech. Rep., </type> <institution> Sun Microsystems, </institution> <month> Nov. </month> <year> 1996, </year> <note> Reprinted in [52]. </note>
Reference-contexts: Presently, most of the fundamental features of Safe-Tcl have been included in the latest release of Tcl/Tk, and a plug-in for the Netscape browser has been developed, allowing Safe-Tcl scripts to be included in HTML pages <ref> [43] </ref>, much like Java applets. C.10 Sumatra Sumatra [44], developed at University of Maryland, is a Java extension designed expressly to support the implementation of resource-aware mobile programs, i.e. programs which are able to adapt to resource changes by exploiting mobility.
Reference: [44] <author> A. Acharya, M. Ranganathan, and J. Saltz, "Sumatra: </author> <title> A Language for Resource-aware Mobile Programs," </title> <booktitle> In Vitek and Tschudin [73], </booktitle> <pages> pp. 111-130. </pages>
Reference-contexts: Presently, most of the fundamental features of Safe-Tcl have been included in the latest release of Tcl/Tk, and a plug-in for the Netscape browser has been developed, allowing Safe-Tcl scripts to be included in HTML pages [43], much like Java applets. C.10 Sumatra Sumatra <ref> [44] </ref>, developed at University of Maryland, is a Java extension designed expressly to support the implementation of resource-aware mobile programs, i.e. programs which are able to adapt to resource changes by exploiting mobility. Sumatra provides support for strong mobility of Java threads, which are Sumatra EUs.
Reference: [45] <author> M. Shaw and D. Garlan, </author> <title> Software Architecture: Perspective on an Emerging Discipline, </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: This is particularly evident in a critical phase of software development: software design. The goal of design is the creation of a software architecture, which can be defined as the decomposition of a software system in terms of software components and interactions among them <ref> [45] </ref>. Software architectures with similar characteristics can be represented by architectural styles [46] or design paradigms, which define architectural abstractions and reference structures that may be instantiated into actual software architectures.
Reference: [46] <author> G. Abowd, R. Allen, and D. Garlan, </author> <title> "Using Style to Understand Descriptions of Software Architecture," </title> <booktitle> in Proc. of SIG-SOFT'93: Foundations of Software Engineering, </booktitle> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: The goal of design is the creation of a software architecture, which can be defined as the decomposition of a software system in terms of software components and interactions among them [45]. Software architectures with similar characteristics can be represented by architectural styles <ref> [46] </ref> or design paradigms, which define architectural abstractions and reference structures that may be instantiated into actual software architectures. A design paradigm is not necessarily induced by the technology used to develop the software system|it is a conceptually separate entity.
Reference: [47] <author> J. Waldo, G. Wyant, A. Wollrath, and S. Kendall, </author> <note> "A Note on Distributed Computing," In Vitek and Tschudin [73], Also available as Sun Microsystems Laboratories Technical Report TR-94-29. </note> <author> FUGGETTA, PICCO, AND VIGNA: </author> <title> UNDERSTANDING CODE MOBILITY 21 </title>
Reference-contexts: In these cases, the concepts of location, distribution of components among locations, and migration of components to different locations need to be taken explicitly into account during the design stage. As stated in <ref> [47] </ref>, interaction among components residing on the same host is remarkably different from the case where FUGGETTA, PICCO, AND VIGNA: UNDERSTANDING CODE MOBILITY 11 components reside on different hosts of a computer network in terms of latency, access to memory, partial failure, and concurrency.
Reference: [48] <author> G.P. Picco, G.-C. Roman, and P.J. McCann, </author> <title> "Expressing Code Mobility in Mobile UNITY," </title> <booktitle> in Proc. of the 6 th Eu-ropean Software Engineering Conf. held jointly with the 5 th ACM SIGSOFT Symp. on the Foundations of Software Engineering (ESEC/FSE '97), </booktitle> <editor> M. Jazayeri and H. Schauer, Eds., </editor> <address> Zurich, Switzerland, </address> <month> Sept. </month> <year> 1997, </year> <title> vol. </title> <booktitle> 1301 of LNCS, </booktitle> <pages> pp. 500-518, </pages> <publisher> Springer. </publisher>
Reference-contexts: These paradigms are characterized by the location 3 The reader interested in the original formulation of the paradigms described here is directed to [4]. A case study centered around a formalization of these paradigms using the UNITY notation is also provided in <ref> [48] </ref>. of components before and after the execution of the service, by the computational component which is responsible for execution of code, and by the location where the computation of the service actually takes place (see Table II).
Reference: [49] <author> C. Ghezzi and G. Vigna, </author> <title> "Mobile Code Paradigms and Technologies: A Case Study," </title> <booktitle> In Rothermel and Popescu-Zeletin [72], </booktitle> <pages> pp. 39-49. </pages>
Reference-contexts: On the other hand, the paradigms themselves are independent of a particular technology, and could even be implemented without using mobile technology at all, as described in the case study presented in <ref> [49] </ref>. A. Basic Concepts Before introducing design paradigms we present some basic concepts that are an abstraction of the entities that constitute a software system, such as files, variable values, executable code, or processes. In particular, we introduce three architectural concepts: components, interactions, and sites. <p> B. Discussion and Comparison The mobile code design paradigms introduced in the previous sections define a number of abstractions for representing the bindings among components, locations, and code, and their dynamic reconfiguration. Our initial experience in applying the paradigms [50], <ref> [49] </ref> suggests that these abstractions are effective in the design of distributed applications. Furthermore, they are fairly independent of the particular language or system in which they are eventually implemented. Mobile code paradigms model explicitly the concept of location. <p> Therefore the programmer is set free from handling the management of the compo nent's state and can concentrate on the problem to solve. A case study that analyzes these relationships in detail can be found in <ref> [49] </ref>. V. Mobile Code Applications At the time of writing, applications exploiting code mobility can still be considered as relegated to a niche, at least if compared to traditional client-server based applications.
Reference: [50] <author> M. Baldi, S. Gai, </author> <title> and G.P. Picco, "Exploiting Code Mobility in Decentralized and Flexible Network Management," </title> <booktitle> In Rother-mel and Popescu-Zeletin [72], </booktitle> <pages> pp. 13-26. </pages>
Reference-contexts: B. Discussion and Comparison The mobile code design paradigms introduced in the previous sections define a number of abstractions for representing the bindings among components, locations, and code, and their dynamic reconfiguration. Our initial experience in applying the paradigms <ref> [50] </ref>, [49] suggests that these abstractions are effective in the design of distributed applications. Furthermore, they are fairly independent of the particular language or system in which they are eventually implemented. Mobile code paradigms model explicitly the concept of location. <p> Code mobility could be used to design and implement monitoring components that are co-located with the devices being monitored and report events that represent the evolution of the device state. In addition, the shipment of management components to remote sites could improve both performance and flexibility <ref> [50] </ref>, [58]. A case study focused on the application of our taxonomy to the network management application domain is presented in Section VI. B.5 Workflow Management and Cooperation Workflow management applications support the cooperation of persons and tools involved in an engineering or business process. <p> The results illustrated in the remainder of this section represent the preliminary achievements of on-going work on the subject <ref> [50] </ref>, [66]. A.
Reference: [51] <author> K.A. Bharat and L. Cardelli, </author> <title> "Migratory Applications," </title> <type> Tech. Rep. 138, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: A common case is represented by the use of a weak MCS that allows for code shipping for implementing applications designed following the MA paradigm <ref> [51] </ref>. In this case, the architectural concept of a moving component must be implemented using a technology that does not preserve the execution state upon migration.
Reference: [52] <author> G. Vigna, Ed., </author> <title> Mobile Agents and Security, LNCS State-of-the-Art Survey. </title> <publisher> Springer, </publisher> <year> 1998. </year>
Reference-contexts: V. Mobile Code Applications At the time of writing, applications exploiting code mobility can still be considered as relegated to a niche, at least if compared to traditional client-server based applications. This is a consequence of the immaturity of technology|mostly as far as performance and security <ref> [52] </ref> are concerned|and of the lack of suitable methodologies for application development.
Reference: [53] <author> P. Knudsen, </author> <title> "Comparing two Distributed Computing Paradigms a Performance Case Study," M.S. </title> <type> thesis, </type> <institution> Univ. of Tromso, </institution> <year> 1995. </year>
Reference-contexts: Code mobility could improve efficiency by migrating the code that performs the search process close to the (possibly huge) information base to be analyzed <ref> [53] </ref>. This type of application has been often considered "the killer application" motivating a design based on the MA paradigm.
Reference: [54] <author> A. Limongiello, R. Melen, M. Roccuzzo, A. Scalisi, V. Trecordi, and J. Wojtowicz, "ORCHESTRA: </author> <title> An Experimental Agent-based Service Control Architecture For Broadband Multimedia Networks," GLOBAL Internet '96, </title> <month> Nov. </month> <year> 1996. </year>
Reference-contexts: For example, the application components managing the setup, signalling, and presentation services for a video-conference could be dispatched to the users by a service broker. Examples of approaches exploiting code mobility can be found in <ref> [54] </ref> and [55]. A particular class of advanced telecommunications services are those supporting mobile users. In this case, as discussed earlier, autonomous components can provide support for disconnected operations, as discussed in [56].
Reference: [55] <author> T. Magedanz, K. Rothermel, and S. Krause, </author> <title> "Intelligent Agents: An Emerging Technology for Next Generation Telecommunications?," </title> <booktitle> in INFOCOM'96, </booktitle> <address> San Francisco, CA, USA, </address> <month> Mar. </month> <year> 1996. </year>
Reference-contexts: For example, the application components managing the setup, signalling, and presentation services for a video-conference could be dispatched to the users by a service broker. Examples of approaches exploiting code mobility can be found in [54] and <ref> [55] </ref>. A particular class of advanced telecommunications services are those supporting mobile users. In this case, as discussed earlier, autonomous components can provide support for disconnected operations, as discussed in [56].
Reference: [56] <author> R.S. Gray, D. Kotz, S. Nog, D. Rus, and G. Cybenko, </author> <title> "Mo bile agents for mobile computing," </title> <booktitle> in Proc. of the 2 nd Aizu Int. Symp. on Parallel Algorithms/Architectures Synthesis, Fukushima, </booktitle> <address> Japan, </address> <month> Mar. </month> <year> 1997. </year>
Reference-contexts: Examples of approaches exploiting code mobility can be found in [54] and [55]. A particular class of advanced telecommunications services are those supporting mobile users. In this case, as discussed earlier, autonomous components can provide support for disconnected operations, as discussed in <ref> [56] </ref>. B.4 Remote Device Control and Configuration Remote device control applications are aimed at configuring a network of devices and monitoring their status. This domain encompasses several other application domains, e.g., industrial process control and network management. In the classical approach, monitoring is achieved by polling periodically the resource state.
Reference: [57] <author> Y. Yemini, </author> <title> "The OSI Network Management Model," </title> <journal> IEEE Communications, </journal> <pages> pp. 20-29, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: In the classical approach, monitoring is achieved by polling periodically the resource state. Configuration is performed using a predefined set of services. This approach, based on the CS paradigm, can lead to a number of problems <ref> [57] </ref>. Code mobility could be used to design and implement monitoring components that are co-located with the devices being monitored and report events that represent the evolution of the device state. In addition, the shipment of management components to remote sites could improve both performance and flexibility [50], [58]. <p> To this end, we focus on the typical functionality required to a network management application, i.e., the polling of management information from a pool of network devices. Current protocols are based on a centralized client-server paradigm that exhibits several drawbacks <ref> [57] </ref>, discussed in Section VI-A. The identification and evaluation of alternative solutions will be discussed in the remainder of this section. The suggested development process proceeds as follows.
Reference: [58] <author> G. Goldszmidt and Y. Yemini, </author> <title> "Distributed Management by Delegation," </title> <booktitle> in Proc. of the 15 th Int. Conf. on Distributed Computing, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Code mobility could be used to design and implement monitoring components that are co-located with the devices being monitored and report events that represent the evolution of the device state. In addition, the shipment of management components to remote sites could improve both performance and flexibility [50], <ref> [58] </ref>. A case study focused on the application of our taxonomy to the network management application domain is presented in Section VI. B.5 Workflow Management and Cooperation Workflow management applications support the cooperation of persons and tools involved in an engineering or business process. <p> This will be discussed in Section VI-D. We chose network management as the application domain for our case study because, although it is often indicated as the ideal testbed for code mobility, efforts in this direction are still in their early stages <ref> [58] </ref>, [60]. The results illustrated in the remainder of this section represent the preliminary achievements of on-going work on the subject [50], [66]. A.
Reference: [59] <author> T. Cai, P. Gloor, and S. Nog, </author> <title> "DataFlow: A Workflow Management System on the Web using transportable Agents," </title> <type> Tech. Rep. </type> <institution> TR96-283, Dept. of Computer Science, Dartmouth College, </institution> <address> Hanover, NH, </address> <year> 1996. </year>
Reference-contexts: For example, a mobile component could encapsulate a text document that undergoes several revisions. The component maintains information about the document state, the legal operations on its contents, and the next scheduled step in the revision process. An application of these concepts can be found in <ref> [59] </ref>. B.6 Active Networks The idea of active networks has been proposed recently [60], [61] as a means to introduce flexibility into networks and provide more powerful mechanisms to "pro 16 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 24, NO. XX, XXXXX 1998 gram" the network according to applications' needs.
Reference: [60] <author> D.L. Tennenhouse, J.M. Smith, W.D. Sincoskie, D.J. Wetherall, and G.J. Minden, </author> <title> "A Survey of Active Network Research," </title> <journal> IEEE Communications, </journal> <volume> vol. 35, no. 1, </volume> <pages> pp. 80-86, </pages> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: The component maintains information about the document state, the legal operations on its contents, and the next scheduled step in the revision process. An application of these concepts can be found in [59]. B.6 Active Networks The idea of active networks has been proposed recently <ref> [60] </ref>, [61] as a means to introduce flexibility into networks and provide more powerful mechanisms to "pro 16 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 24, NO. XX, XXXXX 1998 gram" the network according to applications' needs. <p> Although some interpret the idea of active networks without any relation with code mobility [62], most of the approaches rely on it. They can be classified along a spectrum delimited by two extremes represented by the programmable switch and the capsule approaches <ref> [60] </ref>. The programmable switch approach is basically an instantiation of the COD paradigm, and aims at providing dynamic extensibility of network devices through dynamic linking of code. <p> This will be discussed in Section VI-D. We chose network management as the application domain for our case study because, although it is often indicated as the ideal testbed for code mobility, efforts in this direction are still in their early stages [58], <ref> [60] </ref>. The results illustrated in the remainder of this section represent the preliminary achievements of on-going work on the subject [50], [66]. A.
Reference: [61] <author> Y. Yemini and S. da Silva, </author> <title> "Towards Programmable Networks," </title> <booktitle> in IFIP/IEEE Int. Workshop on Distributed Systems: Operations and Management, </booktitle> <address> L'Aquila, Italy, </address> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: The component maintains information about the document state, the legal operations on its contents, and the next scheduled step in the revision process. An application of these concepts can be found in [59]. B.6 Active Networks The idea of active networks has been proposed recently [60], <ref> [61] </ref> as a means to introduce flexibility into networks and provide more powerful mechanisms to "pro 16 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 24, NO. XX, XXXXX 1998 gram" the network according to applications' needs.
Reference: [62] <author> S. Bhattacharjee, K.L. Calvert, </author> <title> and E.W. Zegura, "An Architecture for Active Networking," </title> <booktitle> in High Performance Networking (HPN'97), </booktitle> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: XX, XXXXX 1998 gram" the network according to applications' needs. Although some interpret the idea of active networks without any relation with code mobility <ref> [62] </ref>, most of the approaches rely on it. They can be classified along a spectrum delimited by two extremes represented by the programmable switch and the capsule approaches [60].
Reference: [63] <author> D.J. Wetherall, J. Guttag, and D.L. Tennenhouse, </author> <title> "ANTS: A Toolkit for Building an Dynamically Deploying Network Protocols," </title> <type> Tech. Rep., </type> <institution> MIT, </institution> <year> 1997, </year> <note> Submitted for publication to IEEE OPENARCH'98. </note>
Reference-contexts: As an example, in this scenario a multiprotocol router could download on demand the code needed to handle a packet corresponding to an unknown protocol, or even receive the protocol together with the packet. The work described in <ref> [63] </ref> is an example of an active network architecture exploiting the COD paradigm. B.7 Electronic Commerce Electronic commerce applications enable users to perform business transactions through the network. The application environment is composed of several independent and possibly competing business entities.
Reference: [64] <author> J.E. White, </author> <title> "Telescript Technology: The Foundation for the Electronic Marketplace," </title> <type> Tech. Rep., </type> <institution> General Magic, Inc., </institution> <year> 1994, </year> <note> White Paper. </note>
Reference-contexts: Moreover, it is desirable to move application components close to the information relevant to the transaction. This problems make mobile code appealing for this kind of applications. Actually, Telescript <ref> [64] </ref> was conceived explicitly to support electronic commerce. For this reason, the term "mobile agent" is often related with electronic commerce. Another application of code mobility to electronic commerce can be found in [65]. VI.
Reference: [65] <author> M. Merz and W. Lamersdorf, </author> <title> "Agents, Services, and Electronic Markets: How do they Integrate?," </title> <booktitle> in Proc. of the Int'l Conf. on Distributed Platforms. </booktitle> <address> IFIP/IEEE, </address> <year> 1996. </year>
Reference-contexts: This problems make mobile code appealing for this kind of applications. Actually, Telescript [64] was conceived explicitly to support electronic commerce. For this reason, the term "mobile agent" is often related with electronic commerce. Another application of code mobility to electronic commerce can be found in <ref> [65] </ref>. VI. A Case Study in Network Management The purpose of this section is to illustrate how the classification we presented so far can be used to guide the software engineer through the design and implementation phases of the application development process.
Reference: [66] <author> M. </author> <title> Baldi and G.P. Picco, "Evaluating the Tradeoffs of Mobile Code Design Paradigms in Network Management Applications," </title> <booktitle> in Proc. of the 20 th Int. Conf. on Software Engineering, </booktitle> <editor> R. Kem-merer, Ed., </editor> <year> 1998, </year> <note> To appear. </note>
Reference-contexts: The results illustrated in the remainder of this section represent the preliminary achievements of on-going work on the subject [50], <ref> [66] </ref>. A. <p> Nevertheless, our goal here is to illustrate some guidelines to evaluate the tradeoffs among paradigms: a quantitative comparison among paradigms, encompassing a precise characterization of network management functionalities and an accurate model of network protocols, can be found in <ref> [66] </ref>.
Reference: [67] <author> J.D. Case, M. Fedor, M. L. Schoffstall, and C. Davin, </author> <title> "Simple Network Management Protocol," </title> <type> RFC 1157, </type> <month> May </month> <year> 1990. </year>
Reference-contexts: A. The Problem: Decentralizing Network Traffic The world of network management research can be split roughly in two worlds: management of IP networks, where the Simple Network Management Protocol <ref> [67] </ref> proposed by IETF is the dominant protocol, and management of ISO networks, based on the Common Management Information Protocol [68]. Both protocols are based on a CS paradigm where a network management station|the client|polls information from agents 5 |the servers|residing on the network devices.
Reference: [68] <author> OSI, </author> <title> "ISO 9595 Information Technology, Open System Interconnection, Common Management Information Protocol Specification," </title> <year> 1991. </year>
Reference-contexts: A. The Problem: Decentralizing Network Traffic The world of network management research can be split roughly in two worlds: management of IP networks, where the Simple Network Management Protocol [67] proposed by IETF is the dominant protocol, and management of ISO networks, based on the Common Management Information Protocol <ref> [68] </ref>. Both protocols are based on a CS paradigm where a network management station|the client|polls information from agents 5 |the servers|residing on the network devices.
Reference: [69] <author> J.D. Case, K. McCloghrie, M. Rose, and S. Waldbusser, </author> <title> "Structure of Management Information for version 2 of the Simple Network Management Protocol," </title> <booktitle> RFC 1902, </booktitle> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: CMIP uses the term management information tree (MIT) database instead. Hereinafter, we will ignore the difference for the sake of simplicity. FUGGETTA, PICCO, AND VIGNA: UNDERSTANDING CODE MOBILITY 17 These problems have been addressed by IETF and ISO with modifications of their management architecture. For instance, SNMPv2 <ref> [69] </ref> introduced hierarchical decentralization through the concept of proxy agents. A proxy agent is responsible for the management of a pool of devices (towards which it acts as a client) on behalf of the network management station (towards which it acts as a server).
Reference: [70] <author> S. Waldbusser, </author> <title> "Remote Network Monitoring Management Information Base," </title> <type> RFC 1757, </type> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: A proxy agent is responsible for the management of a pool of devices (towards which it acts as a client) on behalf of the network management station (towards which it acts as a server). Another protocol derived from SNMP, called Remote MONitoring (RMON) <ref> [70] </ref>, assumes the existence of stand-alone dedicated devices called probes. Each probe hosts an agent able to monitor "global" information flowing through links rather than information "local" to a device.
Reference: [71] <author> C. Ghezzi and M. Jazayeri, </author> <title> Programming Language Concepts, </title> <publisher> John Wiley & Sons, </publisher> <address> 3 rd edition, </address> <year> 1997. </year>
Reference-contexts: In particular, we need to improve our understanding of the properties and weaknesses of the existing design paradigms. We also need to consolidate a detailed conceptual framework for mobile code languages, that makes it possible to compare them as we do for traditional programming languages <ref> [71] </ref>. Another issue is the development of models enabling formal reasoning and verification. Finally, we need to further explore the relatively 20 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 24, NO.
Reference: [72] <editor> K. Rothermel and R. Popescu-Zeletin, Eds., </editor> <booktitle> Mobile Agents: 1 st International Workshop MA '97, vol. 1219 of LNCS. </booktitle> <publisher> Springer, </publisher> <month> Apr. </month> <year> 1997. </year>

References-found: 72

