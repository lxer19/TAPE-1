URL: http://www.cs.wisc.edu/wpis/papers/pepm95b.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Title: Shape Analysis as a Generalized Path Problem  
Author: Thomas Reps 
Affiliation: University of Wisconsin  
Abstract: This paper concerns a method for approximating the possible shapes that heap-allocated structures in a program can take on. We present a new approach to finding solutions to shape-analysis problems that involves formulating them as generalized graph-reachability problems. The reachability problem that arises is not an ordinary reacha-bility problem (e.g., transitive closure), but one in which a path is considered to connect two vertices only if the concatenation of the labels on the edges of the path is a word in a certain context-free language. This graph-reachability approach allows us to give polynomial bounds on the running time of an algorithm for shape analysis. It also permits us to obtain a demand algorithm for shape analysis. (In a demand algorithm, the goal is to determine shape information selectivelyi.e., for particular variables at particular points in the program, rather than for every variable at every point in the program.) 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Assmann, U., </author> <title> On edge addition rewrite systems and their relevance to program analysis, </title> <type> Unpublished report, </type> <institution> GMD Forschungsstelle Karlsruhe, Karlsruhe, </institution> <address> Germany (1993). </address>
Reference-contexts: For instance, one of the examples in Ullman's book on database theory shows how a logic database can be used to solve the intraprocedural reaching-definitions problem [28, pp. 984-987]. Assmann has examined a variety of other intraprocedural dataflow-analysis problems <ref> [1] </ref>. Although Assmann expresses these problems using a certain kind of graph grammar, he points out that this formalism is equivalent to Datalog.
Reference: 2. <author> Bancilhon, F., Maier, D., Sagiv, Y., and Ullman, J., </author> <title> Magic sets and other strange ways to implement logic programs, </title> <booktitle> in Proceedings of the Fifth ACM Symposium on Principles of Database Systems, </booktitle> <address> (Cam-bridge, MA, </address> <month> March </month> <year> 1986), (1986). </year>
Reference-contexts: The presence of this rule will cause magic facts other than the original one to be generated during evaluation. Note that the members of relation magic_same_generation_bf will be exactly the ancestors of a (the so-called cone of a <ref> [2] </ref>).
Reference: 3. <author> Bancilhon, F. and Ramakrishnan, R., </author> <title> Performance evaluation of data intensive logic programs, pp. 439-517 in Foundations of Deductive Databases and Logic Programming, </title> <editor> ed. J. </editor> <month> Minker,Morgan-Kaufmann </month> <year> (1988). </year>
Reference-contexts: of a. ` Note that in a bottom-up evaluation, the transformed program (the demand algorithm) will never perform more work than the untransformed program (the exhaustive algorithm) wouldmodulo a small amount of overhead for computing magic facts, which are reported to be only a small fraction of the generated facts <ref> [3] </ref>. In practice, the demand algorithm usually performs far less work than the exhaustive algorithm. Acknowledgements I am grateful for the comments and helpful suggestions that Susan Horwitz and Mooly Sagiv provided about the work.
Reference: 4. <author> Beeri, C. and Ramakrishnan, R., </author> <title> On the power of magic, pp. </title> <booktitle> 269-293 in Proceedings of the Sixth ACM Symposium on Principles of Database Systems, </booktitle> <address> (San Diego, CA, </address> <month> March </month> <year> 1987), (1987). </year>
Reference: 5. <author> Ceri, S., Gottlob, G., and Tanca, L., </author> <title> What you always wanted to know about Datalog (and never dared to ask), </title> <journal> IEEE Transactions on Knowledge and Data Engineering 1(1) pp. </journal> <month> 146-166 (March </month> <year> 1989). </year>
Reference-contexts: For these reasons, a short tutorial on bottom-up evaluation and the Magic-sets transformation is provided in the Appendix. (See also <ref> [5] </ref>.) Some programming-languages people are also leery of the (space, time, and conceptual) overheads involved in hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 2 This is similar to the situation one has with functional programs where a recursive Fibonacci program executed with a non-memoizing implementation of the language uses exponential time, whereas an iterative program that computes
Reference: 6. <author> Chase, D.R., Wegman, M., and Zadeck, F.K., </author> <title> Analysis of pointers and structures, </title> <booktitle> Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <address> (White Plains, NY, </address> <month> June 20-22, </month> <year> 1990), </year> <journal> ACM SIGPLAN Notices 25(6) pp. </journal> <month> 296-310 (June </month> <year> 1990). </year>
Reference: 7. <author> Cousot, P. and Cousot, R., </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints, pp. </title> <booktitle> 238-252 in Conference Record of the Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Los Angeles, CA, </address> <month> January 17-19, </month> <year> 1977), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1977). </address>
Reference-contexts: changes that occur when a procedure is called. (By introducing equations between dataflow variables associated with formal out-parameters and dataflow variables associated with the corresponding actuals at the return site, call-by-value-result can also be handled.) When solved over a suitable domain, the equations define an abstract interpretation of the program <ref> [7] </ref>. The question, however, is: Over what domain are they to be solved? In the Reynolds and Jones-Muchnick approach, the value of each dataflow variable is a set of shapes (i.e., a set of sets of root-to-leaf paths), and the join operation is union.
Reference: 8. <author> Duesterwald, E., Gupta, R., and Soffa, </author> <title> M.L., Demand-driven computation of interprocedural data flow, pp. </title> <booktitle> 37-48 in Conference Record of the Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Francisco, CA, </address> <month> Jan. </month> <pages> 23-25, </pages> <address> 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference: 9. <author> Heintze, N., </author> <title> Set based analysis of ML programs, </title> <type> Technical Report CMU-CS-93-193, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA (July 1993). </address>
Reference-contexts: Other techniques that are imprecise in the same way that ours is have been employed by Mogensen in his binding-time analysis for program bifurcation [19] and by Heintze in his work on set-based analysis problems <ref> [9] </ref>. Compared to previous work, the novelty of our work stems from our formulation of the shape-analysis problem as a generalized graph-reachability problem. <p> Set-based analysis problems involve solving a set of constraint equations, and Heintze has shown that they can be solved in time O (Prog 3 ) <ref> [9] </ref>. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh x := nil read (z); while z 0 do x := cons (z, x); read (z) od; while x nil do temp := car (x); y := cons (temp, y); x := cdr (x) y := nil while x != nil temp := car (x) y := cons (temp, <p> In our version of the shape-analysis problem, such relationships are lost (i.e., the C-E pairing is permitted). The version of the shape-analysis problem addressed in the paper is related to what Heintze calls set-based analysis <ref> [9] </ref>. Set-based-analysis problems are a generalization of the shape-analysis problem to incorporate data other than just heap-allocated storage.
Reference: 10. <author> Hendren, L.J. and Nicolau, A., </author> <title> Parallelizing programs with recursive data structures, </title> <journal> IEEE Transactions on Parallel and Distributed Systems 1(1) pp. </journal> <month> 35-47 (January </month> <year> 1990). </year>
Reference-contexts: Our work is less general than the techniques reported in those papers in that our method does not handle destructive-update operations. However, there are a couple of aspects of our work that, compared with previous work, make it unique. For example, the techniques of Hendren and Nicolau <ref> [10] </ref> and Larus and Hilfinger [16] are based on regular languages, whereas our approach makes use of context-free languages.
Reference: 11. <author> Horwitz, S., Pfeiffer, P., and Reps, T., </author> <title> Dependence analysis for pointer variables, </title> <booktitle> Proceedings of the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <address> (Portland, OR, </address> <month> June 21-23, </month> <year> 1989), </year> <journal> ACM SIGPLAN Notices 24(7) pp. </journal> <month> 28-40 (July </month> <year> 1989). </year>
Reference: 12. <author> Horwitz, S., Reps, T., and Sagiv, M., </author> <title> Demand interprocedural dataflow analysis, </title> <type> Unpublished Report, </type> <institution> Comp. Sci. Dept., Univ. of Wisconsin, Madison, </institution> <address> WI (March 1995). </address>
Reference-contexts: However, as already discussed in Section 4, a low-overhead implementation of a demand CFL-reachability algorithm for these problemsnot based on Magic-sets, and suitable for implementation in an imperative programming languagehas been developed [22]. Some preliminary experimental results from such an implementation are reported in <ref> [12] </ref>. Appendix: Two Examples of the Magic-Sets Transformation In this appendix, we present two examples that illustrate the capabilities of the Magic-sets transformation. The Magic-sets transformation attempts to combine the advantages of a top-down, goal-directed evaluation strategy with those of a bottom-up evaluation strategy.
Reference: 13. <editor> Jones, N.D. and Muchnick, S.S., </editor> <title> Complexity of flow analysis, inductive assertion synthesis, and a language due to Dijkstra, pp. 380-393 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones,Prentice-Hall, </editor> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: Relation to Previous Work The version of the shape-analysis problem studied in this paper was originally introduced by Mogensen [19]. This version is simpler but less precise than the one addressed by Reynolds and by Jones and Muchnick. Using the terminology of <ref> [13] </ref>, the simpler version of the problem is an independent attribute method for shape analysis, whereas the Reynolds/Jones-Muchnick version of the problem has some of the flavor of a relational method.
Reference: 14. <editor> Jones, N.D. and Muchnick, S.S., </editor> <title> Flow analysis and optimization of Lisp-like structures, pp. 102-131 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones,Prentice-Hall, </editor> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: In particular, his algorithm for solving the shape-analysis problem repeatedly applies a reduction step to eliminate selection operations from the set of equations. The shape-analysis problem was formulated independently a few years later by Jones and Muchnick <ref> [14] </ref>. They treated the problem as one of solving (i.e., finding the least fixed-point of) a collection of equations using regular tree grammars. <p> This assumption is not essential, but it simplifies the presentation and also has a small effect on how we state our bound on the time to solve shape-analysis problems. Example. An example program, taken from <ref> [14] </ref>, is shown in Figure 1. The program first reads atoms and forms a list x; it then traverses x to assign y the reversal of x. <p> ) " iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh the paper to illustrate our techniques. ` As in [26] and <ref> [14] </ref>, a collection of dataflow equations is introduced to capture the shapes of (a superset of) the possible terms at the various points in the program. The domain of shape descriptors is similar to the domain of trees, except that all atoms are replaced by the special value at. <p> information available about the value of A at program-point r in the two approaches can be represented with the following two tree grammars: v r, A fi cons (v p, B , v p, C ) | cons (v q, D , v q, E ) (a) Jones and Muchnick <ref> [14] </ref> v r, A fi cons (v p, B v q, D , v p, C v q, E ) (b) Mogensen [19] Grammar (a) uses multiple cons right-hand sides for a given nonterminal. <p> These grammars are also similar to the relation that Jones and Muchnick define in order to eliminate productions with selectors <ref> [14, pp. 111-113] </ref>.
Reference: 15. <author> Kasami, J., </author> <title> An efficient recognition and syntax analysis algorithm for context-free languages, </title> <type> Scientific Report AFCRL-65-758, </type> <institution> Air Force Cambridge Research Laboratory, Bedford, </institution> <address> MA (1965). </address>
Reference: 16. <author> Larus, J.R. and Hilfinger, </author> <title> P.N., Detecting conflicts between structure accesses, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 21-34 (July </month> <year> 1988). </year>
Reference-contexts: However, there are a couple of aspects of our work that, compared with previous work, make it unique. For example, the techniques of Hendren and Nicolau [10] and Larus and Hilfinger <ref> [16] </ref> are based on regular languages, whereas our approach makes use of context-free languages.
Reference: 17. <author> McCarthy, J., </author> <title> A basis for a mathematical theory of computation, </title> <note> pp. 33-70 in Computer Programming and Formal Systems, </note> <editor> ed. Braf-fort and Hershberg,North-Holland, </editor> <address> Amsterdam (1963). </address>
Reference-contexts: Thus, the first two rules of grammar L 1 are the grammar-theoretic analogs of McCarthy's rules <ref> [17] </ref>: car (cons (x, y )) = x cdr (cons (x, y)) = y.
Reference: 18. <author> Mogensen, T., </author> <title> Partially static structures in a self-applicable partial evaluator, pp. 325-347 in Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation, </booktitle> <address> (Gammel Avernaes, Denmark, </address> <month> 18-24 October, </month> <year> 1987), </year> <editor> ed. D. Bjo| rner, A.P. Ershov, </editor> <address> N.D. Jones,North-Holland, New York, NY (1988). </address>
Reference-contexts: 1. Introduction This paper concerns a method for approximating the possible shapes that heap-allocated structures in a program can take on. In the context of partial evaluation, variations on the method have been used for a variety of purposes, notably in Mogensen's binding-time analysis for partially static structures <ref> [18] </ref> and later in his binding-time analysis for program bifurcation [19]. The shape-analysis problem was originally formulated by Reynolds [26]. Reynolds treated the problem as one of simplifying a collection of set equations.
Reference: 19. <author> Mogensen, T., </author> <title> Separating binding times in language specifications, pp. </title> <booktitle> 12-25 in Fourth International Conference on Functional Programming and Computer Architecture, </booktitle> <address> (London, UK, </address> <month> Sept. </month> <pages> 11-13, </pages> <address> 1989), </address> <publisher> ACM Press, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: In the context of partial evaluation, variations on the method have been used for a variety of purposes, notably in Mogensen's binding-time analysis for partially static structures [18] and later in his binding-time analysis for program bifurcation <ref> [19] </ref>. The shape-analysis problem was originally formulated by Reynolds [26]. Reynolds treated the problem as one of simplifying a collection of set equations. In particular, his algorithm for solving the shape-analysis problem repeatedly applies a reduction step to eliminate selection operations from the set of equations. <p> Other techniques that are imprecise in the same way that ours is have been employed by Mogensen in his binding-time analysis for program bifurcation <ref> [19] </ref> and by Heintze in his work on set-based analysis problems [9]. Compared to previous work, the novelty of our work stems from our formulation of the shape-analysis problem as a generalized graph-reachability problem. <p> In our work, however, we follow Mogensen <ref> [19] </ref>: The value of each dataflow variable is a single Shape (i.e., a set of root-to-leaf paths), and the join operation is union. Functions cons, car, and cdr are functions from Shape to Shape. <p> grammars: v r, A fi cons (v p, B , v p, C ) | cons (v q, D , v q, E ) (a) Jones and Muchnick [14] v r, A fi cons (v p, B v q, D , v p, C v q, E ) (b) Mogensen <ref> [19] </ref> Grammar (a) uses multiple cons right-hand sides for a given nonterminal. In grammar (b), the link between branches in different cons alternatives is broken, and a single cons right-hand side is formed with the union of a set of nonterminals in each arm. <p> However, retaining the sharper information is achieved at some cost <ref> [19] </ref>. 2.1. <p> Relation to Previous Work The version of the shape-analysis problem studied in this paper was originally introduced by Mogensen <ref> [19] </ref>. This version is simpler but less precise than the one addressed by Reynolds and by Jones and Muchnick.
Reference: 20. <author> Ramakrishnan, R., Seshadri, P., Srivastava, D., and Sudarshan, S., </author> <title> The Coral user manual: A tutorial introduction to Coral, Unpublished documentation, </title> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI (1993). </institution> <note> (Available via ftp from ftp.cs.wisc.edu.) </note>
Reference: 21. <author> Ramakrishnan, R., Seshadri, P., Srivastava, D., and Sudarshan, S., </author> <title> Coral Release 1.1, Software system, </title> <institution> Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (May 1994). (Available via ftp from ftp.cs.wisc.edu.) </note>
Reference-contexts: The times reported in column three indicate the time taken to answer the queries when the Magic-sets transformation was not applied; the times in column four indicate the time taken by the Magic-sets-transformed version. (These tests were carried out with Release 1.1 of the Coral logic-database system <ref> [21] </ref> on a Sun SPARCstation 10 Model 30 with 32 MB of RAM.) Remark.
Reference: 22. <author> Reps, T., Sagiv, M., and Horwitz, S., </author> <title> Interprocedural dataflow analysis via graph reachability, </title> <type> TR 94-14, </type> <institution> Datalogisk Institut, University of Copenhagen, Copenhagen, </institution> <address> Denmark (April 1994). </address> <note> (Available on the World Wide Web at ftp://ftp.diku.dk/diku/semantics/papers/D-215.ps.Z.) </note>
Reference-contexts: Demand algorithms can then be obtained by applying the Magic-sets transformation. However, as already discussed in Section 4, a low-overhead implementation of a demand CFL-reachability algorithm for these problemsnot based on Magic-sets, and suitable for implementation in an imperative programming languagehas been developed <ref> [22] </ref>. Some preliminary experimental results from such an implementation are reported in [12]. Appendix: Two Examples of the Magic-Sets Transformation In this appendix, we present two examples that illustrate the capabilities of the Magic-sets transformation.
Reference: 23. <author> Reps, T., </author> <title> Demand interprocedural program analysis using logic databases, </title> <note> pp. 163-196 in Applications of Logic Databases, </note> <editor> ed. R. </editor> <publisher> Ramakrishnan,Kluwer Academic Publishers, </publisher> <address> Boston, MA (1994). </address>
Reference: 24. <author> Reps, T., </author> <title> Solving demand versions of interprocedural analysis problems, pp. </title> <booktitle> 389-403 in Proceedings of the Fifth International Conference on Compiler Construction, </booktitle> <address> (Edinburgh, Scotland, </address> <month> April 7-9, </month> <year> 1994), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 786, </volume> <editor> ed. P. Fritzson,Springer-Verlag, </editor> <address> New York, NY (1994). </address>
Reference-contexts: A successful application of this approach can be found in the author's recent work on demand algorithms for interprocedural dataflow-analysis problems, which showed how certain classes of interprocedural dataflow-analysis problems can be posed as CFL-reachability problems: In <ref> [24] </ref>, the Magic-sets transformation was used to obtain demand algorithms for a class of interprocedural dataflow-analysis problems; subsequently, a demand algorithm was developed that can be implemented easily in an imperative programming language [22,12].
Reference: 25. <author> Reps, T., Horwitz, S., and Sagiv, M., </author> <title> Precise interprocedural dataflow analysis via graph reachability, pp. </title> <booktitle> 49-61 in Conference Record of the Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Francisco, CA, </address> <month> Jan. </month> <pages> 23-25, </pages> <address> 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference: 26. <author> Reynolds, </author> <title> J.C., Automatic computation of data set definitions, pp. </title> <booktitle> 456-461 in Information Processing 68: Proceedings of the IFIP Congress 68, </booktitle> <publisher> North-Holland, </publisher> <address> New York, NY (1968). </address>
Reference-contexts: In the context of partial evaluation, variations on the method have been used for a variety of purposes, notably in Mogensen's binding-time analysis for partially static structures [18] and later in his binding-time analysis for program bifurcation [19]. The shape-analysis problem was originally formulated by Reynolds <ref> [26] </ref>. Reynolds treated the problem as one of simplifying a collection of set equations. In particular, his algorithm for solving the shape-analysis problem repeatedly applies a reduction step to eliminate selection operations from the set of equations. <p> p, z ) " iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh the paper to illustrate our techniques. ` As in <ref> [26] </ref> and [14], a collection of dataflow equations is introduced to capture the shapes of (a superset of) the possible terms at the various points in the program. <p> of vertices in a program's control-flow graph and Var is the maximum number of variables visible in any scope.) The grammars L 1 , L 2 , and L 3 (for nonterminals id_path, hd_path, and tl_path, respectively) take the place of the reduction step that Reynolds uses for eliminating selections <ref> [26] </ref>. These grammars are also similar to the relation that Jones and Muchnick define in order to eliminate productions with selectors [14, pp. 111-113].
Reference: 27. <author> Rohmer, R., Lescoeur, R., and Kersit, J.-M., </author> <title> The Alexander method, a technique for the processing of recursive axioms in deductive databases, </title> <journal> New Generation Computing 4(3) pp. </journal> <month> 273-285 </month> <year> (1986). </year>
Reference: 28. <author> Ullman, J.D., </author> <title> Principles of Database and Knowledge-Base Systems, Volume II: The New Technologies, </title> <publisher> Computer Science Press, </publisher> <address> Rock-ville, MD (1989). </address>
Reference-contexts: There has been some previous work in which dataflow-analysis problems have been expressed using Horn clauses. For instance, one of the examples in Ullman's book on database theory shows how a logic database can be used to solve the intraprocedural reaching-definitions problem <ref> [28, pp. 984-987] </ref>. Assmann has examined a variety of other intraprocedural dataflow-analysis problems [1]. Although Assmann expresses these problems using a certain kind of graph grammar, he points out that this formalism is equivalent to Datalog.
Reference: 29. <author> Yannakakis, M., </author> <booktitle> Graph-theoretic methods in database theory, </booktitle> <pages> pp. </pages> <booktitle> 230-242 in Proceedings of the Symposium on Principles of Database Systems, </booktitle> <year> (1990). </year>
Reference-contexts: By treating the problem in this way, we gain two important benefits: (i) There is a general result that all context-free-language reachability problems can be solved in time cubic in the number of vertices in the graph <ref> [29] </ref>. <p> The Cost of Solving CFL-Reachability Problems There is a general result that all CFL-reachability problems can be solved in time cubic in the number of vertices in the graph <ref> [29] </ref>. <p> They can be thought of as generalizations of the CYK algorithm for context-free recognition [15,30]. (For instance, the recognition problem for any context-free language L can be formulated as a source-target L-path problem on a linear graph whose edges are labeled by the letters of the input string <ref> [29] </ref>.) We delay further discussion of solution methods until Section 4. There we give a Horn-clause program that, when viewed as rules to be evaluated bottom-up, specifies a dynamic-programming algorithm for all sixteen L 1 -, L 2 -, L 3 -, and L 4 -path problems. 3.
Reference: 30. <author> Younger, D.H., </author> <title> Recognition and parsing of context-free languages in time n**3, </title> <journal> Information and Control 10 pp. </journal> <month> 189-208 </month> <year> (1967). </year>
References-found: 30

