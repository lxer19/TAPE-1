URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-94-1233/CS-TR-94-1233.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-94-1233/
Root-URL: http://www.cs.wisc.edu
Email: fshatdal,naughtong@cs.wisc.edu  
Title: Processing Aggregates in Parallel Database Systems  
Author: Ambuj Shatdal Jeffrey F. Naughton 
Date: June, 1994  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  Computer Sciences  
Pubnum: Technical Report 1233  
Abstract: Aggregates are rife in real life SQL queries. However, in the parallel query processing literature aggregate processing has received surprisingly little attention; furthermore, the way current parallel database systems do aggregate processing is far from optimal in many scenarios. We describe two hashing based algorithms for parallel evaluation of aggregates. A performance analysis via an analytical model and an implementation on the Intel Paragon multi-computer shows that each works well for some aggregation selectivities but poorly for the remaining. Fortunately, where one does poorly the other does well and vice-versa. Thus, the two together cover all possible selectivities. We show how, using sampling, an optimizer can decide which of the two algorithms to use for a particular query. Finally, we investigate the impact of data skew on the performance of these algorithms.
Abstract-found: 1
Intro-found: 1
Reference: [BBDW83] <author> Dina Bitton, Haran Boral, David J. DeWitt, and W. Kevin Wilkinson. </author> <title> Parallel algorithms for the execution of relational database operations. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 8(3) </volume> <pages> 324-353, </pages> <month> September </month> <year> 1983. </year>
Reference-contexts: As mentioned, there has been little work reported in literature on aggregate processing. Epstein [Eps79] discusses some algorithms for computing scalar aggregates and aggregate functions on a uniprocessor. Bitton et al. <ref> [BBDW83] </ref> discuss two sorting based algorithms for aggregate processing on a shared disk cache architecture. The first is somewhat similar to the proposed two phase approach in that it uses local aggregation. <p> ) or using merging of sorted streams: jGj fl t m * generating final result: jGj fl S g fl t r * I/O cost for storing result: (G fl S g =P ) fl IO 2.2 Approach of Bitton et al. : Hierarchical Merging The first algorithm proposed in <ref> [BBDW83] </ref> first makes each node do aggregation on locally resident data like the traditional approach.
Reference: [BCL93] <author> Kurt P. Brown, Michael J. Carey, and Miron Livny. </author> <title> Managing Memory to Meet Multiclass Workload Response Time Goals. </title> <booktitle> In Proc. of 19th VLDB Conf., </booktitle> <pages> pages 328-341, </pages> <year> 1993. </year>
Reference-contexts: We assume that the aggregation is being performed directly on a base relation stored on disks as in the example query. The parameters of the study are listed in Table 1 unless otherwise specified. These parameters are similar to those in previous studies e.g. <ref> [BCL93] </ref>. <p> The I/O rate was as observed on the Maxtor disk on the Paragon. The software parameters are based on instruction counts taken from the Gamma prototype and are similar to those in previous studies e.g. <ref> [BCL93] </ref>. In the following we assume that aggregation on a node is done by hashing.
Reference: [BF93] <author> J. Bunge and M. Fitzpatrick. </author> <title> Estimating the Number of Species: A Review. </title> <journal> Journal of the American Statistical Association, </journal> <volume> 88(421) </volume> <pages> 364-373, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: The general problem of accurately estimating the number of groups (and hence the GROUP BY selectivity) is similar to the projection estimation problem. It is fairly complex and has received a lot of attention in the statistics literature <ref> [BF93] </ref>. However, in our case we only need to decide efficiently whether the number of groups in the relation is small or not because we have a lot of leeway in the middle range where both 15 the algorithms perform well.
Reference: [DGS + 90] <author> D. DeWitt, S. Ghandeharizadeh, D. Schneider, A. Bricker, H.-I Hsiao, and R. Rasmussen. </author> <title> The Gamma database machine project. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1), </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: The following simple query will serve as the running example using relation R (tid,cardNo,amount). select cardNo, avg (amount) from R group by cardNo; Further, we assume a Gamma <ref> [DGS + 90] </ref> like architecture where each relational operation is represented by operators. The data "flows" through the operators in a pipelined fashion as far as possible. For example, a join of two base relations is implemented as two select operators followed by a join operator. <p> In the remainder of this section we discuss previously proposed approaches to parallel aggregation and two new approaches that we have not seen discussed in the literature. 2.1 Traditional Approach The traditional approach, e.g. the one implemented in Gamma <ref> [DGS + 90] </ref> and some commercial PDBMSs, is for each node to do aggregation on the partition of the relation on the node. These result in local (group, aggregate-value) tuples. These are sent to a central coordinator which merges the local results into the overall (global) aggregate value (Figure 1).
Reference: [Eps79] <author> Robert Epstein. </author> <title> Techniques for Processing of Aggregates in Relational Database Systems. </title> <institution> Memorandum UCB/ERL M79/8, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <month> February </month> <year> 1979. </year> <month> 19 </month>
Reference-contexts: Finally, we study how these schemes perform in presence of data skew. We first characterize the data skew problem in aggregate processing and investigate the impact of skew on the performance of these algorithms. As mentioned, there has been little work reported in literature on aggregate processing. Epstein <ref> [Eps79] </ref> discusses some algorithms for computing scalar aggregates and aggregate functions on a uniprocessor. Bitton et al. [BBDW83] discuss two sorting based algorithms for aggregate processing on a shared disk cache architecture. The first is somewhat similar to the proposed two phase approach in that it uses local aggregation.
Reference: [ER61] <author> Paul Erdos and Alfred Renyi. </author> <title> On a Classical Problem of Probability Theory. MTA Mat. </title> <booktitle> Kut. Int. Kozl, 6A:215-220, 1961. Also in Selected Papers of Alfred Renyi, </booktitle> <volume> volume 2, </volume> <pages> pages 617-621, </pages> <address> Akademiai Kiado, Budapest. </address>
Reference-contexts: This equation can be solved quite efficiently using dynamic programming. Note that the probability does not depend on the size of the relation. For any fixed value of P (G; S), the number S grows approximately as G fl log G <ref> [ER61] </ref>. This ensures that the number of samples required is not very large even if the crossover threshold is significant.
Reference: [Gra93] <author> Goetz Graefe. </author> <title> Query Evaluation Techniques for Large Databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(2) </volume> <pages> 73-170, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: This is too impractical on today's multiprocessor interconnects which do not efficiently support broadcasting. Su et al. [SM82] discuss an implementation of the traditional approach. Graefe <ref> [Gra93] </ref> discusses some issues in dealing with bucket overflow when using hash bases aggregation in a memory constrained environment. The rest of the paper is organized as follows. Section 2 introduces aggregation, the previous approaches to aggregate processing and describes the two proposed approaches.
Reference: [Int93] <author> Intel Corporation. </author> <title> Paragon T M OSF/1 USer's Guide, </title> <month> February </month> <year> 1993. </year>
Reference-contexts: However, to our knowledge neither a description of these algorithms nor an analysis of their performance has appeared in the literature. While these approaches are simple, their performance behavior is not obvious. The analytical models and the implementation on the Intel Paragon parallel super computer <ref> [Int93] </ref> show that the two proposed schemes are complementary in terms of performance. We find that whereas first approach works well when the number of result tuples is small, the second approach works better when the GROUP BY is not very selective.
Reference: [SM82] <author> Stanley Y. W. Su and Krishna P. Mikkilineni. </author> <booktitle> Parallel Algorithms and Their Implentation in MICRONET. In Proc. of 8th VLDB Conf., </booktitle> <pages> pages 310-324, </pages> <year> 1982. </year>
Reference-contexts: The second algorithm of Bitton et al. uses broadcast of the tuples and lets each node process the tuples belonging to a subset of groups. This is too impractical on today's multiprocessor interconnects which do not efficiently support broadcasting. Su et al. <ref> [SM82] </ref> discuss an implementation of the traditional approach. Graefe [Gra93] discusses some issues in dealing with bucket overflow when using hash bases aggregation in a memory constrained environment. The rest of the paper is organized as follows.
Reference: [TPC94] <author> TPC. </author> <title> TPC Benchmark TM D (Decision Support). Working draft 6.5, Transaction Processing Performance Council, </title> <month> February </month> <year> 1994. </year> <month> 20 </month>
Reference-contexts: 1 Introduction SQL queries in the real world are replete with aggregate operations. One measure of the perceived importance of aggregation is that in the proposed TPC-D benchmark <ref> [TPC94] </ref> 15 out of 17 queries contain aggregate operations. Yet we find that aggregate processing is an issue almost totally ignored by the researchers in the parallel database community. The deceptive simplicity of aggregate processing is possibly the reason for this negligence.
References-found: 10

