URL: ftp://ftp.eecs.umich.edu/groups/gasm/typedasm.ps.Z
Refering-URL: http://www.eecs.umich.edu/gasm/intromat.html
Root-URL: http://www.cs.umich.edu
Email: giusp@uni-paderborn.de)  gurevich@eecs.umich.edu)  Karl.Stroetmann@mchp.siemens.de)  
Title: Typed Abstract State Machines  
Author: Giuseppe Del Castillo Yuri Gurevich Karl Stroetmann 
Address: Germany  USA  Germany  
Affiliation: (Universitat-GH Paderborn,  (University of Michigan,  (Siemens AG,  
Abstract: As introduced in the Lipari guide, Abstract State Machines (abbreviated as ASMs) are untyped. This is useful for many purposes. However, typed languages have their own advantages. Types structure the data, type checking uncovers errors. Here we propose a typed version of ASMs. Key Words: abstract state machine, type system, polymorphism Category: D.3.1, F.1.1, F.3.2, F.3.3 
Abstract-found: 1
Intro-found: 1
Reference: [ASM] <institution> Abstract state machines. Web site of the University of Michigan at http://www.eecs.umich.edu/gasm/. </institution>
Reference-contexts: We give a typed version of the latter. Because typed ASMs do not yet support the import construction of [Gur95], there is no need for reserve elements. The papers mentioned above can be obtained from the web site at the University of Michigan <ref> [ASM] </ref>, where further material on ASMs can be found. 3.1 Syntax of Rules In order to give a concise definition of typeable rules we extend our vocabulary by adding a nullary type constructor rule and by adding the following function symbols: skip, assign, block, if, forall, and choose.
Reference: [Bei95] <author> Christoph Beierle. </author> <title> Concepts, implementation, and applications of a typed logic programming language. </title> <editor> In Beierle and Plumer [BP95], </editor> <volume> chapter 5, </volume> <pages> pages 139-167. </pages>
Reference-contexts: BCPL, the untyped forerunner of C, has been completely replaced by C and C ++ . Similarly Lisp is being gradually replaced by ML and Haskell. Concerning logic programming, the last years have seen the development of several typed logic programming languages, e.g., Mercury [HSC96], Protos-L <ref> [Bei95] </ref>, and Godel [HL92]. Among others, there are the following important reasons for the introduction of types: 1. To facilitate structuring of the data of an application. 2. To have a type checker that automatically detects errors at compile time. Detecting errors automatically when writing a program is certainly useful.
Reference: [BP95] <editor> Christoph Beierle and Lutz Plumer, editors. </editor> <booktitle> Logic Programming: Formal Methods and Practical Applications. Studies in Computer Science and Artificial Intelligence. </booktitle> <publisher> Elsevier Science B.V./North-Holland, Amsterdam, Holland, </publisher> <year> 1995. </year>
Reference: [Cas98] <author> Giuseppe Del Castillo. ASM-SL, </author> <title> a specification language based on Gure-vich's abstract state machines: Introduction and tutorial. </title> <type> Technical report, </type> <institution> Universitat-GH Paderborn, </institution> <year> 1998. </year> <note> to appear. </note>
Reference-contexts: Accordingly, efficiency is not an issue. There was a division of labour among the authors of this paper. The second and third authors did the theoretical part. The first author implemented the type checking algorithm <ref> [Cas98] </ref> and provided the example in Section 4. 2 Types and Terms In this section we define the syntax of terms and types, define typeable terms, and give a type-checking algorithm. <p> Therefore, if candidateList becomes empty, the ASM terminates. The ASM given above is well-typed. This can be checked mechanically using a type checker. For example, we have used the type checker that has been implemented as part of a workbench for ASMs developed at the University of Paderborn <ref> [Cas98] </ref>. Of course, the benefit of type checking gets most obvious when dealing with ill-typed terms.
Reference: [Cla78] <author> K. L. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: (t 1 ; : : : ; t n ) and if this term uses only function symbols from F, then f (t 1 ; : : : ; t n ) 6= x. (In the logic programming community these axioms are known as the axioms of Clark's Equational Theory <ref> [Cla78] </ref>.) The otherwise clause in the matching rule is optional, i.e., the following version of the matching rule is also supported: match t case p 1 : R 1 . . . case p n : R n end-match.
Reference: [FM90] <author> You-Chin Fuh and Prateek Mishra. </author> <title> Type inference with subtypes. </title> <journal> Theoretical Computer Science, </journal> <volume> 73(2) </volume> <pages> 155-175, </pages> <year> 1990. </year>
Reference-contexts: We present a type system that introduces parametric polymorphism as suggested by [Mor68] and [Mil78]. Our type system can be described as a restriction of the type system of the programming language ML [MTH90] to the first order case. A followup paper [GS98] extends our type system with casting <ref> [FM90] </ref> and a modest version of type classes [WB89]. This is not the first paper on typed ASMs. In the pioneering paper [Zam97], Zamulin presented a different and more ambitious approach. Zamulin does not confine himself to the introduction of types.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java TM Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: However, we will ignore first order terms in this paper. These terms will be dealt with in [GS98]. The most important syntactic sugaring is the introduction of the matching rule. It is akin to the matching rule found in Pizza [OW97], an extension of the programming language Java TM <ref> [GJS96] </ref>. The syntax of the matching rule is match t case p 1 : R 1 . . . case p n : R n otherwise: R n+1 end-match.
Reference: [GS98] <author> Yuri Gurevich and Karl Stroetmann. </author> <title> Typed ASMs: Adding casting and overloading (tentative title), </title> <note> 1998. In preparation. </note>
Reference-contexts: We present a type system that introduces parametric polymorphism as suggested by [Mor68] and [Mil78]. Our type system can be described as a restriction of the type system of the programming language ML [MTH90] to the first order case. A followup paper <ref> [GS98] </ref> extends our type system with casting [FM90] and a modest version of type classes [WB89]. This is not the first paper on typed ASMs. In the pioneering paper [Zam97], Zamulin presented a different and more ambitious approach. Zamulin does not confine himself to the introduction of types. <p> However, we will ignore first order terms in this paper. These terms will be dealt with in <ref> [GS98] </ref>. The most important syntactic sugaring is the introduction of the matching rule. It is akin to the matching rule found in Pizza [OW97], an extension of the programming language Java TM [GJS96].
Reference: [Gur95] <author> Yuri Gurevich. </author> <title> Evolving algebras 1993: Lipari guide. </title> <editor> In Egon Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 3-36. </pages> <publisher> Oxford University Press, </publisher> <year> 1995. </year> <note> Available at [ASM]. </note>
Reference-contexts: With most specification languages, the notion of a partial function is difficult to handle. In fact, much of the intricacies of modern specification languages have their origin in the treatment of partial functions. Fortunately, in the framework of ASMs <ref> [Gur95] </ref> this problem has been solved: formally speaking, all functions are total. This is achieved by providing a default value. As a consequence, the richness of a type system is less vital for ASMs than it is for many other specification languages. <p> This annotated term ff is called the full annotation of t. 3 Basic Rules: Syntax and Semantics Syntax and semantics of ASMs are defined in the Lipari guide <ref> [Gur95] </ref>, a part of which has been updated in the 1997 guide [Gur97]. We give a typed version of the latter. Because typed ASMs do not yet support the import construction of [Gur95], there is no need for reserve elements. <p> t. 3 Basic Rules: Syntax and Semantics Syntax and semantics of ASMs are defined in the Lipari guide <ref> [Gur95] </ref>, a part of which has been updated in the 1997 guide [Gur97]. We give a typed version of the latter. Because typed ASMs do not yet support the import construction of [Gur95], there is no need for reserve elements.
Reference: [Gur97] <author> Yuri Gurevich. </author> <title> May 1997 draft of the ASM guide. </title> <type> Technical Report CSE-TR-336-97, </type> <institution> University of Michigan, EECS Department, </institution> <year> 1997. </year> <note> Available at [ASM]. </note>
Reference-contexts: This annotated term ff is called the full annotation of t. 3 Basic Rules: Syntax and Semantics Syntax and semantics of ASMs are defined in the Lipari guide [Gur95], a part of which has been updated in the 1997 guide <ref> [Gur97] </ref>. We give a typed version of the latter. Because typed ASMs do not yet support the import construction of [Gur95], there is no need for reserve elements. <p> It is tedious to define these concepts for rules anew. This is our motivation for introducing rules as extended terms. We realize that our exposition may be confusing for the reader seeing rules for the first time; such a reader is referred to <ref> [Gur97] </ref> for a traditional definition of rules. 10 Definition 16 (Rule) An extended typeable term R is called a rule iff the following conditions are satisfied. 1. The principal type of R is rule. 2. The principal typing environment does not assign the type rule to any variable. 3. <p> We regard do forall x; y satisfying g R as an abbreviation of do forall x satisfying true do forall y satisfying g R end-do and similar abbreviations apply for any number of variables. Note: According to <ref> [Gur97] </ref>, one can also interpret the abbreviation given above as do forall x satisfying (9y)g do forall y satisfying g R end-do i.e., the guard true can be replaced by the first order term (9y)g. However, we will ignore first order terms in this paper. <p> Firing a rule is then done by non-deterministically choosing an update set from this family and then firing this update set. Here, we forgo a formal definition, and refer to <ref> [Gur97] </ref> for the details. It is straightforward to adapt the definition given in the above reference to the typed case. 4 An Example In this section we give an example of a typed ASM specification.
Reference: [HL92] <author> Patricia M. Hill and John W. Lloyd. </author> <title> The Godel programming language. </title> <type> Technical Report CSTR-92-27, </type> <institution> Department of Computer Science, University of Bristol, </institution> <year> 1992. </year>
Reference-contexts: BCPL, the untyped forerunner of C, has been completely replaced by C and C ++ . Similarly Lisp is being gradually replaced by ML and Haskell. Concerning logic programming, the last years have seen the development of several typed logic programming languages, e.g., Mercury [HSC96], Protos-L [Bei95], and Godel <ref> [HL92] </ref>. Among others, there are the following important reasons for the introduction of types: 1. To facilitate structuring of the data of an application. 2. To have a type checker that automatically detects errors at compile time. Detecting errors automatically when writing a program is certainly useful.
Reference: [HSC96] <author> Fergus Henderson, Zoltan Somogyi, and Thomas Conway. </author> <title> Determinism analysis in the mercury compiler. </title> <booktitle> In Proceedings of the Australian Computer Science Conference, </booktitle> <pages> pages 337-346, </pages> <address> Melbourne, Australia, </address> <month> January </month> <year> 1996. </year> <month> 21 </month>
Reference-contexts: BCPL, the untyped forerunner of C, has been completely replaced by C and C ++ . Similarly Lisp is being gradually replaced by ML and Haskell. Concerning logic programming, the last years have seen the development of several typed logic programming languages, e.g., Mercury <ref> [HSC96] </ref>, Protos-L [Bei95], and Godel [HL92]. Among others, there are the following important reasons for the introduction of types: 1. To facilitate structuring of the data of an application. 2. To have a type checker that automatically detects errors at compile time.
Reference: [LP97] <author> Leslie Lamport and Lawrence C. Paulson. </author> <title> Should your specification language be typed. </title> <type> Report 147, </type> <institution> DEC Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: Furthermore, following a software engineering approach known as data oriented, one starts building a complex system by building the so called data model. It is obvious that this process is facilitated by a suitable type system. However, typing a specification language is not without its own pitfalls; cf. <ref> [LP97] </ref>. The same richness of types that makes it convenient to describe types in applications may become an impediment. In the worst case, it may lead to inconsistencies of the type system. [LP97] cites some examples. <p> However, typing a specification language is not without its own pitfalls; cf. <ref> [LP97] </ref>. The same richness of types that makes it convenient to describe types in applications may become an impediment. In the worst case, it may lead to inconsistencies of the type system. [LP97] cites some examples. Also, for a rich type system the 1 well-typedness problem tends to get hard and might even be undecidable. And then one of the main typing benefits is lost.
Reference: [Mil78] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <year> 1978. </year>
Reference-contexts: As a consequence, the richness of a type system is less vital for ASMs than it is for many other specification languages. For these reasons, we have decided to build a simple type system. We present a type system that introduces parametric polymorphism as suggested by [Mor68] and <ref> [Mil78] </ref>. Our type system can be described as a restriction of the type system of the programming language ML [MTH90] to the first order case. A followup paper [GS98] extends our type system with casting [FM90] and a modest version of type classes [WB89].
Reference: [MM82] <author> Alberto Martelli and Ugo Montanari. </author> <title> An efficient unification algorithm. </title> <journal> ACM Transactions on Programming Language Systems, </journal> <volume> 4 </volume> <pages> 258-282, </pages> <year> 1982. </year>
Reference: [Mor68] <author> Jim H. Morris. </author> <title> Lambda Calculus Models of Programming Languages. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1968. </year>
Reference-contexts: As a consequence, the richness of a type system is less vital for ASMs than it is for many other specification languages. For these reasons, we have decided to build a simple type system. We present a type system that introduces parametric polymorphism as suggested by <ref> [Mor68] </ref> and [Mil78]. Our type system can be described as a restriction of the type system of the programming language ML [MTH90] to the first order case. A followup paper [GS98] extends our type system with casting [FM90] and a modest version of type classes [WB89].
Reference: [MTH90] <author> Robin Milner, Mats Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: For these reasons, we have decided to build a simple type system. We present a type system that introduces parametric polymorphism as suggested by [Mor68] and [Mil78]. Our type system can be described as a restriction of the type system of the programming language ML <ref> [MTH90] </ref> to the first order case. A followup paper [GS98] extends our type system with casting [FM90] and a modest version of type classes [WB89]. This is not the first paper on typed ASMs. In the pioneering paper [Zam97], Zamulin presented a different and more ambitious approach. <p> For example, this is done in the literature on the programming language ML <ref> [MTH90] </ref>. However, since adding universal quantifiers to type specifications does not add any new information, we leave these universal quantifiers implicit. 4 denotes a corresponding default value. For example, in the case of the type bool, default denotes the value false.
Reference: [OW97] <author> Martin Odersky and Philip Wadler. </author> <title> Pizza into Java: Translating theory into practice. </title> <booktitle> In Proc. 24th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1997. </year>
Reference-contexts: However, we will ignore first order terms in this paper. These terms will be dealt with in [GS98]. The most important syntactic sugaring is the introduction of the matching rule. It is akin to the matching rule found in Pizza <ref> [OW97] </ref>, an extension of the programming language Java TM [GJS96]. The syntax of the matching rule is match t case p 1 : R 1 . . . case p n : R n otherwise: R n+1 end-match.
Reference: [Rob65] <author> John Alan Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the ACM, </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: In order for this paper to be self contained, the appendix of this paper deals with the issue of type inference. Appendix A gives an algorithm to compute the principal type of a typeable term. This algorithm is based on unification <ref> [Rob65] </ref>. Unification is discussed in Appendix B. Since this paper is concerned mainly with the concept of a typed ASM, we do not discuss the implementation of the algorithms given in the appendix. Accordingly, efficiency is not an issue.
Reference: [Wan87] <author> Mitchell Wand. </author> <title> A simple algorithm and proof for type inference. </title> <journal> Fundamenta Infomaticae, </journal> <volume> 10 </volume> <pages> 115-122, </pages> <year> 1987. </year>
Reference: [WB89] <author> Philip Wadler and Stephen Blott. </author> <title> How to make ad-hoc polymorphism less ad hoc. </title> <booktitle> ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: Our type system can be described as a restriction of the type system of the programming language ML [MTH90] to the first order case. A followup paper [GS98] extends our type system with casting [FM90] and a modest version of type classes <ref> [WB89] </ref>. This is not the first paper on typed ASMs. In the pioneering paper [Zam97], Zamulin presented a different and more ambitious approach. Zamulin does not confine himself to the introduction of types. He introduces a specification language for specifying the static part of an ASM.
Reference: [Zam97] <author> Alexandre V. Zamulin. </author> <title> Typed Gurevich machines revisited. </title> <journal> Joint NCC and IIS Bulletin of Computer Science, </journal> <volume> 5 </volume> <pages> 1-30, </pages> <year> 1997. </year> <note> Acknowledgements We thank Egon Borger, </note> <author> Bertil A. Brandin, Sabine Glesner, Jim Huggins, Martin Muller, </author> <title> and Peter Pappinghaus for commenting on drafts of this paper. Furthermore, we would like to thank three anonymous referees, who have given given very detailed and helpful comments. The second author has been partially supported by NSF grant CCR 95-04375 and ONR grant N00014-94-1-1137. The third author has been partially supported by BMBF grant 01 IS 519 A 9. </title>
Reference-contexts: A followup paper [GS98] extends our type system with casting [FM90] and a modest version of type classes [WB89]. This is not the first paper on typed ASMs. In the pioneering paper <ref> [Zam97] </ref>, Zamulin presented a different and more ambitious approach. Zamulin does not confine himself to the introduction of types. He introduces a specification language for specifying the static part of an ASM. This provides obvious benefits but much of the flexibility of the ASM approach is lost in the process.
References-found: 22

