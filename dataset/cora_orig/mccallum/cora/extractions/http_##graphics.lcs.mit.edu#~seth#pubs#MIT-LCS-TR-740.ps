URL: http://graphics.lcs.mit.edu/~seth/pubs/MIT-LCS-TR-740.ps
Refering-URL: http://graphics.lcs.mit.edu/~seth/pubs/pubs.html
Root-URL: 
Title: Frustum Casting for Progressive, Interactive Rendering  
Author: Seth Teller John Alex 
Date: January 1998  
Affiliation: MIT Computer Graphics Group  Brown Computer Graphics Group  
Pubnum: MIT LCS TR-740  
Abstract: This technical report (TR) has been made available free of charge from the MIT Laboratory for Computer Science, at www.lcs.mit.edu. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Airey, J. M., Rohlf, J. H., and Brooks, Jr., F. P. </author> <title> Towards image realism with interactive update rates in complex virtual building environments. </title> <booktitle> ACM Siggraph Special Issue on 1990 Symposium on Interactive 3D Graphics 24, 2 (1990), </booktitle> <pages> 41-50. </pages>
Reference-contexts: Frustum culling algorithms cull those scene elements lying outside the view frustum, but do not detect occlusion [17]. Occlusion culling algorithms exclude portions of the scene invisible due to nearer, opaque elements; these algorithms operate in object space <ref> [1, 29, 11, 22] </ref> or in both object and image space [20, 24, 19, 32]. <p> A perfect visibility "oracle" (as yet 3 undiscovered) could do so without touching invisible scene elements, thus eliminating overdraw entirely. For specialized environments, effective oracles exist through "preprocessing" <ref> [1, 29, 16] </ref>. The principal strength of these methods is their capability to schedule physical and virtual memory accesses both before and during rendering, avoiding most sudden losses of interaction due to traversal of out-of-memory scene elements. <p> Frustum Advance. The spatial index is traversed starting from a leaf cell, by adjacency, and constrained so as to maintain incidence with the view frustum. Examples of frustum advance algorithms are (for conservative interactive viewing of polyhedral, densely occluded, typically architectural environments) <ref> [23, 1, 16, 24] </ref>, and (for analytic, usually batch rendering of general environments) ray casting with spatial indexing (e.g., [18, 14]). This class of algorithm has a nearly minimal memory footprint; it touches no nodes beyond the occlusion frontier (Figure 1-d).
Reference: [2] <author> Akeley, K. </author> <title> The Silicon Graphics 4D/240GTX superworkstation. </title> <journal> IEEE Computer Graphics and Applications 9, </journal> <month> 4 (July </month> <year> 1989), </year> <pages> 71-83. </pages>
Reference-contexts: Specialized hardware "geometry engines" eventually emerged to accelerate the extensive calculations inherent in polygon transformation, clipping, shading and rasterization [10]. Such dedicated rendering architectures have since formed a major development path, as successive versions have incorporated depth-buffering, texturing, and many other extended capabilities (e.g., <ref> [4, 2, 3, 25, 27] </ref>). 1.2 Managing Geometric Complexity Graphics workstations dedicate substantial hardware "pipelines" to geometric transformations, polygon clipping, application of shading and texturing operations, anti-aliasing and depth-buffering. However, geometric models have grown ever more complex as well, due to CAD, military, scientific, entertainment and other applications.
Reference: [3] <author> Akeley, K. </author> <title> RealityEngine graphics. </title> <booktitle> Computer Graphics 27, Annual Conference Series (1993), </booktitle> <pages> 109-116. </pages>
Reference-contexts: Specialized hardware "geometry engines" eventually emerged to accelerate the extensive calculations inherent in polygon transformation, clipping, shading and rasterization [10]. Such dedicated rendering architectures have since formed a major development path, as successive versions have incorporated depth-buffering, texturing, and many other extended capabilities (e.g., <ref> [4, 2, 3, 25, 27] </ref>). 1.2 Managing Geometric Complexity Graphics workstations dedicate substantial hardware "pipelines" to geometric transformations, polygon clipping, application of shading and texturing operations, anti-aliasing and depth-buffering. However, geometric models have grown ever more complex as well, due to CAD, military, scientific, entertainment and other applications.
Reference: [4] <author> Akeley, K., and Jermoluk, T. </author> <title> High-performance polygon rendering. </title> <booktitle> Computer Graphics 22, Annual Conference Series (1988), </booktitle> <pages> 239-246. </pages>
Reference-contexts: Specialized hardware "geometry engines" eventually emerged to accelerate the extensive calculations inherent in polygon transformation, clipping, shading and rasterization [10]. Such dedicated rendering architectures have since formed a major development path, as successive versions have incorporated depth-buffering, texturing, and many other extended capabilities (e.g., <ref> [4, 2, 3, 25, 27] </ref>). 1.2 Managing Geometric Complexity Graphics workstations dedicate substantial hardware "pipelines" to geometric transformations, polygon clipping, application of shading and texturing operations, anti-aliasing and depth-buffering. However, geometric models have grown ever more complex as well, due to CAD, military, scientific, entertainment and other applications.
Reference: [5] <author> Appel, A. </author> <title> Some techniques for shading machine renderings of solids. </title> <booktitle> In Proceedings of SJCC (1968), </booktitle> <publisher> Thompson Books, </publisher> <address> Washington, D.C., </address> <pages> pp. 37-45. </pages>
Reference-contexts: This interruptable scheduling mechanism supports either fixed-time or fixed-quality rendering. 5.3 Shading The shading module implements Phong lighting [26], as well as diffuse texture lookups and shadow rays <ref> [5] </ref>, at each pixel. From visible surface points identified by frustum casting, the shading model generates "confirmed" sample values for use by the reconstruction module and eventual display (x5.4). Shading tasks can be interactively designated as either "immediate" or "deferred." During user motion, the shading module performs only immediate subtasks.
Reference: [6] <author> Arge, L., Vengroff, D. E., and Vitter, J. S. </author> <title> External-memory algorithms for processing line segments in geographic information systems. </title> <booktitle> Lecture Notes in Computer Science 979 (1995), </booktitle> <pages> 295. </pages>
Reference-contexts: The care with which algorithms manage access to this spatial index will become an increasingly important, and perhaps decisive, evaluation criterion. This has already occurred in the GIS community, although so far mostly for two-dimensional data <ref> [6] </ref>. We defer a discussion of algorithmic working set considerations to x1.5. Finally, general purpose processors have grown enormously powerful. Most desktop workstations make available several hundred MIPS and MFLOPS for general purpose computing.
Reference: [7] <author> Bentley, J. </author> <title> Multidimensional binary search trees used for associative searching. </title> <booktitle> Communications of the ACM 18 (1975), </booktitle> <pages> 509-517. </pages>
Reference-contexts: We describe each module in turn, then give some examples of the system in use. 5.1 Spatial Index The spatial index is an implementation of k d trees <ref> [7] </ref>, augmented to support ray casting and primitive intersections tests as in [18], and frustum casting as described here. (Note that any spatial decomposition fixed grid, octree, tetrahedralization, hexahedralization, etc. would serve here so long as it supports object population, point location, and ray traversal.) The currently supported set of objects
Reference: [8] <author> Bishop, L., Eberly, D., Whitted, T., Finch, M., and Shantz, M. </author> <title> Designing a pc game engine. </title> <journal> IEEE Computer Graphics and Applications 18, </journal> <volume> 1 (January/February 1998), </volume> <pages> 46-53. </pages>
Reference-contexts: It remains to be seen which of these algorithms, when afforded equivalent computational bandwidth, is superior in practice, and in what regime of performance, model complexity, and viewport resolution. 6 A related idea has been developed independently <ref> [8] </ref>. 7 Note that near and far planes are not required by ray casting, in contrast to approaches which use standard perspective transformation. 10 5 Implementation and Example Results We implemented a simple software prototype of a progressive rendering system based on frustum casting.
Reference: [9] <author> Catmull, E. E. </author> <title> A Subdivision Algorithm for Computer Display of Curved Surfaces. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> Dec. </month> <year> 1974. </year> <note> Also TR UTEC-CSc-74-133, </note> <institution> CS Dept., University of Utah. </institution>
Reference-contexts: This can be wasteful when visibility information is required only for a finite set of samples at each pixel. Thus these algorithms are not ordinarily competitive for very complex, or very general, environments. The z-buffer, proposed in <ref> [9] </ref>, resolved visibility independently at each pixel through repeated depth comparisons. Although this method was initially regarded as overly memory-intensive, it did have time complexity linear in the scene size; as available memory grew and cheapened, depth buffering gained favor over object space methods.
Reference: [10] <author> Clark, J. H. </author> <title> The geometry engine: A VLSI geometry system for graphics. </title> <booktitle> Computer Graphics 16, </booktitle> <month> 3 (July </month> <year> 1982), </year> <pages> 127-133. </pages>
Reference-contexts: Specialized hardware "geometry engines" eventually emerged to accelerate the extensive calculations inherent in polygon transformation, clipping, shading and rasterization <ref> [10] </ref>.
Reference: [11] <author> Coorg, S., and Teller, S. </author> <title> Temporally coherent conservative visibility. </title> <booktitle> In Proc. 12 th Annual ACM Symposium on Computational Geometry (1996). </booktitle>
Reference-contexts: Frustum culling algorithms cull those scene elements lying outside the view frustum, but do not detect occlusion [17]. Occlusion culling algorithms exclude portions of the scene invisible due to nearer, opaque elements; these algorithms operate in object space <ref> [1, 29, 11, 22] </ref> or in both object and image space [20, 24, 19, 32]. <p> Frustum culling algorithms process nodes outside the view frustum and beyond the occlusion frontier, and scene geometry beyond the occlusion frontier, resulting in extensive overdraw (Figure 1-b). Occlusion Culling. A collection of occluders near the viewpoint is identified either o*ine or during rendering, and maintained either in object space <ref> [11, 22] </ref> or (hierarchically and conservatively 2 ) in screen space [20, 19, 32]. The spatial index is traversed from the root. If a cell is occluded by the current occlusion map, its children are unexamined. Otherwise, its associated geometric data and children are traversed, possibly updating the visibility map. <p> The algorithm we introduce falls into this category. 2 The algorithm of [32] is not conservative; that is, it may omit visible polygons. 3 The scene in [19] was procedurally instanced, avoiding the problems inherent in global scene traversal. 4 In fact each of <ref> [20, 19, 11, 22, 32] </ref> uses the root-first traversal order of [17].
Reference: [12] <author> Fournier, A., and Poulin, P. </author> <title> A ray tracing accelerator based on a hierarchy of 1D sorted lists. </title> <booktitle> In Proceedings of Graphics Interface '93 (Toronto, </booktitle> <address> Ontario, </address> <month> May </month> <year> 1993), </year> <booktitle> Canadian Information Processing Society, </booktitle> <pages> pp. 53-61. </pages>
Reference-contexts: Frusta can be classified with regard to sign and major propagation direction, and checked against incidence lists using 1-D object sorting, as in <ref> [12] </ref>. The difference is that, while unitized rays always have a unique major direction, frusta may not.
Reference: [13] <author> Francois Sillion, George Drettakis, B. B. </author> <title> Efficient impostor manipulation for real-time visualization of urban scenery. </title> <booktitle> In Eurographics '97 (Oxford, UK, 1997), Eurographics, </booktitle> <publisher> Blackwell Publishers. </publisher>
Reference-contexts: When the visible scene geometry is larger than physical memory, researchers have proposed substituting simplified geometry [15] or imagery <ref> [13] </ref>. Such methods have complex implications for memory footprint, and are outside the scope of this discussion of visible surface algorithms. When only a portion of the scene is visible from ordinary viewpoints, an effective algorithm could reduce overdraw by identifying and traversing only this portion.
Reference: [14] <author> Fujimoto, A., and Iwata, K. </author> <title> Accelerated ray tracing. </title> <booktitle> Computer Graphics: Visual Technology and Art (Proc. Computer Graphics Tokyo '85) (1985), </booktitle> <pages> 41-65. </pages>
Reference-contexts: Examples of frustum advance algorithms are (for conservative interactive viewing of polyhedral, densely occluded, typically architectural environments) [23, 1, 16, 24], and (for analytic, usually batch rendering of general environments) ray casting with spatial indexing (e.g., <ref> [18, 14] </ref>). This class of algorithm has a nearly minimal memory footprint; it touches no nodes beyond the occlusion frontier (Figure 1-d).
Reference: [15] <author> Funkhouser, T., and S equin, C. </author> <title> Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments. </title> <booktitle> Computer Graphics (Proc. Siggraph '93) 27 (1993), </booktitle> <pages> 247-254. </pages>
Reference-contexts: Working set is closely related to "overdraw," the effort expended to render (transform, light, clip, rasterize, depth buffer; intersect rays with; etc.) surfaces which do not contribute to the rendered image. When the visible scene geometry is larger than physical memory, researchers have proposed substituting simplified geometry <ref> [15] </ref> or imagery [13]. Such methods have complex implications for memory footprint, and are outside the scope of this discussion of visible surface algorithms. When only a portion of the scene is visible from ordinary viewpoints, an effective algorithm could reduce overdraw by identifying and traversing only this portion.
Reference: [16] <author> Funkhouser, T., S equin, C., and Teller, S. </author> <title> Management of large amounts of data in interactive building walkthroughs. </title> <booktitle> In Proc. 1992 Workshop on Interactive 3D Graphics (1992), </booktitle> <pages> pp. 11-20. </pages>
Reference-contexts: A perfect visibility "oracle" (as yet 3 undiscovered) could do so without touching invisible scene elements, thus eliminating overdraw entirely. For specialized environments, effective oracles exist through "preprocessing" <ref> [1, 29, 16] </ref>. The principal strength of these methods is their capability to schedule physical and virtual memory accesses both before and during rendering, avoiding most sudden losses of interaction due to traversal of out-of-memory scene elements. <p> Frustum Advance. The spatial index is traversed starting from a leaf cell, by adjacency, and constrained so as to maintain incidence with the view frustum. Examples of frustum advance algorithms are (for conservative interactive viewing of polyhedral, densely occluded, typically architectural environments) <ref> [23, 1, 16, 24] </ref>, and (for analytic, usually batch rendering of general environments) ray casting with spatial indexing (e.g., [18, 14]). This class of algorithm has a nearly minimal memory footprint; it touches no nodes beyond the occlusion frontier (Figure 1-d).
Reference: [17] <author> Garlick, B., Baum, D. R., and Winget, J. M. </author> <title> Interactive viewing of large geometric databases using multiprocessor graphics workstations. Siggraph '90 Course Notes (Parallel Algorithms and Architectures for 3D Image Generation) (1990). </title>
Reference-contexts: Efficient algorithms to identify and render only potentially visible scene elements, thus reducing overdraw, appear in several forms. Frustum culling algorithms cull those scene elements lying outside the view frustum, but do not detect occlusion <ref> [17] </ref>. Occlusion culling algorithms exclude portions of the scene invisible due to nearer, opaque elements; these algorithms operate in object space [1, 29, 11, 22] or in both object and image space [20, 24, 19, 32]. <p> Either algorithm plainly touches all model data (Figure 1-a), so does not scale well to complex models, and results in extensive overdraw. Frustum Culling. The spatial index is traversed from the root. Recursively, cells are examined for intersection with the view frustum <ref> [17] </ref>. Disjointness causes a cell's associated scene data and children (if any) to go unexamined; incidence causes traversal of the cell's children (if any) and contents. <p> into this category. 2 The algorithm of [32] is not conservative; that is, it may omit visible polygons. 3 The scene in [19] was procedurally instanced, avoiding the problems inherent in global scene traversal. 4 In fact each of [20, 19, 11, 22, 32] uses the root-first traversal order of <ref> [17] </ref>. However each algorithm is easily modified to touch only those nodes incident on the viewing frustum, by adoption of constrained depth- or breadth-first traversal. 4 1.6 Discussion Consider the latter two classes of algorithms: occlusion culling and frustum advance.
Reference: [18] <author> Glassner, A. S. </author> <title> Space subdivision for fast ray tracing. </title> <journal> IEEE Computer Graphics and Applications 4, </journal> <volume> 10 (1984), </volume> <pages> 15-22. </pages>
Reference-contexts: Examples of frustum advance algorithms are (for conservative interactive viewing of polyhedral, densely occluded, typically architectural environments) [23, 1, 16, 24], and (for analytic, usually batch rendering of general environments) ray casting with spatial indexing (e.g., <ref> [18, 14] </ref>). This class of algorithm has a nearly minimal memory footprint; it touches no nodes beyond the occlusion frontier (Figure 1-d). <p> current techniques are converging to ray casting - strong evidence that ray casting deserves examination as a design alternative for interactive rendering systems. 5 2 Preliminaries Frustum casting is a novel synthesis of three well-known algorithms: screen-space subdivision [30], beam tracing [21]; and fast ray walking through a spatial subdivision <ref> [18] </ref>. Each of these algorithms introduced a significant innovation to yield efficiency in an important problem domain. Yet, each has a significant computational disadvantage, as we describe. Frustum casting combines efficient aspects of the three algorithms. 2.1 Screen-Space Subdivision Warnock's hidden-surface elimination algorithm operates as follows [30]. <p> Its running time can therefore grow quadratically with scene complexity, even in the non-recursive (i.e. ray casting) case. 2.3 Ray Walking Glassner's octree-based ray-walking algorithm provided for the efficient propagation of rays through an axial spatial index <ref> [18] </ref>. <p> That it indeed scales to interactive rates on complex scenes is not yet proven, although initial results are encouraging (x5). 3.1 Data Structures and Subdivision The frustum casting method depends on the following data structures. Before interaction begins, the scene is organized into a hierarchical spatial index, as in <ref> [18] </ref>, which supports efficient population of scene objects and location of the synthetic viewpoint. <p> We describe each module in turn, then give some examples of the system in use. 5.1 Spatial Index The spatial index is an implementation of k d trees [7], augmented to support ray casting and primitive intersections tests as in <ref> [18] </ref>, and frustum casting as described here. (Note that any spatial decomposition fixed grid, octree, tetrahedralization, hexahedralization, etc. would serve here so long as it supports object population, point location, and ray traversal.) The currently supported set of objects includes spheres, axial parallelepipeds and polygons (but is of course generalizable to
Reference: [19] <author> Greene, N. </author> <title> Hierarchical polygon tiling with coverage masks. </title> <booktitle> In SIGGRAPH 96 Conference Proceedings (Aug. </booktitle> <year> 1996), </year> <editor> H. Rushmeier, Ed., </editor> <booktitle> Annual Conference Series, ACM SIGGRAPH, </booktitle> <publisher> Addison Wesley, </publisher> <pages> pp. 65-74. </pages> <address> held in New Orleans, Louisiana, </address> <month> 04-09 August </month> <year> 1996. </year>
Reference-contexts: Frustum culling algorithms cull those scene elements lying outside the view frustum, but do not detect occlusion [17]. Occlusion culling algorithms exclude portions of the scene invisible due to nearer, opaque elements; these algorithms operate in object space [1, 29, 11, 22] or in both object and image space <ref> [20, 24, 19, 32] </ref>. <p> Occlusion Culling. A collection of occluders near the viewpoint is identified either o*ine or during rendering, and maintained either in object space [11, 22] or (hierarchically and conservatively 2 ) in screen space <ref> [20, 19, 32] </ref>. The spatial index is traversed from the root. If a cell is occluded by the current occlusion map, its children are unexamined. Otherwise, its associated geometric data and children are traversed, possibly updating the visibility map. <p> This class of algorithm has a nearly minimal memory footprint; it touches no nodes beyond the occlusion frontier (Figure 1-d). The algorithm we introduce falls into this category. 2 The algorithm of [32] is not conservative; that is, it may omit visible polygons. 3 The scene in <ref> [19] </ref> was procedurally instanced, avoiding the problems inherent in global scene traversal. 4 In fact each of [20, 19, 11, 22, 32] uses the root-first traversal order of [17]. <p> The algorithm we introduce falls into this category. 2 The algorithm of [32] is not conservative; that is, it may omit visible polygons. 3 The scene in [19] was procedurally instanced, avoiding the problems inherent in global scene traversal. 4 In fact each of <ref> [20, 19, 11, 22, 32] </ref> uses the root-first traversal order of [17]. <p> However each algorithm is easily modified to touch only those nodes incident on the viewing frustum, by adoption of constrained depth- or breadth-first traversal. 4 1.6 Discussion Consider the latter two classes of algorithms: occlusion culling and frustum advance. Of occlusion culling algorithms, only <ref> [20, 19, 32] </ref> are likely to scale well to large environments, and then only if they adopt the spatial traversal ordering (i.e., eye outward, constrained to within the frustum) of frustum advance methods. <p> Now consider the overall processing performed by a hardware rasterization system when augmented by any of the proposed algorithms of <ref> [20, 19, 32] </ref>, modified to adopt frustum advance traversal.
Reference: [20] <author> Greene, N., Kass, M., and Miller, G. </author> <title> Hierarchical Z-buffer visibility. </title> <booktitle> In Proceedings of Siggraph '93 (Aug. </booktitle> <year> 1993), </year> <pages> pp. 231-238. </pages>
Reference-contexts: Frustum culling algorithms cull those scene elements lying outside the view frustum, but do not detect occlusion [17]. Occlusion culling algorithms exclude portions of the scene invisible due to nearer, opaque elements; these algorithms operate in object space [1, 29, 11, 22] or in both object and image space <ref> [20, 24, 19, 32] </ref>. <p> Occlusion Culling. A collection of occluders near the viewpoint is identified either o*ine or during rendering, and maintained either in object space [11, 22] or (hierarchically and conservatively 2 ) in screen space <ref> [20, 19, 32] </ref>. The spatial index is traversed from the root. If a cell is occluded by the current occlusion map, its children are unexamined. Otherwise, its associated geometric data and children are traversed, possibly updating the visibility map. <p> The algorithm we introduce falls into this category. 2 The algorithm of [32] is not conservative; that is, it may omit visible polygons. 3 The scene in [19] was procedurally instanced, avoiding the problems inherent in global scene traversal. 4 In fact each of <ref> [20, 19, 11, 22, 32] </ref> uses the root-first traversal order of [17]. <p> However each algorithm is easily modified to touch only those nodes incident on the viewing frustum, by adoption of constrained depth- or breadth-first traversal. 4 1.6 Discussion Consider the latter two classes of algorithms: occlusion culling and frustum advance. Of occlusion culling algorithms, only <ref> [20, 19, 32] </ref> are likely to scale well to large environments, and then only if they adopt the spatial traversal ordering (i.e., eye outward, constrained to within the frustum) of frustum advance methods. <p> Now consider the overall processing performed by a hardware rasterization system when augmented by any of the proposed algorithms of <ref> [20, 19, 32] </ref>, modified to adopt frustum advance traversal.
Reference: [21] <author> Heckbert, P., and Hanrahan, P. </author> <title> Beam tracing polygonal objects. </title> <journal> Computer Graphics (Proc. </journal> <volume> Siggraph '84) 18, 3 (1984), </volume> <pages> 119-127. </pages>
Reference-contexts: We consider this development that current techniques are converging to ray casting - strong evidence that ray casting deserves examination as a design alternative for interactive rendering systems. 5 2 Preliminaries Frustum casting is a novel synthesis of three well-known algorithms: screen-space subdivision [30], beam tracing <ref> [21] </ref>; and fast ray walking through a spatial subdivision [18]. Each of these algorithms introduced a significant innovation to yield efficiency in an important problem domain. Yet, each has a significant computational disadvantage, as we describe. <p> However, the algorithm has a significant disadvantage: to initialize the root viewport, it must classify (e.g., process) every polygon in the scene, even those polygons eventually determined to be invisible. 2.2 Beam Tracing Heckbert and Hanrahan's beam tracing algorithm was formulated for ray tracing polyhedral environments, and operates as follows <ref> [21] </ref>. A root frustum is defined to encompass the entire viewport, and represents an initial visibility "beam" emanating from the eye. A sweep plane algorithm traverses polygons in depth order 5 , and "subtracts" them from the beam (using generalized intersection operations [31]).
Reference: [22] <author> Hudson, T., Manocha, D., Cohen, J., Lin, M., Hoff, K., and Zhang, H. </author> <title> Accelerated occlusion culling using shadow frusta. </title> <booktitle> In Proc. 13 th Annual ACM Symposium on Computational Geometry (1997), </booktitle> <pages> pp. 1-10. </pages>
Reference-contexts: Frustum culling algorithms cull those scene elements lying outside the view frustum, but do not detect occlusion [17]. Occlusion culling algorithms exclude portions of the scene invisible due to nearer, opaque elements; these algorithms operate in object space <ref> [1, 29, 11, 22] </ref> or in both object and image space [20, 24, 19, 32]. <p> Frustum culling algorithms process nodes outside the view frustum and beyond the occlusion frontier, and scene geometry beyond the occlusion frontier, resulting in extensive overdraw (Figure 1-b). Occlusion Culling. A collection of occluders near the viewpoint is identified either o*ine or during rendering, and maintained either in object space <ref> [11, 22] </ref> or (hierarchically and conservatively 2 ) in screen space [20, 19, 32]. The spatial index is traversed from the root. If a cell is occluded by the current occlusion map, its children are unexamined. Otherwise, its associated geometric data and children are traversed, possibly updating the visibility map. <p> The algorithm we introduce falls into this category. 2 The algorithm of [32] is not conservative; that is, it may omit visible polygons. 3 The scene in [19] was procedurally instanced, avoiding the problems inherent in global scene traversal. 4 In fact each of <ref> [20, 19, 11, 22, 32] </ref> uses the root-first traversal order of [17].
Reference: [23] <author> Jones, C. </author> <title> A new approach to the `hidden line' problem. </title> <journal> The Computer Journal 14, </journal> <volume> 3 (1971), </volume> <pages> 232-237. </pages>
Reference-contexts: Frustum Advance. The spatial index is traversed starting from a leaf cell, by adjacency, and constrained so as to maintain incidence with the view frustum. Examples of frustum advance algorithms are (for conservative interactive viewing of polyhedral, densely occluded, typically architectural environments) <ref> [23, 1, 16, 24] </ref>, and (for analytic, usually batch rendering of general environments) ray casting with spatial indexing (e.g., [18, 14]). This class of algorithm has a nearly minimal memory footprint; it touches no nodes beyond the occlusion frontier (Figure 1-d).
Reference: [24] <author> Luebke, D., and Georges, C. </author> <title> Portals and mirrors: Simple, fast evaluation of potentially visible sets. </title> <booktitle> In 1995 Symposium on Interactive 3D Graphics (Apr. </booktitle> <year> 1995), </year> <editor> P. Hanrahan and J. Winget, Eds., </editor> <booktitle> ACM SIGGRAPH, </booktitle> <pages> pp. 105-106. </pages> <note> ISBN 0-89791-736-7. </note>
Reference-contexts: Frustum culling algorithms cull those scene elements lying outside the view frustum, but do not detect occlusion [17]. Occlusion culling algorithms exclude portions of the scene invisible due to nearer, opaque elements; these algorithms operate in object space [1, 29, 11, 22] or in both object and image space <ref> [20, 24, 19, 32] </ref>. <p> Frustum Advance. The spatial index is traversed starting from a leaf cell, by adjacency, and constrained so as to maintain incidence with the view frustum. Examples of frustum advance algorithms are (for conservative interactive viewing of polyhedral, densely occluded, typically architectural environments) <ref> [23, 1, 16, 24] </ref>, and (for analytic, usually batch rendering of general environments) ray casting with spatial indexing (e.g., [18, 14]). This class of algorithm has a nearly minimal memory footprint; it touches no nodes beyond the occlusion frontier (Figure 1-d).
Reference: [25] <author> Montrym, J. S., Baum, D. R., Dignam, D. L., and Migdal, C. J. InfiniteReality: </author> <title> A real-time graphics system. </title> <booktitle> In SIGGRAPH 97 Conference Proceedings (Aug. </booktitle> <year> 1997), </year> <editor> T. Whitted, Ed., </editor> <booktitle> Annual Conference Series, ACM SIGGRAPH, </booktitle> <publisher> Addison Wesley, </publisher> <pages> pp. 293-302. </pages> <note> ISBN 0-89791-896-7. </note>
Reference-contexts: Specialized hardware "geometry engines" eventually emerged to accelerate the extensive calculations inherent in polygon transformation, clipping, shading and rasterization [10]. Such dedicated rendering architectures have since formed a major development path, as successive versions have incorporated depth-buffering, texturing, and many other extended capabilities (e.g., <ref> [4, 2, 3, 25, 27] </ref>). 1.2 Managing Geometric Complexity Graphics workstations dedicate substantial hardware "pipelines" to geometric transformations, polygon clipping, application of shading and texturing operations, anti-aliasing and depth-buffering. However, geometric models have grown ever more complex as well, due to CAD, military, scientific, entertainment and other applications.
Reference: [26] <author> Phong, B.-T. </author> <title> Illumination for computer generated pictures. </title> <journal> Communications of the ACM 18, </journal> <month> 6 (June </month> <year> 1975), </year> <pages> 311-317. </pages>
Reference-contexts: Second, the interleaved sampling schedule ensures that samples are distributed roughly equally throughout the view-port, regardless of whether or when job queue execution is interrupted (for periodic reconstruction and display). This interruptable scheduling mechanism supports either fixed-time or fixed-quality rendering. 5.3 Shading The shading module implements Phong lighting <ref> [26] </ref>, as well as diffuse texture lookups and shadow rays [5], at each pixel. From visible surface points identified by frustum casting, the shading model generates "confirmed" sample values for use by the reconstruction module and eventual display (x5.4).
Reference: [27] <author> Silicon Graphics, I. </author> <title> O 2 unified memory architecture. </title> <type> Tech. Rep. </type> <institution> Whitepaper 1352, Silicon Graphics, Inc., </institution> <year> 1997. </year>
Reference-contexts: Specialized hardware "geometry engines" eventually emerged to accelerate the extensive calculations inherent in polygon transformation, clipping, shading and rasterization [10]. Such dedicated rendering architectures have since formed a major development path, as successive versions have incorporated depth-buffering, texturing, and many other extended capabilities (e.g., <ref> [4, 2, 3, 25, 27] </ref>). 1.2 Managing Geometric Complexity Graphics workstations dedicate substantial hardware "pipelines" to geometric transformations, polygon clipping, application of shading and texturing operations, anti-aliasing and depth-buffering. However, geometric models have grown ever more complex as well, due to CAD, military, scientific, entertainment and other applications. <p> Figure 12 shows the model viewed from "outside," i.e. as an ordinary geometric object. Although our prototype system uses only general-purpose computational resources, it could of course benefit from dedicated hardware, already present in principle in at least one modern hardware rasteriza-tion pipeline <ref> [27] </ref>, to transform rays and normals, perform plane sidedness tests, fetch object bounding volumes, object geometry, and texels from main memory, and perform sample buffer reconstruction. 13 Frame 1 Frame 2 Frame 3 Frame 4 Frame 1 Frame 2 Frame 5 Frame 8 6 Conclusion This paper makes a case, on
Reference: [28] <author> Sutherland, I. E., Sproull, R. F., and Schumacker, R. A. </author> <title> A characterization of ten hidden-surface algorithms. </title> <journal> Computing Surveys 6, </journal> <volume> 1 (1974), </volume> <pages> 1-55. </pages>
Reference-contexts: 1 Introduction and Related Work Achieving visually correct, interactive viewing of complex, general geometric scenes has long been a fundamental challenge in computer graphics. Early rendering systems were based on software implementations of "hidden-surface elimination" algorithms for polygonal scenes <ref> [28] </ref>. Given a scene description, these elegant algorithms identified and displayed those portions of the scene visible to a specified synthetic camera. Importantly, these algorithms compute analytic (i.e., object-space) descriptions of visible surfaces and surface fragments.
Reference: [29] <author> Teller, S., and S equin, C. H. </author> <title> Visibility preprocessing for interactive walkthroughs. </title> <journal> Computer Graphics (Proc. </journal> <volume> Siggraph '91) 25, 4 (1991), </volume> <pages> 61-69. </pages>
Reference-contexts: Frustum culling algorithms cull those scene elements lying outside the view frustum, but do not detect occlusion [17]. Occlusion culling algorithms exclude portions of the scene invisible due to nearer, opaque elements; these algorithms operate in object space <ref> [1, 29, 11, 22] </ref> or in both object and image space [20, 24, 19, 32]. <p> A perfect visibility "oracle" (as yet 3 undiscovered) could do so without touching invisible scene elements, thus eliminating overdraw entirely. For specialized environments, effective oracles exist through "preprocessing" <ref> [1, 29, 16] </ref>. The principal strength of these methods is their capability to schedule physical and virtual memory accesses both before and during rendering, avoiding most sudden losses of interaction due to traversal of out-of-memory scene elements.
Reference: [30] <author> Warnock, J. </author> <title> A hidden-surface algorithm for computer generated half-tone pictures. </title> <type> Tech. Rep. TR 4-15, </type> <institution> NTIS AD-733 671, University of Utah, Computer Science Department, </institution> <year> 1969. </year>
Reference-contexts: to a method for hidden-surface elimination, rendering systems formulate a shading model in order to display visible scene elements with simulated illumination values. 1.1 Depth-Buffered Rasterization Architectures Early hidden-surface algorithms expend considerable effort computing descriptions of visible fragments in object space (or some hybrid of object and screen space, e.g., <ref> [30] </ref>). This can be wasteful when visibility information is required only for a finite set of samples at each pixel. Thus these algorithms are not ordinarily competitive for very complex, or very general, environments. The z-buffer, proposed in [9], resolved visibility independently at each pixel through repeated depth comparisons. <p> We consider this development that current techniques are converging to ray casting - strong evidence that ray casting deserves examination as a design alternative for interactive rendering systems. 5 2 Preliminaries Frustum casting is a novel synthesis of three well-known algorithms: screen-space subdivision <ref> [30] </ref>, beam tracing [21]; and fast ray walking through a spatial subdivision [18]. Each of these algorithms introduced a significant innovation to yield efficiency in an important problem domain. Yet, each has a significant computational disadvantage, as we describe. <p> Each of these algorithms introduced a significant innovation to yield efficiency in an important problem domain. Yet, each has a significant computational disadvantage, as we describe. Frustum casting combines efficient aspects of the three algorithms. 2.1 Screen-Space Subdivision Warnock's hidden-surface elimination algorithm operates as follows <ref> [30] </ref>. Given a root (screen space) viewport and a collection of polygons, all polygons are transformed to screen space (retaining depth) and classified as disjoint, covering, or incident on the root viewport.
Reference: [31] <author> Weiler, K., and Atherton, P. </author> <title> Hidden surface removal using polygon area sorting. </title> <journal> Computer Graphics (Proc. </journal> <volume> Siggraph '77) 11, 2 (1977), </volume> <pages> 214-222. </pages>
Reference-contexts: A root frustum is defined to encompass the entire viewport, and represents an initial visibility "beam" emanating from the eye. A sweep plane algorithm traverses polygons in depth order 5 , and "subtracts" them from the beam (using generalized intersection operations <ref> [31] </ref>). The masked portion of the beam is then reflected from the occluding polygon and recursively propagated through the scene. Beam tracing's significant innovation is its use of polyhedral beams to advance many rays through the scene at once, attaining significant acceleration of ray tracing.
Reference: [32] <author> Zhang, H., Manocha, D., Hudson, T., and Hoff III, K. E. </author> <title> Visibility culling using hierarchical occlusion maps. </title> <booktitle> In SIGGRAPH 97 Conference Proceedings (Aug. </booktitle> <year> 1997), </year> <editor> T. Whitted, Ed., </editor> <booktitle> Annual Conference Series, ACM SIGGRAPH, </booktitle> <publisher> Addison Wesley, </publisher> <pages> pp. 77-88. </pages> <note> ISBN 0-89791-896-7. </note>
Reference-contexts: Frustum culling algorithms cull those scene elements lying outside the view frustum, but do not detect occlusion [17]. Occlusion culling algorithms exclude portions of the scene invisible due to nearer, opaque elements; these algorithms operate in object space [1, 29, 11, 22] or in both object and image space <ref> [20, 24, 19, 32] </ref>. <p> Occlusion Culling. A collection of occluders near the viewpoint is identified either o*ine or during rendering, and maintained either in object space [11, 22] or (hierarchically and conservatively 2 ) in screen space <ref> [20, 19, 32] </ref>. The spatial index is traversed from the root. If a cell is occluded by the current occlusion map, its children are unexamined. Otherwise, its associated geometric data and children are traversed, possibly updating the visibility map. <p> This class of algorithm has a nearly minimal memory footprint; it touches no nodes beyond the occlusion frontier (Figure 1-d). The algorithm we introduce falls into this category. 2 The algorithm of <ref> [32] </ref> is not conservative; that is, it may omit visible polygons. 3 The scene in [19] was procedurally instanced, avoiding the problems inherent in global scene traversal. 4 In fact each of [20, 19, 11, 22, 32] uses the root-first traversal order of [17]. <p> The algorithm we introduce falls into this category. 2 The algorithm of [32] is not conservative; that is, it may omit visible polygons. 3 The scene in [19] was procedurally instanced, avoiding the problems inherent in global scene traversal. 4 In fact each of <ref> [20, 19, 11, 22, 32] </ref> uses the root-first traversal order of [17]. <p> However each algorithm is easily modified to touch only those nodes incident on the viewing frustum, by adoption of constrained depth- or breadth-first traversal. 4 1.6 Discussion Consider the latter two classes of algorithms: occlusion culling and frustum advance. Of occlusion culling algorithms, only <ref> [20, 19, 32] </ref> are likely to scale well to large environments, and then only if they adopt the spatial traversal ordering (i.e., eye outward, constrained to within the frustum) of frustum advance methods. <p> Now consider the overall processing performed by a hardware rasterization system when augmented by any of the proposed algorithms of <ref> [20, 19, 32] </ref>, modified to adopt frustum advance traversal. <p> Frustum subdivision is therefore unsuitable for application in complex environments. 3 Frustum Casting Recently, several practically-motivated criteria have been proposed for visibility culling algorithms: that such algorithms be general, run at interactive rates, provide effective culling, be amenable to implementation, and scale well to complex models <ref> [32] </ref>. Here we suggest a somewhat more theoretically motivated set of design considerations germane to crafting visible surface algorithms.
Reference: [33] <author> Zhao, T. C., and Overmars, M. </author> <note> X-Forms http://bloch.phys.uwm.edu/xforms. 17 </note>
Reference-contexts: Instead, such frame-related variables maintain a monotically increasing frame time; if it does not match the globally-maintained time, the variable is treated as uninitialized by the first relevant routine to consider it. 12 5.5 User Interface and Display The user interface is based on XForms <ref> [33] </ref>. Significantly, the UI copies successive reconstructed sample buffers to the framebuffer for display.
References-found: 33

