URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR347.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Email: colby@cs.indiana.edu  
Title: An Algebra for List-Oriented Applications  
Author: Latha S. Colby 
Note: The author was supported by a grant from the Indiana Corporation for Science and Technology.  
Date: February 23, 1992  
Address: Bloomington, IN, 47405  
Affiliation: Department of Computer Science Indiana University  
Abstract: Most data models and query languages, provide mechanisms for dealing with sets of objects. Many applications nowadays, however, are list-oriented, i.e., deal with collections or aggregates of objects in which their order is important. A formal model and an algebra for representing and manipulating list-oriented data are presented in this paper. We also give the criteria that were used in the design of the algebra and show how the algebra satisfies these criteria. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abiteboul, S., and Hull, R. </author> <title> Restructuring hierarchical database objects. </title> <booktitle> Theoretical Computer Science 62 (1988), </booktitle> <pages> 3-38. </pages>
Reference-contexts: The operators Rename and Replace change the structure of instances without affecting the `information content' of the instances. They can hence be considered restructuring operators. Other types of restructuring operators were considered, in [11] and <ref> [1] </ref>, in the context of the Format model. Replace has two parameters and has different actions depending upon the types of these parameters. The first parameter p 1 is a production and the second parameter p 2 is either a production or is of the form C ! fl. <p> Let C, D, E, F , S and Q be variables that are not in the schemes of r 1 or r 2 . 1. r 3 = Insert (P; (fl; ))(r 1 ; h <ref> [C; 1] </ref>; [[C; fC ! Integerg]]i) 2. r 4 = Insert (P; (fl; ))(r 2 ; h [C; 2]; [[C; fC ! Integerg]]i) 3. r 5 = Replace (R ! P fl ; S ! P fl )r 3 4. r 6 = Insert (R; ([S; fl]; fl))(r 5 ; r <p> Union 11. r 13 = F ind (E; <ref> [F ( ([C; 1] </ref>; fl))] ^ [F ( ([C; 2]; fl))]; Q)r 12 12. r 14 = Delete (Q; (fl; ([F; ([C; 2]; fl)]); fl))r 13 72 Difference 11. r 13 = F ind (E; [F ( ([C; 2]; fl))]; Q)r 12 12. r 14 = Delete (R; (fl; ([P; (fl; <p> r 14 = Delete (Q; (fl; ([F; ([C; 2]; fl)]); fl))r 13 72 Difference 11. r 13 = F ind (E; [F ( ([C; 2]; fl))]; Q)r 12 12. r 14 = Delete (R; (fl; ([P; (fl; [E; ([Q; fl])])]); fl))r 13 Intersection 11. r 13 = F ind (E; <ref> [F ( ([C; 1] </ref>; fl))] ^ [F ( ([C; 2]; fl))]; Q)r 12 12. r 14 = Delete (R; (fl; ([P; (fl; [E; (fl; [F; fl]; fl)])]); fl))r 13 The following steps are again common to all the different cases. 13. r 15 = Replace (E ! Q; Q ! fl)r
Reference: [2] <author> Andries, M., Gemis, M., Paredaens, J., Thyssens, I., and Van den Bussche, J. </author> <title> Concepts for graph-oriented object manipulation. </title> <type> Tech. Rep. 91-36, </type> <institution> University of Antwerp (UIA), </institution> <year> 1991. </year> <note> To appear in Proceedings EDBT'92, Lecture Notes in Computer Science, </note> <month> March </month> <year> 1992. </year>
Reference-contexts: For instance, it should be possible to have a system in which there is a query mode and an update mode (similar to the concept of modes in the context of the GOOD model <ref> [2] </ref>). In the query mode the result of an operation Q on an instance i will be a different instance i 0 , whereas in the update mode, i will be replaced by the result of Q (i). <p> D, E, F , S and Q be variables that are not in the schemes of r 1 or r 2 . 1. r 3 = Insert (P; (fl; ))(r 1 ; h [C; 1]; [[C; fC ! Integerg]]i) 2. r 4 = Insert (P; (fl; ))(r 2 ; h <ref> [C; 2] </ref>; [[C; fC ! Integerg]]i) 3. r 5 = Replace (R ! P fl ; S ! P fl )r 3 4. r 6 = Insert (R; ([S; fl]; fl))(r 5 ; r 4 ) 5. r 7 = Rename ((S; R); S; R ! SR)r 6 6. r 8 <p> Union 11. r 13 = F ind (E; [F ( ([C; 1]; fl))] ^ <ref> [F ( ([C; 2] </ref>; fl))]; Q)r 12 12. r 14 = Delete (Q; (fl; ([F; ([C; 2]; fl)]); fl))r 13 72 Difference 11. r 13 = F ind (E; [F ( ([C; 2]; fl))]; Q)r 12 12. r 14 = Delete (R; (fl; ([P; (fl; [E; ([Q; fl])])]); fl))r 13 Intersection <p> Union 11. r 13 = F ind (E; [F ( ([C; 1]; fl))] ^ <ref> [F ( ([C; 2] </ref>; fl))]; Q)r 12 12. r 14 = Delete (Q; (fl; ([F; ([C; 2]; fl)]); fl))r 13 72 Difference 11. r 13 = F ind (E; [F ( ([C; 2]; fl))]; Q)r 12 12. r 14 = Delete (R; (fl; ([P; (fl; [E; ([Q; fl])])]); fl))r 13 Intersection 11. r 13 = F ind (E; [F ( ([C; 1]; fl))] ^ [F ( ([C; 2]; fl))]; Q)r 12 12. r 14 = Delete (R; (fl; ([P; (fl; <p> ([F; ([C; 2]; fl)]); fl))r 13 72 Difference 11. r 13 = F ind (E; <ref> [F ( ([C; 2] </ref>; fl))]; Q)r 12 12. r 14 = Delete (R; (fl; ([P; (fl; [E; ([Q; fl])])]); fl))r 13 Intersection 11. r 13 = F ind (E; [F ( ([C; 1]; fl))] ^ [F ( ([C; 2]; fl))]; Q)r 12 12. r 14 = Delete (R; (fl; ([P; (fl; [E; (fl; [F; fl]; fl)])]); fl))r 13 The following steps are again common to all the different cases. 13. r 15 = Replace (E ! Q; Q ! fl)r 14 14. r 16 = U
Reference: [3] <editor> Bancilhon, F., et al. </editor> <title> The design and implementation of O 2 , an object-oriented database system. </title> <booktitle> In Proceedings of the 2nd International Workshop on Object-Oriented Database Systems (Bad Munster am Stein-Ebernburg, </booktitle> <address> Germany, </address> <month> September </month> <year> 1988), </year> <pages> pp. 1-22. </pages>
Reference-contexts: Models, like the nested relational model [12, 19], are simple extensions of the relational model, that allow a more natural representation of complex objects. Semantic and object-oriented models, such as, ER [4], SDM [9], FDM [18], and O 2 <ref> [3] </ref>, on the other hand, were designed independent of the relational model and are equipped with various data modeling features that enable a variety of data applications to be modeled. However, none of these models is best suited for all applications.
Reference: [4] <author> Chen, P. P. </author> <title> The entity-relationship model-toward a unified view of data. </title> <journal> ACM Transactions on Database Systems 1, </journal> <month> 1 (March </month> <year> 1976), </year> <pages> 9-36. </pages>
Reference-contexts: Models, like the nested relational model [12, 19], are simple extensions of the relational model, that allow a more natural representation of complex objects. Semantic and object-oriented models, such as, ER <ref> [4] </ref>, SDM [9], FDM [18], and O 2 [3], on the other hand, were designed independent of the relational model and are equipped with various data modeling features that enable a variety of data applications to be modeled. However, none of these models is best suited for all applications.
Reference: [5] <author> Codd, E. F. </author> <title> A relational model for large shared data banks. </title> <journal> Communications ACM 6, </journal> <month> 13 (June </month> <year> 1970), </year> <pages> 377-387. </pages>
Reference-contexts: 1 Introduction The relational data model <ref> [5] </ref> provides a simple yet powerful means of representing and querying data. However, the need for representing data with more complex structure and semantic information has resulted in a variety of complex data models.
Reference: [6] <author> Gonnet, G. H., and Tompa, F. W. </author> <title> Mind your grammar-a new approach to mod-elling text. </title> <booktitle> In Proceedings of the 13th VLDB (Brighton, </booktitle> <address> England, </address> <year> 1987), </year> <pages> pp. 339-346. </pages>
Reference-contexts: Operations for manipulating and retrieving documents are provided. Retrievals are specified by means of query filters. A query filter defines a portion of an instance tree and all trees that match the filter are retrieved. Gonnet and Tompa <ref> [6] </ref> proposed a similar model based on grammars and a data-manipulation language. The language is oriented towards "text-dominated databases" and has the flavor of a programming language. In [8], Gyssens, Paredaens and Van Gucht define an algebra and a calculus for a similar grammar-based model. <p> Thus, all of the requirements that were outlined earlier, (except the requirement that the model must allow for sets and bags), are satisfied by the list-structure model. The list-structure model is essentially the same as those of <ref> [6] </ref> and [8]. The main difference is in the kinds of productions that are allowed. For instance, both [6] and [8] allow productions that can have a combination of constants and variables on the right hand side, and [8] does not allow list productions. <p> The list-structure model is essentially the same as those of <ref> [6] </ref> and [8]. The main difference is in the kinds of productions that are allowed. For instance, both [6] and [8] allow productions that can have a combination of constants and variables on the right hand side, and [8] does not allow list productions. These variations do not affect the type of information that can be represented in these models.
Reference: [7] <author> G uting, R. H., Zicari, R., and Choy, D. M. </author> <title> An algebra for structured office documents. </title> <journal> ACM Transactions on Office Information Systems 7, </journal> <month> 4 (April </month> <year> 1989), </year> <pages> 123-157. </pages>
Reference-contexts: The language and the data model that the language is based on are well suited for simple list-oriented applications, but not for complex applications involving variable schema. An algebra for structured office documents is described in <ref> [7] </ref> by Guting, Zicari and Choy. The algebra, which is an extension of the relational algebra, is well-defined and has several features for dealing with sequences of objects. However, the data model upon which the algebra is defined uses a simplistic approach by combining aggregation and sequencing. <p> The result of the application on each tree is stored as an additional attribute within the same tree. This is similar to the extend () operator of <ref> [7] </ref>. The operators listed so far are the value-changing operators. ChangeScheme is a value-preserving operator that is used to modify the scheme of an instance without affecting the structure by adding new productions or deleting extraneous ones.
Reference: [8] <author> Gyssens, M., Paredaens, J., and Van Gucht, D. </author> <title> A grammar-based approach towards unifying hierarchical data models. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data (Portland, </booktitle> <address> Oregon, </address> <year> 1989), </year> <pages> pp. 263-272. 82 </pages>
Reference-contexts: Gonnet and Tompa [6] proposed a similar model based on grammars and a data-manipulation language. The language is oriented towards "text-dominated databases" and has the flavor of a programming language. In <ref> [8] </ref>, Gyssens, Paredaens and Van Gucht define an algebra and a calculus for a similar grammar-based model. While the languages are fairly simple and well defined, the operators of the languages are very primitive. Queries tend to become long and complicated when expressed in terms of such primitive operators. <p> Thus, all of the requirements that were outlined earlier, (except the requirement that the model must allow for sets and bags), are satisfied by the list-structure model. The list-structure model is essentially the same as those of [6] and <ref> [8] </ref>. The main difference is in the kinds of productions that are allowed. For instance, both [6] and [8] allow productions that can have a combination of constants and variables on the right hand side, and [8] does not allow list productions. <p> The list-structure model is essentially the same as those of [6] and <ref> [8] </ref>. The main difference is in the kinds of productions that are allowed. For instance, both [6] and [8] allow productions that can have a combination of constants and variables on the right hand side, and [8] does not allow list productions. These variations do not affect the type of information that can be represented in these models. <p> The list-structure model is essentially the same as those of [6] and <ref> [8] </ref>. The main difference is in the kinds of productions that are allowed. For instance, both [6] and [8] allow productions that can have a combination of constants and variables on the right hand side, and [8] does not allow list productions. These variations do not affect the type of information that can be represented in these models. As we shall see, our choice of production types allows for simplicity in the definitions of the operators of the query language.
Reference: [9] <author> Hammer, M., and McLeod, D. </author> <title> Database description with SDM: A semantic database model. </title> <journal> ACM Transactions on Database Systems 6, </journal> <month> 3 (September </month> <year> 1981), </year> <pages> 351-386. </pages>
Reference-contexts: Models, like the nested relational model [12, 19], are simple extensions of the relational model, that allow a more natural representation of complex objects. Semantic and object-oriented models, such as, ER [4], SDM <ref> [9] </ref>, FDM [18], and O 2 [3], on the other hand, were designed independent of the relational model and are equipped with various data modeling features that enable a variety of data applications to be modeled. However, none of these models is best suited for all applications.
Reference: [10] <author> Hopcroft, J. E., and Ullman, J. D. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979, </year> <title> ch. </title> <booktitle> Context-Free Grammars, </booktitle> <pages> pp. 77-106. </pages>
Reference-contexts: For any scheme G, the set of all the structures that can be defined over G is the same as that of normalize (G). The proof is by induction on the number of productions in G and is very similar to the one given in <ref> [10] </ref> and is hence omitted here. In the rest of this paper we will assume that all structures are defined over normalized schemes. 11 4 An Algebra for the List-Structure Model In this section we describe an algebra for the list-structure model.
Reference: [11] <author> Hull, R., and Yap, C. K. </author> <title> The Format model: A theory of database organization. </title> <journal> JACM 31, </journal> <volume> 3 (1984), </volume> <pages> 518-537. </pages>
Reference-contexts: As we shall see, our choice of production types allows for simplicity in the definitions of the operators of the query language. The list-structure model can also be viewed as a variation of the Format model <ref> [11] </ref>. The objects that can be represented in this model also have hierarchical structures that correspond 5 to types that are built from three type constructors aggregate, set and union and a set of base types. <p> The operators Rename and Replace change the structure of instances without affecting the `information content' of the instances. They can hence be considered restructuring operators. Other types of restructuring operators were considered, in <ref> [11] </ref> and [1], in the context of the Format model. Replace has two parameters and has different actions depending upon the types of these parameters.
Reference: [12] <author> Jaeschke, G., and Schek, H. J. </author> <title> Remarks on the algebra on non-first normal form relations. </title> <booktitle> In Proceedings of the first ACM SIGACT-SIGMOD Symposium on Principles of Database Systems (Los Angeles, </booktitle> <year> 1982), </year> <pages> pp. 124-138. </pages>
Reference-contexts: 1 Introduction The relational data model [5] provides a simple yet powerful means of representing and querying data. However, the need for representing data with more complex structure and semantic information has resulted in a variety of complex data models. Models, like the nested relational model <ref> [12, 19] </ref>, are simple extensions of the relational model, that allow a more natural representation of complex objects. <p> For example, (the structure part of) sum (A ! B fl ; G) when applied to the structure x 3 in Figure 24 will be <ref> [G; 12] </ref>. This way, the closure property that was discussed in Section 4.1 is maintained. 81 Acknowledgements I would like to thank Ed Robertson, Larry Saxton and Dirk Van Gucht for their ideas and suggestions which improved this paper substantially.
Reference: [13] <author> Klug, A. </author> <title> Equivalence of relational algebra and relational calculus query languages having aggregate functions. </title> <journal> Journal of the ACM 29, </journal> <month> 3 (July </month> <year> 1982), </year> <pages> 699-717. </pages>
Reference-contexts: Languages like SQL, and those proposed in [15] and <ref> [13] </ref>, are examples of query languages augmented with aggregate functions. In the list-structure algebra, the Apply function provides an easy means of integrating the results of aggregate or other functions in the structure. We give an example to illustrate this.
Reference: [14] <author> Macleod, I. A. </author> <title> A query language for retrieving information from hierarchic text structures. </title> <journal> The Computer Journal 34, </journal> <volume> 3 (1991), </volume> <pages> 254-264. </pages>
Reference-contexts: While the languages are fairly simple and well defined, the operators of the languages are very primitive. Queries tend to become long and complicated when expressed in terms of such primitive operators. A query language for manipulating text structures was proposed in <ref> [14] </ref> by Macleod. The model on which the language is based allows the hierarchical representation of text (using a grammar-based representation) as well as non-hierarchical linkages between objects (using references).
Reference: [15] <author> Ozsoyoglu, G., Ozsoyoglu, Z. M., and Matos, V. </author> <title> Extending relational algebra and relational calculus with set-valued attributes and aggregate functions. </title> <journal> ACM Transactions on Database Systems 12, </journal> <month> 4 (December </month> <year> 1987), </year> <pages> 566-592. </pages>
Reference-contexts: Languages like SQL, and those proposed in <ref> [15] </ref> and [13], are examples of query languages augmented with aggregate functions. In the list-structure algebra, the Apply function provides an easy means of integrating the results of aggregate or other functions in the structure. We give an example to illustrate this.
Reference: [16] <author> Pistor, P., and Traunmueller, R. </author> <title> A database language for sets, lists and tables. </title> <booktitle> Information Systems 11, 4 (1986), </booktitle> <pages> 323-336. </pages>
Reference-contexts: The model and the language are specifically designed for text applications and 2 are not entirely suitable for other types of list-oriented applications. Moreover, the language does not provide enough flexibility to deal with arbitrary schema restructurings. An extended nested relational model was proposed in <ref> [16] </ref>, by Pistor and Traunmueller for dealing with both sets and lists. They extend the SQL language by providing some list-oriented operators and the equivalent of some nested relational algebra operators.
Reference: [17] <author> Rabitti, F. </author> <title> A model for multimedia documents. In Office Automation, </title> <editor> D. Tsichritzis, Ed. </editor> <publisher> Springer, </publisher> <address> New York, </address> <year> 1985, </year> <pages> pp. 227-250. </pages>
Reference-contexts: A model for multimedia documents was proposed by Rabitti in <ref> [17] </ref>. The model is based on the idea of using context-free grammars to represent document structures. A schema defined in this model consists of a grammar and a set of restrictions.
Reference: [18] <author> Shipman, D. W. </author> <title> The Functional Data Model and the data language DAPLEX. </title> <journal> ACM Transactions on Database Systems 6, </journal> <month> 1 (March </month> <year> 1981), </year> <pages> 140-173. </pages>
Reference-contexts: Models, like the nested relational model [12, 19], are simple extensions of the relational model, that allow a more natural representation of complex objects. Semantic and object-oriented models, such as, ER [4], SDM [9], FDM <ref> [18] </ref>, and O 2 [3], on the other hand, were designed independent of the relational model and are equipped with various data modeling features that enable a variety of data applications to be modeled. However, none of these models is best suited for all applications.
Reference: [19] <author> Thomas, S. J., and Fischer, P. C. </author> <title> Nested Relational Structures. </title> <address> JAIPress, </address> <year> 1986, </year> <pages> pp. 269-307. </pages>
Reference-contexts: 1 Introduction The relational data model [5] provides a simple yet powerful means of representing and querying data. However, the need for representing data with more complex structure and semantic information has resulted in a variety of complex data models. Models, like the nested relational model <ref> [12, 19] </ref>, are simple extensions of the relational model, that allow a more natural representation of complex objects.
References-found: 19

