URL: http://www.daimi.aau.dk/~beta/Papers/Conc/concpaper.ps
Refering-URL: http://www.daimi.aau.dk/~beta/Papers/Conc/concpaper.abstract.html
Root-URL: http://www.daimi.aau.dk
Email: E-mail: olmadsen@daimi.aau.dk  
Phone: Tlf.: +45 86 12 71 88  
Title: Building Abstractions for Concurrent Object-Oriented Programming  
Author: Ole Lehrmann Madsen 
Date: February 1993  
Note: Draft  Category: Research.  
Address: Ny Munkegade, DK-8000 Aarhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University  
Abstract: A large number of different models for concurrent object-oriented programming have been proposed. None of this models have received widespread acceptance. In this paper the Simula model of quasi-parallel execution is extended to include concurrency and synchronization. Active objects may execute concurrently and access shared objects without synchronization. Synchronization may be obtained by means of semaphores. In order to avoid explicit low-level manipulation of semaphores, it is possible to build high-level concurrency abstractions that encapsulates and hide the details of the semaphores. A class library may then include abstractions corresponding to commonly used mechanisms like monitor and rendezvous. When these mechanisms are not adequate, it is possible to define new concurrency abstractions. This approach to concurrent object-oriented programming makes it possible to use many different concurrency abstractions within the same language. It is also possible to some extent to inherit synchronization constraints. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Agha, </author> <title> ACTORS: A Model of Concurrent Computation in Distributed Systems, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: 1 Introduction Many models for concurrent object-oriented programming have been proposed. These models include monitors, CSP/Ada-like type of rendezvous, objects with more than one internal thread, objects with a communication manager controlling the execution of its operations [20], and many more <ref> [1, 2, 3, 7, 19, 21, 22, 23, 25, 26] </ref>. When concurrency is combined with inheritance there is also a large number of proposals for mechanisms for inheriting the protocol or synchronization constraints defined in the superclass [10, 8].
Reference: [2] <author> P. </author> <title> America, Inheritance and Subtyping in a Parallel Object-Oriented Language, </title> <booktitle> Proc. ECOOP'87, European Conference on Object-Oriented Programming (ed. P Cointe), Paris, Springer Lecture Notes in Computer Science Vol. </booktitle> ??, <year> 1987. </year>
Reference-contexts: 1 Introduction Many models for concurrent object-oriented programming have been proposed. These models include monitors, CSP/Ada-like type of rendezvous, objects with more than one internal thread, objects with a communication manager controlling the execution of its operations [20], and many more <ref> [1, 2, 3, 7, 19, 21, 22, 23, 25, 26] </ref>. When concurrency is combined with inheritance there is also a large number of proposals for mechanisms for inheriting the protocol or synchronization constraints defined in the superclass [10, 8].
Reference: [3] <author> P. America, F. van der Linden: </author> <title> A Parallel Object-Oriented Language with Inheritance and Subtyping, </title> <booktitle> OOPSLA/ECOOP'90, Conference on Object-Oriented Programming: Systems, Languages, and Applications/European Conference on Object-Oriented Programming, SIGPLAN Notices, </booktitle> <volume> vol. 25, no. 10, </volume> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Many models for concurrent object-oriented programming have been proposed. These models include monitors, CSP/Ada-like type of rendezvous, objects with more than one internal thread, objects with a communication manager controlling the execution of its operations [20], and many more <ref> [1, 2, 3, 7, 19, 21, 22, 23, 25, 26] </ref>. When concurrency is combined with inheritance there is also a large number of proposals for mechanisms for inheriting the protocol or synchronization constraints defined in the superclass [10, 8].
Reference: [4] <author> G.M. Birtwistle, O.J. Dahl, B. Myhrhaug, K. Nygaard: </author> <title> SIMULA BEGIN, </title> <institution> Lund, Sweden: Studentlitteratur, </institution> <year> 1973. </year>
Reference-contexts: Especially familiarity with the inner construct is important. This may be obtained through some of the references [11, 12, 13, 15, 16, 17, 5]. It is also an advantage if the reader has some knowledge about coroutine sequencing in Simula and BETA. This can be obtained from <ref> [4, 6, 14] </ref>. The BETA program in figure 1 shows the basic elements of BETA including passive and active objects and the execution of active objects as coroutines. The program defines a number of patterns: Account, Deposit, Withdraw and Person.
Reference: [5] <author> G. Bracha, W. Cook: </author> <title> Mixin-based Inheritance, </title> <booktitle> Proc. OOPSLA/ECOOP'90, Conference on Object-Oriented Programming: Systems, Languages, and Applications/European Conference on Object-Oriented Programming, SIGPLAN Notices, </booktitle> <volume> vol. 25, no. 10, </volume> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: It is an advantage if the reader has some previous knowledge about BETA. Especially familiarity with the inner construct is important. This may be obtained through some of the references <ref> [11, 12, 13, 15, 16, 17, 5] </ref>. It is also an advantage if the reader has some knowledge about coroutine sequencing in Simula and BETA. This can be obtained from [4, 6, 14].
Reference: [6] <author> O.-J. Dahl, </author> <title> C.A.R Hoare Hierarchical Program Structures In: Structured Programming (Dahl, Dijkstra, Hoare), </title> <publisher> Academic Press, </publisher> <year> 1972 </year>
Reference-contexts: Especially familiarity with the inner construct is important. This may be obtained through some of the references [11, 12, 13, 15, 16, 17, 5]. It is also an advantage if the reader has some knowledge about coroutine sequencing in Simula and BETA. This can be obtained from <ref> [4, 6, 14] </ref>. The BETA program in figure 1 shows the basic elements of BETA including passive and active objects and the execution of active objects as coroutines. The program defines a number of patterns: Account, Deposit, Withdraw and Person.
Reference: [7] <author> J.-P. Briot, A. Yonezawa: </author> <title> Inheritance and Synchronization in Concurrent OOP, </title> <booktitle> Proc. ECOOP'87, European Conference on Object-Oriented Programming (ed. P Cointe), Paris, Springer Lecture Notes in Computer Science Vol. </booktitle> ??, <year> 1987. </year> <title> 1 C++ has a form of nested classes, but a nested class cannot refer to variables in the enclosing class. Only local variables and global variables can be referred within a class. </title> <type> 19 </type>
Reference-contexts: 1 Introduction Many models for concurrent object-oriented programming have been proposed. These models include monitors, CSP/Ada-like type of rendezvous, objects with more than one internal thread, objects with a communication manager controlling the execution of its operations [20], and many more <ref> [1, 2, 3, 7, 19, 21, 22, 23, 25, 26] </ref>. When concurrency is combined with inheritance there is also a large number of proposals for mechanisms for inheriting the protocol or synchronization constraints defined in the superclass [10, 8].
Reference: [8] <author> S. Frolund: </author> <title> Inheritance of Synchronization Constraints in Concurrent Object--oriented Programming Languages, </title> <booktitle> Proc. ECOOP'92, European Conference on Object-Oriented Programming (ed. O.L Madsen), Utrecht, Springer Lecture Notes in Computer Science Vol. </booktitle> <volume> 615, </volume> <year> 1992. </year>
Reference-contexts: When concurrency is combined with inheritance there is also a large number of proposals for mechanisms for inheriting the protocol or synchronization constraints defined in the superclass <ref> [10, 8] </ref>. In one end of this large spectrum of concurrency mechanisms there are the high-level abstractions, like monitors and rendezvous, which are easy to use and provide a high degree of security.
Reference: [9] <author> C.A.R. Hoare: </author> <title> Monitors: An Operating System Structuring Concept, </title> <journal> Comm. ACM, Oct. </journal> <volume> 74, Vol. 17, No. 10, </volume> <pages> pp. 549-557. </pages>
Reference-contexts: The pattern in figure 6 (adapted from [24]) describes a traditional monitor. The monitor pattern may be used to define a buffer as shown in figure 7. Note that a process executing a signal is delayed if there are processes waiting on the corresponding Condition. As mentioned in <ref> [9] </ref> Signal is often the last imperative executed in an operation. This implies that the signaling process may be unnecessarily delayed. The purpose of this example is not to introduce monitor as a concurrency mechanism for BETA.
Reference: [10] <author> D.G. Kafura, K.H. Lee: </author> <title> Inheritance in Actor Based Concurrent Object-Oriented Languages, </title> <booktitle> Proc. ECOOP'89, European Conference on Object-Oriented Programming (ed. </booktitle> <editor> S. Cook), </editor> <booktitle> British Computer Society Workshop Series, </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: When concurrency is combined with inheritance there is also a large number of proposals for mechanisms for inheriting the protocol or synchronization constraints defined in the superclass <ref> [10, 8] </ref>. In one end of this large spectrum of concurrency mechanisms there are the high-level abstractions, like monitors and rendezvous, which are easy to use and provide a high degree of security.
Reference: [11] <author> B.B. Kristensen, O.L. Madsen, B. Moller-Pedersen, K. </author> <booktitle> NygaardAbstraction Mechanisms in the BETA Programming Language Proceedings of the Tenth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January 24-26 </month> <year> 1983, </year> <institution> Austin, Texas </institution>
Reference-contexts: It is an advantage if the reader has some previous knowledge about BETA. Especially familiarity with the inner construct is important. This may be obtained through some of the references <ref> [11, 12, 13, 15, 16, 17, 5] </ref>. It is also an advantage if the reader has some knowledge about coroutine sequencing in Simula and BETA. This can be obtained from [4, 6, 14].
Reference: [12] <author> B.B. Kristensen, O.L. Madsen, B. Moller-Pedersen, K. </author> <title> Nygaard Classification of Actions or Inheritance also for Methods Proc. </title> <booktitle> ECOOP'87, European Conference on Object-Oriented Programming (ed. P. ), Paris, Springer Lecture Notes in Computer Science Vol. </booktitle> ,? <year> 1987. </year>
Reference-contexts: It is an advantage if the reader has some previous knowledge about BETA. Especially familiarity with the inner construct is important. This may be obtained through some of the references <ref> [11, 12, 13, 15, 16, 17, 5] </ref>. It is also an advantage if the reader has some knowledge about coroutine sequencing in Simula and BETA. This can be obtained from [4, 6, 14].
Reference: [13] <author> B.B. Kristensen, O.L. Madsen, B. Moller-Pedersen, K. </author> <title> NygaardThe BETA Programming Language In: B.D. </title> <editor> Shriver, P.Wegner (ed.), </editor> <booktitle> Research Directions in Object Oriented Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1987 </year>
Reference-contexts: It is an advantage if the reader has some previous knowledge about BETA. Especially familiarity with the inner construct is important. This may be obtained through some of the references <ref> [11, 12, 13, 15, 16, 17, 5] </ref>. It is also an advantage if the reader has some knowledge about coroutine sequencing in Simula and BETA. This can be obtained from [4, 6, 14]. <p> Entry will take care of manipulation of the mutex semaphore. The pattern init must be called to initialize the semaphore. Init is a virtual pattern that may be specialized in subpatterns of CriticalRegion. Virtuals patterns in BETA are e.g. described in <ref> [13, 16] </ref>. The Account pattern may now be defined as in figure 5. The class pattern Account will inherit the semaphore mutex and the abstract patterns entry and init from CriticalRegion. The operations Deposit, and Withdraw are defined as subpatterns of entry.
Reference: [14] <author> B.B. Kristensen, O.L. Madsen, B. Moller-Pedersen, K. </author> <booktitle> NygaardCoroutine Sequencing in BETA Hawaii International Conference on System Sciences - 21, </booktitle> <month> January 5-8, </month> <year> 1988 </year>
Reference-contexts: Especially familiarity with the inner construct is important. This may be obtained through some of the references [11, 12, 13, 15, 16, 17, 5]. It is also an advantage if the reader has some knowledge about coroutine sequencing in Simula and BETA. This can be obtained from <ref> [4, 6, 14] </ref>. The BETA program in figure 1 shows the basic elements of BETA including passive and active objects and the execution of active objects as coroutines. The program defines a number of patterns: Account, Deposit, Withdraw and Person.
Reference: [15] <author> O.L. Madsen, B. Moller-Pedersen: </author> <title> What Object-Oriented Programming may be, and what it does not have to be, </title> <booktitle> Proc. ECOOP'88, European Conference on Object Oriented Programming (eds. </booktitle> <editor> S. Gjessing, K Nygaard), </editor> <address> Oslo, </address> <month> August </month> <year> 1988 </year>
Reference-contexts: It is an advantage if the reader has some previous knowledge about BETA. Especially familiarity with the inner construct is important. This may be obtained through some of the references <ref> [11, 12, 13, 15, 16, 17, 5] </ref>. It is also an advantage if the reader has some knowledge about coroutine sequencing in Simula and BETA. This can be obtained from [4, 6, 14].
Reference: [16] <author> O.L. Madsen, B. Moller-Pedersen: </author> <title> Virtual Classes | A Powerful Mechanism in Object-Oriented Programming, </title> <booktitle> OOPSLA'89, Object-Oriented Programming, Systems, Languages, and Systems, </booktitle> ... 
Reference-contexts: It is an advantage if the reader has some previous knowledge about BETA. Especially familiarity with the inner construct is important. This may be obtained through some of the references <ref> [11, 12, 13, 15, 16, 17, 5] </ref>. It is also an advantage if the reader has some knowledge about coroutine sequencing in Simula and BETA. This can be obtained from [4, 6, 14]. <p> Entry will take care of manipulation of the mutex semaphore. The pattern init must be called to initialize the semaphore. Init is a virtual pattern that may be specialized in subpatterns of CriticalRegion. Virtuals patterns in BETA are e.g. described in <ref> [13, 16] </ref>. The Account pattern may now be defined as in figure 5. The class pattern Account will inherit the semaphore mutex and the abstract patterns entry and init from CriticalRegion. The operations Deposit, and Withdraw are defined as subpatterns of entry.
Reference: [17] <author> O.L Madsen, B. Moller-Pedersen: </author> <title> Part Objects and their Location Technology of Object-Oriented Languages and Systems, </title> <booktitle> TOOLS 7, </booktitle> <address> Dortmund, </address> <publisher> Prentice Hall 1992 </publisher>
Reference-contexts: It is an advantage if the reader has some previous knowledge about BETA. Especially familiarity with the inner construct is important. This may be obtained through some of the references <ref> [11, 12, 13, 15, 16, 17, 5] </ref>. It is also an advantage if the reader has some knowledge about coroutine sequencing in Simula and BETA. This can be obtained from [4, 6, 14]. <p> The concept of a port for encapsulating the semaphores is introduced. port is an example of a nested pattern. In addition, the patterns entry and accept are nested within port. Nested patterns are used quite heavily in BETA, see e.g. <ref> [18, 17] </ref>. The active object R may be defined using the task abstraction as shown in figure 10.
Reference: [18] <author> O.L. </author> <title> Madsen Block Structure and Object Oriented Languages In: B.D. </title> <editor> Shriver, P. Wegner (ed.): </editor> <booktitle> Research Directions in Object Oriented Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1987 </year> <month> 20 </month>
Reference-contexts: The concept of a port for encapsulating the semaphores is introduced. port is an example of a nested pattern. In addition, the patterns entry and accept are nested within port. Nested patterns are used quite heavily in BETA, see e.g. <ref> [18, 17] </ref>. The active object R may be defined using the task abstraction as shown in figure 10.
Reference: [19] <author> J.E.B. Moss, </author> <title> W.H. Kohler: Concurrency Features for the Trellis/Owl Lan--guage, </title> <booktitle> Proc. ECOOP'87, European Conference on Object-Oriented Programming (ed. </booktitle> <editor> P. Cointe), </editor> <booktitle> Paris, Springer Lecture Notes in Computer Science Vol. </booktitle> ??, <year> 1987. </year>
Reference-contexts: 1 Introduction Many models for concurrent object-oriented programming have been proposed. These models include monitors, CSP/Ada-like type of rendezvous, objects with more than one internal thread, objects with a communication manager controlling the execution of its operations [20], and many more <ref> [1, 2, 3, 7, 19, 21, 22, 23, 25, 26] </ref>. When concurrency is combined with inheritance there is also a large number of proposals for mechanisms for inheriting the protocol or synchronization constraints defined in the superclass [10, 8].
Reference: [20] <author> C. Neusius: </author> <title> Synchronizing Actions, </title> <booktitle> In Proceedings ECOOP'91, European Conference on Object-Oriented Programming (ed. P. America), Geneva, Springer Lecture Notes in Computer Science Vol. </booktitle> <volume> 512, </volume> <year> 1991. </year>
Reference-contexts: 1 Introduction Many models for concurrent object-oriented programming have been proposed. These models include monitors, CSP/Ada-like type of rendezvous, objects with more than one internal thread, objects with a communication manager controlling the execution of its operations <ref> [20] </ref>, and many more [1, 2, 3, 7, 19, 21, 22, 23, 25, 26]. When concurrency is combined with inheritance there is also a large number of proposals for mechanisms for inheriting the protocol or synchronization constraints defined in the superclass [10, 8].
Reference: [21] <author> O. Nierstrasz: </author> <title> Active Objects in Hybrid, </title> <journal> Proc. OOPSLA'87, SIGPLAN Notices, </journal> <volume> vol. 22, no. 12, </volume> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Many models for concurrent object-oriented programming have been proposed. These models include monitors, CSP/Ada-like type of rendezvous, objects with more than one internal thread, objects with a communication manager controlling the execution of its operations [20], and many more <ref> [1, 2, 3, 7, 19, 21, 22, 23, 25, 26] </ref>. When concurrency is combined with inheritance there is also a large number of proposals for mechanisms for inheriting the protocol or synchronization constraints defined in the superclass [10, 8].
Reference: [22] <author> M. Papathomas: </author> <title> Language Design Rational and Semantic Framework for Concurrent Object-Oriented Programming, </title> <institution> University of Geneve, </institution> <type> Ph.D. Thesis, </type> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Many models for concurrent object-oriented programming have been proposed. These models include monitors, CSP/Ada-like type of rendezvous, objects with more than one internal thread, objects with a communication manager controlling the execution of its operations [20], and many more <ref> [1, 2, 3, 7, 19, 21, 22, 23, 25, 26] </ref>. When concurrency is combined with inheritance there is also a large number of proposals for mechanisms for inheriting the protocol or synchronization constraints defined in the superclass [10, 8].
Reference: [23] <author> J. Van Den Bos, C. Laffra: </author> <title> PROCOL: A Parallel Object Language with Protocols, </title> <journal> Proc. OOPSLA'89, SIGPLAN Notices, </journal> <volume> vol. 24, no. 10, </volume> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Many models for concurrent object-oriented programming have been proposed. These models include monitors, CSP/Ada-like type of rendezvous, objects with more than one internal thread, objects with a communication manager controlling the execution of its operations [20], and many more <ref> [1, 2, 3, 7, 19, 21, 22, 23, 25, 26] </ref>. When concurrency is combined with inheritance there is also a large number of proposals for mechanisms for inheriting the protocol or synchronization constraints defined in the superclass [10, 8].
Reference: [24] <author> J. Vaucher: </author> <title> Prefixed Procedures: A Structuring Concept for Operations, </title> <journal> IN-FOR, </journal> <volume> Vol. 13, No. 3, </volume> <month> October </month> <year> 1975. </year>
Reference-contexts: The basic idea is to make use of "prefixed procedures" as found in BETA and which has also been proposed by Jean Vaucher in <ref> [24] </ref>. He has also shown how the concept of "prefixed procedure" may be used to define abstract super classes for Hoare's monitors. In this paper we extend these ideas and show how more elaborate communication models can be abstracted. In addition examples of inheritance of synchronization constraints will be given. <p> A monitor abstraction is similar to the simple CriticalRegion defined in the previous section. The main difference is that a process executing a monitor procedure may temporarily wait on a condition variable. The pattern in figure 6 (adapted from <ref> [24] </ref>) describes a traditional monitor. The monitor pattern may be used to define a buffer as shown in figure 7. Note that a process executing a signal is delayed if there are processes waiting on the corresponding Condition. <p> The basic BETA library provides abstractions for the most common type of concurrency problems. 18 The inner mechanism of Simula and BETA is central for the technique used defining the concurrency abstractions in this paper. In addition the possibility to define subprocedures (called "prefixed procedures" in <ref> [24] </ref>). Neither inner, subprocedures or nested patterns (classes) 1 are available in main stream object-oriented languages. We think that the examples in this paper has demonstrated the usefulness of these mechanisms. Finally concurrency must of course be supported by the object-oriented language in order to support concurrent object.oriented programming.
Reference: [25] <author> Y. Yokote, M. Tokoro: </author> <title> Concurrent Programming in ConcurrentSmalltalk, In Object-Oriented Concurrent Programming (ed. </title> <editor> M. Tokoro), </editor> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1987. </year>
Reference-contexts: 1 Introduction Many models for concurrent object-oriented programming have been proposed. These models include monitors, CSP/Ada-like type of rendezvous, objects with more than one internal thread, objects with a communication manager controlling the execution of its operations [20], and many more <ref> [1, 2, 3, 7, 19, 21, 22, 23, 25, 26] </ref>. When concurrency is combined with inheritance there is also a large number of proposals for mechanisms for inheriting the protocol or synchronization constraints defined in the superclass [10, 8].
Reference: [26] <author> A. Yonezawa, E. Shibayama, T. Takada, Y. Honda: </author> <title> Modelling and Programming in an Object-Oriented Concurrent Language ABC/1, In Object-Oriented Concurrent Programming (ed. </title> <editor> M. Tokoro), </editor> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1987. </year>
Reference-contexts: 1 Introduction Many models for concurrent object-oriented programming have been proposed. These models include monitors, CSP/Ada-like type of rendezvous, objects with more than one internal thread, objects with a communication manager controlling the execution of its operations [20], and many more <ref> [1, 2, 3, 7, 19, 21, 22, 23, 25, 26] </ref>. When concurrency is combined with inheritance there is also a large number of proposals for mechanisms for inheriting the protocol or synchronization constraints defined in the superclass [10, 8].
References-found: 26

