URL: ftp://ftp.cs.unc.edu/pub/users/manocha/PAPERS/COLLISION/wafr.ps.gz
Refering-URL: http://www.cs.unc.edu/~lin/papers.html
Root-URL: http://www.cs.unc.edu
Title: Collision Detection: Algorithms and Applications  
Author: Ming C. Lin, Dinesh Manocha, Jon Cohen, 
Web: http://www.cs.unc.edu/~geom/collide.html  
Address: Chapel Hill, NC, USA  Chapel Hill, NC, USA  Chapel Hill, NC, USA  Chapel Hill, NC, USA  
Affiliation: University of North Carolina,  University of North Carolina,  University of North Carolina,  Stefan Gottschalk, University of North Carolina,  
Note: U.S. Army Research Office and  
Abstract: Fast and accurate collision detection between general geometric models is a fundamental problem in modeling, robotics, manufacturing and computer-simulated environments. Most of the earlier algorithm are either restricted to a class of geometric models, say convex polytopes, or are not fast enough for practical applications. We present an efficient and accurate algorithm for collision detection between general polygonal models in dynamic environments. The algorithm makes use of hierarchical representations along with frame to frame coherence to rapidly detect collisions. It is robust and has been implemented as part of public domain packages. In practice, it can accurately detect all the contacts between large complex geometries composed of hundreds of thousands of polygons at interactive rates. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.Garica-Alonso, N.Serrano, and J.Flaquer. </author> <title> Solving the collision detection problem. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 13(3) </volume> <pages> 36-43, </pages> <year> 1994. </year>
Reference-contexts: Other spatial representations are based on BSP's [27] and its extensions to multi-space partitions [32], spatial representations based on space-time bounds or four-dimensional testing <ref> [1, 6, 9, 20] </ref> and many more. All of these hierarchical methods do very well in performing "rejection tests", whenever two objects are far apart.
Reference: [2] <author> J. Arvo and D. Kirk. </author> <title> A survey of ray tracing acceleration techniques. In An Introduction to Ray Tracing, </title> <address> pages 201-262, </address> <year> 1989. </year>
Reference-contexts: An OBB is a rectangular bounding box at an arbitrary orientation in 3-space. The resulting hierarchical structure is referred to as an OBBTree. The idea of using OBBs is not new and many researchers have used them extensively to speed up ray tracing and interference detection computations <ref> [2] </ref>. In this paper, we briefly describe the algorithms for computing tight-fitting OBBs and checking them for overlap. More details are given in [18]. leftmark 4.2.1 Building an OBBTree In this section we describe algorithms for building an OBBTree.
Reference: [3] <author> D. Baraff. </author> <title> Dynamic simulation of non-penetrating rigid body simulation. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1992. </year>
Reference-contexts: Moreover, the objects move only slightly from frame to frame and the collision detection scheme should take advantage of the information from the previous frame to initialize the computation for the current frame <ref> [3, 23] </ref>. Several solutions based on this idea of coherence have been proposed in [22]. Approaches that combine collision response with detection can be found in [3, 33, 25]. The methods in [32, 33] make use of the boundary representation to detect collisions. <p> Several solutions based on this idea of coherence have been proposed in [22]. Approaches that combine collision response with detection can be found in <ref> [3, 33, 25] </ref>. The methods in [32, 33] make use of the boundary representation to detect collisions. Collision detection for multiple moving objects has recently become a popular research topic with the increased interest in large-scaled virtual prototyping environments. <p> For a configuration of N objects, the worst case running time for any collision detection algorithm is O (N 2 ) where N is the number of objects. However, evidence suggests that these cases rarely occur in simulations <ref> [3, 12, 22, 28] </ref>. So our algorithm uses a Sweep and Prune technique to eliminate testing object pairs that are far apart, and later we show that the technique can be extended to eliminate testing features that are far apart between two colliding objects. <p> In environments where the objects make relatively small movements between frames, the lists will be nearly sorted, so we can re-sort using insertion sort in expected O (N ) time <ref> [26, 3] </ref>. Graphs 1 - 6 are timings taken from a multi-object simulation where we compare the performance of using fixed versus dynamic sized boxes [12].
Reference: [4] <author> B. Barber, D. Dobkin, and H. Huhdanpaa. </author> <title> The quickhull algorithm for convex hull. </title> <type> Technical Report GCG53, </type> <institution> The Geometry Center, MN, </institution> <year> 1993. </year>
Reference-contexts: We improve the algorithm by using the convex hull of the vertices of the triangles. The convex hull is the smallest convex set containing all the points and efficient algorithms of O (n lg n) complexity and their robust implementations are available as public domain packages <ref> [4] </ref>. This is an improvement, but still suffers from a similar sampling problem: a small but very dense collection of nearly collinear vertices on the convex hull can cause the bounding box to align with that collection.
Reference: [5] <author> N. Beckmann, H. Kriegel, R. Schneider, and B. Seeger. </author> <title> The r*-tree: An efficient and robust access method for points and rectangles. Proc. leftmark Pivot has 44921 triangles; Average time to perform collision query: </title> <booktitle> 100 msec on SGI Reality Engine with 200MHz R4400 CPU SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 322-331, </pages> <year> 1990. </year>
Reference-contexts: Hierarchical structures used for collision detection include cone trees, k-d trees and octrees [31], sphere trees [20, 30], R-trees and their variants <ref> [5] </ref>, trees based on S-bounds [7] etc. Other spatial representations are based on BSP's [27] and its extensions to multi-space partitions [32], spatial representations based on space-time bounds or four-dimensional testing [1, 6, 9, 20] and many more.
Reference: [6] <author> S. Cameron. </author> <title> Collision detection by four-dimensional intersection testing. </title> <booktitle> Proceedings of International Conference on Robotics and Automation, </booktitle> <pages> pages 291-302, </pages> <year> 1990. </year>
Reference-contexts: Other spatial representations are based on BSP's [27] and its extensions to multi-space partitions [32], spatial representations based on space-time bounds or four-dimensional testing <ref> [1, 6, 9, 20] </ref> and many more. All of these hierarchical methods do very well in performing "rejection tests", whenever two objects are far apart.
Reference: [7] <author> S. Cameron. </author> <title> Approximation hierarchies and s-bounds. </title> <booktitle> In Proceedings. Symposium on Solid Modeling Foundations and CAD/CAM Applications, </booktitle> <pages> pages 129-137, </pages> <address> Austin, TX, </address> <year> 1991. </year>
Reference-contexts: To achieve interactive rates, the total number of pairwise intersection tests must be reduced before performing exact collision tests on the object pairs, which are in the close vicinity of each other. Several methods dealing with this situation are found in <ref> [7, 12, 16] </ref>. Most methods use some type of a hierarchical bounding box scheme. Objects are surrounded by bounding boxes. If the bounding boxes overlap, indicating the objects are near each other, a more precise collision test is applied. <p> Hierarchical structures used for collision detection include cone trees, k-d trees and octrees [31], sphere trees [20, 30], R-trees and their variants [5], trees based on S-bounds <ref> [7] </ref> etc. Other spatial representations are based on BSP's [27] and its extensions to multi-space partitions [32], spatial representations based on space-time bounds or four-dimensional testing [1, 6, 9, 20] and many more.
Reference: [8] <author> S. Cameron and R. K. Culley. </author> <title> Determining the minimum translational distance between two convex polyhedra. </title> <booktitle> Proceedings of International Conference on Robotics and Automation, </booktitle> <pages> pages 591-596, </pages> <year> 1986. </year>
Reference-contexts: Robotics literature deals with collision detection in the context of path planning. Using sophisticated mathematical tools, several algorithms have been developed that plan collision-free paths for a robot in restricted environments <ref> [8, 9] </ref>. However, in path planners based on potential field methods, collision detection and distance computation are still considered as major bottlenecks [21, 10]. Most computational geometry literature deals with collision detection of objects in a static environment.
Reference: [9] <author> J. F. Canny. </author> <title> Collision detection for moving polyhedra. </title> <journal> IEEE Trans. PAMI, </journal> <volume> 8 </volume> <pages> 200-209, </pages> <year> 1986. </year>
Reference-contexts: Robotics literature deals with collision detection in the context of path planning. Using sophisticated mathematical tools, several algorithms have been developed that plan collision-free paths for a robot in restricted environments <ref> [8, 9] </ref>. However, in path planners based on potential field methods, collision detection and distance computation are still considered as major bottlenecks [21, 10]. Most computational geometry literature deals with collision detection of objects in a static environment. <p> Other spatial representations are based on BSP's [27] and its extensions to multi-space partitions [32], spatial representations based on space-time bounds or four-dimensional testing <ref> [1, 6, 9, 20] </ref> and many more. All of these hierarchical methods do very well in performing "rejection tests", whenever two objects are far apart.
Reference: [10] <author> H. Chang and T. Li. </author> <title> Assembly maintainability study with motion planning. </title> <booktitle> In Proceedings of International Conference on Robotics and Automation, </booktitle> <year> 1995. </year>
Reference-contexts: Using sophisticated mathematical tools, several algorithms have been developed that plan collision-free paths for a robot in restricted environments [8, 9]. However, in path planners based on potential field methods, collision detection and distance computation are still considered as major bottlenecks <ref> [21, 10] </ref>. Most computational geometry literature deals with collision detection of objects in a static environment. Objects are at a fixed location and orientation, and the algorithms determine whether they are intersecting [11, 13].
Reference: [11] <author> B. Chazelle and D. P. Dobkin. </author> <title> Intersection of convex objects in two and three dimensions. </title> <journal> J. ACM, </journal> <volume> 34 </volume> <pages> 1-27, </pages> <year> 1987. </year>
Reference-contexts: Most computational geometry literature deals with collision detection of objects in a static environment. Objects are at a fixed location and orientation, and the algorithms determine whether they are intersecting <ref> [11, 13] </ref>. In most modeling and graphics applications, where many objects are in motion, such an approach would be inefficient.
Reference: [12] <author> J. Cohen, M. Lin, D. Manocha, and M. Ponamgi. I-collide: </author> <title> An interactive and exact collision detection system for large-scale environments. </title> <booktitle> In Proc. of ACM Interactive 3D Graphics Conference, </booktitle> <pages> pages 189-196, </pages> <year> 1995. </year>
Reference-contexts: Given the geometric models, the algorithm pre-computes the convex hull and a hierarchical representation of each model in terms of oriented bounding boxes. At runtime, it uses tight fitting axis-aligned bounding boxes to pair down the number of object pair interactions to only those pairs within close proximity <ref> [12] </ref>. For each pair of objects whose bounding boxes overlap, the algorithm checks whether their convex hulls are intersecting based on the closest feature pairs [22]. Finally for each object pair whose convex hulls overlap, it makes use of oriented bounding box hierarchy (OBBTree) to check for actual contact [18]. <p> To achieve interactive rates, the total number of pairwise intersection tests must be reduced before performing exact collision tests on the object pairs, which are in the close vicinity of each other. Several methods dealing with this situation are found in <ref> [7, 12, 16] </ref>. Most methods use some type of a hierarchical bounding box scheme. Objects are surrounded by bounding boxes. If the bounding boxes overlap, indicating the objects are near each other, a more precise collision test is applied. <p> For a configuration of N objects, the worst case running time for any collision detection algorithm is O (N 2 ) where N is the number of objects. However, evidence suggests that these cases rarely occur in simulations <ref> [3, 12, 22, 28] </ref>. So our algorithm uses a Sweep and Prune technique to eliminate testing object pairs that are far apart, and later we show that the technique can be extended to eliminate testing features that are far apart between two colliding objects. <p> It would be pointless and expensive to keep track of all possible interactions between objects at each time step. Sorting the bounding boxes surrounding the objects is the key to our Sweep and Prune approach <ref> [12] </ref>. It is not intuitively obvious how to sort bounding boxes in 3-space to determine overlaps. We use a dimension reduction approach. If two bounding boxes collide in 3-D, then their orthogonal projections on the x, y, and z axes must overlap. <p> Graphs 1 - 6 are timings taken from a multi-object simulation where we compare the performance of using fixed versus dynamic sized boxes <ref> [12] </ref>. Parameters such as the number of objects, the polygonal complexity of the objects, the velocity of the objects, etc. were varied as the graphs show. 4 Exact Collision Detection Given two objects in close proximity, the algorithm initially checks whether their convex hulls are overlapping. <p> RAPID interference detection package available at http://www.cs.unc.edu/~geom/OBB/OBBT.html. It contains routines for building the OBBTree data structure and fast overlap tests between two OBB-Trees. It has been used for virtual prototyping and simulation-based design applications. More details on their performance and robustness issues are given in <ref> [12, 18] </ref>. In practice, the algorithms based on OBBs asymptotically perform much better than hierarchies based on sphere trees or axis-aligned bounding boxes (like Oc-trees).
Reference: [13] <author> D. P. Dobkin and D. G. Kirkpatrick. </author> <title> A linear algorithm for determining the separation of convex pol yhedra. </title> <journal> J. Algorithms, </journal> <volume> 6 </volume> <pages> 381-392, </pages> <year> 1985. </year>
Reference-contexts: Most computational geometry literature deals with collision detection of objects in a static environment. Objects are at a fixed location and orientation, and the algorithms determine whether they are intersecting <ref> [11, 13] </ref>. In most modeling and graphics applications, where many objects are in motion, such an approach would be inefficient.
Reference: [14] <author> R.O. Duda and P.E. Hart. </author> <title> Pattern Classification and Scene Analysis. </title> <publisher> John Wiley and Sons, </publisher> <year> 1973. </year>
Reference-contexts: We triangulate all polygons composed of more than three edges. The OBB computation algorithm makes use of first and second order statistics summarizing the vertex coordinates. They are the mean, , and the covariance matrix, C, respectively <ref> [14] </ref>.
Reference: [15] <author> Tom Duff. </author> <title> Interval arithmetic and recursive subdivision for implicit functions and constructive solid geometry. </title> <journal> ACM Computer Graphics, </journal> <volume> 26(2) </volume> <pages> 131-139, </pages> <year> 1992. </year> <title> Collision Detection: Algorithms & Applications perform collision query: 4.2 msec on SGI Reality Engine with 90MHz R8000 CPU </title>
Reference-contexts: Objects are surrounded by bounding boxes. If the bounding boxes overlap, indicating the objects are near each other, a more precise collision test is applied. As for curved models, algorithms based on interval arithmetic for collision detection are described in <ref> [15, 17] </ref>. These algorithms expect the motion of the objects to be expressed as a closed form function of time. Moreover, the performance of interval arithmetic based algorithms is too slow for interactive applications. Coherence based algorithms for curved models are presented in [24].
Reference: [16] <author> P. Dworkin and D. Zeltzer. </author> <title> A new model for efficient dynamics simulation. </title> <booktitle> Proceedings Euro-graphics workshop on animation and simulation, </booktitle> <pages> pages 175-184, </pages> <year> 1993. </year>
Reference-contexts: To achieve interactive rates, the total number of pairwise intersection tests must be reduced before performing exact collision tests on the object pairs, which are in the close vicinity of each other. Several methods dealing with this situation are found in <ref> [7, 12, 16] </ref>. Most methods use some type of a hierarchical bounding box scheme. Objects are surrounded by bounding boxes. If the bounding boxes overlap, indicating the objects are near each other, a more precise collision test is applied.
Reference: [17] <author> J. Snyder et. al. </author> <title> Interval methods for multi-point collisions between time dependent curved surfaces. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 321-334, </pages> <year> 1993. </year>
Reference-contexts: Objects are surrounded by bounding boxes. If the bounding boxes overlap, indicating the objects are near each other, a more precise collision test is applied. As for curved models, algorithms based on interval arithmetic for collision detection are described in <ref> [15, 17] </ref>. These algorithms expect the motion of the objects to be expressed as a closed form function of time. Moreover, the performance of interval arithmetic based algorithms is too slow for interactive applications. Coherence based algorithms for curved models are presented in [24].
Reference: [18] <author> S. Gottschalk, M. Lin, and D. Manocha. Obb-tree: </author> <title> A hierarchical structure for rapid interference detection. </title> <note> To Appear in Proc. of ACM Siggraph'96, </note> <year> 1996. </year>
Reference-contexts: For each pair of objects whose bounding boxes overlap, the algorithm checks whether their convex hulls are intersecting based on the closest feature pairs [22]. Finally for each object pair whose convex hulls overlap, it makes use of oriented bounding box hierarchy (OBBTree) to check for actual contact <ref> [18] </ref>. Organization: The rest of the paper is organized as follows: Section 2 reviews some of the previous work in collision detection. Section 3 outlines the algorithm for pruning the number of object pairs. We briefly describe the closest feature and contact determination algorithms in Section 4. <p> The idea of using OBBs is not new and many researchers have used them extensively to speed up ray tracing and interference detection computations [2]. In this paper, we briefly describe the algorithms for computing tight-fitting OBBs and checking them for overlap. More details are given in <ref> [18] </ref>. leftmark 4.2.1 Building an OBBTree In this section we describe algorithms for building an OBBTree. The tree construction has two components: first is the placement of a tight fitting OBB around a collection of polygons, and second is the grouping of nested OBB's into a tree hierarchy. <p> If the intervals do overlap, then the boxes may or may not be disjoint further tests may be required. We make use of the separating axis theorem presented in <ref> [18] </ref> to check for overlaps. According to it, two convex polytopes in 3-D are disjoint iff there exists a separating axis orthogonal to a face of either polytope or orthogonal to an edge from each polytope. Each box has 3 unique face orientations, and 3 unique edge directions. <p> This is shown in 2D in Fig. 5. In practice, this corresponds to at most 200 arithmetic operations in the worst case <ref> [18] </ref>. Due to early exit (when the boxes are not overlapping), the algorithm takes about half the operations in practice. <p> RAPID interference detection package available at http://www.cs.unc.edu/~geom/OBB/OBBT.html. It contains routines for building the OBBTree data structure and fast overlap tests between two OBB-Trees. It has been used for virtual prototyping and simulation-based design applications. More details on their performance and robustness issues are given in <ref> [12, 18] </ref>. In practice, the algorithms based on OBBs asymptotically perform much better than hierarchies based on sphere trees or axis-aligned bounding boxes (like Oc-trees).
Reference: [19] <author> J. K. Hahn. </author> <title> Realistic animation of rigid bodies. </title> <journal> Computer Graphics, </journal> <volume> 22(4):pp. </volume> <pages> 299-308, </pages> <year> 1988. </year>
Reference-contexts: In such cases, their performance slows down considerably and they become a major bottleneck in the simulation, as stated in <ref> [19] </ref>. Collision Detection: Algorithms & Applications 3 Collision Detection between Multiple Moving Objects We review our previous algorithm for multiple moving convex polytopes in complex environments. Coherence combined with incremental computation is a major theme of our algorithms.
Reference: [20] <author> P. M. Hubbard. </author> <title> Interactive collision detection. </title> <booktitle> In Proceedings of IEEE Symposium on Research Frontiers in Virtual Reality, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: Typical examples of bounding volumes include axis-aligned boxes (of which cubes are a special case) and spheres, and they are chosen for to the simplicity of finding collision between two such volumes. Hierarchical structures used for collision detection include cone trees, k-d trees and octrees [31], sphere trees <ref> [20, 30] </ref>, R-trees and their variants [5], trees based on S-bounds [7] etc. Other spatial representations are based on BSP's [27] and its extensions to multi-space partitions [32], spatial representations based on space-time bounds or four-dimensional testing [1, 6, 9, 20] and many more. <p> Other spatial representations are based on BSP's [27] and its extensions to multi-space partitions [32], spatial representations based on space-time bounds or four-dimensional testing <ref> [1, 6, 9, 20] </ref> and many more. All of these hierarchical methods do very well in performing "rejection tests", whenever two objects are far apart.
Reference: [21] <author> J.C. Latombe. </author> <title> Robot Motion Planning. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Using sophisticated mathematical tools, several algorithms have been developed that plan collision-free paths for a robot in restricted environments [8, 9]. However, in path planners based on potential field methods, collision detection and distance computation are still considered as major bottlenecks <ref> [21, 10] </ref>. Most computational geometry literature deals with collision detection of objects in a static environment. Objects are at a fixed location and orientation, and the algorithms determine whether they are intersecting [11, 13].
Reference: [22] <author> M.C. Lin. </author> <title> Efficient Collision Detection for Animation and Robotics. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, University of California, Berkeley, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: For each pair of objects whose bounding boxes overlap, the algorithm checks whether their convex hulls are intersecting based on the closest feature pairs <ref> [22] </ref>. Finally for each object pair whose convex hulls overlap, it makes use of oriented bounding box hierarchy (OBBTree) to check for actual contact [18]. Organization: The rest of the paper is organized as follows: Section 2 reviews some of the previous work in collision detection. <p> Moreover, the objects move only slightly from frame to frame and the collision detection scheme should take advantage of the information from the previous frame to initialize the computation for the current frame [3, 23]. Several solutions based on this idea of coherence have been proposed in <ref> [22] </ref>. Approaches that combine collision response with detection can be found in [3, 33, 25]. The methods in [32, 33] make use of the boundary representation to detect collisions. <p> For a configuration of N objects, the worst case running time for any collision detection algorithm is O (N 2 ) where N is the number of objects. However, evidence suggests that these cases rarely occur in simulations <ref> [3, 12, 22, 28] </ref>. So our algorithm uses a Sweep and Prune technique to eliminate testing object pairs that are far apart, and later we show that the technique can be extended to eliminate testing features that are far apart between two colliding objects. <p> Furthermore, it classifies the feature of convex hulls into red and green features. The red features correspond to the features of the original model and the green features are introduced by the convex hull computation. We use the algorithm described in <ref> [22] </ref> to keep track of closest features for a pair of convex polytopes. The algorithm maintains a pair of closest features for each convex polytope pair and calculates the Euclidean distance between the features to detect collisions. <p> If a point lies on a constraint plane, then it is equi-distant from the two features which share this constraint plane in their Voronoi regions. For more details on this construction and its properties, please refer to <ref> [22] </ref>. 4.1.2 Closest Feature Tests Our method for finding closest feature pairs is based on Voronoi regions. We start with a candidate pair of features, one from each polytope, and check whether the closest points lie on these features.
Reference: [23] <author> M.C. Lin and John F. Canny. </author> <title> Efficient algorithms for incremental distance computation. </title> <booktitle> In IEEE Conference on Robotics and Automation, </booktitle> <pages> pages 1008-1014, </pages> <year> 1991. </year>
Reference-contexts: Moreover, the objects move only slightly from frame to frame and the collision detection scheme should take advantage of the information from the previous frame to initialize the computation for the current frame <ref> [3, 23] </ref>. Several solutions based on this idea of coherence have been proposed in [22]. Approaches that combine collision response with detection can be found in [3, 33, 25]. The methods in [32, 33] make use of the boundary representation to detect collisions.
Reference: [24] <author> M.C. Lin and Dinesh Manocha. </author> <title> Efficient contact determination between geometric models. </title> <journal> International Journal of Computational Geometry and Applications, </journal> <note> 1996. To appear. </note>
Reference-contexts: These algorithms expect the motion of the objects to be expressed as a closed form function of time. Moreover, the performance of interval arithmetic based algorithms is too slow for interactive applications. Coherence based algorithms for curved models are presented in <ref> [24] </ref>. In many CAD applications, the input models are given as collections of polygons with no topology information. Such models are also known as `polygon soups' and their boundaries may have cracks, T-joints, or may have non-manifold geometry. In general, no robust techniques are known for cleaning such models.
Reference: [25] <author> M. Moore and J. Wilhelms. </author> <title> Collision detection and response for computer animation. </title> <journal> Computer Graphics, </journal> <volume> 22(4) </volume> <pages> 289-298, </pages> <year> 1988. </year> <month> leftmark </month>
Reference-contexts: Several solutions based on this idea of coherence have been proposed in [22]. Approaches that combine collision response with detection can be found in <ref> [3, 33, 25] </ref>. The methods in [32, 33] make use of the boundary representation to detect collisions. Collision detection for multiple moving objects has recently become a popular research topic with the increased interest in large-scaled virtual prototyping environments.
Reference: [26] <author> M.Shamos and D.Hoey. </author> <title> Geometric intersection problems. </title> <booktitle> Proc. 17th An. IEEE Symp. Found. on Comput. Science, </booktitle> <pages> pages 208-215, </pages> <year> 1976. </year>
Reference-contexts: In environments where the objects make relatively small movements between frames, the lists will be nearly sorted, so we can re-sort using insertion sort in expected O (N ) time <ref> [26, 3] </ref>. Graphs 1 - 6 are timings taken from a multi-object simulation where we compare the performance of using fixed versus dynamic sized boxes [12].
Reference: [27] <author> B. Naylor, J. Amanatides, and W. Thibault. </author> <title> Merging bsp trees yield polyhedral modeling results. </title> <booktitle> In Proc. of ACM Siggraph, </booktitle> <pages> pages 115-124, </pages> <year> 1990. </year>
Reference-contexts: Hierarchical structures used for collision detection include cone trees, k-d trees and octrees [31], sphere trees [20, 30], R-trees and their variants [5], trees based on S-bounds [7] etc. Other spatial representations are based on BSP's <ref> [27] </ref> and its extensions to multi-space partitions [32], spatial representations based on space-time bounds or four-dimensional testing [1, 6, 9, 20] and many more. All of these hierarchical methods do very well in performing "rejection tests", whenever two objects are far apart.
Reference: [28] <author> M. Ponamgi, D. Manocha, and M. Lin. </author> <title> Incremental algorithms for collision detection between general solid models. </title> <booktitle> In Proc. of ACM/Siggraph Symposium on Solid Modeling, </booktitle> <pages> pages 293-304, </pages> <year> 1995. </year>
Reference-contexts: For a configuration of N objects, the worst case running time for any collision detection algorithm is O (N 2 ) where N is the number of objects. However, evidence suggests that these cases rarely occur in simulations <ref> [3, 12, 22, 28] </ref>. So our algorithm uses a Sweep and Prune technique to eliminate testing object pairs that are far apart, and later we show that the technique can be extended to eliminate testing features that are far apart between two colliding objects. <p> A detailed discussion is presented in <ref> [28] </ref> 4.1.4 Feature Classification The algorithm highlighted above returns all pairs of overlapping features between the convex hulls.
Reference: [29] <author> F.P. Preparata and M. I. Shamos. </author> <title> Computational Geometry. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: Each feature is described by its geometric parameters and its neighboring features, i.e. the topological information of incidences and adjacencies. Definition: A Voronoi region associated with a feature is a set of points closer to that feature than any other <ref> [29] </ref>. The Voronoi regions form a partition of the space outside the polytope, and they form the generalized Voronoi diagram of the polytope. Note that the generalized Voronoi diagram of a convex polytope has linear number of features and consists of polyhedral regions. <p> For internal partitioning, internal Voronoi regions can be used. The internal Voronoi regions can be constructed for any convex polytope by computing all the equi-distant hyperplanes between two or more facets on the polytope. However the general construction of the internal Voronoi regions is a non-trivial computation <ref> [29] </ref>. To detect a penetration as opposed to knowing all the closest features it is unnecessary to construct the exact internal Voronoi regions. Rather we use an approximation, labeled as pseudo-internal Voronoi region.
Reference: [30] <author> S. Quinlan. </author> <title> Efficient distance computation between non-convex objects. </title> <booktitle> In Proceedings of International Conference on Robotics and Automation, </booktitle> <pages> pages 3324-3329, </pages> <year> 1994. </year>
Reference-contexts: Typical examples of bounding volumes include axis-aligned boxes (of which cubes are a special case) and spheres, and they are chosen for to the simplicity of finding collision between two such volumes. Hierarchical structures used for collision detection include cone trees, k-d trees and octrees [31], sphere trees <ref> [20, 30] </ref>, R-trees and their variants [5], trees based on S-bounds [7] etc. Other spatial representations are based on BSP's [27] and its extensions to multi-space partitions [32], spatial representations based on space-time bounds or four-dimensional testing [1, 6, 9, 20] and many more.
Reference: [31] <author> H. Samet. </author> <title> Spatial Data Structures: Quadtree, Oc-trees and Other Hierarchical Methods. </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Typical examples of bounding volumes include axis-aligned boxes (of which cubes are a special case) and spheres, and they are chosen for to the simplicity of finding collision between two such volumes. Hierarchical structures used for collision detection include cone trees, k-d trees and octrees <ref> [31] </ref>, sphere trees [20, 30], R-trees and their variants [5], trees based on S-bounds [7] etc. Other spatial representations are based on BSP's [27] and its extensions to multi-space partitions [32], spatial representations based on space-time bounds or four-dimensional testing [1, 6, 9, 20] and many more.
Reference: [32] <author> W.Bouma and G.Vanecek. </author> <title> Collision detection and analysis in a physically based simulation. </title> <booktitle> Proceedings Eurographics workshop on animation and simulation, </booktitle> <pages> pages 191-203, </pages> <year> 1991. </year>
Reference-contexts: Several solutions based on this idea of coherence have been proposed in [22]. Approaches that combine collision response with detection can be found in [3, 33, 25]. The methods in <ref> [32, 33] </ref> make use of the boundary representation to detect collisions. Collision detection for multiple moving objects has recently become a popular research topic with the increased interest in large-scaled virtual prototyping environments. <p> Hierarchical structures used for collision detection include cone trees, k-d trees and octrees [31], sphere trees [20, 30], R-trees and their variants [5], trees based on S-bounds [7] etc. Other spatial representations are based on BSP's [27] and its extensions to multi-space partitions <ref> [32] </ref>, spatial representations based on space-time bounds or four-dimensional testing [1, 6, 9, 20] and many more. All of these hierarchical methods do very well in performing "rejection tests", whenever two objects are far apart.
Reference: [33] <author> W.Bouma and G.Vanecek. </author> <title> Modeling contacts in a physically based simulation. </title> <booktitle> Second Symposium on Solid Modeling and Applications, </booktitle> <pages> pages 409-419, </pages> <year> 1993. </year> <title> Torus Torus has 20000 polygons; Environment has 98000 polygons; Average time to perform collision detection: 6.9 msec on SGI Reality Engine </title>
Reference-contexts: Several solutions based on this idea of coherence have been proposed in [22]. Approaches that combine collision response with detection can be found in <ref> [3, 33, 25] </ref>. The methods in [32, 33] make use of the boundary representation to detect collisions. Collision detection for multiple moving objects has recently become a popular research topic with the increased interest in large-scaled virtual prototyping environments. <p> Several solutions based on this idea of coherence have been proposed in [22]. Approaches that combine collision response with detection can be found in [3, 33, 25]. The methods in <ref> [32, 33] </ref> make use of the boundary representation to detect collisions. Collision detection for multiple moving objects has recently become a popular research topic with the increased interest in large-scaled virtual prototyping environments.
References-found: 33

