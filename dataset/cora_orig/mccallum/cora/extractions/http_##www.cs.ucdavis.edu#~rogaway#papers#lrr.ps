URL: http://www.cs.ucdavis.edu/~rogaway/papers/lrr.ps
Refering-URL: http://www.cs.ucdavis.edu/~rogaway/papers/
Root-URL: http://www.cs.ucdavis.edu
Title: Locally Random Reductions: Improvements and Applications  
Author: D. Beaver J. Feigenbaum J. Kilian P. Rogaway 
Date: September 1, 1995  
Abstract: A (t; n)-locally random reduction maps a problem instance x into a set of problem instances y 1 ; : : :; y n in such a way that it is easy to construct the answer to x from the answers to y 1 ; : : :; y n , and yet the distribution on t-element subsets of y 1 ; : : : ; y n depends only on jxj. In this paper we formalize such reductions and give improved methods for achieving them. Then we give a cryptographic application, showing a new way to prove in perfect zero knowledge that committed bits x 1 ; : : : ; x m satisfy some predicate Q. Unlike previous techniques for such perfect zero-knowledge proofs, ours uses an amount of communication that is bounded by a fixed polynomial in m, regardless of the computational complexity of Q.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, J. Feigenbaum, and J. Kilian. </author> <title> On Hiding Information from an Oracle, </title> <journal> J. Comput. System Sci. </journal> <volume> 39 (1989), </volume> <pages> 21-50. </pages>
Reference-contexts: Unfortunately, this approach is limited, because of the following result. Suppose that P 3 6= P and that f is NP-hard. Then there is no polynomial-time random reduction from f to any function g such that the distribution on random instances y depends only on jxj (cf. <ref> [1] </ref>). This result holds for a generalized notion of random reductions, known as single-oracle instance-hiding schemes. These schemes have a probabilistic polynomial-time bounded player P and an unbounded player O that always answers correctly. P wishes to compute f (x) for some function f and an input x. <p> Here, "revealing only jxj to O" means that if jx 1 j = jx 2 j, then O's views of the conversation when x = x 1 and when x = x 2 are identically distributed. A more precise and general formulation of this idea may be found in <ref> [1] </ref>. Rivest [17, 1] proposed the more general notion of multi-oracle instance-hiding schemes, in which P is allowed to interact with a number of oracles O 1 ; : : : ; O n . <p> A more precise and general formulation of this idea may be found in [1]. Rivest <ref> [17, 1] </ref> proposed the more general notion of multi-oracle instance-hiding schemes, in which P is allowed to interact with a number of oracles O 1 ; : : : ; O n . <p> The basic idea is to run several independent copies of the protocols. Instead of breaking each x i into a single pair, (x 0 i ; x 1 i ), P will break each x i into a sequence of independent pairs, (x 0 i <ref> [1] </ref>); : : :; (x 0 i [l]): Similarly, P reveals x i by revealing all l pairs that he previously committed. When P is honest, x 0 i [j] will have the same value, x i , for all values of j.
Reference: [2] <author> L. Babai, L. Fortnow, and C. Lund. </author> <title> Non-Deterministic Exponential Time has Two-Prover Interactive Proofs, </title> <booktitle> Computational Complexity 1 (1991), </booktitle> <pages> 3-40. </pages>
Reference-contexts: Since the results of 2 Beaver-Feigenbaum [3] and Lipton [15] appeared, a number of researchers have used random-self--reducibility properties of multivariate polynomials to show, among other things, that P #P IP (cf. [16]), IP = PSPACE (cf. [19]), and MIP = NEXPTIME (cf. <ref> [2] </ref>). <p> In this way, algebraic properties of polynomials can be directly exploited. Such arithmetization of Boolean functions is an important insight of Ben-Or, Goldwasser, and Wigderson [7]. The polynomial P is sometimes referred to as a "multilinear extension of f over F " (e.g., in <ref> [2, 16, 19] </ref>). Fix a function f : f0; 1g m ! f0; 1g and a finite field F .
Reference: [3] <author> D. Beaver and J. Feigenbaum. </author> <title> Hiding Instances in Multioracle Queries, </title> <booktitle> Proc. 7 th Annual Symposium On Theoretical Aspects Of Computer Science, Lecture Notes in Computer Science, </booktitle> <volume> vol. 415, </volume> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1990, </year> <pages> 37-48. </pages>
Reference-contexts: Whereas schemes with only one oracle appear relatively weak, Beaver and Feigenbaum proved the following theorem for multi-oracle schemes. Theorem: <ref> [3] </ref> For any function f , there exists an (jxj + 1)-oracle instance-hiding scheme that reveals at most jxj. <p> In fact, we will later show how to reduce this to jxj=c lg jxj. Lipton [15] translated the arguments of <ref> [3] </ref> into the language of multivariate polynomials and applied them to the area of program testing. This framework is much easier to work with than the original framework, which involved multi-party computations on shared secrets, and furthermore allows one to prove useful program-testing results for multivariate polynomials of low degree. <p> Since the results of 2 Beaver-Feigenbaum <ref> [3] </ref> and Lipton [15] appeared, a number of researchers have used random-self--reducibility properties of multivariate polynomials to show, among other things, that P #P IP (cf. [16]), IP = PSPACE (cf. [19]), and MIP = NEXPTIME (cf. [2]). <p> Theorem 1: For any function f : f0; 1g m ! f0; 1g and any constant c &gt; 0, there is a function g such that f is (t; tm=c lg m)-locally random reducible to g. This improves on the results of <ref> [3, 15] </ref> mentioned above. We apply locally random reductions in a novel protocol for zero-knowledge proofs on committed bits. <p> Otherwise, everything that we present is the same for all finite fields. 3 Improved locally random reductions We now show how to improve the results of Beaver-Feigenbaum <ref> [3] </ref> and Lipton [15]. We first exhibit a parameterized family of random-self-reductions for multivariate polynomials over sufficiently large finite fields. We then give, for any constant c &gt; 0 and any m-bit function f , a (t; tbm=c lg mc)-locally random reductions from f to some other function g. <p> Furthermore, there is a single pair of functions (scatter; reconstruct) that serves as a locally random self-reduction for any P satisfying the above conditions. Proof: Our proof proceeds along the lines of <ref> [3] </ref>, using the polynomial framework of [15]. First, we define scatter (X; r).
Reference: [4] <author> D. Beaver, J. Feigenbaum, J. Kilian, and P. Rogaway. </author> <title> Cryptographic Applications of Locally Random Reductions, </title> <institution> AT&T Bell Laboratories Technical Memorandum, </institution> <month> November 15, </month> <year> 1989. </year>
Reference-contexts: In Section 3, we give our improved construction of locally random reductions. In Section 4, we give our communication-efficient protocol for zero-knowledge proofs on committed bits. Open questions are given in Section 5. These results first appeared in our Technical Memorandum <ref> [4] </ref>. 2 Preliminaries 2.1 Locally random reductions We now formalize the intuition of Section 1.2. Definition 1 Let f : D ! f0; 1g fl , g : D 0 ! f0; 1g fl , and t; n : N ! N.
Reference: [5] <author> C. Bennett. </author> <title> Private communication via Gilles Brassard. </title>
Reference-contexts: A natural question to ask is whether one can actually perform zero-knowledge proofs on committed bits in this setting. This question has been answered in the affirmative by several researchers (e.g., <ref> [5, 18] </ref>); a written account of a more recent scheme appears in [6]. It is natural to ask whether an interactive proof system is at all interesting if it requires the verifier as well as the prover to have unlimited computational power. <p> It is not at all clear (and might even be counterintuitive) that an arbitrary predicate f can be proven in a communication-efficient manner, even if both prover and verifier have enough computational power to compute f . All previous schemes for zero-knowledge proofs on committed bits, including those of <ref> [5, 6, 18] </ref>, have bit complexity proportional to the circuit complexity of f , where by "bit complexity" we mean the total number of bits committed to or communicated between the two players. <p> Thus, if f is an arbitrary predicate on m bits, a zero-knowledge proof that f (x) = 1 will require exponential communication if one uses the protocols of <ref> [5, 6, 18] </ref>, regardless of the amount of computational power one allows the verifier. By applying 3 locally random reductions, we achieve a protocol whose total communication cost is polynomial, even if the circuit complexity of f is exponential. <p> With respect to practical applicability, our protocol is not an improvement over those of <ref> [5, 6, 18] </ref>. The rest of the paper is organized as follows. In Section 2, we formally define locally random reductions and other notions that we will use later in the paper. In Section 3, we give our improved construction of locally random reductions. <p> Zero-knowledge proofs on committed bits were first used in the study of multi-party secure computation [12] and were based on complexity theoretic assumptions. Simple schemes for basing zero-knowledge proofs on committed bits on ideal commitment schemes were developed not long thereafter (e.g., <ref> [5, 18] </ref>) but did not appear in the literature until [6]. These schemes allowed one to prove arbitrary predicates on k committed bits using a total amount of communication that was potentially exponential in k. This exponential communication cost is sometimes acceptable. <p> Under this interpretation, even a malicious prover is guaranteed to be committing to some unambiguous value. More precisely, recall the following standard protocol that is used in earlier work on zero knowledge proofs, e.g., in those of Bennett <ref> [5] </ref> and Rudich [18]. Given two pairs, (x 0 i [j]; x 1 (x 0 i [k]), we wish to give a zero-knowledge proof that x 0 i [j] = x 0 i [k]: This is accomplished by using protocol prove-equal on the four committed bits.
Reference: [6] <author> M. Ben-Or, O. Goldreich, S. Goldwasser, J. Hastaad, J. Kilian, S. Micali, and P. Rogaway. </author> <title> Everything Provable is Provable in Zero-Knowledge, </title> <booktitle> Advances in Cryptology - Crypto '88, Lecture Notes in Computer Science, </booktitle> <volume> vol. 403, </volume> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1990, </year> <pages> 37-56. </pages>
Reference-contexts: A natural question to ask is whether one can actually perform zero-knowledge proofs on committed bits in this setting. This question has been answered in the affirmative by several researchers (e.g., [5, 18]); a written account of a more recent scheme appears in <ref> [6] </ref>. It is natural to ask whether an interactive proof system is at all interesting if it requires the verifier as well as the prover to have unlimited computational power. <p> It is not at all clear (and might even be counterintuitive) that an arbitrary predicate f can be proven in a communication-efficient manner, even if both prover and verifier have enough computational power to compute f . All previous schemes for zero-knowledge proofs on committed bits, including those of <ref> [5, 6, 18] </ref>, have bit complexity proportional to the circuit complexity of f , where by "bit complexity" we mean the total number of bits committed to or communicated between the two players. <p> Thus, if f is an arbitrary predicate on m bits, a zero-knowledge proof that f (x) = 1 will require exponential communication if one uses the protocols of <ref> [5, 6, 18] </ref>, regardless of the amount of computational power one allows the verifier. By applying 3 locally random reductions, we achieve a protocol whose total communication cost is polynomial, even if the circuit complexity of f is exponential. <p> With respect to practical applicability, our protocol is not an improvement over those of <ref> [5, 6, 18] </ref>. The rest of the paper is organized as follows. In Section 2, we formally define locally random reductions and other notions that we will use later in the paper. In Section 3, we give our improved construction of locally random reductions. <p> Simple schemes for basing zero-knowledge proofs on committed bits on ideal commitment schemes were developed not long thereafter (e.g., [5, 18]) but did not appear in the literature until <ref> [6] </ref>. These schemes allowed one to prove arbitrary predicates on k committed bits using a total amount of communication that was potentially exponential in k. This exponential communication cost is sometimes acceptable.
Reference: [7] <author> M. Ben-Or, S. Goldwasser and A. Wigderson. </author> <title> Completeness Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation, </title> <booktitle> Proc. 20 th Annual Symposium on Theory of of Computing,, </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1988, </year> <pages> 1-10. </pages>
Reference-contexts: In this way, algebraic properties of polynomials can be directly exploited. Such arithmetization of Boolean functions is an important insight of Ben-Or, Goldwasser, and Wigderson <ref> [7] </ref>. The polynomial P is sometimes referred to as a "multilinear extension of f over F " (e.g., in [2, 16, 19]). Fix a function f : f0; 1g m ! f0; 1g and a finite field F .
Reference: [8] <author> U. Feige and A. Shamir. </author> <title> Witness Indistinguishable and Witness Hiding Proofs, </title> <booktitle> Proc. 22 nd Annual Symposium on Theory of Computing, </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1990, </year> <pages> 416-426. </pages>
Reference-contexts: Another way to model potential information leakage follows the notion of "witness indistinguishability" of Feige and Shamir <ref> [8] </ref>. In particular, for any equal length x and x 0 that satisfy predicate Q, the views that the verifier gets in these cases should be identical. This approach concerns itself more with hiding the input than with leaking extraneous information.
Reference: [9] <author> J. Feigenbaum. </author> <title> Locally Random Reductions in Interactive Complexity Theory, </title> <booktitle> Advances in Computational Complexity, DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <volume> vol. 13, </volume> <publisher> AMS, </publisher> <address> Providence, </address> <year> 1993, </year> <pages> 73-98. </pages>
Reference-contexts: A detailed overview of the relationship of locally random reductions to other basic concepts in complexity theory can be found in <ref> [9] </ref>. 1.2 Our results In this paper, we provide a formal definition of locally random reductions, exhibit an improved general construction of such reductions, and apply them to zero-knowledge proof systems. Informally, a (t; n)-locally random reduction from a function f to a function g works as follows.
Reference: [10] <author> L. Fortnow and M. Szegedy. </author> <title> On the Power of Two-Oracle Instance-Hiding Schemes, </title> <journal> Inform. Proc. Ltrs. </journal> <volume> 44 (1992), </volume> <pages> 303-306. </pages>
Reference-contexts: Fortnow and Szegedy <ref> [10] </ref> show that there is an f that is not (1; 2)- locally random reducible to a pair of functions (g 1 ; g 2 ), if one insists that the functions g i be boolean and that the reduction have 0 error probability.
Reference: [11] <author> O. Goldreich, S. Micali, and A. Wigderson. </author> <title> Proofs that Yield Nothing but the Validity of the Assertion, and a Methodology of Cryptographic Protocol Design, </title> <editor> J. </editor> <booktitle> ACM 38 (1991), </booktitle> <pages> 691-729. </pages>
Reference-contexts: Ideal commitment schemes were used in the construction of zero-knowledge proofs for predicates in NP (cf. <ref> [11] </ref>) and IP (cf. [14]). Zero-knowledge proofs on committed bits were first used in the study of multi-party secure computation [12] and were based on complexity theoretic assumptions.
Reference: [12] <author> O. Goldreich, S. Micali, and A. Wigderson. </author> <title> How to Play ANY Mental Game, </title> <booktitle> Proc. 19 th Annual Symposium on Theory of Computing, </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1987, </year> <pages> 218-229. 18 </pages>
Reference-contexts: Ideal commitment schemes were used in the construction of zero-knowledge proofs for predicates in NP (cf. [11]) and IP (cf. [14]). Zero-knowledge proofs on committed bits were first used in the study of multi-party secure computation <ref> [12] </ref> and were based on complexity theoretic assumptions. Simple schemes for basing zero-knowledge proofs on committed bits on ideal commitment schemes were developed not long thereafter (e.g., [5, 18]) but did not appear in the literature until [6].
Reference: [13] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The Knowledge Complexity of Interactive Proof Systems, </title> <journal> SIAM J. Comput. </journal> <volume> 18 (1989), </volume> <pages> 186-208. </pages>
Reference-contexts: This improves on the results of [3, 15] mentioned above. We apply locally random reductions in a novel protocol for zero-knowledge proofs on committed bits. Zero-knowledge proof systems, as originally formulated by Goldwasser, Micali, and Rack-off <ref> [13] </ref>, are two-party protocols in which the parties have a common input x, and one party (the prover) convinces the other (the verifier) that, say, f (x) = 1, without revealing anything about x except that f (x) = 1. <p> Nothing else is revealed. As in the more customary setting of Goldwasser, Micali and Rackoff <ref> [13] </ref>, we can formalize this idea by using a simulator: We require of any (possibly cheating) verifier that there be an algorithm that produces a distribution on (fake) views that coincides with the distribution on (real) views received by that verifier (when interacting with the prover who has initial input x,
Reference: [14] <author> R. Impagliazzo and M. Yung. </author> <title> Direct Minimum Knowledge Computations, </title> <booktitle> Advances in Cryptology - Crypto '87, Lecture Notes in Computer Science, </booktitle> <volume> vol. 293, </volume> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1988, </year> <pages> 40-51. </pages>
Reference-contexts: Ideal commitment schemes were used in the construction of zero-knowledge proofs for predicates in NP (cf. [11]) and IP (cf. <ref> [14] </ref>). Zero-knowledge proofs on committed bits were first used in the study of multi-party secure computation [12] and were based on complexity theoretic assumptions.
Reference: [15] <author> R. Lipton. </author> <title> New Directions in Testing, </title> <booktitle> in Distributed Computing and Cryptography, DIMACS Series on Discrete Mathematics and Theoretical Computer Science, </booktitle> <volume> vol. 2, </volume> <publisher> American Mathematical Society, </publisher> <address> Providence, </address> <year> 1991, </year> <pages> 191-202. </pages>
Reference-contexts: In fact, we will later show how to reduce this to jxj=c lg jxj. Lipton <ref> [15] </ref> translated the arguments of [3] into the language of multivariate polynomials and applied them to the area of program testing. <p> It has been observed that Lipton's program-testing reductions imply average-case complexity results, such as the following theorem on computing permanents over finite fields. Theorem: <ref> [15] </ref> Let F be a finite field with more than m + 1 elements. <p> Since the results of 2 Beaver-Feigenbaum [3] and Lipton <ref> [15] </ref> appeared, a number of researchers have used random-self--reducibility properties of multivariate polynomials to show, among other things, that P #P IP (cf. [16]), IP = PSPACE (cf. [19]), and MIP = NEXPTIME (cf. [2]). <p> Theorem 1: For any function f : f0; 1g m ! f0; 1g and any constant c &gt; 0, there is a function g such that f is (t; tm=c lg m)-locally random reducible to g. This improves on the results of <ref> [3, 15] </ref> mentioned above. We apply locally random reductions in a novel protocol for zero-knowledge proofs on committed bits. <p> Otherwise, everything that we present is the same for all finite fields. 3 Improved locally random reductions We now show how to improve the results of Beaver-Feigenbaum [3] and Lipton <ref> [15] </ref>. We first exhibit a parameterized family of random-self-reductions for multivariate polynomials over sufficiently large finite fields. We then give, for any constant c &gt; 0 and any m-bit function f , a (t; tbm=c lg mc)-locally random reductions from f to some other function g. <p> Furthermore, there is a single pair of functions (scatter; reconstruct) that serves as a locally random self-reduction for any P satisfying the above conditions. Proof: Our proof proceeds along the lines of [3], using the polynomial framework of <ref> [15] </ref>. First, we define scatter (X; r). Let X = (x 1 ; : : : ; x m ) 2 F m , and regard r as a set of mt random elements of F , denoted fc i;j g, where 1 i m and 1 j t.
Reference: [16] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan. </author> <title> Algebraic Methods for Interactive Proof Systems, </title> <editor> J. </editor> <booktitle> ACM 39 (1992), </booktitle> <pages> 859-868. </pages>
Reference-contexts: Since the results of 2 Beaver-Feigenbaum [3] and Lipton [15] appeared, a number of researchers have used random-self--reducibility properties of multivariate polynomials to show, among other things, that P #P IP (cf. <ref> [16] </ref>), IP = PSPACE (cf. [19]), and MIP = NEXPTIME (cf. [2]). <p> In this way, algebraic properties of polynomials can be directly exploited. Such arithmetization of Boolean functions is an important insight of Ben-Or, Goldwasser, and Wigderson [7]. The polynomial P is sometimes referred to as a "multilinear extension of f over F " (e.g., in <ref> [2, 16, 19] </ref>). Fix a function f : f0; 1g m ! f0; 1g and a finite field F .
Reference: [17] <author> R. Rivest. </author> <title> Workshop on Communication and Computing, </title> <publisher> MIT, </publisher> <month> October </month> <year> 1986. </year>
Reference-contexts: A more precise and general formulation of this idea may be found in [1]. Rivest <ref> [17, 1] </ref> proposed the more general notion of multi-oracle instance-hiding schemes, in which P is allowed to interact with a number of oracles O 1 ; : : : ; O n .
Reference: [18] <author> S. Rudich. </author> <title> Private communication via Gilles Brassard. </title>
Reference-contexts: A natural question to ask is whether one can actually perform zero-knowledge proofs on committed bits in this setting. This question has been answered in the affirmative by several researchers (e.g., <ref> [5, 18] </ref>); a written account of a more recent scheme appears in [6]. It is natural to ask whether an interactive proof system is at all interesting if it requires the verifier as well as the prover to have unlimited computational power. <p> It is not at all clear (and might even be counterintuitive) that an arbitrary predicate f can be proven in a communication-efficient manner, even if both prover and verifier have enough computational power to compute f . All previous schemes for zero-knowledge proofs on committed bits, including those of <ref> [5, 6, 18] </ref>, have bit complexity proportional to the circuit complexity of f , where by "bit complexity" we mean the total number of bits committed to or communicated between the two players. <p> Thus, if f is an arbitrary predicate on m bits, a zero-knowledge proof that f (x) = 1 will require exponential communication if one uses the protocols of <ref> [5, 6, 18] </ref>, regardless of the amount of computational power one allows the verifier. By applying 3 locally random reductions, we achieve a protocol whose total communication cost is polynomial, even if the circuit complexity of f is exponential. <p> With respect to practical applicability, our protocol is not an improvement over those of <ref> [5, 6, 18] </ref>. The rest of the paper is organized as follows. In Section 2, we formally define locally random reductions and other notions that we will use later in the paper. In Section 3, we give our improved construction of locally random reductions. <p> Zero-knowledge proofs on committed bits were first used in the study of multi-party secure computation [12] and were based on complexity theoretic assumptions. Simple schemes for basing zero-knowledge proofs on committed bits on ideal commitment schemes were developed not long thereafter (e.g., <ref> [5, 18] </ref>) but did not appear in the literature until [6]. These schemes allowed one to prove arbitrary predicates on k committed bits using a total amount of communication that was potentially exponential in k. This exponential communication cost is sometimes acceptable. <p> Under this interpretation, even a malicious prover is guaranteed to be committing to some unambiguous value. More precisely, recall the following standard protocol that is used in earlier work on zero knowledge proofs, e.g., in those of Bennett [5] and Rudich <ref> [18] </ref>. Given two pairs, (x 0 i [j]; x 1 (x 0 i [k]), we wish to give a zero-knowledge proof that x 0 i [j] = x 0 i [k]: This is accomplished by using protocol prove-equal on the four committed bits.
Reference: [19] <author> A. Shamir. </author> <title> IP = PSPACE, </title> <editor> J. </editor> <booktitle> ACM 39 (1992), </booktitle> <pages> 869-877. 19 </pages>
Reference-contexts: Since the results of 2 Beaver-Feigenbaum [3] and Lipton [15] appeared, a number of researchers have used random-self--reducibility properties of multivariate polynomials to show, among other things, that P #P IP (cf. [16]), IP = PSPACE (cf. <ref> [19] </ref>), and MIP = NEXPTIME (cf. [2]). <p> In this way, algebraic properties of polynomials can be directly exploited. Such arithmetization of Boolean functions is an important insight of Ben-Or, Goldwasser, and Wigderson [7]. The polynomial P is sometimes referred to as a "multilinear extension of f over F " (e.g., in <ref> [2, 16, 19] </ref>). Fix a function f : f0; 1g m ! f0; 1g and a finite field F .
References-found: 19

