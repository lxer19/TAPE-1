URL: http://geraes.sp.cs.cmu.edu/papers/CMU-CS-98-124.ps.gz
Refering-URL: http://www.cs.cmu.edu/~berez/publications.html
Root-URL: 
Title: Combining Symbolic Model Checking with Uninterpreted Functions for Out-of-Order Processor Verification  
Author: Sergey Berezin, Armin Biere, Edmund Clarke, and Yunshan Zhu 
Note: Submitted for FMCAD'98  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: April 20, 1998  
Pubnum: CMU-CS-98-124  
Abstract: This research is sponsored by the Semiconductor Research Corporation (SRC) under Contract No. 97-DJ-294, the National Science Foundation (NSF) under Grant No. CCR-9505472, and the Defense Advanced Research Projects Agency (DARPA) under Contract No. DABT63-96-C-0071. Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of SRC, NSF, DARPA, or the United States Government. Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of SRC, NSF, DARPA, or the United States Government. The U. S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation thereon. This manuscript is submitted for publication with the understanding that the U. S. Government is authorized to reproduce and distribute reprints for Governmental purposes. 
Abstract-found: 1
Intro-found: 1
Reference: [BBDE + 97] <author> I. Beer, S. Ben-David, C. Eisner, D. Geist, L. Gluhovsky, T. Heyman, A. Landver, P. Paanah, Y. Rodeh, G. Ronin, and Y. Wolfsthal. </author> <title> Rulebase: Model checking at IBM. </title> <booktitle> In Computer Aided Verification (CAV'97), number 1254 in Lecture Notes in Computer Science, </booktitle> <pages> pages 480483. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: If we split our specification to compare one entry of the reference file at a time, then all the other entries can be removed from the model. A similar technique was used in [McM98]. Early Evaluation of AG Specifications (e.g. <ref> [BBDE + 97] </ref>) was invaluable in debugging the model. This is a technique of evaluating AG specifications at every iteration of the breadth first search for the set of reachable states.
Reference: [BCM92] <author> J. R. Burch, E. M. Clarke, and K. L. McMillan. </author> <title> Symbolic model checking: 10 20 states and beyond. Information and Computation, </title> <address> 98:142170, </address> <year> 1992. </year>
Reference-contexts: Terms that share common subexpressions simply have references to the same entries in the reference file. This greatly reduces the memory requirements and also simplifies the problem of checking equivalence between terms we simply compare the references. We propose to use symbolic model checking techniques <ref> [BCM92, McM93] </ref> to perform the actual symbolic execution of the circuit. The correctness of the method has been proven in the PVS theorem prover [SOR93]. Recently there has been done a lot of work on the verification of superscalar microprocessors both with and without OOO execution.
Reference: [BD94] <author> J. R. Burch and D. L. Dill. </author> <title> Automatic verification of pipelined microprocessor control. </title> <editor> In D. L. Dill, editor, </editor> <booktitle> Computer Aided Verification (CAV'94), volume 818 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <month> 16 </month>
Reference-contexts: Straightforward model checking techniques [CE81, CES86] can not handle this complexity because of the state explosion problem. Theorem proving [DP97, SH98] alone usually involves significant manual effort. Moreover, the proofs are too tedious to be easily manageable. Symbolic execution using uninterpreted function symbols <ref> [BD94] </ref> is based on extensive term rewriting and simple proof-theoretic reasoning, and thus, can be easily automated. However, when the circuit becomes too large, each cycle in the symbolic execution produces large formulas. In addition, the number of cycles required to complete the verification grows as well. <p> The correctness of the method has been proven in the PVS theorem prover [SOR93]. Recently there has been done a lot of work on the verification of superscalar microprocessors both with and without OOO execution. Burch and Dill <ref> [BD94] </ref> use the notion of uninterpreted functions to represent data and instructions symbolically. Interpreting these symbols results in a particular run of the concrete processor being verified. All of the formulas with uninterpreted function symbols that can be proven remain true under arbitrary interpretations. <p> Our approach does not require any special decision procedures. We only need a powerful symbolic model checker. Sajid et al. [SGZ + 98] have extended the decision procedures for uninterpreted function symbols to use BDDs. However, their work shares the disadvantage of <ref> [BD94] </ref> that their decision procedure can not be easily combined with symbolic model checking. Moreover, they do not have a notion of fairness nor can their method verify more involved temporal properties. They have also not investigated how their techniques can be applied to the verification of OOO. <p> Moreover, we have developed a number of new transformations in addition to the classical symmetry reduction [CJ95] that significantly reduce the state space. In particular, these reductions enable us to verify liveness easily. The approaches of Burch & Dill <ref> [BD94] </ref> and McMillan [McM98] are both valuable for verifying out-of-order execution algorithms. However, they both have major limitations. The decision procedures of Burch & Dill can not be used directly with symbolic model checking. McMillan's work, on the other hand, does use symbolic model checking techniques. <p> In their approach the operations become uninterpreted function symbols and the data is represented by terms over these symbols. For their model of a microprocessor the verification task amounts to checking the equivalence of two deeply nested terms. A special decision procedure for quantifier-free first order logic with equality <ref> [BD94] </ref> is needed for this purpose. The original [BD94] paper only considered a single scalar pipeline. This work was extended to a superscalar in-order microprocessor in [Bur96]. However, his project required a non-trivial amount of human interaction and manual modification of the model. <p> For their model of a microprocessor the verification task amounts to checking the equivalence of two deeply nested terms. A special decision procedure for quantifier-free first order logic with equality <ref> [BD94] </ref> is needed for this purpose. The original [BD94] paper only considered a single scalar pipeline. This work was extended to a superscalar in-order microprocessor in [Bur96]. However, his project required a non-trivial amount of human interaction and manual modification of the model. <p> The decision procedure of Burch & Dill can not make use of highly effective symbolic model checking techniques and is unable to handle OOO properly, as noted in [SJD98]. We start with the same basic idea as <ref> [BD94] </ref>. The model of the microprocessor does not compute concrete values. It only manipulates symbolic terms made of constants and uninterpreted function symbols. This is explained in Figure 3 (a) where a symbolic execution trace of a sequential microprocessor is shown. <p> A standard approach to deal with instruction sequences is to use 9 10 induction on the length of the sequence <ref> [BD94] </ref>. Below we use s and t to denote states of the OOO machine, and p and q for the sequential machine. In the induction step we have to compare states of the OOO and the sequential machines. <p> Then we need to check that the resulting states t and q are again equivalent. This property is often described as a commutative diagram <ref> [BD94] </ref> (the rear side of the cube in Figure 7). There are two paths from s to q in Figure 7. The path where dispatching of I is followed by flushing is called the OOO path. <p> However, proving the lemma is hard and is the main bottleneck of the verification of OOO designs. In part, our method of proving this lemma is similar to the one of Burch & Dill <ref> [BD94] </ref>. As in their approach, we use an initial abstraction that replaces the concrete instructions and data values by uninterpreted constants and function symbols. But then we apply symbolic model checking techniques, including the reference file, as opposed to special decision procedures.
Reference: [Bry86] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Trans--actions on Computers, </journal> <volume> 35(8):677691, </volume> <year> 1986. </year>
Reference-contexts: Thus, their approach can prove the correctness of a device regardless of the concrete implementation. This approach, however, requires special decision procedures for uninterpreted function symbols and does not use previously existing techniques like BDDs <ref> [Bry86] </ref>. Skakkebk et al. [SJD98] propose an incremental flushing technique to verify an OOO design. Their approach is also based on uninterpreted function symbols and uses the SVC tool as a decision procedure. Our approach does not require any special decision procedures. We only need a powerful symbolic model checker.
Reference: [Bur96] <author> J. R. Burch. </author> <title> Techniques for verifying superscalar microprocessors. </title> <booktitle> In 33rd Design Automation Conference (DAC'96), </booktitle> <pages> pages 552557, </pages> <year> 1996. </year>
Reference-contexts: A special decision procedure for quantifier-free first order logic with equality [BD94] is needed for this purpose. The original [BD94] paper only considered a single scalar pipeline. This work was extended to a superscalar in-order microprocessor in <ref> [Bur96] </ref>. However, his project required a non-trivial amount of human interaction and manual modification of the model. The decision procedure of Burch & Dill can not make use of highly effective symbolic model checking techniques and is unable to handle OOO properly, as noted in [SJD98].
Reference: [CAV98] <institution> Computer Aided Verification (CAV'98), </institution> <year> 1998. </year> <note> To appear. </note>
Reference: [CE81] <author> E. Clarke and E. A. Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching time temporal logic. </title> <booktitle> In Proceedings of the IBM Workshop on Logics of Programs, volume 131 of LNCS, </booktitle> <pages> pages 5271. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: However, the growing complexity of microprocessors makes formal verification increasingly difficult because data and control flow are tightly coupled. A formal model has to capture all of the data dependencies. As a result, the state space may become enormous. Straightforward model checking techniques <ref> [CE81, CES86] </ref> can not handle this complexity because of the state explosion problem. Theorem proving [DP97, SH98] alone usually involves significant manual effort. Moreover, the proofs are too tedious to be easily manageable.
Reference: [CES86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2):244263, </volume> <year> 1986. </year>
Reference-contexts: However, the growing complexity of microprocessors makes formal verification increasingly difficult because data and control flow are tightly coupled. A formal model has to capture all of the data dependencies. As a result, the state space may become enormous. Straightforward model checking techniques <ref> [CE81, CES86] </ref> can not handle this complexity because of the state explosion problem. Theorem proving [DP97, SH98] alone usually involves significant manual effort. Moreover, the proofs are too tedious to be easily manageable.
Reference: [CJ95] <author> E. M. Clarke and S. Jha. </author> <title> Symmetry and induction in model checking. </title> <booktitle> Number 1000 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: He also does not consider liveness, which is also the case for [DP97]. Our representation makes it possible to abstract away the concrete instructions and functional units. Moreover, we have developed a number of new transformations in addition to the classical symmetry reduction <ref> [CJ95] </ref> that significantly reduce the state space. In particular, these reductions enable us to verify liveness easily. The approaches of Burch & Dill [BD94] and McMillan [McM98] are both valuable for verifying out-of-order execution algorithms. However, they both have major limitations. <p> However, to verify designs that are closer to real microprocessors we need to apply other optimizations as well. 12 (Classical) Symmetry Reduction for Functional Units <ref> [CJ95] </ref>. In our model the result of only one functional unit can be written back at each clock cycle. We make all the functional units completely general such that they can execute any type of instructions. <p> In addition to that, we have developed a number of different transformations that dramatically reduce the size of the set of reachable states and increase the scale of the designs that we are able to handle. Most of the transformations can be formulated as a symmetry reduction <ref> [CJ95] </ref> and we want to investigate to what extent these reductions can be automated. The technique includes a theorem proving part using PVS where we check that we did not overlook any important detail. First, we prove a general Theorem 1 together with Lemma 4.
Reference: [DP97] <author> W. Damm and A. Pnueli. </author> <title> Verifying out-of-order executions. </title> <editor> In D. Probst, editor, CHARME'97. </editor> <publisher> Chapman & Hall, </publisher> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: A formal model has to capture all of the data dependencies. As a result, the state space may become enormous. Straightforward model checking techniques [CE81, CES86] can not handle this complexity because of the state explosion problem. Theorem proving <ref> [DP97, SH98] </ref> alone usually involves significant manual effort. Moreover, the proofs are too tedious to be easily manageable. Symbolic execution using uninterpreted function symbols [BD94] is based on extensive term rewriting and simple proof-theoretic reasoning, and thus, can be easily automated. <p> However, because the functional unit is modeled explicitly, his approach is unsuitable for verifying examples with a large number of instruction types or complex functional units (e.g. for operations like integer multiplication). He also does not consider liveness, which is also the case for <ref> [DP97] </ref>. Our representation makes it possible to abstract away the concrete instructions and functional units. Moreover, we have developed a number of new transformations in addition to the classical symmetry reduction [CJ95] that significantly reduce the state space. In particular, these reductions enable us to verify liveness easily. <p> This algorithm is the basic technique that is used to implement OOO in modern microprocessors. It also has been used in previous work on the verification of OOO <ref> [DP97, McM98] </ref>. We will explain how OOO works and how Tomasulo's algorithm implements it. At the end of the section we briefly describe our model. To achieve greater throughput of instructions, superscalar microprocessors use several functional units that can operate in parallel. <p> Because of the power of symbolic model checking techniques we decided to investigate whether they could be used in combination with uninterpreted function symbols to verify OOO designs. The advantage of model checking over theorem proving <ref> [DP97, SH98] </ref> is that it is much more automatic. But even with the use of symbolic methods like BDDs there is a limit on the size of the models that can be handled.
Reference: [Gwe95] <author> L. Gwennap. </author> <title> Intel's P6 uses decoupled superscalar design. </title> <type> Microprocessor Report, </type> <institution> 9(2):915, </institution> <year> 1995. </year>
Reference-contexts: It consists of a set of registers (the register file), a pool of reservation stations, and several functional units. The main difference is that reservation stations are not associated with specific functional units. In our paper we build a pool of reservation stations instead. The Pentium Pro TM <ref> [Gwe95] </ref> microprocessor also has a pool of reservation stations. A similar model was used in [McM98]. 3 Basic Abstraction Techniques Symbolic model checking techniques [McM93] have proven to be of great value for the verification of reactive systems.
Reference: [HB95] <author> R. Hojati and R. K. Brayton. </author> <title> Automatic datapath abstraction of hardware systems. In Computer Aided Verification (CAV'95). </title> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Moreover, they do not have a notion of fairness nor can their method verify more involved temporal properties. They have also not investigated how their techniques can be applied to the verification of OOO. Hojati and Brayton <ref> [HB95] </ref> have developed a formal description technique for integer combinational/sequential (ICS) systems. Their technique is even more general than uninterpreted functions ([BD94]). <p> This allows the usage of efficient symbolic model checkers. However, OOO is inherently data dependent and thus these abstraction techniques can not be applied. <ref> [HB95] </ref> also investigates how approximate 1 reachability analysis can be performed for general ICS models. They give an algorithm that makes use of BDDs, but it is only used for reachability analysis and no limit on the number of terms occurring in the verification can be given. <p> This number of state bits is clearly out of the scope of all currently available model checkers. 3.2 The Brute Force Approach The most obvious abstraction is to use only a small number of bits for each register. This abstraction technique is described in <ref> [Wol86, HB95] </ref> and minimizes the size of registers (and reservation stations) containing data.
Reference: [HP96] <author> J. Hennessy and D. Patterson. </author> <title> Computer Architecture: a Quantitative Approach. </title> <publisher> Mor-gan Kaufmann Publishers, </publisher> <year> 1996. </year>
Reference-contexts: Section 7 shows some experimental results. The paper concludes in Section 8 with a discussion of some directions for future research. 2 Out-of-Order Execution As benchmarks for our method we have verified several configurations of our implementation of Tomasulo's algorithm <ref> [HP96] </ref>. This algorithm is the basic technique that is used to implement OOO in modern microprocessors. It also has been used in previous work on the verification of OOO [DP97, McM98]. We will explain how OOO works and how Tomasulo's algorithm implements it. <p> In our model tags and values share the same memory for efficiency. Figure 1 is a high level floorplan of our model. It is similar to the OOO unit described in <ref> [HP96] </ref>. It consists of a set of registers (the register file), a pool of reservation stations, and several functional units. The main difference is that reservation stations are not associated with specific functional units. In our paper we build a pool of reservation stations instead.
Reference: [Jon87] <editor> S. L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Moreover, the same terms or subterms are referenced at different locations. For instance, in the final state of the execution trace in twice and can not be shared. A similar problem occurs in the implementation of logic and functional programming languages like Prolog and Lisp <ref> [War83, Jon87, Kog91] </ref>. They use a heap to store newly generated terms. Registers in the abstract machine for these languages (e.g. WAM [War83]) only contain constant values or pointers to the heap. This prevents unnecessary copying and allows sharing of common subterms.
Reference: [Kog91] <author> Peter M. Kogge. </author> <title> The Architecture of Symbolic Computers. </title> <publisher> McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: Moreover, the same terms or subterms are referenced at different locations. For instance, in the final state of the execution trace in twice and can not be shared. A similar problem occurs in the implementation of logic and functional programming languages like Prolog and Lisp <ref> [War83, Jon87, Kog91] </ref>. They use a heap to store newly generated terms. Registers in the abstract machine for these languages (e.g. WAM [War83]) only contain constant values or pointers to the heap. This prevents unnecessary copying and allows sharing of common subterms.
Reference: [McM93] <author> K. L. McMillan. </author> <title> Symbolic Model Checking: An Approach to the State Explosion Problem. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Terms that share common subexpressions simply have references to the same entries in the reference file. This greatly reduces the memory requirements and also simplifies the problem of checking equivalence between terms we simply compare the references. We propose to use symbolic model checking techniques <ref> [BCM92, McM93] </ref> to perform the actual symbolic execution of the circuit. The correctness of the method has been proven in the PVS theorem prover [SOR93]. Recently there has been done a lot of work on the verification of superscalar microprocessors both with and without OOO execution. <p> In our paper we build a pool of reservation stations instead. The Pentium Pro TM [Gwe95] microprocessor also has a pool of reservation stations. A similar model was used in [McM98]. 3 Basic Abstraction Techniques Symbolic model checking techniques <ref> [McM93] </ref> have proven to be of great value for the verification of reactive systems. They have made it possible to verify a large number of practical examples, often with enormous state spaces. The techniques are automatic and can generate counterexamples when a system fails to satisfy its specification.
Reference: [McM98] <author> K. L. McMillan. </author> <title> Verification of an implementation of tomasulo's algorithm by compositional model checking. </title> <note> In CAV'98 [CAV98]. To appear. </note>
Reference-contexts: Our approach does not require a new algorithm, and the number of terms that need to be considered can be calculated a priori. Therefore, our model can be represented very efficiently in previously existing symbolic model checkers. McMillan in <ref> [McM98] </ref> has used model checking to verify a variant of Tomasulo's algorithm (see Section 2). However, his model has only one functional unit that computes only one concrete operation (integer addition). The main idea in his paper is to use compositional reasoning to reduce the complexity of the verification. <p> Moreover, we have developed a number of new transformations in addition to the classical symmetry reduction [CJ95] that significantly reduce the state space. In particular, these reductions enable us to verify liveness easily. The approaches of Burch & Dill [BD94] and McMillan <ref> [McM98] </ref> are both valuable for verifying out-of-order execution algorithms. However, they both have major limitations. The decision procedures of Burch & Dill can not be used directly with symbolic model checking. McMillan's work, on the other hand, does use symbolic model checking techniques. <p> This algorithm is the basic technique that is used to implement OOO in modern microprocessors. It also has been used in previous work on the verification of OOO <ref> [DP97, McM98] </ref>. We will explain how OOO works and how Tomasulo's algorithm implements it. At the end of the section we briefly describe our model. To achieve greater throughput of instructions, superscalar microprocessors use several functional units that can operate in parallel. <p> The main difference is that reservation stations are not associated with specific functional units. In our paper we build a pool of reservation stations instead. The Pentium Pro TM [Gwe95] microprocessor also has a pool of reservation stations. A similar model was used in <ref> [McM98] </ref>. 3 Basic Abstraction Techniques Symbolic model checking techniques [McM93] have proven to be of great value for the verification of reactive systems. They have made it possible to verify a large number of practical examples, often with enormous state spaces. <p> We made this mistake in a preliminary version of our model and during the verification the model checker produced a counter example. A similar error is also reported in <ref> [McM98] </ref>. In the fourth step the second and third instructions are executed in parallel. After that, in the fifth step, the execution of both instructions is finished. However, only one functional unit at a time can use the CDB to write back. <p> Thus, no state variable depends on any of the entries in the reference file. If we split our specification to compare one entry of the reference file at a time, then all the other entries can be removed from the model. A similar technique was used in <ref> [McM98] </ref>. Early Evaluation of AG Specifications (e.g. [BBDE + 97]) was invaluable in debugging the model. This is a technique of evaluating AG specifications at every iteration of the breadth first search for the set of reachable states. <p> We are also going to implement the reorder buffer and support for precise exception handling. Finally, it is very important to combine our method with compositional approaches like those of McMillan's <ref> [McM98] </ref>.
Reference: [SGZ + 98] <author> K. Sajid, A. Goel, H. Zhou, A. Aziz, and V. Singhal. </author> <title> BDD based procedures for a theory of equality with uninterpreted functions. </title> <note> In CAV'98 [CAV98]. To appear. </note>
Reference-contexts: Their approach is also based on uninterpreted function symbols and uses the SVC tool as a decision procedure. Our approach does not require any special decision procedures. We only need a powerful symbolic model checker. Sajid et al. <ref> [SGZ + 98] </ref> have extended the decision procedures for uninterpreted function symbols to use BDDs. However, their work shares the disadvantage of [BD94] that their decision procedure can not be easily combined with symbolic model checking.
Reference: [SH98] <author> J. Sawada and W. A. Hunt. </author> <title> Processor verification with precise exceptions and speculative execution. </title> <note> In CAV'98 [CAV98]. To appear. </note>
Reference-contexts: A formal model has to capture all of the data dependencies. As a result, the state space may become enormous. Straightforward model checking techniques [CE81, CES86] can not handle this complexity because of the state explosion problem. Theorem proving <ref> [DP97, SH98] </ref> alone usually involves significant manual effort. Moreover, the proofs are too tedious to be easily manageable. Symbolic execution using uninterpreted function symbols [BD94] is based on extensive term rewriting and simple proof-theoretic reasoning, and thus, can be easily automated. <p> Because of the power of symbolic model checking techniques we decided to investigate whether they could be used in combination with uninterpreted function symbols to verify OOO designs. The advantage of model checking over theorem proving <ref> [DP97, SH98] </ref> is that it is much more automatic. But even with the use of symbolic methods like BDDs there is a limit on the size of the models that can be handled.
Reference: [SJD98] <author> J. U. Skakkebk, R. B. Jones, and D. L. Dill. </author> <title> Formal verification of out-of-order execution using incremental flushing. </title> <note> In CAV'98 [CAV98]. To appear. 17 </note>
Reference-contexts: Thus, their approach can prove the correctness of a device regardless of the concrete implementation. This approach, however, requires special decision procedures for uninterpreted function symbols and does not use previously existing techniques like BDDs [Bry86]. Skakkebk et al. <ref> [SJD98] </ref> propose an incremental flushing technique to verify an OOO design. Their approach is also based on uninterpreted function symbols and uses the SVC tool as a decision procedure. Our approach does not require any special decision procedures. We only need a powerful symbolic model checker. <p> However, his project required a non-trivial amount of human interaction and manual modification of the model. The decision procedure of Burch & Dill can not make use of highly effective symbolic model checking techniques and is unable to handle OOO properly, as noted in <ref> [SJD98] </ref>. We start with the same basic idea as [BD94]. The model of the microprocessor does not compute concrete values. It only manipulates symbolic terms made of constants and uninterpreted function symbols. This is explained in Figure 3 (a) where a symbolic execution trace of a sequential microprocessor is shown.
Reference: [SOR93] <author> N. Shankar, S. Owre, and J. M. </author> <title> Rushby. </title> <booktitle> PVS Tutorial. Computer Science Labora--tory, SRI International, </booktitle> <address> Menlo Park, CA, </address> <year> 1993. </year> <title> Also appears in Tutorial Notes, Formal Methods Europe'93: </title> <booktitle> Industrial-Strength Formal Methods, </booktitle> <pages> pages 357406, </pages> <address> Odense, Denmark, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: We propose to use symbolic model checking techniques [BCM92, McM93] to perform the actual symbolic execution of the circuit. The correctness of the method has been proven in the PVS theorem prover <ref> [SOR93] </ref>. Recently there has been done a lot of work on the verification of superscalar microprocessors both with and without OOO execution. Burch and Dill [BD94] use the notion of uninterpreted functions to represent data and instructions symbolically.
Reference: [War83] <author> D. H. D. Warren. </author> <title> An abstract prolog instruction set. </title> <type> Tech. Note 309, </type> <institution> SRI International, </institution> <year> 1983. </year>
Reference-contexts: Moreover, the same terms or subterms are referenced at different locations. For instance, in the final state of the execution trace in twice and can not be shared. A similar problem occurs in the implementation of logic and functional programming languages like Prolog and Lisp <ref> [War83, Jon87, Kog91] </ref>. They use a heap to store newly generated terms. Registers in the abstract machine for these languages (e.g. WAM [War83]) only contain constant values or pointers to the heap. This prevents unnecessary copying and allows sharing of common subterms. <p> A similar problem occurs in the implementation of logic and functional programming languages like Prolog and Lisp [War83, Jon87, Kog91]. They use a heap to store newly generated terms. Registers in the abstract machine for these languages (e.g. WAM <ref> [War83] </ref>) only contain constant values or pointers to the heap. This prevents unnecessary copying and allows sharing of common subterms. We use a special data structure, called reference file, similar to a heap. This is a much more compact encoding of the terms occurring during an execution.
Reference: [Wol86] <author> P. Wolper. </author> <title> Expressing interesting properties of programs in propositional temporal logic. </title> <booktitle> In Proceedings of the 13th annual ACM Symposium on Principles of Programming Languages (POPL'86), </booktitle> <pages> pages 184193. </pages> <publisher> ACM, </publisher> <year> 1986. </year> <month> 18 </month>
Reference-contexts: Hojati and Brayton [HB95] have developed a formal description technique for integer combinational/sequential (ICS) systems. Their technique is even more general than uninterpreted functions ([BD94]). For a restricted class of models they show, by applying the notion of data independence <ref> [Wol86] </ref>, that 0-1 instantiation can reduce the size of the model to a finite number of states. This allows the usage of efficient symbolic model checkers. <p> This number of state bits is clearly out of the scope of all currently available model checkers. 3.2 The Brute Force Approach The most obvious abstraction is to use only a small number of bits for each register. This abstraction technique is described in <ref> [Wol86, HB95] </ref> and minimizes the size of registers (and reservation stations) containing data.
References-found: 23

