URL: http://choices.cs.uiuc.edu/Security/Papers/theron_thesis.ps
Refering-URL: http://choices.cs.uiuc.edu/Security/index.html
Root-URL: http://www.cs.uiuc.edu
Title: c  
Author: flCopyright by Theron Donald Tock 
Date: 1994  
Abstract-found: 0
Intro-found: 1
Reference: [AR87] <author> David P. Anderson and P. Venkat Rangan. </author> <title> A Basis for Secure Communication in Large Distributed Systems. </title> <booktitle> In Symposium on Research in Security and Privacy, </booktitle> <pages> pages 167-172. </pages> <publisher> IEEE, </publisher> <year> 1987. </year>
Reference-contexts: Other systems use message ports for communication, including Mach [Ras86] and V [Che88]. Anderson and Rangan have developed an authentication interface based on message ports, though it is incompatible with previous interfaces <ref> [AR87] </ref>. None of these systems are able to benefit from object orientation to maximize code reuse and provide polymorphism. Furthermore, it is not clear how to add new features such as delegation in such systems.
Reference: [Che88] <author> David R. Cheriton. </author> <title> The V Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 314-333, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Current delegation systems have various tradeoffs in scalability, revocation and processing requirement; the method we present minimizes processing and enables frequent revocation. Other systems use message ports for communication, including Mach [Ras86] and V <ref> [Che88] </ref>. Anderson and Rangan have developed an authentication interface based on message ports, though it is incompatible with previous interfaces [AR87]. None of these systems are able to benefit from object orientation to maximize code reuse and provide polymorphism.
Reference: [CI93] <author> Roy H. Campbell and Nayeem Islam. </author> <title> A Technique for Documenting the Framework of an Object-Oriented System. </title> <journal> Computing Systems, </journal> <volume> 6(4), </volume> <year> 1993. </year>
Reference-contexts: The internal representation is not relevant so long as multiply, add and compare operations are provided. 2.1.5 Design Reuse While classes and inheritance provide interface and code reuse, these same techniques can be used at the system level to provide design reuse <ref> [CI93] </ref>. A framework is a collection of classes or components that form a complete system or subsystem, with informal specifications for the interactions of the components of the framework.
Reference: [CIMR93] <author> Roy Campbell, Nayeem Islam, Peter Madany, and David Raila. </author> <title> Experiences Building an Object-Oriented Operating System in C++. </title> <booktitle> In Communications of the ACM, </booktitle> <pages> pages 117-126, </pages> <year> 1993. </year>
Reference-contexts: represents a subframework and can be replaced by a concrete round-robin or priority-queue class, or similarly the standard virtual memory management can be extended to include distributed virtual memory. 4 2.2 The Choices Message-Passing System The Choices operating system is an object-oriented operating system developed at the University of Illinois <ref> [CIMR93, Rus91] </ref>. It is implemented in C++ [Str86] which provides the object-oriented features described previously with only minimal performance loss. All system concepts are implemented as objects, from files to locks to device drivers. The system is composed of various subframeworks for managing a particular aspect of the system.
Reference: [FS86] <author> Amos Fiat and Adi Shamir. </author> <title> How to Prove Yourself: Practical Solutions to Identification and Signature Problems. </title> <editor> In G. Goos and J. Hartmanis, editors, </editor> <booktitle> Lecture Notes in Computer Science 263, </booktitle> <pages> pages 186-194. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: In the ideal case, the function g is identical for all principals: this obviates the need to ensure we obtain the correct function for a particular principal, requiring a certifying authority as in the Needham-Schroeder protocol. The Fiat-Shamir zero-knowledge proof system <ref> [FS86] </ref> does have this property, with the function g accepting the identity of P as a parameter.
Reference: [GGKL89] <author> M. Gasser, A. Goldstein, C. Kaufman, and B. Lampson. </author> <title> The Digital Distributed System Security Architecture. </title> <booktitle> In National Computer Security Conference, </booktitle> <pages> pages 305-319, </pages> <address> Baltimore, MD, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: network domain that uses an unfamiliar protocol: by merely loading a new module the mobile system will be capable of participating in the new network. 1.2 Related work Numerous solutions for providing authentication and key exchange exist in the literature, including Kerberos [SNS88] and the Distributed System Security Architecture (DSSA) <ref> [GGKL89] </ref> that we will analyze in detail later. Other examples include the ISO security architecture [iITT88] and privacy-enhanced mail [KL89]. None of these systems were designed to facilitate application development, and most are based on a specific authentication protocol. <p> For an environment 22 where numerous delegations are issued, this may cause the authentication server to become a bottleneck. 4.1.2 Delegation in DSSA The Distributed System Security Architecture (DSSA) is a system for managing authentication and security in large distributed systems <ref> [GGKL89] </ref>. To maximize scalability the system uses the asymmetric version of the Needham-Schroeder key exchange protocol to establish secure and authenticated connections between principals. The certifying authorities may be structured hierarchically and the naming scheme used to identify each principal reflects the hierarchy of authorities that certify it [Lin90].
Reference: [GM90] <author> Morrie Gasser and Ellen McDermott. </author> <title> An Architecture for Practical Delegation in a Distributed System. </title> <booktitle> In Symposium on Research in Security and Privacy, </booktitle> <pages> pages 20-30. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: Delegation has only relatively recently received much attention as large-scale distributed systems become more common. As a result the available literature is somewhat limited. Dele 1 gation has been considered for Kerberos [KN93] and DSSA <ref> [GM90] </ref>, which led to our decision to compare our system to these. Other work includes a precursor to the Kerberos work [Sol88] and a good overview of delegation issues [VAB91]. <p> We show how this design fits nicely on the framework for authentication, and then outline the interfaces this design uses. 21 4.1 Delegation Systems We present two actual systems based on the two variants of the Needham-Schroeder protocol that include delegation: Kerberos [KN93] and the Distributed Systems Security Architecture (DSSA) <ref> [GM90] </ref>. We then present a third delegation scheme called Passports [Sol88]. 4.1.1 Delegation in Kerberos Kerberos [SNS88] uses the Needham-Schroeder key exchange protocol with symmetric encryption to exchange session keys that are used for authentication. <p> The certifying authorities may be structured hierarchically and the naming scheme used to identify each principal reflects the hierarchy of authorities that certify it [Lin90]. The system supports both delegations and roles <ref> [GM90] </ref>, where roles serve to delineate the different set of authorizations a principal may use. For example, a system administrator may have two roles User and SuperUser but use the former role for normal cases to prevent accidental damage to the system. <p> The second problem is the matter of revocation. If a delegation key is compromised, or if the delegator loses trust in the delegate, there should be some mechanism to invalidate the delegation. Here the details are a little unclear about DSSA. In <ref> [GM90, p.24] </ref> we find "As we stressed earlier, good systems are expected to act in the best interests of the user, and the user must assume that no system to which he delegates will delegate to another system that the user doesn't trust." Following this is a discussion of how timeouts <p> However, <ref> [GM90, p.23] </ref> mentions an access-control list (ACL) mechanism and states "An additional constraint is that all the delegated principals in the chain must be listed on the ACL of the object as permitted delegates." This seems to violate the requirement that the delegator not know a priori which principals will use
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1983. </year>
Reference-contexts: None of these systems are able to benefit from object orientation to maximize code reuse and provide polymorphism. Furthermore, it is not clear how to add new features such as delegation in such systems. Other systems are object oriented or object based, including Chorus [Mar88], Apertos [Yok92], and Smalltalk <ref> [GR83] </ref>. However, none of these have addressed means of providing authentication and delegation. 2 Chapter 2 Background In this chapter we introduce terms and concepts used throughout the remainder of the thesis.
Reference: [iITT88] <author> CCITT (Consultative Committee in International Telegraphy and Telephony). </author> <title> Recommendation X.509: The Directory-Authentication Framework, </title> <year> 1988. </year>
Reference-contexts: The cornerstones of communication security | message authentication and key exchange | are well understood problems with numerous existing solutions <ref> [OR87, NS78, iITT88] </ref>. Unfortunately, these solutions are frequently implemented in such a way that they are inflexible and difficult for application developers to use. In this thesis, we present a design for a message authentication system that is both simple and extensible. <p> Other examples include the ISO security architecture <ref> [iITT88] </ref> and privacy-enhanced mail [KL89]. None of these systems were designed to facilitate application development, and most are based on a specific authentication protocol. Delegation has only relatively recently received much attention as large-scale distributed systems become more common. As a result the available literature is somewhat limited.
Reference: [Isl94] <author> Nayeem Islam. </author> <title> Customized Message Passing and Scheduling for Parallel and Distributed Applications. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: All system concepts are implemented as objects, from files to locks to device drivers. The system is composed of various subframeworks for managing a particular aspect of the system. There are subframe-works for file systems [Mad92], device drivers [Kou91], virtual memory management [Rus91], and the message passing system <ref> [Isl94] </ref>, among others. Each of these subframeworks includes multiple concrete implementations that deliver different performance or semantics. 5 The following subsections describe the framework for the message passing system 1 pictured in Figure 2.1.
Reference: [KL89] <author> S. Kent and J. Linn. </author> <title> RFC 1114: Privacy Enhancement for Internet Electronic Mail: Part II | Certificate-Based Key Management. </title> <institution> Internet Activities Board, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: Other examples include the ISO security architecture [iITT88] and privacy-enhanced mail <ref> [KL89] </ref>. None of these systems were designed to facilitate application development, and most are based on a specific authentication protocol. Delegation has only relatively recently received much attention as large-scale distributed systems become more common. As a result the available literature is somewhat limited.
Reference: [KN93] <author> J. Kohl and C. Neuman. </author> <title> RFC 1510: The Kerberos Network Authentication Service (V5), </title> <month> September </month> <year> 1993. </year>
Reference-contexts: Delegation has only relatively recently received much attention as large-scale distributed systems become more common. As a result the available literature is somewhat limited. Dele 1 gation has been considered for Kerberos <ref> [KN93] </ref> and DSSA [GM90], which led to our decision to compare our system to these. Other work includes a precursor to the Kerberos work [Sol88] and a good overview of delegation issues [VAB91]. <p> When authenticating individual messages, this port is used to perform the interactive zero-knowledge protocol. 3.3 Authentication Interface We now present the interfaces to the two subframeworks for authentication. We present the interface visible to applications and compare this with the interface used by Kerberos <ref> [KN93] </ref>, and then present the interface that protocols must adhere to. 3.3.1 Application Level Interface The message port interface visible to the application is only slightly extended from the old interface. The class definition in C++ of the old interface is given in Figure 3.6. <p> The application is guaranteed that only this principal will be capable of reading messages sent through the port. To emphasize the simplicity of this interface, we compare it to two commonly invoked procedures in Kerberos <ref> [KN93] </ref>. Kerberos is a popular package that provides message authentication using the symmetric-encryption variant of the Needham-Schroeder key exchange protocol. <p> We show how this design fits nicely on the framework for authentication, and then outline the interfaces this design uses. 21 4.1 Delegation Systems We present two actual systems based on the two variants of the Needham-Schroeder protocol that include delegation: Kerberos <ref> [KN93] </ref> and the Distributed Systems Security Architecture (DSSA) [GM90]. We then present a third delegation scheme called Passports [Sol88]. 4.1.1 Delegation in Kerberos Kerberos [SNS88] uses the Needham-Schroeder key exchange protocol with symmetric encryption to exchange session keys that are used for authentication. <p> We then present a third delegation scheme called Passports [Sol88]. 4.1.1 Delegation in Kerberos Kerberos [SNS88] uses the Needham-Schroeder key exchange protocol with symmetric encryption to exchange session keys that are used for authentication. The earlier version of Kerberos did not address delegation, but the current version <ref> [KN93] </ref> does include it. The Kerberos protocol uses tickets and authenticators to exchange session keys and verify freshness. Each ticket contains a session key, the identities of the principal and issuing authentication server, a validity period, and various flags. <p> The application-specific authorizations might permit access to only certain files or actions. The Kerberos documentation advises against using tickets with no addresses, though they are considered acceptable if they are proxies with authorization information. Such a ticket would serve as a capability <ref> [KN93] </ref> since any principal may use it. Tickets may be proxied multiple times unless the proxiable flag is disabled, allowing delegates to cascade a delegation. Additional authorization constraints can be placed on a proxiable ticket, though currently there is a fixed upper limit.
Reference: [Kou91] <author> Panagiotis Kougiouris. </author> <title> A Device Management Framework for an Object-Oriented Operating System. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: All system concepts are implemented as objects, from files to locks to device drivers. The system is composed of various subframeworks for managing a particular aspect of the system. There are subframe-works for file systems [Mad92], device drivers <ref> [Kou91] </ref>, virtual memory management [Rus91], and the message passing system [Isl94], among others. Each of these subframeworks includes multiple concrete implementations that deliver different performance or semantics. 5 The following subsections describe the framework for the message passing system 1 pictured in Figure 2.1.
Reference: [Lin90] <author> John Linn. </author> <title> Practical Authentication for Distributed Systems. </title> <booktitle> In Symposium on Research in Security and Privacy, </booktitle> <pages> pages 31-40. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: To maximize scalability the system uses the asymmetric version of the Needham-Schroeder key exchange protocol to establish secure and authenticated connections between principals. The certifying authorities may be structured hierarchically and the naming scheme used to identify each principal reflects the hierarchy of authorities that certify it <ref> [Lin90] </ref>. The system supports both delegations and roles [GM90], where roles serve to delineate the different set of authorizations a principal may use. For example, a system administrator may have two roles User and SuperUser but use the former role for normal cases to prevent accidental damage to the system.
Reference: [LM91] <author> X. Lai and J.L. Massey. </author> <title> A Proposal for a New Block Encryption Standard. </title> <booktitle> In Advances in Cryptology | Eurocrypt '90, </booktitle> <pages> pages 389-404, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: There are numerous symmetric encryption schemes to choose from with varying degrees of strength <ref> [oS77, LM91, Miy89] </ref>. The notation we use to denote the encryption of a message M with key K is fM g K . A commonly used protocol for key exchange using symmetric encryption is the Needham-Schroeder protocol given in Figure 3.2.
Reference: [Mad92] <author> Peter W. Madany. </author> <title> An Object-Oriented Framework for File Systems. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: All system concepts are implemented as objects, from files to locks to device drivers. The system is composed of various subframeworks for managing a particular aspect of the system. There are subframe-works for file systems <ref> [Mad92] </ref>, device drivers [Kou91], virtual memory management [Rus91], and the message passing system [Isl94], among others. Each of these subframeworks includes multiple concrete implementations that deliver different performance or semantics. 5 The following subsections describe the framework for the message passing system 1 pictured in Figure 2.1.
Reference: [Mar88] <author> J. L. Martins. </author> <title> The Design of the CHORUS Inter-process Communication Facility. </title> <booktitle> IFIP, </booktitle> <pages> pages 61-72, </pages> <year> 1988. </year>
Reference-contexts: None of these systems are able to benefit from object orientation to maximize code reuse and provide polymorphism. Furthermore, it is not clear how to add new features such as delegation in such systems. Other systems are object oriented or object based, including Chorus <ref> [Mar88] </ref>, Apertos [Yok92], and Smalltalk [GR83]. However, none of these have addressed means of providing authentication and delegation. 2 Chapter 2 Background In this chapter we introduce terms and concepts used throughout the remainder of the thesis.
Reference: [McE78] <author> R. </author> <title> McEliece. A Public-Key Cryptosystem Based on Algebraic Coding Theory. </title> <booktitle> In DSN Progress Report 42-44, </booktitle> <pages> pages 114-116. </pages> <institution> Jet Propulsion Laboratory, Pasadena, </institution> <address> CA, </address> <year> 1978. </year>
Reference-contexts: In particular, knowledge of the encryption key should reveal nothing about the decryption key. There are effectively only two asymmetric encryption systems with these properties, the RSA [RSA78] and McEliece <ref> [McE78] </ref> systems, though many more have been proposed and been shown to be unsecure. Since the McEliece system uses keys with size on the order 100 KBytes, only RSA is considered to be practical and is assumed throughout the remainder of this subsection.
Reference: [Miy89] <author> Shoji Miyaguchi. </author> <title> FEAL-N Specifications. </title> <type> Technical report, </type> <institution> NTT, </institution> <year> 1989. </year>
Reference-contexts: There are numerous symmetric encryption schemes to choose from with varying degrees of strength <ref> [oS77, LM91, Miy89] </ref>. The notation we use to denote the encryption of a message M with key K is fM g K . A commonly used protocol for key exchange using symmetric encryption is the Needham-Schroeder protocol given in Figure 3.2.
Reference: [Nie89] <author> Oscar Nierstrasz. </author> <title> A Survey of Object-Oriented Concepts. </title> <editor> In Won Kim and Freder-ick H. Lochovsky, editors, </editor> <booktitle> Object-Oriented Concepts, Databases, and Applications, </booktitle> <pages> pages 3-22. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: Early languages such as Fortran and Cobol suffered from numerous problems that limited maintainability and large-scale development. From these were born structured languages like Pascal, Algol and Modula which attempted to organize programs into more modular structures. Object orientation combines strict modularity with inheritance <ref> [Nie89] </ref> to facilitate reuse and maximize extensibility, maintainability, and portability. There are four features supported by object-oriented languages: encapsulation, data abstraction, inheritance, and polymorphism. Combined, these provide a powerful mechanism for design reuse. Each of these is described in detail below, with material drawn from [Nie89] and [Weg87]. 2.1.1 Encapsulation Decomposing <p> combines strict modularity with inheritance <ref> [Nie89] </ref> to facilitate reuse and maximize extensibility, maintainability, and portability. There are four features supported by object-oriented languages: encapsulation, data abstraction, inheritance, and polymorphism. Combined, these provide a powerful mechanism for design reuse. Each of these is described in detail below, with material drawn from [Nie89] and [Weg87]. 2.1.1 Encapsulation Decomposing programs into procedures increases code readability and maintainability, yet aside from simple functional procedures each procedure call will modify state information external to the procedure. This requires either numerous parameters to each procedure, or more commonly the procedure modifies global data.
Reference: [NS78] <author> Roger Needham and Michael Schroeder. </author> <title> Using Encryption for Authentication in Large Networks of Computers. </title> <journal> Communications of the ACM, </journal> <volume> 21(12) </volume> <pages> 993-999, </pages> <month> De-cember </month> <year> 1978. </year>
Reference-contexts: The cornerstones of communication security | message authentication and key exchange | are well understood problems with numerous existing solutions <ref> [OR87, NS78, iITT88] </ref>. Unfortunately, these solutions are frequently implemented in such a way that they are inflexible and difficult for application developers to use. In this thesis, we present a design for a message authentication system that is both simple and extensible. <p> An example of a two-tiered key-exchange protocol using asymmetric encryption is illustrated in Figure 3.3. This is a variation on the protocol devised by Needham and Schroeder <ref> [NS78] </ref>. The root authority is an entity trusted by every principal in the system. The root authority need not be on-line, though every principal must have a correct copy of its encryption key. The root authority certifies subordinate certifying authorities, which in turn certify principals.
Reference: [OR87] <author> D. Otway and O. Rees. </author> <title> Efficient and Timely Mutual Authentication. </title> <journal> ACM Operating Systems Review, </journal> <volume> 21(1) </volume> <pages> 8-10, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: The cornerstones of communication security | message authentication and key exchange | are well understood problems with numerous existing solutions <ref> [OR87, NS78, iITT88] </ref>. Unfortunately, these solutions are frequently implemented in such a way that they are inflexible and difficult for application developers to use. In this thesis, we present a design for a message authentication system that is both simple and extensible.
Reference: [oS77] <author> National Bureau of Standards. </author> <title> Data Encryption Standard. Federal Information Processing Standards Publication 46, NBS, </title> <address> Washington, D.C., </address> <month> January </month> <year> 1977. </year>
Reference-contexts: There are numerous symmetric encryption schemes to choose from with varying degrees of strength <ref> [oS77, LM91, Miy89] </ref>. The notation we use to denote the encryption of a message M with key K is fM g K . A commonly used protocol for key exchange using symmetric encryption is the Needham-Schroeder protocol given in Figure 3.2.
Reference: [oS80] <institution> National Bureau of Standards. DES Modes of Operation. Federal Information Processing Standards Publication 81, NBS, </institution> <address> Washington, D.C., </address> <month> December </month> <year> 1980. </year>
Reference-contexts: Subsequent sends and receives will use this session key to perform some message integrity check that is attached to the message. In our implementation, we attach a timestamp and a hash using DES in cipher-block chaining (CBC) mode <ref> [oS80] </ref> to prevent message alteration. 3.2.2.3 Zero-knowledge Design For protocols that are interactive in nature or more generally that require a request-response pattern to establish the initial connection or authentication messages, the design is essentially the same except for one difference.
Reference: [Ras86] <author> Richard Rashid. </author> <title> Threads of a New System. UNIX Review, </title> <year> 1986. </year>
Reference-contexts: Other work includes a precursor to the Kerberos work [Sol88] and a good overview of delegation issues [VAB91]. Current delegation systems have various tradeoffs in scalability, revocation and processing requirement; the method we present minimizes processing and enables frequent revocation. Other systems use message ports for communication, including Mach <ref> [Ras86] </ref> and V [Che88]. Anderson and Rangan have developed an authentication interface based on message ports, though it is incompatible with previous interfaces [AR87]. None of these systems are able to benefit from object orientation to maximize code reuse and provide polymorphism.
Reference: [RSA78] <author> R. Rivest, A. Shamir, and L. Adleman. </author> <title> A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. </title> <journal> Communications of the ACM, </journal> <volume> 21(2) </volume> <pages> 120-127, </pages> <month> February </month> <year> 1978. </year>
Reference-contexts: In particular, knowledge of the encryption key should reveal nothing about the decryption key. There are effectively only two asymmetric encryption systems with these properties, the RSA <ref> [RSA78] </ref> and McEliece [McE78] systems, though many more have been proposed and been shown to be unsecure. Since the McEliece system uses keys with size on the order 100 KBytes, only RSA is considered to be practical and is assumed throughout the remainder of this subsection.
Reference: [Rus91] <author> Vincent F. Russo. </author> <title> An Object-Oriented Operating System. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> January </month> <year> 1991. </year> <month> 35 </month>
Reference-contexts: represents a subframework and can be replaced by a concrete round-robin or priority-queue class, or similarly the standard virtual memory management can be extended to include distributed virtual memory. 4 2.2 The Choices Message-Passing System The Choices operating system is an object-oriented operating system developed at the University of Illinois <ref> [CIMR93, Rus91] </ref>. It is implemented in C++ [Str86] which provides the object-oriented features described previously with only minimal performance loss. All system concepts are implemented as objects, from files to locks to device drivers. The system is composed of various subframeworks for managing a particular aspect of the system. <p> All system concepts are implemented as objects, from files to locks to device drivers. The system is composed of various subframeworks for managing a particular aspect of the system. There are subframe-works for file systems [Mad92], device drivers [Kou91], virtual memory management <ref> [Rus91] </ref>, and the message passing system [Isl94], among others. Each of these subframeworks includes multiple concrete implementations that deliver different performance or semantics. 5 The following subsections describe the framework for the message passing system 1 pictured in Figure 2.1. <p> obtained from the distributed name server. 1 This framework was developed by Nayeem Islam as part of his research in customizable operating systems for parallel and distributed applications 6 2.2.3 Proxy Application-Kernel Interface Objects that are protected by the kernel may be exported to applications using the Choices proxy interface <ref> [Rus91] </ref>. A proxy is simply a surrogate for the kernel object with stub methods. Invoking a method on a proxy object causes a trap into the kernel, which is then dispatched to the proper kernel method. Parameter passing is handled automatically by the proxy system.
Reference: [SNS88] <author> Jennifer G. Steiner, Clifford Neuman, and Jeffrey I. Schiller. </author> <title> Kerberos: An Authen--tication Service for Open Network Systems. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 191-202, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: for mobile hosts that may move into a network domain that uses an unfamiliar protocol: by merely loading a new module the mobile system will be capable of participating in the new network. 1.2 Related work Numerous solutions for providing authentication and key exchange exist in the literature, including Kerberos <ref> [SNS88] </ref> and the Distributed System Security Architecture (DSSA) [GGKL89] that we will analyze in detail later. Other examples include the ISO security architecture [iITT88] and privacy-enhanced mail [KL89]. None of these systems were designed to facilitate application development, and most are based on a specific authentication protocol. <p> We then present a third delegation scheme called Passports [Sol88]. 4.1.1 Delegation in Kerberos Kerberos <ref> [SNS88] </ref> uses the Needham-Schroeder key exchange protocol with symmetric encryption to exchange session keys that are used for authentication. The earlier version of Kerberos did not address delegation, but the current version [KN93] does include it. The Kerberos protocol uses tickets and authenticators to exchange session keys and verify freshness.
Reference: [Sol88] <author> Karen R. Sollins. </author> <title> Cascaded Authentication. </title> <booktitle> In Symposium on Research in Security and Privacy, </booktitle> <pages> pages 156-163. </pages> <publisher> IEEE, </publisher> <year> 1988. </year>
Reference-contexts: As a result the available literature is somewhat limited. Dele 1 gation has been considered for Kerberos [KN93] and DSSA [GM90], which led to our decision to compare our system to these. Other work includes a precursor to the Kerberos work <ref> [Sol88] </ref> and a good overview of delegation issues [VAB91]. Current delegation systems have various tradeoffs in scalability, revocation and processing requirement; the method we present minimizes processing and enables frequent revocation. Other systems use message ports for communication, including Mach [Ras86] and V [Che88]. <p> We then present a third delegation scheme called Passports <ref> [Sol88] </ref>. 4.1.1 Delegation in Kerberos Kerberos [SNS88] uses the Needham-Schroeder key exchange protocol with symmetric encryption to exchange session keys that are used for authentication. The earlier version of Kerberos did not address delegation, but the current version [KN93] does include it. <p> listed on the ACL of the object as permitted delegates." This seems to violate the requirement that the delegator not know a priori which principals will use the delegation, though it could be used for revocation. 4.1.3 Delegation with Passports A technique for delegation using passports was developed by Sollins <ref> [Sol88] </ref>. Kerberos was based on this work, so the ideas are very similar. A passport is essentially the same as a 23 ticket in Kerberos though with slightly different information.
Reference: [Str86] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: Access to the state information of an object can be restricted by the compiler to only procedures listed in the object's interface. This facilitates the decomposition of a program into insulated components. The terminology we use throughout this thesis is adopted from C++ <ref> [Str86] </ref>. Each object has a set of methods or procedures that operate on member variables of the object. <p> It is implemented in C++ <ref> [Str86] </ref> which provides the object-oriented features described previously with only minimal performance loss. All system concepts are implemented as objects, from files to locks to device drivers. The system is composed of various subframeworks for managing a particular aspect of the system.
Reference: [VAB91] <author> Vijay Varadharajan, Phillip Allen, and Stewart Black. </author> <title> An Analysis of the Proxy Problem in Distributed Systems. </title> <booktitle> In Symposium on Research in Security and Privacy, </booktitle> <pages> pages 255-275. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: As a result the available literature is somewhat limited. Dele 1 gation has been considered for Kerberos [KN93] and DSSA [GM90], which led to our decision to compare our system to these. Other work includes a precursor to the Kerberos work [Sol88] and a good overview of delegation issues <ref> [VAB91] </ref>. Current delegation systems have various tradeoffs in scalability, revocation and processing requirement; the method we present minimizes processing and enables frequent revocation. Other systems use message ports for communication, including Mach [Ras86] and V [Che88]. <p> Using the above example, the entity A is the delegator and B is the delegate. Some of the issues that must be considered for a delegation system are presented below. The interested reader is referred to <ref> [VAB91] </ref> for more detail on some of these issues. Revocation After a delegation is issued, the delegator may at some later time lose trust in the delegate and desire to invalidate all delegations given to that delegate.
Reference: [Weg87] <author> Peter Wegner. </author> <title> Dimensions of Object-Based Language Design. </title> <booktitle> In Proceedings of OOPSLA '87, </booktitle> <pages> pages 168-183, </pages> <address> Orlando, Florida, </address> <month> October </month> <year> 1987. </year>
Reference-contexts: There are four features supported by object-oriented languages: encapsulation, data abstraction, inheritance, and polymorphism. Combined, these provide a powerful mechanism for design reuse. Each of these is described in detail below, with material drawn from [Nie89] and <ref> [Weg87] </ref>. 2.1.1 Encapsulation Decomposing programs into procedures increases code readability and maintainability, yet aside from simple functional procedures each procedure call will modify state information external to the procedure. This requires either numerous parameters to each procedure, or more commonly the procedure modifies global data.
Reference: [Yok92] <author> Yasuhiko Yokote. </author> <title> The Apertos Reflective Operating System: The Concept and Its Implementation. </title> <booktitle> In Proceedings of the 1992 International Conference on Object-Oriented Programming, Systems, Languages, and Applications, </booktitle> <month> October </month> <year> 1992. </year> <month> 36 </month>
Reference-contexts: None of these systems are able to benefit from object orientation to maximize code reuse and provide polymorphism. Furthermore, it is not clear how to add new features such as delegation in such systems. Other systems are object oriented or object based, including Chorus [Mar88], Apertos <ref> [Yok92] </ref>, and Smalltalk [GR83]. However, none of these have addressed means of providing authentication and delegation. 2 Chapter 2 Background In this chapter we introduce terms and concepts used throughout the remainder of the thesis.
References-found: 33

