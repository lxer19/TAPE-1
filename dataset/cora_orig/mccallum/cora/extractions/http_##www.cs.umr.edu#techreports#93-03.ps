URL: http://www.cs.umr.edu/techreports/93-03.ps
Refering-URL: http://www.cs.umr.edu/techreports/
Root-URL: 
Title: ENSURING VALUE LIVENESS of DISTRIBUTED SOFTWARE THROUGH CHANGELING  
Author: Grace Tsai, Matt Insall and Bruce McMillin 
Date: March 15, 1993  
Pubnum: CSC-93-03  
Abstract: This work was supported in part by the National Science Foundation under Grant Numbers MSS-9216479 and CDA-9222827, and, in part, from the Air Force Office of Scientific Research under contract number F49620-92-J-0546. Grace Tsai and Bruce McMillin are with the Department of Computer Science at the University of Missouri-Rolla, Rolla, MO 65401. Matt Insall is with the Department of Mathematics and Statistics at the University of Missouri-Rolla, Rolla, MO 65401. 
Abstract-found: 1
Intro-found: 1
Reference: [ClEm83] <author> Clarke, </author> <title> E.M., Emerson, E.A. and Sistla, A.P. ``Automatic Verification of Finite State Concurrent Systems Using Temporal Logic Specifications:A Practical Approach,'' </title> <booktitle> 10th annual ACM Symposium on Principles of Programming Language, </booktitle> <year> 1983, </year> <pages> pp. 117-126. </pages>
Reference-contexts: Among many mathematical models, we choose Interleaving Set Temporal Logic (ISTL * ) [KaPe88,PePn90], since it is capable of representing intermediate behavior of distributed programs. Traditionally, concurrent and distributed programs are verified using variants of temporal logics with interleaving semantics <ref> [ClEm83, ClEm86, MaPn82, MaPn89, HeMP90] </ref>. However, verification using sets of state sequences which represent the executions of a program is tedious and unnatural since all the possible interleavings of a program must be checked.
Reference: [ClEm86] <author> Clarke, E. M., Emerson, E. A. and Sistla, A. P. </author> <title> ``Automatic Verification of Finite State Concurrent Systems Using Temporal Logic Specification,'' </title> <journal> ACM Transactions on Programming Language and Systems, </journal> <volume> Vol. 8(2), </volume> <month> Apr. </month> <year> 1986, </year> <pages> pp. 244-263. </pages>
Reference-contexts: Among many mathematical models, we choose Interleaving Set Temporal Logic (ISTL * ) [KaPe88,PePn90], since it is capable of representing intermediate behavior of distributed programs. Traditionally, concurrent and distributed programs are verified using variants of temporal logics with interleaving semantics <ref> [ClEm83, ClEm86, MaPn82, MaPn89, HeMP90] </ref>. However, verification using sets of state sequences which represent the executions of a program is tedious and unnatural since all the possible interleavings of a program must be checked.
Reference: [HeMP90] <author> Henzinger, T.A., Manna, Z. and Pnueli, A. </author> <title> ``Temporal Proof Methodologies for Real-Time Systems,'' </title> <booktitle> 18th Annual ACM Symposium on Principles of Programming Language, </booktitle> <year> 1990, </year> <pages> pp. 353-366. </pages>
Reference-contexts: Among many mathematical models, we choose Interleaving Set Temporal Logic (ISTL * ) [KaPe88,PePn90], since it is capable of representing intermediate behavior of distributed programs. Traditionally, concurrent and distributed programs are verified using variants of temporal logics with interleaving semantics <ref> [ClEm83, ClEm86, MaPn82, MaPn89, HeMP90] </ref>. However, verification using sets of state sequences which represent the executions of a program is tedious and unnatural since all the possible interleavings of a program must be checked.
Reference: [Hoar69] <author> Hoare, C. </author> <title> ``An Axiomatic Basis for Computer Programming'', </title> <journal> Communications of the ACM, </journal> <volume> 12, 10, </volume> <year> 1969, </year> <pages> pp. 576-583. </pages>
Reference-contexts: Definition 3.5: Let T j denote the local counter of a process P j . The actions performed in the translation include updates of auxiliary variables, sending and receiving messages, which are described below. send (P j , t, u ): (P j !v, t) in CSP <ref> [Hoar69] </ref> notion, which denotes that a message with content u is sent to process P j at time T j = t with respect to the local counter T j of process P j . receive (P j , t, u ): (P j ?v, t) in CSP notion, which denotes
Reference: [KaPe87] <author> Katz, S. and Peled, D. </author> <title> ``Interleaving Set Temporal Logic,'' </title> <booktitle> 3rd Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1987, </year> <pages> pp. 178-190. </pages>
Reference-contexts: Thus, many attempts have been made to design a temporal logic with appropriate formalism for distributed programs. That is the partial order approach <ref> [KaPe87, PiWo84, Reis88, PePn90] </ref>, where the order is defined by the local events (events are executions of atomic operations) within a process and the events of sending and later receiving a message. All other events that are not related are arbitrary.
Reference: [KaPe88] <author> Katz, S. and Peled, D. </author> <title> ``An Efficient Verification Method for Parallel and Distributed Programs,'' </title> <booktitle> Lecture Notes in Computer Science 354, </booktitle> <year> 1988, </year> <pages> pp. 489-507. </pages>
Reference-contexts: These assertions can also serve as - 4 - expected behavior to monitor the run time behavior of a program. In the application to programs, an ISTL * <ref> [KaPe88, PePn90] </ref> structure corresponds to a computation (run) of a program and each (branching) structure denotes the global states of a single partial order as well as causal relations among these states. <p> Future research will examine executable assertions derived from responsiveness properties for the run time analysis of responsive computing systems. Appendix A. This appendix presents the proof rules of ISTL * ; for details the reader may refer to <ref> [KaPe88, PePn90] </ref>.
Reference: [KoSt74] <author> Kohler, W., and Steiglitz, K., </author> <title> ``Characterization and Theoretical Comparison of Branch-and-Bound Algorithms for Permutation Problems,'' </title> <journal> Journal of the ACM, </journal> <volume> Vol. 21, No. 1, </volume> <year> 1974, </year> <pages> pp. 140-156. </pages>
Reference-contexts: Thus, the optimization function f is the sum of manhattan distance of tiles plus the level of the tree. The following two theorems describe the properties of function f . Theorem 5.2: <ref> [KoSt74] </ref> Let s represent a minimal cost node according to the function f , where f is monotonically nondecreasing. Then s is an optimal node in the search space. Theorem 5.3: [LuSM92b] The optimization function f is monotonically nondecreasing as the level k increases.
Reference: [Lamp78] <author> Lamport, L., </author> <title> ``Time, Clocks and the Ordering of Events in a Distributed System,'' </title> <journal> Communications of the ACM, </journal> <volume> Vol. 21, No. 7, </volume> <year> 1978, </year> <pages> pp. 558-565. </pages>
Reference-contexts: The incorporation of logical clocks into the translation is to obtain a total ordering of all causally related events of the system, which is based on the concept of ``happened before'' relation <ref> [Lamp78] </ref>. To keep track of operations, each process must maintain a history that records all the operations performed and observed so far, which is defined below. <p> In other words, we may conclude the same assertions only if the communication events occur in the same order after the transformation. The arrival of messages in order after the transformation is guaranteed by the introduction of ``happened before'' relation. In the translation, we incorporate this notion from <ref> [Lamp78] </ref>, which defines a total ordering of all causally related events of distributed systems. For simplicity, within the proofs each transition is referenced by its name denoted below the arrow instead of its operation denoted above the arrow, as shown in Figure 3.2 and Figure 3.3. <p> ( pfiEFq) measure the validity of assertions at run time, hence, we embed them into the program to monitor the run time behavior of the program. 4.1 Faulty Clock Problem In the translation, each process maintains a logical clock which is updated based on the notion of ``happened before'' relation <ref> [Lamp78] </ref>. The incorporation of ``happened before'' relation into the - 13 - translation is to ensure that the arrival of messages is in order after the transformation. <p> Case 2: r j receives (t - k) instead of t. In the algorithm of <ref> [Lamp78] </ref>, the sending of a message is defined to be happened before the receiving of the same message. Thus, after the updates of T j the value of the clock T j is greater than that of the clock T i of the sending process r i . <p> For process r i , the clock T i has the value (t - 1) before the communication t n . If (t - k) is less than (t - 1), then an error has occurred. Otherwise, according to the algorithm <ref> [Lamp78] </ref> the clock T i is self-corrected and incremented correctly. Thus, the ordering of communication events are still maintained in spite of the occurrence of faulty clock value t. In other words, [ J , t n-1 xyt n zt n+1 ] = p.
Reference: [LuMc91b] <author> Lutfiyya, H. and McMillin, B. </author> <title> ``Formal Generation Of Executable Assertions For A Fault-Tolerant Parallel Matrix Relaxation,'' </title> <institution> UMR Department of Computer Science Technical Report CSC-91-13, </institution> <month> October, </month> <year> 1991. </year>
Reference-contexts: Without formal techniques, life-critical distributed computer control programs cannot be relied on to produce correct results, in time, and, in the presence of failures. Changeling provides a formal strategy for the integration of fault tolerance and distributed computing through executable assertions <ref> [LuMc91b, LuSM92, LuSM92a] </ref>. Within this framework, axiomatic proof system is chosen as the mathematical model and the assertions generated from the proof are translated into executable assertions which can detect errors in the presence of failures.
Reference: [LuSM92] <author> Lutfiyya, H., Schollmeyer, M., and McMillin, B., </author> <title> ``Fault-Tolerant Distributed Sort Generated from a Verification Proof Outline,'' 2nd Responsive Systems Symposium, </title> <note> Springer-Verlag (to appear). </note>
Reference-contexts: Without formal techniques, life-critical distributed computer control programs cannot be relied on to produce correct results, in time, and, in the presence of failures. Changeling provides a formal strategy for the integration of fault tolerance and distributed computing through executable assertions <ref> [LuMc91b, LuSM92, LuSM92a] </ref>. Within this framework, axiomatic proof system is chosen as the mathematical model and the assertions generated from the proof are translated into executable assertions which can detect errors in the presence of failures.
Reference: [LuSM92a] <author> Lutfiyya, H., Schollmeyer, M., and McMillin, B., </author> <title> ``Formal Generation of Executable Assertions for Application-Oriented Fault Tolerance,'' </title> <institution> UMR Department of Computer Science Technical Report CSC-92-15, Octo-ber, </institution> <year> 1992. </year> <month> - 23 </month> - 
Reference-contexts: Without formal techniques, life-critical distributed computer control programs cannot be relied on to produce correct results, in time, and, in the presence of failures. Changeling provides a formal strategy for the integration of fault tolerance and distributed computing through executable assertions <ref> [LuMc91b, LuSM92, LuSM92a] </ref>. Within this framework, axiomatic proof system is chosen as the mathematical model and the assertions generated from the proof are translated into executable assertions which can detect errors in the presence of failures. <p> In other words, a transformation that takes into account the distributed operational environment is necessary to convert value liveness assertions into executable assertions or run-time assertions. In the translation, we adopt a notion similar to that of HAA proof system <ref> [LuSM92a] </ref> to closely match the distributed operational environment. Each process maintains its own view of a system by a set of auxiliary variables that record process communications. Also, every process keeps track of its updates of auxiliary variables with respect to other processes.
Reference: [LuSM92b] <author> Lutfiyya, H., Sun, A., and McMillin, B., </author> <title> ``Fault-Tolerant Concurrent Branch and Bound Algorithm Derived from Program Verification,'' </title> <institution> UMR Department of Computer Science Technical Report CSC-92-12, </institution> <year> 1992. </year>
Reference-contexts: For our model problem of branch and bound N-puzzle, the best-first search strategy is assumed and an optimization function is applied to reduce exponential search space. The N-puzzle problem <ref> [Quin88, LuSM92b] </ref> is described below. - 14 - 8 0 4 2 0 6 8 3 1 board configuration has N+1 tile positions with N tiles distinctly numbered from 1 to N and one blank space denoted by 0. <p> The following two theorems describe the properties of function f . Theorem 5.2: [KoSt74] Let s represent a minimal cost node according to the function f , where f is monotonically nondecreasing. Then s is an optimal node in the search space. Theorem 5.3: <ref> [LuSM92b] </ref> The optimization function f is monotonically nondecreasing as the level k increases.
Reference: [Male90] <author> Malek, M., </author> <title> "Responsive Systems: A Challenge for the Nineties," Keynote Address, </title> <booktitle> Proc. EUROMICRO90, 16th Symp. in Microprocessing and Microprogramming, </booktitle> <address> Amersterdam, The Netherlands, </address> <publisher> North Holland, </publisher> <year> 1990, </year> <pages> pp. 9-16, pp. 622-628. </pages>
Reference-contexts: 1. INTRODUCTION A system is responsive <ref> [Male90] </ref> if it responds to internal programs or external inputs in a timely, dependable and predictable manner. It is a necessity for a responsive system to manage initiation and termination of activities to meet the specified timing constraints. <p> The incorporation of real-time and fault tolerance into distributed parallel environments is a challenging task, while the specifications of the distributed system must be met within the deadlines in spite of the presence of failures. However, this integrated system or responsive computer system <ref> [Male90] </ref> can greatly benefit from the application of formal methods. Without formal techniques, life-critical distributed computer control programs cannot be relied on to produce correct results, in time, and, in the presence of failures.
Reference: [MaPn82] <author> Manna, Z. and Pnueli, A., </author> <title> ``Verification of Concurrent Programs: The Temporal Proof Principles,`` </title> <booktitle> Lecture Notes in Computer Science 131, </booktitle> <year> 1982, </year> <pages> pp. 215-273. </pages>
Reference-contexts: Among many mathematical models, we choose Interleaving Set Temporal Logic (ISTL * ) [KaPe88,PePn90], since it is capable of representing intermediate behavior of distributed programs. Traditionally, concurrent and distributed programs are verified using variants of temporal logics with interleaving semantics <ref> [ClEm83, ClEm86, MaPn82, MaPn89, HeMP90] </ref>. However, verification using sets of state sequences which represent the executions of a program is tedious and unnatural since all the possible interleavings of a program must be checked.
Reference: [MaPn89] <author> Manna, Z. and Pnueli, A., </author> <title> ``Verification of Concurrent Programs: A Temporal Proof System,`` </title> <booktitle> Lecture Notes in Computer Science 354, </booktitle> <year> 1989. </year>
Reference-contexts: Among many mathematical models, we choose Interleaving Set Temporal Logic (ISTL * ) [KaPe88,PePn90], since it is capable of representing intermediate behavior of distributed programs. Traditionally, concurrent and distributed programs are verified using variants of temporal logics with interleaving semantics <ref> [ClEm83, ClEm86, MaPn82, MaPn89, HeMP90] </ref>. However, verification using sets of state sequences which represent the executions of a program is tedious and unnatural since all the possible interleavings of a program must be checked.
Reference: [Mili81] <author> Mili, A. </author> <title> ``Self-Checking Programs: An Axiomatization of Program Validation by Executable Assertions,'' </title> <booktitle> 11th Annual Int'l Symp. on Fault-Tolerant Computing, </booktitle> <year> 1981, </year> <pages> pp. 118-120. </pages>
Reference-contexts: A value liveness assertion of the form ( pfiEFq) states that every computation contains some state sequence (path) eventually satisfying the assertion q when starting from a state satisfying the assertion p. 3. THE TRANSLATION SCHEME <ref> [Mili81] </ref> adopted formal methods to obtain fault tolerance through software specified executable assertions, which shows that program verification is a viable starting point for generating assertions.
Reference: [PePn90] <author> Peled, D. and Pnueli, A. </author> <title> ``Proving Partial Order Liveness Properties,'' </title> <booktitle> 17th Colloquium on Automata, Language and Programming, edited by M.S. Peterson, </booktitle> <year> 1990, </year> <pages> pp. 553-571. </pages>
Reference-contexts: The value liveness assertion ( pfiEFq) ensures what values the program variables must possess eventually at a state with assertion q, starting from a state with assertion p. These assertions are derived from the temporal proof system of Interleaving Set Temporal Logic <ref> [PePn90] </ref>, and are used to reason about progress property from one communication point to another. This paper extends the work of - 3 - Changeling to create executable assertions that are, essentially, operational evaluation of value liveness assertions. <p> Thus, many attempts have been made to design a temporal logic with appropriate formalism for distributed programs. That is the partial order approach <ref> [KaPe87, PiWo84, Reis88, PePn90] </ref>, where the order is defined by the local events (events are executions of atomic operations) within a process and the events of sending and later receiving a message. All other events that are not related are arbitrary. <p> These assertions can also serve as - 4 - expected behavior to monitor the run time behavior of a program. In the application to programs, an ISTL * <ref> [KaPe88, PePn90] </ref> structure corresponds to a computation (run) of a program and each (branching) structure denotes the global states of a single partial order as well as causal relations among these states. <p> The following steps outline the translation scheme. (1) obtain value liveness assertions from temporal specifications: value liveness properties are derived from the proof system of Interleaving Set Temporal Logic (ISTL * ) <ref> [PePn90] </ref> which adopts partial order semantics, hence, providing a more suitable representation of concurrency than interleaving semantics does. (2) translate value liveness assertions into executable assertions: executable assertions demonstrate a programs expected behavior, since they are developed based on the definitions of the prob lems and the behavior they exhibit in <p> Auxiliary variables are used to communicate variables in the assertions, which allows processes to evaluate the satisfiability of the behaviors of other processes. Hence, we can avoid having a process test itself or do self-checking. Before describing the translation, the following definitions <ref> [PePn90] </ref> are needed. These definitions describe the history and the equivalence class of histories under partial order semantics. <p> Future research will examine executable assertions derived from responsiveness properties for the run time analysis of responsive computing systems. Appendix A. This appendix presents the proof rules of ISTL * ; for details the reader may refer to <ref> [KaPe88, PePn90] </ref>.
Reference: [PiWo84] <author> Pinter, S.S. and Wolper, P. </author> <title> ``A Temporal Logic for Reasoning about Partially Ordered Computations, </title> <booktitle> 3th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1984, </year> <pages> pp. 28-37. </pages>
Reference-contexts: Thus, many attempts have been made to design a temporal logic with appropriate formalism for distributed programs. That is the partial order approach <ref> [KaPe87, PiWo84, Reis88, PePn90] </ref>, where the order is defined by the local events (events are executions of atomic operations) within a process and the events of sending and later receiving a message. All other events that are not related are arbitrary.
Reference: [Quin88] <author> Quinn, M. J., </author> <title> Designing Efficient Algorithms for Parallel Computers, </title> <publisher> McGraw Hill, </publisher> <year> 1988, </year> <pages> pp. 185-195. </pages>
Reference-contexts: For our model problem of branch and bound N-puzzle, the best-first search strategy is assumed and an optimization function is applied to reduce exponential search space. The N-puzzle problem <ref> [Quin88, LuSM92b] </ref> is described below. - 14 - 8 0 4 2 0 6 8 3 1 board configuration has N+1 tile positions with N tiles distinctly numbered from 1 to N and one blank space denoted by 0.
Reference: [Reis88] <author> Reisig, W., </author> <title> "Toward a Temporal Logic for Casuality and Choice in Distributed Systems," </title> <editor> In J.W. de Bakker, W.P. Roever, and G. Rozen-burg, editors, </editor> <title> Models of Concur-rency:Linear, Branching and Partial Orders, </title> <address> LNCS354, </address> <year> 1988, </year> <pages> pp. 603-627. </pages>
Reference-contexts: Thus, many attempts have been made to design a temporal logic with appropriate formalism for distributed programs. That is the partial order approach <ref> [KaPe87, PiWo84, Reis88, PePn90] </ref>, where the order is defined by the local events (events are executions of atomic operations) within a process and the events of sending and later receiving a message. All other events that are not related are arbitrary.
References-found: 20

