URL: http://www-cs-faculty.stanford.edu/~koza/ep96.ps
Refering-URL: http://www-cs-faculty.stanford.edu/~koza/List1996.html
Root-URL: 
Email: EMAIL: Koza@Cs.Stanford.Edu  EMAIL: Andre@Flamingo.Stanford.Edu  
Title: Evolution of Iteration in Genetic Programming D a v d A The solution to many
Author: J o h n R K o a n d r 
Note: Work first presented at the Fourth Annual Conference on Evolutionary Programming in 1995 (EP-95) demonstrated that six then-new  branch out of a portion of an existing  should be part of the answer provided by an automated machine  
Date: ABSTRACT  
Web: WWW: http://www-cs-faculty.stanford.edu/~koza/  
Address: Stanford, California 94305-9020 USA  Stanford, California 94305 USA  
Affiliation: Computer Science Department Stanford University  e Visiting Scholar Computer Science Department Stanford University  
Abstract: This paper introduces the new operation of restricted iteration creation that automatically Genetic programming extends Holland's genetic algorithm to the task of automatic programming. Early work on genetic programming demonstrated that it is possible to evolve a sequence of work-performing steps in a single result-producing branch (that is, a one-part "main" program). The book Genetic Programming: On the Programming of Computers by Means of Natural Selection (Koza 1992) describes an extension of Holland's genetic algorithm in which the genetic population consists of computer programs (that is, compositions of primitive functions and terminals). See also Koza and Rice (1992). In the most basic form of genetic programming (where only a single result-producing branch is evolved), genetic programming demonstrated the capability to discover a sequence (as to both its length and its content) of work-performing steps that is sufficient to produce a satisfactory solution to several problems, including many problems that have been used over the years as benchmarks in machine learning and artificial intelligence. Before applying genetic programming to a problem, the user must perform five major preparatory steps, namely identifying the terminals (inputs) of the to-be-evolved programs, identifying the primitive functions (operations) contained in the to-be-evolved programs, creating the fitness measure for evaluating how well a given program does at solving the problem at hand, choosing certain control parameters (notably population size and number of generations to be run), and determining the termination criterion and method of result designation (typically the best-so-far individual from the populations produced during the run). creates a restricted iteration-performing
Abstract-found: 1
Intro-found: 0
Reference: <author> Andre, David (1994). </author> <title> Evolution of map making: Learning, planning, and memory using genetic programming. </title> <booktitle> Proceedings of the First IEEE Conference on Evolutionary Computation. </booktitle> <publisher> IEEE Press. </publisher> <editor> Volume I. </editor> <volume> 250255. </volume>
Reference: <author> Andre, David and Koza, John R. </author> <year> 1996. </year> <title> Parallel genetic programming: A scalable implementation using the transputer architecture. </title> <editor> In Angeline, Peter J. and Kinnear, Kenneth E. Jr. (editors). </editor> <booktitle> 1996. Advances in Genetic Programming 2. </booktitle> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher>
Reference-contexts: pre-specification by the user of the architecture consisting of three zero-argument automatically defined functions and one iteration-performing branch (ch. 18.10 and 18.11 of Koza 1994a), (3) the architecture-altering version using the six recently developed architecture-altering operations of branch duplication, argument duplication, branch deletion, argument deletion, branch creation, and argument creation <ref> (Koza and Andre 1996) </ref>. In this section, the new architecture-altering operation of restricted iteration creation is applied to the transmembrane segment identification problem. 4 . 1 . The Transmembrane Segment Identification Problem Proteins are polypeptide molecules composed of sequences of amino acids (Stryer 1995). <p> the user of the architecture consisting of three zero-argument automatically defined functions and one iteration-performing branch (ch. 18.10 and 18.11 of Koza 1994a), (5) the architecture-altering version using genetic programming employing the six recently developed operations of branch duplication, argument duplication, branch deletion, argument deletion, branch creation, and argument creation <ref> (Koza and Andre 1996) </ref>, and (6) the result using the new operation of restricted iteration creation (and the six recently developed architecture-altering operations), as described in this paper. Table 1 Comparison of eight methods.
Reference: <author> Engelman, D., Steitz, T., and Goldman, A. </author> <year> 1986. </year> <title> Identifying nonpolar transbilayer helices in amino acid sequences of membrane proteins. </title> <journal> Annual Review of Biophysics and Biophysiological Chemistry. </journal> <volume> Volume 15. </volume>
Reference: <author> Goldberg, David E. l989. </author> <title> Genetic Algorithms in Search, Optimization, </title> <booktitle> and Machine Learning. </booktitle> <address> Reading, MA: </address> <publisher> Addison-Wesley. </publisher>
Reference: <author> Holland, John H. </author> <year> 1975. </year> <title> Adaptation in Natural and Artificial Systems: An Introductory Analysis with Applications to Biology, Control, </title> <booktitle> and Artificial Intelligence. </booktitle> <address> Ann Arbor, MI: </address> <publisher> University of Michigan Press. (2nd ed. MIT Press 1992). </publisher>
Reference: <author> Koza, John R. </author> <year> 1992. </year> <title> Genetic Programming: On the Programming of Computers by Means of Natural Selection. </title> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Early work on genetic programming demonstrated that it is possible to evolve a sequence of work-performing steps in a single result-producing branch (that is, a one-part "main" program). The book Genetic Programming: On the Programming of Computers by Means of Natural Selection <ref> (Koza 1992) </ref> describes an extension of Holland's genetic algorithm in which the genetic population consists of computer programs (that is, compositions of primitive functions and terminals). See also Koza and Rice (1992). <p> The six one-argument setting functions, SETM0, SETM1, ... , SETM5, can be used to set the six settable memory variables, M 0, M 1, ... , M5 to a particular value. These setting functions operating on specific settable variables <ref> (Koza 1992, 1994a) </ref> are the simplest kind of memory used in genetic programming. Teller's indexed memory (1994) and Andre's memory maps (1994) illustrate more complex ways of incorporating state and memory into genetic programming.
Reference: <author> Koza, John R. </author> <year> 1994a. </year> <title> Genetic Programming II: Automatic Discovery of Reusable Programs. </title> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher>
Reference-contexts: In ordinary computer programs, subroutines provide a hierarchical mechanism to exploit, by reuse and parameterization, the regularities, symmetries, homogeneities, similarities, patterns, and modularities inherent in problem environments. Accordingly, Genetic Programming II: Automatic Discovery of Reusable Programs <ref> (Koza 1994a, 1994b) </ref> describes how to evolve multipart programs consisting of a main program and one or more reusable, parameterized, hierarchically-callable subprograms. <p> Genetic programming has been previously applied to three versions of this problem: (1) the set-creating version using genetic programming with pre-specification by the user of the architecture consisting of three zero-argument automatically defined functions and one iteration-performing branch <ref> (ch. 18.5 through 18.9 of Koza 1994a) </ref>, (2) the arithmetic-performing version using genetic programming with pre-specification by the user of the architecture consisting of three zero-argument automatically defined functions and one iteration-performing branch (ch. 18.10 and 18.11 of Koza 1994a), (3) the architecture-altering version using the six recently developed architecture-altering operations <p> by the user of the architecture consisting of three zero-argument automatically defined functions and one iteration-performing branch (ch. 18.5 through 18.9 of Koza 1994a), (2) the arithmetic-performing version using genetic programming with pre-specification by the user of the architecture consisting of three zero-argument automatically defined functions and one iteration-performing branch <ref> (ch. 18.10 and 18.11 of Koza 1994a) </ref>, (3) the architecture-altering version using the six recently developed architecture-altering operations of branch duplication, argument duplication, branch deletion, argument deletion, branch creation, and argument creation (Koza and Andre 1996). <p> Indurkhya 1993, (2) the result of Weiss, Cohen, and Indurkhya (1993) using a machine learning technique along with a considerable amount of human ingenuity, (3) the set-creating version using genetic programming with prespecification by the user of the architecture consisting of three zero-argument automatically defined functions and one iteration-performing branch <ref> (ch. 18.5 through 18.9 of Koza 1994a) </ref>, 4) the arithmetic-performing version using genetic programming with prespecification by the user of the architecture consisting of three zero-argument automatically defined functions and one iteration-performing branch (ch. 18.10 and 18.11 of Koza 1994a), (5) the architecture-altering version using genetic programming employing the six recently <p> by the user of the architecture consisting of three zero-argument automatically defined functions and one iteration-performing branch (ch. 18.5 through 18.9 of Koza 1994a), 4) the arithmetic-performing version using genetic programming with prespecification by the user of the architecture consisting of three zero-argument automatically defined functions and one iteration-performing branch <ref> (ch. 18.10 and 18.11 of Koza 1994a) </ref>, (5) the architecture-altering version using genetic programming employing the six recently developed operations of branch duplication, argument duplication, branch deletion, argument deletion, branch creation, and argument creation (Koza and Andre 1996), and (6) the result using the new operation of restricted iteration creation (and
Reference: <author> Koza, John R. </author> <year> 1994b. </year> <title> Genetic Programming II Videotape: The Next Generation. </title> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher>
Reference: <author> Koza, John R. </author> <year> 1995a. </year> <title> Evolving the architecture of a multipart program in genetic programming using architecture-altering operations. </title> <editor> In McDonnell, John R., Reynolds, Robert G., and Fogel, David B. (editors). </editor> <booktitle> 1995. Evolutionary Programming IV: Proceedings of the Fourth Annual Conference on Evolutionary Programming. </booktitle> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher> <pages> 695717. </pages>
Reference: <author> Koza, John R. and Andre, David. </author> <year> 1996. </year> <title> Classifying protein segments as transmembrane domains using architecture-altering operations in genetic programming. </title> <editor> Angeline, Peter and Kinnear, Kenneth E., Jr. (editors). </editor> <booktitle> 1996. Advances in Genetic Programming 2, </booktitle> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher>
Reference-contexts: pre-specification by the user of the architecture consisting of three zero-argument automatically defined functions and one iteration-performing branch (ch. 18.10 and 18.11 of Koza 1994a), (3) the architecture-altering version using the six recently developed architecture-altering operations of branch duplication, argument duplication, branch deletion, argument deletion, branch creation, and argument creation <ref> (Koza and Andre 1996) </ref>. In this section, the new architecture-altering operation of restricted iteration creation is applied to the transmembrane segment identification problem. 4 . 1 . The Transmembrane Segment Identification Problem Proteins are polypeptide molecules composed of sequences of amino acids (Stryer 1995). <p> the user of the architecture consisting of three zero-argument automatically defined functions and one iteration-performing branch (ch. 18.10 and 18.11 of Koza 1994a), (5) the architecture-altering version using genetic programming employing the six recently developed operations of branch duplication, argument duplication, branch deletion, argument deletion, branch creation, and argument creation <ref> (Koza and Andre 1996) </ref>, and (6) the result using the new operation of restricted iteration creation (and the six recently developed architecture-altering operations), as described in this paper. Table 1 Comparison of eight methods.
Reference: <author> Koza, John R., and Rice, James P. </author> <year> 1992. </year> <title> G e n e t i c Programming: The Movie. </title> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Early work on genetic programming demonstrated that it is possible to evolve a sequence of work-performing steps in a single result-producing branch (that is, a one-part "main" program). The book Genetic Programming: On the Programming of Computers by Means of Natural Selection <ref> (Koza 1992) </ref> describes an extension of Holland's genetic algorithm in which the genetic population consists of computer programs (that is, compositions of primitive functions and terminals). See also Koza and Rice (1992). <p> The six one-argument setting functions, SETM0, SETM1, ... , SETM5, can be used to set the six settable memory variables, M 0, M 1, ... , M5 to a particular value. These setting functions operating on specific settable variables <ref> (Koza 1992, 1994a) </ref> are the simplest kind of memory used in genetic programming. Teller's indexed memory (1994) and Andre's memory maps (1994) illustrate more complex ways of incorporating state and memory into genetic programming.
Reference: <author> Kyte, J. and Doolittle, R. </author> <year> 1982. </year> <title> A simple method for displaying the hydropathic character of proteins. </title> <journal> Journal of Molecular Biology. </journal> <volume> 157 </volume> <pages> 105-132. </pages>
Reference-contexts: M and V are hydrophobic on the Kyte-Dolittle hydrophobicity scale <ref> (Kyte and Dolittle 1982) </ref> and W is neutral. Note that this myopic program makes a decision for the entire protein segment (whose average length is 22) based on this manifestly inadequate test applied to a manifestly inadequate portion (only one residue) of the protein segment. 4.3.2.
Reference: <author> Samuel, Arthur L. </author> <year> 1959. </year> <title> Some studies in machine learning using the game of checkers. </title> <journal> IBM Journal of Research and Development. </journal> <volume> 3(3): </volume> <pages> 210229. </pages> <address> Stryer, Lubert. </address> <year> 1995. </year> <title> Biochemistry. </title> <address> New York, NY:W. </address> <publisher> H. Freeman. Fourth Edition. </publisher>
Reference-contexts: One of the most persistent and vexatious aspects of automated machine learning from the earliest times has been the requirement that the human user predetermine the size, shape, and character of the ultimate solution to the problem <ref> (Samuel 1959) </ref>. The size, shape, and character of the solution should be part of the answer provided by an automated machine learning technique, rather than part of the question supplied by the human user. 1 . 1 .
Reference: <author> Teller, A.. </author> <year> (1994). </year> <title> The evolution of mental models. </title> <editor> In Kinnear, K. E. Jr. (editor). </editor> <booktitle> Advances in Genetic Programming. </booktitle> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher> <editor> von Heijne, G. </editor> <year> 1992. </year> <title> Membrane protein structure prediction: Hydrophobicity analysis and the positive-inside rule. </title> <journal> Journal of Molecular Biology. </journal> <volume> 225:487 494. </volume>
Reference: <author> Weiss, S. M., Cohen, D. M., and Indurkhya, N. </author> <year> 1993. </year> <title> Transmembrane segment prediction from protein sequence data. </title> <editor> In Hunter, L., Searls, D., and Shavlik, J. (editors). </editor> <booktitle> Proceedings of the First International Conference on Intelligent Systems for Molecular Biology. </booktitle> <address> Menlo Park, CA: </address> <publisher> AAAI Press. </publisher>
Reference: <author> Wright, Sewall. </author> <year> 1943. </year> <title> Isolation by distance. Genetics 28:114138. </title>
Reference-contexts: The Power PC processors communicate by means of one INMOS transputer that is associated with each Power PC processor. The socalled distributed genetic algorithm or island model for parallelization (Goldberg l989) was used. That is, subpopulations <ref> (called demes after Wright 1943) </ref> were situated at the processing nodes of the system. Population size was Q = 1,000 at each of the D = 64 demes for a total population size of 64,000. The initial random subpopulations were created locally at each processing node.
Reference: <author> Yeagle, Philip L. </author> <year> 1993. </year> <title> The Membranes of Cells. Second edition. </title> <address> San Diego, CA: </address> <publisher> Academic Press. </publisher>
Reference-contexts: A transmembrane protein is embedded in a membrane (such as a cell membrane) in such a way that part of the protein is located on one side of the membrane, part is within the membrane, and part is on the opposite side of the membrane <ref> (Yeagle 1993) </ref>. Understanding the behavior of transmembrane proteins requires identification of the portion (s) of the protein sequence that are actually embedded within the membrane, such portion (s) being called the transmembrane domain (s) of the protein.
References-found: 17

