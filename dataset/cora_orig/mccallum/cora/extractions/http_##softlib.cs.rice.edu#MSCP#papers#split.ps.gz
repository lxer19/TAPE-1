URL: http://softlib.cs.rice.edu/MSCP/papers/split.ps.gz
Refering-URL: http://www.cs.rice.edu/MSCP/publications.html
Root-URL: 
Phone: 2  
Title: Live Range Splitting in a Graph Coloring Register Allocator  
Author: Keith D. Cooper and L. Taylor Simpson 
Address: Houston, Texas, USA  Austin, Texas, USA  
Affiliation: 1 Rice University,  Trilogy Development Group,  
Abstract: Graph coloring is the dominant paradigm for global register allocation [8, 7, 4]. Coloring allocators use an interference graph to model the conflicts that prevent two values from sharing a register. Nodes in the graph represent live ranges, or values. An edge between two nodes indicates that they are simultaneously live and, thus, cannot share a register. The allocator tries to construct a k-coloring of the graph, for k equal to the number of registers on the target machine. If it succeeds, it maps the k colors onto the k registers to produce an allocation. Unfortunately, it may not discover a k-coloring. In that case, it spills some live ranges by saving their values to memory. Early coloring allocators spilled live ranges completely at each definition and use. This approach often introduces more spill code than necessary. In this paper, we present a global approach to reducing spill code based on live range splitting. We are not the first to study this problem. Bergner et al. describe a heuristic called interference region spilling that reduces the amount of spill code necessary for spilled live ranges [1]. Briggs experimented with an aggressive form of live range splitting and saw mixed results [3, Chapter 6]. This paper presents a more passive form of live range splitting. The allocator uses splitting as an alternative to spilling. It looks for regions where splitting can break the interferences responsible for the spill; it uses estimated costs to choose between splitting the live range and spilling it. We present experimental evidence that this technique is effective. We have seen reductions in the amount of dynamic spill overhead as high as 78% for non-trivial routines. Because our splitting technique chooses between splitting and spilling on the basis of estimated costs, combining it with Bergner's technique will create an allocator that chooses the better spill strategy, on a live range by live range basis.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Peter Bergner, Peter Dahl, David Engebretsen, and Matthew O'Keefe. </author> <title> Spill code minimization via interference region spilling. </title> <journal> SIGPLAN Notices, </journal> <volume> 32(6) </volume> <pages> 287-295, </pages> <month> June </month> <year> 1997. </year> <booktitle> Proceedings of the ACM SIGPLAN '97 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: These methods reduce spills within a block that contains multiple references to the spilled value. They do nothing for problems that arise across multiple blocks. Bergner et al. introduced a technique called interference region spilling that takes a global approach to reducing the amount of spill code introduced <ref> [1] </ref>. Rather than spill a live range everywhere, their method chooses a color for the live range and only spills it in areas where that color is unavailable. The allocator picks a color for the spilled live range by estimating the costs that would be Fig. 1.
Reference: 2. <author> David Bernstein, Dina Q. Goldin, Martin C. Golumbic, Hugo Krawczyk, Yishay Mansour, Itai Nahshon, and Ron Y. Pinter. </author> <title> Spill code minimization techniques for optimizing compilers. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(7) </volume> <pages> 258-263, </pages> <month> July </month> <year> 1989. </year> <booktitle> Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Chaitin's basic scheme has been improved by other authors. Briggs et al. describe a variation on the coloring heuristic that increases the number of live ranges that can be colored [4, 5]. Bernstein et al. showed that different heuristics for choosing spill candidates can improve the results <ref> [2] </ref>. Even with these improvements, some routines still require spill code. The problem is not poor coloring; these routines simply need more registers than the hardware provides. Once it chooses a live range to spill, Chaitin's original scheme spills the value everywhere. <p> It places a store instruction after each definition of the value and a load instruction before each use of the value. Local heuristics exist to reduce the number of spill instructions inserted into a single basic block <ref> [7, 2] </ref>. These methods reduce spills within a block that contains multiple references to the spilled value. They do nothing for problems that arise across multiple blocks.
Reference: 3. <author> Preston Briggs. </author> <title> Register Allocation via Graph Coloring. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Chow used this observation in his priority-based coloring scheme; when his allocator encountered a live range that could not be kept in a register, it broke it into smaller pieces. Briggs experimented with an aggressive form of live range splitting in his Chaitin-style allocator <ref> [3, Chapter 6] </ref>. Prior to coloring, his aggressive splitting broke every live range into smaller parts; he added several mechanisms to the allocator that could recombine the smaller pieces when doing so would not cause a spill.
Reference: 4. <author> Preston Briggs, Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> Coloring heuristics for register allocation. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(7) </volume> <pages> 275-284, </pages> <month> July </month> <year> 1989. </year> <booktitle> Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: It inserts code to spill those values and tries to color the resulting, modified procedure. Chaitin's basic scheme has been improved by other authors. Briggs et al. describe a variation on the coloring heuristic that increases the number of live ranges that can be colored <ref> [4, 5] </ref>. Bernstein et al. showed that different heuristics for choosing spill candidates can improve the results [2]. Even with these improvements, some routines still require spill code. The problem is not poor coloring; these routines simply need more registers than the hardware provides. <p> Section 4 explains how to insert the code that splits a live range. 2 Briggs' Allocator Because our live range splitting procedure is an extension of a Briggs-style allocator, we will first provide an overview of that allocator. Figure 2 shows a flow chart of a Briggs-style allocator <ref> [4] </ref>. It is composed of seven major phases: Renumber The symbolic registers in the routine are renamed to create live ranges. A live range is a collection of definitions that reach a common use. <p> See Briggs et al. for a detailed discussion of this point <ref> [4, 5] </ref>. 5 In other words, the tiny live ranges left at definitions and uses of l j will continue to interfere with l i if and only if hl j ; l i i is an edge in the containment graph. Fig. 3. <p> Table 1 shows the results of our experiment. The Briggs column shows the number of spill instructions executed when the code is allocated using the Briggs-style allocator. Our version of the Briggs-style allocator includes optimistic coloring, rematerialization, and biased coloring <ref> [4, 5] </ref>. The Splits column shows the spill code executed using our splitting allocator. The Bergner column shows how Bergner et al.'s interference region spilling performs on the same code. In some cases, splitting produces a drastic reduction in the number of operations introduced for spilling.
Reference: 5. <author> Preston Briggs, Keith D. Cooper, and Linda Torczon. </author> <title> Rematerialization. </title> <journal> SIG-PLAN Notices, </journal> <volume> 27(7) </volume> <pages> 311-321, </pages> <month> July </month> <year> 1992. </year> <booktitle> Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: It inserts code to spill those values and tries to color the resulting, modified procedure. Chaitin's basic scheme has been improved by other authors. Briggs et al. describe a variation on the coloring heuristic that increases the number of live ranges that can be colored <ref> [4, 5] </ref>. Bernstein et al. showed that different heuristics for choosing spill candidates can improve the results [2]. Even with these improvements, some routines still require spill code. The problem is not poor coloring; these routines simply need more registers than the hardware provides. <p> See Briggs et al. for a detailed discussion of this point <ref> [4, 5] </ref>. 5 In other words, the tiny live ranges left at definitions and uses of l j will continue to interfere with l i if and only if hl j ; l i i is an edge in the containment graph. Fig. 3. <p> However, if a live range is rematerializ able <ref> [5] </ref>, we need only restore its value after each death. Fig. 5. Death along an edge in the CFG def B 1 H H Hj Fig. 6. <p> Table 1 shows the results of our experiment. The Briggs column shows the number of spill instructions executed when the code is allocated using the Briggs-style allocator. Our version of the Briggs-style allocator includes optimistic coloring, rematerialization, and biased coloring <ref> [4, 5] </ref>. The Splits column shows the spill code executed using our splitting allocator. The Bergner column shows how Bergner et al.'s interference region spilling performs on the same code. In some cases, splitting produces a drastic reduction in the number of operations introduced for spilling.
Reference: 6. <author> Steve Carr. </author> <title> Memory-Hierarchy Management. </title> <type> PhD thesis, </type> <institution> Rice University, Department of Computer Science, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: 82 putb 43 44 -2.33 38 getb 26 22 15.38 20 rffti1 24 19 20.83 20 slv2xy 11 9 18.18 11 pdiag 6 0 100.00 6 Our initial interest in this problem arose from several studies in which we examined code that resulted from automatic application of aggressive program transformations <ref> [10, 6, 14] </ref>. As these techniques become more widely applied, compilers will need to deal with their consequences. For this study, we focused on routines from the program wave5 in the SPEC95 benchmark suite.
Reference: 7. <author> Gregory J. Chaitin. </author> <title> Register allocation and spilling via graph coloring. </title> <journal> SIGPLAN Notices, </journal> <volume> 17(6) </volume> <pages> 98-105, </pages> <month> June </month> <year> 1982. </year> <booktitle> Proceedings of the ACM SIGPLAN '82 Symposium on Compiler Construction. </booktitle>
Reference-contexts: 1 Introduction Chaitin et al. first used graph coloring as a paradigm for register allocation and assignment in a compiler <ref> [8, 7] </ref>. <p> It places a store instruction after each definition of the value and a load instruction before each use of the value. Local heuristics exist to reduce the number of spill instructions inserted into a single basic block <ref> [7, 2] </ref>. These methods reduce spills within a block that contains multiple references to the spilled value. They do nothing for problems that arise across multiple blocks.
Reference: 8. <author> Gregory J. Chaitin, Marc A. Auslander, Ashok K. Chandra, John Cocke, Martin E. Hopkins, and Peter W. Markstein. </author> <title> Register allocation via coloring. </title> <journal> Computer Languages, </journal> <volume> 6(1) </volume> <pages> 47-57, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: 1 Introduction Chaitin et al. first used graph coloring as a paradigm for register allocation and assignment in a compiler <ref> [8, 7] </ref>.
Reference: 9. <author> Fred C. Chow and John L. Hennessy. </author> <title> Register allocation by priority-based coloring. </title> <journal> SIGPLAN Notices, </journal> <volume> 19(6) </volume> <pages> 222-232, </pages> <month> June </month> <year> 1984. </year> <booktitle> Proceedings of the ACM SIGPLAN '84 Symposium on Compiler Construction. </booktitle>
Reference-contexts: Chaitin-style allocators use maximal-length live ranges as the basic unit of allocation. It has long been recognized that breaking a live range into smaller pieces may allow some, or all, of the subsequent pieces to be colored <ref> [13, 9] </ref>. Chow used this observation in his priority-based coloring scheme; when his allocator encountered a live range that could not be kept in a register, it broke it into smaller pieces. Briggs experimented with an aggressive form of live range splitting in his Chaitin-style allocator [3, Chapter 6].
Reference: 10. <author> Keith D. Cooper, Mary W. Hall, and Linda Torczon. </author> <title> An experiment with inline substitution. </title> <journal> Software Practice and Experience, </journal> <volume> 21(6) </volume> <pages> 581-601, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: 82 putb 43 44 -2.33 38 getb 26 22 15.38 20 rffti1 24 19 20.83 20 slv2xy 11 9 18.18 11 pdiag 6 0 100.00 6 Our initial interest in this problem arose from several studies in which we examined code that resulted from automatic application of aggressive program transformations <ref> [10, 6, 14] </ref>. As these techniques become more widely applied, compilers will need to deal with their consequences. For this study, we focused on routines from the program wave5 in the SPEC95 benchmark suite.
Reference: 11. <author> Keith D. Cooper, Timothy J. Harvey, and Linda Torczon. </author> <title> How to build an interference graph. </title> <note> Software-Practice and Experience (to appear), 1997. Available on the web at http://softlib.rice.edu/MSCP/publications.html. </note>
Reference-contexts: The containment graph is no harder to build than the lower-triangular bit-matrix. 2. A bit matrix may be space inefficient for the containment graph. A recent study of techniques for building the interference graph showed that a closed hash table implementation can use less space for sufficiently large graphs <ref> [11] </ref>. The containment graph should reach that threshold much earlier than the lower-triangular bit-matrix. Taken together, these suggestions should reduce the space impact of building the containment graph rather than an undirected interference graph.
Reference: 12. <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> An efficient method of computing static single assignment form. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 25-35, </pages> <address> Austin, Texas, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: It is composed of seven major phases: Renumber The symbolic registers in the routine are renamed to create live ranges. A live range is a collection of definitions that reach a common use. Briggs accomplishes this renumbering by converting the routine to pruned static single assignment form <ref> [12] </ref> and then combining all names mentioned in each -node. Build The interference graph contains a node for each live range and an edge between each pair of live ranges that are simultaneously live. The graph is represented by both a triangular bit matrix and a collection of adjacency lists.
Reference: 13. <author> Janet Fabri. </author> <title> Automatic storage optimization. </title> <journal> SIGPLAN Notices, </journal> <volume> 14(8) </volume> <pages> 83-91, </pages> <month> August </month> <year> 1979. </year> <booktitle> Proceedings of the ACM SIGPLAN '79 Symposium on Compiler Construction. </booktitle>
Reference-contexts: Chaitin-style allocators use maximal-length live ranges as the basic unit of allocation. It has long been recognized that breaking a live range into smaller pieces may allow some, or all, of the subsequent pieces to be colored <ref> [13, 9] </ref>. Chow used this observation in his priority-based coloring scheme; when his allocator encountered a live range that could not be kept in a register, it broke it into smaller pieces. Briggs experimented with an aggressive form of live range splitting in his Chaitin-style allocator [3, Chapter 6].
Reference: 14. <author> Todd C. Mowry, Monica S. Lam, and Anoop Gupta. </author> <title> Design and evaluation of a compiler algorithm for prefetching. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(9) </volume> <pages> 62-75, </pages> <month> September </month> <year> 1992. </year> <title> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems. This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: 82 putb 43 44 -2.33 38 getb 26 22 15.38 20 rffti1 24 19 20.83 20 slv2xy 11 9 18.18 11 pdiag 6 0 100.00 6 Our initial interest in this problem arose from several studies in which we examined code that resulted from automatic application of aggressive program transformations <ref> [10, 6, 14] </ref>. As these techniques become more widely applied, compilers will need to deal with their consequences. For this study, we focused on routines from the program wave5 in the SPEC95 benchmark suite. <p> As these techniques become more widely applied, compilers will need to deal with their consequences. For this study, we focused on routines from the program wave5 in the SPEC95 benchmark suite. These routines had been transformed by the insertion of advisory prefetch instructions intended to improve cache behavior <ref> [14] </ref>. The transformations increased register pressure to the point where spilling was a recognizable performance problem, even on a machine with thirty-two integer and thirty-two floating-point registers. Table 1 shows the results of our experiment.
References-found: 14

