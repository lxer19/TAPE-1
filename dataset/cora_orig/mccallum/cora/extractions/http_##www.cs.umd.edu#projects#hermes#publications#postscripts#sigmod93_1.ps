URL: http://www.cs.umd.edu/projects/hermes/publications/postscripts/sigmod93_1.ps
Refering-URL: http://www.cs.umd.edu/projects/hermes/publications/abstracts/mvi.html
Root-URL: 
Email: agupta@cs.stanford.edu  mumick@research.att.com  vs@cs.umd.edu  
Title: Maintaining Views Incrementally Extended Abstract  
Author: Ashish Gupta Inderpal Singh Mumick V.S. Subrahmanian 
Note: This work was supported by NSF grants IRI-91-16646 and IRI-90-16358, and ARO DAAL-03-G-0177. This work was supported by ARO grant DAAL-03-92-G-0225, and NSF grant IRI-9109755, and AFOSR grant F49620-93-1-0065.  
Affiliation: Stanford University  AT&T Bell Laboratories  University of Maryland  
Abstract: We present incremental evaluation algorithms to compute changes to materialized views in relational and deductive database systems, in response to changes (insertions, deletions, and updates) to the relations. The view definitions can be in SQL or Datalog, and may use UNION, negation, aggregation (e.g. SUM, MIN), linear recursion, and general recursion. We first present a counting algorithm that tracks the number of alternative derivations (counts) for each derived tuple in a view. The algorithm works with both set and duplicate semantics. We present the algorithm for nonrecursive views (with negation and aggregation), and show that the count for a tuple can be computed at little or no cost above the cost of deriving the tuple. The algorithm is optimal in that it computes exactly those view tuples that are inserted or deleted. Note that we store only the number of derivations, not the derivations themselves. We then present the Delete and Rederive algorithm, DRed, for incremental maintenance of recursive views (negation and aggregation are permitted). The algorithm works by first deleting a superset of the tuples that need to be deleted, and then rederiving some of them. The algorithm can also be used when the view definition is itself altered. 
Abstract-found: 1
Intro-found: 1
Reference: [ABW88] <author> Krzysztof R. Apt, Howard A. Blair, and Adrian Walker. </author> <title> Towards a Theory of Declarative Knowledge. In Foundations of Deductive Databases and Logic Programming. </title> <editor> Editor J. Minker, </editor> <publisher> 1988 Mor-gan Kaufmann. </publisher>
Reference-contexts: They do not discuss how to handle recursively defined relations that are derivable in infinitely many iterations, and do not handle aggregation. 3 Notation We use Datalog, mostly as discussed in [Ull89], extended with stratified negation <ref> [VG86, ABW88] </ref>, and stratified aggregation [Mum91]. Datalog extended with stratified negation and aggregation can be mapped to a class of recursive SQL queries, and vice versa [Mum91]. We chose Datalog syntax over SQL syntax for conciseness. <p> We chose Datalog syntax over SQL syntax for conciseness. Definition 3.1 Stratum Numbers (SN) and Rule Stratum Number (RSN): Stratum numbers are assigned as follows: Construct a reduced dependency graph (RDG) of the given program by collapsing every strongly connected component (scc) of the dependency graph (as defined by <ref> [ABW88] </ref>) to a single node. A RDG is guaranteed to be acyclic. A topological sort of the RDG assigns a stratum number to each node. If a node represents a scc, all predicates in the scc are assigned the stratum number of the node.
Reference: [BC79] <author> Peter O. Buneman and Eric K. Clemons. </author> <title> Efficiently Monitoring Relational Databases. </title> <journal> In ACM TODS, </journal> <volume> Vol 4, No. 3, </volume> <year> 1979, </year> <pages> 368-382. </pages>
Reference: [BCL89] <author> J. A. Blakeley, N. Coburn, and P. Larson. </author> <title> Updating Derived Relations: Detecting Irrelevant and Autonomously Computable Updates. </title> <journal> In ACM TODS Vol 14, </journal> <volume> No. 3, </volume> <pages> 369-400, </pages> <year> 1989. </year>
Reference: [BLR91] <author> Veronique Benzaken, Christophe Lecluse, and Philippe Richard. </author> <title> Enforcing Integrity Constraints in Database Programming Languages. </title> <type> TR Altair 68-91, </type> <institution> Altair, France, </institution> <year> 1991. </year>
Reference: [BLT86] <author> J. A. Blakeley, P. Larson, and F. W. Tompa. </author> <title> Efficiently Updating Materialized Views. </title> <booktitle> In SIGMOD 1986, </booktitle> <pages> pages 61-71. </pages>
Reference-contexts: Their algorithm depends on keys, and cannot be used if the view does not contain the key attributes of a base relation. Qian and Wiederhold [QW91] use algebraic operations to derive the minimal relational expression that computes the change to select-project-join views. The algorithms by Blakeley et. al. <ref> [BLT86] </ref> and Nicolas and Yazdanian (The BD-GEN system [NY83]) are perhaps most closely related to our counting algorithm. Blakeley's algorithm is a special case of the counting algorithm applied to select-project-join expressions (no negation, aggregation, or recursion).
Reference: [BMM92] <author> F. Bry, R. Manthey, and B. Martens. </author> <title> Integrity Verification in Knowledge Bases. </title> <booktitle> In Logic Programming, LNAI 592, </booktitle> <pages> pages 114-139, </pages> <year> 1992. </year>
Reference: [BT88] <author> J. A. Blakeley and F. W. Tompa. </author> <title> Maintaining Materialized Views without Accessing Base Data. </title> <journal> Information Systems, </journal> <volume> 13(4) </volume> <pages> 393-406, </pages> <year> 1988. </year>
Reference: [CW91] <author> Stefano Ceri and Jennifer Widom. </author> <title> Deriving Production Rules for Incremental View Maintenance. </title> <booktitle> In 17th VLDB, </booktitle> <year> 1991. </year>
Reference-contexts: Section 6 explains how negation and aggregation are handled by the counting algorithm of Section 4. Section 7 discusses the DRed algorithm for maintaining general recursive views. The results are summarized in Section 8. 2 Related Work Ceri and Widom <ref> [CW91] </ref> describe a strategy to efficiently update views defined in a subset of SQL 2 without negation, aggregation, and duplicate seman-tics. Their algorithm depends on keys, and cannot be used if the view does not contain the key attributes of a base relation.
Reference: [CW92] <author> Stefano Ceri and Jennifer Widom. </author> <title> Deriving Incremental Production Rules for Deductive Data. </title> <type> IBM RJ 9071, </type> <institution> IBM Almaden, </institution> <year> 1992. </year>
Reference-contexts: Alternative derivations of t are not considered. Semi-naive therefore computes an overestimate of the tuples that actually need to be deleted. The DRed algorithm refines this 2 The DRed algorithm is similar to an algorithm developed independently, and at the same time as our work, by Ceri and Widom <ref> [CW92] </ref>, though their algorithm is presented in a production rule framework, and they don't handle aggregation and insertions/deletions of rules. 8 overestimate by considering alternative derivations of the deleted tuples (in the overestimate) as follows: 1.
Reference: [DAJ91] <author> S. Dar, R. Agrawal, and H. V. Jagadish. </author> <title> Optimization of generalized transitive closure. </title> <booktitle> In Seventh IEEE International Conference on Data Engineering, </booktitle> <address> Kobe, Japan, </address> <year> 1991. </year>
Reference-contexts: Using the old tuple T c and the tuples in (U ), the new tuple corresponding to the groupby attribute value c can be computed incrementally for each of the aggregate functions MIN, MAX, COUNT, SUM, and for any other incrementally computable function <ref> [DAJ91] </ref>. For instance consider the aggregation operation SUM. The sum of the attribute A of the tuples in a group can be computed using the old sum when a new tuple is added to the group by adding :A to the old sum. <p> = 1. (T ) = (T ) ] f (T y -; 1)g % Insert new % T y into (T ) with a count = 1. % Else the aggregate tuple is unchanged % and nothing needs to be done. 3 If the aggregation function is not incrementally computable <ref> [DAJ91] </ref>, and is not even decomposable into incrementally computable functions, then the computation of T y maybe more expensive. For non incrementally computable aggregate functions, the tuple T y has to be computed using the tuples of relation U that have the value y for the variables Y .
Reference: [DS92] <author> Guozhu Dong and Jianwen Su. </author> <title> Incremental and Decremental Evaluation of Transitive Closure by First-Order Queries. </title> <type> TRCS 92-18, </type> <institution> University of California, Santa Barbara, </institution> <year> 1992. </year>
Reference-contexts: Kuchen-hoff's algorithm needs to store auxiliary relations, and fragments computation in a manner similar to the PF algorithm. Dong and Topor [DT92] derive nonrecursive programs to update right-linear chain views in response to insertions only. Dong and Su <ref> [DS92] </ref> give nonrecur-sive transformations to update the transitive closure of specific kinds of graphs in response to insertions and deletions. The algorithm does not apply to all graphs or to general recursive programs. They also need auxiliary derived relations, and cannot handle negation and aggregation.
Reference: [DT92] <author> Guozhu Dong and Rodney Topor. </author> <title> Incremental Evaluation of Datalog Queries. </title> <booktitle> In ICDT, </booktitle> <year> 1992. </year>
Reference-contexts: Kuchen-hoff's algorithm needs to store auxiliary relations, and fragments computation in a manner similar to the PF algorithm. Dong and Topor <ref> [DT92] </ref> derive nonrecursive programs to update right-linear chain views in response to insertions only. Dong and Su [DS92] give nonrecur-sive transformations to update the transitive closure of specific kinds of graphs in response to insertions and deletions. The algorithm does not apply to all graphs or to general recursive programs.
Reference: [GKM92] <author> Ashish Gupta, Dinesh Katiyar, and Inderpal Singh Mumick. </author> <title> Counting Solutions to the View Maintenance Problem. </title> <booktitle> In Workshop on Deductive Databases, JICSLP, </booktitle> <year> 1992. </year>
Reference-contexts: Conversely, we note that the counting algorithm can also be used to incrementally maintain certain recursive views <ref> [GKM92] </ref>. A semi-naive [Ull89] computation is sufficient to compute new inserted tuples for a recursively defined view when insertions are made to base relations.
Reference: [GMS92] <author> Ashish Gupta, Inderpal Singh Mumick, and V. S. Subrahmanian. </author> <title> Maintaining views incrementally. </title> <type> TR 921214-19-TM, </type> <institution> AT&T Bell Labs, </institution> <year> 1992. </year>
Reference-contexts: The + -rules are applied until no new inserted facts are derived. This three step process is formalized as an algorithm, and proved correct, in <ref> [GMS92] </ref>. A recursive program P can be fragmented into programs P 1 ; : : : ; P n , where P i = fr j RSN (r) = ig constitutes stratum i. <p> The details of the algorithm are given in <ref> [GMS92] </ref>. 8 Conclusions and Future Work We have presented general techniques for maintaining views in relational and deductive databases, including SQL with duplicate semantics, when view definitions include negation, aggregation and general recursion.
Reference: [HD92] <author> John V. Harrison and Suzanne Dietrich. </author> <title> Maintenance of Materialized Views in a Deductive Database: An Update Propagation Approach. </title> <booktitle> In Workshop on Deductive Databases, JICSLP, </booktitle> <year> 1992. </year>
Reference-contexts: Kuchenhoff [Kuc91] and Harrison and Dietrich (the PF algorithm <ref> [HD92] </ref>) discuss recursive view maintenance algorithms related to our rederivation algorithm. Both of these algorithms cannot handle aggregation (we can).
Reference: [ISO90] <author> ISO ANSI. </author> <note> ISO-ANSI Working Draft: Database Language SQL2 and SQL3; X3H2; ISO/IEC JTC1/SC21/WG3, </note> <year> 1990. </year>
Reference-contexts: We first consider database systems that implement duplicate semantics, such as DB2 and SQL/DS from IBM, and Nonstop SQL from Tandem. The query language SQL in the above systems requires duplicates to be retained for semantic correctness <ref> [ISO90] </ref>. In an implementation, duplicates may be represented either by keeping multiple copies of a tuple, or by keeping a count with each tuple. In both cases, our algorithm works without incurring any overhead due to duplicate computation.
Reference: [Kuc91] <author> V. Kuchenhoff. </author> <title> On the Efficient Computation of the Difference Between Consecutive Database States. </title> <booktitle> In DOOD, LNCS 566, </booktitle> <year> 1991. </year>
Reference-contexts: Thus the BDGEN counts, unlike our counts, do not correspond to the number of derivations of a tuple, are more expensive to compute, and the BDGEN algorithm cannot be used with (SQL) duplicate semantics or with aggregation, while our algorithm can be. Kuchenhoff <ref> [Kuc91] </ref> and Harrison and Dietrich (the PF algorithm [HD92]) discuss recursive view maintenance algorithms related to our rederivation algorithm. Both of these algorithms cannot handle aggregation (we can).
Reference: [MS93a] <author> Inderpal Singh Mumick and Oded Shmueli. </author> <title> Finiteness Properties of Database Queries. </title> <booktitle> In Fourth Australian Database Conference, </booktitle> <year> 1993. </year>
Reference-contexts: We call this number count (t). count (t) is derived from the multiplicity of tuple t under duplicate semantics, as defined in [Mum91] for positive programs and in <ref> [MS93a] </ref> for programs with stratified negation. Given a program T defining a set of views V 1 ; : : : ; V k , the counting algorithm derives a program T at compile time. <p> Nonrecursive programs are always stratified. The following Example 6.1 gives the intuition for computing counts with negated subgoals. A negated subgoal is computed in the same way for both set and duplicate semantics. 1 1 Formal semantics of Duplicate Datalog with negation is given in <ref> [MS93a] </ref> 6 Example 6.1 Consider view only tri hop that uses views tri hop and hop as defined in Example 4.2. only tri hop contains all pairs of nodes that are connected using three links but not using just two. (v3): only tri hop (X; Y ) :- tri hop (X; <p> This estimate is refined to obtain an exact answer. New derived tuples are computed subsequently. Counting can be used to maintain recursive views also. However computing counts for recursive views is expensive and furthermore counting may not terminate on some views. Techniques to detect finiteness <ref> [MS93a] </ref> and to use partial derivations for counting are being explored. Similarly DRed can be used for nonrecursive views also but it is less efficient than counting. The techniques to handle negation and aggregation as described in this paper can be used to extend many other existing view maintenance techniques.
Reference: [Mum91] <author> Inderpal Singh Mumick. </author> <title> Query Optimization in Deductive and Relational Databases. </title> <type> Ph.D. Thesis, </type> <institution> Stanford University, </institution> <address> CA 94305, </address> <year> 1991. </year>
Reference-contexts: We call this number count (t). count (t) is derived from the multiplicity of tuple t under duplicate semantics, as defined in <ref> [Mum91] </ref> for positive programs and in [MS93a] for programs with stratified negation. Given a program T defining a set of views V 1 ; : : : ; V k , the counting algorithm derives a program T at compile time. <p> They do not discuss how to handle recursively defined relations that are derivable in infinitely many iterations, and do not handle aggregation. 3 Notation We use Datalog, mostly as discussed in [Ull89], extended with stratified negation [VG86, ABW88], and stratified aggregation <ref> [Mum91] </ref>. Datalog extended with stratified negation and aggregation can be mapped to a class of recursive SQL queries, and vice versa [Mum91]. We chose Datalog syntax over SQL syntax for conciseness. <p> derivable in infinitely many iterations, and do not handle aggregation. 3 Notation We use Datalog, mostly as discussed in [Ull89], extended with stratified negation [VG86, ABW88], and stratified aggregation <ref> [Mum91] </ref>. Datalog extended with stratified negation and aggregation can be mapped to a class of recursive SQL queries, and vice versa [Mum91]. We chose Datalog syntax over SQL syntax for conciseness. <p> Theorem 6.1 Algorithm 4.1 works correctly in the presence of negated subgoals. 2 6.2 Aggregation Aggregation is often used to reduce large amounts of data to more usable form. In this section we use the semantics for aggregation as discussed in <ref> [Mum91] </ref>. The following example illustrates the notation and semantics. Example 6.2 Consider the relation link from Example 1.1 and let tuples in link also have a cost associated with them, i.e. link (s; d; c) represents a link from source s to destination d of cost c.
Reference: [NY83] <author> J. M. Nicolas and Yazdanian. </author> <title> An Outline of BDGEN: A Deductive DBMS. </title> <booktitle> In Information Processing, </booktitle> <pages> pages 705-717, </pages> <year> 1983. </year>
Reference-contexts: Qian and Wiederhold [QW91] use algebraic operations to derive the minimal relational expression that computes the change to select-project-join views. The algorithms by Blakeley et. al. [BLT86] and Nicolas and Yazdanian (The BD-GEN system <ref> [NY83] </ref>) are perhaps most closely related to our counting algorithm. Blakeley's algorithm is a special case of the counting algorithm applied to select-project-join expressions (no negation, aggregation, or recursion).
Reference: [QW91] <author> Xiaolei Qian and Gio Wiederhold. </author> <title> Incremental Recomputation of Active Relational Expressions. </title> <journal> In ACM TKDE, </journal> <year> 1991. </year>
Reference-contexts: Their algorithm depends on keys, and cannot be used if the view does not contain the key attributes of a base relation. Qian and Wiederhold <ref> [QW91] </ref> use algebraic operations to derive the minimal relational expression that computes the change to select-project-join views. The algorithms by Blakeley et. al. [BLT86] and Nicolas and Yazdanian (The BD-GEN system [NY83]) are perhaps most closely related to our counting algorithm.
Reference: [RS93] <author> Torre Risch and Martin Skold. </author> <title> Active rules based on object-oriented queries. To Appear, </title> <journal> ACM TKDE, </journal> <year> 1993. </year>
Reference-contexts: View maintenance has applications in integrity constraint maintenance, index maintenance in object-oriented databases (define the index between attributes of interest as a view), persistent queries, active database <ref> [SPAM91, RS93] </ref> (a rule may fire when a particular tuple is inserted into a view). We present two algorithms, counting and DRed, for incremental maintenance of a large class of views.
Reference: [SI84] <author> Oded Shmueli and Alon Itai. </author> <title> Maintenance of Views. </title> <booktitle> In Sigmod Record, </booktitle> <volume> 14(2) </volume> <pages> 240-255, </pages> <year> 1984. </year>
Reference: [SPAM91] <author> Ulf Schreier, Hamid Pirahesh, Rakesh Agrawal, and C. Mohan. Alert: </author> <title> An Architecture for Transforming a Passive DBMS Into an Active DBMS. </title> <booktitle> In 17th VLDB, </booktitle> <pages> pages 469-478, </pages> <year> 1991. </year>
Reference-contexts: View maintenance has applications in integrity constraint maintenance, index maintenance in object-oriented databases (define the index between attributes of interest as a view), persistent queries, active database <ref> [SPAM91, RS93] </ref> (a rule may fire when a particular tuple is inserted into a view). We present two algorithms, counting and DRed, for incremental maintenance of a large class of views.
Reference: [Ull89] <author> Jeffrey D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, Volumes 1 and 2. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: They do not discuss how to handle recursively defined relations that are derivable in infinitely many iterations, and do not handle aggregation. 3 Notation We use Datalog, mostly as discussed in <ref> [Ull89] </ref>, extended with stratified negation [VG86, ABW88], and stratified aggregation [Mum91]. Datalog extended with stratified negation and aggregation can be mapped to a class of recursive SQL queries, and vice versa [Mum91]. We chose Datalog syntax over SQL syntax for conciseness. <p> Conversely, we note that the counting algorithm can also be used to incrementally maintain certain recursive views [GKM92]. A semi-naive <ref> [Ull89] </ref> computation is sufficient to compute new inserted tuples for a recursively defined view when insertions are made to base relations.
Reference: [UO92] <author> Toni Urpi and Antoni Olive. </author> <title> A Method for Change Computation in Deductive Databases. </title> <booktitle> In 18th VLDB, </booktitle> <pages> pages 225-237, </pages> <year> 1992. </year>
Reference-contexts: The algorithm does not apply to all graphs or to general recursive programs. They also need auxiliary derived relations, and cannot handle negation and aggregation. Urpi and Olive <ref> [UO92] </ref> need to derive functional dependencies, a problem that is known to be undecidable. Wolfson et. al. [WDSY91] use a rule language with negation in the head and body of rules, along with auxiliary information about the number of certain derivations of each tuple.
Reference: [VG86] <author> Allen Van Gelder. </author> <title> Negation as failure using tight derivations for general logic programs. </title> <booktitle> In Third IEEE Symposium on Logic Programming, 1986. </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: They do not discuss how to handle recursively defined relations that are derivable in infinitely many iterations, and do not handle aggregation. 3 Notation We use Datalog, mostly as discussed in [Ull89], extended with stratified negation <ref> [VG86, ABW88] </ref>, and stratified aggregation [Mum91]. Datalog extended with stratified negation and aggregation can be mapped to a class of recursive SQL queries, and vice versa [Mum91]. We chose Datalog syntax over SQL syntax for conciseness.
Reference: [WDSY91] <author> Ouri Wolfson, Hasanat M. Dewan, Salvatore J. Stolfo, and Yechiam Yemini. </author> <title> Incremental Evaluation of Rules and its Relationship to Parallelism. </title> <booktitle> In SIGMOD 1991, </booktitle> <pages> pages 78-87. 10 </pages>
Reference-contexts: The algorithm does not apply to all graphs or to general recursive programs. They also need auxiliary derived relations, and cannot handle negation and aggregation. Urpi and Olive [UO92] need to derive functional dependencies, a problem that is known to be undecidable. Wolfson et. al. <ref> [WDSY91] </ref> use a rule language with negation in the head and body of rules, along with auxiliary information about the number of certain derivations of each tuple.
References-found: 28

