URL: http://www.cs.cmu.edu/~clh/papers/hase97.ps.Z
Refering-URL: http://www.cs.cmu.edu/~clh/papers/publications.html
Root-URL: 
Date: Aug. 11-12, 1997.  
Address: Los Alamitos, CA,  
Note: Second Workshop on High Assurance Systems Engineering (Hase97), IEEE Computer Society Press,  
Abstract: The market demands that software systems be adaptable to changes in requirements. Software must be evolvable to solve slightly different problems over time. The transition from real-world requirements to software is a human-intensive and potentially complex process that provides limited automated support for the analysis of alternative designs with respect to their evolvability. In this paper, we propose an analytical software design approach to localize changes to control flow requirements. We present an analytical and heuristically good design approach to generate control components that localize change and reduce the computational complexity of an optimal approach. We apply our heuristic to an example and summarize the results. Lastly, we propose future research and summarize our ideas. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.K. Adams and D.E. Thomas, </author> <title> Design Automation for Mixed HardwareSoftware Systems, </title> <journal> Electronic Design, </journal> <volume> Vol. 45, No. 5, </volume> <month> Mar. </month> <year> 1997, </year> <pages> pp. 64-66, 71-72. </pages>
Reference-contexts: We seek techniques that are analytic, automatable, and applicable to the creation of new designs (architectures) as well as to the assessment of existing designs. What we have in mind are the types of analytical techniques that researchers in the area of hardwaresoftware codesign use to partition system functionality <ref> [1] </ref>. 3. Design of Control Flow Components In this section, we propose the analytical design of software components to direct the flow of control in an application. We assume a software architecture that decouples the complexity of this flow from basic data operations.
Reference: [2] <author> T.H. Cormen, C.E. Leiserson, and R.L Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: With this definition, X = &lt;a,c,e&gt; would be a subsequence of Y = &lt;a,b,c,d,e&gt; <ref> [2] </ref>. With our definition, &lt;a,b,c&gt; is a subsequence of Y; while &lt;a,c,e&gt; is not.
Reference: [3] <author> M. </author> <title> Fayad and M.P. Cline, Aspects of Software Adaptability, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 39, No. 10, </volume> <month> Oct. </month> <year> 1996, </year> <pages> pp. 58-59. </pages>
Reference-contexts: 1. Introduction Because the market demands changes in application requirements, there is an increasing need for software systems to adaptively support changes in application-level objectives <ref> [3] </ref>. A software system should be able to grow and change to solve slightly different problems over time: a software system should be easily changed with minimal error to satisfy changing requirements. Ease and reliability of modification is particularly important for high assurance applications such as air traffic control.
Reference: [4] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable ObjectOriented Software, </title> <publisher> Addison-Wesley Pub. Co., </publisher> <address> Reading, Mass., </address> <year> 1994. </year>
Reference-contexts: The idea of decoupling the part of a software solution which may change (in this case the ordering of task activations) from the part not involved in the change (the tasks themselves) is similar to the design pattern in which Mediator objects coordinate the application-specific interactions between Colleague objects <ref> [4] </ref>. The problem is how to group the task activations so that the resulting control components can be easily modified to make the potential changes. A process for doing this analytically follows in the next section. 3.2. Analytical Process for Optimal Partitioning First, we define the terms for our discussion.
Reference: [5] <author> D. Garlan and M. Shaw, </author> <title> An Introduction to Software Architecture, </title> <booktitle> Advances in Software Engineering and Knowledge Engineering, </booktitle> <volume> Vol. 1, </volume> <publisher> World Scientific Pub. Co., </publisher> <year> 1994. </year>
Reference-contexts: We apply both the optimal approach and the heuristic to an example and compare the results. For the purposes of this paper, we assume an architectural-level view of software components as defined by Garlan and Shaw <ref> [5] </ref>. 2. Software Partitioning and Change Our overall goal is an analytical way to derive a software architecture that localizes change. The input would be a requirements analysis, known design constraints, and potential changes to the problem or solution.
Reference: [6] <author> D.E. Goldberg, </author> <title> Genetic Algorithms in Search, Optimization, and Machine Learning, </title> <publisher> Addison-Wesley Pub. Co., </publisher> <address> Reading, Mass., </address> <year> 1989. </year>
Reference-contexts: For small values of n, this may not be a problem. But as n increases, the execution time required to find the optimal partition would become computationally expensive (O (2 n One could apply a combinatorial optimization algorithm such as a genetic or simulated annealing algorithm <ref> [6] </ref> [9]. The change complexity metric would provide the rationale for an objective function. The primary issue would be how to automate the process of walking-through the change to a control flow sequence in order to determine the change complexity value. This appears to be an intricate process.
Reference: [7] <author> C.L. Hoover and P.K. Khosla, </author> <title> An Analytical Approach to Change for the Design of Reusable Real-Time Software, </title> <booktitle> Proc. of the Second Workshop on ObjectOriented Real-Time Dependable Systems (WORDS96), </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> Calif., </address> <month> Feb. </month> <pages> 1-2, </pages> <year> 1996, </year> <pages> pp. 144-151. </pages>
Reference-contexts: Application of the Analytical Process Our previous analysis of genetic algorithms demonstrated the use of master control logic to activate operations performed by reusable components such as the search space, the fitness values, a random item selector, and a value-based item selector <ref> [7] </ref>. The required sequence of application-level tasks might be &lt;A,B,C,D,E,F,G,H,I&gt;, where each letter shown below represents an activation of a specific task for a genetic algorithm. A Initialize the population. B Retrieve population member 1. C Retrieve the fitness value for member 1. D Randomly select population member 2.
Reference: [8] <author> R. Kazman, G. Abowd, L. Bass, and P. Clements, </author> <title> Scenario-Based Analysis of Software Architecture, </title> <journal> IEEE Software, </journal> <volume> Vol. 13, No. 6, </volume> <month> Nov. </month> <year> 1996, </year> <pages> pp. 47-55. </pages>
Reference-contexts: SAAM provides high-level process steps for assessing a particular architecture with respect to design objectives but lets the analyst generate alternative architectures <ref> [8] </ref>. Analytical Design of Evolutionary Control Flow Components* Carol L. Hoover Pradeep K.
Reference: [9] <author> S. Kirkpatrick, C.D. Gelatt, Jr., </author> <title> and M.P. Vecchi, Optimization by Simulated Annealing, </title> <journal> Science, </journal> <volume> Vol. 220, No. 4598, </volume> <month> May 13, </month> <year> 1983, </year> <pages> pp. 45-54. </pages>
Reference-contexts: For small values of n, this may not be a problem. But as n increases, the execution time required to find the optimal partition would become computationally expensive (O (2 n One could apply a combinatorial optimization algorithm such as a genetic or simulated annealing algorithm [6] <ref> [9] </ref>. The change complexity metric would provide the rationale for an objective function. The primary issue would be how to automate the process of walking-through the change to a control flow sequence in order to determine the change complexity value. This appears to be an intricate process.
Reference: [10] <author> D.L. Parnas, </author> <title> P.C. Clements, and D.M. Weiss, The Modular Structure of Complex Systems, </title> <booktitle> IEEE Second Workshop on High Assurance Systems Engineering (Hase97), </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <month> Aug. </month> <pages> 11-12, </pages> <year> 1997. </year> <journal> 9 Transactions on Software Engineering, </journal> <volume> Vol. SE-11, No. 3, </volume> <month> Mar. </month> <year> 1985, </year> <pages> pp. 259-266. </pages>
Reference-contexts: The output would be a specification of software components that should either be selected for reuse or built. We are seeking an analytical way to mathematically and automatically apply Parnas guidelines for modularizing complex software systems <ref> [10] </ref>. VanHilst and Notkin applied the language features of C++ to structure class definitions in a way that localizes design decisions and changes to the software solution [11]. The problem is that objectoriented techniques currently guide but do not automate the transformation of requirements into design.
Reference: [11] <author> M. VanHilst and D. Notkin, </author> <title> Decoupling Change from Design, </title> <journal> Software Engineering Notes, </journal> <volume> Vol. 21, No. 6, </volume> <month> Nov. </month> <year> 1996, </year> <pages> pp. 58-69. </pages>
Reference-contexts: We are seeking an analytical way to mathematically and automatically apply Parnas guidelines for modularizing complex software systems [10]. VanHilst and Notkin applied the language features of C++ to structure class definitions in a way that localizes design decisions and changes to the software solution <ref> [11] </ref>. The problem is that objectoriented techniques currently guide but do not automate the transformation of requirements into design. Analysis objects do not necessarily map into design objects, and the designer must determine which and how much logic should be encapsulated by each class definition.
Reference: [12] <author> A. von Mayrhauser and A. M. Vans, </author> <title> Program Comprehension During Software Maintenance and Evolution, </title> <journal> Computer, </journal> <volume> Vol. 28, No. 8, </volume> <month> Aug. </month> <year> 1995, </year> <pages> pp. 44 55. </pages>
Reference-contexts: In our work, the targeted behavior was modification of control flow components within a master control architecture. A study of the type of cognitive tasks that programmers perform in maintaining and evolving software systems may also help us to develop more comprehensive metrics <ref> [12] </ref>. 6. Summary The goal of this paper is to motivate the need for analytical techniques to support the design of software that can be changed easily with minimal error. To demonstrate this need, we discussed the complexity of changing software components that localize changes to control flow.
References-found: 12

