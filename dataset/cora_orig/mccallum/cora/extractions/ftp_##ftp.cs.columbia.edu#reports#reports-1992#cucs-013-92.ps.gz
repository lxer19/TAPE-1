URL: ftp://ftp.cs.columbia.edu/reports/reports-1992/cucs-013-92.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1992.html
Root-URL: http://www.cs.columbia.edu
Title: Rule-Based Process Servers for Software Development Environments  
Author: Steven S. Popovich 
Degree: (Thesis Proposal)  Advisor: Prof. Gail E. Kaiser  
Note: Copyright 1992 Steven S. Popovich  
Date: 14 April 1992  
Address: New York, NY 10027  
Affiliation: Columbia University Department of Computer Science  
Pubnum: CUCS-013-92  
Abstract: The author is supported in part by NASA grant NGT 50583 and in part by IBM Canada Ltd. The Programming Systems Laboratory is supported by National Science Foundation grants CCR-9106368, CCR-9000930 and CCR-8858029, by grants from AT&T, BNR, DEC, IBM and SRA, by the New York State Center for Advanced Technology in Computers and Information Systems and by the NSF Engineering Research Center for Telecommunications Research. 
Abstract-found: 1
Intro-found: 1
Reference: [Ambriola 90] <author> V. Ambriola, P. Ciancarini and C. Montangero. </author> <title> Software Process Enactment in Oikos. </title> <editor> In Richard N. Taylor (editor), </editor> <booktitle> SIGPLAN '90 4th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 183-192. </pages> <address> Irvine CA, </address> <month> December, </month> <year> 1990. </year> <journal> Special issue of SIGSOFT Software Engineering Notes, </journal> <volume> 15(6), </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: This would raise questions regarding the generality of our "assembly language", since Prolog's chaining model involves backtracking and the MSL chaining model, although it includes backward chaining, has no backtracking. It is more likely, though, that we will implement the Oikos <ref> [Ambriola 90] </ref> specification language, since we should be able to obtain that system. Other possibilities are the Merlin [Schaefer 92] rule-based environment and the Melmac Petri net-based environment.
Reference: [Barghouti 88] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Implementation of a Knowledge-Based Programming Environment. </title> <booktitle> In 21st Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 54-63. </pages> <publisher> IEEE Computer Society, </publisher> <address> Kona HI, </address> <month> January, </month> <year> 1988. </year>
Reference-contexts: Some, such as Darwin [Minsky 88], are meant to enforce a development process on their users, and so use a backward chaining model, "proving" to themselves at each development step that the proposed step is legal within the supported process. Finally, there are environments, such as MARVEL <ref> [Kaiser 88, Barghouti 88, Barghouti 90a, Barghouti 90b] </ref>, that use what has been termed a "maximalist" model [Barghouti 91], involving both forward and backward chaining, and may provide both automation and enforcement.
Reference: [Barghouti 90a] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Multi-Agent Rule-Based Software Development Environments. </title> <booktitle> In 5th Annual Knowledge-Based Software Assistant Conference, </booktitle> <pages> pages 375-387. </pages> <address> Syracuse NY, </address> <month> September, </month> <year> 1990. </year>
Reference-contexts: Some, such as Darwin [Minsky 88], are meant to enforce a development process on their users, and so use a backward chaining model, "proving" to themselves at each development step that the proposed step is legal within the supported process. Finally, there are environments, such as MARVEL <ref> [Kaiser 88, Barghouti 88, Barghouti 90a, Barghouti 90b] </ref>, that use what has been termed a "maximalist" model [Barghouti 91], involving both forward and backward chaining, and may provide both automation and enforcement.
Reference: [Barghouti 90b] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Modeling Concurrency in Rule-Based Development Environments. </title> <booktitle> IEEE Expert 5(6) </booktitle> <pages> 15-27, </pages> <month> December, </month> <year> 1990. </year>
Reference-contexts: Some, such as Darwin [Minsky 88], are meant to enforce a development process on their users, and so use a backward chaining model, "proving" to themselves at each development step that the proposed step is legal within the supported process. Finally, there are environments, such as MARVEL <ref> [Kaiser 88, Barghouti 88, Barghouti 90a, Barghouti 90b] </ref>, that use what has been termed a "maximalist" model [Barghouti 91], involving both forward and backward chaining, and may provide both automation and enforcement.
Reference: [Barghouti 91] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Scaling Up Rule-Based Development Environments. </title> <editor> In A. van Lamsweerde and A. Fugetta (editor), </editor> <booktitle> 3rd European Software Engineering Conference, </booktitle> <pages> pages 380-395. </pages> <publisher> Springer-Verlag, </publisher> <address> Milano, Italy, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: Finally, there are environments, such as MARVEL [Kaiser 88, Barghouti 88, Barghouti 90a, Barghouti 90b], that use what has been termed a "maximalist" model <ref> [Barghouti 91] </ref>, involving both forward and backward chaining, and may provide both automation and enforcement. <p> The kernel's chaining model will also be configurable. We will preserve the MARVEL idea of having multiple types of chains that chain to one another under specified conditions <ref> [Barghouti 91] </ref>. Each condition and effect node will have a set of chaining types attached to it, and each element of this set will consist of a set of rules that may possibly be chained to. <p> There was only one type of chaining, which today we call automation chaining; the prototype made no distinction between consistency and automation. Today, we would consider this fact a drawback; Barghouti and Kaiser <ref> [Barghouti 91] </ref> have shown why such a distinction is desirable. There was also no support for undoing the effects of a rule or chain on the objectbase. Indeed, there was no support for crash recovery in the objectbase, other than that which was already provided by Smile. <p> These issues specifically include schema evolution, both of the data in the environment and of its description in the policy language understood by the kernel. Barghouti and Kaiser have designed a process evolution facility for MARVEL <ref> [Barghouti 91] </ref>, much of which should remain applicable to RBPS environments. Similarly, we must also consider the issues of schema evolution to be outside of our scope. 6. Plan Our plan for this thesis was summarized in Section 3.4.
Reference: [Barghouti 92] <author> Naser S. Barghouti. </author> <title> Concurrency Control in Rule-Based Software Development Environments. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <month> February, </month> <year> 1992. </year> <month> CUCS-001-92. </month>
Reference-contexts: This is the case in the current MARVEL design, where there are four chaining types: Consistency forward, consistency "backward" (bringing currently inconsistent objects into a consistent state) <ref> [Barghouti 92] </ref>, automation forward, and automation backward. Consistency "backward" chaining is not currently implemented in MARVEL; instead, no inconsistency is tolerated. If a consistency implication of a user action cannot be performed, then the entire chain is aborted atomically. <p> In MARVEL 3.0, the chain that attempts to acquire a conflicting lock is always the one aborted. However, there is a design for semantics-based concurrency control, which should be implemented in an upcoming version of MARVEL. This design, called SCCP in Barghouti's thesis <ref> [Barghouti 92] </ref> uses the type of a chain, along with other information, to make decisions as to which chain to abort whenever two chains conflict. Chaining types, however, can also be used to restrict which rules may chain to which other rules. <p> This restriction will be 30 made to keep the size and length of the project within reasonable bounds for a Ph.D. thesis. 5.3. Multi-User Issues Multi-user concurrency control issues are explicitly outside the scope of this thesis; these were the topic of Barghouti's thesis <ref> [Barghouti 92] </ref>. Also, another student on the MARVEL project is working in this area and is likely to choose as his thesis topic a general concurrency control tool for software development environments. I do not intend to duplicate his work.
Reference: [Brownston 85] <author> Lee Brownston, Robert Farrell, Elaine Kant and Nancy Martin. </author> <title> Programming Expert Systems in OPS5. </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1985. </year>
Reference-contexts: It will also be possible, in RBPS, to implement an arbitrarily strict conflict resolution strategy, which might pare down the list to a single element as in OPS5 <ref> [Brownston 85] </ref>, or even eliminate all elements to end chaining. This notion of conflict resolution will need to be reconciled with the existing MARVEL concept of consistency chaining before Oz can be built using RBPS; Oz is described in Section 6.
Reference: [CLF 88] <institution> CLF Project. CLF Manual USC Information Sciences Institute, </institution> <year> 1988. </year>
Reference-contexts: In an RBDE, the process is specified not in the form of a conventional program, but in the form of a set of rules that govern the application of the various tools. RBDE's have been created with several purposes in mind; some, exemplified by CLF <ref> [CLF 88] </ref>, are intended mainly to support automation of certain tasks and use a forward chaining model.
Reference: [Clocksin 81] <author> W.F. Clocksin and C.S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: It should be possible, using chaining type specifications, to specify substantially different chaining models from MARVEL's current one. For example, MARVEL's backward chaining is non-backtracking, but we expect to be able to implement Prolog-style backtracking <ref> [Clocksin 81] </ref> as one alternative backward chaining type.
Reference: [Deiters 90] <author> Wolfgang Deiters and Volker Gruhn. </author> <title> Managing Software Processes in the Environment MELMAC. </title> <editor> In Richard N. Taylor (editor), </editor> <booktitle> SIGPLAN '90 4th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 193-205. </pages> <publisher> ACM Press, </publisher> <address> Irvine CA, </address> <month> December, </month> <year> 1990. </year> <journal> Special issue of Software Engineering Notes, </journal> <volume> 15(6), </volume> <month> December </month> <year> 1990. </year> <month> 35 </month>
Reference-contexts: A third alternative, which we consider as part of the same branch as the rule-based languages, is to use another form of declarative specification, such as an augmented form of Petri nets <ref> [Deiters 90, Gruhn 91] </ref>, or regular expression-based activity structures [Riddle 91b].
Reference: [Dowson 87] <author> Mark Dowson. </author> <title> Integrated Project Support with IStar. </title> <booktitle> IEEE Software 4(6) </booktitle> <pages> 6-15, </pages> <month> November, </month> <year> 1987. </year>
Reference-contexts: Many SDE's make tools and facilities available to the programmer, but fail to guide their application. They may facilitate using a particular methodology, but they cannot enforce it. One example is the ISTAR environment <ref> [Dowson 87] </ref>. ISTAR is based on a contractual model of software development, where the software to be developed is specified in terms of a set of deliverables.
Reference: [Garlan 90] <author> David Garlan and Ehsan Ilias. </author> <title> Low-cost, Adaptable Tool Integration Policies for Integrated Environments. </title> <editor> In Richard N. Taylor (editor), </editor> <booktitle> SIGSOFT '90 4th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 1-10. </pages> <publisher> ACM Press, </publisher> <address> Irvine CA, </address> <month> December, </month> <year> 1990. </year> <journal> Special issue of Software Engineering Notes, </journal> <volume> 15(6), </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: These environments would need policy tools to control the application of the other tools they provide in order to enact a software development process. Examples of policy tools are the Forest <ref> [Garlan 90] </ref> policy tool developed by Garlan and Ilias for the Field environment, and the Field/MARVEL experiment, which we will describe later in this paper.
Reference: [Gisi 91] <author> Mark A. Gisi and Gail E. Kaiser. </author> <title> Extending A Tool Integration Language. </title> <booktitle> In 1st International Conference on the Software Process, </booktitle> <pages> pages 218-227. </pages> <address> Redondo Beach CA, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: In this proposal, however, all three terms will be used interchangeably. 3 What ISTAR does provide, besides contracts, is a framework for tool integration. In fact, its idea for encapsulating tools in an "envelope" was the inspiration for MARVEL's black-box tool integration facility <ref> [Gisi 91] </ref>, although the enveloping mechanisms in the two environments are completely dissimilar. It also provides a well-defined pathway for communication between tools, in the form of the contract database. <p> MARVEL's current tool objects are much weaker than those we describe here; they are only a set of name definitions, which translate from the names that rule activities use for the tool's operations to the names of the underlying SEL scripts that implement the tools <ref> [Gisi 91] </ref>. A RBPS tool object will be responsible not only for translating operation names, as in MARVEL, but also for translating from its argument objects to whatever back-end constructs are applicable in the target environment.
Reference: [Gruhn 91] <author> Volker Gruhn. </author> <title> Validation and Verification of Software Process Models. </title> <type> PhD thesis, </type> <institution> Universitat Dortmund, </institution> <month> June, </month> <year> 1991. </year>
Reference-contexts: A third alternative, which we consider as part of the same branch as the rule-based languages, is to use another form of declarative specification, such as an augmented form of Petri nets <ref> [Deiters 90, Gruhn 91] </ref>, or regular expression-based activity structures [Riddle 91b].
Reference: [Honda 88] <author> M. Honda. </author> <title> Support for Parallel Development in the Sun Network Software Environment. </title> <booktitle> In 2nd International Workshop on Computer-Aided Software Engineering, </booktitle> <pages> pages 5-5 - 5-7. </pages> <year> 1988. </year>
Reference-contexts: It also provides a well-defined pathway for communication between tools, in the form of the contract database. So ISTAR can be summarized as a contract mechanism, along with a set of tools in an integration framework for specifying and executing the contracts. Many other environments, such as NSE <ref> [Honda 88] </ref>, DSEE [Leblang 84], and Field [Reiss 90], have been structured along similar lines as an "integrated tool set" and a mechanism to allow integration of additional tools. Sometimes the integration mechanism is a shared objectbase, as in ISTAR; sometimes it is a shared communication channel, as in Field.
Reference: [Kaiser 87] <author> Gail E. Kaiser and Peter H. Feiler. </author> <title> Intelligent Assistance without Artificial Intelligence. </title> <booktitle> In 32nd IEEE Computer Society International Conference, </booktitle> <pages> pages 236-241. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> San Francisco CA, </address> <month> February, </month> <year> 1987. </year>
Reference-contexts: In order to provide some degree of motivation for these decisions, we will compare these design features of MARVEL 3.0 with the corresponding ones in the original MARVEL prototype, which dates from 1986. The MARVEL "version 0" prototype was built on an existing programming environment, Smile <ref> [Kaiser 87] </ref>. Although the terminology did not exist at the time, today we would call Smile a process-based environment; its policy, however, was hardwired in the system's code.
Reference: [Kaiser 88] <author> Gail E. Kaiser, Peter H. Feiler and Steven S. Popovich. </author> <title> Intelligent Assistance for Software Development and Maintenance. </title> <booktitle> IEEE Software 5(3) </booktitle> <pages> 40-49, </pages> <month> May, </month> <year> 1988. </year>
Reference-contexts: Some, such as Darwin [Minsky 88], are meant to enforce a development process on their users, and so use a backward chaining model, "proving" to themselves at each development step that the proposed step is legal within the supported process. Finally, there are environments, such as MARVEL <ref> [Kaiser 88, Barghouti 88, Barghouti 90a, Barghouti 90b] </ref>, that use what has been termed a "maximalist" model [Barghouti 91], involving both forward and backward chaining, and may provide both automation and enforcement.
Reference: [Kaiser 91a] <author> Gail E. </author> <note> Kaiser. </note>
Reference-contexts: In order to address this difficulty, and allow the user to interact primarily with the tools of an RBDE rather than with its rule processor, Kaiser has put forth the idea of moving the process description into a rule-based process server 2 (RBPS) <ref> [Kaiser 91a] </ref>, which is consulted by the tools whenever the developer attempts to perform a significant development step. The RBPS extends Schaefer et al.'s notion of a process control server [Peuschel 90] to RBDE's.
References-found: 18

