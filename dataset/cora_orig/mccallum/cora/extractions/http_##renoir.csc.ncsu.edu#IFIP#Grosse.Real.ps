URL: http://renoir.csc.ncsu.edu/IFIP/Grosse.Real.ps
Refering-URL: http://renoir.csc.ncsu.edu/IFIP/WoCo7.Open.Grosse.html
Root-URL: http://www.csc.ncsu.edu
Title: Real Inferno  
Author: Eric Grosse 
Date: 21 June 1996  
Address: Murray Hill NJ 07974 USA  
Affiliation: Bell Laboratories  
Abstract: Inferno is an operating system well suited to applications that need to be portable, graphical, and networked. This paper describes the funda mental floating point facilities of the system. Although the focus of Inferno is interactive media, its portability across hardware and operating platforms, its relative simplicity, and its strength in distributed computing make it attractive for advanced scientific computing as well. Since the appearance of a new operating system is a relatively uncommon event, this is a special opportunity for numerical analysts to voice their opinion about what fundamental facilities they need. The purpose of this short paper is to describe numerical aspects of the initial release of Inferno, and to invite comment before the tyranny of backward compatibility makes changes impossible. Overviews can be found at http://inferno.bell-labs.com/inferno/, but for our immediate purposes it may suffice to say that Inferno plays the role of a traditional operating system (with compilers, process control, networking, graphics, and so on) but can run either on bare hardware or on top of another operating system like Windows95 or Unix. Programs for Inferno are written in the language Limbo and compiled to machine-independent object files for the Dis virtual machine, which is then implemented with runtime compilation for best performance. Files are accessible over networks using the Styx protocol; together with the presentation of most system resources as files and the manipulation of file namespaces, this permits integration of a collection of machines into a team. Limbo looks somewhat like a mixture of C and Pascal, augmented by modules (to cope with the namespace and dynamic loading needs of large programs) and by a channel facility for convenient (coarse-grain) parallel programing. Array references are bounds-checked and memory is garbage collected. The rest of this paper covers the fundamental floating point environment provided by the Limbo compiler and math module, the "elementary functions," and finally some comments on why particular definitions were chosen or why certain facilities were included or excluded. This discussion assumes the reader is familiar with scientific computing in general and the IEEE floating point standard in particular. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. D. Clinger. </author> <title> How to read floating point numbers accurately. </title> <booktitle> In Pro-cedings of the ACM SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 92-101, </pages> <year> 1990. </year>
Reference: [2] <author> James W. Demmel and Xiaoye Li. </author> <title> Faster numerical algorithms via exception handling. </title> <type> Technical report, </type> <institution> Univ. Calif. Berkeley, </institution> <note> February 20 1993. to appear in 11th IEEE Symp. on Computer Arithmetic. </note>
Reference-contexts: This often suffices, though there are important examples where it forces an uglier and slower coding style. A worse situation is if the hardware uses system traps for Infinity and NaN arithmetic. The resulting slowdown will make otherwise excellent and natural algorithms run slowly <ref> [2] </ref>.
Reference: [3] <author> Jack J. Dongarra, Jeremy Du Croz, Sven Hammarling, and Richard J. Han-son. </author> <title> Algorithm 656: An extended set of Basic Linear Algebra Subprograms. </title> <journal> ACM Trans. on Mathematical Software, </journal> <volume> 14(1) </volume> <pages> 18-32, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: If demands warrant, 3 degree versions of the trigonometric functions will be added, but for now the style sin (45 fl Degree) is used. The library also provides IEEE functions ilogb, scalbn, copysign, finite, isnan, and nextafter. The functions dot, norm1, norm2, iamax, gemm are adopted from the blas <ref> [3] </ref> to get tuned linear algebra kernels for each architecture, possibly using extra-precise accumulators. These are defined by x i y i , jx i j, p i , i such that jx i j = max, and C = ffAB + fiC with optional transposes on A and B.
Reference: [4] <author> D. M. Gay. </author> <title> Correctly rounded binary-decimal and decimal-binary conversions. Numerical Analysis Manuscript No. </title> <type> 90-10, </type> <institution> AT&T Bell Lab 6 oratories, </institution> <address> Murray Hill, NJ, </address> <year> 1990. </year> <note> freely redistributable, available at http://netlib.bell-labs.com/netlib/fp/. </note>
Reference: [5] <author> E. H. Grosse and W. M. Coughran, Jr. </author> <title> The pine programming language. Numerical Analysis Manuscript 83-4, </title> <institution> ATT Bell Laboratories, </institution> <year> 1983. </year> <month> ftp://cm.bell-labs.com/cm/cs/doc/92/pine.ps.Z. </month>
Reference-contexts: This promotes easier exchange of data with other applications and reuses intellectual effort in organizing loops to achieve good locality. In previous language work <ref> [5] </ref>, we implemented a C preprocessor that allowed the programmer to choose a convenient origin (such as 1) and have it compiled into 0 for the base language; because we passed arrays as dope vectors, we were even able to allow different origins for the same array in calling and called
Reference: [6] <author> IEEE. </author> <title> Standard for binary floating-point arithmetic. </title> <type> Technical Report Std 754-1985, </type> <institution> ANSI, </institution> <year> 1985. </year>
Reference-contexts: These are the same rules as for Fortran and C. Contracted multiply-add instructions (with a single rounding) are not generated by the compiler, though they may be used in the native blas libraries. All arithmetic follows the IEEE fp standard <ref> [6] </ref>, except that denormalized numbers may not be supported; see the discussion in section 3. The most important numerical development at the language level recently has been accurate binary/decimal conversion [1][11][4].
Reference: [7] <author> Bo Kagstrom, Per Ling, and Charles Van Loan. </author> <title> Portable high performance GEMM-based Level 3 BLAS. </title> <editor> In R. F. Sincovec et al., editor, </editor> <booktitle> Parallel Processing for Scientific Computing, </booktitle> <pages> pages 339-346. </pages> <publisher> SIAM Publications, </publisher> <year> 1993. </year> <month> /netlib/blas/. </month>
Reference-contexts: Limbo array slices permit the calling sequences to be more readable than in Fortran/C, though restricted to unit stride. This encourages better cache performance anyway. The matrix multiply function gemm remains general stride (and is the foundation for other operations <ref> [7] </ref>). Limbo is like C in providing singly-subscripted arrays with indexing starting at 0. Although Limbo offers arrays of arrays, as in C, for scientific work a better choice is to adopt the style of linearizing subscripts using Fortran storage order.
Reference: [8] <author> W. Kahan. </author> <title> Lecture notes on the status of IEEE Standard 754 for binary floating-point arithmetic. </title> <type> Technical report, </type> <institution> Univ. Calif. Berkeley, </institution> <month> May 23 </month> <year> 1995. </year> <title> Work in Progress. </title>
Reference-contexts: Accumulated fp exceptions are even more useful. User trap handling is a harder problem, and may be worth leaving for later, possibly with a default "retrospective diagnostics" log <ref> [8] </ref>. Note that the exception masks must be architecture independent, since they reside in the Limbo bytecodes, and therefore the implementation involves a small amount of bit fiddling. Still, it is efficient enough not to deter use.
Reference: [9] <author> M. D. McIlroy. </author> <title> Mass produced software components. </title> <editor> In Peter Naur and Brian Randell, editors, </editor> <booktitle> Software Engineering, </booktitle> <pages> pages 138-155, </pages> <address> 1969. Garmisch, Germany, </address> <month> October </month> <year> 1968. </year>
Reference-contexts: An additional function pow10 (n) = 10 n is defined; in the default implementation this is just fdlibm's pow (10:; n) but it is provided so that separate trade-offs of accuracy and simplicity can be made <ref> [9] </ref>. fdlibm uses extra precise argument reduction, so the computed sin (n fl P i) is small but nonzero. If demands warrant, 3 degree versions of the trigonometric functions will be added, but for now the style sin (45 fl Degree) is used.
Reference: [10] <author> Kwok C. Ng. fdlibm: </author> <title> C math library for machines that support ieee 754 floating-point. </title> <note> freely redistributable; available at http://netlib.bell-labs.com/netlib/fdlibm/, March 1995. </note>
Reference-contexts: The function rint rounds to an integer, following the rounding mode specified in the floating point control word. For a good-quality, freely-available elementary function library, math uses the IEEE subset of fdlibm <ref> [10] </ref>. Of course, a conforming implementation may use entirely different source, but must take care with accuracy and with special arguments. There are the customary power, trigonometric, Bessel, and erf functions, and specialized versions expm1 (x) = e x 1, log1p (x) = log (1 + x).
Reference: [11] <author> G. L. Steele and J. L. White. </author> <title> How to print floating point numbers accurately. </title> <booktitle> In Procedings of the ACM SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 112-126, </pages> <year> 1990. </year>
Reference: [12] <author> X3J11.1. </author> <title> Chapter 5, floating-point C extensions. </title> <type> Technical report, </type> <institution> ANSI, </institution> <month> March 29 </month> <year> 1995. </year> <month> 7 </month>
Reference-contexts: MachEps is 2 52 , the unit in the last place of the mantissa 1:0. The value of Pi is the nearest machine number to the mathematical value . Degree is Pi /180. Three useful functions fdim, fmax, fmin are adopted from the Numerical C extensions <ref> [12] </ref>. The unusual one of these, often denoted (x y) + , is defined by fdim (x; y) = x y if x &gt; y, else 0. The compiler may turn these into efficient machine instruction sequences, possibly even branch-free, rather than function calls. <p> The resulting slowdown will make otherwise excellent and natural algorithms run slowly [2]. We considered providing syntax to declare a certain scope precise IEEE behavior was needed, and relaxing the rules outside such scopes. (The numerical C extensions <ref> [12] </ref> use pragma for this purpose.) These scope declarations would need to be in the bytecodes, since significant optimization may be attempted by the runtime compiler.
References-found: 12

