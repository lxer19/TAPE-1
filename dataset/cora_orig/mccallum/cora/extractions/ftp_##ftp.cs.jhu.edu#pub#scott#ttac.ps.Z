URL: ftp://ftp.cs.jhu.edu/pub/scott/ttac.ps.Z
Refering-URL: http://www.cs.jhu.edu/~scott/homepage/concdist.html
Root-URL: http://www.cs.jhu.edu
Email: agha@cs.uiuc.edu  iam@cs.stanford.edu  scott@cs.jhu.edu  clt@sail.stanford.edu  
Title: Towards a Theory of Actor Computation (Extended Abstract)  
Author: Gul Agha Ian A. Mason Scott Smith Carolyn Talcott 
Affiliation: University of Illinois  Stanford University  Johns Hopkins University  Stanford University  
Abstract: In this paper we present preliminary results of a rigorous development of the actor model of computation. We present an actor language which is an extension of a simple functional language, and provide a precise operational semantics for this extension. Our actor systems are open distributed systems, meaning we explicitly take into account the interface with external components in the specification of an actor system. We define and study various notions of equivalence on actor expressions and systems. We show that the usual tripartite family of testing equivalence relations collapses to two in the presence of fairness. We define a notion of operational bisimulation as a tool for establishing equivalence under fairness assumptions, and illustrate its use. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: The actor model is a primitive model of computation, but nonetheless easily expresses a wide range of computation paradigms. It directly supports encapsulation and sharing, and provides a natural extension of both functional programming and object style data abstraction to concurrent open systems <ref> [1, 2] </ref>. The main features of an open distributed system are that new components can be added, existing components can be replaced, and interconnections can be changed, largely without disturbing the functioning of the system. Components have no control over the components with which they might be connected. <p> Following the tradition of [9, 7] we adopt an operational interpretation of actor systems. Actor behavior is defined by a transition relation on configurations. Each configuration is a symbolic instantaneous representation of an actor system with respect to some idealized observer <ref> [1] </ref>, and a transition on configurations maps configurations to possible future ones. Two actor expressions/systems are said to be observationally equivalent if they give rise to the same observations, suitably defined, inside all observing contexts. This notion is closely related to testing equivalence [4]. <p> This is a weak form of synchronization and would not be necessary if message sending were synchronous. An alternative would be to have built into the semantics that every actor knows its own name, as is done in many actor and object-oriented languages. See <ref> [1] </ref> for intuitions behind these constructs. 2.1. Syntax We take as given countable sets X (variables) and A t (atoms). F n is the set of primitive operations of rank n and F = S n2N F n .
Reference: [2] <author> Gul Agha. </author> <title> Concurrent object-oriented programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 125-141, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The actor model is a primitive model of computation, but nonetheless easily expresses a wide range of computation paradigms. It directly supports encapsulation and sharing, and provides a natural extension of both functional programming and object style data abstraction to concurrent open systems <ref> [1, 2] </ref>. The main features of an open distributed system are that new components can be added, existing components can be replaced, and interconnections can be changed, largely without disturbing the functioning of the system. Components have no control over the components with which they might be connected.
Reference: [3] <author> D. Berry, R. Milner, and D.N. Turner. </author> <title> A semantics for ML concurrency primitives. </title> <booktitle> In Conference record of the 19th annual ACM symposium on principles of programming languages, </booktitle> <pages> pages 105-129, </pages> <year> 1992. </year>
Reference-contexts: In addition, we plan to develop methods for modularizing specifications and combining components to build complex systems from simpler systems. We contrast our work with three related efforts: CSP / Occam [6], the - calculus [8], and Concurrent ML <ref> [3] </ref>. The CSP / Occam model is very restrictive. Occam assumes a fixed interconnection topology of processes, supports only static storage allocation, and disallows recursive procedures. <p> Lack of locality in these model may cause problems similar to those encountered in denotational models of reference/block structure in higher order languages. We also contrast our work with more practical development of -calculus-style communications primitives found in Berry, Milner, and Turner's effort <ref> [3] </ref>, and Reppy's CML [10]. For our purposes we equate these presentations.
Reference: [4] <author> R. de Nicola and M. C. B. Hennessy. </author> <title> Testing equivalences for processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 83-133, </pages> <year> 1984. </year>
Reference-contexts: Two actor expressions/systems are said to be observationally equivalent if they give rise to the same observations, suitably defined, inside all observing contexts. This notion is closely related to testing equivalence <ref> [4] </ref>. Observational equivalence provides a semantic basis for developing sound transformation rules. Some highlights of this paper include the following. The operational semantics extends that of the embedded functional language in such a way that the equational theory of the functional language is preserved. <p> Since termination is not particularly relevant for actor configurations, we instead introduce an observer primitive, event and observe whether or not in a given computation, event is exe-cuted. This approach is similar to that used in testing equivalence for CCS <ref> [4] </ref>. Since the language is nondeterministic, three different observations may be made instead of two: either event occurs for all possible executions, it occurs in some executions but not others, or it never occurs. Formally, the language of observing contexts is obtained by introducing a new 0-ary primitive operator, event.
Reference: [5] <author> C. Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Journal of Artificial Intelligence, </journal> <volume> 8(3), </volume> <year> 1977. </year>
Reference-contexts: 1. Introduction The actor model of computation was originally proposed by Hewitt <ref> [5] </ref>. Actors are self-contained, concurrently interacting entities of a computing system. They communicate via message passing which is asynchronous and fair. Actors can be dynamically created and the topology of actor systems can change dynamically.
Reference: [6] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: In addition, we plan to develop methods for modularizing specifications and combining components to build complex systems from simpler systems. We contrast our work with three related efforts: CSP / Occam <ref> [6] </ref>, the - calculus [8], and Concurrent ML [3]. The CSP / Occam model is very restrictive. Occam assumes a fixed interconnection topology of processes, supports only static storage allocation, and disallows recursive procedures.
Reference: [7] <author> I. A. Mason and C. L. Talcott. </author> <title> Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 287-327, </pages> <year> 1991. </year>
Reference-contexts: Our choices and approach are motivated by a desire to bridge the gap between theory and practice. The theory we develop is intended to be useful for justifying program transformations for real languages, and to formalize intuitive arguments and properties used by programmers. Following the tradition of <ref> [9, 7] </ref> we adopt an operational interpretation of actor systems. Actor behavior is defined by a transition relation on configurations. Each configuration is a symbolic instantaneous representation of an actor system with respect to some idealized observer [1], and a transition on configurations maps configurations to possible future ones. <p> A simple actor behavior b that expects its message to be an actor address, sends the message 5 to that address, and becomes the same behavior, may be expressed using a definable call-by-value fixed-point combinator rec (cf. <ref> [7] </ref>) as follows. b = app (rec; y:x:seq (become (y); send (x; 5))) An expression that would create an actor with this behavior and send it some other actor address a is e = letfx := newadr ()gseq (initbeh (x; b); send (x; a)): The behavior of a sink, an actor <p> This pun is useful for two reasons: it allows us to use expressions to describe actor states and message contents; and it allows us to avoid problems of choice of names for newly created actors by appealing to an extended form of alpha conversion. (See <ref> [7] </ref> for use of this pun to represent reference cells.) Definition (cV, A s, M ): The set of communicable values, cV, the set of actor states, A s, and the set of messages, M , are defined as follows. cV= A t [ X [ pr (cV; cV) A s
Reference: [8] <author> R. Milner, J. G. Parrow, and D. J. Walker. </author> <title> A calculus of mobile processes, parts i and ii. </title> <type> Technical Report ECS-LFCS-89-85, </type> <institution> -86, Edinburgh University, </institution> <year> 1989. </year>
Reference-contexts: In addition, we plan to develop methods for modularizing specifications and combining components to build complex systems from simpler systems. We contrast our work with three related efforts: CSP / Occam [6], the - calculus <ref> [8] </ref>, and Concurrent ML [3]. The CSP / Occam model is very restrictive. Occam assumes a fixed interconnection topology of processes, supports only static storage allocation, and disallows recursive procedures.
Reference: [9] <author> G. Plotkin. </author> <title> Call-by-name, call-by-value and the lambda-v-calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: Our choices and approach are motivated by a desire to bridge the gap between theory and practice. The theory we develop is intended to be useful for justifying program transformations for real languages, and to formalize intuitive arguments and properties used by programmers. Following the tradition of <ref> [9, 7] </ref> we adopt an operational interpretation of actor systems. Actor behavior is defined by a transition relation on configurations. Each configuration is a symbolic instantaneous representation of an actor system with respect to some idealized observer [1], and a transition on configurations maps configurations to possible future ones. <p> Notions of Equivalence for Actors Two forms of equivalence are given, one for expressing the equivalence of actor expressions, and another for expressing the equivalence of actor configurations. We base our notion of equivalence on the now classic operational equivalence of <ref> [9] </ref>. For the deterministic functional languages of the sort Plotkin studied, this equality is defined as follows.
Reference: [10] <author> J. H. Reppy. </author> <title> An operational semantics of first-class synchronous operations. </title> <type> Technical Report TR 91-1232, </type> <institution> Cornell University, </institution> <year> 1991. </year>
Reference-contexts: Lack of locality in these model may cause problems similar to those encountered in denotational models of reference/block structure in higher order languages. We also contrast our work with more practical development of -calculus-style communications primitives found in Berry, Milner, and Turner's effort [3], and Reppy's CML <ref> [10] </ref>. For our purposes we equate these presentations.
Reference: [11] <author> C. L. Talcott. </author> <title> A theory for program and data specification. </title> <booktitle> In Design and Implementation of Symbolic Computation Systems, DISCO'90, volume 429 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> full version to appear in TCS special issue. </note>
Reference-contexts: Since our reduction rules preserve the evaluation semantics of the embedded functional language, many of the equational laws for this language (cf. <ref> [11] </ref>) continue to hold in the full actor language. For example, operational equivalence is a congruence and the laws concerning lambda abstraction and application continue to hold.
Reference: [12] <author> A. Yonezawa. </author> <title> ABCL: An Object-Oriented Concurrent System. </title> <publisher> MIT Press, </publisher> <address> Cambridge Mass., </address> <year> 1990. </year>
Reference-contexts: Equivalence is proved by establishing an operational bisimulation between the two systems, in which related nodes of the computation trees are constrained to be `in step'. This approach also works for transformations such as fusion or splitting of internal actors <ref> [12] </ref>. We outline the construction of the bisimulation informally. We call the original system S 0 and the transformed system S 1 . We let K 0 , K 1 be the initial configurations of the S 0 , S 1 , respectively.
References-found: 12

