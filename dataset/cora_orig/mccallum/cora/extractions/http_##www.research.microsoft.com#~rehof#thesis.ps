URL: http://www.research.microsoft.com/~rehof/thesis.ps
Refering-URL: http://www.research.microsoft.com/~rehof/publications.html
Root-URL: http://www.research.microsoft.com
Email: rehof@diku.dk  
Phone: Phone 45) 35 32 14 08 Fax 45) 35 32 14 01  
Title: The Complexity of Simple Subtyping Systems  
Author: Jakob Rehof 
Degree: Ph.D. thesis  
Note: Electronic mail:  
Address: Universitetsparken 1 DK-2100 Copenhagen Denmark  
Affiliation: DIKU, Department of Computer Science University of Copenhagen  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Aho, J. Hopcroft, and J. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: A witness to the non-universality property is a word w not accepted by the automaton A, and such a word might be exponentially long in the size of A. The solution, in the NPSPACE algorithm for non-universality <ref> [1] </ref>, is to guess the witness w bit by bit, forgetting all but the last bit of the witness; the reason this works is that the algorithm can simulate the behaviour of the automaton sufficiently, using this bit together with a subset of the state set of the automaton; the state
Reference: [2] <author> A. Aiken, F. Henglein, and J. Rehof. </author> <title> Subtyping and the cubic time bottleneck. </title> <note> Preliminary draft, </note> <month> August </month> <year> 1997. </year>
Reference: [3] <author> A. Aiken and E.L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings FPCA '93, Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pages 31-42, </pages> <month> June </month> <year> 1993. </year>
Reference: [4] <author> A. Aiken, E.L. Wimmers, and J. Palsberg. </author> <title> Optimal representations of polymorphic types with subtyping. </title> <booktitle> In Proceedings TACS '97, Theoretical Aspects of Computer Software, Sendai, Japan, </booktitle> <pages> pages 47-77. </pages> <booktitle> Springer Lecture Notes in Computer Science, </booktitle> <volume> vol. 1281, </volume> <month> September </month> <year> 1997. </year>
Reference: [5] <author> R. Amadio and L. Cardelli. </author> <title> Subtyping recursive types. </title> <booktitle> In Proc. 18th Annual ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <address> Orlando, Florida, </address> <pages> pages 104-118. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1991. </year>
Reference: [6] <author> R. Amadio and L. Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <month> Septem-ber </month> <year> 1993. </year>
Reference-contexts: In order to prove PSPACE-hardness of entailment with non-structurally ordered finite trees, we shall need to talk about approximations of infinite trees by finite trees. To this end, we recall from <ref> [6, 45] </ref> the definition of the level-k truncation of a tree t, denoted td k ; it has domain D (td k ) = fw 2 D (t) j jwj kg and is defined by td k (w) = t (w) if jwj &lt; k CHAPTER 9. <p> NON-STRUCTURAL ENTAILMENT 129 This definition is simplified, since it does not take into account the con-travariance of !; this is so, because we shall only consider monotone constraint sets here. We shall use the properties stated in the following lemma; the first two are taken from <ref> [6, 45] </ref>, and the third is an immediate consequence of the definitions, so we leave out the proof. Lemma 9.4.1 Let t and t 0 be trees in T .
Reference: [7] <author> H.P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <year> 1984. </year>
Reference-contexts: This eliminates the need for the conditional. Eliminating pairing and projections is more subtle. A first attempt might be to use the standard lambda-calculus encodings (see <ref> [7, Chapter 6.2] </ref>), taking an encoded pair of M and N to be hj M; N ji with the definition hj M; N ji = p:(p M ) N APPENDIX A. PROOFS 193 and 1 = x:y:x, 2 = x:y:y.
Reference: [8] <author> H.P. Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In S. Abramsky, D.M. Gabbay, and T.S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume II, </volume> <pages> pages 117-309. </pages> <publisher> Oxford University Press, </publisher> <year> 1992. </year> <note> 203 BIBLIOGRAPHY 204 </note>
Reference: [9] <author> M. Benke. </author> <title> Efficient type reconstruction in the presence of inheritance. </title> <booktitle> In Mathematical Foundations of Computer Science (MFCS), </booktitle> <pages> pages 272-280. </pages> <publisher> Springer Verlag, LNCS 711, </publisher> <year> 1993. </year>
Reference: [10] <author> M. Benke. </author> <title> Some complexity bounds for subtype inequalities. </title> <type> Technical Report TR 95-20 (220), </type> <institution> Warsaw University, Institute of Informatics, Warsaw University, Poland, </institution> <month> December </month> <year> 1995. </year>
Reference: [11] <author> P. A. Bloniarz, H. B. Hunt, and D. J . Rosenkrantz. </author> <title> Algebraic structures with hard equivalence and minimization problems. </title> <type> Technical Report 82-3, </type> <institution> SUNY, </institution> <month> March </month> <year> 1982. </year>
Reference-contexts: coNP and cubic time corresponding to PSPACE.) This would be the more striking, if our Conjecture 9.4.5 turns out to be correct. 13.2 Related work Bloniarz, Hunt and Rosenkrantz [39] studied the complexity of deciding logical equivalence of constant-free functional expressions over lattices and a variety of other algebraic structures <ref> [11, 12] </ref>.
Reference: [12] <author> P. A. Bloniarz, H. B. Hunt, and D. J. Rosenkrantz. </author> <title> Algebraic structures with hard equivalence and minimization problems. </title> <journal> Journal of the ACM, </journal> <volume> 31(4) </volume> <pages> 879-904, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: coNP and cubic time corresponding to PSPACE.) This would be the more striking, if our Conjecture 9.4.5 turns out to be correct. 13.2 Related work Bloniarz, Hunt and Rosenkrantz [39] studied the complexity of deciding logical equivalence of constant-free functional expressions over lattices and a variety of other algebraic structures <ref> [11, 12] </ref>.
Reference: [13] <author> F. Bourdoncle and S. Merz. </author> <title> Type checking higher-order polymorphic multi-methods. </title> <booktitle> In Proceedings POPL '97, 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Paris, France, </booktitle> <pages> pages 301-315. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1997. </year>
Reference: [14] <author> W. Charatonik and A. </author> <title> Podelski. Set constraints with intersection. </title> <booktitle> In Proceedings LICS '97, Twelfth Annual IEEE Symposium on Logic in Computer Science, Warsaw, Poland, </booktitle> <pages> pages 362-372. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1997. </year>
Reference: [15] <author> S. S. Cosmadakis. </author> <title> The word and generator problem for lattices. </title> <journal> Information and Computation, </journal> <volume> 77 </volume> <pages> 192-217, </pages> <year> 1988. </year>
Reference-contexts: In comparison to this, the formalisms studied in the present thesis are characterized by the absence of algebraic operations (like formal meet and join) and the presence of syntactic structure (type expressions and trees). Cosmadakis <ref> [15] </ref> studied the uniform word problem for lattices, i.e., the problem of deciding E j= = , where ; are formal expressions built from variables, meet and join, and where E is a set of equations between such expressions.
Reference: [16] <author> B. Courcelle. </author> <title> Fundamental properties of infinite trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 25 </volume> <pages> 95-169, </pages> <year> 1983. </year>
Reference-contexts: First, we wish to keep the constraint set finite and simple, so we cannot mention the (possibly infinite) trees top s (ff) directly in C 0 . However, as regular trees, the elements top s (ff) can all be defined by sets of regular and contractive equations (see <ref> [16] </ref>), of the form fl = fl 1 fi fl 2 or fl = fl 1 ! fl 2 , which are evidently expressible by simple inequalities. Such sets have unique solutions (they define contractions in the complete metric space of trees, see [16].) We can assume, therefore, that for any <p> sets of regular and contractive equations (see <ref> [16] </ref>), of the form fl = fl 1 fi fl 2 or fl = fl 1 ! fl 2 , which are evidently expressible by simple inequalities. Such sets have unique solutions (they define contractions in the complete metric space of trees, see [16].) We can assume, therefore, that for any structural constraint set C and any shape s, ff 2 Var (C), there is a simple constraint set C s of regular equations defining top s .
Reference: [17] <author> P. Curtis. </author> <title> Constrained quantification in polymorphic type analysis. </title> <type> Technical Report CSL-90-1, </type> <note> Xerox Parc, </note> <month> February </month> <year> 1990. </year>
Reference: [18] <author> L. Damas. </author> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1984. </year> <note> Technical Report CST-33-85 (1985). </note>
Reference: [19] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proc. 9th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <month> January </month> <year> 1982. </year> <note> BIBLIOGRAPHY 205 </note>
Reference: [20] <author> W. F. Dowling and J. H. Gallier. </author> <title> Linear-time algorithms for testing the satisfiability of propositional horn formulae. </title> <journal> Journal of Logic Programming, </journal> <volume> 3 </volume> <pages> 267-284, </pages> <year> 1984. </year>
Reference: [21] <author> J. Eifrig, S. Smith, and V. Trifonov. </author> <title> Sound polymorphic type inference for objects. </title> <booktitle> In Proceedings OOPSLA '95, </booktitle> <year> 1995. </year>
Reference: [22] <author> M. Fahndrich and A. Aiken. </author> <title> Making set-constraint program analyses scale. In Workshop on Set Constraints, </title> <address> Cambridge MA, </address> <year> 1996. </year>
Reference: [23] <author> M. Fahndrich, J. Foster, Z. Su, and A. Aiken. </author> <title> Partial online cycle elimination in inclusion constraint graphs. </title> <booktitle> In Proceedings PLDI '98, ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1998. </year> <note> To appear. </note>
Reference: [24] <author> C. Flanagan. </author> <type> Personal communication, </type> <month> March </month> <year> 1997. </year>
Reference-contexts: The problem UNIV is known to be PSPACE-complete [30]. However, we cannot reduce UNIV directly to entailment; rather, we shall need to reduce a special case of this problem to entailment. The reason is that a basic idea (found in both [65] and <ref> [24] </ref> but used differently here) of our reduction is to represent sets of strings as domains of trees, and since the latter are always prefix-closed languages, we shall need to consider only automata that accept such languages. <p> Even though the exact relation between their work and ours remains unclear, we have to some extent been inspired by their methods. Thus, Flanagan <ref> [24] </ref> proves PSPACE-hardness of their entailment predicate by reduction from the NFA containment problem (see [30].) However, the proof relies on a complicated (and impressive), complete axiomatization of entailment, whereas our proof uses non-syntactic methods and a different reduction from a special form of the NFA universality problem (their reduction appears
Reference: [25] <author> C. Flanagan and M. Felleisen. </author> <title> Componential set-based analysis. </title> <booktitle> In Proceedings of the ACM SIGPLAN '97 Conference on Programming Language Design and Implementation. ACM, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: Again, a major difference in comparison to the work presented in this thesis is that we are dealing with complexity arising from syntax, not algebraic operations, and entailment in the present work is not uniform. The study of entailment by Flanagan and Felleisen <ref> [25] </ref> is related to the present study, although they work in a different model of complete infinite trees labeled with sets of constructors, and their notion of entailment is different from ours.
Reference: [26] <author> A. Frey. </author> <title> Satisfiability of subtype inequalities in structural infinite terms over lattices in PTIME. Unpublished note, </title> <month> April </month> <year> 1997. </year>
Reference-contexts: Nevertheless, adapting the method in detail to the structural model requires a good amount of technical work, which (even though it may be found to be somewhat boring) requires some care. A sketch of an alternative reduction of satisfiability to consistency can be found in the note <ref> [26] </ref> by Frey. 1 10.1 Infinitary matching Infinite terms In order to talk about matching properties of constraint sets, it is useful to introduce special terms and substitutions. We first introduce a form of infinitary type expressions.
Reference: [27] <author> A. Frey. </author> <title> Satisfying subtype inequalities in polynomial space. </title> <booktitle> In Proceedings SAS '97, International Static Analysis Symposium, Paris, France 1997, </booktitle> <pages> pages 265-277. </pages> <booktitle> Springer Lecture Notes in Computer Science, </booktitle> <volume> vol. 1302, </volume> <year> 1997. </year>
Reference-contexts: This is a straight-forward generalization of the corresponding property from finite terms (Section 2.3.1, see [53] for the finite case, and see <ref> [72, 27] </ref> for other generalizations to the infinitary case.) Next we give a simple example involving infinite terms introduced by fi C , arising due to circular constraints. Example 10.1.2 (Infinite expansion) Let Then fi C (C) produces the inequality with infinite terms shown in Fig ure 10.1.
Reference: [28] <author> Y. Fuh and P. Mishra. </author> <title> Polymorphic subtype inference: Closing the theory-practice gap. </title> <booktitle> In Proc. Int'l J't Conf. on Theory and Practice of Software Development, </booktitle> <pages> pages 167-183, </pages> <address> Barcelona, Spain, March 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference: [29] <author> Y. Fuh and P. Mishra. </author> <title> Type inference with subtypes. </title> <journal> Theoretical Computer Science (TCS), </journal> <volume> 73 </volume> <pages> 155-175, </pages> <year> 1990. </year>
Reference: [30] <author> M. Garey and D. Johnson. </author> <title> Computers and Intractability A Guide to the Theory of NP-Completeness. </title> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference-contexts: The problem UNIV is known to be PSPACE-complete <ref> [30] </ref>. However, we cannot reduce UNIV directly to entailment; rather, we shall need to reduce a special case of this problem to entailment. <p> not hold.) Since there may be exponentially many distinct leaf addresses in fi C (ff) in the worst case (recall Example 2.3.7), it is a relatively short step to the idea that such addresses might be used to encode propositional truth valuations, thereby reducing the propositional satisfiability problem SAT (see <ref> [30] </ref>) to the problem of non-entailment. The reduction is given in the proof of the following theorem. Example 11.2.2 below gives a pictorial view of the reduction, which should make it very easy to understand. CHAPTER 11. <p> Fix two distinct variables ff and fi. Let NENT be the problem: * Given C, decide whether C 6j= ff fi We reduce SAT (propositional satisfiability, <ref> [30] </ref>) to NENT. This shows that NENT is NP-hard, which in turn shows that the problem of deciding C j= ff fi is coNP-hard. The basic idea is that an address w 2 ff; sg fl defines a truth assignment of an instance of SAT. <p> Even though the exact relation between their work and ours remains unclear, we have to some extent been inspired by their methods. Thus, Flanagan [24] proves PSPACE-hardness of their entailment predicate by reduction from the NFA containment problem (see <ref> [30] </ref>.) However, the proof relies on a complicated (and impressive), complete axiomatization of entailment, whereas our proof uses non-syntactic methods and a different reduction from a special form of the NFA universality problem (their reduction appears not to be directly applicable to our cases.) Their axiomatization leads to a complete algorithm
Reference: [31] <author> N. Heintze and D. McAllester. </author> <title> On the cubic bottleneck in subtyping and flow analysis. </title> <booktitle> In Proceedings LICS '97, Twelfth Annual IEEE Symposium on Logic in Computer Science, Warsaw, Poland, </booktitle> <pages> pages 342-351. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1997. </year> <note> BIBLIOGRAPHY 206 </note>
Reference: [32] <author> F. Henglein. </author> <title> Preunification and precongruence closure: Algorithms and applications. </title> <note> Preliminary draft, </note> <month> September </month> <year> 1992. </year>
Reference: [33] <author> F. Henglein and J. Rehof. </author> <title> The complexity of subtype entailment for simple types. </title> <booktitle> In Proceedings LICS '97, Twelfth Annual IEEE Symposium on Logic in Computer Science, Warsaw, Poland, </booktitle> <pages> pages 352-361. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: We begin (Chapter 10) by giving some basic properties for structural recursive subtyping, which will be needed later. We show that satisfia-bility with structural recursive subtyping over a lattice is in PTIME. We then show (Chapter 11) that finite, structural subtype entailment is coNP-complete <ref> [33] </ref>. We answer (Chapter 12) the corresponding question for recursive structural subtype entailment: it is PSPACE-complete.
Reference: [34] <author> F. Henglein and J. Rehof. </author> <title> Constraint automata and the complexity of recursive subtype entailment. </title> <booktitle> In Proceedings ICALP '98, 5th International Colloquium on Automata, Languages, and Programming. </booktitle> <address> Aalborg, Denmark. </address> <note> (To appear), </note> <month> July </month> <year> 1998. </year>
Reference: [35] <author> J.R. Hindley. </author> <title> Basic Simple Type Theory. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science, </booktitle> <volume> 42, </volume> <publisher> Cambridge University Press, </publisher> <year> 1997. </year>
Reference: [36] <author> R. Hindley and J. Seldin. </author> <title> Introduction to Combinators and -Calculus, volume 1 of London Mathematical Society Student Texts. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference: [37] <author> M. Hoang and J.C. Mitchell. </author> <title> Lower bounds on type inference with subtypes. </title> <booktitle> In Proc. 22nd Annual ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 176-185. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference: [38] <author> J. Hopcroft and J. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: The state set Q is V ; the alphabet is A; every state is an accept state. The iterated transition relation of an NFA, denoted b ffi N , is defined in the standard way (see <ref> [38] </ref>). We sometimes write q 7! w q 0 to denote a w-transition from q to q 0 in the automaton, i.e., q 0 2 ffi N (q; w). Notice that the transition relation 7! a of the automaton is different from the relations 7! a of the constraint graph.
Reference: [39] <author> H. B. Hunt, D. J. Rosenkrantz, </author> <title> and P.A. Bloniarz. On the computational complexity of algebra on lattices. </title> <journal> SIAM Journal of Computing, </journal> <volume> 16(1) </volume> <pages> 129-148, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: CONCLUSION TO PART II 176 of the table for satisfiability (with M (n) corresponding to coNP and cubic time corresponding to PSPACE.) This would be the more striking, if our Conjecture 9.4.5 turns out to be correct. 13.2 Related work Bloniarz, Hunt and Rosenkrantz <ref> [39] </ref> studied the complexity of deciding logical equivalence of constant-free functional expressions over lattices and a variety of other algebraic structures [11, 12].
Reference: [40] <author> M. P. Jones. </author> <title> Qualified Types: Theory and Practice. </title> <publisher> Cambridge University Press, </publisher> <year> 1994. </year>
Reference: [41] <author> S. Kaes. </author> <title> Type inference in the presence of overloading, subtyping and recursive types. </title> <booktitle> In Proc. ACM Conf. on LISP and Functional Programming (LFP), </booktitle> <address> San Francisco, California, </address> <pages> pages 193-204. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1992. </year> <title> also in LISP Pointers, </title> <journal> Vol. V, </journal> <volume> Number 1, </volume> <month> January-March </month> <year> 1992. </year>
Reference: [42] <author> P. Kanellakis, H. Mairson, and J.C. Mitchell. </author> <title> Unification and ML type reconstruction. </title> <editor> In J.-L. Lassez and G. Plotkin, editors, </editor> <booktitle> Computational Logic | Essays in Honor of Alan Robinson. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year> <note> BIBLIOGRAPHY 207 </note>
Reference: [43] <author> G. Kildall. </author> <title> A unified approach to global program optimization. </title> <booktitle> Proc. At tCM Symp. on Principles of Programming Languages (POPL), </booktitle> <year> 1973. </year>
Reference: [44] <author> D. Kozen, J. Palsberg, and M.I. Schwartzbach. </author> <title> Efficient inference of partial types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 49(2) </volume> <pages> 306-324, </pages> <year> 1994. </year>
Reference: [45] <author> Dexter Kozen, Jens Palsberg, and Michael Schwartzbach. </author> <title> Efficient recursive subtyping. </title> <booktitle> In Proc. 20th Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 419-428. </pages> <publisher> ACM, ACM Press, </publisher> <month> January </month> <year> 1993. </year>
Reference-contexts: s) = i * C (ff 0 * For q not of the forms above, the transitions functions are undefined. 9.1.5 Term automata As is done in [57, 59] for non-structural subtyping, we can use deterministic constraint automata to define regular trees presented as term automata, in the style of <ref> [45] </ref>. To do so, we need to provide a labeling function (see [45]) ` : Q ! CHAPTER 9. <p> the forms above, the transitions functions are undefined. 9.1.5 Term automata As is done in [57, 59] for non-structural subtyping, we can use deterministic constraint automata to define regular trees presented as term automata, in the style of <ref> [45] </ref>. To do so, we need to provide a labeling function (see [45]) ` : Q ! CHAPTER 9. NON-STRUCTURAL ENTAILMENT 122 With Con (t ) 2 denoting the main constructor of a constructed type t , we define for q 2 Q the set Con (q) = fCon (t ) j t 2 qg. <p> In order to prove PSPACE-hardness of entailment with non-structurally ordered finite trees, we shall need to talk about approximations of infinite trees by finite trees. To this end, we recall from <ref> [6, 45] </ref> the definition of the level-k truncation of a tree t, denoted td k ; it has domain D (td k ) = fw 2 D (t) j jwj kg and is defined by td k (w) = t (w) if jwj &lt; k CHAPTER 9. <p> NON-STRUCTURAL ENTAILMENT 129 This definition is simplified, since it does not take into account the con-travariance of !; this is so, because we shall only consider monotone constraint sets here. We shall use the properties stated in the following lemma; the first two are taken from <ref> [6, 45] </ref>, and the third is an immediate consequence of the definitions, so we leave out the proof. Lemma 9.4.1 Let t and t 0 be trees in T . <p> valuation v ^ by setting v ^ (ff) = t C For a type expression t , let A (t ) be the term automaton A C D (* C (t )), and let t A (t) denote the term defined by this automaton (in the standard way, according to <ref> [45] </ref>). Because * C (t ) = ft g, whenever t is not a variable, one has for non-variable t . Lemma 10.4.1 therefore states that v ^ (t ) v ^ (t 0 ) for all t t 0 2 C.
Reference: [46] <author> D. J. Lillie. </author> <title> Conjunctive subtyping. </title> <booktitle> In Proceedings FPCA '93, ACM SIGPLAN/SIGARCH Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pages 42-52, </pages> <month> June </month> <year> 1993. </year>
Reference: [47] <author> P. Lincoln and J.C. Mitchell. </author> <title> Algorithmic aspects of type inference with subtypes. </title> <booktitle> In Proc. 19th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programmin Languages (POPL), </booktitle> <address> Albuquerque, New Mexico, </address> <pages> pages 293-304. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1992. </year>
Reference: [48] <author> S. Marlow and P. Wadler. </author> <title> A practical subtyping system for erlang. </title> <booktitle> In 2nd International Conference on Functional Programming, </booktitle> <address> Amsterdam. </address> <publisher> ACM, </publisher> <month> June </month> <year> 1997. </year>
Reference: [49] <author> E. Melski and T. Reps. </author> <title> Interconvertability of set constraints and context-free language reachability. </title> <booktitle> In Proceedings PEPM '97, ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation. </booktitle> <publisher> ACM Press, </publisher> <year> 1997. </year>
Reference: [50] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> J. Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference: [51] <author> J.C. Mitchell. </author> <title> Coercion and type inference (summary). </title> <booktitle> In Proc. 11th ACM Symp. on Principles of Programming Languages (POPL), </booktitle> <pages> pages 175-185, </pages> <year> 1984. </year>
Reference: [52] <author> J.C. Mitchell. </author> <title> Polymorphic type inference and containment. </title> <journal> Information and Control, </journal> <volume> 76 </volume> <pages> 211-249, </pages> <year> 1988. </year>
Reference: [53] <author> J.C. Mitchell. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(3) </volume> <pages> 245-285, </pages> <month> July </month> <year> 1991. </year> <note> BIBLIOGRAPHY 208 </note>
Reference-contexts: After some technical preliminaries we prove (Chapter 9) a PSPACE lower bound for this problem, and we show that the problem remains PSPACE-hard even when restricting trees to be finite (non-structural, simple subtyping.) We conjecture that the problem is PSPACE-complete (in PSPACE). Structural subtyping was introduced by Mitchell <ref> [53] </ref> and has been used in many subsequent subtyping systems, both with finite and recursive types. <p> This is a straight-forward generalization of the corresponding property from finite terms (Section 2.3.1, see <ref> [53] </ref> for the finite case, and see [72, 27] for other generalizations to the infinitary case.) Next we give a simple example involving infinite terms introduced by fi C , arising due to circular constraints.
Reference: [54] <author> J.C. Mitchell. </author> <title> Foundations for Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference: [55] <author> C. Mossin. </author> <title> Flow Analysis of Typed Higher-Order Programs. </title> <type> PhD thesis, DIKU Technical Report No. 97/1, </type> <institution> Dept. of Computer Science, University of Copenhagen, </institution> <year> 1997. </year>
Reference: [56] <author> P. O'Keefe and M. Wand. </author> <title> Type inference for partial types is decidable. </title> <editor> In B. Krieg-Bruckner, editor, </editor> <booktitle> Proc. 4th European Symp. on Programming (ESOP), Rennes, France, </booktitle> <pages> pages 408-417. </pages> <publisher> Springer, </publisher> <month> February </month> <year> 1992. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <pages> 582. </pages>
Reference: [57] <author> J. Palsberg and P. O'Keefe. </author> <title> A type system equivalent to flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(4) </volume> <pages> 576-599, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: The second construction is essentially a determinization of the first one, by the standard subset construction; it was used in <ref> [57] </ref> and [59] to show that any consistent constraint set has a solution (recall the notion of consistency for non-structural sets, Definition 2.3.3). 116 CHAPTER 9. <p> a t 00 is a transition in the automaton, but t 7! a t 00 is not a single edge in the constraint graph. 9.1.4 Deterministic constraint automaton We shall now define a deterministic constraint automaton (DCA for short) associated with a non-structural constraint set C, along the lines of <ref> [57, 59] </ref>. We shall later modify the construction to encompass structural constraint sets as well. We shall assume here that constraint sets are given in a special form. <p> We now define a DFA constructed from C, with designated start state q 0 , in the style of <ref> [57, 59] </ref>; the DFA is called A C D (q 0 ) and is of the form (Q; ; q 0 ; ffi D ) with state set Q given by Q = -(Nvt (C)), the set of subsets of Nvt (C), alphabet = A, initial state q 0 2 Q, <p> 0 ffi D (q; d) = i * C (ff i ) S i ) i g i : S ffi D (q; s) = i * C (ff 0 * For q not of the forms above, the transitions functions are undefined. 9.1.5 Term automata As is done in <ref> [57, 59] </ref> for non-structural subtyping, we can use deterministic constraint automata to define regular trees presented as term automata, in the style of [45]. To do so, we need to provide a labeling function (see [45]) ` : Q ! CHAPTER 9. <p> Similar definitions can be given for structural subtyping, once we have defined deterministic constraint automata for the structural theory. This will be done later. 9.1.6 Satisfiability and consistency Using the methods of <ref> [57, 59] </ref>, one can show the following theorem, which states that satisfiability coincides with consistency for non-structural sub-typing (see also Section 2.4.3 for background). The theorem is an elegant use of constraint- and term automata. <p> We gave a number of further standard properties for finite, structural subtyping in Chapter 2. These will be generalized to the recursive case in the present chapter. We fix T to be T [s] in this chapter. As was noted in Section 2.4, previous work by Palsberg and O'Keefe <ref> [57] </ref> and by Pottier [59] has shown that satisfiability of constraint sets in recursive, non-structural subtyping is equivalent to consistency and therefore in PTIME (recall Theorem 2.4.3). <p> The proof is similar to Pottier's proof [59] of the corresponding property for non-structural recursive sets; this proof, in turn, was based on ideas in <ref> [57] </ref>. The essential property needed is the following: CHAPTER 10. STRUCTURAL TREES 142 Lemma 10.4.1 (Main Lemma) Suppose that C is consistent (weakly unifiable and ground consistent). Let * denote the function * C &gt; .
Reference: [58] <author> J. Palsberg, M. Wand, and P. O'Keefe. </author> <title> Type inference with nonstructural subtyping. </title> <type> BRICS Technical Report RC-95-33, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> April </month> <year> 1995. </year>
Reference: [59] <author> F. Pottier. </author> <title> Simplifying subtyping constraints. </title> <booktitle> In Proceedings ICFP '96, International Conference on Functional Programming, </booktitle> <pages> pages 122-133. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: This result is based on a characterization of atomic entailment, which will be used in later chapters. The non-structural recursive entailment problem is relevant for subtype inference for object oriented programming languages. Thus, the problem is central in the subtype simplification system proposed by Pottier <ref> [59] </ref>, which has an entailment algorithm at its core; however, the algorithm is incomplete, as pointed out by Pottier [59]. The problem also occurs (as a special case) in the simplification framework of Trifonov and Smith [73]. <p> The non-structural recursive entailment problem is relevant for subtype inference for object oriented programming languages. Thus, the problem is central in the subtype simplification system proposed by Pottier <ref> [59] </ref>, which has an entailment algorithm at its core; however, the algorithm is incomplete, as pointed out by Pottier [59]. The problem also occurs (as a special case) in the simplification framework of Trifonov and Smith [73]. The problem of finding a complete algorithm to decide recursive subtype entailment over non-structurally ordered trees remains open. However, no nontrivial lower bounds on the problem have been given up until now. <p> The second construction is essentially a determinization of the first one, by the standard subset construction; it was used in [57] and <ref> [59] </ref> to show that any consistent constraint set has a solution (recall the notion of consistency for non-structural sets, Definition 2.3.3). 116 CHAPTER 9. <p> a t 00 is a transition in the automaton, but t 7! a t 00 is not a single edge in the constraint graph. 9.1.4 Deterministic constraint automaton We shall now define a deterministic constraint automaton (DCA for short) associated with a non-structural constraint set C, along the lines of <ref> [57, 59] </ref>. We shall later modify the construction to encompass structural constraint sets as well. We shall assume here that constraint sets are given in a special form. <p> We now define a DFA constructed from C, with designated start state q 0 , in the style of <ref> [57, 59] </ref>; the DFA is called A C D (q 0 ) and is of the form (Q; ; q 0 ; ffi D ) with state set Q given by Q = -(Nvt (C)), the set of subsets of Nvt (C), alphabet = A, initial state q 0 2 Q, <p> 0 ffi D (q; d) = i * C (ff i ) S i ) i g i : S ffi D (q; s) = i * C (ff 0 * For q not of the forms above, the transitions functions are undefined. 9.1.5 Term automata As is done in <ref> [57, 59] </ref> for non-structural subtyping, we can use deterministic constraint automata to define regular trees presented as term automata, in the style of [45]. To do so, we need to provide a labeling function (see [45]) ` : Q ! CHAPTER 9. <p> Similar definitions can be given for structural subtyping, once we have defined deterministic constraint automata for the structural theory. This will be done later. 9.1.6 Satisfiability and consistency Using the methods of <ref> [57, 59] </ref>, one can show the following theorem, which states that satisfiability coincides with consistency for non-structural sub-typing (see also Section 2.4.3 for background). The theorem is an elegant use of constraint- and term automata. <p> These will be generalized to the recursive case in the present chapter. We fix T to be T [s] in this chapter. As was noted in Section 2.4, previous work by Palsberg and O'Keefe [57] and by Pottier <ref> [59] </ref> has shown that satisfiability of constraint sets in recursive, non-structural subtyping is equivalent to consistency and therefore in PTIME (recall Theorem 2.4.3). The method used to prove this was to consider deterministic constraint automata, which translate a constraint set to a solution, whenever the constraint set is consistent. <p> The proof is similar to Pottier's proof <ref> [59] </ref> of the corresponding property for non-structural recursive sets; this proof, in turn, was based on ideas in [57]. The essential property needed is the following: CHAPTER 10. STRUCTURAL TREES 142 Lemma 10.4.1 (Main Lemma) Suppose that C is consistent (weakly unifiable and ground consistent).
Reference: [60] <author> F. Pottier. </author> <title> Simplifying subtyping constraints (full version). </title> <type> Technical report, </type> <institution> INRIA, Ecole Normale Superieure, </institution> <month> October </month> <year> 1996. </year>
Reference-contexts: w is accepted by A C &gt; D (q 1 ) and A C &gt; D (q 2 ), then q 1 q 2 implies b ffi D (q 1 ; w) w b ffi D (q 2 ; w) proof By induction on the length of w, as in <ref> [60] </ref>. 2 Our labeling function is anti-monotone: Lemma A.4.4 Let q 1 and q 2 be sets of terms for which ` ^ is defined, b 2 f0; 1g a polarity.
Reference: [61] <author> V. Pratt. </author> <type> Personal communication, </type> <month> May </month> <year> 1997. </year>
Reference-contexts: Let CLOSED-UNIV be the computational problem: * Given a prefix-closed NFA A over a non-trivial alphabet , is it the case that L (A) = fl ? CHAPTER 9. NON-STRUCTURAL ENTAILMENT 124 The construction used in the proof of the following lemma is due to Vaughan Pratt <ref> [61] </ref>. Lemma 9.2.1 The problem CLOSED-UNIV is PSPACE-complete. proof Membership in PSPACE is obvious, since we know that UNIV is in PSPACE. To see hardness, we reduce from UNIV, as follows.
Reference: [62] <author> V. Pratt and J. Tiuryn. </author> <title> Satisfiability of inequalities in a poset. </title> <journal> Funda-menta Informaticae, </journal> <volume> 28 </volume> <pages> 165-182, </pages> <year> 1996. </year>
Reference: [63] <author> D. Prawitz. </author> <title> Natural deduction. </title> <publisher> Almquist & Wiksell, </publisher> <address> Uppsala 1965. </address>
Reference-contexts: In particular, G- and S-simplification still leaves an exponential number of observable 2-crowns, and Theorem 4.2.5 can therefore be used as before. 1 This can be explained in terms of the Curry-Howard isomorphism, because one cannot define logical conjunction as a derived notion from implication in minimal logic (see, e.g., <ref> [63] </ref>.) APPENDIX A. PROOFS 194 A.4 Proofs for Chapter 10 Proof of Theorem 10.2.3 Theorem 10.2.3 For any constraint set C one has: 1. C is satisfiable in T if and only if C is satisfied by a C-shaped valu ation 2.
Reference: [64] <author> J. Rehof. </author> <title> Minimal typings in atomic subtyping. </title> <type> Technical Report D-278, </type> <institution> DIKU, Dept. of Computer Science, University of Copen-hagen, Denmark. </institution> <note> Available at http://www.diku.dk/research-groups/ topps/personal/rehof/publications.html, </note> <year> 1996. </year>
Reference: [65] <author> J. Rehof. </author> <title> Minimal typings in atomic subtyping. </title> <booktitle> In Proceedings POPL '97, 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Paris, France, </booktitle> <pages> pages 278-291. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1997. </year> <note> BIBLIOGRAPHY 209 </note>
Reference-contexts: The problem UNIV is known to be PSPACE-complete [30]. However, we cannot reduce UNIV directly to entailment; rather, we shall need to reduce a special case of this problem to entailment. The reason is that a basic idea (found in both <ref> [65] </ref> and [24] but used differently here) of our reduction is to represent sets of strings as domains of trees, and since the latter are always prefix-closed languages, we shall need to consider only automata that accept such languages.
Reference: [66] <author> J. Rehof and T. Mogensen. </author> <title> Tractable constraints in finite semilat-tices. </title> <booktitle> In Proceedings SAS '96, International Static Analysis Symposium, </booktitle> <address> Aachen, Germany, </address> <month> September </month> <year> 1996. </year> <booktitle> Springer Lecture Notes in Computer Science, </booktitle> <volume> vol. 1145, </volume> <year> 1996. </year> <note> Journal version to appear in Science of Computer Programming, </note> <year> 1998. </year>
Reference: [67] <author> G. S. Smith. </author> <title> Principal type schemes for functional programs with overloading and subtyping. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 23 </volume> <pages> 197-226, </pages> <year> 1994. </year>
Reference: [68] <author> S. F. Smith. </author> <title> Constrained types: A personal perspective. </title> <note> http://www.cs.jhu.edu/hog/constrained.ps, September 1996. </note>
Reference: [69] <author> S. Thatte. </author> <title> Type inference with partial types. </title> <booktitle> In Proc. Int'l Coll. on Automata, Languages and Programming (ICALP), </booktitle> <pages> pages 615-629, </pages> <year> 1988. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol 317. </volume>
Reference: [70] <author> S. R. Thatte. </author> <title> Type inference with partial types. </title> <journal> Theoretical Computer Science, </journal> <volume> 124(1) </volume> <pages> 127-148, </pages> <month> February </month> <year> 1994. </year>
Reference: [71] <author> J. Tiuryn. </author> <title> Subtype inequalities. </title> <booktitle> In Proc. 7th Annual IEEE Symp. on Logic in Computer Science (LICS), </booktitle> <address> Santa Cruz, California, </address> <pages> pages 308-315. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Structural subtyping was introduced by Mitchell [53] and has been used in many subsequent subtyping systems, both with finite and recursive types. We study structural subtyping over a lattice because it is known <ref> [71] </ref> that even the satisfiability problem is PSPACE-hard for many non-lattices, but in PTIME for large classes of partial orders, including lattices of base types, which are of practical interest (see Section 2.4 for full background). <p> b 2 g is consistent (and hence satisfiable); then the set C 00 fff w 7! b 1 ; fi w 7! b 2 g must also be consistent (this should be rather obvious, but a detailed argument for this can be found in the proof of Theorem 5 in <ref> [71] </ref>), and it easily follows that C becomes consistent when ff is mapped to T w ff fff w 7! b 1 g and fi is mapped to T w fi ffi w 7! b 2 g, thereby constituting a counterexample to the leaf entailment.
Reference: [72] <author> J. Tiuryn and M. Wand. </author> <title> Type reconstruction with recursive types and atomic subtyping. </title> <editor> In M.-C. Gaudel and J.-P. Jouannaud, editors, </editor> <booktitle> Proc. Theory and Practice of Software Development (TAPSOFT), Or-say, France, volume 668 of Lecture Notes in Computer Science, </booktitle> <pages> pages 686-701. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1993. </year>
Reference-contexts: The best previous result is the PSPACE lower bound and DEXPTIME upper 132 CHAPTER 10. STRUCTURAL TREES 133 bound for the problem REG-SAT (satisfiability of infinite, regular sets of atomic inequalities) of Tiuryn and Wand <ref> [72] </ref>. We prove here that structural recursive subtype satisfiability is equivalent to consistency, when the order is generated from a lattice of base types, and therefore the satisfiability problem is in PTIME for this model also. <p> This is a straight-forward generalization of the corresponding property from finite terms (Section 2.3.1, see [53] for the finite case, and see <ref> [72, 27] </ref> for other generalizations to the infinitary case.) Next we give a simple example involving infinite terms introduced by fi C , arising due to circular constraints. Example 10.1.2 (Infinite expansion) Let Then fi C (C) produces the inequality with infinite terms shown in Fig ure 10.1.
Reference: [73] <author> V. Trifonov and S. Smith. </author> <title> Subtyping constrained types. </title> <booktitle> In Proceedings SAS '96, Static Analysis Symposium, </booktitle> <address> Aachen, Germany, </address> <pages> pages 349-365. </pages> <publisher> Springer, </publisher> <year> 1996. </year> <note> Lecture Notes in Computer Science, vol.1145. </note>
Reference-contexts: Thus, the problem is central in the subtype simplification system proposed by Pottier [59], which has an entailment algorithm at its core; however, the algorithm is incomplete, as pointed out by Pottier [59]. The problem also occurs (as a special case) in the simplification framework of Trifonov and Smith <ref> [73] </ref>. The problem of finding a complete algorithm to decide recursive subtype entailment over non-structurally ordered trees remains open. However, no nontrivial lower bounds on the problem have been given up until now. <p> Another interesting open problem is to determine decidability and complexity of the "semantic" relations, with the the logical form of sem , over various structures. The problem was conjectured to be undecidable over T [n] (non-structural recursive types) in <ref> [73] </ref>. Appendix A Proofs A number of proofs were left out of the main text. They are given in the following sections. Each section is devoted to proofs for a chapter in the main text.
Reference: [74] <author> M. Wand. </author> <title> A simple algorithm and proof for type inference. </title> <note> Fundamenta Informaticae, X:115-122, </note> <year> 1987. </year>
References-found: 74

