URL: http://www.cms.dmu.ac.uk/~sp/postscripts/CSMR98.ps
Refering-URL: http://www.cms.dmu.ac.uk:80/~sp/
Root-URL: 
Email: email: sp/zedan/luker]@dmu.ac.uk  
Title: Conceptual Foundations for the Design Transformation of Procedural Software to ObjectOriented Architecture  
Author: Sagar Pidaparthi, Hussein Zedan, Paul Luker 
Address: UK,  
Affiliation: School of Computing Sciences, DeMontfort University, Leicester,  
Abstract: The movement from algorithmic decomposition, structured design and procedural implementation towards object-oriented design and programming has resulted in a growing need to restructure /re-engineer old programs which have a poor architecture in order to reap the benefits of this new technology. It is more economic to restructure existing software into an objectoriented topology by identifying objects within the subject system rather than to redesign the software starting from the requirements. Such object identification relies upon program analysis and a study of intercomponent relationships and dependencies. This paper initially provides a conceptual foundation for migration from a procedural to an objectoriented software architecture for legacy software, which relies upon a view of the software life cycle, in which all software development is considered to be an evolutionary activity with reengineering/restructuring as an important process applied repeatedly to the artefacts of development at various stages in this evolution. We then introduce a novel approach of viewing a procedural program from an objectoriented perspective in which there is single god class, which has a large number of global variables and methods, supported by several user defined classes which have no behaviour, only data definitions. This view, coupled with repeated restructuring, enables a seamless migration of behaviour from the god class to other classes using design transformation methods. There is a distinction between the processes of translation and transformation, processes that we contend are orthogonal to each other, which thereby enables us to concentrate on behaviour-preserving design transformations in order to migrate from one design to another, leaving the language issues to be handled by translators. Finally, the paper describes some basic design transformations which preserve system behaviour over the partitioning of classes. A CASE tool RESTRUCT which is based on these ideas is being implemented to test the ideas presented in this paper. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Booch, G.,(1991), </author> <title> ObjectOriented Design with Applications, </title> <publisher> The Benjamin/Cummings Publishing Company. </publisher>
Reference-contexts: The structured methodologies of the 1970s and 1980s supported linear design processes, which do not lend themselves well to evolutionary development. It is now commonly accepted that software design and development requires cyclic or iterative approaches in order to control evolution. Booch <ref> [1] </ref> proposes a life cycle in which there are two kinds of processes for software design, the macro design process and the micro design process. Each phase in the macro design process encompasses a complete iteration of a micro design processes. <p> Usually there is one component called the system, which controls the execution of the system. Components in a software system are: classes, procedures, functions, types, variables. Design can be developed using design languages, which can be graphical such as OMT [5], UML [6], or Booch <ref> [1] </ref>, or by using languages like Language for Object Oriented Modelling (LOOM)[7]. Alternatively they can be specified using formal languages like COLD-K [2,3,4] as in the Meteor Project.
Reference: 2. <author> Feijs, L. </author> <title> (1993) Formalisation of Design Methods, Ellis Horwood Series in Computers and their Applications. </title>
Reference: 3. <author> Feijs, L. And Jonkers, H.B.M. </author> <title> (1989) METEOR and beyond: industrialising formal methods, </title> <editor> In: K.H. Bennet (ED.) </editor> <booktitle> Software Engineering Environments: Research and Practice, </booktitle> <publisher> Ellis Horwood Limited, </publisher> <pages> pp. </pages> <month> 255-274.. </month>
Reference-contexts: However, it is important to note that the design transformations discussed by Feijs <ref> [3] </ref>, are at a very high level of abstraction and are not suitable for our purpose of migrating from procedural to objectoriented programs. COLD-K is used to specify the designs of software systems, for which it introduces the concepts of black box descriptions and glass box descriptions of software systems.
Reference: 4. <author> Bergstra, J.A., Heering, J., Klint,, </author> <title> P (1990) Module Algebra, </title> <journal> JACM Vol. </journal> <volume> 37 No 2 pp. </volume> <pages> 335-372. </pages>
Reference: 5. <author> Rumbaugh, J.,Blaha, M., Premerlani, W., Eddy, F., Lorensen, W., </author> <title> (1991)Object-Oriented Modeling and Design, </title> <publisher> Prentice-Hall. </publisher>
Reference-contexts: Usually there is one component called the system, which controls the execution of the system. Components in a software system are: classes, procedures, functions, types, variables. Design can be developed using design languages, which can be graphical such as OMT <ref> [5] </ref>, UML [6], or Booch [1], or by using languages like Language for Object Oriented Modelling (LOOM)[7]. Alternatively they can be specified using formal languages like COLD-K [2,3,4] as in the Meteor Project.
Reference: 6. <institution> Unified Modelling Language, </institution> <note> Available at &lt;http://www.rational.com/ </note>
Reference-contexts: Usually there is one component called the system, which controls the execution of the system. Components in a software system are: classes, procedures, functions, types, variables. Design can be developed using design languages, which can be graphical such as OMT [5], UML <ref> [6] </ref>, or Booch [1], or by using languages like Language for Object Oriented Modelling (LOOM)[7]. Alternatively they can be specified using formal languages like COLD-K [2,3,4] as in the Meteor Project.
Reference: 7. <author> Barclay, K., Savage, J., </author> <year> (1996), </year> <title> Language for object Oriented modelling taken from Object Oriented Design with C++ , Prentice Hall Publishers, </title> <publisher> pp35-75. </publisher>
Reference: 8. <author> Choi, S.C. and Scacchi, W., </author> <year> (1990), </year> <title> Extracting and Restructuring the design of large systems, </title> <journal> IEEE Software. </journal>
Reference: 9. <author> Chen, Y.F., Nishimoto, M.Y., Ramamoorthy, </author> <title> C.V.,(1990) The C Information Abstraction System, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 16, No. </volume> <pages> 3. </pages>
Reference: 10. <author> Pidaparthi, S., </author> <title> (1994) Forward and Reverse Engineering CASE Tool Supporting Multiple Views for Software Development". </title> <institution> Internal Report for De Montfort University, Leicester, U.K. </institution>
Reference: 11. <author> Pidaparthi, S., Cysewski, </author> <title> G.,(1996) Migration to Object Oriented System Structure Using Design Transformation Methods, </title> <booktitle> Proceedings of The Fifth International Conference Information Systems Development - ISD96.pp 555-571. </booktitle>
Reference: 12. <author> Pidaparthi, S, Cysewski, </author> <title> G.,(1997) Case Study in Migration to ObjectOriented System Structure Using Design Transformation Methods, </title> <booktitle> Proceedings of First Euro-Micro Working Conference on Software Maintenance and Reengineering, </booktitle> <address> 17-19,March, </address> <year> 1997. </year> <pages> pp 128-135. </pages>
Reference: 13. <author> Zedan, H., Pidaparthi, S., </author> <title> (1997) Formalisation of Design Transformations, </title> <institution> Internal Report for DeMontfort University, Leicester, U.K. </institution>
Reference: 14. <author> Gamma, E., Helm, R., Johnson, R., Vlissides., </author> <title> (1994) Design Patterns, </title> <publisher> Addison-Wesley Professional Computing Series. </publisher>
Reference-contexts: It is important to ensure that there is only a single instance of the variables defined by the super class as the god class originally had only a single instance of these global variables, accessible to all the members of the class. The proposed solution incorporates the singleton <ref> [14] </ref> design pattern. Structure before transformation: Refer to figure 5. Preconditions for the application of the transformation : Variables a and b are modified only by abModifier1 () and abModifier2 ().
Reference: 15. <author> Riel, A.J. </author> <year> (1997), </year> <title> ObjectOriented Design Heuristics. </title> <publisher> Addison-Wesley Professional Computing Series. </publisher>
Reference-contexts: The translated version of the program will have a large number of global variables and methods encapsulated by the major (system) class of the system called the god class <ref> [15] </ref>, while there will be several small classes, which represent the user-defined types of the procedural subject program. In effect, we can state that a procedural program is a badly designed objectoriented program with a single large god class in which all the program behaviour is centralised.
Reference: 16. <author> Livadas,P.E.,Roy,P.K.,(1992), </author> <title> Program dependence analysis",IEEE Conference on Software Maintenance. </title>
Reference: 17. <author> Sneed, H.M., </author> <title> (1992),Migration of Procedurally Oriented COBOL Programs in an ObjectOriented Architecture, </title> <booktitle> Proc. IEEE Conference on Software Maintenance., </booktitle> <address> San Deigo, </address> <pages> pp 266-271. </pages>
Reference: 18. <author> Liu, S.S., Wilde, N., </author> <title> (1990) Identifying Objects in a Conventional Procedural Language : An Example of Data Design Recovery", </title> <booktitle> Proc. of the Conference on Software Maintenance. </booktitle>
Reference: 19. <author> Confora, G., Cimitile, A., Munro, M., and Tortorella, </author> <title> (1994) A precise method for Identifying Reusable Abstract data Types in Code. </title> <booktitle> Proc. Conference on Software Maintenance, British Colombia, </booktitle> <pages> pp 404-413. </pages>
Reference: 20. <author> Sneed, M.H., and Nyary, E., </author> <year> (1995). </year> <title> Extracting Object Oriented Specification from Procedurally Oriented Programs. </title> <booktitle> Proc 2 nd Working Conference on Reverse Engineering, WCRE95, Toronto. </booktitle> <pages> pp 217-226. </pages>
Reference: 21. <author> Gall, H., and KlOsch, R. </author> <year> (1995), </year> <title> Finding Objects in Procedural programs. An Alternative approach. </title> <booktitle> Proc. 2 nd Working Conference on Reverse Engineering, WCRE95, Toronto, </booktitle> <pages> 208-216. </pages>
Reference: 22. <author> Jarzabeck,,, S., Woon, I., </author> <year> (1997), </year> <title> Toward a Precise Description of Reverse Engineering Methods and Tools. </title> <booktitle> Proceedings of First Euromicro Conference on Software Maintenance and Reengineering., </booktitle> <address> Berlin, </address> <pages> pp 3-10. </pages>
Reference: 23. <author> Pidaparthi, S., Luker., P., Zedan, H., </author> <title> (1998) A Template for Design Transform Specification, </title> <booktitle> Submitted to International Conference on Software Engineering (ICSE) 1998, </booktitle> <address> Kyoto, Japan. </address>
Reference-contexts: The design transforms presented below provide only a short description of the transform. In order to communicate the full impact of a design transform, we need a formal template <ref> [23] </ref>, which specifies all the changes that result from a given transform. In the design diagrams presented below, we adopt OMT notation for design description. Given below are some basic transformations: Simple Partition: Figure 1 describes two behaviourally equivalent designs, before and after the partition. <p> This paper provides some of the design transformations necessary for partitioning a large procedural system which can be represented as a single class. We are working on designing a canonical set of design transforms and a template <ref> [23] </ref> for reporting design transforms in an unambiguous manner.
References-found: 23

