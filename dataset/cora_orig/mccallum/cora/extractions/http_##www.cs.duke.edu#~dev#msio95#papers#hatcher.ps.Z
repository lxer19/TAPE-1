URL: http://www.cs.duke.edu/~dev/msio95/papers/hatcher.ps.Z
Refering-URL: http://www.cs.duke.edu/~dev/msio95/abstracts/hatcher.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fsanjay,pjh,rdrg@cs.unh.edu  
Title: The Design and Implementation of Data-Parallel Files (Extended Abstract)  
Author: Sanjay Batra Philip J. Hatcher Robert D. Russell 
Address: Kingsbury Hall  Durham, NH 03824 U.S.A.  
Affiliation: Department of Computer Science  University of New Hampshire  
Abstract: Data-parallel programming languages, including C* and High-Performance Fortran, do not currently have constructs for parallel i/o. Parallel i/o, if done at all, is performed via vendor specific facilities. We present the design for extensions to the C* programming model to support parallel i/o. Our planned extensions are based on the notion of a data-parallel file, which encapsulates a set of i/o streams in a single abstraction. These extensions allow the virtual processors of a C* program to perform the usual Unix file i/o operations. While this is a very natural extension, a key question is whether this abstraction can be efficiently implemented. To address this question, we present preliminary performance data from a prototype implementation of a file system supporting data-parallel files.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Brezany, M. Gerndt, P. Mehrotra, and H. Zima. </author> <title> Concurrent file operations in a high performance FORTRAN. </title> <type> Technical Report 92-46, </type> <institution> Institute for Computer Applications in Science and Engineering, NASA Langley Research Center, </institution> <year> 1992. </year>
Reference-contexts: Virtual file pointers also maximize asynchrony, which is very important for efficiency on MIMD hardware. Systems that allow i/o operations on parallel aggregates, but with a single file pointer <ref> [1, 10] </ref>, force over-synchronization of many applications. fl This work is being supported by National Science Foundation grants ASC-9203971 and CDA-9421997. 1 Since we are simply allowing the C* VPs to execute the standard Unix i/o functions, the function interface is nearly identical to that used by Unix C programs.
Reference: [2] <author> G. Chandranmenon, R. Russell, and P. Hatcher. </author> <title> Providing an execution environment for C* programs on a Mach-based PC cluster. </title> <type> Technical Report 94-20, </type> <institution> University of New Hampshire, </institution> <year> 1994. </year>
Reference-contexts: There is also a single file open daemon (opend) process executing on one of the i/o nodes. The compute nodes are running a SPMD C program created by the C* compiler. This software structure has been built by extending the Net* system <ref> [2] </ref> and by using the UNH C* compiler [6]. A data-parallel file consists of virtual data blocks (VDBs), virtual control blocks (VCBs), super control blocks, and a header information file, which is a conventional file in the conventional directory hierarchy.
Reference: [3] <author> T. Crockett. </author> <title> File concepts for parallel I/O. </title> <booktitle> In Supercomputing `89, </booktitle> <pages> pages 574-579, </pages> <year> 1989. </year>
Reference-contexts: Virtual file pointers also generalize the proposals for "multifiles", which are too closely tied to the number of physical processors being employed <ref> [3, 5] </ref>. Virtual file pointers also maximize asynchrony, which is very important for efficiency on MIMD hardware.
Reference: [4] <author> J. Frankel. </author> <title> A reference description of the C* language. </title> <type> Technical Report TR-253, </type> <institution> Thinking Machines Corporation, </institution> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: 1 Data-Parallel I/O in C* The C* programming language <ref> [4] </ref> is centered upon the notion of a shape. A shape is a template to which parallel data values are aligned. (C* shapes are very similar in spirit to High Performance Fortran templates.) A shape is "array-like", having a rank and dimensions.
Reference: [5] <author> D. Kotz. </author> <title> Multiprocessor file system interfaces. </title> <type> Technical Report 92-179, </type> <institution> Dartmouth College, </institution> <year> 1992. </year>
Reference-contexts: Virtual file pointers also generalize the proposals for "multifiles", which are too closely tied to the number of physical processors being employed <ref> [3, 5] </ref>. Virtual file pointers also maximize asynchrony, which is very important for efficiency on MIMD hardware.
Reference: [6] <author> A. Lapadula and K. Herold. </author> <title> A retargetable C* compiler and run-time library for mesh-connected MIMD multicomputers. </title> <type> Technical Report 92-15, </type> <institution> University of New Hampshire, </institution> <year> 1992. </year>
Reference-contexts: The compute nodes are running a SPMD C program created by the C* compiler. This software structure has been built by extending the Net* system [2] and by using the UNH C* compiler <ref> [6] </ref>. A data-parallel file consists of virtual data blocks (VDBs), virtual control blocks (VCBs), super control blocks, and a header information file, which is a conventional file in the conventional directory hierarchy.
Reference: [7] <author> J. Moore, P. Hatcher, and M. Quinn. </author> <title> Stream*: Fast, flexible data-parallel i/o. </title> <type> Technical Report 94-80-13, </type> <institution> Oregon State University, </institution> <year> 1994. </year>
Reference-contexts: This would cause extra blocks to be unnecessarily written to disk. This extended abstract only reports on one prong of a two-pronged strategy. Compilers for data-parallel programs using our parallel i/o primitives can often deduce file usage patterns to reduce the overhead of virtualization <ref> [7] </ref> [8]. Examples of optimizations are the elimination of copies between C* variables and file buffers, and the elimination of the maintenance of independent file pointers.
Reference: [8] <author> J. Moore, P. Hatcher, and M. Quinn. </author> <title> Stream*: Fast, flexible data-parallel i/o. </title> <booktitle> In Proceedings of Parallel Computing '95, </booktitle> <month> September </month> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: This would cause extra blocks to be unnecessarily written to disk. This extended abstract only reports on one prong of a two-pronged strategy. Compilers for data-parallel programs using our parallel i/o primitives can often deduce file usage patterns to reduce the overhead of virtualization [7] <ref> [8] </ref>. Examples of optimizations are the elimination of copies between C* variables and file buffers, and the elimination of the maintenance of independent file pointers.
Reference: [9] <author> P. Pierce. </author> <title> A concurrent file system for a highly parallel mass storage system. </title> <booktitle> In Fourth Conference on Hypercube Concurrent Computers and Applications, </booktitle> <pages> pages 155-160, </pages> <year> 1989. </year>
Reference-contexts: Having a set of virtual file pointers provides a significant improvement over other existing or proposed parallel i/o systems. A programmer does not need to map a program's logical streams onto a conventional serial file, as is the case, for example, with Intel's Concurrent File System <ref> [9] </ref>. Virtual file pointers also generalize the proposals for "multifiles", which are too closely tied to the number of physical processors being employed [3, 5]. Virtual file pointers also maximize asynchrony, which is very important for efficiency on MIMD hardware.
Reference: [10] <institution> Thinking Machines Corporation. </institution> <note> CM Fortran User's Guide, Version 2.0 Beta, 1993. 4 </note>
Reference-contexts: Virtual file pointers also maximize asynchrony, which is very important for efficiency on MIMD hardware. Systems that allow i/o operations on parallel aggregates, but with a single file pointer <ref> [1, 10] </ref>, force over-synchronization of many applications. fl This work is being supported by National Science Foundation grants ASC-9203971 and CDA-9421997. 1 Since we are simply allowing the C* VPs to execute the standard Unix i/o functions, the function interface is nearly identical to that used by Unix C programs.
References-found: 10

