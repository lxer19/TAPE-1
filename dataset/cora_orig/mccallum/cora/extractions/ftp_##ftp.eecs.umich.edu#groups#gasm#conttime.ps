URL: ftp://ftp.eecs.umich.edu/groups/gasm/conttime.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.eecs.umich.edu
Title: On Semantics of Algorithms with Continuous Time  
Author: Daniele Beauquier Anatol Slissenko 
Address: 61, Avenue du General de Gaulle, 94010 Creteil cedex, France  
Affiliation: INFORMATIQUE Universite Paris 12 Val de Marne, Faculte des Science et Technologie  
Note: 97-15, Revised Version  
Email: F  
Phone: Tel.: (33)(1) 45 17 16 47, Fax: (33)(1) 45 17 16 49, Telex: UPVMINT 264 167  
Date: October 1997  
Abstract-found: 0
Intro-found: 1
Reference: [ACH + 95] <author> R. Alur, C. Courcoubetis, N. Halbwachs, T. Henzinger, P.-H. Ho, X. Nicollin, A. Olivero, J. Sifakis, and S. Yovine. </author> <title> The algorithmic analysis of hybrid systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 138 </volume> <pages> 3-34, </pages> <year> 1995. </year>
Reference-contexts: As for timed automata, they are easy to understand if their size is reasonable. The mostly studied notion of [AD94] with all its advantages is clearly not sufficient for specifying algorithms, for example clock synchronisation algorithms. The notion in <ref> [ACHH93, ACH + 95] </ref> gives more flexibility. But obviously, further development is needed to meet practical demands of analysis of algorithms specifications. <p> Dir ffi via the specification of the environment. 2.2 Admissible Interpretations It seems reasonable to consider time dependent functions defined over partitions fI k g k of T "piecewise finitely", that is as being piecewise constant, piecewise polynomial, etc. on every I k when the other arguments are fixed (cf. <ref> [ACHH93, ACH + 95] </ref>). To simplify the presentation we consider here as admissible only piecewise constant functions over some particular class of partitions. So we take as admissible the interpretations of the input functions defined within the following setting.
Reference: [ACHH93] <author> R. Alur, C. Courcoubetis, T. Henzinger, and P.-H. Ho. </author> <title> Hybrid automata: an algorithmic approach to the specification and verification of hybrid systems. In R.L. </title> <editor> Grossman, A. Nerode, A.P. Ravn, and H. Rischel, editors, </editor> <booktitle> Workshop on Theory of Hybrid Systems, </booktitle> <year> 1992, </year> <pages> pages 209-229. </pages> <publisher> Springer Verlag, </publisher> <year> 1993. </year> <note> Lect. Notes in Comput. Sci, vol. 736. </note>
Reference-contexts: As for timed automata, they are easy to understand if their size is reasonable. The mostly studied notion of [AD94] with all its advantages is clearly not sufficient for specifying algorithms, for example clock synchronisation algorithms. The notion in <ref> [ACHH93, ACH + 95] </ref> gives more flexibility. But obviously, further development is needed to meet practical demands of analysis of algorithms specifications. <p> Dir ffi via the specification of the environment. 2.2 Admissible Interpretations It seems reasonable to consider time dependent functions defined over partitions fI k g k of T "piecewise finitely", that is as being piecewise constant, piecewise polynomial, etc. on every I k when the other arguments are fixed (cf. <ref> [ACHH93, ACH + 95] </ref>). To simplify the presentation we consider here as admissible only piecewise constant functions over some particular class of partitions. So we take as admissible the interpretations of the input functions defined within the following setting.
Reference: [AD94] <author> R. Alur and D. Dill. </author> <title> A theory of timed automata. </title> <journal> Theoretical Computer Science, </journal> <volume> 126 </volume> <pages> 183-235, </pages> <year> 1994. </year>
Reference-contexts: Efficient algorithms for model checking are mostly associated with temporal logics [Pnu77, Eme90] as requirement specification languages, and with timed automata <ref> [AD94] </ref> or regular process algebras [Mil90] as algorithms specification languages. <p> As for timed automata, they are easy to understand if their size is reasonable. The mostly studied notion of <ref> [AD94] </ref> with all its advantages is clearly not sufficient for specifying algorithms, for example clock synchronisation algorithms. The notion in [ACHH93, ACH + 95] gives more flexibility. But obviously, further development is needed to meet practical demands of analysis of algorithms specifications.
Reference: [BS96] <author> D. Beauquier and A. Slissenko. </author> <title> The railroad crossing problem: Towards semantics of timed algorithms and their model-checking in high-level languages. </title> <type> Technical Report 96-10, </type> <institution> University Paris-12, Department of Informatics, </institution> <year> 1996. </year>
Reference-contexts: 1 Introduction We continue our study <ref> [BS96, BS97b] </ref> of the problem of verification of algorithms with contin uous time in high-level languages apt to write easily complete requirement specifications with explicit time constraints and simple operations on time. Here the focus is on the definition of semantics of timed algorithms and its representation in logic.
Reference: [BS97a] <author> D. Beauquier and A. Slissenko. </author> <title> Decidable model checking for a class of timed automata specified in first order logic. </title> <type> Technical Report 97-12, </type> <institution> University Paris-12, Department of Informatics, </institution> <year> 1997. </year>
Reference-contexts: As for the extensions of the theory of real addition, though the satisfiability problem is undecidable for them in general case, one can use the fact of decidability of the underlying theory of real addition to try to describe decidable subclasses of such logics, see <ref> [BS97a] </ref>. 1.1 Structure of the Paper. In the next subsection 1.2 we give an informal description of the Generalized Railroad Crossing Problem borrowed from [GH96] where it, on the whole, follows the original formulation of [HL94]. <p> Such an extension is undecidable even if to add a small number of unary predicates. But the fact that the underlying theory of real addition is decidable can be exploited to describe decidable classes of verification problems <ref> [BS97a] </ref>. <p> Our proofs can be considered as some experimental material to look for efficient inference search heuristics and for decidable classes of verification problem. An attempt to find such classes has been done in <ref> [BS97a] </ref>. Acknowledgement. We are thankful for Kostya Vershinine for several valuable remarks that permitted to rectify some inaccuracies in the initial version and better understand the formal aspects of the problem.
Reference: [BS97b] <author> D. Beauquier and A. Slissenko. </author> <title> The railroad crossing problem: Towards semantics of timed algorithms and their model-checking in high-level languages. </title> <editor> In M. Bidoit and M. Dauchet, editors, TAPSOFT'97: </editor> <booktitle> Theory and Practice of Software Development, </booktitle> <pages> pages 201-212. </pages> <publisher> Springer Verlag, </publisher> <year> 1997. </year> <note> Lect. Notes in Comput. Sci., vol. 1214. </note>
Reference-contexts: 1 Introduction We continue our study <ref> [BS96, BS97b] </ref> of the problem of verification of algorithms with contin uous time in high-level languages apt to write easily complete requirement specifications with explicit time constraints and simple operations on time. Here the focus is on the definition of semantics of timed algorithms and its representation in logic. <p> Here we will define a semantics that conserves this type of interpretation for the internal functions, though the representation of this semantics in logic is more complicated that our first version <ref> [BS97b] </ref> where the internal functions were piecewise constant on intervals closed to the right. The present version has two advantages: all the partitions are of the same kind, and in a way, it is closer to the classical semantics of algorithms with discrete time.
Reference: [Eme90] <author> A. Emerson. </author> <title> Temporal and modal logic. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science. Vol. B: Formal Models and Sematics, </booktitle> <pages> pages 995-1072. </pages> <publisher> Elsevier Science Publishers B.V., </publisher> <year> 1990. </year>
Reference-contexts: Efficient algorithms for model checking are mostly associated with temporal logics <ref> [Pnu77, Eme90] </ref> as requirement specification languages, and with timed automata [AD94] or regular process algebras [Mil90] as algorithms specification languages. <p> Efficient algorithms for model checking are mostly associated with temporal logics [Pnu77, Eme90] as requirement specification languages, and with timed automata [AD94] or regular process algebras [Mil90] as algorithms specification languages. Whatever impressive be the achievements of research on temporal logics and their applications to verification (e. g. <ref> [Eme90, Eme96, Var96, 2 MP92] </ref>), some of their evident shortcomings such as hardness of understanding the temporal logic formulas and not direct way of representing desired properties inhibit their wide practical applications and seem to be insurmountable.
Reference: [Eme96] <author> A. Emerson. </author> <title> Automated temporal reasoning about reactive systems. </title> <editor> In F. Moller and G. Birtwistle, editors, </editor> <booktitle> Logic for Concurrency. Structure versus Automata, </booktitle> <pages> pages 41-101. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year> <title> Series: </title> <booktitle> "Lecture notes in Computer Science (Tutorial)", </booktitle> <volume> Vol. 1043. </volume> <pages> 23 </pages>
Reference-contexts: Efficient algorithms for model checking are mostly associated with temporal logics [Pnu77, Eme90] as requirement specification languages, and with timed automata [AD94] or regular process algebras [Mil90] as algorithms specification languages. Whatever impressive be the achievements of research on temporal logics and their applications to verification (e. g. <ref> [Eme90, Eme96, Var96, 2 MP92] </ref>), some of their evident shortcomings such as hardness of understanding the temporal logic formulas and not direct way of representing desired properties inhibit their wide practical applications and seem to be insurmountable.
Reference: [GH96] <author> Y. Gurevich and J. Huggins. </author> <title> The railroad crossing problem: an experiment with instantaneous actions and immediate reactions. </title> <editor> In H. K. Buning, editor, </editor> <booktitle> Computer Science Logics, Selected papers from CSL'95, </booktitle> <pages> pages 266-290. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year> <note> Lect. Notes in Comput. Sci., vol. 1092. </note>
Reference-contexts: In the next subsection 1.2 we give an informal description of the Generalized Railroad Crossing Problem borrowed from <ref> [GH96] </ref> where it, on the whole, follows the original formulation of [HL94]. Section 2 contains a description of logical languages used later in sections 3, 6, 7 to specify various aspects of the Railroad Crossing Problem. These specifications are short and understandable. <p> Section 2 contains a description of logical languages used later in sections 3, 6, 7 to specify various aspects of the Railroad Crossing Problem. These specifications are short and understandable. In section 4 we give a modification of Railroad Crossing Controller from <ref> [GH96] </ref> which better 3 meets intuitive requirements on the optimal dependability of the railroad crossing (the controller from [HL96] is neither optimal), and then give a semantics in section 5. In section 6 we represent the semantics in a language of the same type as used for requirement specifications. <p> Strictly speaking, we are to prove that this character-isations of when it is safe to open the gate assures the maximal dependability of the railroad crossing. It is an important point, and its neglecting implied the mentioned deficiency of the controllers from <ref> [HL96, GH96] </ref>. 3.1 Railroad Crossing Problem: Specification of the Environment. The specifications that follow consist of two parts, namely, of specification of the environment and that of control. <p> Informally, we assume that all conditional instructions are executed simultaneously for all !, and all assignments in all block assignments are also executed simultaneously. This is the hypothesis of instantaneous actions, see <ref> [GH96] </ref>. Before treating the semantics of such algorithms consider our example. 4.2 Railroad Crossing Controller. Logical representation of the identifiers of the algorithm that will be described later has been given above in subsubsection 2.1.1. <p> Notation: Saf eT oOpen= df 8x i TrackStatus (x) = empty _ CT &lt; DeadLine (x) j An algorithm to control the railroad crossing is on Figure 2. To distinguish it from that of <ref> [GH96] </ref> we will name it Symmetric Controller as it uses our version of SafeToOpen condition in a symmetric way. <p> Note that the controller of <ref> [GH96] </ref> as well as the controller of the fundamental paper [HL96] on the Railroad Crossing Problem do not give optimal dependability, and thus, are not quite correct with respect to clearly stated intuitive demands. <p> And this shortcoming has not been found by formal verification because it is a fault in the specification of safe-to-open condition that had been neither explicitely described nor analysed in <ref> [HL96, GH96] </ref>. However, this fault makes the both mentioned papers even more valuable. 5 Semantics of Block Algorithms.
Reference: [Gur95] <author> Y. Gurevich. </author> <title> Evolving algebra 1993: Lipari guide. </title> <editor> In E. Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 9-93. </pages> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Here the focus is on the definition of semantics of timed algorithms and its representation in logic. We consider only block Gurevich machines <ref> [Gur95] </ref> which presume high parallelism and represent an essential part of difficulties related to treating programming languages constructions. <p> But obviously, further development is needed to meet practical demands of analysis of algorithms specifications. At the other pole one finds easily understandable and powerful languages such as VDM and Z [WH93, Wor92, HJN93] for logic specification or, for example, Gurevich machines <ref> [Gur95] </ref> for specifying algorithms (our choice of the mentioned approaches is personal, many other interesting approaches are being developed and are represented at the specification site of WWW). <p> On the basis of such a systematization we could at least formulate hypotheses on properties that may help to find efficiently decidable classes which contain the problems under consideration. As two "high-level" languages for specifications we take: evolving algebras of Yuri Gurevich (that we will call Gurevich machines) <ref> [Gur95] </ref> to specify algorithms, and an extension of the theory of real addition to specify requirements. <p> By now the latter is not clear. Our description of block Gurevich machines will be sketchy, but, we hope, sufficient, for more details see <ref> [Gur95] </ref> and the www page http://www.eecs.umich.edu/gasm/. 4.1 Block Gurevich Machines. A block Gurevich machine (we slightly deviate from [Gur95] to meet our particular demands of analyzing the concrete example of the Railroad Crossing Problem is a tuple of the form (V; Ini; P rog), where V is a vocabulary, Ini is <p> By now the latter is not clear. Our description of block Gurevich machines will be sketchy, but, we hope, sufficient, for more details see <ref> [Gur95] </ref> and the www page http://www.eecs.umich.edu/gasm/. 4.1 Block Gurevich Machines. A block Gurevich machine (we slightly deviate from [Gur95] to meet our particular demands of analyzing the concrete example of the Railroad Crossing Problem is a tuple of the form (V; Ini; P rog), where V is a vocabulary, Ini is a closed formula over V describing the initial values of functions and P rog is a program.
Reference: [Han94] <author> H. A. Hansson. </author> <title> Time and Probability in Formal Design of Distributed Systems. </title> <publisher> Elsevier, </publisher> <year> 1994. </year> <title> Series: "Real Time Safety Critical System", </title> <journal> vol. </journal> <volume> 1, </volume> <editor> Series Editor: H. </editor> <publisher> Zedan. </publisher>
Reference-contexts: Lack of explicit time is among the shortcomings of temporal logics, and it is not easy to remedy them in a persuasive way (see, e. g. <ref> [Han94] </ref>), not speaking that the initial idea of temporal logics was to avoid explicit use of time. As for timed automata, they are easy to understand if their size is reasonable.
Reference: [HJN93] <author> I. J. Hayes, C. B. Jones, and J. E. </author> <title> Nicholls. Understanding the differences between VDM and Z. </title> <type> Technical Report UMCS-93-8-1, </type> <institution> University of Manchester, Computer Science Dept., </institution> <year> 1993. </year>
Reference-contexts: The notion in [ACHH93, ACH + 95] gives more flexibility. But obviously, further development is needed to meet practical demands of analysis of algorithms specifications. At the other pole one finds easily understandable and powerful languages such as VDM and Z <ref> [WH93, Wor92, HJN93] </ref> for logic specification or, for example, Gurevich machines [Gur95] for specifying algorithms (our choice of the mentioned approaches is personal, many other interesting approaches are being developed and are represented at the specification site of WWW).
Reference: [HL94] <author> C. Heitmeyer and N. Lynch. </author> <title> The generalized railroad crossing: a case study in formal verification of real-time systems. </title> <booktitle> In Proc. of Real-Time Systems Symp., </booktitle> <address> San Juan, Puerto Rico. </address> <publisher> IEEE, </publisher> <year> 1994. </year>
Reference-contexts: We consider only block Gurevich machines [Gur95] which presume high parallelism and represent an essential part of difficulties related to treating programming languages constructions. After that we give more detailed proof of correctness for a Gurevich machine solution of the Generalized Railroad Crossing Problem 3 <ref> [HL94] </ref> with respect to our requirement specifications and make some conclusions on the inference search rules sufficient to find it in more or less automatic way. <p> In the next subsection 1.2 we give an informal description of the Generalized Railroad Crossing Problem borrowed from [GH96] where it, on the whole, follows the original formulation of <ref> [HL94] </ref>. Section 2 contains a description of logical languages used later in sections 3, 6, 7 to specify various aspects of the Railroad Crossing Problem. These specifications are short and understandable.
Reference: [HL96] <author> C. Heitmeyer and N. Lynch. </author> <title> Formal verification of real-time systems using timed automata. </title> <editor> In C. Heitmeyer and D. Mandrioli, editors, </editor> <booktitle> Formal Methods for Real-Time Computing, </booktitle> <pages> pages 83-106. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1996. </year> <title> In series: </title> <booktitle> "Trends in Software", </booktitle> <volume> vol. 5, </volume> <editor> Series Editor: B. </editor> <publisher> Krishnamurthy. </publisher>
Reference-contexts: These specifications are short and understandable. In section 4 we give a modification of Railroad Crossing Controller from [GH96] which better 3 meets intuitive requirements on the optimal dependability of the railroad crossing (the controller from <ref> [HL96] </ref> is neither optimal), and then give a semantics in section 5. In section 6 we represent the semantics in a language of the same type as used for requirement specifications. A proof of correctness of the algorithm is discussed in section 7. We give a proof of safety only. <p> Strictly speaking, we are to prove that this character-isations of when it is safe to open the gate assures the maximal dependability of the railroad crossing. It is an important point, and its neglecting implied the mentioned deficiency of the controllers from <ref> [HL96, GH96] </ref>. 3.1 Railroad Crossing Problem: Specification of the Environment. The specifications that follow consist of two parts, namely, of specification of the environment and that of control. <p> Note that the controller of [GH96] as well as the controller of the fundamental paper <ref> [HL96] </ref> on the Railroad Crossing Problem do not give optimal dependability, and thus, are not quite correct with respect to clearly stated intuitive demands. <p> And this shortcoming has not been found by formal verification because it is a fault in the specification of safe-to-open condition that had been neither explicitely described nor analysed in <ref> [HL96, GH96] </ref>. However, this fault makes the both mentioned papers even more valuable. 5 Semantics of Block Algorithms.
Reference: [HM96] <author> C. Heitmeyer and D. Mandrioli, </author> <title> editors. Formal Methods for Real-Time Computing, </title> <booktitle> volume 5 of Trends in Software. </booktitle> <publisher> John Wiley & Sons, </publisher> <year> 1996. </year> <title> Series Editor: </title> <publisher> B. Krish-namurthy. </publisher>
Reference-contexts: E-mail: beauquier-paris12.fr 2 Address: Dept. of Informatics, University Paris-12, 61 Av. du Gen. de Gaulle, 94010, Creteil, France. E-mail: slissenko@univ-paris12.fr 3 The Generalized Railroad Crossing Problem seems to be a good introductory example and is widely exploited, e. g. see a recent collection of papers <ref> [HM96] </ref> where it serves as a common example. practical problems. The most efficient inference search and reasoning is the human one, and it is highly semantical and is based on easily understandable and powerful languages. This argument does not contradict to applying and composing various approaches to the verification problem.
Reference: [Mil90] <author> R. Milner. </author> <title> Operational and algebraic semantics of concurrent processes. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science. Vol. B: Formal Models and Sematics, </booktitle> <pages> pages 1201-1242. </pages> <publisher> Elsevier Science Publishers B.V., </publisher> <year> 1990. </year>
Reference-contexts: Efficient algorithms for model checking are mostly associated with temporal logics [Pnu77, Eme90] as requirement specification languages, and with timed automata [AD94] or regular process algebras <ref> [Mil90] </ref> as algorithms specification languages.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference: [ORNvH95] <author> S. Owre, J. Rushby, Shankar N., and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <year> 1995. </year>
Reference-contexts: Powerful and easily comprehensible languages are more attractive as they permit to avoid grave errors during the formalization process and are more productive in detecting and rectifying semantic faults that are difficult to discover. One of the most successful computer systems for treatment of formal specifications, namely PVS <ref> [ORNvH95, PVS] </ref>, is definitely oriented towards understandability and expressiveness of specification languages. As payment for this power the system uses heuristic algorithms without systematic analysis of domains of their efficiency, and, sure, human interaction.
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proc. IEEE 18th Annu. Symp. on Found. Comput. Sci., </booktitle> <pages> pages 46-57, </pages> <address> New York, 1977. </address> <publisher> IEEE. </publisher>
Reference-contexts: Efficient algorithms for model checking are mostly associated with temporal logics <ref> [Pnu77, Eme90] </ref> as requirement specification languages, and with timed automata [AD94] or regular process algebras [Mil90] as algorithms specification languages.
Reference: [PVS] <author> PVS. </author> <note> WWW site of PVS papers. http://www.csl.sri.com/sri-csl-fm.html. </note>
Reference-contexts: Powerful and easily comprehensible languages are more attractive as they permit to avoid grave errors during the formalization process and are more productive in detecting and rectifying semantic faults that are difficult to discover. One of the most successful computer systems for treatment of formal specifications, namely PVS <ref> [ORNvH95, PVS] </ref>, is definitely oriented towards understandability and expressiveness of specification languages. As payment for this power the system uses heuristic algorithms without systematic analysis of domains of their efficiency, and, sure, human interaction.
Reference: [Var96] <author> M. Vardi. </author> <title> An automata-theoretic approach to linear temporal logic. </title> <editor> In F. Moller and G. Birtwistle, editors, </editor> <booktitle> Logic for Concurrency. Structure versus Automata, </booktitle> <pages> pages 238-266. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year> <title> Series: </title> <booktitle> "Lecture notes in Computer Science (Tutorial)", </booktitle> <volume> Vol. </volume> <pages> 1043. </pages>
Reference-contexts: Efficient algorithms for model checking are mostly associated with temporal logics [Pnu77, Eme90] as requirement specification languages, and with timed automata [AD94] or regular process algebras [Mil90] as algorithms specification languages. Whatever impressive be the achievements of research on temporal logics and their applications to verification (e. g. <ref> [Eme90, Eme96, Var96, 2 MP92] </ref>), some of their evident shortcomings such as hardness of understanding the temporal logic formulas and not direct way of representing desired properties inhibit their wide practical applications and seem to be insurmountable.
Reference: [WH93] <author> M. Woodman and B. Heal. </author> <title> Introduction to VDM. </title> <publisher> McGraw-Hill, </publisher> <year> 1993. </year>
Reference-contexts: The notion in [ACHH93, ACH + 95] gives more flexibility. But obviously, further development is needed to meet practical demands of analysis of algorithms specifications. At the other pole one finds easily understandable and powerful languages such as VDM and Z <ref> [WH93, Wor92, HJN93] </ref> for logic specification or, for example, Gurevich machines [Gur95] for specifying algorithms (our choice of the mentioned approaches is personal, many other interesting approaches are being developed and are represented at the specification site of WWW).
Reference: [Wor92] <author> J. B. Wordsworth. </author> <title> Software Development with Z. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year> <month> 24 </month>
Reference-contexts: The notion in [ACHH93, ACH + 95] gives more flexibility. But obviously, further development is needed to meet practical demands of analysis of algorithms specifications. At the other pole one finds easily understandable and powerful languages such as VDM and Z <ref> [WH93, Wor92, HJN93] </ref> for logic specification or, for example, Gurevich machines [Gur95] for specifying algorithms (our choice of the mentioned approaches is personal, many other interesting approaches are being developed and are represented at the specification site of WWW).
References-found: 23

