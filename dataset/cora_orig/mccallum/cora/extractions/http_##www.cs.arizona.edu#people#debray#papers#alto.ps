URL: http://www.cs.arizona.edu/people/debray/papers/alto.ps
Refering-URL: http://www.cs.arizona.edu/alto/
Root-URL: http://www.cs.arizona.edu
Email: fmuth, debray, sawg@cs.arizona.edu  kdb@elis.rug.ac.be  
Title: alto A Link-Time Optimizer for the DEC Alpha  
Author: Robert Muth Saumya Debray Scott Watterson Koen De Bosschere Robert Muth, Saumya Debray and Scott Watterson 
Note: The work of  was supported in part by the National Science Foundation under grant numbers CCR-9502826 and CCR-9711166. Koen De Bosschere is a research associate with the Fund for Scientific Research Flanders.  
Date: September 2, 1998  
Address: Tucson, AZ 85721, USA  B-9000 Gent, Belgium  
Affiliation: Department of Computer Science University of Arizona  Vakgroep Elektronica en Informatiesystemen Universiteit Gent  
Abstract: Traditional optimizing compilers are limited in the scope of their optimizations by the fact that only a single function, or possibly a single module, is available for analysis and optimization. In particular, this means that library routines cannot be optimized to specific calling contexts. A possible solution is to carry out whole-program optimization at link time. This paper describes alto, a link-time optimizer for the DEC Alpha architecture. It implements a number of simple analyses and optimizations, and produces code that is, on the average, signifi cantly faster than that produced by the OM link-time optimizer. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi and J. D. Ullman, </author> <booktitle> Compilers Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction Optimizing compilers for traditional imperative languages often limit their program analyses and optimizations to individual procedures <ref> [1] </ref>. This has the disadvantage that some possible optimizations may be missed because they depend on propagating information across procedure boundaries. <p> The determination of intra-procedural control flow is not too difficult; and since an intermediate representation is used, there is no need to deal with machine-level idioms for control transfer. As a result, the construction of a control flow graph is a fairly straightforward process <ref> [1] </ref>. Things are somewhat more complex at link time because machine code is harder to decompile. The algorithm used by alto to construct a control flow graph for an input program is as follows: 1. <p> The start address of the program appears at a fixed location within the header of the file (this location may be different for different file formats). Using this as a starting point, the standard algorithm <ref> [1] </ref> is used to identify leaders and basic blocks, as well as function entry blocks. At this stage alto makes two assumptions: (i) that each function has a single entry block; and (ii) that all of the basic blocks of a function are laid out contiguously. <p> The price paid for this improvement in precision is an increase in the cost of analysis. The analyses implemented in alto are relatively straightforward interprocedural liveness analyses <ref> [1] </ref>, restricted to registers, and extended to deal with idiosyncracies of the Alpha instruction set. <p> A load instruction that satisfies all the conditions can be moved out of the loop provided that it satisfies the usual conditions for code motion out of loops (see <ref> [1] </ref>). If a load instruction satisfies the first two conditions but not the third, it is termed potentially loop-invariant.
Reference: [2] <author> A. L. Chow and A. Rudnick, </author> <title> The Design of a Data Flow Analyzer, </title> <booktitle> Proc. SIGPLAN '82 Conference on Compiler Construction, </booktitle> <month> June </month> <year> 1982, </year> <pages> pp. 106-119. </pages>
Reference-contexts: This has the advantages of simplicity and efficiency: nothing special needs to be done to handle inter-procedural control flow, and a procedure does not have to be re-analyzed for its various call-sites <ref> [2, 3, 8, 22] </ref>. The problem is that such analyses can suffer from a loss of precision because they can explore execution paths containing call/return pairs that do not correspond to each other and therefore cannot occur in any execution of the program.
Reference: [3] <author> D. R. Chase, M. Wegman, and F. K. Zadeck, </author> <title> Analysis of Pointers and Structures, </title> <booktitle> Proc. SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1990, </year> <pages> pp. 296-310. </pages>
Reference-contexts: This has the advantages of simplicity and efficiency: nothing special needs to be done to handle inter-procedural control flow, and a procedure does not have to be re-analyzed for its various call-sites <ref> [2, 3, 8, 22] </ref>. The problem is that such analyses can suffer from a loss of precision because they can explore execution paths containing call/return pairs that do not correspond to each other and therefore cannot occur in any execution of the program.
Reference: [4] <author> F. C. Chow, </author> <title> Minimizing Register Usage Penalty at Procedure Calls, </title> <booktitle> Proc. SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1988, </year> <pages> pp. 85-94. </pages>
Reference-contexts: To reduce the number of such unnecessary memory accesses, alto uses a variation on shrink-wrapping <ref> [4] </ref> to move register save/restore actions away from execution paths that don't need them. The difference between our implementation of shrink-wrapping, and that originally proposed by Chow [4], is that we don't allow any execution path through a function to contain more than one each of save and restore actions. <p> To reduce the number of such unnecessary memory accesses, alto uses a variation on shrink-wrapping <ref> [4] </ref> to move register save/restore actions away from execution paths that don't need them. The difference between our implementation of shrink-wrapping, and that originally proposed by Chow [4], is that we don't allow any execution path through a function to contain more than one each of save and restore actions.
Reference: [5] <author> P. Codognet and D. Diaz, wamcc: </author> <title> Compiling Prolog to C, </title> <booktitle> Proc. Twelfth International Conference on Logic Programming, </booktitle> <month> June </month> <year> 1995, </year> <pages> pp. 317-332. </pages> <publisher> MIT Press. </publisher>
Reference-contexts: By contrast, all of the benchmarks achieved significant increases in speed, ranging from 10% for earley to almost 28% for nucleic, with an average improvement of a little over 15%. 6.3 Prolog Programs To evaluate alto on Prolog programs we used wamcc version 2.21, by Codognet and Diaz <ref> [5] </ref>. This system relies on extensions to C implemented within gcc, which precludes a comparison against the effects of alto with those of profile-directed inter-file and link-time optimization within cc.
Reference: [6] <author> C. S. Collberg, </author> <title> Flexible Encapsulation, </title> <type> Ph.D. Thesis, </type> <institution> Lund University, </institution> <year> 1992. </year>
Reference-contexts: Link-time code optimization has been considered by a number of other researchers. Link-time register allocation, aimed at allowing global variables to be kept in registers and reducing register saves and restores at inter-module calls, is discussed by Santhanam and Odnert [23] and Wall [30]. The Zuse Translation System <ref> [6] </ref> and the mld link-time optimizer [11] are aimed at reducing the cost of abstraction in object-oriented languages. Machine-level global optimization is discussed also by Johnson and Miller [17], but unlike alto, this system does not carry out interprocedural analysis and optimizations.
Reference: [7] <author> K. De Bosschere, S. K. Debray, D. Gudeman, and S. Kannan, </author> <title> Call Forwarding: A Simple Interprocedural Optimization Technique for Dynamically Typed Languages, </title> <booktitle> Proc. 21st. ACM Symposium on Principles of Programming Languages, </booktitle> <address> Portland, Oregon, </address> <month> Jan. </month> <year> 1994, </year> <pages> pp. 409-420. </pages>
Reference-contexts: This has the disadvantage that some possible optimizations may be missed because they depend on propagating information across procedure boundaries. This is addressed to some extent in procedure-call-intensive programming languages, such as Prolog and Scheme, that rely greatly on inter-procedural analyses and optimizations <ref> [7, 18, 25, 29] </ref>; recent years have also seen a great deal of interest in inter-procedural analyses for languages like C (see, for example, [8, 9, 19, 22, 31]).
Reference: [8] <author> A. Deutsch, </author> <title> Interprocedural May-Alias Analysis for Pointers: Beyond k-Limiting, </title> <booktitle> Proc. SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1994, </year> <pages> pp. 230-241. </pages>
Reference-contexts: This is addressed to some extent in procedure-call-intensive programming languages, such as Prolog and Scheme, that rely greatly on inter-procedural analyses and optimizations [7, 18, 25, 29]; recent years have also seen a great deal of interest in inter-procedural analyses for languages like C (see, for example, <ref> [8, 9, 19, 22, 31] </ref>). However, even here the scope of the possible analyses and optimizations are limited to code that is available for examination at compile time. <p> This has the advantages of simplicity and efficiency: nothing special needs to be done to handle inter-procedural control flow, and a procedure does not have to be re-analyzed for its various call-sites <ref> [2, 3, 8, 22] </ref>. The problem is that such analyses can suffer from a loss of precision because they can explore execution paths containing call/return pairs that do not correspond to each other and therefore cannot occur in any execution of the program.
Reference: [9] <author> M. Emami, R. Ghiya, and L. J. Hendren, </author> <title> Context-Sensitive Interprocedural Analysis in the Presence of Function Pointers, </title> <booktitle> Proc. SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1994, </year> <pages> pp. 242-256. </pages>
Reference-contexts: This is addressed to some extent in procedure-call-intensive programming languages, such as Prolog and Scheme, that rely greatly on inter-procedural analyses and optimizations [7, 18, 25, 29]; recent years have also seen a great deal of interest in inter-procedural analyses for languages like C (see, for example, <ref> [8, 9, 19, 22, 31] </ref>). However, even here the scope of the possible analyses and optimizations are limited to code that is available for examination at compile time. <p> Context-sensitive analyses, by contrast, avoid this problem by maintaining information about which return edges correspond to which call sites, and propagating information only along realizable call/return paths <ref> [9, 19, 31] </ref>. The price paid for this improvement in precision is an increase in the cost of analysis. The analyses implemented in alto are relatively straightforward interprocedural liveness analyses [1], restricted to registers, and extended to deal with idiosyncracies of the Alpha instruction set.
Reference: [10] <author> M. Feeley, Gambit-C, </author> <title> version 2.8c: a portable implementation of Scheme, </title> <address> Edition 2.8c, </address> <institution> Dept. of Computer Science and Operations Research, University of Montreal, </institution> <month> Feb. </month> <year> 1998. </year>
Reference-contexts: Overall, profile-directed inter-file and link-time optimization using om produced an average improvement of 2.6%, while for alto the figure is 17.1%. 6.2 Scheme Programs To evaluate alto on Scheme programs, we used two different optimizing Scheme compilers: Bigloo version 1.8, by Serrano [24], and Gambit-C version 3.0 by Feeley <ref> [10] </ref>. Our experiments were run using nine commonly used Scheme benchmarks, whose characteristics are reported in Appendix B.2.
Reference: [11] <author> M. F. Fernandez, </author> <title> Simple and Effective Link-Time Optimization of Modula-3 Programs, </title> <booktitle> Proc. SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995, </year> <pages> pp. 103-115. </pages>
Reference-contexts: Link-time register allocation, aimed at allowing global variables to be kept in registers and reducing register saves and restores at inter-module calls, is discussed by Santhanam and Odnert [23] and Wall [30]. The Zuse Translation System [6] and the mld link-time optimizer <ref> [11] </ref> are aimed at reducing the cost of abstraction in object-oriented languages. Machine-level global optimization is discussed also by Johnson and Miller [17], but unlike alto, this system does not carry out interprocedural analysis and optimizations.
Reference: [12] <author> D. W. Goodwin, </author> <title> Interprocedural dataflow analysis in an executable optimizer, </title> <booktitle> In Proc. ACM SIGPLAN '97 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 122-133, </pages> <month> June </month> <year> 1997. </year>
Reference: [13] <author> R. E. Griswold and M. T. Griswold, </author> <title> The Implementation of the Icon Programming Language, </title> <publisher> Princeton University Press, </publisher> <year> 1986. </year>
Reference-contexts: As an example of this optimization, consider the following (heavily executed) basic block from the Icon interpreter v9.3.1 <ref> [13] </ref>, corresponding to the code to interpret a byte code instruction using an indirect jump through a jump table: ldq $28,0x9018 ($29) s4addq $21,$28,$28 ldl $28,0x0018 ($28) addq $28,$29,$28 jmp $31 ($28) (a) original code ldah $28,0xfffd ($29) lda $28,0xeb9c ($28) s4addq $21,$28,$28 ldl $28,0x0000 ($28) addq $28,$29,$28 jmp $31 ($28)
Reference: [14] <author> D. Grove, J. Dean, C. Garrett, and C. Chambers, </author> <title> Profile-Guided Receiver Class Prediction, </title> <booktitle> Proc. Tenth Annual Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA '95), </booktitle> <month> Oct. </month> <year> 1995, </year> <pages> pp. 108-123. 20 </pages>
Reference-contexts: The notion of guarded inlining is conceptually very similar to a technique for optimizing dynamically dispatched function calls in object-oriented languages called receiver class prediction <ref> [14] </ref>. The transformation we describe is somewhat more general, for two reasons. First, it doesn't rely on specific language features such as an inheritance hierarchy, and so is applicable to any language. More importantly, it can be adapted to any indirect jump, not just indirect function calls.
Reference: [15] <author> F. Henglein, </author> <title> Global Tagging Optimization by Type Inference, </title> <booktitle> Proc. 1992 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pp. 205-215. </pages>
Reference: [16] <author> S. Jagannathan and A. Wright, </author> <title> Flow-directed Inlining, </title> <booktitle> Proc. SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <month> May </month> <year> 1996, </year> <pages> pp. 193-205. </pages>
Reference-contexts: Traditional C compilers usually don't inline functions that are called indirectly at a call site. Some Scheme compilers deal with higher order functions using sophisticated control flow analyses <ref> [16] </ref> that are, we believe, too expensive to be practical at the level of machine code. Instead, we use a simple profile-guided inlining technique we call guarded inlining to achieve similar results. Suppose we have an indirect function call whose target we are unable to resolve. <p> This mechanism allows us to get the benefits of inlining even for call sites that can, in fact, have multiple possible targets, in contrast to schemes that require control flow analysis to identify a unique target for a call site before inlining can take place <ref> [16] </ref>.
Reference: [17] <author> M. S. Johnson and T. C. Miller, </author> <title> Effectiveness of a Machine-Level Global Optimizer, </title> <booktitle> Proc. SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <month> June </month> <year> 1986, </year> <pages> pp. 99-108. </pages>
Reference-contexts: The Zuse Translation System [6] and the mld link-time optimizer [11] are aimed at reducing the cost of abstraction in object-oriented languages. Machine-level global optimization is discussed also by Johnson and Miller <ref> [17] </ref>, but unlike alto, this system does not carry out interprocedural analysis and optimizations. The system that is the closest to ours is the OM link-time optimizer [27, 28].
Reference: [18] <author> D. Krantz, </author> <title> ORBIT: An Optimizing Compiler for Scheme, </title> <type> Ph.D. Dissertation, </type> <institution> Yale University, </institution> <year> 1988. </year> <note> (Also available as Technical Report YALEU/DCS/RR-632, </note> <institution> Dept. of Computer Science, Yale University, </institution> <month> Feb. </month> <year> 1988.) </year>
Reference-contexts: This has the disadvantage that some possible optimizations may be missed because they depend on propagating information across procedure boundaries. This is addressed to some extent in procedure-call-intensive programming languages, such as Prolog and Scheme, that rely greatly on inter-procedural analyses and optimizations <ref> [7, 18, 25, 29] </ref>; recent years have also seen a great deal of interest in inter-procedural analyses for languages like C (see, for example, [8, 9, 19, 22, 31]).
Reference: [19] <author> W. Landi and B. G. Ryder, </author> <title> A Safe Approximate Algorithm for Interprocedural Pointer Aliasing, </title> <booktitle> Proc. SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992, </year> <pages> pp. 235-248. </pages>
Reference-contexts: This is addressed to some extent in procedure-call-intensive programming languages, such as Prolog and Scheme, that rely greatly on inter-procedural analyses and optimizations [7, 18, 25, 29]; recent years have also seen a great deal of interest in inter-procedural analyses for languages like C (see, for example, <ref> [8, 9, 19, 22, 31] </ref>). However, even here the scope of the possible analyses and optimizations are limited to code that is available for examination at compile time. <p> Context-sensitive analyses, by contrast, avoid this problem by maintaining information about which return edges correspond to which call sites, and propagating information only along realizable call/return paths <ref> [9, 19, 31] </ref>. The price paid for this improvement in precision is an increase in the cost of analysis. The analyses implemented in alto are relatively straightforward interprocedural liveness analyses [1], restricted to registers, and extended to deal with idiosyncracies of the Alpha instruction set.
Reference: [20] <author> S. McFarling, </author> <title> Procedure Merging with Instruction Caches, </title> <booktitle> Proc. SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1991, </year> <pages> pp. 71-79. </pages>
Reference-contexts: More sophisticated strategies are possible <ref> [20] </ref>, but these have not been implemented within alto at this time. Inlining through indirect function calls, e.g., via function pointers in C or due to higher order functions in languages such as Scheme, is generally considered problematic.
Reference: [21] <author> K. Pettis and R. C. Hansen, </author> <title> Profile-Guided Code Positioning, </title> <booktitle> Proc. SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1990, </year> <pages> pp. 16-27. </pages>
Reference-contexts: This is followed by a function inlining phase. The fourth phase repeats the optimizations carried out in the second phase to the code resulting from inlining. The final phase carries out profile-directed code layout <ref> [21] </ref>, instruction scheduling, and insertion of no-ops for alignment purposes, after which the code is written out. 3 Control Flow Analysis Traditional compilers generally construct control flow graphs for individual functions, based on some intermediate representation of the program. <p> The final reason is to improve branch prediction and instruction cache behavior using profile-directed code layout <ref> [21] </ref>.
Reference: [22] <author> E. Ruf, </author> <title> Context-Insensitive Alias Analysis Revisited, </title> <booktitle> Proc. SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995, </year> <pages> pp. 13-22. </pages>
Reference-contexts: This is addressed to some extent in procedure-call-intensive programming languages, such as Prolog and Scheme, that rely greatly on inter-procedural analyses and optimizations [7, 18, 25, 29]; recent years have also seen a great deal of interest in inter-procedural analyses for languages like C (see, for example, <ref> [8, 9, 19, 22, 31] </ref>). However, even here the scope of the possible analyses and optimizations are limited to code that is available for examination at compile time. <p> This has the advantages of simplicity and efficiency: nothing special needs to be done to handle inter-procedural control flow, and a procedure does not have to be re-analyzed for its various call-sites <ref> [2, 3, 8, 22] </ref>. The problem is that such analyses can suffer from a loss of precision because they can explore execution paths containing call/return pairs that do not correspond to each other and therefore cannot occur in any execution of the program.
Reference: [23] <author> V. Santhanam and D. Odnert, </author> <title> Register Allocation across Procedure and Module Boundaries, </title> <booktitle> Proc. SIG-PLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1990, </year> <pages> pp. 28-39 </pages>
Reference-contexts: Link-time code optimization has been considered by a number of other researchers. Link-time register allocation, aimed at allowing global variables to be kept in registers and reducing register saves and restores at inter-module calls, is discussed by Santhanam and Odnert <ref> [23] </ref> and Wall [30]. The Zuse Translation System [6] and the mld link-time optimizer [11] are aimed at reducing the cost of abstraction in object-oriented languages. Machine-level global optimization is discussed also by Johnson and Miller [17], but unlike alto, this system does not carry out interprocedural analysis and optimizations.
Reference: [24] <author> M. Serrano and P. Weis, Bigloo: </author> <title> a portable and optimizing compiler for strict functional languages Proc. </title> <booktitle> Static Analysis Symposium (SAS '95), </booktitle> <year> 1995, </year> <pages> pp. 366-381. </pages>
Reference-contexts: Overall, profile-directed inter-file and link-time optimization using om produced an average improvement of 2.6%, while for alto the figure is 17.1%. 6.2 Scheme Programs To evaluate alto on Scheme programs, we used two different optimizing Scheme compilers: Bigloo version 1.8, by Serrano <ref> [24] </ref>, and Gambit-C version 3.0 by Feeley [10]. Our experiments were run using nine commonly used Scheme benchmarks, whose characteristics are reported in Appendix B.2.
Reference: [25] <author> O. Shivers, </author> <title> Control Flow Analysis in Scheme, </title> <booktitle> Proc. SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1988, </year> <pages> pp. 164-174. </pages>
Reference-contexts: This has the disadvantage that some possible optimizations may be missed because they depend on propagating information across procedure boundaries. This is addressed to some extent in procedure-call-intensive programming languages, such as Prolog and Scheme, that rely greatly on inter-procedural analyses and optimizations <ref> [7, 18, 25, 29] </ref>; recent years have also seen a great deal of interest in inter-procedural analyses for languages like C (see, for example, [8, 9, 19, 22, 31]).
Reference: [26] <author> A. Srivastava, </author> <title> Unreachable Procedures in Object-Oriented Programming, </title> <journal> ACM Letters on Programming Languages and Systems vol. </journal> <volume> 1 no. 4, </volume> <month> Dec. </month> <year> 1992, </year> <pages> pp. 355-364. </pages>
Reference-contexts: On the average, about 10% of the instructions in our benchmarks were found to be unreachable. This is somewhat higher than the results of Srivastava, whose estimate of the amount of unreachable code in C and Fortran programs was about 4%-6% <ref> [26] </ref>.
Reference: [27] <author> A. Srivastava and D. W. Wall, </author> <title> A Practical System for Intermodule Code Optimization at Link-Time, </title> <journal> Journal of Programming Languages, </journal> <pages> pp. 1-18, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Experiments indicate that even though it currently implements only relatively simple analysesfor example, checks for pointer aliasing are only implemented in the most rudimentary and conservative waythe performance of the code generated by the system is considerably better than that generated by the om link-time optimizer <ref> [27] </ref> supplied by DEC. Link-time code optimization has been considered by a number of other researchers. Link-time register allocation, aimed at allowing global variables to be kept in registers and reducing register saves and restores at inter-module calls, is discussed by Santhanam and Odnert [23] and Wall [30]. <p> Machine-level global optimization is discussed also by Johnson and Miller [17], but unlike alto, this system does not carry out interprocedural analysis and optimizations. The system that is the closest to ours is the OM link-time optimizer <ref> [27, 28] </ref>. OM translates object files compiled on DEC Alpha or MIPS architectures into a higher-level 1 internal representation, carries out various optimizations on this, then regenerates executable code from the opti-mized internal representation. By contrast, alto operates directly on a (minor) extension to the Alpha instruction set. <p> This section presents the overall performance improvements attained using alto, and compares this with the performance obtained using inter-file and profile-directed optimizations within the compiler together with link-time optimization using the om link-time optimizer <ref> [27] </ref>. Because most of the development, testing, and testing of alto was carried out using C benchmarks, we wanted to evaluate its effect on code generated from source programs in very different languages. To this end, we also tested it on a set of Scheme and Prolog programs. <p> using the existing capabilities of the compilation and optimization tools available under Digital Unix, we measured the performance of the programs when compiled at the same optimization level as before, but additionally with inter-file optimization turned on, guided by profile feedback, and with link-time optimization via the om link-time optimizer <ref> [27] </ref>. For this, the programs were compiled as follows: 1. <p> Experiments indicate that even though it currently implements only relatively simple analysesfor example, checks for pointer aliasing are only implemented in the most rudimentary and conservative waythe performance of the code generated by the system is, on the average, significantly better than that generated by the om link-time optimizer <ref> [27] </ref> supplied by DEC.
Reference: [28] <author> A. Srivastava and D. W. Wall, </author> <title> Link-time Optimization of Address Calculation on a 64-bit Architecture, </title> <booktitle> Proc. SIGPLAN '94 Conference Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1994, </year> <pages> pp. 49-60. </pages>
Reference-contexts: Machine-level global optimization is discussed also by Johnson and Miller [17], but unlike alto, this system does not carry out interprocedural analysis and optimizations. The system that is the closest to ours is the OM link-time optimizer <ref> [27, 28] </ref>. OM translates object files compiled on DEC Alpha or MIPS architectures into a higher-level 1 internal representation, carries out various optimizations on this, then regenerates executable code from the opti-mized internal representation. By contrast, alto operates directly on a (minor) extension to the Alpha instruction set. <p> The basic optimization is described by Srivastava and Wall <ref> [28] </ref>; in alto it is generalized so that a constant can be computed from a known value in any register, not just $31 or gp.
Reference: [29] <author> P. Van Roy, </author> <title> Can Logic Programming Execute as Fast as Imperative Programming? PhD thesis, </title> <institution> University of California at Berkeley, </institution> <year> 1990. </year>
Reference-contexts: This has the disadvantage that some possible optimizations may be missed because they depend on propagating information across procedure boundaries. This is addressed to some extent in procedure-call-intensive programming languages, such as Prolog and Scheme, that rely greatly on inter-procedural analyses and optimizations <ref> [7, 18, 25, 29] </ref>; recent years have also seen a great deal of interest in inter-procedural analyses for languages like C (see, for example, [8, 9, 19, 22, 31]).
Reference: [30] <author> D. W. Wall, </author> <title> Global Register Allocation at Link Time, </title> <booktitle> Proc. SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <month> July </month> <year> 1986, </year> <pages> pp. 264-275. </pages>
Reference-contexts: Link-time code optimization has been considered by a number of other researchers. Link-time register allocation, aimed at allowing global variables to be kept in registers and reducing register saves and restores at inter-module calls, is discussed by Santhanam and Odnert [23] and Wall <ref> [30] </ref>. The Zuse Translation System [6] and the mld link-time optimizer [11] are aimed at reducing the cost of abstraction in object-oriented languages. Machine-level global optimization is discussed also by Johnson and Miller [17], but unlike alto, this system does not carry out interprocedural analysis and optimizations. <p> At link time, accesses to globals from different modules become evident, making it possible to keep them in registers <ref> [30] </ref>; inlining across module boundaries, and of library routines, may make it possible to resolve aliasing beyond what can be done at compile time; and a link time optimizer may be able to scavenge registers that can be used to hold values that were spilled to memory by the compiler.
Reference: [31] <author> R. P. Wilson and M. S. Lam, </author> <title> Efficient Context-Sensitive Pointer Analysis for C Programs, </title> <booktitle> Proc. SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995, </year> <pages> pp. 1-12. 21 </pages>
Reference-contexts: This is addressed to some extent in procedure-call-intensive programming languages, such as Prolog and Scheme, that rely greatly on inter-procedural analyses and optimizations [7, 18, 25, 29]; recent years have also seen a great deal of interest in inter-procedural analyses for languages like C (see, for example, <ref> [8, 9, 19, 22, 31] </ref>). However, even here the scope of the possible analyses and optimizations are limited to code that is available for examination at compile time. <p> Context-sensitive analyses, by contrast, avoid this problem by maintaining information about which return edges correspond to which call sites, and propagating information only along realizable call/return paths <ref> [9, 19, 31] </ref>. The price paid for this improvement in precision is an increase in the cost of analysis. The analyses implemented in alto are relatively straightforward interprocedural liveness analyses [1], restricted to registers, and extended to deal with idiosyncracies of the Alpha instruction set.
References-found: 31

