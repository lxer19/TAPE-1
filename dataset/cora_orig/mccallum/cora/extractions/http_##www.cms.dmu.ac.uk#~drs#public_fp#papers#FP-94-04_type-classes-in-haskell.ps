URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/FP-94-04_type-classes-in-haskell.ps
Refering-URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/
Root-URL: 
Title: Type classes in Haskell  
Author: Cordelia Hall, Kevin Hammond, Simon Peyton Jones and Philip Wadler 
Date: January 20, 1994  
Affiliation: University of Glasgow  
Abstract: This paper defines a set of type inference rules for resolving overloading introduced by type classes. Programs including type classes are transformed into ones which may be typed by the Hindley-Milner inference rules. In contrast to other work on type classes, the rules presented here relate directly to user programs. An innovative aspect of this work is the use of second-order lambda calculus to record type information in the program. 
Abstract-found: 1
Intro-found: 1
Reference: [Aug93] <author> L. Augustsson, </author> <title> Implementing Haskell Overloading. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: At the same time, these rules and the monad-based [Wad92] implementation they support provide a clean, `high-level' specification for the implementation of a typechecker, unlike more implementation oriented papers <ref> [HaBl89, Aug93, Jon92b] </ref>.
Reference: [Blo91] <author> S. Blott, </author> <title> Type classes. </title> <type> Ph.D. Thesis, </type> <institution> Glasgow University, </institution> <year> 1991. </year>
Reference-contexts: This system was originally described fl This work is supported by the SERC AQUA Project. Authors' address: Computing Science Dept, Glasgow University, 17 Lilybank Gdns., Glasgow, Scotland. Email: fcvh, kh, simonpj, wadlerg@dcs.glasgow.ac.uk 1 Miranda is a trademark of Research Software Limited. by Wadler and Blott <ref> [WB89, Blo91] </ref>, and a similar proposal was made independently by Kaes [Kae88]. The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. <p> We have deliberately adopted many of the same techniques they use for mastering complexity. This approach unites theory and practice. The industrial grade rules given here provide a useful complement to the more theoretical approaches of Wadler and Blott <ref> [WB89, Blo91] </ref>, Nipkow and Snelting [NS91], Nipkow and Prehofer [NP93], and Jones [Jon92a, Jon93]. A number of simplifying assumptions made in those papers are not made here. Unlike [WB89], it is not assumed that each class has exactly one operation.
Reference: [Car87] <author> L. Cardelli, </author> <title> Basic Polymorphic Typechecking. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> Vol. 8, </volume> <year> 1987, </year> <pages> pp. 147-172. </pages>
Reference-contexts: However, the introduction given here is necessarily cursory; for further motivating examples, see the original paper by Wadler and Blott [WB89]. For a comparison of the Hindley-Milner and Girard-Reynolds systems, see the excellent summary by Reynolds [Rey85]. For a practicum on Hindley-Milner type inference, see the tutorials by Cardelli <ref> [Car87] </ref> or Hancock [Han87]. The remainder of this paper is organised as follows. Section 2 introduces type classes and our translation method. Section 3 describes the various notations used in presenting the inferences rules.
Reference: [CHO92] <author> K. Chen, P. Hudak, and M. Odersky, </author> <title> Parametric Type Classes. </title> <booktitle> In Lisp and Functional Programming, </booktitle> <year> 1992, </year> <pages> pp. 170-181. </pages>
Reference-contexts: There has been closely related work by Rouaix [Rou90] and Comack and Wright [CW90], and work directly inspired by type classes includes Nipkow and Snelting [NS91], Volpano and Smith [VS91], Jones [Jon92a, Jon93], Nipkow and Prehofer [NP93], Odersky and Laufer [OdLa91], Laufer [Lau92, Lau93], and Chen, Hudak and Odersky <ref> [CHO92] </ref>. The paper presents a source language (lambda calculus with implicit typing and with overloading) and a target language (polymorphic lambda calculus with explicit typing and without overloading). The semantics of the former is provided by translation into the latter, which has a well-known semantics [Hue 90].
Reference: [CW90] <author> G. V. Comack and A. K. Wright, </author> <title> Type dependent parameter inference. </title> <booktitle> In Programming Language Design and Implementation, </booktitle> <address> White Plains, New York, June 1990, </address> <publisher> ACM Press. </publisher>
Reference-contexts: The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. There has been closely related work by Rouaix [Rou90] and Comack and Wright <ref> [CW90] </ref>, and work directly inspired by type classes includes Nipkow and Snelting [NS91], Volpano and Smith [VS91], Jones [Jon92a, Jon93], Nipkow and Prehofer [NP93], Odersky and Laufer [OdLa91], Laufer [Lau92, Lau93], and Chen, Hudak and Odersky [CHO92].
Reference: [DM82] <author> L. Damas and R. Milner, </author> <title> Principal type schemes for functional programs. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <address> Al-buquerque, N.M., </address> <month> January </month> <year> 1982. </year>
Reference-contexts: The target language used here differs in that all polymor-phism has been made explicit. In [WB89, NS91, Jon92a], the target language resembles the implicitly typed polymorphic lambda calculus of Hindley and Milner <ref> [Hin69, Mil78, DM82] </ref>. Here, the target language resembles the explicitly typed second-order polymorphic lambda calculus of Girard and Reynolds [Gir72, Rey74]. It has constructs for type abstraction and application, and each bound variable is labeled with its type.
Reference: [Gir72] <author> J.-Y. Girard, </author> <title> Interpretation functionelle et elimination des coupures dans l'arithmetique d'ordre superieure. </title> <type> Ph.D. thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: In [WB89, NS91, Jon92a], the target language resembles the implicitly typed polymorphic lambda calculus of Hindley and Milner [Hin69, Mil78, DM82]. Here, the target language resembles the explicitly typed second-order polymorphic lambda calculus of Girard and Reynolds <ref> [Gir72, Rey74] </ref>. It has constructs for type abstraction and application, and each bound variable is labeled with its type. The reason for using this as our target language is that it makes it easy to extract a type from any subterm.
Reference: [HaBl89] <author> K. Hammond and S. Blott, </author> <title> Implementing Haskell Type Classes. </title> <booktitle> In 1989 Glasgow Workshop on Functional Programming, </booktitle> <address> Fraserburgh, Scotland, September 1989, </address> <publisher> Springer-Verlag WICS, </publisher> <pages> pp. 266-286. </pages>
Reference-contexts: At the same time, these rules and the monad-based [Wad92] implementation they support provide a clean, `high-level' specification for the implementation of a typechecker, unlike more implementation oriented papers <ref> [HaBl89, Aug93, Jon92b] </ref>.
Reference: [Han87] <author> P. Hancock, </author> <title> Chapters 8 and 9 In S. </title> <editor> L. Pey-ton Jones, </editor> <booktitle> The implementation of functional programming languages, Prentice-Hall International, </booktitle> <address> Englewood Cliffs, New Jersey, </address> <year> 1987. </year>
Reference-contexts: For a comparison of the Hindley-Milner and Girard-Reynolds systems, see the excellent summary by Reynolds [Rey85]. For a practicum on Hindley-Milner type inference, see the tutorials by Cardelli [Car87] or Hancock <ref> [Han87] </ref>. The remainder of this paper is organised as follows. Section 2 introduces type classes and our translation method. Section 3 describes the various notations used in presenting the inferences rules.
Reference: [Hin69] <author> R. Hindley, </author> <title> The principal type scheme of an object in combinatory logic. </title> <journal> Trans. Am. Math. Soc. </journal> <volume> 146, </volume> <month> December </month> <year> 1969, </year> <pages> pp. 29-60, </pages> . 
Reference-contexts: The target language used here differs in that all polymor-phism has been made explicit. In [WB89, NS91, Jon92a], the target language resembles the implicitly typed polymorphic lambda calculus of Hindley and Milner <ref> [Hin69, Mil78, DM82] </ref>. Here, the target language resembles the explicitly typed second-order polymorphic lambda calculus of Girard and Reynolds [Gir72, Rey74]. It has constructs for type abstraction and application, and each bound variable is labeled with its type.
Reference: [HPW92] <editor> P. Hudak, S. L. Peyton Jones, and P. Wadler, editors, </editor> <title> Report on the Programming Language Haskell, Version 1.2. </title> <journal> SIGPLAN Notices, </journal> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction A funny thing happened on the way to Haskell <ref> [HPW92] </ref>. The goal of the Haskell committee was to design a standard lazy functional language, applying existing, well-understood methods. To the committee's surprise, it emerged that there was no standard way to provide overloaded operations such as equality (==), arithmetic (+), and conversion to a string (show).
Reference: [Hue 90] <editor> Gerard Huet, editor, </editor> <booktitle> Logical Foundations of Functional Programming, </booktitle> <publisher> Addison Wesley, </publisher> <year> 1990. </year> <title> See Part II, Polymorphic Lambda Calculus, especially the introduction by Reynolds. </title>
Reference-contexts: The paper presents a source language (lambda calculus with implicit typing and with overloading) and a target language (polymorphic lambda calculus with explicit typing and without overloading). The semantics of the former is provided by translation into the latter, which has a well-known semantics <ref> [Hue 90] </ref>. Normally, one expects a theorem stating that the translation is sound, in that the translation preserves the meaning of programs. That is not possible here, as the translation defines the meaning of programs.
Reference: [Jon92a] <author> M. P. Jones, </author> <title> A theory of qualified types. </title> <booktitle> In European Symposium on Programming, Rennes, </booktitle> <month> February </month> <year> 1992, </year> <note> LNCS 582, Springer-Verlag. </note>
Reference-contexts: The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. There has been closely related work by Rouaix [Rou90] and Comack and Wright [CW90], and work directly inspired by type classes includes Nipkow and Snelting [NS91], Volpano and Smith [VS91], Jones <ref> [Jon92a, Jon93] </ref>, Nipkow and Prehofer [NP93], Odersky and Laufer [OdLa91], Laufer [Lau92, Lau93], and Chen, Hudak and Odersky [CHO92]. The paper presents a source language (lambda calculus with implicit typing and with overloading) and a target language (polymorphic lambda calculus with explicit typing and without overloading). <p> This approach unites theory and practice. The industrial grade rules given here provide a useful complement to the more theoretical approaches of Wadler and Blott [WB89, Blo91], Nipkow and Snelting [NS91], Nipkow and Prehofer [NP93], and Jones <ref> [Jon92a, Jon93] </ref>. A number of simplifying assumptions made in those papers are not made here. Unlike [WB89], it is not assumed that each class has exactly one operation. Unlike [NS91], it is not assumed that the intersection of every pair of classes must be separately declared. <p> A number of simplifying assumptions made in those papers are not made here. Unlike [WB89], it is not assumed that each class has exactly one operation. Unlike [NS91], it is not assumed that the intersection of every pair of classes must be separately declared. Unlike <ref> [Jon92a] </ref>, we deal directly with instance and class declarations. Each of those papers emphasises one aspect or another of the theory, while this paper stresses what we learned from practice. <p> A further contribution of this work is the use of explicit polymorphism in the target language, as described in the next section. 1.2 A target language with explicit poly morphism As in <ref> [WB89, NS91, Jon92a] </ref>, the rules given here specify a translation from a source language with type classes to a target language without them. The translation implements type classes by introducing extra parameters to overloaded functions, which are instantiated at the calling point with dictionaries that define the overloaded operations. <p> The translation implements type classes by introducing extra parameters to overloaded functions, which are instantiated at the calling point with dictionaries that define the overloaded operations. The target language used here differs in that all polymor-phism has been made explicit. In <ref> [WB89, NS91, Jon92a] </ref>, the target language resembles the implicitly typed polymorphic lambda calculus of Hindley and Milner [Hin69, Mil78, DM82]. Here, the target language resembles the explicitly typed second-order polymorphic lambda calculus of Girard and Reynolds [Gir72, Rey74].
Reference: [Jon92b] <author> M. P. Jones, </author> <title> Efficient Implementation of Type Class Overloading. </title> <institution> Dept. of Computing Science, Oxford University. </institution>
Reference-contexts: At the same time, these rules and the monad-based [Wad92] implementation they support provide a clean, `high-level' specification for the implementation of a typechecker, unlike more implementation oriented papers <ref> [HaBl89, Aug93, Jon92b] </ref>.
Reference: [Jon93] <author> M. P. Jones, </author> <title> A System of Constructor Classes: Overloading and Implicit Higher-Order Poly-morphism. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <address> Copenhagen, </address> <month> June </month> <year> 1993, </year> <pages> pp. 52-61. </pages>
Reference-contexts: The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. There has been closely related work by Rouaix [Rou90] and Comack and Wright [CW90], and work directly inspired by type classes includes Nipkow and Snelting [NS91], Volpano and Smith [VS91], Jones <ref> [Jon92a, Jon93] </ref>, Nipkow and Prehofer [NP93], Odersky and Laufer [OdLa91], Laufer [Lau92, Lau93], and Chen, Hudak and Odersky [CHO92]. The paper presents a source language (lambda calculus with implicit typing and with overloading) and a target language (polymorphic lambda calculus with explicit typing and without overloading). <p> This approach unites theory and practice. The industrial grade rules given here provide a useful complement to the more theoretical approaches of Wadler and Blott [WB89, Blo91], Nipkow and Snelting [NS91], Nipkow and Prehofer [NP93], and Jones <ref> [Jon92a, Jon93] </ref>. A number of simplifying assumptions made in those papers are not made here. Unlike [WB89], it is not assumed that each class has exactly one operation. Unlike [NS91], it is not assumed that the intersection of every pair of classes must be separately declared.
Reference: [Kae88] <author> S. Kaes, </author> <title> Parametric polymorphism. </title> <booktitle> In European Symposium on Programming, </booktitle> <address> Nancy, France, March 1988, </address> <publisher> LNCS 300, Springer-Verlag. </publisher>
Reference-contexts: Authors' address: Computing Science Dept, Glasgow University, 17 Lilybank Gdns., Glasgow, Scotland. Email: fcvh, kh, simonpj, wadlerg@dcs.glasgow.ac.uk 1 Miranda is a trademark of Research Software Limited. by Wadler and Blott [WB89, Blo91], and a similar proposal was made independently by Kaes <ref> [Kae88] </ref>. The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. <p> It is a grave shortcoming of the system presented here is that there is no direct way of assigning meaning to a program, and it must be done indirectly via translation; but there appears to be no alternative. (Note, however, that <ref> [Kae88] </ref> does give a direct semantics for a slightly simpler form of overloading.) The original type inference rules given in [WB89] were deliberately rather sparse, and were not intended to reflect the Haskell language precisely.
Reference: [Lau92] <editor> Polymorphic Type Inference and Abstract Data Types. K. </editor> <title> Laufer, </title> <type> Ph.D. Thesis, </type> <address> New York University, </address> <year> 1992. </year>
Reference-contexts: There has been closely related work by Rouaix [Rou90] and Comack and Wright [CW90], and work directly inspired by type classes includes Nipkow and Snelting [NS91], Volpano and Smith [VS91], Jones [Jon92a, Jon93], Nipkow and Prehofer [NP93], Odersky and Laufer [OdLa91], Laufer <ref> [Lau92, Lau93] </ref>, and Chen, Hudak and Odersky [CHO92]. The paper presents a source language (lambda calculus with implicit typing and with overloading) and a target language (polymorphic lambda calculus with explicit typing and without overloading).
Reference: [Lau93] <institution> An Extension of Haskell with First-Class Abstract Types. K. Laufer, </institution> <type> Technical Report, </type> <institution> Loy-ola University of Chicago, </institution> <year> 1993. </year>
Reference-contexts: There has been closely related work by Rouaix [Rou90] and Comack and Wright [CW90], and work directly inspired by type classes includes Nipkow and Snelting [NS91], Volpano and Smith [VS91], Jones [Jon92a, Jon93], Nipkow and Prehofer [NP93], Odersky and Laufer [OdLa91], Laufer <ref> [Lau92, Lau93] </ref>, and Chen, Hudak and Odersky [CHO92]. The paper presents a source language (lambda calculus with implicit typing and with overloading) and a target language (polymorphic lambda calculus with explicit typing and without overloading).
Reference: [MTH90] <author> R. Milner, M. Tofte, and R. Harper, </author> <title> The definition of Standard ML, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: To the committee's surprise, it emerged that there was no standard way to provide overloaded operations such as equality (==), arithmetic (+), and conversion to a string (show). Languages such as Miranda 1 [Tur85] and Standard ML <ref> [MTH90, MT91] </ref> offer differing solutions to these problems. The solutions differ not only between languages, but within a language. <p> Writing down the rules has enabled us to discover bugs in the various prototypes, and to ensure that similar errors cannot arise in our new compiler. We have been inspired in our work by the formal semantics of Standard ML prepared by Milner, Tofte, and Harper <ref> [MTH90, MT91] </ref>. We have deliberately adopted many of the same techniques they use for mastering complexity. This approach unites theory and practice.
Reference: [MT91] <author> R. Milner and M. Tofte, </author> <title> Commentary on Standard ML, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1991. </year>
Reference-contexts: To the committee's surprise, it emerged that there was no standard way to provide overloaded operations such as equality (==), arithmetic (+), and conversion to a string (show). Languages such as Miranda 1 [Tur85] and Standard ML <ref> [MTH90, MT91] </ref> offer differing solutions to these problems. The solutions differ not only between languages, but within a language. <p> Writing down the rules has enabled us to discover bugs in the various prototypes, and to ensure that similar errors cannot arise in our new compiler. We have been inspired in our work by the formal semantics of Standard ML prepared by Milner, Tofte, and Harper <ref> [MTH90, MT91] </ref>. We have deliberately adopted many of the same techniques they use for mastering complexity. This approach unites theory and practice.
Reference: [Mil78] <author> R. Milner, </author> <title> A theory of type polymorphism in programming. </title> <journal> J. Comput. Syst. Sci. </journal> <volume> 17, </volume> <year> 1978, </year> <pages> pp. 348-375. </pages>
Reference-contexts: The committee adopted a completely new technique, based on a proposal by Wadler, which extends the familiar Hindley-Milner system <ref> [Mil78] </ref> with type classes. Type classes provide a uniform solution to overloading, including providing operations for equality, arithmetic, and string conversion. They generalise the idea of equality types from Standard ML, and subsume the approach to string conversion used in Miranda. <p> The target language used here differs in that all polymor-phism has been made explicit. In [WB89, NS91, Jon92a], the target language resembles the implicitly typed polymorphic lambda calculus of Hindley and Milner <ref> [Hin69, Mil78, DM82] </ref>. Here, the target language resembles the explicitly typed second-order polymorphic lambda calculus of Girard and Reynolds [Gir72, Rey74]. It has constructs for type abstraction and application, and each bound variable is labeled with its type.
Reference: [NP93] <author> T. Nipkow and C. Prehofer, </author> <title> Type Checking Type Classes. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993, </year> <pages> pp. 409-418. </pages>
Reference-contexts: There has been closely related work by Rouaix [Rou90] and Comack and Wright [CW90], and work directly inspired by type classes includes Nipkow and Snelting [NS91], Volpano and Smith [VS91], Jones [Jon92a, Jon93], Nipkow and Prehofer <ref> [NP93] </ref>, Odersky and Laufer [OdLa91], Laufer [Lau92, Lau93], and Chen, Hudak and Odersky [CHO92]. The paper presents a source language (lambda calculus with implicit typing and with overloading) and a target language (polymorphic lambda calculus with explicit typing and without overloading). <p> We have deliberately adopted many of the same techniques they use for mastering complexity. This approach unites theory and practice. The industrial grade rules given here provide a useful complement to the more theoretical approaches of Wadler and Blott [WB89, Blo91], Nipkow and Snelting [NS91], Nipkow and Prehofer <ref> [NP93] </ref>, and Jones [Jon92a, Jon93]. A number of simplifying assumptions made in those papers are not made here. Unlike [WB89], it is not assumed that each class has exactly one operation. Unlike [NS91], it is not assumed that the intersection of every pair of classes must be separately declared.
Reference: [NS91] <author> T. Nipkow and G. Snelting, </author> <title> Type Classes and Overloading Resolution via Order-Sorted Unification. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <address> Boston, </address> <month> August </month> <year> 1991, </year> <note> LNCS 523, Springer-Verlag. </note>
Reference-contexts: The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. There has been closely related work by Rouaix [Rou90] and Comack and Wright [CW90], and work directly inspired by type classes includes Nipkow and Snelting <ref> [NS91] </ref>, Volpano and Smith [VS91], Jones [Jon92a, Jon93], Nipkow and Prehofer [NP93], Odersky and Laufer [OdLa91], Laufer [Lau92, Lau93], and Chen, Hudak and Odersky [CHO92]. <p> We have deliberately adopted many of the same techniques they use for mastering complexity. This approach unites theory and practice. The industrial grade rules given here provide a useful complement to the more theoretical approaches of Wadler and Blott [WB89, Blo91], Nipkow and Snelting <ref> [NS91] </ref>, Nipkow and Prehofer [NP93], and Jones [Jon92a, Jon93]. A number of simplifying assumptions made in those papers are not made here. Unlike [WB89], it is not assumed that each class has exactly one operation. Unlike [NS91], it is not assumed that the intersection of every pair of classes must be <p> to the more theoretical approaches of Wadler and Blott [WB89, Blo91], Nipkow and Snelting <ref> [NS91] </ref>, Nipkow and Prehofer [NP93], and Jones [Jon92a, Jon93]. A number of simplifying assumptions made in those papers are not made here. Unlike [WB89], it is not assumed that each class has exactly one operation. Unlike [NS91], it is not assumed that the intersection of every pair of classes must be separately declared. Unlike [Jon92a], we deal directly with instance and class declarations. Each of those papers emphasises one aspect or another of the theory, while this paper stresses what we learned from practice. <p> A further contribution of this work is the use of explicit polymorphism in the target language, as described in the next section. 1.2 A target language with explicit poly morphism As in <ref> [WB89, NS91, Jon92a] </ref>, the rules given here specify a translation from a source language with type classes to a target language without them. The translation implements type classes by introducing extra parameters to overloaded functions, which are instantiated at the calling point with dictionaries that define the overloaded operations. <p> The translation implements type classes by introducing extra parameters to overloaded functions, which are instantiated at the calling point with dictionaries that define the overloaded operations. The target language used here differs in that all polymor-phism has been made explicit. In <ref> [WB89, NS91, Jon92a] </ref>, the target language resembles the implicitly typed polymorphic lambda calculus of Hindley and Milner [Hin69, Mil78, DM82]. Here, the target language resembles the explicitly typed second-order polymorphic lambda calculus of Girard and Reynolds [Gir72, Rey74].
Reference: [OdLa91] <author> M. Odersky and K. Laufer, </author> <title> Type classes are signatures of abstract types. </title> <type> Technical Report, </type> <institution> IBM TJ Watson Research Centre, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: There has been closely related work by Rouaix [Rou90] and Comack and Wright [CW90], and work directly inspired by type classes includes Nipkow and Snelting [NS91], Volpano and Smith [VS91], Jones [Jon92a, Jon93], Nipkow and Prehofer [NP93], Odersky and Laufer <ref> [OdLa91] </ref>, Laufer [Lau92, Lau93], and Chen, Hudak and Odersky [CHO92]. The paper presents a source language (lambda calculus with implicit typing and with overloading) and a target language (polymorphic lambda calculus with explicit typing and without overloading).
Reference: [Pey87] <editor> S. L. Peyton Jones, </editor> <booktitle> The implementation of functional programming languages, Prentice-Hall International, </booktitle> <address> Englewood Cliffs, New Jersey, </address> <year> 1987. </year>
Reference-contexts: Types are stored in type applications and with each bound variable, rather than at every sub term. * It eases subsequent transformation. A standard and productive technique for compiling functional languages is to apply various transformations at intermediate phases <ref> [Pey87] </ref>. With annotations, each transformation must carefully preserve annotations on all sub-terms and add new annotations where required. With polymorphic lambda calculus, the usual transformation rules - e.g., fi-reduction for type abstractions preserve type information in a simple and efficient way. * It provides greater generality.
Reference: [PW91] <author> S. L. Peyton Jones and P. Wadler, </author> <title> A static semantics for Haskell. </title> <institution> Department of Computing Science, Glasgow University, </institution> <month> May </month> <year> 1991. </year> <month> 16 </month>
Reference-contexts: The rules were written to provide a precise specification of what type classes were, but we found that they also provided a blueprint for how to implement them. This paper presents a simplified subset of the rules we derived. The full static semantics of Haskell <ref> [PW91] </ref> contains over 30 judgement forms and over 100 rules. The reader will be pleased to know that this paper simplifies the rules considerably, while maintaining their essence in so far as 1 type classes are concerned. <p> First, it presents a minimal, readable set of inference rules to handle type classes in Haskell, derived from the full static semantics <ref> [PW91] </ref>. An important feature of this style of presentation is that it scales up well to a description of the entire Haskell language, as we have found in practice. Second, the paper has shown how these rules can be directly implemented using monads.
Reference: [Rey74] <author> J. C. Reynolds, </author> <title> Towards a theory of type struc-ture. </title> <editor> In B. Robinet, editor, </editor> <booktitle> Proc. Colloque sur la Programmation, </booktitle> <publisher> LNCS 19, Springer-Verlag. </publisher>
Reference-contexts: In [WB89, NS91, Jon92a], the target language resembles the implicitly typed polymorphic lambda calculus of Hindley and Milner [Hin69, Mil78, DM82]. Here, the target language resembles the explicitly typed second-order polymorphic lambda calculus of Girard and Reynolds <ref> [Gir72, Rey74] </ref>. It has constructs for type abstraction and application, and each bound variable is labeled with its type. The reason for using this as our target language is that it makes it easy to extract a type from any subterm.
Reference: [Rey85] <author> J. C. Reynolds, </author> <title> Three approaches to type structure. </title> <booktitle> In Mathematical Foundations of Software Development, </booktitle> <publisher> LNCS 185, Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: However, the introduction given here is necessarily cursory; for further motivating examples, see the original paper by Wadler and Blott [WB89]. For a comparison of the Hindley-Milner and Girard-Reynolds systems, see the excellent summary by Reynolds <ref> [Rey85] </ref>. For a practicum on Hindley-Milner type inference, see the tutorials by Cardelli [Car87] or Hancock [Han87]. The remainder of this paper is organised as follows. Section 2 introduces type classes and our translation method. Section 3 describes the various notations used in presenting the inferences rules.
Reference: [Rou90] <author> F. Rouaix, </author> <title> Safe run-time overloading. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, </address> <month> January </month> <year> 1990, </year> <note> ACM Press. </note>
Reference-contexts: The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. There has been closely related work by Rouaix <ref> [Rou90] </ref> and Comack and Wright [CW90], and work directly inspired by type classes includes Nipkow and Snelting [NS91], Volpano and Smith [VS91], Jones [Jon92a, Jon93], Nipkow and Prehofer [NP93], Odersky and Laufer [OdLa91], Laufer [Lau92, Lau93], and Chen, Hudak and Odersky [CHO92].
Reference: [Tur85] <author> D. A. Turner, Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <address> Nancy, France, </address> <month> September </month> <year> 1985, </year> <title> LNCS 201, </title> <publisher> Springer-Verlag, </publisher> <pages> pp. 1-16. </pages>
Reference-contexts: To the committee's surprise, it emerged that there was no standard way to provide overloaded operations such as equality (==), arithmetic (+), and conversion to a string (show). Languages such as Miranda 1 <ref> [Tur85] </ref> and Standard ML [MTH90, MT91] offer differing solutions to these problems. The solutions differ not only between languages, but within a language.
Reference: [VS91] <author> D. M. Volpano and G. S. Smith, </author> <title> On the complexity of ML typability with overloading. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <address> Boston, </address> <month> August </month> <year> 1991, </year> <note> LNCS 523, Springer-Verlag. </note>
Reference-contexts: The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. There has been closely related work by Rouaix [Rou90] and Comack and Wright [CW90], and work directly inspired by type classes includes Nipkow and Snelting [NS91], Volpano and Smith <ref> [VS91] </ref>, Jones [Jon92a, Jon93], Nipkow and Prehofer [NP93], Odersky and Laufer [OdLa91], Laufer [Lau92, Lau93], and Chen, Hudak and Odersky [CHO92]. The paper presents a source language (lambda calculus with implicit typing and with overloading) and a target language (polymorphic lambda calculus with explicit typing and without overloading).
Reference: [Wad92] <author> P. L. Wadler, </author> <title> The essence of functional programming. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Unlike [Jon92a], we deal directly with instance and class declarations. Each of those papers emphasises one aspect or another of the theory, while this paper stresses what we learned from practice. At the same time, these rules and the monad-based <ref> [Wad92] </ref> implementation they support provide a clean, `high-level' specification for the implementation of a typechecker, unlike more implementation oriented papers [HaBl89, Aug93, Jon92b].
Reference: [WB89] <author> P. L. Wadler and S. Blott, </author> <title> How to make ad-hoc polymorphism less ad hoc, </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, Texas, </address> <month> January </month> <year> 1989, </year> <pages> pp. 60-76. </pages>
Reference-contexts: This system was originally described fl This work is supported by the SERC AQUA Project. Authors' address: Computing Science Dept, Glasgow University, 17 Lilybank Gdns., Glasgow, Scotland. Email: fcvh, kh, simonpj, wadlerg@dcs.glasgow.ac.uk 1 Miranda is a trademark of Research Software Limited. by Wadler and Blott <ref> [WB89, Blo91] </ref>, and a similar proposal was made independently by Kaes [Kae88]. The type system of Haskell is certainly its most innovative feature, and has provoked much discussion. <p> that there is no direct way of assigning meaning to a program, and it must be done indirectly via translation; but there appears to be no alternative. (Note, however, that [Kae88] does give a direct semantics for a slightly simpler form of overloading.) The original type inference rules given in <ref> [WB89] </ref> were deliberately rather sparse, and were not intended to reflect the Haskell language precisely. As a result, there has been some confusion as to precisely how type classes in Haskell are defined. 1.1 Contributions of this paper This paper spells out the precise definition of type classes in Haskell. <p> We have deliberately adopted many of the same techniques they use for mastering complexity. This approach unites theory and practice. The industrial grade rules given here provide a useful complement to the more theoretical approaches of Wadler and Blott <ref> [WB89, Blo91] </ref>, Nipkow and Snelting [NS91], Nipkow and Prehofer [NP93], and Jones [Jon92a, Jon93]. A number of simplifying assumptions made in those papers are not made here. Unlike [WB89], it is not assumed that each class has exactly one operation. <p> The industrial grade rules given here provide a useful complement to the more theoretical approaches of Wadler and Blott [WB89, Blo91], Nipkow and Snelting [NS91], Nipkow and Prehofer [NP93], and Jones [Jon92a, Jon93]. A number of simplifying assumptions made in those papers are not made here. Unlike <ref> [WB89] </ref>, it is not assumed that each class has exactly one operation. Unlike [NS91], it is not assumed that the intersection of every pair of classes must be separately declared. Unlike [Jon92a], we deal directly with instance and class declarations. <p> A further contribution of this work is the use of explicit polymorphism in the target language, as described in the next section. 1.2 A target language with explicit poly morphism As in <ref> [WB89, NS91, Jon92a] </ref>, the rules given here specify a translation from a source language with type classes to a target language without them. The translation implements type classes by introducing extra parameters to overloaded functions, which are instantiated at the calling point with dictionaries that define the overloaded operations. <p> The translation implements type classes by introducing extra parameters to overloaded functions, which are instantiated at the calling point with dictionaries that define the overloaded operations. The target language used here differs in that all polymor-phism has been made explicit. In <ref> [WB89, NS91, Jon92a] </ref>, the target language resembles the implicitly typed polymorphic lambda calculus of Hindley and Milner [Hin69, Mil78, DM82]. Here, the target language resembles the explicitly typed second-order polymorphic lambda calculus of Girard and Reynolds [Gir72, Rey74]. <p> However, the introduction given here is necessarily cursory; for further motivating examples, see the original paper by Wadler and Blott <ref> [WB89] </ref>. For a comparison of the Hindley-Milner and Girard-Reynolds systems, see the excellent summary by Reynolds [Rey85]. For a practicum on Hindley-Milner type inference, see the tutorials by Cardelli [Car87] or Hancock [Han87]. The remainder of this paper is organised as follows.
References-found: 33

