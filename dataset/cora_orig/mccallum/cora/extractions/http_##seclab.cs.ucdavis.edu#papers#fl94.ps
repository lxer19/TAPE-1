URL: http://seclab.cs.ucdavis.edu/papers/fl94.ps
Refering-URL: http://seclab.cs.ucdavis.edu/papers.html
Root-URL: http://www.cs.ucdavis.edu
Email: email contact: gfink@cs.ucdavis.edu  
Title: Property-based testing of privileged programs  
Author: George Fink Karl Levitt 
Address: Davis, CA 95616  
Affiliation: Department of Computer Science, University of California, Davis  
Abstract: We address the problem of testing security-relevant software, especially privileged (typically setuid root) and daemon programs in UNIX. The problem is important, since it is these programs that are the source of most UNIX security flaws. For some programs, such as the UNIX sendmail program, new security flaws are still discovered, despite being in use for years. For special-purpose systems with fewer users, flaws are likely to remain undiscovered for even longer. Our testing process is driven by specifications we create for the privileged programs. These specifications simultaneously define the allowed behavior for these programs and identify problematic system calls, regions where the program is vulnerable, and generic security flaws. The specifications serve three roles in our testing methodology: as criteria against which a program is sliced, as oracles against which it is tested, and as a basis for generating useful tests. Slicing is employed to significantly reduce the size of the program to be tested. We show that a slice of a privileged program (rdist) with respect to its security specifications is quite small. We introduce the Tester's Assistant, a collection of tools to mechanize the process of testing security-related C programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. P. Abbott, J. S. Chin, J. E. Donnelley, W. L. Konigsford, S. Tokubo, and D. A. Webb. </author> <title> Security analysis and enhancements of computer operating systems. </title> <type> Technical report, </type> <institution> Lawrence Livermore Laboratory, </institution> <month> April </month> <year> 1976. </year> <note> available as NBSIR 76-1041 from National Technical Information Service. </note>
Reference-contexts: Thus, our specifications can take different forms, such as: the objects a program is allowed to access during execution, the identification of system calls that if improperly invoked would cause security problems, and characterizations of generic security flaws <ref> [1] </ref>. We use specifications for multiple purposes in our methodology, one of which is to generate slicing criteria. A slice of a program with respect to a criterion is a sub-program which has the same behavior as the full program with respect to the criterion. <p> An additional category of specification describes safety properties and other generic flaws [12] <ref> [1] </ref>. Safety properties cover common programming mistakes such as lack of argument checking, and include the well-behavedness property, described in Section 3.
Reference: [2] <author> Thomas Ball and Susan Horwitz. </author> <title> Slicing programs with arbitrary control flow. </title> <type> Technical Report 1128, </type> <institution> Department of Computer Science, University of Wisconsin-Madison, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: Using ELI, we are able to quickly prototype the Tester's Assistant. The dataflow representation has been implemented. The slicer is partially implemented: it is operational on multi-procedure programs using most of C's operations and properties, relying in part on algorithms from [10], <ref> [2] </ref>, and [5]. Pointer anti-aliasing will be introduced to make slices more efficient. Currently, the slicer makes worst case assumptions about pointer aliasing, though the well-behavedness assumption limits the scope of the aliasing assumptions. Library and system calls are being specified as necessary.
Reference: [3] <author> Robert S. Boyer, Bernard Elspas, and Karl N. Levitt. </author> <title> Select a formal system for testing and debugging programs by symbolic execution. </title> <booktitle> In Proceedings of the International Conference on Reliable Software, </booktitle> <pages> pages 234-245, </pages> <year> 1975. </year>
Reference-contexts: Test data generation So far, our discussion of property-based testing has assumed that a human generates test data. But, in part, the process for test data generation can be automated. Using a slice as an intermediary between a specification and test data generation is the key. In symbolic evaluation <ref> [3] </ref>, input data is represented by variables, and execution is controlled by a meta-interpreter for the language.
Reference: [4] <author> Richard A. DeMillo and A. Jefferson Offutt. </author> <title> Constraint based automatic test data generation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(9) </volume> <pages> 900-910, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Additionally, loop invariants and assertions often need to be provided in order to make simplifying inferences about the behavior of loops. However, symbolic evaluation becomes feasible when conditional expressions and loops are eliminated <ref> [4] </ref>. If the results of the coverage analysis reveal unexecuted paths, each path can be given to the symbolic evaluator for test data generation.
Reference: [5] <author> Michael Ernst. </author> <title> Program slicing using the value de-pendance graph. </title> <booktitle> To appear in the Proceedings of the 22nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <year> 1994. </year>
Reference-contexts: Using ELI, we are able to quickly prototype the Tester's Assistant. The dataflow representation has been implemented. The slicer is partially implemented: it is operational on multi-procedure programs using most of C's operations and properties, relying in part on algorithms from [10], [2], and <ref> [5] </ref>. Pointer anti-aliasing will be introduced to make slices more efficient. Currently, the slicer makes worst case assumptions about pointer aliasing, though the well-behavedness assumption limits the scope of the aliasing assumptions. Library and system calls are being specified as necessary.
Reference: [6] <author> Richard Hamlet. </author> <title> Testing programs to detect malicious faults. </title> <booktitle> In Proceedings of the IFIP Working Conference on Dependable Computing, </booktitle> <pages> pages 162-169, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: If the coverage is not complete, an indicator called coverage percentage is used to calculate the ratio of tested code to total code. Code that is not executed by such a test suite is referred to as a "gap" in the coverage. As Hamlet demonstrates <ref> [6] </ref>, simple coverage met-rics can easily result in flawed code going undetected. Hamlet suggests that data-flow coverage approaches are superior. Data-flow coverage is a term that encompasses a variety of coverage schemes based on measuring coverage of sub-paths of a program from the definition of a variable to its uses.
Reference: [7] <author> Calvin Ko, Karl Levitt, and George Fink. </author> <title> Automated detection of vulnerabilities in privileged programs by execution monitoring. </title> <booktitle> In Proceedings of the Tenth Annual Computer Security Applications Conference, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: In current operating systems, the state can be changed only through invocation of system calls to the kernel, so state checking only need be done at these points in the program. One method being explored to accomplish security-based execution monitoring is through system call audit trail analysis <ref> [7] </ref>; traces of system calls are collected by the operating system and analyzed in real time. For many security flaws, this form of execution monitoring is both effective and efficient. But, using auditing as a basis for testing programs has limitations.
Reference: [8] <author> Bogdan Korel and Janusz Laski. </author> <title> STAD a system for testing and debugging: User perspective. </title> <booktitle> In Second Workshop on Software Testing, Verification, and Analysis, </booktitle> <pages> 1888. </pages>
Reference-contexts: Hamlet suggests that data-flow coverage approaches are superior. Data-flow coverage is a term that encompasses a variety of coverage schemes based on measuring coverage of sub-paths of a program from the definition of a variable to its uses. Covering def-use paths <ref> [8] </ref>, allows complicated flaws to be exposed. Computing complete dataflow coverage information becomes inefficient as the program size increases. Information needs to be kept on each individual path through the program; the number of paths grows exponentially with the size of the program.
Reference: [9] <author> Panas E. Livadas and Stephen Croll. </author> <title> The C-Ghinsu tool. </title> <type> Technical Report SERC-TR-55-F, </type> <institution> University of Florida, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Another slicing technique works forward through the parse tree, tracing the fan-out effect of a flow node. Combinations of backward and forward slic-ing (possibly with different criteria) can produce slices which more exactly characterize a program's behavior in some circumstances. This technique is called dicing <ref> [9] </ref>. Different ways in which forward and backward slicing are applied in property-based testing are discussed in Section 4. The current version of our Tester's Assistant slicer does a data-flow breakdown of C programs, and finds simple slices 4 .
Reference: [10] <author> Panas E. Livadas and Stephen Croll. </author> <title> Program slicing. </title> <type> Technical Report SERC-TR-61-F, </type> <institution> University of Florida, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: Using ELI, we are able to quickly prototype the Tester's Assistant. The dataflow representation has been implemented. The slicer is partially implemented: it is operational on multi-procedure programs using most of C's operations and properties, relying in part on algorithms from <ref> [10] </ref>, [2], and [5]. Pointer anti-aliasing will be introduced to make slices more efficient. Currently, the slicer makes worst case assumptions about pointer aliasing, though the well-behavedness assumption limits the scope of the aliasing assumptions. Library and system calls are being specified as necessary.
Reference: [11] <author> Raymond Waiman Lo. </author> <title> Static Analysis of Programs with Application to Malicious Code Detection. </title> <type> PhD thesis, </type> <institution> University of California, Davis, </institution> <year> 1992. </year>
Reference-contexts: A pointer is well-behaved if, once assigned to an object in memory, it does not, through pointer addition or typecasting, refer to a different object in memory. A program is well-behaved if all of its pointers are well-behaved. Lo <ref> [11] </ref> showed that static analysis can establish the 4 In our current version, pointer analysis is not complete. 5 Considerable speedups are possible in the slicer, as it is currently an unoptimized prototype. well-behavedness property in many cases without requiring a proof of correctness.
Reference: [12] <author> Robin R. Lutz. </author> <title> Targeting safety-related errors during software requirements analysis. </title> <booktitle> In Proceedings of the First ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 99-105, </pages> <month> Decem-ber </month> <year> 1993. </year>
Reference-contexts: An additional category of specification describes safety properties and other generic flaws <ref> [12] </ref> [1]. Safety properties cover common programming mistakes such as lack of argument checking, and include the well-behavedness property, described in Section 3.
Reference: [13] <author> Debra J. Richardson Owen O'Malley and Cindy Tittle. </author> <title> Approaches to specification-based testing. </title> <booktitle> In Proceedings of the First ACM SIGSOFT '89 Third Symposium on Testing, Analysis, and Verification(TAV3), </booktitle> <pages> pages 86-96, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: We create executable oracles derived from the security requirements. 7 . The use of specifications as oracles to test programs is not new: Richardson <ref> [13] </ref> and Sankar [15] [14] used specifications to generate assertion-checking functions. What is unique about our approach is the relative (small) size of the specifications, and the ability to associate them with a slice of the program.
Reference: [14] <author> S. Sankar. </author> <title> Automatic Runtime Consistency Checking and Debugging of Formally Specified Programs. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> August </month> <year> 1989. </year> <institution> Also Stanford University Department of Computer Science Technical Report No. STAN-CS-89-1282, and Computer Systems Laboratory Technical Report No. CSL-TR-89-391. </institution>
Reference-contexts: We create executable oracles derived from the security requirements. 7 . The use of specifications as oracles to test programs is not new: Richardson [13] and Sankar [15] <ref> [14] </ref> used specifications to generate assertion-checking functions. What is unique about our approach is the relative (small) size of the specifications, and the ability to associate them with a slice of the program.
Reference: [15] <author> S. Sankar and R. Hayes. </author> <title> Adl | an interface definition language for specifying and testing software. </title> <type> Technical Report CMU-CS-94-WIDL-1, </type> <institution> Carnegie-Mellon University, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: We create executable oracles derived from the security requirements. 7 . The use of specifications as oracles to test programs is not new: Richardson [13] and Sankar <ref> [15] </ref> [14] used specifications to generate assertion-checking functions. What is unique about our approach is the relative (small) size of the specifications, and the ability to associate them with a slice of the program.
Reference: [16] <author> Eugene H. Spafford. </author> <title> Crisis and aftermath. </title> <journal> Communications of the ACM, </journal> <volume> 32(6) </volume> <pages> 678-687, </pages> <year> 1989. </year>
Reference-contexts: Portions of the stack were overwritten, which allowed the user of the program to execute code which had been entered as part of the input argument. Before this flaw was extensively exploited by the Internet Worm <ref> [16] </ref>, fingerd was run setuid root, and so the flaw allowed system penetration.
Reference: [17] <author> William Waite et al. </author> <title> Eli system manuals. </title> <type> Unpublished Manuals, </type> <year> 1993. </year>
Reference-contexts: This paper presents a specification model for describing security properties of programs, and translations from properties into slicing criteria. The slicer is one component of our Tester's Assistant (see Figure 1), which mechanizes property-based testing; it slices C programs, and is implemented in the ELI <ref> [17] </ref> compiler construction toolset. Still under development are other components of the Tester's Assistant (see * a coverage analyzer, which determines the effectiveness of a set of tests with respect to a coverage measure. <p> All of the components coordinate through a common dataflow program representation. To generate the dataflow representation and construct the instrumentation necessary for coverage analysis and monitoring, the ELI <ref> [17] </ref> system is used. ELI is a text processing and compiler construction toolkit. In ELI, high-level specifications are converted into high-performance executable translators and compilers. Using ELI, we are able to quickly prototype the Tester's Assistant. The dataflow representation has been implemented.
Reference: [18] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-375, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: Elements of the forward slice have an "F" at the beginning of the line. Elements of the backward slice have a "B" at the beginning of the line. from the full source code of a program. Weiser <ref> [18] </ref> originally implemented slicing for FORTRAN programs. Slicing is carried out with respect to a slicing criterion. In its simplest form, a criterion is a variable and a location in the program.
References-found: 18

