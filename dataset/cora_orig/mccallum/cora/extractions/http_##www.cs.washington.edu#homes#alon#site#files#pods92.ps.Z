URL: http://www.cs.washington.edu/homes/alon/site/files/pods92.ps.Z
Refering-URL: http://www.cs.washington.edu/homes/alon/site/PaperAbstractPresentation_bib19.html
Root-URL: 
Email: (alevy@cs.stanford.edu)  (sagiv@cs.huji.ac.il)  
Title: Constraints and Redundancy in Datalog  
Author: Alon Levy Yehoshua Sagiv 
Address: Stanford, CA 94305  Jerusalem, Israel  
Affiliation: Dept. of Computer Science Stanford University  Dept. of Computer Science Hebrew University  
Abstract: Two types of redundancies in datalog programs are considered. Redundancy based on reachabil-ity eliminates rules and predicates that do not participate in any derivation tree of a fact for the query predicate. Redundancy based on irrelevance is similar, but considers only minimal derivation trees, that is, derivation trees having no pair of identical atoms, such that one is an ancestor of the other. Algorithms for detecting these redundancies are given, including the case of programs with constraint literals. These algorithms not only detect redundancies in the presence of constraints, but also push constraints from the given query and rules to the EDB predicates. Under certain assumptions discussed in the paper, the constraints are pushed to the EDB as tightly as possible. 
Abstract-found: 1
Intro-found: 1
Reference: [BK*89] <author> Balbin, I., Kemp, D.B., Meenakshi, K., and Ramamohanarao, K. </author> <title> Propagating constraints in recursive deductive databases. </title> <booktitle> North American Conf. on Logic Programming, </booktitle> <year> 1989, </year> <pages> pp. 16-20. </pages>
Reference-contexts: The magic-set transformation (cf. [Ull89]) is a prime example of pushing constants from the query to the database. More recently, constraints have started to play an important role. Pushing constraints from the query to the database was investigated in <ref> [BK*89, MF*90] </ref>|essentially these papers proposed generalizations of the magic-set transformation in order to handle constraints that appear in the query and the rules. Constraints as a part of the data were investigated in [KKR90]. <p> Consequently, the definition of state equivalence also requires equality of adornments, and the resulting tree is the basis for a magic-set evaluation (cf. [Ull89]); the details, however, are beyond the scope of this paper. This approach incorporates constraints in the magic-set evaluation more effectively than <ref> [BK*89, MF*90] </ref>. An interesting issue is the types of constraint languages that satisfy the properties mentioned earlier.
Reference: [BS91] <author> Brodsky, A., and Y. Sagiv. </author> <title> Inference of inequality constraints in logic programs. </title> <booktitle> Proc. Tenth ACM SIGACT-SIGART-SIGMOD Symp. on Principles of Database Systems, </booktitle> <year> 1991, </year> <pages> pp. 227-240. </pages>
Reference-contexts: However, it may result in a larger magic program. Linear inequalities do not satisfy the Finiteness Property, and consequently, Algorithm 4.1 may not terminate in this case. However, one may think of ad hoc heuristics that provide termination and soundness without guaranteeing completeness. The approaches of <ref> [BS91, VG90] </ref> may be useful in finding more effective heuristics. Another direction is to find subcases in which Algorithm 4.1 terminates when the constraints are linear inequalities.
Reference: [Co91] <author> Courcelle, B. </author> <title> Recursive queries and context-free graph grammars. </title> <journal> Theoretical Computer Science, </journal> <volume> 78(1991), </volume> <pages> pp. 217-244. </pages>
Reference-contexts: The algorithms presented in this paper construct trees that are used for finding redundant rules, and could also be used for a magic-set evaluation. The approach of tree automata, however, was useful in getting a first insight into these problems. A recent paper <ref> [Co91] </ref> characterized a large class of decidable problems involving datalog rules (the theory of tree automata is at the core of that work). However, the problems we investigate do not fall into the framework 1 of [Co91], and therefore, our results are not a corollary of that work. 1 The reason <p> A recent paper <ref> [Co91] </ref> characterized a large class of decidable problems involving datalog rules (the theory of tree automata is at the core of that work). However, the problems we investigate do not fall into the framework 1 of [Co91], and therefore, our results are not a corollary of that work. 1 The reason for that is that our problems involve not only the facts derived by a datalog program, but also the derivation trees. 2 Preliminaries We discuss datalog programs which are collections of safe Horn rules with no
Reference: [KKR90] <author> Kanellakis, P.C., Kuper, G.M., and Revesz, P.Z. </author> <title> Constraint query languages. </title> <booktitle> Proc. 9th ACM Symp. on Principles of Database Systems, </booktitle> <year> 1990, </year> <pages> pp. 299-313. </pages>
Reference-contexts: Pushing constraints from the query to the database was investigated in [BK*89, MF*90]|essentially these papers proposed generalizations of the magic-set transformation in order to handle constraints that appear in the query and the rules. Constraints as a part of the data were investigated in <ref> [KKR90] </ref>. Earlier work on constraints was done by Klug [Kl88] who investigated equivalence of conjunctive queries with inequalities. This paper deals with constraints that are part of the program (but not the data), and the issues of interest are both redundancy and constraint pushing.
Reference: [Ki88] <author> Kifer, M. </author> <title> On safety, domain indepen dence, and capturability of database queries. </title> <booktitle> Proc. Int. Conf. on Data and Knowledge Bases, </booktitle> <address> Jerusalem, </address> <year> 1988. </year>
Reference-contexts: Both types of redundancy are investigated when constraints are present and when they are not. One case, namely, the problem of unreachable rules when there are no constraints has an easy solution <ref> [Ki88] </ref>. The other three cases are not as easy, and we solve them in this paper. The algorithms we present are based on creating a rule-goal tree that represents all redundancy-free derivations that can be con structed for the query. <p> Finding unreachable rules is easy; it is especially easy if we assume that the query predicate depends on all other predicates and there are no constants in the program <ref> [Ki88] </ref>. In this special case, a rule is unreachable if either its body or head has an unreachable IDB predicate.
Reference: [Kl88] <author> Klug, A., </author> <title> On conjunctive queries con taining inequalities. </title> <journal> JACM, </journal> <volume> Vol. 35, No. 1, </volume> <year> 1988, </year> <pages> pp. 146-160. </pages>
Reference-contexts: Constraints as a part of the data were investigated in [KKR90]. Earlier work on constraints was done by Klug <ref> [Kl88] </ref> who investigated equivalence of conjunctive queries with inequalities. This paper deals with constraints that are part of the program (but not the data), and the issues of interest are both redundancy and constraint pushing. In fact, it is shown that the two are closely related.
Reference: [MF*90] <author> Mumick, I.S., Finkelstein, S.J., Pi rahesh, H., and Ramakrishnan, R. </author> <title> Magic conditions. </title> <booktitle> Proc. 9th ACM Symp. on Principles of Database Systems, </booktitle> <year> 1990, </year> <pages> pp. 314-330. </pages>
Reference-contexts: The magic-set transformation (cf. [Ull89]) is a prime example of pushing constants from the query to the database. More recently, constraints have started to play an important role. Pushing constraints from the query to the database was investigated in <ref> [BK*89, MF*90] </ref>|essentially these papers proposed generalizations of the magic-set transformation in order to handle constraints that appear in the query and the rules. Constraints as a part of the data were investigated in [KKR90]. <p> Consequently, the definition of state equivalence also requires equality of adornments, and the resulting tree is the basis for a magic-set evaluation (cf. [Ull89]); the details, however, are beyond the scope of this paper. This approach incorporates constraints in the magic-set evaluation more effectively than <ref> [BK*89, MF*90] </ref>. An interesting issue is the types of constraint languages that satisfy the properties mentioned earlier.
Reference: [Sag88] <author> Sagiv, Y. </author> <title> Optimizing datalog pro grams. In Foundations of Deductive Databases and Logic Programming, </title> <editor> (J. Minker, ed.), </editor> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1988, </year> <pages> pp. 659-698. </pages>
Reference-contexts: The algorithm for minimization under uniform equivalence <ref> [Sag88] </ref> is one example of removing redundant parts from datalog programs. The magic-set transformation (cf. [Ull89]) is a prime example of pushing constants from the query to the database. More recently, constraints have started to play an important role. <p> Generally, finding redundant rules is undecidable [Sar90, Sh87]. A narrower notion is redundancy under uniform equivalence <ref> [Sag88] </ref>, but it cannot show the redundancies in the above examples. 2 The next definitions describe a new type of redundancy, called irrelevance, which is based on the notion of minimal derivation trees. This notion of redundancy subsumes the one based on unreachability.
Reference: [Sar90] <author> Saraiya, Y.P. </author> <title> Hard problems for simple logic programs. </title> <booktitle> Proc. ACM-SIGMOD Int. Conf. on Management of Data, </booktitle> <year> 1990, </year> <pages> pp. 64-73. </pages>
Reference-contexts: Example 2.3: Consider the following program: r 1 : p (x) : q (x): r 3 : q (x) : e (x): In this program, r 2 is reachable, but is redundant (regardless of which is the query predicate). Generally, finding redundant rules is undecidable <ref> [Sar90, Sh87] </ref>. A narrower notion is redundancy under uniform equivalence [Sag88], but it cannot show the redundancies in the above examples. 2 The next definitions describe a new type of redundancy, called irrelevance, which is based on the notion of minimal derivation trees.
Reference: [Sh87] <author> Shmueli, O. </author> <title> Decidability and expres siveness aspects of logic queries. </title> <booktitle> Proc. 6th ACM Symp. on Principles of Database Systems, </booktitle> <year> 1987, </year> <pages> pp. 237-249. </pages>
Reference-contexts: Example 2.3: Consider the following program: r 1 : p (x) : q (x): r 3 : q (x) : e (x): In this program, r 2 is reachable, but is redundant (regardless of which is the query predicate). Generally, finding redundant rules is undecidable <ref> [Sar90, Sh87] </ref>. A narrower notion is redundancy under uniform equivalence [Sag88], but it cannot show the redundancies in the above examples. 2 The next definitions describe a new type of redundancy, called irrelevance, which is based on the notion of minimal derivation trees.
Reference: [SS90] <author> Sippu, S., and Soisalon-Soininen, E. </author> <title> Multiple SIP strategies and bottom-up adorning in logic query optimization. </title> <booktitle> Third Int. Conf. on Database Theory, </booktitle> <editor> (LNCS-470, Abiteboul and Kanellakis, eds.), </editor> <year> 1990, </year> <pages> pp. 485-498. </pages>
Reference-contexts: Note that our approach of handling a small EDB relation as a constraint is different from that of <ref> [SS90] </ref>, and it appears to be more effective, since it pushes the exact constraint and not just adornments. However, it may result in a larger magic program. Linear inequalities do not satisfy the Finiteness Property, and consequently, Algorithm 4.1 may not terminate in this case.
Reference: [Ull89] <author> Ullman, J.D. </author> <title> Principles of Database and Knowledge-Base Systems, Volume II. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: The algorithm for minimization under uniform equivalence [Sag88] is one example of removing redundant parts from datalog programs. The magic-set transformation (cf. <ref> [Ull89] </ref>) is a prime example of pushing constants from the query to the database. More recently, constraints have started to play an important role. <p> Actually, the tree will be stable after one bottom-up phase followed by a top-down phase; note that this is essentially a semijoin reduction, as in Yannakakis' algorithm (cf. <ref> [Ull89] </ref>). In principle, bottom-up and top-down propagation of constraints can also be done in the rule-goal forest constructed by Algorithm 4.1. <p> Formulas in the language are either atomic or conjunctions of atomic formulas. There is a complete set of axioms for inferring constraints of this form <ref> [Ull89] </ref>. However, this language does not satisfy the Closure Property we require and, therefore, the tree with the top-down labels may not be stable. Consequently, the top-down constraint label of a node does not necessarily describe all the constraints that the node has to satisfy. <p> Moreover, we can augment the information in the tree with bound-free adornments. Consequently, the definition of state equivalence also requires equality of adornments, and the resulting tree is the basis for a magic-set evaluation (cf. <ref> [Ull89] </ref>); the details, however, are beyond the scope of this paper. This approach incorporates constraints in the magic-set evaluation more effectively than [BK*89, MF*90]. An interesting issue is the types of constraint languages that satisfy the properties mentioned earlier.
Reference: [VG90] <author> Van Gelder, A. </author> <title> Deriving constraints among argument sizes in logic programs. </title> <booktitle> Proc. 9th ACM Symp. on Principles of Database Systems, </booktitle> <year> 1990, </year> <pages> pp. 314-330. </pages>
Reference-contexts: However, it may result in a larger magic program. Linear inequalities do not satisfy the Finiteness Property, and consequently, Algorithm 4.1 may not terminate in this case. However, one may think of ad hoc heuristics that provide termination and soundness without guaranteeing completeness. The approaches of <ref> [BS91, VG90] </ref> may be useful in finding more effective heuristics. Another direction is to find subcases in which Algorithm 4.1 terminates when the constraints are linear inequalities.
Reference: [Va89] <author> Vardi, M.Y. </author> <title> Automata theory for database theoreticians. </title> <booktitle> Proc. 8th ACM Symp. on Principles of Database Systems, </booktitle> <year> 1989, </year> <pages> pp. 83-92. </pages>
Reference-contexts: Second, the algorithms can be used to push constraints to the database. In this paper, we emphasize the first aspect of the results. However, we also indicate how the second aspect follows from our work. Recently, Vardi <ref> [Va89] </ref> showed that the theory of tree automata is a useful tool for solving problems involving datalog rules. The problems we consider can also be solved as decision problems on certain tree automata.
References-found: 14

