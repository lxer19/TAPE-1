URL: ftp://ftp.cs.umass.edu/pub/osl/papers/lfp94.ps.Z
Refering-URL: http://spa-www.cs.umass.edu/bibliography.html
Root-URL: 
Title: Characterisation of object behaviour in Standard ML of New Jersey  
Author: Darko Stefanovi c J. Eliot B. Moss 
Affiliation: Department of Computer Science University of Massachussets  
Abstract: We describe a method of measuring lifetime characteristics of heap objects, and discuss ways in which such quantitative object behaviour measurements can help improve language implementations, especially garbage collection performance. For Standard ML of New Jersey, we find that certain primary aspects of object be-haviour are qualitatively the same across benchmark programs, in particular the rapid object decay. We show that the heap-only allocation implementation model is the cause of this similarity. We confirm the weak generational hypothesis for SML/NJ and discuss garbage collector configuration tuning. Our approach is to obtain object statistics directly from program execution, rather than simulation, for reasons of simplicity and speed. Towards this end, we exploit the flexibility of the garbage collector toolkit as a measurement tool. Careful numerical analysis of the acquired data is necessary to arrive at relevant object lifetime measures. This study fills a gap in quantitative knowledge of the workings of heap-based compilers and their run-time systems, and should be useful to functional language implementors. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel. </author> <title> Simple generational garbage collection and fast allocation. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 19(2) </volume> <pages> 171-83, </pages> <year> 1989. </year>
Reference-contexts: The results indicate that under the current heap-based compilation model the allocation region should be kept at a fixed size of around one megabyte, but otherwise justify Appel's simple garbage collection scheme <ref> [1] </ref>. The advantages of using type-safe languages with a well-defined formal semantics, such as the mostly functional language Standard ML, are well recognised. The one disadvantage often perceived as an insuperable obstacle is the inefficiency of programs written in * This work is supported by National Science Foundation grant CCR-9211272. <p> The distribution of allocated objects by size is shown by means of histograms (Figures 4b and 7b). Small objects completely dominate allocation in these programs. This situation is favourable to a simple collector which minimises per-object overhead <ref> [1] </ref>. The distribution of allocated objects by tag is shown in Figures 4c and 7c.
Reference: [2] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <address> first edition, </address> <year> 1992. </year>
Reference-contexts: Using the analytical expression of the spline, we compute its derivatives, and then, inverting the logarithmic scale, compute the nursery mortality, object survival and object mortality rates. 2.6 Benchmark programs The benchmark suite we used draws upon Appel's collection, and adds some further scientific programs. Table 1 (adapted from <ref> [2, 11] </ref>) summarises the individual benchmarks.
Reference: [3] <author> Andrew W. Appel, James S. Mattson, and David Tarditi. </author> <title> A lexical analyzer generator for Standard ML. Distributed with Standard ML of New Jersey, </title> <year> 1989. </year>
Reference-contexts: Leroy An implementation of the Knuth-Bendix completion algorithm, implemented by Gerard Huet, processing some axioms of geometry. Lexgen A lexical-analyser generator, implemented by James S. Mattson and David R. Tarditi <ref> [3] </ref>, processing the lexical description of Standard ML. ML The SML/NJ compiler compiling the Leroy benchmark. Modula A compiler translating a Modula-like language [23] into GNU C. The input is a 1400-line source program.
Reference: [4] <author> Andrew W. Appel and Zhong Shao. </author> <title> An empirical and analytic study of stack vs. heap cost for languages with closures. </title> <type> Technical Report CS-TR-450-94, </type> <institution> Dept. of Computer Science, Princeton University, Princeton, NJ, </institution> <year> 1994. </year>
Reference-contexts: Allocation on the heap carries a higher price of deallocation, usually garbage collection. SML/NJ avoids using the stack entirely, and allocates all closure records on the heap. Whether this kind of strategy is better or worse than stack-based implementations remains an open question <ref> [4] </ref>. As a result, the allocation rate is greatly increased (Section 3.2), and so is the burden on the garbage collector. For example, running the standard collector accounts for 5 - 24% (10% on the average) of total execution cost in the SML/NJ system [25].
Reference: [5] <author> Henry Baker. </author> <title> The thermodynamics of garbage collection a tutorial. </title> <booktitle> In OOPSLA '93 Workshop on Memory Management and Garbage Collection, </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: Ungar [27] reported on the performance of garbage collection in a Smalltalk 6 system and investigated the tradeoffs in nursery size selection. The--oretical models of behaviour have been proposed by Baker <ref> [5] </ref>. Zorn conducted statistical studies in the context of Lisp [31]; his methodology is based on object-level simulation, and lifetimes are estimated from object reference points. We improve on his Discrete Interval Simulator by taking advantage of complete liveness information.
Reference: [6] <author> Henry G. Baker. </author> <title> `Infant Mortality' and generational garbage collection. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(4) </volume> <pages> 55-57, </pages> <year> 1993. </year>
Reference-contexts: However, having more generations is justified only under the strong hypothesis. We now turn to an analytical model of the temporal behaviour of heap-allocated objects, following the lead of Baker <ref> [6] </ref>. The intensity of heap allocation the rate at which new objects are created varies from one language implementation to another, from one application program to another, and from one program execution phase to another. For a class of performance considerations, the latter variation is important.
Reference: [7] <editor> Yves Bekkers and Jacques Cohen, editors. </editor> <booktitle> International Workshop on Memory Management, number 637 in Lecture Notes in Computer Science, </booktitle> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference: [8] <author> Rance Cleaveland, Joachim Parrow, and Bernhard Steffen. </author> <title> The Concurrency Workbench: A semantics-based tool for the verification of concurrent systems. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 36-72, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The conclusion is that the newly allocated objects behave in substantially the same way across all benchmarks. We explain this as a result of the overwhelming number of function-closure objects as opposed to user-level objects. These objects are for the most part 4 Program Description CW The Concurrency Workbench <ref> [8] </ref> is a tool for analysing networks of finite state processes expressed in Milner's Calculus of Communicating Systems, processing a sample session input. Leroy An implementation of the Knuth-Bendix completion algorithm, implemented by Gerard Huet, processing some axioms of geometry. Lexgen A lexical-analyser generator, implemented by James S.
Reference: [9] <author> Eric Cooper, Scott Nettles, and Indira Subramanian. </author> <title> Improving the performance of SML garbage collection using application-specific virtual memory management. </title> <booktitle> In 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 43-52, </pages> <address> San Francisco, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Even when there is enough physical memory to avoid paging entirely, the pauses caused by major collections are intolerably long <ref> [9, 20] </ref>. Cache performance of SML/NJ was also suspected to be bad. It was speculated that 40% of execution time was spent waiting for main memory access, a 66% overhead.
Reference: [10] <author> W. P. Crowley, C. P. Hendrickson, and T. E. Rudy. </author> <title> The SIMPLE code. </title> <type> Technical Report UCID 17715, </type> <institution> Lawrence Liver-more Laboratory, Livermore, </institution> <address> CA, </address> <month> February </month> <year> 1978. </year>
Reference-contexts: Modula A compiler translating a Modula-like language [23] into GNU C. The input is a 1400-line source program. PIA The Perspective Inversion Algorithm [28] decides the location of an object in a perspective video image. Simple A spherical fluid-dynamics program, developed as a realistic FORTRAN benchmark <ref> [10] </ref>, translated into ID [13], and then translated into Standard ML by Lal George. VLIW A Very-Long-Instruction-Word instruction scheduler written by John Danskin. Yacc A LALR (1) parser generator, implemented by David R. Tarditi [24], processing the grammar of Standard ML.
Reference: [11] <author> Amer Diwan, David Tarditi, and J. Eliot B. Moss. </author> <title> Memory subsystem performance of programs with intensive heap allocation. </title> <note> Submitted for Publication, </note> <month> October </month> <year> 1993. </year>
Reference-contexts: Cache performance of SML/NJ was also suspected to be bad. It was speculated that 40% of execution time was spent waiting for main memory access, a 66% overhead. Recent work <ref> [11] </ref> has shown that this is not altogether true, at least for some current architectures and memory subsystem organisations. In particular, the cache performance on the DECStation 5000/200 is reasonably good across all benchmarks reported, at a 17% overhead. <p> Using the analytical expression of the spline, we compute its derivatives, and then, inverting the logarithmic scale, compute the nursery mortality, object survival and object mortality rates. 2.6 Benchmark programs The benchmark suite we used draws upon Appel's collection, and adds some further scientific programs. Table 1 (adapted from <ref> [2, 11] </ref>) summarises the individual benchmarks.
Reference: [12] <author> Amer Diwan, David Tarditi, and J. Eliot B. Moss. </author> <title> Memory subsystem performance of programs using copying garbage collection. </title> <booktitle> In Conference Record of the Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <address> Port-land, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: A large part of allocation is due to function closure records and callee-save register records; less than a quarter is due to data records, and a large fraction of these are three words long, that is, cons-cells <ref> [12] </ref>. There is no check for allocation overflow on individual allocations; instead, checks are performed at function entry points only. A function in the SML/NJ intermediate representation has one entry point, several exit points and no loops.
Reference: [13] <author> K. Ekanadham and Arvind. </author> <title> SIMPLE: An exercise in future scientific programming. Technical Report Computation Structures Group Memo 273, </title> <publisher> MIT, </publisher> <address> Cambridge, MA, </address> <month> July </month> <year> 1987. </year> <note> Simultaneously published as IBM/T. J. </note> <institution> Watson Research Center Research Report 12686, Yorktown Heights, NY. </institution>
Reference-contexts: The input is a 1400-line source program. PIA The Perspective Inversion Algorithm [28] decides the location of an object in a perspective video image. Simple A spherical fluid-dynamics program, developed as a realistic FORTRAN benchmark [10], translated into ID <ref> [13] </ref>, and then translated into Standard ML by Lal George. VLIW A Very-Long-Instruction-Word instruction scheduler written by John Danskin. Yacc A LALR (1) parser generator, implemented by David R. Tarditi [24], processing the grammar of Standard ML.
Reference: [14] <author> Barry Hayes. </author> <title> Using key object opportunism to collect old objects. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 33-46, </pages> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1991. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 26, </volume> <month> 11 (November </month> <year> 1991). </year>
Reference-contexts: Hayes refined this into a weak and a strong generational hypothesis <ref> [14] </ref>. Qualitatively expressed, the weak hypothesis is that newly created objects have a much lower survival rate than objects that are older; the strong hypothesis is that even if the objects are not newly created, the relatively younger objects have a lower survival rate than the relatively older objects.
Reference: [15] <author> Antony L. Hosking, J. Eliot B. Moss, and Darko Stefanovic. </author> <title> A comparative performance evaluation of write barrier implementations. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 92-109, </pages> <address> Vancouver, Canada, </address> <month> October </month> <year> 1992. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 27, </volume> <month> 10 (October </month> <year> 1992). </year>
Reference-contexts: We improve on his Discrete Interval Simulator by taking advantage of complete liveness information. For a more detailed discussion of the UMass Garbage Collector Toolkit consult the original design report [16] and a later article on the Smalltalk system <ref> [15] </ref>. For a broader overview of garbage collection algorithms and generational techniques, consult Wilson's survey paper [29]. 6 Acknowledgements In the beginning of this work, Scott Nettles and David Tarditi provided us with some of the benchmarks, and with valuable discussions.
Reference: [16] <author> Richard L. Hudson, J. Eliot B. Moss, Amer Diwan, and Christopher F. </author> <title> Weight. A language-independent garbage collector toolkit. </title> <type> COINS Technical Report 91-47, </type> <institution> University of Massachusetts, Amherst, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: We improve on his Discrete Interval Simulator by taking advantage of complete liveness information. For a more detailed discussion of the UMass Garbage Collector Toolkit consult the original design report <ref> [16] </ref> and a later article on the Smalltalk system [15]. For a broader overview of garbage collection algorithms and generational techniques, consult Wilson's survey paper [29]. 6 Acknowledgements In the beginning of this work, Scott Nettles and David Tarditi provided us with some of the benchmarks, and with valuable discussions.
Reference: [17] <author> Peter Lancaster and Kestutis Salkauskas. </author> <title> Curve and Surface Fitting. </title> <publisher> Academic Press, </publisher> <year> 1986. </year>
Reference-contexts: We then compute a fitting cubic spline, carefully adjusting the minimisation functional for a balance between goodness of fit and degree of smoothness <ref> [17, 21] </ref>. Using the analytical expression of the spline, we compute its derivatives, and then, inverting the logarithmic scale, compute the nursery mortality, object survival and object mortality rates. 2.6 Benchmark programs The benchmark suite we used draws upon Appel's collection, and adds some further scientific programs.
Reference: [18] <author> Henry Lieberman and Carl Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Communications of the ACM, </journal> <volume> 26(6) </volume> <pages> 419-429, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: 1 There is a hidden cost of processing the stack when the heap is collected, but this need not be great. becomes even greater. 1.1 Object dynamics The effectiveness of generational garbage collectors hinges on the assumption, termed the generational hypothesis, that young objects die more quickly than old objects <ref> [18, 26] </ref>. Hayes refined this into a weak and a strong generational hypothesis [14].
Reference: [19] <author> Frederick Mosteller and John W. Tukey. </author> <title> Data Analysis and Regression. </title> <publisher> Addison-Wesley, </publisher> <year> 1977. </year>
Reference-contexts: Starting with the nursery survival rate data, we re-express the nurs ery size on a logarithmic scale since we span three decades (35 10 3 - 20 10 6 bytes) <ref> [19] </ref>. We then compute a fitting cubic spline, carefully adjusting the minimisation functional for a balance between goodness of fit and degree of smoothness [17, 21].
Reference: [20] <author> Scott M. Nettles, James W. O'Toole, David Pierce, and Nicholas Haines. </author> <title> Replication-based incremental copying collection. </title> <booktitle> In Bekkers and Cohen [7], </booktitle> <pages> pages 357-364. </pages>
Reference-contexts: Even when there is enough physical memory to avoid paging entirely, the pauses caused by major collections are intolerably long <ref> [9, 20] </ref>. Cache performance of SML/NJ was also suspected to be bad. It was speculated that 40% of execution time was spent waiting for main memory access, a 66% overhead.
Reference: [21] <author> G.A.F. Seber and C.J. Wild. </author> <title> Nonlinear Regression. </title> <publisher> Wiley, </publisher> <year> 1989. </year>
Reference-contexts: We then compute a fitting cubic spline, carefully adjusting the minimisation functional for a balance between goodness of fit and degree of smoothness <ref> [17, 21] </ref>. Using the analytical expression of the spline, we compute its derivatives, and then, inverting the logarithmic scale, compute the nursery mortality, object survival and object mortality rates. 2.6 Benchmark programs The benchmark suite we used draws upon Appel's collection, and adds some further scientific programs.
Reference: [22] <author> Darko Stefanovic. </author> <title> The garbage collection toolkit as an experimentation tool, </title> <month> October </month> <year> 1993. </year> <title> Position paper for OOPSLA '93 Workshop on Memory Management and Garbage Collection. </title>
Reference-contexts: We note below that size can be abstracted away if we consider allocation by volume, not by number of objects. With age as the remaining relevant parameter, it turns out that a generational garbage collector, properly instrumented, can serve as the analysis tool we need <ref> [22] </ref>. 2.1 Toolkit collector The garbage collector used for the studies reported here is the UMass Language-Independent Garbage Collector Toolkit, to which we added language-specific code to interface it with the SML/NJ system.
Reference: [23] <author> Darko Stefanovic. </author> <title> Implementing a small imperative language with safe dynamic allocation. </title> <type> Memo, </type> <month> April </month> <year> 1993. </year> <month> 7 </month>
Reference-contexts: Lexgen A lexical-analyser generator, implemented by James S. Mattson and David R. Tarditi [3], processing the lexical description of Standard ML. ML The SML/NJ compiler compiling the Leroy benchmark. Modula A compiler translating a Modula-like language <ref> [23] </ref> into GNU C. The input is a 1400-line source program. PIA The Perspective Inversion Algorithm [28] decides the location of an object in a perspective video image.
Reference: [24] <author> David Tarditi and Andrew W. Appel. ML-Yacc, </author> <title> version 2.0. Distributed with Standard ML of New Jersey, </title> <month> April </month> <year> 1990. </year>
Reference-contexts: Simple A spherical fluid-dynamics program, developed as a realistic FORTRAN benchmark [10], translated into ID [13], and then translated into Standard ML by Lal George. VLIW A Very-Long-Instruction-Word instruction scheduler written by John Danskin. Yacc A LALR (1) parser generator, implemented by David R. Tarditi <ref> [24] </ref>, processing the grammar of Standard ML. Table 1: Benchmark Programs (a) Nursery survival rate (b) Object survival rate (c) Nursery mortality (d) Object mortality 5 short-lived, as they represent what in other implementations would be the active area on top of the stack.
Reference: [25] <author> David Tarditi and Amer Diwan. </author> <title> The full cost of a generational copying garbage collection implementation, </title> <month> October </month> <year> 1993. </year> <title> Position paper for OOPSLA '93 Workshop on Memory Management and Garbage Collection. </title>
Reference-contexts: As a result, the allocation rate is greatly increased (Section 3.2), and so is the burden on the garbage collector. For example, running the standard collector accounts for 5 - 24% (10% on the average) of total execution cost in the SML/NJ system <ref> [25] </ref>. <p> All such records are linked together into the store list. A dedicated register points to the head of the list. This mechanism makes assignments very expensive <ref> [25] </ref>, and discourages imperative-style programming, in keeping with the philosophy of functional programming. With programmers avoiding the imperative features, the frequency of updates in ML is extremely low relative to the rate of allocation, and the store list becomes a feasible way to implement the write barrier of generational collection. <p> Previously, there have been measurements of the distribution of allocated objects by kind for SML <ref> [25] </ref>. In addition to this, we are in a position to assess the difference in temporal object behaviour by kind. The same analysis as in Section 1.1 applies here, but for individual object classes.
Reference: [26] <author> David Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 157-167, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> April </month> <year> 1984. </year> <journal> ACM SIG-PLAN Not. </journal> <volume> 19, </volume> <month> 5 (May </month> <year> 1984). </year>
Reference-contexts: 1 There is a hidden cost of processing the stack when the heap is collected, but this need not be great. becomes even greater. 1.1 Object dynamics The effectiveness of generational garbage collectors hinges on the assumption, termed the generational hypothesis, that young objects die more quickly than old objects <ref> [18, 26] </ref>. Hayes refined this into a weak and a strong generational hypothesis [14].
Reference: [27] <author> David Michael Ungar. </author> <title> The Design and Evaluation of a High Performance Smalltalk System. </title> <publisher> ACM Distinguished Dissertations. The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year> <type> Ph.D. Dissertation, </type> <institution> University of California at Berkeley, </institution> <month> February </month> <year> 1986. </year>
Reference-contexts: We believe that both approaches, in addition to finer granularity measurements described here, are needed to inspire theoretical models, and should be used to validate them. Ungar <ref> [27] </ref> reported on the performance of garbage collection in a Smalltalk 6 system and investigated the tradeoffs in nursery size selection. The--oretical models of behaviour have been proposed by Baker [5].
Reference: [28] <author> Kevin G. Waugh, Patrick McAndrew, and Greg Michaelson. </author> <title> Parallel implementations from function prototypes: a case study. </title> <institution> Technical Report Computer Science 90/4, Heriot-Watt University, Edinburgh, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: Mattson and David R. Tarditi [3], processing the lexical description of Standard ML. ML The SML/NJ compiler compiling the Leroy benchmark. Modula A compiler translating a Modula-like language [23] into GNU C. The input is a 1400-line source program. PIA The Perspective Inversion Algorithm <ref> [28] </ref> decides the location of an object in a perspective video image. Simple A spherical fluid-dynamics program, developed as a realistic FORTRAN benchmark [10], translated into ID [13], and then translated into Standard ML by Lal George. VLIW A Very-Long-Instruction-Word instruction scheduler written by John Danskin.
Reference: [29] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <note> In Bekkers and Cohen [7]. </note>
Reference-contexts: For a more detailed discussion of the UMass Garbage Collector Toolkit consult the original design report [16] and a later article on the Smalltalk system [15]. For a broader overview of garbage collection algorithms and generational techniques, consult Wilson's survey paper <ref> [29] </ref>. 6 Acknowledgements In the beginning of this work, Scott Nettles and David Tarditi provided us with some of the benchmarks, and with valuable discussions. Brian Milnes, Andi Stephens, and Craig Marcus helped set up the operating system environment.
Reference: [30] <author> Paul R. Wilson and Thomas G. Moher. </author> <title> Design of the Opportunistic Garbage Collector. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 23-35, </pages> <address> New Orleans, Louisiana, </address> <month> October </month> <year> 1989. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 24, </volume> <month> 10 (October </month> <year> 1989). </year>
Reference-contexts: For a class of performance considerations, the latter variation is important. For example, opportunistic garbage collection <ref> [30] </ref> takes advantage of idle periods in an interactive application to run the collector. In such a setting, heap behaviour must be characterised in terms of real, wall-clock time. Otherwise, the load on the collector can be defined by the amount of data created.

References-found: 30

