URL: http://hellgate.cs.nyu.edu:8888/~leunga/refman.ps
Refering-URL: http://hellgate.cs.nyu.edu:8888/~leunga/prop.html
Root-URL: http://www.cs.nyu.edu
Email: E-mail: leunga@cs.nyu.edu  
Title: Prop Language Reference Manual (for version 2.3.4) how to develop programs using the Prop to
Author: Allen Leung 
Note: and describes  
Date: April 4, 1997  
Address: 251 Mercer Street New York, NY 10012  
Affiliation: Courant Institute of Mathematical Sciences  
Web: http://valis.cs.nyu.edu:8888/~leunga  
Abstract: The author will neither assume responsibility for any damages caused by the use of this product, nor accept warranty or update claims. This product is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. This product is in the public domain, and may be freely distributed. Prop is a research prototype. The information contained in this document is subject to change without notice. 
Abstract-found: 1
Intro-found: 1
Reference: [AF] <author> Guiseppe Attardi and Tito Flagella. </author> <title> A customisable memory management framework. </title> <type> Technical report, </type> <institution> University of Pisa. </institution>
Reference-contexts: When a user programs in Prop using these constructs, an applicative style of programming is the most natural paradigm. A.2 The Framework We base our design on the work on the Customisable Memory Management (CMM) system <ref> [AF] </ref>. In this framework, multiple independent heaps (including the usually non-collectable heap) can coexist with each other. Bartlett's mostly copying garbage collector is used as the primary collector. CMM extends the work of Bartlett [Bar88] by allowing cross heap pointers and unrestricted interior pointers. <p> In <ref> [AF] </ref>, examples are given in which the lifetime of certain class of objects exhibit first-in/first-out behavior. In this case a special collector can be written to take full advantage of this property.
Reference: [AGT89] <author> Alfred V. Aho, Mahadevan Ganapathi, and Steven W. K. Tjiang. </author> <title> Code generation using tree matching and dynamic programming. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 491-516, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Equational rules can often be used to specify semantics based simplification (e.g. constant folding and simplification based on simple algebraic identities) or transformation (e.g. code selection in a compiler backend <ref> [AGT89] </ref>). Unlike plain pattern matching, however, the structural traversal process in rewriting is implicitly inferred from the type structure of an algebraic datatype, as specified in its definition.
Reference: [Bar88] <author> Joel F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Technical Report 88/2, </type> <institution> DEC Western Research Laboratory, Palo Alto, California, </institution> <month> Febrarry </month> <year> 1988. </year>
Reference-contexts: Exp e1 = INT'(mem)(1); Exp e2 = VAR'(mem)- name = "foo", typ = t -; 4.5.1 Garbage collection The support library contains an implementation 6 of a conservative garbage collector using two algorithms: one using a mostly copying scheme <ref> [Bar88, Bar89] </ref> and one using mark-sweep. A datatype can be defined to be garbage collectable with the qualifier collectable. In the following example, the datatype Exp is will be allocated from the a garbage collected heap instead of the default heap. <p> Like the previous approach, we have implemented a mostly copying conservative collector based on the work of Bartlett <ref> [Bar88] </ref>. Similar to CMM, our architecture provides a protocol to allow multiple garbage collectors using different algorithms to coexist in the same memory space. <p> In this framework, multiple independent heaps (including the usually non-collectable heap) can coexist with each other. Bartlett's mostly copying garbage collector is used as the primary collector. CMM extends the work of Bartlett <ref> [Bar88] </ref> by allowing cross heap pointers and unrestricted interior pointers. However, all collectable objects are required to derive from a base class and reimplement a tracing method, which identifies the internal pointers of an object.
Reference: [Bar89] <author> Joel F. Bartlett. </author> <title> Mostly-copying collection picks up generations and C++. </title> <type> Technical Report TN-12, </type> <institution> DEC Western Research Laboratory, Palo Alto, California, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: Exp e1 = INT'(mem)(1); Exp e2 = VAR'(mem)- name = "foo", typ = t -; 4.5.1 Garbage collection The support library contains an implementation 6 of a conservative garbage collector using two algorithms: one using a mostly copying scheme <ref> [Bar88, Bar89] </ref> and one using mark-sweep. A datatype can be defined to be garbage collectable with the qualifier collectable. In the following example, the datatype Exp is will be allocated from the a garbage collected heap instead of the default heap.
Reference: [Boe93] <author> Hans-Juergen Boehm. </author> <title> Space efficient conservative garbage collection. </title> <booktitle> ACM SIGPLAN PLDI, </booktitle> <pages> pages 197-206, </pages> <year> 1993. </year>
Reference-contexts: Similar to CMM, our architecture provides a protocol to allow multiple garbage collectors using different algorithms to coexist in the same memory space. A few improvements are made to improve the performance, the flexibility and the functionality of our collector: to reduce retention due to false roots identification, blacklisting <ref> [Boe93] </ref> is used to identify troublesome heap addresses; the architecture of the system has been generalized so that it is now possible to have multiple instantiations of Bartlett-style heaps; finally, object finalization and weak pointer support are added. <p> Unlike CMM, however, we allow multiple Bartlett-style collectors to be instantiated. Most of the services involving low level page management and object marking have been relegated to a separate heap manager. * We provide support for finalization and weakpointers. * We have implemented blacklisting <ref> [Boe93] </ref> to reduce the chance of false roots identification.
Reference: [CFH + 91] <author> J. Cai, P. Facon, F. Henglein, R. Paige, and E. Schonberg. </author> <title> Type transofrmation and data structure choice. </title> <editor> In B. Moeller, editor, </editor> <booktitle> Constructing Programs From Specifications, </booktitle> <pages> pages 126-164, </pages> <year> 1991. </year>
Reference-contexts: Thus the user can concentrate on specifying the semantic relationships between the elements of the domain, instead of the implementation details. The graph structure mapping process uses real-time set machine simulation [Pai89] and subtype analysis <ref> [CFH + 91] </ref> to convert associative accesses involving sets, maps, and multimaps into hash free, worst-case constant time pointer manipulations. This optimization is performed transparently by the translator.
Reference: [ED93] <author> J.R. Ellis and D.L. Detlefs. </author> <title> Safe, efficient garbage collection for C++. </title> <type> Technical Report CSL-93-4, </type> <note> Xerox Parc, </note> <year> 1993. </year>
Reference: [HMM86] <author> Robert Harper, David MacQueen, and Robin Milner. </author> <title> Standard ML. </title> <type> Report ECS-LFCS-86-2, </type> <institution> Laboratory for Foundations of Computer Science, Computer Science Department, Edinburgh University, </institution> <year> 1986. </year>
Reference-contexts: During parsing, the reductions that are taken will be printed to cerr. 2 Alternatively, inheritance may be used. 4. Algebraic Datatypes and Pattern Matching 17 4 Algebraic Datatypes and Pattern Matching Prop implements algebraic datatypes and pattern matching in the style of Standard ML <ref> [HMM86] </ref>. Tree, DAG and even graph structures can be specified as a set of datatype equations in algebraic datatype specifications. Prop then proceeds to translate these into concrete C++ classes. This makes it very easy to implement complex data structures.
Reference: [Les75] <author> M. E. Lesk. LEX: </author> <title> a lexical analyzer generator. </title> <type> Technical Report 39, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, N.J., </address> <year> 1975. </year>
Reference-contexts: This construct is responsible for generating the actual string matching DFA. The actual buffering mechanisms are provided by the classes LexerBuffer, IOLexerBuffer and IOLexerStack. These classes are part of the support library distributed with Prop. We assume that the user is familiar with lexer generator tools like lex <ref> [Les75] </ref> or flex [Pax90]. 3.1.1 Regular expressions found in lex, or egrep. c matches character c if it is not a meta character e 1 e 2 matches e 1 then e 2 . matches any character except "n "c matches escape sequence c ^e matches e at the start of
Reference: [Pai89] <author> R. Paige. </author> <title> Real-time simulation of a set machine on a RAM. </title> <editor> In N. Janicki and W. Koczkodaj, editor, </editor> <booktitle> Computing and Information, </booktitle> <address> II:69-73, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: The data structure mapping process of translating high level graph specifications into concrete C++ classes is completely automated. Thus the user can concentrate on specifying the semantic relationships between the elements of the domain, instead of the implementation details. The graph structure mapping process uses real-time set machine simulation <ref> [Pai89] </ref> and subtype analysis [CFH + 91] to convert associative accesses involving sets, maps, and multimaps into hash free, worst-case constant time pointer manipulations. This optimization is performed transparently by the translator.
Reference: [Pax90] <author> V. Paxson. </author> <title> Using flex | a fast lexical analyzer. </title> <type> Technical report, </type> <institution> The Regents of the University of California, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: The actual buffering mechanisms are provided by the classes LexerBuffer, IOLexerBuffer and IOLexerStack. These classes are part of the support library distributed with Prop. We assume that the user is familiar with lexer generator tools like lex [Les75] or flex <ref> [Pax90] </ref>. 3.1.1 Regular expressions found in lex, or egrep. c matches character c if it is not a meta character e 1 e 2 matches e 1 then e 2 . matches any character except "n "c matches escape sequence c ^e matches e at the start of the line e
Reference: [San94] <author> Georg Sander. </author> <title> Graph layout through the VCG tool. </title> <type> Technical Report A03/94, </type> <institution> Universitat des Saarlandes, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: The full range of pattern matching and rewriting capability can be used on these externally defined data.. In addition, we intend to implement/fix-up the following features in the near future: 1. Persistence. 2. Pretty printing/reading. 3. Visualization of data structures using vcg <ref> [San94, San95] </ref>. 4. Automatic mapping of graph structure specifications into C++ classes. 5.
Reference: [San95] <author> Georg Sander. VCG: </author> <title> Visualization of Compiler Graphs (v.1.30), </title> <year> 1995. </year>
Reference-contexts: The full range of pattern matching and rewriting capability can be used on these externally defined data.. In addition, we intend to implement/fix-up the following features in the near future: 1. Persistence. 2. Pretty printing/reading. 3. Visualization of data structures using vcg <ref> [San94, San95] </ref>. 4. Automatic mapping of graph structure specifications into C++ classes. 5.
Reference: [SDDS86] <author> J. Schwartz, R. Dewar, D. Dubinsky, and E. Schonberg. </author> <title> Programming with Sets: An Introduction to SETL. </title> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>

References-found: 14

