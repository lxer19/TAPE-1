URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-233.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Email: email: fxxzhang, ryderg@cs.rutgers.edu  
Title: Complexity of Single Level Function Pointer Aliasing Analysis  
Author: Sean Zhang Barbara G. Ryder 
Address: Piscataway, NJ 08855  
Affiliation: Department of Computer Science Rutgers University,  
Abstract: We present a definition of the function pointer aliasing problem for single level function pointers, according to a new approximation of possible program execution for interprocedural analyses in the presence of calls through function pointers. We have classified the complexity of the problem as either polynomial or NP-hard, with respect to various program constructs affecting function pointer aliasing. We present our problem classification and give brief proofs for a polynomial case and a NP-hard case. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Rita Altucher. </author> <type> Personal communication. </type> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: A related area of research is the work done on analyzing aliasing induced by pointers other than function pointers [4, 9, 12, 13]. Since function pointers are just a special kind of pointers, these methods have been adapted to handle function pointers <ref> [1, 6, 7] </ref>, but none of these analyses explicitly define their precision and none are precise according to our definition of the problem.
Reference: [2] <author> D. Callahan, A. Carle, M. W. Hall, and K. Kennedy. </author> <title> Constructing the procedure call multigraph. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 16(4) </volume> <pages> 483-487, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Related Work Ryder [15] presented the first algorithm for call graph construction in the presence of calls through procedure parameters in FORTRAN. Callahan et. al. <ref> [2] </ref> extended it to handle recursion. Both algorithms propagate sets of pairs, each made of a procedure parameter and a procedure name, on incomplete call graphs and construct the final, precise call graphs. <p> The intuition behind the case with no procedure calls returning function pointers, is that only information about k or less function pointer aliases holding simultaneously at program points is necessary for determining precise function pointer may aliases; details are in [18]. The call graph construction problem for FORTRAN <ref> [2, 8, 15] </ref> is a special case of the latter, where no assignments for function pointers are allowed. 4.1 At Most One Function Pointer Referenced in any Indirect Call In this section, we consider the function pointer may aliasing problem when assignments for function pointers, procedure calls, procedure calls returning function
Reference: [3] <author> C. Chambers and D. Ungar. </author> <title> Iterative type analysis and extended message splitting: optimizing dynamically-typed object-oriented programs. </title> <booktitle> In Proceedings of SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 150-164, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: There has also been some work on using static analysis to resolve function invocations through variables for functional languages like Scheme [16] or to resolve dynamic method invocations for object-oriented languages like SELF and C ++ <ref> [3, 14] </ref>. None of these related work has addressed the theoretical difficulty of static analysis for imper ative languages with calls through procedure parameters or function pointers. 2 We show in [18] that multiple level function pointers are more difficult to handle. 2 Overview This paper is organized as follows.
Reference: [4] <author> J. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of te 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year> <month> 15 </month>
Reference-contexts: Weihl [17] proved that the problem of determining possible values for procedure-valued variables without considering other aliasing is P-space hard. A related area of research is the work done on analyzing aliasing induced by pointers other than function pointers <ref> [4, 9, 12, 13] </ref>. Since function pointers are just a special kind of pointers, these methods have been adapted to handle function pointers [1, 6, 7], but none of these analyses explicitly define their precision and none are precise according to our definition of the problem.
Reference: [5] <author> K. Cooper and K. Kennedy. </author> <title> Complexity of interprocedural side-effect analysis. </title> <type> Technical Report 87-61, </type> <institution> Depart--ment of Computer Science, Rice University, Houston,Texas, </institution> <year> 1987. </year>
Reference-contexts: A more general representation would be &lt; flfp , flproc &gt; [11, 12]. 7 This is analogous to similar assumption made about the maximum number of formal parameters of any procedure <ref> [5] </ref>.
Reference: [6] <author> Maryam Emami, Rakesh Ghiya, and Laurie Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: A related area of research is the work done on analyzing aliasing induced by pointers other than function pointers [4, 9, 12, 13]. Since function pointers are just a special kind of pointers, these methods have been adapted to handle function pointers <ref> [1, 6, 7] </ref>, but none of these analyses explicitly define their precision and none are precise according to our definition of the problem.
Reference: [7] <author> Rakesh Ghiya. </author> <title> Interprocedural analysis in the presence of function pointers. </title> <type> ACAPS Technical Memo 62, </type> <institution> McGill University, School of Computer Science, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: A related area of research is the work done on analyzing aliasing induced by pointers other than function pointers [4, 9, 12, 13]. Since function pointers are just a special kind of pointers, these methods have been adapted to handle function pointers <ref> [1, 6, 7] </ref>, but none of these analyses explicitly define their precision and none are precise according to our definition of the problem.
Reference: [8] <author> Mary W. Hall and Ken Kennedy. </author> <title> Efficient call graph analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(3) </volume> <pages> 227-242, </pages> <year> 1993. </year>
Reference-contexts: Callahan et. al. [2] extended it to handle recursion. Both algorithms propagate sets of pairs, each made of a procedure parameter and a procedure name, on incomplete call graphs and construct the final, precise call graphs. Hall and Kennedy <ref> [8] </ref> simplified the algorithm by propagating single pairs instead of sets and thus introduced imprecision into the call graphs constructed. None of these considered assignments for procedure parameters because they are not allowed in FORTRAN. <p> The intuition behind the case with no procedure calls returning function pointers, is that only information about k or less function pointer aliases holding simultaneously at program points is necessary for determining precise function pointer may aliases; details are in [18]. The call graph construction problem for FORTRAN <ref> [2, 8, 15] </ref> is a special case of the latter, where no assignments for function pointers are allowed. 4.1 At Most One Function Pointer Referenced in any Indirect Call In this section, we consider the function pointer may aliasing problem when assignments for function pointers, procedure calls, procedure calls returning function
Reference: [9] <author> Laurie J. Hendren. </author> <title> Parallelizing Programs with Recursive Data Structures. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: Weihl [17] proved that the problem of determining possible values for procedure-valued variables without considering other aliasing is P-space hard. A related area of research is the work done on analyzing aliasing induced by pointers other than function pointers <ref> [4, 9, 12, 13] </ref>. Since function pointers are just a special kind of pointers, these methods have been adapted to handle function pointers [1, 6, 7], but none of these analyses explicitly define their precision and none are precise according to our definition of the problem.
Reference: [10] <author> Arun Lakhotia. </author> <title> Constructing call multigraphs using dependence graphs. </title> <booktitle> In Conference Record of te 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 273-284, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Hall and Kennedy [8] simplified the algorithm by propagating single pairs instead of sets and thus introduced imprecision into the call graphs constructed. None of these considered assignments for procedure parameters because they are not allowed in FORTRAN. Lakhotia <ref> [10] </ref> gave a more general algorithm that handled assignments for what he called procedure variables. His algorithm propagated single pairs, each consisting of a procedure variable and a procedure name, on program dependence graphs; similar to that of Hall and Kennedy, it is not precise.
Reference: [11] <author> William Landi and Barbara G. Ryder. </author> <title> Pointer-induced aliasing: a problem classification. </title> <booktitle> In Conference Record of the 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: Intuitively, a realizable path has matching call and return nodes. The above definition is same as that of a realizable path in <ref> [11, 12] </ref>. Realizable paths starting from entry main would be considered potentially executable for static analysis if there are no calls through function pointers. In the presence of these calls, however, realizability does not totally capture the notion of potentially executable; we define statically executable paths to correct this deficiency. <p> A summary of our results is provided in Figure 2. 6 This notation is only used for single level function pointers. A more general representation would be &lt; flfp , flproc &gt; <ref> [11, 12] </ref>. 7 This is analogous to similar assumption made about the maximum number of formal parameters of any procedure [5]. <p> * more than one function pointer referenced in indirect calls NP-hard NP-hard (i.e., k &gt; 1) (Section 4.2) * procedure calls returning function pointers 7 With only direct calls, statically executable paths are simply realizable paths; the problem can be solved precisely by adapting the algorithm by Landi and Ryder <ref> [11, 12] </ref> for pointer-induced aliasing. With indirect calls and assignments for function pointers, the presence of global function pointers immediately makes tracking of statically executable paths NP-hard; the proof of this can be found in [18]. <p> To account for the effects of procedures being called and avoid paths in the EICFG that are not realizable, a two-phase approach is employed, similar to <ref> [11, 12] </ref>. <p> In this phase, edges from exit nodes to return nodes are ignored and the effects of procedure calls on function pointer aliasing are accounted for at entry nodes of called procedures. Similar to <ref> [11, 12] </ref>, we prove that in this context, we need only consider sets A of function pointer aliases such that jAj 1. The following lemma states this.
Reference: [12] <author> William Landi and Barbara G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of 1992 ACM Symposium on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Weihl [17] proved that the problem of determining possible values for procedure-valued variables without considering other aliasing is P-space hard. A related area of research is the work done on analyzing aliasing induced by pointers other than function pointers <ref> [4, 9, 12, 13] </ref>. Since function pointers are just a special kind of pointers, these methods have been adapted to handle function pointers [1, 6, 7], but none of these analyses explicitly define their precision and none are precise according to our definition of the problem. <p> Intuitively, a realizable path has matching call and return nodes. The above definition is same as that of a realizable path in <ref> [11, 12] </ref>. Realizable paths starting from entry main would be considered potentially executable for static analysis if there are no calls through function pointers. In the presence of these calls, however, realizability does not totally capture the notion of potentially executable; we define statically executable paths to correct this deficiency. <p> A summary of our results is provided in Figure 2. 6 This notation is only used for single level function pointers. A more general representation would be &lt; flfp , flproc &gt; <ref> [11, 12] </ref>. 7 This is analogous to similar assumption made about the maximum number of formal parameters of any procedure [5]. <p> * more than one function pointer referenced in indirect calls NP-hard NP-hard (i.e., k &gt; 1) (Section 4.2) * procedure calls returning function pointers 7 With only direct calls, statically executable paths are simply realizable paths; the problem can be solved precisely by adapting the algorithm by Landi and Ryder <ref> [11, 12] </ref> for pointer-induced aliasing. With indirect calls and assignments for function pointers, the presence of global function pointers immediately makes tracking of statically executable paths NP-hard; the proof of this can be found in [18]. <p> To account for the effects of procedures being called and avoid paths in the EICFG that are not realizable, a two-phase approach is employed, similar to <ref> [11, 12] </ref>. <p> In this phase, edges from exit nodes to return nodes are ignored and the effects of procedure calls on function pointer aliasing are accounted for at entry nodes of called procedures. Similar to <ref> [11, 12] </ref>, we prove that in this context, we need only consider sets A of function pointer aliases such that jAj 1. The following lemma states this.
Reference: [13] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. D. Choi, M. G. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: a clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9) </volume> <pages> 67-70, </pages> <year> 1993. </year>
Reference-contexts: Weihl [17] proved that the problem of determining possible values for procedure-valued variables without considering other aliasing is P-space hard. A related area of research is the work done on analyzing aliasing induced by pointers other than function pointers <ref> [4, 9, 12, 13] </ref>. Since function pointers are just a special kind of pointers, these methods have been adapted to handle function pointers [1, 6, 7], but none of these analyses explicitly define their precision and none are precise according to our definition of the problem.
Reference: [14] <author> Hemant D. Pande and Barbara G. Ryder. </author> <title> Static type determination for C++. </title> <booktitle> In Proceedings of USENIX 6th C++ Technical Conference, </booktitle> <pages> pages 85-97, </pages> <month> April </month> <year> 1994. </year> <note> Also available as Technical Report 197-A, </note> <institution> LCSR, Rutgers University. </institution>
Reference-contexts: There has also been some work on using static analysis to resolve function invocations through variables for functional languages like Scheme [16] or to resolve dynamic method invocations for object-oriented languages like SELF and C ++ <ref> [3, 14] </ref>. None of these related work has addressed the theoretical difficulty of static analysis for imper ative languages with calls through procedure parameters or function pointers. 2 We show in [18] that multiple level function pointers are more difficult to handle. 2 Overview This paper is organized as follows.
Reference: [15] <author> Barbara G. Ryder. </author> <title> Constructing the call graph of a program. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 5(3) </volume> <pages> 216-226, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: Ultimately, these findings will help us to come up with practical aliasing algorithms for function pointers and to tackle the problem of interprocedural data flow analyses in the presence of calls through function pointers. Related Work Ryder <ref> [15] </ref> presented the first algorithm for call graph construction in the presence of calls through procedure parameters in FORTRAN. Callahan et. al. [2] extended it to handle recursion. <p> The intuition behind the case with no procedure calls returning function pointers, is that only information about k or less function pointer aliases holding simultaneously at program points is necessary for determining precise function pointer may aliases; details are in [18]. The call graph construction problem for FORTRAN <ref> [2, 8, 15] </ref> is a special case of the latter, where no assignments for function pointers are allowed. 4.1 At Most One Function Pointer Referenced in any Indirect Call In this section, we consider the function pointer may aliasing problem when assignments for function pointers, procedure calls, procedure calls returning function
Reference: [16] <author> Olin Shivers. </author> <title> Control flow analysis in scheme. </title> <booktitle> In Proceedings of SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 164-174, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: There has also been some work on using static analysis to resolve function invocations through variables for functional languages like Scheme <ref> [16] </ref> or to resolve dynamic method invocations for object-oriented languages like SELF and C ++ [3, 14].
Reference: [17] <author> W. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables and label variables. </title> <booktitle> In Conference Record of the 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <month> Jan. </month> <year> 1980. </year>
Reference-contexts: Lakhotia [10] gave a more general algorithm that handled assignments for what he called procedure variables. His algorithm propagated single pairs, each consisting of a procedure variable and a procedure name, on program dependence graphs; similar to that of Hall and Kennedy, it is not precise. Weihl <ref> [17] </ref> proved that the problem of determining possible values for procedure-valued variables without considering other aliasing is P-space hard. A related area of research is the work done on analyzing aliasing induced by pointers other than function pointers [4, 9, 12, 13].
Reference: [18] <author> Sean Zhang and Barbara G. Ryder. </author> <title> Complexity of interprocedural function pointer aliasing analysis. </title> <type> Technical report, </type> <institution> Laboratory for Computer Science Research, Rutgers University, </institution> <month> July </month> <year> 1994. </year> <note> In Preparation. 16 </note>
Reference-contexts: None of these related work has addressed the theoretical difficulty of static analysis for imper ative languages with calls through procedure parameters or function pointers. 2 We show in <ref> [18] </ref> that multiple level function pointers are more difficult to handle. 2 Overview This paper is organized as follows. Section 2 presents the program representation and Section 3 defines the problem. The classification of the problem is reported in Section 4. <p> Function Pointer May Aliasing Program Constructs in the absence of Single Level in the presence of Single Level Global Function Pointers Global Function Pointers * assignments for function pointers * no indirect calls Polynomial Polynomial * procedure calls returning function pointers * assignments for function pointers * procedure calls NP-hard <ref> [18] </ref> * assignments for function pointers * procedure calls * one or more function pointers referenced in any direct call Polynomial [18] NP-hard (i.e., k 1) * no procedure calls returning function pointers * assignments for function pointers * procedure calls * only one function pointer referenced in any indirect call <p> Global Function Pointers * assignments for function pointers * no indirect calls Polynomial Polynomial * procedure calls returning function pointers * assignments for function pointers * procedure calls NP-hard <ref> [18] </ref> * assignments for function pointers * procedure calls * one or more function pointers referenced in any direct call Polynomial [18] NP-hard (i.e., k 1) * no procedure calls returning function pointers * assignments for function pointers * procedure calls * only one function pointer referenced in any indirect call Polynomial NP-hard (i.e., k = 1) (Section 4.1) * procedure calls returning function pointers * assignments for function pointers * procedure <p> With indirect calls and assignments for function pointers, the presence of global function pointers immediately makes tracking of statically executable paths NP-hard; the proof of this can be found in <ref> [18] </ref>. In the absence of global function pointers, the following two program constructs are significant to the problem: more than one function pointer referenced in indirect calls (i.e., k &gt; 1) and procedure calls returning function pointers. <p> The intuition behind the case with no procedure calls returning function pointers, is that only information about k or less function pointer aliases holding simultaneously at program points is necessary for determining precise function pointer may aliases; details are in <ref> [18] </ref>. <p> The proof of this Lemma is by induction on the length of the subpath n 1 n 2 :::n i n and a case analysis on n i <ref> [18] </ref>. Computing Conditional Function Pointer May Aliases. Given an EICFG, conditional function pointer may aliases are computed on a function pointer alias graph (FPAG). <p> We claim the calculation of f-holds and f-alias is a polynomial time algorithm for determining precise function pointer may aliases in this context. The proof that the algorithm is precise is by induction on path length and number of iterations of the fixed point calculations for f-holds and f-alias <ref> [18] </ref>. 4.2 More Than One Function Pointer Referenced in Indirect Calls and Proce dure Calls Returning Function Pointers Theorem 4.2 In the absence of global function pointers, and in the presence of assignments for function 13 typedef void (flPF)(); PF true ( PF (*arg)() ) f return ((PF) arg); g =fl
References-found: 18

