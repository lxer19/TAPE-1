URL: http://www.cs.ucsd.edu/users/mihir/papers/batch.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/mihir/papers/batch.html
Root-URL: http://www.cs.ucsd.edu
Email: E-mail: garay@  E-mail: talr@watson.ibm.com.  
Title: Fast Batch Verification for Modular Exponentiation and Digital Signatures  
Author: Mihir Bellare Juan A. Garay Tal Rabin watson.ibm.com. 
Address: PO Box 704, Yorktown Heights, New York 10598, USA.  PO Box 704, Yorktown Heights, New York 10598, USA.  
Affiliation: IBM T.J. Watson Research Center,  IBM T.J. Watson Research Center,  
Date: June 1998  
Note: Lecture Notes in Computer Science Vol. 1403, K. Nyberg ed., Springer-Verlag, 1998. This is the full version.  
Abstract: An extended abstract of this paper appears in Advances in Cryptology - Eurocrypt 98 Proceedings, Abstract Many tasks in cryptography (e.g., digital signature verification) call for verification of a basic operation like modular exponentiation in some group: given (g; x; y) check that g x = y. This is typically done by re-computing g x and checking we get y. We would like to do it differently, and faster. The approach we use is batching. Focusing first on the basic modular exponentiation operation, we provide some probabilistic batch verifiers, or tests, that verify a sequence of modular exponentiations significantly faster than the naive re-computation method. This yields speedups for several verification tasks that involve modular exponentiations. Focusing specifically on digital signatures, we then suggest a weaker notion of (batch) verification which we call "screening." It seems useful for many usages of signatures, and has the advantage that it can be done very fast; in particular, we show how to screen a sequence of RSA signatures at the cost of one RSA verification plus hashing. fl Department of Computer Science & Engineering, Mail Code 0114, University of California at San Diego, 9500 Gilman Drive, La Jolla, CA 92093, USA. E-mail: mihir@cs.ucsd.edu. URL: http://www-cse.ucsd.edu/ users/mihir. Supported in part by NSF CAREER Award CCR-9624439 and a 1996 Packard Foundation Fellowship in Science and Engineering. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Adleman and K. Kompella. </author> <title> Fast Checkers for Cryptography. </title> <booktitle> Advances in Cryptology - Crypto 90 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 537, </volume> <editor> A. J. Menezes and S. Vanstone ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Suppose b 1 ; : : : ; b n are integers in the range 0; : : : ; 2 t 1 &lt; jGj. We write them all as strings of length t, so that b i = b i [t] : : : b i <ref> [1] </ref>. The problem is to compute the product a = Q n b i the operations being in G. <p> We say that I (t; *)-breaks RSA (e) , where t: N ! N and *: N ! <ref> [0; 1] </ref>, if, in the above experiment, I runs for at most t (k) steps and has success probability at least *(k). We say that RSA (e) is (t; *)-secure collection of one-way functions if there is no inverter which (t; *)-breaks RSA (e) .
Reference: [2] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. </author> <title> Proof verification and hardness of approximation problems. </title> <booktitle> Proceedings of the 33rd Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1992. </year>
Reference: [3] <author> M. Bellare, J. Garay and T. Rabin. </author> <title> Distributed pseudo-random bit generators| a new way to speed-up shared coin tossing. </title> <booktitle> Proceedings Fifteenth Annual Symposium on Principles of Distributed Computing, ACM, </booktitle> <year> 1996. </year>
Reference-contexts: See Section C for more information including explanations of how this differs from other notions like batch program checking [28]. In Appendix B we provide batch verification algorithms for degrees of polynomials, which has applications in verifiable secret sharing. The idea of batch verification introduced here was applied in <ref> [3] </ref> in the domain of fault-tolerant distributed computing. They design a batch verifiable secret sharing protocol and use it to construct "distributed pseudo-random bit generators," which are efficient ways of generating shared distributed coins. An extended abstract of this paper appeared as [4].
Reference: [4] <author> M. Bellare, J. Garay and T. Rabin. </author> <title> Fast batch verification for modular exponentiation and digital signatures. </title> <booktitle> Advances in Cryptology - Eurocrypt 98 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 1403, </volume> <editor> K. Nyberg ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1998. </year> <month> 17 </month>
Reference-contexts: They design a batch verifiable secret sharing protocol and use it to construct "distributed pseudo-random bit generators," which are efficient ways of generating shared distributed coins. An extended abstract of this paper appeared as <ref> [4] </ref>. <p> The simplest thing to do is compute the hashes of all the messages, and then sort these values. If there are duplicates in 1 In the preliminary version of this paper <ref> [4] </ref> we had omitted the pruning step, implicitly assuming (both in the test and in the analysis) that all messages M 1 ; : : : ; M n going into the main test were distinct. <p> Acknowledgments We thank the (anonymous) referees of Eurocrypt 98 for their comments. We also thank David Naccache for pointing out that the presentation of our RSA screen test in the preliminary version of this work <ref> [4] </ref> made the assumption that the messages are distinct. Accordingly we have added the pruning step in Figure 4.
Reference: [5] <author> M. Bellare, J. Garay and T. Rabin. </author> <title> Batch verification with applications to cryptography and checking (Invited Paper), </title> <booktitle> Latin American Theoretical INformatics 98 (LATIN '98) Proceedings, </booktitle> <volume> LNCS Vol. 1830, </volume> <editor> C. Lucchesi and A. Moura eds., </editor> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: An extended abstract of this paper appeared as [4]. An invited talk on batch verification including the material presented in this paper was given at LATIN '98 <ref> [5] </ref>. 2 Definitions Here we provide formal definitions of the main new notions underlying this work, extending the discussion in Section 1. 2.1 Batch verification Let R () be a boolean relation, meaning R () 2 f0; 1g.
Reference: [6] <author> M. Bellare and P. Rogaway. </author> <title> Random oracles are practical: A paradigm for designing efficient protocols. </title> <booktitle> First ACM Conference on Computer and Communications Security, ACM, </booktitle> <year> 1994. </year>
Reference-contexts: To get a better security guarantee without sacrificing performance, [7] appeals to the random oracle paradigm <ref> [6] </ref> and considers a couple of schemes in this setting. The simplest is the Full Domain Hash (FDH-RSA) scheme, which assumes H is a random oracle mapping f0; 1g fl to Z fl N , and they show that FDH-RSA scheme is secure assuming RSA is a one-way function.
Reference: [7] <author> M. Bellare and P. Rogaway. </author> <title> The exact security of digital signatures: How to sign with RSA and Rabin. </title> <booktitle> Advances in Cryptology - Eurocrypt 96 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 1070, </volume> <editor> U. Maurer ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: A pair (M; x) is verified by checking that x e = H (M ) mod N . This was named the "hash-then-decrypt" paradigm and studied recently in <ref> [7] </ref> who point out that collision-freeness of H is not a strong enough requierement to guarantee security of this scheme based on the one-wayness of RSA. To get a better security guarantee without sacrificing performance, [7] appeals to the random oracle paradigm [6] and considers a couple of schemes in this <p> This was named the "hash-then-decrypt" paradigm and studied recently in <ref> [7] </ref> who point out that collision-freeness of H is not a strong enough requierement to guarantee security of this scheme based on the one-wayness of RSA. To get a better security guarantee without sacrificing performance, [7] appeals to the random oracle paradigm [6] and considers a couple of schemes in this setting. <p> Below, we show there is not, unless inverting RSA is easy. Correctness of the screen test. Since this is based on the hardness of RSA we first recall the latter, following the concrete treatment of <ref> [7] </ref>. Fix some prime number e. <p> by looking at important special cases like Z fl p where p is prime or Z fl N where N is an RSA modulus. * Find fast screening algorithms for other signature schemes like DSS. * Extend our screen test for FDH-RSA to other RSA based signature schemes like PSS <ref> [7] </ref> which have tighter security, and try to get tighter reductions of the security of the screen test to that of RSA as a one-way function. Acknowledgments We thank the (anonymous) referees of Eurocrypt 98 for their comments.
Reference: [8] <author> M. Beller and Y. Yacobi. </author> <title> Batch Diffie-Hellman key agreement systems and their application to portable communications. </title> <booktitle> Advances in Cryptology - Eurocrypt 92 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 658, </volume> <editor> R. Rueppel ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In fact, better exponentiation methods only make our batch verifiers even faster, because we use these methods as subroutines. The idea of batching in cryptography is of course not new: some previous instances are <ref> [18, 25, 8, 24, 34] </ref>.
Reference: [9] <author> E. Berlekamp and L. Welch. </author> <title> Error correction of algebraic block codes. </title> <type> US Patent 4,633,470. </type>
Reference: [10] <author> M. Blum, W. Evans, P. Gemmell, S. Kannan, and M. Naor. </author> <title> Checking the Correctness of Memories. </title> <booktitle> Proceedings of the 32nd Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1991. </year>
Reference: [11] <author> M. Blum and S. Kannan. </author> <title> Designing programs that check their work. </title> <booktitle> Proceedings of the 21st Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1989. </year>
Reference-contexts: Nonetheless, we apply this notion to do program checking in a novel way. Our approach, called batch program instance checking, permits fast checking, and also permits instance checking, not just program checking, in the sense that (in contrast to standard program checking <ref> [11] </ref>), a correct result is not rejected just because the program might be wrong on some other instance.
Reference: [12] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self-Testing/Correcting with Applications to Numerical Problems. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 47 </volume> <pages> 549-595, </pages> <year> 1993. </year>
Reference: [13] <author> J. Bos and M. Coster. </author> <title> Addition chain heuristics. </title> <booktitle> Advances in Cryptology - Crypto 89 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 435, </volume> <editor> G. Brassard ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Following a brief discussion of previous work, we will look at all the above in more detail. Previous work. The modular exponentiation operation itself can be made more efficient via preprocessing [14, 23] or addition chain heuristics <ref> [13, 32, 27] </ref>. What we are saying is that performing modular exponentiation is only one way to perform verification, and if the interest is verification, one can do better than any of these ways. <p> b for a 2 G and b an integer of k 1 bits; and ExpCost s G (k 1 ) is the cost of computing s different such exponentiations. (Under the normal square-and-multiply method, ExpCost G (k 1 ) 1:5k 1 multiplications in the group, but it could be less <ref> [14, 23, 13] </ref>. Obviously ExpCost s G (k 1 ) s ExpCost G (k 1 ), but there are ways to make it strictly less [14, 23, 13], which is why it is a separate parameter. <p> s different such exponentiations. (Under the normal square-and-multiply method, ExpCost G (k 1 ) 1:5k 1 multiplications in the group, but it could be less <ref> [14, 23, 13] </ref>. Obviously ExpCost s G (k 1 ) s ExpCost G (k 1 ), but there are ways to make it strictly less [14, 23, 13], which is why it is a separate parameter. See Section 2.3 for more information.) We treat costs of basic operations like exponentiation as a parameter to stress that our tests can make use of any method for the task. <p> Given a 2 G and an integer b, the standard square-and-multiply method computes a b 2 G at a cost of 1:5jbj multiplications on the average. Using the windowing method based on addition chains <ref> [13, 32] </ref>, the cost can be reduced to about 1:2jbj; pre-computation methods have been proposed to reduce the number of multiplications further at the expense of storage for the pre computed values [14, 23] (a range of values can be obtained here; we give some numerical examples 7 in Section 3.6).
Reference: [14] <author> E. Brickell, D. Gordon, K. McCurley and D. Wilson. </author> <title> Fast exponentiation with precomputa-tion. </title> <booktitle> Advances in Cryptology - Eurocrypt 92 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 658, </volume> <editor> R. Rueppel ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Following a brief discussion of previous work, we will look at all the above in more detail. Previous work. The modular exponentiation operation itself can be made more efficient via preprocessing <ref> [14, 23] </ref> or addition chain heuristics [13, 32, 27]. What we are saying is that performing modular exponentiation is only one way to perform verification, and if the interest is verification, one can do better than any of these ways. <p> b for a 2 G and b an integer of k 1 bits; and ExpCost s G (k 1 ) is the cost of computing s different such exponentiations. (Under the normal square-and-multiply method, ExpCost G (k 1 ) 1:5k 1 multiplications in the group, but it could be less <ref> [14, 23, 13] </ref>. Obviously ExpCost s G (k 1 ) s ExpCost G (k 1 ), but there are ways to make it strictly less [14, 23, 13], which is why it is a separate parameter. <p> s different such exponentiations. (Under the normal square-and-multiply method, ExpCost G (k 1 ) 1:5k 1 multiplications in the group, but it could be less <ref> [14, 23, 13] </ref>. Obviously ExpCost s G (k 1 ) s ExpCost G (k 1 ), but there are ways to make it strictly less [14, 23, 13], which is why it is a separate parameter. See Section 2.3 for more information.) We treat costs of basic operations like exponentiation as a parameter to stress that our tests can make use of any method for the task. <p> Using the windowing method based on addition chains [13, 32], the cost can be reduced to about 1:2jbj; pre-computation methods have been proposed to reduce the number of multiplications further at the expense of storage for the pre computed values <ref> [14, 23] </ref> (a range of values can be obtained here; we give some numerical examples 7 in Section 3.6). Accordingly it is best to treat the cost of exponentiation as a parameter. <p> Say each exponent is t bits long. We can certainly do this with n ExpCost G (t) multiplications. However, it is possible to do better, via the techniques of <ref> [14, 23] </ref>, because in this case the pre-computation can be done on-line and still yield an overall savings. Accordingly, we treat the cost of this operation as a parameter too, denoting it ExpCost n G (t). <p> + n 1 multiplications, where k 2 is the size of the representation of an element of G. (Using square-and-multiply exponentiation, for example, this works out to 3ntk 2 =2 + n 1 multiplications; with a faster exponentiation it may be a bit less.) However, drawing on some ideas from <ref> [14] </ref>, we can do better, as follows: Algorithm FastMult ((a 1 ; b 1 ); : : : ; (a n ; b n )) a := 1; for j = t downto 1 do for i = 1 to n do if b i [j] = 1 then a := <p> We compare with the naive batch test, but this test is not naively implemented, in the sense that to be fair we use fast exponentiation as per <ref> [14, 23] </ref> to get the numbers in the first column. (Our tests use the same fast exponentiation methods as subroutines.) We assume a single exponentiation requires 200 12 n No. of multiplications used by different tests Naive Random Subset Small Exponents Bucket 5 1 K 12 K 0.4 K 4.3 K
Reference: [15] <author> E. Brickell, P. Lee and Y. Yacobi. </author> <title> Secure audio teleconference. </title> <booktitle> Advances in Cryptology - Crypto 87 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 293, </volume> <editor> C. Pomerance ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: See Appendix A. In many ZK or witness-hiding proofs, discrete exponentiation may be used to implement bit commitment, and there are lots of such commitments. Our batch verifiers will speed-up verification of the de-commitments. We can also improve the discrete log based n-party signature protocols of Brickell et al. <ref> [15] </ref>. See Appendix A. Exponentiation with common exponent. The version of the exponentiation problem that underlies RSA is different from the above in that the exponent, not the base, is fixed. The results discussed above don't apply to this version.
Reference: [16] <author> D. Chaum and J. van de Graaf. </author> <title> An Improved Protocol for Demonstrating Possession of a Discrete Logarithm and Some Generalizations. </title> <booktitle> Advances in Cryptology - Eurocrypt 87 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 304, </volume> <editor> D. Chaum ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference: [17] <author> F. Ergun, S. Ravi Kumar, and R. Rubinfeld. </author> <title> Approximate Checking of Polynomials and Functional Equations. </title> <booktitle> Proceedings of the 37th Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1996. </year>
Reference: [18] <author> A. Fiat. </author> <title> Batch RSA. </title> <journal> Journal of Cryptology, </journal> <volume> Vol. 10, No. 2, </volume> <year> 1997, </year> <pages> pp. 75-88. </pages>
Reference-contexts: In fact, better exponentiation methods only make our batch verifiers even faster, because we use these methods as subroutines. The idea of batching in cryptography is of course not new: some previous instances are <ref> [18, 25, 8, 24, 34] </ref>.
Reference: [19] <author> A. Fiat and A. Shamir. </author> <title> How to Prove Yourself: Practical Solutions to Identification and Signature Problems. </title> <booktitle> Advances in Cryptology - Crypto 86 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 263, </volume> <editor> A. Odlyzko ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference: [20] <author> National Institute for Standards and Technology. </author> <title> Digital Signature Standard (DSS). </title> <journal> Federal Register, </journal> <volume> Vol. 56, No. 169, </volume> <month> August 30, </month> <year> 1991. </year>
Reference-contexts: Some applications. Applications are relatively obvious, namely to any discrete logarithm based protocol in which discrete exponentiation needs to be verified. In some cases, we need to tweak the techniques. DSS signatures <ref> [20] </ref> are a particularly attractive target for batch verification because signing is fast and verification is slow. Naccache et al. [25] give some batch verification algorithms for a slight variant of DSS. We can adapt our tests to apply to this variant, and get faster batch verification algorithms.
Reference: [21] <author> P. Gemmell, R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson. </author> <title> Self-testing/correcting for polynomials and for approximate functions. </title> <booktitle> Proceedings of the 23rd Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1991. </year>
Reference: [22] <author> R. Heiman. </author> <title> Secure Audio Teleconference: A Practical Solution. </title> <booktitle> Advances in Cryptology Euro-crypt 92 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 658, </volume> <editor> R. Rueppel ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [23] <author> C. Lim and P. Lee. </author> <title> More flexible exponentiation with precomputation. </title> <booktitle> Advances in Cryptology - Crypto 94 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 839, </volume> <editor> Y. Desmedt ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Following a brief discussion of previous work, we will look at all the above in more detail. Previous work. The modular exponentiation operation itself can be made more efficient via preprocessing <ref> [14, 23] </ref> or addition chain heuristics [13, 32, 27]. What we are saying is that performing modular exponentiation is only one way to perform verification, and if the interest is verification, one can do better than any of these ways. <p> b for a 2 G and b an integer of k 1 bits; and ExpCost s G (k 1 ) is the cost of computing s different such exponentiations. (Under the normal square-and-multiply method, ExpCost G (k 1 ) 1:5k 1 multiplications in the group, but it could be less <ref> [14, 23, 13] </ref>. Obviously ExpCost s G (k 1 ) s ExpCost G (k 1 ), but there are ways to make it strictly less [14, 23, 13], which is why it is a separate parameter. <p> s different such exponentiations. (Under the normal square-and-multiply method, ExpCost G (k 1 ) 1:5k 1 multiplications in the group, but it could be less <ref> [14, 23, 13] </ref>. Obviously ExpCost s G (k 1 ) s ExpCost G (k 1 ), but there are ways to make it strictly less [14, 23, 13], which is why it is a separate parameter. See Section 2.3 for more information.) We treat costs of basic operations like exponentiation as a parameter to stress that our tests can make use of any method for the task. <p> Using the windowing method based on addition chains [13, 32], the cost can be reduced to about 1:2jbj; pre-computation methods have been proposed to reduce the number of multiplications further at the expense of storage for the pre computed values <ref> [14, 23] </ref> (a range of values can be obtained here; we give some numerical examples 7 in Section 3.6). Accordingly it is best to treat the cost of exponentiation as a parameter. <p> Say each exponent is t bits long. We can certainly do this with n ExpCost G (t) multiplications. However, it is possible to do better, via the techniques of <ref> [14, 23] </ref>, because in this case the pre-computation can be done on-line and still yield an overall savings. Accordingly, we treat the cost of this operation as a parameter too, denoting it ExpCost n G (t). <p> We compare with the naive batch test, but this test is not naively implemented, in the sense that to be fair we use fast exponentiation as per <ref> [14, 23] </ref> to get the numbers in the first column. (Our tests use the same fast exponentiation methods as subroutines.) We assume a single exponentiation requires 200 12 n No. of multiplications used by different tests Naive Random Subset Small Exponents Bucket 5 1 K 12 K 0.4 K 4.3 K <p> The lowest number for each n is underlined. multiplications <ref> [23] </ref>. (Using other storage to time tradeoffs as per [23] doesn't change the results, namely that our tests consistently perform better.) Observe that which test is better depends on the value of n. As we expected, the RS test is actually worse than naive for small n. <p> The lowest number for each n is underlined. multiplications <ref> [23] </ref>. (Using other storage to time tradeoffs as per [23] doesn't change the results, namely that our tests consistently perform better.) Observe that which test is better depends on the value of n. As we expected, the RS test is actually worse than naive for small n. Until n about 200, the Small Exponents Test test is the best.
Reference: [24] <author> D. M'Ra hi and D. Naccache. </author> <title> Batch exponentiation A fast DLP based signature generation strategy. </title> <booktitle> 3rd ACM Conference on Computer and Communications Security, ACM, </booktitle> <year> 1996. </year>
Reference-contexts: In fact, better exponentiation methods only make our batch verifiers even faster, because we use these methods as subroutines. The idea of batching in cryptography is of course not new: some previous instances are <ref> [18, 25, 8, 24, 34] </ref>.
Reference: [25] <author> D. Naccache, D. M'Ra hi, S. Vaudenay and D. Raphaeli. </author> <title> Can D.S.A be improved? Complexity trade-offs with the digital signature standard. </title> <booktitle> Advances in Cryptology - Eurocrypt 94 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 950, </volume> <editor> A. De Santis ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In fact, better exponentiation methods only make our batch verifiers even faster, because we use these methods as subroutines. The idea of batching in cryptography is of course not new: some previous instances are <ref> [18, 25, 8, 24, 34] </ref>. <p> In some cases, we need to tweak the techniques. DSS signatures [20] are a particularly attractive target for batch verification because signing is fast and verification is slow. Naccache et al. <ref> [25] </ref> give some batch verification algorithms for a slight variant of DSS. We can adapt our tests to apply to this variant, and get faster batch verification algorithms. See Appendix A.
Reference: [26] <author> K. Ohta and T. Okamoto. </author> <title> A Modification of the Fiat-Shamir Scheme. </title> <booktitle> Advances in Cryptology - Crypto 88 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 403, </volume> <editor> S. Goldwasser ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference: [27] <author> P. de Rooij. </author> <title> Efficient exponentiation using precomputation and vector addition chains. </title> <booktitle> Advances in Cryptology - Eurocrypt 94 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 950, </volume> <editor> A. De Santis ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Following a brief discussion of previous work, we will look at all the above in more detail. Previous work. The modular exponentiation operation itself can be made more efficient via preprocessing [14, 23] or addition chain heuristics <ref> [13, 32, 27] </ref>. What we are saying is that performing modular exponentiation is only one way to perform verification, and if the interest is verification, one can do better than any of these ways.
Reference: [28] <author> R. Rubinfeld. </author> <title> Batch Checking with applications to linear functions. </title> <journal> Information Processing Letters, </journal> <volume> 42 </volume> <pages> 77-80, </pages> <year> 1992. </year>
Reference-contexts: See Section C for more information including explanations of how this differs from other notions like batch program checking <ref> [28] </ref>. In Appendix B we provide batch verification algorithms for degrees of polynomials, which has applications in verifiable secret sharing. The idea of batch verification introduced here was applied in [3] in the domain of fault-tolerant distributed computing.
Reference: [29] <author> R. Rubinfeld. </author> <title> On the Robustness of Functional Equations. </title> <booktitle> Proceedings of the 35th Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1994. </year>
Reference: [30] <author> R. Rubinfeld. </author> <title> Designing Checkers for Programs that Run in Parallel. </title> <journal> Algorithmica, </journal> <volume> 15(4) </volume> <pages> 287-301, </pages> <year> 1996. </year>
Reference: [31] <author> R. Rubinfeld and M. Sudan. </author> <title> Robust Characterizations of Polynomials with Applications to Program Testing. </title> <journal> SIAM Journal on Computing, </journal> <volume> 25(2) </volume> <pages> 252-271, </pages> <year> 1996. </year>
Reference: [32] <author> J. Sauerbrey and A. Dietel. </author> <title> Resource requirements for the application of addition chains modulo exponentiation. </title> <booktitle> Advances in Cryptology - Eurocrypt 92 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 658, </volume> <editor> R. Rueppel ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Following a brief discussion of previous work, we will look at all the above in more detail. Previous work. The modular exponentiation operation itself can be made more efficient via preprocessing [14, 23] or addition chain heuristics <ref> [13, 32, 27] </ref>. What we are saying is that performing modular exponentiation is only one way to perform verification, and if the interest is verification, one can do better than any of these ways. <p> Given a 2 G and an integer b, the standard square-and-multiply method computes a b 2 G at a cost of 1:5jbj multiplications on the average. Using the windowing method based on addition chains <ref> [13, 32] </ref>, the cost can be reduced to about 1:2jbj; pre-computation methods have been proposed to reduce the number of multiplications further at the expense of storage for the pre computed values [14, 23] (a range of values can be obtained here; we give some numerical examples 7 in Section 3.6).
Reference: [33] <author> D. Stee, L. Strawczynski, W. Diffie, and M. Wiener. </author> <title> A Secure Audio Teleconference System. </title> <booktitle> Advances in Cryptology - Crypto 88 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 403, </volume> <editor> S. Goldwasser ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference: [34] <author> S. Yen and C. Laih. </author> <title> Improved Digital Signature suitable for Batch Verification. </title> <type> Technical Report, </type> <institution> Dept. of Electrical Engineering, Laboratory of Cryptography and Information Security, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: In fact, better exponentiation methods only make our batch verifiers even faster, because we use these methods as subroutines. The idea of batching in cryptography is of course not new: some previous instances are <ref> [18, 25, 8, 24, 34] </ref>.
References-found: 34

