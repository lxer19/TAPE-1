URL: http://www.cs.wisc.edu/~vganti/rtgenesis.ps
Refering-URL: http://www.cs.wisc.edu/~vganti/vganti.html
Root-URL: 
Email: (krithi@cs.umass.edu)  
Title: Design, Implementation and Performance of a Real-Time Version of a Commercial RDBMS  
Author: Rohan.F.M. Aranha Venkatesh Ganti Srinivasa Narayanan C.R. Muthukrishnan flfl S.T.S. Prasad Krithi Ramamritham 
Address: Massachusetts  
Affiliation: Stanford University, University of Wisconsin, flfl Indian Institute of Technology, Madras, HCL-HP, Madras, India University of  
Abstract: A real-time database system is a database system in which transactions have explicit timing constraints such as deadlines. Apart from satisfying the database consistency constraints, transaction executions must also satisfy these timing constraints. The goal of transaction and query processing in real-time databases is to maximise the number of successful transactions in the system. This paper reports on the design, development and performance evaluation of RT-Genesis, a real-time database management system resulting from modifying an existing commercial DBMS, Genesis. RT-Genesis is a relational database management system that accommodates SQL queries and transactions having time constraints. It features time-cognizant algorithms for scheduling, concurrency control and buffer management. The system has been tested and the performance of the different algorithms compared in isolation as well as in combination with different classes of SQL workloads. In addition, a two-phased approach to transaction execution has also been implemented with the goal of exploiting access invariance to improve predictability. This work demonstrates the feasibility of converting non-real-time DBMSs into real-time DBMSs for firm deadline transactions. Besides reporting on how this was achieved and on the performance of the incorporated algorithms, lessons learned from this experience are also discussed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abbott R. and H. Garcia-Molina. </author> <title> Scheduling Real-Time Transactions: A Performance Evaluation. </title> <journal> ACM Transactions on Database Systems, </journal> <pages> pp. 513-560, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: With regard to the last two items, in some sense, the conclusions are not startling. Similar observations have been made in earlier simulation-based studies (see <ref> [1, 10, 14, 15] </ref>, for example) or the rarer implementation-based study [9].
Reference: [2] <author> B Adelberg, H. Garcia-Molina, B. Kao. </author> <title> Emulating Soft Real-Time Scheduling using Traditional Operating System Schedulers, </title> <booktitle> Real-Time Systems Symposium, </booktitle> <pages> pp. 292-298, </pages> <month> Dec </month> <year> 1994. </year>
Reference-contexts: This policy has been the cornerstone of many real-time systems and in the non-overloaded case, it has been proved to be optimal. We have implemented a dynamic earliest deadline first policy as well as two static policies, the latter inspired by those proposed in <ref> [2] </ref>. The scheduling policies involve mapping deadlines linearly onto the priorities.
Reference: [3] <author> M.J. Carey, R. Jauhari and M. Livny. </author> <title> Priority in DBMS Resource Scheduling, </title> <booktitle> Proceedings of the VLDB, </booktitle> <pages> pp. 397-410, </pages> <year> 1990. </year>
Reference-contexts: Work done in the area of real-time buffer management includes <ref> [3] </ref> and [9]. Whereas [9] reports of no significant performance improvements when time-cognizant buffer management 11 policies are used, studies discussed in [3] show that transaction priorities must be considered in buffer management. <p> Work done in the area of real-time buffer management includes <ref> [3] </ref> and [9]. Whereas [9] reports of no significant performance improvements when time-cognizant buffer management 11 policies are used, studies discussed in [3] show that transaction priorities must be considered in buffer management. In this study we see that policies taking the priorities of transactions into account do perform better than those which do not. This corroborates the results from [3]. 7 Lock Management Similar to the buffer case, we can have inheritance <p> improvements when time-cognizant buffer management 11 policies are used, studies discussed in <ref> [3] </ref> show that transaction priorities must be considered in buffer management. In this study we see that policies taking the priorities of transactions into account do perform better than those which do not. This corroborates the results from [3]. 7 Lock Management Similar to the buffer case, we can have inheritance and abort based protocols. Since it has already been established that time cognizant protocols are essential, we do not compare with a non real-time protocol. <p> Thus, for example, when a buffer page was unavailable, it was not possible to preempt a running transaction, use a single page used by the transaction, and later allow it to resume. But for such constraints, we would have liked to study other protocols, e.g., priority-LRU <ref> [3] </ref>, for buffer management.
Reference: [4] <author> M. Dertouzos, </author> <title> Control Robotics: The Procedural Control of Physical Processes. </title> <booktitle> Proceedings of the IFIP Congress, </booktitle> <year> 1974. </year>
Reference-contexts: It assigns priorities strictly in the earliest deadline first fashion. The transaction with an earlier deadline has a higher priority. This has been proved to be optimal <ref> [4] </ref>. So the performance of the dynamic scheduling algorithm is better than the static scheduling algorithms. The overhead of recomputation of priorities for every new arrival is not very large in our case since at most 10 transactions were concurrently in the system at any given time in our system.
Reference: [5] <author> Franaszek P. A., J. T. Robinson, and A. Thomasian. </author> <title> Concurrency Control for High Contention Environments. </title> <journal> ACM Transactions on Database Systems, </journal> <pages> pp. 304-345, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Between these two extremes when one needs to judiciously decide which transaction to abort. A decision based on which transaction has done more work, such as with LC, has good payoffs. 9 Two Phase Transaction Execution We have also implemented a two-phased approach to transaction execution <ref> [11, 5] </ref>. The motivation for this approach is to decrease the effect of lock conflicts when combined with I/O delays. Specifically, because of the delay involved in bringing the data into the buffer, a transaction holds its locks for a longer duration, resulting in increased conflicts.
Reference: [6] <author> H-T Chou and D. J. DeWitt. </author> <title> An Evaluation of Buffer Management Strategies for Re--lational Database Systems, </title> <booktitle> Proceedings of the VLDB, </booktitle> <year> 1985. </year>
Reference-contexts: A maximum size and page replacement policy is identified for each of the page sets, depending on the type of object and predicted reference pattern. This is done using the DBMIN algorithm <ref> [6] </ref>. Whenever a transaction writes a data item it is copied from the buffer onto its local address space if it is not already present. The local memory where the data modified is kept are called intentions.
Reference: [7] <author> J. Huang, J. A. Stankovic, D. Towsley. </author> <title> Krithi Ramamritham Real-Time Transaction Processing : Design, Implementation and Performance Evaluation, </title> <type> COINS 90-43, </type> <institution> Univ. of Massachusetts, </institution> <month> May </month> <year> 1990. </year>
Reference: [8] <author> J. Huang, J.A. Stankovic, K. Ramamritham, D. Towsley and B. Purimetla. </author> <title> On Using Priority Inheritance in Real-Time Databases, </title> <journal> Real-Time Systems Journal, </journal> <volume> Vol 4, No. 3, </volume> <pages> pp. 243-268, </pages> <year> 1992. </year>
Reference-contexts: Therefore the abortion procedure need not undo any updates and hence the cost of abortion is small. Instead of aborting a transaction to avoid priority inversion, we can resort to priority inheritance <ref> [8, 13] </ref>. In this case, we increase the priority of the resource holding transaction to that of the transaction which is waiting for the resource. This inheritance is done for the duration that the transaction with higher priority waits for the lower priority transaction to release the resource. <p> This dynamic decision could be based on the parameters of the conflicting transactions such as the work left, slack time, work done etc. An algorithm which is based on the amount of work left has been proposed in <ref> [8] </ref> and shown to work better than the others. Our algorithm is based on the amount of work the conflicting transactions have done. <p> The latter is inferred from the the number of locks it holds. Since, we base our algorithm on the number of locks the conflicting transactions hold rather than on the execution time left, this protocol turns out to be slightly different from the one in <ref> [8] </ref>. If we assume that the longer a transaction has been executing the less work it has left, this protocol would be a reasonable approximation to the one in [8]. 13 To be more precise, in the event of conflict over a lock, if the priority of the requesting transaction is <p> transactions hold rather than on the execution time left, this protocol turns out to be slightly different from the one in <ref> [8] </ref>. If we assume that the longer a transaction has been executing the less work it has left, this protocol would be a reasonable approximation to the one in [8]. 13 To be more precise, in the event of conflict over a lock, if the priority of the requesting transaction is less than or equal to the priority of the lock holding transaction, the requesting transaction waits.
Reference: [9] <author> J. Huang and J. Stankovic, </author> <title> Real-time buffer management. </title> <type> COINS TR 90-65, </type> <year> 1990. </year>
Reference-contexts: Work done in the area of real-time buffer management includes [3] and <ref> [9] </ref>. Whereas [9] reports of no significant performance improvements when time-cognizant buffer management 11 policies are used, studies discussed in [3] show that transaction priorities must be considered in buffer management. <p> Work done in the area of real-time buffer management includes [3] and <ref> [9] </ref>. Whereas [9] reports of no significant performance improvements when time-cognizant buffer management 11 policies are used, studies discussed in [3] show that transaction priorities must be considered in buffer management. <p> With regard to the last two items, in some sense, the conclusions are not startling. Similar observations have been made in earlier simulation-based studies (see [1, 10, 14, 15], for example) or the rarer implementation-based study <ref> [9] </ref>. Thus, in terms of performance, the actual performance trends in our results were similar to those in the literature, even though if one were to run our transactions in simulation mode the overheads assumed may affect the actual performance figures.
Reference: [10] <author> J. Haritsa, M. Carey, M. Livny. </author> <title> Data access Scheduling in Firm Real-Time Database Systems, </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 4, </volume> <pages> pp. 203-241, </pages> <year> 1992. </year>
Reference-contexts: With regard to the last two items, in some sense, the conclusions are not startling. Similar observations have been made in earlier simulation-based studies (see <ref> [1, 10, 14, 15] </ref>, for example) or the rarer implementation-based study [9].
Reference: [11] <author> P. O'Neil, K. Ramamritham, and C. Pu, </author> <title> A Two-Phase Approach to Predictably Scheduling Real-Time Transactions, in Performance of Concurrency Control Mechanisms in centralized Database Systems, </title> <editor> V. Kumar, Ed. </editor> <publisher> Prentice-Hall, </publisher> <pages> pp. 494-522, </pages> <year> 1995. </year>
Reference-contexts: Between these two extremes when one needs to judiciously decide which transaction to abort. A decision based on which transaction has done more work, such as with LC, has good payoffs. 9 Two Phase Transaction Execution We have also implemented a two-phased approach to transaction execution <ref> [11, 5] </ref>. The motivation for this approach is to decrease the effect of lock conflicts when combined with I/O delays. Specifically, because of the delay involved in bringing the data into the buffer, a transaction holds its locks for a longer duration, resulting in increased conflicts. <p> Specifically, because of the delay involved in bringing the data into the buffer, a transaction holds its locks for a longer duration, resulting in increased conflicts. We briefly describe the implemented scheme here. Note that this is a much simplified version of the protocol detailed in <ref> [11] </ref>. In the first phase, the transaction is run once bringing the data into main memory if it is not already present. No writes are performed in this phase and no locks are held, i.e., conflicts with other transactions are ignored.
Reference: [12] <author> K. Ramamritham, </author> <title> Real-time databases, </title> <booktitle> Distributed and Parallel Databases, </booktitle> <volume> Vol 1, </volume> <pages> pp. 199-226, </pages> <year> 1993. </year>
Reference: [13] <author> L. Sha, R. Rajkumar and J. Lehoczsky. </author> <title> Priority inheritance protocols: an approach to real-time synchronization, </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39, </volume> <pages> pp. 1175 - 1185, </pages> <year> 1990. </year>
Reference-contexts: Therefore the abortion procedure need not undo any updates and hence the cost of abortion is small. Instead of aborting a transaction to avoid priority inversion, we can resort to priority inheritance <ref> [8, 13] </ref>. In this case, we increase the priority of the resource holding transaction to that of the transaction which is waiting for the resource. This inheritance is done for the duration that the transaction with higher priority waits for the lower priority transaction to release the resource. <p> the data item D if no conflict with T H then T R accesses D else if priority (T R ) priority (T H ) then T R waits else abort-or-inherit end if Each protocol is derived by refining the statement abort-or-inherit. 7.1.1 Priority Inheritance Protocol (LI) In this protocol <ref> [13] </ref>, whenever a transaction conflicts with another transaction over a data item, that is, when a transaction requests a lock which another transaction is holding, the lock is not immediately granted to the requesting transaction.
Reference: [14] <author> S. .H. Son, Y. Lin, and R. P. Cook, </author> <title> Concurrency Control in Real-Time Database Systems, in Foundations of Real-Time Computing: Scheduling and Resource Management, </title> <editor> edited by Andre van Tilborg and Gary Koob, </editor> <publisher> Kluwer Academic Publishers, </publisher> <pages> pp. 185-202, </pages> <year> 1991. </year>
Reference-contexts: With regard to the last two items, in some sense, the conclusions are not startling. Similar observations have been made in earlier simulation-based studies (see <ref> [1, 10, 14, 15] </ref>, for example) or the rarer implementation-based study [9].
Reference: [15] <author> O. Ulusoy and G.G. Belford, </author> <title> Real-Time Transaction Scheduling in Database Systems, </title> <journal> Information Systems, </journal> <volume> Vol 18, No. 8, </volume> <pages> pp. 559-580, </pages> <year> 1993. </year> <month> 24 </month>
Reference-contexts: With regard to the last two items, in some sense, the conclusions are not startling. Similar observations have been made in earlier simulation-based studies (see <ref> [1, 10, 14, 15] </ref>, for example) or the rarer implementation-based study [9].
References-found: 15

