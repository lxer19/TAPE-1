URL: http://www.cs.washington.edu/homes/amir/phd/icse99.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/amir/CodeWeb/
Root-URL: http://www.cs.washington.edu
Email: famir,notking@cs.washington.edu  
Title: Assessing Software Libraries by Browsing Similar Classes, Functions and Relationships  
Author: Amir Michail and David Notkin 
Keyword: Software libraries, reuse, assessment, information retrieval.  
Web: http://www.cs.washington.edu/homes/amir/CodeWeb  
Address: Box 352350 Seattle, WA 98195-2350, USA  
Affiliation: Dept. of Computer Science and Engineering University of Washington,  
Abstract: Comparing and contrasting a set of software libraries is useful for reuse related activities such as selecting a library from among several candidates or porting an application from one library to another. The current state of the art in assessing libraries relies on qualitative methods. To reduce costs and/or assess a large collection of libraries, automation is necessary. Although there are tools that help a developer examine an individual library in terms of architecture, style, etc., we know of no tools that help the developer directly compare several libraries. With existing tools, the user must manually integrate the knowledge learned about each library. Automation to help developers directly compare and contrast libraries requires matching of similar components (such as classes and functions) across libraries. This is different than the traditional component retrieval problem in which components are returned that best match a user's query. Rather, we need to find those components that are similar across the libraries under consideration. In this paper, we show how this kind of matching can be done. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. J. Biggerstaff. </author> <title> Design recovery for maintenance and reuse. </title> <journal> Computer, </journal> <volume> 22(7) </volume> <pages> 36-49, </pages> <year> 1989. </year>
Reference-contexts: To reduce costs and/or assess a large collection of libraries, automation is necessary. Although there are tools that help a developer examine an individual library in terms of architecture, style, etc. <ref> [1, 9, 17] </ref>, we know of no tools that help the developer directly compare several libraries. With existing tools, the user must manually integrate the knowledge learned about each library.
Reference: [2] <author> W. B. Croft and D. J. Harper. </author> <title> Using probabilistic models of document retrieval without relevance information. </title> <journal> Documentation, </journal> <volume> 35(4) </volume> <pages> 285-295, </pages> <year> 1979. </year>
Reference-contexts: Let N denote the total number of components in the library, and let df (t) denote the number of components containing term t. We use the following definition for idf (t), which is decreasing in df (t), as proposed in <ref> [2] </ref>: idf (t) = log 2 N 1 : Within-Document Weight The within-document weight wdw i (t) indicates how important term t is in a particular component.
Reference: [3] <author> W. B. Frakes and R. S. Baeza-Yates, </author> <title> editors. Information Retrieval: Data Structures and Algorithms. </title> <publisher> Pren-tice Hall, </publisher> <year> 1992. </year>
Reference-contexts: A third approach is to use free-text indexing [4], which uses the text in the libraries (and not just the component names) for indexing using standard information retrieval techniques <ref> [3] </ref>. No manual domain analysis is required, nor must the libraries be annotated with additional information. Researchers have observed that this method works well with libraries that include extensive documentation, such as Unix man pages [5, 10]. <p> We define a similarity measure that indicates how closely two components are related. The ideas in this section borrow heavily from the field of information retrieval <ref> [3] </ref>, where similarity measures are used to rank documents returned by a query in order of relevance. In our case, there is no query per se, but we view components as documents D i and compute the similarity between components in one library with components in another.
Reference: [4] <author> W. B. Frakes and B. A. Nejmeh. </author> <title> Software reuse through information retrieval. </title> <booktitle> In 20th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 530-535. </pages> <publisher> IEEE, </publisher> <year> 1987. </year>
Reference-contexts: Specifically, we present two matching techniques: name matching and similarity matching. The name matching method matches those components that have the same standardized name in each library. The similarity matching method uses more conventional information retrieval techniques similar those used in component retrieval tools based on free-text indexing <ref> [4, 7, 10] </ref>. In this paper we shall be concerned with components that are classes or functions. We use the term library to mean any collection of reusable components such as a toolkit or framework. <p> Another approach is to exploit formal specifications associated with the code to identify similar behaviors [12]; since most libraries do not have formal specifications associated with them, the approach is either limited or costly. A third approach is to use free-text indexing <ref> [4] </ref>, which uses the text in the libraries (and not just the component names) for indexing using standard information retrieval techniques [3]. No manual domain analysis is required, nor must the libraries be annotated with additional information.
Reference: [5] <author> W. B. Frakes and T. </author> <title> Pole. An empirical study of representation methods for reusable software components. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(8) </volume> <pages> 617-630, </pages> <year> 1994. </year>
Reference-contexts: No manual domain analysis is required, nor must the libraries be annotated with additional information. Researchers have observed that this method works well with libraries that include extensive documentation, such as Unix man pages <ref> [5, 10] </ref>. Then one can rely on regularities in the text such as relative word frequencies or lexical affinities [10]. It has also been suggested that one could combine library documentation with structural information (such as inheritance relationships) that can be extracted from the source [7].
Reference: [6] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: By looking at the type of the first parameter, we can infer membership relationships between functions and the structures that they operate upon. Inheritance and Composition The two most common techniques for reuse in object-oriented libraries are class inheritance and composition <ref> [6, p. 18] </ref>. We view both inheritance and composition as forms of a single reuse relationship. When using inheritance, a class A inherits from some class B. When using composition, a class A has B as one of its member variables. However, not all member variables indicate composition.
Reference: [7] <author> R. Helm and Y. S. Maarek. </author> <title> Integrating information retrieval and domain specific approaches for browsing and retrieval in object-oriented class libraries. </title> <booktitle> In OOP-SLA, </booktitle> <pages> pages 47-61, </pages> <year> 1991. </year>
Reference-contexts: Specifically, we present two matching techniques: name matching and similarity matching. The name matching method matches those components that have the same standardized name in each library. The similarity matching method uses more conventional information retrieval techniques similar those used in component retrieval tools based on free-text indexing <ref> [4, 7, 10] </ref>. In this paper we shall be concerned with components that are classes or functions. We use the term library to mean any collection of reusable components such as a toolkit or framework. <p> Then one can rely on regularities in the text such as relative word frequencies or lexical affinities [10]. It has also been suggested that one could combine library documentation with structural information (such as inheritance relationships) that can be extracted from the source <ref> [7] </ref>. Unfortunately, not all libraries and components are well-documented. Consequently, we have pursued an alternative approach where we define a similarity measure that makes heavy use of structural information.
Reference: [8] <author> R. Kazman, L. Bass, G. Abowd, and M. Webb. SAAM: </author> <title> A method for analyzing the properties of software architectures. </title> <booktitle> In 16th International Conference on Software Engineering, </booktitle> <pages> pages 81-90. </pages> <publisher> IEEE, </publisher> <year> 1994. </year>
Reference-contexts: The current state of the art in selecting among library candidates relies on qualitative assessment. This may take the form of informal tips for selecting frameworks [15] or a complete analysis method, such as SAAM <ref> [8] </ref>. Either way, the developer manually inspects each library, reads the documentation, examines the architecture, and considers subjective scenarios and other available information. To reduce costs and/or assess a large collection of libraries, automation is necessary.
Reference: [9] <author> R. Kazman and S. J. Carriere. </author> <title> View extraction and view fusion in architectural understanding. </title> <booktitle> In 5th International Conference on Software Reuse. IEEE, </booktitle> <year> 1998. </year>
Reference-contexts: To reduce costs and/or assess a large collection of libraries, automation is necessary. Although there are tools that help a developer examine an individual library in terms of architecture, style, etc. <ref> [1, 9, 17] </ref>, we know of no tools that help the developer directly compare several libraries. With existing tools, the user must manually integrate the knowledge learned about each library.
Reference: [10] <author> Y. S. Maarek, D. M. Berry, and G. E. Kaiser. </author> <title> An information retrieval approach for automatically constructing software libraries. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(8) </volume> <pages> 800-813, </pages> <year> 1991. </year>
Reference-contexts: Specifically, we present two matching techniques: name matching and similarity matching. The name matching method matches those components that have the same standardized name in each library. The similarity matching method uses more conventional information retrieval techniques similar those used in component retrieval tools based on free-text indexing <ref> [4, 7, 10] </ref>. In this paper we shall be concerned with components that are classes or functions. We use the term library to mean any collection of reusable components such as a toolkit or framework. <p> No manual domain analysis is required, nor must the libraries be annotated with additional information. Researchers have observed that this method works well with libraries that include extensive documentation, such as Unix man pages <ref> [5, 10] </ref>. Then one can rely on regularities in the text such as relative word frequencies or lexical affinities [10]. It has also been suggested that one could combine library documentation with structural information (such as inheritance relationships) that can be extracted from the source [7]. <p> Researchers have observed that this method works well with libraries that include extensive documentation, such as Unix man pages [5, 10]. Then one can rely on regularities in the text such as relative word frequencies or lexical affinities <ref> [10] </ref>. It has also been suggested that one could combine library documentation with structural information (such as inheritance relationships) that can be extracted from the source [7]. Unfortunately, not all libraries and components are well-documented.
Reference: [11] <author> A. Michail and D. Notkin. </author> <title> Illustrating object-oriented library reuse by example: A tool-based approach. </title> <booktitle> In 13th IEEE International Conference on Automated Software Engineering, </booktitle> <year> 1998. </year>
Reference-contexts: For example, we elsewhere described a way to help developers reuse a particular software library by matching components in the library with components in user-selected example applications, where a match occurs between two components if and only if one directly reuses the other <ref> [11] </ref>. It would be of interest to consider other ways to match components across different software systems for reuse related activities. ACKNOWLEDGMENTS We would like to thank Will Tracz and Michael Ernst for valuable feedback on this research.
Reference: [12] <author> A. Moormann-Zaremski and J. M. Wing. </author> <title> Specification matching of software components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 6(4) </volume> <pages> 333-369, </pages> <year> 1997. </year>
Reference-contexts: Another approach is to exploit formal specifications associated with the code to identify similar behaviors <ref> [12] </ref>; since most libraries do not have formal specifications associated with them, the approach is either limited or costly. A third approach is to use free-text indexing [4], which uses the text in the libraries (and not just the component names) for indexing using standard information retrieval techniques [3].
Reference: [13] <author> R. Prieto-Diaz and P. Freeman. </author> <title> Classifying software for reusability. </title> <journal> IEEE Software, </journal> <volume> 4(1) </volume> <pages> 6-16, </pages> <year> 1987. </year>
Reference-contexts: We describe our heuristics for name matching in Section 4. But name matching alone is not enough. It is still possible that some important concept is represented by components with completely different names in the libraries. One approach to identifying such concepts would be to exploit facet information <ref> [13] </ref>; however, facets are defined and associated with components manually, which is too costly for applying to broad collections and/or large sets of libraries.
Reference: [14] <author> G. Salton and C. S. Yang. </author> <title> On the specification of term values in automatic indexing. </title> <journal> Documentation, </journal> <volume> 29(4) </volume> <pages> 351-372, </pages> <year> 1973. </year>
Reference-contexts: It is standard practice to define each weight as the product of the inverse document frequency and the within-document frequency <ref> [14] </ref>. However, as mentioned earlier, we cannot rely on term frequencies since the documents in our case are short. For this reason, we do not use the within-document frequency. Instead, we rely on structural information which is supplied as the within-document weight.
Reference: [15] <author> S. Sparks, K. Benner, and C. Faris. </author> <title> Managing object-oriented framework reuse. </title> <journal> Computer, </journal> <volume> 29(9) </volume> <pages> 52-61, </pages> <year> 1996. </year>
Reference-contexts: Library selection in particular is difficult and can be very expensive. Indeed, Sparks, Benner and Faris give this advice for framework selection: Budget adequately to support frameworks. Expect the evaluation and selection of a framework to take up to six staff-months per new framework <ref> [15, p. 54] </ref>. The current state of the art in selecting among library candidates relies on qualitative assessment. This may take the form of informal tips for selecting frameworks [15] or a complete analysis method, such as SAAM [8]. <p> Expect the evaluation and selection of a framework to take up to six staff-months per new framework [15, p. 54]. The current state of the art in selecting among library candidates relies on qualitative assessment. This may take the form of informal tips for selecting frameworks <ref> [15] </ref> or a complete analysis method, such as SAAM [8]. Either way, the developer manually inspects each library, reads the documentation, examines the architecture, and considers subjective scenarios and other available information. To reduce costs and/or assess a large collection of libraries, automation is necessary.
Reference: [16] <editor> C. J. van Rijsbergen. </editor> <booktitle> Information Retrieval. </booktitle> <address> Butter-worths, </address> <year> 1979. </year>
Reference-contexts: For convenience, we define w i (t) = 0 if t 62 T i . Given two components D i and D j in different libraries, we define the similarity between them, S i;j , as the dot product of the weights <ref> [16] </ref>: S i;j = t (We do not use a normalized similarity function, such as the cosine coefficient where the expression above is divided by p P i (t) t w 2 j (t) [16], because the components usu ally don't have enough terms associated with them for this to yield <p> we define the similarity between them, S i;j , as the dot product of the weights <ref> [16] </ref>: S i;j = t (We do not use a normalized similarity function, such as the cosine coefficient where the expression above is divided by p P i (t) t w 2 j (t) [16], because the components usu ally don't have enough terms associated with them for this to yield better results.) The remainder of this section shows how to extract terms and determine the associated weights for each component in a library. This is done independently of any other libraries.
Reference: [17] <author> A. S. Yeh, D. R. Harris, and M. P. Chase. </author> <title> Manipulating recovered software architecture views. </title> <booktitle> In Proceedings of the International Conference on Software Engineering, </booktitle> <pages> pages 184-194, </pages> <year> 1997. </year>
Reference-contexts: To reduce costs and/or assess a large collection of libraries, automation is necessary. Although there are tools that help a developer examine an individual library in terms of architecture, style, etc. <ref> [1, 9, 17] </ref>, we know of no tools that help the developer directly compare several libraries. With existing tools, the user must manually integrate the knowledge learned about each library.
References-found: 17

