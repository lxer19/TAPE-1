URL: ftp://ftp.cse.cuhk.edu.hk/pub/techreports/94/tr-94-16.ps.gz
Refering-URL: ftp://ftp.cs.cuhk.hk/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fjlee,twleeg@cs.cuhk.hk  
Title: A WAM-based Abstract Machine for Interval Constraint Logic Programming  
Author: J.H.M. Lee and T.W. Lee 
Address: Hong Kong, Shatin  
Affiliation: Department of Computer Science The Chinese University of Hong Kong  
Abstract: In this paper, we propose an integration of constraint interval arithmetic into logic programming at the machine architectural level, of which WAM is the de facto standard. The language in consideration is ICL, a subset of ICHIP which shares the same semantic properties as CHIP. We use the work of Diaz and Codognet as a starting point, and exploit the simplicity of interval constraint solving over finite domain constraint solving. The resulting extension of WAM is simple, efficient, robust, and portable. Our ICL prototype compares favourably against BNR Prolog, CLP(BNR), Echidna, and CLP(R) in various types of numerical examples. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aggoun and N. Beldiceanu. </author> <title> Time stamps techniques for the trailed data in CLP systems. </title> <booktitle> In Actes du Seminaire 1990 Programmation en Logique, </booktitle> <year> 1990. </year>
Reference-contexts: In clp (FD), there is one more type of object in the trail: (n + 2)-word entry for trailing n previous values [6]. As the interval of an i-variable is gradually shrunk, the WAM criterion for trailing introduces the multiple-trailing problem. Clp (FD) uses a time stamp method <ref> [1] </ref> to solve the problem. We co-develop and adopt the trailing scheme in [18]. 3.2 Data structures for constraints In clp (FD), an argument frame is created to represent the environment in which the constraint is called. It is used to achieve optimization 1 in [6].
Reference: [2] <author> A. Aggoun and N. Beldiceanu. </author> <title> Overview of the CHIP compiler system. </title> <booktitle> In Proceedings of the Eight International Conference on Logic Programming, </booktitle> <year> 1991. </year>
Reference-contexts: Warren's Abstract Machine (WAM for short) [21], which has been a de facto standard of Prolog implementation, is chosen as our base architecture. Different approaches are proposed to extend the WAM architecture to handle constraints efficiently for such languages as CLP (R) [10], CHIP <ref> [2] </ref>, and clp (FD) [6]. The design of these abstract machines is strongly influenced by the computation domains and the constraint solving techniques adopted. We consider the Interval Constraint Language (ICL for short), a subset of ICHIP [12]. <p> Lee and van Emden [12] show that the interval narrowing operation is a form of LAIR [19], and that the relaxation algorithm is equivalent to the Lookahead Efficient Computation rule [19]. This semantic resemblance suggests using either the work of Aggoun and Beldiceanu <ref> [2] </ref> or Diaz and Codognet [6] as a starting point in our project. We adopt the latter. Our design exploits the simplicity of the interval domain structure, the need to handle only LAIR (interval narrowing), and the embedding of the computation rule in the relaxation algorithm.
Reference: [3] <editor> F. Benhamou and W.J. Older. </editor> <title> Applying interval arithmetic to real, integer and boolean constraints. </title> <note> (to appear) Journal of Logic Programming, </note> <year> 1994. </year>
Reference-contexts: 1 Introduction Arithmetic facilities in Prolog, which are unsound and functional in nature, have much to be desired. Cleary [5] realizes the shortcomings and proposes a relational version of interval arithmetic for Prolog. Loosely based on Cleary's ideas, several constraint logic programming languages <ref> [15, 3, 17, 13, 11, 12] </ref>, such as BNR Prolog and Echidna, have emerged and have demonstrated their applicabilities in areas such as critical path scheduling [15], X-ray diffraction crystallography [15], boolean constraint solving [3], disjunctive constraint solving [3, 17], and finite domain constraint solving [3]. <p> Loosely based on Cleary's ideas, several constraint logic programming languages [15, 3, 17, 13, 11, 12], such as BNR Prolog and Echidna, have emerged and have demonstrated their applicabilities in areas such as critical path scheduling [15], X-ray diffraction crystallography [15], boolean constraint solving <ref> [3] </ref>, disjunctive constraint solving [3, 17], and finite domain constraint solving [3]. The implementation of these languages either employs meta-programming techniques [16, 13, 11] or consists of an independent constraint solver built as a module separate from the Prolog engine [17, 3]. <p> Loosely based on Cleary's ideas, several constraint logic programming languages [15, 3, 17, 13, 11, 12], such as BNR Prolog and Echidna, have emerged and have demonstrated their applicabilities in areas such as critical path scheduling [15], X-ray diffraction crystallography [15], boolean constraint solving [3], disjunctive constraint solving <ref> [3, 17] </ref>, and finite domain constraint solving [3]. The implementation of these languages either employs meta-programming techniques [16, 13, 11] or consists of an independent constraint solver built as a module separate from the Prolog engine [17, 3]. <p> several constraint logic programming languages [15, 3, 17, 13, 11, 12], such as BNR Prolog and Echidna, have emerged and have demonstrated their applicabilities in areas such as critical path scheduling [15], X-ray diffraction crystallography [15], boolean constraint solving <ref> [3] </ref>, disjunctive constraint solving [3, 17], and finite domain constraint solving [3]. The implementation of these languages either employs meta-programming techniques [16, 13, 11] or consists of an independent constraint solver built as a module separate from the Prolog engine [17, 3]. Meta-programming techniques consist of building a constraint solver as a module on top of Prolog. <p> The implementation of these languages either employs meta-programming techniques [16, 13, 11] or consists of an independent constraint solver built as a module separate from the Prolog engine <ref> [17, 3] </ref>. Meta-programming techniques consist of building a constraint solver as a module on top of Prolog. This approach is good for fast prototyping but lacks the efficiency required for real applications. The independent solver approach provides a clean interface between the Prolog kernel and the constraint solver.
Reference: [4] <author> C.K. Chiu and J.H.M. Lee. </author> <title> Towards practical interval constraint solving in logic programming. </title> <booktitle> In Logic Programming: Proceedings of the 1994 International Symposium, </booktitle> <year> 1994. </year>
Reference-contexts: Second, a prototype implementation of ICL is built and benchmarking results show its numerical processing ability. There are a few directions for future work. First, the benchmarking results show that interval narrowing is inefficient in solving linear constraints. This suggests the integration of an efficient linear interval constraint solver <ref> [4] </ref>. Second, an ICL derivation can end with floundered constraints. Consistency checking techniques are topics of further studies. Third, implementation results show that clp (FD) is more than twice as fast as the commercial version of CHIP on average [6].
Reference: [5] <author> J.G. Cleary. </author> <title> Logical arithmetic. </title> <journal> Future Computing Systems, </journal> <volume> 2(2) </volume> <pages> 125-149, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Arithmetic facilities in Prolog, which are unsound and functional in nature, have much to be desired. Cleary <ref> [5] </ref> realizes the shortcomings and proposes a relational version of interval arithmetic for Prolog. <p> This interpretation is also adopted for answer constraints in CLP languages [9]. Sometimes, constraint interval arithmetic is too weak to narrow intervals to our desirable width. For example, this behaviour occurs if we use ICL to solve the roots of general polynomials and simultaneous equations <ref> [5] </ref>. ICL provides two built-in predicates split/1 and split/2 to narrow interval domain to the smallest width allowed by the (preset) precision of the underlying floating-point system. The two predicates are based on domain splitting , a case analysis technique.
Reference: [6] <author> D. Diaz and P. Codognet. </author> <title> A minimal extension of the WAM for clp(FD). </title> <booktitle> In Proceedings of the Tenth International Conference on Logic Programming, </booktitle> <pages> pages 774-790, </pages> <year> 1993. </year>
Reference-contexts: Warren's Abstract Machine (WAM for short) [21], which has been a de facto standard of Prolog implementation, is chosen as our base architecture. Different approaches are proposed to extend the WAM architecture to handle constraints efficiently for such languages as CLP (R) [10], CHIP [2], and clp (FD) <ref> [6] </ref>. The design of these abstract machines is strongly influenced by the computation domains and the constraint solving techniques adopted. We consider the Interval Constraint Language (ICL for short), a subset of ICHIP [12]. <p> Lee and van Emden [12] show that the interval narrowing operation is a form of LAIR [19], and that the relaxation algorithm is equivalent to the Lookahead Efficient Computation rule [19]. This semantic resemblance suggests using either the work of Aggoun and Beldiceanu [2] or Diaz and Codognet <ref> [6] </ref> as a starting point in our project. We adopt the latter. Our design exploits the simplicity of the interval domain structure, the need to handle only LAIR (interval narrowing), and the embedding of the computation rule in the relaxation algorithm. The rest of the paper is organized as follows. <p> Our machine architecture is similar to that of CHIP and clp (FD). We deviate from Diaz and Codognet <ref> [6] </ref> in the way that we encode constraints and handle the multiple-trailing problem. First, the primitive constraints used by Diaz and Codognet are low level. Compositions of these constraints can be used to model more complex constraints than necessary for constraint interval arithmetic. <p> Associated with an i-variable is an i-variable frame which will be described in section 3.2. The introduction of i-variables prompts for modifications of data manipulation, unification, indexing and trailing. Data manipulation As stated in <ref> [6] </ref>, finite domain variables in clp (FD) cannot be duplicated (as is done for terms by structure-copying). <p> The same scheme is applicable to i-variables. Unification Unification is enhanced as described in section 2.2. The modification is similar to that of clp (FD) <ref> [6] </ref>. The change also slightly affects instructions which manipulate constant such as set_constant. Indexing For procedure definitions that contain more than one clause, WAM adopts indexing to optimize clause selection. The first argument of a clause's head is used as the indexing key. <p> In clp (FD), there is one more type of object in the trail: (n + 2)-word entry for trailing n previous values <ref> [6] </ref>. As the interval of an i-variable is gradually shrunk, the WAM criterion for trailing introduces the multiple-trailing problem. Clp (FD) uses a time stamp method [1] to solve the problem. <p> We co-develop and adopt the trailing scheme in [18]. 3.2 Data structures for constraints In clp (FD), an argument frame is created to represent the environment in which the constraint is called. It is used to achieve optimization 1 in <ref> [6] </ref>. In ICL, there is no similar data structures. On the other hand, ICL has its own active list (to be described below). <p> Second, an ICL derivation can end with floundered constraints. Consistency checking techniques are topics of further studies. Third, implementation results show that clp (FD) is more than twice as fast as the commercial version of CHIP on average <ref> [6] </ref>. It is interesting to check if the use of primitive constraint X in r can improve the performance of ICL. Acknowledgement We are indebted to Chong Kan Chiu, Maarten van Emden, and Bo Ming Tong for numerous discussions and critical comments.
Reference: [7] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier. </author> <title> The constraint logic programming language CHIP. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems (FGCS'88), </booktitle> <pages> pages 693-702, </pages> <address> Tokyo, Japan, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: In section 3, we describe the ex-tension to the WAM architecture and the enhanced instruction set. In section 4, we discuss the ICL prototype implementation and benchmarking results. We summarize our contributions and discuss future perspectives in section 5. 2 The ICL language ICHIP [12] extends CHIP <ref> [7] </ref> with constraint interval arithmetic by allowing domain [19] to be, besides finite set of values, interval of real numbers. ICHIP provides relational arithmetic on integers (by finite domain), rational and real numbers (by interval domain).
Reference: [8] <author> H. Hong. </author> <title> Non-linear real constraints in constraint logic programming. </title> <booktitle> In Proceedings of the Second International Conference on Algebraic and Logic Programming, </booktitle> <pages> pages 201-212, </pages> <year> 1992. </year>
Reference-contexts: CLP (BNR) returns "yes" while Echidna returns "yes" with default precision and exits abruptly with high precision. CLP (R) can detect the inconsistency. 4.3 Wilkinson polynomial The Wilkinson polynomial equation <ref> [8] </ref> is stated as follows: 20 Y (X + i) + EX 19 = 0 (1) The problem is to find the real roots of equation (1). Consider the case where X 2 [20; 10].
Reference: [9] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the 14th ACM POPL Conference, </booktitle> <pages> pages 111-119, </pages> <address> Munich, </address> <month> Jan-uary </month> <year> 1987. </year>
Reference-contexts: This interpretation is also adopted for answer constraints in CLP languages <ref> [9] </ref>. Sometimes, constraint interval arithmetic is too weak to narrow intervals to our desirable width. For example, this behaviour occurs if we use ICL to solve the roots of general polynomials and simultaneous equations [5].
Reference: [10] <author> J. Jaffar, S. Michaylov, P.J. Stuckey, and R.H.C. Yap. </author> <title> An abstract machine for CLP(R). </title> <booktitle> In Proceedings of the ACM SIGPLAN U92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 128-139, </pages> <address> San Francisco, 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Warren's Abstract Machine (WAM for short) [21], which has been a de facto standard of Prolog implementation, is chosen as our base architecture. Different approaches are proposed to extend the WAM architecture to handle constraints efficiently for such languages as CLP (R) <ref> [10] </ref>, CHIP [2], and clp (FD) [6]. The design of these abstract machines is strongly influenced by the computation domains and the constraint solving techniques adopted. We consider the Interval Constraint Language (ICL for short), a subset of ICHIP [12]. <p> CLP (R) can detect the inconsistency. 4.3 Wilkinson polynomial The Wilkinson polynomial equation [8] is stated as follows: 20 Y (X + i) + EX 19 = 0 (1) The problem is to find the real roots of equation (1). Consider the case where X 2 <ref> [20; 10] </ref>. When E = 0, ICL computes the roots which are 20; 19; : : : ; 11; 10. The roots can also be computed using simple numerical analysis technique. When E 6= 0, the roots are perturbed. <p> The roots can also be computed using simple numerical analysis technique. When E 6= 0, the roots are perturbed. Even if E is as small as 2 23 , the perturbation is already so big that all roots in X 2 <ref> [20; 10] </ref> disappear. This effect is demonstrated in figure 5, which consists of the curves Y = Q 20 Y = EX 19 . ICL returns no answer as expected. CLP (BNR) and BNR Prolog produce the same response. Echidna does not terminate in 15 minutes.
Reference: [11] <author> J.H.M. Lee and M.H. van Emden. </author> <title> Adapting CLP(R) to floating-point arithmetic. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 996-1003, </pages> <address> Tokyo, Japan, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Arithmetic facilities in Prolog, which are unsound and functional in nature, have much to be desired. Cleary [5] realizes the shortcomings and proposes a relational version of interval arithmetic for Prolog. Loosely based on Cleary's ideas, several constraint logic programming languages <ref> [15, 3, 17, 13, 11, 12] </ref>, such as BNR Prolog and Echidna, have emerged and have demonstrated their applicabilities in areas such as critical path scheduling [15], X-ray diffraction crystallography [15], boolean constraint solving [3], disjunctive constraint solving [3, 17], and finite domain constraint solving [3]. <p> The implementation of these languages either employs meta-programming techniques <ref> [16, 13, 11] </ref> or consists of an independent constraint solver built as a module separate from the Prolog engine [17, 3]. Meta-programming techniques consist of building a constraint solver as a module on top of Prolog. <p> The design of these abstract machines is strongly influenced by the computation domains and the constraint solving techniques adopted. We consider the Interval Constraint Language (ICL for short), a subset of ICHIP [12]. ICL is based on constraint interval arithmetic <ref> [11, 12] </ref>, a generalization of Cleary's framework which consists of an interval narrowing operation and a relaxation algorithm. Lee and van Emden [12] show that the interval narrowing operation is a form of LAIR [19], and that the relaxation algorithm is equivalent to the Lookahead Efficient Computation rule [19]. <p> We call the usual variables of first-order logic Herbrand variables, abbreviated as h-variables. ICL provides a set of primitive constraints on real numbers, namely add/3, multplus/3, multminus/3, lt/2, le/2, sqrplus/2 and sqrminus/2 as described in [12]. Other constraints that satisfy the interval integrity 1 criterion <ref> [11, 12] </ref> can be added to this set as appropriate. The predicate names of the constraints are self-explanatory. An atom is any standard atomic formula whose predicate symbol is different from those of the primitive constraints, and can contain both i-variables and h-variables. <p> H is called the head and C 1 ; : : : ; C m ; B 1 ; : : : ; B n is the body 1 No name was given to this criterion in <ref> [11, 12] </ref>. An explanation of the criterion requires a full exposition of interval narrowing, which is outside the scope of this paper.
Reference: [12] <author> J.H.M. Lee and M.H. van Emden. </author> <title> Interval computation as deduction in CHIP. </title> <journal> Journal of Logic Programming, </journal> <volume> 16(3 </volume> & 4):255-276, 1993. 
Reference-contexts: 1 Introduction Arithmetic facilities in Prolog, which are unsound and functional in nature, have much to be desired. Cleary [5] realizes the shortcomings and proposes a relational version of interval arithmetic for Prolog. Loosely based on Cleary's ideas, several constraint logic programming languages <ref> [15, 3, 17, 13, 11, 12] </ref>, such as BNR Prolog and Echidna, have emerged and have demonstrated their applicabilities in areas such as critical path scheduling [15], X-ray diffraction crystallography [15], boolean constraint solving [3], disjunctive constraint solving [3, 17], and finite domain constraint solving [3]. <p> The design of these abstract machines is strongly influenced by the computation domains and the constraint solving techniques adopted. We consider the Interval Constraint Language (ICL for short), a subset of ICHIP <ref> [12] </ref>. ICL is based on constraint interval arithmetic [11, 12], a generalization of Cleary's framework which consists of an interval narrowing operation and a relaxation algorithm. Lee and van Emden [12] show that the interval narrowing operation is a form of LAIR [19], and that the relaxation algorithm is equivalent to <p> The design of these abstract machines is strongly influenced by the computation domains and the constraint solving techniques adopted. We consider the Interval Constraint Language (ICL for short), a subset of ICHIP [12]. ICL is based on constraint interval arithmetic <ref> [11, 12] </ref>, a generalization of Cleary's framework which consists of an interval narrowing operation and a relaxation algorithm. Lee and van Emden [12] show that the interval narrowing operation is a form of LAIR [19], and that the relaxation algorithm is equivalent to the Lookahead Efficient Computation rule [19]. <p> We consider the Interval Constraint Language (ICL for short), a subset of ICHIP <ref> [12] </ref>. ICL is based on constraint interval arithmetic [11, 12], a generalization of Cleary's framework which consists of an interval narrowing operation and a relaxation algorithm. Lee and van Emden [12] show that the interval narrowing operation is a form of LAIR [19], and that the relaxation algorithm is equivalent to the Lookahead Efficient Computation rule [19]. <p> In section 3, we describe the ex-tension to the WAM architecture and the enhanced instruction set. In section 4, we discuss the ICL prototype implementation and benchmarking results. We summarize our contributions and discuss future perspectives in section 5. 2 The ICL language ICHIP <ref> [12] </ref> extends CHIP [7] with constraint interval arithmetic by allowing domain [19] to be, besides finite set of values, interval of real numbers. ICHIP provides relational arithmetic on integers (by finite domain), rational and real numbers (by interval domain). <p> We call the usual variables of first-order logic Herbrand variables, abbreviated as h-variables. ICL provides a set of primitive constraints on real numbers, namely add/3, multplus/3, multminus/3, lt/2, le/2, sqrplus/2 and sqrminus/2 as described in <ref> [12] </ref>. Other constraints that satisfy the interval integrity 1 criterion [11, 12] can be added to this set as appropriate. The predicate names of the constraints are self-explanatory. <p> We call the usual variables of first-order logic Herbrand variables, abbreviated as h-variables. ICL provides a set of primitive constraints on real numbers, namely add/3, multplus/3, multminus/3, lt/2, le/2, sqrplus/2 and sqrminus/2 as described in [12]. Other constraints that satisfy the interval integrity 1 criterion <ref> [11, 12] </ref> can be added to this set as appropriate. The predicate names of the constraints are self-explanatory. An atom is any standard atomic formula whose predicate symbol is different from those of the primitive constraints, and can contain both i-variables and h-variables. <p> H is called the head and C 1 ; : : : ; C m ; B 1 ; : : : ; B n is the body 1 No name was given to this criterion in <ref> [11, 12] </ref>. An explanation of the criterion requires a full exposition of interval narrowing, which is outside the scope of this paper. <p> into primitive constraints, possibly introducing a few slack variables. 2. there exists a clause "H:- ~ C 0 ; A 1 ; : : : ; A n :" (n 0) in P such that H is unifiable with B j generat ing substitution i ; 3. the relaxation algorithm <ref> [12] </ref> stabilizes for con straint network ~ C 00 = ( ~ C [ ~ C 0 ) i ; 4.
Reference: [13] <author> O. Lhomme. </author> <title> Consistency techniques for numeric CSPs. </title> <booktitle> In Proceedings of the 13th International Joint Conference on Artificial Intelligence, </booktitle> <year> 1993. </year>
Reference-contexts: 1 Introduction Arithmetic facilities in Prolog, which are unsound and functional in nature, have much to be desired. Cleary [5] realizes the shortcomings and proposes a relational version of interval arithmetic for Prolog. Loosely based on Cleary's ideas, several constraint logic programming languages <ref> [15, 3, 17, 13, 11, 12] </ref>, such as BNR Prolog and Echidna, have emerged and have demonstrated their applicabilities in areas such as critical path scheduling [15], X-ray diffraction crystallography [15], boolean constraint solving [3], disjunctive constraint solving [3, 17], and finite domain constraint solving [3]. <p> The implementation of these languages either employs meta-programming techniques <ref> [16, 13, 11] </ref> or consists of an independent constraint solver built as a module separate from the Prolog engine [17, 3]. Meta-programming techniques consist of building a constraint solver as a module on top of Prolog.
Reference: [14] <author> A.K. Mackworth. </author> <title> Consistency in networks of relations. </title> <journal> AI Journal, </journal> <volume> 8(1) </volume> <pages> 99-118, </pages> <year> 1977. </year>
Reference-contexts: computed answer of a successful derivation is the composition of substitutions = 1 m plus the domain constraints of the form X 2 I for each i-variable X I in N . 2.3 Answer interpretation and splitting The semantics of CHIP, and thus ICL, is based on arc consistency techniques <ref> [14] </ref>. It is well-known that arc consistency techniques are "incomplete" [14]: a network can be stable but neither a solution nor inconsistency is found. Logically, we interpret constraints in the answer network as qualified or conditional answers [20]. <p> substitutions = 1 m plus the domain constraints of the form X 2 I for each i-variable X I in N . 2.3 Answer interpretation and splitting The semantics of CHIP, and thus ICL, is based on arc consistency techniques <ref> [14] </ref>. It is well-known that arc consistency techniques are "incomplete" [14]: a network can be stable but neither a solution nor inconsistency is found. Logically, we interpret constraints in the answer network as qualified or conditional answers [20]. Let P be a logic program with domain variables and G a goal.
Reference: [15] <author> W. Older and A. Vellino. </author> <title> Constraint arithmetic on real intervals. </title> <editor> In A. Colmerauer and F. Ben-hamou, editors, </editor> <booktitle> Constraint Logic Programming: Selected Research. </booktitle> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Arithmetic facilities in Prolog, which are unsound and functional in nature, have much to be desired. Cleary [5] realizes the shortcomings and proposes a relational version of interval arithmetic for Prolog. Loosely based on Cleary's ideas, several constraint logic programming languages <ref> [15, 3, 17, 13, 11, 12] </ref>, such as BNR Prolog and Echidna, have emerged and have demonstrated their applicabilities in areas such as critical path scheduling [15], X-ray diffraction crystallography [15], boolean constraint solving [3], disjunctive constraint solving [3, 17], and finite domain constraint solving [3]. <p> Loosely based on Cleary's ideas, several constraint logic programming languages [15, 3, 17, 13, 11, 12], such as BNR Prolog and Echidna, have emerged and have demonstrated their applicabilities in areas such as critical path scheduling <ref> [15] </ref>, X-ray diffraction crystallography [15], boolean constraint solving [3], disjunctive constraint solving [3, 17], and finite domain constraint solving [3]. The implementation of these languages either employs meta-programming techniques [16, 13, 11] or consists of an independent constraint solver built as a module separate from the Prolog engine [17, 3]. <p> Loosely based on Cleary's ideas, several constraint logic programming languages [15, 3, 17, 13, 11, 12], such as BNR Prolog and Echidna, have emerged and have demonstrated their applicabilities in areas such as critical path scheduling <ref> [15] </ref>, X-ray diffraction crystallography [15], boolean constraint solving [3], disjunctive constraint solving [3, 17], and finite domain constraint solving [3]. The implementation of these languages either employs meta-programming techniques [16, 13, 11] or consists of an independent constraint solver built as a module separate from the Prolog engine [17, 3].
Reference: [16] <author> W.J. </author> <title> Older. Interval arithmetic specification. </title> <type> Research Report 89032, </type> <institution> Computing Research Laboratory, Bell-Northern Research, Ottawa, Ont., Canada, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: The implementation of these languages either employs meta-programming techniques <ref> [16, 13, 11] </ref> or consists of an independent constraint solver built as a module separate from the Prolog engine [17, 3]. Meta-programming techniques consist of building a constraint solver as a module on top of Prolog.
Reference: [17] <author> G. Sidebottom and W.S. Havens. </author> <title> Hierarchical arc consistency for disjoint real intervals in constraint logic programming. </title> <journal> Computational Intelligence, </journal> <volume> 8(4), </volume> <year> 1992. </year>
Reference-contexts: 1 Introduction Arithmetic facilities in Prolog, which are unsound and functional in nature, have much to be desired. Cleary [5] realizes the shortcomings and proposes a relational version of interval arithmetic for Prolog. Loosely based on Cleary's ideas, several constraint logic programming languages <ref> [15, 3, 17, 13, 11, 12] </ref>, such as BNR Prolog and Echidna, have emerged and have demonstrated their applicabilities in areas such as critical path scheduling [15], X-ray diffraction crystallography [15], boolean constraint solving [3], disjunctive constraint solving [3, 17], and finite domain constraint solving [3]. <p> Loosely based on Cleary's ideas, several constraint logic programming languages [15, 3, 17, 13, 11, 12], such as BNR Prolog and Echidna, have emerged and have demonstrated their applicabilities in areas such as critical path scheduling [15], X-ray diffraction crystallography [15], boolean constraint solving [3], disjunctive constraint solving <ref> [3, 17] </ref>, and finite domain constraint solving [3]. The implementation of these languages either employs meta-programming techniques [16, 13, 11] or consists of an independent constraint solver built as a module separate from the Prolog engine [17, 3]. <p> The implementation of these languages either employs meta-programming techniques [16, 13, 11] or consists of an independent constraint solver built as a module separate from the Prolog engine <ref> [17, 3] </ref>. Meta-programming techniques consist of building a constraint solver as a module on top of Prolog. This approach is good for fast prototyping but lacks the efficiency required for real applications. The independent solver approach provides a clean interface between the Prolog kernel and the constraint solver.
Reference: [18] <author> B.M. Tong and H.F. Leung. </author> <title> Implementation of a data-parallel concurrent constraint programming system. </title> <booktitle> In Proceedings of the First International Symposium on Parallel Symbolic Computation (to appear), </booktitle> <year> 1994. </year>
Reference-contexts: As the interval of an i-variable is gradually shrunk, the WAM criterion for trailing introduces the multiple-trailing problem. Clp (FD) uses a time stamp method [1] to solve the problem. We co-develop and adopt the trailing scheme in <ref> [18] </ref>. 3.2 Data structures for constraints In clp (FD), an argument frame is created to represent the environment in which the constraint is called. It is used to achieve optimization 1 in [6]. In ICL, there is no similar data structures.
Reference: [19] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> The MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: ICL is based on constraint interval arithmetic [11, 12], a generalization of Cleary's framework which consists of an interval narrowing operation and a relaxation algorithm. Lee and van Emden [12] show that the interval narrowing operation is a form of LAIR <ref> [19] </ref>, and that the relaxation algorithm is equivalent to the Lookahead Efficient Computation rule [19]. This semantic resemblance suggests using either the work of Aggoun and Beldiceanu [2] or Diaz and Codognet [6] as a starting point in our project. We adopt the latter. <p> Lee and van Emden [12] show that the interval narrowing operation is a form of LAIR <ref> [19] </ref>, and that the relaxation algorithm is equivalent to the Lookahead Efficient Computation rule [19]. This semantic resemblance suggests using either the work of Aggoun and Beldiceanu [2] or Diaz and Codognet [6] as a starting point in our project. We adopt the latter. <p> In section 4, we discuss the ICL prototype implementation and benchmarking results. We summarize our contributions and discuss future perspectives in section 5. 2 The ICL language ICHIP [12] extends CHIP [7] with constraint interval arithmetic by allowing domain <ref> [19] </ref> to be, besides finite set of values, interval of real numbers. ICHIP provides relational arithmetic on integers (by finite domain), rational and real numbers (by interval domain). <p> The "&gt;=" predicate is for the comparison of h-variables and integers. Output from the query "?- mg (99999,10,I^'[0.01,0.05]',B,5000)." is: B 2 (58150.0452133925,99998.3711053734) 2.2 Computation model The introduction of i-variables calls for an enhanced unification algorithm. The extension is similar to that of CHIP <ref> [19] </ref>. We have three cases to consider. (1) Unification for two i-variables X I and Y J succeeds with binding fX I =Z I"J ; Y J =Z I"J g if I " J 6= ;. <p> The clause (G G 1 ; : : :; G n ) is a conditional answer to the original goal. From the soundness of SLDD-resolution and LAIR <ref> [19] </ref>, we have P j= 8 (G G 1 ; : : : ; G n ) where the universal quantification is over all variables that occur in (G G 1 ; : : : ; G n ).
Reference: [20] <author> P. Vasey. </author> <title> Qualified answers and their application to transformation. </title> <booktitle> In Proceedings of the Third International Logic Programming Conference, </booktitle> <pages> pages 425-432, </pages> <year> 1986. </year>
Reference-contexts: It is well-known that arc consistency techniques are "incomplete" [14]: a network can be stable but neither a solution nor inconsistency is found. Logically, we interpret constraints in the answer network as qualified or conditional answers <ref> [20] </ref>. Let P be a logic program with domain variables and G a goal. Suppose, we have derived from G a non-empty goal G 1 ; : : : ; G n , with being the composition of all substitutions so far. <p> CLP (R) can detect the inconsistency. 4.3 Wilkinson polynomial The Wilkinson polynomial equation [8] is stated as follows: 20 Y (X + i) + EX 19 = 0 (1) The problem is to find the real roots of equation (1). Consider the case where X 2 <ref> [20; 10] </ref>. When E = 0, ICL computes the roots which are 20; 19; : : : ; 11; 10. The roots can also be computed using simple numerical analysis technique. When E 6= 0, the roots are perturbed. <p> The roots can also be computed using simple numerical analysis technique. When E 6= 0, the roots are perturbed. Even if E is as small as 2 23 , the perturbation is already so big that all roots in X 2 <ref> [20; 10] </ref> disappear. This effect is demonstrated in figure 5, which consists of the curves Y = Q 20 Y = EX 19 . ICL returns no answer as expected. CLP (BNR) and BNR Prolog produce the same response. Echidna does not terminate in 15 minutes.
Reference: [21] <author> D.H.D. Warren. </author> <title> An abstract Prolog instruction set. </title> <type> Technical Note 309, </type> <institution> SRI International, </institution> <address> Menlo Park, CA, </address> <year> 1983. </year>
Reference-contexts: Communications between the solver and the Prolog engine, however, incur high overhead. Backtracking also becomes a costly operation. Attaining an efficient implementation calls for a tight integration of interval constraint solving and the Prolog engine at the machine architectural level. Warren's Abstract Machine (WAM for short) <ref> [21] </ref>, which has been a de facto standard of Prolog implementation, is chosen as our base architecture. Different approaches are proposed to extend the WAM architecture to handle constraints efficiently for such languages as CLP (R) [10], CHIP [2], and clp (FD) [6].
References-found: 21

