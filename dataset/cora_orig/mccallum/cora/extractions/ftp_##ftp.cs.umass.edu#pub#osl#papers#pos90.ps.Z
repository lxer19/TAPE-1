URL: ftp://ftp.cs.umass.edu/pub/osl/papers/pos90.ps.Z
Refering-URL: http://spa-www.cs.umass.edu/bibliography.html
Root-URL: 
Email: hosking@cs.umass.edu  moss@cs.umass.edu  
Title: Towards Compile-Time Optimisations for Persistence  
Author: Antony L. Hosking J. Eliot B. Moss 
Address: Amherst, MA 01003  
Affiliation: Department of Computer and Information Science University of Massachusetts  
Abstract: We consider how a persistent programming language might offer performance competitive with that of non-persistent languages, at least on memory resident data. We are concerned with object-oriented languages, and with implementing persistence via object faulting, where the system detects uses of non-resident objects and fetches them on demand. We present some background on object faulting and means for implementing it, and describe a specific language we are developing, namely Persistent Modula-3. Then we explore approaches to optimising persistence aspects of Persistent Modula-3, and outline techniques under consideration in our compiler development effort. 
Abstract-found: 1
Intro-found: 1
Reference: [Atkinson and Morrison, 1985] <author> Malcolm P. Atkinson and Ronald Morrison. </author> <title> Procedures as persistent data objects. </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 7, </volume> <month> 4 (Oct. </month> <year> 1985), </year> <pages> 539-559. </pages>
Reference-contexts: 1 Introduction The Object Oriented Systems Group at the University of Massachusetts is engaged in research exploring the integration of programming languages with database technology. As a part of this work, we are involved in the development of persistent programming languages, as popularised by the PS-Algol effort <ref> [Atkinson et al., 1981; Atkinson and Morrison, 1985] </ref>. We approach the problem of language-database integration from the object-oriented standpoint. Our particular approach to persistence is to integrate existing programming languages with our own persistent object store, Mneme [Moss and Sinofsky, 1988; Moss, 1989].
Reference: [Atkinson et al., 1981] <author> M. P. Atkinson, K. J. Chisolm, and W. P. Cockshott. </author> <title> PS-Algol: an Algol with a persistent heap. </title> <journal> ACM SIGPLAN Notices 17, </journal> <month> 7 (July </month> <year> 1981). </year>
Reference-contexts: 1 Introduction The Object Oriented Systems Group at the University of Massachusetts is engaged in research exploring the integration of programming languages with database technology. As a part of this work, we are involved in the development of persistent programming languages, as popularised by the PS-Algol effort <ref> [Atkinson et al., 1981; Atkinson and Morrison, 1985] </ref>. We approach the problem of language-database integration from the object-oriented standpoint. Our particular approach to persistence is to integrate existing programming languages with our own persistent object store, Mneme [Moss and Sinofsky, 1988; Moss, 1989].
Reference: [Cardelli et al., 1989] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <type> Modula-3 report (revised). Tech. Rep. </type> <institution> DEC SRC 52, DEC Systems Research Center/Olivetti Research Center, </institution> <address> Palo Alto/Menlo Park, CA, </address> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: We have chosen two object-oriented languages for integration with Mneme: Smalltalk [Goldberg and Robson, 1983] and Modula-3 <ref> [Cardelli et al., 1989] </ref>. Our reasons for choosing these are as follows. First, they are relatively well-known. Smalltalk was the first object-oriented programming language to gain widespread recognition.
Reference: [Carey et al., 1986] <author> M. J. Carey, D. J. DeWitt, J. E. Richardson, and E. J. Shekita. </author> <title> Object and file management in the EXODUS extensible database system. </title> <booktitle> In Proceedings of the Twelfth International Conference on Very Large Databases (Kyoto, </booktitle> <address> Japan, </address> <month> Sept. </month> <year> 1986), </year> <booktitle> ACM, </booktitle> <pages> pp. 91-100. </pages>
Reference-contexts: Our particular approach to persistence is to integrate existing programming languages with our own persistent object store, Mneme [Moss and Sinofsky, 1988; Moss, 1989]. While there is some difference in functionality between Mneme and other object storage systems such as the Exodus storage manager <ref> [Carey et al., 1986; Carey et al., 1989] </ref> or Observer [Skarra et al., 1987; Hornick and Zdonik, 1987], our integration techniques would extend to them. We have chosen two object-oriented languages for integration with Mneme: Smalltalk [Goldberg and Robson, 1983] and Modula-3 [Cardelli et al., 1989].
Reference: [Carey et al., 1989] <author> Michael J. Carey, David J. DeWitt, Joel E. Richardson, and Eugene J. Shekita. </author> <title> Storage management for objects in EXODUS. In Object-Oriented Concepts, Databases, and Applications, </title> <editor> Won Kim and Lochovsky Frederick H, Eds., </editor> <booktitle> Frontier Series. </booktitle> <publisher> Addison-Wesley, ACM Press, </publisher> <address> New York, NY, </address> <year> 1989, </year> <journal> ch. </journal> <volume> 14, </volume> <pages> pp. 341-369. </pages>
Reference-contexts: Our particular approach to persistence is to integrate existing programming languages with our own persistent object store, Mneme [Moss and Sinofsky, 1988; Moss, 1989]. While there is some difference in functionality between Mneme and other object storage systems such as the Exodus storage manager <ref> [Carey et al., 1986; Carey et al., 1989] </ref> or Observer [Skarra et al., 1987; Hornick and Zdonik, 1987], our integration techniques would extend to them. We have chosen two object-oriented languages for integration with Mneme: Smalltalk [Goldberg and Robson, 1983] and Modula-3 [Cardelli et al., 1989].
Reference: [Chambers and Ungar, 1989] <author> Craig Chambers and David Ungar. </author> <title> Customization: Optimizing compiler technology for SELF, a dynamically-typed object-oriented programming language. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation (Portland, </booktitle> <address> OR, </address> <month> June </month> <year> 1989), </year> <journal> vol. </journal> <volume> 24, no. </volume> <booktitle> 7 of ACM SIGPLAN Notices, ACM, </booktitle> <pages> pp. 146-160. 10 </pages>
Reference-contexts: This technique is known as message splitting and has been applied in other object-oriented languages such as SELF <ref> [Chambers and Ungar, 1989; Chambers and Ungar, 1990] </ref>. If we are prepared to do some inter-procedural analysis, we can use customised compilation to tailor the compilation of a procedure to the characteristics of a particular call site.
Reference: [Chambers and Ungar, 1990] <author> Craig Chambers and David Ungar. </author> <title> Iterative type analysis and extended message split-ting: Optimizing dynamically-typed object-oriented programs. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation (White Plains, </booktitle> <address> NY, </address> <month> June </month> <year> 1990), </year> <journal> vol. </journal> <volume> 25, no. </volume> <booktitle> 6 of ACM SIGPLAN Notices, ACM, </booktitle> <pages> pp. 150-164. </pages>
Reference-contexts: This technique is known as message splitting and has been applied in other object-oriented languages such as SELF <ref> [Chambers and Ungar, 1989; Chambers and Ungar, 1990] </ref>. If we are prepared to do some inter-procedural analysis, we can use customised compilation to tailor the compilation of a procedure to the characteristics of a particular call site.
Reference: [Goldberg and Robson, 1983] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: We have chosen two object-oriented languages for integration with Mneme: Smalltalk <ref> [Goldberg and Robson, 1983] </ref> and Modula-3 [Cardelli et al., 1989]. Our reasons for choosing these are as follows. First, they are relatively well-known. Smalltalk was the first object-oriented programming language to gain widespread recognition.
Reference: [Hornick and Zdonik, 1987] <author> Mark F. Hornick and Stanley B. Zdonik. </author> <title> A shared, segmented memory system for an object-oriented database. </title> <journal> ACM Trans. Office Inf. Syst. </journal> <volume> 5, </volume> <month> 1 (Jan. </month> <year> 1987), </year> <pages> 70-95. </pages>
Reference-contexts: While there is some difference in functionality between Mneme and other object storage systems such as the Exodus storage manager [Carey et al., 1986; Carey et al., 1989] or Observer <ref> [Skarra et al., 1987; Hornick and Zdonik, 1987] </ref>, our integration techniques would extend to them. We have chosen two object-oriented languages for integration with Mneme: Smalltalk [Goldberg and Robson, 1983] and Modula-3 [Cardelli et al., 1989]. Our reasons for choosing these are as follows. First, they are relatively well-known.
Reference: [Hosking et al., 1990] <author> Antony L. Hosking, J. Eliot B. Moss, and Cynthia Bliss. </author> <title> Design of an object faulting persistent Smalltalk. </title> <type> COINS Technical Report 90-45, </type> <institution> Department of Computer and Information Science, University of Massachusetts, </institution> <address> Amherst, MA, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: We can consider all such referenced data items (both persistent and volatile) as a kind of virtual heap. Object faulting does not preload the entire heap; rather, objects are faulted on demand. Our design of Persistent Smalltalk makes object faulting the responsibility of the run-time system <ref> [Hosking et al., 1990] </ref>. All references to non-resident objects are trapped by the Smalltalk virtual machine. Certain heuristics are used to restrict residency checks to just the send bytecodes and some primitives. This approach is purely dynamic in that no changes are made to the Smalltalk compiler or image. <p> For details see <ref> [Hosking et al., 1990] </ref>. 2 Shorthands OBJECT...END and UNTRACED OBJECT...END may be used for the forms ROOT OBJECT...END and UNTRACED ROOT OBJECT...END, object types inheriting from ROOT and UNTRACED ROOT, respectively. 5 NULL &lt;: REF T &lt;: REFANY NULL &lt;: UNTRACED REF T &lt;: ADDRESS NULL &lt;: T OBJECT...END &lt;: T,
Reference: [Jensen and Wirth, 1974] <author> Kathleen Jensen and Niklaus Wirth. </author> <title> Pascal User Manual and Report, second ed. </title> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: Our reasons for choosing these are as follows. First, they are relatively well-known. Smalltalk was the first object-oriented programming language to gain widespread recognition. Modula-3 is less widely known, but its ancestry is quite familiar, as it derives from the class of languages including Pascal <ref> [Jensen and Wirth, 1974] </ref>, Modula-2 [Wirth, 1983], and Oberon [Wirth, 1988a; Wirth, 1988b]. Second, they represent quite different philosophies. In Smalltalk there is no static type checking. In fact, the Smalltalk class hierarchy provides only a very weak notion of type.
Reference: [Moss and Sinofsky, 1988] <author> J. Eliot B. Moss and Steven Sinofsky. </author> <title> Managing persistent data with Mneme: Designing a reliable, shared object interface. </title> <booktitle> In Advances in Object-Oriented Database Systems (Sept. 1988), vol. 334 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 298-316. </pages>
Reference-contexts: We approach the problem of language-database integration from the object-oriented standpoint. Our particular approach to persistence is to integrate existing programming languages with our own persistent object store, Mneme <ref> [Moss and Sinofsky, 1988; Moss, 1989] </ref>.
Reference: [Moss, 1989] <author> J. Eliot B. Moss. </author> <title> The Mneme persistent object store. </title> <type> COINS Technical Report 89-107, </type> <institution> Department of Computer and Information Science, University of Massachusetts, </institution> <address> Amherst, MA, </address> <month> Oct. </month> <year> 1989. </year> <note> Submitted for publication as Design of the Mneme Persistent Object Store. </note>
Reference-contexts: We approach the problem of language-database integration from the object-oriented standpoint. Our particular approach to persistence is to integrate existing programming languages with our own persistent object store, Mneme <ref> [Moss and Sinofsky, 1988; Moss, 1989] </ref>.
Reference: [Richardson and Carey, 1987] <author> Joel E. Richardson and Michael J. Carey. </author> <title> Programming constructs for database system implementations in EXODUS. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data (San Francisco, </booktitle> <address> CA, </address> <month> May </month> <year> 1987), </year> <journal> vol. </journal> <volume> 16, no. </volume> <booktitle> 3 of ACM SIGMOD Record, ACM, </booktitle> <pages> pp. 208-219. </pages>
Reference-contexts: In this section we extend that type system to incorporate persistence by adding a third class of reference types: persistent references, similar to the db types of the E database programming language <ref> [Richardson and Carey, 1987] </ref>. A persistent reference type is indicated by the keyword PERSISTENT, analogous to UNTRACED. A persistent reference indicates a specific object, but that object may or may not be resident in memory.
Reference: [Richardson, 1989] <author> Joel Edward Richardson. E: </author> <title> A Persistent Systems Implementation Language. </title> <type> PhD thesis, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI, </institution> <month> Aug. </month> <year> 1989. </year> <note> Available as Computer Sciences Technical Report #868. </note>
Reference-contexts: Code hoisting can be used to replace two residency checks that occur in different paths of the program by just one. Techniques similar to these were shown to be quite effective in E <ref> [Richardson, 1989] </ref>. Procedure inlining replaces a full call to a procedure with the code that implements that procedure. This allows the called code to be optimised in the context of the call site, integrating its analysis with that of the calling procedure.
Reference: [Schaffert et al., 1986] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (Portland, </booktitle> <address> OR, </address> <month> Sept. </month> <journal> 1986), </journal> <volume> vol. 21, no. </volume> <booktitle> 11 of ACM SIGPLAN Notices, ACM, </booktitle> <pages> pp. 9-16. </pages>
Reference-contexts: The customised compiled procedure can only be used at call sites having appropriate characteristics. Again, this has been used previously in SELF and also in Trellis 4 /Owl <ref> [Schaffert et al., 1986] </ref>. Applying customised compilation to persistence, we can compile customised versions of procedures based on assumptions about the residency of their arguments. A particular customised version can then be used at any call site where its residency requirements are satisfied.
Reference: [Skarra et al., 1987] <author> Andrea Skarra, Stanley B. Zdonik, and Stephen P. Reiss. </author> <title> An object server for an object oriented database system. </title> <booktitle> In Proceedings of International Workshop on Object-Oriented Database Systems (Pacific Grove, </booktitle> <address> CA, </address> <month> Sept. </month> <year> 1987), </year> <booktitle> ACM, </booktitle> <pages> pp. 196-204. </pages>
Reference-contexts: While there is some difference in functionality between Mneme and other object storage systems such as the Exodus storage manager [Carey et al., 1986; Carey et al., 1989] or Observer <ref> [Skarra et al., 1987; Hornick and Zdonik, 1987] </ref>, our integration techniques would extend to them. We have chosen two object-oriented languages for integration with Mneme: Smalltalk [Goldberg and Robson, 1983] and Modula-3 [Cardelli et al., 1989]. Our reasons for choosing these are as follows. First, they are relatively well-known.
Reference: [Ungar, 1984] <author> David Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Pittsburgh, </booktitle> <address> PA, </address> <month> Apr. </month> <year> 1984), </year> <journal> ACM SIGPLAN Notices, ACM, </journal> <pages> pp. 157-167. </pages>
Reference-contexts: Whenever a pointer to an object in the buffer is stored in some memory location, we must check to see if the buffer's remembered set should be updated to reflect the store. Techniques such as this are employed by generation scavenging garbage collectors <ref> [Ungar, 1984] </ref>. Such garbage collectors have been shown to have superior performance for interactive systems such as Smalltalk [Ungar, 1987].
Reference: [Ungar, 1987] <author> David Michael Ungar. </author> <title> The Design and Evaluation of a High Performance Smalltalk System. </title> <publisher> ACM Distinguished Dissertations. The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year> <type> Ph.D. Dissertation, </type> <institution> University of California at Berkeley, </institution> <month> February </month> <year> 1986. </year>
Reference-contexts: Techniques such as this are employed by generation scavenging garbage collectors [Ungar, 1984]. Such garbage collectors have been shown to have superior performance for interactive systems such as Smalltalk <ref> [Ungar, 1987] </ref>. Given this performance reputation we assume that generation scavenging will be the garbage collector of choice, so that maintaining remembered sets for the buffers of the object manager will require little additional mechanism.
Reference: [Wirth, 1983] <author> Niklaus Wirth. </author> <title> Programming in Modula-2, second, corrected ed. </title> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: First, they are relatively well-known. Smalltalk was the first object-oriented programming language to gain widespread recognition. Modula-3 is less widely known, but its ancestry is quite familiar, as it derives from the class of languages including Pascal [Jensen and Wirth, 1974], Modula-2 <ref> [Wirth, 1983] </ref>, and Oberon [Wirth, 1988a; Wirth, 1988b]. Second, they represent quite different philosophies. In Smalltalk there is no static type checking. In fact, the Smalltalk class hierarchy provides only a very weak notion of type.
Reference: [Wirth, 1988a] <author> Niklaus Wirth. </author> <title> From Modula to Oberon. </title> <journal> Software: Practice and Experience 18, </journal> <month> 7 (July </month> <year> 1988), </year> <pages> 661-670. </pages>
Reference-contexts: First, they are relatively well-known. Smalltalk was the first object-oriented programming language to gain widespread recognition. Modula-3 is less widely known, but its ancestry is quite familiar, as it derives from the class of languages including Pascal [Jensen and Wirth, 1974], Modula-2 [Wirth, 1983], and Oberon <ref> [Wirth, 1988a; Wirth, 1988b] </ref>. Second, they represent quite different philosophies. In Smalltalk there is no static type checking. In fact, the Smalltalk class hierarchy provides only a very weak notion of type.
Reference: [Wirth, 1988b] <author> Niklaus Wirth. </author> <title> The programming language Oberon. </title> <journal> Software: Practice and Experience 18, </journal> <month> 7 (July </month> <year> 1988), </year> <pages> 671-690. </pages>
Reference-contexts: First, they are relatively well-known. Smalltalk was the first object-oriented programming language to gain widespread recognition. Modula-3 is less widely known, but its ancestry is quite familiar, as it derives from the class of languages including Pascal [Jensen and Wirth, 1974], Modula-2 [Wirth, 1983], and Oberon <ref> [Wirth, 1988a; Wirth, 1988b] </ref>. Second, they represent quite different philosophies. In Smalltalk there is no static type checking. In fact, the Smalltalk class hierarchy provides only a very weak notion of type.
References-found: 22

