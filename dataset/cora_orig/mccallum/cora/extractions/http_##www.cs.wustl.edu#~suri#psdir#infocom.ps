URL: http://www.cs.wustl.edu/~suri/psdir/infocom.ps
Refering-URL: http://www.cs.wustl.edu/~suri/research.html
Root-URL: http://www.cs.wustl.edu
Title: Packet Filter Management for Layer 4 Switching whether a new filter conflicts with the database
Author: Hari Adiseshu Subhash Suri Guru Parulkar 
Note: Detecting  
Address: St. Louis, MO 63130  
Affiliation: Department of Computer Science Washington University  
Abstract: The Internet is being pushed to the limit by the increased demand for bandwidth and functionality. The increased demand for bandwidth is fueled by the explosive growth in the number of users and multimedia applications. The increased demand for functionality is propelled by new services like Quality of Service (QoS), Virtual Private Networks (vpn)s and firewalls. These services require routers to maintain state and to look at additional fields in each packet for proper packet processing. This installed state is often referred to as filters, and the lookup of additional fields including transport layer headers as Layer 4 Switching. Filters introduce two new problems. One, how does one match packets to filters? This packet classification problem is now the subject of active research [8, 9]. Second, overlapping filters cause conflicts since a packet can match multiple filters. How does one resolve such conflicts? While both problems are important with the increasing emphasis on layer 4 switching, the second problem of resolving ambiguities in overlapping filters has not been studied so far. Efficient solutions are important because the increased demand for bandwidth can only be met by high speed packet processing algorithms. In this paper, we develop a geometric framework for studying filters, and present algorithms for detecting and resolving conflicts. Our scheme for conflict resolution is based on adding new filters. We show that our algorithm adds the fewest possible new filters to resolve conflicts. We give a simple but general algorithm for adding a new k-tuple filter to an existing database of filters, and resolving any conflicts it creates with existing filters by adding new filters. In the special case of 2-tuple filters with w number of bits in the filter fields we are able to design a highly efficient algorithm with the following properties: * Resolving all the conflicts created by the addition of a new filter takes O(w 2 +wC) worst-case time, where C is the number of filters in conflict with the new filter; we assume that the database prior to the addition of the new filter was conflict free. A time-space tradeoff can reduce the w 2 term to (w=k) 2 by increasing memory by a factor of 2 k . We also report on simulation studies that validate these theoretical results. Interestingly, our data structure and algorithms can be used not only for fast conflict detection amongst filters, but also for packet classification. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Lampson, V. Srinivasan and G. Varghese. </author> <title> IP Lookups using Multiway and Multicolumn Search. </title> <booktitle> In Infocomm, </booktitle> <year> 1998. </year>
Reference-contexts: While cidr was motivated by the need to contain the growth of the routing table and to manage the exiting ipv4 address space in a more efficient manner, it is only recently <ref> [3, 8, 9, 1, 7] </ref> that schemes have been developed which allow prefix based ip packet forwarding at wire speeds for gigabit links. * Quality of Service (QoS) in the Internet. <p> Finally, we discuss the use of the algorithm not only for conflict detection, but also for packet classification. 2 Conflicts in Filters Abstractly, a filter F is a k-tuple (F <ref> [1] </ref>, F [2], : : :, F [k]), where each field F [i] is a prefix bit string. <p> For example, in Figure 4, if we add a new filter covering the region a2 then we resolve the conflict between filters A and B. 4 The General Algorithm We recall that each filter F is a k-tuple (F <ref> [1] </ref>, F [2], : : :, F [k]), where each field F [i] is a prefix bit string. We say that two prefixes x:fl and y:fl are disjoint if there is no address common to them. Two filters are said to be disjoint if no packet header matches them both. <p> The key insight for the new algorithm is the following observation, which follows readily from the general result in Theorem 4.1. Lemma 5.1 Filters F and G have a conflict if and only if 1. G <ref> [1] </ref> is a prefix of F [1] and F [2] is a prefix of G [2], or 2. F [1] is a prefix of G [1] and G [2] is a prefix of F [2]. <p> The key insight for the new algorithm is the following observation, which follows readily from the general result in Theorem 4.1. Lemma 5.1 Filters F and G have a conflict if and only if 1. G <ref> [1] </ref> is a prefix of F [1] and F [2] is a prefix of G [2], or 2. F [1] is a prefix of G [1] and G [2] is a prefix of F [2]. While our algorithm can handle any two prefix fields, let us use source and destination addresses for concreteness. <p> Lemma 5.1 Filters F and G have a conflict if and only if 1. G <ref> [1] </ref> is a prefix of F [1] and F [2] is a prefix of G [2], or 2. F [1] is a prefix of G [1] and G [2] is a prefix of F [2]. While our algorithm can handle any two prefix fields, let us use source and destination addresses for concreteness. We will use the example database B shown in Figure 10 to illustrate our scheme. <p> Lemma 5.1 Filters F and G have a conflict if and only if 1. G <ref> [1] </ref> is a prefix of F [1] and F [2] is a prefix of G [2], or 2. F [1] is a prefix of G [1] and G [2] is a prefix of F [2]. While our algorithm can handle any two prefix fields, let us use source and destination addresses for concreteness. We will use the example database B shown in Figure 10 to illustrate our scheme. <p> We associate a second trie D (u) (destination trie) with u, which stores the destination prefixes of the filters whose source prefix is exactly s (u). More precisely, let us define the set X (u) = fF 2 B j F <ref> [1] </ref> = s (u)g: That is, X (u) is the set of filters with source field equal to s (u). We build a secondary trie D (u) on the destination addresses of the set X (u), which is pointed to by the node u. Figure 11 shows the complete construction. <p> We will search both Recursive Tries 1 and 2. When searching Recursive Trie 1, we first use the source trie S (B) to locate the longest matching prefix of the source field F <ref> [1] </ref>. Let u be the node with this longest matching prefix, and let v 1 ; v 2 ; : : : ; v m be the nodes in the source trie whose bit strings correspond to (proper) prefixes of F [1]. <p> the longest matching prefix of the source field F <ref> [1] </ref>. Let u be the node with this longest matching prefix, and let v 1 ; v 2 ; : : : ; v m be the nodes in the source trie whose bit strings correspond to (proper) prefixes of F [1]. Observe that v 1 ; : : : ; v m are all ancestors of u, and possibly u = v 1 . We visit each of the destination tries D (v 1 ); D (v 2 ); : : :; D (v m ) in turn. <p> First, we show that every filter G added to C (F ) has a conflict with F . Suppose G is added to C (F ) in line 6. Then, line 2 ensures that, in the source field, G <ref> [1] </ref> is a prefix or F [1], and line 5 ensures that, in the destination field, F [2] is a prefix of G [2]. Thus, by Lemma 5.1, F and G must have a conflict. A similar reasoning holds if G is added in line 11. <p> First, we show that every filter G added to C (F ) has a conflict with F . Suppose G is added to C (F ) in line 6. Then, line 2 ensures that, in the source field, G <ref> [1] </ref> is a prefix or F [1], and line 5 ensures that, in the destination field, F [2] is a prefix of G [2]. Thus, by Lemma 5.1, F and G must have a conflict. A similar reasoning holds if G is added in line 11. <p> Initialize C (F ) = fF g; (* Search Recursive Trie 1 *) 2. Let u be the node in the source trie S (B) for which s (u) is the longest matching prefix of the source field F <ref> [1] </ref>; 3. Let v 1 ; v 2 ; : : : ; v m denote the nodes in S (B) whose bit strings correspond to (proper) prefixes of F [1]; 4. for i = 1 to m do 5. <p> in the source trie S (B) for which s (u) is the longest matching prefix of the source field F <ref> [1] </ref>; 3. Let v 1 ; v 2 ; : : : ; v m denote the nodes in S (B) whose bit strings correspond to (proper) prefixes of F [1]; 4. for i = 1 to m do 5. Determine the node z in D (v i ) whose string is the longest matching prefix of the destination field F [2]; 6. <p> Determine the node z in S (v i ) whose string is the longest matching prefix of the source field F <ref> [1] </ref>; 11. Add to C (F ) all the filters stored with a descendant node of z; 12. If C (F ) only contains F , then add F to B, and return "No Conflict"; 13. for each filter F 0 2 C (F ) do 14. <p> A filter F can be added to each of the two recursive tries in O (w) time. Specifically, first consider Recursive Trie 1. We search down the source trie S (B) to see if the source field F <ref> [1] </ref> exists. If not, we expand the trie to place an entry for the string F [1]. Let u be the node containing the source field F [1]. We search D (u) to find the node z that corresponds to the destination field F [2]. <p> Specifically, first consider Recursive Trie 1. We search down the source trie S (B) to see if the source field F <ref> [1] </ref> exists. If not, we expand the trie to place an entry for the string F [1]. Let u be the node containing the source field F [1]. We search D (u) to find the node z that corresponds to the destination field F [2]. The node z keeps a pointer to the filter F . Recursive Trie 2 is updated similarly. <p> Specifically, first consider Recursive Trie 1. We search down the source trie S (B) to see if the source field F <ref> [1] </ref> exists. If not, we expand the trie to place an entry for the string F [1]. Let u be the node containing the source field F [1]. We search D (u) to find the node z that corresponds to the destination field F [2]. The node z keeps a pointer to the filter F . Recursive Trie 2 is updated similarly. The update cost is clearly O (w) per filter added.
Reference: [2] <author> D. Decasper, Z. Dittia, G. Parulkar, B. Plattner. </author> <title> Router Plugins: A Software Architecture for Next Generation Routers. </title> <booktitle> In Sigcomm, </booktitle> <year> 1998. </year>
Reference-contexts: Finally, we discuss the use of the algorithm not only for conflict detection, but also for packet classification. 2 Conflicts in Filters Abstractly, a filter F is a k-tuple (F [1], F <ref> [2] </ref>, : : :, F [k]), where each field F [i] is a prefix bit string. <p> For example, in Figure 4, if we add a new filter covering the region a2 then we resolve the conflict between filters A and B. 4 The General Algorithm We recall that each filter F is a k-tuple (F [1], F <ref> [2] </ref>, : : :, F [k]), where each field F [i] is a prefix bit string. We say that two prefixes x:fl and y:fl are disjoint if there is no address common to them. Two filters are said to be disjoint if no packet header matches them both. <p> The key insight for the new algorithm is the following observation, which follows readily from the general result in Theorem 4.1. Lemma 5.1 Filters F and G have a conflict if and only if 1. G [1] is a prefix of F [1] and F <ref> [2] </ref> is a prefix of G [2], or 2. F [1] is a prefix of G [1] and G [2] is a prefix of F [2]. While our algorithm can handle any two prefix fields, let us use source and destination addresses for concreteness. <p> Lemma 5.1 Filters F and G have a conflict if and only if 1. G [1] is a prefix of F [1] and F <ref> [2] </ref> is a prefix of G [2], or 2. F [1] is a prefix of G [1] and G [2] is a prefix of F [2]. While our algorithm can handle any two prefix fields, let us use source and destination addresses for concreteness. <p> Lemma 5.1 Filters F and G have a conflict if and only if 1. G [1] is a prefix of F [1] and F <ref> [2] </ref> is a prefix of G [2], or 2. F [1] is a prefix of G [1] and G [2] is a prefix of F [2]. While our algorithm can handle any two prefix fields, let us use source and destination addresses for concreteness. We will use the example database B shown in Figure 10 to illustrate our scheme. <p> Lemma 5.1 Filters F and G have a conflict if and only if 1. G [1] is a prefix of F [1] and F <ref> [2] </ref> is a prefix of G [2], or 2. F [1] is a prefix of G [1] and G [2] is a prefix of F [2]. While our algorithm can handle any two prefix fields, let us use source and destination addresses for concreteness. We will use the example database B shown in Figure 10 to illustrate our scheme. We develop a 2-dimensional recursive trie data structure to solve the filter conflict problem. <p> In particular, one data structure can efficiently isolate the filters whose source field is a prefix of F 's source field, and then organize these filters to quickly determine if any of them has the destination field with F <ref> [2] </ref> as a prefix. The second data structure reverses the roles of source and destination fields. Recursive Trie 1 We start by building a trie on all the source address prefixes in the database B. We call this the source trie S (B). <p> We visit each of the destination tries D (v 1 ); D (v 2 ); : : :; D (v m ) in turn. In each destination trie, say, D (v i ), we locate the longest matching prefix of the destination field F <ref> [2] </ref>. If the node z with the longest matching prefix is a leaf then no filters in D (v i ) are in conflict with F . Otherwise (if z is not a leaf), all the filters associated with descendants of z are in conflict with F . <p> Suppose G is added to C (F ) in line 6. Then, line 2 ensures that, in the source field, G [1] is a prefix or F [1], and line 5 ensures that, in the destination field, F <ref> [2] </ref> is a prefix of G [2]. Thus, by Lemma 5.1, F and G must have a conflict. A similar reasoning holds if G is added in line 11. <p> Suppose G is added to C (F ) in line 6. Then, line 2 ensures that, in the source field, G [1] is a prefix or F [1], and line 5 ensures that, in the destination field, F <ref> [2] </ref> is a prefix of G [2]. Thus, by Lemma 5.1, F and G must have a conflict. A similar reasoning holds if G is added in line 11. The second part of the proof is to show that all filters in conflict with F are detected and added to C (F ). <p> Determine the node z in D (v i ) whose string is the longest matching prefix of the destination field F <ref> [2] </ref>; 6. Add to C (F ) all the filters stored with a descendant node of z; (* Search Recursive Trie 2 *) 7. Let u be the node in destination trie D (B) for which d (u) is the longest matching prefix of the destination field F [2]; 8. <p> field F <ref> [2] </ref>; 6. Add to C (F ) all the filters stored with a descendant node of z; (* Search Recursive Trie 2 *) 7. Let u be the node in destination trie D (B) for which d (u) is the longest matching prefix of the destination field F [2]; 8. Let v 1 ; v 2 ; : : : ; v m denote the nodes in D (B) whose bit strings correspond to (proper) prefixes of F [2]; 9. for i = 1 to m do 10. <p> node in destination trie D (B) for which d (u) is the longest matching prefix of the destination field F <ref> [2] </ref>; 8. Let v 1 ; v 2 ; : : : ; v m denote the nodes in D (B) whose bit strings correspond to (proper) prefixes of F [2]; 9. for i = 1 to m do 10. Determine the node z in S (v i ) whose string is the longest matching prefix of the source field F [1]; 11. Add to C (F ) all the filters stored with a descendant node of z; 12. <p> If not, we expand the trie to place an entry for the string F [1]. Let u be the node containing the source field F [1]. We search D (u) to find the node z that corresponds to the destination field F <ref> [2] </ref>. The node z keeps a pointer to the filter F . Recursive Trie 2 is updated similarly. The update cost is clearly O (w) per filter added. <p> One may be tempted to use FastDetect on every pair of fields, and conclude 20 1000 100000 1e+07 Memory (in bytes) Number of Filters in Database Scheme Space Complexity Time Complexity Update Cost FastDetect O (n) O (w 2 ) O (w) Set Pruning Trees <ref> [8, 2] </ref> O (n 2 ) O (2w) O (w) Grid of Tries [8] O (n) O (2w) O (n) Table 1: Comparison of different schemes for packet classification. Assume n filters in the database, and each field of the filter has w bits. that it finds all conflicting filters.
Reference: [3] <author> Andrej Brodnik et. al. </author> <title> Small Forwarding Tables for Fast Routing Lookups . In Computer Communication Review, </title> <booktitle> Vol 27, </booktitle> <volume> #4, </volume> <month> October </month> <year> 1997. </year>
Reference-contexts: While cidr was motivated by the need to contain the growth of the routing table and to manage the exiting ipv4 address space in a more efficient manner, it is only recently <ref> [3, 8, 9, 1, 7] </ref> that schemes have been developed which allow prefix based ip packet forwarding at wire speeds for gigabit links. * Quality of Service (QoS) in the Internet.
Reference: [4] <editor> Waldvogel et. al. </editor> <booktitle> Scalable High Speed IP Routing Lookups . In Computer Communication Review, </booktitle> <volume> Vol 27, #4, </volume> <month> October </month> <year> 1997. </year>
Reference-contexts: In particular, fast multibit hashed trie lookups designed for ip prefix matching <ref> [4] </ref> can reduce the conflict detection times to nanoseconds. The advantage of this scheme is that the insert () procedure is straightforward, while the fast schemes have slower insert () procedures, besides increased memory cost.
Reference: [5] <author> H. Edelsbrunner. </author> <title> A New Approach to Rectangle Intersections (Parts I and II). In Int. </title> <journal> J. of Computer Math., </journal> <pages> pages 209-229, </pages> <year> 1983. </year>
Reference-contexts: Conflict detection among filters is related to the abstract problem of multidimensional range searching , which is studied in computational geometry. The filter database corresponds to a set of N k-dimensional rectangular boxes, and the object is to determine the subset of boxes that intersect a query box. Edelsbrunner <ref> [5] </ref> has proposed a data structure that can solve this problem in worst-case time O ((log N ) 2k1 +R), where R is the number of rectangular boxes intersecting the query box.
Reference: [6] <author> Hari Adiseshu, Guru Parulkar and Raj Yavatkar. </author> <title> A State Management Protocol for IntServ, DiffServ and Label Switching. </title> <booktitle> In IEEE ICNP, </booktitle> <year> 1998. </year>
Reference-contexts: As the signaling information propagates through the network, network routers can use the algorithm to report conflicts back to the originators of the signaling requests. We plan to study the use of this algorithm in the IntServ/DiffServ testbed with enhanced signaling <ref> [6] </ref> we are currently building.
Reference: [7] <author> V. Srinivasan and G. Varghese. </author> <title> Faster IP Lookups using Controlled Prefix Expansion. </title> <booktitle> In Proc. ACM Sigmetrics, </booktitle> <year> 1998. </year>
Reference-contexts: While cidr was motivated by the need to contain the growth of the routing table and to manage the exiting ipv4 address space in a more efficient manner, it is only recently <ref> [3, 8, 9, 1, 7] </ref> that schemes have been developed which allow prefix based ip packet forwarding at wire speeds for gigabit links. * Quality of Service (QoS) in the Internet.
Reference: [8] <author> V. Srinivasan, G. Varghese, S. Suri and M. Waldvogel. </author> <title> Fast and Scalable Layer Four Switching. </title> <booktitle> In Sigcomm, </booktitle> <year> 1998. </year>
Reference-contexts: While cidr was motivated by the need to contain the growth of the routing table and to manage the exiting ipv4 address space in a more efficient manner, it is only recently <ref> [3, 8, 9, 1, 7] </ref> that schemes have been developed which allow prefix based ip packet forwarding at wire speeds for gigabit links. * Quality of Service (QoS) in the Internet. <p> For instance, the prefix 10fl in a 4-bit field determines the range [1000; 1011] = <ref> [8; 11] </ref>. We say that an address X matches a prefix x:fl if X lies in the range [x0 0; x1 1]. We say that a packet P matches a filter F , if each field of P matches the corresponding prefix of F . <p> However, filters are sometimes specified as ranges. For example, a firewall might block an arbitrary range of ports. It is always possible to transform a subrange of [0, 2 k ] into at most 2k prefixes <ref> [8] </ref>. Thus, a filter with arbitrary ranges can always be transformed into a set of filters with prefix strings. We therefore do not view this as a limitation of our algorithm. We are currently working on fast versions of the conflict detection algorithm for k-tuple filters, where k &gt; 2. <p> One may be tempted to use FastDetect on every pair of fields, and conclude 20 1000 100000 1e+07 Memory (in bytes) Number of Filters in Database Scheme Space Complexity Time Complexity Update Cost FastDetect O (n) O (w 2 ) O (w) Set Pruning Trees <ref> [8, 2] </ref> O (n 2 ) O (2w) O (w) Grid of Tries [8] O (n) O (2w) O (n) Table 1: Comparison of different schemes for packet classification. Assume n filters in the database, and each field of the filter has w bits. that it finds all conflicting filters. <p> every pair of fields, and conclude 20 1000 100000 1e+07 Memory (in bytes) Number of Filters in Database Scheme Space Complexity Time Complexity Update Cost FastDetect O (n) O (w 2 ) O (w) Set Pruning Trees [8, 2] O (n 2 ) O (2w) O (w) Grid of Tries <ref> [8] </ref> O (n) O (2w) O (n) Table 1: Comparison of different schemes for packet classification. Assume n filters in the database, and each field of the filter has w bits. that it finds all conflicting filters.
Reference: [9] <editor> V.P. Kumar, T.V. Lakshman, D. Stiliadis. </editor> <title> Beyond Best Effort: Router Architectures for the Differentiated Services of Tomorrow's Internet. </title> <year> 1998. </year>
Reference-contexts: While cidr was motivated by the need to contain the growth of the routing table and to manage the exiting ipv4 address space in a more efficient manner, it is only recently <ref> [3, 8, 9, 1, 7] </ref> that schemes have been developed which allow prefix based ip packet forwarding at wire speeds for gigabit links. * Quality of Service (QoS) in the Internet.
Reference: [10] <author> Y. Rekhter and T. Li. </author> <title> Classless Inter-Domain Routing. </title> <booktitle> In RFC1517, </booktitle> <volume> 1518, 1519, </volume> <month> September </month> <year> 1993. </year> <month> 22 </month>
Reference-contexts: Successful deployment of these technologies and services is cruicial for the successful evolution of the Internet towards a full service network. * CIDR. The first development was cidr <ref> [10] </ref> which replaced the traditional full length address lookup with variable length prefix lookups.
References-found: 10

