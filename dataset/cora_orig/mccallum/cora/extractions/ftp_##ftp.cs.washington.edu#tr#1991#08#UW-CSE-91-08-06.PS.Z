URL: ftp://ftp.cs.washington.edu/tr/1991/08/UW-CSE-91-08-06.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: A Probabilistic Algorithm for Verifying Matrix Products Using O(n 2 Time and log 2 n
Author: Tracy Kimbrel Rakesh Kumar Sinha 
Keyword: )e random bits.  
Note: This material is based upon work supported under a National Science Foundation Graduate Fellowship. This material is based upon work supported by the National Science Foundation under grants CCR-8858799 and CCR-8907960.  
Date: August 8; 1991  
Address: Seattle, Washington, U.S.A. 98195  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington  
Abstract: A one-sided error probabilistic algorithm is given that determines, for n fi n input matrices A, B, and C, whether AB 6= C, using O(n 2 ) multiplications and additions and dlog 2 ne + 1 random bits. We further show how to reduce the error probability to * with only an additional dlog 2 ( 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Alon, O. Goldreich, J. H-astad, and R. Peralta. </author> <title> Simple constructions of almost k-wise independent random variables. </title> <booktitle> In 31st Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 544-553, </pages> <address> St. Louis, MO, </address> <month> Oct. </month> <year> 1990. </year> <note> IEEE. </note>
Reference-contexts: A similar method is used here, but the vector ~v is chosen from a set of less than 4n vectors, requiring only dlog 2 ne + 1 random bits. Naor and Naor [6], and Alon, Goldreich, H-astad, and Peralta <ref> [1] </ref> give constructions of polynomial size (polynomial in n) sample spaces of n-bit vectors, yielding O (log n) randomness solutions to this problem. Our method is similar to the constructions of Alon et al., particularly their powering construction.
Reference: [2] <author> R. Freivalds. </author> <title> Fast probabilistic algorithms. </title> <booktitle> In Mathematical Foundations of Computer Science: Proceedings, 8th Symposium, volume 74 of Lecture Notes in Computer Science, </booktitle> <pages> pages 57-69. </pages> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: 1. Introduction Given two n fi n matrices A and B, computing their product is a classic problem. We consider a related decision problem: given three n fi n matrices A, B, and C, how difficult is it to verify whether AB = C? Freivalds <ref> [2] </ref> gave a probabilistic algorithm to verify matrix products using O (n 2 ) multiplications and additions, and n bits of randomness. The algorithm accepts the set fhA; B; Ci j AB 6= Cg with one-sided error.
Reference: [3] <author> G. H. Hardy and E. M. Wright. </author> <title> An Introduction to the Theory of Numbers. </title> <publisher> Oxford University Press, </publisher> <address> fifth edition, </address> <year> 1979. </year>
Reference-contexts: The rest of the proof of correctness remains unchanged. 4 For every k 1, there is a prime between k and 2k (Theorem 418 of Hardy and Wright <ref> [3] </ref>); thus, there is some prime p, 2n p 4n. Let m be the maximum of 4n and the largest absolute value in A, B, and C, and let b = dlog 2 me. We can use the sieve method to find p. <p> We can use the sieve method to find p. It is straightforward to see that this requires O (n 3=2 ) additions of O (log n)-bit integers. (One can use Merten's lemma (Theorem 427 of Hardy and Wright <ref> [3] </ref>) to argue that the number of additions is only O (n log log n).) The overall running time of the algorithm is O (n 2 b 2 ) (counting bit operations) using simple algorithms for integer multiplication and addition.
Reference: [4] <author> R. Impagliazzo and D. Zuckerman. </author> <title> How to recycle random bits. </title> <booktitle> In 30th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 248-253, </pages> <address> Research Triangle Park, NC, </address> <month> Oct. </month> <year> 1989. </year> <note> IEEE. </note>
Reference-contexts: The straightforward approach involves running Algorithm 1 for k independent trials, where ( 1 * ). This strategy requires dlog 2 ( 1 * )edlog 2 (n)e random bits and (n 2 log ( 1 * )) operations. Using the techniques of Impagliazzo and 6 Zuckerman <ref> [4] </ref> we can achieve the same error bound with only O (log ( 1 * )) additional random bits.
Reference: [5] <author> J. D. Lipson. </author> <title> Elements of Algebra and Algebraic Computing. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1981. </year>
Reference-contexts: The following lemma is easily proved using the interpolation theorem. Lemma 1: Over any integral domain, every Vandermonde matrix of n distinct non-zero elements is nonsingular. (See Proposition 1, page 300 of Lipson <ref> [5] </ref> for a proof.) We are now ready to state our first result. Theorem 2: Algorithm 1 accepts the triple of matrices hA; B; Ci with probability greater than 1 2 if AB 6= C, and rejects if AB = C.
Reference: [6] <author> J. Naor and M. Naor. </author> <title> Small-bias probability spaces: efficient constructions and applications. </title> <booktitle> In Proceedings of the Twenty Second Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 213-223, </pages> <address> Baltimore, MD, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: A similar method is used here, but the vector ~v is chosen from a set of less than 4n vectors, requiring only dlog 2 ne + 1 random bits. Naor and Naor <ref> [6] </ref>, and Alon, Goldreich, H-astad, and Peralta [1] give constructions of polynomial size (polynomial in n) sample spaces of n-bit vectors, yielding O (log n) randomness solutions to this problem. Our method is similar to the constructions of Alon et al., particularly their powering construction.
Reference: [7] <author> P. Pritchard. </author> <title> A sublinear additive sieve for finding prime numbers. </title> <journal> Communications of the ACM, </journal> <volume> 24 </volume> <pages> 18-23, </pages> <year> 1981. </year>
Reference-contexts: Finding the first prime greater than n * seems to be prohibitive in running time for smaller values of *. Pritchard <ref> [7] </ref> shows how to find the smallest prime larger than N using O ( N log N log log N ) bit operations.
Reference: [8] <author> V. Shoup. </author> <title> New algorithms for finding irreducible polynomials over finite fields. </title> <booktitle> In 29th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 283-290, </pages> <address> White Plains, NY, </address> <month> Oct. </month> <year> 1988. </year> <journal> IEEE. </journal> <volume> 8 </volume>
Reference-contexts: The only complication is that an irreducible monic polynomial of degree ff over GF (p) is needed to do GF (p ff ) arithmetic. Such a polynomial 5 can be found within the overall time bound of O (n 2 ff); for instance, the method of Shoup <ref> [8] </ref> can be used. However, a much more naive and simple algorithm will suffice for our purposes. Consider the two cases p p p &gt; 2n separately. Suppose p &gt; p 2n. In this case, ff = 2.
References-found: 8

