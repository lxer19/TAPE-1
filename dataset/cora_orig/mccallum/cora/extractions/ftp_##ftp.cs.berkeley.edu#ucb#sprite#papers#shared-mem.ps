URL: ftp://ftp.cs.berkeley.edu/ucb/sprite/papers/shared-mem.ps
Refering-URL: http://www.cs.berkeley.edu/projects/sprite/sprite.papers.html
Root-URL: 
Title: An Implementation of Memory Sharing and File Mapping  
Author: Ken Shirriff 
Note: January 4, 1993 The work described here was supported by NASA and the Defense Advanced Research Projects Agency under Contract No. NAG2-591, by the National Science Foundation under Grant No. MIP-8715235, and by the IBM Fellowship program.  
Pubnum: Master's Report  
Abstract: Due to demand for shared memory in order to implement databases efficiently, I added the mmap mapped file interface of 4.2 BSD Unix to Sprite, providing shared memory, file mapping, and user-level control over paging. This report first discusses the design issues for a shared memory and file mapping interface and provides an overview of the support for these functions in other operating systems. Details of the Sprite virtual memory system and the changes to support shared memory and file mapping are given. Performance measurements show that in this implementation, mapped files have comparable performance to block I/O and are faster than buffered I/O for sequential access. For random access to locally cached files, the relative performance of mapped files versus block I/O depends on the access patterns. Access to files across the network is limited by network transmission time, both for mapped files and block I/O. 
Abstract-found: 1
Intro-found: 1
Reference: [ATT86] <institution> System V Interface Definition, AT&T, Indianapolis, IN, </institution> <year> 1986. </year>
Reference-contexts: System V Unix System V Unix has support for shared memory but not for file mapping <ref> [ATT86] </ref>. The System V shared memory interface is summarized in Table 2. This interface has also been implemented in other Unix-based operating systems such as SunOS. The Postgres group has implemented a simplified version of the System V interface at user level on top of Sprite's BSD mmap interface.
Reference: [BCD72] <author> A. Bensoussan, C. Clingen and R. Daley, </author> <title> The Multics Virtual Memory: Concepts and Design, </title> <journal> Communications of the ACM 15, </journal> <month> 5 (May </month> <year> 1972), </year> <pages> 308-318. </pages>
Reference-contexts: Finally the sharing - 6 - mechanisms of Sprite are described. 4.1. Multics Multics is interesting historically, as it was one of the first operating systems to provide shared memory and file mapping [DaD68], <ref> [BCD72] </ref>. Two design goals of Multics were to provide direct access to all data and to permit controlled sharing of information. These goals were attained by file mapping and shared memory. File mapping is the basic method for accessing information in Multics.
Reference: [BAL89] <author> B. Bershad, T. Anderson, E. Lazowska and H. Levy, </author> <title> Lightweight Remote Procedure Call, </title> <booktitle> Proc. Twelfth ACM Symposium on Operating System Principles, Operating Systems Review 23, </booktitle> <month> 5 (Dec. </month> <year> 1989), </year> <pages> 102-113. </pages>
Reference-contexts: Shared memory can also be used for interprocess communication functions such as message passing. A message can be written into shared memory and then read by the recipient without explicitly copying the data. For instance, the lightweight remote procedure call facility of the Taos operating system <ref> [BAL89] </ref> uses a shared message buffer to transmit messages efficiently across domains on a machine. Shared memory can make memory usage more efficient if several processes are using the same information, since only one copy of the information needs to be kept in memory.
Reference: [DaD68] <author> R. Daley and J. Dennis, </author> <title> Virtual Memory, Processes, and Sharing in MULTICS, </title> <journal> Communications of the ACM 11, </journal> <month> 5 (May </month> <year> 1968), </year> <pages> 306-312. </pages>
Reference-contexts: Finally the sharing - 6 - mechanisms of Sprite are described. 4.1. Multics Multics is interesting historically, as it was one of the first operating systems to provide shared memory and file mapping <ref> [DaD68] </ref>, [BCD72]. Two design goals of Multics were to provide direct access to all data and to permit controlled sharing of information. These goals were attained by file mapping and shared memory. File mapping is the basic method for accessing information in Multics.
Reference: [FiR86] <author> R. Fitzgerald and R. Rashid, </author> <title> The Integration of Virtual Memory Management and Interprocess Communication in Accent, </title> <journal> ACM Transactions on Computer Systems 4, </journal> <month> 2 (May </month> <year> 1986), </year> <pages> 147-177. </pages>
Reference-contexts: This was not done, in order to minimize changes to the previous Sprite implementation. However, it would probably result in a cleaner implementation since all segment types would be treated uniformly. Another alternative is a tree-structured address map such as is used in Accent <ref> [FiR86] </ref>. This structure provides compact storage of a complex, sparse address space and allows fast indexing into the appropriate address map. However, it has a high implementation cost [RTY88].
Reference: [GMS87] <author> R. Gingell, J. Moran and W. Shannon, </author> <title> Virtual Memory Architecture in SunOS, </title> <booktitle> Proceedings of Summer USENIX, </booktitle> <month> June </month> <year> 1987, </year> <pages> 81-94. </pages>
Reference-contexts: BSD Unix An interface for shared memory and file mapping was defined in 4.2 BSD Unix [JFL86, McK86] but was not implemented in BSD Unix until Version 4.4 (which is currently unreleased) [McK90]. This interface has been implemented in various operating systems derived from BSD Unix, such as SunOS <ref> [GMS87] </ref> and DYNIX [Seq86]. The Sprite implementation of shared memory and file mapping is based on the 4.2 BSD design. The functions implemented in Sprite are summarized in Table 1.
Reference: [JFL86] <author> W. Joy, R. Fabry, S. Leffler, M. McKusick and M. Karels, </author> <title> Berkeley Software Architecture Manual 4.3BSD Edition, </title> <institution> Computer Systems Research Group, University of California, Berkeley, </institution> <year> 1986. </year>
Reference-contexts: Each process has its own temporary directory for holding segments created during execution, such as heap and stack segments. - 7 - 4.2. BSD Unix An interface for shared memory and file mapping was defined in 4.2 BSD Unix <ref> [JFL86, McK86] </ref> but was not implemented in BSD Unix until Version 4.4 (which is currently unreleased) [McK90]. This interface has been implemented in various operating systems derived from BSD Unix, such as SunOS [GMS87] and DYNIX [Seq86].
Reference: [Li86] <author> K. Li and P. Hudak, </author> <title> Memory Coherence in Shared Virtual Memory Systems, </title> <booktitle> Proceedings 5th ACM SIGACT News-SIGOPS Symposium of Principles of Distributed Computing, </booktitle> <address> Canada, </address> <month> Aug. </month> <year> 1986. </year>
Reference: [McK86] <author> M. McKusick and M. Karels, </author> <title> A New Virtual Memory Implementation for Berkeley UNIX, </title> <booktitle> Proceedings of the European UNIX Users Group Meeting, </booktitle> <address> Manchester, England, </address> <month> Sep. </month> <year> 1986, </year> <pages> 451-460. </pages>
Reference-contexts: Each process has its own temporary directory for holding segments created during execution, such as heap and stack segments. - 7 - 4.2. BSD Unix An interface for shared memory and file mapping was defined in 4.2 BSD Unix <ref> [JFL86, McK86] </ref> but was not implemented in BSD Unix until Version 4.4 (which is currently unreleased) [McK90]. This interface has been implemented in various operating systems derived from BSD Unix, such as SunOS [GMS87] and DYNIX [Seq86].
Reference: [McK90] <author> K. McKusick, </author> <type> (Personal communication), </type> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: BSD Unix An interface for shared memory and file mapping was defined in 4.2 BSD Unix [JFL86, McK86] but was not implemented in BSD Unix until Version 4.4 (which is currently unreleased) <ref> [McK90] </ref>. This interface has been implemented in various operating systems derived from BSD Unix, such as SunOS [GMS87] and DYNIX [Seq86]. The Sprite implementation of shared memory and file mapping is based on the 4.2 BSD design. The functions implemented in Sprite are summarized in Table 1.
Reference: [Nel86] <author> M. Nelson, </author> <title> Virtual Memory for the Sprite Operating System, </title> <type> Technical Report UCB/CSD 86/301, </type> <institution> University of California, Berkeley, </institution> <month> June </month> <year> 1986. </year>
Reference-contexts: Sprite Prior to the addition of the 4.2 BSD mmap interface, Sprite had two limited sharing capabilities. Sprite permitted processes to share code segments, similar to Unix. In addition, Sprite processes could share both their code and heap segments, while having separate stacks <ref> [Nel86] </ref>. This is similar to the Mach model of multiple threads of execution in a single address space. The motivation for heap sharing was to provide fast and efficient interprocess communication for Sprite applications running on the SPUR multiprocessor. <p> The virtual memory system in Sprite Section 7.1 discusses the data structures in the virtual memory system in Sprite prior to the addition of shared memory and file mapping. A higher level description of the original Sprite virtual memory system is given in <ref> [Nel86] </ref>. Section 7.2 describes the data structures used to provided shared memory and file mapping. Section 7.3 describes the machinedependent aspects of shared memory. 7.1.
Reference: [Nel88] <author> M. Nelson, </author> <title> Physical Memory Management in a Network Operating System, </title> <type> PhD Thesis, Technical Report UCB/CSD 88/471, </type> <institution> University of California, Berkeley, </institution> <month> Dec. </month> <year> 1988. </year> <month> - 30 </month> - 
Reference-contexts: Thus, random accesses to a large file will almost never reference data already in the I/O buffer. In contrast, physical user memory and the file cache may each be several megabytes. - 5 - of heterogeneous high-performance workstations <ref> [Nel88] </ref>, [OCD88]. Sprite has a kernel interface and functionality similar to 4.3 BSD Unix. A single system image is provided, with files shared transparently among the machines in a Sprite cluster.
Reference: [Org72] <author> E. Organick, </author> <title> The Multics System: An Examination of its Structure, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1972. </year>
Reference-contexts: File mapping is transparent under Multics: there is no distinction between accessing a file and accessing memory. All on-line information in the Multics system is organized into the file system as directories of symbolically named segments <ref> [Org72] </ref>. These segments include not only normal files, but also dynamic blocks of data created by a process, such as its heap segment. A process's address space is a collection of segments mapped into memory.
Reference: [OCD88] <author> J. Ousterhout, A. Cherenson, F. Douglis, M. Nelson and B. Welch, </author> <title> The Sprite Network Operating System, </title> <booktitle> Computer, </booktitle> <month> Feb. </month> <year> 1988, </year> <pages> 23-36. </pages>
Reference-contexts: Thus, random accesses to a large file will almost never reference data already in the I/O buffer. In contrast, physical user memory and the file cache may each be several megabytes. - 5 - of heterogeneous high-performance workstations [Nel88], <ref> [OCD88] </ref>. Sprite has a kernel interface and functionality similar to 4.3 BSD Unix. A single system image is provided, with files shared transparently among the machines in a Sprite cluster.
Reference: [Ous89] <author> J. Ousterhout, </author> <title> Why Aren't Operating Systems Getting Faster as Fast As Hardware?, </title> <type> WRL Technical Report TN-11, </type> <institution> Digital Western Research Laboratory, Palo Alto, California, </institution> <month> Oct. </month> <year> 1989. </year>
Reference: [RTY88] <author> R. Rashid, A. Tevanian, Jr., M. Young, D. Golub, R. Baron, D. Black, W. Bolosky and J. Chew, </author> <title> Machine-Independent Virtual Memory Management for Paged Uniprocessor and Multiprocessor Architectures, </title> <journal> IEEE Transactions on Computers 37, </journal> <month> 8 (Aug. </month> <year> 1988), </year> <pages> 896-908. </pages>
Reference-contexts: Mach permits user-defined network sharing semantics through the capabilities of an external memory pager. File mapping is provided by the Mach function map_fd, which is similar to mmap, but doesn't provide sharing. Mach provides flexible control of the virtual memory system through the abstractions of memory objects and pagers <ref> [RTY88] </ref>. A memory object is an abstract block of data which can be mapped into a process's address space. The data can be provided by a default paging routine or by an external user-level memory pager. <p> Another alternative is a tree-structured address map such as is used in Accent [FiR86]. This structure provides compact storage of a complex, sparse address space and allows fast indexing into the appropriate address map. However, it has a high implementation cost <ref> [RTY88] </ref>. When a segment is mapped into memory by mmap, the list of shared-segment control blocks is checked to see if the specified file is already mapped. If so, a pointer to the control block is added to the process's segment list. <p> In Sprite, page table data structures will be created for the entire validated region. In contrast, Mach uses an address map <ref> [RTY88] </ref>, which compactly describes the mapping of a contiguous virtual address range. The address map representation is much more compact than the page table representation for sparse address ranges. Other improvements could be made to the Sprite virtual memory system to make database support more efficient.
Reference: [Sel89] <author> M. Seltzer, </author> <title> Transaction Processing Under Unix, </title> <type> CS 286 class project report, </type> <institution> University of California, Berkeley, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: The address map representation is much more compact than the page table representation for sparse address ranges. Other improvements could be made to the Sprite virtual memory system to make database support more efficient. Some suggestions are given in [Sto81] and <ref> [Sel89] </ref>. One improvement would be to provide asynchronous I/O for paging in data.
Reference: [Seq86] <editor> DYNIX Programmer's Manual, </editor> <volume> Volume 1, </volume> <booktitle> Sequent Computer Systems, </booktitle> <publisher> Inc., </publisher> <year> 1986. </year>
Reference-contexts: This interface has been implemented in various operating systems derived from BSD Unix, such as SunOS [GMS87] and DYNIX <ref> [Seq86] </ref>. The Sprite implementation of shared memory and file mapping is based on the 4.2 BSD design. The functions implemented in Sprite are summarized in Table 1.
Reference: [Sto81] <author> M. Stonebraker, </author> <title> Operating System Support for Database Management, </title> <journal> Communications of the ACM 24, </journal> <month> 7 (July </month> <year> 1981), </year> <pages> 412-418. </pages>
Reference-contexts: Another application of shared memory is database memory management. Many database management systems (DBMS) organize memory as a user-level buffer pool <ref> [Sto81] </ref>. In this scheme, data blocks are controlled by a buffer pool manager process instead of being cached by the operating system. By organizing memory in this way, the DBMS can fetch data from the buffer without the overhead of a kernel call. <p> The address map representation is much more compact than the page table representation for sparse address ranges. Other improvements could be made to the Sprite virtual memory system to make database support more efficient. Some suggestions are given in <ref> [Sto81] </ref> and [Sel89]. One improvement would be to provide asynchronous I/O for paging in data.
Reference: [TRY87] <author> A. Tevanian, Jr., R. Rashid, M. Young, D. Golub, M. Thompson, W. Bolosky and R. Sanzi, </author> <title> A Unix Interface for Shared Memory and Memory Mapped Files Under Mach, </title> <booktitle> Proceedings of Summer USENIX, </booktitle> <month> June </month> <year> 1987, </year> <pages> 53-67. </pages>
Reference-contexts: Mach The Mach operating system has extensive, flexible support for shared memory and file mapping <ref> [TRY87] </ref>. One method of sharing is the concept of a thread, which is a lightweight process that shares its entire address space with other processes. Another method of sharing is inheritance, which allows a process to share regions of memory with its child processes. <p> The accuracy of the remotely cached measurements is not sufficient to indicate any performance differ ence except betweeen block I/O (getc) and the others. In <ref> [TRY87] </ref> it is suggested that mapped files can reduce the cost of file I/O since mapped files don't need to copy data from the kernel to user level. However, in the present Sprite implementation, this benefit of mapped files will only occur for remote file accesses, for reasons described below.
Reference: [YTR87] <author> M. Young, A. Tevanian, R. Rashid, D. Golub, J. Eppinger, J. Chew, W. Bolosky, D. Black and R. Baron, </author> <title> The Duality of Memory and Communication in the Implementation of a Multiprocessor Operating System, </title> <booktitle> Proc. Eleventh ACM Symposium on Operating Systems, Operating Systems Review 21, </booktitle> <address> 5 (Nov. </address> <year> 1987), </year> <pages> 63-76. - 31 </pages> - 
Reference-contexts: Consistent shared memory across a network can be implemented at user level by a pager that provides the same memory object to several different machines and makes sure the data is consistent among the machines <ref> [YTR87] </ref>. A different shared memory consistency policy can be obtained by modifying the pager. - 10 - 4.5. Sprite Prior to the addition of the 4.2 BSD mmap interface, Sprite had two limited sharing capabilities. Sprite permitted processes to share code segments, similar to Unix.
References-found: 21

