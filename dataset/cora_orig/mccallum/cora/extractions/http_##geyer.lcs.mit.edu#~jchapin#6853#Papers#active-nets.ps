URL: http://geyer.lcs.mit.edu/~jchapin/6853/Papers/active-nets.ps
Refering-URL: http://geyer.lcs.mit.edu/~jchapin/6853/readinglist.html
Root-URL: 
Title: ANTS: A Toolkit for Building and Dynamically Deploying Network Protocols  
Author: David J. Wetherall, John V. Guttag and David L. Tennenhouse 
Affiliation: Software Devices and Systems Group Laboratory for Computer Science Massachusetts Institute of Technology  
Date: April 1998  
Address: OPENARCH'98, San Francisco, CA,  
Note: Submitted to IEEE  
Abstract: We present a novel approach to building and deploying network protocols. The approach is based on mobile code, demand loading, and caching techniques. The architecture of our system allows new protocols to be dynamically deployed at both routers and end systems, without the need for coordination and without unwanted interaction between co-existing protocols. In this paper, we describe our architecture and its realization in a prototype implementation. To demonstrate how to exploit our architecture, we present two simple protocols that operate within our prototype to introduce multicast and mobility services into a network that initially lacks them. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. S. Alexanger et al. </author> <title> Active Bridging. </title> <booktitle> In SIG-COMM'97, </booktitle> <year> 1997. </year>
Reference-contexts: make a new one if necessary if (m == null) - m = new W_JAN (); n.put (group, sender, MCAST, m, IDLE); - // are we at an intermediate node? add: if (reverse != 0) - if (m.nodes == null) - // start a new list m.nodes = new Node <ref> [1] </ref>; m.nodes [0] = reverse; else // does it contain our info? for (int i = 0; i &lt; m.nodes.length; i++) if (m.nodes [i] == reverse) break add; // if not, add it int len = m.nodes.length; Node [] nn = new Node [len+1]; System.arraycopy (m.nodes,0,nn,0,len); nn [len] = reverse; m.nodes <p> Our approach offers a greater scope for customization by including intermediate nodes as well as end-systems. There are several new efforts investigating active networks. The Switchware project [16] is developing a programmable switch approach to explore the use of formal methods to assure network security. The Active Bridge <ref> [1] </ref> is their first example of such a programmable network element. The Netscript project [23] is addressing network management tasks (such as routing, packet analysis, and signaling) with a dataflow language and scripting agents that may be dynamically distributed.
Reference: [2] <author> A. Ballardie et al. </author> <title> Core based Trees. </title> <booktitle> In SIG-COMM'93, </booktitle> <year> 1993. </year>
Reference-contexts: If multiple senders are needed, then multiple distribution trees may be formed by having members subscribe to each of the 7 senders. Alternatively, the sender may be considered the root of a core-based tree <ref> [2] </ref>, with messages routed up the tree towards the root and down other branches. 4 Prototype Implementation Over the last several months we have been experimenting with a prototype implementation of the ants architecture.
Reference: [3] <author> S. Bhattacharjee et al. </author> <title> An Architecture for Active Networking. </title> <booktitle> In High Performance Networking (HPN'97), </booktitle> <year> 1997. </year>
Reference-contexts: The Liquid Software project [10] is developing technologies (such as the ultra-fast compilation of Java bytecodes) that will facilitate the use of mobile code in the network substrate. An effort at Georgia Tech <ref> [3] </ref> is applying ac tive networking concepts to congestion control and other areas.
Reference: [4] <author> R. Braden et al. </author> <title> Resource ReSerVation Protocol (RSVP) Version 1 Functional Specification. </title> <type> Internet Draft, </type> <month> Nov </month> <year> 1996. </year>
Reference-contexts: The slow evolution is attributable neither to lack of need nor to a lack of innovative ideas. In the case of IP, for example, changes are underway to better support multimedia applications, as well as to accommodate a larger number of potentially mobile hosts <ref> [6, 4, 5, 15] </ref>. Unfortunately, though agreement on the need for these changes was reached many years ago, they are still not fully deployed. The problem is that the current process of changing network protocols is both lengthy and difficult. It requires standardization, since internetworking protocols fl djw@lcs.mit.edu. http://www.sds.lcs.mit.edu/.
Reference: [5] <author> S. Deering and R. Hinden. </author> <title> Internet Protocol, Version 6 (IPv6) Specification. Request For Comments 1883, </title> <month> Dec </month> <year> 1995. </year>
Reference-contexts: The slow evolution is attributable neither to lack of need nor to a lack of innovative ideas. In the case of IP, for example, changes are underway to better support multimedia applications, as well as to accommodate a larger number of potentially mobile hosts <ref> [6, 4, 5, 15] </ref>. Unfortunately, though agreement on the need for these changes was reached many years ago, they are still not fully deployed. The problem is that the current process of changing network protocols is both lengthy and difficult. It requires standardization, since internetworking protocols fl djw@lcs.mit.edu. http://www.sds.lcs.mit.edu/.
Reference: [6] <author> S. E. Deering. </author> <title> Host Extensions for IP multicasting. Request For Comments 1112, </title> <month> Aug </month> <year> 1989. </year>
Reference-contexts: The slow evolution is attributable neither to lack of need nor to a lack of innovative ideas. In the case of IP, for example, changes are underway to better support multimedia applications, as well as to accommodate a larger number of potentially mobile hosts <ref> [6, 4, 5, 15] </ref>. Unfortunately, though agreement on the need for these changes was reached many years ago, they are still not fully deployed. The problem is that the current process of changing network protocols is both lengthy and difficult. It requires standardization, since internetworking protocols fl djw@lcs.mit.edu. http://www.sds.lcs.mit.edu/. <p> To facilitate shortcut routing, mobile updates may enter forwarding pointers at any node, and messages from other nodes will follow them like a trail of crumbs once their paths cross. 3.2 Multicast We introduce a basic Multicast protocol, resembling IP multicast <ref> [6] </ref>, composed of two cooperating capsule types 1 . One type of capsule is sent to subscribe to a group, and the other carries the multicast message itself. Applications that wish to receive messages sent to a given group by a particular sender periodically send Subscribe capsules towards the sender.
Reference: [7] <author> P. Deutsch and C. A. Grant. </author> <title> A Flexible Measurement Tool for Software Systems. </title> <booktitle> In Information Processing, </booktitle> <year> 1971. </year>
Reference-contexts: Processing time and link bandwidth are allocated by time and capsule quanta, respectively; node memory is allocated by cached objects, since caching converts memory into a renewable resource. We hope, however, that it will prove feasible to enforce static limits at nodes with a scheme similar to <ref> [7] </ref> or by using proof-carrying code techniques [13]. 2.3 Code Distribution The third component of our architecture is a code distribution system. Given a programmable infrastructure, a mechanism is needed for propagating program definitions to where they are needed.
Reference: [8] <author> G. Di Marzo et al. </author> <title> The Messenger Paradigm and its Impact on Distributed Systems. </title> <booktitle> In Workshop on Intelligent Computer Communication, </booktitle> <year> 1995. </year>
Reference-contexts: The most similar recent work we are aware of is the messenger paradigm <ref> [8] </ref> and work on flexible protocol stacks that preceded it [20]. Like our system, this work allows new protocols to be deployed. The intent, however, is to investigate the structuring of communicating systems, including distributed operating systems and intelligent agents.
Reference: [9] <author> R. Gilligan and E. Nordmark. </author> <title> Transition Mechanisms for IPv6 Hosts and Routers. Request For Comments 1933, </title> <month> April </month> <year> 1996. </year>
Reference-contexts: This is the nature of our approach-to introduce and use specialized protocols. To assist applications in selecting which protocol to use in the first place, a directory service may be used, much as the choice of IPv4 versus IPv6 is to be incorporated into the DNS <ref> [9] </ref>. Second, it is not necessary to confine mobile forwarding information to the edges of the network.
Reference: [10] <author> J. Hartman et al. </author> <title> Liquid Software: A New Paradigm for Networked Systems. </title> <type> Technical Report TR96-11, </type> <institution> Dept. of Computer Science, Univ. of Arizona, </institution> <year> 1996. </year>
Reference-contexts: The Active Bridge [1] is their first example of such a programmable network element. The Netscript project [23] is addressing network management tasks (such as routing, packet analysis, and signaling) with a dataflow language and scripting agents that may be dynamically distributed. The Liquid Software project <ref> [10] </ref> is developing technologies (such as the ultra-fast compilation of Java bytecodes) that will facilitate the use of mobile code in the network substrate. An effort at Georgia Tech [3] is applying ac tive networking concepts to congestion control and other areas.
Reference: [11] <author> N. C. Hutchinson and L. L. Peterson. </author> <title> The x-Kernel: An Architecture for Implementing Network Protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: Our architecture views the network as a distributed programming system by providing a programming language model for expressing new protocols in terms of operations at nodes. Compared with alternative systems in which new protocols may be formed by selecting from a library of components, e.g., the x-kernel <ref> [11] </ref>, ants provides the greater flexibility that accompanies a programming language and the convenience of dynamic deployment. In the next section of this paper, we present the ants protocol architecture. <p> The intent, however, is to investigate the structuring of communicating systems, including distributed operating systems and intelligent agents. As such, it lacks the network layer specializations, e.g., demand loading, that we have developed. Some modern protocol architectures have been configurable, as opposed to programmable. The x-kernel <ref> [11] </ref> provides a collection of micro-protocols from which protocols (e.g., RPC) can be synthesized. Configurable systems can further increase their flexibility by deferring the selection of components until runtime, and so the x-kernel supports the dynamic composition of micro-protocols on a per packet basis.
Reference: [12] <author> D. Murphy. </author> <title> Building an Active Node on the Internet. </title> <type> M.Eng Thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: We pay much larger penalties for an inefficient implementation of our runtime environment and for using an interpreter to execute capsule code. Experience with another implementation of the ants architecture <ref> [12] </ref> demonstrates that a more careful implementation of the runtime environment (especially with respect to memory management) can increase throughput by a factor of at least four. Using a better implementation of the Java runtime may make an even bigger difference, but we don't yet have any experience to cite. <p> With this experience, we are now building a new implementation, to be distributed in August of 1997, that pays greater attention to performance, security and resource management issues. Based on experience with a separate implementation <ref> [12] </ref>, we expect that throughput can be increased by a factor of at least four by restructuring our Java code, and further still by using a better Java runtime, e.g., one including just-in-time compilation.
Reference: [13] <author> G. Necula and P. Lee. </author> <title> Safe Kernel Extensions Without Run-Time Checking. </title> <booktitle> In 2nd Symp. on Operating System Design and Implementation, </booktitle> <year> 1996. </year>
Reference-contexts: We hope, however, that it will prove feasible to enforce static limits at nodes with a scheme similar to [7] or by using proof-carrying code techniques <ref> [13] </ref>. 2.3 Code Distribution The third component of our architecture is a code distribution system. Given a programmable infrastructure, a mechanism is needed for propagating program definitions to where they are needed.
Reference: [14] <author> C. Partridge. </author> <title> Late-Binding RPC: A Paradigm for Distributed Computation in a Gigabit Environment. </title> <type> PhD thesis, </type> <institution> Harvard University, </institution> <year> 1992. </year>
Reference-contexts: We speculate that this was because of difficulties with safety and efficiency, problems that may now be more tractable, given the recent advances in mobile code and operating system technology. End-to-end code shipping to improve performance has been studied in the context of RPC <ref> [17, 14] </ref>. Our approach offers a greater scope for customization by including intermediate nodes as well as end-systems. There are several new efforts investigating active networks. The Switchware project [16] is developing a programmable switch approach to explore the use of formal methods to assure network security.
Reference: [15] <author> C. Perkins, Ed. </author> <title> IP Mobility Support. Request For Comments 2002, </title> <month> Oct </month> <year> 1996. </year>
Reference-contexts: The slow evolution is attributable neither to lack of need nor to a lack of innovative ideas. In the case of IP, for example, changes are underway to better support multimedia applications, as well as to accommodate a larger number of potentially mobile hosts <ref> [6, 4, 5, 15] </ref>. Unfortunately, though agreement on the need for these changes was reached many years ago, they are still not fully deployed. The problem is that the current process of changing network protocols is both lengthy and difficult. It requires standardization, since internetworking protocols fl djw@lcs.mit.edu. http://www.sds.lcs.mit.edu/. <p> Despite the simplicity of this scheme, it provides the essential feature of mobility: hosts may be reached as they move without introducing another layer of addressing. There are also some interesting comparisons with Mobile IP <ref> [15] </ref>. First, unlike Mobile IP, a different protocol is used to reach mobile and non-mobile hosts. This is the nature of our approach-to introduce and use specialized protocols.
Reference: [16] <author> J. Smith et al. </author> <title> SwitchWare Accelerating Network Evolution. </title> <type> Technical Report MS-CIS-96-38, </type> <institution> CIS Dept., Univ. of Pennsylvannia, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: End-to-end code shipping to improve performance has been studied in the context of RPC [17, 14]. Our approach offers a greater scope for customization by including intermediate nodes as well as end-systems. There are several new efforts investigating active networks. The Switchware project <ref> [16] </ref> is developing a programmable switch approach to explore the use of formal methods to assure network security. The Active Bridge [1] is their first example of such a programmable network element.
Reference: [17] <author> J. W. Stamos and D. K. Gifford. </author> <title> Remote Evaluation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 537-565, </pages> <month> Oct </month> <year> 1990. </year>
Reference-contexts: We speculate that this was because of difficulties with safety and efficiency, problems that may now be more tractable, given the recent advances in mobile code and operating system technology. End-to-end code shipping to improve performance has been studied in the context of RPC <ref> [17, 14] </ref>. Our approach offers a greater scope for customization by including intermediate nodes as well as end-systems. There are several new efforts investigating active networks. The Switchware project [16] is developing a programmable switch approach to explore the use of formal methods to assure network security.
Reference: [18] <author> D. Tennenhouse et al. </author> <title> A Survey of Active Network Research. </title> <journal> IEEE Communications Magazine, </journal> <pages> pages 80-86, </pages> <month> Jan </month> <year> 1997. </year>
Reference-contexts: This paper presents a new approach to network protocol innovation that addresses all of these problems. The essence of our approach is to standardize a communication model (rather than individual communication protocols) that allows uncoordinated deployment of co-existing protocols. We have developed an active network <ref> [18, 19] </ref> toolkit, called ants, in which new protocols are automatically deployed at both intermediate nodes and end systems by using mobile code techniques. Our architecture views the network as a distributed programming system by providing a programming language model for expressing new protocols in terms of operations at nodes.
Reference: [19] <author> D. L. Tennenhouse and D. Wetherall. </author> <title> Towards an Active Network Architecture. </title> <booktitle> In Multimedia Computing and Networking 96, </booktitle> <year> 1996. </year>
Reference-contexts: This paper presents a new approach to network protocol innovation that addresses all of these problems. The essence of our approach is to standardize a communication model (rather than individual communication protocols) that allows uncoordinated deployment of co-existing protocols. We have developed an active network <ref> [18, 19] </ref> toolkit, called ants, in which new protocols are automatically deployed at both intermediate nodes and end systems by using mobile code techniques. Our architecture views the network as a distributed programming system by providing a programming language model for expressing new protocols in terms of operations at nodes.
Reference: [20] <author> C. Tschudin. </author> <title> Flexible Protocol Stacks. </title> <booktitle> In SIG-COMM'91, </booktitle> <year> 1991. </year>
Reference-contexts: The most similar recent work we are aware of is the messenger paradigm [8] and work on flexible protocol stacks that preceded it <ref> [20] </ref>. Like our system, this work allows new protocols to be deployed. The intent, however, is to investigate the structuring of communicating systems, including distributed operating systems and intelligent agents. As such, it lacks the network layer specializations, e.g., demand loading, that we have developed.
Reference: [21] <author> V. C. Van. </author> <title> A Defense Against Address Spoofing Using Active Networks. </title> <type> M.Eng Thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: We have used it to test and debug the Mobile and Multicast protocols discussed in this paper, as well as a high performance reliable multicast developed by Li Lehman and a TCP SYN-flooding defense protocol developed by Van Van <ref> [21] </ref>. We are now in the process of building a new implementation. The structure of the new implementation is quite similar to the one described here, but far more attention is being devoted to performance related issues.
Reference: [22] <author> D. J. Wetherall and D. L. Tennenhouse. </author> <title> The ACTIVE IP Option. </title> <booktitle> In 7th SIGOPS European Workshop, </booktitle> <year> 1996. </year>
Reference-contexts: They also supply the resources shared between protocols and enforce constraints on how these resources may be used as protocols are executed. We describe our node design along these two lines. Node Primitives We chose an initial set of primitives based on our experience with a predecessor system <ref> [22] </ref>. This work suggests that a relatively small set of primitives is sufficient to express a number of different and useful forwarding routines.
Reference: [23] <author> Y. Yemini and S. da Silva. </author> <title> Towards Programmable Networks. </title> <booktitle> In FIP/IEEE Intl. Workshop on Distributed Systems Operations and Management, </booktitle> <year> 1996. </year>
Reference-contexts: There are several new efforts investigating active networks. The Switchware project [16] is developing a programmable switch approach to explore the use of formal methods to assure network security. The Active Bridge [1] is their first example of such a programmable network element. The Netscript project <ref> [23] </ref> is addressing network management tasks (such as routing, packet analysis, and signaling) with a dataflow language and scripting agents that may be dynamically distributed.
Reference: [24] <author> J. Zander and R. Forchheimer. </author> <title> Softnet An Approach to High-Level Packet Communication. </title> <booktitle> In ARRL 2nd Computer Networking Conference, </booktitle> <year> 1983. </year> <month> 11 </month>
Reference-contexts: Although configurable systems are capable of expressing a range of protocols, their means of composition, e.g., layering, is less flexible than that of a programming language. The earliest programmable network based on mobile code that we are aware of is Softnet <ref> [24] </ref>, an experimental packet radio network constructed in the early 1980s. Its goal was similar to our own: to allow users to define their own high level services. As with our approach, packets were considered to be programs of a language, FORTH, and interpreted at nodes on arrival.
References-found: 24

