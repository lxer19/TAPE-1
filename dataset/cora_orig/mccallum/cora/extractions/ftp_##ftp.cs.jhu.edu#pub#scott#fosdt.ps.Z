URL: ftp://ftp.cs.jhu.edu/pub/scott/fosdt.ps.Z
Refering-URL: http://www.cs.jhu.edu/~scott/homepage/papers.html
Root-URL: http://www.cs.jhu.edu
Email: iam@cs.stanford.edu  scott@cs.jhu.edu  clt@sail.stanford.edu  
Title: From Operational Semantics to Domain Theory  
Author: Ian A. Mason Scott F. Smith Carolyn L. Talcott 
Note: Contents  
Affiliation: Stanford University  The Johns Hopkins University  Stanford University  
Abstract: This paper builds domain theoretic concepts upon an operational foundation. The basic operational theory consists of a single step reduction system from which an operational ordering and equivalence on programs are defined. The theory is then extended to include concepts from domain theory, including the notions of directed set, least upper bound, complete partial order, monotonicity, continuity, finite element, !-algebraicity, full abstraction, and least fixed point properties. We conclude by using these concepts to construct a (strongly) fully abstract continuous model for our language. In addition we generalize a result of Milner and prove the uniqueness of such models. 
Abstract-found: 1
Intro-found: 1
Reference: [Abadi et al., 1991] <author> Abadi, M., Pierce, B., and Plotkin, G. </author> <year> (1991). </year> <title> Faithful ideal models for recursive polymorphic types. </title> <journal> International Journal of Foundations of Computer Science, </journal> <volume> 2(1) </volume> <pages> 1-21. </pages>
Reference-contexts: The goal is to show &lt; s induces a CPO, but this does not follow directly. Next in section 4.4 we consider the structure of the finite expressions. We show that the finite elements are the image of syntactically definable projection functions, an idea taken from <ref> [Abadi et al., 1991] </ref>. In sections 4.5 and 4.6 we use the finite elements to show that &lt; s -directed sets (of &lt; -directed sets) have &lt; s -least upper bounds, and that the resulting CPO is !-algebraic. Furthermore, application is continuous. <p> Most importantly here, they will be used to show &lt; s is complete. Finite expressions are critical to a number of constructions, including the model construction <ref> [MacQueen et al., 1984, Abadi et al., 1991] </ref>. The following definition of finite expressions relies on the representation of limits by directed sets of expressions. <p> The idea of syntactically defined projection functions is found in <ref> [Abadi et al., 1991] </ref>, though the uses we put them to here are significantly different. 16 Definition 4.15 (Finite Projections n ) The projection functional , finite projections n , and infinite projection 1 are defined as follows. = x:y: if (isnat (x); if (iszero (x); 0; succ (y (pred (x))));
Reference: [Abramsky, 1990] <author> Abramsky, S. </author> <year> (1990). </year> <title> The lazy lambda calculus. </title> <booktitle> In Research Topics in Functional Programming, </booktitle> <pages> pages 65-116. </pages> <publisher> Addison-Wesley. </publisher> <pages> 33 </pages>
Reference-contexts: It also should be mentioned that for simple untyped functional languages like the one studied here, domain models may be altered by various means to give fully abstract models <ref> [Abramsky, 1990, Ong, 1988] </ref>. [Talcott, 1985] studies general notions of equivalence for languages based on the call-by-value lambda calculus, and develops several schemes for establishing properties of such relations. [Howe, 1989] proves congruence for a class of languages with a particular style of operational semantics. <p> 3.4. (vii) Follows directly from Theorems 3.4 and 3.5. 2 3.2 Other Notions of Ordering and Equivalence We briefly compare &lt; and &lt; ciu with some other characterizations found in the literature, in partic ular applicative approximation &lt; app of [Jim and Meyer, 1991] and applicative bisimulation &lt; bisim of <ref> [Abramsky, 1990] </ref>. The main difference centers on the fact that our R may be of the form v ( * ), while &lt; bisim have no such case in their definition. Here we show all notions are in fact equivalent.
Reference: [Bloom, 1990] <author> Bloom, B. </author> <year> (1990). </year> <note> Can LCF be topped? Information and Computation, 87 264-301. </note> <author> [deBakker and Scott, 1969] deBakker, J. W. and Scott, D. </author> <year> (1969). </year> <title> A theory of programs. </title> <note> unpublished Notes. </note>
Reference-contexts: This is known as the full abstraction problem. No such problem is encountered in a bottom-up approach as the structure is built using operational tools alone. A full discussion of full abstraction is outside the scope of this paper, see for instance <ref> [Stoughton, 1988, Bloom, 1990] </ref>. We study a variant of the untyped call-by-value lambda calculus enriched with arithmetic, pairing, and branching primitives. The syntax and semantics of our language is defined in section 2. <p> A number of properties are desired, including congruence and extensionality of = . Researchers that have developed methods to directly prove basic operational properties include [Milner, 1977], [Talcott, 1985], [Howe, 1989], <ref> [Bloom, 1990] </ref>, [Jim and Meyer, 1991], and [Mason and Talcott, 1991].
Reference: [Felleisen et al., 1987] <author> Felleisen, M., Friedman, D., and Kohlbecker, E. </author> <year> (1987). </year> <title> A syntactic theory of sequential control. </title> <journal> Theoretical Computer Science, </journal> <volume> 52 </volume> <pages> 205-237. </pages>
Reference-contexts: Note that bot is an expression, not a value. 2.2 Semantics The operational semantics of expressions is given by a reduction relation 7!, using the convenient notion of a reduction context (a.k.a. evaluation context) taken from <ref> [Felleisen et al., 1987] </ref>. C [*] denotes a context, an expression C with occurrences of holes "*". Definition 2.3 (Contexts C ) C = f*g + X+ N + X:C + n2N n ( z -| - We let C range over C .
Reference: [Howe, 1989] <author> Howe, D. J. </author> <year> (1989). </year> <title> Equality in lazy computation systems. </title> <booktitle> In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 198-203. </pages> <publisher> IEEE. </publisher>
Reference-contexts: A number of properties are desired, including congruence and extensionality of = . Researchers that have developed methods to directly prove basic operational properties include [Milner, 1977], [Talcott, 1985], <ref> [Howe, 1989] </ref>, [Bloom, 1990], [Jim and Meyer, 1991], and [Mason and Talcott, 1991]. <p> untyped functional languages like the one studied here, domain models may be altered by various means to give fully abstract models [Abramsky, 1990, Ong, 1988]. [Talcott, 1985] studies general notions of equivalence for languages based on the call-by-value lambda calculus, and develops several schemes for establishing properties of such relations. <ref> [Howe, 1989] </ref> proves congruence for a class of languages with a particular style of operational semantics. <p> [A oe ]; R [B oe ] E ; )(9b 2 B)(R [a oe ] o R [b oe ]) The main characterization we desire is, Theorem 4.6 (Set Ordering CIU) A &lt; s B , A &lt; ciu 12 We give a proof that synthesizes ideas from proofs in <ref> [Smith, 1992, Mason and Talcott, 1991, Howe, 1989] </ref>. We first give an informal overview of the proof. The ( ) ) direction is not difficult, since &lt; s has a smaller collection of contexts to distinguish expressions than &lt; s has. ( ( ) is the difficult direction.
Reference: [Hyland, 1976] <author> Hyland, J. M. E. </author> <year> (1976). </year> <title> A survey of some useful partial order relations on terms of the lambda calculus. </title> <editor> In Boehm, C., editor, </editor> <booktitle> Lambda Calculus and Computer Science Theory, volume 37 of Lecture Notes in Computer Science, </booktitle> <pages> pages 83-93. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: An earlier version of some of this work treated a call-by-name variant [Smith, 1992]. This work could be said to be a descendant of [Milner, 1977], and may ultimately traced back to results for the pure -calculus <ref> [Hyland, 1976, Wadsworth, 1976] </ref>. 2 The Syntax and Semantics In this paper, a simple untyped call-by-value functional language with numbers and pairing is studied.
Reference: [Igarashi, 1972] <author> Igarashi, S. </author> <year> (1972). </year> <title> Admissibility of fixed-point induction in first-order logic of typed theories. </title> <type> Technical Report Stan-CS-72-287, </type> <institution> Stanford University Computer Science Department. </institution>
Reference-contexts: definition of &lt; s ) and the above equivalences, the result is immediate. 2 It is a simple matter to extend this theorem to logical formulas in which statements C [fix (f )] &lt; C 0 [fix (f )] occur, although only certain admissible formulas admit a fixed-point induction principle <ref> [Paulson, 1987, Igarashi, 1972] </ref>. 4.4 Finite Expressions An important tool in the further development of the theory of &lt; and &lt; s are the finite expressions. Most importantly here, they will be used to show &lt; s is complete.
Reference: [Jim and Meyer, 1991] <author> Jim, T. and Meyer, A. </author> <year> (1991). </year> <title> Full abstraction and the context lemma. </title> <booktitle> In Theoretical Aspects of Computer Science, volume 526 of Lecture Notes in Computer Science, </booktitle> <pages> pages 131-151. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: A number of properties are desired, including congruence and extensionality of = . Researchers that have developed methods to directly prove basic operational properties include [Milner, 1977], [Talcott, 1985], [Howe, 1989], [Bloom, 1990], <ref> [Jim and Meyer, 1991] </ref>, and [Mason and Talcott, 1991]. <p> This schema succeeds in capturing many simple functional programming language features. <ref> [Jim and Meyer, 1991] </ref> present another schema. [Mason and Talcott, 1991] have proven respect of computation and congruence for more complex languages than the language presented here|the languages have continuations as first-class objects and a global state. <p> Proof: (i)-(vi) are direct by Theorem 3.4. (vii) Follows directly from Theorems 3.4 and 3.5. 2 3.2 Other Notions of Ordering and Equivalence We briefly compare &lt; and &lt; ciu with some other characterizations found in the literature, in partic ular applicative approximation &lt; app of <ref> [Jim and Meyer, 1991] </ref> and applicative bisimulation &lt; bisim of [Abramsky, 1990]. The main difference centers on the fact that our R may be of the form v ( * ), while &lt; bisim have no such case in their definition. Here we show all notions are in fact equivalent.
Reference: [MacQueen et al., 1984] <author> MacQueen, D. B., Plotkin, G., and Sethi, R. </author> <year> (1984). </year> <title> An ideal model of types. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages. </booktitle>
Reference-contexts: Most importantly here, they will be used to show &lt; s is complete. Finite expressions are critical to a number of constructions, including the model construction <ref> [MacQueen et al., 1984, Abadi et al., 1991] </ref>. The following definition of finite expressions relies on the representation of limits by directed sets of expressions.
Reference: [Manna, 1974] <author> Manna, Z. </author> <year> (1974). </year> <title> Mathematical Theory of Computation. </title> <publisher> McGraw-Hill. </publisher>
Reference-contexts: Thus, ffix (f )g &lt; s fx:ag, so fix (f ) &lt; x:a by Lemma 4.2 (iii). 2 One of the most useful induction principles for proving facts about fixed points is Scott fixed-point induction ([deBakker and Scott, 1969]; see also <ref> [Manna, 1974] </ref>). The justification of fixed-point induction necessitates functions be continuous in a domain. All that is needed to justify fixed-point induction here is Lemma 4.11.
Reference: [Mason and Talcott, 1991] <author> Mason, I. A. and Talcott, C. L. </author> <year> (1991). </year> <title> Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 287-327. </pages>
Reference-contexts: A number of properties are desired, including congruence and extensionality of = . Researchers that have developed methods to directly prove basic operational properties include [Milner, 1977], [Talcott, 1985], [Howe, 1989], [Bloom, 1990], [Jim and Meyer, 1991], and <ref> [Mason and Talcott, 1991] </ref>. <p> This schema succeeds in capturing many simple functional programming language features. [Jim and Meyer, 1991] present another schema. <ref> [Mason and Talcott, 1991] </ref> have proven respect of computation and congruence for more complex languages than the language presented here|the languages have continuations as first-class objects and a global state. <p> What is then gained is not a different notion of equivalence, but simpler methods for establishing equivalence. We define such an alternate notion in this paper, restricting contexts to be Closed Instances of all Uses of an expression. This equivalence is thus called CIU equivalence, = ciu , following <ref> [Mason and Talcott, 1991] </ref>. a = ciu b means a and b behave identically when closed (the closed instances part) and placed in any reduction context R (the uses part). <p> [A oe ]; R [B oe ] E ; )(9b 2 B)(R [a oe ] o R [b oe ]) The main characterization we desire is, Theorem 4.6 (Set Ordering CIU) A &lt; s B , A &lt; ciu 12 We give a proof that synthesizes ideas from proofs in <ref> [Smith, 1992, Mason and Talcott, 1991, Howe, 1989] </ref>. We first give an informal overview of the proof. The ( ) ) direction is not difficult, since &lt; s has a smaller collection of contexts to distinguish expressions than &lt; s has. ( ( ) is the difficult direction. <p> The basic theory of &lt; s strongly parallels the basic theory of &lt; developed within (in fact the proofs for &lt; s are very minor generalizations on proofs &lt; , see sections 3.1 and 4.2), and for instance in <ref> [Mason and Talcott, 1991] </ref> it is shown how a basic theory of &lt; may be developed for languages with state. However, it is unclear if the notion of finite expression will generalize to languages with features such as state and continuations, or even to languages without recognizers ispr, isnat.
Reference: [Meyer, 1982] <author> Meyer, A. R. </author> <year> (1982). </year> <title> What is a model of the lambda calculus? Information and Computation, </title> <booktitle> 52 </booktitle> <pages> 87-122. </pages>
Reference-contexts: Furthermore, application is continuous. In section 5 we study the general notion of model of a functional call-by-value programming language with numbers and pairing. Our approach builds on the work of Milner [Milner, 1977] and Meyer <ref> [Meyer, 1982] </ref>. We begin by defining the notion of an FLD domain (functional programming language domain). These are reflexive domains with an extensional partial ordering v reflecting degrees of definedness. Next we define a notion of FLEM (functional language environment model) for interpreting expressions in an FLD domain. <p> Our approach builds on the work of Milner [Milner, 1977] and Meyer <ref> [Meyer, 1982] </ref>. We begin by defining the notion of an FLD domain (functional programming language domain). These are reflexive domains with an extensional partial ordering v reflecting degrees of definedness. Next we define a notion of FLEM (functional language environment model) for interpreting expressions in an FLD domain.
Reference: [Milner, 1977] <author> Milner, R. </author> <year> (1977). </year> <title> Fully abstract models of typed -calculi. </title> <journal> Theoretical Computer Science, </journal> <volume> 4 </volume> <pages> 1-22. </pages>
Reference-contexts: In section 3.1 we give an alternate characterization of &lt; as equivalent to the ordering &lt; . This characterization is an analogue of Milner's context lemma <ref> [Milner, 1977] </ref> and is used to prove a number of properties such as extensionality of &lt; . &lt; however fails to satisfy several basic domain theoretic requirements. <p> Furthermore, application is continuous. In section 5 we study the general notion of model of a functional call-by-value programming language with numbers and pairing. Our approach builds on the work of Milner <ref> [Milner, 1977] </ref> and Meyer [Meyer, 1982]. We begin by defining the notion of an FLD domain (functional programming language domain). These are reflexive domains with an extensional partial ordering v reflecting degrees of definedness. <p> Continuity is thus an important property for non-standard models only. We then construct a model, using &lt; s , that is (strongly) fully abstract, continuous, and !-algebraic, using the results of section 4.6. Following Milner <ref> [Milner, 1977] </ref> we show all such models are isomorphic. 1.1 Related Work There is a considerable corpus of work developing basic operational theories found in the literature, though mostly for call-by-name languages. A number of properties are desired, including congruence and extensionality of = . <p> A number of properties are desired, including congruence and extensionality of = . Researchers that have developed methods to directly prove basic operational properties include <ref> [Milner, 1977] </ref>, [Talcott, 1985], [Howe, 1989], [Bloom, 1990], [Jim and Meyer, 1991], and [Mason and Talcott, 1991]. <p> This work gives anecdotal evidence that the results presented herein may apply to more complex languages, a subject for future work. An earlier version of some of this work treated a call-by-name variant [Smith, 1992]. This work could be said to be a descendant of <ref> [Milner, 1977] </ref>, and may ultimately traced back to results for the pure -calculus [Hyland, 1976, Wadsworth, 1976]. 2 The Syntax and Semantics In this paper, a simple untyped call-by-value functional language with numbers and pairing is studied. <p> Our approach builds on the work of Milner <ref> [Milner, 1977] </ref> and Meyer [Meyer, 1982]. We begin by defining the notion of an FLD domain (functional programming language domain). These are reflexive domains with an extensional partial ordering v reflecting degrees of definedness. <p> We then show that all standard, fully abstract models are isomorphic, and thus no such model is continuous. We then construct a model, using &lt; s , that is strongly fully abstract, continuous, and !-algebraic, using the results of section 4.6. Following Milner <ref> [Milner, 1977] </ref> we show all such models are isomorphic. 5.1 The Notion of Model We use the usual lifting operator, D ? = D [ f?g, adding distinguished element ? to arbitrary set D. <p> For the reverse implication, assume that [[A]] v [[B]] and choose a 2 A, OE 2 F def such that OE ([[a]]) 6=?. Thus OE ([[A]]) 6=?, and consequently OE ([[B]]) 6=?. This last fact also implies OE ([[b]]) 6=? for some b 2 B. 2 25 In <ref> [Milner, 1977] </ref> a straightforward induction argument establishes that, in the simply typed lambda calculus, a fully abstract, continuous model with !-algebraic base types that contains the finite projections is also !-algebraic. In the untyped framework, whether or not an analogous result remains true is an open question. <p> That M s 2 CPO follows directly from Lemma 4.34. M s 2 CON is a consequence of Lemma 4.37. 2 5.5 Milner's Uniqueness Theorem In this section we prove an untyped version of Milner's uniqueness theorem <ref> [Milner, 1977] </ref>: all complete, continuous, fully abstract models of the typed lambda calculus that articulate their base domains are isomorphic. In the untyped framework we prove that all complete, continuous, strongly fully abstract models are isomorphic.
Reference: [Ong, 1988] <author> Ong, C.-H. L. </author> <year> (1988). </year> <title> Fully abstract models of the lazy lambda calculus. </title> <booktitle> In Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 368-376. </pages>
Reference-contexts: It also should be mentioned that for simple untyped functional languages like the one studied here, domain models may be altered by various means to give fully abstract models <ref> [Abramsky, 1990, Ong, 1988] </ref>. [Talcott, 1985] studies general notions of equivalence for languages based on the call-by-value lambda calculus, and develops several schemes for establishing properties of such relations. [Howe, 1989] proves congruence for a class of languages with a particular style of operational semantics.
Reference: [Paulson, 1987] <author> Paulson, L. C. </author> <year> (1987). </year> <title> Logic and Computation: Interactive Proof with Cambridge LCF. </title> <publisher> Cambridge. </publisher>
Reference-contexts: definition of &lt; s ) and the above equivalences, the result is immediate. 2 It is a simple matter to extend this theorem to logical formulas in which statements C [fix (f )] &lt; C 0 [fix (f )] occur, although only certain admissible formulas admit a fixed-point induction principle <ref> [Paulson, 1987, Igarashi, 1972] </ref>. 4.4 Finite Expressions An important tool in the further development of the theory of &lt; and &lt; s are the finite expressions. Most importantly here, they will be used to show &lt; s is complete.
Reference: [Smith, 1992] <author> Smith, S. F. </author> <year> (1992). </year> <title> From operational to denotational semantics. </title> <booktitle> In MFPS 1991, volume 598 of Lecture notes in Computer Science, </booktitle> <pages> pages 54-76. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This work gives anecdotal evidence that the results presented herein may apply to more complex languages, a subject for future work. An earlier version of some of this work treated a call-by-name variant <ref> [Smith, 1992] </ref>. This work could be said to be a descendant of [Milner, 1977], and may ultimately traced back to results for the pure -calculus [Hyland, 1976, Wadsworth, 1976]. 2 The Syntax and Semantics In this paper, a simple untyped call-by-value functional language with numbers and pairing is studied. <p> Here we show all notions are in fact equivalent. The distinction between call-by-name and call-by-value becomes important here; in a call-by-name reduction system <ref> [Smith, 1992] </ref>, arguments to functions are not first computed to a value, and v ( * ) would thus not be included amongst the reduction contexts. Without this case &lt; &lt; bisim / &lt; app are of a very similar character and may be easily shown equivalent. <p> [A oe ]; R [B oe ] E ; )(9b 2 B)(R [a oe ] o R [b oe ]) The main characterization we desire is, Theorem 4.6 (Set Ordering CIU) A &lt; s B , A &lt; ciu 12 We give a proof that synthesizes ideas from proofs in <ref> [Smith, 1992, Mason and Talcott, 1991, Howe, 1989] </ref>. We first give an informal overview of the proof. The ( ) ) direction is not difficult, since &lt; s has a smaller collection of contexts to distinguish expressions than &lt; s has. ( ( ) is the difficult direction.
Reference: [Stoughton, 1988] <author> Stoughton, A. </author> <year> (1988). </year> <title> Fully abstract models of programming languages. </title> <booktitle> Research Notes in theoretical computer science. </booktitle> <publisher> Pitman. </publisher>
Reference-contexts: This is known as the full abstraction problem. No such problem is encountered in a bottom-up approach as the structure is built using operational tools alone. A full discussion of full abstraction is outside the scope of this paper, see for instance <ref> [Stoughton, 1988, Bloom, 1990] </ref>. We study a variant of the untyped call-by-value lambda calculus enriched with arithmetic, pairing, and branching primitives. The syntax and semantics of our language is defined in section 2.
Reference: [Talcott, 1985] <author> Talcott, C. L. </author> <year> (1985). </year> <title> The essence of Rum: A theory of the intensional and extensional aspects of Lisp-type computation. </title> <type> PhD thesis, </type> <institution> Stanford University. </institution>
Reference-contexts: A number of properties are desired, including congruence and extensionality of = . Researchers that have developed methods to directly prove basic operational properties include [Milner, 1977], <ref> [Talcott, 1985] </ref>, [Howe, 1989], [Bloom, 1990], [Jim and Meyer, 1991], and [Mason and Talcott, 1991]. It also should be mentioned that for simple untyped functional languages like the one studied here, domain models may be altered by various means to give fully abstract models [Abramsky, 1990, Ong, 1988]. [Talcott, 1985] studies <p> [Milner, 1977], <ref> [Talcott, 1985] </ref>, [Howe, 1989], [Bloom, 1990], [Jim and Meyer, 1991], and [Mason and Talcott, 1991]. It also should be mentioned that for simple untyped functional languages like the one studied here, domain models may be altered by various means to give fully abstract models [Abramsky, 1990, Ong, 1988]. [Talcott, 1985] studies general notions of equivalence for languages based on the call-by-value lambda calculus, and develops several schemes for establishing properties of such relations. [Howe, 1989] proves congruence for a class of languages with a particular style of operational semantics.
Reference: [Wadsworth, 1976] <author> Wadsworth, C. </author> <year> (1976). </year> <title> Relation between computational and denotational properties for Scott's D 1 models of the -calculus. </title> <journal> SIAM J Computing. </journal> <volume> 34 </volume>
Reference-contexts: An earlier version of some of this work treated a call-by-name variant [Smith, 1992]. This work could be said to be a descendant of [Milner, 1977], and may ultimately traced back to results for the pure -calculus <ref> [Hyland, 1976, Wadsworth, 1976] </ref>. 2 The Syntax and Semantics In this paper, a simple untyped call-by-value functional language with numbers and pairing is studied.
References-found: 19

