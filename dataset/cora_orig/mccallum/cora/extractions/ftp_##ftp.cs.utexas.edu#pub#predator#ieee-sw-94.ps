URL: ftp://ftp.cs.utexas.edu/pub/predator/ieee-sw-94.ps
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: http://www.cs.utexas.edu
Title: Achieving Reuse With Software System Generators  
Author: Don Batory, Sankar Dasari, Bart Geraci, Vivek Singhal, Marty Sirkin, and Jeff Thomas 
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas  
Abstract: A key problem in software engineering is building complex software systems economically. We believe that domain-specific software system generators is a promising technology for attacking this problem. Generators are realizations of domain models that explain how software systems in a target domain can be assembled from previously written components. Thus, generators require significant problems in software reuse to be solved. In this paper, we review a related set of projects that we have undertaken to understand better the unusual software design techniques that are required and to evaluate the productivity and performance potentials of software system generators.
Abstract-found: 1
Intro-found: 1
Reference: [ACM91] <editor> ACM. </editor> <title> Next generation database systems. </title> <journal> Communications of the ACM, </journal> <volume> 34(10), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: Readers may recognize cursors and containers as well-established concepts in databases [Kor91]; our earlier work on Genesis and contemporary work in object-oriented databases strongly inuenced our choice of these abstractions <ref> [ACM91] </ref>. Figure 3a illustrates the basic ideas; a container with eight elements is shown, with a cursor that references one of these objects. DS is the realm of components that implement the container-cursor abstractions. <p> Examples are given in Section 5. In addition to the container-cursor-element abstractions, Predator also provides link abstractions. A link is a relationship between elements of (possibly distinct) containers. Well-known implementations of links are relational join algorithms and pointer-based methods (e.g., ring lists) used in object-oriented databases <ref> [Kor91, ACM91] </ref>. We will not elaborate more on links or the realm of components that implement them. The basic idea that we wish to convey is that our domain model relies on database-like interface to data structures.
Reference: [Bar93] <author> John Barnes. </author> <title> Introducing Ada 9X. </title> <type> Technical Report, </type> <institution> Intermetrics Inc., </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Third, alteration and experimentation with different implementations is facilitated by component compositions. 6 Related work We noted in earlier sections that the basic ideas of GenVoca can be recognized in the work of many other researchers. Component definition constructs are provided by languages like Ada 9X <ref> [Bar93] </ref> and Modula 3 [Car89]. Realms and symmetric components can be seen in Volpanos STS [Vol85]. Goguen provides a model for parameterized programming in the languages LIL [Gog86] and FOOPS [Gog93]; the functional language ML [Mil90] takes another approach to parameterization. Software system generators are related to application generators.
Reference: [Bat88] <author> Don Batory. </author> <title> Concepts for a DBMS synthesizer. </title> <booktitle> In Proceedings of ACM Principles of Database Systems Conference, </booktitle> <year> 1988. </year> <note> Also in Rubin Prieto-Dmaz and Guillermo Arango, </note> <editor> editors, </editor> <title> Domain Analysis and Software Systems Modeling. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: McIlroy called this goal the industrialization of software [McI68]. Our research has focused on domain-specific software system generators. Our early work was Genesis, the first generator for database management systems (DBMSs) <ref> [Bat88, Bat92a] </ref>. Genesis demonstrated that complex and customized DBMSs could be synthesized in minutes by composing prefabricated and plug-compatible components. The DBMSs that were produced were of university-quality; they were untuned, but substantial in size (i.e., exceeding 60K lines of C code). <p> This took two days for us to write and debug a persistent DS component; to swap it with the transient DS component took minutes. We compared persistent-RL to DATEX, the persistent-memory version of LEAPS [Bra93]. DATEX was a reimplementation of LEAPS using the Genesis file manager <ref> [Bat88] </ref> and took many months to build. Interviewing members of the LEAPS team suggests that Predator offers a factor of 3 in productivity that leads to a more extensible product.
Reference: [Bat92a] <author> Don Batory and Jim Barnett, DaTE: </author> <title> the Genesis DBMS software layout editor. </title> <editor> In Pericles Loucopoulos and Roberto Zicari, editors, </editor> <title> Conceptual Modeling, Databases, and CASE: An Integrated View of Information Systems Development. </title> <publisher> Wiley, </publisher> <year> 1992. </year>
Reference-contexts: McIlroy called this goal the industrialization of software [McI68]. Our research has focused on domain-specific software system generators. Our early work was Genesis, the first generator for database management systems (DBMSs) <ref> [Bat88, Bat92a] </ref>. Genesis demonstrated that complex and customized DBMSs could be synthesized in minutes by composing prefabricated and plug-compatible components. The DBMSs that were produced were of university-quality; they were untuned, but substantial in size (i.e., exceeding 60K lines of C code).
Reference: [Bat92b] <author> D. Batory and S.W. OMalley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(4) </volume> <pages> 355-398, </pages> <month> October </month> <year> 1992. </year> <month> 11 </month>
Reference-contexts: Simple forms of parameterization, i.e., constant and type parameters, are necessary but not sufficient for software system generators. Components must also be able to import other components as parameters [Gog86, Tra93]. These lessons on software design have been captured in GenVoca <ref> [Bat92b] </ref>. It is a domain-independent model for defining families of hierarchical systems as compositions of reusable components. From our experience, models of software design are best understood when programming languages provide direct support for model constructs.
Reference: [Bat92c] <author> Don Batory, Vivek Singhal, and Marty Sirkin. </author> <title> Implementing a domain model for data structures. </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <volume> 2(3) </volume> <pages> 375-402, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: A sizable fraction of P2 implements features that will be eventually provided by P++. P++ will be the platform for our future development efforts. Further details on the architecture and optimizations of these prototypes is given in <ref> [Bat92c, Sin93, Sir93] </ref>. 7 5 Results For any generator to be practical, it must satisfy two requirements: (1) use of the generator should yield significant productivity gains, and (2) the performance of generated code must be comparable to that of handwritten code.
Reference: [Bat93a] <author> Don Batory, Vivek Singhal, Marty Sirkin, and Jeff Thomas. </author> <title> Scalable software libraries. </title> <booktitle> In Proceedings of the ACM SIGSOFT 93: Symposium on the Foundations of Software Engineering, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: By changing DS component compositions, we were able to alter the data structure implementations of the Predator spellchecker immediately. In contrast, substantial effort was needed to recode spell-checkers to use different Booch or libg++ components. Details of these experiments are presented in <ref> [Bat93a] </ref>. We learned three valuable lessons from these experiments. First, it is possible to generate code for simple data structures that is comparable in performance to hand-crafted and hand-optimized code. Second, current template libraries are not designed to maximize programmer productivity. Every template library consists of families of related components.
Reference: [Bat93b] <author> Don Batory, Lou Coglianese, Mark Goodwin, and Steve Shafer. </author> <title> Creating reference architectures: an example from avionics. </title> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: used in independently-conceived generators for the domains of network protocols [Oma92], data manipulation languages [Vil94], distributed file sys This research was supported in part by grants from the University of Texas Applied Research Laboratories, Schlumberger, and Digital Equipment Corporation. 2 tems [Hei93], host-at-sea buoy systems [Wei90], and real-time avionics software <ref> [Bat93b] </ref>. Thus it seems worthwhile to factor out the common, domain-independent ideas that underlie different software system generators, and to build tools and develop design techniques that support these particular methods of software organization and construction.
Reference: [Boo87] <author> Grady Booch. </author> <title> Software Components with Ada, </title> <address> Benjamin/Cummings, </address> <year> 1987. </year>
Reference-contexts: Some of our findings on these topics are presented in the following sections. 5.1 Generators versus class libraries Class (or template) libraries are a popular means of boosting programmer productivity and reducing the time and cost of software development. The Booch Components <ref> [Boo87] </ref>, libg++ [Lea88], NIHCL [Gor90], and COOL [Fon90] are examples of such libraries. A large fraction (i.e., over 80%) of these libraries is devoted to components for generic data structures (e.g., lists, trees, queues, etc.). These components offered a prime opportunity for evaluating Predator.
Reference: [Bra92] <author> D. A. Brant, T. Grose, B. Lofaso, and D. P. Miranker. </author> <title> Effects of database size on rule system performance: five case studies. </title> <booktitle> Proceedings of the International Conference on Very Large Data Bases, </booktitle> <year> 1992. </year>
Reference: [Bra93] <author> David Brant and Dan Miranker. </author> <title> Index support for rule activation. </title> <booktitle> In Proceedings of 1993 ACM SIGMOD, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: This took two days for us to write and debug a persistent DS component; to swap it with the transient DS component took minutes. We compared persistent-RL to DATEX, the persistent-memory version of LEAPS <ref> [Bra93] </ref>. DATEX was a reimplementation of LEAPS using the Genesis file manager [Bat88] and took many months to build. Interviewing members of the LEAPS team suggests that Predator offers a factor of 3 in productivity that leads to a more extensible product.
Reference: [Car89] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <type> Modula-3 report (revised). Technical Report 52, </type> <institution> Systems Research Center, Digital Equipment Corporation, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: Component definition constructs are provided by languages like Ada 9X [Bar93] and Modula 3 <ref> [Car89] </ref>. Realms and symmetric components can be seen in Volpanos STS [Vol85]. Goguen provides a model for parameterized programming in the languages LIL [Gog86] and FOOPS [Gog93]; the functional language ML [Mil90] takes another approach to parameterization. Software system generators are related to application generators.
Reference: [Cur88] <author> Bill Curtis, Herb Krasner, and Neil Iscoe. </author> <title> A field study of the software design process for large systems. </title> <journal> Communications of the ACM, </journal> <volume> 31(11), </volume> <month> November </month> <year> 1988. </year>
Reference-contexts: First, creating a software generator for any target domain requires a thorough understanding of that domain and how software in that domain has been built. Acquiring domain expertise in order to formulate a realistic domain model requires a considerable investment on the part of reuse researchers <ref> [Cur88] </ref>. Second, it is not sufficient to propose a domain model; the model must be validated through extensive pro-totyping. We estimate that building a software system generator requires 50% to 100% more effort than building a single system.
Reference: [Fon90] <author> M. Fontana, L. Oren, and M. Neath. </author> <title> COOL: C++ object-oriented library. </title> <institution> Texas Instruments, </institution> <year> 1990. </year>
Reference-contexts: Some of our findings on these topics are presented in the following sections. 5.1 Generators versus class libraries Class (or template) libraries are a popular means of boosting programmer productivity and reducing the time and cost of software development. The Booch Components [Boo87], libg++ [Lea88], NIHCL [Gor90], and COOL <ref> [Fon90] </ref> are examples of such libraries. A large fraction (i.e., over 80%) of these libraries is devoted to components for generic data structures (e.g., lists, trees, queues, etc.). These components offered a prime opportunity for evaluating Predator.
Reference: [Gog86] <author> Joseph Goguen. </author> <title> Reusing and interconnecting software components. </title> <journal> IEEE Computer, </journal> <volume> 19(2) </volume> <pages> 16-28, </pages> <month> February </month> <year> 1986. </year> <note> Also in Rubin Prieto-Dmaz and Guillermo Arango, </note> <editor> editors, </editor> <title> Domain Analysis and Software Systems Modeling. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Component composition and customization is achieved through parameterization. Parameterization is an easy-to-understand model for combining and customizing components. Simple forms of parameterization, i.e., constant and type parameters, are necessary but not sufficient for software system generators. Components must also be able to import other components as parameters <ref> [Gog86, Tra93] </ref>. These lessons on software design have been captured in GenVoca [Bat92b]. It is a domain-independent model for defining families of hierarchical systems as compositions of reusable components. From our experience, models of software design are best understood when programming languages provide direct support for model constructs. <p> Component definition constructs are provided by languages like Ada 9X [Bar93] and Modula 3 [Car89]. Realms and symmetric components can be seen in Volpanos STS [Vol85]. Goguen provides a model for parameterized programming in the languages LIL <ref> [Gog86] </ref> and FOOPS [Gog93]; the functional language ML [Mil90] takes another approach to parameterization. Software system generators are related to application generators. Many application generators provide a domain-specific programming language, and include either an interpreter or compiler for that language [Kru92].
Reference: [Gog93] <author> Joseph Goguen and Adolfo Socorro. </author> <title> Module composition and system design for the object paradigm. </title> <type> Technical Report, </type> <institution> Programming Research Group, Oxford University Computing Laboratory, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Component definition constructs are provided by languages like Ada 9X [Bar93] and Modula 3 [Car89]. Realms and symmetric components can be seen in Volpanos STS [Vol85]. Goguen provides a model for parameterized programming in the languages LIL [Gog86] and FOOPS <ref> [Gog93] </ref>; the functional language ML [Mil90] takes another approach to parameterization. Software system generators are related to application generators. Many application generators provide a domain-specific programming language, and include either an interpreter or compiler for that language [Kru92].
Reference: [Gor90] <author> K. Gorlen, S. Orlow, and P. Plexico. </author> <title> Data Abstraction and Object-Oriented Programming in C++, </title> <publisher> John Wiley, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Some of our findings on these topics are presented in the following sections. 5.1 Generators versus class libraries Class (or template) libraries are a popular means of boosting programmer productivity and reducing the time and cost of software development. The Booch Components [Boo87], libg++ [Lea88], NIHCL <ref> [Gor90] </ref>, and COOL [Fon90] are examples of such libraries. A large fraction (i.e., over 80%) of these libraries is devoted to components for generic data structures (e.g., lists, trees, queues, etc.). These components offered a prime opportunity for evaluating Predator.
Reference: [Hei93] <author> John Heidemann and Gerald Popek. </author> <title> File system development with stackable layers. </title> <journal> ACM Transactions on Computer Systems, </journal> <note> to appear. Also in Technical Report CSD-930019, </note> <institution> Department of Computer Science, University of California, </institution> <address> Los Angeles, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: been noted and virtually identical software organizations have been used in independently-conceived generators for the domains of network protocols [Oma92], data manipulation languages [Vil94], distributed file sys This research was supported in part by grants from the University of Texas Applied Research Laboratories, Schlumberger, and Digital Equipment Corporation. 2 tems <ref> [Hei93] </ref>, host-at-sea buoy systems [Wei90], and real-time avionics software [Bat93b]. Thus it seems worthwhile to factor out the common, domain-independent ideas that underlie different software system generators, and to build tools and develop design techniques that support these particular methods of software organization and construction.
Reference: [Joh88] <author> R. E. Johnson and B. Foote. </author> <title> Designing reusable classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <month> June/July </month> <year> 1988. </year>
Reference-contexts: It is too unwieldy to construct a large software system by selecting and assembling hundreds or thousands of functions and classes from a reuse library. Instead, larger units of software encapsulation are needed <ref> [Joh88] </ref>. Components import and export standardized interfaces. The key to software system synthesis is composition. Composition is much easier when component interfaces correspond to fundamental abstractions of the target domain and these interfaces have been standardized. Standardization encourages functionally similar components to be plug-compatible and interchangeable.
Reference: [Kor91] <author> Hank Korth and Avi Silberschatz. </author> <title> Database System Concepts, </title> <publisher> McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: Elements of a container are enclosed by the container and can be referenced and modified only through run-time objects called cursors. Readers may recognize cursors and containers as well-established concepts in databases <ref> [Kor91] </ref>; our earlier work on Genesis and contemporary work in object-oriented databases strongly inuenced our choice of these abstractions [ACM91]. Figure 3a illustrates the basic ideas; a container with eight elements is shown, with a cursor that references one of these objects. <p> Examples are given in Section 5. In addition to the container-cursor-element abstractions, Predator also provides link abstractions. A link is a relationship between elements of (possibly distinct) containers. Well-known implementations of links are relational join algorithms and pointer-based methods (e.g., ring lists) used in object-oriented databases <ref> [Kor91, ACM91] </ref>. We will not elaborate more on links or the realm of components that implement them. The basic idea that we wish to convey is that our domain model relies on database-like interface to data structures.
Reference: [Kru92] <author> Charles Krueger. </author> <title> Software reuse. </title> <journal> ACM Computing Surveys, </journal> <month> June </month> <year> 1992. </year>
Reference-contexts: Software system generators are related to application generators. Many application generators provide a domain-specific programming language, and include either an interpreter or compiler for that language <ref> [Kru92] </ref>. Well-known examples of application generators include Lex, Yacc, VisiCalc, Mathematica, and so-called fourth generation languages (4GLs). The reuse advantages of application generators are well-known, affording gains in productivity over general-purpose programming languages for constructing families of related programs. <p> The reuse advantages of application generators are well-known, affording gains in productivity over general-purpose programming languages for constructing families of related programs. The disadvantages of application generators are (1) limited availability, (2) lack of appropriate functionality, or (3) poor performance <ref> [Kru92] </ref>. Software system generators provide the advantages of application generators while addressing their disadvantages.
Reference: [Lea88] <author> Doug Lea. libg++, </author> <title> the GNU C++ library. </title> <booktitle> In Proceedings of the USENIX C++ Conference, </booktitle> <year> 1988. </year>
Reference-contexts: Some of our findings on these topics are presented in the following sections. 5.1 Generators versus class libraries Class (or template) libraries are a popular means of boosting programmer productivity and reducing the time and cost of software development. The Booch Components [Boo87], libg++ <ref> [Lea88] </ref>, NIHCL [Gor90], and COOL [Fon90] are examples of such libraries. A large fraction (i.e., over 80%) of these libraries is devoted to components for generic data structures (e.g., lists, trees, queues, etc.). These components offered a prime opportunity for evaluating Predator.
Reference: [McI68] <author> M. D. McIlroy. </author> <title> Mass produced software components. </title> <editor> In Peter Naur and Brian Randell, editors, </editor> <booktitle> Software Engineering: Report on a Conference Sponsored by the NATO Science Committee, NATO Scientific Affairs Division, </booktitle> <month> October </month> <year> 1968. </year> <month> 12 </month>
Reference-contexts: The primary goal of generators is to eliminate the mundane aspects of software construction and to permit the expenditure of proportionally more effort on the critical parts of target systems. McIlroy called this goal the industrialization of software <ref> [McI68] </ref>. Our research has focused on domain-specific software system generators. Our early work was Genesis, the first generator for database management systems (DBMSs) [Bat88, Bat92a]. Genesis demonstrated that complex and customized DBMSs could be synthesized in minutes by composing prefabricated and plug-compatible components.
Reference: [Mil90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML, </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Component definition constructs are provided by languages like Ada 9X [Bar93] and Modula 3 [Car89]. Realms and symmetric components can be seen in Volpanos STS [Vol85]. Goguen provides a model for parameterized programming in the languages LIL [Gog86] and FOOPS [Gog93]; the functional language ML <ref> [Mil90] </ref> takes another approach to parameterization. Software system generators are related to application generators. Many application generators provide a domain-specific programming language, and include either an interpreter or compiler for that language [Kru92]. Well-known examples of application generators include Lex, Yacc, VisiCalc, Mathematica, and so-called fourth generation languages (4GLs).
Reference: [Mir91] <author> D. P. Miranker, D. Brant, B.J. Lofaso, and D. Gadbois. </author> <title> On the performance of lazy matching in production system. </title> <booktitle> In Proceedings of the 1990 National Conference on Artificial Intelligence, </booktitle> <month> July </month> <year> 1990. </year>
Reference-contexts: This prospect led to our next series of experiments. 8 5.2 A re-engineering of OPS5/C LEAPS OPS5/C LEAPS is a state-of-the-art production system compiler that translates complex OPS5 rule sets into C programs <ref> [Mir91, Bra92-93] </ref>. The run-time efficiency of LEAPS-generated programs has been documented to be several orders of magnitude faster than that of OPS5 interpreters.
Reference: [Nei84] <author> James M. Neighbors. </author> <title> The Draco approach to constructing software from reusable components. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> SE-10(5), </volume> <month> September </month> <year> 1984. </year> <editor> Also in Peter Freeman, editor. </editor> <booktitle> Software Reusability. </booktitle> <publisher> IEEE Computer Science Press, </publisher> <year> 1987. </year>
Reference-contexts: Unlike GenVoca, system designs were expressed in an application-specific language, and were mapped to expressions in other domain-specific languages during the process of code generation <ref> [Nei84, Nei89] </ref>. Therefore, Draco embodied a different model of application generators than GenVoca does. 7 Conclusions and future work We are convinced that software reuse is inherently an experimental discipline; the techniques to achieve reuse are best revealed, understood, and learned through experience.
Reference: [Nei89] <author> James M. Neighbors. </author> <title> Draco: a method for engineering reusable software systems. </title> <editor> In Ted J. Biggerstaff and Alan J. Perlis, editors. </editor> <title> Software Reusability, Volume I: Concepts and Models, </title> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: Unlike GenVoca, system designs were expressed in an application-specific language, and were mapped to expressions in other domain-specific languages during the process of code generation <ref> [Nei84, Nei89] </ref>. Therefore, Draco embodied a different model of application generators than GenVoca does. 7 Conclusions and future work We are convinced that software reuse is inherently an experimental discipline; the techniques to achieve reuse are best revealed, understood, and learned through experience.
Reference: [OMa92] <author> Sean OMalley and Larry Peterson. </author> <title> A dynamic network architecture. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(2) </volume> <pages> 110-143, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Our experiences with domain-specific software generators are not unique. Similar experiences have been noted and virtually identical software organizations have been used in independently-conceived generators for the domains of network protocols <ref> [Oma92] </ref>, data manipulation languages [Vil94], distributed file sys This research was supported in part by grants from the University of Texas Applied Research Laboratories, Schlumberger, and Digital Equipment Corporation. 2 tems [Hei93], host-at-sea buoy systems [Wei90], and real-time avionics software [Bat93b].
Reference: [Sin93] <author> Vivek Singhal and Don Batory. </author> <title> P++: a language for software system generators. </title> <type> Technical Report TR-93-16, </type> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: A sizable fraction of P2 implements features that will be eventually provided by P++. P++ will be the platform for our future development efforts. Further details on the architecture and optimizations of these prototypes is given in <ref> [Bat92c, Sin93, Sir93] </ref>. 7 5 Results For any generator to be practical, it must satisfy two requirements: (1) use of the generator should yield significant productivity gains, and (2) the performance of generated code must be comparable to that of handwritten code.
Reference: [Sir93] <author> Marty Sirkin, Don Batory, and Vivek Singhal. </author> <title> Software components in a data structure precompiler. </title> <booktitle> In Proceedings of the 15th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: A sizable fraction of P2 implements features that will be eventually provided by P++. P++ will be the platform for our future development efforts. Further details on the architecture and optimizations of these prototypes is given in <ref> [Bat92c, Sin93, Sir93] </ref>. 7 5 Results For any generator to be practical, it must satisfy two requirements: (1) use of the generator should yield significant productivity gains, and (2) the performance of generated code must be comparable to that of handwritten code.
Reference: [Sir94] <author> Marty Sirkin. </author> <title> A Software System Generator for Data Structures, </title> <type> Ph.D. Thesis. </type> <institution> Department of Computer Sciences and Engineering, University of Washington, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: Both the RL and LEAPS implementations used very complicated data structures to solve the triples and bigjoin rule sets. Performance results on more complex rule sets are presented in <ref> [Sir94] </ref>. The productivity gains using Predator became clear when we altered RL to store its data in persistent memory. This took two days for us to write and debug a persistent DS component; to swap it with the transient DS component took minutes. <p> Moreover, since the Genesis file manager was never tuned, we had expected a 50-fold performance improvement; we measured at least a factor of 60. Details of these experiments are presented in <ref> [Sir94] </ref>. We believe that the productivity and performance advantages of using Predator stem from three sources. First, decomposing complex monolithic data structures into primitive, independent, encapsulated components significantly simplifies implementation and makes possible performance optimizations that are difficult, if not impossible, to accomplish by hand.
Reference: [Tra93] <author> Will Tracz. LILEANNA: </author> <title> a parameterized programming language. </title> <booktitle> In Proceedings of the 2nd International Workshop on Software Reuse, </booktitle> <month> March </month> <year> 1993. </year>
Reference-contexts: Component composition and customization is achieved through parameterization. Parameterization is an easy-to-understand model for combining and customizing components. Simple forms of parameterization, i.e., constant and type parameters, are necessary but not sufficient for software system generators. Components must also be able to import other components as parameters <ref> [Gog86, Tra93] </ref>. These lessons on software design have been captured in GenVoca [Bat92b]. It is a domain-independent model for defining families of hierarchical systems as compositions of reusable components. From our experience, models of software design are best understood when programming languages provide direct support for model constructs.
Reference: [Vol85] <author> D. Volpano and R. Kieburtz. </author> <title> Software templates, </title> <booktitle> In Proceedings of the 8th International Conference on Software Engineering, </booktitle> <year> 1985. </year>
Reference-contexts: Component definition constructs are provided by languages like Ada 9X [Bar93] and Modula 3 [Car89]. Realms and symmetric components can be seen in Volpanos STS <ref> [Vol85] </ref>. Goguen provides a model for parameterized programming in the languages LIL [Gog86] and FOOPS [Gog93]; the functional language ML [Mil90] takes another approach to parameterization. Software system generators are related to application generators.
Reference: [Vil94] <author> E. Villarreal. </author> <title> Automated Compiler Generation for Extensible Data Languages, </title> <type> Ph.D. Thesis. </type> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <year> 1994. </year>
Reference-contexts: Our experiences with domain-specific software generators are not unique. Similar experiences have been noted and virtually identical software organizations have been used in independently-conceived generators for the domains of network protocols [Oma92], data manipulation languages <ref> [Vil94] </ref>, distributed file sys This research was supported in part by grants from the University of Texas Applied Research Laboratories, Schlumberger, and Digital Equipment Corporation. 2 tems [Hei93], host-at-sea buoy systems [Wei90], and real-time avionics software [Bat93b].
Reference: [Wei90] <author> David M. Weiss. </author> <title> Synthesis Operational Scenarios. </title> <type> Technical Report 90038-N, Version 1.00.01, </type> <institution> Software Productivity Consortium, </institution> <address> Herndon, Virginia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: identical software organizations have been used in independently-conceived generators for the domains of network protocols [Oma92], data manipulation languages [Vil94], distributed file sys This research was supported in part by grants from the University of Texas Applied Research Laboratories, Schlumberger, and Digital Equipment Corporation. 2 tems [Hei93], host-at-sea buoy systems <ref> [Wei90] </ref>, and real-time avionics software [Bat93b]. Thus it seems worthwhile to factor out the common, domain-independent ideas that underlie different software system generators, and to build tools and develop design techniques that support these particular methods of software organization and construction.
References-found: 35

