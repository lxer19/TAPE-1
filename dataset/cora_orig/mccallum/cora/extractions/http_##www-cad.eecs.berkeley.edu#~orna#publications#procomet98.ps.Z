URL: http://www-cad.eecs.berkeley.edu/~orna/publications/procomet98.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~orna/pub.html
Root-URL: 
Email: Email: orna@eecs.berkeley.edu,  Email: vardi@cs.rice.edu,  
Title: Relating Linear and Branching Model Checking  
Author: O. Kupferman M.Y. Vardi 
Web: URL: www.eecs.berkeley.edu/~orna  URL: www.cs.rice.edu/~vardi  
Address: Berkeley CA 94720-1770, U.S.A.  Houston, TX 77005-1892, U.S.A.  
Affiliation: UC Berkeley EECS Department,  Rice University Department of Computer Science,  
Abstract: The difference in the complexity of branching and linear model checking has been viewed as an argument in favor of the branching paradigm. In particular, the computational advantage of CTL model checking over LTL model checking makes CTL a popular choice, leading to efficient model-checking tools for this logic. Can we use these tools in order to verify linear properties? In this paper we relate branching and linear model checking. With each LTL formula , we associate a CTL formula A that is obtained from by preceding each temporal operator by the universal path quantifier A. We first describe a number of attempts to utilize the tight syntactic relation between and A in order to use CTL model-checking tools in the process of checking the formula . Neither attempt, however, suggests a method that is guaranteed to perform better than usual LTL model checkers. We then claim that, in practice, LTL model checkers perform nicely on formulas with equivalences of CTL. In fact, they often proceed essentially as the ones for CTL. 
Abstract-found: 1
Intro-found: 1
Reference: [BBG + 94] <author> I. Beer, S. Ben-David, D. Geist, R. Gewirtzman, and M. Yoeli. </author> <title> Methodology and system for practical formal verification of reactive hardware. </title> <booktitle> In Proc. 6th CAV, </booktitle> <volume> LNCS 818, </volume> <pages> pp. 182-193, </pages> <year> 1994. </year>
Reference-contexts: The attractive complexity of CTL model checking have compensated for its lack of expressive power and branching-time model-checking tools that can handle systems with more than 10 120 states [McM93, CGL93] are incorporated into industrial development of new designs <ref> [BBG + 94] </ref>. If we examine the history of these issues more closely, we find that things are not that simple. On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback [EH86]. <p> On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback [EH86]. In addition, the introduction of fair-CTL [CES86] and of many other extensions to CTL <ref> [Lon93, BBG + 94, KG96] </ref>, have made CTL a basis for specification languages that maintain the efficiency of CTL model checking and yet overcome many of its expressiveness limitations. On the other hand, the computational superiority of CTL is also not that clear.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <booktitle> In Proc. 6th CAV, </booktitle> <volume> LNCS 818, </volume> <pages> pp. 142-155, </pages> <year> 1994. </year>
Reference-contexts: Checking a weak automaton A for nonemptiness proceeds in phases as follows (see <ref> [BVW94] </ref>). Let Q 1 : : : Q n be the partial order on the sets of A. The algorithm proceeds up the partial order. <p> On the other hand, the computational superiority of CTL is also not that clear. For example, comparing the complexities of CTL and LTL model checking for concurrent programs, both are in PSPACE <ref> [VW86, BVW94] </ref>. As shown in [Var95, KV95], the advantage that CTL enjoys over LTL disappears also when the complexity of modular verification is considered. The distinction between closed an open systems questions the computational superiority of the branching-time paradigm further.
Reference: [CDK93] <author> E. M. Clarke, I. A. Draghicescu, and R. P. Kurshan. </author> <title> A unified approach for showing language containment and equivalence between various types of !-automata. </title> <journal> IPL 46, </journal> <pages> pp 301-308, </pages> <year> 1993. </year>
Reference-contexts: use these tools in order to verify linear properties? A straightforward relation between LTL and CTL model checking follows from the fact that LTL model checking can be reduced to the language-containment problem [VW86], which itself can be reduced to searching for fair paths, and hence to CTL model checking <ref> [VW86, CDK93] </ref>. Such an approach, however, involves the definition of a new transition system whose size is exponential in the length of the LTL formula. As such, it does not enjoy the computational advantage of CTL.
Reference: [CE81] <author> E.M. Clarke and E.A. Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching time temporal logic. In Proc. Work 22 Relating Linear and Branching Model Checking shop on Logic of Programs, </title> <publisher> LNCS 131, </publisher> <pages> pp. 52-71, </pages> <year> 1981. </year>
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: Thus, in practice, there is no need to relate linear and branching model checking and the question whether A is equivalent to A is not that important. In order to prove our claim, we compare the behavior of the bottom-up CTL model-checking algorithm of <ref> [CES86] </ref> with the behavior of the automata-based LTL model-checking algorithm of [VW86]. We show that most LTL formulas for which A is equivalent to A induce a special type of automata. <p> For simplicity, we consider modules M with no fairness conditions; i.e., modules in which all the computations are fair. As the "representative" CTL model checker we take the bottom-up labeling procedure of <ref> [CES86] </ref>. There, in order to check whether M satisfies ', we label the states of M by subformulas of ', starting from the innermost formulas and proceeding such that, when labeling a formula, all its subformulas are already labeled. <p> If we examine the history of these issues more closely, we find that things are not that simple. On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback [EH86]. In addition, the introduction of fair-CTL <ref> [CES86] </ref> and of many other extensions to CTL [Lon93, BBG + 94, KG96], have made CTL a basis for specification languages that maintain the efficiency of CTL model checking and yet overcome many of its expressiveness limitations.
Reference: [CGL93] <author> E.M. Clarke, O. Grumberg, and D. </author> <title> Long. Verification tools for finite-state concurrent systems. </title> <booktitle> In Proc. REX School, </booktitle> <volume> LNCS 803, </volume> <pages> pp. 124-175, </pages> <year> 1993. </year>
Reference-contexts: The attractive complexity of CTL model checking have compensated for its lack of expressive power and branching-time model-checking tools that can handle systems with more than 10 120 states <ref> [McM93, CGL93] </ref> are incorporated into industrial development of new designs [BBG + 94]. If we examine the history of these issues more closely, we find that things are not that simple. On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback [EH86].
Reference: [Cla97] <author> E. Clarke. </author> <title> Private communication, </title> <year> 1997. </year>
Reference-contexts: Intuitively, both model checkers proceed according to the semantics of the formula and are insensitive to the syntax in which it is given. Experimental results of LTL and CTL model checking of common specifications support our observation and show no advantage to the branching paradigm <ref> [Cla97] </ref>. The computational disadvantage of LTL originates from formulas that do not have equivalent CTL formulas and from less common specifications that we rarely meet in practice. ACKNOWLEDGMENT O.
Reference: [EH86] <author> E.A. Emerson and J.Y. Halpern. </author> <title> Sometimes and not never revisited: On branching versus linear time. </title> <journal> Journal of the ACM, </journal> <volume> 33(1) </volume> <pages> 151-178, </pages> <year> 1986. </year>
Reference-contexts: If we examine the history of these issues more closely, we find that things are not that simple. On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback <ref> [EH86] </ref>. In addition, the introduction of fair-CTL [CES86] and of many other extensions to CTL [Lon93, BBG + 94, KG96], have made CTL a basis for specification languages that maintain the efficiency of CTL model checking and yet overcome many of its expressiveness limitations.
Reference: [EJ88] <author> E.A. Emerson and C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proc. 29th FOCS, </booktitle> <pages> pp. 368-377, </pages> <year> 1988. </year>
Reference-contexts: We first study the problem of deciding whether A and A are equivalent. As A and A are CTL ? formulas, the known 2EXPTIME upper bound for CTL ? satisfiability <ref> [ES84, EJ88] </ref> suggests an obvious 2EXPTIME upper bound for the above equivalence problem. Moreover, as A and A are 8CTL ? formulas, the problem can be solved in EXPSPACE [KV95]. <p> This implication is not valid for all LTL formulas . For example, the formula AF Gp does not imply the formula AF AGp. We now solve this implication problem. As A and A are CTL ? formulas, the known 2EXPTIME upper bound for CTL ? satisfiability <ref> [ES84, EJ88] </ref> suggests an obvious 2EXPTIME upper bound for the problem. Moreover, as A and A are 8CTL ? formulas, the problem can be solved in EXPSPACE [KV95].
Reference: [EL85] <author> E.A. Emerson and C.-L. Lei. </author> <title> Modalities for model checking: Branching time logic strikes back. </title> <booktitle> In Proc. 20th POPL, </booktitle> <pages> pp. 84-96, </pages> <year> 1985. </year>
Reference-contexts: This can be checked by solving the model-checking problem M j= A $ A . The model-checking problem M j= A $ ' for in LTL and ' in 8CTL can be solved in PSPACE <ref> [EL85] </ref>. What about the special case where ' = A ? One could hope that the tight syntactic relation between A and A would make it easier. <p> This equivalence can be checked by solving the model-checking problem M j= A $ A . The model-checking problem M j= A $ ' for in LTL and ' in 8CTL can be solved in PSPACE <ref> [EL85] </ref>. What about the special case where ' = A ? One could hope that the tight syntactic relation between and A would make it easier. In the next theorem we refute this hope. <p> In the next theorem we refute this hope. Relating and A 15 Theorem 3.6 Given a module M and an LTL formula , solving the model-checking problem M j= A ! A is PSPACE-complete. Proof. The upper bound follows from CTL ? model-checking complexity <ref> [EL85] </ref>. For the lower bound, we do a reduction from polynomial space Turing machines.
Reference: [Eme90] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pp. 997-1072, </pages> <year> 1990. </year>
Reference-contexts: Assuming an agreed module M , we use w j= ' to indicate that a state formula ' holds at state w, and we use j= ' to indicate that a path formula ' holds at path . The formal definition of the relation j= can be found in <ref> [Eme90] </ref>. A module M satisfies a formula iff holds in all the initial states of M .
Reference: [ES84] <author> E.A. Emerson and A. P. Sistla. </author> <title> Deciding branching time logic. </title> <booktitle> In Proc. 16th STOC, </booktitle> <year> 1984. </year>
Reference-contexts: We first study the problem of deciding whether A and A are equivalent. As A and A are CTL ? formulas, the known 2EXPTIME upper bound for CTL ? satisfiability <ref> [ES84, EJ88] </ref> suggests an obvious 2EXPTIME upper bound for the above equivalence problem. Moreover, as A and A are 8CTL ? formulas, the problem can be solved in EXPSPACE [KV95]. <p> This implication is not valid for all LTL formulas . For example, the formula AF Gp does not imply the formula AF AGp. We now solve this implication problem. As A and A are CTL ? formulas, the known 2EXPTIME upper bound for CTL ? satisfiability <ref> [ES84, EJ88] </ref> suggests an obvious 2EXPTIME upper bound for the problem. Moreover, as A and A are 8CTL ? formulas, the problem can be solved in EXPSPACE [KV95].
Reference: [GL94] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: The formal definition of the relation j= can be found in [Eme90]. A module M satisfies a formula iff holds in all the initial states of M . The model-checking problem is to decide, given M and , whether M j= . 2.2 Simulation relation and maximal models In <ref> [GL94] </ref>, Grumberg and Long define an order relation between modules that captures what it means for a module M 0 to have "more behaviors" than a module M . The definition in [GL94] extend previous definitions [Mil71], which relate modules with no fairness conditions. <p> is to decide, given M and , whether M j= . 2.2 Simulation relation and maximal models In <ref> [GL94] </ref>, Grumberg and Long define an order relation between modules that captures what it means for a module M 0 to have "more behaviors" than a module M . The definition in [GL94] extend previous definitions [Mil71], which relate modules with no fairness conditions. <p> Intuitively, it means that the module M 0 has more behaviors than the module M . In fact, 8 Relating Linear and Branching Model Checking every possible behavior of M is also a possible behavior of M 0 . The following theorem is proved in <ref> [GL94] </ref> for modules with a Streett fairness condition. The proof is independent of the type of the fairness condition being used and it holds also for fair Rabin modules. <p> The implication ' ! is valid iff holds in all modules M in which ' holds. Since the more behaviors M has the less likely it is to satisfy , it makes sense to examine the implication by checking in a maximal model of ': Theorem 2.2 <ref> [GL94] </ref> Let ' and be 8CTL ? formulas, and let M ' be a maximal model of '. <p> We first prove that L (M ) L (M A ). Consider an initialized fair computation of M . We can regard as a module of branching degree 1. Since satisfies then, by Lemma 3.1, it satisfies A as well. Hence, M A . Since simulation implies trace-containment <ref> [GL94] </ref>, it follows that the trace induced by is a member of L (M A ). So, L (M ) L (M A ). Therefore, for every state w i 0 2 W 0 , we have L (M i ) L (M A ).
Reference: [GPVW95] <author> R. Gerth, D. Peled, M.Y. Vardi, and P. Wolper. </author> <title> A simple on-the-fly automatic verification for linear temporal logic. In Protocol Specification, Testing, </title> <booktitle> and Verification, </booktitle> <pages> pp. 3-18. </pages> <publisher> Chapman & Hall, </publisher> <year> 1995. </year>
Reference-contexts: Theorem 3.6, however, refutes this hope. 18 Relating Linear and Branching Model Checking exists an initial state in the intersection that satisfies CTL formula EGtrue. For the construction of A : , we follow the definition in <ref> [GPVW95] </ref>, which improves [VW86] by being demand-driven; that is, the state space of A : is restricted to states that are reachable from the initial state.
Reference: [HK96] <author> G. Holzmann and O. Kupferman. </author> <title> Not checking for closure under stuttering. </title> <booktitle> In Proc. 2nd SPIN, </booktitle> <pages> pp 163-169, </pages> <year> 1996. </year>
Reference-contexts: that, Spin first closes the given specification under stuttering, then it model checks (with partial-order reductions) the closed specification, and it uses the relation between the closed specification and the original one in order to deduce either the satisfaction of the original specification or its not being closed under stuttering <ref> [HK96] </ref>. We follow the same lines: instead of checking A , verification starts by checking M with respect to A . If M satisfies A , we deduce that M satisfies A as well. <p> The idea is very similar to an idea used in the model checker Spin. There, Spin avoids the check of its specifications for being closed under stuttering and is still able to use its partial-order reductions <ref> [HK96] </ref>. Given a module M and an LTL formula , we suggest to proceed as follows (see Figure 1). Instead of checking A , verification starts by checking M with respect to A . This can be done using a CTL model checker.
Reference: [Hol97] <author> G.J. Holzmann. </author> <title> The model checker SPIN. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 23(5) </volume> <pages> 279-295, </pages> <year> 1997. </year>
Reference-contexts: There is, however, a method to avoid the equivalence check of A and A and still use the relation between the two formulas in order to benefit from CTL model-checking tools. The idea is very similar to an idea used in the model checker Spin <ref> [Hol97] </ref>. In order to use its partial-order reductions, Spin has to check its specifications for closure under stuttering. Spin avoids the expensive check but still employs its partial-order reductions.
Reference: [Imm88] <author> N. Immerman. </author> <title> Nondeterministic space is closed under complement. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17 </volume> <pages> 935-938, </pages> <year> 1988. </year>
Reference-contexts: Theorem 3.5 Given a module M , the problem of checking M for indifference is NLOGSPACE-complete. Proof. For the upper bound, we show that checking whether M is not indifferent can be done in NLOGSPACE. The result then follows from the NLOGSPACE = co-NLOGSPACE equivalence <ref> [Imm88, Sze88] </ref>. Let M = hAP; W; W 0 ; R; L; ffi. By Theorem 3.4, M is not indifferent iff there exists an initial state w i 0 2 W 0 such that the language L (M i ) is not a singleton.
Reference: [Jon75] <author> N.D. Jones. </author> <title> Space-bounded reducibility among combinatorial problems. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 11 </volume> <pages> 68-75, </pages> <year> 1975. </year>
Reference-contexts: Membership in NLOGSPACE then follows from the known NLOGSPACE complexity for the reachability problem and the nonemptiness problem for fair Rabin modules. The lower bound follows by an easy reduction from the graph reachability problem <ref> [Jon75] </ref>. By Theorem 3.5, it is easy to check a given module M for being indifferent. On the other hand, by the characterization in Theorem 3.4, we are unlikely to find indifferent modules in practice. Indeed, branches in M originate from nondeterminism in the program that M models.
Reference: [KG96] <author> O. Kupferman and O. Grumberg. </author> <title> Buy one, get one free!!! Journal of Logic and Computation, </title> <booktitle> 6(4) </booktitle> <pages> 523-539, </pages> <year> 1996. </year>
Reference-contexts: Second, even when such ' exists, it may be substantially longer than , making the whole effort useless. A partial success for this approach is presented in <ref> [KG96, Sch97] </ref>, which identify fragments of CTL ? that can be easily translated in to CTL. In this paper we study a more modest approach: instead looking for some equivalent CTL formula to A , we restrict ourselves to the specific candidate A . <p> On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback [EH86]. In addition, the introduction of fair-CTL [CES86] and of many other extensions to CTL <ref> [Lon93, BBG + 94, KG96] </ref>, have made CTL a basis for specification languages that maintain the efficiency of CTL model checking and yet overcome many of its expressiveness limitations. On the other hand, the computational superiority of CTL is also not that clear.
Reference: [KV95] <author> O. Kupferman and M.Y. Vardi. </author> <title> On the complexity of branching modular model checking. </title> <booktitle> In Proc. 6th CONCUR, </booktitle> <volume> LNCS 962. </volume> <pages> pp. </pages> <year> 408-422,1995. </year>
Reference-contexts: As A and A are CTL ? formulas, the known 2EXPTIME upper bound for CTL ? satisfiability [ES84, EJ88] suggests an obvious 2EXPTIME upper bound for the above equivalence problem. Moreover, as A and A are 8CTL ? formulas, the problem can be solved in EXPSPACE <ref> [KV95] </ref>. We present here an EXPSPACE algorithm that is much simpler than the one in [KV95], as it avoids Safra's complicated co-determinization construction [Saf89] that is used in the definition of the maximal models described there. <p> Moreover, as A and A are 8CTL ? formulas, the problem can be solved in EXPSPACE <ref> [KV95] </ref>. We present here an EXPSPACE algorithm that is much simpler than the one in [KV95], as it avoids Safra's complicated co-determinization construction [Saf89] that is used in the definition of the maximal models described there. Our hopes to 4 Relating Linear and Branching Model Checking use the tight syntactic relation between A and A in order to improve this bound were not fulfilled. <p> As A and A are CTL ? formulas, the known 2EXPTIME upper bound for CTL ? satisfiability [ES84, EJ88] suggests an obvious 2EXPTIME upper bound for the problem. Moreover, as A and A are 8CTL ? formulas, the problem can be solved in EXPSPACE <ref> [KV95] </ref>. Can we hope for a better bound? This at first seems unlikely: the implication problem ! ' is EXPSPACE-hard already for in LTL and ' in 8CTL [KV95]. Here, however, we handle the special case where ' = A . <p> Moreover, as A and A are 8CTL ? formulas, the problem can be solved in EXPSPACE <ref> [KV95] </ref>. Can we hope for a better bound? This at first seems unlikely: the implication problem ! ' is EXPSPACE-hard already for in LTL and ' in 8CTL [KV95]. Here, however, we handle the special case where ' = A . Hopefully, the tight syntactic relation between and A would enable a more efficient 10 Relating Linear and Branching Model Checking check. We conjecture that the problem can be solved in polynomial space, which matches our lower bound. <p> We conjecture that the problem can be solved in polynomial space, which matches our lower bound. The algorithm we present below requires exponential space, and in the worst case shows no improvement over the known EXPSPACE upper bound. Yet, it is much simpler than the algorithm in <ref> [KV95] </ref>, as it avoids Safra's complicated co-determinization construction that is used in the definition of the maximal models described there. Theorem 3.3 For an LTL formula , checking A ! A is in EXPSPACE and is PSPACE-hard. Proof. We start with the upper bound. <p> To complete the reduction of implication to model checking, we have to describe the construction of maximal models for LTL formulas. A construction of maximal models for 8CTL ? formulas is described in <ref> [KV95] </ref>. The restriction to LTL formulas enables us to come with a much simpler construction. Given an LTL formula , let A = h2 AP ; Q; Q 0 ; ffi; F i be the Buchi automaton that corresponds to (see Theorem 2.3). <p> The model-checking problem for CTL with respect to fair Rabin modules with a single pair can be solved in space that is polynomial in the length of the formula and is polylogarithmic in the size of the module <ref> [KV95] </ref>. Moreover, the algorithm described in [KV95] proceeds on-the-fly, without keeping the whole module in memory at once. Therefore, the EXPSPACE upper bound follows. For the lower bound, we do a reduction from LTL satisfiability, proved to be hard for PSPACE in [SC85]. <p> The model-checking problem for CTL with respect to fair Rabin modules with a single pair can be solved in space that is polynomial in the length of the formula and is polylogarithmic in the size of the module <ref> [KV95] </ref>. Moreover, the algorithm described in [KV95] proceeds on-the-fly, without keeping the whole module in memory at once. Therefore, the EXPSPACE upper bound follows. For the lower bound, we do a reduction from LTL satisfiability, proved to be hard for PSPACE in [SC85]. Consider the LTL formula = (Xp) _ (Xq) _ X ((:p) ^ (:q)). <p> On the other hand, the computational superiority of CTL is also not that clear. For example, comparing the complexities of CTL and LTL model checking for concurrent programs, both are in PSPACE [VW86, BVW94]. As shown in <ref> [Var95, KV95] </ref>, the advantage that CTL enjoys over LTL disappears also when the complexity of modular verification is considered. The distinction between closed an open systems questions the computational superiority of the branching-time paradigm further.
Reference: [KV96] <author> O. Kupferman and M.Y. Vardi. </author> <title> Module checking. </title> <booktitle> In Proc. 8th CAV, </booktitle> <volume> LNCS 1102, </volume> <pages> pp. 75-86, </pages> <year> 1996. </year>
Reference-contexts: As shown in [Var95, KV95], the advantage that CTL enjoys over LTL disappears also when the complexity of modular verification is considered. The distinction between closed an open systems questions the computational superiority of the branching-time paradigm further. As shown in <ref> [KV96, KV97] </ref>, while for LTL specifications, the model-checking paradigm is applicable also for the verification of open systems, this is not true for CTL Conclusions 21 specifications. The ability of CTL to quantify computations existentially requires a more careful check, in which all possible environments are taken into considerations.
Reference: [KV97] <author> O. Kupferman and M.Y. Vardi. </author> <title> Module checking revisited. </title> <booktitle> In Proc. 9th CAV, </booktitle> <volume> LNCS 1254, </volume> <pages> pp. 36-47, </pages> <year> 1997. </year>
Reference-contexts: As shown in [Var95, KV95], the advantage that CTL enjoys over LTL disappears also when the complexity of modular verification is considered. The distinction between closed an open systems questions the computational superiority of the branching-time paradigm further. As shown in <ref> [KV96, KV97] </ref>, while for LTL specifications, the model-checking paradigm is applicable also for the verification of open systems, this is not true for CTL Conclusions 21 specifications. The ability of CTL to quantify computations existentially requires a more careful check, in which all possible environments are taken into considerations.
Reference: [Lam80] <author> L. Lamport. </author> <title> Sometimes is sometimes "not never" on the temporal logic of programs. </title> <booktitle> In Proc. 7th POPL, </booktitle> <pages> pp. 174-185, </pages> <year> 1980. </year>
Reference-contexts: The restriction to branchable subformulas takes care of formulas like ^ (' _ :') discussed above, and still leaves us with the bulk of LTL formulas used in practice. 5 CONCLUSIONS The discussion of the relative merits of linear versus branching temporal logics is almost as early as these paradigms <ref> [Lam80] </ref>. We mainly refer here to the linear temporal logic LTL and the branching temporal logic CTL. One of the beliefs dominating this discussion has been "while specifying is easier in LTL, model checking is easier for CTL".
Reference: [Lon93] <author> D.E. </author> <title> Long. Model checking, abstraction and compositional verification. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, Pittsburgh, </institution> <year> 1993. </year>
Reference-contexts: On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback [EH86]. In addition, the introduction of fair-CTL [CES86] and of many other extensions to CTL <ref> [Lon93, BBG + 94, KG96] </ref>, have made CTL a basis for specification languages that maintain the efficiency of CTL model checking and yet overcome many of its expressiveness limitations. On the other hand, the computational superiority of CTL is also not that clear.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent Conclusions 23 programs satisfy their linear specification. </title> <booktitle> In Proc. 12th POPL, </booktitle> <pages> pp. 97-107, </pages> <year> 1985. </year>
Reference: [McM93] <author> K.L. McMillan. </author> <title> Symbolic model checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: The attractive complexity of CTL model checking have compensated for its lack of expressive power and branching-time model-checking tools that can handle systems with more than 10 120 states <ref> [McM93, CGL93] </ref> are incorporated into industrial development of new designs [BBG + 94]. If we examine the history of these issues more closely, we find that things are not that simple. On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback [EH86].
Reference: [Mil71] <author> R. Milner. </author> <title> An algebraic definition of simulation between programs. </title> <booktitle> In Proc. 2nd IJCAI, </booktitle> <pages> pp. 481-489, </pages> <year> 1971. </year>
Reference-contexts: The definition in [GL94] extend previous definitions <ref> [Mil71] </ref>, which relate modules with no fairness conditions.
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proc. 18th FOCS, </booktitle> <pages> pp. 46-57, </pages> <year> 1977. </year>
Reference: [Pnu81] <author> A. Pnueli. </author> <title> The temporal semantics of concurrent programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 45-60, </pages> <year> 1981. </year>
Reference: [QS81] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Proc. 5th International Symp. on Programming, </booktitle> <volume> LNCS 137, </volume> <pages> pp. 337-351, </pages> <year> 1981. </year>
Reference: [RS59] <author> M.O. Rabin and D. Scott. </author> <title> Finite automata and their decision problems. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 3 </volume> <pages> 115-125, </pages> <year> 1959. </year>
Reference-contexts: In particular, for every state s, the set ffi (s; ) is not empty iff s " AP = . Defining the maximal model M , we apply to A the classical subset construction of <ref> [RS59] </ref>, that is, we extend ffi to a mapping from 2 Q fi2 AP to 2 Q where ffi (S; a) = fq 2 Q : q 2 ffi (s; a) for some s 2 Sg.
Reference: [Saf89] <author> S. Safra. </author> <title> Complexity of automata on infinite objects. </title> <type> PhD thesis, </type> <institution> Weiz-mann Institute of Science, Rehovot, Israel, </institution> <year> 1989. </year>
Reference-contexts: Moreover, as A and A are 8CTL ? formulas, the problem can be solved in EXPSPACE [KV95]. We present here an EXPSPACE algorithm that is much simpler than the one in [KV95], as it avoids Safra's complicated co-determinization construction <ref> [Saf89] </ref> that is used in the definition of the maximal models described there. Our hopes to 4 Relating Linear and Branching Model Checking use the tight syntactic relation between A and A in order to improve this bound were not fulfilled.
Reference: [SC85] <author> A.P. Sistla and E.M. Clarke. </author> <title> The complexity of propositional linear temporal logic. </title> <journal> Journal ACM, </journal> <volume> 32 </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference-contexts: Introduction 3 checking is PSPACE-complete <ref> [SC85] </ref>, the latter bound probably cannot be improved. The difference in the complexity of linear and branching model checking has been viewed as an argument in favor of the branching paradigm. <p> Moreover, the algorithm described in [KV95] proceeds on-the-fly, without keeping the whole module in memory at once. Therefore, the EXPSPACE upper bound follows. For the lower bound, we do a reduction from LTL satisfiability, proved to be hard for PSPACE in <ref> [SC85] </ref>. Consider the LTL formula = (Xp) _ (Xq) _ X ((:p) ^ (:q)). It is easy to see that while is valid, the 8CTL formula A = (AXp) _ (AXq) _ AX ((:p) ^ (:q)) is not valid. <p> In order to prove that the model-checking problem for LTL is hard for PSPACE, Sistla and Clarke associate with a polynomial space Turing machine T , a module M and an LTL formula , such that M j= E iff T accepts the empty tape <ref> [SC85] </ref>.
Reference: [Sch97] <author> K. Schneider. </author> <booktitle> CTL and equivalent sublanguages of CTL ? . In Proc. IFIP Conference on Computer Hardware Description Languages and Applications, </booktitle> <pages> pp. 40-59, </pages> <year> 1997. </year>
Reference-contexts: Second, even when such ' exists, it may be substantially longer than , making the whole effort useless. A partial success for this approach is presented in <ref> [KG96, Sch97] </ref>, which identify fragments of CTL ? that can be easily translated in to CTL. In this paper we study a more modest approach: instead looking for some equivalent CTL formula to A , we restrict ourselves to the specific candidate A .
Reference: [Sze88] <author> R. Szelepcsinyi. </author> <title> The method of forced enumeration for nondeterministic automata. </title> <journal> Acta Informatica, </journal> <volume> 26 </volume> <pages> 279-284, </pages> <year> 1988. </year>
Reference-contexts: Theorem 3.5 Given a module M , the problem of checking M for indifference is NLOGSPACE-complete. Proof. For the upper bound, we show that checking whether M is not indifferent can be done in NLOGSPACE. The result then follows from the NLOGSPACE = co-NLOGSPACE equivalence <ref> [Imm88, Sze88] </ref>. Let M = hAP; W; W 0 ; R; L; ffi. By Theorem 3.4, M is not indifferent iff there exists an initial state w i 0 2 W 0 such that the language L (M i ) is not a singleton.
Reference: [Var95] <author> M.Y. Vardi. </author> <title> On the complexity of modular model checking. </title> <booktitle> In Proc. 10th LICS, </booktitle> <pages> pp. 101-111, </pages> <year> 1995. </year>
Reference-contexts: On the other hand, the computational superiority of CTL is also not that clear. For example, comparing the complexities of CTL and LTL model checking for concurrent programs, both are in PSPACE [VW86, BVW94]. As shown in <ref> [Var95, KV95] </ref>, the advantage that CTL enjoys over LTL disappears also when the complexity of modular verification is considered. The distinction between closed an open systems questions the computational superiority of the branching-time paradigm further.
Reference: [VW86] <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proc. 1st LICS, </booktitle> <pages> pp. 322-331, </pages> <year> 1986. </year>
Reference-contexts: Can we use these tools in order to verify linear properties? A straightforward relation between LTL and CTL model checking follows from the fact that LTL model checking can be reduced to the language-containment problem <ref> [VW86] </ref>, which itself can be reduced to searching for fair paths, and hence to CTL model checking [VW86, CDK93]. Such an approach, however, involves the definition of a new transition system whose size is exponential in the length of the LTL formula. <p> use these tools in order to verify linear properties? A straightforward relation between LTL and CTL model checking follows from the fact that LTL model checking can be reduced to the language-containment problem [VW86], which itself can be reduced to searching for fair paths, and hence to CTL model checking <ref> [VW86, CDK93] </ref>. Such an approach, however, involves the definition of a new transition system whose size is exponential in the length of the LTL formula. As such, it does not enjoy the computational advantage of CTL. <p> In order to prove our claim, we compare the behavior of the bottom-up CTL model-checking algorithm of [CES86] with the behavior of the automata-based LTL model-checking algorithm of <ref> [VW86] </ref>. We show that most LTL formulas for which A is equivalent to A induce a special type of automata. Solving the nonemptiness problem of these automata involves essentially the same steps required for solving the model-checking problem for A . <p> Labeling subformulas of the form A 1 U 2 , E 1 U 2 , A 1 ~ U 2 , or E 1 ~ U 2 involves a backward reachability test. As the "representative" LTL model checker, we take the automata-based algorithm of <ref> [VW86] </ref>. There, in order to check whether M satisfies , we construct a Buchi word automaton A : for : and check whether the intersection of the language of M with that of A : is nonempty. <p> Theorem 3.6, however, refutes this hope. 18 Relating Linear and Branching Model Checking exists an initial state in the intersection that satisfies CTL formula EGtrue. For the construction of A : , we follow the definition in [GPVW95], which improves <ref> [VW86] </ref> by being demand-driven; that is, the state space of A : is restricted to states that are reachable from the initial state. <p> On the other hand, the computational superiority of CTL is also not that clear. For example, comparing the complexities of CTL and LTL model checking for concurrent programs, both are in PSPACE <ref> [VW86, BVW94] </ref>. As shown in [Var95, KV95], the advantage that CTL enjoys over LTL disappears also when the complexity of modular verification is considered. The distinction between closed an open systems questions the computational superiority of the branching-time paradigm further.

References-found: 37

