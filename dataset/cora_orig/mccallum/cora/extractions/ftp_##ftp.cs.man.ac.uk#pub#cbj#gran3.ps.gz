URL: ftp://ftp.cs.man.ac.uk/pub/cbj/gran3.ps.gz
Refering-URL: http://www.cs.man.ac.uk/fmethods/projects/pobl-development-method.html
Root-URL: http://www.cs.man.ac.uk
Title: Granularity and the Development of Concurrent Programs  introduction formal development and concurrency object-oriented concepts  
Author: Cliff B Jones conclusions 
Address: New Orleans 1995-03-29  
Affiliation: Manchester University  MFPS, Tulane University,  
Abstract-found: 0
Intro-found: 1
Reference: [BA90] <author> M. Ben-Ari. </author> <title> Principles of Concurrent and Distributed Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year> <note> ISBN 0-13-711821-X. </note>
Reference-contexts: 1 ) (S 1 k S 2 ) sat (p; r ; g; q) * n-ary forms possible * all require many proof obligations * do not fix granularity * probably require atomicity to implement * references [Jon81, Sti88, Sto90, Xu92, Col92] 10 Granularity * implementing atomicity - Dekker's algorithm <ref> [BA90, Section 3.6] </ref>: critical sections without semaphores semaphores conditional critical regions monitors - (CSP) use of &lt; &gt;, await, . . . * should design languages fix granularity assumptions? assignments: very inefficient - Bernstein rule: inefficient at assignment level of thinking, designer ought to have fixed synchronization so, No! * tension
Reference: [Col92] <author> Pierre Collette. </author> <title> Semantic rules to compose rely-guarantee specifications. </title> <type> Technical Report RR 92-25, </type> <institution> Universit`e de Louvain, </institution> <year> 1992. </year>
Reference-contexts: r 1 S 1 sat (p; r 1 ; g 1 ; q 1 ) (S 1 k S 2 ) sat (p; r ; g; q) * n-ary forms possible * all require many proof obligations * do not fix granularity * probably require atomicity to implement * references <ref> [Jon81, Sti88, Sto90, Xu92, Col92] </ref> 10 Granularity * implementing atomicity - Dekker's algorithm [BA90, Section 3.6]: critical sections without semaphores semaphores conditional critical regions monitors - (CSP) use of &lt; &gt;, await, . . . * should design languages fix granularity assumptions? assignments: very inefficient - Bernstein rule: inefficient at assignment
Reference: [Col93] <author> Pierre Collette. </author> <title> Application of the composition principle to Unity-like specifications. </title> <booktitle> In [GJ93], </booktitle> <pages> pages 230-242, </pages> <year> 1993. </year>
Reference-contexts: synchronization so, No! * tension between implementation and tractability * semantically critical references (cf. [MP92, Section 2.2]) * granularity and rely/guarantee-conditions rely oe = ( oe ; guar true implementation open - x x does not fix steps 11 Alternatives * UNITY logic: can be combined with rely/guarantee thinking (cf. <ref> [Col93] </ref>) program notation: no discussion of interference * Broy's `stream assertions' * Lamport's notion of `stuttering' * process algebra 12 Object-oriented concepts * (sequential) OOLs are a `good thing' * controlling concurrency shared variables as objects * granularity in ofi atomic) - pseudo-atomic ) reasoning about (shared) references ) * other
Reference: [GJ93] <editor> M-C. Gaudel and J-P. Jouannaud, editors. TAPSOFT'93: </editor> <booktitle> Theory and Practice of Software Development, volume 668 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [Jon81] <author> C. B. Jones. </author> <title> Development Methods for Computer Programs including a Notion of Interference. </title> <type> PhD thesis, </type> <institution> Oxford University, </institution> <month> June </month> <year> 1981. </year> <title> Printed as: Programming Research Group, </title> <type> Technical Monograph 25. </type>
Reference-contexts: r 1 S 1 sat (p; r 1 ; g 1 ; q 1 ) (S 1 k S 2 ) sat (p; r ; g; q) * n-ary forms possible * all require many proof obligations * do not fix granularity * probably require atomicity to implement * references <ref> [Jon81, Sti88, Sto90, Xu92, Col92] </ref> 10 Granularity * implementing atomicity - Dekker's algorithm [BA90, Section 3.6]: critical sections without semaphores semaphores conditional critical regions monitors - (CSP) use of &lt; &gt;, await, . . . * should design languages fix granularity assumptions? assignments: very inefficient - Bernstein rule: inefficient at assignment
Reference: [MP92] <author> Zohar Manna and Amir Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: regions monitors - (CSP) use of &lt; &gt;, await, . . . * should design languages fix granularity assumptions? assignments: very inefficient - Bernstein rule: inefficient at assignment level of thinking, designer ought to have fixed synchronization so, No! * tension between implementation and tractability * semantically critical references (cf. <ref> [MP92, Section 2.2] </ref>) * granularity and rely/guarantee-conditions rely oe = ( oe ; guar true implementation open - x x does not fix steps 11 Alternatives * UNITY logic: can be combined with rely/guarantee thinking (cf. [Col93]) program notation: no discussion of interference * Broy's `stream assertions' * Lamport's notion of
Reference: [Sti88] <author> C. Stirling. </author> <title> A generalisation of Owicki-Gries's Hoare logic for a concurrent while language. </title> <journal> TCS, </journal> <volume> 58 </volume> <pages> 347-359, </pages> <year> 1988. </year>
Reference-contexts: r 1 S 1 sat (p; r 1 ; g 1 ; q 1 ) (S 1 k S 2 ) sat (p; r ; g; q) * n-ary forms possible * all require many proof obligations * do not fix granularity * probably require atomicity to implement * references <ref> [Jon81, Sti88, Sto90, Xu92, Col92] </ref> 10 Granularity * implementing atomicity - Dekker's algorithm [BA90, Section 3.6]: critical sections without semaphores semaphores conditional critical regions monitors - (CSP) use of &lt; &gt;, await, . . . * should design languages fix granularity assumptions? assignments: very inefficient - Bernstein rule: inefficient at assignment
Reference: [Sto90] <author> K. Stolen. </author> <title> Development of Parallel Programs on Shared Data-Structures. </title> <type> PhD thesis, </type> <institution> Manchester University, </institution> <year> 1990. </year> <note> available as UMCS-91-1-1. </note>
Reference-contexts: r 1 S 1 sat (p; r 1 ; g 1 ; q 1 ) (S 1 k S 2 ) sat (p; r ; g; q) * n-ary forms possible * all require many proof obligations * do not fix granularity * probably require atomicity to implement * references <ref> [Jon81, Sti88, Sto90, Xu92, Col92] </ref> 10 Granularity * implementing atomicity - Dekker's algorithm [BA90, Section 3.6]: critical sections without semaphores semaphores conditional critical regions monitors - (CSP) use of &lt; &gt;, await, . . . * should design languages fix granularity assumptions? assignments: very inefficient - Bernstein rule: inefficient at assignment
Reference: [Xu92] <author> Qiwen Xu. </author> <title> A Theory of State-based Parallel Programming. </title> <type> PhD thesis, </type> <institution> Oxford University, </institution> <year> 1992. </year> <note> REFERENCES 21 </note>
Reference-contexts: r 1 S 1 sat (p; r 1 ; g 1 ; q 1 ) (S 1 k S 2 ) sat (p; r ; g; q) * n-ary forms possible * all require many proof obligations * do not fix granularity * probably require atomicity to implement * references <ref> [Jon81, Sti88, Sto90, Xu92, Col92] </ref> 10 Granularity * implementing atomicity - Dekker's algorithm [BA90, Section 3.6]: critical sections without semaphores semaphores conditional critical regions monitors - (CSP) use of &lt; &gt;, await, . . . * should design languages fix granularity assumptions? assignments: very inefficient - Bernstein rule: inefficient at assignment
References-found: 9

