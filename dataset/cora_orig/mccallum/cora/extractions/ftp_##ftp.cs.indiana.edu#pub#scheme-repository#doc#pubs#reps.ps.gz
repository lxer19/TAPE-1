URL: ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/reps.ps.gz
Refering-URL: http://www.cs.indiana.edu/scheme-repository/doc.publications.html
Root-URL: http://www.cs.indiana.edu
Email: Spreitzer@PARC.Xerox.Com  
Title: First-class Data-type Representations in SchemeXerox  
Author: Norman Adams, Pavel Curtis, Mike Spreitzer Norman, Pavel, 
Address: 3333 Coyote Hill Rd. Palo Alto, CA 94304  
Affiliation: Xerox PARC  
Abstract: In most programming language implementations, the compiler has detailed knowledge of the representations of and operations on primitive data types and data-type constructors. In SchemeXerox, this knowledge is almost entirely external to the compiler, in ordinary, procedural user code. The primitive representations and operations are embodied in first-class "representation types" that are constructed and implemented in an abstract and high-level fashion. Despite this abstractness, a few generally-useful optimizing transformations are sufficient to allow the SchemeXerox compiler to generate efficient code for the primitive operations, essentially as good as could be achieved using more contorted, traditional techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> Clinger, William and Jonathan Rees, editors, </editor> <title> Revised 4 Report on the Algorithmic Programming Language Scheme, LISP Pointers 4(3), </title> <year> 1991. </year>
Reference-contexts: Finally, in languages like Scheme, it can be very difficult for compilers to discover sufficient information to generate good code; the problem is that user-defined data types are created by procedural manipulation of first-class `type' values rather than by static program syntax <ref> [1, 2] </ref>. The usual solution is to give the compiler detailed knowledge of the built-in types and operations (e.g., cons, pair?, car, and set-car! in Scheme) and to let all of the implementation of user-defined types take place in essentially unoptimized run-time code.
Reference: [2] <author> Curtis, Pavel, </author> <title> The Scheme of Things, LISP Pointers 4(1), </title> <year> 1991. </year>
Reference-contexts: Finally, in languages like Scheme, it can be very difficult for compilers to discover sufficient information to generate good code; the problem is that user-defined data types are created by procedural manipulation of first-class `type' values rather than by static program syntax <ref> [1, 2] </ref>. The usual solution is to give the compiler detailed knowledge of the built-in types and operations (e.g., cons, pair?, car, and set-car! in Scheme) and to let all of the implementation of user-defined types take place in essentially unoptimized run-time code.
Reference: [3] <author> Curtis, Pavel and James Rauen, </author> <title> A Module System for Scheme, </title> <booktitle> in Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Nice, France, </address> <year> 1990. </year>
Reference-contexts: Very much in the style of languages like Modula, ML, Ada, or Cedar/Mesa, SchemeXerox programs are structured into lexically-isolated modules that export implementations of variables described in textually-separate interfaces. Curtis and Rauen describe the module system in detail <ref> [3] </ref>, but for the purposes of this paper it is enough to know two facts. <p> Among the conventional transformations performed are beta reduction, constant folding, boolean short-circuiting, and the elimination of dead code. Simplifiying modules individually will not yield adequate performance for the type system. To address this, Scheme-Xerox supports exposures <ref> [3] </ref>, a mechanism that permits a user to give the compiler access to interface implementations in other modules.
Reference: [4] <author> Kranz, David, Richard Kelsey, Jonathan A. Rees, Paul Hudak, James Philbin, and Norman I. Adams, </author> <title> Orbit: An Optimizing Compiler for Scheme, </title> <booktitle> Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pp. 219-233, </pages> <note> published as SIGPLAN Notices 21(7), </note> <month> July </month> <year> 1986. </year>
Reference-contexts: This a convenience for the compiler (it need not maintain non-pointer/pointer distinction), and for the type system (it is constructing Scheme values in user code). The SchemeXerox compiler is similar in structure to Orbit <ref> [4] </ref>, though it is not as ambitious in closure analysis; the compiler doesn't even recognize simple loops. Unlike many Lisp compilers, though, the SchemeXerox compiler operates on whole modules by default.
Reference: [5] <author> Queinnec, Christian and Pierre Cointe, </author> <title> An Open Ended Data Representation Model for EU LISP, </title> <booktitle> in Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 298-308, </pages> <address> Snowbird, Utah, </address> <year> 1988. </year>
Reference-contexts: The Type and Layout provide the public interface to the type system; the Structure and Bits are internal to the implementation. A Bits object stands for a sequence of bits. A Structure object stands for a node in a hierarchical structure imposed on a bit sequence, a la Queinnec <ref> [5, 6] </ref>. A Layout object also stands for a node in a hierarchical structure; a Layout object differs from a Structure object in: (1) introducing naming, (2) converting element representations, and (3) organizing the access of atomic elements into one name-oriented and one subscript-oriented step. <p> Because the read and write operations use machine words to carry the subsequences read or written, such subsequences cannot be longer than a machine word. A Structure object stands for a node in a hierarchical structure imposed on a bit sequence, a la Queinnec <ref> [5, 6] </ref>. Each Structure is either atomic or composed of a number of other Structures, indexed by integers starting with 0. We currently implement composite Structures for records and fixed- and variable-length arrays; variant-record structure could be added easily within the existing framework.
Reference: [6] <author> Queinnec, Christian, </author> <title> A Specification Framework for Data Aggregates, </title> <institution> unnumbered technical report from Laboratoire d'Informatique de l' Ecole Polytechnique, </institution> <year> 1989. </year>
Reference-contexts: The Type and Layout provide the public interface to the type system; the Structure and Bits are internal to the implementation. A Bits object stands for a sequence of bits. A Structure object stands for a node in a hierarchical structure imposed on a bit sequence, a la Queinnec <ref> [5, 6] </ref>. A Layout object also stands for a node in a hierarchical structure; a Layout object differs from a Structure object in: (1) introducing naming, (2) converting element representations, and (3) organizing the access of atomic elements into one name-oriented and one subscript-oriented step. <p> Because the read and write operations use machine words to carry the subsequences read or written, such subsequences cannot be longer than a machine word. A Structure object stands for a node in a hierarchical structure imposed on a bit sequence, a la Queinnec <ref> [5, 6] </ref>. Each Structure is either atomic or composed of a number of other Structures, indexed by integers starting with 0. We currently implement composite Structures for records and fixed- and variable-length arrays; variant-record structure could be added easily within the existing framework.
Reference: [7] <author> Stallman, Richard, </author> <title> Using and Porting GNU CC, Free Software Foundation, </title> <year> 1989. </year>
Reference-contexts: i & 0xFFFFFFFF; r2 = (0 &gt;= 32) ? 0 : (w2 &lt;< 0); (* (unsigned *) a) = r3; return SX_UNSPECIFIED; else r4 = SX_G_type_err.value; if (! SX_procedure_p (proc = r4)) SX_Procedure_Error (proc); SX_For_Effect ( SX_Procedure_Code (proc) (proc, 2, v, G_literal_4)); return v; -; Compiling this code with GCC <ref> [7] </ref> yields the following SPARC assembly code.
Reference: [8] <author> Steele, Guy Lewis, Jr., Rabbit: </author> <title> a Compiler for Scheme, MIT AI Memo 474, </title> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, Mass., </address> <month> May </month> <year> 1978. </year>
Reference-contexts: To make the type system of practical use, the Scheme-Xerox compiler must turn all of this into a handful of instructions. Though of modest complexity at 7500 lines of Scheme, the compiler succeeds in this task. It does so with extensive cross-module inline substitution, Rabbit-style optimizations <ref> [8] </ref>, and a bit of help from a few language extensions: the module system, the "others" extra arguments facility, and programmer-supplied inlining declarations. In addition to this, the type system is written in a style which takes the compiler's optimization strategy into account.
Reference: [9] <author> Weiser, Mark, Alan Demers, and Carl Hauser, </author> <title> The Portable Runtime Approach to Interoperability, </title> <booktitle> in Proceedings of the Twelfth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 114-122, </pages> <note> published as Operating Systems Review 23(5), </note> <month> December </month> <year> 1989. </year>
Reference-contexts: In particular, the code contains no side effects, and data structures are represented procedurally. The type system implementor included declarations for procedure inlin-ing, and was careful to avoid non-trivial recursion among inlined procedures. 4.1 Compiler Overview SchemeXerox is built on the Xerox Portable Common Run-time <ref> [9] </ref>. PCR provides garbage collection, dynamic loading, and threads. PCR's conservative garbage collector permits SchemeXerox code to generate ill-formed Scheme objects as intermediate results without having to lock out the garbage collector.
References-found: 9

