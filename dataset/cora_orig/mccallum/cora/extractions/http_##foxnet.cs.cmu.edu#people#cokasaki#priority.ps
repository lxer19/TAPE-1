URL: http://foxnet.cs.cmu.edu/people/cokasaki/priority.ps
Refering-URL: http://foxnet.cs.cmu.edu/people/cokasaki/papers.html
Root-URL: 
Email: (e-mail: gerth@daimi.aau.dk)  (e-mail: cokasaki@cs.cmu.edu)  
Title: Optimal Purely Functional Priority Queues  
Author: GERTH STLTING BRODAL CHRIS OKASAKI 
Address: Ny Munkegade, DK-8000 -Arhus C, Denmark  5000 Forbes Avenue, Pittsburgh, Pennsylvania, USA 15213  
Affiliation: BRICS Department of Computer Science, University of Aarhus  School of Computer Science, Carnegie Mellon University  
Date: 6(6): 839-857, November 1996  
Note: J. Functional Programming  c 1996 Cambridge University Press 1  
Abstract: Brodal recently introduced the first implementation of imperative priority queues to support findMin, insert, and meld in O(1) worst-case time, and deleteMin in O(log n) worst-case time. These bounds are asymptotically optimal among all comparison-based priority queues. In this paper, we adapt Brodal's data structure to a purely functional setting. In doing so, we both simplify the data structure and clarify its relationship to the binomial queues of Vuillemin, which support all four operations in O(log n) time. Specifically, we derive our implementation from binomial queues in three steps: first, we reduce the running time of insert to O(1) by eliminating the possibility of cascading links; second, we reduce the running time of findMin to O(1) by adding a global root to hold the minimum element; and finally, we reduce the running time of meld to O(1) by allowing priority queues to contain other priority queues. Each of these steps is expressed using ML-style functors. The last transformation, known as data-structural bootstrapping, is an interesting application of higher-order functors and recursive structures.
Abstract-found: 1
Intro-found: 1
Reference: <author> Brodal, G. S. </author> <title> (1995) Fast meldable priority queues. </title> <booktitle> Workshop on Algorithms and Data Structures. </booktitle> <volume> LNCS 955, </volume> <pages> pp. 282-290. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: between the running times of the various operations are also possible, but no comparison-based priority queue can support insert in better than O (log n) worst-case time or meld in better than O (n) worst-case time unless one of findMin or deleteMin takes at least O (log n) worst-case time <ref> (Brodal, 1995) </ref>. The bootstrapping process can be elegantly expressed in Standard ML extended with higher-order functors and recursive structures, as shown in Figure 9.
Reference: <author> Brodal, G. S. </author> <title> (1996) Worst-case priority queues. </title> <booktitle> ACM-SIAM Symposium on Discrete Algorithms pp. </booktitle> <pages> 52-58. </pages>
Reference: <author> Brown, M. R. </author> <title> (1978) Implementation and analysis of binomial queue algorithms. </title> <journal> SIAM Journal on Computing 7(3) </journal> <pages> 298-319. </pages>
Reference: <author> Buchsbaum, A. L. and Tarjan, R. E. </author> <title> (1995) Confluently persistent deques via data structural bootstrapping. </title> <journal> Journal of Algorithms 18(3) </journal> <pages> 513-547. </pages>
Reference: <author> Buchsbaum, A. L., Sundar, R. and Tarjan, R. E. </author> <title> (1995) Data-structural bootstrapping, linear path compression, and catenable heap-ordered double-ended queues. </title> <journal> SIAM Journal on Computing 24(6) </journal> <pages> 1190-1206. </pages>
Reference: <author> Crane, C. A. </author> <title> (1972) Linear lists and priority queues as balanced binary trees. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Stanford University. </institution> <note> Available as STAN-CS-72-259. </note>
Reference: <author> Driscoll, J. R., Sarnak, N., Sleator, D. D. K. and Tarjan, R. E. </author> <title> (1989) Making data structures persistent. </title> <journal> Journal of Computer and System Sciences 38(1) </journal> <pages> 86-124. </pages>
Reference-contexts: 1 Introduction Purely functional data structures differ from imperative data structures in at least two respects. First, many imperative data structures rely crucially on destructive assignments for efficiency, whereas purely functional data structures are forbidden from using destructive assignments. Second, purely functional data structures are automatically persistent <ref> (Driscoll et al., 1989) </ref>, meaning that, after an update, both y Research partially supported by the ESPRIT II Basic Research Actions Program of the EC under contract no. 7141 (project ALCOM II) and by the Danish Natural Science Research Council (Grant No. 9400044). z Basic Research in Computer Science, Centre of
Reference: <author> Fredman, M. L. and Tarjan, R. E. </author> <title> (1987) Fibonacci heaps and their uses in improved network optimization algorithms. </title> <journal> Journal of the ACM 34(3) </journal> <pages> 596-615. </pages>
Reference-contexts: Figure 1 displays a Standard ML signature for these priority queues. Brodal (1995) recently introduced the first imperative data structure to support all these operations in O (1) worst-case time except deleteMin, which requires O (log n) worst-case time. Several previous implementations, most notably Fibonacci heaps <ref> (Fredman & Tarjan, 1987) </ref>, had achieved these bounds, but in an amortized, rather that worst-case, sense. <p> Schoenmakers (1992), extending earlier work with Kaldewaij (1991), uses functional notation to aid in the derivation of amortized bounds for a number of data structures, including three priority queues: skew heaps y (Sleator & Tarjan, 1986), Fibonacci heaps <ref> (Fredman & Tarjan, 1987) </ref>, and pairing heaps (Fredman et al., 1986). Schoenmakers also discusses splay trees (Sleator & Tarjan, 1985), a form of self-adjusting binary search tree that has been shown by Jones (1986) to be particularly effective as a non-meldable priority queue.
Reference: <author> Fredman, M. L., Sedgewick, R., Sleator, D. D. K. and Tarjan, R. E. </author> <title> (1986) The pairing heap: A new form of self-adjusting heap. </title> <journal> Algorithmica 1(1) </journal> <pages> 111-129. </pages>
Reference-contexts: Schoenmakers (1992), extending earlier work with Kaldewaij (1991), uses functional notation to aid in the derivation of amortized bounds for a number of data structures, including three priority queues: skew heaps y (Sleator & Tarjan, 1986), Fibonacci heaps (Fredman & Tarjan, 1987), and pairing heaps <ref> (Fredman et al., 1986) </ref>. Schoenmakers also discusses splay trees (Sleator & Tarjan, 1985), a form of self-adjusting binary search tree that has been shown by Jones (1986) to be particularly effective as a non-meldable priority queue. Each of these four data structures is efficient only in the amortized sense.
Reference: <author> Hood, R. </author> <title> (1982) The Efficient Implementation of Very-High-Level Programming Language Constructs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University. </institution> <type> (Cornell TR 82-503). </type>
Reference: <author> Hoogerwoord, R. R. </author> <title> (1992) A logarithmic implementation of flexible arrays. </title> <booktitle> Conference on Mathematics of Program Construction. </booktitle> <volume> LNCS 669, </volume> <pages> pp. 191-207. </pages> <publisher> Springer-Verlag. </publisher>
Reference: <author> Hudak, P., Peyton Jones, S., Wadler, P., Boutel, B., Fairbairn, J., Fasel, J., Guzman, M. M., Hammond, K., Hughes, J., Johnsson, T., Kieburtz, D., Nikhil, R., Partain, W. and Peterson, J. </author> <title> (1992) Report on the functional programming language Haskell, Version 1.2. </title> <journal> SIGPLAN Notices 27(5). </journal>
Reference-contexts: Although we have implemented our data structure in Standard ML, a strict functional language, it could easily be translated into other functional languages, even lazy languages such as Haskell <ref> (Hudak et al., 1992) </ref>. However, in a lazy language, the worst-case bounds become amortized because the actions of each insert, meld, and deleteMin are delayed until their results are needed by a findMin.
Reference: <author> Jones, D. W. </author> <title> (1986) An empirical comparison of priority-queue and event-set implementations. </title> <journal> Communications of the ACM 29(4) </journal> <pages> 300-311. </pages>
Reference-contexts: A variant of Paulson's queues, using the slightly simpler front-extension of Hoogerwoord, appears to be part of the functional programming folklore. King (1994) presents a purely functional implementation of binomial queues. Although binomial queues are considered to be rather complicated in imperative settings <ref> (Jones, 1986) </ref>, King demonstrates that the more convenient list-processing capabilities of functional languages support binomial queues quite elegantly.
Reference: <author> Kaldewaij, A. and Schoenmakers, B. </author> <title> (1991) The derivation of a tighter bound for top-down skew heaps. </title> <journal> Information Processing Letters 37(5) </journal> <pages> 265-271. </pages>
Reference: <author> Kaplan, H. and Tarjan, R. E. </author> <title> (1995) Persistent lists with catenation via recursive slowdown. </title> <booktitle> ACM Symposium on Theory of Computing pp. </booktitle> <pages> 93-102. </pages>
Reference: <author> King, D. J. </author> <title> (1994) Functional binomial queues. </title> <booktitle> Glasgow Workshop on Functional Programming pp. </booktitle> <pages> 141-150. </pages> <note> 20 Brodal and Okasaki MacQueen, </note> <author> D. B. and Tofte, M. </author> <title> (1994) A semantics for higher-order functors. </title> <booktitle> European Symposium on Programming pp. </booktitle> <pages> 409-423. </pages>
Reference: <author> Milner, R., Tofte, M. and Harper, R. </author> <title> (1990) The Definition of Standard ML. </title> <publisher> The MIT Press. </publisher>
Reference-contexts: After describing a few possible optimizations, we conclude with brief discussions of related work and future work. 4 Brodal and Okasaki Rank 0 s Rank 1 s Rank 2 s s Rank 3 s s , ,s s All source code is presented in Standard ML <ref> (Milner et al., 1990) </ref> and is available through the World Wide Web from http://foxnet.cs.cmu.edu/people/cokasaki/priority.html 2 Binomial Queues Binomial queues are an elegant form of priority queue introduced by Vuillemin (1978) and extensively studied by Brown (1978). <p> First-order functors can only take and return structures, but higher-order functors can take and return other functors as well. Although the definition of Standard ML <ref> (Milner et al., 1990) </ref> describes only first-order func-tors, some implementations of Standard ML, notably Standard ML of New Jersey, support higher-order functors.
Reference: <author> Myers, E. W. </author> <title> (1983) An applicative random-access stack. </title> <journal> Information Processing Letters 17(5) </journal> <pages> 241-248. </pages>
Reference-contexts: We can reduce the cost of an insert to at most a single link by borrowing a technique from random-access lists (Okasaki, 1995b). Random-access lists are based on a variant number system, called skew binary numbers <ref> (Myers, 1983) </ref>, in which adding one causes at most a single carry. 6 Brodal and Okasaki functor BinomialQueue (E : ORDERED) : PRIORITY QUEUE = struct structure Elem = E type Rank = int datatype Tree = Node of Elem.T fi Rank fi Tree list type T = Tree list (fl
Reference: <author> Okasaki, C. </author> <year> (1995a) </year> <month> Amortization, </month> <title> lazy evaluation, and persistence: Lists with catenation via lazy linking. </title> <booktitle> IEEE Symposium on Foundations of Computer Science pp. </booktitle> <pages> 646-654. </pages>
Reference: <author> Okasaki, C. </author> <title> (1995b) Purely functional random-access lists. </title> <booktitle> Conference on Functional Programming Languages and Computer Architecture pp. </booktitle> <pages> 86-95. </pages>
Reference-contexts: We can reduce the cost of an insert to at most a single link by borrowing a technique from random-access lists <ref> (Okasaki, 1995b) </ref>.
Reference: <author> Okasaki, C. </author> <title> (1995c) Simple and efficient purely functional queues and deques. </title> <journal> Journal of Functional Programming 5(4) </journal> <pages> 583-592. </pages>
Reference: <author> Okasaki, C. </author> <title> (1996) The role of lazy evaluation in amortized data structures. </title> <booktitle> ACM SIG-PLAN International Conference on Functional Programming pp. </booktitle> <pages> 62-72. </pages>
Reference-contexts: We use skew linking to reduce the cost of insertion in binomial queues to O (1), but recursive slowdown (Ka-plan & Tarjan, 1995) and lazy evaluation <ref> (Okasaki, 1996) </ref> could be used for the same purpose.
Reference: <author> Paulson, L. C. </author> <title> (1991) ML for the Working Programmer. </title> <publisher> Cambridge University Press. </publisher>
Reference: <author> Schoenmakers, B. </author> <title> (1992) Data Structures and Amortized Complexity in a Functional Setting. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology. </institution>
Reference: <author> Sleator, D. D. K. and Tarjan, R. E. </author> <title> (1985) Self-adjusting binary search trees. </title> <journal> Journal of the ACM 32(3) </journal> <pages> 652-686. </pages>
Reference-contexts: Schoenmakers also discusses splay trees <ref> (Sleator & Tarjan, 1985) </ref>, a form of self-adjusting binary search tree that has been shown by Jones (1986) to be particularly effective as a non-meldable priority queue. Each of these four data structures is efficient only in the amortized sense.
Reference: <author> Sleator, D. D. K. and Tarjan, R. E. </author> <title> (1986) Self-adjusting heaps. </title> <journal> SIAM Journal on Computing 15(1) </journal> <pages> 52-69. </pages>
Reference-contexts: Schoenmakers (1992), extending earlier work with Kaldewaij (1991), uses functional notation to aid in the derivation of amortized bounds for a number of data structures, including three priority queues: skew heaps y <ref> (Sleator & Tarjan, 1986) </ref>, Fibonacci heaps (Fredman & Tarjan, 1987), and pairing heaps (Fredman et al., 1986). Schoenmakers also discusses splay trees (Sleator & Tarjan, 1985), a form of self-adjusting binary search tree that has been shown by Jones (1986) to be particularly effective as a non-meldable priority queue.
Reference: <author> Tarjan, R. E. </author> <title> (1983) Data Structures and Network Algorithms. </title> <booktitle> CBMS Regional Conference Series in Applied Mathematics, </booktitle> <volume> vol. </volume> <pages> 44. </pages> <institution> Society for Industrial and Applied Mathematics. </institution>
Reference: <author> Vuillemin, J. </author> <title> (1978) A data structure for manipulating priority queues. </title> <journal> Communications of the ACM 21(4) </journal> <pages> 309-315. </pages>
Reference: <editor> Wadler, P. </editor> <booktitle> (1990) Linear types can change the world! Proceedings of the IFIP TC 2 Working Conference on Programming Concepts and Methods pp. </booktitle> <pages> 561-581. </pages>
Reference-contexts: Although he uses functional notation, Schoen-makers restricts his attention to ephemeral uses of data structures, where only the most recent version of a data structure may be accessed or updated. Ephemerality is closely related to the notion of linearity <ref> (Wadler, 1990) </ref>. When persistence is allowed, traditional amortized analyses break down because operations on "expensive" versions of a data structure can be repeated arbitrarily often. Okasaki (1995a; 1996) describes how to use the memoization implicit in lazy evaluation to support amortized data structures whose bounds hold even under persistence.
Reference: <author> Williams, J. W. J. </author> <title> (1964) Algorithm 232: Heapsort. </title> <journal> Communications of the ACM 7(6) </journal> <pages> 347-348. </pages>
Reference-contexts: Optimal Purely Functional Priority Queues 17 Paulson (1991) describes a (non-meldable) priority queue combining the techniques of implicit heaps <ref> (Williams, 1964) </ref>, which traditionally are implemented using arrays, with a balanced-tree representation of arrays supporting extension at the rear. Hoogerwoord (1992) represents arrays using the same trees as Paulson, but also allows the arrays to be extended at the front.
References-found: 30

