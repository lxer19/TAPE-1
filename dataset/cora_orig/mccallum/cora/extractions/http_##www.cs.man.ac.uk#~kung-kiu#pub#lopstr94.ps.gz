URL: http://www.cs.man.ac.uk/~kung-kiu/pub/lopstr94.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: kung-kiu@cs.man.ac.uk  ornaghi@imiucca.csi.unimi.it  
Phone: 2  
Title: On Specification Frameworks and Deductive Synthesis of Logic Programs  
Author: Kung-Kiu Lau and Mario Ornaghi 
Address: Oxford Road, Manchester M13 9PL, United Kingdom  Via Comelico 39/41, Milano, Italy  
Affiliation: 1 Department of Computer Science, University of Manchester  Dipartimento di Scienze dell'Informazione Universita' degli studi di Milano  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> A. Bertoni, G. Mauri and P. Miglioli. </author> <title> On the power of model theory in specifying abstract data types and in capturing their recursiveness. </title> <note> Fundamenta Informaticae VI(2):127-170, </note> <year> 1983. </year>
Reference-contexts: If we use isoinitial semantics instead of initial semantics, we get such a criterion 5 As is well-known in logic programming, the completion of a normal program may be inconsistent, or it may have many incomparable models. Isoinitial semantics was introduced in <ref> [1] </ref>, as a semantic characterisation of the computable ADT's. <p> As a consequence, isoinitial models turn out to be always recursive, whilst this property is not guaranteed, in general, for initial models. An extensive comparison of the two kinds of semantics can be found in <ref> [1] </ref>. We will make use of the following criterion for the existence of isoinitial models. Definition 3. We say that a model M of a theory F is reachable if every element of the domain of M is represented by some closed term of the language of F.
Reference: 2. <author> C.C. Chang and H.J. Keisler. </author> <title> Model Theory. </title> <publisher> North-Holland, </publisher> <year> 1973. </year>
Reference-contexts: The interpretation of the new symbol r in the expansion I r is the following: for every tuple t of constructions (of the appropriate sorts), t belongs to r I r iff F [ D r ` r (t). We recall that in an expansion of a model (see <ref> [2] </ref>) by new symbols, the interpretation of the old ones remains unchanged. Thus an adequate expansion F [ D r preserves the semantics of the symbols already present in L F . This nice property holds only for completely defined relations, however.
Reference: 3. <author> K.L. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <year> 1978. </year>
Reference-contexts: The existence of a set of construction symbols satisfying the freeness axioms is not strictly necessary (reachability sufficies). It is required here, since we deal with synthesis of logic programs and use Clark's equality theory 7 <ref> [3] </ref> for construction symbols. Of course, in logic programs only construction symbols can be used for constant and function symbols. Example 4. As we have already seen, PA is a closed framework. <p> , we define: * free (P ) to be the freeness axioms for the constant and function symbols of P . * Comp + (P ) = free (P ) [ Ax (P ), where Ax (P ) is the if -part of Comp (P ), the completion of P <ref> [3] </ref>. * Comp (P; r) is the only-if -part of the completed definition of a predicate r in P : For convenience, we shall also write Comp (P; r 1 ; : : : ; r n ) for multiple pred icate symbols.
Reference: 4. <author> K.L. Clark and S.- A. </author> <title> Tarnlund. A first order theory of data and programs. </title> <booktitle> Proc. </booktitle> <pages> IFIP 77 , pages 939-944. </pages> <publisher> North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: For logic programming, Clark and Tarnlund <ref> [4] </ref> formulated a first-order theory of programs and data. Other examples of first-order theories of general interest to Computer Science are presented in [12]. However, a systematic use of axiomatisations to specify data and programs has been studied mainly in the field of algebraic specifications of abstract data types (ADT's).
Reference: 5. <author> Y. Deville and K.K. Lau. </author> <title> Logic program synthesis. </title> <note> To appear in J. Logic Programming, special issue on "Ten Years of Logic Programming", </note> <year> 1994. </year>
Reference-contexts: 1 Introduction Logic program synthesis methods can be roughly divided into those that use a formal specification and a formal synthesis process, and those that use an informal specification and an informal synthesis technique. A taxonomy and a survey of logic program synthesis methods can be found in <ref> [5] </ref>. In formal methods for logic program synthesis, the issue of what specification language is best has never loomed large, because first-order logic is the obvious candidate and hence the natural choice. This, in our view, has resulted in an over-simplistic view of logic program specifications.
Reference: 6. <author> J.A. Goguen and J. Meseguer. </author> <title> EQLOG: Equality, types,and generic modules for logic programming. </title> <editor> In D. DeGroot and G. Lindstrom, editors, </editor> <title> Logic Programming: Functions, Relations, </title> <booktitle> and Equations, </booktitle> <pages> pages 295-363. </pages> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: In our approach to modularity, we borrow many of the basic ideas developed in the algebraic approach (e.g. <ref> [6, 7, 14] </ref>). We shall briefly contrast the two approaches in Section 2.3. 2 Specification Frameworks and Specifications In this section, we give an informal introduction to specification frameworks, and show why and how we distinguish between them and specifications. <p> However, a systematic use of axiomatisations to specify data and programs has been studied mainly in the field of algebraic specifications of abstract data types (ADT's). We refer in particular to the so-called initial algebra approach, which has been popularised by many authors (e.g. <ref> [8, 6, 7, 14] </ref>). In our approach, we incorporate many of their basic ideas (and their terminology): in particular, modularity (and parametric modules, like LIST ), and intended-model semantics. However, there are some major and fundamental differences. <p> Consequently, we cannot exploit the strengths of the initial algebra approach, namely that: (a) Equational theory admits an initial model [8], unique up to isomorphism, and this result can be easily extended to Horn axioms (as in EQLOG <ref> [6] </ref>). (b) There is a correspondence between truth in the initial model and provability for positive formulas.
Reference: 7. <author> J.A. Goguen and J. Meseguer. </author> <title> Unifying functional, object-oriented and relational programming with logical semantics. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: In our approach to modularity, we borrow many of the basic ideas developed in the algebraic approach (e.g. <ref> [6, 7, 14] </ref>). We shall briefly contrast the two approaches in Section 2.3. 2 Specification Frameworks and Specifications In this section, we give an informal introduction to specification frameworks, and show why and how we distinguish between them and specifications. <p> However, a systematic use of axiomatisations to specify data and programs has been studied mainly in the field of algebraic specifications of abstract data types (ADT's). We refer in particular to the so-called initial algebra approach, which has been popularised by many authors (e.g. <ref> [8, 6, 7, 14] </ref>). In our approach, we incorporate many of their basic ideas (and their terminology): in particular, modularity (and parametric modules, like LIST ), and intended-model semantics. However, there are some major and fundamental differences.
Reference: 8. <author> J.A. Goguen, J.W. Thatcher and E. Wagner. </author> <title> An initial algebra approach to specification, correctness and implementation. </title> <editor> In R. Yeh, editor, </editor> <booktitle> Current Trends in Programming Methodology, </booktitle> <pages> IV , pages 80-149. </pages> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference-contexts: However, a systematic use of axiomatisations to specify data and programs has been studied mainly in the field of algebraic specifications of abstract data types (ADT's). We refer in particular to the so-called initial algebra approach, which has been popularised by many authors (e.g. <ref> [8, 6, 7, 14] </ref>). In our approach, we incorporate many of their basic ideas (and their terminology): in particular, modularity (and parametric modules, like LIST ), and intended-model semantics. However, there are some major and fundamental differences. <p> In contrast, the initial algebra approach only allows restricted classes of axioms. Consequently, we cannot exploit the strengths of the initial algebra approach, namely that: (a) Equational theory admits an initial model <ref> [8] </ref>, unique up to isomorphism, and this result can be easily extended to Horn axioms (as in EQLOG [6]). (b) There is a correspondence between truth in the initial model and provability for positive formulas.
Reference: 9. <author> K.K. Lau and M. Ornaghi. </author> <title> An incompleteness result for deductive synthesis of logic programs. </title> <editor> In D.S. Warren, editor, </editor> <booktitle> Proc. 10 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 456-477, </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Such a simplistic approach to specification has, in our experience, two major drawbacks: * It cannot capture the entire body of knowledge needed for and used in the synthesis process. For example, our formalisation of deductive synthesis of logic programs in <ref> [9] </ref> reveals that the synthesis process has to make use of background knowledge not captured by the if-and-only-if definition of the specified relation. Such knowledge includes relevant theories, e.g. of data types, with induction schema, etc. * It does not provide an adequate means to specify properties other than correctness. <p> The second author was partially supported by MURST. programs, then we need to use axiomatisations which allow us to reason about program modularity and composition. In our work <ref> [9, 10] </ref>, therefore, we have used specification frameworks to provide the background for deductive synthesis of logic programs. In this paper, we take a closer look at such frameworks.
Reference: 10. <author> K.K. Lau, M. Ornaghi, and S.- A. </author> <title> Tarnlund. The halting problem for deductive synthesis of logic programs. </title> <editor> In P. Van Hentenryck, editor, </editor> <booktitle> Proc. 11 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 665-683. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Such knowledge includes relevant theories, e.g. of data types, with induction schema, etc. * It does not provide an adequate means to specify properties other than correctness. For example, in <ref> [10] </ref>, we show that if we want to synthesise steadfast programs, i.e. programs that are modular in the sense that they define program units that remain correct (and hence unchanged) when integrated into larger ? The first author was partially supported by the EC HCM project on Logic Program Synthesis and <p> The second author was partially supported by MURST. programs, then we need to use axiomatisations which allow us to reason about program modularity and composition. In our work <ref> [9, 10] </ref>, therefore, we have used specification frameworks to provide the background for deductive synthesis of logic programs. In this paper, we take a closer look at such frameworks. <p> Then we show how synthesis can be used to determine the adequacy of any expansion of a closed or open framework. For an adequate open framework, we also introduce the notion of open, reusable programs. 6.1 Deductive Synthesis of Logic Programs First, as in <ref> [10] </ref>, for a program P , we define: * free (P ) to be the freeness axioms for the constant and function symbols of P . * Comp + (P ) = free (P ) [ Ax (P ), where Ax (P ) is the if -part of Comp (P ), <p> However, (i) and (ii) together do not ensure total correctness. In Sections 6.2 and 6.3, we will define the notion of total correctness in closed and open frameworks precisely. In the meantime, we state a criterion for halting synthesis with a totally correct program, which we presented in <ref> [10] </ref>. Definition 9. <p> We say that a program P ground terminates if, for every relation symbol r of P , and every ground goal r (t), the SLD -tree for P [ f r (t)g contains at least one success node or is finitely failed. 9 The following theorem holds (see <ref> [10] </ref>): 9 We assume a fair computation rule. Theorem 11. Let hD 0 ; Gi be a specification in a closed framework F , where r 0 is the relation defined by D 0 . <p> Now we can compare the positive diagrams with the Herbrand models of programs, and we introduce and define steadfastness (as in <ref> [10] </ref>) as follows: Definition 13. Let M be a class of models, and assume that, for every model M 2 M, there is a set C M of construction symbols of L M such that M is C M - generable. <p> It follows from the fact that P [ Q ` Comp (P j [ Q; r 1 ; : : : ; r k ; q 1 ; : : : ; q m ), and from Theorem 11. More general facts about steadfast programs could be proved (see <ref> [10] </ref>), but they are not directly applicable to the methodology outlined here.
Reference: 11. <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1987. </year>
Reference-contexts: (S)) G sort = f9S : List : sort (l; S) j l is groundg The relations ord and sort depend on the ordering : List fiList ; hence this specification specifies a class of sorting programs, depending on the interpretations of : List fi List. 4 As defined in <ref> [11] </ref>. 2.3 Background and Motivation Various axiomatisations of data and programs can be found in the literature. For logic programming, Clark and Tarnlund [4] formulated a first-order theory of programs and data. Other examples of first-order theories of general interest to Computer Science are presented in [12].
Reference: 12. <author> Z. Manna and R. Waldinger. </author> <booktitle> The Deductive Foundations of Computer Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: For logic programming, Clark and Tarnlund [4] formulated a first-order theory of programs and data. Other examples of first-order theories of general interest to Computer Science are presented in <ref> [12] </ref>. However, a systematic use of axiomatisations to specify data and programs has been studied mainly in the field of algebraic specifications of abstract data types (ADT's). We refer in particular to the so-called initial algebra approach, which has been popularised by many authors (e.g. [8, 6, 7, 14]).
Reference: 13. <author> J.C. Shepherdson. </author> <title> Negation in Logic Programming. </title> <editor> in J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 19-88. </pages> <publisher> Morgan Kauf-mann, </publisher> <year> 1988. </year>
Reference-contexts: There is at least one model of F reachable by a subset of the constant and function symbols of L F , called the construction symbols. The ground terms containing only construction symbols will be called construc tions. Freeness. F proves the freeness axioms <ref> [13] </ref> for the construction symbols. Atomic completeness. F is atomically complete. Thus, by Theorem 4, a closed framework is a theory admitting an isoinitial model. The existence of a set of construction symbols satisfying the freeness axioms is not strictly necessary (reachability sufficies).
Reference: 14. <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: In our approach to modularity, we borrow many of the basic ideas developed in the algebraic approach (e.g. <ref> [6, 7, 14] </ref>). We shall briefly contrast the two approaches in Section 2.3. 2 Specification Frameworks and Specifications In this section, we give an informal introduction to specification frameworks, and show why and how we distinguish between them and specifications. <p> However, a systematic use of axiomatisations to specify data and programs has been studied mainly in the field of algebraic specifications of abstract data types (ADT's). We refer in particular to the so-called initial algebra approach, which has been popularised by many authors (e.g. <ref> [8, 6, 7, 14] </ref>). In our approach, we incorporate many of their basic ideas (and their terminology): in particular, modularity (and parametric modules, like LIST ), and intended-model semantics. However, there are some major and fundamental differences.
References-found: 14

