URL: http://www.pmg.lcs.mit.edu/~umesh/pubs/thesis_draft.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/~umesh/pubs/
Root-URL: 
Title: Garbage Collection in a Large, Distributed Object Store  
Author: by Umesh Maheshwari Barbara Liskov Arthur C. Smith 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Doctor of Philosophy in Computer Science and Engineering at the  c Umesh Maheshwari, MCMXCVII. All rights reserved. The author hereby grants to MIT permission to reproduce and distribute publicly paper and electronic copies of this thesis document in whole or in part, and to grant others the right to do so. Author  Certified by  Ford Professor of Engineering Thesis Supervisor Accepted by  Chairman, Departmental Committee on Graduate Students  
Date: September 1997  September 1, 1997  
Affiliation: MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [ABC + 83] <author> Malcolm P. Atkinson, P. J. Bailey, K. J. Chisholm, P. W. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> Computer Journal, </journal> <volume> 26(4) </volume> <pages> 360-365, </pages> <year> 1983. </year>
Reference-contexts: A consequence of the safety rule and the fact that the persistent roots are always reachable is that objects reachable from a persistent root must exist; this is often known as persistence by reachability <ref> [ABC + 83] </ref>. Garbage collection might not be suitable for a network of sites owned by many users with little common interest, such as the Internet. In such networks, the need for autonomous control of storage overrides the need to prevent dangling references.
Reference: [Ady94] <author> A. Adya. </author> <title> Transaction management for mobile objects using optimistic concurrency control. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: We assume an underlying mechanism for August 13, 1997 DRAFT CHAPTER 6. INTER-SITE GARBAGE CYCLES 75 migrating objects that is robust against concurrent mutations and that updates references to migrated objects <ref> [DLMM94, Ady94] </ref>. Migration has been proposed earlier to collect distributed cycles [Bis77, SGP90]. However, previous proposals used weak heuristics to decide which objects to migrate. A popular heuristic was to move to all objects not locally reachable from a global root.
Reference: [AFFS95] <author> Laurent Amsaleg, P. Ferreira, Michael Franklin, and Marc Shapiro. </author> <title> Evaluating garbage collection for large persistent stores. </title> <booktitle> In Addendum to Proc. 1995 OOPSLA Workshop on Object Database Behavior. </booktitle> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: In our experiments, however, we accounted for the expected log overhead from these actions; they were found to be negligible. 3.4.2 Workload Amsaleg et al. pointed out the lack of a standard benchmark for database garbage collectors <ref> [AFFS95] </ref>; such a benchmark remains absent today. Therefore, we designed a micro-benchmark specifically for evaluating the overhead of maintaining insets. The benchmark database consists of a homogenous collection of small objects, each of which has a single reference and some data fields.
Reference: [AGF95] <author> Laurent Amsaleg, Olivier Gruber, and Michael Franklin. </author> <title> Efficient incremental garbage collection for workstation-server database systems. </title> <booktitle> In Proc. 21st VLDB. </booktitle> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: Thus, timeliness and efficiency require that the disk space be divided into smaller partitions that are traced independently. This is the approach taken in many single-site systems with large, disk-based heaps <ref> [Bis77, YNY94, AGF95, MMH96, CKWZ96] </ref>. However, to trace a site independently of other sites, and a partition independently of other partitions, objects reachable from other sites or other partitions on the same site must not be August 13, 1997 DRAFT CHAPTER 1. INTRODUCTION 14 collected. <p> Partitioned garbage collection of a persistent store involves a wide range of other issues such as the choice of the tracing algorithm (marking, copying [Bak78], replicating [ON93], etc.), the selection of partitions to trace [CWZ94], the rate of starting traces [CKWZ96], handling transactional rollback <ref> [AGF95] </ref>, etc. This thesis either does not cover the above issues or addresses them only marginally. <p> Applications may use handles obtained during one transaction in subsequent transactions. Some other systems constrain applications to release all handles with each transaction <ref> [AGF95] </ref>, so an 19 CHAPTER 2. THE CONTEXT 20 application must start each transaction from the persistent root. This constraint makes garbage collection simpler because it need not account for handles held by applications. However, this constraint makes it inconvenient to write applications. <p> Not using the steal policy simplifies garbage collection because it ensures that the collector does not see uncommitted data. Other researchers have provided solutions for problems that arise from seeing uncommitted data <ref> [AGF95] </ref>. Their solutions can be used in conjunction with the techniques suggested in this thesis. August 13, 1997 DRAFT CHAPTER 2. THE CONTEXT 25 2.6 Failure Model A Thor client might crash at any time and never recover. On the other hand, servers are expected to recover from crashes. <p> However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts [Bev87, Piq91], and reference source-listing <ref> [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96] </ref>. This chapter presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. The above scheme successfully collects chains of garbage objects across multiple partitions. <p> Therefore, a trace of the entire disk is likely to have poor locality of reference. It would thrash on disk, i.e., fetch and evict a disk page many times in order to scan different objects in the page <ref> [YNY94, AGF95] </ref>. On the other hand, a partition trace fetches the pages of one partition into memory and scans all live objects in them before fetching another partition. <p> On the other hand, big partitions mean more memory space used by the collector, which reduces the memory available for the server cache. Further, if the partition does not fit in the memory available, the trace would thrash on disk as shown in previous studies <ref> [AGF95] </ref>. Therefore, partitions should fit in a fraction, say, a tenth, of main memory. Given current memory sizes, a partition may be a few megabytes to tens of megabytes. <p> Arranging inter-partition references into translists and sharing them between insets and outsets provides a cheap mechanism to record both insets and outsets. Other single-site partitioned collectors implement insets as a sequence of pairs hreference, source-partitioniand do not provide mechanisms to find the outset <ref> [AGF95, MMH96] </ref>. The scheme by Amsaleg et al. must scan the insets of all partitions after a trace to remove untraced references [AGF95]. <p> Other single-site partitioned collectors implement insets as a sequence of pairs hreference, source-partitioniand do not provide mechanisms to find the outset [AGF95, MMH96]. The scheme by Amsaleg et al. must scan the insets of all partitions after a trace to remove untraced references <ref> [AGF95] </ref>. The scheme by Moss et al. computes the outset whenever a page is fetched and also when a modified page is evicted, and applies the differences to insets [HM92, MMH96]. <p> Finally, the use of slotted pages allows a mark-and-sweep scheme to compact live objects by sliding them within their pages, as discussed later in Section 3.3.4. Amsaleg et al. also chose a mark-and-sweep scheme for these reasons in the context of another object database <ref> [AGF95] </ref>. 3.3.1 Safe Tracing A trace that runs concurrently with ongoing transactions needs to see a safe view of the object graph such that it does not miss any references due to concurrent modifications.
Reference: [AGLM95] <author> A. Adya, R. Gruber, B. Liskov, and U. Maheshwari. </author> <title> Efficient optimistic concurrency control using loosely synchronized clocks. </title> <booktitle> In Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 23-34. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1995. </year>
Reference-contexts: A client executes requested operations on local copies of objects. This may require fetching objects from servers into a local cache. New and modified objects in the client cache are sent to the servers when a transaction commits. Thor uses optimistic concurrency control to ensure the atomicity of transactions <ref> [AGLM95] </ref>, so a client does not lock the objects it uses. This improves performance but it means that objects in client caches might be out of date. Both server and client sites might crash and lose contents of main memory. <p> In particular, a client need not lock objects before using them, which would require contacting the server and possibly other clients [CFZ94]. For concreteness, we indicate the transactional mechanisms employed in Thor. Thor uses optimistic concurrency control <ref> [AGLM95] </ref>. A transaction does not lock the objects is uses; instead, it is validated against previous transactions when it commits. Validation requires information about the objects read and modified by the transaction. This information is logged by the client and sent to the servers at commit time.
Reference: [Ali85] <author> K. A. M. Ali. </author> <title> Garbage collection schemes for distributed storage systems. </title> <booktitle> In Proc. Workshop on Implementation of Functional Languages, </booktitle> <pages> pages 422-428, </pages> <year> 1985. </year>
Reference-contexts: It would also not be fault tolerant in a system with thousands of sites. Thus, timeliness and fault tolerance require that a site trace local objects independently of other sites. This is the approach taken in many distributed systems <ref> [Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Independent tracing of sites has the locality property: Collecting a garbage object involves only the sites it is reachable from. This property minimizes inter-site dependence. In particular, garbage not reachable from other sites is collected locally. <p> The challenge in collecting an inter-site garbage cycle is to preserve the locality property, that is, to involve only the sites containing the cycle. This has August 13, 1997 DRAFT CHAPTER 1. INTRODUCTION 17 proven surprisingly difficult. Most previous schemes do not preserve locality <ref> [Ali85, JJ92, LQP92, MKI + 95, RJ96] </ref>. The few that do are prohibitively costly [SGP90, Sch89, LC97]. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> Minimizing inter-site dependence requires the locality property: Collecting a garbage cycle should involve only the sites containing it. Locality has proven surprisingly difficult to preserve in collecting inter-site cycles; most previous schemes do not preserve locality. For example, some conduct periodic global marking in addition to site-marking <ref> [Ali85, JJ92] </ref>. The drawbacks of global marking can be alleviated by marking within groups of selected sites [LQP92, MKI + 95, RJ96], but inter-group cycles might never be collected. Few schemes for collecting inter-site cycles have the locality property.
Reference: [Bak78] <author> Henry G. Baker. </author> <title> List processing in real-time on a serial computer. </title> <journal> CACM, </journal> <volume> 21(4) </volume> <pages> 280-94, </pages> <year> 1978. </year>
Reference-contexts: We describe techniques for acquiring a consistent view of a partition in such an environment. Partitioned garbage collection of a persistent store involves a wide range of other issues such as the choice of the tracing algorithm (marking, copying <ref> [Bak78] </ref>, replicating [ON93], etc.), the selection of partitions to trace [CWZ94], the rate of starting traces [CKWZ96], handling transactional rollback [AGF95], etc. This thesis either does not cover the above issues or addresses them only marginally.
Reference: [Bak93] <author> Henry G. Baker. </author> <title> `Infant mortality' and generational garbage collection. </title> <journal> ACM SIG-PLAN Notices, </journal> <volume> 28(4), </volume> <year> 1993. </year>
Reference-contexts: Third, partitions allow faster garbage collection since the collector can focus on partitions that are likely to contain the most garbage. This is similar to generational collectors which collect newer partitions more frequently [Ung84]. Although the age-based heuristics of generational collectors are not applicable to persistent stores <ref> [Bak93] </ref>, other heuristics are available for selecting partitions [CWZ94]. Fourth, if the server crashes in the middle of a trace, the work done during the trace is wasted. <p> Most techniques described in this chapter can be used with a variety of tracing algorithms. We chose a mark-and-sweep scheme to trace a partition. A copying collector would use twice the space used by mark-and-sweep. Further, persistent stores often have little garbage to be collected <ref> [Bak93] </ref>, so a copying collector would spend significant time copying many live objects. Finally, the use of slotted pages allows a mark-and-sweep scheme to compact live objects by sliding them within their pages, as discussed later in Section 3.3.4.
Reference: [BEN + 93] <author> Andrew Birrell, David Evers, Greg Nelson, Susan Owicki, and Edward Wobber. </author> <title> Distributed garbage collection for network objects. </title> <type> Technical Report 116, </type> <institution> Digital Systems Research Center, </institution> <year> 1993. </year>
Reference-contexts: It would also not be fault tolerant in a system with thousands of sites. Thus, timeliness and fault tolerance require that a site trace local objects independently of other sites. This is the approach taken in many distributed systems <ref> [Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Independent tracing of sites has the locality property: Collecting a garbage object involves only the sites it is reachable from. This property minimizes inter-site dependence. In particular, garbage not reachable from other sites is collected locally. <p> However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts [Bev87, Piq91], and reference source-listing <ref> [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96] </ref>. This chapter presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. The above scheme successfully collects chains of garbage objects across multiple partitions. <p> Further, storing locations at a fine granularity results in more information if multiple locations contain the same reference. On the other hand, many distributed collectors do maintain both insets and outsets for inter-site references <ref> [SDP92, BEN + 93, ML94] </ref>. However, insets and outsets do not share translists; a translist is maintained at both the source and the target sites to avoid some messages. <p> The add message must reach T in time such that a trace at T does not miss the reference. There are various protocols for sending, deferring, or avoiding add messages without compromising safety and for tolerating lost messages <ref> [SDP92, BEN + 93, ML94] </ref>. Sections 5.2 and 5.3 describe new protocols to add client-to-server and server-to-server references. When S does a local trace, it removes the references in its outlists that are not reachable, and sends remove messages for them to their target sites. <p> When the count of a reference reduces to zero, it is removed from the inset. On the other hand, our scheme effectively records the identities of the source sites for each reference in the inset, a technique known as reference listing <ref> [Mah93, BEN + 93] </ref>. Reference listing keeps more information than reference counting, but we use it for the following reasons: 1. Reference listing tolerates permanent site failures. If a client or server X fails permanently, other servers need simply remove their inlists from X.
Reference: [Bev87] <author> David I. Bevan. </author> <title> Distributed garbage collection using reference counting. </title> <booktitle> In PARLE, volume 259 of Lecture Notes in Computer Science, </booktitle> <pages> pages 176-187. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: It would also not be fault tolerant in a system with thousands of sites. Thus, timeliness and fault tolerance require that a site trace local objects independently of other sites. This is the approach taken in many distributed systems <ref> [Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Independent tracing of sites has the locality property: Collecting a garbage object involves only the sites it is reachable from. This property minimizes inter-site dependence. In particular, garbage not reachable from other sites is collected locally. <p> However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts <ref> [Bev87, Piq91] </ref>, and reference source-listing [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96]. This chapter presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. <p> Reference Counting Some distributed systems use alternative forms of storing the inset, although most of them store outlists as described here. In inter-site reference counting, the target site keeps a count of source sites that hold a reference to a given local object <ref> [Bev87, Piq91] </ref>. When the count of a reference reduces to zero, it is removed from the inset. On the other hand, our scheme effectively records the identities of the source sites for each reference in the inset, a technique known as reference listing [Mah93, BEN + 93].
Reference: [Bis77] <author> Peter B. Bishop. </author> <title> Computer systems with a very large address space and garbage collection. </title> <type> Technical Report MIT/LCS/TR-178, </type> <institution> MIT, </institution> <year> 1977. </year> <note> 91 BIBLIOGRAPHY 92 </note>
Reference-contexts: Thus, timeliness and efficiency require that the disk space be divided into smaller partitions that are traced independently. This is the approach taken in many single-site systems with large, disk-based heaps <ref> [Bis77, YNY94, AGF95, MMH96, CKWZ96] </ref>. However, to trace a site independently of other sites, and a partition independently of other partitions, objects reachable from other sites or other partitions on the same site must not be August 13, 1997 DRAFT CHAPTER 1. INTRODUCTION 14 collected. <p> However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts [Bev87, Piq91], and reference source-listing <ref> [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96] </ref>. This chapter presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. The above scheme successfully collects chains of garbage objects across multiple partitions. <p> Few schemes for collecting inter-site cycles have the locality property. A prominent technique it to migrate an inter-site garbage cycle to a single site, where is collected by site-marking <ref> [Bis77, SGP90] </ref>. However, previous schemes based on migration are prone to migrating live objects besides garbage cycles, which is undesirable because migration is expensive. We present a practical scheme with locality to collect inter-site cycles. It has two parts. <p> We assume an underlying mechanism for August 13, 1997 DRAFT CHAPTER 6. INTER-SITE GARBAGE CYCLES 75 migrating objects that is robust against concurrent mutations and that updates references to migrated objects [DLMM94, Ady94]. Migration has been proposed earlier to collect distributed cycles <ref> [Bis77, SGP90] </ref>. However, previous proposals used weak heuristics to decide which objects to migrate. A popular heuristic was to move to all objects not locally reachable from a global root.
Reference: [BN84] <author> A. D. Birrell and B. J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1), </volume> <month> February </month> <year> 1984. </year>
Reference-contexts: Further, we present solutions to problems introduced by the use of optimistic concurrency control and the reuse of object names. In RPC-based (or function-shipping) distributed systems, inter-server references are created when references are transferred in a remote procedure call <ref> [BN84] </ref>. However, in client-caching (or data-shipping) transactional systems, inter-server references are created when clients commit transactions. We present a new protocol for recording inter-server references created in this manner.
Reference: [CDN93] <author> M. J. Carey, D. J. DeWitt, and J. F. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> In Proc. SIGMOD, </booktitle> <pages> pages 12-21. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1993. </year>
Reference-contexts: Cycles are common in practice; for example, in many CAD applications a container object points to its parts and the parts point back to the containerthus creating a huge tree with doubly linked edges <ref> [CDN93] </ref>. We present a site-wide marking scheme for collecting cycles between partitions on the same site. Complementary global marking has been proposed earlier to collect cyclic garbage in partitioned schemes. We present the first such scheme that has the following features [ML97b]: 1.
Reference: [CFZ94] <author> M. Carey, M. Franklin, and M. Zaharioudakis. </author> <title> Fine-Graned Sharing in a Page Server OODBMS. </title> <booktitle> In Proceedings of the 1994 ACM SIGMOD, </booktitle> <address> Minneapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: August 13, 1997 DRAFT CHAPTER 2. THE CONTEXT 23 2.4 Concurrency Control The techniques described in this thesis are applicable to a wide range of transactional systems. In particular, a client need not lock objects before using them, which would require contacting the server and possibly other clients <ref> [CFZ94] </ref>. For concreteness, we indicate the transactional mechanisms employed in Thor. Thor uses optimistic concurrency control [AGLM95]. A transaction does not lock the objects is uses; instead, it is validated against previous transactions when it commits. Validation requires information about the objects read and modified by the transaction.
Reference: [CKWZ96] <author> Jonathan E. Cook, Artur W. Klauser, Alexander L. Wolf, and Benjamin G. Zorn. </author> <title> Semi-automatic, self-adaptive control of garbage collection rates in object databases. </title> <booktitle> In Proc. 1996 SIGMOD. </booktitle> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: Thus, timeliness and efficiency require that the disk space be divided into smaller partitions that are traced independently. This is the approach taken in many single-site systems with large, disk-based heaps <ref> [Bis77, YNY94, AGF95, MMH96, CKWZ96] </ref>. However, to trace a site independently of other sites, and a partition independently of other partitions, objects reachable from other sites or other partitions on the same site must not be August 13, 1997 DRAFT CHAPTER 1. INTRODUCTION 14 collected. <p> Partitioned garbage collection of a persistent store involves a wide range of other issues such as the choice of the tracing algorithm (marking, copying [Bak78], replicating [ON93], etc.), the selection of partitions to trace [CWZ94], the rate of starting traces <ref> [CKWZ96] </ref>, handling transactional rollback [AGF95], etc. This thesis either does not cover the above issues or addresses them only marginally.
Reference: [CWZ94] <author> Jonathan E. Cook, Alexander L. Wolf, and Benjamin G. Zorn. </author> <title> Partition selection policies in object databases garbage collection. </title> <booktitle> In Proc. 1994 SIGMOD. </booktitle> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: We describe techniques for acquiring a consistent view of a partition in such an environment. Partitioned garbage collection of a persistent store involves a wide range of other issues such as the choice of the tracing algorithm (marking, copying [Bak78], replicating [ON93], etc.), the selection of partitions to trace <ref> [CWZ94] </ref>, the rate of starting traces [CKWZ96], handling transactional rollback [AGF95], etc. This thesis either does not cover the above issues or addresses them only marginally. <p> This is similar to generational collectors which collect newer partitions more frequently [Ung84]. Although the age-based heuristics of generational collectors are not applicable to persistent stores [Bak93], other heuristics are available for selecting partitions <ref> [CWZ94] </ref>. Fourth, if the server crashes in the middle of a trace, the work done during the trace is wasted. <p> A useful heuristic is to select partitions whose insets have reduced since the last time they were traced. Cook et al. have suggested some other heuristics for selecting partitions <ref> [CWZ94] </ref>. Most techniques described in this chapter can be used with a variety of tracing algorithms. We chose a mark-and-sweep scheme to trace a partition. A copying collector would use twice the space used by mark-and-sweep.
Reference: [DLMM94] <author> M. Day, B. Liskov, U. Maheshwari, and A. Myers. </author> <title> References to remote mobile objects in thor. </title> <journal> Letters on Programming Languages and Systems, </journal> <volume> 2(1-4):115-126, </volume> <year> 1994. </year>
Reference-contexts: At any time, a persistent object resides in a particular page at a particular server site. However, objects may be migrated to a different server. This leaves a surrogate object at the old location that contains a forwarding reference to the new location of the object <ref> [DLMM94] </ref>. Old references to a surrogate are updated in the background. As with normal objects, a surrogate is collected when it is not reachable from applications. In most cases, a server treats an object as a vector of untyped fields. <p> We assume an underlying mechanism for August 13, 1997 DRAFT CHAPTER 6. INTER-SITE GARBAGE CYCLES 75 migrating objects that is robust against concurrent mutations and that updates references to migrated objects <ref> [DLMM94, Ady94] </ref>. Migration has been proposed earlier to collect distributed cycles [Bis77, SGP90]. However, previous proposals used weak heuristics to decide which objects to migrate. A popular heuristic was to move to all objects not locally reachable from a global root.
Reference: [EH84] <author> W. Effelsberg and T. Haerder. </author> <title> Principles of database buffer management. </title> <journal> ACM Transaction on Database Systems, </journal> <volume> 9(4) </volume> <pages> 560-595, </pages> <month> December </month> <year> 1984. </year>
Reference-contexts: A server never installs a modified object into its page until the transaction has committed. This approach conflicts with a popular policy known as steal buffer management <ref> [EH84] </ref>, which may flush uncommitted updates to disk pages. There are two reasons for not using the steal policy: First, the steal policy must un-install updates of transactions that abort. This requires undo information in log records.
Reference: [FS96] <author> Paulo Ferreira and Marc Shapiro. Larchant: </author> <title> Persistence by reachability in distributed shared memory through garbage collection. </title> <booktitle> In Proc. 16th ICDCS, </booktitle> <year> 1996. </year>
Reference-contexts: Few collectors handle multiple partitions within multiple servers <ref> [FS96] </ref>. However, these schemes do not differentiate between information for inter-partition and inter-site references. We present different techniques for handling inter-partition and inter-site references to suit efficiency and fault-tolerance requirements: August 13, 1997 DRAFT CHAPTER 1. INTRODUCTION 16 1.
Reference: [Fuc95] <author> Matthew Fuchs. </author> <title> Garbage collection on an open network. </title> <editor> In Henry Baker, editor, </editor> <booktitle> Proc. IWMM, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The second technique traces back from the suspects to check if they are reachable from any root. Unlike forward global tracing, this approach preserves locality and scalability. Back tracing was proposed earlier by Fuchs <ref> [Fuc95] </ref>. However, this proposal assumed that inverse information was available for references, and it ignored problems due to concurrent mutations and forward local traces. We present efficient techniques for conducting back tracing that handle these and other practical problems. <p> However, some systems do not support migration. The second technique traces back from the suspects to check if they are reachable from any global root [ML97a]. Unlike forward global marking, this approach preserves locality and scalability. Back tracing was proposed earlier by Fuchs <ref> [Fuc95] </ref>. However, that proposal assumed that inverse information was available to trace references backwards, and it ignored problems due to concurrent mutations and forward local marking. The organization of the full scheme is illustrated in Figure 6-1. Section 6.1 describes the distance heuristic for finding suspects. <p> Most garbage is expected to be collected by forward local tracing (partition tracing). Back tracing is a complementary technique to detect uncollected garbage, and is used for objects suspected to be on inter-site garbage cycles. Back tracing was proposed earlier by Fuchs <ref> [Fuc95] </ref>. However, this proposal assumed that inverse information was available for all references, and it ignored problems due to concurrent mutations and forward local traces.
Reference: [GF93] <author> Aloke Gupta and W. K. Fuchs. </author> <title> Garbage collection in a distributed object-oriented system. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5(2), </volume> <year> 1993. </year>
Reference-contexts: If the suspicion threshold distance is 10, e 2 will be batched for migration with e, while b 2 will not be migrated. This is desirable because b 2 is likely to be live. 6.2.1 Where to Migrate Some previous schemes migrate objects to a fixed dump site <ref> [GF93] </ref>, but this can be a performance or fault-tolerance bottleneck in a large system. Other schemes migrate objects to sites that refer to them.
Reference: [Ghe95] <author> Sanjay Ghemawat. </author> <title> The modified object buffer: A storage management technique for object-oriented databases. </title> <type> Technical Report MIT/LCS/TR-666, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: The header of each object contains a reference to its class object. A server maintains a cache of pages to serve fetch requests from clients. Besides a page cache, the server contains a modified object buffer to store newly persistent or modified copies of objects returned by clients <ref> [Ghe95] </ref>. This buffer allows the server to defer and batch the installation of new and modified objects into their disk pages. When the buffer becomes full, the server chooses certain disk pages and installs all modified objects contained in them. August 13, 1997 DRAFT CHAPTER 2. <p> When a server prepares a transaction, it stores the new and modified objects as a prepare record in a stable log. Conventional systems use a disk-based log, but Thor uses an in-memory log replicated on several machines <ref> [Ghe95] </ref>. Modifications stored in prepare records are not visible to clients. When a transaction commits, the server applies the new and modified objects in the prepare record by moving them into the modified object buffer, which is also a part of the in-memory stable log.
Reference: [Gra78] <author> J. N. Gray. </author> <title> Notes on database operating systems. </title> <editor> In R. Bayer, R. Graham, and G. Seegmuller, editors, </editor> <booktitle> Operating Systems: An Advanced Course, number 60 in Lecture Notes in Computer Science, </booktitle> <pages> pages 393-481. </pages> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: INTRODUCTION 11 Concurrent use of objects by multiple applications might have unexpected results if operations are interleaved. Similarly, failures of sites storing objects might leave objects in an unexpected state. Therefore, object stores allow applications to group a sequence of operations into a transaction <ref> [Gra78] </ref>; a transaction behaves as if its operations happened atomically with respect to other transactions or failures. This thesis was developed in the context of a state-of-the-art object store called Thor [LAC + 96]. Thor is implemented as a client-server system shown in Figure 1.1. <p> If there are more than one participants, a two-phase commit protocol is used <ref> [Gra78] </ref>. The client sends the validation information and copies of new and modified objects to a participant chosen as the coordinator. The coordinator sends a prepare message to each participant. The participant tries to validate the transaction.
Reference: [HM92] <author> Richard L. Hudson and J. Eliot B. Moss. </author> <title> Incremental garbage collection for mature objects. </title> <booktitle> In Proc. IWMM, volume 637 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The scheme by Amsaleg et al. must scan the insets of all partitions after a trace to remove untraced references [AGF95]. The scheme by Moss et al. computes the outset whenever a page is fetched and also when a modified page is evicted, and applies the differences to insets <ref> [HM92, MMH96] </ref>. Some generational collectors implement insets as remembered sets, which record the locations at the level of a word, object, or pagethat may contain inter-partition references [Ung84, Sob88]. August 13, 1997 DRAFT CHAPTER 3.
Reference: [Hug85] <author> R. John M. Hughes. </author> <title> A distributed garbage collection algorithm. </title> <booktitle> In Proc. 1985 FPCA, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 256-272. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <note> August 13, 1997 DRAFT BIBLIOGRAPHY 93 </note>
Reference-contexts: This collects inter-partition garbage cycles because they are not reachable from the site-level roots. Similar marking schemes have been proposed earlier in the context of distributed garbage collection to collect cyclic garbage. However, previous schemes either propagate marks separately from partition-marks [JJ92], or delay the collection of non-cyclic garbage <ref> [Hug85] </ref>, or are not guaranteed to terminate correctly in the presence of concurrent mutations [LQP92]. Our scheme for site-marking has the following desirable properties: * Site-marking is piggybacked on partition-marking, so it has little time and space overhead. * Site-marking does not delay the collection of non-cyclic garbage. <p> New objects are created site-marked. Rule 3. Whenever a partition is unflagged, at least one of its un-site-marked objects is site-marked. A site-mark bit is required for each object expressly to guarantee termination by enforcing these rules. Otherwise, site-mark bits for just the inter-partition references would suffice, as in <ref> [Hug85, LQP92] </ref>. 4.2 Starting a Phase When a phase starts, only the site's inset is site-marked. The partitions containing these references are unflagged and the rest are flagged. This satisfies the site-marking invariant. These actions are performed incrementally as follows. A phase counter is incremented with each phase.
Reference: [JJ92] <author> Neils-Christian Juul and Eric Jul. </author> <title> Comprehensive and robust garbage collection in a distributed system. </title> <booktitle> In Proc. IWMM, volume 637 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: It would also not be fault tolerant in a system with thousands of sites. Thus, timeliness and fault tolerance require that a site trace local objects independently of other sites. This is the approach taken in many distributed systems <ref> [Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Independent tracing of sites has the locality property: Collecting a garbage object involves only the sites it is reachable from. This property minimizes inter-site dependence. In particular, garbage not reachable from other sites is collected locally. <p> The challenge in collecting an inter-site garbage cycle is to preserve the locality property, that is, to involve only the sites containing the cycle. This has August 13, 1997 DRAFT CHAPTER 1. INTRODUCTION 17 proven surprisingly difficult. Most previous schemes do not preserve locality <ref> [Ali85, JJ92, LQP92, MKI + 95, RJ96] </ref>. The few that do are prohibitively costly [SGP90, Sch89, LC97]. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> This collects inter-partition garbage cycles because they are not reachable from the site-level roots. Similar marking schemes have been proposed earlier in the context of distributed garbage collection to collect cyclic garbage. However, previous schemes either propagate marks separately from partition-marks <ref> [JJ92] </ref>, or delay the collection of non-cyclic garbage [Hug85], or are not guaranteed to terminate correctly in the presence of concurrent mutations [LQP92]. <p> Minimizing inter-site dependence requires the locality property: Collecting a garbage cycle should involve only the sites containing it. Locality has proven surprisingly difficult to preserve in collecting inter-site cycles; most previous schemes do not preserve locality. For example, some conduct periodic global marking in addition to site-marking <ref> [Ali85, JJ92] </ref>. The drawbacks of global marking can be alleviated by marking within groups of selected sites [LQP92, MKI + 95, RJ96], but inter-group cycles might never be collected. Few schemes for collecting inter-site cycles have the locality property.
Reference: [KW93] <author> Elliot K. Kolodner and William E. Weihl. </author> <title> Atomic incremental garbage collection and recovery for large stable heap. </title> <booktitle> In Proc. 1993 SIGMOD, </booktitle> <pages> pages 177-186, </pages> <year> 1993. </year>
Reference-contexts: partition, but it might be significant when the disk is traced as a unit. (The trace of a 10 gigabyte disk might take more than a day to finish.) It is possible to conduct a trace such that it can be resumed after a crash, but this adds substantial complexity <ref> [KW93] </ref>. 3.1.2 The Structure of Partitions A partition may contain many pages, possibly non-adjacent. This approach has important advantages. First, the page size is chosen to allow efficient fetching and caching, while a partition is chosen to be an efficient unit of tracing.
Reference: [LAC + 96] <author> B. Liskov, A. Adya, M. Castro, M. Day, S. Ghemawat, R. Gruber, U. Maheshwari, A. Myers, and L. Shrira. </author> <title> Safe and efficient sharing of persistent objects in Thor. </title> <booktitle> In Proc. 1996 SIGMOD, </booktitle> <pages> pages 318-329. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: Therefore, object stores allow applications to group a sequence of operations into a transaction [Gra78]; a transaction behaves as if its operations happened atomically with respect to other transactions or failures. This thesis was developed in the context of a state-of-the-art object store called Thor <ref> [LAC + 96] </ref>. Thor is implemented as a client-server system shown in Figure 1.1. Objects are stored at server sites, which may be distributed over a wide-area network. A server stores objects on disk; it may also cache some objects in memory. <p> August 13, 1997 DRAFT Chapter 2 The Context This thesis was developed in the context of Thor, a distributed object database <ref> [LAC + 96] </ref>. This chapter describes the parts of Thor that are relevant to the garbage collector.
Reference: [LC97] <author> Sylvain Louboutin and Vinny Cahill. </author> <title> Comprehensive distributed garbage collection by tracking the causal dependencies of relevant mutator events. </title> <booktitle> In Proc. </booktitle> <address> ICDCS. </address> <publisher> IEEE Press, </publisher> <year> 1997. </year>
Reference-contexts: This has August 13, 1997 DRAFT CHAPTER 1. INTRODUCTION 17 proven surprisingly difficult. Most previous schemes do not preserve locality [Ali85, JJ92, LQP92, MKI + 95, RJ96]. The few that do are prohibitively costly <ref> [SGP90, Sch89, LC97] </ref>. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> The space occupied by inreaches or outreaches is O (n i fi n o ), where n i and n o are the number of suspected inrefs and suspected outrefs. The space overhead is less than other non-migration-based schemes with locality <ref> [Sch89, LC97] </ref>. These other schemes require complete local-reachability information between inrefs and outrefsnot just suspected ones, and they store additional path information for each inref. 6.3.3 Concurrency The description so far assumed that back traces used the information computed during previous local traces and there were no intervening modifications. <p> The space overhead is more than migration, which consists of destination information in suspected inrefs and outrefs (O (n i + n o )), and storage of surrogates for migrated objects. However, the space overhead of back tracing is less than other schemes with locality <ref> [Sch89, LC97] </ref>. These other schemes require complete local-reachability information between inrefs and outrefsnot just suspected ones, and they store additional path information for each inref. Back traces are conducted concurrently with modifications and forward local traces.
Reference: [LeL77] <author> G. LeLann. </author> <title> Distributed systems, towards a formal approach. </title> <booktitle> In IFIP Congress, </booktitle> <pages> pages 155-160, </pages> <year> 1977. </year>
Reference-contexts: In this case, object b will be migrated to S, while object d will be migrated to R. Unlike some leader election algorithms <ref> [LeL77] </ref>, estimating the destination does not incorporate termination detection, so sites must guess when destination propagation has completed; we discuss how to make this guess in the next section. The advantage of our scheme is that it is simple and effective even in compound cycles.
Reference: [LGG + 91] <author> Barbara Liskov, Sanjay Ghemawat, Robert Gruber, Paul Johnson, Liuba Shrira, and Michael Williams. </author> <title> Replication in the Harp file system. </title> <booktitle> In Proc. SOSP, </booktitle> <pages> pages 226-238. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: When a server crashes, it loses the data in its main memory but retains the data on its disk. Further, the server log is replicated using a primary-copy technique, so it is stable under a limited number of faults <ref> [LGG + 91] </ref>. However, wide-spread failures or disk failures may result in loss of data. We assume that failures are fail-stop and do not cause arbitrary or malicious behavior. Clients and servers may be distributed over a wide-area network.
Reference: [LQP92] <author> Bernard Lang, Christian Queinniec, and Jos e Piquer. </author> <title> Garbage collecting the world. </title> <booktitle> In Proc. POPL '92, </booktitle> <pages> pages 39-50. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: The challenge in collecting an inter-site garbage cycle is to preserve the locality property, that is, to involve only the sites containing the cycle. This has August 13, 1997 DRAFT CHAPTER 1. INTRODUCTION 17 proven surprisingly difficult. Most previous schemes do not preserve locality <ref> [Ali85, JJ92, LQP92, MKI + 95, RJ96] </ref>. The few that do are prohibitively costly [SGP90, Sch89, LC97]. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> Similar marking schemes have been proposed earlier in the context of distributed garbage collection to collect cyclic garbage. However, previous schemes either propagate marks separately from partition-marks [JJ92], or delay the collection of non-cyclic garbage [Hug85], or are not guaranteed to terminate correctly in the presence of concurrent mutations <ref> [LQP92] </ref>. Our scheme for site-marking has the following desirable properties: * Site-marking is piggybacked on partition-marking, so it has little time and space overhead. * Site-marking does not delay the collection of non-cyclic garbage. <p> New objects are created site-marked. Rule 3. Whenever a partition is unflagged, at least one of its un-site-marked objects is site-marked. A site-mark bit is required for each object expressly to guarantee termination by enforcing these rules. Otherwise, site-mark bits for just the inter-partition references would suffice, as in <ref> [Hug85, LQP92] </ref>. 4.2 Starting a Phase When a phase starts, only the site's inset is site-marked. The partitions containing these references are unflagged and the rest are flagged. This satisfies the site-marking invariant. These actions are performed incrementally as follows. A phase counter is incremented with each phase. <p> The number of retracings is reduced further by maintaining a separate scan-set for site-marked objects and selecting objects in this scan-set preferentially over the existing scan-set. Some previous proposals piggybacked site-marking on partition-marking by dividing the trace into two parts <ref> [LQP92] </ref>. The first traced from site-marked roots and site-marked all objects it reached. The second traced from un-site-marked roots without site-marking any object. This two-part scheme does not rescan any object. <p> Locality has proven surprisingly difficult to preserve in collecting inter-site cycles; most previous schemes do not preserve locality. For example, some conduct periodic global marking in addition to site-marking [Ali85, JJ92]. The drawbacks of global marking can be alleviated by marking within groups of selected sites <ref> [LQP92, MKI + 95, RJ96] </ref>, but inter-group cycles might never be collected. Few schemes for collecting inter-site cycles have the locality property. A prominent technique it to migrate an inter-site garbage cycle to a single site, where is collected by site-marking [Bis77, SGP90].
Reference: [LSW91] <author> B. Liskov, L. Shrira, and J. Wroclawski. </author> <title> Efficient at-most-once messages based on synchronized clocks. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 125-142, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Clients and servers may be distributed over a wide-area network. We assume the presence of a reliable channel for ordered delivery of messages between any pair of sites. Such delivery can be provided efficiently even if the underlying network is unreliable <ref> [Pos81, LSW91, Mah97] </ref>. However, all practical protocols for reliable delivery might lose the last message if an end-site crashes.
Reference: [Mah93] <author> Umesh Maheshwari. </author> <title> Distributed garbage collection in a client-server persistent object system. </title> <editor> In Eliot Moss, Paul R. Wilson, and Benjamin Zorn, editors, </editor> <booktitle> OOPSLA/ECOOP '93 Workshop on Garbage Collection in Object-Oriented Systems, </booktitle> <year> 1993. </year>
Reference-contexts: When the count of a reference reduces to zero, it is removed from the inset. On the other hand, our scheme effectively records the identities of the source sites for each reference in the inset, a technique known as reference listing <ref> [Mah93, BEN + 93] </ref>. Reference listing keeps more information than reference counting, but we use it for the following reasons: 1. Reference listing tolerates permanent site failures. If a client or server X fails permanently, other servers need simply remove their inlists from X.
Reference: [Mah97] <author> Umesh Maheshwari. Hula: </author> <title> An efficient protocol for reliable delivery of messages. </title> <type> Technical Report Technical Report MIT/LCS/TR-720, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: Clients and servers may be distributed over a wide-area network. We assume the presence of a reliable channel for ordered delivery of messages between any pair of sites. Such delivery can be provided efficiently even if the underlying network is unreliable <ref> [Pos81, LSW91, Mah97] </ref>. However, all practical protocols for reliable delivery might lose the last message if an end-site crashes.
Reference: [MKI + 95] <author> Munenori Maeda, Hiroki Konaka, Yutaka Ishikawa, Takashi Tomok iyo, Atsushi Hori, and Jorg Nolte. </author> <title> On-the-fly global garbage collection based on partly mark-sweep. </title> <editor> In Henry Baker, editor, </editor> <booktitle> Proc. IWMM, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The challenge in collecting an inter-site garbage cycle is to preserve the locality property, that is, to involve only the sites containing the cycle. This has August 13, 1997 DRAFT CHAPTER 1. INTRODUCTION 17 proven surprisingly difficult. Most previous schemes do not preserve locality <ref> [Ali85, JJ92, LQP92, MKI + 95, RJ96] </ref>. The few that do are prohibitively costly [SGP90, Sch89, LC97]. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> Locality has proven surprisingly difficult to preserve in collecting inter-site cycles; most previous schemes do not preserve locality. For example, some conduct periodic global marking in addition to site-marking [Ali85, JJ92]. The drawbacks of global marking can be alleviated by marking within groups of selected sites <ref> [LQP92, MKI + 95, RJ96] </ref>, but inter-group cycles might never be collected. Few schemes for collecting inter-site cycles have the locality property. A prominent technique it to migrate an inter-site garbage cycle to a single site, where is collected by site-marking [Bis77, SGP90].
Reference: [ML94] <author> Umesh Maheshwari and Barbara Liskov. </author> <title> Fault-tolerant distributed garbage collection in a client-server object-oriented database. </title> <booktitle> In Proc. </booktitle> <address> PDIS. </address> <publisher> IEEE Press, </publisher> <year> 1994. </year>
Reference-contexts: It would also not be fault tolerant in a system with thousands of sites. Thus, timeliness and fault tolerance require that a site trace local objects independently of other sites. This is the approach taken in many distributed systems <ref> [Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Independent tracing of sites has the locality property: Collecting a garbage object involves only the sites it is reachable from. This property minimizes inter-site dependence. In particular, garbage not reachable from other sites is collected locally. <p> Since sites store information about inter-site references, it is necessary to account for site crashes. Servers recover from crashes while clients might not. We present techniques to handle both server and client crashes <ref> [ML94] </ref>. Servers recover their information by storing it on disk. A problem in handling client crashes is that a live client might appear to have crashed because of a network partition. <p> However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts [Bev87, Piq91], and reference source-listing <ref> [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96] </ref>. This chapter presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. The above scheme successfully collects chains of garbage objects across multiple partitions. <p> Further, storing locations at a fine granularity results in more information if multiple locations contain the same reference. On the other hand, many distributed collectors do maintain both insets and outsets for inter-site references <ref> [SDP92, BEN + 93, ML94] </ref>. However, insets and outsets do not share translists; a translist is maintained at both the source and the target sites to avoid some messages. <p> The add message must reach T in time such that a trace at T does not miss the reference. There are various protocols for sending, deferring, or avoiding add messages without compromising safety and for tolerating lost messages <ref> [SDP92, BEN + 93, ML94] </ref>. Sections 5.2 and 5.3 describe new protocols to add client-to-server and server-to-server references. When S does a local trace, it removes the references in its outlists that are not reachable, and sends remove messages for them to their target sites. <p> Since a client may fetch a large amount of data from a server, potentially containing millions of references, recording all such references in an inlist will use a lot of space and time and potentially delay fetch requests <ref> [ML94] </ref>. Another problem with treating all references held by clients as roots is that it might prevent the collection of garbage objects. If the pages cached by a client happen to contain a bunch of garbage objects, the server will not collect that garbage.
Reference: [ML95] <author> Umesh Maheshwari and Barbara Liskov. </author> <title> Collecting cyclic distributed garbage by controlled migration. </title> <booktitle> In Proc. PODC, </booktitle> <pages> pages 57-63, </pages> <year> 1995. </year> <note> August 13, 1997 DRAFT BIBLIOGRAPHY 94 </note>
Reference-contexts: Suspects are found by estimating distances; the distance of an object is the minimum number of inter-site references in any path from a persistent root to that object <ref> [ML95] </ref>. This technique preserves locality, has very little overhead, and guarantees that all cyclic garbage is eventually detected. The second part checks if the suspects are in fact garbage. <p> This part has the luxury of using techniques that would be too costly if applied to all objects but are acceptable if applied only to suspects. We present two alternatives for checking suspects. The first migrates the suspects such that a distributed cycle converges on a single site <ref> [ML95] </ref>. Unlike previous migration-based proposals, it avoids migration as much as possible: both in the number of objects migrated and the number of times they are migrated. The second technique traces back from the suspects to check if they are reachable from any root. <p> This part may use an unsafe technique that might suspect live objects, although a performance requirement is that few 68 CHAPTER 6. INTER-SITE GARBAGE CYCLES 69 suspects be live. We find suspects by estimating distances of objects from persistent roots in terms of inter-site references <ref> [ML95] </ref>. This technique preserves locality, has very little overhead, and guarantees that all inter-site garbage cycles are eventually detected. The second part checks if the suspects are in fact garbage. <p> This part may use techniques that would be too costly if applied to all objects but are acceptable if applied only to suspects. I present two alternatives for checking suspects. The first migrates the suspects such that an inter-site cycle converges on a single site <ref> [ML95] </ref>. Unlike previous migration-based proposals, it avoids migration as much as possible. However, some systems do not support migration. The second technique traces back from the suspects to check if they are reachable from any global root [ML97a]. Unlike forward global marking, this approach preserves locality and scalability.
Reference: [ML96] <author> Umesh Maheshwari and Barbara Liskov. </author> <title> Partitioned garbage collection of a large object store. </title> <type> Technical Report MIT/LCS/TR-699, </type> <institution> MIT LCS, </institution> <year> 1996. </year>
Reference-contexts: If this organization were used for inter-partition references, it would have a higher space overhead and require safety invariants between insets and outsets. We have experimented with such a technique earlier <ref> [ML96] </ref>; it was much more complex than the current technique due to the need to maintain invariants. 3.2.1 Maintaining Insets Translists, insets, and outsets are kept on disk for two reasons.
Reference: [ML97a] <author> Umesh Maheshwari and Barbara Liskov. </author> <title> Collecting distributed garbage cycles by back tracing. </title> <booktitle> In Proc. </booktitle> <address> PODC, </address> <year> 1997. </year>
Reference-contexts: Unlike previous migration-based proposals, it avoids migration as much as possible. However, some systems do not support migration. The second technique traces back from the suspects to check if they are reachable from any global root <ref> [ML97a] </ref>. Unlike forward global marking, this approach preserves locality and scalability. Back tracing was proposed earlier by Fuchs [Fuc95]. However, that proposal assumed that inverse information was available to trace references backwards, and it ignored problems due to concurrent mutations and forward local marking. <p> Since suspected objects are highly likely to be garbage, the condition in the suspect barrier is highly unlikely to be applicable. For a description of the suspect barrier in a non-transactional system where references are transferred between sites by direct messages (as in an RPC-based system), see <ref> [ML97a] </ref>. Remote Reference Copy If a reference to z is copied from x at site X into y at another site Y (X 6= Y ), we handle it in one of the following ways: 1. <p> For a proof of safety provided by the clean rule in a non-transactional system where references are transferred between sites directly (as in an RPC-based system), see <ref> [ML97a] </ref>. Below we discuss safety of back tracing in a transactional system. This part yet to be written. August 13, 1997 DRAFT CHAPTER 6. INTER-SITE GARBAGE CYCLES 89 6.3.4 Back Tracing Through Partitions The description so far assumed that forward local traces compute back information at the site level.
Reference: [ML97b] <author> Umesh Maheshwari and Barbara Liskov. </author> <title> Partitioned garbage collection in a large object store. </title> <booktitle> In Proc. SIGMOD. </booktitle> <publisher> ACM Press, </publisher> <year> 1997. </year>
Reference-contexts: We present a site-wide marking scheme for collecting cycles between partitions on the same site. Complementary global marking has been proposed earlier to collect cyclic garbage in partitioned schemes. We present the first such scheme that has the following features <ref> [ML97b] </ref>: 1. It piggybacks site-wide marking on partition tracing, thus adding little overhead to the base scheme. 2. It does not delay the collection of non-cyclic garbage. 3. It terminates correctly in the presence of concurrent modifications. The scheme also preserves the localized and disk-efficient nature of partition tracing.
Reference: [MMH96] <author> J. Eliot B. Moss, David S. Munro, and Richard L. Hudson. Pmos: </author> <title> A complete and coarse-grained incremental garbage collector for persistent object stores. </title> <booktitle> In Proc. 7th Workshop on Persistent Object Systems, </booktitle> <year> 1996. </year>
Reference-contexts: Thus, timeliness and efficiency require that the disk space be divided into smaller partitions that are traced independently. This is the approach taken in many single-site systems with large, disk-based heaps <ref> [Bis77, YNY94, AGF95, MMH96, CKWZ96] </ref>. However, to trace a site independently of other sites, and a partition independently of other partitions, objects reachable from other sites or other partitions on the same site must not be August 13, 1997 DRAFT CHAPTER 1. INTRODUCTION 14 collected. <p> These techniques are applicable to all systems that maintain a stable update log. Another scheme, PMOS <ref> [MMH96] </ref>, batches disk accesses for inter-partition information; however, PMOS processes information and scans objects whenever they are fetched or evicted, which would slow down applications. A server traces a partition concurrently with ongoing transactions. Modifications made by transactions might not be installed in their serialization order. <p> However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts [Bev87, Piq91], and reference source-listing <ref> [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96] </ref>. This chapter presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. The above scheme successfully collects chains of garbage objects across multiple partitions. <p> Arranging inter-partition references into translists and sharing them between insets and outsets provides a cheap mechanism to record both insets and outsets. Other single-site partitioned collectors implement insets as a sequence of pairs hreference, source-partitioniand do not provide mechanisms to find the outset <ref> [AGF95, MMH96] </ref>. The scheme by Amsaleg et al. must scan the insets of all partitions after a trace to remove untraced references [AGF95]. <p> The scheme by Amsaleg et al. must scan the insets of all partitions after a trace to remove untraced references [AGF95]. The scheme by Moss et al. computes the outset whenever a page is fetched and also when a modified page is evicted, and applies the differences to insets <ref> [HM92, MMH96] </ref>. Some generational collectors implement insets as remembered sets, which record the locations at the level of a word, object, or pagethat may contain inter-partition references [Ung84, Sob88]. August 13, 1997 DRAFT CHAPTER 3.
Reference: [ON93] <author> James W. O'Toole and Scott M. Nettles. </author> <title> Concurrent replication garbage collection. </title> <institution> Technical Report MIT-LCS-TR-570 and CMU-CS-93-138, MIT and CMU., </institution> <year> 1993. </year> <title> Also LFP94 and OOPSLA93 Workshop on Memory Management and Garbage Collection. </title>
Reference-contexts: We describe techniques for acquiring a consistent view of a partition in such an environment. Partitioned garbage collection of a persistent store involves a wide range of other issues such as the choice of the tracing algorithm (marking, copying [Bak78], replicating <ref> [ON93] </ref>, etc.), the selection of partitions to trace [CWZ94], the rate of starting traces [CKWZ96], handling transactional rollback [AGF95], etc. This thesis either does not cover the above issues or addresses them only marginally.
Reference: [ONG93] <author> James W. O'Toole, Scott M. Nettles, and David Gifford. </author> <title> Concurrent compacting garbage collection of a persistent heap. </title> <booktitle> In Proc. 14th SOSP, </booktitle> <pages> pages 161-174, </pages> <year> 1993. </year>
Reference-contexts: This is done lazily by scanning modified objects in the log for inter-partition references. (Other garbage collectors have used the log to process modified objects lazily for various purposes <ref> [ONG93] </ref>.) We refer to scanning objects for inter-partition references as inter-scanning to distinguish it from scanning objects as part of a trace. An object in the log must be inter-scanned before it is installed, since information about the modification is lost at that point.
Reference: [Piq91] <author> Jos e M. Piquer. </author> <title> Indirect reference counting: A distributed garbage collection algorithm. </title> <editor> In Aarts et al., editors, </editor> <booktitle> PARLE'91 Parallel Architectures and Languages Europe, volume 505 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts <ref> [Bev87, Piq91] </ref>, and reference source-listing [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96]. This chapter presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. <p> Reference Counting Some distributed systems use alternative forms of storing the inset, although most of them store outlists as described here. In inter-site reference counting, the target site keeps a count of source sites that hold a reference to a given local object <ref> [Bev87, Piq91] </ref>. When the count of a reference reduces to zero, it is removed from the inset. On the other hand, our scheme effectively records the identities of the source sites for each reference in the inset, a technique known as reference listing [Mah93, BEN + 93]. <p> August 13, 1997 DRAFT CHAPTER 5. INTER-SITE GARBAGE COLLECTION 61 The Commit Part of the Add Protocol The add protocol is similar to indirect protection <ref> [Piq91, SDP92] </ref>. The problem in implementing it in a client-caching system is that the client does not always know who the guardian is. If the client is not a guardian itself, any participant could be a guardian. Therefore, it must broadcast a request to guard b to all participants.
Reference: [Pos81] <author> J. Postel. </author> <title> DoD standard transmition control protocol. </title> <address> DARPA-Internet RFC-793, </address> <month> September </month> <year> 1981. </year>
Reference-contexts: Clients and servers may be distributed over a wide-area network. We assume the presence of a reliable channel for ordered delivery of messages between any pair of sites. Such delivery can be provided efficiently even if the underlying network is unreliable <ref> [Pos81, LSW91, Mah97] </ref>. However, all practical protocols for reliable delivery might lose the last message if an end-site crashes.
Reference: [RJ96] <author> Helena Rodrigues and Richard Jones. </author> <title> A cyclic distributed garbage collector for network objects. </title> <booktitle> In Proc. 10th Workshop on Distributed Algorithms, </booktitle> <year> 1996. </year>
Reference-contexts: The challenge in collecting an inter-site garbage cycle is to preserve the locality property, that is, to involve only the sites containing the cycle. This has August 13, 1997 DRAFT CHAPTER 1. INTRODUCTION 17 proven surprisingly difficult. Most previous schemes do not preserve locality <ref> [Ali85, JJ92, LQP92, MKI + 95, RJ96] </ref>. The few that do are prohibitively costly [SGP90, Sch89, LC97]. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> Locality has proven surprisingly difficult to preserve in collecting inter-site cycles; most previous schemes do not preserve locality. For example, some conduct periodic global marking in addition to site-marking [Ali85, JJ92]. The drawbacks of global marking can be alleviated by marking within groups of selected sites <ref> [LQP92, MKI + 95, RJ96] </ref>, but inter-group cycles might never be collected. Few schemes for collecting inter-site cycles have the locality property. A prominent technique it to migrate an inter-site garbage cycle to a single site, where is collected by site-marking [Bis77, SGP90].
Reference: [Sch89] <author> M. Schelvis. </author> <title> Incremental distribution of timestamp packets a new approach to distributed garbage collection. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(10) </volume> <pages> 37-48, </pages> <year> 1989. </year>
Reference-contexts: This has August 13, 1997 DRAFT CHAPTER 1. INTRODUCTION 17 proven surprisingly difficult. Most previous schemes do not preserve locality [Ali85, JJ92, LQP92, MKI + 95, RJ96]. The few that do are prohibitively costly <ref> [SGP90, Sch89, LC97] </ref>. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> The space occupied by inreaches or outreaches is O (n i fi n o ), where n i and n o are the number of suspected inrefs and suspected outrefs. The space overhead is less than other non-migration-based schemes with locality <ref> [Sch89, LC97] </ref>. These other schemes require complete local-reachability information between inrefs and outrefsnot just suspected ones, and they store additional path information for each inref. 6.3.3 Concurrency The description so far assumed that back traces used the information computed during previous local traces and there were no intervening modifications. <p> The space overhead is more than migration, which consists of destination information in suspected inrefs and outrefs (O (n i + n o )), and storage of surrogates for migrated objects. However, the space overhead of back tracing is less than other schemes with locality <ref> [Sch89, LC97] </ref>. These other schemes require complete local-reachability information between inrefs and outrefsnot just suspected ones, and they store additional path information for each inref. Back traces are conducted concurrently with modifications and forward local traces.
Reference: [SDP92] <author> Marc Shapiro, Peter Dickman, and David Plainfoss e. </author> <title> Robust, distributed references and acyclic garbage collection. </title> <booktitle> In Proc. </booktitle> <address> PODC, </address> <year> 1992. </year>
Reference-contexts: It would also not be fault tolerant in a system with thousands of sites. Thus, timeliness and fault tolerance require that a site trace local objects independently of other sites. This is the approach taken in many distributed systems <ref> [Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Independent tracing of sites has the locality property: Collecting a garbage object involves only the sites it is reachable from. This property minimizes inter-site dependence. In particular, garbage not reachable from other sites is collected locally. <p> This protocol is piggybacked on the commit protocol, but it does not delay the commit by sending extra foreground messages or by adding extra participants. All extra messages are sent in the background, so they may be deferred and batched. Background protocols have been proposed before in RPC-based systems <ref> [SDP92] </ref>, but this is the first protocol to achieve the same in a system where references are transferred between servers through modifications made by clients. Since sites store information about inter-site references, it is necessary to account for site crashes. Servers recover from crashes while clients might not. <p> However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts [Bev87, Piq91], and reference source-listing <ref> [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96] </ref>. This chapter presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. The above scheme successfully collects chains of garbage objects across multiple partitions. <p> Further, storing locations at a fine granularity results in more information if multiple locations contain the same reference. On the other hand, many distributed collectors do maintain both insets and outsets for inter-site references <ref> [SDP92, BEN + 93, ML94] </ref>. However, insets and outsets do not share translists; a translist is maintained at both the source and the target sites to avoid some messages. <p> The add message must reach T in time such that a trace at T does not miss the reference. There are various protocols for sending, deferring, or avoiding add messages without compromising safety and for tolerating lost messages <ref> [SDP92, BEN + 93, ML94] </ref>. Sections 5.2 and 5.3 describe new protocols to add client-to-server and server-to-server references. When S does a local trace, it removes the references in its outlists that are not reachable, and sends remove messages for them to their target sites. <p> August 13, 1997 DRAFT CHAPTER 5. INTER-SITE GARBAGE COLLECTION 61 The Commit Part of the Add Protocol The add protocol is similar to indirect protection <ref> [Piq91, SDP92] </ref>. The problem in implementing it in a client-caching system is that the client does not always know who the guardian is. If the client is not a guardian itself, any participant could be a guardian. Therefore, it must broadcast a request to guard b to all participants.
Reference: [SGP90] <author> Marc Shapiro, O. Gruber, and David Plainfoss e. </author> <title> A garbage detection protocol for a realistic distributed object-support system. </title> <institution> Rapports de Recherche 1320, INRIA-Rocquencourt, </institution> <year> 1990. </year>
Reference-contexts: This has August 13, 1997 DRAFT CHAPTER 1. INTRODUCTION 17 proven surprisingly difficult. Most previous schemes do not preserve locality [Ali85, JJ92, LQP92, MKI + 95, RJ96]. The few that do are prohibitively costly <ref> [SGP90, Sch89, LC97] </ref>. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> Few schemes for collecting inter-site cycles have the locality property. A prominent technique it to migrate an inter-site garbage cycle to a single site, where is collected by site-marking <ref> [Bis77, SGP90] </ref>. However, previous schemes based on migration are prone to migrating live objects besides garbage cycles, which is undesirable because migration is expensive. We present a practical scheme with locality to collect inter-site cycles. It has two parts. <p> We assume an underlying mechanism for August 13, 1997 DRAFT CHAPTER 6. INTER-SITE GARBAGE CYCLES 75 migrating objects that is robust against concurrent mutations and that updates references to migrated objects [DLMM94, Ady94]. Migration has been proposed earlier to collect distributed cycles <ref> [Bis77, SGP90] </ref>. However, previous proposals used weak heuristics to decide which objects to migrate. A popular heuristic was to move to all objects not locally reachable from a global root. <p> To ensure that objects in a cycle converge on the same site instead of following each other in circles, sites are totally ordered and migration is allowed in one direction only, say, from higher-id August 13, 1997 DRAFT CHAPTER 6. INTER-SITE GARBAGE CYCLES 76 sites to lower-id sites <ref> [SGP90] </ref>. We refer to this rule as the one-way rule. The one-way rule ensures convergence, but objects on a multi-site cycle might be migrated multiple times before they converge on a site.
Reference: [Sob88] <author> Patrick Sobalvarro. </author> <title> A lifetime-based garbage collector for Lisp systems on general-purpose computers. </title> <type> Technical Report AITR-1417, </type> <institution> MIT, AI Lab, </institution> <year> 1988. </year>
Reference-contexts: Therefore, any reference e that is in the inset of another partition on account of P alone and that was not visited by the trace of P is removed. However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets <ref> [Ung84, Sob88] </ref>, reference counts [Bev87, Piq91], and reference source-listing [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96]. This chapter presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. <p> Some generational collectors implement insets as remembered sets, which record the locations at the level of a word, object, or pagethat may contain inter-partition references <ref> [Ung84, Sob88] </ref>. August 13, 1997 DRAFT CHAPTER 3. PARTITIONED GARBAGE COLLECTION 30 This information allows the collector to update references when an object is moved for compacting the storage. However, this scheme is not suitable for disk-based heaps because tracing a partition requires examining and updating locations in other partitions.
Reference: [Sun96] <author> Sun Microsystems, Inc. </author> <title> Remote method invocation. </title> <note> http://www.javasoft.com/products/jdk/1.1/docs/guide/rmi, 1996. August 13, 1997 DRAFT BIBLIOGRAPHY 95 </note>
Reference-contexts: Its space and time overheads are limited to suspected objects. The techniques presented in this regard are applicable to both client-caching and RPC-based distributed systems, and to transactional and non-transactional systems. In particular, they are relevant to distributed object stores encouraged by newly popular standards such as Java RMI <ref> [Sun96] </ref>. 1.4.5 Limitations Popular use of distributed object stores is in its infancy and little factual information is available about them, especially about the distribution of garbage objects in such systems. Therefore, this thesis provides robust techniques that will work in a wide range of workloads.
Reference: [Tar72] <author> R. Tarjan. </author> <title> Depth first search and linear graph algorithms. </title> <journal> SIAM Journal of Computing, </journal> <volume> 1(2), </volume> <year> 1972. </year>
Reference-contexts: In general, a backward edge introduces a strongly connected component, and the outreaches of objects in a strongly connected component should all be equal. Fortunately, strongly connected components can be computed efficiently during a depth first traversal with linear performance <ref> [Tar72] </ref>. For each object, the algorithm finds the first object visited in its component, called its leader. The algorithm uses a counter to mark objects in the order they are visited. It uses an auxiliary stack to find the objects in a component.
Reference: [Ung84] <author> David M. Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 19(5) </volume> <pages> 157-167, </pages> <year> 1984. </year>
Reference-contexts: Therefore, any reference e that is in the inset of another partition on account of P alone and that was not visited by the trace of P is removed. However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets <ref> [Ung84, Sob88] </ref>, reference counts [Bev87, Piq91], and reference source-listing [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96]. This chapter presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. <p> Third, partitions allow faster garbage collection since the collector can focus on partitions that are likely to contain the most garbage. This is similar to generational collectors which collect newer partitions more frequently <ref> [Ung84] </ref>. Although the age-based heuristics of generational collectors are not applicable to persistent stores [Bak93], other heuristics are available for selecting partitions [CWZ94]. Fourth, if the server crashes in the middle of a trace, the work done during the trace is wasted. <p> Some generational collectors implement insets as remembered sets, which record the locations at the level of a word, object, or pagethat may contain inter-partition references <ref> [Ung84, Sob88] </ref>. August 13, 1997 DRAFT CHAPTER 3. PARTITIONED GARBAGE COLLECTION 30 This information allows the collector to update references when an object is moved for compacting the storage. However, this scheme is not suitable for disk-based heaps because tracing a partition requires examining and updating locations in other partitions.
Reference: [WLM92] <author> Paul R. Wilson, Michael S. Lam, and Thomas G. Moher. </author> <title> Caching considerations for generational garbage collection. </title> <booktitle> In Conference Record of the 1992 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 32-42. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: An old-view trace scans an object at most oncethe state of the object when the trace startedand it need not scan new objects created during the trace because they are created marked. Such a trace is also known as snapshot at the beginning <ref> [WLM92] </ref>. A new-view trace sees the most recent view of the heap. It must scan new and modified objects, possibly multiple times, such that when the last object is scanned, no further modifications are pending. Such tracing is also known as incremental update [WLM92]. <p> also known as snapshot at the beginning <ref> [WLM92] </ref>. A new-view trace sees the most recent view of the heap. It must scan new and modified objects, possibly multiple times, such that when the last object is scanned, no further modifications are pending. Such tracing is also known as incremental update [WLM92]. An old-view trace is more conservative because garbage generated during the current trace is not collected until the next trace.
Reference: [YNY94] <author> V. Yong, J. Naughton, and J. Yu. </author> <title> Storage reclamation and reorganization in clinet-server persistent object stores. </title> <booktitle> In Proc. Data Engineering, </booktitle> <pages> pages 120-133. </pages> <publisher> IEEE Press, </publisher> <year> 1994. </year> <note> August 13, 1997 DRAFT </note>
Reference-contexts: Each server has a large disk space and a relatively small main memory. Often, the memory size is only a hundredth of the disk size. Therefore, a trace of the site's objects is likely to thrash on disk because of poor locality of reference <ref> [YNY94] </ref>. In particular, a disk page might be fetched and evicted many times to scan different objects on the page. This is undesirable for two reasons. First, the trace might take a long time to finish, preventing timely collection of garbage. <p> Thus, timeliness and efficiency require that the disk space be divided into smaller partitions that are traced independently. This is the approach taken in many single-site systems with large, disk-based heaps <ref> [Bis77, YNY94, AGF95, MMH96, CKWZ96] </ref>. However, to trace a site independently of other sites, and a partition independently of other partitions, objects reachable from other sites or other partitions on the same site must not be August 13, 1997 DRAFT CHAPTER 1. INTRODUCTION 14 collected. <p> Therefore, a trace of the entire disk is likely to have poor locality of reference. It would thrash on disk, i.e., fetch and evict a disk page many times in order to scan different objects in the page <ref> [YNY94, AGF95] </ref>. On the other hand, a partition trace fetches the pages of one partition into memory and scans all live objects in them before fetching another partition.
References-found: 56

