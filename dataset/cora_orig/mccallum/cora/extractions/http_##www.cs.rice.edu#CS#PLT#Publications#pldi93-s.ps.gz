URL: http://www.cs.rice.edu/CS/PLT/Publications/pldi93-s.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Handling Control  
Author: Dorai Sitaram 
Date: June 21-25, 1993  
Note: To appear in: ACM SIGPLAN '93 Conf. on Programming Language Design Implementation Albuquerque, N.M.,  
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: Non-local control transfer and exception handling have a long tradition in higher-order programming languages such as Common Lisp, Scheme and ML. However, each language stops short of providing a full and complementary approach | control handling is provided only if the corresponding control operator is first-order. In this work, we describe handlers in a higher-order control setting. We invoke our earlier theoretical result that all denotational models of control languages invariably include capabilities that handle control. These capabilities, when incorporated into the language, form an elegant and powerful higher-order generalization of the first-order exception-handling mechanism. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> W. Clinger, J. Rees, et al. </editor> <title> Revised 4 Report on the Algorithmic Language Scheme, </title> <month> November </month> <year> 1991. </year>
Reference-contexts: They are invariably accompanied by forms that delimit and handle the aborted value, e.g., catch in Common Lisp and handle in ML. In contrast, higher-order operators such as call-with-current-continuation in Scheme <ref> [27, 1] </ref> and ML [4] allow unrestricted transfers of control without regard to dynamic scope. In pre-Common Lisp [16], the operators error and errorset, intended to respectively signal and handle errors, work equally well for exits.
Reference: [2] <author> W.F. Clocksin and C.S. Mellish. </author> <title> Programming in Pro-log. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: is reset to parent-ticks-left , thereby restarting the parent engine computation: ;;; *** hticks-postludei for nestable engines *** (set! parent-ticks-left (+ parent-ticks-left ticks-left )) (set! ticks-left (+ child-ticks-left ticks-left )) (clock 'set parent-ticks-left ) : : : 4 Backtracking through handling Control handling provides an accessible approach to Prolog-style backtracking <ref> [2, 25] </ref>. Backtracking solves a problem or goal by trying to solve its subgoals. If the goal is a simple or atomic goal, it is solved by matching it with statements or facts in a database. A goal that is solved is said to succeed.
Reference: [3] <author> O. Danvy and A. Filinski. </author> <title> Abstracting control. </title> <booktitle> In Proc. 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 151-160, </pages> <year> 1990. </year>
Reference-contexts: The prompt and run are equivalent: either can be seen as syntactic sugar for the other. Together with higher-order control reifiers like call/cc, the prompt supports powerful programming idioms [7, 20]. It has several successors specially suited to various practical settings, e.g., spawn [14], reset <ref> [3] </ref>, and splitter [18]. However, none of these constructs handles control objects | the corresponding control reifier continues to double as handler. In this work, we continue the process of extrapolation identified above by adding control-handling capabilities to the delimiter.
Reference: [4] <author> B.F. Duba, R. Harper, and D. MacQueen. </author> <title> Typing first-class continuations in ML. </title> <booktitle> In Proc. 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <year> 1991. </year>
Reference-contexts: They are invariably accompanied by forms that delimit and handle the aborted value, e.g., catch in Common Lisp and handle in ML. In contrast, higher-order operators such as call-with-current-continuation in Scheme [27, 1] and ML <ref> [4] </ref> allow unrestricted transfers of control without regard to dynamic scope. In pre-Common Lisp [16], the operators error and errorset, intended to respectively signal and handle errors, work equally well for exits. The form errorset simply returns the value of its subexpression if the latter has no calls to error.
Reference: [5] <author> R.K. Dybvig and R. Hieb. </author> <title> Engines from Continuations. </title> <journal> Journal of Computer Languages (Pergamon Press), </journal> <volume> 14(2) </volume> <pages> 109-124, </pages> <year> 1989. </year>
Reference-contexts: In the presence of several continuations with their respective quasi-handlers, keeping track of the various jump-off points and avoiding clashes between them requires sophisticated bookkeeping strategies <ref> [5, 12] </ref>. It is therefore useful to explore options that tackle this problem without sacrificing the programming power of higher-order control. Here we show that the historical duality of first-order throwing and handling is useful even for higher-order control. <p> We shall henceforth usurp the name run and fcontrol for the tagged operators. The previous untagged uses can be considered as having either a default or catch-all tag, say false. 3 Nestable engines Our first larger example involving intensive control manipulation is the engine. An engine <ref> [5, 11] </ref> is an abstraction of computation subject to timed preemption. It forms a tractable building block for realizing a variety of communicating concurrent processes. An engine's underlying computation is a thunk that can be run as a preemptable process. <p> Extending it to allow nestable engines entails more than adding code for tick management, since the continuations to be captured while transferring control across the generations of engines need involved bookkeeping <ref> [5] </ref>. We show here an implementation of nestable engines using control handlers. <p> The following describes the type of clock we shall use: it may be defined using either natively provided alarms or through syntactic extensions <ref> [5] </ref> that simulate tick consumption. The internal state of the clock contains: 1. the number of remaining ticks; and 2. an interrupt handler to be invoked when the clock runs out of ticks.
Reference: [6] <author> M. Felleisen. </author> <title> Transliterating Prolog into Scheme. </title> <type> Technical Report 182, </type> <institution> Indiana University Computer Science Department, </institution> <year> 1985. </year>
Reference-contexts: Implementing backtracking in Scheme provides an apt use of continuations. While "purely functional" solutions with goals returning boolean values are possible, such methods require that goals explicitly call success and failure procedures to allow resumption of subgoals at backtrack points. In contrast, Scheme approaches <ref> [6, 10] </ref> aim for more concise and readable code using call/cc-continuations to identify and jump to backtrack points. <p> process itself is a predicate: thus, the unification of two terms is an example of an atomic goal.) In this treatment, since our purpose is to study the backtracking capabilities provided by control handlers, we will not go into the details of implementing logic variables and unification in Scheme (refer <ref> [6, 10] </ref>). 4.2 Goals In this treatment, a goal is a Scheme expression that throw s (instead of just returning) the boolean false if it fails and a true value if it succeeds.
Reference: [7] <author> M. Felleisen. -v-CS: </author> <title> An Extended -Calculus for Scheme. </title> <booktitle> In Proc. 1988 Conference on Lisp and Functional Programming, </booktitle> <pages> pages 72-84, </pages> <year> 1988. </year>
Reference-contexts: The prompt and run are equivalent: either can be seen as syntactic sugar for the other. Together with higher-order control reifiers like call/cc, the prompt supports powerful programming idioms <ref> [7, 20] </ref>. It has several successors specially suited to various practical settings, e.g., spawn [14], reset [3], and splitter [18]. However, none of these constructs handles control objects | the corresponding control reifier continues to double as handler.
Reference: [8] <author> M. Felleisen. </author> <title> The Theory and Practice of First-Class Prompts. </title> <booktitle> In Proc. 15th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 180-190, </pages> <year> 1988. </year>
Reference-contexts: Extrapolating from the relationship between errorset and error or catch and throw, a control delimiter for call/cc would control the extent of the context captured by call/cc or erased by its continuations. This operator, proposed by Felleisen <ref> [8] </ref>, is called the "prompt", since it annotates its subexpression as an independent program, in so far as control actions are concerned, much like the prompt sign in a read-eval print loop.
Reference: [9] <author> R. Harper. </author> <title> Introduction to Standard ML. </title> <type> LFCS Report Series ECS-LFCS-86-14, </type> <institution> University of Edinburgh, </institution> <year> 1986. </year>
Reference-contexts: 1 Introduction Control manipulation in applicative programming languages comes in two flavors. First-order control operators allow computations to abort to a dynamically enclosing control context, e.g., Common Lisp's [23, 24] throw and ML's <ref> [9, 17] </ref> raise. They are invariably accompanied by forms that delimit and handle the aborted value, e.g., catch in Common Lisp and handle in ML. In contrast, higher-order operators such as call-with-current-continuation in Scheme [27, 1] and ML [4] allow unrestricted transfers of control without regard to dynamic scope.
Reference: [10] <author> C.T. Haynes. </author> <title> Logic Continuations. </title> <journal> J. Logic Program., </journal> <volume> 4 </volume> <pages> 157-176, </pages> <year> 1987. </year> <title> Preliminary version: </title> <booktitle> In Proc. of the Third International Conference on Logic Programming, </booktitle> <month> July </month> <year> 1985, </year> <title> London, </title> <booktitle> England, Lecture Notes in Computer Science, </booktitle> <volume> Vol. 225, </volume> <publisher> Springer-Verlag, Berlin, </publisher> <pages> 671-685. </pages>
Reference-contexts: This ability to substitute the current program context by a previously stored snapshot of a program context is simple and powerful. It allows a wide range of programming paradigms <ref> [10, 11, 12, 13] </ref> not possible with catch and throw. However, there is no analog to delimiting or handling a control action, as with errorset, or to distinguishing between different varieties of control actions, as with catch. Methods of handling and distinguishing control actions are left to user programs. <p> Implementing backtracking in Scheme provides an apt use of continuations. While "purely functional" solutions with goals returning boolean values are possible, such methods require that goals explicitly call success and failure procedures to allow resumption of subgoals at backtrack points. In contrast, Scheme approaches <ref> [6, 10] </ref> aim for more concise and readable code using call/cc-continuations to identify and jump to backtrack points. <p> process itself is a predicate: thus, the unification of two terms is an example of an atomic goal.) In this treatment, since our purpose is to study the backtracking capabilities provided by control handlers, we will not go into the details of implementing logic variables and unification in Scheme (refer <ref> [6, 10] </ref>). 4.2 Goals In this treatment, a goal is a Scheme expression that throw s (instead of just returning) the boolean false if it fails and a true value if it succeeds.
Reference: [11] <author> C.T. Haynes and D.P. Friedman. </author> <title> Abstracting Timed Preemption with Engines. </title> <journal> Journal of Computer Languages (Pergamon Press), </journal> <volume> 12(2) </volume> <pages> 109-121, </pages> <year> 1987. </year> <title> Preliminary version: Engines Build Process Abstractions. </title> <booktitle> In Proc. Conference on Lisp and Functional Programming, </booktitle> <year> 1985, </year> <pages> 18-24. </pages>
Reference-contexts: This ability to substitute the current program context by a previously stored snapshot of a program context is simple and powerful. It allows a wide range of programming paradigms <ref> [10, 11, 12, 13] </ref> not possible with catch and throw. However, there is no analog to delimiting or handling a control action, as with errorset, or to distinguishing between different varieties of control actions, as with catch. Methods of handling and distinguishing control actions are left to user programs. <p> We shall henceforth usurp the name run and fcontrol for the tagged operators. The previous untagged uses can be considered as having either a default or catch-all tag, say false. 3 Nestable engines Our first larger example involving intensive control manipulation is the engine. An engine <ref> [5, 11] </ref> is an abstraction of computation subject to timed preemption. It forms a tractable building block for realizing a variety of communicating concurrent processes. An engine's underlying computation is a thunk that can be run as a preemptable process. <p> This thunk, when called, resumes the interrupted engine computation. 6 Haynes and Friedman <ref> [11] </ref> distinguish two varieties of engines: flat (unnestable) and nestable. Flat engines cannot run other engines, but as the authors say, this restriction "considerably simplifies the implementation of engines", where the implementation uses Scheme-style continuations.
Reference: [12] <author> C.T. Haynes and D.P. Friedman. </author> <title> Embedding Continuations in Procedural Objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(4) </volume> <pages> 245-254, </pages> <year> 1987. </year>
Reference-contexts: This ability to substitute the current program context by a previously stored snapshot of a program context is simple and powerful. It allows a wide range of programming paradigms <ref> [10, 11, 12, 13] </ref> not possible with catch and throw. However, there is no analog to delimiting or handling a control action, as with errorset, or to distinguishing between different varieties of control actions, as with catch. Methods of handling and distinguishing control actions are left to user programs. <p> In the presence of several continuations with their respective quasi-handlers, keeping track of the various jump-off points and avoiding clashes between them requires sophisticated bookkeeping strategies <ref> [5, 12] </ref>. It is therefore useful to explore options that tackle this problem without sacrificing the programming power of higher-order control. Here we show that the historical duality of first-order throwing and handling is useful even for higher-order control.
Reference: [13] <author> C.T. Haynes, D.P. Friedman, and M. Wand. </author> <title> Obtaining Coroutines from Continuations. </title> <journal> Journal of Computer Languages (Pergamon Press), </journal> 11(3/4):109-121, 1986. 
Reference-contexts: This ability to substitute the current program context by a previously stored snapshot of a program context is simple and powerful. It allows a wide range of programming paradigms <ref> [10, 11, 12, 13] </ref> not possible with catch and throw. However, there is no analog to delimiting or handling a control action, as with errorset, or to distinguishing between different varieties of control actions, as with catch. Methods of handling and distinguishing control actions are left to user programs.
Reference: [14] <author> R. Hieb and R.K. Dybvig. </author> <title> Continuations and Con-currency. </title> <booktitle> In Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 128-136, </pages> <year> 1990. </year>
Reference-contexts: The prompt and run are equivalent: either can be seen as syntactic sugar for the other. Together with higher-order control reifiers like call/cc, the prompt supports powerful programming idioms [7, 20]. It has several successors specially suited to various practical settings, e.g., spawn <ref> [14] </ref>, reset [3], and splitter [18]. However, none of these constructs handles control objects | the corresponding control reifier continues to double as handler. In this work, we continue the process of extrapolation identified above by adding control-handling capabilities to the delimiter.
Reference: [15] <author> P.J. Landin. </author> <title> A Correspondence between Algol 60 and Church's Lambda Notation. </title> <journal> Communications of the ACM, </journal> <volume> 8(2) </volume> <pages> 89-101; 158-165, </pages> <year> 1965. </year>
Reference-contexts: In contrast to the first-order operators described above, a higher-order control operator such as Scheme's and ML's call-with-current-continuation 1 can transfer control to arbitrary points in the program, not just to dynamically enclosing contexts. Like its historical forerunners J <ref> [15] </ref> and escape [19], call/cc provides the user with a representation of the current control context: the "rest of the program" or the "continuation". Invoking this continuation at any point in the program causes the program's current context to be replaced by the continuation's context.
Reference: [16] <author> J. McCarthy et al. </author> <title> Lisp 1.5 Programmer's Manual. </title> <publisher> The MIT Press, </publisher> <address> 2nd edition, </address> <year> 1965. </year>
Reference-contexts: They are invariably accompanied by forms that delimit and handle the aborted value, e.g., catch in Common Lisp and handle in ML. In contrast, higher-order operators such as call-with-current-continuation in Scheme [27, 1] and ML [4] allow unrestricted transfers of control without regard to dynamic scope. In pre-Common Lisp <ref> [16] </ref>, the operators error and errorset, intended to respectively signal and handle errors, work equally well for exits. The form errorset simply returns the value of its subexpression if the latter has no calls to error.
Reference: [17] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mas-sachusetts and London, England, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Control manipulation in applicative programming languages comes in two flavors. First-order control operators allow computations to abort to a dynamically enclosing control context, e.g., Common Lisp's [23, 24] throw and ML's <ref> [9, 17] </ref> raise. They are invariably accompanied by forms that delimit and handle the aborted value, e.g., catch in Common Lisp and handle in ML. In contrast, higher-order operators such as call-with-current-continuation in Scheme [27, 1] and ML [4] allow unrestricted transfers of control without regard to dynamic scope.
Reference: [18] <author> C. Queinnec and B. Serpette. </author> <title> A Dynamic Extent Control Operator for Partial Continuations. </title> <booktitle> In Proc. 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-184, </pages> <year> 1991. </year>
Reference-contexts: The prompt and run are equivalent: either can be seen as syntactic sugar for the other. Together with higher-order control reifiers like call/cc, the prompt supports powerful programming idioms [7, 20]. It has several successors specially suited to various practical settings, e.g., spawn [14], reset [3], and splitter <ref> [18] </ref>. However, none of these constructs handles control objects | the corresponding control reifier continues to double as handler. In this work, we continue the process of extrapolation identified above by adding control-handling capabilities to the delimiter.
Reference: [19] <author> J.C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proc. ACM Conference, </booktitle> <pages> pages 717-740, </pages> <year> 1972. </year>
Reference-contexts: In contrast to the first-order operators described above, a higher-order control operator such as Scheme's and ML's call-with-current-continuation 1 can transfer control to arbitrary points in the program, not just to dynamically enclosing contexts. Like its historical forerunners J [15] and escape <ref> [19] </ref>, call/cc provides the user with a representation of the current control context: the "rest of the program" or the "continuation". Invoking this continuation at any point in the program causes the program's current context to be replaced by the continuation's context.
Reference: [20] <author> D. Sitaram and M. Felleisen. </author> <title> Control Delimiters and Their Hierarchies. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3(1) </volume> <pages> 67-99, </pages> <year> 1990. </year>
Reference-contexts: The prompt and run are equivalent: either can be seen as syntactic sugar for the other. Together with higher-order control reifiers like call/cc, the prompt supports powerful programming idioms <ref> [7, 20] </ref>. It has several successors specially suited to various practical settings, e.g., spawn [14], reset [3], and splitter [18]. However, none of these constructs handles control objects | the corresponding control reifier continues to double as handler. <p> In an earlier approach, we suggested a hierarchically ordered set of delimiters <ref> [20] </ref>.
Reference: [21] <author> D. Sitaram and M. Felleisen. </author> <title> Reasoning with Continuations II: How to Get Full Abstraction for Models of Control. </title> <booktitle> In Proc. 1990 Conference on Lisp and Functional Programming, </booktitle> <pages> pages 161-175, </pages> <year> 1990. </year>
Reference-contexts: It is therefore useful to explore options that tackle this problem without sacrificing the programming power of higher-order control. Here we show that the historical duality of first-order throwing and handling is useful even for higher-order control. In earlier work <ref> [21, 22] </ref>, we showed that all conventional models for non-local control include a control-handling capability. In other words, if the relationship between the model meanings and the observable behavior of language terms is to match, the language, like the model, must include handlers. <p> The control system is identical to the one suggested by a different, theoretical route, viz., the control-handling prompts that we showed to be implicitly present in all the traditional denotational models <ref> [21, 22] </ref>. 2.1 Run and fcontrol The control delimiter is called run. It takes two arguments, a thunk 3 and a binary procedure called the handler: (run hthunki hhandleri) The procedure run calls the thunk as an control-independent program.
Reference: [22] <author> D. Sitaram and M. Felleisen. </author> <title> Modeling Continuations without Continuations. </title> <booktitle> In Proc. 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 185-196, </pages> <year> 1991. </year>
Reference-contexts: It is therefore useful to explore options that tackle this problem without sacrificing the programming power of higher-order control. Here we show that the historical duality of first-order throwing and handling is useful even for higher-order control. In earlier work <ref> [21, 22] </ref>, we showed that all conventional models for non-local control include a control-handling capability. In other words, if the relationship between the model meanings and the observable behavior of language terms is to match, the language, like the model, must include handlers. <p> The control system is identical to the one suggested by a different, theoretical route, viz., the control-handling prompts that we showed to be implicitly present in all the traditional denotational models <ref> [21, 22] </ref>. 2.1 Run and fcontrol The control delimiter is called run. It takes two arguments, a thunk 3 and a binary procedure called the handler: (run hthunki hhandleri) The procedure run calls the thunk as an control-independent program.
Reference: [23] <author> G.L. Steele Jr. </author> <title> Common Lisp: the Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: 1 Introduction Control manipulation in applicative programming languages comes in two flavors. First-order control operators allow computations to abort to a dynamically enclosing control context, e.g., Common Lisp's <ref> [23, 24] </ref> throw and ML's [9, 17] raise. They are invariably accompanied by forms that delimit and handle the aborted value, e.g., catch in Common Lisp and handle in ML.
Reference: [24] <author> G.L. Steele Jr. </author> <title> Common Lisp: the Language. </title> <publisher> Digital Press, </publisher> <address> 2nd edition, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Control manipulation in applicative programming languages comes in two flavors. First-order control operators allow computations to abort to a dynamically enclosing control context, e.g., Common Lisp's <ref> [23, 24] </ref> throw and ML's [9, 17] raise. They are invariably accompanied by forms that delimit and handle the aborted value, e.g., catch in Common Lisp and handle in ML.
Reference: [25] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: is reset to parent-ticks-left , thereby restarting the parent engine computation: ;;; *** hticks-postludei for nestable engines *** (set! parent-ticks-left (+ parent-ticks-left ticks-left )) (set! ticks-left (+ child-ticks-left ticks-left )) (clock 'set parent-ticks-left ) : : : 4 Backtracking through handling Control handling provides an accessible approach to Prolog-style backtracking <ref> [2, 25] </ref>. Backtracking solves a problem or goal by trying to solve its subgoals. If the goal is a simple or atomic goal, it is solved by matching it with statements or facts in a database. A goal that is solved is said to succeed.
Reference: [26] <author> J.E. Stoy and C. Strachey. OS6: </author> <title> An Operating System for a Small Computer. </title> <journal> Comp. J., </journal> <volume> 15(2) </volume> <pages> 117-124, 195-203, </pages> <year> 1972. </year>
Reference-contexts: The procedural variant of the prompt is called run, to borrow a term used for an operator that runs programs <ref> [26] </ref>. The prompt and run are equivalent: either can be seen as syntactic sugar for the other. Together with higher-order control reifiers like call/cc, the prompt supports powerful programming idioms [7, 20]. It has several successors specially suited to various practical settings, e.g., spawn [14], reset [3], and splitter [18].
Reference: [27] <author> G.J. Sussman and G.L. Steele Jr. </author> <title> Scheme: An interpreter for extended lambda calculus. </title> <type> Memo 349, </type> <institution> MIT AI Lab, </institution> <year> 1975. </year>
Reference-contexts: They are invariably accompanied by forms that delimit and handle the aborted value, e.g., catch in Common Lisp and handle in ML. In contrast, higher-order operators such as call-with-current-continuation in Scheme <ref> [27, 1] </ref> and ML [4] allow unrestricted transfers of control without regard to dynamic scope. In pre-Common Lisp [16], the operators error and errorset, intended to respectively signal and handle errors, work equally well for exits.
References-found: 27

