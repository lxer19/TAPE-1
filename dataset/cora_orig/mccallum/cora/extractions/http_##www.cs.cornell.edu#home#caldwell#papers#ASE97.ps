URL: http://www.cs.cornell.edu/home/caldwell/papers/ASE97.ps
Refering-URL: http://www.cs.cornell.edu/home/caldwell/papers.html
Root-URL: 
Email: caldwell@cs.cornell.edu  
Title: Moving Proofs-As-Programs Into Practice  
Author: James L. Caldwell 
Address: Mail Stop 269-1 Moffett Field, CA, 94035-1000  
Affiliation: NASA Ames Research Center Computational Sciences Division  
Abstract: Proofs in the Nuprl system, an implementation of a constructive type theory, yield correct-by-construction programs. In this paper a new methodology is presented for extracting efficient and readable programs from inductive proofs. The resulting extracted programs are in a form suitable for use in hierarchical verifications in that they are amenable to clean partial evaluation via extensions to the Nuprl rewrite system. The method is based on two elements: specifications written with careful use of the Nuprl set-type to restrict the extracts to strictly computational content; and on proofs that use induction tactics that generate extracts using familiar fixed-point combinators of the untyped lambda calculus. In this paper the methodology is described and its application is illustrated by example. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. L. Constable, et al. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1986. </year>
Reference-contexts: 1. Introduction The ability to extract correct-by-construction programs directly from proofs is the most notable feature of constructive type theories as implemented in Nuprl <ref> [1] </ref> and related systems [8, 2, 10]. However, there still is no established software engineering practice based on the extraction of programs from constructive proofs in any of the constructive systems. <p> A complete presentation of the type theory can be found in the Nuprl book <ref> [1] </ref>. The Nuprl system, as distinguished from the type theory, implements a rich environment to support reasoning about and computing with the Nuprl type theory. <p> The term x2T is an encoding of x=x2T Interpreting the type membership equality relation and type membership as types is made sensible via the propositions-as-types interpretation <ref> [1, pg.29-31] </ref>. In addition to the type membership equality provided with each type, there is an equality on types. Equality of types is intensional i.e. type equality in Nuprl is a structural equality modulo the direct computation rules. <p> Judgements of the second form are also called well-formedness goals. The computational content of well-formedness goals is trivial. Stating the conditions under which a Nuprl sequent is deemed true are technically complicated by functionality constraints; the reader is referred to the Nuprl book <ref> [1, pg.141] </ref> for a fuller account. Somewhat informally, a judgement asserts that, assuming the hypotheses are well-formed types, and the hypotheses, conclusion and extract terms are functional in those types, then the term S is an inhabited type and the extract s is an inhabitant. <p> While the Y itself can not be assigned a type in Nuprl (i.e. it is not well-formed); well-formedness theorems for functions defined using Y show they inhabit the appropriate type. This approach is possible because the fixed-point behavior is justified via Nuprl's direct computation rules which implicitly preserve typing <ref> [1] </ref>. Because the direct computation rules preserve typing, well-formedness goals are not generated when the conversion to unfold Y is applied and one is never required to assign a type to Y itself. <p> Thus if f is the extract of the theorem, we can easily prove 8T:U.8P:T ! P.8L:T List. (f (T)(P)(L)).1 2 P Where for any pair hx,yi, hx,yi.1 = x. This is precisely the approach described in the Nuprl book <ref> [1, section 4.4] </ref> and elsewhere [10, section 21.1]. But the approach fails if we are interested in using the extract in proofs where we need efficient selective unfolding of terms and partial evaluations. <p> Certainly it is well known in the Nuprl community how the set type can be used to hide unwanted computational content. However, the approach is rarely applied in practice. Indeed, even in examples where the goal of the exercise is to extract computational content <ref> [1, pg.86-93] </ref> they prefer the existential quantifier to the set type and choose to project the first element of the pair. The problem of extracting clear programs from proofs in the Calculus of Constructions has been addressed by Paulin-Mohring [9, 11].
Reference: [2] <author> G. Dowek, A. Felty, H. Herbelin, G. Huet, C. Murthy, C. Parent, C. Paulin-Mohring, and B. Werner. </author> <title> The Coq proof assistant user's guide. Rapport Techniques 154, </title> <publisher> INRIA, </publisher> <address> Roc-quencourt, France, </address> <year> 1993. </year> <note> Version 5.8. </note>
Reference-contexts: 1. Introduction The ability to extract correct-by-construction programs directly from proofs is the most notable feature of constructive type theories as implemented in Nuprl [1] and related systems <ref> [8, 2, 10] </ref>. However, there still is no established software engineering practice based on the extraction of programs from constructive proofs in any of the constructive systems.
Reference: [3] <author> M. Gordon, R. Milner, and C. Wadsworth. </author> <title> Edinburgh LCF: a mechanized logic of computation. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 78, </volume> <year> 1979. </year>
Reference-contexts: The Nuprl system The Nuprl system supports construction of top-down proofs by refinement. The prover is implemented as a tactic based prover in the style of LCF <ref> [3] </ref> and is built on a base of ML. In Nuprl the proposition-as-types interpretation allows for presentations to be cloaked in either logical or more purely type-theoretic terms. The system supports a library mechanism which provides for grouping of Nuprl objects.
Reference: [4] <author> S. Hayashi and H. Nakano. PX: </author> <title> A Computational Logic. </title> <booktitle> Foundations of Computing. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year>
Reference-contexts: The approach separates computationally informative and non-informative propositions by syntactic means. This provides a means of eliminating the parts of the program corresponding to the logical specification. A similar idea of separating non-computational content from computationally interesting content is implemented in the system PX <ref> [4] </ref>. But neither system can define functions by ordinary recursion and neither provides a means for proving new induction principles as we have above. 6. Conclusions and Future Work The work reported on here was motivated by need.
Reference: [5] <author> D. J. Howe. </author> <title> Reasoning about functional programs in Nuprl. </title> <booktitle> In Functional Programming, Concurrency, Simulation and Automated Reasoning, volume 693 of Lecture Notes in Computer Science, </booktitle> <address> Berlin, 1993. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: The author is currently visiting Cornell University, and can be contacted at 4116 Upson Hall, Cornell University, Ithaca, NY, 14850. in an attempt to improve the efficiency, readability, and understanding of extracted programs <ref> [11, 5, 12] </ref>. This paper presents a methodology for specification and proof in the Nuprl system that yields clean recursive programs as extracts. The methodology for directly defining recursive functions and proving properties about them is well established in Nuprl practice. <p> The methodology for directly defining recursive functions and proving properties about them is well established in Nuprl practice. Indeed many of the pieces for the new methodology described here are already present in <ref> [5] </ref>. The approach described here makes it possible to extract programs from proofs that can be uniformly manipulated by the Nuprl system using current methodology. <p> For the purposes of this paper we are concerned with display form objects, definition objects (or abstractions), theorem objects, and ML objects. 3. Recursive Function Definitions In Nuprl In current Nuprl methodology recursive functions are directly defined by applying Curry's Y combinator <ref> [5, 7] </ref>. The Y combinator is defined in the Nuprl system library core 2 as follows: *A ycomb Y == f.(x.f (x x))(x.f (x x)) The methodology for effective use of definitions incorporating Y depend on the rewriting system. <p> The proof is surprisingly intricate although it is modeled on a similar induction principle developed by Howe <ref> [5] </ref> for natural numbers and having a recursion combinator defined using Y as its extract. A new tactic, ListIndY, facilitates the application of the induction principle. ListIndY duplicates the behavior of the ordinary ListInd tactic in most contexts. <p> L,L'. (letrec f L = if null (L) then [] else h::t = L in if null (L') then f (t) else append (map (z.&lt;h, z&gt;;L'),f (t)) fi 5. Related Work The methodology in this paper owes much to <ref> [5] </ref>. In that paper, Howe described verification and extraction methodologies applied to Boyer-Moore's fast majority algorithm in Nuprl 3. He developed a natural number induction theorem having as its extract the recursion combinator defined by Y.
Reference: [6] <author> P. Jackson. </author> <title> The Nuprl proof developemnt system, version 4.2 reference manual and user's guide. </title> <institution> Computer Science Department, Cornell University, Ithaca, N.Y. </institution> <note> Manuscript available at http://www.cs.cornell.edu/Info/Projects/NuPrl/nuprl.html, July 1995. </note>
Reference-contexts: Because the direct computation rules preserve typing, well-formedness goals are not generated when the conversion to unfold Y is applied and one is never required to assign a type to Y itself. Tactic support for the methodology is described in <ref> [6, 7] </ref> In this paper, and in Nuprl libraries developed by the author, the Y combinator is hidden by the more familiar letrec form.
Reference: [7] <author> P. B. Jackson. </author> <title> Enhancing the Nuprl proof development system and applying it to computational abstract algebra. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1995. </year>
Reference-contexts: For the purposes of this paper we are concerned with display form objects, definition objects (or abstractions), theorem objects, and ML objects. 3. Recursive Function Definitions In Nuprl In current Nuprl methodology recursive functions are directly defined by applying Curry's Y combinator <ref> [5, 7] </ref>. The Y combinator is defined in the Nuprl system library core 2 as follows: *A ycomb Y == f.(x.f (x x))(x.f (x x)) The methodology for effective use of definitions incorporating Y depend on the rewriting system. <p> Because the direct computation rules preserve typing, well-formedness goals are not generated when the conversion to unfold Y is applied and one is never required to assign a type to Y itself. Tactic support for the methodology is described in <ref> [6, 7] </ref> In this paper, and in Nuprl libraries developed by the author, the Y combinator is hidden by the more familiar letrec form.
Reference: [8] <author> P. </author> <title> Martin-L of. </title> <booktitle> Constructive mathematics and computer programming. In Sixth International Congress for Logic, Methodology, and Philosophy of Science, </booktitle> <pages> pages 153-75. </pages> <address> Amsterdam:North Holland, </address> <year> 1982. </year>
Reference-contexts: 1. Introduction The ability to extract correct-by-construction programs directly from proofs is the most notable feature of constructive type theories as implemented in Nuprl [1] and related systems <ref> [8, 2, 10] </ref>. However, there still is no established software engineering practice based on the extraction of programs from constructive proofs in any of the constructive systems. <p> For example, although T and fx:T | Trueg have the same members and equality relations, they are not equal types in Nuprl. Like the related type theory of Martin-L of <ref> [8] </ref> or the type theory of Whitehead and Russell's Principia Mathematica, Nuprl's type theory is predicative, supporting an unbounded cumulative hierarchy of type universes. Every universe is itself a type and every type is an element of some universe.
Reference: [9] <author> C. Mohring. </author> <title> Algorithm development in the Calculus of Constructions. </title> <booktitle> In Proceedings of the First Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 84-91. </pages> <publisher> IEEE, </publisher> <year> 1986. </year>
Reference-contexts: The problem of extracting clear programs from proofs in the Calculus of Constructions has been addressed by Paulin-Mohring <ref> [9, 11] </ref>. The approach separates computationally informative and non-informative propositions by syntactic means. This provides a means of eliminating the parts of the program corresponding to the logical specification. A similar idea of separating non-computational content from computationally interesting content is implemented in the system PX [4].
Reference: [10] <author> B. Nordstrom, K. Petersson, and J. M. Smith. </author> <title> Programming in Martin-L of's type theory: an introduction. </title> <publisher> Oxford University Press, </publisher> <year> 1990. </year>
Reference-contexts: 1. Introduction The ability to extract correct-by-construction programs directly from proofs is the most notable feature of constructive type theories as implemented in Nuprl [1] and related systems <ref> [8, 2, 10] </ref>. However, there still is no established software engineering practice based on the extraction of programs from constructive proofs in any of the constructive systems. <p> Thus if f is the extract of the theorem, we can easily prove 8T:U.8P:T ! P.8L:T List. (f (T)(P)(L)).1 2 P Where for any pair hx,yi, hx,yi.1 = x. This is precisely the approach described in the Nuprl book [1, section 4.4] and elsewhere <ref> [10, section 21.1] </ref>. But the approach fails if we are interested in using the extract in proofs where we need efficient selective unfolding of terms and partial evaluations. The following term, shown after one step of reduction, was extracted from a natural proof of the list all exists lemma.
Reference: [11] <author> C. Paulin-Mohring. </author> <title> Extracting F ! 's programs from proofs in the Calculus of Constructions. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 89-104. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: The author is currently visiting Cornell University, and can be contacted at 4116 Upson Hall, Cornell University, Ithaca, NY, 14850. in an attempt to improve the efficiency, readability, and understanding of extracted programs <ref> [11, 5, 12] </ref>. This paper presents a methodology for specification and proof in the Nuprl system that yields clean recursive programs as extracts. The methodology for directly defining recursive functions and proving properties about them is well established in Nuprl practice. <p> The problem of extracting clear programs from proofs in the Calculus of Constructions has been addressed by Paulin-Mohring <ref> [9, 11] </ref>. The approach separates computationally informative and non-informative propositions by syntactic means. This provides a means of eliminating the parts of the program corresponding to the logical specification. A similar idea of separating non-computational content from computationally interesting content is implemented in the system PX [4].
Reference: [12] <author> C. Paulin-Mohring and B. Werner. </author> <title> Synthesis of ML programs in the system coq. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 15(5-6):607-640, </volume> <year> 1993. </year>
Reference-contexts: The author is currently visiting Cornell University, and can be contacted at 4116 Upson Hall, Cornell University, Ithaca, NY, 14850. in an attempt to improve the efficiency, readability, and understanding of extracted programs <ref> [11, 5, 12] </ref>. This paper presents a methodology for specification and proof in the Nuprl system that yields clean recursive programs as extracts. The methodology for directly defining recursive functions and proving properties about them is well established in Nuprl practice.
References-found: 12

