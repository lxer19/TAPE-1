URL: http://www.cs.indiana.edu/l/www/ftp/pierce/pict/pict-4.1/Doc/design.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/pict/pict-4.1/Doc/
Root-URL: http://www.cs.indiana.edu
Title: Pict: A Programming Language Based on the Pi-Calculus  
Author: Benjamin C. Pierce David N. Turner 
Note: Dedicated to Robin Milner on the occasion of his 60th birthday.  
Abstract: Indiana University CSCI Technical Report #476 March 22, 1998 Abstract The -calculus offers an attractive basis for concurrent programming. It is small, elegant, and well studied, and supports (via simple encodings) a wide range of high-level constructs including data structures, higher-order functional programming, concurrent control structures, and objects. Moreover, familiar type systems for the -calculus have direct counterparts in the -calculus, yielding strong, static typing for a high-level language using the -calculus as its core. This paper describes Pict, a strongly-typed concurrent programming language constructed in terms of an explicitly-typed -calculus core language. 
Abstract-found: 1
Intro-found: 1
Reference: [AC93] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <year> 1993. </year> <note> A preliminary version appeared in POPL '91 (pp. 104-118) and as DEC Systems Research Center Research Report number 62, </note> <month> August </month> <year> 1990. </year>
Reference-contexts: Such recursive types have received considerable attention in the literature <ref> [MPS86, CC91, AC93, etc.] </ref>, and many different technical treatments have been proposed. <p> if F and G are type operators, then we say F &lt; G if (F T) &lt; (G T) for all appropriately kinded argument types T. ; X&lt;Top:K ` S &lt; T (S-Abs) ` (S U) &lt; (T U) For subtyping of recursive types, we use the familiar "Amber rule" <ref> [Car86, AC93] </ref>, which states that (rec X=S) is a subtype of (rec Y=T) if we can show S &lt; T under the assumption X &lt; Y. ; Y&lt;Top:K; X&lt;Y ` S &lt; T (S-Rec) 3.10 Values If the current context contains the binding x:T for the variable x, then the type <p> we design a practical type system for the -calculus combining subtyping and higher-order polymorphism? The Pict type system integrates a number of well-studied ideas: Milner's simple sorting discipline for channels [Mil91], polymorphic channels [Tur96], higher-order polymorphism [Gir72], input/output modalities [PS93], higher-order subtyping [Car90, Mit90, PT94, HP95, PS96], and recursive types <ref> [MPS86, AC93] </ref>. However, the key to obtaining a workable type system for Pict was the development of a practical type inference algorithm. Pict's partial type inference algorithm is surprisingly simple and easy to understand, but yet our experience has been that it gives very acceptable results.
Reference: [AC96] <author> Martn Abadi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The treatment of subtyping and higher-order polymorphism is based on recent work on static type systems for object-oriented languages <ref> [Car84, Bru94, CHC90, PT94, HP95, FM94, AC96, etc.] </ref> and the -calculus F ! [Car90, Mit90, PS96]. The rules for channel types are taken from Pierce and Sangiorgi's type system for the pure -calculus [PS93]. An early version of the Pict type system was presented in [PRT93].
Reference: [ACS96] <author> Roberto M. Amadio, Ilaria Castellani, and Davide Sangiorgi. </author> <title> On bisimulations for the asynchronous pi-calculus. </title> <type> Technical report, </type> <institution> INRIA-Sophia Antipolis, </institution> <year> 1996. </year> <month> 22 </month>
Reference-contexts: The investigation of asynchronous process calculi was initiated by Honda, Tokoro, and Yoshida [HT91, HY94] and Boudol [Bou92]. Amadio, Castellani and Sangiorgi <ref> [ACS96] </ref> have more recently shown how several technical aspects of observational equivalence are simplified in the asynchronous case. 2.3.3 No Choice Early versions of the -calculus used a completely unrestricted choice operator: in the expression e 1 + e 2 , the branches e 1 and e 2 could be arbitrary
Reference: [Agh86] <author> Gul A. Agha. </author> <title> Actors: a Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: Cardelli's Obliq [Car95] achieves related aims by building on a primitive notion of network objects. Pict belongs to a sizeable family of concurrent programming language designs inspired by theoretical calculi, including Vasconcelos's TyCo [Vas94], Kobayashi's HACL [Kob96], and numerous actor languages <ref> [Hew77, Agh86, etc.] </ref>. A particularly close relative is the language Oz [Smo95], which integrates functional, object-oriented, and concurrent constraint programming by translation into a common core calculus [Smo94]. Although this calculus uses concurrent constraints as its basic communication mechanism, the encoding of high-level features is strongly reminiscent of Pict.
Reference: [Ama94] <author> Roberto M. Amadio. </author> <title> Translating core Facile. </title> <type> Technical Report ECRC-TR-3-94, </type> <institution> European Computer-Industry Research Center, GmbH, Munich, </institution> <year> 1994. </year> <note> Also available as a technical report from CRIN(CNRS)- Inria (Nancy). </note>
Reference-contexts: In this section, we show how more convenient high-level constructs are built up from the core by means of source-to-source translations | following in the tradition of numerous papers showing how various high-level features can be encoded in the -calculus <ref> [San92, San94, San93, Mil90, Jon93, Wal95, Ama94, AP94, etc.] </ref>. We discuss only the more interesting translation rules; the complete list can be found in the Pict language definition [PT97]. 4.1 Simple Translations Large programs often contain long sequences of declarations like (new x 1 ... (new x n e)).
Reference: [AP94] <author> Roberto M. Amadio and Sanjiva Prasad. </author> <title> Localities and failures. </title> <type> Technical Report ECRC-M2-R10, </type> <institution> European Computer-Industry Research Center, GmbH, Munich, </institution> <year> 1994. </year>
Reference-contexts: In this section, we show how more convenient high-level constructs are built up from the core by means of source-to-source translations | following in the tradition of numerous papers showing how various high-level features can be encoded in the -calculus <ref> [San92, San94, San93, Mil90, Jon93, Wal95, Ama94, AP94, etc.] </ref>. We discuss only the more interesting translation rules; the complete list can be found in the Pict language definition [PT97]. 4.1 Simple Translations Large programs often contain long sequences of declarations like (new x 1 ... (new x n e)).
Reference: [Bar92] <author> Henk Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In Gabbay Abramsky and Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, volume II. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: That is, List is a function from types to types. To avoid nonsensical applications like (List List) or (Int Int), we classify types and type operators according to their kinds, as in typed -calculi such as System F ! <ref> [Gir72, Bar92] </ref> and F ! [Car90, Mit90, HP95, PS96]. Thus, the type system recognizes three distinct levels of expressions: values, types, and kinds. The level of values contains familiar entities like 5, true, the tuple [5 true], and channels.
Reference: [BMT92] <author> Dave Berry, Robin Milner, and David N. Turner. </author> <title> A semantics for ML concurrency primitives. </title> <booktitle> In ACM Principles of Programming Languages, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: Although this calculus uses concurrent constraints as its basic communication mechanism, the encoding of high-level features is strongly reminiscent of Pict. Our choice of high-level language features leads to a programming style similar to that found in functional languages with channel-based concurrency such as PFL [Hol83], Amber [Car86], CML <ref> [Rep91, BMT92] </ref>, Facile [GMP89], Poly/ML [Mat91], and Concurrent Haskell [JGF96]. The most significant difference lies in the type system: the impredicative polymorphism of Pict permits the encoding of polymorphic functions 20 using polymorphic communication.
Reference: [Bou92] <author> Gerard Boudol. </author> <title> Asynchrony and the -calculus (note). </title> <institution> Rapporte de Recherche 1702, INRIA Sofia-Antipolis, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: The programmer must send an explicit acknowledgement or result to inform the client that its request has been processed, thereby eliminating any possible sensitivity to buffering or reordering of requests. The investigation of asynchronous process calculi was initiated by Honda, Tokoro, and Yoshida [HT91, HY94] and Boudol <ref> [Bou92] </ref>.
Reference: [Bru94] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design, static typing and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2), </volume> <month> April </month> <year> 1994. </year> <title> A preliminary version appeared in POPL 1993 under the title "Safe Type Checking in a Statically Typed Object-Oriented Programming Language". </title>
Reference-contexts: The treatment of subtyping and higher-order polymorphism is based on recent work on static type systems for object-oriented languages <ref> [Car84, Bru94, CHC90, PT94, HP95, FM94, AC96, etc.] </ref> and the -calculus F ! [Car90, Mit90, PS96]. The rules for channel types are taken from Pierce and Sangiorgi's type system for the pure -calculus [PS93]. An early version of the Pict type system was presented in [PRT93].
Reference: [Car84] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In G. Kahn, D. MacQueen, and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year> <note> Full version in Information and Computation </note> 76(2/3):138-164, 1988. 
Reference-contexts: The treatment of subtyping and higher-order polymorphism is based on recent work on static type systems for object-oriented languages <ref> [Car84, Bru94, CHC90, PT94, HP95, FM94, AC96, etc.] </ref> and the -calculus F ! [Car90, Mit90, PS96]. The rules for channel types are taken from Pierce and Sangiorgi's type system for the pure -calculus [PS93]. An early version of the Pict type system was presented in [PRT93].
Reference: [Car86] <author> Luca Cardelli. </author> <title> Amber. </title> <editor> In Guy Cousineau, Pierre-Louis Curien, and Bernard Robinet, editors, </editor> <booktitle> Combi-nators and Functional Programming Languages, </booktitle> <pages> pages 21-47. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> Lecture Notes in Computer Science No. 242. </note>
Reference-contexts: the replicated choice construct of [PT95] exhibits similar good behavior. 3 Type System The Pict type system has its roots in the theoretical literature on type systems for the -calculus [Mil91, Gay93, VH93, PS93, Tur96] and for functional languages, among which its most immediate predecessors are Quest [Car91] and Amber <ref> [Car86] </ref>. The treatment of subtyping and higher-order polymorphism is based on recent work on static type systems for object-oriented languages [Car84, Bru94, CHC90, PT94, HP95, FM94, AC96, etc.] and the -calculus F ! [Car90, Mit90, PS96]. <p> if F and G are type operators, then we say F &lt; G if (F T) &lt; (G T) for all appropriately kinded argument types T. ; X&lt;Top:K ` S &lt; T (S-Abs) ` (S U) &lt; (T U) For subtyping of recursive types, we use the familiar "Amber rule" <ref> [Car86, AC93] </ref>, which states that (rec X=S) is a subtype of (rec Y=T) if we can show S &lt; T under the assumption X &lt; Y. ; Y&lt;Top:K; X&lt;Y ` S &lt; T (S-Rec) 3.10 Values If the current context contains the binding x:T for the variable x, then the type <p> Although this calculus uses concurrent constraints as its basic communication mechanism, the encoding of high-level features is strongly reminiscent of Pict. Our choice of high-level language features leads to a programming style similar to that found in functional languages with channel-based concurrency such as PFL [Hol83], Amber <ref> [Car86] </ref>, CML [Rep91, BMT92], Facile [GMP89], Poly/ML [Mat91], and Concurrent Haskell [JGF96]. The most significant difference lies in the type system: the impredicative polymorphism of Pict permits the encoding of polymorphic functions 20 using polymorphic communication.
Reference: [Car90] <author> Luca Cardelli. </author> <title> Notes about F ! &lt;: </title> . <type> Unpublished manuscript, </type> <month> October </month> <year> 1990. </year>
Reference-contexts: The treatment of subtyping and higher-order polymorphism is based on recent work on static type systems for object-oriented languages [Car84, Bru94, CHC90, PT94, HP95, FM94, AC96, etc.] and the -calculus F ! <ref> [Car90, Mit90, PS96] </ref>. The rules for channel types are taken from Pierce and Sangiorgi's type system for the pure -calculus [PS93]. An early version of the Pict type system was presented in [PRT93]. Typed process calculi with related goals have been proposed by Nierstrasz [Nie95] and Vasconce-los [Vas94]. <p> That is, List is a function from types to types. To avoid nonsensical applications like (List List) or (Int Int), we classify types and type operators according to their kinds, as in typed -calculi such as System F ! [Gir72, Bar92] and F ! <ref> [Car90, Mit90, HP95, PS96] </ref>. Thus, the type system recognizes three distinct levels of expressions: values, types, and kinds. The level of values contains familiar entities like 5, true, the tuple [5 true], and channels. <p> of being compiled to native code.) 21 Can we design a practical type system for the -calculus combining subtyping and higher-order polymorphism? The Pict type system integrates a number of well-studied ideas: Milner's simple sorting discipline for channels [Mil91], polymorphic channels [Tur96], higher-order polymorphism [Gir72], input/output modalities [PS93], higher-order subtyping <ref> [Car90, Mit90, PT94, HP95, PS96] </ref>, and recursive types [MPS86, AC93]. However, the key to obtaining a workable type system for Pict was the development of a practical type inference algorithm.
Reference: [Car91] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> An earlier version appeared as DEC Systems Research Center Research Report #45, </note> <month> February </month> <year> 1989. </year>
Reference-contexts: are handled fairly; the replicated choice construct of [PT95] exhibits similar good behavior. 3 Type System The Pict type system has its roots in the theoretical literature on type systems for the -calculus [Mil91, Gay93, VH93, PS93, Tur96] and for functional languages, among which its most immediate predecessors are Quest <ref> [Car91] </ref> and Amber [Car86]. The treatment of subtyping and higher-order polymorphism is based on recent work on static type systems for object-oriented languages [Car84, Bru94, CHC90, PT94, HP95, FM94, AC96, etc.] and the -calculus F ! [Car90, Mit90, PS96].
Reference: [Car95] <author> Luca Cardelli. </author> <title> A language with distributed scope. </title> <journal> Computing Systems, </journal> <volume> 8(1) </volume> <pages> 27-59, </pages> <year> 1995. </year> <note> Short version in Principles of Programming Languages (POPL), </note> <month> January </month> <year> 1995. </year>
Reference-contexts: Work is currently underway on the design of a new language, tentatively named Distributed Pict, based on a variant of the -calculus [FG96] extended with distribution primitives [FGL + 96]. Cardelli's Obliq <ref> [Car95] </ref> achieves related aims by building on a primitive notion of network objects. Pict belongs to a sizeable family of concurrent programming language designs inspired by theoretical calculi, including Vasconcelos's TyCo [Vas94], Kobayashi's HACL [Kob96], and numerous actor languages [Hew77, Agh86, etc.].
Reference: [CC91] <author> Felice Cardone and Mario Coppo. </author> <title> Type inference with recursive types. Syntax and semantics. </title> <journal> Information and Computation, </journal> <volume> 92(1) </volume> <pages> 48-80, </pages> <year> 1991. </year>
Reference-contexts: Such recursive types have received considerable attention in the literature <ref> [MPS86, CC91, AC93, etc.] </ref>, and many different technical treatments have been proposed.
Reference: [CHC90] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: The treatment of subtyping and higher-order polymorphism is based on recent work on static type systems for object-oriented languages <ref> [Car84, Bru94, CHC90, PT94, HP95, FM94, AC96, etc.] </ref> and the -calculus F ! [Car90, Mit90, PS96]. The rules for channel types are taken from Pierce and Sangiorgi's type system for the pure -calculus [PS93]. An early version of the Pict type system was presented in [PRT93].
Reference: [CMMS94] <author> Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. </author> <title> An extension of system F with subtyping. </title> <journal> Information and Computation, </journal> <note> 109(1-2):4-56, 1994. A preliminary version appeared in TACS '91 (Sendai, Japan, pp. 750-770). </note>
Reference-contexts: list, tl, has already been built and has type (List Int)): (new r:^(List Int) (cons!-Int-[33 tl r] | r?l:(List Int) = ...)) Polymorphism and subtyping are combined by giving each bound type variable in a package value an upper bound, as in the polymorphic -calculus with bounded quantification, System F <ref> [CW85, CMMS94] </ref>. 10 For example, the type ^-X&lt;T-[X ^X] describes a channel that can be used to transmit a type X and two values of types X and ^X, but also stipulates that the only legal values of X are subtypes of T.
Reference: [Com94] <author> Adriana B. Compagnoni. </author> <title> Decidability of higher-order subtyping with intersection types. </title> <booktitle> In Computer Science Logic, </booktitle> <month> September </month> <year> 1994. </year> <title> Kazimierz, </title> <booktitle> Poland. Springer Lecture Notes in Computer Science 933, </booktitle> <month> June </month> <year> 1995. </year> <note> Also available as University of Edinburgh, LFCS technical report ECS-LFCS-94-281, titled "Subtyping in F ! ^ is decidable". </note>
Reference-contexts: foundations needed to prove these two properties have already been established for the major components of the Pict type system | for channel types and subtyping by Pierce and Sangiorgi [PS93], 16 for polymorphic channels by Turner [Tur96], for higher-order polymorphism with subtyping by Pierce and Steffen [PS96] and Compagnoni <ref> [Com94] </ref>. However, the above properties remain conjectures, since we have not checked the type system as a whole. 4 Derived Forms The statically-typed core language of Pict is a powerful, safe, and unacceptably verbose programming notation.
Reference: [CS87] <author> G. Costa and C. Stirling. </author> <title> Weak and strong fairness in CCS. </title> <journal> Information and Computation, </journal> <volume> 73(3) </volume> <pages> 207-244, </pages> <year> 1987. </year>
Reference-contexts: We are unaware of any work formalising fairness for -calculus, but Costa and Stirling's work on fairness for CCS <ref> [CS87] </ref> seems likely to be generalisable to the case of -calculus.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: list, tl, has already been built and has type (List Int)): (new r:^(List Int) (cons!-Int-[33 tl r] | r?l:(List Int) = ...)) Polymorphism and subtyping are combined by giving each bound type variable in a package value an upper bound, as in the polymorphic -calculus with bounded quantification, System F <ref> [CW85, CMMS94] </ref>. 10 For example, the type ^-X&lt;T-[X ^X] describes a channel that can be used to transmit a type X and two values of types X and ^X, but also stipulates that the only legal values of X are subtypes of T. <p> Readers familiar with typed -calculi will recognize the similarity of this rule to the standard introduction rule for existential types (e.g. <ref> [CW85, MP88] </ref>). The pattern typing rule P-Package in Section 3.12 plays the role of the standard elimination rule for existentials.
Reference: [FG96] <author> Cedric Fournet and Georges Gonthier. </author> <title> The reflexive chemical abstract machine and the join-calculus. </title> <booktitle> In Principles of Programming Languages, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: Work is currently underway on the design of a new language, tentatively named Distributed Pict, based on a variant of the -calculus <ref> [FG96] </ref> extended with distribution primitives [FGL + 96]. Cardelli's Obliq [Car95] achieves related aims by building on a primitive notion of network objects.
Reference: [FGL + 96] <author> Cedric Fournet, Georges Gonthier, Jean-Jacques Levy, Luc Maranget, and Didier Remy. </author> <title> A calculus of mobile agents. </title> <booktitle> In 7th International Conference on Concurrency Theory (CONCUR'96), </booktitle> <pages> pages 406-421, </pages> <address> Pisa, Italy, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. LNCS 1119. </note>
Reference-contexts: Work is currently underway on the design of a new language, tentatively named Distributed Pict, based on a variant of the -calculus [FG96] extended with distribution primitives <ref> [FGL + 96] </ref>. Cardelli's Obliq [Car95] achieves related aims by building on a primitive notion of network objects. Pict belongs to a sizeable family of concurrent programming language designs inspired by theoretical calculi, including Vasconcelos's TyCo [Vas94], Kobayashi's HACL [Kob96], and numerous actor languages [Hew77, Agh86, etc.].
Reference: [FM94] <author> Kathleen Fisher and John Mitchell. </author> <booktitle> Notes on typed object-oriented programming. In Proceedings of Theoretical Aspects of Computer Software, Sendai, Japan, </booktitle> <pages> pages 844-885. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1994. </year> <note> LNCS 789. 23 </note>
Reference-contexts: The treatment of subtyping and higher-order polymorphism is based on recent work on static type systems for object-oriented languages <ref> [Car84, Bru94, CHC90, PT94, HP95, FM94, AC96, etc.] </ref> and the -calculus F ! [Car90, Mit90, PS96]. The rules for channel types are taken from Pierce and Sangiorgi's type system for the pure -calculus [PS93]. An early version of the Pict type system was presented in [PRT93].
Reference: [Gay93] <author> Simon J. Gay. </author> <title> A sort inference algorithm for the polyadic -calculus. </title> <booktitle> In Proceedings of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: lock channel l in the reference cell of Section 4.6 ensures that competing set and get requests are handled fairly; the replicated choice construct of [PT95] exhibits similar good behavior. 3 Type System The Pict type system has its roots in the theoretical literature on type systems for the -calculus <ref> [Mil91, Gay93, VH93, PS93, Tur96] </ref> and for functional languages, among which its most immediate predecessors are Quest [Car91] and Amber [Car86].
Reference: [Gir72] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: values, since the position of a field in a record can be determined from its type at compile time (this is especially useful when separately compiling Pict programs). 3.5 Polymorphism Our type system may readily be extended to include polymorphism, just as simply typed -calculus can be extended with polymorphism <ref> [Gir72, Rey74] </ref>. We support polymorphic communications by adding two new syntactic forms: package values -T-v and package patterns -X-p. For example, if c is a channel of type ^Int, the output expression z!-Int-[5 c] sends along the channel z the type Int and the pair of values 5 and c. <p> That is, List is a function from types to types. To avoid nonsensical applications like (List List) or (Int Int), we classify types and type operators according to their kinds, as in typed -calculi such as System F ! <ref> [Gir72, Bar92] </ref> and F ! [Car90, Mit90, HP95, PS96]. Thus, the type system recognizes three distinct levels of expressions: values, types, and kinds. The level of values contains familiar entities like 5, true, the tuple [5 true], and channels. <p> the CML program had the advantage of being compiled to native code.) 21 Can we design a practical type system for the -calculus combining subtyping and higher-order polymorphism? The Pict type system integrates a number of well-studied ideas: Milner's simple sorting discipline for channels [Mil91], polymorphic channels [Tur96], higher-order polymorphism <ref> [Gir72] </ref>, input/output modalities [PS93], higher-order subtyping [Car90, Mit90, PT94, HP95, PS96], and recursive types [MPS86, AC93]. However, the key to obtaining a workable type system for Pict was the development of a practical type inference algorithm.
Reference: [GMP89] <author> Alessandro Giacalone, Prateek Mishra, and Sanjiva Prasad. </author> <title> Facile: A Symmetric Integration of Concurrent and Functional Programming. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 18(2) </volume> <pages> 121-160, </pages> <year> 1989. </year>
Reference-contexts: Our choice of high-level language features leads to a programming style similar to that found in functional languages with channel-based concurrency such as PFL [Hol83], Amber [Car86], CML [Rep91, BMT92], Facile <ref> [GMP89] </ref>, Poly/ML [Mat91], and Concurrent Haskell [JGF96]. The most significant difference lies in the type system: the impredicative polymorphism of Pict permits the encoding of polymorphic functions 20 using polymorphic communication.
Reference: [Hew77] <author> C. Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Artificial Intelligence, </journal> <volume> 8 </volume> <pages> 323-364, </pages> <year> 1977. </year>
Reference-contexts: Cardelli's Obliq [Car95] achieves related aims by building on a primitive notion of network objects. Pict belongs to a sizeable family of concurrent programming language designs inspired by theoretical calculi, including Vasconcelos's TyCo [Vas94], Kobayashi's HACL [Kob96], and numerous actor languages <ref> [Hew77, Agh86, etc.] </ref>. A particularly close relative is the language Oz [Smo95], which integrates functional, object-oriented, and concurrent constraint programming by translation into a common core calculus [Smo94]. Although this calculus uses concurrent constraints as its basic communication mechanism, the encoding of high-level features is strongly reminiscent of Pict.
Reference: [HL94] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Proceedings of the Twenty-First ACM Symposium on Principles of Programming Languages (POPL), Portland, Oregon, </booktitle> <pages> pages 123-137, </pages> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: For instance, we hope to extend Pict's treatment of existential types to account for type sharing (using techniques similar to those proposed by Leroy [Ler95] and Harper and Lillibridge <ref> [HL94] </ref>). Acknowledgements Robin Milner's past and present work on programming languages, concurrency, and the -calculus in particular is very strongly in the background of this project, and conversations with Robin have contributed many specific insights.
Reference: [Hol83] <author> Soren Holmstrom. </author> <title> PFL: A functional language for parallel programming, and its implementation. Programming Methodology Group, </title> <type> Report 7, </type> <institution> University of Goteborg and Chalmers University of Technology, </institution> <month> September </month> <year> 1983. </year>
Reference-contexts: Although this calculus uses concurrent constraints as its basic communication mechanism, the encoding of high-level features is strongly reminiscent of Pict. Our choice of high-level language features leads to a programming style similar to that found in functional languages with channel-based concurrency such as PFL <ref> [Hol83] </ref>, Amber [Car86], CML [Rep91, BMT92], Facile [GMP89], Poly/ML [Mat91], and Concurrent Haskell [JGF96]. The most significant difference lies in the type system: the impredicative polymorphism of Pict permits the encoding of polymorphic functions 20 using polymorphic communication.
Reference: [Hon93] <author> Kohei Honda. </author> <title> Types for dyadic interaction. </title> <booktitle> In CONCUR'93, volume 715 of Lecture Notes in Computer Science, </booktitle> <pages> pages 509-523, </pages> <year> 1993. </year>
Reference-contexts: An early version of the Pict type system was presented in [PRT93]. Typed process calculi with related goals have been proposed by Nierstrasz [Nie95] and Vasconce-los [Vas94]. Further refinements to the channel typing discipline incorporating notions of linear channel usage have been studied by Honda <ref> [Hon93, HY94, Hon96] </ref>, and more recently by Kobayashi and Yonezawa [KY94] and the present authors in collaboration with Kobayashi [KPT96]. 8 3.1 Channel Types Most type systems for process calculi and concurrent languages impose the constraint that each channel must be used throughout its lifetime to carry values of a single
Reference: [Hon96] <author> Kohei Honda. </author> <title> Composing processes. </title> <booktitle> In Principles of Programming Languages (POPL), </booktitle> <pages> pages 344-357, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: An early version of the Pict type system was presented in [PRT93]. Typed process calculi with related goals have been proposed by Nierstrasz [Nie95] and Vasconce-los [Vas94]. Further refinements to the channel typing discipline incorporating notions of linear channel usage have been studied by Honda <ref> [Hon93, HY94, Hon96] </ref>, and more recently by Kobayashi and Yonezawa [KY94] and the present authors in collaboration with Kobayashi [KPT96]. 8 3.1 Channel Types Most type systems for process calculi and concurrent languages impose the constraint that each channel must be used throughout its lifetime to carry values of a single
Reference: [HP95] <author> Martin Hofmann and Benjamin Pierce. </author> <title> A unifying type-theoretic framework for objects. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(4) </volume> <pages> 593-635, </pages> <month> October </month> <year> 1995. </year> <note> Previous versions appeared in the Symposium on Theoretical Aspects of Computer Science, </note> <year> 1994, </year> <title> (pages 251-262) and, under the title "An Abstract View of Objects and Subtyping (Preliminary Report)," as University of Edinburgh, </title> <type> LFCS technical report ECS-LFCS-92-226, </type> <year> 1992. </year>
Reference-contexts: Another goal of the Pict project was to explore the practical applicability of our earlier theoretical work on type systems for the -calculus [PS93, Tur96] and on -calculus type systems with subtyping <ref> [PT94, HP95, PS96] </ref>. In particular, in [PT94] we proposed a powerful combination of subtyping and polymorphism as a basis for statically typed object-oriented programming in functional languages; equipping Pict with a similar type system provides a testbed for experiments with statically typed concurrent objects. <p> The treatment of subtyping and higher-order polymorphism is based on recent work on static type systems for object-oriented languages <ref> [Car84, Bru94, CHC90, PT94, HP95, FM94, AC96, etc.] </ref> and the -calculus F ! [Car90, Mit90, PS96]. The rules for channel types are taken from Pierce and Sangiorgi's type system for the pure -calculus [PS93]. An early version of the Pict type system was presented in [PRT93]. <p> That is, List is a function from types to types. To avoid nonsensical applications like (List List) or (Int Int), we classify types and type operators according to their kinds, as in typed -calculi such as System F ! [Gir72, Bar92] and F ! <ref> [Car90, Mit90, HP95, PS96] </ref>. Thus, the type system recognizes three distinct levels of expressions: values, types, and kinds. The level of values contains familiar entities like 5, true, the tuple [5 true], and channels. <p> The rules for well-kinded types and well-formed contexts are familiar from the literature on higher-order typed -calculi (e.g. <ref> [HP95, PS96] </ref>), and we do not discuss them here. <p> of being compiled to native code.) 21 Can we design a practical type system for the -calculus combining subtyping and higher-order polymorphism? The Pict type system integrates a number of well-studied ideas: Milner's simple sorting discipline for channels [Mil91], polymorphic channels [Tur96], higher-order polymorphism [Gir72], input/output modalities [PS93], higher-order subtyping <ref> [Car90, Mit90, PT94, HP95, PS96] </ref>, and recursive types [MPS86, AC93]. However, the key to obtaining a workable type system for Pict was the development of a practical type inference algorithm.
Reference: [HT91] <author> Kohei Honda and Mario Tokoro. </author> <title> An object calculus for asynchronous communication. </title> <editor> In Pierre America, editor, </editor> <booktitle> Proceedings of the European Conference on Object-Oriented Programming (ECOOP), volume 512 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, Tokyo, </address> <year> 1991. </year>
Reference-contexts: The programmer must send an explicit acknowledgement or result to inform the client that its request has been processed, thereby eliminating any possible sensitivity to buffering or reordering of requests. The investigation of asynchronous process calculi was initiated by Honda, Tokoro, and Yoshida <ref> [HT91, HY94] </ref> and Boudol [Bou92].
Reference: [HY94] <author> Kohei Honda and Nobuko Yoshida. </author> <booktitle> Combinatory representation of mobile processes. In Principles of Programming Languages (POPL), </booktitle> <pages> pages 348-360, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: The programmer must send an explicit acknowledgement or result to inform the client that its request has been processed, thereby eliminating any possible sensitivity to buffering or reordering of requests. The investigation of asynchronous process calculi was initiated by Honda, Tokoro, and Yoshida <ref> [HT91, HY94] </ref> and Boudol [Bou92]. <p> An early version of the Pict type system was presented in [PRT93]. Typed process calculi with related goals have been proposed by Nierstrasz [Nie95] and Vasconce-los [Vas94]. Further refinements to the channel typing discipline incorporating notions of linear channel usage have been studied by Honda <ref> [Hon93, HY94, Hon96] </ref>, and more recently by Kobayashi and Yonezawa [KY94] and the present authors in collaboration with Kobayashi [KPT96]. 8 3.1 Channel Types Most type systems for process calculi and concurrent languages impose the constraint that each channel must be used throughout its lifetime to carry values of a single
Reference: [JGF96] <author> Simon Peyton Jones, Andrew Gordon, and Sigbjorn Finne. </author> <title> Concurrent Haskell. </title> <booktitle> In Conference Record of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'96), </booktitle> <pages> pages 295-308, </pages> <address> St. Petersburg, Florida, </address> <month> January 21-24, </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: Our choice of high-level language features leads to a programming style similar to that found in functional languages with channel-based concurrency such as PFL [Hol83], Amber [Car86], CML [Rep91, BMT92], Facile [GMP89], Poly/ML [Mat91], and Concurrent Haskell <ref> [JGF96] </ref>. The most significant difference lies in the type system: the impredicative polymorphism of Pict permits the encoding of polymorphic functions 20 using polymorphic communication. This pun is not possible in languages whose type systems are based on ML polymorphism, where channels cannot carry messages of varying types.
Reference: [Jon93] <author> Cliff B. Jones. </author> <title> A pi-calculus semantics for an object-based design notation. </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings of CONCUR'93, </booktitle> <volume> LNCS 715, </volume> <pages> pages 158-172. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In this section, we show how more convenient high-level constructs are built up from the core by means of source-to-source translations | following in the tradition of numerous papers showing how various high-level features can be encoded in the -calculus <ref> [San92, San94, San93, Mil90, Jon93, Wal95, Ama94, AP94, etc.] </ref>. We discuss only the more interesting translation rules; the complete list can be found in the Pict language definition [PT97]. 4.1 Simple Translations Large programs often contain long sequences of declarations like (new x 1 ... (new x n e)).
Reference: [Kob96] <author> Naoki Kobayashi. </author> <title> Concurrent Linear Logic Programming. </title> <type> PhD thesis, </type> <institution> Department of Information Science, University of Tokyo, </institution> <month> April </month> <year> 1996. </year>
Reference-contexts: Cardelli's Obliq [Car95] achieves related aims by building on a primitive notion of network objects. Pict belongs to a sizeable family of concurrent programming language designs inspired by theoretical calculi, including Vasconcelos's TyCo [Vas94], Kobayashi's HACL <ref> [Kob96] </ref>, and numerous actor languages [Hew77, Agh86, etc.]. A particularly close relative is the language Oz [Smo95], which integrates functional, object-oriented, and concurrent constraint programming by translation into a common core calculus [Smo94].
Reference: [KPT96] <author> Naoki Kobayashi, Benjamin C. Pierce, and David N. Turner. </author> <title> Linearity and the pi-calculus. </title> <booktitle> In Principles of Programming Languages, </booktitle> <year> 1996. </year>
Reference-contexts: Similar encodings can be used for data structures such as records. However, such encodings do not always give rise to useful derived typing rules. In particular, when we started the Pict design, there were no type systems for the pure, monadic -calculus (although more recent work on linear types <ref> [KPT96] </ref> may lead to such type systems). <p> Further refinements to the channel typing discipline incorporating notions of linear channel usage have been studied by Honda [Hon93, HY94, Hon96], and more recently by Kobayashi and Yonezawa [KY94] and the present authors in collaboration with Kobayashi <ref> [KPT96] </ref>. 8 3.1 Channel Types Most type systems for process calculi and concurrent languages impose the constraint that each channel must be used throughout its lifetime to carry values of a single type.
Reference: [KY94] <author> Naoki Kobayashi and Akinori Yonezawa. </author> <title> Type-theoretic foundations for concurrent object-oriented programming. </title> <booktitle> In Proceedings of ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA'94), </booktitle> <pages> pages 31-45, </pages> <year> 1994. </year>
Reference-contexts: Typed process calculi with related goals have been proposed by Nierstrasz [Nie95] and Vasconce-los [Vas94]. Further refinements to the channel typing discipline incorporating notions of linear channel usage have been studied by Honda [Hon93, HY94, Hon96], and more recently by Kobayashi and Yonezawa <ref> [KY94] </ref> and the present authors in collaboration with Kobayashi [KPT96]. 8 3.1 Channel Types Most type systems for process calculi and concurrent languages impose the constraint that each channel must be used throughout its lifetime to carry values of a single type.
Reference: [Ler95] <author> Xavier Leroy. </author> <title> Applicative functors and fully transparent higher-order modules. </title> <booktitle> In Proceedings of the Twenty-Second ACM Symposium on Principles of Programming Languages (POPL), Portland, Oregon, </booktitle> <pages> pages 142-153, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: For instance, we hope to extend Pict's treatment of existential types to account for type sharing (using techniques similar to those proposed by Leroy <ref> [Ler95] </ref> and Harper and Lillibridge [HL94]). Acknowledgements Robin Milner's past and present work on programming languages, concurrency, and the -calculus in particular is very strongly in the background of this project, and conversations with Robin have contributed many specific insights.
Reference: [Mat91] <author> David Matthews. </author> <title> A distributed concurrent implementation of Standard ML. </title> <type> Technical Report ECS-LFCS-91-174, </type> <institution> University of Edinburgh, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: Our choice of high-level language features leads to a programming style similar to that found in functional languages with channel-based concurrency such as PFL [Hol83], Amber [Car86], CML [Rep91, BMT92], Facile [GMP89], Poly/ML <ref> [Mat91] </ref>, and Concurrent Haskell [JGF96]. The most significant difference lies in the type system: the impredicative polymorphism of Pict permits the encoding of polymorphic functions 20 using polymorphic communication.
Reference: [Mil90] <author> Robin Milner. </author> <title> Functions as processes. </title> <type> Research Report 1154, </type> <institution> INRIA, Sofia Antipolis, </institution> <year> 1990. </year> <note> Final version in Journal of Mathematical Structures in Computer Science 2(2) 119-141, </note> <year> 1992. </year>
Reference-contexts: In this section, we show how more convenient high-level constructs are built up from the core by means of source-to-source translations | following in the tradition of numerous papers showing how various high-level features can be encoded in the -calculus <ref> [San92, San94, San93, Mil90, Jon93, Wal95, Ama94, AP94, etc.] </ref>. We discuss only the more interesting translation rules; the complete list can be found in the Pict language definition [PT97]. 4.1 Simple Translations Large programs often contain long sequences of declarations like (new x 1 ... (new x n e)).
Reference: [Mil91] <author> Robin Milner. </author> <title> The polyadic -calculus: a tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> Laboratory for Foundations of Computer Science, Department of Computer Science, University of Edinburgh, UK, </institution> <month> October </month> <year> 1991. </year> <booktitle> Appeared in Proceedings of the International Summer School on Logic and Algebra of Specification, Marktoberdorf, </booktitle> <month> August </month> <year> 1991. </year> <title> Reprinted in Logic and Algebra of Specification, </title> <editor> ed. F. L. Bauer, W. Brauer, and H. Schwichtenberg, </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <month> 24 </month>
Reference-contexts: 1 Introduction Milner, Parrow, and Walker's -calculus <ref> [MPW92, Mil91] </ref> generalizes the channel-based communication of CCS and its relatives by allowing channels to be passed as data along other channels. This extension introduces an element of mobility, enabling the specification and verification of concurrent systems with dynamically evolving communication topologies. <p> More details can be found in the original -calculus papers [MPW92] and in Milner's tutorial <ref> [Mil91] </ref>. The computational world modeled by the -calculus contains just two kinds of entities: processes and channels. Processes, sometimes called agents, are the active components of a system; they interact by synchronous rendezvous on channels, also called names or ports. <p> Adding such syntax does not change the fundamental character of the language at all, since all these types of data can easily be encoded as processes <ref> [Mil91] </ref>. To give the compiler maximum freedom to implement primitive values efficiently, the types Bool, Char, String, and Int are abstract: they reveal nothing about how values of these types are represented. Instead, built-in channels are provided for performing common operations. <p> This style of definition means that we need only give operational semantics and typing rules for the core language; the rules for functions arise from the translation. The pure -calculus can easily encode "polyadic" communication, in which several channels are exchanged during a single communication <ref> [Mil91] </ref>. Similar encodings can be used for data structures such as records. However, such encodings do not always give rise to useful derived typing rules. <p> More recent presentations, for example <ref> [Mil91] </ref>, use a more constrained operator called guarded choice, where e 1 and e 2 must be input expressions, output expressions, or choice expressions. <p> It is now time to make this understanding precise. Following <ref> [Mil91] </ref>, the operational semantics of Pict programs is presented in two steps. First, we define a structural congruence relation e 1 e 2 ; this relation captures the fact that, for example, the order of the branches in a parallel composition has no effect on its behavior. <p> lock channel l in the reference cell of Section 4.6 ensures that competing set and get requests are handled fairly; the replicated choice construct of [PT95] exhibits similar good behavior. 3 Type System The Pict type system has its roots in the theoretical literature on type systems for the -calculus <ref> [Mil91, Gay93, VH93, PS93, Tur96] </ref> and for functional languages, among which its most immediate predecessors are Quest [Car91] and Amber [Car86]. <p> of Pict's communication primitives. (Especially since the CML program had the advantage of being compiled to native code.) 21 Can we design a practical type system for the -calculus combining subtyping and higher-order polymorphism? The Pict type system integrates a number of well-studied ideas: Milner's simple sorting discipline for channels <ref> [Mil91] </ref>, polymorphic channels [Tur96], higher-order polymorphism [Gir72], input/output modalities [PS93], higher-order subtyping [Car90, Mit90, PT94, HP95, PS96], and recursive types [MPS86, AC93]. However, the key to obtaining a workable type system for Pict was the development of a practical type inference algorithm.
Reference: [Mit90] <author> John C. Mitchell. </author> <title> Toward a typed foundation for method specialization and inheritance. </title> <booktitle> In Proceedings of the 17th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-124, </pages> <month> January </month> <year> 1990. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: The treatment of subtyping and higher-order polymorphism is based on recent work on static type systems for object-oriented languages [Car84, Bru94, CHC90, PT94, HP95, FM94, AC96, etc.] and the -calculus F ! <ref> [Car90, Mit90, PS96] </ref>. The rules for channel types are taken from Pierce and Sangiorgi's type system for the pure -calculus [PS93]. An early version of the Pict type system was presented in [PRT93]. Typed process calculi with related goals have been proposed by Nierstrasz [Nie95] and Vasconce-los [Vas94]. <p> That is, List is a function from types to types. To avoid nonsensical applications like (List List) or (Int Int), we classify types and type operators according to their kinds, as in typed -calculi such as System F ! [Gir72, Bar92] and F ! <ref> [Car90, Mit90, HP95, PS96] </ref>. Thus, the type system recognizes three distinct levels of expressions: values, types, and kinds. The level of values contains familiar entities like 5, true, the tuple [5 true], and channels. <p> of being compiled to native code.) 21 Can we design a practical type system for the -calculus combining subtyping and higher-order polymorphism? The Pict type system integrates a number of well-studied ideas: Milner's simple sorting discipline for channels [Mil91], polymorphic channels [Tur96], higher-order polymorphism [Gir72], input/output modalities [PS93], higher-order subtyping <ref> [Car90, Mit90, PT94, HP95, PS96] </ref>, and recursive types [MPS86, AC93]. However, the key to obtaining a workable type system for Pict was the development of a practical type inference algorithm.
Reference: [MP88] <author> John Mitchell and Gordon Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3), </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: Readers familiar with typed -calculi will recognize the similarity of this rule to the standard introduction rule for existential types (e.g. <ref> [CW85, MP88] </ref>). The pattern typing rule P-Package in Section 3.12 plays the role of the standard elimination rule for existentials.
Reference: [MPS86] <author> David MacQueen, Gordon Plotkin, and Ravi Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> <volume> 71 </volume> <pages> 95-130, </pages> <year> 1986. </year>
Reference-contexts: Such recursive types have received considerable attention in the literature <ref> [MPS86, CC91, AC93, etc.] </ref>, and many different technical treatments have been proposed. <p> we design a practical type system for the -calculus combining subtyping and higher-order polymorphism? The Pict type system integrates a number of well-studied ideas: Milner's simple sorting discipline for channels [Mil91], polymorphic channels [Tur96], higher-order polymorphism [Gir72], input/output modalities [PS93], higher-order subtyping [Car90, Mit90, PT94, HP95, PS96], and recursive types <ref> [MPS86, AC93] </ref>. However, the key to obtaining a workable type system for Pict was the development of a practical type inference algorithm. Pict's partial type inference algorithm is surprisingly simple and easy to understand, but yet our experience has been that it gives very acceptable results.
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes (Parts I and II). </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Milner, Parrow, and Walker's -calculus <ref> [MPW92, Mil91] </ref> generalizes the channel-based communication of CCS and its relatives by allowing channels to be passed as data along other channels. This extension introduces an element of mobility, enabling the specification and verification of concurrent systems with dynamically evolving communication topologies. <p> More details can be found in the original -calculus papers <ref> [MPW92] </ref> and in Milner's tutorial [Mil91]. The computational world modeled by the -calculus contains just two kinds of entities: processes and channels. Processes, sometimes called agents, are the active components of a system; they interact by synchronous rendezvous on channels, also called names or ports.
Reference: [Nie95] <author> Oscar Nierstrasz. </author> <title> Regular types for active objects. </title> <editor> In O. Nierstrasz and D. Tsichritzis, editors, </editor> <booktitle> Object-Oriented Software Composition, </booktitle> <pages> pages 99-121. </pages> <publisher> Prentice Hall, </publisher> <year> 1995. </year> <note> Earlier version in proceedings of OOPSLA '93, published in ACM Sigplan Notices, 28(10), </note> <month> October </month> <year> 1993, </year> <pages> pp. 1-15. </pages>
Reference-contexts: The rules for channel types are taken from Pierce and Sangiorgi's type system for the pure -calculus [PS93]. An early version of the Pict type system was presented in [PRT93]. Typed process calculi with related goals have been proposed by Nierstrasz <ref> [Nie95] </ref> and Vasconce-los [Vas94].
Reference: [NP96] <author> Uwe Nestmann and Benjamin C. Pierce. </author> <title> Decoding choice encodings. </title> <booktitle> In Proceedings of CONCUR '96, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: In Pict we go a step further, dropping the choice operator altogether. This simplifies both formal semantics and implementation, and has little effect on the expressiveness of the language, since input-only choice is easy to implement as a library module <ref> [PT95, NP96] </ref>. (This has some cost in syntactic convenience, and some benefit in flexibility. Our library actually implements a subset of Reppy's events [Rep91], allowing the branches of a choice to be manipulated as data.) In fact, most Pict programs use simpler mechanisms such as locks and semaphores (cf.
Reference: [NSL96] <author> Oscar Nierstrasz, Jean-Guy Schneider, and Markus Lumpe. </author> <title> Formalizing composable software systems | a research agenda. In Formal Methods in Open, </title> <booktitle> Object-Based Distributed Systems (FMOODS '96), </booktitle> <month> February </month> <year> 1996. </year>
Reference-contexts: Pict's type system incorporates a number of powerful constructs, such as higher-order subtyping, especially for this purpose. Preliminary experiments with concurrent objects in Pict are described in [PT95]. Some more sophisticated proposals are described in <ref> [NSL96] </ref>. Can the -calculus be implemented efficiently? Pict's high-level language is defined by means of a translation into a -calculus core language.
Reference: [Pie96] <author> Benjamin C. Pierce. </author> <title> Programming in the pi-calculus: A tutorial introduction to Pict. </title> <note> Available electronically, </note> <year> 1996. </year>
Reference-contexts: The primary motivation of the Pict project, begun at the University of Edinburgh in 1992, was to design and implement a high-level concurrent language purely in terms of the -calculus primitives <ref> [PT97, Pie96] </ref>. Compiling a language based solely on communicating processes raises challenging code generation problems.
Reference: [PRT93] <author> Benjamin C. Pierce, Didier Remy, and David N. Turner. </author> <title> A typed higher-order programming language based on the pi-calculus. In Workshop on Type Theory and its Application to Computer Systems, </title> <publisher> Kyoto University, </publisher> <month> July </month> <year> 1993. </year>
Reference-contexts: The rules for channel types are taken from Pierce and Sangiorgi's type system for the pure -calculus [PS93]. An early version of the Pict type system was presented in <ref> [PRT93] </ref>. Typed process calculi with related goals have been proposed by Nierstrasz [Nie95] and Vasconce-los [Vas94]. <p> From Davide Sangiorgi, we learned about the higher-order -calculus and the many ways of encoding -calculi in the -calculus. Didier Remy helped build the original PIC compiler (on which the first version of the present Pict compiler was based <ref> [PRT93] </ref>) and joined in many discussions about the integration of processes and functions. Uwe Nestmann's research on proof techniques for compilations between concurrent calculi sharpened our ideas about the formal foundations of Pict. Martin Steffen helped study the formal foundations of the subtyping algorithm.
Reference: [PS93] <author> Benjamin Pierce and Davide Sangiorgi. </author> <title> Typing and subtyping for mobile processes. </title> <booktitle> In Logic in Computer Science, </booktitle> <year> 1993. </year> <note> Full version in Mathematical Structures in Computer Science, Vol. 6, No. 5, </note> <year> 1996. </year>
Reference-contexts: Another goal of the Pict project was to explore the practical applicability of our earlier theoretical work on type systems for the -calculus <ref> [PS93, Tur96] </ref> and on -calculus type systems with subtyping [PT94, HP95, PS96]. <p> lock channel l in the reference cell of Section 4.6 ensures that competing set and get requests are handled fairly; the replicated choice construct of [PT95] exhibits similar good behavior. 3 Type System The Pict type system has its roots in the theoretical literature on type systems for the -calculus <ref> [Mil91, Gay93, VH93, PS93, Tur96] </ref> and for functional languages, among which its most immediate predecessors are Quest [Car91] and Amber [Car86]. <p> The rules for channel types are taken from Pierce and Sangiorgi's type system for the pure -calculus <ref> [PS93] </ref>. An early version of the Pict type system was presented in [PRT93]. Typed process calculi with related goals have been proposed by Nierstrasz [Nie95] and Vasconce-los [Vas94]. <p> Note that the channel l is created with both read and write capabilities. The cons cell server uses l's read capability locally and gives the client the write capability. The types ^T, ?T, and !T fall naturally into a subtype relation <ref> [PS93] </ref>, since a channel of type ^T may always be used in a context where one of type ?T or !T is expected (for example, in an input or output expression). 3.4 Record Subtyping One objective of the Pict project was to explore the applicability of our earlier theoretical work on <p> The metatheoretic foundations needed to prove these two properties have already been established for the major components of the Pict type system | for channel types and subtyping by Pierce and Sangiorgi <ref> [PS93] </ref>, 16 for polymorphic channels by Turner [Tur96], for higher-order polymorphism with subtyping by Pierce and Steffen [PS96] and Compagnoni [Com94]. <p> had the advantage of being compiled to native code.) 21 Can we design a practical type system for the -calculus combining subtyping and higher-order polymorphism? The Pict type system integrates a number of well-studied ideas: Milner's simple sorting discipline for channels [Mil91], polymorphic channels [Tur96], higher-order polymorphism [Gir72], input/output modalities <ref> [PS93] </ref>, higher-order subtyping [Car90, Mit90, PT94, HP95, PS96], and recursive types [MPS86, AC93]. However, the key to obtaining a workable type system for Pict was the development of a practical type inference algorithm.
Reference: [PS96] <author> Benjamin Pierce and Martin Steffen. </author> <title> Higher-order subtyping. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1996. </year> <note> To appear. A preliminary version appeared in IFIP Working Conference on Programming Concepts, Methods and Calculi (PROCOMET), June 1994, and as University of Edinburgh technical report ECS-LFCS-94-280 and Universitat Erlangen-Nurnberg Interner Bericht IMMD7-01/94, </note> <month> January </month> <year> 1994. </year>
Reference-contexts: Another goal of the Pict project was to explore the practical applicability of our earlier theoretical work on type systems for the -calculus [PS93, Tur96] and on -calculus type systems with subtyping <ref> [PT94, HP95, PS96] </ref>. In particular, in [PT94] we proposed a powerful combination of subtyping and polymorphism as a basis for statically typed object-oriented programming in functional languages; equipping Pict with a similar type system provides a testbed for experiments with statically typed concurrent objects. <p> The treatment of subtyping and higher-order polymorphism is based on recent work on static type systems for object-oriented languages [Car84, Bru94, CHC90, PT94, HP95, FM94, AC96, etc.] and the -calculus F ! <ref> [Car90, Mit90, PS96] </ref>. The rules for channel types are taken from Pierce and Sangiorgi's type system for the pure -calculus [PS93]. An early version of the Pict type system was presented in [PRT93]. Typed process calculi with related goals have been proposed by Nierstrasz [Nie95] and Vasconce-los [Vas94]. <p> That is, List is a function from types to types. To avoid nonsensical applications like (List List) or (Int Int), we classify types and type operators according to their kinds, as in typed -calculi such as System F ! [Gir72, Bar92] and F ! <ref> [Car90, Mit90, HP95, PS96] </ref>. Thus, the type system recognizes three distinct levels of expressions: values, types, and kinds. The level of values contains familiar entities like 5, true, the tuple [5 true], and channels. <p> The rules for well-kinded types and well-formed contexts are familiar from the literature on higher-order typed -calculi (e.g. <ref> [HP95, PS96] </ref>), and we do not discuss them here. <p> Int]: S = fiT T (S-Conv) ` S 2 K ` U 2 K ` T 2 K ` S &lt; U ` U &lt; T (S-Trans) Formally, the conversion relation = fiT contains both ordinary fi-conversion (("X:K=T) S = fiT fX 7! SgT) and a rule of "top-conversion" (cf. <ref> [PS96] </ref>) that makes Top at operator kinds behave like a type operator (Top:(K 1 -&gt;K 2 ) S = fiT Top:K 2 ). <p> The metatheoretic foundations needed to prove these two properties have already been established for the major components of the Pict type system | for channel types and subtyping by Pierce and Sangiorgi [PS93], 16 for polymorphic channels by Turner [Tur96], for higher-order polymorphism with subtyping by Pierce and Steffen <ref> [PS96] </ref> and Compagnoni [Com94]. However, the above properties remain conjectures, since we have not checked the type system as a whole. 4 Derived Forms The statically-typed core language of Pict is a powerful, safe, and unacceptably verbose programming notation. <p> of being compiled to native code.) 21 Can we design a practical type system for the -calculus combining subtyping and higher-order polymorphism? The Pict type system integrates a number of well-studied ideas: Milner's simple sorting discipline for channels [Mil91], polymorphic channels [Tur96], higher-order polymorphism [Gir72], input/output modalities [PS93], higher-order subtyping <ref> [Car90, Mit90, PT94, HP95, PS96] </ref>, and recursive types [MPS86, AC93]. However, the key to obtaining a workable type system for Pict was the development of a practical type inference algorithm.
Reference: [PT94] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> April </month> <year> 1994. </year> <note> A preliminary version appeared in Principles of Programming Languages, </note> <year> 1993, </year> <title> and as University of Edinburgh technical report ECS-LFCS-92-225, under the title "Object-Oriented Programming Without Recursive Types". </title>
Reference-contexts: Another goal of the Pict project was to explore the practical applicability of our earlier theoretical work on type systems for the -calculus [PS93, Tur96] and on -calculus type systems with subtyping <ref> [PT94, HP95, PS96] </ref>. In particular, in [PT94] we proposed a powerful combination of subtyping and polymorphism as a basis for statically typed object-oriented programming in functional languages; equipping Pict with a similar type system provides a testbed for experiments with statically typed concurrent objects. <p> Another goal of the Pict project was to explore the practical applicability of our earlier theoretical work on type systems for the -calculus [PS93, Tur96] and on -calculus type systems with subtyping [PT94, HP95, PS96]. In particular, in <ref> [PT94] </ref> we proposed a powerful combination of subtyping and polymorphism as a basis for statically typed object-oriented programming in functional languages; equipping Pict with a similar type system provides a testbed for experiments with statically typed concurrent objects. <p> The treatment of subtyping and higher-order polymorphism is based on recent work on static type systems for object-oriented languages <ref> [Car84, Bru94, CHC90, PT94, HP95, FM94, AC96, etc.] </ref> and the -calculus F ! [Car90, Mit90, PS96]. The rules for channel types are taken from Pierce and Sangiorgi's type system for the pure -calculus [PS93]. An early version of the Pict type system was presented in [PRT93]. <p> In <ref> [PT94] </ref>, we proposed a powerful combination of subtyping and polymorphism as a basis for statically-typed object-oriented programming in functional languages; equipping Pict with a similar type system makes it a useful testbed for experiments with statically typed concurrent objects. <p> of being compiled to native code.) 21 Can we design a practical type system for the -calculus combining subtyping and higher-order polymorphism? The Pict type system integrates a number of well-studied ideas: Milner's simple sorting discipline for channels [Mil91], polymorphic channels [Tur96], higher-order polymorphism [Gir72], input/output modalities [PS93], higher-order subtyping <ref> [Car90, Mit90, PT94, HP95, PS96] </ref>, and recursive types [MPS86, AC93]. However, the key to obtaining a workable type system for Pict was the development of a practical type inference algorithm.
Reference: [PT95] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Concurrent objects in a process calculus. </title> <editor> In Takayasu Ito and Akinori Yonezawa, editors, </editor> <booktitle> Theory and Practice of Parallel Programming (TPPP), Sendai, </booktitle> <address> Japan (Nov. </address> <year> 1994), </year> <booktitle> number 907 in Lecture Notes in Computer Science, </booktitle> <pages> pages 187-215. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1995. </year>
Reference-contexts: arise in this setting? (3) Can the -calculus be implemented efficiently? (4) Can we design a practical type system for the -calculus combining subtyping and higher-order polymorphism? In this paper, we offer our responses to these questions (concentrating on (1) and (4), since (2) has been addressed in detail in <ref> [PT95] </ref> and (3) in [Tur96]), and survey the current state of the Pict language. Section 2 defines the syntax and operational semantics of the core language and discusses some points where it differs from the theoretical -calculus of Milner, Parrow, and Walker. <p> In Pict we go a step further, dropping the choice operator altogether. This simplifies both formal semantics and implementation, and has little effect on the expressiveness of the language, since input-only choice is easy to implement as a library module <ref> [PT95, NP96] </ref>. (This has some cost in syntactic convenience, and some benefit in flexibility. Our library actually implements a subset of Reppy's events [Rep91], allowing the branches of a choice to be manipulated as data.) In fact, most Pict programs use simpler mechanisms such as locks and semaphores (cf. <p> Section 4.6) for basic synchronisation tasks. For controlling concurrent execution of methods in objects, one can use a different library implementing a more specialized operator called replicated choice <ref> [PT95] </ref>. 2.3.4 Replicated Input, No Matching The Pict core language makes two further simplifications of the pure -calculus. First, we restrict replication to replicated input expressions. This variant has the same formal power as full replication, but has a simpler semantics and is closer to a realistic implementation. <p> Our experience of writing applications in Pict has been that this execution strategy works well. For example, the FIFO queueing of the lock channel l in the reference cell of Section 4.6 ensures that competing set and get requests are handled fairly; the replicated choice construct of <ref> [PT95] </ref> exhibits similar good behavior. 3 Type System The Pict type system has its roots in the theoretical literature on type systems for the -calculus [Mil91, Gay93, VH93, PS93, Tur96] and for functional languages, among which its most immediate predecessors are Quest [Car91] and Amber [Car86]. <p> Pict's type system incorporates a number of powerful constructs, such as higher-order subtyping, especially for this purpose. Preliminary experiments with concurrent objects in Pict are described in <ref> [PT95] </ref>. Some more sophisticated proposals are described in [NSL96]. Can the -calculus be implemented efficiently? Pict's high-level language is defined by means of a translation into a -calculus core language.
Reference: [PT97] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Pict language definition. Draft report; available electronically as part of the Pict distribution, </title> <year> 1997. </year>
Reference-contexts: The primary motivation of the Pict project, begun at the University of Edinburgh in 1992, was to design and implement a high-level concurrent language purely in terms of the -calculus primitives <ref> [PT97, Pie96] </ref>. Compiling a language based solely on communicating processes raises challenging code generation problems. <p> Instead, we give an overview of the main decisions we have made in the design of Pict. For a complete description of the current version of Pict, please consult the formal definition <ref> [PT97] </ref>, which is kept up to date with the current version of the compiler. 2 The Core Language We now proceed to a rigorous definition of the syntax and semantics of the core language: an asynchronous, choice-free fragment of the -calculus enriched with records and pattern matching. 2.1 The Pi-Calculus To <p> Further details, such as lexical analysis rules, can be found in the Pict language definition <ref> [PT97] </ref>. The possible forms of each production are listed on successive lines. Keywords are set in typewriter font. An expression of the form X : : : X denotes a list of zero or more occurrences of X. The expression hemptyi denotes an empty production. <p> See the Pict definition <ref> [PT97] </ref> for a formal description of type inference. 3.8 Notation The syntax of type expressions is as follows: Type = ^ Type Input/output channel ! Type Output-only channel ? Type Input-only channel Id &lt; Type Type Package type [ Label Type ... <p> The rest of this section presents a selection of the rules which define the remaining forms of typing statements. (A full description of the typing and kinding rules can be found in the Pict language definition <ref> [PT97] </ref>.) 12 3.9 Subtyping The subtype relation consists of two structural rules plus one or more rules for each type constructor or constant. <p> We discuss only the more interesting translation rules; the complete list can be found in the Pict language definition <ref> [PT97] </ref>. 4.1 Simple Translations Large programs often contain long sequences of declarations like (new x 1 ... (new x n e)). To avoid proliferation of parentheses, we introduce the more compact syntactic form (new x 1 ... new x n e) in the high-level language.
Reference: [Rep91] <author> John Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In Programming Language Design and Implementation, </booktitle> <pages> pages 293-259. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: Our library actually implements a subset of Reppy's events <ref> [Rep91] </ref>, allowing the branches of a choice to be manipulated as data.) In fact, most Pict programs use simpler mechanisms such as locks and semaphores (cf. Section 4.6) for basic synchronisation tasks. <p> Although this calculus uses concurrent constraints as its basic communication mechanism, the encoding of high-level features is strongly reminiscent of Pict. Our choice of high-level language features leads to a programming style similar to that found in functional languages with channel-based concurrency such as PFL [Hol83], Amber [Car86], CML <ref> [Rep91, BMT92] </ref>, Facile [GMP89], Poly/ML [Mat91], and Concurrent Haskell [JGF96]. The most significant difference lies in the type system: the impredicative polymorphism of Pict permits the encoding of polymorphic functions 20 using polymorphic communication.
Reference: [Rey74] <author> John Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proc. Colloque sur la Programmation, </booktitle> <pages> pages 408-425, </pages> <address> New York, 1974. </address> <publisher> Springer-Verlag LNCS 19. </publisher>
Reference-contexts: values, since the position of a field in a record can be determined from its type at compile time (this is especially useful when separately compiling Pict programs). 3.5 Polymorphism Our type system may readily be extended to include polymorphism, just as simply typed -calculus can be extended with polymorphism <ref> [Gir72, Rey74] </ref>. We support polymorphic communications by adding two new syntactic forms: package values -T-v and package patterns -X-p. For example, if c is a channel of type ^Int, the output expression z!-Int-[5 c] sends along the channel z the type Int and the pair of values 5 and c.
Reference: [San92] <author> Davide Sangiorgi. </author> <title> Expressing Mobility in Process Algebras: First-Order and Higher-Order Paradigms. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1992. </year>
Reference-contexts: In this section, we show how more convenient high-level constructs are built up from the core by means of source-to-source translations | following in the tradition of numerous papers showing how various high-level features can be encoded in the -calculus <ref> [San92, San94, San93, Mil90, Jon93, Wal95, Ama94, AP94, etc.] </ref>. We discuss only the more interesting translation rules; the complete list can be found in the Pict language definition [PT97]. 4.1 Simple Translations Large programs often contain long sequences of declarations like (new x 1 ... (new x n e)).
Reference: [San93] <author> Davide Sangiorgi. </author> <title> An investigation into functions as processes. </title> <booktitle> In Proc. Ninth International Conference on the Mathematical Foundations of Programming Semantics (MFPS'93), volume 802 of Lecture Notes in Computer Science, </booktitle> <pages> pages 143-159. </pages> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In this section, we show how more convenient high-level constructs are built up from the core by means of source-to-source translations | following in the tradition of numerous papers showing how various high-level features can be encoded in the -calculus <ref> [San92, San94, San93, Mil90, Jon93, Wal95, Ama94, AP94, etc.] </ref>. We discuss only the more interesting translation rules; the complete list can be found in the Pict language definition [PT97]. 4.1 Simple Translations Large programs often contain long sequences of declarations like (new x 1 ... (new x n e)).
Reference: [San94] <author> Davide Sangiorgi. </author> <title> The lazy lambda calculus in a concurrency scenario. </title> <journal> Information and Computation, </journal> <volume> 111(1) </volume> <pages> 120-153, </pages> <year> 1994. </year>
Reference-contexts: In this section, we show how more convenient high-level constructs are built up from the core by means of source-to-source translations | following in the tradition of numerous papers showing how various high-level features can be encoded in the -calculus <ref> [San92, San94, San93, Mil90, Jon93, Wal95, Ama94, AP94, etc.] </ref>. We discuss only the more interesting translation rules; the complete list can be found in the Pict language definition [PT97]. 4.1 Simple Translations Large programs often contain long sequences of declarations like (new x 1 ... (new x n e)).
Reference: [Sew96] <author> Peter Sewell. </author> <title> Observations on Pict, a nondeterministic programming language. </title> <type> Manuscript, </type> <year> 1996. </year>
Reference-contexts: Work is underway on a more refined semantic framework explicitly incorporating interactions with the environment <ref> [Sew96] </ref>. 2.9 Fairness Even on closed programs, the reduction semantics of the previous section leaves one important issue unaddressed: it characterizes the set of possible behaviors of a process expression, but makes no commitment as to which of these behaviors will actually be observed when the expression is compiled and executed.
Reference: [Smo94] <author> Gert Smolka. </author> <title> A Foundation for Concurrent Constraint Programming. In Constraints in Computational Logics, </title> <booktitle> volume 845 of Lecture Notes in Computer Science, </booktitle> <address> Munich, Germany, </address> <month> September </month> <year> 1994. </year> <type> Invited Talk. 25 </type>
Reference-contexts: A particularly close relative is the language Oz [Smo95], which integrates functional, object-oriented, and concurrent constraint programming by translation into a common core calculus <ref> [Smo94] </ref>. Although this calculus uses concurrent constraints as its basic communication mechanism, the encoding of high-level features is strongly reminiscent of Pict.
Reference: [Smo95] <author> Gert Smolka. </author> <title> The Oz programming model. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Computer Science Today, Lecture Notes in Computer Science, </booktitle> <volume> vol. 1000, </volume> <pages> pages 324-343. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference-contexts: Pict belongs to a sizeable family of concurrent programming language designs inspired by theoretical calculi, including Vasconcelos's TyCo [Vas94], Kobayashi's HACL [Kob96], and numerous actor languages [Hew77, Agh86, etc.]. A particularly close relative is the language Oz <ref> [Smo95] </ref>, which integrates functional, object-oriented, and concurrent constraint programming by translation into a common core calculus [Smo94]. Although this calculus uses concurrent constraints as its basic communication mechanism, the encoding of high-level features is strongly reminiscent of Pict.
Reference: [TAL90] <author> David Tarditi, Anurag Acharya, and Peter Lee. </author> <title> No assembly required: Compiling Standard ML to C. </title> <type> Technical Report CMU-CS-90-187, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: We compile to C for portability and easy inter-operability with existing program libraries, though this does have a significant cost in efficiency for the compiled code (Tarditi, Archarya, and Lee <ref> [TAL90] </ref> report that when they modified the New Jersey SML compiler so that it generated C code, it produced code which ran approximately twice as slow as code produced by the native code generator).
Reference: [Tur96] <author> David N. Turner. </author> <title> The Polymorphic Pi-calulus: Theory and Implementation. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1996. </year>
Reference-contexts: Another goal of the Pict project was to explore the practical applicability of our earlier theoretical work on type systems for the -calculus <ref> [PS93, Tur96] </ref> and on -calculus type systems with subtyping [PT94, HP95, PS96]. <p> (3) Can the -calculus be implemented efficiently? (4) Can we design a practical type system for the -calculus combining subtyping and higher-order polymorphism? In this paper, we offer our responses to these questions (concentrating on (1) and (4), since (2) has been addressed in detail in [PT95] and (3) in <ref> [Tur96] </ref>), and survey the current state of the Pict language. Section 2 defines the syntax and operational semantics of the core language and discusses some points where it differs from the theoretical -calculus of Milner, Parrow, and Walker. <p> lock channel l in the reference cell of Section 4.6 ensures that competing set and get requests are handled fairly; the replicated choice construct of [PT95] exhibits similar good behavior. 3 Type System The Pict type system has its roots in the theoretical literature on type systems for the -calculus <ref> [Mil91, Gay93, VH93, PS93, Tur96] </ref> and for functional languages, among which its most immediate predecessors are Quest [Car91] and Amber [Car86]. <p> The metatheoretic foundations needed to prove these two properties have already been established for the major components of the Pict type system | for channel types and subtyping by Pierce and Sangiorgi [PS93], 16 for polymorphic channels by Turner <ref> [Tur96] </ref>, for higher-order polymorphism with subtyping by Pierce and Steffen [PS96] and Compagnoni [Com94]. However, the above properties remain conjectures, since we have not checked the type system as a whole. 4 Derived Forms The statically-typed core language of Pict is a powerful, safe, and unacceptably verbose programming notation. <p> Very simple comparisons of the code produced by Pict and New Jersey SML <ref> [Tur96] </ref> indicate that functional code compiled by Pict runs approximately six times slower than that produced by New Jersey SML. <p> To give an idea of how fast our channel-based communication primitives are, we compared the performance of the Pict nqueens program with an equivalent CML program which uses CML's channel primitives to implement the result channels used in Pict <ref> [Tur96] </ref>. The CML program ran almost four times slower than Pict. This is not to say that CML programs in general run four times slower than Pict, since CML programs typically consist of large amounts of SML code, which runs faster than Pict. <p> primitives. (Especially since the CML program had the advantage of being compiled to native code.) 21 Can we design a practical type system for the -calculus combining subtyping and higher-order polymorphism? The Pict type system integrates a number of well-studied ideas: Milner's simple sorting discipline for channels [Mil91], polymorphic channels <ref> [Tur96] </ref>, higher-order polymorphism [Gir72], input/output modalities [PS93], higher-order subtyping [Car90, Mit90, PT94, HP95, PS96], and recursive types [MPS86, AC93]. However, the key to obtaining a workable type system for Pict was the development of a practical type inference algorithm.
Reference: [Vas94] <author> Vasco T. Vasconcelos. </author> <title> Typed concurrent objects. </title> <booktitle> In Proceedings of the Eighth European Conference on Object-Oriented Programming (ECOOP), volume 821 of Lecture Notes in Computer Science, </booktitle> <pages> pages 100-117. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1994. </year>
Reference-contexts: The rules for channel types are taken from Pierce and Sangiorgi's type system for the pure -calculus [PS93]. An early version of the Pict type system was presented in [PRT93]. Typed process calculi with related goals have been proposed by Nierstrasz [Nie95] and Vasconce-los <ref> [Vas94] </ref>. <p> Cardelli's Obliq [Car95] achieves related aims by building on a primitive notion of network objects. Pict belongs to a sizeable family of concurrent programming language designs inspired by theoretical calculi, including Vasconcelos's TyCo <ref> [Vas94] </ref>, Kobayashi's HACL [Kob96], and numerous actor languages [Hew77, Agh86, etc.]. A particularly close relative is the language Oz [Smo95], which integrates functional, object-oriented, and concurrent constraint programming by translation into a common core calculus [Smo94].
Reference: [VH93] <author> Vasco T. Vasconcelos and Kohei Honda. </author> <title> Principal typing schemes in a polyadic pi-calculus. </title> <booktitle> In Proceedings of CONCUR '93, </booktitle> <month> July </month> <year> 1993. </year> <note> Also available as Keio University Report CS-92-004. </note>
Reference-contexts: lock channel l in the reference cell of Section 4.6 ensures that competing set and get requests are handled fairly; the replicated choice construct of [PT95] exhibits similar good behavior. 3 Type System The Pict type system has its roots in the theoretical literature on type systems for the -calculus <ref> [Mil91, Gay93, VH93, PS93, Tur96] </ref> and for functional languages, among which its most immediate predecessors are Quest [Car91] and Amber [Car86].
Reference: [Wal95] <author> David Walker. </author> <title> Objects in the -calculus. </title> <journal> Information and Computation, </journal> <volume> 116 </volume> <pages> 253-271, </pages> <year> 1995. </year> <month> 26 </month>
Reference-contexts: In this section, we show how more convenient high-level constructs are built up from the core by means of source-to-source translations | following in the tradition of numerous papers showing how various high-level features can be encoded in the -calculus <ref> [San92, San94, San93, Mil90, Jon93, Wal95, Ama94, AP94, etc.] </ref>. We discuss only the more interesting translation rules; the complete list can be found in the Pict language definition [PT97]. 4.1 Simple Translations Large programs often contain long sequences of declarations like (new x 1 ... (new x n e)).
References-found: 71

