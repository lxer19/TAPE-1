URL: ftp://ftp.cs.uchicago.edu/pub/publications/tech-reports/TR-90-22.ps
Refering-URL: http://cs-www.uchicago.edu/publications/tech-reports/
Root-URL: 
Title: ON THE RANDOM-SELF-REDUCIBILITY OF COMPLETE SETS  
Author: JOAN FEIGENBAUM AND LANCE FORTNOW 
Keyword: Key words. random-self-reductions, complexity classes, interactive proof systems, program checkers  
Note: AMS(MOS) subject classifications. 68Q05, 68Q15  
Abstract: In this paper, we generalize the previous formal definitions of random-self-reducibi-lity. We show that, even under our very general definition, sets that are complete for any level of the polynomial hierarchy are not nonadaptively random-self-reducible, unless the hierarchy collapses. In particular, NP-complete sets are not nonadaptively random-self-reducible, unless the hierarchy collapses at the third level. By contrast, we show that sets complete for the classes PP and MOD m P are random-self-reducible. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, J. Feigenbaum, and J. Kilian, </author> <title> On hiding information from an oracle, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 39 (1989), </volume> <pages> pp. 21-50. </pages>
Reference-contexts: Random-self-reductions also provide natural examples of instance-hiding schemes (cf. <ref> [1, 7, 8] </ref>), in which a weak, private computing device uses the resources of a powerful, shared computing device without revealing its private data. <p> Although random-self-reducibility had been used for a long time in the design and analysis of cryptographic protocols (cf., e.g., [17, 13]), it was first defined formally and studied from a complexity theoretic point of view by Abadi, Feigenbaum, and Kilian <ref> [1] </ref>; they considered reductions that map the given instance x to one random instance y. It is a corollary of the main result in [1] that no NP-hard function is random-self-reducible in this sense, unless the polynomial-time hierarchy collapses at the third level. <p> of cryptographic protocols (cf., e.g., [17, 13]), it was first defined formally and studied from a complexity theoretic point of view by Abadi, Feigenbaum, and Kilian <ref> [1] </ref>; they considered reductions that map the given instance x to one random instance y. It is a corollary of the main result in [1] that no NP-hard function is random-self-reducible in this sense, unless the polynomial-time hierarchy collapses at the third level. <p> The related idea of mapping an instance x in the domain of f to one or more random instances y 1 , : : :, y k in the domain of a different function g is studied in <ref> [1, 7, 8] </ref>. For the case of one random y, a negative result for NP-hard functions is obtained in [1]. If multiple random y i 's are allowed, then every function f can be locally randomly reduced to a related function g; see [7, 8] for a thorough discussion. <p> For the case of one random y, a negative result for NP-hard functions is obtained in <ref> [1] </ref>. If multiple random y i 's are allowed, then every function f can be locally randomly reduced to a related function g; see [7, 8] for a thorough discussion. In this paper, we continue the study of random-self-reductions from a complexity-theoretic point of view. <p> The view of any set of at most t of the oracles (i.e., the transcript of queries and answers together with the coin flips of the oracles) depends only on the length of the input instance. One-oracle ihs's were studied by Abadi, Feigenbaum, and Kilian <ref> [1] </ref>, who showed that NP-hard functions do not have one-oracle ihs's unless the polynomial-time hierarchy collapses at the third level. The question of whether multioracle ihs's exist was posed by Rivest [1] and answered by Beaver and Feigenbaum [7]: Every function f has a 1-private, (n + 1)-oracle ihs. <p> One-oracle ihs's were studied by Abadi, Feigenbaum, and Kilian <ref> [1] </ref>, who showed that NP-hard functions do not have one-oracle ihs's unless the polynomial-time hierarchy collapses at the third level. The question of whether multioracle ihs's exist was posed by Rivest [1] and answered by Beaver and Feigenbaum [7]: Every function f has a 1-private, (n + 1)-oracle ihs. <p> The gist of Definitions 2.1 and 2.2 is that, for any fixed value of i, the distribution of random queries to the i th oracle depends only on the length n of the input x. In keeping with the terminology in <ref> [1, 7] </ref>, we say that an rsr "leaks at most n to each oracle." In cryptographic applications, it is often natural to consider reductions that leak at most some other function L; Definitions 2.1 and 2.2 have natural generalizations that fit these applications see [1, 7] for details. <p> In keeping with the terminology in <ref> [1, 7] </ref>, we say that an rsr "leaks at most n to each oracle." In cryptographic applications, it is often natural to consider reductions that leak at most some other function L; Definitions 2.1 and 2.2 have natural generalizations that fit these applications see [1, 7] for details. In several proofs, we will use the following Chernoff bounds on the binomial distribution, which are taken directly from [25, Lecture 4, p. 29]. Fact 2.3.
Reference: [2] <author> L. Adleman and H. Lenstra, </author> <title> Finding irreducible polynomials over finite fields, </title> <booktitle> in Proceedings of the 16th ACM Symposium on the Theory of Computing, ACM, </booktitle> <address> New York, </address> <year> 1986, </year> <pages> pp. 350-355. </pages>
Reference-contexts: Such a polynomial could be generated in deterministic polynomial time <ref> [2] </ref>, but this is not necessary for our purpose, which is to use the polynomial in a reduction that is inherently probabilistic.) We can represent each element a of GF (m k ) as the k fi k matrix M a denoting the linear transformation x 7! ax of GF (m
Reference: [3] <author> L. Babai, </author> <title> Random oracles separate PSPACE from the polynomial-time hierarchy, </title> <journal> Information Processing Letters, </journal> <volume> 26 (1987), </volume> <pages> pp. 51-53. </pages>
Reference-contexts: Furthermore, the random-self-reduction for PERM is very simple, whereas standard average-case hardness proofs are often complicated. Lower bounds: The random-self-reducibility of the parity function is used in <ref> [3] </ref> to obtain a simple proof that a random oracle separates the polynomial hierarchy (PH) from PSPACE. (An earlier proof of this result in [14] does not use random-self-reducibility.) Interactive proof systems and program checkers: Random-self-reductions are crucial ingredients in many of the original examples of interactive proof systems and fl
Reference: [4] <author> L. Babai and L. Fortnow, Arithmetization: </author> <title> A new method in structural complexity theory, Computational Complexity, </title> <booktitle> 1 (1991), </booktitle> <pages> pp. 41-66. </pages>
Reference-contexts: We use the following class of straight-line programs of multivariate polynomials over Z to prove that sets complete for MOD m P are rsr. Definition 2.14. (cf. <ref> [4] </ref>): A positive retarded arithmetic program with binary substitutions (PRAB) is a sequence P = fp 1 ; : : : ; p s g of instructions such that, for every k, one of the following holds. (1) p k is one of the constant polynomials 0 or 1. (2) p <p> Here p j (x i = *) refers to the polynomial obtained from p j by replacing the variable x i by the value *. We say that the program P computes the polynomial p s . Definition 2.15. (cf. <ref> [4] </ref>): A sequence P 1 , P 2 , : : : of PRAB's is uniform if there is a deterministic polynomial-time machine that, on input 1 n , outputs the instruction sequence P n . 6 Fact 2.16. (cf. [4]): A set S is in MOD m P if and <p> Definition 2.15. (cf. <ref> [4] </ref>): A sequence P 1 , P 2 , : : : of PRAB's is uniform if there is a deterministic polynomial-time machine that, on input 1 n , outputs the instruction sequence P n . 6 Fact 2.16. (cf. [4]): A set S is in MOD m P if and only if there is a uniform sequence fP n g n1 of PRAB's such that, for every x 2 f0; 1g fl , S (x) P jxj (x) mod m: We use AM (k) to denote the class of sets <p> We deal with this problem as it is dealt with in the proof that MOD m P-complete sets are checkable (cf. <ref> [4] </ref>). For every positive integer k, there is a unique finite field GF (m k ), and it is a vector space over Z m . Fix a basis for this vector space.
Reference: [5] <author> L. Babai, L. Fortnow, and C. Lund, </author> <title> Non-deterministic exponential time has two-prover interactive protocols, Computational Complexity, </title> <booktitle> 1 (1991), </booktitle> <pages> pp. 3-40. </pages>
Reference-contexts: Several variations of this relationship between random-self-reducibility and proof systems/checkers are stated formally in [12, 21, 27]. These ideas play a crucial role in the characterization of the language-recognition power of interactive proof systems (cf. <ref> [5, 21, 24] </ref>). Currently, one of the most important open questions about checkability is whether NP-complete sets are checkable. The main result that we present in Section 3 implies that, if NP-complete sets are checkable, their checkers must use radically different techniques from those used by the existing checkers.
Reference: [6] <author> L. Babai and S. Moran, </author> <title> Arthur-Merlin games: a randomized proof system, and a hierarchy of complexity classes, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 36 (1988), </volume> <pages> pp. 254-276. </pages>
Reference-contexts: m P if and only if there is a uniform sequence fP n g n1 of PRAB's such that, for every x 2 f0; 1g fl , S (x) P jxj (x) mod m: We use AM (k) to denote the class of sets accepted by k-move Arthur-Merlin games (cf. <ref> [6] </ref>). Let AM (k)=poly be the class of sets accepted by k-move Arthur-Merlin games in which Arthur is given polynomial-length advice in addition to probabilistic polynomial time. We use AM (resp. AM=poly) synonymously with AM (2) (resp. AM (2)=poly). <p> Let AM (k)=poly be the class of sets accepted by k-move Arthur-Merlin games in which Arthur is given polynomial-length advice in addition to probabilistic polynomial time. We use AM (resp. AM=poly) synonymously with AM (2) (resp. AM (2)=poly). Fact 2.17. (cf. <ref> [6, 19] </ref>): For any constant k, AM (k)=poly = NP=poly. Finally we use the following known relationship between levels of the polynomial-time hierarchy and the corresponding nonuniform classes. Fact 2.18. (cf. [29]): If P i P i =poly, then the polynomial-time hierarchy collapses to P i+2 .
Reference: [7] <author> D. Beaver and J. Feigenbaum, </author> <title> Hiding instances in multioracle queries, </title> <booktitle> in Proceedings of the 7th Symposium on Theoretical Aspects of Computer Science, vol. 415 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1990, </year> <pages> pp. 37-48. </pages>
Reference-contexts: Random-self-reductions also provide natural examples of instance-hiding schemes (cf. <ref> [1, 7, 8] </ref>), in which a weak, private computing device uses the resources of a powerful, shared computing device without revealing its private data. <p> The related idea of mapping an instance x in the domain of f to one or more random instances y 1 , : : :, y k in the domain of a different function g is studied in <ref> [1, 7, 8] </ref>. For the case of one random y, a negative result for NP-hard functions is obtained in [1]. If multiple random y i 's are allowed, then every function f can be locally randomly reduced to a related function g; see [7, 8] for a thorough discussion. <p> For the case of one random y, a negative result for NP-hard functions is obtained in [1]. If multiple random y i 's are allowed, then every function f can be locally randomly reduced to a related function g; see <ref> [7, 8] </ref> for a thorough discussion. In this paper, we continue the study of random-self-reductions from a complexity-theoretic point of view. We further generalize the formal definition of random-self-reducibility that is studied in [15]. <p> One-oracle ihs's were studied by Abadi, Feigenbaum, and Kilian [1], who showed that NP-hard functions do not have one-oracle ihs's unless the polynomial-time hierarchy collapses at the third level. The question of whether multioracle ihs's exist was posed by Rivest [1] and answered by Beaver and Feigenbaum <ref> [7] </ref>: Every function f has a 1-private, (n + 1)-oracle ihs. In fact, the general ihs construction of [7] uses only one round of queries and does not require the oracles to flip coins; so, in current terminology, it is a (1; n + 1)-lrr. <p> The question of whether multioracle ihs's exist was posed by Rivest [1] and answered by Beaver and Feigenbaum <ref> [7] </ref>: Every function f has a 1-private, (n + 1)-oracle ihs. In fact, the general ihs construction of [7] uses only one round of queries and does not require the oracles to flip coins; so, in current terminology, it is a (1; n + 1)-lrr. <p> The gist of Definitions 2.1 and 2.2 is that, for any fixed value of i, the distribution of random queries to the i th oracle depends only on the length n of the input x. In keeping with the terminology in <ref> [1, 7] </ref>, we say that an rsr "leaks at most n to each oracle." In cryptographic applications, it is often natural to consider reductions that leak at most some other function L; Definitions 2.1 and 2.2 have natural generalizations that fit these applications see [1, 7] for details. <p> In keeping with the terminology in <ref> [1, 7] </ref>, we say that an rsr "leaks at most n to each oracle." In cryptographic applications, it is often natural to consider reductions that leak at most some other function L; Definitions 2.1 and 2.2 have natural generalizations that fit these applications see [1, 7] for details. In several proofs, we will use the following Chernoff bounds on the binomial distribution, which are taken directly from [25, Lecture 4, p. 29]. Fact 2.3. <p> The random-self-reducibility of multivariate polynomials is the key to some of the results stated above. Beaver and Feigenbaum's general construction of multioracle ihs's <ref> [7] </ref>, which they described in terms of arithmetic circuits, can be described in current terminology as follows: Every boolean function is (1; n + 1)-lrr to its arithmetiza-tion over fK n g n1 , where K n is any finite field of size greater than n.
Reference: [8] <author> D. Beaver, J. Feigenbaum, J. Kilian, and P. Rogaway, </author> <title> Security with low communication overhead, </title> <booktitle> in Advances in Cryptology - Crypto '90, vol. 537 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1991, </year> <pages> pp. 62-76. </pages>
Reference-contexts: Random-self-reductions also provide natural examples of instance-hiding schemes (cf. <ref> [1, 7, 8] </ref>), in which a weak, private computing device uses the resources of a powerful, shared computing device without revealing its private data. <p> The related idea of mapping an instance x in the domain of f to one or more random instances y 1 , : : :, y k in the domain of a different function g is studied in <ref> [1, 7, 8] </ref>. For the case of one random y, a negative result for NP-hard functions is obtained in [1]. If multiple random y i 's are allowed, then every function f can be locally randomly reduced to a related function g; see [7, 8] for a thorough discussion. <p> For the case of one random y, a negative result for NP-hard functions is obtained in [1]. If multiple random y i 's are allowed, then every function f can be locally randomly reduced to a related function g; see <ref> [7, 8] </ref> for a thorough discussion. In this paper, we continue the study of random-self-reductions from a complexity-theoretic point of view. We further generalize the formal definition of random-self-reducibility that is studied in [15]. <p> In fact, the general ihs construction of [7] uses only one round of queries and does not require the oracles to flip coins; so, in current terminology, it is a (1; n + 1)-lrr. The term lrr was subsequently introduced and formally defined by Beaver, Feigenbaum, Kilian, and Rogaway <ref> [8] </ref>, who also gave an improvement of the Beaver-Feigenbaum construction: For every polynomially bounded t = t (n) and every function f , there is a function g such that f is (t; (tn= log n) + 1)-lrr to g. <p> Lipton also pointed out that the function that computes the permanent of a matrix over a finite field is a low-degree multivari-ate polynomial and thus randomly testable. Finally, Beaver, Feigenbaum, Kilian, and Rogaway <ref> [8] </ref> showed how to represent f n as a degree-(n= log n) polynomial h n over K n 5 by performing a simple change of variables, thus obtaining a (1; (n= log n) + 1)-lrr from f to h. Definition 2.6.
Reference: [9] <author> R. Beigel, J. Gill, and U. Hertrampf, </author> <title> Counting classes: Thresholds, parity, </title> <booktitle> mods, and fewness, in Proceedings of the 7th Symposium on Theoretical Aspects of Computer Science, vol. 415 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1990, </year> <pages> pp. 49-57. 12 </pages>
Reference-contexts: Thus the class P, defined in [22], is MOD 2 P in the notation used here. Fact 2.12. (cf. <ref> [9] </ref>): If m 1 and m 2 are relatively prime, then S 2 MOD m 1 m 2 P if and only if there are sets S 1 2 MOD m 1 P and S 2 2 MOD m 2 P such that S = S 1 [ S 2 . <p> Fact 2.13. (cf. <ref> [9] </ref>): If p e 1 1 p e t t is the prime factorization of m, then MOD m P = MOD p 1 p t P.
Reference: [10] <author> E. Berlekamp, </author> <title> Algebraic Coding Theory, </title> <publisher> McGraw Hill, </publisher> <address> New York, </address> <year> 1968. </year>
Reference-contexts: Fix a basis for this vector space. This entails finding a polynomial of degree k that is irreducible over Z m , which can be done in probabilistic polynomial time <ref> [10, 23] </ref>. (In fact, we could choose k so that all that is required is a polynomial of degree l, where (k= log m) = l k, that is irreducible over Z m .
Reference: [11] <author> M. Blum and S. Kannan, </author> <title> Designing programs that check their work, </title> <booktitle> in Proceedings of the 21st ACM Symposium on the Theory of Computing, ACM, </booktitle> <address> New York, </address> <year> 1989, </year> <pages> pp. 86-97. </pages>
Reference-contexts: O. Box 636, Murray Hill, NJ 07974-0636, jf@research.att.com z University of Chicago, Computer Science Department, 1100 East 58th Street, Chicago, IL 60637, fortnow@cs.uchicago.edu 1 program checkers (cf. <ref> [11, 18] </ref>). Intuitively, this is because the verifier/checker interrogates the prover/program by comparing its output on the specific input of interest to its outputs on other correlated random instances. Several variations of this relationship between random-self-reducibility and proof systems/checkers are stated formally in [12, 21, 27]. <p> Open Problems. Open problems abound, including: * Do NP-complete sets have adaptive k-rsr's for some k log n? * Are NP-complete sets checkable in the sense of <ref> [11] </ref>? Note that all known checkers for sets that are complete for natural complexity classes use rsr's. * What other sets do or do not have rsr's? How about incomplete sets? Sets and functions complete for classes C that satisfy PH BPP C and P C PSPACE? The classes MOD m
Reference: [12] <author> M. Blum, M. Luby, and R. Rubinfeld, </author> <title> Self-testing and self-correcting programs, with appli cations to numerical programs, </title> <booktitle> in Proceedings of the 22nd ACM Symposium on the Theory of Computing, ACM, </booktitle> <address> New York, </address> <year> 1990, </year> <pages> pp. 73-83. </pages>
Reference-contexts: Intuitively, this is because the verifier/checker interrogates the prover/program by comparing its output on the specific input of interest to its outputs on other correlated random instances. Several variations of this relationship between random-self-reducibility and proof systems/checkers are stated formally in <ref> [12, 21, 27] </ref>. These ideas play a crucial role in the characterization of the language-recognition power of interactive proof systems (cf. [5, 21, 24]). Currently, one of the most important open questions about checkability is whether NP-complete sets are checkable.
Reference: [13] <author> M. Blum and S. Micali, </author> <title> How to generate cryptographically strong sequences of pseudo-random bits, </title> <journal> SIAM Journal on Computing, </journal> <volume> 13 (1984), </volume> <pages> pp. 850-864. </pages>
Reference-contexts: Cryptographic protocols: The fact that certain number-theoretic functions are random-self-reducible (and hence hard on average if they are hard at all) is used extensively in the theory of cryptography - e.g., to achieve probabilistic encryption (cf. [17]) and cryptographically strong pseudorandom number generation (cf. <ref> [13] </ref>). Random-self-reductions also provide natural examples of instance-hiding schemes (cf. [1, 7, 8]), in which a weak, private computing device uses the resources of a powerful, shared computing device without revealing its private data. <p> Although random-self-reducibility had been used for a long time in the design and analysis of cryptographic protocols (cf., e.g., <ref> [17, 13] </ref>), it was first defined formally and studied from a complexity theoretic point of view by Abadi, Feigenbaum, and Kilian [1]; they considered reductions that map the given instance x to one random instance y.
Reference: [14] <author> J. Cai, </author> <title> With probability one, a random oracle separates pspace from the polynomial-time hier archy, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 38 (1989), </volume> <pages> pp. 68-85. </pages>
Reference-contexts: Lower bounds: The random-self-reducibility of the parity function is used in [3] to obtain a simple proof that a random oracle separates the polynomial hierarchy (PH) from PSPACE. (An earlier proof of this result in <ref> [14] </ref> does not use random-self-reducibility.) Interactive proof systems and program checkers: Random-self-reductions are crucial ingredients in many of the original examples of interactive proof systems and fl This work was supported in part by National Science Foundation grant CCR 90-09936.
Reference: [15] <author> J. Feigenbaum, S. Kannan, and N. Nisan, </author> <title> Lower bounds on random-self-reducibility, </title> <booktitle> in Proceedings of the 5th IEEE Structure in Complexity Theory Conference, IEEE, </booktitle> <address> New York, </address> <year> 1990, </year> <pages> pp. 100-109. </pages>
Reference-contexts: Random-self-reductions that produce several, correlated random instances y 1 , : : :, y k were defined formally by Feigenbaum, Kannan, and Nisan <ref> [15] </ref>; however, they only considered reductions that produce y i 's that are uniformly distributed over f0; 1g jxj . <p> In this paper, we continue the study of random-self-reductions from a complexity-theoretic point of view. We further generalize the formal definition of random-self-reducibility that is studied in <ref> [15] </ref>. Specifically, we look at reductions that map a given instance x to a sequence of random instances y 1 , : : :, y k , with the property that the induced distribution on each y i depends only on the length of x. <p> In particular, if the characteristic 2 function for any NP-complete set has a nonadaptive random-self-reduction, then the polynomial-time hierarchy collapses at the third level. This strengthens the main result in <ref> [15] </ref>. * If S is complete for PP or for MOD m P, for any m &gt; 1, then S is adap tively k (n)-random-self-reducible, for some polynomially bounded function k. Setting m = 2, we get that P-complete sets are random-self-reducible. <p> Feigenbaum, Kannan, and Nisan <ref> [15] </ref> use the term "k (n)-random-self-reduction" to describe a special case of Definition 2.1, i.e., the case in which each of the random variables (i; x; r) is distributed uniformly over f0; 1g n . Next we generalize Definition 2.1 to allow a multiround, adaptive strategy for choosing random queries. <p> We obtain this bound by using Inequality (1) from Fact 2.3, with a = m=k 2 p The technique of showing that a particular type of random-self-reduction for S implies a type of interactive proof system for S was first used by Feigenbaum, Kannan, and Nisan <ref> [15, Theorem 4.4] </ref>. There it is shown that if S has what they call a "one-sided 1-rsr," then S 2 AM=poly. These reductions are much more restricted than the type of rsr's considered here; a precise definition can be found in [15]. <p> There it is shown that if S has what they call a "one-sided 1-rsr," then S 2 AM=poly. These reductions are much more restricted than the type of rsr's considered here; a precise definition can be found in <ref> [15] </ref>. In fact, the following stronger statement can be made. This observation is due to Mario Szegedy. Corollary 3.2. If S is in NP and is nonadaptively poly-rsr, then S is in AM/log. Proof. Let , be a nonadaptive rsr for S.
Reference: [16] <author> S. Fenner, L. Fortnow, and S. Kurtz, </author> <title> Gap-definable counting classes, </title> <booktitle> in Proceedings of the 6th IEEE Structure in Complexity Theory Conference, IEEE, </booktitle> <address> New York, </address> <year> 1991, </year> <pages> pp. 30-42. </pages>
Reference-contexts: Definition 2.6. A complexity class C is #P-robust if FP C = #P C , where FP denotes the class of all polynomial-time computable functions. In Section 4, we will use the following generalized version of #P. Definition 2.7. (cf. <ref> [16] </ref>): A function f : f0; 1g fl ! Z is in the complexity class Gap-P if there is an NP machine M such that, for all x, f (x) is the difference between the number of accepting computations of M on input x and the number of rejecting computations of <p> A complexity class C is Gap-P-robust if and only if it is #P-robust. Let h; i be a one-to-one, onto, polynomial-time computable, polynomial-time invertible pairing function from f0; 1g fl fi f0; 1g fl to f0; 1g fl . Gap-P has the following closure properties. Fact 2.10. (cf. <ref> [16] </ref>): If a function f (hx; yi) 2 Gap-P then the following functions are also in Gap-P for any polynomial p: 1. g (hx; yi) = f (hx; yi) P jyjp (jxj) f (hx; yi) 3. g (x) = 1yp (jxj) f (hx; yi) In particular, Gap-P is closed under subtraction.
Reference: [17] <author> S. Goldwasser and S. Micali, </author> <title> Probabilistic encryption, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 28 (1984), </volume> <pages> pp. 270-299. </pages>
Reference-contexts: Cryptographic protocols: The fact that certain number-theoretic functions are random-self-reducible (and hence hard on average if they are hard at all) is used extensively in the theory of cryptography - e.g., to achieve probabilistic encryption (cf. <ref> [17] </ref>) and cryptographically strong pseudorandom number generation (cf. [13]). Random-self-reductions also provide natural examples of instance-hiding schemes (cf. [1, 7, 8]), in which a weak, private computing device uses the resources of a powerful, shared computing device without revealing its private data. <p> Although random-self-reducibility had been used for a long time in the design and analysis of cryptographic protocols (cf., e.g., <ref> [17, 13] </ref>), it was first defined formally and studied from a complexity theoretic point of view by Abadi, Feigenbaum, and Kilian [1]; they considered reductions that map the given instance x to one random instance y.
Reference: [18] <author> S. Goldwasser, S. Micali, and C. Rackoff, </author> <title> The knowledge complexity of interactive proof systems, </title> <journal> SIAM Journal on Computing, </journal> <volume> 18 (1989), </volume> <pages> pp. 186-208. </pages>
Reference-contexts: O. Box 636, Murray Hill, NJ 07974-0636, jf@research.att.com z University of Chicago, Computer Science Department, 1100 East 58th Street, Chicago, IL 60637, fortnow@cs.uchicago.edu 1 program checkers (cf. <ref> [11, 18] </ref>). Intuitively, this is because the verifier/checker interrogates the prover/program by comparing its output on the specific input of interest to its outputs on other correlated random instances. Several variations of this relationship between random-self-reducibility and proof systems/checkers are stated formally in [12, 21, 27].
Reference: [19] <author> S. Goldwasser and M. Sipser, </author> <title> Private coins versus public coins in interactive proof systems., in Randomness and Computation, </title> <editor> S. Micali, ed., </editor> <volume> vol. </volume> <booktitle> 5 of Advances in Computing Research, </booktitle> <publisher> JAI Press, </publisher> <address> Greenwich, </address> <year> 1989, </year> <pages> pp. 73-90. </pages>
Reference-contexts: Let AM (k)=poly be the class of sets accepted by k-move Arthur-Merlin games in which Arthur is given polynomial-length advice in addition to probabilistic polynomial time. We use AM (resp. AM=poly) synonymously with AM (2) (resp. AM (2)=poly). Fact 2.17. (cf. <ref> [6, 19] </ref>): For any constant k, AM (k)=poly = NP=poly. Finally we use the following known relationship between levels of the polynomial-time hierarchy and the corresponding nonuniform classes. Fact 2.18. (cf. [29]): If P i P i =poly, then the polynomial-time hierarchy collapses to P i+2 .
Reference: [20] <author> R. Lipton, </author> <title> New directions in testing, in Distributed Computing and Cryptography, </title> <editor> J. Feigen baum and M. Merritt, eds., </editor> <volume> vol. </volume> <booktitle> 2 of DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <publisher> American Mathematical Society, </publisher> <address> Providence, </address> <year> 1991, </year> <pages> pp. 191 - 202. </pages>
Reference-contexts: In this case, f "is as hard on average as it is in the worst case." For example, it follows from a result in <ref> [20] </ref> that the PERM (permanent of integer matrices) function is random-self-reducible. <p> Lipton <ref> [20] </ref> later used the same construction to show that multivariate polynomials are, in his terms, randomly testable; his was the first paper to state the construction in terms of polynomials instead of arithmetic circuits.
Reference: [21] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan, </author> <title> Algebraic methods for interactive proof systems, </title> <journal> Journal of the ACM, </journal> <volume> 39 (1992), </volume> <pages> pp. 859-868. </pages>
Reference-contexts: Intuitively, this is because the verifier/checker interrogates the prover/program by comparing its output on the specific input of interest to its outputs on other correlated random instances. Several variations of this relationship between random-self-reducibility and proof systems/checkers are stated formally in <ref> [12, 21, 27] </ref>. These ideas play a crucial role in the characterization of the language-recognition power of interactive proof systems (cf. [5, 21, 24]). Currently, one of the most important open questions about checkability is whether NP-complete sets are checkable. <p> Several variations of this relationship between random-self-reducibility and proof systems/checkers are stated formally in [12, 21, 27]. These ideas play a crucial role in the characterization of the language-recognition power of interactive proof systems (cf. <ref> [5, 21, 24] </ref>). Currently, one of the most important open questions about checkability is whether NP-complete sets are checkable. The main result that we present in Section 3 implies that, if NP-complete sets are checkable, their checkers must use radically different techniques from those used by the existing checkers.
Reference: [22] <author> C. Papadimitriou and S. Zachos, </author> <title> Two remarks on the power of counting, </title> <booktitle> in Proceedings of the 6th GI Conference on Theoretical Computer Science, vol. 145 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1983, </year> <pages> pp. 269-276. </pages>
Reference-contexts: Thus the class P, defined in <ref> [22] </ref>, is MOD 2 P in the notation used here.
Reference: [23] <author> M. Rabin, </author> <title> Probabilistic algorithms in finite fields, </title> <journal> SIAM Journal on Computing, </journal> <volume> 9 (1980), </volume> <pages> pp. 273-280. </pages>
Reference-contexts: Fix a basis for this vector space. This entails finding a polynomial of degree k that is irreducible over Z m , which can be done in probabilistic polynomial time <ref> [10, 23] </ref>. (In fact, we could choose k so that all that is required is a polynomial of degree l, where (k= log m) = l k, that is irreducible over Z m .
Reference: [24] <author> A. Shamir, </author> <title> IP = PSPACE, </title> <journal> Journal of the ACM, </journal> <volume> 39 (1992), </volume> <pages> pp. 869-877. </pages>
Reference-contexts: Several variations of this relationship between random-self-reducibility and proof systems/checkers are stated formally in [12, 21, 27]. These ideas play a crucial role in the characterization of the language-recognition power of interactive proof systems (cf. <ref> [5, 21, 24] </ref>). Currently, one of the most important open questions about checkability is whether NP-complete sets are checkable. The main result that we present in Section 3 implies that, if NP-complete sets are checkable, their checkers must use radically different techniques from those used by the existing checkers.
Reference: [25] <author> J. Spencer, </author> <title> Ten Lectures on the Probabilistic Method, </title> <booktitle> vol. 52 of CBMS, </booktitle> <publisher> SIAM, </publisher> <address> Philadelphia, </address> <year> 1987. </year>
Reference-contexts: In several proofs, we will use the following Chernoff bounds on the binomial distribution, which are taken directly from <ref> [25, Lecture 4, p. 29] </ref>. Fact 2.3.
Reference: [26] <author> S. </author> <title> Toda, PP is as hard as the polynomial-time hierarchy, </title> <journal> SIAM Journal on Computing, </journal> <volume> 20 (1991), </volume> <pages> pp. 865-877. </pages>
Reference-contexts: use rsr's. * What other sets do or do not have rsr's? How about incomplete sets? Sets and functions complete for classes C that satisfy PH BPP C and P C PSPACE? The classes MOD m P, PP, and #P all fall between PH and PSPACE in this sense (cf. <ref> [26] </ref>). Acknowledgments. We would like to thank Manuel Blum, Russell Impagliazzo, Steven Rudich, Gabor Tardos, and the referee for their comments on earlier versions of this paper.
Reference: [27] <author> M. Tompa and H. Woll, </author> <title> Random self-reducibility and zero-knowledge interactive proofs of possession of information, </title> <booktitle> in Proceedings of the 28th IEEE Symposium on Foundations of Computer Science, IEEE, </booktitle> <address> New York, </address> <year> 1987, </year> <pages> pp. 472-482. </pages>
Reference-contexts: Intuitively, this is because the verifier/checker interrogates the prover/program by comparing its output on the specific input of interest to its outputs on other correlated random instances. Several variations of this relationship between random-self-reducibility and proof systems/checkers are stated formally in <ref> [12, 21, 27] </ref>. These ideas play a crucial role in the characterization of the language-recognition power of interactive proof systems (cf. [5, 21, 24]). Currently, one of the most important open questions about checkability is whether NP-complete sets are checkable.
Reference: [28] <author> L. Valiant, </author> <title> The complexity of computing the permanent, </title> <booktitle> Theoretical Computer Science, 8 (1979), </booktitle> <pages> pp. 189-201. </pages>
Reference-contexts: In this case, f "is as hard on average as it is in the worst case." For example, it follows from a result in [20] that the PERM (permanent of integer matrices) function is random-self-reducible. The PERM function is also #P-complete (cf. <ref> [28] </ref>); thus, if PERM could be computed efficiently on average (with respect to the target distribution of the reduction), then every function in #P could, with a randomized algorithm, be computed efficiently in the worst case.
Reference: [29] <author> C. Yap, </author> <title> Some consequences of nonuniform conditions on uniform classes, </title> <booktitle> Theoretical Computer Science, 26 (1983), </booktitle> <pages> pp. 287-300. 13 </pages>
Reference-contexts: We use AM (resp. AM=poly) synonymously with AM (2) (resp. AM (2)=poly). Fact 2.17. (cf. [6, 19]): For any constant k, AM (k)=poly = NP=poly. Finally we use the following known relationship between levels of the polynomial-time hierarchy and the corresponding nonuniform classes. Fact 2.18. (cf. <ref> [29] </ref>): If P i P i =poly, then the polynomial-time hierarchy collapses to P i+2 . This fact relativizes: For any O, if P;O P;O i =poly, then PH O i+2 . 3. Complete Sets in the Polynomial-Time Hierarchy. Theorem 3.1.
References-found: 29

