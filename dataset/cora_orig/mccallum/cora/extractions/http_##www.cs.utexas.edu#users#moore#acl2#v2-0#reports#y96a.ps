URL: http://www.cs.utexas.edu/users/moore/acl2/v2-0/reports/y96a.ps
Refering-URL: http://www.cs.utexas.edu/users/moore/acl2/v2-0/acl2-doc.html
Root-URL: 
Email: young@cli.com  
Title: Comparing Verification Systems: Interactive Consistency in ACL2  
Author: William D. Young 
Date: March, 1997  
Address: 1717 W. 6th Street, Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic, Inc.  
Abstract: Achieving interactive consistency among processors in the presence of faults is an important problem in fault tolerant computing, first cleanly formulated by Lamport, Pease and Shostak and solved in selected cases with their Oral Messages (OM) Algorithm. Several machine-supported verifications of this algorithm have been presented, including a particularly elegant formulation and proof by John Rushby using EHDM and PVS. Rushby proposes interactive consistency as a benchmark problem for specification and verification systems. We present a formalization of the OM algorithm in the ACL2 logic and compare our formalization and proof to his. We draw some conclusions concerning the range of desirable features for verification systems. In particular, while higher-order functions, strong typing, lambda abstraction and full quantification have some value they come with a cost; moreover, many uses of such feature can be easily translated into simpler logical constructs which facilitate more automated proof discovery. We offer a cautionary note about comparing systems with respect to a small set of problems in a limited domain. An earlier version of this paper appears in Proceedings of the Eleventh Annual 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W.R. Bevier and W.D. Young. </author> <title> The proof of correctness of a fault-tolerant circuit design. </title> <booktitle> In Proceedings of the Second International Working Conference on Dependable Computing for Critical Applications, </booktitle> <pages> pages 107-114. </pages> <publisher> IFIP, </publisher> <month> February </month> <year> 1991. </year>
Reference-contexts: at least a third of the total are faulty. 3 Previous Formalizations of OM Bevier and Young [2] published a formalization and proof of the Oral Messages algorithm using the Boyer-Moore Nqthm [4] theorem prover in the context of a larger project of building a verified circuit implementing interactive consistency <ref> [1, 10] </ref>. They also mechanically checked the Lamport, et al. proof that the Oral Messages algorithm is "optimal" among its class of algorithms. Bevier and Young reported of their proof: The proofs of lemmas IC1 and IC2 are a fairly difficult exercise in mechanical theorem proving.
Reference: [2] <author> W.R. Bevier and W.D. Young. </author> <title> Machine checked proofs of the design of a fault-tolerant circuit. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4 </volume> <pages> 755-775, </pages> <year> 1992. </year>
Reference-contexts: Several mechanically checked verifications of this algorithm have been presented, including one by Bevier and Young <ref> [2] </ref> using Nqthm [4] and a particularly elegant formulation by Rushby using EHDM [15, 19] and PVS [12, 13] 1 . Rushby draws some comparisons between his formulation and the earlier Bevier/Young version and between the automated tools used in the proofs. <p> That is, no algorithm relying solely on oral message passing for interprocess communication can achieve interactive consistency among a collection of processors if at least a third of the total are faulty. 3 Previous Formalizations of OM Bevier and Young <ref> [2] </ref> published a formalization and proof of the Oral Messages algorithm using the Boyer-Moore Nqthm [4] theorem prover in the context of a larger project of building a verified circuit implementing interactive consistency [1, 10].
Reference: [3] <author> R.S. Boyer and J S. Moore. </author> <title> The addition of bounded quantification and partial functions to a computational logic and its theorem prover. </title> <type> Technical Report ICSCA-CMP-52, </type> <institution> Institute for Computing Science, University of Texas at Austin, </institution> <month> January </month> <year> 1987. </year>
Reference-contexts: of the BG version would have been significantly more difficult had we not already performed the IC version; that is specification and verification of IC followed by BG is probably much simpler than tackling BG alone," which is the route 3 A limited version of quantification was available in Nqthm <ref> [3] </ref>, but was not used in their proof of the algorithm correctness.
Reference: [4] <author> R.S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: Several mechanically checked verifications of this algorithm have been presented, including one by Bevier and Young [2] using Nqthm <ref> [4] </ref> and a particularly elegant formulation by Rushby using EHDM [15, 19] and PVS [12, 13] 1 . Rushby draws some comparisons between his formulation and the earlier Bevier/Young version and between the automated tools used in the proofs. <p> solely on oral message passing for interprocess communication can achieve interactive consistency among a collection of processors if at least a third of the total are faulty. 3 Previous Formalizations of OM Bevier and Young [2] published a formalization and proof of the Oral Messages algorithm using the Boyer-Moore Nqthm <ref> [4] </ref> theorem prover in the context of a larger project of building a verified circuit implementing interactive consistency [1, 10]. They also mechanically checked the Lamport, et al. proof that the Oral Messages algorithm is "optimal" among its class of algorithms. <p> To do so, we first briefly describe ACL2, the successor to Nqthm, and then provide a translation of Rushby's OMIC formalization into ACL2. 4 Brief Description of ACL2 ACL2 is an extended, reimplemented version of Nqthm <ref> [4] </ref> that reasons about an applicative subset of Common Lisp. It has been designed and implemented by J Moore and Matt Kaufmann at CLI, with assistance and inspiration from Bob Boyer. The system is described more fully elsewhere in this issue [11]. <p> Function if evaluates only its test and the selected branch. Some other functions, such as the elementary logical operators not, and, or and implies, are defined in terms of if. 4.2 Theorem Prover The ACL2 theorem prover is a reimplementation of the Nqthm theorem prover <ref> [4] </ref> for the ACL2 logic. Every proof technique of Nqthm has been implemented in ACL2. Many have been extended significantly.
Reference: [5] <author> R.W. Butler. </author> <title> An introduction to requirements capture using PVS: Specification of a simple autopilot. </title> <type> Technical Memorandum 110255, </type> <institution> NASA, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: For example, in a recent report, Ricky Butler describes the translation of some informal requirements specifications for a simple autopilot into a formal model using PVS <ref> [5] </ref>. Butler makes the assertion that "the modeling techniques used in this paper can be used with other formal specification languages that are based upon higher order logic" (emphasis added).
Reference: [6] <author> K. Finney. </author> <title> Mathematical notation in formal specification: </title> <journal> Too difficult for the masses? IEEE Transactions on Software Engineering, </journal> <volume> 22(2) </volume> <pages> 158-159, </pages> <month> February </month> <year> 1996. </year> <month> 29 </month>
Reference-contexts: But it has the advantages of being completely unambiguous without any ancillary precedence rules, and is trivially machine parsed, making it much easier to perform meta-theoretic reasoning about terms in the logic, for example. "Traditional" notation requires considerably more effort to parse. Some recent research <ref> [6] </ref> suggests that so-called "standard mathematical notations" in fact may be quite difficult to understand except to the expert, exactly because of such complex ancillary rules.
Reference: [7] <author> M. Kaufmann and J S. Moore. </author> <title> Design goals of ACL2. </title> <type> Technical Report 101, </type> <institution> Computational Logic, Inc., </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: It is that implied suggestion that we question. We have duplicated Rushby's formalization and proof of the Oral Messages algorithm using ACL2 <ref> [7, 11] </ref>, the successor to Nqthm. The formalization of the algorithm in ACL2, the statement of its correctness properties and their proof are very similar to Rushby's.
Reference: [8] <author> L. Lamport. </author> <title> Types considered harmful. </title> <note> DEC SRC Internal note, De-cember 1992. </note>
Reference-contexts: reviewers for pointing out this example to me. 24 [T]ypes are not just unnecessary, they are harmful in formaliz-ing mathematics...Most computer scientists have an unreasonable attachment to types...We can assure the reader that mathematicians have gotten along quite well for two thousand years without types, and they still can today <ref> [8] </ref>. Lisp derives much of its expressive utility from its weak typing; on the other hand, considerable execution efficiency can be gained from type declarations. ACL2 preserves both benefits by the judicious integration of an untyped logic with guards to insure compliance with efficiently executable raw Lisp implementations [11].
Reference: [9] <author> L. Lamport, R. Shostak, and M. Pease. </author> <title> The Byzantine Generals problem. </title> <journal> ACM TOPLAS, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: 1 Introduction Achieving interactive consistency among processors in the presence of faults is an important problem in fault tolerant computing, first cleanly formulated by Lamport, Shostak, and Pease <ref> [14, 9] </ref> and solved in selected cases with their Oral Messages (OM) Algorithm. Several mechanically checked verifications of this algorithm have been presented, including one by Bevier and Young [2] using Nqthm [4] and a particularly elegant formulation by Rushby using EHDM [15, 19] and PVS [12, 13] 1 . <p> Lamport, Shostak, and Pease <ref> [9] </ref> describe the problem in terms of the colorful metaphor of Byzantine Generals attempting to arrive at a common battle plan through an exchange of messages. <p> The Oral Messages algorithm OM (m) describes m rounds of communication among the generals and is inductively defined for all nonnegative integers m. The goal is to convey an order by the commanding general to each of n 1 lieutenants. The description of the algorithm from <ref> [9] </ref> is as follows: Algorithm OM (0) 1. The commander sends his value to every lieutenant. 2. Each lieutenant uses the value he receives from the comman der, or uses the value retreat if he receives no value. Algorithm OM (m), m &gt; 0. 1.
Reference: [10] <author> J S. Moore. </author> <title> Mechanically verified hardware implementing an 8-bit parallel IO Byzantine agreement processor. </title> <type> Technical Report Technical Report 69, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: at least a third of the total are faulty. 3 Previous Formalizations of OM Bevier and Young [2] published a formalization and proof of the Oral Messages algorithm using the Boyer-Moore Nqthm [4] theorem prover in the context of a larger project of building a verified circuit implementing interactive consistency <ref> [1, 10] </ref>. They also mechanically checked the Lamport, et al. proof that the Oral Messages algorithm is "optimal" among its class of algorithms. Bevier and Young reported of their proof: The proofs of lemmas IC1 and IC2 are a fairly difficult exercise in mechanical theorem proving.
Reference: [11] <author> J S. Moore and M. Kaufmann. ACL2: </author> <title> An industrial strength version of Nqthm. </title> <journal> Transactions on Software Engineering, </journal> <year> 1997. </year>
Reference-contexts: It is that implied suggestion that we question. We have duplicated Rushby's formalization and proof of the Oral Messages algorithm using ACL2 <ref> [7, 11] </ref>, the successor to Nqthm. The formalization of the algorithm in ACL2, the statement of its correctness properties and their proof are very similar to Rushby's. <p> It has been designed and implemented by J Moore and Matt Kaufmann at CLI, with assistance and inspiration from Bob Boyer. The system is described more fully elsewhere in this issue <ref> [11] </ref>. By formalizing a logic around applicative Common Lisp the designers take advantage of the exceptionally good optimizing compilers for Common Lisp to get, in many cases, execution speeds comparable to C. <p> Lisp derives much of its expressive utility from its weak typing; on the other hand, considerable execution efficiency can be gained from type declarations. ACL2 preserves both benefits by the judicious integration of an untyped logic with guards to insure compliance with efficiently executable raw Lisp implementations <ref> [11] </ref>. In theorems, "type" hypotheses can be included where needed. As in PVS this permits using arbitrary predicates as "types" but also requires arbitrarily hard theorem proving to assure type compliance. Regarding higher order features and lambda expressions: they often are elegant, but seldom necessary.
Reference: [12] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2), </volume> <month> February </month> <year> 1995. </year>
Reference-contexts: Several mechanically checked verifications of this algorithm have been presented, including one by Bevier and Young [2] using Nqthm [4] and a particularly elegant formulation by Rushby using EHDM [15, 19] and PVS <ref> [12, 13] </ref> 1 . Rushby draws some comparisons between his formulation and the earlier Bevier/Young version and between the automated tools used in the proofs. In particular, he cites the strong typing and higher-order functions available in PVS as helpful in leading to his improved formulation. <p> His proof is also quite different, and closer to the journal proof. We cannot dispute Rushby's claim that he found various features helpful in his thinking about the problem. But one might infer also from his success in formally analyzing the Oral Messages algorithm and other fault tolerant algorithms <ref> [12] </ref> that the features of EHDM and PVS highlighted by these efforts are either necessary or highly desirable in a modern specification and proof system. It is that implied suggestion that we question. <p> Therefore, even a machine certified proof will be most useful if it conveys insight. Rushby reformulated the algorithm using first the EHDM system [19] and later PVS <ref> [12] </ref>. His formulation [15] is decidedly simpler and more elegant than the version by Bevier and Young. Rushby "found that one of the keys to simplifying the algorithm was to focus on the symmetric formulation (which is actually the form required), rather than the asymmetric Byzantine Generals form" [12] used by <p> later PVS <ref> [12] </ref>. His formulation [15] is decidedly simpler and more elegant than the version by Bevier and Young. Rushby "found that one of the keys to simplifying the algorithm was to focus on the symmetric formulation (which is actually the form required), rather than the asymmetric Byzantine Generals form" [12] used by Bevier and Young. For completeness Rushby included formalizations of both the symmetric (OMIC) and asymmetric (OMBG) versions of the algorithm. <p> We agree with Rushby that "The value of syntactic conveniences [...] should not be underestimated; we find that they reduce learning time, and ease comprehension and communication" <ref> [12] </ref>. But they also should not be overestimated. Our experience is that such syntactic issues are a relatively minor concern for serious users of automated proof tools, when compared to the intellectual effort of analyzing complex algorithms.
Reference: [13] <author> S. Owre, J. M. Rushby, and N. Shankar. Pvs: </author> <title> A prototype verification system. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Eleventh Conference on Automated Deduction, number 607 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Several mechanically checked verifications of this algorithm have been presented, including one by Bevier and Young [2] using Nqthm [4] and a particularly elegant formulation by Rushby using EHDM [15, 19] and PVS <ref> [12, 13] </ref> 1 . Rushby draws some comparisons between his formulation and the earlier Bevier/Young version and between the automated tools used in the proofs. In particular, he cites the strong typing and higher-order functions available in PVS as helpful in leading to his improved formulation.
Reference: [14] <author> M. Pease, R. Shostak, and L. Lamport. </author> <title> Reaching agreement in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 27(2) </volume> <pages> 228-234, </pages> <year> 1980. </year>
Reference-contexts: 1 Introduction Achieving interactive consistency among processors in the presence of faults is an important problem in fault tolerant computing, first cleanly formulated by Lamport, Shostak, and Pease <ref> [14, 9] </ref> and solved in selected cases with their Oral Messages (OM) Algorithm. Several mechanically checked verifications of this algorithm have been presented, including one by Bevier and Young [2] using Nqthm [4] and a particularly elegant formulation by Rushby using EHDM [15, 19] and PVS [12, 13] 1 .
Reference: [15] <author> J. Rushby. </author> <title> Formal verification of an oral messages algorithm for interactive consistency. </title> <type> Contractor Report NAS1-18969, </type> <institution> NASA, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: Several mechanically checked verifications of this algorithm have been presented, including one by Bevier and Young [2] using Nqthm [4] and a particularly elegant formulation by Rushby using EHDM <ref> [15, 19] </ref> and PVS [12, 13] 1 . Rushby draws some comparisons between his formulation and the earlier Bevier/Young version and between the automated tools used in the proofs. In particular, he cites the strong typing and higher-order functions available in PVS as helpful in leading to his improved formulation. <p> Moreover, their proof followed the purely constructive style common in the quantifier-free logic of Nqthm. 3 This led Rushby to observe that he "continued to find the journal description and proof more compelling than their formal version" <ref> [15] </ref> and to develop an alternative formulation and proof of the algorithm using EHDM. Of course, in a very real sense a machine checked formalization does not need to be as compelling as a journal version, if the prover is sound. <p> Therefore, even a machine certified proof will be most useful if it conveys insight. Rushby reformulated the algorithm using first the EHDM system [19] and later PVS [12]. His formulation <ref> [15] </ref> is decidedly simpler and more elegant than the version by Bevier and Young. <p> He reports that his formalization of OMBG is due to his colleague Shankar, and that its formal verification "is very similar to that of OMIC, and was derived from that of OMIC in less than a day" <ref> [15] </ref>. <p> According to Rushby, the upshot was that: "The complexity discovered by Bevier and Young was an artifact of their formalization and of the theorem prover at their disposal" <ref> [15] </ref>. 10 C1prop (r) = (8 p; q; y; caucus; v : ok (p) ^ ok (q) ^ p 2 caucus ^ q 2 caucus ^ y 2 caucus ^ jcaucusj &gt; 3 fl r ^ r jfaulty members (caucus)j OMIC (r; v; caucus)(p)(y) = OMIC (r; v; caucus)(q)(y)) C1: Lemma <p> As with Rushby's version, the final theorems on the full set of processes follows immediately from the inductive versions. Following Rushby's proof structure <ref> [15] </ref>, we were able to formulate and prove our versions of the interactive consistency conditions in a little over a day. 7 Except for replacing some quantified notions in Rushby's version by recursive functions, our proof structure is very similar to his. <p> We agree with John Rushby that "comparisons [between verification systems] are very useful, since they provide the only reasonable way to compare claims for `readability' or `expressiveness' in specification languages, and `power' or `effectiveness' in verification environments" <ref> [15] </ref>. However, it is very easy to overstate the merits of one system over another in such comparisons either by selecting idiosyncratic criteria of comparison or by comparing performance of systems on two very different formulations of a problem.
Reference: [16] <author> J. Rushby. </author> <title> Formal methods and their role in certification of critical systems. </title> <type> Technical Report CSL-95-1, </type> <institution> SRI International, Computer Science Laboratory, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Of course, in a very real sense a machine checked formalization does not need to be as compelling as a journal version, if the prover is sound. It is sufficient for the problem formulation to be clear and accurate, assuming we trust the machine-checked proof. Rushby himself argues strongly <ref> [16] </ref> that machine-checked proofs are required for fault-tolerant algorithms, such as OM, precisely because of their extreme subtlety and the tendency to get informal proofs wrong.
Reference: [17] <author> J. Rushby. </author> <title> Formal methods and their role in digital systems validation for airborne systems. </title> <type> Contractor Report 4673, </type> <institution> NASA, </institution> <month> August </month> <year> 1995. </year> <month> 30 </month>
Reference-contexts: It requires great skill to address these problems using formal methods, but the number and size of these problems may not be large. The greatest return on formal methods may be obtained when relatively few, very highly skilled people apply formal methods to the hardest and most critical problems. <ref> [17] </ref> Whereas two state-of-the-art general-purpose verification environments such as PVS and ACL2 have different strengths and weaknesses, we believe that either can be an effective and powerful tool in the hands of a skilled user. Both have been used for some very sophisticated specification and proof efforts.
Reference: [18] <author> J. Rushby and F. von Henke. </author> <title> Formal verification of the interactive convergence clock synchronization algorithm using EHDM. </title> <type> Technical report, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA 94025, </address> <month> January </month> <year> 1989. </year> <note> Draft. </note>
Reference-contexts: Some recent research [6] suggests that so-called "standard mathematical notations" in fact may be quite difficult to understand except to the expert, exactly because of such complex ancillary rules. For example, we noted in [21] that the published proof of the Interactive Convergence Clock Synchronization algorithm in EHDM <ref> [18] </ref> is unnecessarily confusing in places because the expected precedence was not observed in generating "traditional" notation from the EHDM internal form. In our translation of the OMBG version of the algorithm into ACL2 we encountered another instance of the ambiguity of "traditional" notation.
Reference: [19] <author> J. Rushby, F. von Henke, and S. Owre. </author> <title> An introduction to formal specification and verification using EHDM. </title> <type> Technical Report SRI-CSL-91-2, </type> <institution> SRI International, Computer Science Laboratory, </institution> <month> February </month> <year> 1991. </year>
Reference-contexts: Several mechanically checked verifications of this algorithm have been presented, including one by Bevier and Young [2] using Nqthm [4] and a particularly elegant formulation by Rushby using EHDM <ref> [15, 19] </ref> and PVS [12, 13] 1 . Rushby draws some comparisons between his formulation and the earlier Bevier/Young version and between the automated tools used in the proofs. In particular, he cites the strong typing and higher-order functions available in PVS as helpful in leading to his improved formulation. <p> However, the cleaner the formulation of the algorithm, the higher the likelihood that it will be scrutinized carefully and understood well by potential users and implementors. Therefore, even a machine certified proof will be most useful if it conveys insight. Rushby reformulated the algorithm using first the EHDM system <ref> [19] </ref> and later PVS [12]. His formulation [15] is decidedly simpler and more elegant than the version by Bevier and Young.
Reference: [20] <author> L. Wos and S. Winker. </author> <title> Open questions solved with the assistance of AURA. In Automatic Theorem Proving: After 25 Years. </title> <publisher> American Mathematical Society, </publisher> <year> 1984. </year>
Reference-contexts: For example, if the criteria of merit were the number of open questions in mathematics solved with the prover, the resolution-based Aura system <ref> [20] </ref> would win hands down. However, Aura likely would not perform well on verifying the Oral Messages algorithm.
Reference: [21] <author> W.D. Young. </author> <title> Verifying the interactive convergence clock synchronization algorithm using the Boyer-Moore theorem prover. </title> <type> Contractor Report 189649, </type> <institution> NASA, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Some recent research [6] suggests that so-called "standard mathematical notations" in fact may be quite difficult to understand except to the expert, exactly because of such complex ancillary rules. For example, we noted in <ref> [21] </ref> that the published proof of the Interactive Convergence Clock Synchronization algorithm in EHDM [18] is unnecessarily confusing in places because the expected precedence was not observed in generating "traditional" notation from the EHDM internal form. <p> We have found in translating several specifications (e.g. the Interactive Convergence Clock Synchronization Algorithm <ref> [21] </ref> and the current effort) from a higher order framework to a first order framework that we have not had any difficulty. This suggests that the "higher orderness" of these specification is primarily a notational convenience.
Reference: [22] <author> W.D. Young. </author> <title> Specification of a simple autopilot in ACL2. Internal note 327, Computational Logic, </title> <publisher> Inc., </publisher> <month> July </month> <year> 1996. </year>
Reference-contexts: fact, the reader will be hard pressed to find even one higher order feature in Butler's specification; the entire specification can easily be translated to a first order formalism such as ACL2. 9 To demonstrate that this is so, we translated Butler's specification into ACL2 in about two hours work <ref> [22] </ref>. For the one lemma for which Butler gave proof performance numbers, ACL2 running on a slower machine dispatched the lemma totally automatically in less than one tenth the time.
Reference: [23] <author> W.D. Young and W.R. Bevier. </author> <title> Mathematical modeling and analysis of an external memory manager. </title> <type> Technical Report 105, </type> <institution> Computational Logic, Inc., </institution> <month> October </month> <year> 1994. </year> <month> 31 </month>
Reference-contexts: We acknowledge, however, that syntax does present an issue when publishing formal verifications and making them available to a wider audience. For that reason, many of our published papers (e.g. <ref> [23] </ref>) use a more traditional mathematical syntax similar to that displayed earlier. 6.2 Features of the Logic Is our formalization of the OMIC algorithm as perspicuous as Rushby's, independent of the surface syntax of the logic? The answer depends on whom you ask.
References-found: 23

