URL: http://www.cs.utah.edu/~stoller/pubs/wwos-iv.ps
Refering-URL: http://www.cs.utah.edu/~stoller/pubs/pubs.html
Root-URL: 
Title: FLEX: A Tool for Building Efficient and Flexible Systems  
Author: John B. Carter, Bryan Ford, Mike Hibler, Ravindra Kuramkote, Jeffrey Law, Jay Lepreau, Douglas B. Orr, Leigh Stoller, and Mark Swanson 
Affiliation: University of Utah, Department of Computer Science  
Abstract: Modern operating systems must support a wide variety of services for a diverse set of users. Designers of these systems face a tradeoff between functionality and performance. Systems like Mach provide a set of general abstractions and attempt to handle every situation, which can lead to poor performance for common cases. Other systems, such as Unix, provide a small set of abstractions that can be made very efficient, at the expense of functionality. We are implementing a flexible system building tool, FLEX, that allows us to support a powerful operating systems interface efficiently by constructing specialized module implementations at runtime. FLEX improves the performance of existing systems by optimizing interprocess communications paths and relocating servers and clients to reduce communications overhead. These facilities improve the performance of Unix system calls on Mach from 20-400%. Furthermore, FLEX can dynamically extend the kernel in a controlled fashion, which gives user programs access to privileged data and devices not envisioned by the original operating system implementor.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: A new kernel foundation for Unix development. </title> <booktitle> In Proceedings of the Summer Usenix Conference, </booktitle> <month> July </month> <year> 1986. </year>
Reference-contexts: For example, if a client process contains a reference to a system call that normally is implemented as an RPC to a user-level server process, which is how many Unix system calls are emulated in Mach 3.0 <ref> [1] </ref>, it can replace the RPC interface with an LRPC-like interface if it recognizes that the server is always local. LRPC [2] exploits memory sharing and thread migration to reduce the overhead of an RPC, but it is only possible between two processes on the same machine.
Reference: [2] <author> B.N. Bershad, T.E. Anderson, E.D. Lazowska, and H.M. Levy. </author> <title> Lightweight remote procedure call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 37-55, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: LRPC <ref> [2] </ref> exploits memory sharing and thread migration to reduce the overhead of an RPC, but it is only possible between two processes on the same machine. Implementing the full LRPC mechanism requires modifications to the Mach thread model to support thread migration [6].
Reference: [3] <author> G. Bracha. </author> <title> The Programming Language Jigsaw : Mixins, Modularity, and Multiple Inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Most modules processed by FLEX are normal relocatable object files produced by a compiler, but there are also several kinds of interface definition modules. FLEX uses a Lisp-like module manipulation language developed as part of the Jigsaw framework <ref> [3] </ref> to specify how particular modules are to be combined. This language provides a complete implementation of module name manipulation, much more powerful than existing linkers. Augmented with detailed knowledge of communication mechanisms and corresponding argument semantics, this allows FLEX to transparently specialize inter-module communication.
Reference: [4] <author> J.B. Carter, A. Cox, D. Johnson, and W. Zwaenepoel. </author> <title> Distributed operating systems based on a protected global virtual address space. </title> <booktitle> In Third Workshop on Workstation Operating Systems, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: We view support for these "in-server clients" and "in-kernel servers" as the first step in an evolution towards a single address space system that can efficiently support existing programs written for existing systems <ref> [4] </ref>. Finally, we have experimented with the option of linking specially authorized routines into the kernel on a per-client basis. <p> Thus, communications between the user process and database server occur via protected procedure calls (involving traps) or directly through normal procedure calls and shared memory, depending on the desired level of protection <ref> [4] </ref>. Additionally, because this user process needs real-time performance guarantees, it uses its own paging mechanism (implemented as an in-kernel server) to control its paging behavior. <p> FLEX allows references to added routines to be installed directly in a single per-process trap table, because all such installations are performed by OMOS, which will improve the performance of this mechanism <ref> [4] </ref>. 5 Conclusions FLEX can improve an operating system in two different ways: (i) by improving the performance of existing system implementations and (ii) by dynamically extending operating system functionality. The core of FLEX is the OMOS server.
Reference: [5] <author> P. Druschel, L.L. Peterson, </author> <title> and N.C. Hutchinson. Beyond micro-kernel design: Decoupling modularity and protection in Lipto. </title> <booktitle> In Proceedings of the 12th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 512-520, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Even for I/O intensive programs, such as ls, the use of in-server client technology reduced the total running time by 10%. 4 Related Work There are a number of systems that provide various aspects of FLEX, although none supports its full generality of optimizations. Like FLEX, Lipto <ref> [5] </ref> provides architectural support for modules that is independent of protection domains, and thereby allows communications between modules to be optimized using techniques similar to those described above. However, it was not designed to work with existing system implementations, and currently does not include support for FLEX-like dynamic kernel extensions.
Reference: [6] <author> B. Ford, M. Hibler, and J. Lepreau. </author> <title> Notes on thread models in Mach 3.0. </title> <type> Technical Report UUCS-93-012, </type> <institution> University of Utah Computer Science Department, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: LRPC [2] exploits memory sharing and thread migration to reduce the overhead of an RPC, but it is only possible between two processes on the same machine. Implementing the full LRPC mechanism requires modifications to the Mach thread model to support thread migration <ref> [6] </ref>. Similarly, if the service is currently being provided by a server that has been loaded into the kernel address space, FLEX can replace the RPC with a trap that directly invokes the desired service. These examples demonstrate the potential that FLEX has for improving the quality of existing systems. <p> performance improves by a factor of three, Unix system calls to the server improve by 20-200%, and the overall performance of large benchmarks improves by 4-13%. (ii) While performing the INKS work, we discovered that many performance optimizations could be introduced if the Mach kernel supported a full migrating-threads model <ref> [6] </ref>. We have implemented such a mechanism, fully decoupling threads from tasks.
Reference: [7] <author> B. Ford, J. Lepreau, and D. Orr. </author> <title> Remote procedure call specialization with the OMOS object server. </title> <type> Technical report, </type> <institution> University of Utah, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: FLEX is able to improve upon existing system implementations by transparently substituting a particular declaration of a symbol with a functionally equivalent implementation that provides the same interface and semantics. The details of the low-level binding mechanism are beyond the scope of this paper, but are described elsewhere <ref> [7] </ref>.
Reference: [8] <author> L.J. Kenah, R.E. Goldenberg, and S.F. Bate. </author> <title> VAX/VMS Internals and Data Structures. </title> <publisher> Digital Press, </publisher> <address> Bedford, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: It does not reconfigure modules for performance purposes. Synthesis [10] generates both specialized OS interfaces and actual operating systems functions, but does not reconfigure processes or move functions between modules. Finally, the VMS operating system <ref> [8] </ref> gave users the ability to extend the system dynamically by installing specially authorized trap handlers. VMS supported this capability by associating a per-process dispatcher routine with each protected shareable image that was installed and querying the appropriate dispatchers when an unrecognized trap was encountered.
Reference: [9] <author> J. Lepreau, M. Hibler, B. Ford, and J. </author> <title> Law. In-kernel servers on Mach 3.0: Implementation and performance. </title> <booktitle> In Proceedings of the Third Usenix Mach Symposium, </booktitle> <pages> pages 39-55, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: We have performed three experiments that demonstrate the value of evolving an existing operating system, Mach 3.0 and the OSF/1 Unix server, into a flexibly structured system. (i) We transparently merged a frequently accessed and trusted user-level server, the Unix server, into the kernel's protection domain, while fully preserving semantics <ref> [9] </ref>. We refer to this mechanism as in-kernel servers, or INKS. Client calls to the server are bound either to a simple system call interface, or to a full RPC mechanism, depending on the server's location.
Reference: [10] <author> H. Massalin and C. Pu. </author> <title> Threads and input/output in the Synthesis kernel. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Psyche [14] uses module interface information to construct systems composed of modules implemented by radically different operating systems and languages, so-called multi-model programming. It does not reconfigure modules for performance purposes. Synthesis <ref> [10] </ref> generates both specialized OS interfaces and actual operating systems functions, but does not reconfigure processes or move functions between modules. Finally, the VMS operating system [8] gave users the ability to extend the system dynamically by installing specially authorized trap handlers.
Reference: [11] <author> D.B. Orr, J. Bonn, J. Lepreau, and R. Mecklenburg. </author> <title> Fast and flexible shared libraries. </title> <booktitle> In Proceedings of the Summer 1993 USENIX Conference, </booktitle> <address> Cincinnati, OH, </address> <month> Summer </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: In addition, OMOS is providing a fast and portable shared library service for an 800,000 line CAD system <ref> [11] </ref>, with substantial speedups due to its caching of relocated images.
Reference: [12] <author> D.B. Orr and R. Mecklenburg. </author> <title> OMOS | an object server for program execution. </title> <booktitle> In Proceedings of the Second International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 200-209, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: FLEX works by reading modules, manipulating them as specified by module manipulation files, and writing the resulting executable either to a user's address space or to a file for later use. The active entity in FLEX is the OMOS server <ref> [12] </ref>, which runs as a privileged process. It performs several functions, including: generating, relocating and binding object files, caching relocated object files for later use, managing address spaces, and interacting with the kernel to add or delete kernel routines on demand.
Reference: [13] <author> D.B. Orr, R.W. Mecklenburg, P.J. Hoogenboom, and J. Lepreau. </author> <title> Dynamic program monitoring and transformation using the OMOS object server. </title> <booktitle> In Proceedings of the Twenty-Sixth Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 232-241, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: In addition to its role in FLEX, OMOS has been able to improve the performance of a number of running systems by an average of 10% by optimizing the locality of instruction references performed by the systems, and thereby improving cache and paging behavior <ref> [13] </ref>. In addition, OMOS is providing a fast and portable shared library service for an 800,000 line CAD system [11], with substantial speedups due to its caching of relocated images.
Reference: [14] <author> M.L. Scott, T.J. LeBlanc, </author> <title> and B.D. Marsh. </title> <booktitle> Multi-model parallel programming in Psyche. In Proceedings of the 1990 Conference on the Principles and Practice of Parallel Programming, </booktitle> <pages> pages 70-78, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: However, it was not designed to work with existing system implementations, and currently does not include support for FLEX-like dynamic kernel extensions. Psyche <ref> [14] </ref> uses module interface information to construct systems composed of modules implemented by radically different operating systems and languages, so-called multi-model programming. It does not reconfigure modules for performance purposes.
References-found: 14

