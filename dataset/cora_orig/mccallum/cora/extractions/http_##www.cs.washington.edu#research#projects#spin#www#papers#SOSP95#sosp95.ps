URL: http://www.cs.washington.edu/research/projects/spin/www/papers/SOSP95/sosp95.ps
Refering-URL: http://velvet.cs.washington.edu/spin/docs/papers/index.html
Root-URL: 
Title: SPIN Operating System  
Author: Brian N. Bershad Stefan Savage Przemys law Pardyak Emin Gun Sirer Marc E. Fiuczynski David Becker Craig Chambers Susan Eggers 
Keyword: Extensibility, Safety and Performance  
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Note: in the  
Abstract: A version of this paper appeared in the Proceedings of the Fifteenth Symposium on Operating Systems Principles Abstract This paper describes the motivation, architecture and performance of SPIN, an extensible operating system. SPIN provides an extension infrastructure, together with a core set of extensible services, that allow applications to safely change the operating system's interface and implementation. Extensions allow an application to specialize the underlying operating system in order to achieve a particular level of performance and functionality. SPIN uses language and link-time mechanisms to inexpensively export fine-grained interfaces to operating system services. Extensions are written in a type safe language, and are dynamically linked into the operating system kernel. This approach offers extensions rapid access to system services, while protecting the operating system code executing within the kernel address space. SPIN and its extensions are written in Modula-3 and run on DEC Alpha workstations. 
Abstract-found: 1
Intro-found: 1
Reference: [Abrossimov et al. 89] <author> Abrossimov, V., Rozier, M., and Shapiro, M. </author> <title> Generic Virtual Memory Management for Operating System Kernels. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 123-136, </pages> <address> Litchfield Park, AZ, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: Unfortunately, applications often require substantial changes to a microkernel's implementation to compensate for limitations in interfaces [Lee et al. 94, Davis et al. 93, Wald-spurger & Weihl 94]. Although a microkernel's communication facilities provide the infrastructure for extending nearly any kernel service <ref> [Barrera 91, Abrossimov et al. 89, Forin et al. 91] </ref>, few have been so extended.
Reference: [Anderson et al. 91] <author> Anderson, T. E., Levy, H. M., Bershad, B. N., and Lazowska, E. D. </author> <title> The Interaction of Architecture and Operating System Design. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV), </booktitle> <pages> pages 108-120, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: The FORE cards use programmed I/O and can maximally deliver only about 53Mb/sec between a pair of hosts [Brustoloni & Bershad 93]. We avoid comparisons with operating systems running on different hardware as benchmarks tend to scale poorly for a variety of architectural reasons <ref> [Anderson et al. 91] </ref>. All measurements are taken while the operating systems run in single-user mode. 5.1 System components SPIN runs as a standalone kernel on DEC Alpha workstations. The system consists of five main components, sys, core, rt, lib and sal, that support different classes of service. <p> fault-based DEC OSF/1 Mach SPIN kernel user kernel user kernel user Operation layered integrated Fork-Join 198 1230 101 338 22 262 111 Ping-Pong 21 264 71 115 17 159 85 Table 3: Thread management overhead in microseconds. strategies has been the overhead of handling a page fault in an application <ref> [Thekkath & Levy 94, Anderson et al. 91] </ref>. There are two sources of this overhead. First, handling each fault in a user application requires crossing the user/kernel boundary several times. Second, conventional systems provide quite general exception interfaces that can perform many functions at once.
Reference: [Anderson et al. 92] <author> Anderson, T. E., Bershad, B. N., Lazowska, E. D., and Levy, H. M. </author> <title> Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: For example, Mach's user-level C-Threads implementation [Cooper & Draves 88] can have anomalous behavior because it is not well-integrated with kernel ser vices <ref> [Anderson et al. 92] </ref>. In contrast, scheduler activations, which are integrated with the kernel, have high communication overhead [Davis et al. 93]. In SPIN an application can provide its own thread package and scheduler that executes within the kernel. The thread package defines the application's execution model and synchronization constructs.
Reference: [Appel & Li 91] <author> Appel, W. and Li, K. </author> <title> Virtual Memory Primitives for User Programs. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV), </booktitle> <pages> pages 96-107, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: If it accesses an allocated, but unmapped virtual page, then the Translation.PageNotPresent event is raised. Implementors of higher level memory management abstractions can use these events to define services, such as demand paging, copy-on-write [Rashid et al. 87], distributed shared memory [Carter et al. 91], or concurrent garbage collection <ref> [Appel & Li 91] </ref>. The physical page service may at any time reclaim physical memory by raising the PhysAddr.Reclaim event. The interface allows the handler for this event to volunteer an alternative page, which may be of less importance than the candidate page. <p> The table shows that SPIN's extensible thread implementation does not incur a performance penalty when compared to non-extensible ones, even when integrated with kernel services. Virtual memory Applications can exploit the virtual memory fault path to extend system services <ref> [Appel & Li 91] </ref>. For example, concurrent and generational garbage collectors can use write faults to maintain invariants or collect reference information. <p> SPIN allows applications to define specialized fault handling extensions to avoid user/kernel boundary crossings and implement precisely the functionality that is required. Table 4 shows the time to execute several commonly referenced virtual memory benchmarks <ref> [Appel & Li 91, Engler et al. 95] </ref>. The line labeled Dirty in the table measures the time for an application to query the status of a particular virtual page. Neither DEC OSF/1 nor Mach provide this facility.
Reference: [Bala et al. 94] <author> Bala, K., Kaashoek, M. F., and Weihl, W. E. </author> <title> Software Prefetching and Caching for Translation Looka-side Buffers. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 243-253, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: Others have enabled control over relatively small objects, such as cache pages [Romer et al. 94] or TLB entries <ref> [Bala et al. 94] </ref>, entirely from the kernel. None have allowed for fast, fine-grained control over the physical and virtual memory resources required by applications. SPIN's virtual memory system provides such control, and is enabled by the system's low-overhead invocation and protection services.
Reference: [Balakrishnan et al. 95] <author> Balakrishnan, H., Seshan, S., Amir, E., and Katz., R. H. </author> <title> Improving TCP/IP Performance over Wireless Networks. </title> <booktitle> In Proceedings of the First ACM Conference on Mobile Computing and Networking, </booktitle> <month> November </month> <year> 1995. </year>
Reference-contexts: The maximum usable Ethernet and ATM bandwidths between a pair of hosts are roughly 9 Mb/sec and 53Mb/sec. Protocol forwarding SPIN's extension architecture can be used to provide protocol functionality not generally available in conventional systems. For example, some TCP redirection protocols <ref> [Balakrishnan et al. 95] </ref> that have otherwise required kernel modifications can be straightforwardly defined by an application as a SPIN extension. A forwarding protocol can also be used to load balance service requests across multiple servers.
Reference: [Barrera 91] <author> Barrera, J. S. </author> <title> A Fast Mach Network IPC Implementation. </title> <booktitle> In Proceedings of the Second USENIX Mach Symposium, </booktitle> <pages> pages 1-11, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: Unfortunately, applications often require substantial changes to a microkernel's implementation to compensate for limitations in interfaces [Lee et al. 94, Davis et al. 93, Wald-spurger & Weihl 94]. Although a microkernel's communication facilities provide the infrastructure for extending nearly any kernel service <ref> [Barrera 91, Abrossimov et al. 89, Forin et al. 91] </ref>, few have been so extended.
Reference: [Bartlett 88] <author> Bartlett, J. F. </author> <title> Compacting Garbage Collection with Ambiguous Roots. </title> <type> Technical Report WRL-TR-88-2, </type> <institution> Digital Equipment Corporation Western Research Labs, </institution> <month> Febru-ary </month> <year> 1988. </year>
Reference-contexts: As previously mentioned, memory management schemes that allow extensions to return objects to the system heap are unsafe because a rogue client can violate the type system by retaining a reference to a freed object. SPIN uses a trace-based, mostly-copying, garbage collector <ref> [Bartlett 88] </ref> to safely reclaim memory resources. The collector serves as a safety net for untrusted extensions, and ensures that resources released by an extension, either through inaction or as a result of premature termination, are eventually reclaimed.
Reference: [Berners-Lee et al. 94] <author> Berners-Lee, T., Cailliau, R., Luotonen, A., Nielsen, H. F., and Secretr, A. </author> <title> The World-Wide Web. </title> <journal> Communications of the ACM, </journal> <volume> 37(8) </volume> <pages> 76-82, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: The UDP and TCP extensions support the Internet protocols. 2 The Forward extension provides transparent UDP/IP and TCP/IP forwarding for packets arriving on a specific port. Finally, the HTTP extension implements the HyperText Transport Protocol <ref> [Berners-Lee et al. 94] </ref> directly within the kernel, enabling a server to respond quickly to HTTP requests by splicing together the protocol stack and the local file system.
Reference: [Bershad 93] <author> Bershad, B. N. </author> <title> Practical Considerations for Non-Blocking Concurrent Objects. </title> <booktitle> In Proceedings of the Thirteenth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 264-274, </pages> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1993. </year>
Reference: [Bershad et al. 90] <author> Bershad, B. N., Anderson, T. E., Lazowska, E. D., and Levy, H. M. </author> <title> Lightweight Remote Procedure Call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 37-55, </pages> <month> February </month> <year> 1990. </year>
Reference: [Bershad et al. 92a] <author> Bershad, B. N., Draves, R. P., and Forin, A. </author> <title> Using Microbenchmarks to Evaluate System Performance. </title> <booktitle> In Proceedings of the Third Workshop on Workstation Operating Systems, </booktitle> <pages> pages 148-153, </pages> <address> Key Biscayne, FL, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: They define the bounds of system performance and provide a framework for understanding larger operations. Times presented in this section, measured with the Alpha's internal cycle counter, are the average of a large number of iterations, and may therefore be overly optimistic regarding cache effects <ref> [Bershad et al. 92a] </ref>. Protected communication In a conventional operating system, applications, services and extensions communicate using two protected mechanisms: system calls and cross-address space calls. The first enables applications and kernel services to interact. The second enables interaction between applications and services that are not part of the kernel.
Reference: [Bershad et al. 92b] <author> Bershad, B. N., Redell, D. D., and Ellis, J. R. </author> <title> Fast Mutual Exclusion for Uniprocessors. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <pages> pages 223-233, </pages> <address> Boston, MA, </address> <month> October </month> <year> 1992. </year>
Reference: [Black et al. 92] <editor> Black, D. L. et al. </editor> <booktitle> Microkernel Operating System Architecture and Mach. In Proceedings of the USENIX Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 11-30, </pages> <address> Seattle, WA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Unlike other operating systems based on capabilities, which rely on special-purpose hardware [Carter et al. 94], virtual memory mechanisms [Wulf et al. 81], probabilistic protection [Engler et al. 94], or protected message channels <ref> [Black et al. 92] </ref>, SPIN implements capabilities directly using pointers, which are supported by the language. A pointer is a reference to a block of memory whose type is declared within an interface. Figure 1 demonstrates the definition and use of interfaces and capabilities (pointers) in SPIN.
Reference: [Bricker et al. 91] <author> Bricker, A., Gien, M., Guillemont, M., Lip-kis, J., Orr, D., and Rozier, M. </author> <title> A New Look at Micro-kernel-based UNIX Operating Systems: Lessons in Performance and Compatibility. </title> <booktitle> In Proceedings of the EurOpen Spring'91 Conference, </booktitle> <address> Tromsoe, Norway, </address> <month> May </month> <year> 1991. </year>
Reference: [Brockschmidt 94] <author> Brockschmidt, K. </author> <title> Inside OLE 2. </title> <publisher> Microsoft Press, </publisher> <year> 1994. </year>
Reference-contexts: A module that exports an interface explicitly creates a domain for its interface, and exports the domain through an in-kernel nameserver. The exported name of the interface, which can be specified within the interface, is used to coordinate the export and import as in many RPC systems <ref> [Schroeder & Burrows 90, Brockschmidt 94] </ref>. The constant Console.InterfaceName in Figure 1 defines a name that exporters and importers can use to uniquely identify a particular version of a service. Some interfaces, such as those for devices, restrict access at the time of the import.
Reference: [Brustoloni & Bershad 93] <author> Brustoloni, J. C. and Bershad, B. N. </author> <title> Simple Protocol Processing for High-Bandwidth Low-Latency Networking. </title> <type> Technical Report CMU-CS-93-132, </type> <institution> Carnegie Mellon University, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: The FORE cards use programmed I/O and can maximally deliver only about 53Mb/sec between a pair of hosts <ref> [Brustoloni & Bershad 93] </ref>. We avoid comparisons with operating systems running on different hardware as benchmarks tend to scale poorly for a variety of architectural reasons [Anderson et al. 91].
Reference: [Cao et al. 94] <author> Cao, P., Felten, E. W., and Li, K. </author> <title> Implementation and Performance of Application-Controlled File Caching. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 165-177, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year>
Reference: [Carter et al. 91] <author> Carter, J. B., Bennett, J. K., and Zwaenepoel, W. </author> <title> Implementation and Performance of Munin. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 152-64, </pages> <address> Pacific Grove, CA, </address> <month> Oc-tober </month> <year> 1991. </year>
Reference-contexts: If it accesses an allocated, but unmapped virtual page, then the Translation.PageNotPresent event is raised. Implementors of higher level memory management abstractions can use these events to define services, such as demand paging, copy-on-write [Rashid et al. 87], distributed shared memory <ref> [Carter et al. 91] </ref>, or concurrent garbage collection [Appel & Li 91]. The physical page service may at any time reclaim physical memory by raising the PhysAddr.Reclaim event.
Reference: [Carter et al. 94] <author> Carter, N. P., Keckler, S. W., and Dally, W. J. </author> <title> Hardware Support for Fast Capability-Based Addressing. </title> <booktitle> In Proceedings of the Sixth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-VI), </booktitle> <pages> pages 319-327, </pages> <address> San Jose, CA, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: Interfaces and collections of interfaces are protected to allow different extensions to have different views on the set of available services. Unlike other operating systems based on capabilities, which rely on special-purpose hardware <ref> [Carter et al. 94] </ref>, virtual memory mechanisms [Wulf et al. 81], probabilistic protection [Engler et al. 94], or protected message channels [Black et al. 92], SPIN implements capabilities directly using pointers, which are supported by the language.
Reference: [Chankhunthod et al. 95] <author> Chankhunthod, A., Danzig, P., Neer-daels, C., Schwartz, M., and Worrell, K. </author> <title> A Hierarchical Internet Object Cache. </title> <type> Technical Report CU-CS-766-95, </type> <institution> DCS University of Colorado, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: Another application that can benefit from SPIN's architecture is a web server. To service requests quickly, a web server should cache recently accessed objects, not cache large objects that are infrequently accessed <ref> [Chankhunthod et al. 95] </ref>, and avoid double buffering with other caching agents [Stonebraker 81]. A server that does not itself cache but is built on top of a conventional caching file system avoids the double buffering problem, but is unable to control the caching policy.
Reference: [Chen & Bershad 93] <author> Chen, J. B. and Bershad, B. N. </author> <title> The Impact of Operating System Structure on Memory System Performance. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 120-133, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference: [Cheriton & Duda 94] <author> Cheriton, D. R. and Duda, K. J. </author> <title> A Caching Model of Operating System Kernel Functionality. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 179-194, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year>
Reference: [Cheriton & Zwaenepoel 83] <author> Cheriton, D. R. and Zwaenepoel, W. </author> <title> The Distributed V Kernel and its Performance for Disk-less Workstations. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 129-140, </pages> <address> Bretton Woods, NH, </address> <month> October </month> <year> 1983. </year>
Reference: [Colwell 85] <author> Colwell, R. </author> <title> The Performance Effects of Func--tional Migration and Architectural Complexity in Object-Oriented Systems. </title> <type> Technical Report CMU-CS-85-159, </type> <institution> Carnegie Mellon University, </institution> <month> August </month> <year> 1985. </year>
Reference-contexts: As a point of comparison, the Intel 432 [Int 81], which provided hardware support for protected cross-domain transfer, had a cross-domain communication overhead on the order of about 10 procedure call times <ref> [Colwell 85] </ref>, and was generally considered unacceptable. Some systems rely on "little languages" to safely extend the operating system interface through the use of interpreted code that runs in the kernel [Lee et al. 94, Mogul et al. 87, Yuhara et al. 94]. These systems suffer from three problems.
Reference: [Cooper & Draves 88] <author> Cooper, E. C. and Draves, R. P. </author> <title> C Threads. </title> <type> Technical Report CMU-CS-88-154, </type> <institution> Carnegie Mel-lon University, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: User-level thread management systems have addressed this mismatch [Wulf et al. 81, Cooper & Draves 88, Marsh et al. 91, Anderson et al. 92], but only partially. For example, Mach's user-level C-Threads implementation <ref> [Cooper & Draves 88] </ref> can have anomalous behavior because it is not well-integrated with kernel ser vices [Anderson et al. 92]. In contrast, scheduler activations, which are integrated with the kernel, have high communication overhead [Davis et al. 93]. <p> In the current implementation, the global scheduler implements a round-robin, preemptive, priority policy. We have used the strand interface to implement as kernel extensions a variety of thread management interfaces including DEC OSF/1 kernel threads [Dig 93], C-Threads <ref> [Cooper & Draves 88] </ref>, and Modula-3 threads. The implementations of these interfaces are built directly from strands and not layered on top of others. The interface supporting DEC OSF/1 kernel threads allows us to incorporate the vendor's device drivers directly into the kernel.
Reference: [Cooper et al. 91] <author> Cooper, E., Harper, R., and Lee, P. </author> <title> The Fox Project: Advanced Development of Systems Software. </title> <type> Technical Report CMU-CS-91-178, </type> <institution> Carnegie Mellon University, </institution> <month> August </month> <year> 1991. </year>
Reference: [Davis et al. 93] <author> Davis, P.-B., McNamee, D., Vaswani, R., and Lazowska, E. </author> <title> Adding Scheduler Activations to Mach 3.0. </title> <booktitle> In Proceedings of the Third USENIX Mach Symposium, </booktitle> <pages> pages 119-136, </pages> <address> Santa Fe, NM, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: For example, Mach's user-level C-Threads implementation [Cooper & Draves 88] can have anomalous behavior because it is not well-integrated with kernel ser vices [Anderson et al. 92]. In contrast, scheduler activations, which are integrated with the kernel, have high communication overhead <ref> [Davis et al. 93] </ref>. In SPIN an application can provide its own thread package and scheduler that executes within the kernel. The thread package defines the application's execution model and synchronization constructs. The scheduler controls the multiplexing of the processor across multiple threads.
Reference: [Dig 93] <author> Digital Equipment Corporation. </author> <title> DEC OSF/1 Writing Device Drivers: </title> <booktitle> Advanced Topics, </booktitle> <year> 1993. </year>
Reference-contexts: An object file is safe if it is unknown to the kernel but has been signed by the Modula-3 compiler, or if the kernel can otherwise assert the object file to be safe. For example, SPIN's lowest level device interface is identical to the DEC OSF/1 driver interface <ref> [Dig 93] </ref>, allowing us to dynamically link vendor drivers into the kernel. Although the drivers are written in C, the kernel asserts their safety. <p> In the current implementation, the global scheduler implements a round-robin, preemptive, priority policy. We have used the strand interface to implement as kernel extensions a variety of thread management interfaces including DEC OSF/1 kernel threads <ref> [Dig 93] </ref>, C-Threads [Cooper & Draves 88], and Modula-3 threads. The implementations of these interfaces are built directly from strands and not layered on top of others. The interface supporting DEC OSF/1 kernel threads allows us to incorporate the vendor's device drivers directly into the kernel.
Reference: [Draves 93] <author> Draves, R. </author> <title> The Case for Run-Time Replaceable Kernel Modules. </title> <booktitle> In Proceedings of the Fourth Workshop on Workstation Operating Systems, </booktitle> <pages> pages 160-164, </pages> <address> Napa, CA, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: While individual applications have benefited from this level of freedom, the lack of safe interfaces to either operating system services or operating system extension services has created system configuration "chaos" <ref> [Draves 93] </ref>. 2.1 Related work Previous efforts to build extensible systems have demonstrated the three-way tension between extensibility, safety and performance. For example, Hydra [Wulf et al. 81] defined an infrastructure that allowed applications to manage resources through multi-level policies.
Reference: [Draves 94] <author> Draves, R. P. </author> <title> Control Transfer in Operating System Kernels. </title> <type> Technical Report CMU-CS-94-142, </type> <institution> Carnegie Mel-lon University, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: The third line in the table shows the time to perform a protected, cross-address space procedure call. DEC OSF/1 supports cross-address space procedure call using sockets and SUN RPC. Mach provides an optimized path for cross-address space communication using messages <ref> [Draves 94] </ref>. SPIN's cross-address space procedure call is implemented as an extension that uses system calls to transfer control in and out of the kernel and cross-domain procedure calls within the kernel to transfer control between address spaces.
Reference: [Draves et al. 91] <author> Draves, R. P., Bershad, B. N., Rashid, R. F., and Dean, R. W. </author> <title> Using Continuations to Implement Thread Management and Communication in Operating Systems. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 122-136, </pages> <address> Pacific Grove, CA, </address> <month> October </month> <year> 1991. </year>
Reference: [Engler & Kaashoek 95] <author> Engler, D. and Kaashoek, M. F. </author> <title> Exterminate All Operating System Abstractions. </title> <booktitle> In Proceedings of the Fifth Workshop on Hot Topics in Operating Systems, </booktitle> <pages> pages 78-83, </pages> <address> Orcas Island, WA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Aegis [Engler et al. 95] is an operating system that relies on efficient trap redirection to export hardware services, such as exception handling and TLB management, directly to applications. The system itself defines no abstractions beyond those minimally provided by the hardware <ref> [Engler & Kaashoek 95] </ref>. Instead, conventional operating system services, such as virtual memory and scheduling, are implemented as libraries executing in an application's address space. System service code executing in a library can be changed by the application according to its needs.
Reference: [Engler & Proebsting 94] <author> Engler, D. R. and Proebsting, T. A. </author> <title> DCG: An Efficient, Retargettable Dynamic Code Generation System. </title> <booktitle> In Proceedings of the Sixth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-VI), </booktitle> <pages> pages 263-272, </pages> <address> San Jose, CA, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: The dispatcher exploits this similarity to optimize event raise as a direct procedure call where there is only one handler for a given event. Otherwise, the dispatcher uses dynamic code generation <ref> [Engler & Proebsting 94] </ref> to construct optimized call paths from the raiser to the handlers. The primary right to handle an event is restricted to the default implementation module for the event, which is the module that statically exports the procedure named by the event.
Reference: [Engler et al. 94] <author> Engler, D., Kaashoek, M. F., and O'Toole, J. </author> <title> The Operating System Kernel as a Secure Programmable Machine. </title> <booktitle> In Proceedings of the 1994 ACM European SIGOPS Workshop, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: Interfaces and collections of interfaces are protected to allow different extensions to have different views on the set of available services. Unlike other operating systems based on capabilities, which rely on special-purpose hardware [Carter et al. 94], virtual memory mechanisms [Wulf et al. 81], probabilistic protection <ref> [Engler et al. 94] </ref>, or protected message channels [Black et al. 92], SPIN implements capabilities directly using pointers, which are supported by the language. A pointer is a reference to a block of memory whose type is declared within an interface.
Reference: [Engler et al. 95] <author> Engler, D. R., Kaashoek, M. F., and Jr, J. O. Exokernel: </author> <title> An Operating System Architecture for Application-Level Resource Management. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <address> Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Otherwise, protected interaction between system components, which occurs frequently in a system with fine-grained extensions, can be a limiting performance factor. Although the performance of cross-domain communication has improved substantially in recent years <ref> [Hamil ton & Kougiouris 93, Hildebrand 92, Engler et al. 95] </ref>, it still does not approach that of a procedure call, encouraging the construction of monolithic, non-extensible systems. <p> In these systems the right to define extensions is restricted because any extension can bring down the entire system; application-specific extensibility is not possible. Several projects <ref> [Lucco 94, Engler et al. 95, Small & Seltzer 94] </ref> are exploring the use of software fault isolation [Wahbe et al. 93] to safely link application code, written in any language, into the kernel's virtual address space. <p> In addition, software fault isolation is only a protection mechanism and does not define an extension model or the service interfaces that determine the degree to which a system can be extended. Aegis <ref> [Engler et al. 95] </ref> is an operating system that relies on efficient trap redirection to export hardware services, such as exception handling and TLB management, directly to applications. The system itself defines no abstractions beyond those minimally provided by the hardware [Engler & Kaashoek 95]. <p> SPIN allows applications to define specialized fault handling extensions to avoid user/kernel boundary crossings and implement precisely the functionality that is required. Table 4 shows the time to execute several commonly referenced virtual memory benchmarks <ref> [Appel & Li 91, Engler et al. 95] </ref>. The line labeled Dirty in the table measures the time for an application to query the status of a particular virtual page. Neither DEC OSF/1 nor Mach provide this facility.
Reference: [Fall & Pasquale 94] <author> Fall, K. and Pasquale, J. </author> <title> Improving Continuous-Media Playback Performance with In-Kernel Data Paths. </title> <booktitle> In Proceedings of the First IEEE International Conference on Multimedia Computing and Systems, </booktitle> <pages> pages 100-109, </pages> <address> Boston, MA, </address> <month> May </month> <year> 1994. </year>
Reference: [Felten 92] <author> Felten, E. W. </author> <title> The Case for Application-Specific Communication Protocols. </title> <booktitle> In Intel Supercomputer Systems Technology Focus Conference, </booktitle> <pages> pages 171-181, </pages> <month> April </month> <year> 1992. </year>
Reference: [Fiuczynski & Bershad 96] <author> Fiuczynski, M. and Bershad, B. </author> <title> An Extensible Protocol Architecture for Application-Specific Networking. </title> <booktitle> In Proceedings of the 1996 Winter USENIX Conference, </booktitle> <address> San Diego, CA, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Neither DEC OSF/1 nor Mach provide an interface for querying the internal state of a page frame. 5.3 Networking We have used SPIN's extension architecture to implement a set of network protocol stacks for Ethernet and ATM networks <ref> [Fiuczynski & Bershad 96] </ref>. Figure 5 illustrates the structure of the protocol stacks, which are similar to the x-kernel's [Hutchinson et al. 89] except that SPIN permits user code to be dynamically placed within the stack.
Reference: [Forin et al. 91] <author> Forin, A., Golub, D., and Bershad, B. N. </author> <title> An I/O System for Mach 3.0. </title> <booktitle> In Proceedings of the Second USENIX Mach Symposium, </booktitle> <pages> pages 163-176, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: Unfortunately, applications often require substantial changes to a microkernel's implementation to compensate for limitations in interfaces [Lee et al. 94, Davis et al. 93, Wald-spurger & Weihl 94]. Although a microkernel's communication facilities provide the infrastructure for extending nearly any kernel service <ref> [Barrera 91, Abrossimov et al. 89, Forin et al. 91] </ref>, few have been so extended.
Reference: [Geschke et al. 77] <author> Geschke, C., Morris, J., and Satterthwaite, E. </author> <title> Early Experiences with Mesa. </title> <journal> Communications of the ACM, </journal> <volume> 20(8) </volume> <pages> 540-553, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: Several systems [Cooper et al. 91, Redell et al. 80, Mossenbock 94, Organick 73] like SPIN, have relied on language features to extend operating system services. Pilot, for instance, was a single-address space system that ran programs written in Mesa <ref> [Geschke et al. 77] </ref>, an ancestor of Modula-3. In general, systems such as Pilot have depended on the language for all protection in the system, not just for the protection of the operating system and its extensions.
Reference: [Golub et al. 90] <author> Golub, D., Dean, R., Forin, A., and Rashid, R. </author> <title> Unix as an Application Program. </title> <booktitle> In Proceedings of the 1990 Summer USENIX Conference, </booktitle> <pages> pages 87-95, </pages> <month> June </month> <year> 1990. </year>
Reference: [Hamilton & Kougiouris 93] <author> Hamilton, G. and Kougiouris, P. </author> <title> The Spring Nucleus: A Microkernel for Objects. </title> <booktitle> In Proceedings of the 1993 Summer USENIX Conference, </booktitle> <pages> pages 147-159, </pages> <address> Cincinnati, OH, </address> <month> June </month> <year> 1993. </year>
Reference: [Harty & Cheriton 91] <author> Harty, K. and Cheriton, D. R. </author> <title> Application-Controlled Physical Memory using External Page-Cache Management. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV), </booktitle> <pages> pages 187-197, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Some of these interfaces have made it possible to manipulate large objects, such as entire address spaces [Young et al. 87, Khalidi & Nelson 93], or to direct expensive operations, for example page-out <ref> [Harty & Cheriton 91, McNamee & Armstrong 90] </ref>, entirely from user level. Others have enabled control over relatively small objects, such as cache pages [Romer et al. 94] or TLB entries [Bala et al. 94], entirely from the kernel.
Reference: [Heidemann & Popek 94] <author> Heidemann, J. and Popek, G. </author> <title> FileSystem Development with Stackable Layers. </title> <journal> Communications of the ACM, </journal> <volume> 12(1) </volume> <pages> 58-89, </pages> <month> February </month> <year> 1994. </year>
Reference: [Hildebrand 92] <author> Hildebrand, D. </author> <title> An Architectural Overview of QNX. </title> <booktitle> In Proceedings of the USENIX Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 113-126, </pages> <address> Seattle, WA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Otherwise, protected interaction between system components, which occurs frequently in a system with fine-grained extensions, can be a limiting performance factor. Although the performance of cross-domain communication has improved substantially in recent years <ref> [Hamil ton & Kougiouris 93, Hildebrand 92, Engler et al. 95] </ref>, it still does not approach that of a procedure call, encouraging the construction of monolithic, non-extensible systems.
Reference: [Hutchinson et al. 89] <author> Hutchinson, N. C., Peterson, L., Abbott, M. B., and O'Malley, S. </author> <title> RPC in x-kernel: Evaluating New Design Techniques. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 91-101, </pages> <address> Litchfield Park, AZ, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: Figure 5 illustrates the structure of the protocol stacks, which are similar to the x-kernel's <ref> [Hutchinson et al. 89] </ref> except that SPIN permits user code to be dynamically placed within the stack. Each incoming packet is "pushed" through the protocol graph by events and "pulled" by handlers.
Reference: [Int 81] <author> Intel Corporation. </author> <title> Introduction to the iAPX 432 Architecture, </title> <year> 1981. </year>
Reference-contexts: For example, the L3 microkernel, even with its aggressive design, has a protected procedure call implementation with overhead of nearly 100 procedure call times [Liedtke 92, Liedtke 93, Int 90]. As a point of comparison, the Intel 432 <ref> [Int 81] </ref>, which provided hardware support for protected cross-domain transfer, had a cross-domain communication overhead on the order of about 10 procedure call times [Colwell 85], and was generally considered unacceptable.
Reference: [Int 90] <author> Intel Corporation. </author> <title> i486 Microprocessor Programmer's Reference Manual, </title> <year> 1990. </year>
Reference-contexts: For example, the L3 microkernel, even with its aggressive design, has a protected procedure call implementation with overhead of nearly 100 procedure call times <ref> [Liedtke 92, Liedtke 93, Int 90] </ref>. As a point of comparison, the Intel 432 [Int 81], which provided hardware support for protected cross-domain transfer, had a cross-domain communication overhead on the order of about 10 procedure call times [Colwell 85], and was generally considered unacceptable.
Reference: [Khalidi & Nelson 93] <author> Khalidi, Y. A. and Nelson, M. </author> <title> An Implementation of UNIX on an Object-Oriented Operating System. </title> <booktitle> In Proceedings of the 1993 Winter USENIX Conference, </booktitle> <pages> pages 469-480, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Other systems have demonstrated significant performance improvements from specialized or "tuned" memory management policies that are accessible through interfaces exposed by the memory management system. Some of these interfaces have made it possible to manipulate large objects, such as entire address spaces <ref> [Young et al. 87, Khalidi & Nelson 93] </ref>, or to direct expensive operations, for example page-out [Harty & Cheriton 91, McNamee & Armstrong 90], entirely from user level.
Reference: [Lazowska et al. 81] <author> Lazowska, E. D., Levy, H. M., Almes, G. T., Fischer, M., Fowler, R., and Vestal, S. </author> <title> The Architecture of the Eden System. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 148| 159, </pages> <month> December </month> <year> 1981. </year>
Reference-contexts: For example, a protection model based on address spaces ensures that a process can only access memory within a particular range of virtual addresses. Address spaces, though, are frequently inadequate for the fine-grained protection and management of resources, being expensive to create and slow to access <ref> [Lazowska et al. 81] </ref>. Capabilities All kernel resources in SPIN are referenced by capabilities. A capability is an unforgeable reference to a resource which can be a system object, an interface, or a collection of interfaces.
Reference: [Lee et al. 94] <author> Lee, C. H., Chen, M. C., and Chang, R. C. </author> <title> HiPEC: High Performance External Virtual Memory Caching. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 153-164, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year>
Reference: [Liedtke 92] <author> Liedtke, J. </author> <title> Fast Thread Management and Communication Without Continuations. </title> <booktitle> In Proceedings of the USENIX Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 213-221, </pages> <address> Seattle, WA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: For example, the L3 microkernel, even with its aggressive design, has a protected procedure call implementation with overhead of nearly 100 procedure call times <ref> [Liedtke 92, Liedtke 93, Int 90] </ref>. As a point of comparison, the Intel 432 [Int 81], which provided hardware support for protected cross-domain transfer, had a cross-domain communication overhead on the order of about 10 procedure call times [Colwell 85], and was generally considered unacceptable.
Reference: [Liedtke 93] <author> Liedtke, J. </author> <title> Improving IPC by Kernel Design. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 175-188, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: For example, the L3 microkernel, even with its aggressive design, has a protected procedure call implementation with overhead of nearly 100 procedure call times <ref> [Liedtke 92, Liedtke 93, Int 90] </ref>. As a point of comparison, the Intel 432 [Int 81], which provided hardware support for protected cross-domain transfer, had a cross-domain communication overhead on the order of about 10 procedure call times [Colwell 85], and was generally considered unacceptable.
Reference: [Lucco 94] <author> Lucco, S. </author> <title> High-Performance Microkernel Systems. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> page 199, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: In these systems the right to define extensions is restricted because any extension can bring down the entire system; application-specific extensibility is not possible. Several projects <ref> [Lucco 94, Engler et al. 95, Small & Seltzer 94] </ref> are exploring the use of software fault isolation [Wahbe et al. 93] to safely link application code, written in any language, into the kernel's virtual address space.
Reference: [Maeda & Bershad 93] <author> Maeda, C. and Bershad, B. N. </author> <title> Protocol Service Decomposition for High-Performance Networking. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 244-255, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference: [Marsh et al. 91] <author> Marsh, B., Scott, M., LeBlanc, T., and Markatos, E. </author> <title> First-Class User-Level Threads. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 110-121, </pages> <address> Pacific Grove, CA, </address> <month> Octo-ber </month> <year> 1991. </year>
Reference: [McNamee & Armstrong 90] <author> McNamee, D. and Armstrong, K. </author> <title> Extending the Mach External Pager Interface to Accommodate User-Level Page Replacement Policies. </title> <booktitle> In Proceedings of the USENIX Mach Symposium, </booktitle> <pages> pages 17-29, </pages> <address> Burling-ton, VT, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: Some of these interfaces have made it possible to manipulate large objects, such as entire address spaces [Young et al. 87, Khalidi & Nelson 93], or to direct expensive operations, for example page-out <ref> [Harty & Cheriton 91, McNamee & Armstrong 90] </ref>, entirely from user level. Others have enabled control over relatively small objects, such as cache pages [Romer et al. 94] or TLB entries [Bala et al. 94], entirely from the kernel.
Reference: [Mogul et al. 87] <author> Mogul, J., Rashid, R., and Accetta, M. </author> <title> The Packet Filter: An Efficient Mechanism for User-level Network Code. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year>
Reference: [Mossenbock 94] <author> Mossenbock, H. </author> <title> Extensibility in the Oberon System. </title> <journal> Nordic Journal of Computing, </journal> <volume> 1(1) </volume> <pages> 77-93, </pages> <month> Febru-ary </month> <year> 1994. </year>
Reference: [Mullender et al. 90] <author> Mullender, S. J., Rossum, G. V., Tanen-baum, A. S., Renesse, R. V., and van Staveren, H. </author> <note> Amoeba </note>
References-found: 61

