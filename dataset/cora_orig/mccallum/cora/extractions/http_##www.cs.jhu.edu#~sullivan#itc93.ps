URL: http://www.cs.jhu.edu/~sullivan/itc93.ps
Refering-URL: http://www.cs.jhu.edu/~sullivan/ftdownload.html
Root-URL: http://www.cs.jhu.edu
Title: Certification Trails and Software Design for Testability  
Author: Gregory F. Sullivan Dwight S. Wilson Gerald M. Masson 
Address: Baltimore, MD 21218 Baltimore, MD 21218 Baltimore, MD 21218  
Affiliation: Dept. of Computer Science Dept. of Computer Science Dept. of Computer Science Johns Hopkins University Johns Hopkins University Johns Hopkins University  
Abstract: This paper investigates design techniques which may be applied to make program testing easier. We present methods for modifying a program to generate additional data which we refer to as a certification trail. This additional data is designed to allow the program output to be checked more quickly and effectively. Certification trails [14, 16] have heretofore been described primarily from a theoretical perspective. In this paper, we report on a comprehensive attempt to assess experimentally the performance and overall value of the certification trail method. The method has been applied to nine fundamental, well-known algorithms for the following problems: convex hull, sorting, huffman tree, shortest path, closest pair, line segment intersection, longest increasing subsequence, skyline, and voronoi diagram. Run-time performance data for each of these problems is given, and selected problems are described in more detail. Our results indicate that there are many cases in which certification trails allow for significantly faster overall program execution time than a 2-version programming approach, and also give further evidence of the breadth of applicability of this method. Keywords: Software design for testability, software fault detection, certification trails, error monitoring, design diversity, data structures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Avizienis, A., </author> <title> "The N-version approach to fault tolerant software," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 11, </volume> <pages> pp. 1491-1501, </pages> <month> Dec., </month> <year> 1985. </year>
Reference-contexts: algorithms considered reveal many cases in which an approach using certification trails allows for significantly faster overall program execution time than a 2-version programming approach. 2 Introduction to Certification Trails First, let us consider a basic method which is used to perform testing to detect software faults called N-version programming <ref> [1, 2] </ref>. This method utilizes N teams of programmers, each independently implementing separate programs based on a problem specification. The programs are executed on the same input and the outputs are compared. Errors caused by software faults are detected whenever the independently written programs do not generate coincident errors. <p> Here we are concerned exclusively with the Huffman tree. See [7] for information about the coding application. Definition 4.4 The Huffman tree problem is the following: Given a sequence of frequencies (positive integers) f <ref> [1] </ref>; f [2]; : : : ; f [n], construct a tree with n leaves and with one frequency value assigned to each leaf so that the weighted path length is minimized.
Reference: [2] <author> Chen, L., and Avizienis A., </author> <title> "N-version programming: a fault tolerant approach to reliability of software operation," 1978 Fault Tol. </title> <booktitle> Comp. Symp., </booktitle> <pages> pp. 3-9, </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1978. </year>
Reference-contexts: algorithms considered reveal many cases in which an approach using certification trails allows for significantly faster overall program execution time than a 2-version programming approach. 2 Introduction to Certification Trails First, let us consider a basic method which is used to perform testing to detect software faults called N-version programming <ref> [1, 2] </ref>. This method utilizes N teams of programmers, each independently implementing separate programs based on a problem specification. The programs are executed on the same input and the outputs are compared. Errors caused by software faults are detected whenever the independently written programs do not generate coincident errors. <p> Here we are concerned exclusively with the Huffman tree. See [7] for information about the coding application. Definition 4.4 The Huffman tree problem is the following: Given a sequence of frequencies (positive integers) f [1]; f <ref> [2] </ref>; : : : ; f [n], construct a tree with n leaves and with one frequency value assigned to each leaf so that the weighted path length is minimized.
Reference: [3] <author> Dijkstra, E. W., </author> <title> "A note on two problems in connexion with graphs," </title> <journal> Numer. Math. </journal> <volume> 1, </volume> <pages> pp. 269-271, </pages> <year> 1959. </year>
Reference-contexts: Our approach is applied to a variant of the Dijkstra algorithm <ref> [3] </ref> as explicated in [17]. We are concerned with the single source problem, i.e., given a graph and a vertex s, find the shortest path from s to v for every vertex v.
Reference: [4] <author> Fortune, S. </author> <title> "A Sweepline Algorithm for Voronoi Diagrams," </title> <journal> Algorithmica, </journal> <pages> pp. 153-174, 2, </pages> <year> 1987. </year>
Reference: [5] <author> Fredman, M. L., and Willard, D. E., </author> <title> "Trans-dichotomous algorithms for minimum spanning trees and shortest paths," </title> <booktitle> Proc. 31st IEEE Foundations of Computer Science, </booktitle> <pages> pp. </pages> <year> 719-725,1990. </year>
Reference-contexts: We are concerned with the single source problem, i.e., given a graph and a vertex s, find the shortest path from s to v for every vertex v. The algorithm for this problem which has the fastest asymptotic time complexity uses fusion trees and is given in <ref> [5] </ref>. This algorithm however appears to have a large constant of proportionality and therefore we do not use it. We use the techniques just discussed to implement the certification trail for this problem. A full description may be found in a technical report [15]. Size Basic Prim. Exec.
Reference: [6] <author> Graham, R. L., </author> <title> "An efficient algorithm for determining the convex hull of a planar set", </title> <journal> Information Processing Letters, </journal> <pages> pp. 132-133, 1, </pages> <year> 1972. </year>
Reference-contexts: Integers were chosen uniformly from interval [1::1; 000; 000; 000]. 4.2 Convex Hull Example The convex hull problem is fundamental in the field of computational geometry. Our certification trail solution is based on a convex hull algorithm due to Graham <ref> [6] </ref> called Graham's Scan. For basic definitions in computational geometry see the text of Preparata and Shamos [11]. For simplicity in the discussion which follows we will assume the points are in general position, e.g., no three points are collinear. It is not hard to remove this restriction.
Reference: [7] <author> Huffman, D., </author> <title> "A method for the construction of minimum redundancy codes", </title> <booktitle> Proc. IRE, </booktitle> <pages> pp 1098-1101, 40, </pages> <year> 1952. </year>
Reference-contexts: Exec. Sav. Trail) 100,1000 0.04 0.05 0.02 12.50 2.00 500,5000 0.31 0.33 0.11 29.03 2.82 2000,20000 1.58 1.67 0.45 32.91 3.51 Table 3: Shortest Path 4.6 Huffman Tree Example This is another classic algorithmic problem and one of the original solutions was found by Huffman <ref> [7] </ref>. It has been used extensively to perform data compression through the design and use of so called Huffman codes. These codes are prefix codes which are based on the Huffman tree and which yield excellent data compres-sion ratios. <p> The tree structure and the code design are based on the frequencies of individual characters in the data to be compressed. Here we are concerned exclusively with the Huffman tree. See <ref> [7] </ref> for information about the coding application.
Reference: [8] <author> Johnson, B., </author> <title> Design and analysis of fault tolerant digital systems Addison-Wesley, </title> <address> Reading, MA, </address> <year> 1989. </year>
Reference: [9] <author> Manber U., </author> <title> Introduction to Algorithms Addison-Wesley, </title> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: Space permits only a brief description of these problems, rather than a full exposition of the certification trail techniques used. The "Manhattan skyline" problem is: Given a set of rectangles with collinear bottom edges, compute the polygonal outline of the union of the rectangles <ref> [9] </ref>. The Voronoi diagram is a fundamental concept in computational geometry [11].
Reference: [10] <author> Nievergelt, J., and Hinrichs, K. H., </author> <title> Algorithms and Data Structures With Applications to Graphics and Geometry, </title> <publisher> Prentice Hall, </publisher> <address> NJ 1993 </address>
Reference: [11] <author> Preparata F. P., and Shamos M. I., </author> <title> Computational geometry, </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1985. </year>
Reference-contexts: Our certification trail solution is based on a convex hull algorithm due to Graham [6] called Graham's Scan. For basic definitions in computational geometry see the text of Preparata and Shamos <ref> [11] </ref>. For simplicity in the discussion which follows we will assume the points are in general position, e.g., no three points are collinear. It is not hard to remove this restriction. <p> Note that generation of the certification trail does not affect the output of the Graham Scan algorithm. Thus the condition on F 1 (d) is satisfied by the correctness of the Graham Scan algorithm, the proof of which is well known <ref> [11] </ref>. To show that F 2 (d; t) = s, note that a copy of s is contained on the trail t. Our description of F 2 (d; t) states that s is output unless one of the five checks above fails. <p> The "Manhattan skyline" problem is: Given a set of rectangles with collinear bottom edges, compute the polygonal outline of the union of the rectangles [9]. The Voronoi diagram is a fundamental concept in computational geometry <ref> [11] </ref>. Given a set of points P in the plane, the Voronoi diagram is a partition of the plane into regions such that each region consists of all points closer to a given p 2 P than to any other other point in P .
Reference: [12] <author> Sedgewick, R., </author> <title> "Implementing quicksort programs," </title> <journal> Comm. of the ACM, </journal> <pages> pp. 847-857, 21(10), </pages> <year> 1978. </year>
Reference: [13] <author> Siewiorek, D., and Swarz, R., </author> <title> The theory and practice of reliable design, </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1982. </year>
Reference: [14] <author> Sullivan, </author> <title> G.F., and Masson, G.M., "Using certification trails to achieve software fault tolerance," </title> <booktitle> Digest of the 1990 Fault Tolerant Computing Symposium, </booktitle> <pages> pp. 423-431, </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference-contexts: Our previous work on certification trails emphasized a theoretical perspective in which we proved that the asymptotic time complexity of the testing process could be reduced <ref> [14, 16] </ref>. In this paper, we report on implementations of the certification trail method so as to assess experimentally with run-time data the performance and overall value of the technique. We have implemented the certification trail method for nine fundamental and well-known algorithms of broad importance and applicability.
Reference: [15] <author> Sullivan, </author> <title> G.F., and Masson, G.M., "Using certification trails to achieve software fault tolerance," </title> <institution> Department of Computer Science Technical Report JHU 89/26, Johns Hopkins University, Baltimore, Mary-land, </institution> <year> 1989. </year>
Reference-contexts: This algorithm however appears to have a large constant of proportionality and therefore we do not use it. We use the techniques just discussed to implement the certification trail for this problem. A full description may be found in a technical report <ref> [15] </ref>. Size Basic Prim. Exec. Sec. % Speedup (Also Gen. Exec. Sav. <p> A full description of the method we employ to generate and use a certification trail is detailed in a technical report <ref> [15] </ref>. Size Basic Prim. Exec. Sec. % Speedup (Also Gen. Exec. Sav.
Reference: [16] <author> Sullivan, </author> <title> G.F., and Masson, G.M., "Certification trails for data structures," </title> <booktitle> Digest of the 1991 Fault Tolerant Computing Symposium, </booktitle> <pages> pp. 240-247, </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Our previous work on certification trails emphasized a theoretical perspective in which we proved that the asymptotic time complexity of the testing process could be reduced <ref> [14, 16] </ref>. In this paper, we report on implementations of the certification trail method so as to assess experimentally with run-time data the performance and overall value of the technique. We have implemented the certification trail method for nine fundamental and well-known algorithms of broad importance and applicability.
Reference: [17] <author> Tarjan, R. E., </author> <title> Data Structures and Network Algorithms, </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA, </address> <year> 1983. </year>
Reference-contexts: Our approach is applied to a variant of the Dijkstra algorithm [3] as explicated in <ref> [17] </ref>. We are concerned with the single source problem, i.e., given a graph and a vertex s, find the shortest path from s to v for every vertex v. The algorithm for this problem which has the fastest asymptotic time complexity uses fusion trees and is given in [5].
References-found: 17

