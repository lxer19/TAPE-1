URL: ftp://ftp.cs.huji.ac.il/users/transis/podc-97.ps
Refering-URL: http://www.cs.huji.ac.il/labs/transis/Abstracts/podc97.html
Root-URL: http://www.cs.huji.ac.il
Email: esti@vnet.ibm.com  idish@cs.huji.ac.il  dolev@cs.huji.ac.il  
Title: Dynamic Voting for Consistent Primary Components  
Author: Esti Yeger Lotem Idit Keidar Danny Dolev 
Web: http://www.cs.huji.ac.il/~idish  http://www.cs.huji.ac.il/~dolev  
Address: Israel  Jerusalem, Israel  Jerusalem, Israel  
Affiliation: IBM Haifa Research Laboratory  Computer Science Institute The Hebrew University of  Computer Science Institute The Hebrew University of  
Abstract: Distributed applications often use quorums in order to guarantee consistency. With emerging world-wide communication technology, many new applications (e.g., conferencing applications and interactive games) wish to allow users to freely join and leave, without restarting the entire system. The dynamic voting paradigm allows such systems to define quorums adaptively, accounting for the changes in the set of participants. Furthermore, dynamic voting was proven to be the most available paradigm for maintaining quorums in unreliable networks. However, the subtleties of implementing dynamic voting were not well understood; in fact, many of the suggested protocols may lead to inconsistencies in case of failures. Other protocols severely limit the availability in case failures occur during the protocol. In this paper we present a robust and efficient dynamic voting protocol for unreliable asynchronous networks. The protocol consistently maintains the primary component in a distributed system. Our protocol allows the system to make progress in cases of repetitive failures in which previously suggested protocols block. The protocol is simple to implement, and its communication requirements are small. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Amir, Y. </author> <title> Replication Using Group Communication Over a Dynamic Network. </title> <type> PhD thesis, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel, </institution> <year> 1995. </year>
Reference-contexts: It may be incorporated in many distributed applications that make progress in a primary component, e.g., replication algorithms [18, 11], transaction management [17], and even infrastructure systems like the ISIS toolkit [5]. If a failure occurs in the course of the protocol, some previously suggested protocols (e.g., <ref> [16, 1] </ref>) block until all the members of the last quorum become reconnected, while our protocol requires only a majority of the members that attempted to form the last quorum to become reconnected in order to make progress. <p> Like other dynamic voting protocols, our paper focuses on solving the latter problem, assuming a separate mechanism that solves the former. Our dynamic voting protocol assumes a membership mechanism no stronger than those assumed in <ref> [9, 14, 20, 16, 11, 1] </ref>. Each process is equipped with an underlying membership module, e.g., [2, 3, 12, 8]. When the membership module senses failures or recoveries, it reports to the process of the new membership, i.e., the set of processes that are currently assumed to be connected.
Reference: [2] <author> Amir, Y., Dolev, D., Kramer, S., and Malki, D. </author> <title> Membership Algorithms for Multicast Communication Groups. </title> <booktitle> In Intl. Workshop on Distributed Algorithms proceedings (WDAG-6), (LNCS, 647) (Novem-ber 1992), </booktitle> <pages> pp. 292-312. </pages>
Reference-contexts: Our dynamic voting protocol assumes a membership mechanism no stronger than those assumed in [9, 14, 20, 16, 11, 1]. Each process is equipped with an underlying membership module, e.g., <ref> [2, 3, 12, 8] </ref>. When the membership module senses failures or recoveries, it reports to the process of the new membership, i.e., the set of processes that are currently assumed to be connected. Furthermore, our protocol assumes that every message is received in the membership in which it was sent.
Reference: [3] <author> Amir, Y., Moser, L. E., Melliar-Smith, P. M., Agarwal, D. A., and Ciarfella, P. </author> <title> Fast Message Ordering and Membership using a Logical Token-Passing Ring. </title> <booktitle> In International Conference on Distributed Computing Systems (May 1993), </booktitle> <volume> no. 13, </volume> <pages> pp. 551-560. </pages>
Reference-contexts: Our dynamic voting protocol assumes a membership mechanism no stronger than those assumed in [9, 14, 20, 16, 11, 1]. Each process is equipped with an underlying membership module, e.g., <ref> [2, 3, 12, 8] </ref>. When the membership module senses failures or recoveries, it reports to the process of the new membership, i.e., the set of processes that are currently assumed to be connected. Furthermore, our protocol assumes that every message is received in the membership in which it was sent.
Reference: [4] <author> Amir, Y., and Wool, A. </author> <title> Evaluating Quorum Systems over the Internet. </title> <booktitle> In The Fault-Tolerant Computing Symposium(FTCS) (June 1996), </booktitle> <pages> pp. 26-35. </pages>
Reference-contexts: Thus, each newly formed quorum must contain a majority of the previous one, but not necessarily a majority of the sites. Stochastic models analysis [16], simulations [20], and empirical results <ref> [4] </ref> show that dynamic voting is more available than any other paradigm for maintaining a primary component. Another important benefit of the dynamic voting paradigm is in its flexibility to support a dynamically changing set of processes.
Reference: [5] <author> Birman, K., and Van Renesse, R. </author> <title> Reliable Distributed Computing with the Isis Toolkit. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Numerous fault tolerant distributed systems, e.g., ISIS <ref> [5] </ref>, use the primary component 1 paradigm to allow a subset of the processes to function when failures occur. A majority (or quorum) of the processes is usually chosen to be the primary component. <p> Our protocol's communication and memory requirements are small and it is simple to implement. It may be incorporated in many distributed applications that make progress in a primary component, e.g., replication algorithms [18, 11], transaction management [17], and even infrastructure systems like the ISIS toolkit <ref> [5] </ref>.
Reference: [6] <author> Chandra, T., Hadzilacos, V., Toueg, S., and Charron-Bost, B. </author> <title> On the Impossibility of Group Membership. </title> <booktitle> In ACM Symp. on Prin. of Distributed Computing (PODC) (May 1996), </booktitle> <pages> pp. 322-330. </pages>
Reference-contexts: These requirements may be fulfilled by a simple and efficient membership protocol, e.g., the one round protocol in [8], which terminates after one communication round. As shown in <ref> [6] </ref>, it is impossible to reach agreement upon the current membership in an asynchronous system. Hence, we do not assume that the membership reports accurately reflect the network situation, nor is the membership reported atomically to all the processes.
Reference: [7] <author> Chandra, T. D., and Toueg, S. </author> <title> Unreliable Failure Detectors for Reliable Distributed Systems. </title> <journal> Journal of ACM 43, </journal> <month> 2 (Mar. </month> <year> 1996), </year> <pages> 225-267. </pages>
Reference-contexts: These protocols do not record historical information, and therefore, in case of failures, must consider all possible histories. This imposes severe limitations on the system's progress. In [19], a three phase consensus protocol <ref> [7] </ref> is employed in order to allow a majority to resolve ambiguous quorums. This protocol is similar to the majority based Three Phase Commit (3PC) [22, 17] protocols.
Reference: [8] <author> Cristian, F., and Schmuck, F. </author> <title> Agreeing on Process Group Membership in Asynchronous Distributed Systems. </title> <type> Tech. Rep. </type> <institution> CSE95-428, Department of Conm-puter Science and Engineering, University of California, </institution> <address> San Diego, </address> <year> 1995. </year>
Reference-contexts: Our dynamic voting protocol assumes a membership mechanism no stronger than those assumed in [9, 14, 20, 16, 11, 1]. Each process is equipped with an underlying membership module, e.g., <ref> [2, 3, 12, 8] </ref>. When the membership module senses failures or recoveries, it reports to the process of the new membership, i.e., the set of processes that are currently assumed to be connected. Furthermore, our protocol assumes that every message is received in the membership in which it was sent. <p> In order to discard messages from previous memberships, the protocol needs to provide a unique membership identifier (which will be added to all the messages sent in this membership). These requirements may be fulfilled by a simple and efficient membership protocol, e.g., the one round protocol in <ref> [8] </ref>, which terminates after one communication round. As shown in [6], it is impossible to reach agreement upon the current membership in an asynchronous system. Hence, we do not assume that the membership reports accurately reflect the network situation, nor is the membership reported atomically to all the processes. <p> We conclude that the transitive closure of the order between intersecting formed sessions is a total order. 6 Evaluating the Efficiency Our protocol assumes a simple underlying membership protocol, which may be conducted in one communication round (e.g., <ref> [8] </ref>). Each session of our protocol is conducted in two communication rounds, one of which may be conducted by piggybacking information on the messages sent by the membership protocol.
Reference: [9] <author> Davcev, D., and Burkhard, W. </author> <title> Consistency and Recovery Control for Replicated Files. </title> <booktitle> In ACM Symp. on Operating Systems Principles (1985), </booktitle> <volume> no. 10, </volume> <pages> pp. 87-96. </pages>
Reference-contexts: When partitions occur, such knowledge differences are inevitable: Once a site detaches, it is impossible for other sites to know whether it received a specific message before its detachment, or not. Some past protocols (e.g., <ref> [9, 20, 11] </ref>) lead to inconsistent results in such cases, as demonstrated by the following typical scenario: * The systems consists of five processes: a; b; c; d and e. <p> Like other dynamic voting protocols, our paper focuses on solving the latter problem, assuming a separate mechanism that solves the former. Our dynamic voting protocol assumes a membership mechanism no stronger than those assumed in <ref> [9, 14, 20, 16, 11, 1] </ref>. Each process is equipped with an underlying membership module, e.g., [2, 3, 12, 8]. When the membership module senses failures or recoveries, it reports to the process of the new membership, i.e., the set of processes that are currently assumed to be connected.
Reference: [10] <author> Dolev, D., Keidar, I., and Yeger Lotem, E. </author> <title> Dynamic Voting for Consistent Primary Components. </title> <type> TR 96-7, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: In Section 5.1 we show how our protocol overcomes the typical problematic scenario described in Section 1. In Section 5.2 we outline the protocol's correctness proof. The detailed correctness proof appears in the full paper <ref> [10] </ref>. <p> This mechanism allows the system to adjust the quorum requirements in the protocol to the dynamically changing set of process. We prove the correctness of the resulting protocol in the full paper <ref> [10] </ref>. Jajodia and Mutchler [15] suggest a similar idea in their hybrid algorithm. The hybrid approach combines dynamic voting in large quorums with static voting in quorums of size three, ruling out quorums consisting of a single process.
Reference: [11] <author> El Abbadi, A., and Dani, S. </author> <title> A Dynamic Accessibility Protocol for Replicated Databases. </title> <journal> Data and Knowledge Engineering, </journal> <volume> 6 (1991), </volume> <pages> 319-332. </pages>
Reference-contexts: Our protocol's communication and memory requirements are small and it is simple to implement. It may be incorporated in many distributed applications that make progress in a primary component, e.g., replication algorithms <ref> [18, 11] </ref>, transaction management [17], and even infrastructure systems like the ISIS toolkit [5]. <p> When partitions occur, such knowledge differences are inevitable: Once a site detaches, it is impossible for other sites to know whether it received a specific message before its detachment, or not. Some past protocols (e.g., <ref> [9, 20, 11] </ref>) lead to inconsistent results in such cases, as demonstrated by the following typical scenario: * The systems consists of five processes: a; b; c; d and e. <p> Like other dynamic voting protocols, our paper focuses on solving the latter problem, assuming a separate mechanism that solves the former. Our dynamic voting protocol assumes a membership mechanism no stronger than those assumed in <ref> [9, 14, 20, 16, 11, 1] </ref>. Each process is equipped with an underlying membership module, e.g., [2, 3, 12, 8]. When the membership module senses failures or recoveries, it reports to the process of the new membership, i.e., the set of processes that are currently assumed to be connected.
Reference: [12] <author> Ezhilchelvan, P. D., Macedo, A., and Shrivas-tava, S. K. Newtop: </author> <title> a Fault Tolerant Group Communication Protocol. </title> <booktitle> In International Conference on Distributed Computing Systems (June 1995), </booktitle> <volume> no. 15, </volume> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 296-306. </pages>
Reference-contexts: Our dynamic voting protocol assumes a membership mechanism no stronger than those assumed in [9, 14, 20, 16, 11, 1]. Each process is equipped with an underlying membership module, e.g., <ref> [2, 3, 12, 8] </ref>. When the membership module senses failures or recoveries, it reports to the process of the new membership, i.e., the set of processes that are currently assumed to be connected. Furthermore, our protocol assumes that every message is received in the membership in which it was sent.
Reference: [13] <author> Herlihy, M. </author> <title> A Quorum-Consensus Replication Method for Abstract Data Types. </title> <journal> ACM Trans. Comp. Syst. </journal> <volume> 4, </volume> <month> 1 (Feb. </month> <year> 1986), </year> <pages> 32-53. </pages>
Reference: [14] <author> Jajodia, S. </author> <title> Managing Replicated Files in Partitioned Distributed Database Systems. </title> <booktitle> In IEEE Int'l. Conf. on Data Engineering (1987), </booktitle> <volume> no. 3, </volume> <pages> pp. 412-418. </pages>
Reference-contexts: Like other dynamic voting protocols, our paper focuses on solving the latter problem, assuming a separate mechanism that solves the former. Our dynamic voting protocol assumes a membership mechanism no stronger than those assumed in <ref> [9, 14, 20, 16, 11, 1] </ref>. Each process is equipped with an underlying membership module, e.g., [2, 3, 12, 8]. When the membership module senses failures or recoveries, it reports to the process of the new membership, i.e., the set of processes that are currently assumed to be connected. <p> Originally, dynamic voting was implemented by allowing a majority of the previous quorum to become the new quorum. Dynamic linear voting <ref> [14] </ref>, optimizes this scheme by breaking ties between groups of equal size using a linear order, L, imposed on all the potential processes in the system. We extend dynamic linear voting with another parameter: Min Quorum, the minimum quorum size allowed in the system.
Reference: [15] <author> Jajodia, S., and Mutchler, D. </author> <title> A Hybrid Replica Control Algorithm Combining Static and Dynamic Voting. </title> <journal> IEEE Transactions on Knowledge and Data Engineering 1, </journal> <month> 4 (Dec. </month> <year> 1989). </year>
Reference-contexts: This mechanism allows the system to adjust the quorum requirements in the protocol to the dynamically changing set of process. We prove the correctness of the resulting protocol in the full paper [10]. Jajodia and Mutchler <ref> [15] </ref> suggest a similar idea in their hybrid algorithm. The hybrid approach combines dynamic voting in large quorums with static voting in quorums of size three, ruling out quorums consisting of a single process. <p> Neither approach is strictly better than the other: There are situations in which our approach allows the system to make progress while the hybrid approach does not, and vice versa. However, the hybrid algorithm of <ref> [15] </ref> applies the hybrid approach to the algorithm of [16] and uses two phase commit to avoid inconsistencies. 9 Conclusions We presented a dynamic voting protocol for consistently maintaining primary components in an asynchronous failure-prone system.
Reference: [16] <author> Jajodia, S., and Mutchler, D. </author> <title> Dynamic Voting Algorithms for Maintaining the Consistency of a Replicated Database. </title> <journal> ACM Trans. Database Systems 15, </journal> <volume> 2 (1990), </volume> <pages> 230-280. </pages>
Reference-contexts: Thus, each newly formed quorum must contain a majority of the previous one, but not necessarily a majority of the sites. Stochastic models analysis <ref> [16] </ref>, simulations [20], and empirical results [4] show that dynamic voting is more available than any other paradigm for maintaining a primary component. Another important benefit of the dynamic voting paradigm is in its flexibility to support a dynamically changing set of processes. <p> It may be incorporated in many distributed applications that make progress in a primary component, e.g., replication algorithms [18, 11], transaction management [17], and even infrastructure systems like the ISIS toolkit [5]. If a failure occurs in the course of the protocol, some previously suggested protocols (e.g., <ref> [16, 1] </ref>) block until all the members of the last quorum become reconnected, while our protocol requires only a majority of the members that attempted to form the last quorum to become reconnected in order to make progress. <p> Like other dynamic voting protocols, our paper focuses on solving the latter problem, assuming a separate mechanism that solves the former. Our dynamic voting protocol assumes a membership mechanism no stronger than those assumed in <ref> [9, 14, 20, 16, 11, 1] </ref>. Each process is equipped with an underlying membership module, e.g., [2, 3, 12, 8]. When the membership module senses failures or recoveries, it reports to the process of the new membership, i.e., the set of processes that are currently assumed to be connected. <p> Neither approach is strictly better than the other: There are situations in which our approach allows the system to make progress while the hybrid approach does not, and vice versa. However, the hybrid algorithm of [15] applies the hybrid approach to the algorithm of <ref> [16] </ref> and uses two phase commit to avoid inconsistencies. 9 Conclusions We presented a dynamic voting protocol for consistently maintaining primary components in an asynchronous failure-prone system. Our protocol is more available than previously suggested protocols, in that it allows progress in more cases.
Reference: [17] <author> Keidar, I., and Dolev, D. </author> <title> Increasing the Resilience of Distributed and Replicated Database Systems. </title> <note> The Journal of Computer and System Sciences (JCSS) special issue with selected papers from PODS 1995 . To Appear. Available in: http://cs.huji.ac.il/ transis/ /Abstracts/jcss.html. Previous version in the 1995 ACM-SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </note> <month> May </month> <year> 1995, </year> <pages> pages 245-254. </pages>
Reference-contexts: Our protocol's communication and memory requirements are small and it is simple to implement. It may be incorporated in many distributed applications that make progress in a primary component, e.g., replication algorithms [18, 11], transaction management <ref> [17] </ref>, and even infrastructure systems like the ISIS toolkit [5]. <p> This imposes severe limitations on the system's progress. In [19], a three phase consensus protocol [7] is employed in order to allow a majority to resolve ambiguous quorums. This protocol is similar to the majority based Three Phase Commit (3PC) <ref> [22, 17] </ref> protocols. This induces a high overhead that makes the protocol infeasible for use in practice: When a majority of the previous quorum reconnects, [19] requires at least five communication rounds in order to resolve the previous quorum and form a new one.
Reference: [18] <author> Keidar, I., and Dolev, D. </author> <title> Efficient Message Ordering in Dynamic Networks. </title> <booktitle> In ACM Symp. on Prin. of Distributed Computing (PODC) (May 1996), </booktitle> <volume> no. 15, </volume> <pages> pp. 68-76. </pages>
Reference-contexts: Our protocol's communication and memory requirements are small and it is simple to implement. It may be incorporated in many distributed applications that make progress in a primary component, e.g., replication algorithms <ref> [18, 11] </ref>, transaction management [17], and even infrastructure systems like the ISIS toolkit [5].
Reference: [19] <author> Malloth, C., and Schiper, A. </author> <title> View Synchronous Communication in large scale networks. In Proceedings 2nd Open Workshop of the ESPRIT project BROADCAST (number 6360) (July 1995 (also available as a Technical Report Nr. </title> <institution> 94/84 at Ecole Polytechnique Federale de Lausanne (Switzerland), </institution> <month> October </month> <year> 1994)). </year>
Reference-contexts: These protocols do not record historical information, and therefore, in case of failures, must consider all possible histories. This imposes severe limitations on the system's progress. In <ref> [19] </ref>, a three phase consensus protocol [7] is employed in order to allow a majority to resolve ambiguous quorums. This protocol is similar to the majority based Three Phase Commit (3PC) [22, 17] protocols. <p> This protocol is similar to the majority based Three Phase Commit (3PC) [22, 17] protocols. This induces a high overhead that makes the protocol infeasible for use in practice: When a majority of the previous quorum reconnects, <ref> [19] </ref> requires at least five communication rounds in order to resolve the previous quorum and form a new one. Our protocol avoids such excessive communication by using pipelining: the status of past ambiguous quorums is resolved during the installation of new quorums.
Reference: [20] <author> Paris, J., and Long, D. </author> <title> Efficient Dynamic Voting Algorithms. </title> <booktitle> Proceedings 13th Int'l. Conf. on Very Large Data Bases (1988), </booktitle> <pages> 268-275. </pages>
Reference-contexts: Thus, each newly formed quorum must contain a majority of the previous one, but not necessarily a majority of the sites. Stochastic models analysis [16], simulations <ref> [20] </ref>, and empirical results [4] show that dynamic voting is more available than any other paradigm for maintaining a primary component. Another important benefit of the dynamic voting paradigm is in its flexibility to support a dynamically changing set of processes. <p> When partitions occur, such knowledge differences are inevitable: Once a site detaches, it is impossible for other sites to know whether it received a specific message before its detachment, or not. Some past protocols (e.g., <ref> [9, 20, 11] </ref>) lead to inconsistent results in such cases, as demonstrated by the following typical scenario: * The systems consists of five processes: a; b; c; d and e. <p> Like other dynamic voting protocols, our paper focuses on solving the latter problem, assuming a separate mechanism that solves the former. Our dynamic voting protocol assumes a membership mechanism no stronger than those assumed in <ref> [9, 14, 20, 16, 11, 1] </ref>. Each process is equipped with an underlying membership module, e.g., [2, 3, 12, 8]. When the membership module senses failures or recoveries, it reports to the process of the new membership, i.e., the set of processes that are currently assumed to be connected.
Reference: [21] <author> Ricciardi, A. M., and Birman, K. P. </author> <title> Using Process Groups to Implement Failure Detection in Asynchronous Environments. </title> <booktitle> In ACM Symp. on Prin. of Distributed Computing (PODC) (August 1991), </booktitle> <pages> pp. 341-352. </pages>
Reference-contexts: Furthermore, the analyses of the availability of dynamic voting do not take the possibility of blocking into consideration, and therefore the actual availability of these protocols is lower than expected. Unlike some previous protocols, e.g., the dynamic voting protocols implemented in ISIS and Horus 2 <ref> [21] </ref>, our protocol recovers from situations in which the primary component was lost (e.g., when the primary component partitions into three minority groups) without requiring a cold start of the entire system. 2 The [21] protocol was implemented in a previous version of Horus. <p> Unlike some previous protocols, e.g., the dynamic voting protocols implemented in ISIS and Horus 2 <ref> [21] </ref>, our protocol recovers from situations in which the primary component was lost (e.g., when the primary component partitions into three minority groups) without requiring a cold start of the entire system. 2 The [21] protocol was implemented in a previous version of Horus.
Reference: [22] <author> Skeen, D. </author> <title> A Quorum-Based Commit Protocol. </title> <booktitle> In Berkeley Workshop on Distributed Data Management and Computer Networks (Feb. 1982), </booktitle> <volume> no. 6, </volume> <pages> pp. 69-80. 9 </pages>
Reference-contexts: This imposes severe limitations on the system's progress. In [19], a three phase consensus protocol [7] is employed in order to allow a majority to resolve ambiguous quorums. This protocol is similar to the majority based Three Phase Commit (3PC) <ref> [22, 17] </ref> protocols. This induces a high overhead that makes the protocol infeasible for use in practice: When a majority of the previous quorum reconnects, [19] requires at least five communication rounds in order to resolve the previous quorum and form a new one.
References-found: 22

