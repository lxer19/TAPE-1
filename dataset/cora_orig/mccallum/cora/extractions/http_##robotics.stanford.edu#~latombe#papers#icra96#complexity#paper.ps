URL: http://robotics.stanford.edu/~latombe/papers/icra96/complexity/paper.ps
Refering-URL: http://robotics.stanford.edu/~latombe/projects/
Root-URL: http://www.cs.stanford.edu
Email: wass@cs.stanford.edu latombe@cs.stanford.edu rajeev@cs.stanford.edu  
Title: Complexity Measures for Assembly Sequences  
Author: Michael Goldwasser Jean-Claude Latombe Rajeev Motwani 
Abstract: Our work examines various complexity measures for two-handed assembly sequences. For many products there exists an exponentially large set of valid sequences, and a natural goal is to use automated systems to select wisely from the choices. Since assembly sequencing is a preprocessing phase for a long and expensive manufacturing process, any work towards finding a "better" assembly sequence is of great value when it comes time to assemble the physical product in mass quantities. We take a step in this direction by introducing a formal framework for studying the optimization of several complexity measures. This framework focuses on the combinatorial aspect of the family of valid assembly sequences, while temporarily separating out the specific geometric assumptions inherent to the problem. With an exponential number of possibilities, finding the true optimal cost solution is non-trivial. In fact in the most general case, our results show that even finding an approximate solution is hard. Furthermore, we can show several hardness results, even in simple geometric settings. Future work is directed towards using this model to study how the original geometric assumptions can be reintroduced to prove stronger approximation results. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. F. Baldwin. </author> <title> Algorithmic methods and software tools for the generation of mechanical assembly sequences. M.Sc. </title> <type> thesis, </type> <institution> MIT, </institution> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: The output is a sequence of operations resulting in the construction of the product from its individual parts. Each operation combines a set of subassemblies using a motion from the allowable set. The use of automation in assembly sequencing has increased rapidly over the years <ref> [1, 5, 10, 11, 12, 15, 16, 23, 24, 25, 26] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process.
Reference: [2] <author> G. Boothroyd. </author> <title> Assembly Automation and Product Design. </title> <publisher> Marcel Dekker, Inc., </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: A logical continuation is to use automated reasoning to find the "best" assembly sequence under a certain complexity measure. Several researchers have acknowledged the need to extend automated reasoning to search for better assembly sequences, although with limited results. Several empirical measures have been suggested <ref> [2] </ref>, and more formal complexity measures have been examined in a simplified system [26]. For a restricted class of inputs which have a "total ordering" property, an algorithm is given which produces the minimal length sequence to remove any given part [27].
Reference: [3] <author> S. Chakrabarty and J. Wolter. </author> <title> A hierarchical approach to assembly planning. </title> <booktitle> In Proc. IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 258-263, </pages> <year> 1994. </year>
Reference-contexts: For a restricted class of inputs which have a "total ordering" property, an algorithm is given which produces the minimal length sequence to remove any given part [27]. A hierarchical approach is used to identify common subassemblies in products <ref> [3] </ref>, thereby allowing more effor to be used towards finding a "better" assembly sequence. Although practical, this technique simply delays the eventual need for better automated reasoning to overcome increasingly large data sets.
Reference: [4] <author> C. Chekuri, M. Goldwasser, D. Halperin, and R. Mot-wani. </author> <title> Hardness of removing a part from a two-dimensional assembly. </title> <type> Stanford technical report, </type> <year> 1996. </year>
Reference-contexts: We give an approximation-preserving reduction from SetCover to the problem of removing a keypart with infinite translations, from an assembly consisting entirely of unit disks in two dimensions <ref> [4] </ref>.
Reference: [5] <author> T. L. De Fazio and D.E. Whitney. </author> <title> Simplified generation of all mechanical assembly sequences. </title> <journal> IEEE Trans. on Robotics and Automation, </journal> <volume> 3(6) </volume> <pages> 640-658, </pages> <year> 1987. </year>
Reference-contexts: The output is a sequence of operations resulting in the construction of the product from its individual parts. Each operation combines a set of subassemblies using a motion from the allowable set. The use of automation in assembly sequencing has increased rapidly over the years <ref> [1, 5, 10, 11, 12, 15, 16, 23, 24, 25, 26] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process. <p> For many of these restricted classes, polynomial algorithms were designed which find an assembly sequence if one exists [22, 23]. There are also algorithms which enumerate all possible assembly sequences <ref> [5] </ref>, however there may be exponentially many such sequences for a product. A logical continuation is to use automated reasoning to find the "best" assembly sequence under a certain complexity measure.
Reference: [6] <author> U. Feige. </author> <title> A threshold of ln n for approximating set cover. </title> <booktitle> In Proc. 28th ACM Symp. Theory Comp., </booktitle> <year> 1996. </year>
Reference-contexts: Unfortunately, we show in Theorem 3 that removing a key part in this model is at least as hard as the Set-Cover problem (defined in [7]). We rely on previous results, given in Lemma 4 proving the hardness of approximating SetCover <ref> [6, 17] </ref>. Finally, we use a self-amplification technique in Theorem ?? to further strengthen the hardness results of approximating the set decomposition problem. <p> Similarly, any solution to the SetCover problem can be translated to a valid assembly sequence. Both of these translations preserve the cardinality of the solutions. Lemma 4 <ref> [6] </ref> There is no polynomial time approximation algorithm for SetCover with a ratio below (1 + o (1)) ln n unless N P T IM E (n O (log log n) ).
Reference: [7] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman, </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference-contexts: Many of these optimization problem turn out to be NP-complete, and so we approach them using techniques common to the theory of approximability <ref> [7, 18] </ref>. Section 2 discusses the polynomial time assembly sequencers that motivate our framework, which is defined in Section 3. Some preliminary results in the general model are given in Section 4, and for the original geometric versions in Section 5. <p> A standard measure for the quality of an approximation algorithm is the performance ratio between the cost of the solution returned by the algorithm versus the cost of the optimal solution. This field of approx-imability theory has been well researched in classical computer science <ref> [7, 18] </ref>. The importance of this type of analysis over studying purely experimental heuristics is to gain a better understanding of the quality of the approximations and the asymptotic behavior as the input size increases. As products become more complex and more densely packed, such analysis will grow in importance. <p> Unfortunately, we show in Theorem 3 that removing a key part in this model is at least as hard as the Set-Cover problem (defined in <ref> [7] </ref>). We rely on previous results, given in Lemma 4 proving the hardness of approximating SetCover [6, 17]. Finally, we use a self-amplification technique in Theorem ?? to further strengthen the hardness results of approximating the set decomposition problem.
Reference: [8] <author> L. J. Guibas, D. Halperin, H. Hirukawa, and J.-C. Latombe R. H. Wilson. </author> <title> A simple and efficient procedure for polyhedral assembly partitioning under infinitesimal motions. </title> <booktitle> In Proc IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 2553-2560, </pages> <year> 1995. </year>
Reference-contexts: Computational geometry techniques allow for the construction of the NDBG for a wide range of motion classes, including infinitesimal translations [22], extended translations (i.e., to infinity) [22], multiple step translations [9], and infinitesimal generalized motions (i.e., rigid body motions) <ref> [8, 22] </ref>. For each of these families of motion, the NDBG framework immediately provides a polynomial time algorithm for constructing an assembly sequence. After constructing the set of DBG's, an arbitrary assembly sequence can be found by taking any legal separation in any direction, and re-cursing on the resulting subassemblies.
Reference: [9] <author> D. Halperin and R. H. Wilson. </author> <title> Assembly partitioning along simple paths: the case of multiple translations. </title> <booktitle> In Proc. IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 1585-1592, </pages> <year> 1995. </year>
Reference-contexts: Computational geometry techniques allow for the construction of the NDBG for a wide range of motion classes, including infinitesimal translations [22], extended translations (i.e., to infinity) [22], multiple step translations <ref> [9] </ref>, and infinitesimal generalized motions (i.e., rigid body motions) [8, 22]. For each of these families of motion, the NDBG framework immediately provides a polynomial time algorithm for constructing an assembly sequence.
Reference: [10] <author> R. L. Hoffman. </author> <title> A common sense approach to assembly sequence planning. </title> <booktitle> In Computer-Aided Mechanical Assembly Planning, </booktitle> <pages> pages 289-314. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1991. </year>
Reference-contexts: The output is a sequence of operations resulting in the construction of the product from its individual parts. Each operation combines a set of subassemblies using a motion from the allowable set. The use of automation in assembly sequencing has increased rapidly over the years <ref> [1, 5, 10, 11, 12, 15, 16, 23, 24, 25, 26] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process.
Reference: [11] <author> L. S. Homem de Mello and A. C. Sander-son. </author> <title> Computer-Aided Mechanical Assembly Planning. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1991. </year>
Reference-contexts: The output is a sequence of operations resulting in the construction of the product from its individual parts. Each operation combines a set of subassemblies using a motion from the allowable set. The use of automation in assembly sequencing has increased rapidly over the years <ref> [1, 5, 10, 11, 12, 15, 16, 23, 24, 25, 26] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process.
Reference: [12] <author> L. S. Homem de Mello and A. C. Sanderson. </author> <title> A correct and complete algorithms for the generation of mechanical assembly sequences. </title> <journal> IEEE Trans. on Robotics and Automation, </journal> <volume> 7(2) </volume> <pages> 228-240, </pages> <year> 1991. </year>
Reference-contexts: The output is a sequence of operations resulting in the construction of the product from its individual parts. Each operation combines a set of subassemblies using a motion from the allowable set. The use of automation in assembly sequencing has increased rapidly over the years <ref> [1, 5, 10, 11, 12, 15, 16, 23, 24, 25, 26] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process. <p> Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process. Early systems resulted in inefficient generate-and-test sequencers, operating by generating candidate operations and testing their feasibility <ref> [12, 25] </ref>. Theoretical results show that assembly sequencing, in its most general form, is intractable [13, 14, 19, 26].
Reference: [13] <author> J. E. Hopcroft, J. T. Schwartz, and M. Sharir. </author> <title> On the complexity of motion planning for multiple independent objects: P-space hardness of the "Warehouseman's Problem". </title> <journal> Int. J. Robotics Research, </journal> <volume> 3(4) </volume> <pages> 76-88, </pages> <year> 1984. </year>
Reference-contexts: Early systems resulted in inefficient generate-and-test sequencers, operating by generating candidate operations and testing their feasibility [12, 25]. Theoretical results show that assembly sequencing, in its most general form, is intractable <ref> [13, 14, 19, 26] </ref>. This led some researchers to consider restricted, but still interesting, versions of the problem (e.g., monotone sequences, where each operation generates a final subassembly, and two-handed sequences, where every operation merges exactly two subassemblies).
Reference: [14] <author> L. Kavraki, J.-C. Latombe, and R. Wilson. </author> <title> Complexity of partitioning an assembly. </title> <booktitle> In Proc. 5th Canad. Conf. Comput. Geom., </booktitle> <pages> pages 12-17, </pages> <address> Waterloo, Canada, </address> <year> 1993. </year>
Reference-contexts: Early systems resulted in inefficient generate-and-test sequencers, operating by generating candidate operations and testing their feasibility [12, 25]. Theoretical results show that assembly sequencing, in its most general form, is intractable <ref> [13, 14, 19, 26] </ref>. This led some researchers to consider restricted, but still interesting, versions of the problem (e.g., monotone sequences, where each operation generates a final subassembly, and two-handed sequences, where every operation merges exactly two subassemblies).
Reference: [15] <author> S. S. Krishnan and A. C. Sanderson. </author> <title> Path planning algorithms for assembly sequence planning. </title> <booktitle> In Proc. Int. Symp. on Intelligent Robotics, </booktitle> <pages> pages 428-439, </pages> <year> 1991. </year>
Reference-contexts: The output is a sequence of operations resulting in the construction of the product from its individual parts. Each operation combines a set of subassemblies using a motion from the allowable set. The use of automation in assembly sequencing has increased rapidly over the years <ref> [1, 5, 10, 11, 12, 15, 16, 23, 24, 25, 26] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process.
Reference: [16] <author> S. Lee and Y. G. Shin. </author> <title> Assembly planning based on geometric reasoning. </title> <journal> Computers and Graphics, </journal> <volume> 14(2) </volume> <pages> 237-250, </pages> <year> 1990. </year>
Reference-contexts: The output is a sequence of operations resulting in the construction of the product from its individual parts. Each operation combines a set of subassemblies using a motion from the allowable set. The use of automation in assembly sequencing has increased rapidly over the years <ref> [1, 5, 10, 11, 12, 15, 16, 23, 24, 25, 26] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process.
Reference: [17] <author> C. Lund and M. Yannakakis. </author> <title> On the hardness of approximating minimization problems. </title> <booktitle> In Proc. 25th ACM Symp. Theory Comp., </booktitle> <pages> pages 286-293, </pages> <year> 1993. </year>
Reference-contexts: Unfortunately, we show in Theorem 3 that removing a key part in this model is at least as hard as the Set-Cover problem (defined in [7]). We rely on previous results, given in Lemma 4 proving the hardness of approximating SetCover <ref> [6, 17] </ref>. Finally, we use a self-amplification technique in Theorem ?? to further strengthen the hardness results of approximating the set decomposition problem.
Reference: [18] <author> R. Motwani. </author> <title> Approximation algorithms. </title> <type> Stanford Technical Report STAN-CS-92-1435, </type> <year> 1992. </year>
Reference-contexts: Many of these optimization problem turn out to be NP-complete, and so we approach them using techniques common to the theory of approximability <ref> [7, 18] </ref>. Section 2 discusses the polynomial time assembly sequencers that motivate our framework, which is defined in Section 3. Some preliminary results in the general model are given in Section 4, and for the original geometric versions in Section 5. <p> A standard measure for the quality of an approximation algorithm is the performance ratio between the cost of the solution returned by the algorithm versus the cost of the optimal solution. This field of approx-imability theory has been well researched in classical computer science <ref> [7, 18] </ref>. The importance of this type of analysis over studying purely experimental heuristics is to gain a better understanding of the quality of the approximations and the asymptotic behavior as the input size increases. As products become more complex and more densely packed, such analysis will grow in importance. <p> As products become more complex and more densely packed, such analysis will grow in importance. We give a series of results, proving not only the hardness of finding the exact optimal solutions in this model, but even of finding reasonable approximation algorithms. To do so, we use approximation-preserving reductions <ref> [18, 20] </ref>. Classical reductions, for instance those equating all NP-complete problems, show that finding the optimal solution for one problem can be used to find the optimal solution for another problem. Such classical reductions do not guarantee anything about the relation between approximate solutions. <p> Although our original reduction from SetCover does not appear to be realizable, we can realize a reduction from Rectangle Cover, a geometric version of the set cover problem, which is conjectured to be as hard as SetCover <ref> [18] </ref>. We are also able realize a very strong non-approximability result for the problem or removing a keypart while minimizing the number of other parts removed.
Reference: [19] <author> B. K. Natarajan. </author> <title> On planning assemblies. </title> <booktitle> In Proc. 4th ACM Symp. on Computational Geometry, </booktitle> <pages> pages 299-308, </pages> <year> 1988. </year>
Reference-contexts: Early systems resulted in inefficient generate-and-test sequencers, operating by generating candidate operations and testing their feasibility [12, 25]. Theoretical results show that assembly sequencing, in its most general form, is intractable <ref> [13, 14, 19, 26] </ref>. This led some researchers to consider restricted, but still interesting, versions of the problem (e.g., monotone sequences, where each operation generates a final subassembly, and two-handed sequences, where every operation merges exactly two subassemblies).
Reference: [20] <author> C. H. Papadimitriou and M. Yannakakis. </author> <title> Optimization, approximation, and complexity classes. </title> <journal> J. Computer and Systems Sci., </journal> <volume> 43(3) </volume> <pages> 425-440, </pages> <year> 1991. </year>
Reference-contexts: As products become more complex and more densely packed, such analysis will grow in importance. We give a series of results, proving not only the hardness of finding the exact optimal solutions in this model, but even of finding reasonable approximation algorithms. To do so, we use approximation-preserving reductions <ref> [18, 20] </ref>. Classical reductions, for instance those equating all NP-complete problems, show that finding the optimal solution for one problem can be used to find the optimal solution for another problem. Such classical reductions do not guarantee anything about the relation between approximate solutions.
Reference: [21] <author> B. Romney, C. Godard, M. Goldwasser, and G. Ramkumar. </author> <title> An efficient system for geometric assembly sequence generation and evaluation. </title> <booktitle> In Proc. ASME Int. Computers in Engineering Conference, </booktitle> <pages> pages 699-712, </pages> <year> 1995. </year>
Reference-contexts: Many of these same complexity measures are looked at by the STAAT assembly sequencer <ref> [21] </ref>, although to optimize over these measures it must perform an expensive brute force search, or settle for simple heuristics. <p> We implemented such heuristics and the experimental results show that the pitfalls causing poor performance are not isolated examples, rather are quite common. We used data sets obtained from products run through the STAAT assembly sequencer <ref> [21] </ref>. Larger data sets were generated randomly, modeling pseudo-assemblies. 7 Conclusions A great deal of research has lead to a series of advancements in the use of automated assembly sequencers, with the goal of industrial use.
Reference: [22] <author> R. Wilson and J.-C. Latombe. </author> <title> Geometric reasoning about mechanical assembly. </title> <journal> Artificial Intelligence, </journal> <volume> 71(1), </volume> <year> 1995. </year>
Reference-contexts: For many of these restricted classes, polynomial algorithms were designed which find an assembly sequence if one exists <ref> [22, 23] </ref>. There are also algorithms which enumerate all possible assembly sequences [5], however there may be exponentially many such sequences for a product. A logical continuation is to use automated reasoning to find the "best" assembly sequence under a certain complexity measure. <p> A more complete discussion on using automated reasoning to evaluate the complexity of assembly sequences, introduces several measures including the number of hands used, the length of the longest sequence of operations, and the number of degrees of freedom required <ref> [22] </ref>. Many of these same complexity measures are looked at by the STAAT assembly sequencer [21], although to optimize over these measures it must perform an expensive brute force search, or settle for simple heuristics. <p> Once this is done, each of the resulting subassemblies can be disassembled. This decomposition can be represented naturally as a binary tree. For a more detailed discussion, see <ref> [22, 23, 26] </ref>. Figure 1 gives an example, taken from [22], of such an assembly tree for a simple 2-dimensional product. Our work builds upon the notion of the nondirectional blocking graph (NDBG) [23]. <p> Once this is done, each of the resulting subassemblies can be disassembled. This decomposition can be represented naturally as a binary tree. For a more detailed discussion, see [22, 23, 26]. Figure 1 gives an example, taken from <ref> [22] </ref>, of such an assembly tree for a simple 2-dimensional product. Our work builds upon the notion of the nondirectional blocking graph (NDBG) [23]. <p> Figure 2, also from <ref> [22] </ref>, gives an example of a 2D product as well as two directional blocking graphs for infinitesimal translation. Notice that a directed cut between subset S and subset T in a DBG represents a collision-free separation. <p> For a given class of motions, this set of blocking graphs completely captures the necessary geometric information for identifying all valid assembly sequences. Computational geometry techniques allow for the construction of the NDBG for a wide range of motion classes, including infinitesimal translations <ref> [22] </ref>, extended translations (i.e., to infinity) [22], multiple step translations [9], and infinitesimal generalized motions (i.e., rigid body motions) [8, 22]. For each of these families of motion, the NDBG framework immediately provides a polynomial time algorithm for constructing an assembly sequence. <p> For a given class of motions, this set of blocking graphs completely captures the necessary geometric information for identifying all valid assembly sequences. Computational geometry techniques allow for the construction of the NDBG for a wide range of motion classes, including infinitesimal translations <ref> [22] </ref>, extended translations (i.e., to infinity) [22], multiple step translations [9], and infinitesimal generalized motions (i.e., rigid body motions) [8, 22]. For each of these families of motion, the NDBG framework immediately provides a polynomial time algorithm for constructing an assembly sequence. <p> Computational geometry techniques allow for the construction of the NDBG for a wide range of motion classes, including infinitesimal translations [22], extended translations (i.e., to infinity) [22], multiple step translations [9], and infinitesimal generalized motions (i.e., rigid body motions) <ref> [8, 22] </ref>. For each of these families of motion, the NDBG framework immediately provides a polynomial time algorithm for constructing an assembly sequence. After constructing the set of DBG's, an arbitrary assembly sequence can be found by taking any legal separation in any direction, and re-cursing on the resulting subassemblies. <p> Our hope is that studying these primitive measures in depth can eventually lead to systems which will be able to specialize complexity measures for custom purposes. Many of these measures are generalizations of ideas introduced in <ref> [22] </ref>. Fewest Number of Directions. The cost of an assembly sequence is equal to the number of directions in F which are used. Once a direction has been used, future uses of the same direction are free of charge.
Reference: [23] <author> R. H. Wilson. </author> <title> On Geometric Assembly Planning. </title> <type> Ph.D. thesis, </type> <institution> Dept. Comput. Sci., Stanford Univ., Stanford, </institution> <address> CA, </address> <year> 1992. </year> <note> Stanford Technical Report STAN-CS-92-1416. </note>
Reference-contexts: The output is a sequence of operations resulting in the construction of the product from its individual parts. Each operation combines a set of subassemblies using a motion from the allowable set. The use of automation in assembly sequencing has increased rapidly over the years <ref> [1, 5, 10, 11, 12, 15, 16, 23, 24, 25, 26] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process. <p> For many of these restricted classes, polynomial algorithms were designed which find an assembly sequence if one exists <ref> [22, 23] </ref>. There are also algorithms which enumerate all possible assembly sequences [5], however there may be exponentially many such sequences for a product. A logical continuation is to use automated reasoning to find the "best" assembly sequence under a certain complexity measure. <p> Once this is done, each of the resulting subassemblies can be disassembled. This decomposition can be represented naturally as a binary tree. For a more detailed discussion, see <ref> [22, 23, 26] </ref>. Figure 1 gives an example, taken from [22], of such an assembly tree for a simple 2-dimensional product. Our work builds upon the notion of the nondirectional blocking graph (NDBG) [23]. <p> This decomposition can be represented naturally as a binary tree. For a more detailed discussion, see [22, 23, 26]. Figure 1 gives an example, taken from [22], of such an assembly tree for a simple 2-dimensional product. Our work builds upon the notion of the nondirectional blocking graph (NDBG) <ref> [23] </ref>.
Reference: [24] <author> R. H. Wilson, L. Kavraki, and T. Lozano-Perez. </author> <title> Two-handed assembly sequencing. </title> <type> Stanford Technical Report STAN-CS-93-1478, </type> <year> 1993. </year>
Reference-contexts: The output is a sequence of operations resulting in the construction of the product from its individual parts. Each operation combines a set of subassemblies using a motion from the allowable set. The use of automation in assembly sequencing has increased rapidly over the years <ref> [1, 5, 10, 11, 12, 15, 16, 23, 24, 25, 26] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process.
Reference: [25] <author> R. H. Wilson and J. F. Rit. </author> <title> Maintaining geometric dependencies in and assembly planner. </title> <booktitle> In Proc. IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 890-895, </pages> <year> 1990. </year>
Reference-contexts: The output is a sequence of operations resulting in the construction of the product from its individual parts. Each operation combines a set of subassemblies using a motion from the allowable set. The use of automation in assembly sequencing has increased rapidly over the years <ref> [1, 5, 10, 11, 12, 15, 16, 23, 24, 25, 26] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process. <p> Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process. Early systems resulted in inefficient generate-and-test sequencers, operating by generating candidate operations and testing their feasibility <ref> [12, 25] </ref>. Theoretical results show that assembly sequencing, in its most general form, is intractable [13, 14, 19, 26].
Reference: [26] <author> J. D. Wolter. </author> <title> On the Automatic Generation of Plans for Mechanical Assembly. </title> <type> Ph.D. thesis, </type> <institution> University of Michigan, </institution> <year> 1988. </year>
Reference-contexts: The output is a sequence of operations resulting in the construction of the product from its individual parts. Each operation combines a set of subassemblies using a motion from the allowable set. The use of automation in assembly sequencing has increased rapidly over the years <ref> [1, 5, 10, 11, 12, 15, 16, 23, 24, 25, 26] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process. <p> Early systems resulted in inefficient generate-and-test sequencers, operating by generating candidate operations and testing their feasibility [12, 25]. Theoretical results show that assembly sequencing, in its most general form, is intractable <ref> [13, 14, 19, 26] </ref>. This led some researchers to consider restricted, but still interesting, versions of the problem (e.g., monotone sequences, where each operation generates a final subassembly, and two-handed sequences, where every operation merges exactly two subassemblies). <p> Several researchers have acknowledged the need to extend automated reasoning to search for better assembly sequences, although with limited results. Several empirical measures have been suggested [2], and more formal complexity measures have been examined in a simplified system <ref> [26] </ref>. For a restricted class of inputs which have a "total ordering" property, an algorithm is given which produces the minimal length sequence to remove any given part [27]. <p> Once this is done, each of the resulting subassemblies can be disassembled. This decomposition can be represented naturally as a binary tree. For a more detailed discussion, see <ref> [22, 23, 26] </ref>. Figure 1 gives an example, taken from [22], of such an assembly tree for a simple 2-dimensional product. Our work builds upon the notion of the nondirectional blocking graph (NDBG) [23]. <p> Fewest Re-orientations. The cost of an assembly sequence is equal to the number of re-orientations necessary while performing the sequence <ref> [26] </ref>. Here, the cost of the output is not simply determined by the structure of the assembly tree, but also by the ordering of the steps.
Reference: [27] <author> T.C. Woo and D. Dutta. </author> <title> Automatic disassembly and total ordering in three dimensions. </title> <journal> J. Engineering for Industry, </journal> <volume> 113(2) </volume> <pages> 207-213, </pages> <year> 1991. </year>
Reference-contexts: Several empirical measures have been suggested [2], and more formal complexity measures have been examined in a simplified system [26]. For a restricted class of inputs which have a "total ordering" property, an algorithm is given which produces the minimal length sequence to remove any given part <ref> [27] </ref>. A hierarchical approach is used to identify common subassemblies in products [3], thereby allowing more effor to be used towards finding a "better" assembly sequence. Although practical, this technique simply delays the eventual need for better automated reasoning to overcome increasingly large data sets.
References-found: 27

