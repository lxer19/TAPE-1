URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS95-06.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: contact: probert@cs.ucsb.edu  
Title: Building Fundamentally Extensible Application-Specific Operating Systems in SPACE 1  
Author: Dave Probert and John Bruno 
Note: 1 This research was supported in part by a UC MICRO grant and the Xerox Corporation.  
Date: March 1995  
Address: Santa Barbara, California 93106  
Affiliation: Computer Science Department University of California  UCSB Computer Science  
Pubnum: TRCS95-06  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Dave Probert, John Bruno, and Murat Karaorman. </author> <title> Space: A new approach to operating system abstraction. </title> <booktitle> In Proceedings of the International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 133-137, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Spring [16] is a microkernel-based operating system developed to build operating systems out of replaceable parts. Spring makes heavy use of cross-domain calls and capability-based portals (called doors), similar to the earlier version of SPACE <ref> [1] </ref> but without the use of the address space as a name space for services, and without the extension of privilege modes. The Synthesis Kernel [7] demonstrated the value of eliminating operating system overhead through customization. <p> arbitrary portal type, it is straight forward to implement special signal types which guarantee separate delivery of each example or pass parameters to the handler. 6 Application-Specific Operating Systems in SPACE SPACE was originally investigated as a set of abstractions for structuring operating systems, using multiple paradigms to support extensibility <ref> [1] </ref>. What we have described in this paper is a natural extension: embedding operating system services within applications. To support application-specific operating systems, SPACE has evolved by increasing the generality of its paradigms, as well as further lowering the level of its abstractions to provide direct access to the hardware.
Reference: [2] <author> T.E. Anderson, H.M. Levy, B.N. Bershad, and E.D. Lazowska. </author> <title> The interaction of architecture and operating system design. </title> <booktitle> In ASPLOS IV, </booktitle> <pages> pages 108-120, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: One aspect of this decrease has been attributed to an increasing mismatch between hardware architecture and operating system abstractions <ref> [2] </ref>. 1 This research was supported in part by a UC MICRO grant and the Xerox Corporation. UCSB Computer Science TRCS95-06 March 1995 2 A further source of the performance problem is due to increasing application requirements for operating system functionality.
Reference: [3] <author> Andrew W. Appel and Kai Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In ASPLOS IV, </booktitle> <pages> pages 96-107, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Some of these requirements are due to the need for interoperability between applications running on different platforms, as well as portability from one platform to another. Others arise from a need for new abstractions to simplify application implementation (e.g. distributed shared memory <ref> [3] </ref> and efficient user-level threading [4]). Performance also affects functionality requirements by necessitating changes in interfaces and implementation. As application demands have been increasing, the complexity of the abstractions provided by operating systems are also increasing. More complexity means more code. Operating systems have become bloated. <p> SPACE decouples the virtual memory implementation from the address space. This allows multiple instances of virtual memory implementations to coexist within the system, or even within a single application. Virtual-memory-like mechanisms can be also used to implement other abstractions, such as garbage collectors, data-compression paging, and persistent stores <ref> [3] </ref>. The SPACE generalization of privilege provides for the implementation of protection domains. In single-kernel operating systems, each address space is part of two domains, corresponding to the two hardware privilege modes (user and supervisor).
Reference: [4] <author> Thomas. E. Anderson, Brian N. Bershad, Edward D. Lazowska, , and Henry M. Levy. </author> <title> Scheduler activations: Effecive kernel support for the user-level management of parallelism. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: Some of these requirements are due to the need for interoperability between applications running on different platforms, as well as portability from one platform to another. Others arise from a need for new abstractions to simplify application implementation (e.g. distributed shared memory [3] and efficient user-level threading <ref> [4] </ref>). Performance also affects functionality requirements by necessitating changes in interfaces and implementation. As application demands have been increasing, the complexity of the abstractions provided by operating systems are also increasing. More complexity means more code. Operating systems have become bloated.
Reference: [5] <author> Brent Welch. </author> <title> The file system belongs in the kernel. </title> <booktitle> In USENIX Mach Symposium, </booktitle> <pages> pages 233-250, </pages> <address> Monterey, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: As application demands have been increasing, the complexity of the abstractions provided by operating systems are also increasing. More complexity means more code. Operating systems have become bloated. Even microkernels can exceed fifty thousand lines of source code <ref> [5] </ref>. The increasingly complex abstractions are multiplexed through a procedure-call system interface, and then internally demultiplexed according to the parameters and the current system state. As an example of the impact of generic operating system abstraction on performance, consider the I/O subsystem in UNIX.
Reference: [6] <author> Berny Goodheart and James Cox. </author> <title> The Magic Garden Explained. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: Consider a read from a UNIX filesystem disk in System V Release 4. The read execution path passes through the following layers and interfaces <ref> [6] </ref>: trap, syscall, vnode, ufs-read, inode, uio, trap, page-fault, address-space-fault, vnode-segfault, ufs-pagein, buffer-cache-read, raw-device-switch, and finally the device-driver Along the way much code is devoted to demultiplexing various operations and conditions, as well as checking for errors.
Reference: [7] <author> Henry Massalin. </author> <title> Synthesis: an efficient implementation of fundamental operating system services. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <year> 1993. </year>
Reference-contexts: The goals of sharing and protection are achieved by this type of implementation, but the cost in performance is high. This cost can be quantified by considering systems which tailor system services for applications. The Synthesis Kernel <ref> [7] </ref> synthesizes specialized code for read/write when an application opens a file. Performance (versus SunOS 3.5) for UNIX pipe operations was improved by 4-6 times for larger buffer sizes (4096-1024 bytes), and 56 times for single bytes. <p> Spring makes heavy use of cross-domain calls and capability-based portals (called doors), similar to the earlier version of SPACE [1] but without the use of the address space as a name space for services, and without the extension of privilege modes. The Synthesis Kernel <ref> [7] </ref> demonstrated the value of eliminating operating system overhead through customization. However Synthesis generates code to efficiently implement a standard set of abstractions rather than building custom abstractions for embedding system services into applications.
Reference: [8] <author> Adrian Nye, </author> <title> editor. Volume 0, X Protocol Reference Manual. The X Window System. </title> <publisher> O'Reilly & Associates, </publisher> <address> Sebastopol, CA, </address> <year> 1992. </year>
Reference-contexts: The overhead of the I/O in the UNIX implementation is so high that it must be amortized over large transfers to even approach the performance of the specialized code. Batching of service requests has been applied not only to file I/O, but also to network protocols <ref> [8] </ref>. Unfortunately there are many applications where batching is difficult, such as client-server RPC using small messages, or fine grain concurrency in multiprocessors.
Reference: [9] <author> Michael J. Spier, Thomas N. Hastings, and David N. Cutler. </author> <title> A storage mapping technique for the implementation of protective domains. </title> <journal> Software-Practice and Experience, </journal> <volume> 4 </volume> <pages> 215-230, </pages> <year> 1974. </year>
Reference-contexts: In single-kernel operating systems, each address space is part of two domains, corresponding to the two hardware privilege modes (user and supervisor). In SPACE an arbitrary number of domains can exist in an address space, each associated with a different privilege mode. Protection domains are useful for modularizing software <ref> [9] </ref>, and insuring the integrity of shared data structures. Applications can be selective about which pages in their address space they expose to system services. System services can be implemented by applications. <p> However, in making these trade-offs they will not be constrained by operating system abstractions that failed to anticipate their requirements. 3 Related Work Extension of the user/supervisor privilege levels into an arbitrary number of protection domains is a very old idea (e.g. <ref> [9] </ref>). Multics [10] used eight hierarchical rings of protection. VAX/VMS used four hierarchical privilege modes [11]. Both Multics and VMS used a layered approach to O/S implementation, as popularized by Dijkstra [12]. Layered systems are successful at managing complexity, but have difficulty supporting alternative implementations of particular services.
Reference: [10] <author> Michael D. Schroeder and Jerome H. Saltzer. </author> <title> A hardware architecture for implementing protection rings. </title> <journal> Communications of the ACM, </journal> <volume> 15(3) </volume> <pages> 157-170, </pages> <month> March </month> <year> 1972. </year>
Reference-contexts: However, in making these trade-offs they will not be constrained by operating system abstractions that failed to anticipate their requirements. 3 Related Work Extension of the user/supervisor privilege levels into an arbitrary number of protection domains is a very old idea (e.g. [9]). Multics <ref> [10] </ref> used eight hierarchical rings of protection. VAX/VMS used four hierarchical privilege modes [11]. Both Multics and VMS used a layered approach to O/S implementation, as popularized by Dijkstra [12]. Layered systems are successful at managing complexity, but have difficulty supporting alternative implementations of particular services.
Reference: [11] <author> Lawrence J. Kenah and Simon F. Bate. </author> <title> VAX/VMS Internals and Data Structures. </title> <publisher> Digital Press, </publisher> <address> Bedford, Massachusetts, </address> <year> 1984. </year>
Reference-contexts: Multics [10] used eight hierarchical rings of protection. VAX/VMS used four hierarchical privilege modes <ref> [11] </ref>. Both Multics and VMS used a layered approach to O/S implementation, as popularized by Dijkstra [12]. Layered systems are successful at managing complexity, but have difficulty supporting alternative implementations of particular services.
Reference: [12] <author> E.W. Dijkstra. </author> <title> The structure of the the-multiprogramming system. </title> <journal> Communications of the ACM, </journal> <volume> 11(5) </volume> <pages> 341-360, </pages> <month> May </month> <year> 1968. </year>
Reference-contexts: Multics [10] used eight hierarchical rings of protection. VAX/VMS used four hierarchical privilege modes [11]. Both Multics and VMS used a layered approach to O/S implementation, as popularized by Dijkstra <ref> [12] </ref>. Layered systems are successful at managing complexity, but have difficulty supporting alternative implementations of particular services. Spier used the four privilege modes on the PDP 11/45 to implement domain-based software, but the goal was to improve modularization and fault isolation in application software, rather than embedding operating system services.
Reference: [13] <author> Elliott I. Organick. </author> <title> A Programmer's View of the Intel 432 System. </title> <publisher> McGraw Hill, </publisher> <year> 1983. </year>
Reference-contexts: The i432 architecture was designed to support O/S implementation using address spaces as independent protection domains, avoiding the user/supervisor dichotomy <ref> [13] </ref>. The system was segment and descriptor based, and used the descriptors to implement access control. Low-level operating system abstractions in the i432 were embedded in the microcode, but they were too expensive to achieve acceptable performance.
Reference: [14] <author> Mike Accetta, Robert Baron, William Bolosky, David Golub, Richard Rashid, Avadis Tevanian, and Michael Young. </author> <title> Mach: a new kernel foundation for unix development. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 93-112, </pages> <address> Atlanta, </address> <month> Summer </month> <year> 1986. </year>
Reference-contexts: Low-level operating system abstractions in the i432 were embedded in the microcode, but they were too expensive to achieve acceptable performance. The i432 is an example of operating system primitives which try to be too general to be generally useful. Mach <ref> [14] </ref> made a substantial contribution to decentralizing operating system design by using a microkernel that retained process, virtual memory abstractions, and interprocess communication primitives while relegating other system services to servers. SPACE goes further by moving even process, VM, and IPC out of the kernel. <p> The simple form of RPC we have described here is particularly powerful because applications can make implementation trade-offs to suit their requirements. It can be as efficient as the hardware will allow. Microkernel/server implementations of operating systems, such as Mach <ref> [14] </ref>, have suffered from performance limitations due to the overhead of calls to the servers. In SPACE this overhead can be reduced by using specialized portal types and exception mappings.
Reference: [15] <author> J.S. Chase, H.M. Levy, M.J. Feeley, and E.D. Lazowska. </author> <title> Sharing and protection in a single-address-space operating system. </title> <journal> Communications of the ACM, </journal> <volume> 12(4) </volume> <pages> 271-307, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: The fundamental communication primitive in SPACE is a cross-domain call which can be implemented much more efficiently than the general message passing primitives in Mach, avoiding the performance problems which have been a major problem with the microkernel approach. Several recent systems use protection domains. Opal <ref> [15] </ref> is an investigation into using a single large address space for running complex applications. Privilege domains are used to manage sharing and protection. Portals between domains are implemented using an explicit capability mechanism rather than an abstraction of the exception mechanism, as in SPACE.
Reference: [16] <author> Graham Hamilton and Panos Kougiouris. </author> <title> The spring nucleus: A microkernel for objects. </title> <booktitle> In USENIX Summer Conference Proceedings, </booktitle> <pages> pages 147-160, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Opal [15] is an investigation into using a single large address space for running complex applications. Privilege domains are used to manage sharing and protection. Portals between domains are implemented using an explicit capability mechanism rather than an abstraction of the exception mechanism, as in SPACE. Spring <ref> [16] </ref> is a microkernel-based operating system developed to build operating systems out of replaceable parts.
Reference: [17] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: The Synthesis Kernel [7] demonstrated the value of eliminating operating system overhead through customization. However Synthesis generates code to efficiently implement a standard set of abstractions rather than building custom abstractions for embedding system services into applications. Sandboxing <ref> [17] </ref> is a technique developed to allow embedding of untrusted application code inside trusted programs, such as an operating system kernel. The untrusted code is modified to control access to external code and data.
Reference: [18] <author> Chandramohan A. Thekkath and Henry M. Levy. </author> <title> Hardware and software support for efficient exception handling. </title> <booktitle> In ASPLOS VI, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: A number of researchers have investigated providing mechanisms to allow applications to exploit hardware facilities, such as exception handling and memory management. Efficient handling of synchronous exceptions is explored by Thekkath and Levy <ref> [18] </ref>. The Tempest interface [19] provides low-level mechanisms allowing implementation of shared-memory semantics within applications. Earlier work with the Wisconsin Wind Tunnel interface [20] provided untrusted application code with protected access to memory management functions. The SPIN operating system [21] has similar goals to SPACE.
Reference: [19] <author> Steven K. Reinhardt, James R. Larus, and David A. Wood. Tempest and typhoon: </author> <title> User-level shared memory. </title> <booktitle> In Proceedings of the 21st International Symposium on Computer Architecture, </booktitle> <month> April </month> <year> 1994. </year> <note> UCSB Computer Science TRCS95-06 March 1995 16 </note>
Reference-contexts: A number of researchers have investigated providing mechanisms to allow applications to exploit hardware facilities, such as exception handling and memory management. Efficient handling of synchronous exceptions is explored by Thekkath and Levy [18]. The Tempest interface <ref> [19] </ref> provides low-level mechanisms allowing implementation of shared-memory semantics within applications. Earlier work with the Wisconsin Wind Tunnel interface [20] provided untrusted application code with protected access to memory management functions. The SPIN operating system [21] has similar goals to SPACE.
Reference: [20] <author> Steven K. Reinhardt, Babak Falsafi, and David A. Wood. </author> <title> Kernel support for the Wisconsin Wind Tunnel. </title> <booktitle> In Second USENIX Symposium on Microkernels and Other Kernel Architectures, </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: Efficient handling of synchronous exceptions is explored by Thekkath and Levy [18]. The Tempest interface [19] provides low-level mechanisms allowing implementation of shared-memory semantics within applications. Earlier work with the Wisconsin Wind Tunnel interface <ref> [20] </ref> provided untrusted application code with protected access to memory management functions. The SPIN operating system [21] has similar goals to SPACE. It supports application-specific operating system services through an extensible microkernel and application-specific spindles, which are mounted on the microkernel to encapsulate policy decisions.
Reference: [21] <author> Brian Bershad, Craig Chambers, Susan Eggers, and et. al. </author> <title> SPIN an extensible microkernel for application-specific operating system services. </title> <type> Technical Report 94-03-03, </type> <institution> Dept. of Comp. Sci. and Eng., University of Washington, </institution> <address> Seattle, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: The Tempest interface [19] provides low-level mechanisms allowing implementation of shared-memory semantics within applications. Earlier work with the Wisconsin Wind Tunnel interface [20] provided untrusted application code with protected access to memory management functions. The SPIN operating system <ref> [21] </ref> has similar goals to SPACE. It supports application-specific operating system services through an extensible microkernel and application-specific spindles, which are mounted on the microkernel to encapsulate policy decisions. Spindles are a higher-level abstraction than the primitives in SPACE.
Reference: [22] <author> Dawson R. Engler, M. Frans Kaashoek, and James W. O'Toole Jr. Aegis: </author> <title> A secure programmable exokernel. </title> <booktitle> In Proceedings of the Sixth European SIGOPS workshop, </booktitle> <address> Wadern, Germany, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: However the use UCSB Computer Science TRCS95-06 March 1995 8 of language mechanisms to ensure the safe integration of spindles with the microkernel is similar to the technique we are investigating for customizing generalized exceptions and portal types. The Exokernel approach to operating systems <ref> [22] </ref> most closely mirrors the philosophy embodied in SPACE: make operating system abstractions optional. Exokernels replace standard abstractions, such as processes and virtual memory, with mechanisms in the kernel which export raw physical resources to applications directly.
Reference: [23] <institution> SPARC Technology Business. </institution> <note> SuperSPARC & MultiCache Controller User's Manual. </note> <institution> SUN Microsystems, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: One architecture which has these characteristics is the SuperSPARC RISC processor <ref> [23] </ref>, found in SPARCstation 10 workstations, the Meiko CS-2 scalable parallel computer, and elsewhere. When a hardware exception occurs, the SuperSPARC processor begins execution of the instructions in the hardware trap vector within a few clocks of detecting the exception.
Reference: [24] <author> SPARC International, Inc. </author> <title> The SPARC Architecture Manual Version 8. </title> <publisher> Prentice Hall, </publisher> <address> 1992. </address> <publisher> Appendix H. </publisher>
Reference-contexts: The instruction and data caches are physical, and the TLBs are tagged so that neither the caches nor the TLB must be flushed during a context switch. These features allow cross-domain calls to be efficiently implemented. The SuperSPARC uses a SPARC reference MMU <ref> [24] </ref>, which tags the TLB entries with a 16-bit context identifier. Multi-level tablewalks are used to handle TLB misses in hardware, by walking the tree of page tables. The 16-bits of context identifier is more than adequate for simulating privilege modes through overlapping AMU contexts.
Reference: [25] <author> Andrew D. Birrell and Bruce Jay Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: Though originally focussed on accessing remote services across a network <ref> [25] </ref>, RPC is just as useful for implementing client-server mechanisms within a single machine. Portal traversal is a natural mechanism for implementation of RPC between protection domains.
Reference: [26] <author> Michael Young, Avadis Tevanian, Richard Rashid, David Golub, Jeffrey Eppinger, Jonathan Chew, William Bolosky, David Black, and Robert Baron. </author> <title> The duality of memory and communication in the implementation of a multiprocessor operating system. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-76, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: For small amounts of data, the argument memory can be statically shared, but dynamically allocated. For large amounts of data, dynamic sharing of data is used, as in the Mach integration of IPC and virtual memory <ref> [26] </ref>. However, if the RPC domains are within a single address space, the sharing is done by allowing access to memory from both privilege modes.
References-found: 26

