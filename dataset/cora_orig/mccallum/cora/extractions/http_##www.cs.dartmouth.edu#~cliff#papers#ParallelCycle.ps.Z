URL: http://www.cs.dartmouth.edu/~cliff/papers/ParallelCycle.ps.Z
Refering-URL: http://www.cs.dartmouth.edu/~cliff/papers/
Root-URL: http://www.cs.dartmouth.edu
Title: A Parallel Algorithm for Eliminating Cycles in Undirected Graphs  
Author: Philip Klein Clifford Stein 
Keyword: parallel algorithms, undirected graphs, cycles, Euler tour.  
Address: Providence, RI  Cambridge, MA  
Affiliation: Computer Science Department Brown University  Laboratory for Computer Science MIT  
Abstract: We give an efficient parallel algorithm for finding a maximal set of edge-disjoint cycles in an undirected graph. The algorithm can be generalized to handle a weighted version of the problem.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. J. Anderson and G. L. Miller, </author> <title> "Deterministic Parallel List Ranking," </title> <note> pp. 81-90, Aegean Workshop on Computing 88, published as Lecture Notes in Computer Science 319, Springer-Verlag, </note> <year> 1988. </year>
Reference-contexts: Step 3 can be implemented in O (log n) time using (n + m)= log n processors by the list-ranking algorithm of Cole and Vishkin [4] or that of Anderson and Miller <ref> [1] </ref>. A naive implementation of step 2 consists of summing at most m n + 1 vectors of length m. This approach takes O (log n) time but requires about m 2 processors.
Reference: [2] <author> B. Awerbach, A. Israeli, and Y. Shiloach, </author> <title> "Finding Euler circuits in logarithmic parallel time," </title> <booktitle> in Proceedings of the 16th Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1984, </year> <pages> pp. 249-257. </pages>
Reference-contexts: Euler showed that a graph has an Eulerian cycle if and only if the graph is connected and every vertex in the graph has even degree. Moreover, there is a linear time sequential algorithm which, given an Eulerian graph, finds an Eulerian cycle. Awerbach, Israeli, and Shiloach <ref> [2] </ref> have given a parallel fl Research partially supported by ONR grant N00014-88-K-0243 and DARPA grant N00039-88-C0113 at Harvard University y Research supported by a graduate fellowship from GE. <p> Except for steps 5 and 6, each step takes constant time on n + m processors or O (log n) time on (n + m)= log n processors. By looking at the spanning tree algorithm of <ref> [2] </ref>, it is easy to see that given an acyclic set of edges which have to be in 7 the spanning tree, the problem only becomes easier, thus steps 5 and 6 can be done in the same time as the algorithm in the previous section.
Reference: [3] <author> C. Berge, </author> <title> Graphs and Hypergraphs, </title> <publisher> North Holland Mathematical library, </publisher> <year> 1979. </year> <month> 8 </month>
Reference-contexts: It is well known that this collection of cycle vectors f (C (e))je 62 F g forms a cycle basis, i.e. a set of linearly independent vectors which span the cycle space. <ref> [3] </ref> We will refer to this particular basis as B. 3 The Algorithm Consider the even-degree subgraph H obtained by adding together mod 2 all the cycles C (e) 2 B. That is, H is defined by (H) = e62F where the sum is elementwise mod 2.
Reference: [4] <author> R. Cole and U. Vishkin, </author> <title> "Optimal parallel algorithms for expression tree evalua-tion and list ranking," </title> <note> pp. 91-100, Aegean Workshop on Computing 88, published as Lecture Notes in Computer Science 319, Springer-Verlag, </note> <year> 1988. </year>
Reference-contexts: Step 3 can be implemented in O (log n) time using (n + m)= log n processors by the list-ranking algorithm of Cole and Vishkin <ref> [4] </ref> or that of Anderson and Miller [1]. A naive implementation of step 2 consists of summing at most m n + 1 vectors of length m. This approach takes O (log n) time but requires about m 2 processors.
Reference: [5] <author> J. Edmonds and R. M. Karp. </author> <title> "Theoretical improvements in algorithmic efficiency for network flow problems." </title> <journal> Journal of the ACM, </journal> <volume> 19 </volume> <pages> 248-264, </pages> <year> 1972. </year>
Reference-contexts: Our parallel algorithm to find such a solution takes O (log n log M ) time using n + m processors. Our approach to solving the maximal disjoint cycles problem will involve the use of scaling, first introduced by Edmonds and Karp <ref> [5] </ref>. Define the maximum cycle multiplicity of a multigraph to be max min fu (e)g; where C is the set of all cycles in G 0 . Our general approach will be to remove cycles of high multiplicity.
Reference: [6] <author> H. Gabow, </author> <title> "Scaling algorithms for network scaling problems." </title> <journal> Journal of Computer and System Sciences 31, </journal> <year> 1985, </year> <pages> pp. 148-168. </pages>
Reference-contexts: We conclude with two observations. First, assuming similarity, i.e. M = O (n k ) for some constant k <ref> [6] </ref>, this algorithm runs in O (log 2 n) time on m processors. As in the simple case, the processor bound can be reduced by a factor of O (log n) using randomization. Second, observe that when we removed a cycle we always assigned it a multiplicity of =2.
Reference: [7] <author> H. Gazit, </author> <title> "An optimal randomized parallel algorithm for finding connected components in a graph," </title> <booktitle> Proc. 27th Annual Symp. on Foundations of Computer Science (1986), </booktitle> <pages> pp. 492-501 </pages>
Reference-contexts: Step 3: Decompose H into edge-disjoint cycles. Step 1 can be implemented in O (log n) time using n+m processors by the spanning tree algorithm of Shiloach and Vishkin [13], or using (n + m)= log n time by the randomized algorithm of Gazit <ref> [7] </ref>. Step 3 can be implemented in O (log n) time using (n + m)= log n processors by the list-ranking algorithm of Cole and Vishkin [4] or that of Anderson and Miller [1].
Reference: [8] <author> A. Goldberg, S. Plotkin, and G. Shannon, </author> <title> "Parallel symmetry-breaking in sparse graphs," </title> <booktitle> in Proceedings of the 19th Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1987, </year> <pages> pp. 315-324. </pages>
Reference: [9] <author> A. Goldberg, and R. Tarjan, </author> <title> "Finding Minimum-Cost Circulations by Canceling Negative Cycles," </title> <booktitle> in Proceedings of the 20th Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1988, </year> <pages> pp. 388-397. </pages>
Reference-contexts: A maximal set of weighted cycles corresponds directly to a set of capacitated cycles such that, after flow is pushed around these cycles, the graph of edges which still have positive capacity is acyclic. Goldberg and Tarjan <ref> [9] </ref> solve the minimum-cost circulation problem by repeatedly finding a maximal set of weighted cycles; they show how to solve the latter problem sequentially in O (m log n) time.
Reference: [10] <author> R. Karp and V. Ramachandran. </author> <title> "A survey of parallel algorithms for shared-memory machines," </title> <type> Technical Report UCB/CSD 88/408, </type> <institution> Computer Science Division (EECS), University of California, Berkeley, </institution> <address> CA, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: We give a parallel algorithm that solves this problem for n-node, m-edge undirected graphs in O (logn) time on n+m processors on a concurrent-read concurrent-write parallel random access machine (CRCW PRAM) <ref> [10] </ref>. In fact, using randomization, our algorithm can be implemented to run in O (log n) time using only (n + m)= log n processors. Since the problem requires (n + m) operations in the worst case, the resulting randomized algorithm is optimal in its use of parallelism.
Reference: [11] <author> G. Miller and J. Reif, </author> <title> "Parallel Tree Contraction and its Applications," </title> <booktitle> in Proceedings, 26th IEEE Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1985, </year> <pages> pp. 478-489. </pages>
Reference: [12] <author> K. Mulmuley, U.V. Vazirani, and V.V. Vazirani, </author> <title> "Matching is as easy as matrix inversion," </title> <booktitle> in Proceedings of the 19th Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1987, </year> <pages> pp. 345-354. </pages>
Reference-contexts: At present, the most efficient parallel algorithm for this problem uses a reduction to weighted non-bipartite matching, which takes O (log 2 n) time on Mn 3:5 m processors, and uses randomization <ref> [12] </ref> . 2 Preliminaries Let G = (V; E) be an n-node undirected graph with node set V and edge set E = fe 1 ; : : : ; e m g. Let f0; 1g E denote the m-dimensional vector space over GF (2).
Reference: [13] <author> Y. Shiloach and U. Vishkin, </author> <title> "An O(log n) parallel connectivity algorithm," </title> <booktitle> Journal of Algorithms 3 (1982), </booktitle> <pages> pp. 57-67. </pages>
Reference-contexts: Step 2: Determine the subgraph H of G by (2). Step 3: Decompose H into edge-disjoint cycles. Step 1 can be implemented in O (log n) time using n+m processors by the spanning tree algorithm of Shiloach and Vishkin <ref> [13] </ref>, or using (n + m)= log n time by the randomized algorithm of Gazit [7]. Step 3 can be implemented in O (log n) time using (n + m)= log n processors by the list-ranking algorithm of Cole and Vishkin [4] or that of Anderson and Miller [1].
Reference: [14] <author> R. Tarjan and U. Vishkin, </author> <title> "Finding biconnected components and computing tree functions in logarithmic parallel time," </title> <booktitle> in Proceedings, 25th IEEE Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1984, </year> <pages> pp. 12-22. 9 </pages>
Reference-contexts: Hence for each node x of G, the number of descendants of x in A that are new nodes gives the value of (4). Using Tree Tour <ref> [14] </ref>, we can compute these values for all old nodes x of G simultaneously, in O (log n) time using (n + m)= log n processors.
References-found: 14

