URL: http://www.math.macalester.edu/~fox/old/cs62-97/macros.ps
Refering-URL: http://www.math.macalester.edu/~fox/old/cs62-97/page.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Programmable Syntax Macros  
Author: Daniel Weise Roger Crew 
Affiliation: Microsoft Research Laboratory  
Abstract: Lisp has shown that a programmable syntax macro system acts as an adjunct to the compiler that gives the programmer important and powerful abstraction facilities not provided by the language. Unlike simple token substitution macros, such as are provided by CPP (the C preprocessor), syntax macros operate on Abstract Syntax Trees (ASTs). Programmable syntax macro systems have not yet been developed for syntactically rich languages such as C because rich concrete syntax requires the manual construction of syntactically valid program fragments, which is a tedious, difficult, and error prone process. Also, using two languages, one for writing the program, and one for writing macros, is another source of complexity. This research solves these problems by having the macro language be a minimal extension of the programming language, by introducing explicit code template operators into the macro language, and by using a type system to guarantee, at macro definition time, that all macros and macro functions only produce syntactically valid program fragments. The code template operators make the language context sensitive, which requires changes to the parser. The parser must perform type analysis in order to parse macro definitions, or to parse user code that invokes macros. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> ANSI Standard on C, X3.159-1989, ANSI, </institution> <address> NY, </address> <year> 1990. </year>
Reference-contexts: We count pre-ANSI CPP as character based because many of them were. Token Macros operate on the tokenized representation of a program. They operate after (or in conjunction with) the tokenizer. Token based macro systems are simple to implement. Most assembler macro languages and the well known CPP <ref> [1] </ref> are token based. Semantic Macros are an extension of syntax macros that have access to, and can make decisions based upon, semantic information maintained by the static semantic analyzer. Semantic macros are the most powerful method for extending a language. 1.
Reference: [2] <author> Cameron, R. D., </author> <title> "Software reuse with metaprogram-ming systems," </title> <booktitle> Proceedings of the Fifth Annual Pacific Northwest Software Quality Conference, </booktitle> <address> OR, </address> <pages> pp. 223-32, </pages> <year> 1987 </year>
Reference-contexts: For example, the meta-programming system of <ref> [2] </ref> heavily uses this style of coding. We solved the problem of concisely generating syntactically valid program fragments in a programmable system by adding explicit template operators to the macro language that provide the convenience of substitution semantics. <p> NULL) error ("No handler for %d", $value); else longjmp (exception_ptr,$value);-); else return ( `-int the_value = $value; if (exception_ptr == NULL) error ("No handler for %d", the_value); else longjmp (exception_ptr, the_value);-);- syntax stmt catch -| $$exp::tag - $$stmt::handler - $$stmt::body - |- -return ( `-int *old_exception_ptr = exception_ptr; int jmp_buf <ref> [2] </ref>; int result; result = setjump (jmp_buf); if (result == 0) -exception_ptr = jmp_buf; $body-else -exception_ptr = old_exception_ptr; if (result == $tag) $handler else throw result;--);- syntax stmt unwind_protect -| - $$stmt::body - $$stmt::cleanup |- -return ( `-int *old_exception_ptr = exception_ptr; int jmp_buf [2]; int result = setjump (jmp_buf); if (result <p> ( `-int *old_exception_ptr = exception_ptr; int jmp_buf <ref> [2] </ref>; int result; result = setjump (jmp_buf); if (result == 0) -exception_ptr = jmp_buf; $body-else -exception_ptr = old_exception_ptr; if (result == $tag) $handler else throw result;--);- syntax stmt unwind_protect -| - $$stmt::body - $$stmt::cleanup |- -return ( `-int *old_exception_ptr = exception_ptr; int jmp_buf [2]; int result = setjump (jmp_buf); if (result = 0) -exception_ptr = jmp_buf; $body-exception_ptr = old_exception_ptr; $cleanup; if (result != 0) throw result;-);- Page 8 (Note, these examples ignore the problem of variable cap-ture caused by the introduction of new names that might match names in substituted code. <p> Persistence code, RPC code, dialog boxes, etc., can be automatically created when data is declared. The problem of automatically constructing such routine code has been addressed before in the meta-programming literature. For example, <ref> [2] </ref> presents a meta-program for automatically constructing reading and writing functions for Pascal enumerated types. Because that system didn't have code templates, the code for doing so is rather bulky and unwieldy. By using code templates, we achieve a similar effect with far less code that is far more readable.
Reference: [3] <author> Campbell, W. R., </author> <title> "A compiler definition facility based on the Syntactic Macro," </title> <journal> Computer Journal 21(1), </journal> <pages> pp. 35-41, </pages> <year> 1975 </year>
Reference-contexts: His macro system was substitution based, that is, macro bodies are ASTs whose leaves are formal parameters that are replaced at invocation time with actual parameters. Our use of the term "Syntax Macro" refers to Vidart's use of the term. W. R. Campbell <ref> [3] </ref> proposed a paper extension to Vidart's work that extended it towards programmability, but in an ad hoc fashion. No implementation was reported for Campbell's extension. The major advantages of syntax macros are syntactic safety, encapsulation, and syntactic abstraction. <p> Except for the last macro example, all macros shown in this paper worked in the previous implementation. Once the re-implementation is complete, we will conduct large scale experiments with the macro system. Besides the systems already mentioned <ref> [14, 3, 4, 9] </ref>, there's current work on new macro systems for syntactically rich languages. Todd Jonker [7] is working on hygienic macro technology for syntactically rich languages. William Mad-dox at Berkeley is investigating extensions of his Master's thesis [10] that give macros semantic abilities.
Reference: [4] <author> Cheatham, T. E., </author> <title> "The introduction of definitional facilities into higher level programming languages," </title> <journal> pp. </journal> <pages> 623-637, </pages> <booktitle> Proc. AFIPS (Fall Joint Computer Conference, </booktitle> <volume> 29), </volume> <year> 1966 </year>
Reference-contexts: This information is used by the parser to ensure macro invocations only occur where their return type is expected. For example, syntax macros that return statements can only occur where statements are allowed by the grammar. Syntax macros were independently introduced by Cheatham <ref> [4] </ref> and Leavenworth [9] in the middle 60's. They proposed that the actual parameters to macro invocations be found by a parser, and that the syntactic type of a macros return result be part of a macro definition. <p> Except for the last macro example, all macros shown in this paper worked in the previous implementation. Once the re-implementation is complete, we will conduct large scale experiments with the macro system. Besides the systems already mentioned <ref> [14, 3, 4, 9] </ref>, there's current work on new macro systems for syntactically rich languages. Todd Jonker [7] is working on hygienic macro technology for syntactically rich languages. William Mad-dox at Berkeley is investigating extensions of his Master's thesis [10] that give macros semantic abilities.
Reference: [5] <author> Harbison, S., and Steele, G., </author> <title> C, A Reference Manual, Third Edition, </title> <publisher> Prentice Hall, </publisher> <year> 1991 </year>
Reference-contexts: The macro language adds two new top-level-declarations to the grammar of C: meta-declarations and macro-definitions. These top-level declarations, which are prefaced by the keywords metadecl and syntax, respectively, declare elements of the meta-program that define macro transformations. Our syntactic descriptions follow the conventions of <ref> [5] </ref>. Non-terminals of the original C language appear in italic type. Non-terminals in our extensions to C appear in boldface type. All concrete tokens appear in typewriter type. Alternatives in a production are listed on separate lines. <p> The macro languages add the following seven meta-tokens to C: (|, f|, |g, $$, $, ::, and @. The syntactic clauses we present are meant to augment the syntax rules given in <ref> [5] </ref>. That is, the reader should assume that the syntax clauses of [5] are part of our syntactic definition of the macro language. Our rules either replace, or add to, this base set of rules. <p> The macro languages add the following seven meta-tokens to C: (|, f|, |g, $$, $, ::, and @. The syntactic clauses we present are meant to augment the syntax rules given in <ref> [5] </ref>. That is, the reader should assume that the syntax clauses of [5] are part of our syntactic definition of the macro language. Our rules either replace, or add to, this base set of rules.
Reference: [6] <author> Hieb, R., Dybvig, R. K., Bruggeman, C., </author> <title> "Syntactic abstraction in Scheme," </title> <institution> University of Indiana Computer Science Technical Report 355, </institution> <address> 18 pages, </address> <month> June </month> <year> 1992 </year> <month> (Revised July </month> <year> 1992). </year>
Reference-contexts: substitution of identifiers. (Our code template mechanism was modeled after Lisp's [12].) We have designed, and have mostly implemented, a programmable macro system for C that has the following attributes: Page 2 Programmability/Macro Basis Character Token Syntax Semantic Full Programming Language GPM [13] 360 Assembler MS 2 Maddox Lisp, Scheme <ref> [6] </ref> Repetition & Conditional Bliss [15] M5 Repetition Hygienic Macros [8] Substitution Pre-ANSI CPP ANSI CPP Cheatham Vidart System). Character Macros operate at the character level. They transform streams of characters into streams of characters. We count pre-ANSI CPP as character based because many of them were. <p> In the Lisp community, "Hygienic Macros" [8] and "syntactic abstractions" have been proposed for making macros easier and cleaner to write. Such macro systems automatically avoid unanticipated capture of free variables. Early hygienic macro system were substitution based and had support for repetition. More recent research <ref> [6] </ref> has given hygienic macro systems complete programming power. We feel that hygienic macro systems are very important, and are considering methods for making our system be hygienic and referentially transparent. In a sense, this research has brought C up to 1970's Lisp macro technology.
Reference: [7] <author> Jonker, Todd, </author> <type> Personal Communication, </type> <year> 1992 </year>
Reference-contexts: Once the re-implementation is complete, we will conduct large scale experiments with the macro system. Besides the systems already mentioned [14, 3, 4, 9], there's current work on new macro systems for syntactically rich languages. Todd Jonker <ref> [7] </ref> is working on hygienic macro technology for syntactically rich languages. William Mad-dox at Berkeley is investigating extensions of his Master's thesis [10] that give macros semantic abilities. Dain Samples has recently announced M5 [11], another token-based macro system.
Reference: [8] <author> Kohlbecker, Eugene, Friedman, Daniel P., Felleisen, Matthias, Duba, Bruce, </author> <title> "Hygienic macro expansion," </title> <booktitle> Proceedings of the 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 151-161, </pages> <publisher> ACM Press, </publisher> <address> NY, </address> <year> 1986 </year>
Reference-contexts: Lisp's [12].) We have designed, and have mostly implemented, a programmable macro system for C that has the following attributes: Page 2 Programmability/Macro Basis Character Token Syntax Semantic Full Programming Language GPM [13] 360 Assembler MS 2 Maddox Lisp, Scheme [6] Repetition & Conditional Bliss [15] M5 Repetition Hygienic Macros <ref> [8] </ref> Substitution Pre-ANSI CPP ANSI CPP Cheatham Vidart System). Character Macros operate at the character level. They transform streams of characters into streams of characters. We count pre-ANSI CPP as character based because many of them were. Token Macros operate on the tokenized representation of a program. <p> Dain Samples has recently announced M5 [11], another token-based macro system. It is a very general macro processor that can be programmed to understand the lexical conventions of different languages (e.g., C, C++, Ada, and Tex). In the Lisp community, "Hygienic Macros" <ref> [8] </ref> and "syntactic abstractions" have been proposed for making macros easier and cleaner to write. Such macro systems automatically avoid unanticipated capture of free variables. Early hygienic macro system were substitution based and had support for repetition. More recent research [6] has given hygienic macro systems complete programming power.
Reference: [9] <author> Leavenworth, B. M., </author> <title> "Syntax Macros and Extended Translation," </title> <journal> CACM 9(11), </journal> <pages> pp. 790-793, </pages> <year> 1966 </year>
Reference-contexts: This information is used by the parser to ensure macro invocations only occur where their return type is expected. For example, syntax macros that return statements can only occur where statements are allowed by the grammar. Syntax macros were independently introduced by Cheatham [4] and Leavenworth <ref> [9] </ref> in the middle 60's. They proposed that the actual parameters to macro invocations be found by a parser, and that the syntactic type of a macros return result be part of a macro definition. <p> Except for the last macro example, all macros shown in this paper worked in the previous implementation. Once the re-implementation is complete, we will conduct large scale experiments with the macro system. Besides the systems already mentioned <ref> [14, 3, 4, 9] </ref>, there's current work on new macro systems for syntactically rich languages. Todd Jonker [7] is working on hygienic macro technology for syntactically rich languages. William Mad-dox at Berkeley is investigating extensions of his Master's thesis [10] that give macros semantic abilities.
Reference: [10] <author> Maddox, William, </author> <title> Semantically-Sensitive Macropro-cessing Report No. </title> <type> UCB/CSD 89/545, (Master's Thesis), </type> <pages> 82 pages, </pages> <institution> University of California, Berkeley, </institution> <year> 1989. </year>
Reference-contexts: A syntax macro system literally adds to existing syntactic domains. (At least one macro system <ref> [10] </ref> also allows the construction of new syntactic domains.) Programmable Syntax Macros Macro systems differ in the power of their transformational engine (Figure 1). The weakest macro system are template based systems, the most powerful macro systems sport a complete programming language. <p> Besides the systems already mentioned [14, 3, 4, 9], there's current work on new macro systems for syntactically rich languages. Todd Jonker [7] is working on hygienic macro technology for syntactically rich languages. William Mad-dox at Berkeley is investigating extensions of his Master's thesis <ref> [10] </ref> that give macros semantic abilities. Dain Samples has recently announced M5 [11], another token-based macro system. It is a very general macro processor that can be programmed to understand the lexical conventions of different languages (e.g., C, C++, Ada, and Tex).
Reference: [11] <author> Samples, Dain, M5, </author> <note> Electronic Announcement on comp.compilers newsgroup, 1992 Page 11 </note>
Reference-contexts: Todd Jonker [7] is working on hygienic macro technology for syntactically rich languages. William Mad-dox at Berkeley is investigating extensions of his Master's thesis [10] that give macros semantic abilities. Dain Samples has recently announced M5 <ref> [11] </ref>, another token-based macro system. It is a very general macro processor that can be programmed to understand the lexical conventions of different languages (e.g., C, C++, Ada, and Tex).
Reference: [12] <author> Steele, G., </author> <title> Common Lisp, The Language, </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: In general, the prefix operator $ causes evaluation of the expression it prefixes; it is not restricted to just the substitution of identifiers. (Our code template mechanism was modeled after Lisp's <ref> [12] </ref>.) We have designed, and have mostly implemented, a programmable macro system for C that has the following attributes: Page 2 Programmability/Macro Basis Character Token Syntax Semantic Full Programming Language GPM [13] 360 Assembler MS 2 Maddox Lisp, Scheme [6] Repetition & Conditional Bliss [15] M5 Repetition Hygienic Macros [8] Substitution
Reference: [13] <author> Strachey, C., </author> <title> "A general purpose macrogenerator," </title> <journal> Computer Journal, </journal> <volume> 8(3), </volume> <pages> pp. 225-241, </pages> <year> 1965 </year>
Reference-contexts: prefixes; it is not restricted to just the substitution of identifiers. (Our code template mechanism was modeled after Lisp's [12].) We have designed, and have mostly implemented, a programmable macro system for C that has the following attributes: Page 2 Programmability/Macro Basis Character Token Syntax Semantic Full Programming Language GPM <ref> [13] </ref> 360 Assembler MS 2 Maddox Lisp, Scheme [6] Repetition & Conditional Bliss [15] M5 Repetition Hygienic Macros [8] Substitution Pre-ANSI CPP ANSI CPP Cheatham Vidart System). Character Macros operate at the character level. They transform streams of characters into streams of characters.
Reference: [14] <author> Vidart, J., </author> <title> Extensions syntaxiques dans une contexte LL(1), </title> <institution> University of Grenoble, Th`ese pour obtenir le grade de Docteur de troisi`eme cycle, </institution> <year> 1974 </year>
Reference-contexts: Syntax macros were independently introduced by Cheatham [4] and Leavenworth [9] in the middle 60's. They proposed that the actual parameters to macro invocations be found by a parser, and that the syntactic type of a macros return result be part of a macro definition. Vidart's PhD thesis <ref> [14] </ref> cleaned up many problems with syntax macros by making the leap to transformations on trees, rather than on token streams. His macro system was substitution based, that is, macro bodies are ASTs whose leaves are formal parameters that are replaced at invocation time with actual parameters. <p> Except for the last macro example, all macros shown in this paper worked in the previous implementation. Once the re-implementation is complete, we will conduct large scale experiments with the macro system. Besides the systems already mentioned <ref> [14, 3, 4, 9] </ref>, there's current work on new macro systems for syntactically rich languages. Todd Jonker [7] is working on hygienic macro technology for syntactically rich languages. William Mad-dox at Berkeley is investigating extensions of his Master's thesis [10] that give macros semantic abilities.
Reference: [15] <institution> Bliss-11 Programmer's Manual, CMU Department of Computer Science, </institution> <year> 1974. </year> <pages> Page 12 </pages>
Reference-contexts: template mechanism was modeled after Lisp's [12].) We have designed, and have mostly implemented, a programmable macro system for C that has the following attributes: Page 2 Programmability/Macro Basis Character Token Syntax Semantic Full Programming Language GPM [13] 360 Assembler MS 2 Maddox Lisp, Scheme [6] Repetition & Conditional Bliss <ref> [15] </ref> M5 Repetition Hygienic Macros [8] Substitution Pre-ANSI CPP ANSI CPP Cheatham Vidart System). Character Macros operate at the character level. They transform streams of characters into streams of characters. We count pre-ANSI CPP as character based because many of them were.
References-found: 15

