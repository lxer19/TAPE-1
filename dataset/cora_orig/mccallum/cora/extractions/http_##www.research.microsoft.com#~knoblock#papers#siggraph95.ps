URL: http://www.research.microsoft.com/~knoblock/papers/siggraph95.ps
Refering-URL: http://www.research.microsoft.com/~knoblock/
Root-URL: http://www.research.microsoft.com
Title: Specializing Shaders  
Author: Brian Guenter Todd B. Knoblock Erik Ruf 
Note: This report is a preprint of the paper Specializing Shaders, to appear in Proceedings of SIGGRAPH 95 (Computer Graphics Proceedings, Annual Conference Series, 1995).  
Address: One Microsoft Way Redmond, WA 98052  
Affiliation: Microsoft Research Advanced Technology Division Microsoft Corporation  
Date: August 2, 1995  
Abstract: Technical Report MSR-TR-95-49 Copyright 1995 by the Association for Computing Machinery, Inc. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Publications Dept, ACM Inc., fax + 1 (212) 869-0481, or &lt;permissions@acm.org&gt;. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andersen, Lars Ole. </author> <title> Self-applicable C Program Specialization. </title> <booktitle> Proceedings of the ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation (San Francisco, </booktitle> <address> California, </address> <month> June 12-20, </month> <year> 1992). </year> <institution> Yale University technical report YALEU/DCS/RR-909, </institution> <year> 1992, </year> <pages> 54-61. </pages>
Reference-contexts: General-purpose partial evaluators for imperative languages include Andersens C-Mix <ref> [1] </ref> and the system of Baier et al. [3], which process programs written in subsets of C and Fortran, respectively. Osgood [11] addresses the full C language, but the large time and space costs of his algorithm limit its applicability.
Reference: [2] <author> Andersen, Peter Holst. </author> <title> Partial Evaluation Applied to Ray Tracing. </title> <type> Unpublished manuscript, </type> <month> October </month> <year> 1994. </year>
Reference-contexts: Mogensen [10] partially evaluated a simple ray-tracer coded in Lisp and got a twofold speedup; when shading was added to the ray-tracer, the speedup increased to 8 times. Andersen <ref> [2] </ref> performed a similar experiment in C, and achieved speedups of 1.8 with a code size blowup of 15-90 times. Other researchers used somewhat more applicationspecific specialization techniques.
Reference: [3] <author> Baier, Romana, Robert Glck, and Robert Zchling. </author> <title> Partial Evaluation of Numerical Programs in Fortran. </title> <booktitle> Proceedings of the ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation (Orlando, </booktitle> <address> Florida, </address> <month> June 25, </month> <year> 1994). </year> <note> University of Melbourne technical report 94/9, </note> <year> 1994, </year> <pages> 119-132 </pages>
Reference-contexts: General-purpose partial evaluators for imperative languages include Andersens C-Mix [1] and the system of Baier et al. <ref> [3] </ref>, which process programs written in subsets of C and Fortran, respectively. Osgood [11] addresses the full C language, but the large time and space costs of his algorithm limit its applicability.
Reference: [4] <author> Demers, Alan J., Thomas Reps, and Tim Teitelbaum. </author> <title> Incremental Evaluation for Attribute Grammars with Application to Syntax-directed Editors. </title> <booktitle> Proceedings of the Eighth Annual ACM Symposium on Principles of Programming Languages (Williamsburg, </booktitle> <address> Virginia, </address> <month> January </month> <year> 1981), </year> <pages> 105-116. </pages>
Reference-contexts: One strategy encodes the program as a set of constraints, and explicitly reestablishes the constraints after each input change. Attribute grammars <ref> [4] </ref> are one example of a constraint system with an efficient incremental solver. Constraint systems are common in graphics; however, they are primarily used for their convenience and generality rather than as a foundation for efficient incremental execution.
Reference: [5] <author> Goad, Chris. </author> <title> Special Purpose Automatic Programming for Hidden Surface Elimination. </title> <booktitle> Proceedings of SIGGRAPH 82 (Boston, </booktitle> <address> Massachusetts, </address> <month> July 26-30, </month> <year> 1982). </year> <booktitle> In Computer Graphics 16, </booktitle> <month> 3 (July </month> <year> 1982), </year> <pages> 167-178. </pages>
Reference-contexts: Other researchers used somewhat more applicationspecific specialization techniques. Hanrahans surface compiler [6] symbolically simplifies input equations defining a general algebraic surface, then outputs a C program that uses numerical methods to find roots of the resulting polynomial. He reported a speedup of 1.3. Goad <ref> [5] </ref> proposed specializing a hidden surface elimination routine with respect to a fixed scene and variable viewpoint.
Reference: [6] <author> Hanrahan, Pat. </author> <title> Ray Tracing Algebraic Surfaces. </title> <booktitle> Proceedings of SIGGRAPH 83 (Detroit, </booktitle> <address> Michigan, </address> <month> July 25-29, </month> <year> 1983). </year> <booktitle> In Computer Graphics 17, </booktitle> <month> 3 (July </month> <year> 1983), </year> <pages> 83-90. </pages>
Reference-contexts: Andersen [2] performed a similar experiment in C, and achieved speedups of 1.8 with a code size blowup of 15-90 times. Other researchers used somewhat more applicationspecific specialization techniques. Hanrahans surface compiler <ref> [6] </ref> symbolically simplifies input equations defining a general algebraic surface, then outputs a C program that uses numerical methods to find roots of the resulting polynomial. He reported a speedup of 1.3. Goad [5] proposed specializing a hidden surface elimination routine with respect to a fixed scene and variable viewpoint.
Reference: [7] <author> Hanrahan, Pat and Jim Lawson. </author> <title> A Language for Shading and Lighting Calculations. </title> <booktitle> Computer Graphics 24, </booktitle> <month> 4 (August </month> <year> 1990), </year> <pages> 289-298. </pages>
Reference-contexts: The user writes the shaders in a subset of C augmented with a library of useful graphics and mathematical functions. The framework is similar to that provided for writing shaders in RenderMan <ref> [7, 16] </ref>. The restricted subset of C excludes the following C features: struct, union, pointer, and array types other than limited support for primitive data types such as vectors and points, continue, break, and goto statements, and recursion in the shader functions (although subroutines may employ recursion). <p> But if we reassociate it as x+(y+z), this contains just one independent computation, y+z. The transformed code requires one less cache slot, and eliminates one + operation in the cache reader (Hanrahan and Lawson <ref> [7] </ref> describe a similar optimization). Thus far, we have described specializing shaders on a single control parameter. The specializer, in fact, supports specializations on multiple parameters.
Reference: [8] <author> Hoover, Roger. Alphonse: </author> <title> Incremental Computation as a Programming Abstraction. </title> <booktitle> Proceedings of the SIGPLAN 92 Conference on Programming Language Design and Implementation (San Francisco, </booktitle> <address> California, </address> <month> June </month> <year> 1992), </year> <pages> 261-272. </pages>
Reference-contexts: Recent research on memoization for functional programs includes improved caching strategies [12] and methods for memoizing specialized functions instead of data values [15]. There is also research on adding dependence information to existing imperative code <ref> [8] </ref>. Incremental execution techniques are general, but suffer in performance due to the need to dynamically process arbitrary input changes.
Reference: [9] <author> Jones, Neil D., Carsten K. Gomard, and Peter Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice-Hall, </publisher> <year> 1993. </year>
Reference: [10] <author> Mogensen, Torben. </author> <title> The Application of Partial Evaluation to Ray-Tracing. </title> <type> Master's thesis, </type> <institution> DIKU, University of Copenhagen, Denmark, </institution> <year> 1986. </year>
Reference-contexts: Several researchers have applied partial evaluation to ray-tracing by using a general-purpose partial evaluator to specialize a general intersection routine with respect to a scene, producing a specialized ray-tracer parameterized only by the viewpoint. Mogensen <ref> [10] </ref> partially evaluated a simple ray-tracer coded in Lisp and got a twofold speedup; when shading was added to the ray-tracer, the speedup increased to 8 times. Andersen [2] performed a similar experiment in C, and achieved speedups of 1.8 with a code size blowup of 15-90 times.
Reference: [11] <author> Osgood, Nathaniel David. </author> <title> PARTICLE: an Automatic Program Specialization System for Imperative and Low-level Languages. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: General-purpose partial evaluators for imperative languages include Andersens C-Mix [1] and the system of Baier et al. [3], which process programs written in subsets of C and Fortran, respectively. Osgood <ref> [11] </ref> addresses the full C language, but the large time and space costs of his algorithm limit its applicability.
Reference: [12] <author> Pugh, William and Tim Teitelbaum. </author> <title> Incremental Computation Via Function Caching. </title> <booktitle> Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages (Austin, </booktitle> <address> Texas, </address> <month> January </month> <year> 1989), </year> <pages> 315-328. </pages>
Reference-contexts: Most other approaches are similar to ours in that they cache intermediate results of an existing batch program. Recent research on memoization for functional programs includes improved caching strategies <ref> [12] </ref> and methods for memoizing specialized functions instead of data values [15]. There is also research on adding dependence information to existing imperative code [8]. Incremental execution techniques are general, but suffer in performance due to the need to dynamically process arbitrary input changes.
Reference: [13] <author> Ruf, Erik. </author> <title> Topics in Online Partial Evaluation. </title> <type> Ph.D. thesis, </type> <institution> Stanford University, </institution> <month> April </month> <year> 1993. </year> <note> Published as Stanford Computer Systems Laboratory technical report CSL-TR-93-563, </note> <month> March </month> <year> 1993. </year>
Reference: [14] <author> Sequin, Carlo H. and Eliot K. Smyrl. </author> <title> Parameterized Ray Tracing. </title> <booktitle> Proceedings of SIGGRAPH 89 (Boston, </booktitle> <address> Massachusetts, July 31-August 4, </address> <year> 1989). </year> <booktitle> In Computer Graphics 23, </booktitle> <month> 3 (July </month> <year> 1989), </year> <pages> 307-314. </pages>
Reference-contexts: He reported a speedup of 1.3. Goad [5] proposed specializing a hidden surface elimination routine with respect to a fixed scene and variable viewpoint. In the area of mixed computation, Sequin <ref> [14] </ref> used ray tree caching to significantly speed up shading computations for a ray traced image. 5.2 Incremental program execution We know of two main approaches to efficiently handling incremental changes. One strategy encodes the program as a set of constraints, and explicitly reestablishes the constraints after each input change.
Reference: [15] <author> Sundaresh, R.S. and Paul Hudak. </author> <title> A Theory of Incremental Computation and Its Application. </title> <booktitle> Proceedings of the Eighteenth Annual ACM Symposium on Principles of Programming Languages (Orlando, </booktitle> <address> Florida, </address> <month> January </month> <year> 1991), </year> <pages> 1-13. </pages>
Reference-contexts: Most other approaches are similar to ours in that they cache intermediate results of an existing batch program. Recent research on memoization for functional programs includes improved caching strategies [12] and methods for memoizing specialized functions instead of data values <ref> [15] </ref>. There is also research on adding dependence information to existing imperative code [8]. Incremental execution techniques are general, but suffer in performance due to the need to dynamically process arbitrary input changes.
Reference: [16] <author> Upstill, Steve. </author> <title> The RenderMan Companion. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The user writes the shaders in a subset of C augmented with a library of useful graphics and mathematical functions. The framework is similar to that provided for writing shaders in RenderMan <ref> [7, 16] </ref>. The restricted subset of C excludes the following C features: struct, union, pointer, and array types other than limited support for primitive data types such as vectors and points, continue, break, and goto statements, and recursion in the shader functions (although subroutines may employ recursion).
Reference: [17] <author> Watkins, Christopher D., Stephen B. Coy, and Mark Finlay. </author> <title> Photorealism and Ray Tracing in C. M&T Books, </title> <year> 1992 </year>
Reference-contexts: Our prototype uses a modified version of the Vivid ray tracer <ref> [17] </ref> to compute this information. During the interactive stage, the user loads a precomputed geometric image and then adjusts shading parameters on objects in the scene. Because the geometric image is rendered prior to the interactive stage, some image properties cannot be varied interactively.
Reference: [18] <author> Watt, Alan and Mark Watt. </author> <title> Advanced Animation and Rendering Techniques. </title> <publisher> ACM Press, </publisher> <year> 1992. </year> <title> Plate 1: Test image. Plate 2: Image obtained by reshading image of Plate 1. </title> <note> This took 12 seconds unspecialized, 0.5 seconds specialized. </note>
References-found: 18

