URL: http://www.cs.toronto.edu/~chechik/courses/2124/lp.ps
Refering-URL: http://www.cs.toronto.edu/~chechik/courses/2124/readings.html
Root-URL: 
Title: 60 Debugging Larch Shared Language Specifications  
Author: Stephen J. Garland and John V. Guttag 
Date: July 4, 1990  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Boyer, R. S. and Moore, J S. </author> <title> A Computational Logic, </title> <address> New York, </address> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: Because many proof attempts fail, LP is designed to fail relatively quickly and to provide useful information when it does. It is not designed to find difficult proofs automatically. Unlike the Boyer-Moore prover <ref> [1] </ref>, it does not perform heuristic searches for a proof. Unlike LCF [15], it does not allow users to define complicated search tactics. Strategic decisions, such as when to try induction, must be supplied as explicit LP commands (either by the user or by a front-end such as LSLC).
Reference: [2] <author> Boyer, R. S. and Moore, J S. </author> <title> A Computational Logic Handbook, </title> <address> New York, </address> <publisher> Academic Press, </publisher> <year> 1988. </year>
Reference: [3] <author> Burstall, R. M. and Goguen, J. A. </author> <title> Putting Theories Together to Make Specifications, </title> <booktitle> Proceedings of the Fifth International Joint Conference on Artificial Intelligence, </booktitle> <year> 1977, </year> <pages> 1045-1058. </pages>
Reference-contexts: Section 7 describes the checking entailed by the converts clause in more detail. Checking composed LSL specifications There are two mechanisms for combining LSL specifications. Both are defined as operations on the texts of specifications, rather than on theories or models <ref> [3, 17] </ref>. For both mechanisms, the theory of a combined specification is axiomatized by the union of the axiomatizations for the individual specifications; each operator is constrained by the axioms of all traits in which it appears.
Reference: [4] <author> Garland, S. J. and Guttag, J. V. </author> <title> Inductive Methods for Reasoning about Abstract Data Types, </title> <booktitle> Proceedings of the 15th ACM Conference on Principles of Programming Languages, </booktitle> <year> 1988, </year> <pages> 219-228. </pages>
Reference: [5] <author> Garland, S. J. and Guttag, J. V. </author> <title> An Overview of LP, The Larch Prover, </title> <booktitle> Proceedings of the Third International Conference on Rewriting Techniques and Applications, </booktitle> <address> Chapel Hill, N.C., </address> <booktitle> Lecture Notes in Computer Science 355, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989, </year> <pages> 137-151. </pages>
Reference-contexts: We rarely complete our rewriting systems, for the reasons discussed in <ref> [5] </ref>. However, we often make selective use of critical pairs. As discussed in Section 9, we also use the completion procedure to look for inconsistencies. * Explicit instantiation of variables in equations, rewrite rules, and deduction rules also produces consequences.
Reference: [6] <author> Garland, S. J., Guttag, J. V. and Staunstrup, J. </author> <title> Verification of VLSI Circuits Using LP, </title> <booktitle> Proceedings of the IFIP WG 10.2 Conference on the Fusion of Hardware Design and Verification, </booktitle> <publisher> North Holland, </publisher> <year> 1988. </year>
Reference-contexts: LP (the Larch Prover) is our principal debugging tool. Its design and development have been motivated primarily by our work on LSL, but it also has other uses (for example, reasoning about circuits and concurrent algorithms <ref> [6, 19] </ref>). Because of these other uses, and because we also intend to use LP to analyze Larch interface specifications, we have tried not to make LP too LSL-specific. Instead, we have chosen to build a second tool, LSLC (the LSL Checker), to serve as a front-end to LP.
Reference: [7] <author> Garland, S. J. and Guttag, J. V. </author> <title> Using LP to Debug Specifications, </title> <booktitle> Proceedings of the IFIP TC2/WG2.2/WG2.3 Working Conference on Programming Concepts and Methods, </booktitle> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference: [8] <author> Guttag, J. V. and Horning, J. J. </author> <title> Formal Specification as a Design Tool, </title> <booktitle> Proceedings of the 7th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1980, </year> <pages> 251-261. </pages>
Reference-contexts: and have therefore removed from LSL the imports construct, which made such claims. 9 Extended example To illustrate our approach to checking specifications in a slightly more realistic setting, we show how one might construct and check some traits to be used in the specification of a simple windowing system <ref> [8] </ref>. These are preliminary versions of traits that would likely be expanded as the specifications (including the interface parts) are developed. The first three traits declare the signatures of some basic operators.
Reference: [9] <author> Guttag, J. V. and Horning, J. J. </author> <title> Report on the Larch Shared Language, </title> <booktitle> Science of Computer Programming 6:2 (Mar. </booktitle> <year> 1986), </year> <pages> 103-134. </pages>
Reference-contexts: 1 Introduction Proponents of formal specifications argue that the susceptibility of formal specifications to machine analysis and manipulation increases their value and reduces their cost. The Larch project <ref> [9, 10, 11, 12] </ref> seeks to support this position by building and using tools that facilitate the construction of formal specifications for program modules. It is not sufficient for specifications to be precise; they should also accurately reflect the specifier's intentions. Without accuracy, precision is useless and misleading. <p> This paper concentrates on the problem of debugging LSL specifications. 3 Semantic checks in the Larch Shared Language A precise definition of the Larch Shared Language, including associated semantic checks, is contained in <ref> [9, 11] </ref>. This section informally describes LSL and these checks by considering claims that specifiers can make about some sample traitsLSL's basic units of specification. A trait specifies the properties of a collection of operators.
Reference: [10] <author> Guttag, J. V. and Horning, J. J. </author> <title> A Larch Shared Language Handbook, </title> <booktitle> Science of Computer Programming 6:2 (Mar. </booktitle> <year> 1986), </year> <note> 135-157 (revision to appear). </note>
Reference-contexts: 1 Introduction Proponents of formal specifications argue that the susceptibility of formal specifications to machine analysis and manipulation increases their value and reduces their cost. The Larch project <ref> [9, 10, 11, 12] </ref> seeks to support this position by building and using tools that facilitate the construction of formal specifications for program modules. It is not sufficient for specifications to be precise; they should also accurately reflect the specifier's intentions. Without accuracy, precision is useless and misleading.
Reference: [11] <author> Guttag, J. V., Horning, J. J., and Modet, A. </author> <title> Revised Report on the Larch Shared Language, </title> <institution> Digital Equipment Corporation Systems Research Center Report 58, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Proponents of formal specifications argue that the susceptibility of formal specifications to machine analysis and manipulation increases their value and reduces their cost. The Larch project <ref> [9, 10, 11, 12] </ref> seeks to support this position by building and using tools that facilitate the construction of formal specifications for program modules. It is not sufficient for specifications to be precise; they should also accurately reflect the specifier's intentions. Without accuracy, precision is useless and misleading. <p> This paper concentrates on the problem of debugging LSL specifications. 3 Semantic checks in the Larch Shared Language A precise definition of the Larch Shared Language, including associated semantic checks, is contained in <ref> [9, 11] </ref>. This section informally describes LSL and these checks by considering claims that specifiers can make about some sample traitsLSL's basic units of specification. A trait specifies the properties of a collection of operators.
Reference: [12] <author> Guttag, J. V., Horning, J. J. and Wing, J. M. </author> <title> An Overview of the Larch Family of Specification Languages, </title> <booktitle> IEEE Software 2:5 (Sept. </booktitle> <year> 1985), </year> <pages> 24-36. </pages>
Reference-contexts: 1 Introduction Proponents of formal specifications argue that the susceptibility of formal specifications to machine analysis and manipulation increases their value and reduces their cost. The Larch project <ref> [9, 10, 11, 12] </ref> seeks to support this position by building and using tools that facilitate the construction of formal specifications for program modules. It is not sufficient for specifications to be precise; they should also accurately reflect the specifier's intentions. Without accuracy, precision is useless and misleading. <p> c : Coord) signals (du plicate) modifies v ensures v 0 D add W .v; w; c/ except when w 2 v signals du plicate ensures v 0 D v 2 The Larch family of specification languages The Larch family of specification languages supports a two-tiered definitional approach to specification <ref> [12] </ref>. Each specification has components written in two languages: one designed for a specific programming language and another independent of any programming language. The former are called Larch interface languages, and the latter the Larch Shared Language (LSL). Larch interface languages are used to specify the interfaces between program components.
Reference: [13] <author> Knuth, D. E. and Bendix, P. B. </author> <title> Simple Word Problems in Universal Algebras, in Computational Problems in Abstract Algebra, </title> <editor> J. Leech (ed.), </editor> <publisher> Pergamon Press, Oxford, </publisher> <year> 1969, </year> <pages> 263-297. </pages>
Reference-contexts: Deduction rules can also be applied explicitly, for example, to immune equations. * The computation of critical pairs and the Knuth-Bendix completion procedure <ref> [13, 16] </ref> produce consequences (such as i.e/ DD e) from incomplete rewriting systems (such as the three rewrite rules for groups). We rarely complete our rewriting systems, for the reasons discussed in [5]. However, we often make selective use of critical pairs.
Reference: [14] <author> McAllester, D. A. Ontic: </author> <title> A Knowledge Representation System for Mathematics, </title> <note> MIT Artificial Intelligence Laboratory Technical Report 979. </note>
Reference-contexts: In general, we can use LP's forward inference mechanisms to search for the presence of inconsistencies in a specification. The completion procedure can search for inconsistencies automatically, and we can instantiate axioms by focus objects (in the sense of McAllester <ref> [14] </ref>) to provide the completion procedure with a basis for its search.
Reference: [15] <author> Paulson, L. C. </author> <title> Logic and Computation: Interactive Proof with Cambridge LCF, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1987. </year>
Reference-contexts: Because many proof attempts fail, LP is designed to fail relatively quickly and to provide useful information when it does. It is not designed to find difficult proofs automatically. Unlike the Boyer-Moore prover [1], it does not perform heuristic searches for a proof. Unlike LCF <ref> [15] </ref>, it does not allow users to define complicated search tactics. Strategic decisions, such as when to try induction, must be supplied as explicit LP commands (either by the user or by a front-end such as LSLC).
Reference: [16] <author> Peterson, G. L. and Stickel, M. E. </author> <title> Complete Sets of Reductions for Some Equational Theories, </title> <journal> JACM 28:2 (Apr. </journal> <year> 1981), </year> <pages> 233-264. </pages>
Reference-contexts: Deduction rules can also be applied explicitly, for example, to immune equations. * The computation of critical pairs and the Knuth-Bendix completion procedure <ref> [13, 16] </ref> produce consequences (such as i.e/ DD e) from incomplete rewriting systems (such as the three rewrite rules for groups). We rarely complete our rewriting systems, for the reasons discussed in [5]. However, we often make selective use of critical pairs.
Reference: [17] <author> Sannella, D. and Tarlecki, A. </author> <title> On Observational Equivalence and Algebraic Specifica tion, </title> <booktitle> Mathematical Foundations of Software Development, Lecture Notes in Computer Science 186 (1985), </booktitle> <pages> 308-322. </pages>
Reference-contexts: Section 7 describes the checking entailed by the converts clause in more detail. Checking composed LSL specifications There are two mechanisms for combining LSL specifications. Both are defined as operations on the texts of specifications, rather than on theories or models <ref> [3, 17] </ref>. For both mechanisms, the theory of a combined specification is axiomatized by the union of the axiomatizations for the individual specifications; each operator is constrained by the axioms of all traits in which it appears.
Reference: [18] <author> Shoenfield, J. R. </author> <title> Mathematical Logic, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1967. </year>
Reference-contexts: A standard approach in logic to proving consistency involves interpreting the theory being checked in another theory whose consistency is assumed (for example, Peano arithmetic) or has been established previously <ref> [18] </ref>. In this approach, user assistance is required to define the interpretation. The proof that the interpretation satisfies the axioms of the trait being checked then becomes a problem of showing theory containment, for which LP is well suited. This approach is cumbersome and unattractive in practice. <p> This approach is cumbersome and unattractive in practice. More promising approaches are based on metatheorems in first-order logic that can be used for restricted classes of specifications. For example, any extension by definitions (see <ref> [18] </ref>) of a consistent theory is consistent. For equational traits (that is to say, traits with purely equational axiomatizations, of which there are relatively few), questions about consistency can be translated into questions about critical pairs.
Reference: [19] <author> Staunstrup, J., Garland, S. J., and Guttag, J. V. </author> <title> Compositional verification of VLSI circuits, </title> <booktitle> Proceedings of an International Workshop on Automatic Verification of Finite State Systems, </booktitle> <address> Grenoble, France, </address> <month> June </month> <year> 1989, </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag. </publisher> <pages> 32 </pages>
Reference-contexts: LP (the Larch Prover) is our principal debugging tool. Its design and development have been motivated primarily by our work on LSL, but it also has other uses (for example, reasoning about circuits and concurrent algorithms <ref> [6, 19] </ref>). Because of these other uses, and because we also intend to use LP to analyze Larch interface specifications, we have tried not to make LP too LSL-specific. Instead, we have chosen to build a second tool, LSLC (the LSL Checker), to serve as a front-end to LP.
References-found: 19

