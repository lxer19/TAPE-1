URL: http://ptolemy.eecs.berkeley.edu/papers/PganRpmcDppo/ApganRpmc.ps.Z
Refering-URL: http://ptolemy.eecs.berkeley.edu/papers/PganRpmcDppo/
Root-URL: 
Title: APGAN and RPMC: Complementary Heuristics for Translating DSP Block Diagrams into Efficient Software Implementations  
Author: Shuvra S. Bhattacharyya, Praveen K. Murthy, and Edward A. Lee P. K. Murthy and E. A. Lee 
Address: East Tasman Drive, San Jose, California 95134, USA.  Berkeley, California 94720, USA.  
Affiliation: Semiconductor Research Laboratory, Hitachi America, Ltd., 201  Dept. of Electrical Engineering and Computer Sciences, University of California at  
Note: S. S. Bhattacharyya is with the  are with the  January 1997.  
Date: May 17, 1996  
Abstract: A portion of this research was undertaken as part of the Ptolemy project, which is supported by the Advanced Research Projects Agency and the U. S. Air Force (under the RASSP program, contract F33615-93-C-1317), Semiconductor Research Corporation (project 94-DC-008), National Science Foundation (MIP-9201605), Office of Naval Technology (via Naval Research Laboratories), the State of Cali-fornia MICRO program, and the following companies: Bell Northern Research, Dolby, Hitachi, Mentor Graphics, Mitsubishi, NEC, Pacific Bell, Philips, Rockwell, Sony, and Synopsys. ABSTRACT Dataow has proven to be an attractive computational model for graphical DSP design environments that support the automatic conversion of hierarchical signal ow diagrams into implementations on programmable processors. The synchronous dataow (SDF) model is particularly well-suited to dataow-based graphical programming because its restricted semantics offer strong formal properties and significant compile-time predictability, while capturing the behavior of a large class of important signal processing applications. When synthesizing software for embedded signal processing applications, critical constraints arise due to the limited amounts of memory. In this paper, we propose a solution to the problem of jointly optimizing the code and data size when converting SDF programs into software implementations. We consider two approaches. The first is a customization to acyclic graphs of a bottom-up technique, called pairwise grouping of adjacent nodes (PGAN), that was proposed earlier for general SDF graphs. We show that our customization to acyclic graphs significantly reduces the complexity of the general PGAN algorithm, and we present a formal study of our modified PGAN technique that rigorously establishes its optimality for a certain class of applications. The second approach that we consider is a top-down technique, based on a generalized minimum-cut operation, that was introduced recently in [14]. We present the results of an extensive experimental investigation on the performance of our modified PGAN technique and the top-down approach and on the trade-offs between them. Based on these results, we conclude that these two techniques complement each other, and thus, they should both be incorporated into SDF-based software implementation environments in which the minimization of memory requirements is important. We have implemented these algorithms in the Ptolemy software environment [5] at UC Berke-ley. In the Design Automation for Embedded Systems Journal, Vol 2, No. 1, 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ade, R. Lauwereins, J. A. Peperstraete, </author> <title> Buffer Memory Requirements in DSP Applications, IEEE Wkshp. on Rapid System Prototyping, </title> <month> June, </month> <year> 1994. </year>
Reference-contexts: of adopting both APGAN and RPMC as a combined solution arises from complementing the strong performance of RPMC on general graphs with the formal properties of APGAN, as specified by Theorem 6, and the ability of APGAN to exploit regularity that arises frequently in practical applications. 9 Related Work In <ref> [1] </ref>, Ade, Lauwereins, and Peperstraete develop upper bounds on the minimum buffer memory requirement for certain classes of SDF graphs.
Reference: [2] <author> S. S. Bhattacharyya, P. K. Murthy, E. A. Lee, </author> <title> Two Complementary Heuristics for Translating Graphical DSP Programs into Minimum Memory Software Implementations, </title> <institution> Memorandum UCB/ERL M95/3, Electronics Research Laboratory, University of California at Berkeley, </institution> <month> Jan., </month> <year> 1995. </year> <note> WWW URL: http://ptolemy.eecs.berkeley.edu/ papers/PganRpmcDppo/. </note>
Reference-contexts: Thus, . We will apply the following obvious fact about lexical order-ings. Fact 1: If is a valid single appearance schedule for a delayless SDF graph, then whenever is an ancestor of , we have . We will also apply the following fact, whose proof can be found in <ref> [2] </ref>. Fact 2: Suppose that is a consistent, connected SDF graph, is a single appearance sched ule for , and is any positive integer. <p> A valid single appearance schedule is an R-schedule if satisfies the R-condition, and every schedule loop contained in satisfies the R-condition. The following result on R-schedules is established in <ref> [2] </ref>. Theorem 1: Suppose that is a consistent SDF graph and is a valid single appearance schedule for . <p> It follows from Definition 1 that is BMLB schedule for . Similarly, if a BMLB schedule for , then is a valid schedule for , and . Again, from Definition 1, must be a BMLB schedule for . Q.E.D. A proof of the following fact can be found in <ref> [2] </ref>. Fact 8: If is a connected, consistent SDF graph and is an edge in , then . 4 PGAN for Acyclic Graphs In the original Pairwise Grouping of Adjacent Nodes (PGAN) technique, developed in [4], a cluster hierarchy is constructed by clustering exactly two adjacent vertices at each step. <p> This check is performed efficiently by applying a reachability matrix, which indicates for any two APG vertices , whether or not there is a path from to . Unfortunately, the cost to compute and store the APG reachability matrix can be prohibitively high for some applications <ref> [2] </ref>. <p> In an acyclic SDF graph , it is easily verified that a subset of actors is not clusterable only if introduces a cycle. This condition is easily checked given a reachability matrix for <ref> [2] </ref>. Since the existence of a cycle in is not a sufficient condition for not to be clusterable, the clusterize-ability test that we apply in APGAN is not exact; it must be viewed as a conservative test. For some graphs, this imprecision can prevent APGAN from attaining optimal results [2]. <p> for <ref> [2] </ref>. Since the existence of a cycle in is not a sufficient condition for not to be clusterable, the clusterize-ability test that we apply in APGAN is not exact; it must be viewed as a conservative test. For some graphs, this imprecision can prevent APGAN from attaining optimal results [2]. In exchange for some degree of suboptimality in these cases, our clusterization test attains a large computational savings over the exact test based on the reachability matrix of the APG, and this is our main reason for adopting it. Fig. 5 illustrates the operation of APGAN. <p> See <ref> [2] </ref> for details. The following lemma states that in a connected SDF graph that contains exactly three actors, and that has a BMLB schedule, the repetition count can exceed unity for at most one adjacent pair. For example, consider the three-actor graph in Fig. 9. <p> This is because although clustering an adjacent pair that satisfies the proper clustering condition preserves the BMLB value on each edge, it does not necessarily preserve the existence of a BMLB schedule <ref> [2] </ref>. Fortunately, the assumption that the adjacent pair being clustered has maximum repetition count is sufficient to preserve the existence of a BMLB schedule. This is established by the following theorem. <p> The solutions developed in this paper have focused on acyclic SDF graphs. These techniques can be applied in a limited way to general SDF graphs <ref> [2] </ref>. More thorough techniques for jointly optimizing code and data for general SDF graphs is a topic for further study. 32
Reference: [3] <author> S. S. Bhattacharyya, P. K. Murthy, E. A. Lee, </author> <title> Software Synthesis from Dataow Graphs, </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Norwell MA, </address> <year> 1996. </year>
Reference-contexts: To a good first approximation, any valid single appearance schedule gives the minimum code space cost for in-line code generation. This approximation neglects second order affects such as loop overhead and the efficiency of data transfers between actors <ref> [3] </ref>. Given an SDF graph , a valid schedule , and an edge in , we define (we may suppress the subscript if is understood) to denote the maximum number of tokens that are queued on during an execution of . <p> Here, edge corresponds to (and vice versa), and corresponds to . The following fact relates the repetitions vector of an SDF graph obtained by clustering a subgraph to that of the original SDF graph. The proofs of both parts can be found in <ref> [3] </ref>. Fact 4: (a). If is a connected, consistent SDF graph, , and , then , and for each , . (b). If is a connected, consistent SDF graph and is a connected subgraph of , then for each , . <p> We refer to this adaptation as Dynamic Programming Post Optimization (DPPO) for single appearance schedules. DPPO can be extended efficiently to handle delays and arbitrary topologies <ref> [3] </ref>. We refer to the extension that we have developed as Generalized DPPO (GDPPO). GDPPO gives a post-optimization for any scheduler for general SDF graphs that constructs single appearance schedules.
Reference: [4] <author> S. S. Bhattacharyya, E. A. Lee, </author> <title> Scheduling Synchronous Dataow Graphs for Efficient Looping, Jo. </title> <booktitle> of VLSI Signal Processing, </booktitle> <month> Dec., </month> <year> 1993. </year>
Reference-contexts: We focus on acyclic graphs. We introduce a customization to acyclic graphs of a bottom-up scheduling technique, called pairwise grouping of adjacent nodes (PGAN), that was proposed in an earlier paper <ref> [4] </ref> for general SDF graphs. We call this customization Acyclic PGAN (APGAN). <p> Q.E.D. A proof of the following fact can be found in [2]. Fact 8: If is a connected, consistent SDF graph and is an edge in , then . 4 PGAN for Acyclic Graphs In the original Pairwise Grouping of Adjacent Nodes (PGAN) technique, developed in <ref> [4] </ref>, a cluster hierarchy is constructed by clustering exactly two adjacent vertices at each step. At each clusterization step, a pair of adjacent actors is chosen that maximizes over all clusterable adjacent pairs. <p> We have developed a fundamental lower bound, called the BMLB, on the amount of data memory required for a minimum code size implementation of an SDF graph; we have presented an efficient adaptation to acyclic graphs, called APGAN, of the PGAN technique developed in <ref> [4] </ref>; and we have shown that for a certain class of graphs, which includes all delayless graphs, APGAN is guaranteed to achieve the BMLB whenever it is achievable.
Reference: [5] <author> JJ. Buck, S. Ha, E. A. Lee, D. G. Messerschmitt, Ptolemy: </author> <title> a Framework for Simulating and Prototyping Heterogeneous Systems, </title> <journal> International Journal of Computer Simulation, </journal> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: An algorithm based on APGAN has in fact been implemented by the Alta group at Cadence Design Systems Inc. in their Signal Processing WorkSys-tem programming environment. We have implemented APGAN and RPMC in the Ptolemy programming environment <ref> [5] </ref> at UC Berkeley and will be making these algorithms available in the next release. The paper is organized as follows. In Section 2 we first review some graph concepts and establish notation that will be used throughout the paper.
Reference: [6] <author> T. H. Cormen, C. E. Leiserson, R. L. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> McGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: Kernighan and Lin [10] devised a heuristic procedure for computing cuts into bounded sets but they considered only undirected graphs. Methods based on network ows <ref> [6] </ref> do not work because the minimum cut given by the max-ow-min-cut theorem may not be legal and may not be bounded [14]. Hence, we give a heuristic solution for finding legal minimum cuts into bounded sets. See [14] for a description and pseudocode specification of the heuristic.
Reference: [7] <author> J. Fabri, </author> <title> Automatic Storage Optimization, </title> <publisher> UMI Research Press, </publisher> <year> 1982. </year>
Reference-contexts: Fabri <ref> [7] </ref> has studied schemes for overlaying buffers when the buffer sizes are not all identical but even these techniques only apply to a given schedule, and do not attempt to optimize over all possible schedules as done in this paper.
Reference: [8] <author> M. R. Garey, D. S. Johnson, </author> <title> Computers and Intractability-A guide to the theory of NP-completeness, </title> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference-contexts: L ( )subgraph V R ( )subgraph e ( )src V L e ( )snk V R K V V R K V L K e w e ( ) e ( )TNSE= 27 the related problem of finding a minimum cut (not necessarily legal) into bounded sets is NP-complete <ref> [8] </ref>, and the problem of finding an acyclic partition of a graph is NP-complete [8], we believe this problem to be NP-complete as well even though we have not discovered a proof. <p> )snk V R K V V R K V L K e w e ( ) e ( )TNSE= 27 the related problem of finding a minimum cut (not necessarily legal) into bounded sets is NP-complete <ref> [8] </ref>, and the problem of finding an acyclic partition of a graph is NP-complete [8], we believe this problem to be NP-complete as well even though we have not discovered a proof. Kernighan and Lin [10] devised a heuristic procedure for computing cuts into bounded sets but they considered only undirected graphs.
Reference: [9] <author> R. Govindarajan, G. R. Gao, P. Desai, </author> <title> Minimizing Memory Requirements in Rate-Optimal Schedules, </title> <booktitle> Proc. of the Intl. Conf. on Application Specific Array Processors, </booktitle> <address> San Francisco, </address> <month> Aug., </month> <year> 1994. </year>
Reference-contexts: A linear programming framework for minimizing the memory requirement of a synchronous data-ow graph in a parallel processing context is explored by Govindarajan and Gao in <ref> [9] </ref>. Here the goal is to minimize the buffer cost without sacrificing throughput. 10 Conclusions In this paper, we have addressed the problem of constructing a software implementation of an SDF graph that requires minimal data memory from among the set of implementations that require minimum code size.
Reference: [10] <author> B. W. Kernighan, S. Lin, </author> <title> An Efficient Heuristic Procedure for Partitioning Graphs, </title> <journal> Bell System Technical Journal, </journal> <month> Feb., </month> <year> 1970. </year>
Reference-contexts: Kernighan and Lin <ref> [10] </ref> devised a heuristic procedure for computing cuts into bounded sets but they considered only undirected graphs. Methods based on network ows [6] do not work because the minimum cut given by the max-ow-min-cut theorem may not be legal and may not be bounded [14].
Reference: [11] <author> R. Lauwereins, P. Wauters, M. Ade, J. A. Peperstraete, </author> <title> Geometric Parallelism and Cyclo-Static Dataow in GRAPE-II, IEEE Wkshp. on Rapid System Prototyping, </title> <month> June, </month> <year> 1994. </year>
Reference-contexts: Numerous DSP design environments, including a number of commercial tools, support SDF or closely related models <ref> [11, 12, 15, 16, 17] </ref>. In SDF, a program is represented by a directed graph in which each vertex (actor) represents a computation, edges specify FIFO communication channels, and each actor produces (consumes) a fixed number of data values (tokens) onto (from) each output (input) edge per invocation. <p> In <ref> [11] </ref>, Lauwereins, Wauters, Ade, and Peperstraete present a generalization of SDF called cyclo-static dataow. A major advantage of cyclo-static dataow is that it can eliminate large amounts of token Table 3.
Reference: [12] <author> E. A. Lee, W. H. Ho, E. Goei, J. Bier, S. S. Bhattacharyya, Gabriel: </author> <title> A Design Environment for DSP, </title> <journal> IEEE Trans. on Acoustics, Speech, and Signal Processing, </journal> <month> Nov., </month> <year> 1989. </year>
Reference-contexts: Numerous DSP design environments, including a number of commercial tools, support SDF or closely related models <ref> [11, 12, 15, 16, 17] </ref>. In SDF, a program is represented by a directed graph in which each vertex (actor) represents a computation, edges specify FIFO communication channels, and each actor produces (consumes) a fixed number of data values (tokens) onto (from) each output (input) edge per invocation.
Reference: [13] <author> E. A. Lee, D. G. Messerschmitt, </author> <title> Static Scheduling of Synchronous Dataow Programs for Digital Signal Processing, </title> <journal> IEEE Trans. on Computers, </journal> <month> Feb., </month> <year> 1987. </year>
Reference-contexts: SDF graphs for which valid schedules exist are called consistent SDF graphs. In <ref> [13] </ref>, efficient algorithms are presented to determine whether or not a given SDF graph is consistent, and to determine the minimum number of times that each actor must be fired in a valid schedule. <p> At each clusterization step, a pair of adjacent actors is chosen that maximizes over all clusterable adjacent pairs. To check whether or not an adjacent pair is clusterable, PGAN maintains the cluster hierarchy on the acyclic precedence graph (APG) <ref> [13] </ref>. Each vertex of the APG corresponds to an actor invocation, and each edge signifies that at least one token produced by is consumed by in a valid schedule.
Reference: [14] <author> P. K. Murthy, S. S. Bhattacharyya, E. A. Lee, </author> <title> Combined Code and Data Minimization for Synchronous Data-ow Programs, </title> <institution> Memorandum UCB/ERL M94/93, Electronics Research Laboratory, University of California at Ber-keley, </institution> <month> Nov., </month> <year> 1994, </year> <note> WWW URL: http://ptolemy.eecs.berkeley.edu/papers/jointCodeDataMinimize/. </note>
Reference-contexts: Although perfectly valid target programs can be generated without this restriction, it can be shown that having a separate buffer on each edge is advantageous because it permits full exploitation of the memory savings attainable from nested loops, and it accommodates delays without complication <ref> [14] </ref>. Another advantage of this model is that by favoring the generation of nested loops, the model also favors schedules that have lower latency than single appearance schedules that are constructed to optimize various alternative cost measures [14]. <p> the memory savings attainable from nested loops, and it accommodates delays without complication <ref> [14] </ref>. Another advantage of this model is that by favoring the generation of nested loops, the model also favors schedules that have lower latency than single appearance schedules that are constructed to optimize various alternative cost measures [14]. Combining the analysis and techniques that we develop in this paper with methods for sharing storage among multiple buffers is a useful direction for further study. <p> Fabri [7] has studied schemes for overlaying buffers when the buffer sizes are not all identical but even these techniques only apply to a given schedule, and do not attempt to optimize over all possible schedules as done in this paper. Finally, as shown in <ref> [14] </ref>, naive techniques for buffer-sharing can result in sub-optimal schedules, and can be awkward to implement. In this paper we address the problem of computing a valid single appearance schedule that minimizes the buffer memory requirement over all valid single appearance schedules. We call such a schedule an optimal schedule. <p> We compare APGAN to a top-down heuristic based on recursively partitioning the input graph using a generalized minimum cut operation, which was introduced recently in <ref> [14] </ref>. This top-down heuristic is called Recursive Partitioning Based on Minimum Cuts (RPMC). We report on an extensive experimental study in which the performance of both scheduling techniques is evaluated on several practical applications, and on a diverse collection of complex random graphs. <p> Even though this class appears restrictive at first, it is shown in Section 8 that a wide variety of practical systems fall into this class and hence it is a useful class. Section 7 briey discusses a different heuristic that was proposed in <ref> [14] </ref>; this discussion is given primarily to facilitate the comparison between the two heuristics in Section 8. Finally we discuss some related work and present our conclusions. 2 Background For reference, a glossary of terminology can be found at the end of the paper. <p> The following result on R-schedules is established in [2]. Theorem 1: Suppose that is a consistent SDF graph and is a valid single appearance schedule for . Then there exists an R-schedule for such that for all , and . 2.3 Optimally Reparenthesizing a Single Appearance Schedule In <ref> [14] </ref>, a dynamic programming algorithm is developed that constructs an optimal schedule for a well-ordered SDF graph (a graph that has only one topological sort) in time, where is the number of actors. <p> In <ref> [14] </ref>, we proposed an alternative top-down approach, which we call Recursive Partitioning by Minimum Cuts (RPMC), that computes the schedule by recursively partitioning the SDF graph in such a way that outer loops are constructed before the inner loops. <p> Kernighan and Lin [10] devised a heuristic procedure for computing cuts into bounded sets but they considered only undirected graphs. Methods based on network ows [6] do not work because the minimum cut given by the max-ow-min-cut theorem may not be legal and may not be bounded <ref> [14] </ref>. Hence, we give a heuristic solution for finding legal minimum cuts into bounded sets. See [14] for a description and pseudocode specification of the heuristic. <p> Methods based on network ows [6] do not work because the minimum cut given by the max-ow-min-cut theorem may not be legal and may not be bounded <ref> [14] </ref>. Hence, we give a heuristic solution for finding legal minimum cuts into bounded sets. See [14] for a description and pseudocode specification of the heuristic. RPMC proceeds by partitioning the graph by computing the legal minimum cut and forming the schedule , where the schedules are obtained recursively by partitioning and . It can be shown that the running time of RPMC is given by [14]. <p> <ref> [14] </ref> for a description and pseudocode specification of the heuristic. RPMC proceeds by partitioning the graph by computing the legal minimum cut and forming the schedule , where the schedules are obtained recursively by partitioning and . It can be shown that the running time of RPMC is given by [14]. The RPMC algorithm is easily extended to efficiently handle nonzero delays. See [14] for details. 8 Experimental Results BMLB schedule. The graph is an abstraction for a satellite receiver implementation and is taken from [18]. The graph is annotated with the produced/consumed numbers wherever they are different from unity. <p> It can be shown that the running time of RPMC is given by <ref> [14] </ref>. The RPMC algorithm is easily extended to efficiently handle nonzero delays. See [14] for details. 8 Experimental Results BMLB schedule. The graph is an abstraction for a satellite receiver implementation and is taken from [18]. The graph is annotated with the produced/consumed numbers wherever they are different from unity. <p> We have presented the results of an extensive experimental study in which we evaluate the performance of APGAN and RPMC, a top-down technique developed in <ref> [14] </ref> that is based on recursively applying a generalized minimum-cut operation.
Reference: [15] <author> D. R. OHallaron, </author> <title> The Assign Parallel Program Generator, </title> <institution> Memorandum CMU-CS-91-141, School of Computer Science, Carnegie Mellon University, </institution> <month> May, </month> <year> 1991. </year>
Reference-contexts: Numerous DSP design environments, including a number of commercial tools, support SDF or closely related models <ref> [11, 12, 15, 16, 17] </ref>. In SDF, a program is represented by a directed graph in which each vertex (actor) represents a computation, edges specify FIFO communication channels, and each actor produces (consumes) a fixed number of data values (tokens) onto (from) each output (input) edge per invocation.
Reference: [16] <author> J. Pino, S. Ha, E. A. Lee, J. T. Buck, </author> <title> Software Synthesis for DSP Using Ptolemy, invited paper in Jo. </title> <booktitle> of VLSI Signal Processing, </booktitle> <month> Jan., </month> <year> 1995. </year>
Reference-contexts: Numerous DSP design environments, including a number of commercial tools, support SDF or closely related models <ref> [11, 12, 15, 16, 17] </ref>. In SDF, a program is represented by a directed graph in which each vertex (actor) represents a computation, edges specify FIFO communication channels, and each actor produces (consumes) a fixed number of data values (tokens) onto (from) each output (input) edge per invocation.
Reference: [17] <author> S. Ritz, S. Pankert, and H. Meyr, </author> <title> High Level Software Synthesis for Signal Processing Systems, </title> <booktitle> Proc. of the Intl. Conf. on Application Specific Array Processors, </booktitle> <month> Aug., </month> <year> 1992. </year>
Reference-contexts: Numerous DSP design environments, including a number of commercial tools, support SDF or closely related models <ref> [11, 12, 15, 16, 17] </ref>. In SDF, a program is represented by a directed graph in which each vertex (actor) represents a computation, edges specify FIFO communication channels, and each actor produces (consumes) a fixed number of data values (tokens) onto (from) each output (input) edge per invocation.

References-found: 17

