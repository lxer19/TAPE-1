URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1993/tr-93-032.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1993.html
Root-URL: http://www.icsi.berkeley.edu
Title: Repetitive Hidden-Surface-Removal for Polyhedra  
Author: Marco Pellegrini 
Keyword: Algorithms and Data Structures.  
Note: Preliminary version of this work is in the Proceedings of the 1993 Workshop on  
Address: I 1947 Center Street Suite 600 Berkeley, California 94704  King's College London  King's College, Strand, London WC2R 2LS U.K.  
Affiliation: INTERNATIONAL COMPUTER SCIENCE INSTITUTE  Dept. of Computer Science,  Dept. of Computer Science,  
Pubnum: TR-93-032  
Email: marco@dcs.kcl.ac.uk  
Phone: 1-510-642-4274 FAX 1-510-643-7684  
Date: July 1993  
Abstract: The repetitive hidden-surface-removal problem can be rephrased as the problem of finding the most compact representation of all views of a polyhedral scene that allows efficient on-line retrieval of a single view. In this paper we present a novel approach to this problem. We assume that a polyhedral scene in 3-space is given in advance and is preprocessed off-line into a data structure. Afterwards, the data structure is accessed repeatedly with view-points given on-line and the portions of the polyhedra visible from each view-point are produced on-line. This mode of operation is close to that of real interactive display systems. The main difficulty is to preprocess the scene without knowing the query view-points. Let n be the number total of edges, vertices and faces of the polyhedral objects and let k be the number of vertices and edges of the image. The main result of this paper is that, using an off-line data structure of size m with n 1+* m n 2+* , it is possible to answer on-line hidden-surface-removal queries in time O(k log n + minfn log n; kn 1+* =m 1=2 g), when the scene is composed of c-oriented polyhedra. This data structure accommodates dynamic insertion and deletion of polyhedral objects. The polyhedra may intersect and may have cycles in the dominance relation. We also improve worst-case time/storage bounds for the repetitive hidden surface removal problem when the polyhedral scene is composed of unrestricted polyhedra. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Agarwal. </author> <title> Geometric partitioning and its applications. </title> <type> Technical Report CS-1991-27, </type> <institution> Dept. of Computer Sci. Duke University, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: Cuttings are the basis of many recent divide-and-conquer algorithms in computational geometry (see <ref> [1] </ref> for a survey). 3. Halfspace range searching. A problem intimately connected to the point-location problem is the half-space range searching problem.
Reference: [2] <author> P. Agarwal, B. Aronov, M. Sharir, and S. Suri. </author> <title> Selecting distances in the plane. </title> <booktitle> In Proceedings of the 6th ACM Symposium on Computational Geometry, </booktitle> <pages> pages 321-331, </pages> <year> 1990. </year>
Reference-contexts: The total time of the simulation is given by O (pT P par + T P 0 T P par log p). Applications of Megiddo's parametric search to geometric problems are in <ref> [2] </ref> [4] [9]. 3 The HSRA Algorithm In this section we give a skeleton algorithm for solving HSR-queries. This algorithm uses the off-line data structures as black boxes (i.e asking queries and receiving answers) and is independent of any particular implementation of these data structures.
Reference: [3] <author> P. Agarwal and J. Matousek. </author> <title> Range searching with semialgebraic sets. </title> <booktitle> In Proc. of the 17th Symp. on Mathematical Foundations of Computer Science, number 629 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-13, </pages> <year> 1992. </year>
Reference-contexts: we can build a data structure D 4 (P ) of size O (n 4+* ) such that for a query point v the visibility map M (v; P ) can be computed in time O (k log 2 n), where k is the output size. 17 Using results in <ref> [3] </ref>, as mentioned in [34], it is possible to trade off storage and query time.
Reference: [4] <author> P. Agarwal and J. Matousek. </author> <title> Ray shooting and parametric search. </title> <booktitle> In Proceedings of the 24th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 517-526, </pages> <year> 1992. </year>
Reference-contexts: The first output-sensitive HSR algorithm that works well even in presence of cycles is in [15] and runs in time O (n 1+* p k). The method in [15] is improved in <ref> [4] </ref> to run in time O (n 2=3+* k 2=3 + n 1+* + k). All methods for one-shot HSR use at least time O (n) to read the input and process it. <p> The total time of the simulation is given by O (pT P par + T P 0 T P par log p). Applications of Megiddo's parametric search to geometric problems are in [2] <ref> [4] </ref> [9]. 3 The HSRA Algorithm In this section we give a skeleton algorithm for solving HSR-queries. This algorithm uses the off-line data structures as black boxes (i.e asking queries and receiving answers) and is independent of any particular implementation of these data structures. <p> The data structure can be built using O (n 2+* ) time and storage. Proof. As noted in <ref> [4] </ref> we obtain a method for ray-shooting by applying the parametric search transformation on an algorithm to test whether a segment does not meet any facet of a c-oriented polyhedra. Thus it sufficient to give an algorithm for counting incidences between segments and c-oriented facets in 3-space.
Reference: [5] <author> P. K. Agarwal and M. Sharir. </author> <title> Applications of a new space partitioning technique. </title> <booktitle> In Proceedings of the 1991 Workshop on Algorithms and Data Structures, number 519 in Lecture Notes in Computer Science, </booktitle> <pages> pages 379-391. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The second algorithm has been improved in <ref> [5] </ref> to run in time O (n 2=3* k 2=3+* + n 1+* + k 1+* ). <p> A graph of the running time T (n; k) as a function of k in logarithmic scale is in Figure 1, for the case of linear storage. 5.2 Dynamization Since all data structures are multilayer data structures based on the CSW scheme <ref> [10, 5] </ref> or on Matousek 's scheme [28] we can use a dynamization result in [5]: Theorem 9 (Theorem 3.1 in [5]) Given a set of n points in R d and a parameter n 1+* m n d+* one can maintain the CSW-partitioning structure in O (m=n 1* ) amortized <p> (n; k) as a function of k in logarithmic scale is in Figure 1, for the case of linear storage. 5.2 Dynamization Since all data structures are multilayer data structures based on the CSW scheme [10, 5] or on Matousek 's scheme [28] we can use a dynamization result in <ref> [5] </ref>: Theorem 9 (Theorem 3.1 in [5]) Given a set of n points in R d and a parameter n 1+* m n d+* one can maintain the CSW-partitioning structure in O (m=n 1* ) amortized time as we insert or delete a point, and can answer half-space range queries in <p> k in logarithmic scale is in Figure 1, for the case of linear storage. 5.2 Dynamization Since all data structures are multilayer data structures based on the CSW scheme [10, 5] or on Matousek 's scheme [28] we can use a dynamization result in <ref> [5] </ref>: Theorem 9 (Theorem 3.1 in [5]) Given a set of n points in R d and a parameter n 1+* m n d+* one can maintain the CSW-partitioning structure in O (m=n 1* ) amortized time as we insert or delete a point, and can answer half-space range queries in time O (n 1+* =m 1=d
Reference: [6] <author> J. Bentley and T. Ottman. </author> <title> Algorithms for reporting and counting geometric intersections. </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-28:643-647, </volume> <year> 1979. </year>
Reference-contexts: This algorithm uses the off-line data structures as black boxes (i.e asking queries and receiving answers) and is independent of any particular implementation of these data structures. The general structure is reminiscent of Bentley and Ottman line-sweep algorithm for reporting intersections of segments in the plane <ref> [6] </ref>. We take a fixed plane at pre-processing time, independently of any viewpoint, as our view-plane V onto which the visibility map is projected. We require that v does not lie on V 1 . <p> Any point is disjoint from at least one such plane. 7 The visibility map M (v; P ) will be constructed by sweeping a vertical line l (x) on V . As in <ref> [6] </ref> we need to keep two data structures: a dictionary Line status (x) which stores the intersection of M (v; P ) with the current line l (x), and the priority queue Event queue (x) which stores the list of "events" in sorted order along the x-axis.
Reference: [7] <author> M. Bern. </author> <title> Hidden surface removal for rectangles. </title> <booktitle> In Proceedings of the 4th ACM Symposium on Computational Geometry, </booktitle> <pages> pages 183-192, </pages> <year> 1988. </year> <month> 18 </month>
Reference: [8] <author> M. Bern, D. Dobkin, D. Eppstein, and R. Grossman. </author> <title> Visibility with a moving point. </title> <booktitle> In Proceedings of the 1st ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 107-117, </pages> <year> 1990. </year>
Reference-contexts: A variation of the HSR problem that received some attention in the research community is obtained when we constrain the view-point to be on a given line L. This problem has applications in flight simulation. The idea in <ref> [8] </ref> and [31] is to precompute all topologically different visibility maps for viewpoints on L using a sweeping approach. Such results are thus close to the aspect graph approach. <p> In general 1 K K s K t n 3 =3. The algorithm in [31] computes all K changes in time O ((K s + n 2 ff (n)) log n). The algorithm in <ref> [8] </ref> computes all K changes in time O ((n 2 + K t ) log n). Since since we can build examples in which K is O (1) and K s ; K t = (n 2 ), these solutions do not exhibit a guaranteed output-sensitive behaviour. <p> Since since we can build examples in which K is O (1) and K s ; K t = (n 2 ), these solutions do not exhibit a guaranteed output-sensitive behaviour. The methods in <ref> [31, 8] </ref> do not seem to be able to make use of a restriction of the input to axis-oriented polyhedra and no trade-off between storage and query time seems possible. 1.4 Previous results on one-shot HSR for c-oriented polyhedra Solutions to the one-shot HSR problem have developed following ideas quite different
Reference: [9] <author> B. Chazelle, H. Edelsbrunner, L. Guibas, and M. Sharir. </author> <title> Diameter, width, closest line pair and parametric search. </title> <booktitle> In Proceedings of the 8th ACM Symposium on Computational Geometry, </booktitle> <pages> pages 120-129, </pages> <year> 1992. </year>
Reference-contexts: The total time of the simulation is given by O (pT P par + T P 0 T P par log p). Applications of Megiddo's parametric search to geometric problems are in [2] [4] <ref> [9] </ref>. 3 The HSRA Algorithm In this section we give a skeleton algorithm for solving HSR-queries. This algorithm uses the off-line data structures as black boxes (i.e asking queries and receiving answers) and is independent of any particular implementation of these data structures.
Reference: [10] <author> B. Chazelle, M. Sharir, and E. Welzl. </author> <title> Quasi-optimal upper bounds for simplex range searching and new zone theorems. </title> <booktitle> In Proceedings of the 6th ACM Symposium on Computational Geometry, </booktitle> <pages> pages 23-33, </pages> <year> 1990. </year>
Reference-contexts: Given a set S of n points in R d , build a data structure such that, for every query half-space h + , the number of points in S " h + is computed efficiently. This problem is solved in <ref> [10, 28] </ref> using partition trees. In a partition tree, each node is associated with a region in R d such that only a fraction of the children intersect the hyperplane h supporting the query half-space. <p> Multilevel data structures are a basic paradigm in computational geometry [30]. They are used to search for elements satisfying a complex property. Usually the complex property is split into elementary properties and each elementary property is tested at a specific level of the data structure. For example, in <ref> [10, 28] </ref> sets of points are organized in multilevel partition trees to answer simplex range queries, where each level of the data structure tests the position of the data points with respect to the hyperplane spanning a facet of the simplex. <p> We have this fundamental theorem in <ref> [10] </ref>: Theorem 1 (Theorem 3.1 in [10]) Simplex range searching in n points in R d can be performed in O (n 1+* =m 1=d ) query time, for every * &gt; 0, using a data structure of size m (for any m between n and n d ) which can <p> We have this fundamental theorem in <ref> [10] </ref>: Theorem 1 (Theorem 3.1 in [10]) Simplex range searching in n points in R d can be performed in O (n 1+* =m 1=d ) query time, for every * &gt; 0, using a data structure of size m (for any m between n and n d ) which can be computed in O (m 1+* <p> The same result can be obtained by dualizing point and surfaces of Lemma 1, in this case the problem is transformed in a series of halfplane range searching on sets of points in 2-spaces. 15 Such queries can be solved using the techniques in <ref> [10, 28] </ref> in n 1+* m n 2+* storage and T = O (n 1+* =m 1=2 ) query time. <p> When we apply the parametric search technique to superlogarithmic algorithms (as it is the case for the query time in the trade-off case) we use the more sophisticated form of parametric search that needs a parallel version of the halfplane range searching algorithm [29]. The data structures in <ref> [10, 28] </ref> are based on a partition-tree approach and the query time depends on the number of nodes in the partition tree visited during the query. We can allocate dynamically processors to the nodes visited during the search, thus we need p = O (n 1+* =m 1=2 ) processors. <p> A graph of the running time T (n; k) as a function of k in logarithmic scale is in Figure 1, for the case of linear storage. 5.2 Dynamization Since all data structures are multilayer data structures based on the CSW scheme <ref> [10, 5] </ref> or on Matousek 's scheme [28] we can use a dynamization result in [5]: Theorem 9 (Theorem 3.1 in [5]) Given a set of n points in R d and a parameter n 1+* m n d+* one can maintain the CSW-partitioning structure in O (m=n 1* ) amortized
Reference: [11] <author> K. Clarkson. </author> <title> New applications of random sampling in computational geometry. </title> <journal> Discrete & Computational Geometry, </journal> <volume> 2 </volume> <pages> 195-222, </pages> <year> 1987. </year>
Reference-contexts: A triangulation 4A (R) is a subdivision of each cell of A (R) into disjoint simplices such that the vertices of each simplex are vertices of A (R). The number of simplices in 4A (R) is O (r d ). The random sampling theory of Clarkson <ref> [11] </ref> states that with probability at least 1=2 the interior of each simplex s 2 4A (R) does not meet more than O (n=r log r) hyperplanes of H. A set as 4A (R) is called a cutting for H. <p> Given H we can build a data structure which uses Cn d+* storage, for each * &gt; 0, where the constant C depends on *, such that a query point is located in A (H) in O (log n) time <ref> [11] </ref>. This data structure is built in expected time O (n d+* ) [11]. <p> can build a data structure which uses Cn d+* storage, for each * &gt; 0, where the constant C depends on *, such that a query point is located in A (H) in O (log n) time <ref> [11] </ref>. This data structure is built in expected time O (n d+* ) [11]. For d = 2 Matousek [27] gives a deterministic method that, for a parameter r &lt; n, subdivides the plane into O (r 2 ) triangles in time O (nr) such that the interior of each triangle meets only n=r lines in H.
Reference: [12] <author> R. Cole. </author> <title> Slowing down sorting networks to obtain faster sorting algorithms. </title> <journal> J. of ACM, </journal> <volume> 34 </volume> <pages> 200-208, </pages> <year> 1987. </year>
Reference-contexts: Moreover, suppose that the predicate P (i; t) is monotone in t, meaning that it is false for t = 0 and once it is true it remains so for larger values of t. Megiddo's parametric search technique <ref> [29, 12] </ref> is a method that transforms P 0 into an algorithm P 00 for finding the minimum value of t for which the predicate P (i; t) is true.
Reference: [13] <author> M. de Berg. </author> <title> Dynamic output-sensitive hidden surface removal for c-oriented polyhedra. Computational Geometry: </title> <journal> Theory and Applications, </journal> <volume> 2 </volume> <pages> 119-140, </pages> <year> 1992. </year>
Reference-contexts: The algorithm proposed by de Berg and Overmars in [17] for HSR on c-oriented polyhedra works in single-shot mode, with a time complexity O ((n + k) log n), without requiring acyclicity of the dominance relation. In <ref> [13] </ref> there is a method for maintaining the view of c-oriented polyhedra from a fixed point of view when we are allowed to insert and delete polyhedra. Since our algorithm borrows some tricks from [17] it is worth to discuss this algorithm in more detail.
Reference: [14] <author> M. de Berg. </author> <title> Efficient Algorithms for ray-shooting and hidden surface removal. </title> <type> PhD thesis, </type> <institution> Utrecht University, Dept. of Comp. Sci., </institution> <year> 1992. </year>
Reference-contexts: A good survey of old and recent results can be found in <ref> [14, 40] </ref>. Given a set P of objects bounded by polygonal faces which we assume to be opaque, a view-point v, and a view-plane V , the problem consists in computing the visible portion of the scene as viewed from v and projected on V . <p> In this case all the visible edges incident to v are inserted in the data structure. Event (vi) is quite important because it allows us to find on-line all the connected components of the visibility map. By a discussion in <ref> [17, 14] </ref> these are all and only the interesting events. Since each edge is traced until visible and discarded afterwards until it might be visible again, at each instant Line status (x) stores a faithful representation of M (v; P ) " l (x).
Reference: [15] <author> M. de Berg, D. Halperlin, M. Overmars, J. Snoeyink, and M. van Kreveld. </author> <title> Efficient ray-shooting and hidden surface removal. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Computational Geometry, </booktitle> <pages> pages 21-30, </pages> <year> 1991. </year>
Reference-contexts: For terrains Reif and Sen [38] obtain an O ((n + k) log n log log n) algorithm. The first output-sensitive HSR algorithm that works well even in presence of cycles is in <ref> [15] </ref> and runs in time O (n 1+* p k). The method in [15] is improved in [4] to run in time O (n 2=3+* k 2=3 + n 1+* + k). All methods for one-shot HSR use at least time O (n) to read the input and process it. <p> For terrains Reif and Sen [38] obtain an O ((n + k) log n log log n) algorithm. The first output-sensitive HSR algorithm that works well even in presence of cycles is in <ref> [15] </ref> and runs in time O (n 1+* p k). The method in [15] is improved in [4] to run in time O (n 2=3+* k 2=3 + n 1+* + k). All methods for one-shot HSR use at least time O (n) to read the input and process it. <p> In all of the methods mentioned above a change in the view-point triggers an extensive reconstruction of the data structures. Our aim is to improve the time bound for small values of k. We will borrow a few tricks from <ref> [15] </ref>. The basic idea in [15] is to use a sweeping line approach to the construction of M (v; P ). The event queue is initialized with the vertices of P and the computation proceeds using primitives for ray-shooting on curtains and ray-shooting from the viewpoint v. <p> In all of the methods mentioned above a change in the view-point triggers an extensive reconstruction of the data structures. Our aim is to improve the time bound for small values of k. We will borrow a few tricks from <ref> [15] </ref>. The basic idea in [15] is to use a sweeping line approach to the construction of M (v; P ). The event queue is initialized with the vertices of P and the computation proceeds using primitives for ray-shooting on curtains and ray-shooting from the viewpoint v. <p> In order to obtain our result on repetitive HSR we mix and modify the approaches in [17] and <ref> [15] </ref>. We use a sweeping line approach, but we avoid initializing the queue with all the vertices. Instead, we discover the visible vertices on the fly. Vertices that are not visible are never put in the queue. The second challenge is to make our data structure independent of v. <p> We pay this freedom with an increase in the storage requirement. Then we return to linear storage by trading off storage with query time. In order to achieve these two goals we must support primitive operations more powerful than those in [17] and <ref> [15] </ref>. In particular, besides supporting ray-shooting queries we must be able to count efficiently how many edges of the polyhedral scene meet query triangles and query pyramids. Moreover, we apply Megiddo's parametric search technique [29] in order to obtain even more powerful operations.
Reference: [16] <author> M. de Berg, D. Halperlin, M. Overmars, and M. van Kreveld. </author> <title> Sparse arrangements and the number of views of polyhedral scenes. </title> <type> Manuscript, </type> <month> June </month> <year> 1992. </year>
Reference-contexts: In [39] it is shown that for axis oriented polyhedra with n edges the number of orthographic views can be fi (n 6 ). In <ref> [16] </ref> it is shown that for a polyhedral terrain with n edges there can be (n 5 ff (n)) orthographic views and (n 8 ff (n)) perspective views.
Reference: [17] <author> M. de Berg and M. Overmars. </author> <title> Hidden surface removal for axis-parallel polyhedra. </title> <booktitle> In Proceedings of the 31st IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 252-261, </pages> <year> 1990. </year>
Reference-contexts: Preparata et al. [37] compute M (v; P ) for axis-oriented polyhedra in time O ((n + k) log n log log n) provided that the dominance relation is acyclic. The algorithm proposed by de Berg and Overmars in <ref> [17] </ref> for HSR on c-oriented polyhedra works in single-shot mode, with a time complexity O ((n + k) log n), without requiring acyclicity of the dominance relation. <p> In [13] there is a method for maintaining the view of c-oriented polyhedra from a fixed point of view when we are allowed to insert and delete polyhedra. Since our algorithm borrows some tricks from <ref> [17] </ref> it is worth to discuss this algorithm in more detail. The method in [17] is based on using some primitive operations: (i) ray-shooting queries on "curtains" and (ii) vertex-visibility queries. Each component of M (v; P ) is "traced" using these two primitives. <p> In [13] there is a method for maintaining the view of c-oriented polyhedra from a fixed point of view when we are allowed to insert and delete polyhedra. Since our algorithm borrows some tricks from <ref> [17] </ref> it is worth to discuss this algorithm in more detail. The method in [17] is based on using some primitive operations: (i) ray-shooting queries on "curtains" and (ii) vertex-visibility queries. Each component of M (v; P ) is "traced" using these two primitives. <p> In order to obtain our result on repetitive HSR we mix and modify the approaches in <ref> [17] </ref> and [15]. We use a sweeping line approach, but we avoid initializing the queue with all the vertices. Instead, we discover the visible vertices on the fly. Vertices that are not visible are never put in the queue. <p> We pay this freedom with an increase in the storage requirement. Then we return to linear storage by trading off storage with query time. In order to achieve these two goals we must support primitive operations more powerful than those in <ref> [17] </ref> and [15]. In particular, besides supporting ray-shooting queries we must be able to count efficiently how many edges of the polyhedral scene meet query triangles and query pyramids. Moreover, we apply Megiddo's parametric search technique [29] in order to obtain even more powerful operations. <p> In this case all the visible edges incident to v are inserted in the data structure. Event (vi) is quite important because it allows us to find on-line all the connected components of the visibility map. By a discussion in <ref> [17, 14] </ref> these are all and only the interesting events. Since each edge is traced until visible and discarded afterwards until it might be visible again, at each instant Line status (x) stores a faithful representation of M (v; P ) " l (x). <p> After the parametric-search transformation we have a total query time O (T 0 p + T T 0 log n) = O (n 1+* =m 1=2 ), for a slightly greater value of *. Also, we can run in parallel the algorithm in <ref> [17] </ref>, which has better performances when k is large. <p> If we allow only linear storage we obtain a query time roughly order of k p n which is asymptotically better than the one-shot algorithm of <ref> [17] </ref> for k p n. The result of Corollary 1 is significant for those scenes in which only a small part of the total number of polyhedra is visible at any given time.
Reference: [18] <author> H. Edelsbrunner. </author> <title> Algorithms in Combinatorial Geometry. </title> <publisher> Springer Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Arrangements. A finite set H of hyperplanes in R d defines a decomposition of R d into convex cells of various dimensions, which is called the arrangement A (H) of H <ref> [18] </ref>. If jHj = n the maximum number of cells in A (H) is O (n d ) and the arrangement A (H) can be computed in optimal O (n d ) time [20]. <p> One d-dimensional cell of A (H) is bounded by O (n bd=2c ) cells of any dimension <ref> [18] </ref>. 2. Random sampling and cuttings. Given a random sample R of a set of hyperlanes H, with jRj = r n, let us consider the arrangement A (R).
Reference: [19] <author> H. Edelsbrunner, L. Guibas, and J. Stolfi. </author> <title> Optimal point location in a monotone subdivision. </title> <journal> SIAM Journal of Computing, </journal> (15):317-339, 1986. 
Reference-contexts: Also we build in time O (r) a fast planar location data structure using the method in <ref> [19, 24] </ref>, which attains O (log r) query time. For each elementary cell t we select a point in its interior and we compute the set S + t of surfaces not intersecting the region t and in positive position with respect to t .
Reference: [20] <author> H. Edelsbrunner, J. O'Rourke, and R. Seidel. </author> <title> Constructing arrangements of lines and hyperplanes with applications. </title> <journal> SIAM Journal of Computing, </journal> <pages> pages 341-363, </pages> <year> 1986. </year>
Reference-contexts: If jHj = n the maximum number of cells in A (H) is O (n d ) and the arrangement A (H) can be computed in optimal O (n d ) time <ref> [20] </ref>. One d-dimensional cell of A (H) is bounded by O (n bd=2c ) cells of any dimension [18]. 2. Random sampling and cuttings. Given a random sample R of a set of hyperlanes H, with jRj = r n, let us consider the arrangement A (R).
Reference: [21] <author> Z. Gigus, J. Canny, and R. Seidel. </author> <title> Efficiently computing and representing aspect graphs of polyhedral objects. </title> <journal> IEEE Transactions on pattern Analysis and Machine Intelligence, </journal> <volume> 13 </volume> <pages> 542-551, </pages> <year> 1991. </year>
Reference-contexts: In the last part of the paper we apply the same approach to the case of general polyhedra thereby improving worst-case time/storage bounds. 1.2 The aspect graph approach Traditionally, the problem of efficiently computing the visibility map of a polygonal scene has been tackled using the aspect graph approach <ref> [25, 26, 35, 21] </ref>. For a survey of results on aspect graphs see [21, 22]. The aspect graph of a polyhedral scene is a graph in which each node is associated with a region of R 3 where visibility maps with the same combinatorial 1 structure are visible. <p> For a survey of results on aspect graphs see <ref> [21, 22] </ref>. The aspect graph of a polyhedral scene is a graph in which each node is associated with a region of R 3 where visibility maps with the same combinatorial 1 structure are visible. <p> Provided that we can store efficiently the visibility maps at the nodes of the graph and that, given a view-point we can find efficiently the corresponding node in the graph, the storage depends mainly on the number of nodes and edges in the aspect graph. In <ref> [21] </ref> Gigus, Canny and Seidel give an algorithm for computing the aspect graph of orthographic views (i.e with viewpoint at infinity) of a general polyhedral scene. They use O (n 4 log n + jGj log jGj) time to produce the aspect graph G. <p> This graph is stored in a data structure of size O (jGj) and orthographic HSR-queries can be solved in time O (log jGj + k), where k is the size of the output visibility map. The method in <ref> [21] </ref> does not seem to generalize immediately to computing also the aspect graph of perspective views (i.e. with a proper point as view-point). For perspective views a method in [36] computes the aspect graph in time O (n 5 + n 2 jGj) and O (n 2 jGj) working storage.
Reference: [22] <author> Z. Gigus and J. Malik. </author> <title> Computing the aspect graphs for line drawings of of polyhedral objects. </title> <journal> IEEE Transactions on pattern Analysis and Machine Intelligence, </journal> <volume> 12 </volume> <pages> 113-122, </pages> <year> 1990. </year>
Reference-contexts: For a survey of results on aspect graphs see <ref> [21, 22] </ref>. The aspect graph of a polyhedral scene is a graph in which each node is associated with a region of R 3 where visibility maps with the same combinatorial 1 structure are visible.
Reference: [23] <author> M. Katz, M. Overmars, and M. Sharir. </author> <title> Efficient hidden surface removal for objects with small union size. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Computational Geometry, </booktitle> <pages> pages 31-40, </pages> <year> 1991. </year>
Reference-contexts: The second algorithm has been improved in [5] to run in time O (n 2=3* k 2=3+* + n 1+* + k 1+* ). For objects with the additional property that the union of their projections has small complexity Katz et al. <ref> [23] </ref> give an algorithm running in time O ((U (n)+k) log 2 n), where U (n) is the maximum size of the union of the projections of n such objects.
Reference: [24] <author> D. Kirkpatrick. </author> <title> Optimal search in planar subdivision. </title> <journal> SIAM Journal of Computing, </journal> (12):28-35, 1983. 
Reference-contexts: Also we build in time O (r) a fast planar location data structure using the method in <ref> [19, 24] </ref>, which attains O (log r) query time. For each elementary cell t we select a point in its interior and we compute the set S + t of surfaces not intersecting the region t and in positive position with respect to t .
Reference: [25] <author> J. Koenderlink and J. van Doorn. </author> <title> The singularities of visual mapping. </title> <journal> Biological Cybernetics, </journal> <volume> 24 </volume> <pages> 51-59, </pages> <year> 1976. </year>
Reference-contexts: In the last part of the paper we apply the same approach to the case of general polyhedra thereby improving worst-case time/storage bounds. 1.2 The aspect graph approach Traditionally, the problem of efficiently computing the visibility map of a polygonal scene has been tackled using the aspect graph approach <ref> [25, 26, 35, 21] </ref>. For a survey of results on aspect graphs see [21, 22]. The aspect graph of a polyhedral scene is a graph in which each node is associated with a region of R 3 where visibility maps with the same combinatorial 1 structure are visible.
Reference: [26] <author> J. Koenderlink and J. van Doorn. </author> <title> The internal representation of solid shape with respect to vision. </title> <journal> Biological Cybernetics, </journal> <volume> 32 </volume> <pages> 211-216, </pages> <year> 1979. </year>
Reference-contexts: In the last part of the paper we apply the same approach to the case of general polyhedra thereby improving worst-case time/storage bounds. 1.2 The aspect graph approach Traditionally, the problem of efficiently computing the visibility map of a polygonal scene has been tackled using the aspect graph approach <ref> [25, 26, 35, 21] </ref>. For a survey of results on aspect graphs see [21, 22]. The aspect graph of a polyhedral scene is a graph in which each node is associated with a region of R 3 where visibility maps with the same combinatorial 1 structure are visible.
Reference: [27] <author> J. Matousek. </author> <title> Cutting hyperplane arrangements. </title> <booktitle> In Proceedings of the 6th ACM Symposium on Computational Geometry, </booktitle> <pages> pages 1-9, </pages> <year> 1990. </year>
Reference-contexts: This data structure is built in expected time O (n d+* ) [11]. For d = 2 Matousek <ref> [27] </ref> gives a deterministic method that, for a parameter r &lt; n, subdivides the plane into O (r 2 ) triangles in time O (nr) such that the interior of each triangle meets only n=r lines in H. <p> Proof. Let T j (n) be the time needed to build the data structure up to level j. We prove the claim by induction on j. For j = 0, T 0 (n) = O (1) therefore the time bound is satisfied. Assume j &gt; 0. Applying Matousek <ref> [27] </ref> partitioning technique on the set of hyperplanes fS j a (:) = 0ja 2 Ag we compute in time O (nr) decomposition of the 2-dimensional space into O (r 2 ) elementary cells (triangles as a matter of fact) with the property that each elementary cell is intersected by no
Reference: [28] <author> J. Matousek. </author> <title> Efficient partition trees. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Computational Geometry, </booktitle> <pages> pages 1-9, </pages> <year> 1991. </year>
Reference-contexts: Given a set S of n points in R d , build a data structure such that, for every query half-space h + , the number of points in S " h + is computed efficiently. This problem is solved in <ref> [10, 28] </ref> using partition trees. In a partition tree, each node is associated with a region in R d such that only a fraction of the children intersect the hyperplane h supporting the query half-space. <p> Multilevel data structures are a basic paradigm in computational geometry [30]. They are used to search for elements satisfying a complex property. Usually the complex property is split into elementary properties and each elementary property is tested at a specific level of the data structure. For example, in <ref> [10, 28] </ref> sets of points are organized in multilevel partition trees to answer simplex range queries, where each level of the data structure tests the position of the data points with respect to the hyperplane spanning a facet of the simplex. <p> R d can be performed in O (n 1+* =m 1=d ) query time, for every * &gt; 0, using a data structure of size m (for any m between n and n d ) which can be computed in O (m 1+* ) randomized expected time. 6 Matousek in <ref> [28] </ref>, using a different partition scheme, is able to make the preprocessing deterministic and to reduce the query time to O (n log O (1) n=m 1=d ). 5. Parametric search. <p> The same result can be obtained by dualizing point and surfaces of Lemma 1, in this case the problem is transformed in a series of halfplane range searching on sets of points in 2-spaces. 15 Such queries can be solved using the techniques in <ref> [10, 28] </ref> in n 1+* m n 2+* storage and T = O (n 1+* =m 1=2 ) query time. <p> When we apply the parametric search technique to superlogarithmic algorithms (as it is the case for the query time in the trade-off case) we use the more sophisticated form of parametric search that needs a parallel version of the halfplane range searching algorithm [29]. The data structures in <ref> [10, 28] </ref> are based on a partition-tree approach and the query time depends on the number of nodes in the partition tree visited during the query. We can allocate dynamically processors to the nodes visited during the search, thus we need p = O (n 1+* =m 1=2 ) processors. <p> A graph of the running time T (n; k) as a function of k in logarithmic scale is in Figure 1, for the case of linear storage. 5.2 Dynamization Since all data structures are multilayer data structures based on the CSW scheme [10, 5] or on Matousek 's scheme <ref> [28] </ref> we can use a dynamization result in [5]: Theorem 9 (Theorem 3.1 in [5]) Given a set of n points in R d and a parameter n 1+* m n d+* one can maintain the CSW-partitioning structure in O (m=n 1* ) amortized time as we insert or delete a
Reference: [29] <author> N. Megiddo. </author> <title> Applying parallel computation algorithms in the design of sequential algorithms. </title> <journal> J. of ACM, </journal> <volume> 30 </volume> <pages> 852-865, </pages> <year> 1983. </year>
Reference-contexts: In particular, besides supporting ray-shooting queries we must be able to count efficiently how many edges of the polyhedral scene meet query triangles and query pyramids. Moreover, we apply Megiddo's parametric search technique <ref> [29] </ref> in order to obtain even more powerful operations. Intuitively, we need to detect efficiently the first moment in which a growing triangle or pyramid intersects a feature of P . We implement all these operations for c-oriented polyhedra by a reduction to planar point location and half-plane range queries. <p> Moreover, suppose that the predicate P (i; t) is monotone in t, meaning that it is false for t = 0 and once it is true it remains so for larger values of t. Megiddo's parametric search technique <ref> [29, 12] </ref> is a method that transforms P 0 into an algorithm P 00 for finding the minimum value of t for which the predicate P (i; t) is true. <p> Therefore we can use Megiddo's parametric search technique to transform the algorithm of Theorem 4 into an algorithm for finding s fl <ref> [29] </ref>. The query time of the transformed algorithm is the square of the time of the original one. <p> When we apply the parametric search technique to superlogarithmic algorithms (as it is the case for the query time in the trade-off case) we use the more sophisticated form of parametric search that needs a parallel version of the halfplane range searching algorithm <ref> [29] </ref>. The data structures in [10, 28] are based on a partition-tree approach and the query time depends on the number of nodes in the partition tree visited during the query. <p> Minimal-empty triangle queries. We use the data structure in [34, Theorem 3] to answer triangle emptiness queries. We modify the query method by applying Megiddo's parametric search <ref> [29] </ref>, thus obtaining a method to determine the smallest empty triangle in a family of triangles forming a chain of inclusions. The query time becomes O (log 2 n). 4. Minimal-empty pyramid queries. <p> This method can be easily adapted to answer emptiness queries with any convex polyhedron with a constant number of facets (e.g. a pyramid with quadrangular base). Similarly to the previous case we modify the query algorithm by applying Megiddo's parametric search <ref> [29] </ref>. Minimal-empty pyramid queries can be solved in time O (log 2 n) using O (n 4+* ) storage.
Reference: [30] <author> K. Mehlhorn. </author> <title> Multidimensional Searching and Computational Geometry. </title> <publisher> Springer Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Partition trees are quite versatile and they can be used to set up multi-level data structures. 4. Multi-level data structures. Multilevel data structures are a basic paradigm in computational geometry <ref> [30] </ref>. They are used to search for elements satisfying a complex property. Usually the complex property is split into elementary properties and each elementary property is tested at a specific level of the data structure.
Reference: [31] <author> K. Mulmuley. </author> <title> Hidden surface removal with respect to a moving view point. </title> <booktitle> In Proceedings of the 23th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 512-522, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction 1.1 The problem The Hidden Surface Removal problem (HSR for short) for polyhedral scenes in 3-space is important for graphical applications and has attracted much interest in the research community in recent years (e.g. [15],[7],[38],[5],[23], [32],[17] and <ref> [31] </ref>). A good survey of old and recent results can be found in [14, 40]. <p> The main conclusion suggested by the new results is that in general the number of possible views of a polyhedral scene is not a lower bound on the storage needed for a compact representation of a scene. 1.3 Other previous results on repetitive HSR In <ref> [31] </ref>, Mulmuley builds a spatial decomposition D (P ) for a general non-intersecting polyhedral scene P . The size of D (P ) is fi (n 2 ) in the worst case, and ranges from linear to quadratic depending on the input. <p> Note that the visibility map M (v; P ) is embedded in the boundary of V (v; P ). The time bound for the construction of M (v; P ) is proportional to the number of features of V (v; P ) " D (P ). As recognized in <ref> [31] </ref> it is not difficult to devise an example (P; v) in which the size of M (v; P ) is constant but but the size of V (v; P ) " D (P ) is quadratic. <p> A variation of the HSR problem that received some attention in the research community is obtained when we constrain the view-point to be on a given line L. This problem has applications in flight simulation. The idea in [8] and <ref> [31] </ref> is to precompute all topologically different visibility maps for viewpoints on L using a sweeping approach. Such results are thus close to the aspect graph approach. Let us define by K the number of topological changes in the visibility map M (v; P ) for v moving on L. <p> With K s we denote the semi-opaque topological changes (i.e. changes on the projection of edges in P , such that the segments involved can see each other locally). In general 1 K K s K t n 3 =3. The algorithm in <ref> [31] </ref> computes all K changes in time O ((K s + n 2 ff (n)) log n). The algorithm in [8] computes all K changes in time O ((n 2 + K t ) log n). <p> Since since we can build examples in which K is O (1) and K s ; K t = (n 2 ), these solutions do not exhibit a guaranteed output-sensitive behaviour. The methods in <ref> [31, 8] </ref> do not seem to be able to make use of a restriction of the input to axis-oriented polyhedra and no trade-off between storage and query time seems possible. 1.4 Previous results on one-shot HSR for c-oriented polyhedra Solutions to the one-shot HSR problem have developed following ideas quite different
Reference: [32] <author> M. Overmars and M. Sharir. </author> <title> Output-sensitive hidden surface removal. </title> <booktitle> In Proceedings of the 30th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 598-603, </pages> <year> 1989. </year>
Reference-contexts: We shall see in this paper how these difficulties can be overcame. 3 1.5 Previous results on one-shot HSR for general polyhedra When the dominance relation on general non-intersecting polyhedra is acyclic, Overmars and Sharir <ref> [32] </ref> give two algorithms running in time O (n p k 3=5 n 4=5+* ). The second algorithm has been improved in [5] to run in time O (n 2=3* k 2=3+* + n 1+* + k 1+* ).
Reference: [33] <author> M. Pellegrini. </author> <title> Ray shooting and isotopy classes of lines in 3-dimensional space. To appear in Algorithmica. </title> <booktitle> Preliminary version in Proceedings of the 1991 Workshop on Algorithms and Data Structures, number 519 in Lecture Notes in Computer Science, </booktitle> <pages> pages 20-31. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Thus from Lemma 1 we can count efficiently how many c-oriented facets meet a query segment, and thus also decide if the query segment is empty of intersections. As a matter of fact, by extending a slightly different approach to this ray-shooting problem developed in <ref> [33] </ref> for axis-oriented polyhedra (a special case of c-oriented polyhedra) it is possible to avoid using parametric search and to reduce the query time to O (log n). <p> Ray-shooting queries. From results in <ref> [33, Theorem 8] </ref> we can answer ray-shooting queries in time O (log n) using O (n 4+* ) storage. 2. Empty triangle queries. From results in [34, Theorem 3] we can answer triangle emptiness queries in time O (log n) using O (n 4+* ) storage. 3. Minimal-empty triangle queries.
Reference: [34] <author> M. Pellegrini. </author> <title> On collision-free placements of simplices and the closest pair of lines in 3-space. </title> <note> To appear in SIAM J. on Computing. Preliminary version in the 8th ACM Symp. on Comp. </note> <editor> Geom. </editor> <title> with the title 'Incidence and nearest-neighbor problems for lines in 3-space' pp. </title> <type> 130-137, </type> <year> 1992. </year>
Reference-contexts: The algorithm in Section 3 is quite general and works also for general polyhedral scenes when we provide an implementation for the primitive operations. The implementation of the primitive operations for general polyhedra is based on results in <ref> [34] </ref> on collision-free simplices. The paper is organized as follows. In Section 2 we review some geometric tools used to derive the results. In Section 3 we describe an high-level generic algorithm for solving hidden-surface removal queries which we will denote as the HSRA algorithm. <p> Note that, for a given j, an element a 2 A (resp. b 2 B) is mapped to a point or to a surface. We call the point and the surface dual to one another. The problem stated above is discussed in full generality in <ref> [34] </ref>. In this paper we discuss a restricted cases relevant for deriving the main result on the HSR problem. We use the 10 additional hypothesis that all of the surfaces S j a and S b are hyperplanes in a 1-dimensional or 2-dimensional space. <p> Ray-shooting queries. From results in [33, Theorem 8] we can answer ray-shooting queries in time O (log n) using O (n 4+* ) storage. 2. Empty triangle queries. From results in <ref> [34, Theorem 3] </ref> we can answer triangle emptiness queries in time O (log n) using O (n 4+* ) storage. 3. Minimal-empty triangle queries. We use the data structure in [34, Theorem 3] to answer triangle emptiness queries. <p> Empty triangle queries. From results in <ref> [34, Theorem 3] </ref> we can answer triangle emptiness queries in time O (log n) using O (n 4+* ) storage. 3. Minimal-empty triangle queries. We use the data structure in [34, Theorem 3] to answer triangle emptiness queries. We modify the query method by applying Megiddo's parametric search [29], thus obtaining a method to determine the smallest empty triangle in a family of triangles forming a chain of inclusions. The query time becomes O (log 2 n). 4. <p> We modify the query method by applying Megiddo's parametric search [29], thus obtaining a method to determine the smallest empty triangle in a family of triangles forming a chain of inclusions. The query time becomes O (log 2 n). 4. Minimal-empty pyramid queries. A data structure described in <ref> [34, Theorem 4] </ref> answers simplex emptiness queries in time O (log n) using O (n 4+* ) storage. This method can be easily adapted to answer emptiness queries with any convex polyhedron with a constant number of facets (e.g. a pyramid with quadrangular base). <p> data structure D 4 (P ) of size O (n 4+* ) such that for a query point v the visibility map M (v; P ) can be computed in time O (k log 2 n), where k is the output size. 17 Using results in [3], as mentioned in <ref> [34] </ref>, it is possible to trade off storage and query time.
Reference: [35] <author> W. Plantiga and C. Dyer. </author> <title> An algorithm for constructing the aspect graph. </title> <booktitle> In Proceedings of the 27th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 123-131, </pages> <year> 1986. </year>
Reference-contexts: In the last part of the paper we apply the same approach to the case of general polyhedra thereby improving worst-case time/storage bounds. 1.2 The aspect graph approach Traditionally, the problem of efficiently computing the visibility map of a polygonal scene has been tackled using the aspect graph approach <ref> [25, 26, 35, 21] </ref>. For a survey of results on aspect graphs see [21, 22]. The aspect graph of a polyhedral scene is a graph in which each node is associated with a region of R 3 where visibility maps with the same combinatorial 1 structure are visible.
Reference: [36] <author> W. Plantiga and C. Dyer. </author> <title> Visibility, occlusion and the aspect graph. </title> <journal> Int. J. of Computer Vision, </journal> <volume> 5 </volume> <pages> 137-160, </pages> <year> 1990. </year> <month> 20 </month>
Reference-contexts: The method in [21] does not seem to generalize immediately to computing also the aspect graph of perspective views (i.e. with a proper point as view-point). For perspective views a method in <ref> [36] </ref> computes the aspect graph in time O (n 5 + n 2 jGj) and O (n 2 jGj) working storage. In [36] it is shown that for n non-intersecting triangles the number of orthographic views is fi (n 6 ) in the worst case and the number of perspective views <p> For perspective views a method in <ref> [36] </ref> computes the aspect graph in time O (n 5 + n 2 jGj) and O (n 2 jGj) working storage. In [36] it is shown that for n non-intersecting triangles the number of orthographic views is fi (n 6 ) in the worst case and the number of perspective views is fi (n 9 ).
Reference: [37] <author> F. Preparata, J. Vitter, and M. Yvinec. </author> <title> Output sensitive generation of the perspective view of isothetic parallelepipeds. </title> <booktitle> In Proceedings of the 2nd Scandinavian Workshop on Algorithm Theory, number 447 in Lecture Notes in Computer Science, </booktitle> <pages> pages 71-84. </pages> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We shall classify output sensitive HSR algorithms in two categories according to their reliance on the existence of an acyclic dominance relation for the objects as seen from the viewpoint. Preparata et al. <ref> [37] </ref> compute M (v; P ) for axis-oriented polyhedra in time O ((n + k) log n log log n) provided that the dominance relation is acyclic.
Reference: [38] <author> J. Reif and S. Sen. </author> <title> An efficient output-sensitive hidden-surface removal algorithm and its parallelization. </title> <booktitle> In Proceedings of the 4th ACM Symposium on Computational Geometry, </booktitle> <pages> pages 193-200, </pages> <year> 1988. </year>
Reference-contexts: This methods applies to disks and balls (U (n) = O (n)), fat triangles (U (n) = O (n log log n)) and terrains (U (n) = O (nff (n))). For terrains Reif and Sen <ref> [38] </ref> obtain an O ((n + k) log n log log n) algorithm. The first output-sensitive HSR algorithm that works well even in presence of cycles is in [15] and runs in time O (n 1+* p k).
Reference: [39] <author> J. Snoeyink. </author> <title> The number of views of axis-parallel objects. </title> <journal> Algorithmic Review, </journal> <volume> 2 </volume> <pages> 27-32, </pages> <year> 1991. </year>
Reference-contexts: In [36] it is shown that for n non-intersecting triangles the number of orthographic views is fi (n 6 ) in the worst case and the number of perspective views is fi (n 9 ). In <ref> [39] </ref> it is shown that for axis oriented polyhedra with n edges the number of orthographic views can be fi (n 6 ).
Reference: [40] <author> I. Sutherland, R. Sproul, and R. Schumaker. </author> <title> A characterization of ten hidden-surface algorithms. </title> <journal> Computing Surveys, </journal> <volume> 6(1) </volume> <pages> 1-55, </pages> <year> 1974. </year> <title> 21 6 log n k0 0.5 1 2 0 1 log n T (n; k) storage. 6 log n k0 0.5 1 2 0 1 log n T (n; k) storage. </title> <type> 22 </type>
Reference-contexts: A good survey of old and recent results can be found in <ref> [14, 40] </ref>. Given a set P of objects bounded by polygonal faces which we assume to be opaque, a view-point v, and a view-plane V , the problem consists in computing the visible portion of the scene as viewed from v and projected on V . <p> This subdivision is called visibility map of P from v, denoted by M (v; P ). Other solutions are classified as "image space" since the aim is to compute for each pixel of the screen the object visible at that pixel <ref> [40] </ref>. We assume in this paper that the polyhedra are given in advance and are preprocessed into a data structure. This step is critical since we do not know at this time which viewpoints will be used. Therefore, our data structure must be independent from any fixed viewpoint.
References-found: 40

