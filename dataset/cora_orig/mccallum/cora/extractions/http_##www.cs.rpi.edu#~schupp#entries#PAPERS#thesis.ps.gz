URL: http://www.cs.rpi.edu/~schupp/entries/PAPERS/thesis.ps.gz
Refering-URL: http://www.cs.rpi.edu/~schupp/suchthat/index.html
Root-URL: http://www.cs.rpi.edu
Title: Generic programming |SuchThat one can build an algebraic library  zur Erlangung des Grades eines  
Author: Doktors der Naturwissenschaften vorgelegt von Sibylle Schupp 
Degree: Dissertation  
Date: 1996  
Affiliation: der Fakultat fur Informatik der Eberhard-Karls-Universitat Tubingen  Tubingen  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. Compilers|Principles, </author> <title> Techniques and Tools. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: But none of the other systems uses C ++ at the realization level. Concerning the imperative body of SuchThat the compiling process goes through canonically. As the compiler construction is well-known today we refer to standard text books <ref> [1] </ref>, [53], [58].
Reference: [2] <author> ANSI, X3J16/95-0087 WG21/NO687. </author> <title> C++ Draft Standard, </title> <month> Apr </month> <year> 1995. </year>
Reference-contexts: According to the current draft standard <ref> [2] </ref>, the return type of a template function becomes significant for the resolution of overloading. 8 A rank differs from the arity in that it contains the type of the return value (s). 13 The forced generality conflicts with the extensibility of a library and with the correctness and the efficiency
Reference: [3] <author> Michael Barr and Charles Wells. </author> <title> Category Theory for Computing Science. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Assume a lift is unique, how can we prove it as unique? We need an analogue to the commutative diagramms of the category theory. If we identify the abstraction process with functors and mathematical structures with nodes can the theory of sketches (see <ref> [3] </ref>, [12], [13]) help? * Liftable properties. <p> Therefore it is an error to redefine the left side. Inside a left hand side, another L A T E X declaration may occur the value of which is replaced by early binding. Examples. * Let Zzeta3X denote `` <ref> [ 3 ] </ref>[X]''; // the string is $"mathbb-Z-["zeta_3][X]$ * let Mmn denote ``Mat nfim ''. // the string is Mat$_-n"times m-$ 48 The realization Syntax. The realization declaration allows to change defaults. Internally, all structure expressions are mapped on a C ++ data type, mostly a container.
Reference: [4] <author> William Brown. </author> <title> The complete Euclidean algorithm. </title> <type> Technical report, </type> <institution> Bell Telephone Laboratories, </institution> <month> Jun </month> <year> 1968. </year>
Reference-contexts: They are important in the theory of symmetric functions and in the theory of discriminants ([39]), in the arithmetics of algebraic extensions ([28]), and in gcd computations. Their importance grew after the connection between resultants and polynomial remainder sequences became clear. For the so-called Fundamental Theorem see [8] and <ref> [4] </ref>, for a survey see [29]. According to its use a resultant is defined as the determinant of the Sylvester matrix (see for example [54]) or as the norm map, i.e., the composition of the determinant map and the regular representation ([41]).
Reference: [5] <author> Kim Bruce, Luca Cardelli, Guiseppe Castagna, The Hopkins Objects Group, Gary T. Leavens, and Benjamin Peirce. </author> <title> On binary methods. </title> <type> Technical Report 95-08, </type> <institution> Iowa State University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: Certainly, there are algorithms for polynomials 9 In the theory of programming languages the necessity for semantic constraints is well-known. For a while, subtyping seemed to be a solution. Quite right, in the meantime it is clear that subtyping itself needs semantic constraints, see [11] and <ref> [5] </ref>. 10 In C ++ the term template denotes families of classes or functions. 14 in general. But there are much more algorithms for special coefficient domains: for UFDs, for gcd-domains with computable unit group, or for algebraic extension of prime characteristic.
Reference: [6] <author> Bruno Buchberger, George Collins, and Rudiger Loos. </author> <title> Computer Algebra. Symbolic and Algebraic Computation. </title> <publisher> Springer, Wien, </publisher> <address> 2nd edition, </address> <year> 1983. </year>
Reference: [7] <author> Reinhard Bundgen. </author> <title> The ReDuX system. </title> <type> Technical Report WSI-91-5, </type> <institution> Wilhelm-Schickard-Institut fur Informatik, </institution> <year> 1991. </year>
Reference: [8] <author> George E. Collins. </author> <title> Subresultant and reduced polynomial remainder sequences. </title> <journal> J. of the Association for Computing Machinery, </journal> <volume> 14(1) </volume> <pages> 128-142, </pages> <month> Jan </month> <year> 1967. </year>
Reference-contexts: They are important in the theory of symmetric functions and in the theory of discriminants ([39]), in the arithmetics of algebraic extensions ([28]), and in gcd computations. Their importance grew after the connection between resultants and polynomial remainder sequences became clear. For the so-called Fundamental Theorem see <ref> [8] </ref> and [4], for a survey see [29]. According to its use a resultant is defined as the determinant of the Sylvester matrix (see for example [54]) or as the norm map, i.e., the composition of the determinant map and the regular representation ([41]). <p> The algorithmic ideas behind the algorithm can be found in a paper of Collins (see <ref> [8] </ref>). We summarize the most important points. The key point is to reduce the resultant computation of multivariate polynomials over to the calculation of univariate polynomials over p 7 . The obvious reason for the reduction is to have coefficients of bounded length.
Reference: [9] <author> George E. Collins. </author> <title> Computer algebra of polynomials and rational functions. </title> <journal> American Mathematical Monthly, </journal> <volume> 80(7) </volume> <pages> 725-755, </pages> <month> Aug-Sept </month> <year> 1973. </year>
Reference-contexts: Definition 2.1.1 A gcd-domain is an integral domain in which any two elements have a greatest common divisor. 25 Thus, the concept of a gcd-domain lies between the concepts of integral domains and principal ideal domains. The concept of a gcd-domain was introduced by Collins <ref> [9] </ref>. <p> Following Collins <ref> [9] </ref>, we call the set of representatives an ample set and the corresponding function ample function. We give the complete definition of both concepts and some examples.
Reference: [10] <author> George E. Collins and Rudiger Loos. </author> <title> Specification and index of SAC-2 algorithms. </title> <type> Technical Report WSI-90-4, </type> <institution> Wilhelm-Schickard-Institut fur Informatik, </institution> <year> 1990. </year>
Reference: [11] <author> Mark Day, Robert Gruber, Barbara Liskov, and Andrew C. Myers. </author> <title> Subtypes vs. where clauses: Constraining parametric polymorphism. </title> <booktitle> In OOPSLA Conference Proceedings, volume 11 of ACM SIGPLAN, </booktitle> <pages> pages 156-168. </pages> <publisher> ACM, </publisher> <month> Nov </month> <year> 1995. </year>
Reference-contexts: Certainly, there are algorithms for polynomials 9 In the theory of programming languages the necessity for semantic constraints is well-known. For a while, subtyping seemed to be a solution. Quite right, in the meantime it is clear that subtyping itself needs semantic constraints, see <ref> [11] </ref> and [5]. 10 In C ++ the term template denotes families of classes or functions. 14 in general. But there are much more algorithms for special coefficient domains: for UFDs, for gcd-domains with computable unit group, or for algebraic extension of prime characteristic.
Reference: [12] <author> Dominique Duval and Jean-Claude Reynaud. Sketches and computation|I: </author> <title> basic definitions and static evaluation. </title> <journal> Math. Struct. in Comp. Science, </journal> <volume> 4 </volume> <pages> 239-271, </pages> <year> 1994. </year>
Reference-contexts: Assume a lift is unique, how can we prove it as unique? We need an analogue to the commutative diagramms of the category theory. If we identify the abstraction process with functors and mathematical structures with nodes can the theory of sketches (see [3], <ref> [12] </ref>, [13]) help? * Liftable properties.
Reference: [13] <author> Dominique Duval and Jean-Claude Reynaud. Sketches and computation|II: </author> <title> dynamic evaluation and applications. </title> <journal> Math. Struct. in Comp. Science, </journal> <volume> 4 </volume> <pages> 185-238, </pages> <year> 1994. </year>
Reference-contexts: Assume a lift is unique, how can we prove it as unique? We need an analogue to the commutative diagramms of the category theory. If we identify the abstraction process with functors and mathematical structures with nodes can the theory of sketches (see [3], [12], <ref> [13] </ref>) help? * Liftable properties.
Reference: [14] <author> Ulfar Erlingsson, Erich Kaltofen, and David Musser. </author> <title> Generic Gram-Schmidt orthogo-nalization by exact division. </title> <note> (to appear in the ISSAC 1996 proceedings). 83 </note>
Reference: [15] <author> Harald Ganzinger and Knut Ripken. </author> <title> Operator identification in ADA: Formal specifica-tion, complexity, and concrete specification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 15 </volume> <pages> 30-42, </pages> <year> 1980. </year>
Reference-contexts: Hence, it is inevitable to localize the algebraic resolution and to prevent the propagation of the algebraic information. The decisive idea of how our algebraic resolver can avoid or restrict any propagation comes from an algorithm of Ganzinger and Ripken for resolving overloading in ADA (see <ref> [15] </ref>) where they use the principle of localization. Although Ganzinger and Ripken do not allow parameterized structures (and do not check algebraic correctness, of course) their algorithm is the base of the algebraic resolution. In the next section we present their algorithm. <p> O (v) = O (v) " res type 1 (T (v)) " T 1j arity (v) par type 1 j (T (v:j)) forall v The existence and uniqueness of a solution of the system of equations is well-known (see 2.2. in <ref> [15] </ref>). In particular, the solution is independent of the order of the intersections.
Reference: [16] <author> Joseph Goguen and Razvan Diaconescu. </author> <title> An Oxford survey of order sorted algebra. </title> <journal> Math. Struct. in Comp. Science, </journal> <volume> 4 </volume> <pages> 363-392, </pages> <year> 1994. </year>
Reference-contexts: The theories of order sorted and many sorted algebras distinguish weak overloading where functions may have more than one rank and strong overloading where functions may have more than one value (see <ref> [16] </ref>). In C ++ only the first form is possible. Therefore, one overloaded identifier can in fact denote several functions. But, overloading relates to the set of identifiers and not to functions. Overloading is in particular not suitable to combine algorithms of the same functionality. <p> Because there is no possibility to select a subset of types, a generic or polymorphic algorithm has to be applicable for all existing, even for all future types. 6 For a study of the theory of algebraic specification resp. of sorted algebras we refer to [59] or <ref> [16] </ref>. 7 Signatures in C ++ are called prototypes.
Reference: [17] <institution> The LiDIA group. </institution> <note> LiDIA Manual, Version 1.2. </note> <institution> Fachbereich 14, Universitat des Saar-landes, </institution> <year> 1996. </year>
Reference-contexts: Translating to C ++ means to provide a library for computer algebra algorithms which is is implemented in C ++ . There are already some C ++ computer algebra algorithms. But they are not only implemented by C ++ , but also written in C ++ (see <ref> [17] </ref> as a successful example). In our library wlog, we distinguish an user and an implementation language which is rather common for computer algebra systems. But none of the other systems uses C ++ at the realization level. Concerning the imperative body of SuchThat the compiling process goes through canonically.
Reference: [18] <author> Mehdi Jazayeri. </author> <title> Component programming|a fresh look at software components. </title> <booktitle> In Proceedings of the 5th European Software Engineering Conference. </booktitle>
Reference: [19] <author> Richard D. Jenks and Robert S. Sutor. </author> <title> Axiom: The Scientific Computation System. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1992. </year>
Reference: [20] <author> Deepak Kapur and David Musser. Tecton: </author> <title> a framework for specifying and verifying generic system components. </title> <type> Technical report, </type> <institution> SUNY, Albany and RPI, Troy, </institution> <year> 1992. </year>
Reference: [21] <author> Aaron Kershenbaum, David Musser, and Alexander Stepanov. </author> <title> Higher order imperative programing. </title> <type> Technical Report 88-10, </type> <institution> Rensselaer Polytechnic Institute Computer Science Departement, </institution> <month> Apr </month> <year> 1988. </year>
Reference-contexts: This means that every algorithm has to be checked with respect to its relative computing costs. To avoid a clash between algorithm design and the following efficiency check, we suggest the method of lifting. Lifting goes back to a programming paradigm of Kershenbaum, Musser, and Stepanov (see <ref> [21] </ref>). According to this paradigm, every generic algorithm should take its starting point from an efficient non-generic algorithm. Stepwise and careful abstractions allow to use the underlying implementation to a certain extent. <p> Stepwise and careful abstractions allow to use the underlying implementation to a certain extent. The abstraction binds at the same time efficiency of the generic algorithm to that of the non-generic counterpart|the abstraction process finishes if algorithmic costs become too high. The paradigm in <ref> [21] </ref> realizes perfectly our definition of a generic algorithm which lays bare minimal conditions. Lifting is no method which results in direct instructions. Nevertheless, there are two techniques known so far: lifting by overloading and lifting by continuation. In the next chapter, we will present both techniques. <p> The method of lifting protects us from a loss of efficiency. The lifting is a formalization of a programming paradigm which means that a generic algorithms has to be developed by abstraction from a non-generic algorithm (see <ref> [21] </ref>). In this section we clarify the concept of the lift. In the following two sections we demonstrate two different ways of lifting. In the last section of this chapter we discuss open questions. We define lifting using the concepts of projection 1.1.2 and similarity 1.3.1 of the chapter before.
Reference: [22] <author> Georg Kreisel and Jean-Louis Krivine. Modelltheorie. </author> <title> Eine Einfuhrung in die mathe-matische Logik und Grundlagentheorie. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1972. </year>
Reference-contexts: If all type parameters of A are correctly instantiated the resulting algorithm is called an instance of A. 2 For a study of model theory we refer to <ref> [22] </ref>. 9 1.1.3 Structuring families of algebraic algorithms Structuring means to go through an existing library and to combine algorithms of the same functionality. As the result, we get clusters of algorithm families.
Reference: [23] <author> John D. Lipson. </author> <title> Chinese remainder and interpolation algorithms. </title> <booktitle> In SYMSAM, </booktitle> <pages> pages 372-391. </pages> <year> 1971. </year>
Reference-contexts: For every n values u i 2 R, 1 i n, there exists a solution u u u i mod M i of the system of congruences. Proof. The solution u can be described in a closed form; for the exact formulas we refer to Lipson <ref> [23] </ref> Well-known applications of the Chinese remainder algorithm are * u i 2 and m i prime 8i, * u i 2 F [X], F field, and m i linear polynomials: m i =X x i , x i 2 F . <p> A solution u, however, is unique only up to " (m i ) = i m i ; T i (m i ) is the kernel of the epimorphism D D=(m i ), see <ref> [23] </ref>, p. 373). Since an output parameter of an algorithm has to be well defined 5 , we must distinguish one solution from the set of solutions. If we pass from the computed solution to its image in the ample set of D=(m) (M ), we get an unique solution.
Reference: [24] <author> Barbara Liskov, Dorothy Curtis, Mark Day, Sanjay Ghemawat, Robert Gruber, Paul Johnson, and Andrew Myers. </author> <title> Theta reference manual. PGM, </title> <publisher> MIT, </publisher> <address> memo 88, </address> <month> Feb </month> <year> 1995. </year>
Reference: [25] <author> Rudiger Loos. </author> <title> Algebraic descriptions as programs. </title> <journal> SIGSAM Bulletin, </journal> <volume> 23 </volume> <pages> 16-24, </pages> <year> 1972. </year>
Reference: [26] <author> Rudiger Loos. </author> <title> Towards a formal implementation of computer algebra. </title> <type> Technical report, </type> <institution> Fachbereich Informatik, Universitat Kaiserslautern, </institution> <year> 1974. </year>
Reference: [27] <author> Rudiger Loos. </author> <title> The algorithm description language Aldes (report). </title> <journal> SIGSAM Bulletin, </journal> 10/1:15-39, 1976. 
Reference-contexts: Instead of writing an expression- and statement grammar of its own we decided to take over expressions and statements from the language Aldes. Aldes was developed by Loos ([25], <ref> [27] </ref>) to support the computer algebra system SAC-2 ([10]). Aldes is in use in the term rewriting system ReDuX ([7]). The expressions and statements of Aldes fulfill all our requirements of the last paragraph 5 .
Reference: [28] <author> Rudiger Loos. </author> <booktitle> Computing in algebraic extensions. </booktitle> <volume> [6], </volume> <pages> pages 173-187. </pages>
Reference: [29] <author> Rudiger Loos. </author> <title> Generalized polynomial remainder sequences. </title> <booktitle> [6], </booktitle> <pages> pages 115-137. </pages>
Reference-contexts: Their importance grew after the connection between resultants and polynomial remainder sequences became clear. For the so-called Fundamental Theorem see [8] and [4], for a survey see <ref> [29] </ref>. According to its use a resultant is defined as the determinant of the Sylvester matrix (see for example [54]) or as the norm map, i.e., the composition of the determinant map and the regular representation ([41]). <p> ; : : : ; X r ] [X 1 ; : : : ; X r1 ] p [X r ] fi p [X r ] p 6 For the source of IPCRA, see the appendix. 7 p is another notation for the prime field GF (p). 8 In <ref> [29] </ref> they are called monic Euclidean polynomial remainder sequences. 30 We have to show that the diagramm commutes and that the result in p can be lifted back to [X 1 ; : : : ; X r1 ].
Reference: [30] <author> Rudiger Loos. </author> <title> Publication Aldes. </title> <type> Technical Report WSI-91-4, </type> <institution> Fakultat fur Informatik, </institution> <year> 1991. </year>
Reference-contexts: Each feature is illustrated by a few examples. For the complete grammar, we refer to the appendix. Our description is a top-down description. Where the description coincides with the description of an Aldes feature we refer to the Aldes report <ref> [30] </ref> and [31]. For the presentation of the grammar we use the form which is accepted by a Yacc program. Comments inside of examples are written in italics.
Reference: [31] <author> Rudiger Loos and George E. Collins. </author> <title> Revised report on the algorithm description language aldes. </title> <type> Technical Report WSI-92-14, </type> <institution> Fakultat fur Informatik, </institution> <year> 1992. </year>
Reference-contexts: At the beginning of the whole project, we just wanted to translate sac-2 algorithms written in Aldes (see <ref> [31] </ref>) into C ++ using mainly the C ++ template mechanism. With the time, however, it became more and more clear what generic programming really is. We namely realized three repeating kinds of difficulties. First, we were never certain about how far we should go with the generalization. <p> Each feature is illustrated by a few examples. For the complete grammar, we refer to the appendix. Our description is a top-down description. Where the description coincides with the description of an Aldes feature we refer to the Aldes report [30] and <ref> [31] </ref>. For the presentation of the grammar we use the form which is accepted by a Yacc program. Comments inside of examples are written in italics. Tokens for sets of keywords are written in upper case, tokens for single keywords are enclosed in quote marks. 3.2.1 Program- and algorithm-declarations Syntax.
Reference: [32] <author> Alberto Mardelli. </author> <title> An efficient unification algorithm. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(2) </volume> <pages> 258-282. 84 </pages>
Reference-contexts: We have to show that we can apply the system of equations 1. and 2. above also in the term situation. But this follows immediately from the unification theory as an unification can be considered as the solution of a set of equations (see <ref> [32] </ref>). To give an example for an algebraic resolution for which a term unification is sufficient we modify our example a little bit. We replace the multiplication for integral domains by a multiplication in finite fields.
Reference: [33] <author> Stefan Missura and Andreas Weber. </author> <title> Using commutativity properties for controlling coercions. </title> <editor> In John A. Campbell, editor, </editor> <booktitle> Artifical Intelligence and Symbolic Mathematical Computation | International Conference AISMC-2, Lecture Notes in Computer Science, </booktitle> <address> Cambridge, Great Britain, Aug 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Formalizing the mathematically language is certainly much more 11 There are approaches to build up type systems for mathematical structures, see [55] or [40]. Unfortunately, they cannot handle changing forms of mathematical structures although in <ref> [33] </ref> Missura and Weber investigate different ways to construct mathematical "types." 16 easier than formalizing a natural language. Easy, however, is it in no way. The main difficulty is to avoid any prescriptions for the kind of mathematical relationships.
Reference: [34] <author> David Musser. </author> <title> Polynomial Factorization Algorithms. </title> <type> PhD thesis, </type> <institution> Madison, </institution> <year> 1971. </year>
Reference: [35] <author> David Musser. </author> <title> Rationale for adding hash tables to the C++ Standard Template Library. </title> <type> Technical Report 95-8, </type> <institution> RPI, Troy, </institution> <month> Apr </month> <year> 1995. </year>
Reference: [36] <author> David Musser and Atul Saini. </author> <title> STL Tutorial and Reference Guide. C++ Programming with the Standard Template Library. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: On the other hand, generic algorithms describe minimal conditions only to delimit the domain of all their valid instantiations. Using SuchThat declarations, no algebraic informations get lost. Therefore, the validity can be checked. 3 For the concepts of the STL library, see <ref> [36] </ref> and [44]. 41 3.1.3 Aldes Which syntactic features do we need in the algorithm bodies? Certainly, we need identifiers, assignments, and control structures, i.e., loops, selection and sequencing. 4 ) In addition, we need the invocation of subalgorithms and return statements.
Reference: [37] <author> David Musser and Alexander Stepanov. </author> <title> The ADA Generic Library: Linear List Processing Packages. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: This is a typical mathematical procedure. The serious difficulty, naturally, is to preserve correctness. The abstraction process can destroy the initial functional connection between input and output in many ways. To give a 13 Neither the generic Ada library <ref> [37] </ref> nor the C ++ Standard Template Library [50] make stronger demands. 19 hint which considerations are necessary in doing the lift and writing generic algorithms, we mention six problems. * Are operations and operators still defined at the more abstract level? Can we, for example, abstract to a field resp.
Reference: [38] <author> David Musser and Alexander Stepanov. </author> <title> Algorithm-oriented generic libraries. </title> <journal> Software-practice and experience, </journal> <volume> 27(7) </volume> <pages> 623-642, </pages> <month> Jul </month> <year> 1994. </year>
Reference: [39] <author> Michael Pohst and Hans Zassenhaus. </author> <title> Algorithmic algebraic number theory. </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference: [40] <author> Philip S. Santas. </author> <title> A type system for computer algebra. </title> <journal> JSC, </journal> <pages> pages 79-110, </pages> <year> 1995. </year>
Reference-contexts: Therefore we developed the language SuchThat, which allows to express mathematically different ways of looking. Formalizing the mathematically language is certainly much more 11 There are approaches to build up type systems for mathematical structures, see [55] or <ref> [40] </ref>. Unfortunately, they cannot handle changing forms of mathematical structures although in [33] Missura and Weber investigate different ways to construct mathematical "types." 16 easier than formalizing a natural language. Easy, however, is it in no way. <p> If there exists no solution, an error message is given.] global OPT [100], TLST. safe OPT. const ITFS=301. (1) [Assignment] if OPT <ref> [40] </ref> then -CLOUT ("algch &gt; "); UWRITE (A)-; TLST:=(); FIRST2 (RED (A);l,r); l:=oiinit (l); r:=oiinit (r); A':=oiroot (l,r); if OPT [40] then oiwrt (A'). (2) [First pass.] oiiter (1,A',(),0); if OPT [40] then -CLOUT (" after 1: "); oiwrt (A')-; if oising (A') then -A':=oifin (A'); return-; if oiempt (A') then <p> If there exists no solution, an error message is given.] global OPT [100], TLST. safe OPT. const ITFS=301. (1) [Assignment] if OPT <ref> [40] </ref> then -CLOUT ("algch &gt; "); UWRITE (A)-; TLST:=(); FIRST2 (RED (A);l,r); l:=oiinit (l); r:=oiinit (r); A':=oiroot (l,r); if OPT [40] then oiwrt (A'). (2) [First pass.] oiiter (1,A',(),0); if OPT [40] then -CLOUT (" after 1: "); oiwrt (A')-; if oising (A') then -A':=oifin (A'); return-; if oiempt (A') then -prot (1,"Error: empty type set after pass 1"); oiwrt (A')-. (3) [Second pass.] oiiter (2,A',(),0); if OPT [40] then -CLOUT <p> no solution, an error message is given.] global OPT [100], TLST. safe OPT. const ITFS=301. (1) [Assignment] if OPT <ref> [40] </ref> then -CLOUT ("algch &gt; "); UWRITE (A)-; TLST:=(); FIRST2 (RED (A);l,r); l:=oiinit (l); r:=oiinit (r); A':=oiroot (l,r); if OPT [40] then oiwrt (A'). (2) [First pass.] oiiter (1,A',(),0); if OPT [40] then -CLOUT (" after 1: "); oiwrt (A')-; if oising (A') then -A':=oifin (A'); return-; if oiempt (A') then -prot (1,"Error: empty type set after pass 1"); oiwrt (A')-. (3) [Second pass.] oiiter (2,A',(),0); if OPT [40] then -CLOUT (" after 2: "); oiwrt (A')-; if oising (A') then -FIRST2 <p> if OPT <ref> [40] </ref> then oiwrt (A'). (2) [First pass.] oiiter (1,A',(),0); if OPT [40] then -CLOUT (" after 1: "); oiwrt (A')-; if oising (A') then -A':=oifin (A'); return-; if oiempt (A') then -prot (1,"Error: empty type set after pass 1"); oiwrt (A')-. (3) [Second pass.] oiiter (2,A',(),0); if OPT [40] then -CLOUT (" after 2: "); oiwrt (A')-; if oising (A') then -FIRST2 (RED3 (A');l,r); l:=oifin (l); r:=oifin (r); A':=(FIRST (A),l,r); return-; if oiempt (A') then -prot (1,"Error: empty type set after pass 2"); oiwrt (A'); stop-. (4) [Report unresolved?] prot (1,"No unique resolution possible "); oiwrt (A'); oival (a')
Reference: [41] <author> Gunter Scheja and Uwe Storch. </author> <title> Lehrbuch der Algebra. Teil 1. </title> <publisher> B.G. Teubner, </publisher> <year> 1980. </year>
Reference: [42] <author> Johannes Graf von Schmettow and Max Juntgen. </author> <title> KANT-2|A Programmer's Guide. </title> <institution> Math. Institut der Heinrich-Heine Universitat, Dusseldorf, </institution> <year> 1993. </year> <note> Available via anonymous ftp at ftp.math.uni-sb.de. </note>
Reference-contexts: For ALEV&gt;1, term unification is replaced by algebraic unifications on different levels.] global ALEV, OPT [100]. safe ALEV, OPT. (1) [Equality sufficient?] if OPT <ref> [42] </ref> then -CLOUT ("sgxn &gt; S,U,V: "); UWRIT1 (S); twrt (U); twrt (V); WRITE-; U~:=stlget (U); V~:=stlget (V); if ALEV=0 then -W:=USINT (U,V); S':=S; goto 4-. (2) [Term unification.] if ALEV&gt;=1 then -S':=S; U':=U; W:=(); while U'#() do -ADV (U';u,U'); V':=V; while V'#() do -ADV (V';v,V'); tunify (FIRST (u),FIRST (v);S'',u'); S*:=tsun <p> S':=S; goto 4-. (2) [Term unification.] if ALEV&gt;=1 then -S':=S; U':=U; W:=(); while U'#() do -ADV (U';u,U'); V':=V; while V'#() do -ADV (V';v,V'); tunify (FIRST (u),FIRST (v);S'',u'); S*:=tsun (S',S''); if S*#-1 then -S':=S*; u':=(u',(),()); W:=tlsub (S',W); W:=USUN ((u'),W)----; goto 4. (3) CLOUT ("sgxn not yet extended."). (4) [Report.] if OPT <ref> [42] </ref> then -CLOUT ("sgxn &lt; W,S': "); twrt (W); UWRITE (S')- || 82
Reference: [43] <author> Martin Schonert, Hans Ulrich Besche, Thomas Breuer, Frank Celler, Jurgen Mnich, Gotz Pfeiffer, Udo Polis, and Alice Niemeyer. </author> <title> GAP. Groups, Algorithms, and Programming. </title> <institution> Lehrstuhl D fur Mathematik, RWTH Aachen, </institution> <address> Aachen, Germany, </address> <month> Jul </month> <year> 1994. </year> <note> Available via anonymous ftp at samson.math.rwth-aachen.de. </note>
Reference: [44] <author> Sibylle Schupp. </author> <title> Fortgeschrittene Konzepte der Standard Template Library (STL). </title> <type> Technical Report WSI-96-18, </type> <institution> Wilhelm-Schickard-Institut fur Informatik, </institution> <year> 1996. </year>
Reference-contexts: On the other hand, generic algorithms describe minimal conditions only to delimit the domain of all their valid instantiations. Using SuchThat declarations, no algebraic informations get lost. Therefore, the validity can be checked. 3 For the concepts of the STL library, see [36] and <ref> [44] </ref>. 41 3.1.3 Aldes Which syntactic features do we need in the algorithm bodies? Certainly, we need identifiers, assignments, and control structures, i.e., loops, selection and sequencing. 4 ) In addition, we need the invocation of subalgorithms and return statements.
Reference: [45] <author> Sibylle Schupp. </author> <title> How to lift a library. </title> <type> Technical Report WSI-7-96, </type> <institution> Wilhelm-Schickard-Institut fur Informatik, </institution> <year> 1996. </year>
Reference-contexts: hope our procedure can serve as a guidance for further experiences. 2.1 Lifting by overloading Our first example is the lift of the MIDCRA algorithm from the SAC-2 library. 2 1 (or raised which is a question of view) 2 A preliminary version of this section can be found in <ref> [45] </ref>. 23 First, we recapitulate the Chinese remainder theorem in its general form and the algo-rithm MIDCRA. Then we introduce three special concepts which result from the abstraction a lift carries out: the concepts of a gcd-domain, of a Bezout-domain, and of an ample set.
Reference: [46] <author> Sibylle Schupp and Rudiger Loos. </author> <title> Considerations for a generic SAC library. </title> <type> Technical Report WSI-25-95, </type> <institution> Wilhelm-Schickard-Institut fur Informatik, </institution> <year> 1995. </year>
Reference-contexts: We speak of an algebraic resolution and not of an algebraic check only, because we do 1 Preliminary considerations of an algebraic check can be found in <ref> [46] </ref>. 52 not only check actual parameters against formal ones. The typical situations for generic algorithms are overloaded function identifiers with parameterized arguments where the relation between actual and formal parameters is the relation of an implication.
Reference: [47] <author> Gabor Simon. </author> <title> A retargetable Aldes Compiler. </title> <type> PhD thesis, </type> <institution> Universitat Tubingen, </institution> <year> 1991. </year>
Reference-contexts: Concerning the imperative body of SuchThat the compiling process goes through canonically. As the compiler construction is well-known today we refer to standard text books [1], [53], [58]. For the special case of the SuchThat imperative body, we refer to <ref> [47] </ref> and [49]. 4.1 Aspects of the algebraic resolution We focus on the pecularity of SuchThat, the introduction of algebraic declarations and their interaction with the body of the algorithm by their check which we call the algebraic resolution. 1 Some of the most important algorithms of the algebraic resolution can <p> pass. v is an oi-tree node. u is the predecessor node of v and u=() if v is the root. 1&lt;=j<=arity (u) such that u.j=v. v is modified by O- and T-sets modified according to the Ganzinger/Ripken-algorithm.] global OPT [100], TLST. safe OPT. (1) [Entry visit of A.] if OPT <ref> [47] </ref> then -CLOUT ("oiiter, entry visit I, pass= "; UWRITE (p); CLOUT ("successor "); UWRIT1 (j); oiwrt (v)-; if p=1 /" u#() then oitput (v,TLST); oiit1 (v,u,j). 80 (2) [Actions performed always.] if OPT [47] then -CLOUT (" oiiter, entry visit II, pass= "); UWRITE (p); oiwrt (v);-; oiit2 (v). (3) <p> to the Ganzinger/Ripken-algorithm.] global OPT [100], TLST. safe OPT. (1) [Entry visit of A.] if OPT <ref> [47] </ref> then -CLOUT ("oiiter, entry visit I, pass= "; UWRITE (p); CLOUT ("successor "); UWRIT1 (j); oiwrt (v)-; if p=1 /" u#() then oitput (v,TLST); oiit1 (v,u,j). 80 (2) [Actions performed always.] if OPT [47] then -CLOUT (" oiiter, entry visit II, pass= "); UWRITE (p); oiwrt (v);-; oiit2 (v). (3) [Visit successors.] L:=RED3 (v); j':=0; while L#() do -j':=j'+1; v':=FIRST (L); u':=v; oiiter (p,v',u',j'); L:=RED (L)-; if OPT [47] then -CLOUT (" oiiter, successors, pass= "); UWRITE (p); oiwrt (v)-; if p=2 then return. <p> p=1 /" u#() then oitput (v,TLST); oiit1 (v,u,j). 80 (2) [Actions performed always.] if OPT <ref> [47] </ref> then -CLOUT (" oiiter, entry visit II, pass= "); UWRITE (p); oiwrt (v);-; oiit2 (v). (3) [Visit successors.] L:=RED3 (v); j':=0; while L#() do -j':=j'+1; v':=FIRST (L); u':=v; oiiter (p,v',u',j'); L:=RED (L)-; if OPT [47] then -CLOUT (" oiiter, successors, pass= "); UWRITE (p); oiwrt (v)-; if p=2 then return. (4) [Exit visit.] oiit2 (v); if OPT [47] then -CLOUT (" oiiter, result exit visit II, pass= "); UWRITE (p); oiwrt (v)-; oiit3 (v,u,j); if OPT [47] then -CLOUT (" oiiter, result III+IV, pass="); UWRITE <p> pass= "); UWRITE (p); oiwrt (v);-; oiit2 (v). (3) [Visit successors.] L:=RED3 (v); j':=0; while L#() do -j':=j'+1; v':=FIRST (L); u':=v; oiiter (p,v',u',j'); L:=RED (L)-; if OPT <ref> [47] </ref> then -CLOUT (" oiiter, successors, pass= "); UWRITE (p); oiwrt (v)-; if p=2 then return. (4) [Exit visit.] oiit2 (v); if OPT [47] then -CLOUT (" oiiter, result exit visit II, pass= "); UWRITE (p); oiwrt (v)-; oiit3 (v,u,j); if OPT [47] then -CLOUT (" oiiter, result III+IV, pass="); UWRITE (p); oiwrt (v)- || oiit1 (v,u,j) [Operator identification iteration step 1. v is an oi-tree. u is its predecessor. 1&lt;=j<=arity (u) such that <p> (L); u':=v; oiiter (p,v',u',j'); L:=RED (L)-; if OPT <ref> [47] </ref> then -CLOUT (" oiiter, successors, pass= "); UWRITE (p); oiwrt (v)-; if p=2 then return. (4) [Exit visit.] oiit2 (v); if OPT [47] then -CLOUT (" oiiter, result exit visit II, pass= "); UWRITE (p); oiwrt (v)-; oiit3 (v,u,j); if OPT [47] then -CLOUT (" oiiter, result III+IV, pass="); UWRITE (p); oiwrt (v)- || oiit1 (v,u,j) [Operator identification iteration step 1. v is an oi-tree. u is its predecessor. 1&lt;=j<=arity (u) such that v=u.j. v is modified by O- and T-sets according to the Ganzinger/Ripken rule I.] global TLST. const constant=-4, variable=-3,
Reference: [48] <author> Gabor Simon. </author> <title> Interoperability between computer algebra systems. </title> <type> Technical Report WSI-96-8, </type> <institution> Wilhelm-Schickard-Institut fur Informatik, </institution> <year> 1996. </year>
Reference: [49] <author> Michael Sperber. Mtrks: </author> <title> a generator for preprocessors. </title> <type> Diploma thesis, </type> <institution> Universitat Tubingen, </institution> <year> 1994. </year> <month> 85 </month>
Reference-contexts: Concerning the imperative body of SuchThat the compiling process goes through canonically. As the compiler construction is well-known today we refer to standard text books [1], [53], [58]. For the special case of the SuchThat imperative body, we refer to [47] and <ref> [49] </ref>. 4.1 Aspects of the algebraic resolution We focus on the pecularity of SuchThat, the introduction of algebraic declarations and their interaction with the body of the algorithm by their check which we call the algebraic resolution. 1 Some of the most important algorithms of the algebraic resolution can be found
Reference: [50] <author> Alexander A. Stepanov and Meng Lee. </author> <title> The Standard Template Library. </title> <note> Available by anonymous ftp from ftp.rpi.edu/pub/stl.doc.ps.Z, </note> <month> Sep </month> <year> 1994. </year>
Reference-contexts: Thus, we have to clarify where the collision has its roots and how it can be resolved. The risk of incompatibility partly depends on our concept of genericity. Musser and Stepanov who developed two widely accepted generic libraries ([37], <ref> [50] </ref>), suggested to design libraries from an algorithm-oriented view instead from a data-oriented one ([38]). But an algorithmen-oriented view should already induce a concept of genericity. We therefore give an algorithmen-oriented definition of genericity. <p> This is a typical mathematical procedure. The serious difficulty, naturally, is to preserve correctness. The abstraction process can destroy the initial functional connection between input and output in many ways. To give a 13 Neither the generic Ada library [37] nor the C ++ Standard Template Library <ref> [50] </ref> make stronger demands. 19 hint which considerations are necessary in doing the lift and writing generic algorithms, we mention six problems. * Are operations and operators still defined at the more abstract level? Can we, for example, abstract to a field resp. to a ring and the resulting formal parameters
Reference: [51] <author> Bjarne Stroustrup. </author> <title> The C++ programming language. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference: [52] <author> Peter Thiemann. </author> <title> Grundlagen der funktionalen Programmierung. </title> <publisher> Teubner, Stuttgart, </publisher> <year> 1994. </year>
Reference-contexts: There are two main classes of polymorphism known. First, ad-hoc polymor-phism which coincides with the concept of overloading. Secondly, parametric polymorphism where an algorithm depends on type parameters (see for example <ref> [52] </ref>). A classical example is the identity function: id: ff ! ff; with ff any type parameter. Parametric polymorphism means that one and only one code has to be executed, independent of the type of an actual parameter. Parametric polymorphism provides a considerable saving of code.
Reference: [53] <author> William Waite and Gerhard Goos. </author> <title> Compiler Construction. </title> <publisher> Springer-Verlag, </publisher> <address> New York, Berlin, Heidelberg,Tokyo, </address> <year> 1984. </year>
Reference-contexts: But none of the other systems uses C ++ at the realization level. Concerning the imperative body of SuchThat the compiling process goes through canonically. As the compiler construction is well-known today we refer to standard text books [1], <ref> [53] </ref>, [58].
Reference: [54] <author> Bartel L. van der Warden. </author> <title> Algebra I. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, 8th edition, </address> <year> 1971. </year>
Reference-contexts: Their importance grew after the connection between resultants and polynomial remainder sequences became clear. For the so-called Fundamental Theorem see [8] and [4], for a survey see [29]. According to its use a resultant is defined as the determinant of the Sylvester matrix (see for example <ref> [54] </ref>) or as the norm map, i.e., the composition of the determinant map and the regular representation ([41]). For the essential theorems on resultants we refer to any of the cited papers of this paragraph.
Reference: [55] <author> Andreas Weber. </author> <title> Type Systems for Computer Algebra. </title> <type> PhD thesis, </type> <institution> Fakultat fur Infor-matik, Universitat Tubingen, </institution> <month> Jul </month> <year> 1993. </year>
Reference-contexts: Therefore we developed the language SuchThat, which allows to express mathematically different ways of looking. Formalizing the mathematically language is certainly much more 11 There are approaches to build up type systems for mathematical structures, see <ref> [55] </ref> or [40]. Unfortunately, they cannot handle changing forms of mathematical structures although in [33] Missura and Weber investigate different ways to construct mathematical "types." 16 easier than formalizing a natural language. Easy, however, is it in no way.
Reference: [56] <author> Hermann Weyl. </author> <title> Topology and abstract algebra as two roads of mathematical comprehension (part I). </title> <journal> American Monthly Society, </journal> <pages> pages 453-460, </pages> <month> May </month> <year> 1995. </year>
Reference: [57] <author> Hermann Weyl. </author> <title> Topology and abstract algebra as two roads of mathematical comprehension (part II). </title> <journal> American Monthly Society, </journal> <pages> pages 646-651, </pages> <month> Aug,Sept </month> <year> 1995. </year>
Reference-contexts: But they can construct the key only because the successful breakthrough enables them to study the lock front and back, from the outside and from the inside. Before we can generalize, formalize, and axiomatize there must be mathematical substance". (Hermann Weyl, 1931.)([56], <ref> [57] </ref>) 66 Appendix A -2 sources A.1 IPCRA and MIDCRA A*:=IPCRA (M,m,m',r,A,a) [Integral polynomial Chinese remainder algorithm. M is A positive integer. m is A positive BETA-integer. Gcd (M,m)=1. m' is the inverse of h sub m of M.
Reference: [58] <author> Reinhard Wilhelm and Dieter Maurer. </author> <title> Ubersetzerbau. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidel-berg, </address> <year> 1992. </year>
Reference-contexts: But none of the other systems uses C ++ at the realization level. Concerning the imperative body of SuchThat the compiling process goes through canonically. As the compiler construction is well-known today we refer to standard text books [1], [53], <ref> [58] </ref>.

References-found: 58

