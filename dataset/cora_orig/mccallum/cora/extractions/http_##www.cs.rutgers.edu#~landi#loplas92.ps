URL: http://www.cs.rutgers.edu/~landi/loplas92.ps
Refering-URL: http://www.cs.rutgers.edu/~landi/pubs.html
Root-URL: http://www.cs.rutgers.edu
Email: wlandi@scr.siemens.com  
Title: Undecidability of Static Analysis  
Author: William Landi 
Keyword: Categories and Subject Descriptors: D.3.1 [Programming Languages]: Processors; F.1.1 [Computation by Abstract Devices]: Models of Computation bounded-action devices; F.4.1 [Math Logic and Formal Languages]: Mathematical Logic computability theory General Terms: Languages, Theory Additional Key Words and Phrases: Alias analysis, data flow analysis, abstract interpretation, halting problem  
Date: 4, December 1992, Pages 323-337.  
Note: From acm Letters on Programming Languages and Systems, Vol. 1, No.  Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a free and/or specific permission. c fl1992 ACM 1057-4514/92/1200-0323$01.50  
Address: 755 College Rd East Princeton, NJ 08540  
Affiliation: Siemens Corporate Research Inc  
Abstract: Static Analysis of programs is indispensable to any software tool, environment, or system that requires compile time information about the semantics of programs. With the emergence of languages like C and LISP, Static Analysis of programs with dynamic storage and recursive data structures has become a field of active research. Such analysis is difficult, and the Static Analysis community has recognized the need for simplifying assumptions and approximate solutions. However, even under the common simplifying assumptions, such analyses are harder than previously recognized. Two fundamental Static Analysis problems are May Alias and Must Alias. The former is not recursive (i.e., is undecidable) and the latter is not recursively enumerable (i.e., is uncomputable), even when all paths are executable in the program being analyzed for languages with if-statements, loops, dynamic storage, and recursive data structures.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aho, A. V., Hopcroft, J. E., and Ullman, J. D. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1976. </year>
Reference-contexts: This is a different from the result of Kam and Ullman [8] that the MOP solution is undecidable for monotone frameworks. 2 Reduction of the Halting Problem to an Alias Problem A Deterministic Turing Machine (DTM) <ref> [1] </ref> is a tuple (Q,T,I,ffi,fi,q 0 ,q f ) where: * Q = fq 1 , q 2 , ..., q n Q g is the set of states * T = f 1 ; 2 ; :::; n T g is the set of tape symbols * I T is
Reference: [2] <author> Aho, A. V., Sethi, R., and Ullman, J. D. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: It is impossible for both or neither then branches to be executed. Static Analysis is not recursive since determining which paths are executable is not recursive. To overcome this problem, Static Analysis is performed assuming that all paths through the program are executable <ref> [2] </ref>. This assumption is not always valid, but it is safe [2]. 1 Also, it simplifies the problem and allows Static Analysis of FORTRAN procedures to be done fairly efficiently. Some approaches (for example [16]) categorize some paths as not executable. <p> Static Analysis is not recursive since determining which paths are executable is not recursive. To overcome this problem, Static Analysis is performed assuming that all paths through the program are executable <ref> [2] </ref>. This assumption is not always valid, but it is safe [2]. 1 Also, it simplifies the problem and allows Static Analysis of FORTRAN procedures to be done fairly efficiently. Some approaches (for example [16]) categorize some paths as not executable. However, these techniques have limited applicability, and often must assume that paths are executable. <p> The general feeling is that it is probably N P complete [11, 13, 12]; this is incorrect. Recently, the problem of finding aliases was shown to be P-space hard [10]. Unfortunately, this is still an underestimate. 1 The term conservative is used in <ref> [2] </ref> instead of safe. 2 An alias occurs at some point during execution of a program when two or more names exist for the same storage location. For example, the C statement "p = &v" creates an alias between flp and v.
Reference: [3] <author> Cousot, P., and Cousot, R. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Conference Record of the Fourth Annual ACM Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1977), </year> <pages> pp. 238-252. </pages>
Reference-contexts: Other classical problems include reaching definitions, available expressions, and very busy expressions [4]. There are two main frameworks for doing Static Analysis: Data Flow Analysis [4] and Abstract Interpretation <ref> [3] </ref>. The framework is not relevant to this paper, as we show that two fundamental Static Analysis problems are harder than previously acknowledged, regardless of the framework used. We view the solution to a Static Analysis problem as the set of "facts" that hold for a given program.
Reference: [4] <author> Hecht, M. S. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> Elsevier North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: 1 Introduction Static Analysis is the processes of extracting semantic information about a program at compile time. One classical example is the live variables <ref> [4] </ref> problem; a variable x is live at a statement s iff on some execution x is used (accessed) after s is executed without being redefined. Other classical problems include reaching definitions, available expressions, and very busy expressions [4]. <p> One classical example is the live variables <ref> [4] </ref> problem; a variable x is live at a statement s iff on some execution x is used (accessed) after s is executed without being redefined. Other classical problems include reaching definitions, available expressions, and very busy expressions [4]. There are two main frameworks for doing Static Analysis: Data Flow Analysis [4] and Abstract Interpretation [3]. The framework is not relevant to this paper, as we show that two fundamental Static Analysis problems are harder than previously acknowledged, regardless of the framework used. <p> Other classical problems include reaching definitions, available expressions, and very busy expressions <ref> [4] </ref>. There are two main frameworks for doing Static Analysis: Data Flow Analysis [4] and Abstract Interpretation [3]. The framework is not relevant to this paper, as we show that two fundamental Static Analysis problems are harder than previously acknowledged, regardless of the framework used.
Reference: [5] <author> Hopcroft, J. E., and Ullman, J. D. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1979. </year>
Reference: [6] <author> Horwitz, S., Pfeiffer, P., and Reps, T. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction (June 1989), </booktitle> <pages> pp. 28-40. </pages>
Reference: [7] <author> Kam, J. B., and Ullman, J. D. </author> <title> Global flow analysis and iterative algorithms. </title> <journal> Journal of the ACM 23, </journal> <volume> 1 (1976), </volume> <pages> 158-171. </pages>
Reference-contexts: Static Analysis originally concentrated on FORTRAN, and was predominately confined to a single procedure (intraprocedural analysis) <ref> [7, 9, 15] </ref>. However, even this simple form of Static Analysis is not recursive. The difficulty lies in conditionals. There are, in general, many paths through a procedure, but not all paths correspond to an execution.
Reference: [8] <author> Kam, J. B., and Ullman, J. D. </author> <title> Monotone data flow analysis frameworks. </title> <journal> Acta Informatica 7 (1977), </journal> <pages> 305-317. </pages>
Reference-contexts: This is a different from the result of Kam and Ullman <ref> [8] </ref> that the MOP solution is undecidable for monotone frameworks. 2 Reduction of the Halting Problem to an Alias Problem A Deterministic Turing Machine (DTM) [1] is a tuple (Q,T,I,ffi,fi,q 0 ,q f ) where: * Q = fq 1 , q 2 , ..., q n Q g is the
Reference: [9] <author> Kildall, G. </author> <title> A unified approach to global program optimization. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1973), </year> <pages> pp. 194-206. </pages>
Reference-contexts: Static Analysis originally concentrated on FORTRAN, and was predominately confined to a single procedure (intraprocedural analysis) <ref> [7, 9, 15] </ref>. However, even this simple form of Static Analysis is not recursive. The difficulty lies in conditionals. There are, in general, many paths through a procedure, but not all paths correspond to an execution.
Reference: [10] <author> Landi, W. </author> <title> Interprocedural Aliasing in the Presence of Pointers. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <month> Jan. </month> <year> 1992. </year> <month> LCSR-TR-174. </month>
Reference-contexts: It is widely accepted that Static Analysis under these conditions is hard. The general feeling is that it is probably N P complete [11, 13, 12]; this is incorrect. Recently, the problem of finding aliases was shown to be P-space hard <ref> [10] </ref>. Unfortunately, this is still an underestimate. 1 The term conservative is used in [2] instead of safe. 2 An alias occurs at some point during execution of a program when two or more names exist for the same storage location.
Reference: [11] <author> Landi, W., and Ryder, B. G. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1991), </year> <pages> pp. 93-103. </pages>
Reference-contexts: It is widely accepted that Static Analysis under these conditions is hard. The general feeling is that it is probably N P complete <ref> [11, 13, 12] </ref>; this is incorrect. Recently, the problem of finding aliases was shown to be P-space hard [10].
Reference: [12] <author> Larus, J. R. </author> <title> Restructuring Symbolic Programs for Concurrent Execution on Multiprocessors. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: It is widely accepted that Static Analysis under these conditions is hard. The general feeling is that it is probably N P complete <ref> [11, 13, 12] </ref>; this is incorrect. Recently, the problem of finding aliases was shown to be P-space hard [10].
Reference: [13] <author> Larus, J. R., and Hilfinger, P. N. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of the SIG-PLAN '88 Conference on Programming Language Design and Implementation (July 1988), </booktitle> <pages> pp. </pages> <month> 21-34. </month> <journal> SIGPLAN NOTICES, </journal> <volume> Vol. 23, No. </volume> <pages> 7. </pages>
Reference-contexts: It is widely accepted that Static Analysis under these conditions is hard. The general feeling is that it is probably N P complete <ref> [11, 13, 12] </ref>; this is incorrect. Recently, the problem of finding aliases was shown to be P-space hard [10].
Reference: [14] <author> Myers, E. M. </author> <title> A precise interprocedural data flow algorithm. </title> <booktitle> In Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1981), </year> <pages> pp. 219-230. </pages>
Reference-contexts: Some approaches (for example [16]) categorize some paths as not executable. However, these techniques have limited applicability, and often must assume that paths are executable. With a basis of a firm understanding of intraprocedural Static Analysis of FORTRAN, Static Analysis of entire programs (interprocedural analysis) was investigated. Myers <ref> [14] </ref> came up with the negative result that many interprocedural Static Analysis problems are N P complete. Practically, this means that interprocedural Static Analysis must make further approximations over intraprocedural analysis or take an exponential amount of time.
Reference: [15] <author> Ullman, J. D. </author> <title> Fast algorithms for the elimination of common subexpressions. </title> <journal> Acta Informatica 2, </journal> <volume> 3 (1973), </volume> <pages> 191-213. </pages>
Reference-contexts: Static Analysis originally concentrated on FORTRAN, and was predominately confined to a single procedure (intraprocedural analysis) <ref> [7, 9, 15] </ref>. However, even this simple form of Static Analysis is not recursive. The difficulty lies in conditionals. There are, in general, many paths through a procedure, but not all paths correspond to an execution.
Reference: [16] <author> Wegman, M., and Zadeck, F. K. </author> <title> Constant propagation with conditional branches. </title> <journal> ACM Transactions on Programming Languages and Systems 13, </journal> <month> 2 (Apr. </month> <year> 1991), </year> <pages> 181-210. </pages>
Reference-contexts: This assumption is not always valid, but it is safe [2]. 1 Also, it simplifies the problem and allows Static Analysis of FORTRAN procedures to be done fairly efficiently. Some approaches (for example <ref> [16] </ref>) categorize some paths as not executable. However, these techniques have limited applicability, and often must assume that paths are executable. With a basis of a firm understanding of intraprocedural Static Analysis of FORTRAN, Static Analysis of entire programs (interprocedural analysis) was investigated.
References-found: 16

