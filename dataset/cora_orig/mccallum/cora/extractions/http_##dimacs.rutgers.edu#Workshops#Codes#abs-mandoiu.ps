URL: http://dimacs.rutgers.edu/Workshops/Codes/abs-mandoiu.ps
Refering-URL: http://dimacs.rutgers.edu/Workshops/Codes/program.html
Root-URL: http://www.cs.rutgers.edu
Title: Optimum extensions of prefix codes  
Author: Ion I. Mandoiu 
Keyword: Algorithms; Prefix codes; Dynamic programming; Quadrangle inequality  
Address: Atlanta, GA 30332-0280  
Affiliation: College of Computing, Georgia Institute of Technology,  
Abstract: An algorithm is given for finding the minimum weight extension of a prefix code. The algorithm runs in O(n 3 ), where n is the number of codewords to be added, and works for arbitrary alphabets. For binary alphabets the running time is reduced to O(n 2 ), by using the fact that a certain cost matrix satisfies the quadrangle inequality. The quadrangle inequality is shown not to hold for alphabets of size larger than two. Similar algorithms are presented for finding alphabetic and length-limited code extensions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aggarwal, M.M. Klawe, S. Moran, P. Shor, and R. Wilber, </author> <title> Geometric applications of a matrix-searching algorithm, </title> <booktitle> Algorithmica 2 (1987), </booktitle> <pages> pp. 195-208. </pages>
Reference-contexts: However, the speed-up is achieved not by using Knuth's technique, but the matrix searching algorithm of Aggar-wal et al. <ref> [1] </ref>. We show that this speed-up idea cannot be extended to alphabets of size larger than two, in particular the quadrangle inequality is shown not to hold for non-binary alphabets. <p> Clearly, C 1 (j) = T <ref> [1; j] </ref> + r 1 t=1 Moreover, for every 2 i k and 1 j n, C i (j) = min C i1 (j); min M i [b; j] ; (2) where M i [b; j] represents the minimum cost of an m-ary forest with root depths r 1 ; : <p> Computing C i (1); : : : ; C i (n) for a fixed i 2 f2; : : : ; kg amounts by (2) to computing the minimum element in each column of M i . Aggarwal et al. <ref> [1] </ref> describe an algorithm that, for an nfin matrix M satisfying a certain property called total monotony, computes all columnwise minimas in O (n) time. As we shall prove, matrices M i are totally monotone when m = 2. <p> the cost of a minimum alphabetic m-ary forest with root depths r 1 ; : : : ; r i , weights w 1 ; : : : ; w j , and leaves of depth at most D, it follows that C 1 (j) = T (Dr 1 ) <ref> [1; j] </ref> + r 1 t=1 Moreover, for every 2 i k and 1 j n, C i (j) = min C i1 (j); min N i [b; j] ; (5) where N i [b; j] = C (D) P j Let L = max i (D r i ). <p> Exactly as in Section 3, this implies that T (d) satisfies the quadrangle inequality and matrices N i , 2 i k, are totally monotone. So, by running the matrix searching algorithm of 8 <ref> [1] </ref> on each N i we obtain a minimum depth-limited alphabetic binary forest in O (n 2 L + nk) time. Acknowledgements I wish to thank Ioan Tomescu and Vijay Vazirani for encouraging my work on the problem and Lawrence Larmore for stimulating discussions.
Reference: [2] <author> C. Calude and I. Tomescu, </author> <title> Optimum extendible prefix codes, </title> <type> Tech. Rep. </type> <note> No. 114 (1995), </note> <institution> Dept. of Computer Science, The University of Auckland, </institution> <address> New Zealand. </address>
Reference-contexts: 1 Introduction Huffman's classical algorithm [6] constructs a prefix code with minimum weighted length over a given alphabet. A related problem, introduced in <ref> [2] </ref>, is that of optimally extending a prefix code: given a prefix code, C, and n positive weights, w 1 ; : : : ; w n , find codewords c 1 ; : : : ; c n such that C [ fc 1 ; : : : ; c <p> Academiei 14, R-70109 Bucharest, Romania. Preprint submitted to Elsevier Science 5 October 1997 a length-minimal word that extends C; clearly, each codeword c i must have an extension root as prefix. Calude and Tomescu <ref> [2] </ref> observe that Huffman's algorithm can be used to find an optimum extension when all extension roots of C have the same length, in particular when C has only one extension root. In this paper we present an algorithm that finds an optimum extension for an arbitrary extendible prefix code. <p> Hence, M 2 is not totally monotone. i ii i i S S S S S S S S S S 1 1 1 1 1 1 1 1 M 2 <ref> [2; 5] </ref> = 5 M 2 [2; 6] = 8 Fig. 1. Matrix M 2 is not totally monotone. Example 4 also shows that matrix T need not satisfy the quadrangle inequality when m 3. Indeed, for the given weights we have T [2; 5] = 6, T [3; 6] = <p> Hence, M 2 is not totally monotone. i ii i i S S S S S S S S S S 1 1 1 1 1 1 1 1 M 2 [2; 5] = 5 M 2 <ref> [2; 6] </ref> = 8 Fig. 1. Matrix M 2 is not totally monotone. Example 4 also shows that matrix T need not satisfy the quadrangle inequality when m 3. <p> 1 1 1 1 1 M 2 <ref> [2; 5] </ref> = 5 M 2 [2; 6] = 8 Fig. 1. Matrix M 2 is not totally monotone. Example 4 also shows that matrix T need not satisfy the quadrangle inequality when m 3. Indeed, for the given weights we have T [2; 5] = 6, T [3; 6] = 6, T [3; 5] = 3, and T [2; 6] = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 <p> Matrix M 2 is not totally monotone. Example 4 also shows that matrix T need not satisfy the quadrangle inequality when m 3. Indeed, for the given weights we have T [2; 5] = 6, T [3; 6] = 6, T [3; 5] = 3, and T <ref> [2; 6] </ref> = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 : : : w n there exists a minimum binary tree in which the weights are <p> Example 4 also shows that matrix T need not satisfy the quadrangle inequality when m 3. Indeed, for the given weights we have T <ref> [2; 5] </ref> = 6, T [3; 6] = 6, T [3; 5] = 3, and T [2; 6] = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 : : : w n there exists a minimum binary tree in which the weights are assigned to leaves in left-to-right order, <p> Indeed, for the given weights we have T [2; 5] = 6, T [3; 6] = 6, T [3; 5] = 3, and T <ref> [2; 6] </ref> = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 : : : w n there exists a minimum binary tree in which the weights are assigned to leaves in left-to-right order, i.e., a minimum binary tree that is alphabetic.
Reference: [3] <author> M.R. Garey, </author> <title> Optimal binary search trees with restricted maximal depth, </title> <journal> SIAM J. Comput. </journal> <volume> 3 (1974), </volume> <pages> pp. 101-110. </pages>
Reference-contexts: The fact that matrices M i are totally monotone when m = 2 will follow from the fact that they satisfy the quadrangle inequality. We first prove that matrix T satisfies the quadrangle inequality. The next result has been first noticed by 4 Garey <ref> [3, Cor. 1] </ref> for non-alphabetic binary trees, and extended by Wessner [12] to alphabetic binary trees with weights on all nodes (not only on leaves) and limited depth. <p> Matrix M 2 is not totally monotone. Example 4 also shows that matrix T need not satisfy the quadrangle inequality when m 3. Indeed, for the given weights we have T [2; 5] = 6, T <ref> [3; 6] </ref> = 6, T [3; 5] = 3, and T [2; 6] = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 : : : w n <p> Matrix M 2 is not totally monotone. Example 4 also shows that matrix T need not satisfy the quadrangle inequality when m 3. Indeed, for the given weights we have T [2; 5] = 6, T [3; 6] = 6, T <ref> [3; 5] </ref> = 3, and T [2; 6] = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 : : : w n there exists a minimum binary <p> Indeed, for the given weights we have T [2; 5] = 6, T <ref> [3; 6] </ref> = 6, T [3; 5] = 3, and T [2; 6] = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 : : : w n there exists a minimum binary tree in which the weights are assigned to leaves in left-to-right order, i.e., a minimum binary <p> Indeed, for the given weights we have T [2; 5] = 6, T [3; 6] = 6, T <ref> [3; 5] </ref> = 3, and T [2; 6] = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 : : : w n there exists a minimum binary tree in which the weights are assigned to leaves in left-to-right order, i.e., a minimum binary tree that is alphabetic.
Reference: [4] <author> E.N. Gilbert and E.F. Moore, </author> <title> Variable-length binary encodings, </title> <journal> Bell Systems Tech. J. </journal> <volume> 38 (1959), </volume> <pages> pp. 933-968. </pages>
Reference-contexts: In this paper we present an algorithm that finds an optimum extension for an arbitrary extendible prefix code. Starting with Gilbert and Moore <ref> [4] </ref>, dynamic programming has been successfully applied to several prefix coding problems (see for example [3,7,8,12]).
Reference: [5] <author> L. Gotlieb and D. Wood, </author> <title> The construction of optimal multiway search trees and the monotonicity principle, </title> <journal> Intern. J. Computer Math. sec. A, </journal> <volume> 9 (1981), </volume> <pages> pp. 17-24. </pages>
Reference-contexts: We show that this speed-up idea cannot be extended to alphabets of size larger than two, in particular the quadrangle inequality is shown not to hold for non-binary alphabets. A similar discrepancy between the binary and non-binary case has been reported in <ref> [5] </ref> with respect to the construction of minimum multiway search trees. In analogy with restrictions studied for prefix coding, we consider two other versions of the code-extension problem. <p> First, we compute T [j 1 ; j 2 ] for every 1 j 1 j 2 n using Itai's algorithm [7]. This takes O (n 3 log m) time; Itai claims that this can be improved to O (n 2 log m), but, as remarked in <ref> [5] </ref>, his claim is correct only for m = 2. After computing all entries of T and the cumulative weights P j t=b+1 w t , it takes constant time to evaluate each M i [b; j]. <p> Hence, M 2 is not totally monotone. i ii i i S S S S S S S S S S 1 1 1 1 1 1 1 1 M 2 <ref> [2; 5] </ref> = 5 M 2 [2; 6] = 8 Fig. 1. Matrix M 2 is not totally monotone. Example 4 also shows that matrix T need not satisfy the quadrangle inequality when m 3. Indeed, for the given weights we have T [2; 5] = 6, T [3; 6] = <p> 1 1 1 1 1 M 2 <ref> [2; 5] </ref> = 5 M 2 [2; 6] = 8 Fig. 1. Matrix M 2 is not totally monotone. Example 4 also shows that matrix T need not satisfy the quadrangle inequality when m 3. Indeed, for the given weights we have T [2; 5] = 6, T [3; 6] = 6, T [3; 5] = 3, and T [2; 6] = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 <p> Matrix M 2 is not totally monotone. Example 4 also shows that matrix T need not satisfy the quadrangle inequality when m 3. Indeed, for the given weights we have T [2; 5] = 6, T [3; 6] = 6, T <ref> [3; 5] </ref> = 3, and T [2; 6] = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 : : : w n there exists a minimum binary <p> Example 4 also shows that matrix T need not satisfy the quadrangle inequality when m 3. Indeed, for the given weights we have T <ref> [2; 5] </ref> = 6, T [3; 6] = 6, T [3; 5] = 3, and T [2; 6] = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 : : : w n there exists a minimum binary tree in which the weights are assigned to leaves in left-to-right order, <p> Indeed, for the given weights we have T [2; 5] = 6, T [3; 6] = 6, T <ref> [3; 5] </ref> = 3, and T [2; 6] = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 : : : w n there exists a minimum binary tree in which the weights are assigned to leaves in left-to-right order, i.e., a minimum binary tree that is alphabetic. <p> Acknowledgements I wish to thank Ioan Tomescu and Vijay Vazirani for encouraging my work on the problem and Lawrence Larmore for stimulating discussions. Thanks also go to the anonymous referees for helpful comments and for suggesting reference <ref> [5] </ref>.
Reference: [6] <author> D.A. Huffman, </author> <title> A method for the construction of minimum redundancy codes, </title> <booktitle> Proc. Inst. Radio Engineers 40 (1952), </booktitle> <pages> pp. 1098-1101. </pages>
Reference-contexts: 1 Introduction Huffman's classical algorithm <ref> [6] </ref> constructs a prefix code with minimum weighted length over a given alphabet. <p> Hence, M 2 is not totally monotone. i ii i i S S S S S S S S S S 1 1 1 1 1 1 1 1 M 2 [2; 5] = 5 M 2 <ref> [2; 6] </ref> = 8 Fig. 1. Matrix M 2 is not totally monotone. Example 4 also shows that matrix T need not satisfy the quadrangle inequality when m 3. <p> Matrix M 2 is not totally monotone. Example 4 also shows that matrix T need not satisfy the quadrangle inequality when m 3. Indeed, for the given weights we have T [2; 5] = 6, T <ref> [3; 6] </ref> = 6, T [3; 5] = 3, and T [2; 6] = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 : : : w n <p> Matrix M 2 is not totally monotone. Example 4 also shows that matrix T need not satisfy the quadrangle inequality when m 3. Indeed, for the given weights we have T [2; 5] = 6, T [3; 6] = 6, T [3; 5] = 3, and T <ref> [2; 6] </ref> = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 : : : w n there exists a minimum binary tree in which the weights are <p> Indeed, for the given weights we have T [2; 5] = 6, T <ref> [3; 6] </ref> = 6, T [3; 5] = 3, and T [2; 6] = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 : : : w n there exists a minimum binary tree in which the weights are assigned to leaves in left-to-right order, i.e., a minimum binary <p> Indeed, for the given weights we have T [2; 5] = 6, T [3; 6] = 6, T [3; 5] = 3, and T <ref> [2; 6] </ref> = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick [11], when w 1 w 2 : : : w n there exists a minimum binary tree in which the weights are assigned to leaves in left-to-right order, i.e., a minimum binary tree that is alphabetic.
Reference: [7] <author> A. Itai, </author> <title> Optimal alphabetic trees, </title> <journal> SIAM J. Comput. </journal> <volume> 5 (1976), </volume> <pages> pp. 9-18. </pages>
Reference-contexts: First, we compute T [j 1 ; j 2 ] for every 1 j 1 j 2 n using Itai's algorithm <ref> [7] </ref>. This takes O (n 3 log m) time; Itai claims that this can be improved to O (n 2 log m), but, as remarked in [5], his claim is correct only for m = 2. <p> For arbitrary m, the values T (d) [j 1 ; j 2 ], 0 d L, 1 j 1 j 2 n, can be evaluated in O (n 3 L log m) time with the algorithm suggested by Itai <ref> [7] </ref>. Thus, using (4) and (5), we obtain a minimum depth-limited alphabetic m-ary forest in O (n 3 L log m + n 2 k) time. The running time can be reduced by a factor of n when m = 2.
Reference: [8] <author> D.E. Knuth, </author> <title> Optimum binary search trees, </title> <journal> Acta Informatica 1 (1971), </journal> <pages> pp. 14-25. </pages>
Reference-contexts: Starting with Gilbert and Moore [4], dynamic programming has been successfully applied to several prefix coding problems (see for example [3,7,8,12]). Particularly efficient algorithms are obtained with a speed-up technique devised by Knuth <ref> [8] </ref>; the speed-up is based on the fact that a certain cost-matrix satisfies the quadrangle inequality (an upper-triangular matrix W satisfies quadrangle inequality if w (i; j) + w (i 0 ; j 0 ) w (i; j 0 ) + w (i 0 ; j) for all i &lt; i <p> We will next show that the running time can be reduced by a factor of n when constructing binary forests, i.e., when m = 2. First, we compute all entries of T in O (n 2 ) time using Knuth's algorithm <ref> [8] </ref>. Clearly, the cumulative weights P j t=b+1 w t can also be computed within the same time bound.
Reference: [9] <author> D.E. Knuth, </author> <booktitle> The Art of Computer Programming vol. </booktitle> <volume> 1, </volume> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1973. </year>
Reference-contexts: Following a common practice, from now on we will use this graph theoretical terminology. Let m 2 be an integer. The notion of m-ary tree is the natural extension of positional binary trees defined in <ref> [9] </ref>: an m-ary tree is a set of nodes that is either empty, or consists of a root node and an ordered list of m disjoint m-ary trees, called the first, second, : : : , respectively the mth subtree of the root.
Reference: [10] <author> L.L. Larmore, </author> <title> Height restricted optimal binary trees, </title> <journal> SIAM J. Comput. </journal> <volume> 16 (1987), </volume> <pages> pp. 1115-1123. </pages>
Reference-contexts: Since Huffman's algorithm can be implemented to run in O (n) time when the 7 weights are already sorted (see for example <ref> [10] </ref>), the pre-processing step is now completed in O (n 3 ) time. 5 Depth-limited forests In practical applications of prefix coding it is desirable to impose an upper-bound on the length of the codewords.
Reference: [11] <author> E.S. Schwartz and B. Kallick, </author> <title> Generating a canonical prefix encoding, </title> <booktitle> Comm. of the ACM 7 (1964), </booktitle> <pages> pp. 166-169. </pages>
Reference-contexts: given weights we have T [2; 5] = 6, T [3; 6] = 6, T [3; 5] = 3, and T [2; 6] = 8, so T [2; 5] + T [3; 6] &gt; T [3; 5] + T [2; 6]. 4 Non-alphabetic forests As observed by Schwartz and Kallick <ref> [11] </ref>, when w 1 w 2 : : : w n there exists a minimum binary tree in which the weights are assigned to leaves in left-to-right order, i.e., a minimum binary tree that is alphabetic.
Reference: [12] <author> R.L. Wessner, </author> <title> Optimal Alphabetic search trees with restricted maximal height, </title> <journal> Inf. Proc. Letters 4,4 (1976), </journal> <pages> pp. 90-94. 9 </pages>
Reference-contexts: We first prove that matrix T satisfies the quadrangle inequality. The next result has been first noticed by 4 Garey [3, Cor. 1] for non-alphabetic binary trees, and extended by Wessner <ref> [12] </ref> to alphabetic binary trees with weights on all nodes (not only on leaves) and limited depth. <p> For the particular case when the weights of internal nodes are zero and the depth limit is n, Wessner's result reads as follows: Lemma 1 (Cf. <ref> [12, Lemma 1] </ref>) Assume that m = 2. If (i; j) = T (i; j) T (i; j 1), then, for every j i + 2, (i; j) (i + 1; j). Corollary 2 Assume that m = 2. <p> The running time can be reduced by a factor of n when m = 2. First, all values T (d) [j 1 ; j 2 ] can be evaluated in O (n 2 L) time [7,12]. Moreover, Lemma 1 holds for matrix T (d) if m = 2 (cf. <ref> [12, Lemma 1] </ref>). Exactly as in Section 3, this implies that T (d) satisfies the quadrangle inequality and matrices N i , 2 i k, are totally monotone.
References-found: 12

