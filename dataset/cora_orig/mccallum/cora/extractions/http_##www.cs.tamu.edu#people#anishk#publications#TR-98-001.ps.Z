URL: http://www.cs.tamu.edu/people/anishk/publications/TR-98-001.ps.Z
Refering-URL: http://www.cs.tamu.edu/people/anishk/publications.html
Root-URL: http://www.cs.tamu.edu
Email: anishk@cs.tamu.edu  pooch@cs.tamu.edu  
Phone: Tel: (409)845-4456  Tel: (409)845-5498  
Title: Cortex: A Framework for Communication Support in Object Oriented Distributed Systems  and  
Author: Anish S. Karmarkar Udo W. Pooch 
Note: TR-98-001  
Date: January 1998  
Address: College Station, Texas 77843-3112.  College Station, Texas 77843-3112.  
Affiliation: Department of Computer Science Texas A&M University  Department of Computer Science Texas A&M University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> T. J. Mowbray and R. Zahavi, </author> <title> The Essential Corba: System Integration Using Distributed Objects, </title> <publisher> John Wiley & Sons Inc., </publisher> <address> New York, New York, </address> <year> 1995. </year>
Reference-contexts: In an object oriented system, all the services are available as object invocations. Thus, the system consists of communicating 1 objects at an abstract level. With OMG's CORBA <ref> [1] </ref> as a standard, interoperability between different object models is easier. Distributed objects refer to the ability of programs to access other program objects anywhere in the Internet or an intranet without knowledge of where the object resides.
Reference: [2] <author> P. Jalote, </author> <title> Fault Tolerance in Distributed Systems, </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1994. </year>
Reference-contexts: The advent of ubiquitous connectivity via the Internet, standards such as CORBA and distributed programming languages such as Java have made distributed objects very practical. There are several levels of abstraction in a fault tolerant distributed system <ref> [2] </ref>. The different levels provide different fault tolerant services. At the lowest level are the abstractions which are frequently used by those at the higher level and are therefore considered to be the basic building blocks.
Reference: [3] <author> L. Liang, S. T. Chason, and G. W. Neufeld, </author> <title> "Process groups and group communications: Classifications and requirements," </title> <journal> IEEE Computer, </journal> <volume> vol. 23, no. 2, </volume> <pages> pp. 56-66, </pages> <month> February </month> <year> 1990. </year> <month> 15 </month>
Reference-contexts: A process group can be viewed as providing a service to the distributed system as a whole. In fact, a client using the services of the group may be unaware of the existence of the group itself <ref> [3] </ref>.
Reference: [4] <author> K. P. Birman, </author> <title> "The process group approach to reliable distributed computing," </title> <journal> Comm. ACM, </journal> <volume> vol. 36, no. 12, </volume> <pages> pp. 37-53, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: In fact, a client using the services of the group may be unaware of the existence of the group itself [3]. A process group abstraction can be used for load balancing, distributed naming service, replicated server group, distributed date bases etc. <ref> [4] </ref> gives good reasons for supporting a process group abstraction in a shared software subsystem: The focus of this paper is a group communication paradigm in an object based system. Group communication simplifies specification and implementation of complex applications.
Reference: [5] <author> D. Powell, </author> <title> "Group communication," </title> <journal> Comm. ACM, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 50-53, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: The performance results obtained from the experiments are presented graphically and discussed. Section 6 concludes this paper with a summary and directions for future work. 2 Group Communication Support in Distributed Systems Recently there has been a lot of research work done in this area <ref> [5] </ref>. Group communication support for distributed computing has been available for some time now. Most of these though did not offer reliable communication. V-system offered a multicast service for process group communication. But, it did not offer a reliable multicast service or a total ordering service.
Reference: [6] <author> S. Navaratnum, S. Chanson, and G. Neufeld, </author> <title> "Reliable group communication in distributed systems," </title> <booktitle> In Proc. 8th Intl. Conf. on Dist. Comp. Syst., </booktitle> <address> San Jose, California, </address> <pages> pp. 439-446, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Group communication support for distributed computing has been available for some time now. Most of these though did not offer reliable communication. V-system offered a multicast service for process group communication. But, it did not offer a reliable multicast service or a total ordering service. Navaratnam et al <ref> [6] </ref> proposed an algorithm for reliable group communication and implemented it on the V-system. Causal ordering for fault-tolerant system was first proposed by Birman and Joseph [7]. Most Causal ordering algorithms use logical vector clocks proposed by Mattern and Fidge.
Reference: [7] <author> K. P. Birman and R. V. Renesse, </author> <title> Reliable Distributed Computing with the ISIS Toolkit, </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> California, </address> <year> 1994. </year>
Reference-contexts: But, it did not offer a reliable multicast service or a total ordering service. Navaratnam et al [6] proposed an algorithm for reliable group communication and implemented it on the V-system. Causal ordering for fault-tolerant system was first proposed by Birman and Joseph <ref> [7] </ref>. Most Causal ordering algorithms use logical vector clocks proposed by Mattern and Fidge. Kopetz et al have developed a protocol for membership services and the ordering of messages in a synchronous system for real-time applications. <p> It is based on the Lansis algorithm, which assumes a broadcast network. It provides causal, totally-ordered and safe delivery of messages. Transis tolerates network partitions and rejoining (partitionable operation) and has a membership service. The membership algorithm works with the group communication algorithm. The Isis system <ref> [7] </ref> provides an interface for applications. It allows a variety of services to the applications such as GBCAST, CBCAST, ABCAST. Isis makes a very good case for process group communication.
Reference: [8] <author> F. Cristian, H. Aghili, R. Strong, and D. Dolev, </author> <title> "Atomic broadcast: From simple message diffusion to byzantine agreement," </title> <booktitle> In Fifteenth Intl. Conf. on Fault Tolerant Computing, </booktitle> <address> Ann Arbor, </address> <publisher> Michigan, </publisher> <pages> pp. 1-12, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: Causal ordering for fault-tolerant system was first proposed by Birman and Joseph [7]. Most Causal ordering algorithms use logical vector clocks proposed by Mattern and Fidge. Kopetz et al have developed a protocol for membership services and the ordering of messages in a synchronous system for real-time applications. Cristian <ref> [8] </ref> has developed an atomic broadcast protocol and membership service for distributed systems with loosely synchronized clocks. Psync [9] provides totally ordered messages using a context graph. One of the earliest reliable total ordering broadcast protocols for asynchronous systems were proposed by Chang and Maxemchuk [10].
Reference: [9] <author> L. L. Peterson, N. C. Buchholz, and R. D. Schlichting, </author> <title> "Preserving and using context information in interprocess communication," </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> vol. 7, no. 3, </volume> <pages> pp. 217-246, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Kopetz et al have developed a protocol for membership services and the ordering of messages in a synchronous system for real-time applications. Cristian [8] has developed an atomic broadcast protocol and membership service for distributed systems with loosely synchronized clocks. Psync <ref> [9] </ref> provides totally ordered messages using a context graph. One of the earliest reliable total ordering broadcast protocols for asynchronous systems were proposed by Chang and Maxemchuk [10]. They proposed a set of protocols that totally order messages reliably in a broadcast network.
Reference: [10] <author> J.-M. Chang and N. F. Maxemchuk, </author> <title> "Reliable broadcast protocols," </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> vol. 2, no. 3, </volume> <pages> pp. 251-273, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Cristian [8] has developed an atomic broadcast protocol and membership service for distributed systems with loosely synchronized clocks. Psync [9] provides totally ordered messages using a context graph. One of the earliest reliable total ordering broadcast protocols for asynchronous systems were proposed by Chang and Maxemchuk <ref> [10] </ref>. They proposed a set of protocols that totally order messages reliably in a broadcast network. Their protocols form a logical token passing ring. The protocols are for varying degree of resiliency, message latency and token passing frequency. <p> It provides total ordering of messages in a group. They also provide membership algorithms on top of total ordering protocols. The Totem system [12] builds on the experience of the Trans/Total stem. It uses a logical token passing ring similar to the one proposed by <ref> [10] </ref>. But in [10] the token holder acknowledges the broadcast messages, whereas in Totem only the token holder can send a message to the group. It assumes a broadcast network. It also provides extended virtual synchrony and tolerates network partitions. The Transis system [13] extends the Trans/Total algorithm. <p> It provides total ordering of messages in a group. They also provide membership algorithms on top of total ordering protocols. The Totem system [12] builds on the experience of the Trans/Total stem. It uses a logical token passing ring similar to the one proposed by <ref> [10] </ref>. But in [10] the token holder acknowledges the broadcast messages, whereas in Totem only the token holder can send a message to the group. It assumes a broadcast network. It also provides extended virtual synchrony and tolerates network partitions. The Transis system [13] extends the Trans/Total algorithm. <p> It also establishes the concept of virtual synchrony, which is expanded to 'extended virtual synchrony' in Totem, to maintain consistent view in distributed systems. The initial Isis algorithm is based on a 2-phase algorithm, which is later changed to a logical token passing ring similar to <ref> [10] </ref>. Isis also provides for the ordering of messages in overlapping process groups. It provides support for causal, totally ordered and safe delivery of messages. Horus [14] is the object oriented extension of Isis. Amoeba [15] implements a reliable totally ordered multicast, at the kernel-level. <p> It provides support for causal, totally ordered and safe delivery of messages. Horus [14] is the object oriented extension of Isis. Amoeba [15] implements a reliable totally ordered multicast, at the kernel-level. A sequencer in the group orders messages for the group. Their algorithm is similar to <ref> [10] </ref>, but they add process group membership to it. Arjuna [16] system also implements a reliable ordered broadcast. It uses the concept of nested atomic transactions, with commit and roll-back for transactions. RMP [17] implements Chang & Maxemchuk's algorithm using IP-multicast.
Reference: [11] <author> P. M. Melliar-Smith, L. E. Moser, and V. Agrawala, </author> <title> "Broadcast protocols for distributed systems," </title> <journal> IEEE Trans. Par. Distr. Syst., </journal> <volume> vol. 1, no. 1, </volume> <pages> pp. 17-25, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: They proposed a set of protocols that totally order messages reliably in a broadcast network. Their protocols form a logical token passing ring. The protocols are for varying degree of resiliency, message latency and token passing frequency. The Trans <ref> [11] </ref> system also provides atomic multicast service for a broadcast network. It is based on piggy-backing positive acknowledgments on regular messages, and sending explicit negative acknowledgments when messages are missed. The Total protocol builds on the Trans system. It provides total ordering of messages in a group.
Reference: [12] <author> Y. Amir, L. E. Moser, P. Melliar-Smith, D. A. Agrawal, and P. Ciarfella, </author> <title> "Fast message ordering and membership using a logical token passing ring," </title> <booktitle> In Proceedings of the 13th Intl. Conf. on Dist. Comp. Syst., </booktitle> <address> Washington DC, </address> <pages> pp. 551-560, </pages> <year> 1993. </year>
Reference-contexts: The Total protocol builds on the Trans system. It provides total ordering of messages in a group. They also provide membership algorithms on top of total ordering protocols. The Totem system <ref> [12] </ref> builds on the experience of the Trans/Total stem. It uses a logical token passing ring similar to the one proposed by [10]. But in [10] the token holder acknowledges the broadcast messages, whereas in Totem only the token holder can send a message to the group.
Reference: [13] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki, "Transis: </author> <title> A Communication Sub-System for High Availability," </title> <booktitle> In 22nd International Symposium on Fault-Tolerant Computing, </booktitle> <address> Boston, Mas-sachusetts, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: But in [10] the token holder acknowledges the broadcast messages, whereas in Totem only the token holder can send a message to the group. It assumes a broadcast network. It also provides extended virtual synchrony and tolerates network partitions. The Transis system <ref> [13] </ref> extends the Trans/Total algorithm. It provides a total order which respects 3 the partial order (causal-ordering of messages), with certainty (unlike Total). It is based on the Lansis algorithm, which assumes a broadcast network. It provides causal, totally-ordered and safe delivery of messages.
Reference: [14] <author> R. van Renesse, K. P. Birman, and S. Maffeis, "Horus: </author> <title> A flexible group communication system," </title> <journal> Comm. ACM, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 76-83, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: The initial Isis algorithm is based on a 2-phase algorithm, which is later changed to a logical token passing ring similar to [10]. Isis also provides for the ordering of messages in overlapping process groups. It provides support for causal, totally ordered and safe delivery of messages. Horus <ref> [14] </ref> is the object oriented extension of Isis. Amoeba [15] implements a reliable totally ordered multicast, at the kernel-level. A sequencer in the group orders messages for the group. Their algorithm is similar to [10], but they add process group membership to it.
Reference: [15] <author> M. F. Kaashoek and A. S. Tanenbaum, </author> <title> "Group communication in the amoeba distributed operating system," </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems (ICDCS), </booktitle> <address> Arlington, Texas, </address> <pages> pp. 222-230, </pages> <address> Arlington, Texas, </address> <year> 1991. </year>
Reference-contexts: Isis also provides for the ordering of messages in overlapping process groups. It provides support for causal, totally ordered and safe delivery of messages. Horus [14] is the object oriented extension of Isis. Amoeba <ref> [15] </ref> implements a reliable totally ordered multicast, at the kernel-level. A sequencer in the group orders messages for the group. Their algorithm is similar to [10], but they add process group membership to it. Arjuna [16] system also implements a reliable ordered broadcast.
Reference: [16] <author> P. D. Ezhilchelvan, R. A. Mac^edo, and S. K. Shrivastava, "Newtop: </author> <title> A fault-tolerant group communication protocol," </title> <booktitle> In Proceedings of the 15th International Conference on Distributed Computing Systems (ICDCS'95), </booktitle> <address> Vancouver, BC, Canada, </address> <pages> pp. 296-306, </pages> <year> 1995. </year>
Reference-contexts: Horus [14] is the object oriented extension of Isis. Amoeba [15] implements a reliable totally ordered multicast, at the kernel-level. A sequencer in the group orders messages for the group. Their algorithm is similar to [10], but they add process group membership to it. Arjuna <ref> [16] </ref> system also implements a reliable ordered broadcast. It uses the concept of nested atomic transactions, with commit and roll-back for transactions. RMP [17] implements Chang & Maxemchuk's algorithm using IP-multicast. Most communication support algorithms can be divided into token-passing and non token passing.
Reference: [17] <author> T. Montgomery, </author> <title> Design, Implementation, and Verification of the Reliable Multicast Protocol, </title> <type> Master's thesis, </type> <institution> Dept. of Electrical Engg., West Virginia University, </institution> <year> 1994. </year> <month> 16 </month>
Reference-contexts: A sequencer in the group orders messages for the group. Their algorithm is similar to [10], but they add process group membership to it. Arjuna [16] system also implements a reliable ordered broadcast. It uses the concept of nested atomic transactions, with commit and roll-back for transactions. RMP <ref> [17] </ref> implements Chang & Maxemchuk's algorithm using IP-multicast. Most communication support algorithms can be divided into token-passing and non token passing. Non-token passing algorithms are spontaneous and all the members can broadcast messages without waiting for a token-holder to transmit messages.
Reference: [18] <author> F. Cristian, </author> <title> "Synchronous and asynchronous group communication," </title> <journal> Comm. ACM, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 88-97, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: Each pair of processes are connected by two one-way channels in opposite directions. We will consider the communication in the system as timed asynchronous (as opposed to synchronous and purely asynchronous <ref> [18] </ref>). Synchronous systems have clock synchronization, message delivery guarantees and process scheduling guarantees. A purely asynchronous system [19] has no bound on the delay in the delivery of messages, no bound on process speeds, no synchronous clocks or a global clock. <p> In a purely asynchronous system a process waits for a message forever, so a very 4 slow process and a failed process cannot be distinguished. A timed asynchronous system <ref> [18] </ref>, is an asynchronous system in the sense that it has no clock synchronization, no message delivery and no process scheduling guarantees. But in a timed asynchronous system a process does not wait for a message forever.
Reference: [19] <author> M. J. Fischer, N. A. Lynch, and M. S. Paterson, </author> <title> "Impossibility of distributed consensus with one faulty process," </title> <journal> Journal of the ACM, </journal> <volume> vol. 32, no. 2, </volume> <pages> pp. 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Each pair of processes are connected by two one-way channels in opposite directions. We will consider the communication in the system as timed asynchronous (as opposed to synchronous and purely asynchronous [18]). Synchronous systems have clock synchronization, message delivery guarantees and process scheduling guarantees. A purely asynchronous system <ref> [19] </ref> has no bound on the delay in the delivery of messages, no bound on process speeds, no synchronous clocks or a global clock. In a purely asynchronous system a process waits for a message forever, so a very 4 slow process and a failed process cannot be distinguished.
Reference: [20] <author> L. Lamport, </author> <title> "Time, clocks and the ordering of events in a distributed system," </title> <journal> Comm. ACM, </journal> <volume> vol. 21, no. 7, </volume> <pages> pp. 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: The Cortex object and the application object are language level objects. A process consists of both the Cortex object and the application object. The execution of the processes is a partially ordered sequence of events. The events in the system follow the Lamport's Happened-Before relation <ref> [20] </ref>. The processes in the system communicate with the other processes using the communication services offered by the network. All the processes in the system have access to a name service, NS. A reference to an object or a group is fetched from the NS.
Reference: [21] <author> G. Beedubail, P. Kessler, and U. Pooch, </author> <title> "Replicated naming service in spring," </title> <type> Technical Report TR95-048, </type> <institution> Computer Science Department,Texas A&M University, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: NS is assumed not to fail. A name service is very important in a distributed system since without a name service clients cannot reach the servers. A name service can be made fault tolerant using the techniques in <ref> [21] </ref>. The fault model that is assumed for the system is crash failure for the processes and fail-silent for the communication system. Processors can fail only by crashing, there are no byzantine failures. The communication system can fail by delaying messages for long periods of time.
Reference: [22] <author> T. D. Chandra and S. Toueg, </author> <title> "Unreliable failure detectors for reliable distributed systems," </title> <type> Technical Report TR93-1374, </type> <institution> Cornell University, Computer Science Department, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: This algorithm suits very well for a typical organization network 2 The failure detectors can be classified as belonging to the category W in <ref> [22] </ref>. 6 (or intranet) connected to the Internet, with a firewall in between. 5) Safe delivery of messages: This protocol makes sure that messages delivered at any process (failed or surviving) is a subset of messages delivered at a surviving process.
Reference: [23] <author> A. S. Karmarkar, </author> <title> A Framework for Communication Support in Object Oriented Distributed Systems, </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Texas A&M University, College Station, </institution> <month> December </month> <year> 1997. </year>
Reference-contexts: Details of the algorithms and proofs are given in <ref> [23] </ref>. The framework implements protocols for: 1) Reliable FIFO unicast: This protocol guarantees that unicast messages sent between two processes are delivered in a FIFO order and in a reliable way.
Reference: [24] <institution> Old Domininion University, </institution> <note> The Java Collaborator Toolset, Available: http://www.cs.odu.edu/~kvande/Projects/Collaborator/, March 1996. 17 </note>
Reference-contexts: This includes classes for drawing, writing, erasing, setting the color of the pen and a scrollable drawing area that are required for a whiteboard. The GUI part of the FTIW is the modified version of the one found in <ref> [24] </ref>. 11 5.4 Experimental Results and Discussion The experimental results were obtained by running test applications on a single ethernet network consisting of thirteen machines. All machines were running SunOS 5.5 operating system.
References-found: 24

