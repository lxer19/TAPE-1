URL: http://www.cs.rice.edu/CS/PLT/Publications/lfp90-sf.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Reasoning with Continuations II: Full Abstraction for Models of Control  
Author: Dorai Sitaram and Matthias Felleisen 
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: A fully abstract model of a programming language assigns the same meaning to two terms if and only if they have the same operational behavior. Such models are well-known for functional languages but little is known about extended functional languages with sophisticated control structures. We show that a direct model with error values and the conventional continuation model are adequate for functional languages augmented with first- and higher-order control facilities, respectively. Furthermore, both models become fully abstract on adding a control delimiter and a parallel conditional to the programming languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aiken A., J.H. Williams, and E.L. Wimmers. </author> <title> Program transformation in the presence of errors. </title> <booktitle> In Proc. 17th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 210-217, </pages> <year> 1990. </year>
Reference-contexts: 7, 11] results on functional languages with first-class control abstractions provide a partial answer to the first question. 1 There is a small number of fundamental laws for the operational equivalence relation of such languages that play a crucial role in equivalence 1 The recent work by Aiken et al <ref> [1] </ref> on program transformations in the presence of errors can also be viewed as addressing this problem although their main concern is quite different. proofs of Lisp-like programs with continuations. Based on these laws, it is possible to manipulate such programs with the same algebraic elegance as functional programs.
Reference: [2] <author> H.P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <booktitle> Studies in Logic and the Foundations of Mathematics 103. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year> <note> Revised edition. </note>
Reference-contexts: We adopt the usual conventions governing the use of concrete syntax for -expressions <ref> [2] </ref>. rules (!) of an abstract machine for Pcf v . The numerals represent numbers. The functional constants 1+ and 1 have the behavior of "add 1" and "subtract 1." A thunk is a procedure with a dummy argument: we use p0q to discharge a thunk.
Reference: [3] <author> V. Breazu-Tannen, C. Gunter, and A. Sce-drov. </author> <title> Computing with coercions. </title> <booktitle> In Proc. 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990, </year> <note> this volume. </note>
Reference-contexts: Env is the set of environments, which are type-respecting maps from variables to elements in the domains. It is straightforward to show that this model is adequate. This result was also obtained by Breazu-Tannen et al <ref> [3] </ref> and Riecke [personal communica tion].
Reference: [4] <author> O. Danvy and A. Filinski. </author> <title> Abstracting control. </title> <booktitle> In Proc. 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990, </year> <note> this volume. </note>
Reference-contexts: This extension is also supported by practical evidence. Our own investigation of control de-limiters found them to yield several useful programming paradigms for languages like Scheme [8, 23]; Danvy and Filinski <ref> [4] </ref> describe other interesting uses of prompt and related concepts. Recently, Hieb and Dybvig [16] argued for an extension of prompt, called spawn, as a crucial programming tool for concurrent systems with control operators.
Reference: [5] <author> R.K. Dybvig and R. Hieb. </author> <title> Engines from continuations. </title> <journal> Journal of Computer Languages (Pergamon Press), </journal> <volume> 14(2) </volume> <pages> 109-124, </pages> <year> 1989. </year>
Reference-contexts: When it is invoked, evaluation reinstates the captured context in place of the current one, and fills it with the continuation's argument. It is easy to simulate other non-local control actions in terms of K <ref> [5, 12, 14, 15, 26] </ref>. A K-expression can occur anywhere inside a program; thus it can have any type s. Also, the program can invoke the continuation anywhere, but the latter's argument must be of the same type as the K-expression.
Reference: [6] <author> M. Felleisen. </author> <title> The Calculi of Lambda-v-CS-Conversion: A Syntactic Theory of Control and State in Imperative Higher-Order Programming Languages. </title> <type> PhD thesis, </type> <institution> Indiana University, </institution> <year> 1987. </year>
Reference-contexts: Moreover, by incorporating explicit statements about the control behavior, a program provides clues to the compiler for possible optimizations. However, control constructs also invalidate some common laws of reasoning that hold for functional programming languages like pure Lisp <ref> [6, 18, 27] </ref>. More technically, the operational equivalence relation for the functional subset of Lisp is not a subset of the operational equivalence relation for Lisp with control facilities. Given the importance of operational equivalence laws for reasoning about programs, this raises two crucial questions: 1. <p> How can we reason with control facilities? 2. How can we relate the reasoning system for functional languages to the system for ex tended languages with control facilities? Talcott's [27, 28] and our own <ref> [6, 7, 11] </ref> results on functional languages with first-class control abstractions provide a partial answer to the first question. 1 There is a small number of fundamental laws for the operational equivalence relation of such languages that play a crucial role in equivalence 1 The recent work by Aiken et al <p> Based on these laws, it is possible to manipulate such programs with the same algebraic elegance as functional programs. Our work <ref> [6, 7, 11] </ref> on conservative extensions of Plotkin's [20] v -calculus for pure Lisp also contributes to an answer for the second question. It shows that all equational proofs in the syntactic theory of functional languages carry over to the extended framework with control mechanisms.
Reference: [7] <author> M. Felleisen. -v-CS: </author> <title> An extended -calculus for Scheme. </title> <booktitle> In Proc. 1988 Conference on Lisp and Functional Programming, </booktitle> <pages> pages 72-84, </pages> <year> 1988. </year>
Reference-contexts: How can we reason with control facilities? 2. How can we relate the reasoning system for functional languages to the system for ex tended languages with control facilities? Talcott's [27, 28] and our own <ref> [6, 7, 11] </ref> results on functional languages with first-class control abstractions provide a partial answer to the first question. 1 There is a small number of fundamental laws for the operational equivalence relation of such languages that play a crucial role in equivalence 1 The recent work by Aiken et al <p> Based on these laws, it is possible to manipulate such programs with the same algebraic elegance as functional programs. Our work <ref> [6, 7, 11] </ref> on conservative extensions of Plotkin's [20] v -calculus for pure Lisp also contributes to an answer for the second question. It shows that all equational proofs in the syntactic theory of functional languages carry over to the extended framework with control mechanisms.
Reference: [8] <author> M. Felleisen. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Proc. 15th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 180-190, </pages> <year> 1988. </year>
Reference-contexts: Adjusting the programming languages so that these models become fully abstract leads to the surprising re-discovery of first-class prompts: We had earlier suggested the inclusion of prompts in languages with control structures but for entirely different reasons <ref> [8, 23] </ref>. The full abstraction theorem for the conventional continuation model also verifies a conjecture by Meyer and Riecke [18:65]. The following section introduces Pcf v -c, an extension of a call-by-value variant of Pcf [21] with a sophisticated control structure. <p> However, the model distinguishes them by applying the denotation of M 0 and M 1 to s m:inL (strip (m0)): To fix this problem, we augment the language with a control delimiter or prompt <ref> [8, 23] </ref>. A prompt-expression, %M , runs its sub-expression M as an independent program insofar as control action is concerned. Aborts cannot extend beyond the dynamically closest prompt. <p> To establish an analogous relationship, languages with control require a control delimiter to express all sequential aspects of their models. This extension is also supported by practical evidence. Our own investigation of control de-limiters found them to yield several useful programming paradigms for languages like Scheme <ref> [8, 23] </ref>; Danvy and Filinski [4] describe other interesting uses of prompt and related concepts. Recently, Hieb and Dybvig [16] argued for an extension of prompt, called spawn, as a crucial programming tool for concurrent systems with control operators.
Reference: [9] <author> M. Felleisen. </author> <title> On the expressive power of programming languages. </title> <booktitle> In Proc. European Symposium on Programming. Lecture Notes in Computer Science, </booktitle> <year> 1990. </year> <note> To appear. </note>
Reference-contexts: It also contains a formal discussion on the above-mentioned problematic relationship between the operational equivalence relations of Pcf v and the extended languages, providing a comprehensive overview of the expressive power of the various control constructs <ref> [9] </ref>. The third section describes the properties of a denotational semantics for Pcf v and the related notions of denotational equivalence, adequacy and full abstraction. The fourth and fifth sections present direct and continuation models for first- and higher-order control structures, respectively. <p> However, the addition of A invalidates some of the operational equivalences in Pcf v , showing that functional languages cannot express abort <ref> [9] </ref>. Proposition 2.2 ' v * ' a Proof. The terms M 1 and M 2 above, which are operationally equivalent in Pcf v , are inequivalent in Pcf v +A, since the context [ ](x:Ax) distinguishes the two. <p> The full language Pcf v +A+K, which we shall call Pcf v -c, is also a non-conservative extension of Pcf v +A, i.e., K adds true expressive power <ref> [9] </ref>. The evaluation function and operational equivalence relation for Pcf v care eval c and ' c , respectively. Proposition 2.4 ' a * ' c Proof.
Reference: [10] <author> M. Felleisen and R.S. Cartwright. </author> <title> Extended direct semantics. </title> <type> Technical Report 105, </type> <institution> Rice University, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: Proof. The proof uses Plotkin's [21] method of defining terms for the finite elements of the domains. The direct model is easily extended to accommodate Pcf v +A <ref> [10] </ref>. Each domain is augmented with exception values to correspond to denotations of abort terms of that type. Since the exception values are always ground, they can be represented by D . The domains and the semantic functionals for Pcf v +A are shown in Figure 3.
Reference: [11] <author> M. Felleisen, D.P. Friedman, E. Kohlbecker, and B. Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theor. Comput. Sci., </journal> <volume> 52(3) </volume> <pages> 205-237, </pages> <year> 1987. </year> <title> Preliminary version: Reasoning with Continuations, </title> <booktitle> Proc. Symposium on Logic in Computer Science, </booktitle> <year> 1986, </year> <pages> 131-141. </pages>
Reference-contexts: How can we reason with control facilities? 2. How can we relate the reasoning system for functional languages to the system for ex tended languages with control facilities? Talcott's [27, 28] and our own <ref> [6, 7, 11] </ref> results on functional languages with first-class control abstractions provide a partial answer to the first question. 1 There is a small number of fundamental laws for the operational equivalence relation of such languages that play a crucial role in equivalence 1 The recent work by Aiken et al <p> Based on these laws, it is possible to manipulate such programs with the same algebraic elegance as functional programs. Our work <ref> [6, 7, 11] </ref> on conservative extensions of Plotkin's [20] v -calculus for pure Lisp also contributes to an answer for the second question. It shows that all equational proofs in the syntactic theory of functional languages carry over to the extended framework with control mechanisms.
Reference: [12] <author> D.P. Friedman, C.T. Haynes, and E. Kohlbecker. </author> <title> Programming with continuations. </title> <editor> In P. Pepper, editor, </editor> <booktitle> Program Transformations and Programming Environments, </booktitle> <pages> pages 263-274. </pages> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1985. </year>
Reference-contexts: When it is invoked, evaluation reinstates the captured context in place of the current one, and fills it with the continuation's argument. It is easy to simulate other non-local control actions in terms of K <ref> [5, 12, 14, 15, 26] </ref>. A K-expression can occur anywhere inside a program; thus it can have any type s. Also, the program can invoke the continuation anywhere, but the latter's argument must be of the same type as the K-expression.
Reference: [13] <author> T. Griffin. </author> <title> A formul-as-types notion of control. </title> <booktitle> In Proc. 17th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1990, </year> <note> to appear. </note>
Reference-contexts: Once again, operational equivalences are not necessarily preserved when Pcf v is extended to Pcf v +K. Proposition 2.3 ' v * ' k Proof. The same counterexample as for Proposition 2.2 holds. The distinguishing context is now K (a:[ ]a). 2 Bruce Duba [private communication] and Tim Griffin <ref> [13] </ref> independently formulated similar typing rules for A and K. The full language Pcf v +A+K, which we shall call Pcf v -c, is also a non-conservative extension of Pcf v +A, i.e., K adds true expressive power [9].
Reference: [14] <author> C.T. Haynes and D.P. Friedman. </author> <title> Embedding continuations in procedural objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(4) </volume> <pages> 245-254, </pages> <year> 1987. </year>
Reference-contexts: When it is invoked, evaluation reinstates the captured context in place of the current one, and fills it with the continuation's argument. It is easy to simulate other non-local control actions in terms of K <ref> [5, 12, 14, 15, 26] </ref>. A K-expression can occur anywhere inside a program; thus it can have any type s. Also, the program can invoke the continuation anywhere, but the latter's argument must be of the same type as the K-expression.
Reference: [15] <author> C.T. Haynes, D.P. Friedman, and M. Wand. </author> <title> Obtaining coroutines from continuations. </title> <journal> Journal of Computer Languages (Pergamon Press), </journal> 11(3/4):109-121, 1986. 
Reference-contexts: When it is invoked, evaluation reinstates the captured context in place of the current one, and fills it with the continuation's argument. It is easy to simulate other non-local control actions in terms of K <ref> [5, 12, 14, 15, 26] </ref>. A K-expression can occur anywhere inside a program; thus it can have any type s. Also, the program can invoke the continuation anywhere, but the latter's argument must be of the same type as the K-expression.
Reference: [16] <author> R. Hieb and R.K. Dybvig. </author> <title> Continuations and concurrency. </title> <booktitle> In Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 128-136, </pages> <year> 1990. </year>
Reference-contexts: This extension is also supported by practical evidence. Our own investigation of control de-limiters found them to yield several useful programming paradigms for languages like Scheme [8, 23]; Danvy and Filinski [4] describe other interesting uses of prompt and related concepts. Recently, Hieb and Dybvig <ref> [16] </ref> argued for an extension of prompt, called spawn, as a crucial programming tool for concurrent systems with control operators.
Reference: [17] <author> J. McCarthy et al. </author> <title> Lisp 1.5 Programmer's Manual. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, </address> <note> second edition, </note> <year> 1965. </year>
Reference-contexts: 1 The Control Structure of Lisp Many programming languages, in particular Lisp <ref> [17, 24] </ref> and Scheme [22, 26], contain sophisticated control structures with constructs for labeling the control state at an arbitrary point for later reuse.
Reference: [18] <author> A.R. Meyer and J.R. Riecke. </author> <title> Continuations may be unreasonable. </title> <booktitle> In Proc. 1988 Conference on Lisp and Functional Programming, </booktitle> <pages> pages 63-71, </pages> <year> 1988. </year>
Reference-contexts: Moreover, by incorporating explicit statements about the control behavior, a program provides clues to the compiler for possible optimizations. However, control constructs also invalidate some common laws of reasoning that hold for functional programming languages like pure Lisp <ref> [6, 18, 27] </ref>. More technically, the operational equivalence relation for the functional subset of Lisp is not a subset of the operational equivalence relation for Lisp with control facilities. Given the importance of operational equivalence laws for reasoning about programs, this raises two crucial questions: 1.
Reference: [19] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Massachusetts and London, England, </address> <year> 1990. </year>
Reference-contexts: The programming language Scheme [22, 26] provides the equivalent of K-expressions with the procedure call-with-current-continuation or call/cc. A limited version of K is provided by the goto-construct and labels of Algol-like languages, the catch/throw or errset/error mechanism of traditional Lisp systems, and the exception handlers of ML <ref> [19] </ref>. A K-expression applies its sub-expression to an abstraction of the surrounding context or the rest of the computation, the continuation. This continuation is a procedural object that can be called anywhere in the program, just like any other procedure.
Reference: [20] <author> G.D. Plotkin. </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <journal> Theor. Comput. Sci., </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: Based on these laws, it is possible to manipulate such programs with the same algebraic elegance as functional programs. Our work [6, 7, 11] on conservative extensions of Plotkin's <ref> [20] </ref> v -calculus for pure Lisp also contributes to an answer for the second question. It shows that all equational proofs in the syntactic theory of functional languages carry over to the extended framework with control mechanisms. Unfortunately, both pieces of research are only incomplete answers to the above questions.
Reference: [21] <author> G.D. Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theor. Comput. Sci., </journal> <volume> 5 </volume> <pages> 223-255, </pages> <year> 1977. </year>
Reference-contexts: It particularly lacks an induction principle, which automatically comes with denotational models. In this paper we present another step toward a reasoning system for languages with control structure. Following Plotkin's <ref> [21] </ref> approach, we analyze extensions of a typed functional language with Lisp-style control facilities and their natural models. <p> The full abstraction theorem for the conventional continuation model also verifies a conjecture by Meyer and Riecke [18:65]. The following section introduces Pcf v -c, an extension of a call-by-value variant of Pcf <ref> [21] </ref> with a sophisticated control structure. It also contains a formal discussion on the above-mentioned problematic relationship between the operational equivalence relations of Pcf v and the extended languages, providing a comprehensive overview of the expressive power of the various control constructs [9]. <p> In both cases, full abstraction fails for the original languages, but language extensions can fix both instances of the problem. The last section interprets our results with respect to programming language design. 2 Pcf v -c Pcf v cis an extension of call-by-value Pcf <ref> [21] </ref> with control facilities. Pcf v , the programming language of computable functions, is a variant of the typed -value-calculus with ground constants, conditionals, and fixpoint combinators. Subscripts on terms indicate the types of the terms; superscripts indicate the types of variables. <p> abstract for a language if for any two terms M , N in the language, M @ ~ N iff M v N: Given that the operational semantics and the model are constructed independently, full abstrac tion should not be expected automatically. 4 Direct Models for Pcf v +A Plotkin <ref> [21] </ref> showed that a simple extension of call-by-name Pcf has a fully abstract direct model. It is part of programming language folklore that this result extends to the call-by-value variant of Pcf, Pcf v , as well as its simple control extension Pcf v +A. <p> Theorem 4.2 For Pcf v +pif terms M; N , (1) M @ ~ N iff M v N , and (2) M ' N iff M N . Proof. The proof uses Plotkin's <ref> [21] </ref> method of defining terms for the finite elements of the domains. The direct model is easily extended to accommodate Pcf v +A [10]. Each domain is augmented with exception values to correspond to denotations of abort terms of that type. <p> Also as above, the addition of pif is orthogonal to the addition of prompt. By augmenting Pcf v -c with pif and prompt, we arrive at a language for which the CPS model is fully abstract. The proof follows Plotkin's plan <ref> [21] </ref> and essentially consists in showing that there are Pcf v -c terms for defining all finite elements. In our case, this includes elements from both the value and the continuation domains. Definition 5.5 [Definability] 1. <p> Theorem 5.7 (Full Abstraction of CPS) For terms M and N in Pcf v -c (1) M @ ~ N iff M v N , and (2) M ' N iff M N . Proof. The proof is standard, based on Lemma 5.6 <ref> [21] </ref>. 6 Enhancing Control Structures In our study of models for Pcf v with control extensions, we looked at both a simple aborting facility and a higher-order control facility, using a direct and a CPS model, respectively.
Reference: [22] <editor> J. Rees and W. Clinger. </editor> <title> The revised 3 report on the algorithmic language Scheme. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(12) </volume> <pages> 37-79, </pages> <year> 1986. </year>
Reference-contexts: 1 The Control Structure of Lisp Many programming languages, in particular Lisp [17, 24] and Scheme <ref> [22, 26] </ref>, contain sophisticated control structures with constructs for labeling the control state at an arbitrary point for later reuse. <p> Our second control extension, the K-expression of the form KM , provides more interesting possibilities for control manipulations than A. The programming language Scheme <ref> [22, 26] </ref> provides the equivalent of K-expressions with the procedure call-with-current-continuation or call/cc. A limited version of K is provided by the goto-construct and labels of Algol-like languages, the catch/throw or errset/error mechanism of traditional Lisp systems, and the exception handlers of ML [19].
Reference: [23] <author> D. Sitaram and M. Felleisen. </author> <title> Control delim-iters and their hierarchies. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3(1) </volume> <pages> 67-99, </pages> <year> 1990. </year>
Reference-contexts: Adjusting the programming languages so that these models become fully abstract leads to the surprising re-discovery of first-class prompts: We had earlier suggested the inclusion of prompts in languages with control structures but for entirely different reasons <ref> [8, 23] </ref>. The full abstraction theorem for the conventional continuation model also verifies a conjecture by Meyer and Riecke [18:65]. The following section introduces Pcf v -c, an extension of a call-by-value variant of Pcf [21] with a sophisticated control structure. <p> However, the model distinguishes them by applying the denotation of M 0 and M 1 to s m:inL (strip (m0)): To fix this problem, we augment the language with a control delimiter or prompt <ref> [8, 23] </ref>. A prompt-expression, %M , runs its sub-expression M as an independent program insofar as control action is concerned. Aborts cannot extend beyond the dynamically closest prompt. <p> To establish an analogous relationship, languages with control require a control delimiter to express all sequential aspects of their models. This extension is also supported by practical evidence. Our own investigation of control de-limiters found them to yield several useful programming paradigms for languages like Scheme <ref> [8, 23] </ref>; Danvy and Filinski [4] describe other interesting uses of prompt and related concepts. Recently, Hieb and Dybvig [16] argued for an extension of prompt, called spawn, as a crucial programming tool for concurrent systems with control operators. <p> Thus, on the strength of both denotational completeness and practical utility, the prompt merits consideration for inclusion in sequential languages with control facilities, whether first- or higher-order. 4 With side-effects and an eval function, it is possible to simulate prompt in Scheme <ref> [23] </ref>. In conclusion, with the right extensions, a Lisp-or Scheme-like language not only increases its power as a programming language, but, just like purely functional languages, becomes a genuine mathematical reasoning system based on the fully abstract model. Acknowledgment.
Reference: [24] <author> G.L. Steele Jr. </author> <title> Common Lisp|The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: 1 The Control Structure of Lisp Many programming languages, in particular Lisp <ref> [17, 24] </ref> and Scheme [22, 26], contain sophisticated control structures with constructs for labeling the control state at an arbitrary point for later reuse. <p> Some of the above language extensions are already present in Lisp and Scheme, though not always in their most general form. In traditional Lisp, the first-order combination of prompt and A occurs as errset and error. Common Lisp <ref> [24] </ref> no longer provides a facility like errset, i.e., it misses a control delimiter for error; its catch mechanism is sufficient as a prompt for control actions by throw. Scheme has higher-order continuations based on call/cc but also lacks a control delimiter. 4 Neither programming language has deterministic parallelism.
Reference: [25] <author> C. </author> <title> Strachey and C.P. Wadsworth. Continuations: A mathematical semantics for handling full jumps. </title> <type> Technical Report PRG-11, </type> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <year> 1974. </year>
Reference-contexts: The traditional model for such languages is the CPS (continuation-passing style) model <ref> [25] </ref>. The ground domain D remains the traditional cpo of natural numbers, but the domains for arrow types are no longer simple function spaces.
Reference: [26] <author> G.J. Sussman and G.L. Steele Jr. </author> <title> Scheme: An interpreter for extended lambda calculus. </title> <type> Memo 349, </type> <institution> MIT AI Lab, </institution> <year> 1975. </year>
Reference-contexts: 1 The Control Structure of Lisp Many programming languages, in particular Lisp [17, 24] and Scheme <ref> [22, 26] </ref>, contain sophisticated control structures with constructs for labeling the control state at an arbitrary point for later reuse. <p> Our second control extension, the K-expression of the form KM , provides more interesting possibilities for control manipulations than A. The programming language Scheme <ref> [22, 26] </ref> provides the equivalent of K-expressions with the procedure call-with-current-continuation or call/cc. A limited version of K is provided by the goto-construct and labels of Algol-like languages, the catch/throw or errset/error mechanism of traditional Lisp systems, and the exception handlers of ML [19]. <p> When it is invoked, evaluation reinstates the captured context in place of the current one, and fills it with the continuation's argument. It is easy to simulate other non-local control actions in terms of K <ref> [5, 12, 14, 15, 26] </ref>. A K-expression can occur anywhere inside a program; thus it can have any type s. Also, the program can invoke the continuation anywhere, but the latter's argument must be of the same type as the K-expression.
Reference: [27] <author> C. Talcott. </author> <title> The Essence of Rum|A Theory of the Intensional and Extensional Aspects of Lisp-type Computation. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1985. </year>
Reference-contexts: Moreover, by incorporating explicit statements about the control behavior, a program provides clues to the compiler for possible optimizations. However, control constructs also invalidate some common laws of reasoning that hold for functional programming languages like pure Lisp <ref> [6, 18, 27] </ref>. More technically, the operational equivalence relation for the functional subset of Lisp is not a subset of the operational equivalence relation for Lisp with control facilities. Given the importance of operational equivalence laws for reasoning about programs, this raises two crucial questions: 1. <p> Given the importance of operational equivalence laws for reasoning about programs, this raises two crucial questions: 1. How can we reason with control facilities? 2. How can we relate the reasoning system for functional languages to the system for ex tended languages with control facilities? Talcott's <ref> [27, 28] </ref> and our own [6, 7, 11] results on functional languages with first-class control abstractions provide a partial answer to the first question. 1 There is a small number of fundamental laws for the operational equivalence relation of such languages that play a crucial role in equivalence 1 The recent
Reference: [28] <author> C. Talcott. Rum: </author> <title> An intensional theory of function and control abstractions. </title> <booktitle> In Proc. 1987 Workshop on Foundations of Logic and Functional Programming. Springer Lecture Notes 306, </booktitle> <year> 1988. </year>
Reference-contexts: Given the importance of operational equivalence laws for reasoning about programs, this raises two crucial questions: 1. How can we reason with control facilities? 2. How can we relate the reasoning system for functional languages to the system for ex tended languages with control facilities? Talcott's <ref> [27, 28] </ref> and our own [6, 7, 11] results on functional languages with first-class control abstractions provide a partial answer to the first question. 1 There is a small number of fundamental laws for the operational equivalence relation of such languages that play a crucial role in equivalence 1 The recent
References-found: 28

