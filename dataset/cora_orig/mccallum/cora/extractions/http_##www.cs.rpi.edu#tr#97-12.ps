URL: http://www.cs.rpi.edu/tr/97-12.ps
Refering-URL: http://www.cs.rpi.edu/tr/
Root-URL: http://www.cs.rpi.edu
Email: fgasth,loosg@informatik.uni-tuebingen.de  schupp@cs.rpi.edu  
Title: Completing the Compilation of SuchThat v0.7  
Author: H. Gast S.Schupp R.Loos 
Note: 1 On leave of absence from the  
Address: Germany  
Affiliation: Wilhelm-Schickard-Institut fur Informatik Universitat Tubingen,  Department of Computer Science Rensselaer Polytechnic Institute  university of Tubingen  
Abstract-found: 0
Intro-found: 1
Reference: [1] <institution> Revised 4 Report on the Algorithmic Language Scheme, </institution> <year> 1991. </year>
Reference-contexts: Before we describe the latter part, we would like to give the reader an impression of the translation process as a whole and highlight the connecting points that had been specified beforehand. The translator itself is mostly written in Scheme <ref> [1] </ref> and most naturally also the intermediate representation of the SuchThat program have the form of Scheme lists. <p> Truly recursive lists, i.e. patterns that are named and used within themselves, would lead to circular structures. The answer to our problem is lazy evaluation, meaning that references inside of a pattern to the same pattern are expanded only when needed. The delay and force concept (see <ref> [1, Sec.6.9] </ref> is not applicable however, since there is no predicate such as delayed-object? in the Scheme standard.
Reference: [2] <author> Herold Abelson and Gerald Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Why we need such a recursive understanding of substitutions is best explained by giving a comprehensive example. The writing style might remind the reader of Louis Reasoner <ref> [2] </ref> and the compiler corrects his mistakes. Bindings Let us start with this problem: We want to write a function BubbleSort which can deal with finite sequences, sorting them in ascending order.
Reference: [3] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D Ullman. </author> <booktitle> Compilers, principles, techniques, and tools. </booktitle> <address> Reading, Mass. </address> : <publisher> Addison-Wesley Pub. Co., </publisher> <year> 1986. </year>
Reference: [4] <author> T. P. Baker. </author> <title> A one-pass algorithm for overload resolution in Ada. </title> <journal> ACM Transactions on Programming Languages and Sytems, </journal> <volume> 4(4) </volume> <pages> 601-614, </pages> <month> October </month> <year> 1982. </year>
Reference: [5] <author> Preston Briggs. </author> <title> nuweb a simple literate programming tool. </title> <address> preston@cs.rice.edu, </address> <month> May </month> <year> 1989. </year>
Reference: [6] <author> Harald Ganziger and Knuth Ripken. </author> <title> Operator identification in Ada: Formal specification, complexity, and concrete implementation. </title> <journal> ACM SIGPLAN Notices, </journal> <pages> pages 30-42, </pages> <month> Feb. </month> <year> 1980. </year>
Reference: [7] <author> Holger Gast. </author> <title> With scheme from SuchThat to c++. </title> <publisher> Studienarbeit, </publisher> <year> 1997. </year>
Reference: [8] <author> Leslie Lamport. </author> <title> L A T E X: A Document Preparation System. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference: [9] <author> Rudiger Loos. </author> <title> A SuchThat Translator to Scheme, 1997. </title> <type> Internal Report. </type>
Reference-contexts: For this implementation, conventional tools, i.e. flex ++ and bison ++ , have been used to translate the SuchThat source into its intermediate representation. <ref> [9] </ref> contains the technical details. As a broad summary we can say that the task of parsing a formalized, yet almost natural, language, yields the expected problems when specified as a LALR (1) grammar. <p> that basically, the sections differ only in the handle procedure to be called. 3.5.2 The Algorithm Body staa passes the body of an algorithm definition unchanged and so the grammar for the input is derived from the description of the parser in the paper A Translator SuchThat to Scheme (see <ref> [9] </ref>). All we have to do is an almost literal translation of the bison ++ rules into our pattern language. <p> They are evaluated in the function second-pass. Now that we have the special expression types defined, we may describe the structure of a statement very close to the input grammar as presented in <ref> [9] </ref>. hdefine the structure of a statement 24bi (define statement-structure `(,unchanged (once ; Anything without a tag is a normal ; Scheme function call ,(lambda (x) (report 2 "Found statement-level function call " x) (handle-expression x)) ("list" ; the parser generated return value ,(lambda (x) (let ((ret houtput adjust: parser generated
Reference: [10] <author> Rudiger Loos and Sibylle Schupp. </author> <title> Associating SuchThat Structures with their Attributes. </title> <type> Internal Report, </type> <year> 1997. </year>
Reference-contexts: An example is: Let T be a group, T is commutative. Here commutative is an attribute of T . Since these expressions are clearly context sensitive, they cannot be directly incorporated into a LALR (1) parser. staa <ref> [10] </ref> associates the attribute commutative with T and expresses their relation in the closed form 5 (with T commutative) 1.5 The Type Checker - sttype A major part of this report is concerned with the type-checking process which guarantees type-safe calls to generic functions.
Reference: [11] <author> Rudiger Loos and Sibylle Schupp. </author> <title> An implementation of structure implication sequents. </title> <type> Internal Report, </type> <year> 1997. </year>
Reference: [12] <author> Sibylle Schupp. </author> <title> Generic Programming - SuchThat One Can Build an Algebraic Library. </title> <type> PhD thesis, </type> <institution> University of Tubingen, </institution> <year> 1996. </year>
Reference: [13] <author> Sibylle Schupp. </author> <title> Deciding structure implications. </title> <year> 1997. </year>
Reference-contexts: These examples also give a guideline for what has to be accomplished in incorporating the idea of bindings into the Gentzen system. 8.1 The Notion of instantiation Besides intuition, the implementation has to be based on the definitions given in <ref> [13] </ref> and be consistent with the calculus presented. However the interpretation of the structure declaration (see below) is not included in these definitions and the implementation cannot follow previous intentions here. The main idea of instantiation is a recursive structural matching between two structures S and T . <p> is a property of the (set) union of all sets bindings found in the individual matchings. * Attributes are treated the following way (we use the internal representation for easier display): Can we instantiate (with (sequence over Ring) finite) by (with (sequence over Integer) finite nonempty) The answer is (see <ref> [13] </ref>): Yes we can, as we can instantiate (without any bindings) sequence over Ring by sequence over Integer since the integers form a ring and furthermore the set ffiniteg is a subset of ffinite, nonemptyg. 8.2 Semantics of Structure Declarations In section 5.3 we have introduced a declaration for structures. <p> Enter the given implication to the file. If the implication does not hold, change the #t to #f. "Instantiation failed because of missing attributes" When instantiating attributed structures like (with T B) by (with S A) then according to <ref> [13] </ref> it is sufficient to demand that S must be an instance of T and B be a subset of identifiers of A.
Reference: [14] <author> Sibylle Schupp. </author> <title> Processing SuchThat declarations. </title> <type> Internal Report, </type> <month> May </month> <year> 1997. </year>
Reference: [15] <author> Alexander Stepanov and Meng Lee. </author> <title> The Standard Template Library. </title> <publisher> Hewlett-Packard Company, </publisher> <address> Palo Alto, </address> <year> 1995. </year>
Reference: [16] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addidson-Wesley Publishing Company, </publisher> <address> 2nd edition, </address> <year> 1991. </year>
Reference: [17] <author> Holger Szillat. </author> <title> Finding the SuchThat-Expressions to Statically type-check. </title> <publisher> Studienarbeit, </publisher> <year> 1997. </year>
Reference: [18] <author> Roland Weiss. </author> <title> ScmToCpp : A configurable, intelligent back end for SuchThat. </title> <address> Diplomarbeit, </address> <year> 1997. </year>
Reference-contexts: It is intended that the underlying library will use STL containers to implement the representations for the SuchThat structures; these containers and algorithms will also be available to the user. The major challenges scm2cpp <ref> [18] </ref> had to cope with are the flexible generation of type-expressions, in particular the generation of (template) function headers.
References-found: 18

