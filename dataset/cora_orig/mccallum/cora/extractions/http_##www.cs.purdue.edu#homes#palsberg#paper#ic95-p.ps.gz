URL: http://www.cs.purdue.edu/homes/palsberg/paper/ic95-p.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: palsberg@theory.lcs.mit.edu  
Title: Efficient Inference of Object Types  
Author: Jens Palsberg 
Address: NE43-340 545 Technology Square Cambridge, MA 02139  
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Note: Information and Computation, 123(2):198-209, 1995.  
Abstract: Abadi and Cardelli have recently investigated a calculus of objects [2]. The calculus supports a key feature of object-oriented languages: an object can be emulated by another object that has more refined methods. Abadi and Cardelli presented four first-order type systems for the calculus. The simplest one is based on finite types and no subtyping, and the most powerful one has both recursive types and subtyping. Open until now is the question of type inference, and in the presence of subtyping "the absence of minimum typings poses practical problems for type inference" [2]. In this paper we give an O(n 3 ) algorithm for each of the four type inference problems and we prove that all the problems are P-complete. We also indicate how to modify the algorithms to handle functions and records. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Luca Cardelli. </author> <title> A semantics of object types. </title> <booktitle> In Proc. LICS'94, Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 332-341, </pages> <year> 1994. </year>
Reference-contexts: The simplest one is based on finite types and no subtyping, and the most powerful one has both recursive types and subtyping. The latter can type many intriguing object-oriented programs, including objects whose methods return an updated self [2], see also <ref> [4, 3, 1] </ref>. Open until now is the question of type inference: Given an untyped program a, is a typable? If so, annotate it. In the presence of subtyping "the absence of minimum typings poses practical problems for type inference" [2].
Reference: [2] <author> Martn Abadi and Luca Cardelli. </author> <title> A theory of primitive objects. </title> <type> Manuscript, </type> <month> February </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Abadi and Cardelli have recently investigated a calculus of objects <ref> [2] </ref>. The calculus supports a key feature of object-oriented languages: an object can 1 be emulated by another object that has more refined methods. <p> The calculus contains four constructions: variables, objects, method invocation, and method override. It is similar to the calculus of Mitchell, Honsell, and Fisher [20] in allowing method override, but it differs significantly in also allowing subsumption but not allowing objects to be extended with more methods. Abadi, Cardelli <ref> [2] </ref> Mitchell, Honsell, Fisher [20] Objects p p Method override p p Subsumption p Object extension p Abadi and Cardelli presented four first-order type systems for their calculus. The simplest one is based on finite types and no subtyping, and the most powerful one has both recursive types and subtyping. <p> The simplest one is based on finite types and no subtyping, and the most powerful one has both recursive types and subtyping. The latter can type many intriguing object-oriented programs, including objects whose methods return an updated self <ref> [2] </ref>, see also [4, 3, 1]. Open until now is the question of type inference: Given an untyped program a, is a typable? If so, annotate it. In the presence of subtyping "the absence of minimum typings poses practical problems for type inference" [2]. <p> objects whose methods return an updated self <ref> [2] </ref>, see also [4, 3, 1]. Open until now is the question of type inference: Given an untyped program a, is a typable? If so, annotate it. In the presence of subtyping "the absence of minimum typings poses practical problems for type inference" [2]. In this paper we give an O (n 3 ) algorithm for each of the four type inference problems and we prove that all the problems are P-complete. Choose: finite types or recursive types. Choose: subtyping or no subtyping. <p> The method l returns a modified self: o 00 :l ; (o 00 :l ( &(x)x) ; o 0 These three examples are taken from Abadi and Cardelli's paper <ref> [2] </ref>. Abadi and Cardelli demonstrate how to encode the pure -calculus in the &-calculus. Note the following difference between these two calculi. In pure -calculus no term yields an error; in the &-calculus for example [ ]:l yields an error. The reason is that objects are structured values. <p> The reason is that objects are structured values. In a -calculus with pairs, some terms yield errors, like in the &-calculus. 3 Type Rules The following type system for the &-calculus catches errors statically, that is, rejects all programs that may yield errors <ref> [2] </ref>. An object type is an edge-labeled regular tree. A tree is regular if it has finitely many distinct subtrees. Labels are drawn from some possibly infinite set N of method names. We represent a type as a non-empty, prefix-closed set of strings over N . <p> In Abadi and Cardelli's type system, [l : A; m : C] can only be a subtype of [l : B] if A = B. The conventional subtyping relation for records is unsound in the case of Abadi and Cardelli's calculus <ref> [2] </ref>. Even though the subtyping relation in Abadi and Cardelli's type system is smaller than the conventional one for record types, it yields a more complicated definition of closed AC-graphs, as illustrated in the following.
Reference: [3] <author> Martn Abadi and Luca Cardelli. </author> <title> A theory of primitive objects: Second-order systems. </title> <booktitle> In Proc. ESOP'94, European Symposium on Programming, </booktitle> <pages> pages 1-25. </pages> <publisher> Springer-Verlag (LNCS 788), </publisher> <year> 1994. </year>
Reference-contexts: The simplest one is based on finite types and no subtyping, and the most powerful one has both recursive types and subtyping. The latter can type many intriguing object-oriented programs, including objects whose methods return an updated self [2], see also <ref> [4, 3, 1] </ref>. Open until now is the question of type inference: Given an untyped program a, is a typable? If so, annotate it. In the presence of subtyping "the absence of minimum typings poses practical problems for type inference" [2].
Reference: [4] <author> Martn Abadi and Luca Cardelli. </author> <title> A theory of primitive objects: Untyped and first-order systems. </title> <booktitle> In Proc. TACS'94, Theoretical Aspects of Computing Sofware, </booktitle> <pages> pages 296-320. </pages> <publisher> Springer-Verlag (LNCS 789), </publisher> <year> 1994. </year>
Reference-contexts: The simplest one is based on finite types and no subtyping, and the most powerful one has both recursive types and subtyping. The latter can type many intriguing object-oriented programs, including objects whose methods return an updated self [2], see also <ref> [4, 3, 1] </ref>. Open until now is the question of type inference: Given an untyped program a, is a typable? If so, annotate it. In the presence of subtyping "the absence of minimum typings poses practical problems for type inference" [2].
Reference: [5] <author> Alexander Aiken and Edward Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proc. Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <year> 1993. </year>
Reference-contexts: In the presence of subtyping, unification-based approaches to type inference seem not to apply. Type inference for -calculi with records and subtyping has been studied by Eifrig, Smith, and Trifonov [9], using the approach to type inference of Aiken and Wimmers <ref> [5] </ref>. Their algorithm does not immediately apply to Abadi and Cardelli's calculus because of the following difference between the subtyping relations. For records, the conventional subtyping relations makes every record type constructor covariant in all arguments.
Reference: [6] <author> Marcin Benke. </author> <title> Efficient type reconstruction in the presence of inheritance. </title> <type> Manuscript, </type> <year> 1994. </year>
Reference-contexts: If (; ) is a disjoint union of lattices, then type inference is computable in polynomial time [23]. Moreover, if (; ) is "tree-like", then type inference is computable in polynomial time <ref> [6] </ref>. In general, the type inference problem is PSPACE - hard [14, 23]. Type inference with atomic subtyping has also been studied in combination with ML polymorphism [10, 11]. Objects do not have base types, so type inference with atomic subtyping does not apply to Abadi and Cardelli's calculus.
Reference: [7] <author> Ravi B. Boppana and Michael Sipser. </author> <title> The complexity of finite functions. </title> <editor> In J. van Leeuwen, A. Meyer, M. Nivat, M. Paterson, and D. Perrin, editors, </editor> <booktitle> Handbook of Theoretical Computer Science, volume A, chapter 14, </booktitle> <pages> pages 757-804. </pages> <publisher> Elsevier Science Publishers, Amsterdam; and MIT Press, </publisher> <year> 1990. </year> <month> 32 </month>
Reference-contexts: Thus, finding finite solutions to a SAC-system is P-hard. 24 We then consider finding arbitrary solutions to SAC-systems. A mono-tone circuit <ref> [7] </ref> is a directed acyclic graph G whose nodes, called gates, are of five different kinds: 1. input gates with no in-edge and one out-edge; 2. and-gates with two in-edges and one out-edge; 3. or-gates with two in-edges and one out-edge; 4. fan-out gates with one in-edge and two out-edges; and
Reference: [8] <author> C. Dwork, P. Kanellakis, and J. Mitchell. </author> <title> On the sequential nature of unifi-cation. </title> <journal> Journal of Logic Programming, </journal> <volume> 1 </volume> <pages> 35-50, </pages> <year> 1984. </year>
Reference-contexts: The construction is adapted from Henglein's proof of P-hardness of left-linear semi-unification [13]. That proof, in turn, is adapted from Dwork, Kanellakis, and Mitchell's proof of P-hardness of unification <ref> [8] </ref>. 25 Given a monotone circuit and an assignment to input gates, we construct an SAC-graph as follows. Each gate in the circuit yields a small "gadget" consisting of a few nodes and edges.
Reference: [9] <author> J. Eifrig, S. Smith, and V. Trifonov. </author> <title> Type inference for recursively constrained types and it application to OOP. </title> <booktitle> In Proc. Mathematical Foundations of Programming Semantics, </booktitle> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: Type inference for -calculi with records but no subtyping has been studied by Wand [24] and Remy [22]. In the presence of subtyping, unification-based approaches to type inference seem not to apply. Type inference for -calculi with records and subtyping has been studied by Eifrig, Smith, and Trifonov <ref> [9] </ref>, using the approach to type inference of Aiken and Wimmers [5]. Their algorithm does not immediately apply to Abadi and Cardelli's calculus because of the following difference between the subtyping relations. For records, the conventional subtyping relations makes every record type constructor covariant in all arguments. <p> The proof that Theorem 6.5 holds is left as an exercise for the reader. In remains to be seen how to extend our algorithm to deal with ML polymorphism. 11 Conclusion The type inference problems we have addressed are related to those treated by Eifrig, Smith, and Trifonov <ref> [9] </ref>. Specifically, our algorithm can be modified to handle functions and records, and it seems possible to modify their algorithm to handle the object calculus. The results of the two approaches appear to be complimentary.
Reference: [10] <author> You-Chin Fuh and Prateek Mishra. </author> <title> Type inference with subtypes. </title> <booktitle> In Proc. ESOP'88, European Symposium on Programming, </booktitle> <pages> pages 94-114. </pages> <publisher> Springer-Verlag (LNCS 300), </publisher> <year> 1988. </year>
Reference-contexts: Moreover, if (; ) is "tree-like", then type inference is computable in polynomial time [6]. In general, the type inference problem is PSPACE - hard [14, 23]. Type inference with atomic subtyping has also been studied in combination with ML polymorphism <ref> [10, 11] </ref>. Objects do not have base types, so type inference with atomic subtyping does not apply to Abadi and Cardelli's calculus. The object types considered 29 in this paper are rather like record types.
Reference: [11] <author> You-Chin Fuh and Prateek Mishra. </author> <title> Polymorphic subtype inference: Closing the theory-practice gap. </title> <booktitle> In Proc. TAPSOFT'89, </booktitle> <pages> pages 167-183. </pages> <publisher> Springer-Verlag (LNCS 352), </publisher> <year> 1989. </year>
Reference-contexts: Moreover, if (; ) is "tree-like", then type inference is computable in polynomial time [6]. In general, the type inference problem is PSPACE - hard [14, 23]. Type inference with atomic subtyping has also been studied in combination with ML polymorphism <ref> [10, 11] </ref>. Objects do not have base types, so type inference with atomic subtyping does not apply to Abadi and Cardelli's calculus. The object types considered 29 in this paper are rather like record types.
Reference: [12] <author> Fritz Henglein. </author> <title> Simple type inference and unification. </title> <type> Technical Report (SETL Newsletter) 232, </type> <institution> Courant Institute of Mathematical Sciences, </institution> <address> New York University, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: These two results are obtained by reductions of simple type inference for -calculus, and of the monotone circuit value problem, respectively, as explained in the following. We first consider finding finite solutions to SAC-systems. Simple type inference for -calculus is P-complete under log space reductions <ref> [12] </ref>. It is log space equivalent to finding finite solutions to a finite set of equations of the forms V = V 0 ! V 00 or V = C, where V; V 0 ; V 00 are variables, and C is a constant.
Reference: [13] <author> Fritz Henglein. </author> <title> Fast left-linear semi-unification. </title> <booktitle> In Proc. ICCI'90, International Conference on Computing and Information, </booktitle> <pages> pages 82-91. </pages> <publisher> Springer-Verlag (LNCS 468), </publisher> <year> 1990. </year>
Reference-contexts: It is P-complete under log-space reductions [16]. We will now give a log space reduction of the monotone circuit value problem to the problem of finding arbitrary solutions to SAC-graphs. The construction is adapted from Henglein's proof of P-hardness of left-linear semi-unification <ref> [13] </ref>. That proof, in turn, is adapted from Dwork, Kanellakis, and Mitchell's proof of P-hardness of unification [8]. 25 Given a monotone circuit and an assignment to input gates, we construct an SAC-graph as follows.
Reference: [14] <author> My Hoang and John C. Mitchell. </author> <title> Lower bounds on type inference with sub-types. </title> <booktitle> In Proc. POPL'95, 22nd Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 176-185, </pages> <year> 1995. </year>
Reference-contexts: If (; ) is a disjoint union of lattices, then type inference is computable in polynomial time [23]. Moreover, if (; ) is "tree-like", then type inference is computable in polynomial time [6]. In general, the type inference problem is PSPACE - hard <ref> [14, 23] </ref>. Type inference with atomic subtyping has also been studied in combination with ML polymorphism [10, 11]. Objects do not have base types, so type inference with atomic subtyping does not apply to Abadi and Cardelli's calculus.
Reference: [15] <author> G. F. </author> <title> Italiano. Amortized efficiency of a path retrieval data structure. </title> <journal> Theoretical Computer Science, </journal> <volume> 48 </volume> <pages> 273-281, </pages> <year> 1986. </year>
Reference-contexts: The insert operation returns a list of all edges that have been added, represented as node pairs. Initialization and maintenance of ITC can be done in O (n 3 ) time, where n is the number of nodes <ref> [15, 21] </ref>. 2. PE: a data structure with potential edges. This data structure is computed in a preprocessing phase. It is a matrix of the same form as the adjacency matrix, but with each entry being a list of pairs of 21 nodes.
Reference: [16] <author> Richard M. Karp and Vijaya Ramachandran. </author> <title> Parallel algorithms for shared-memory machines. </title> <editor> In J. van Leeuwen, A. Meyer, M. Nivat, M. Paterson, and D. Perrin, editors, </editor> <booktitle> Handbook of Theoretical Computer Science, volume A, chapter 17, </booktitle> <pages> pages 869-941. </pages> <publisher> Elsevier Science Publishers, Amsterdam; and MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The monotone circuit value problem <ref> [16] </ref> is the problem of deciding, given a monotone circuit G and an assignment a to the input gates of G, whether a (n) = true for the output gate n. It is P-complete under log-space reductions [16]. <p> The monotone circuit value problem <ref> [16] </ref> is the problem of deciding, given a monotone circuit G and an assignment a to the input gates of G, whether a (n) = true for the output gate n. It is P-complete under log-space reductions [16]. We will now give a log space reduction of the monotone circuit value problem to the problem of finding arbitrary solutions to SAC-graphs. The construction is adapted from Henglein's proof of P-hardness of left-linear semi-unification [13].
Reference: [17] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient inference of partial types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 49(2) </volume> <pages> 306-324, </pages> <year> 1994. </year> <note> Also in Proc. </note> <editor> FOCS'92, </editor> <booktitle> 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 363-371, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Finally, in Section 10 we discuss related work and possible extensions. The reader is encouraged to refer to the examples while reading the other sections. Our approach to type inference is related to that of Kozen, Schwartzbach, and the present author in <ref> [17] </ref>. Although the problems that we solve here are much different from that solved in [17], the two approaches have the same ingredients: constraints, graphs, and automata. We have produced a prototype implementation in Scheme of the most powerful of our type inference algorithms. <p> The reader is encouraged to refer to the examples while reading the other sections. Our approach to type inference is related to that of Kozen, Schwartzbach, and the present author in <ref> [17] </ref>. Although the problems that we solve here are much different from that solved in [17], the two approaches have the same ingredients: constraints, graphs, and automata. We have produced a prototype implementation in Scheme of the most powerful of our type inference algorithms. Experiments have been carried out on a SPARCserver 1000 (with four SuperSPARC processors) running Scm version 4e1. <p> Our algorithms can easily be extended to handle also -terms and a con-travariant function space constructor, in outline as follows. The constraints for -terms are as usual (see for example <ref> [17] </ref>). The definition of AC-graph needs to be extended with a set N ! of nodes and a set E ! of edges. <p> The extra checks can be done in O (n 2 ) time where n is the number of nodes. Given proper definitions of the new set of types and the new relation (along the lines of <ref> [17] </ref>), it should be possible to prove that Theorem 6.5 holds. For the program (x)((x:a)x), the most powerful of the type inference algorithms infers that x has the -least annotation [a : [ ] ! [ ]].
Reference: [18] <author> Bent B. Kristensen, Ole Lehrmann Madsen, Birger Mtller-Pedersen, and Kris-ten Nygaard. </author> <title> The BETA programming language. </title> <editor> In Bruce Shriver and Peter 33 Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 7-48. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: The order of the components does not matter. In a method &(x)b, we have that x is the self variable and b is the body. Thus, in the body of a method we can refer to any enclosing object, like in the Beta language <ref> [18] </ref>. The reduction rules for &-terms are as follows.
Reference: [19] <author> John Mitchell. </author> <title> Coercion and type inference. </title> <booktitle> In Eleventh Symposium on Principles of Programming Languages, </booktitle> <pages> pages 175-185, </pages> <year> 1984. </year>
Reference-contexts: The type rules are those of simply typed -calculus with typed constants together with the subsumption rule. The type inference problem is to decide if a given -term is typable. This problem was introduced by Mitchell in 1984 <ref> [19] </ref> who showed that type inference is computable in NEXPTIME in the size of the program. If (; ) is a disjoint union of lattices, then type inference is computable in polynomial time [23]. Moreover, if (; ) is "tree-like", then type inference is computable in polynomial time [6].
Reference: [20] <author> John C. Mitchell, Furio Honsell, and Kathleen Fisher. </author> <title> A lambda calculus of objects and method specialization. </title> <booktitle> In LICS'93, Eighth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 26-38, </pages> <year> 1993. </year>
Reference-contexts: This phenomenon is called subsumption. The calculus contains four constructions: variables, objects, method invocation, and method override. It is similar to the calculus of Mitchell, Honsell, and Fisher <ref> [20] </ref> in allowing method override, but it differs significantly in also allowing subsumption but not allowing objects to be extended with more methods. Abadi, Cardelli [2] Mitchell, Honsell, Fisher [20] Objects p p Method override p p Subsumption p Object extension p Abadi and Cardelli presented four first-order type systems for <p> It is similar to the calculus of Mitchell, Honsell, and Fisher <ref> [20] </ref> in allowing method override, but it differs significantly in also allowing subsumption but not allowing objects to be extended with more methods. Abadi, Cardelli [2] Mitchell, Honsell, Fisher [20] Objects p p Method override p p Subsumption p Object extension p Abadi and Cardelli presented four first-order type systems for their calculus. The simplest one is based on finite types and no subtyping, and the most powerful one has both recursive types and subtyping.
Reference: [21] <author> J. A. La Poutre and J. van Leeuwen. </author> <title> Maintenance of transitive closure and transitive reduction of graphs. </title> <booktitle> In Proc. Workshop on Graph-Theoretic Concepts in Computer Science, </booktitle> <pages> pages 106-120. </pages> <publisher> Springer-Verlag (LNCS 314), </publisher> <year> 1988. </year>
Reference-contexts: The insert operation returns a list of all edges that have been added, represented as node pairs. Initialization and maintenance of ITC can be done in O (n 3 ) time, where n is the number of nodes <ref> [15, 21] </ref>. 2. PE: a data structure with potential edges. This data structure is computed in a preprocessing phase. It is a matrix of the same form as the adjacency matrix, but with each entry being a list of pairs of 21 nodes.
Reference: [22] <author> Didier Remy. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> In Sixteenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 77-88, </pages> <year> 1989. </year>
Reference-contexts: The object types considered 29 in this paper are rather like record types. Type inference for -calculi with records but no subtyping has been studied by Wand [24] and Remy <ref> [22] </ref>. In the presence of subtyping, unification-based approaches to type inference seem not to apply. Type inference for -calculi with records and subtyping has been studied by Eifrig, Smith, and Trifonov [9], using the approach to type inference of Aiken and Wimmers [5].
Reference: [23] <author> Jerzy Tiuryn. </author> <title> Subtype inequalities. </title> <booktitle> In LICS'92, Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 308-315, </pages> <year> 1992. </year>
Reference-contexts: This problem was introduced by Mitchell in 1984 [19] who showed that type inference is computable in NEXPTIME in the size of the program. If (; ) is a disjoint union of lattices, then type inference is computable in polynomial time <ref> [23] </ref>. Moreover, if (; ) is "tree-like", then type inference is computable in polynomial time [6]. In general, the type inference problem is PSPACE - hard [14, 23]. Type inference with atomic subtyping has also been studied in combination with ML polymorphism [10, 11]. <p> If (; ) is a disjoint union of lattices, then type inference is computable in polynomial time [23]. Moreover, if (; ) is "tree-like", then type inference is computable in polynomial time [6]. In general, the type inference problem is PSPACE - hard <ref> [14, 23] </ref>. Type inference with atomic subtyping has also been studied in combination with ML polymorphism [10, 11]. Objects do not have base types, so type inference with atomic subtyping does not apply to Abadi and Cardelli's calculus.
Reference: [24] <author> Mitchell Wand. </author> <title> Type inference for record concatenation and multiple inheritance. </title> <booktitle> In LICS'89, Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 92-97, </pages> <year> 1989. </year> <month> 34 </month>
Reference-contexts: Objects do not have base types, so type inference with atomic subtyping does not apply to Abadi and Cardelli's calculus. The object types considered 29 in this paper are rather like record types. Type inference for -calculi with records but no subtyping has been studied by Wand <ref> [24] </ref> and Remy [22]. In the presence of subtyping, unification-based approaches to type inference seem not to apply. Type inference for -calculi with records and subtyping has been studied by Eifrig, Smith, and Trifonov [9], using the approach to type inference of Aiken and Wimmers [5].
References-found: 24

