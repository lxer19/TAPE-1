URL: ftp://ftp.cs.brown.edu/pub/techreports/95/cs95-04.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-95-04.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Aggarwal and J. Park, </author> <title> "Notes on searching multidimensional monotone arrays," </title> <booktitle> Proc. 29th Annual IEEE Symposium on Foundations of Computer Science (1988), </booktitle> <pages> 496-512. </pages>
Reference-contexts: A CRCW version of this algorithm runs in time O (log 2 n log log n) and uses n= log log n processors. We also show how to improve our algorithm by using some techniques of <ref> [1] </ref> and [6] to improve the time bound to O (log 2 n) in the CREW 109 model and O (log n log log n) in the CRCW model. 1 The processor bounds still remain as n= log n for the CREW model and n= log log n for the CRCW <p> The problem of determining the value of fi was formalized by Aggarwal and Park as the tube minima problem and has many applications in computational geometry <ref> [1] </ref>. They give the following bounds for calculating the tube minima of an p p p n array: Theorem 17 The tube minima of an p p p n array can be found in time O (log n) and work O (n) in a CREW PRAM.
Reference: [2] <author> A. Aho, J. Hopcroft, and J. Ullman, </author> <title> The design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: Unless otherwise stated, n and m denote, respectively the number of nodes and the number of edges in the graph under consideration. 7 1.3.1 Models of computation In sequential and dynamic settings we use a standard random-access-memory (RAM) model of computation <ref> [2] </ref>. In the parallel setting we use the PRAM [60] or the parallel random-access-memory model of computation. Different algorithms use different PRAM models. However, unless otherwise stated the parallel algorithms presented assume an ARBITRARY CRCW PRAM as the underlying model of computation.
Reference: [3] <author> R. Ahuja, K. Mehlhorn, J. Orlin, and R. E. Tarjan, </author> <title> "Faster algorithms for the shortest path problem," </title> <journal> Journal of the Association for Computing Machinery 37 (1990), </journal> <pages> 213-223. </pages>
Reference: [4] <author> N. Alon, P. Seymour, and R. Thomas, </author> <title> "A separator theorem for graphs with an excluded minor and its applications," </title> <booktitle> Proc. 22nd Annual ACM Symposium on Theory of Computing (1990), </booktitle> <pages> 293-299. </pages>
Reference-contexts: Several families of graphs have such separators of size O ( p n) where n is the number of nodes in the graph. Examples include planar graphs [74], bounded-genus graphs [43], two-dimensional overlap graphs [78], and graphs excluding a fixed graph as a minor <ref> [4] </ref>. Of these families, for all but the last there are polylog-time parallel algorithms for finding such separators.
Reference: [5] <author> A. Apostolico, M. J. Atallah, L. Larmore, and H. S. Mcfaddin, </author> <title> "Efficient parallel algorithms for string editing and related problems ," SIAM Journal on Computing 19 (1990), </title> <type> 968-988. </type>
Reference-contexts: For the class of planar layered digraphs the specialized algorithm performs much better than the algorithm for general planar digraphs presented in Chapter 4. Our algorithm for planar layered digraphs generalizes a similar algorithm presented for grid digraphs in <ref> [5] </ref>. <p> A division of G into one or more pieces is a one-way division if the separator X used to divide G is a one-way separator. Grid digraphs, for instance, have one-way separators of size O ( p n) that 1=2-split the graph. In fact the shortest-path algorithm in <ref> [5] </ref> uses such separators to construct a divide-and-conquer solution. In Chapter 5 our main result is that planar layered digraphs also admit small one-way separators. <p> A grid digraph has the vertices arranged in a rectangular grid and the edges directed 108 from left to right and from bottom to top (an example is shown in Figure 5.1). Apos-tolico et al. <ref> [5] </ref> gave an algorithm to compute shortest paths in a grid in O (log 2 n) time with O (n) processors. The shortest path problem on grid digraphs has applications in text processing, biological research, tomography and medical diagnosis. <p> This can be done in constant time with jSj processors in a CRCW PRAM. However, a little thought reveals that such a naive approach would require too many processors. We first use an idea from <ref> [5] </ref> to show that the all-pairs shortest paths from vertices in S to vertices in T can be computed in log 2 n time with n p = log n processors. We make use of the following definition and lemma.
Reference: [6] <author> M.J. Atallah, </author> <title> "A faster parallel algorithm for a matrix searching problem," </title> <booktitle> Proc. 2nd Scandinavian Workshop on Algorithm Theory (1990), </booktitle> <pages> 193-200. </pages>
Reference-contexts: A CRCW version of this algorithm runs in time O (log 2 n log log n) and uses n= log log n processors. We also show how to improve our algorithm by using some techniques of [1] and <ref> [6] </ref> to improve the time bound to O (log 2 n) in the CREW 109 model and O (log n log log n) in the CRCW model. 1 The processor bounds still remain as n= log n for the CREW model and n= log log n for the CRCW model. <p> Similarly for the CRCW model of computation Atallah <ref> [6] </ref> has given an algorithm with following bounds: Theorem 18 The tube minima of an p p p n array can be found in time O (log log n) and work O (n) in a CRCW PRAM. 123 Using these algorithms in the patchup stage we can improve our bounds to
Reference: [7] <author> G. Ausiello, G.F. Italiano, A. Marchetti-Spaccamela, and U. Nanni, </author> <title> "Incremental algorithms for minimal length paths," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1990), </booktitle> <pages> 12-21. 142 </pages>
Reference-contexts: See [28,30,36,37] for fully dynamic data structures to various graph problems. See [81] for a complexity theoretic approach to dynamic computation. As we discussed in Chapter 1 the shortest-path problem is not very well understood in the dynamic realm. Though there are many algorithms for the dynamic problem <ref> [7, 24,27,33] </ref>, none of them can simultaneously handle both updates and queries in time that is sublinear in the input size. We say that a path is an *-approximate shortest-path if its length is at most 1 + * times the distance between its endpoints.
Reference: [8] <author> B. S. Baker, </author> <title> "Approximation algorithms for NP-complete problems on planar graphs," </title> <booktitle> Proc. 24th Annual IEEE Symposium on Foundations of Computer Science (1983), </booktitle> <pages> 265-273. </pages>
Reference-contexts: Their algorithm can also be used to find separators of size O ( p n polylog n) using only n processors. Indeed, we use this in our algorithm. Another application of parallel breadth-first search is in implementing in parallel a method due to Baker <ref> [8] </ref> for approximation schemes for a variety of problems in planar graphs. Her method involves doing a breadth-first search on a graph derived from the planar input graph. Since the graph still has small separators, our method applies.
Reference: [9] <author> H. Bast, M. Dietzfelbinger, and T. Hagerup, </author> <title> "A perfect parallel dictionary," </title> <booktitle> Symposium on Mathematical Foundations of Computer Science (1992). </booktitle>
Reference-contexts: When multiple processors attempt to write in the same location an arbitrarily chosen processor succeeds. For the algorithm presented in Chapter 3 we assume a model of parallel computation called the OR CRCW PRAM <ref> [9] </ref> in which multiple processors can simultaneously read and write to a shared memory. If multiple processors attempt to write multiple values to a single location, the value written is the bitwise OR of the values.
Reference: [10] <author> R. Bellman, </author> <title> "On a routing problem," </title> <booktitle> Quarterly of Applied Mathematics 16 (1958), </booktitle> <pages> 87-90. </pages>
Reference: [11] <author> G. Birkhoff, </author> <title> "Lattice Theory," </title> <publisher> American Mathematical Society Colloquium Publications 25 (1979). </publisher>
Reference: [12] <author> A.L. Buchsbaum, P.C. Kanellakis, and J.S. Vitter, </author> <title> "A data structure for arc insertion and regular path finding," </title> <booktitle> Proc. ACM-SIAM Symp. on Discrete Algorithms (1990), </booktitle> <pages> 22-31. </pages>
Reference: [13] <author> E. Cohen, </author> <title> "Fast algorithms for constructing t-spanners and paths with stretch t," </title> <booktitle> Proc. 34th Annual IEEE Symposium on Foundations of Computer Science (1993). </booktitle>
Reference: [14] <author> E. Cohen, </author> <title> "Efficient parallel shortest-paths in digraphs with a separator decomposition," </title> <booktitle> Proc. 5th Annual Symposium on Parallel Algorithms and Architectures (1993), </booktitle> <pages> 57-67. </pages>
Reference-contexts: The best previously known polylog-time algorithm for single-source shortest paths in planar undirected graphs is that of Pan and Reif [82,83], which does ~ O (n 1:5 ) work. Cohen <ref> [14] </ref> has given an algorithm with similar bounds for the directed case. The previous bounds are no better for breadth-first search, the special case where every edge-length is one. Our shortest-path algorithm applied to planar graphs in particular has several further applications. <p> For undirected planar graphs, Pan and Reif [82,83] showed how to achieve O (n 3=2 ) time using separators. Cohen <ref> [14] </ref> showed how to achieve the same bound for directed planar graphs. Previously no algorithm handling negative lengths was known that ran faster than O (n 3=2 ). <p> If we are dealing with an undirected graph we can quickly find a representation that approximates the paths of accurately. This is done by running the Bellman-Ford shortest-path algorithm from the detour node x of P for k stages. As observed by Cohen <ref> [14] </ref>, running the Bellman-Ford algorithm for k stages is sufficient to find paths that contain k edges. 19 In a directed setting the approximation technique outlined in Figure 1.1 is invalid because the edges of P go only in one direction. <p> Cohen <ref> [14] </ref> has observed that the following variant of Bellman-Ford correctly computes shortest paths in this case. Set d (v) := 1 for each node v, except set d (source) := 0. Repeat the following step k times. <p> For example, given a decomposition tree, we can use our algorithm to find single-source shortest paths in constant-genus graphs. The best previously known polylog-time algorithm for single-source shortest paths in planar undirected graphs is that of Pan and Reif [82,83], which does ~ O (n 1:5 ) work. Cohen <ref> [14] </ref> has given an algorithm with similar bounds for the directed case. The previous bounds are no better for breadth-first search, the special case where every edge-length is one. As discussed in Chapter 1 our shortest-path algorithm applied to planar graphs in particular has several further applications. <p> To construct a graph that approximates shortest paths in the original graph we use similar but denser graphs on the separators. This idea was used by Lingas [71] in the context of breadth-first search and later by Cohen <ref> [14] </ref> for shortest-paths. However, in [14] the dense graphs on the separators were simply complete graphs where there was an direct edge uv representing the shortest path from u to v. <p> To construct a graph that approximates shortest paths in the original graph we use similar but denser graphs on the separators. This idea was used by Lingas [71] in the context of breadth-first search and later by Cohen <ref> [14] </ref> for shortest-paths. However, in [14] the dense graphs on the separators were simply complete graphs where there was an direct edge uv representing the shortest path from u to v. <p> For undirected planar graphs, Pan and Reif [82,83] showed how to achieve O (n 3=2 ) time using separators. Cohen <ref> [14] </ref> showed how to achieve the same bound for directed planar graphs. Previously no algorithm handling negative lengths was known that ran faster than O (n 3=2 ). <p> Such a compact graph can be easily constructed while performing a nested dissection computation (see Cohen <ref> [14] </ref>). For the sake of completeness we now give a brief account of how the nested-dissection (hereafter referred to as the ND-algorithm) algorithm can be used to compute all-boundary-pair shortest-paths and for computing the compact representation. <p> It is not hard to show that for any two nodes a and b in G ff there exists a shortest a-to-b path in C (G ff ) that contains O (log l) edges (see Cohen <ref> [14] </ref>). 133 procedure ShortPath (G) [The dividing step] 1. Use planar separators to find a k-cluster partition of G with subgraphs G 1 ; G 2 ; ; G k . 2. Mark s as a boundary node. [The nested dissection phase] for each subgraph G i do 1. <p> The correctness of our algorithm therefore follows. To bound the amount of time taken by our algorithm we note that in the nested dissection phase we need O (k 3=2 ) time for each subgraph in the cluster partition (see <ref> [14, 82,83] </ref>). Therefore, the time required to perform nested dissection in all the subgraphs is O (k 3=2 n k ).
Reference: [15] <author> E. Cohen, </author> <title> "Parallel algorithms with improved work for shortest-paths from multiple sources," </title> <booktitle> Proc. 2nd Israel Symposium on Theory of Computing and Systems (1993), </booktitle> <pages> 57-67. </pages>
Reference-contexts: Thus the path 0 consisting of ^sb and 2 0 is an O (log n)-size path that corresponds to a shortest s-to-u path in G. 135 Cohen <ref> [15] </ref> has observed that by running the Bellman-Ford algorithm for q-stages from a source s one can find all shortest-paths that have only q-edges.
Reference: [16] <author> E. Cohen, </author> <title> "Polylog-time and near-linear work approximation scheme for undi-rected shortest paths," </title> <booktitle> Proc. 26th Annual ACM Symposium on Theory of Computing (to appear). </booktitle> <year> (1994). </year>
Reference: [17] <author> R. Cole and U. Vishkin, </author> <title> "Optimal parallel algorithms for expression tree evaluation and list ranking ," Procedings of the third Agean Workshop on Computing: </title> <booktitle> (1988), </booktitle> <pages> 91-100. </pages>
Reference-contexts: a series-parallel digraph the weight of a shortest path between the source and the sink is obtained by evaluating an arithmetic expression with operators + (associated with series compositions) and min (associated with parallel compositions), which can be done optimally in O (log n) time with n= log n processors <ref> [17] </ref>. A grid digraph has the vertices arranged in a rectangular grid and the edges directed 108 from left to right and from bottom to top (an example is shown in Figure 5.1).
Reference: [18] <author> T. H. Cormen, C. E. Leiserson, and R. E. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> MIT Press, </publisher> <year> 1990. </year> <month> 143 </month>
Reference-contexts: The time required to run a Bellman-Ford computation on one subgraph for O (log n) iteration is O (k log k) (see for instance <ref> [18] </ref>). Therefore, the time required to run the third-phase on all the subgraphs is O (n log k). Letting k be equal to n 2=3 log 4=3 D we see that the entire algorithm requires O (n 4=3 log 2=3 D) time. We thus get the bounds of Theorem 20.
Reference: [19] <author> A. L. Delcher and S. R. Kosaraju, </author> <title> "An NC algorithm for evaluating monotone planar circuits," </title> <note> manuscript submitted for publication. </note>
Reference-contexts: Figure 5.2 gives an example of a layered graph with a planar 5-line embedding. Layered graphs have been studied under the name of proper hierarchies in [101]. Di Battista and Nardelli [20] give efficient algorithms to test if a layered digraph with only one source is planar. Kosaraju <ref> [19] </ref> has developed an efficient parallel algorithm to evaluate monotone planar layered circuits. Recently Ramchandran and Yang [86] have developed a linear-processor polylog-time algorithm for evaluating general monotone planar circuits.
Reference: [20] <author> G. Di Battista and E. Nardelli, </author> <title> "An algorithm for testing planarity of hierarchical graphs," </title> <booktitle> Proc. In. Workshop WG 86, </booktitle> <address> Bernierd, </address> <month> June </month> <year> 1986. (1987), </year> <pages> 277-289. </pages>
Reference-contexts: G is a planar layered digraph if it admits a planar p-line embedding. Figure 5.2 gives an example of a layered graph with a planar 5-line embedding. Layered graphs have been studied under the name of proper hierarchies in [101]. Di Battista and Nardelli <ref> [20] </ref> give efficient algorithms to test if a layered digraph with only one source is planar. Kosaraju [19] has developed an efficient parallel algorithm to evaluate monotone planar layered circuits. Recently Ramchandran and Yang [86] have developed a linear-processor polylog-time algorithm for evaluating general monotone planar circuits.
Reference: [21] <author> H. N. Djidev, </author> <title> "A separator theorem," </title> <editor> C. R. </editor> <booktitle> Bulgare Sci. 34 (1981), </booktitle> <pages> 643-645. </pages>
Reference: [22] <author> H. N. Djidev, </author> <title> "A linear algorithm for partitioning graphs," </title> <editor> C. R. </editor> <booktitle> Bulgare Sci. 35 (1982), </booktitle> <pages> 1053-1056. </pages>
Reference: [23] <author> H. N. Djidev, </author> <title> "On the problem of partitioning planar graphs," </title> <note> SIAM J. ALg. Discrete Methods 3 (1982), 229-240. </note>
Reference: [24] <author> H. N. Djidev, G. E. Pantziou, and C. D. Zaroliagis, </author> <title> "Computing shortest paths and distances in planar graphs," </title> <booktitle> Proc. 18th International Colloquium on Automata, Languages and Programming (1991), </booktitle> <pages> 327-338. </pages>
Reference-contexts: In other words a small change to the input graph should not force us to recompute the entire data structure. Thus the challenge of constructing a dynamic data structure is to satisfy both these requirements simultaneously. Though there are many algorithms for the dynamic problem [7,27,33] (see also <ref> [24] </ref>), 2 none of them can simultaneously handle both updates and queries in time that is sublinear in the input size. 1.1.3 Finding shortest paths in parallel and dynamic settings In this thesis we give efficient exact and approximate algorithms for solving shortest-path problems in parallel and dynamic settings for graphs
Reference: [25] <author> D. Eppstein and Z. Galil, </author> <title> "Parallel algorithmic techniques for combinatorial computation," </title> <institution> Columbia University, </institution> <type> Preprint, </type> <year> 1988. </year>
Reference: [26] <author> D. Eppstein, Z. Galil, G.F. Italiano, and T. Spencer, </author> <title> "Separator based sparsifica-tion for dynamic planar graph algorithms," </title> <booktitle> Proc. 25th Annual ACM Symposium on Theory of Computing (1993). </booktitle>
Reference-contexts: In representing reachability, the path-detour technique gives us a sparse representation that contains the same reachability information as the original collection of paths. Sparse substitute graphs have been used earlier in [36], [37], and <ref> [26] </ref> for maintaining various properties in undirected planar graphs. However, our substitute for representing all-pairs reachability is the first such substitute for directed planar graphs. Furthermore, while constructing the substitute, we also need to concern ourselves with the distribution of the selected nodes.
Reference: [27] <author> S. Even and H. Gazit, </author> <title> "Updating distances in dynamic graphs," </title> <booktitle> Methods of Operations Research 49 (1985), </booktitle> <pages> 371-387. </pages>
Reference: [28] <author> G.N. Frederickson, </author> <title> "Data structures for on-line updating of minimum spanning trees, with applications," </title> <journal> SIAM J. Computing 14 (1985), </journal> <pages> 781-798. </pages>
Reference: [29] <author> G.N. Frederickson, </author> <title> "Fast algorithms for shortest paths in planar graphs, with applications," </title> <journal> SIAM Journal on Computing 16 (1987), </journal> <pages> 1004-1022. </pages>
Reference-contexts: In Chapter 5 our main result is that planar layered digraphs also admit small one-way separators. We use these separators to implement a fast and efficient divide-and-conquer solution to the single-source shortest-path problem on planar layered digraphs. 1.4.3 Cluster partitions Frederickson <ref> [29] </ref> first used planar separators to construct what we call a cluster partition (our terminology is similar to the one used by Galil, Italiano, and Sarnak [37]). Using such a partition he gave a more efficient sequential algorithm for finding single-source shortest paths in planar digraphs. <p> If u is a boundary node then we arbitrarily set G u to be one of the subgraphs G i that contains edges incident to u. 11 Lemma 1 (Frederickson <ref> [29] </ref>) Given an n-node planar graph G a k-cluster partition can be obtained in O (n log n) time. Frederickson [29] introduced the idea of such a partition and showed how to obtain one in O (n log n) time. <p> If u is a boundary node then we arbitrarily set G u to be one of the subgraphs G i that contains edges incident to u. 11 Lemma 1 (Frederickson <ref> [29] </ref>) Given an n-node planar graph G a k-cluster partition can be obtained in O (n log n) time. Frederickson [29] introduced the idea of such a partition and showed how to obtain one in O (n log n) time. A cluster partition is obtained by starting with G and repeatedly dividing it using a planar separator [74] until all the pieces have at most k edges. <p> As in the previous case we repeatedly use cycle separators to divide the subgraphs until we get pieces of size k. We retriangulate subgraphs when faces get too big so that the pieces are guaranteed to have small cycle separators. Using techniques due to Frederickson <ref> [29] </ref> we can also make sure that none of the pieces have too many 12 boundary nodes, and in each G i the boundary nodes are on a constant number of faces. This process takes O (n log n) time. <p> This is because, the boundary nodes in G may all end up in one piece. To overcome this problem we use a technique by Frederickson <ref> [29] </ref>. The idea is as follows. Mark any vertex used as a separating vertex at some stage, a boundary vertex. Use the separator algorithm from Theorem 14 once, to divide the boundary nodes (into small pieces), at every stage. <p> Our separator algorithm can be easily modified to divide a collection of marked nodes. This change in our division strategy guarantees that at any stage each piece has a small number of boundary nodes. In particular, we have the 118 following lemma, which follows from the arguments in <ref> [29] </ref>. Lemma 33 Let G be an n-vertex planar layered st-graph, and let 0 * 1. <p> The number of boundary nodes in G i for any i is O ( p Unlike in Chapter 2 we will not insist that the boundary nodes be distributed on a bounded number of faces. Such a cluster decomposition was used first by Fred-erickson <ref> [29] </ref> to speed up single-source shortest-path computation in planar graphs when edges have nonnegative weights.
Reference: [30] <author> G.N. Frederickson, </author> <title> "Ambivalent data structures for dynamic 2-edge connectivity and k-smallest spanning trees," </title> <booktitle> Proc. of the 32nd Symposium on Foundations of Computer Science (1991), </booktitle> <pages> 632-641. 144 </pages>
Reference: [31] <author> M. L. Fredman and D. E. Willard, </author> <title> "Trans-dichotomous algorithms for minimum spanning trees and shortest paths," </title> <booktitle> Proc. 31st Annual IEEE Symposium on Foundations of Computer Science (1990), </booktitle> <pages> 719-725. </pages>
Reference: [32] <author> M.L. Fredman and R.E. Tarjan, </author> <title> "Fibonacci heaps and their uses in improved network optimization algorithms," </title> <journal> Journal of the Association for Computing Machinery 34 (1987), </journal> <pages> 596-615. </pages>
Reference: [33] <author> E. Fuerstein and A. Marchetti-Spaccamela, </author> <title> "Dynamic algorithms for shortest path problems in planar graphs," </title> <booktitle> Proc. 17th International Workshop on Graph Theoretic Concepts in Computer Science (1991), </booktitle> <pages> 187-197. </pages>
Reference: [34] <author> H. N. Gabow, </author> <title> "Scaling algorithms for network problems," </title> <journal> Journal of Computer and System Sciences 31 (1985), </journal> <pages> 148-168. </pages>
Reference-contexts: Our algorithm works by reducing the exact problem to a series of approximate problems (see Section 3.1) by using a scaling technique similar to the one used by Gabow <ref> [34] </ref>. We then show how to solve the approximate problem by extending a breadth first search algorithm of Ullman and Yannakakis [96]. In Chapter 4 we investigate the single-source shortest-path problem in planar graphs. <p> The exact problem is solved by repeatedly finding approximations and using a scaling technique similar to the one by Gabow <ref> [34] </ref> (see Section 3.1). 1.5 The Ullman-Yannakakis random-sampling technique We now describe a random-sampling technique due to Ullman and Yannakakis [96] that is at the core of our parallel algorithms for shortest paths (see Chapters 3 and 4). <p> We use this in conjunction with with a scaling technique, for reducing the exact problem to a series of approximate ones to solve the exact problem. The scaling technique presented in Section 3.1 is similar to the one used by Gabow <ref> [34] </ref> for sequential computation of shortest paths. In other related work, a parallel algorithm for shortest paths was discovered by Spencer [91]. Actually, his algorithm involves a tradeoff between time and work. Spencer specifies his bounds in terms of a parameter and an upper bound L on edge-lengths . <p> Gabow <ref> [34] </ref> has given a scaling algorithm to compute single-source shortest paths in an n-node graph G with maximum edge-length L. His algorithm works by solving a series of log L instances of the problem (involving the same graph) in which each shortest-path distance is guaranteed to be at most n. <p> However, if we restrict ourselves to graphs of the kind described above then we cannot inadvertently create negative cycles because the negative edges are not part of any directed cycle. Our new algorithm also uses Gabow's scaling idea <ref> [34] </ref> to solve the problem by successive approximation (see Section 3.1). As discussed in [34] in order for this method to work the prices d () must obey the following property from I. (I) For every edge uv 2 G the value d (u) + `(uv) must be at least equal <p> Our new algorithm also uses Gabow's scaling idea <ref> [34] </ref> to solve the problem by successive approximation (see Section 3.1). As discussed in [34] in order for this method to work the prices d () must obey the following property from I. (I) For every edge uv 2 G the value d (u) + `(uv) must be at least equal to d (v). <p> Using these prices we set the reduced cost of the edge uv to be d (u) + `(uv) d (v). Note that the reduced cost of the edge uv is nonnegative even if the original cost `(uv) 93 was negative. Also, as proved in <ref> [34] </ref>, the shortest paths from any source remain the same even with respect to the new lengths. Therefore, in order to solve the single source shortest path problem on a graph with negative edge weights we only need to find a set of prices d (v) that satisfy condition (I). <p> Our techniques can also be used to get more work-efficient parallel algorithms for all these problems. Using Gabow's <ref> [34] </ref> reduction of the shortest-path problem to to the problem of computing a maximum matching, along with the parallel algorithm for 128 finding a maximum matching due to Gabow and Tarjan [35], we can get a parallel algorithm for the single-source shortest-path problem with the following bounds.
Reference: [35] <author> H. N. Gabow and R. E. Tarjan, </author> <title> "Almost-optimum speed-ups of algorithms for bipartite matching and related problems," </title> <booktitle> Proc. 20th Annual ACM Symposim on Theory of Computing (1988), </booktitle> <pages> 514-527. </pages>
Reference-contexts: Our techniques can also be used to get more work-efficient parallel algorithms for all these problems. Using Gabow's [34] reduction of the shortest-path problem to to the problem of computing a maximum matching, along with the parallel algorithm for 128 finding a maximum matching due to Gabow and Tarjan <ref> [35] </ref>, we can get a parallel algorithm for the single-source shortest-path problem with the following bounds. Theorem 24 Let G be a n-node planar directed graph such that the sum of the absolute values of the edge-weights is at most D. <p> Therefore, using our shortest-path algorithm we get the bounds in Theorems 21 and 23. To get an efficient parallel algorithm we follow the same strategy but instead of using Golberg's algorithm in the second phase we use an algorithm due to Gabow and 136 Tarjan <ref> [35] </ref>. Given an n-node m-edge graph H with integral edge-weights that are at most N in magnitude the algorithm in [35] can compute single-source shortest-paths in H in time O ( p nm log (nN )(log 2p)=p) using p m=( p n log 2 n) processors. <p> get an efficient parallel algorithm we follow the same strategy but instead of using Golberg's algorithm in the second phase we use an algorithm due to Gabow and 136 Tarjan <ref> [35] </ref>. Given an n-node m-edge graph H with integral edge-weights that are at most N in magnitude the algorithm in [35] can compute single-source shortest-paths in H in time O ( p nm log (nN )(log 2p)=p) using p m=( p n log 2 n) processors.
Reference: [36] <author> Z. Galil and G. F. </author> <title> Italiano, "Maintaining biconnected components of dynamic planar graphs," </title> <booktitle> Proc. 18th Int. Colloquium on Automata, Languages, and Programming. </booktitle> <year> (1991), </year> <pages> 339-350. </pages>
Reference-contexts: Frederickson [28,30] used the idea of partitioning a graph into clusters to develop dynamic data structures for maintaining minimum spanning trees, connected components, and two-edge connected components. Galil and Italiano <ref> [36] </ref> used a k-cluster partition to develop a fully dynamic data structure for two- and three-connectivity in planar graphs. Later Galil, Italiano, and Sarnak [37] used such a decomposition for designing a dynamic planarity-testing algorithm. The basic idea behind these dynamic data structures is the following. <p> In representing reachability, the path-detour technique gives us a sparse representation that contains the same reachability information as the original collection of paths. Sparse substitute graphs have been used earlier in <ref> [36] </ref>, [37], and [26] for maintaining various properties in undirected planar graphs. However, our substitute for representing all-pairs reachability is the first such substitute for directed planar graphs. Furthermore, while constructing the substitute, we also need to concern ourselves with the distribution of the selected nodes.
Reference: [37] <author> Z. Galil, G.F. Italiano, and N. Sarnak, </author> <title> "Fully dynamic planarity testing," </title> <booktitle> Proc. 24th Annual ACM Symposium on Theory of Computing (1992), </booktitle> <pages> 495-506. </pages>
Reference-contexts: use these separators to implement a fast and efficient divide-and-conquer solution to the single-source shortest-path problem on planar layered digraphs. 1.4.3 Cluster partitions Frederickson [29] first used planar separators to construct what we call a cluster partition (our terminology is similar to the one used by Galil, Italiano, and Sarnak <ref> [37] </ref>). Using such a partition he gave a more efficient sequential algorithm for finding single-source shortest paths in planar digraphs. <p> Galil and Italiano [36] used a k-cluster partition to develop a fully dynamic data structure for two- and three-connectivity in planar graphs. Later Galil, Italiano, and Sarnak <ref> [37] </ref> used such a decomposition for designing a dynamic planarity-testing algorithm. The basic idea behind these dynamic data structures is the following. We first divide the underlying graph into suitably sized pieces. We then precom-pute partial solutions to the problem on each of the pieces. <p> In representing reachability, the path-detour technique gives us a sparse representation that contains the same reachability information as the original collection of paths. Sparse substitute graphs have been used earlier in [36], <ref> [37] </ref>, and [26] for maintaining various properties in undirected planar graphs. However, our substitute for representing all-pairs reachability is the first such substitute for directed planar graphs. Furthermore, while constructing the substitute, we also need to concern ourselves with the distribution of the selected nodes. <p> In this section we will assume that all the edge-additions are planarity-preserving. To see whether edge additions preserve planarity we can run the planarity-testing algorithm from <ref> [37] </ref> in the background to prevent addition of edges that destroy planarity. Doing this only increases the time-complexity of our update operations by a constant factor. In the descriptions of our algorithms we will not explicitly mention these additional steps. <p> We again use the cluster-partitioning approach of Chapter 2. Throughout this section we assume that the edge additions preserve planarity. This can be easily enforced within the same time and space bounds by running the planarity testing algorithm by Galil, Italiano, and Sarnak <ref> [37] </ref> in the background and only allowing edge additions that preserve planarity.
Reference: [38] <author> H. Gazit and G. L. Miller, </author> <title> "An O( p n log n) optimal parallel algorithm for a separator in planar graphs," </title> <type> manuscript. </type>
Reference: [39] <author> H. Gazit and G. L. Miller, </author> <title> "A deterministic parallel algorithm for finding a separator in planar graphs," </title> <type> manuscript. </type>
Reference: [40] <author> H. Gazit and G. L. Miller, </author> <title> "A parallel algorithm for finding a separator in planar graphs," </title> <booktitle> Proc. 28th Annual IEEE Symposium on Foundations of Computer Science (1987), </booktitle> <pages> 238-248. 145 </pages>
Reference-contexts: Breadth-first search also has several applications. For example, using our algorithm in conjunction with the method of Miller [76], we obtain the first polylog-time, linear-processor algorithm for finding O ( p n) separators in planar graphs. The best NC algorithm previously known was that of Gazit and Miller <ref> [40] </ref>, which takes O (log 2 n) time and requires O (n 1+* ) processors for any given constant * &gt; 0. Their algorithm can also be used to find separators of size O ( p n polylog n) using only n processors. Indeed, we use this in our algorithm. <p> Of these families, for all but the last there are polylog-time parallel algorithms for finding such separators. If one is willing to settle for separators of size O ( p n polylog n), the algorithm of Gazit and Miller <ref> [40] </ref> for planar graphs requires only a linear number of processors. Separators of size O ( p n) can be found for overlap graphs by an algorithm using only a linear number of processors [78]. <p> A parallel algorithm for finding a cycle separator for biconnected graphs was given by Miller [76] which uses n processors if the breadth first search tree of the graph is already known. An improved version of the algorithm was given by Gazit and Miller <ref> [40] </ref>, which uses randomization to find a cycle separator with n 1+* processors. A version of their algorithm can be used to find O ( p n polylog n) separators using n processors.
Reference: [41] <author> H. Gazit and G. L. Miller, </author> <title> "An improved parallel algorithm that computes the BFS numbering of a directed graph," </title> <booktitle> Information Processing Letters 28 (1988), </booktitle> <pages> 61-65. </pages>
Reference-contexts: In fact, this algorithm can compute shortest paths (see [2,25] for more details). The problem with this algorithm is that it requires too many processors; to achieve O (log n) time requires about n 3 processors. The processor bound has been improved somewhat <ref> [41] </ref> in the case of breadth-first search. The most elementary parallel search technique is parallel breadth-first search. In this technique the nodes are visited level by level as the search progresses.
Reference: [42] <author> J. Gil, Y. Matias, and U. Vishkin, </author> <title> "Towards a theory of nearly constant time parallel algorithms," </title> <booktitle> Proceedings of 33rd IEEE Symposium on Foundations of Computer Scvience (1991), </booktitle> <pages> 628-637. </pages>
Reference-contexts: Their algorithm runs in constant time with probability 1 2 n ffi for some positive constant ffi. Assuming the slightly weaker ARBITRARY CRCW PRAM, in which an arbitrary processor succeeds in writing, would entail using an O (log fl n)-time algorithm <ref> [42] </ref> for processor allocation. This change multiplies our time bounds of Theorem 6 by O (log fl n). In the rest of the chapter we give a brief overview of some of the techniques that have proved useful in addressing the shortest-path problem in different settings.
Reference: [43] <author> J. R. Gilbert, J. P. Hutchinson, and R. E. Tarjan, </author> <title> "A separation theorem for graphs of bounded genus," </title> <journal> Journal of Algorithms, </journal> <year> 1984. </year>
Reference-contexts: Several families of graphs have such separators of size O ( p n) where n is the number of nodes in the graph. Examples include planar graphs [74], bounded-genus graphs <ref> [43] </ref>, two-dimensional overlap graphs [78], and graphs excluding a fixed graph as a minor [4]. Of these families, for all but the last there are polylog-time parallel algorithms for finding such separators.
Reference: [44] <author> A.V. Goldberg, </author> <title> "Scaling algorithms for the shortest path problem," </title> <booktitle> SIAM Symposium on Discrete Algorithms. </booktitle> <year> (1993). </year>
Reference-contexts: In the sequential setting we obtain an algorithm that takes time O (n 4=3 log (nL)), where the lengths are integers greater than L. For general graphs, the best bound known is O (n 1=2 m log L) time, due to Goldberg <ref> [44] </ref> which yields O (n 3=2 log L) time on sparse (e.g. planar) graphs. For undirected planar graphs, Pan and Reif [82,83] showed how to achieve O (n 3=2 ) time using separators. Cohen [14] showed how to achieve the same bound for directed planar graphs. <p> In the sequential setting we obtain an algorithm that takes time O (n 4=3 log (nL)), where the lengths are integers greater than L. For general graphs, the best bound known is O (n 1=2 m log L) time, due to Goldberg <ref> [44] </ref> which yields O (n 3=2 log L) time on sparse (e.g. planar) graphs. For undirected planar graphs, Pan and Reif [82,83] showed how to achieve O (n 3=2 ) time using separators. Cohen [14] showed how to achieve the same bound for directed planar graphs. <p> We use the single-source shortest path algorithm due to Goldberg <ref> [44] </ref> in H to compute shortest paths from s to all the boundary nodes of G. This constitutes the second phase of our algorithm. <p> It is easy to see that the same bounds hold for the size of the auxiliary graph S as well. Therefore, Goldberg's algorithm <ref> [44] </ref> will require O (n 9=7 log D) time to find the shortest u-to-v path. To bound the update time we note that the all-boundary-pair shortest-paths can be found in O (n 9=7 ) time for any subgraph G i using nested dissection.
Reference: [45] <author> M. Goodrich, </author> <title> "Planar separators and parallel polygon triangulation," </title> <booktitle> Proc. 24th Annual ACM Symposium on Theory of Computing (1992), </booktitle> <pages> 507-516. </pages>
Reference: [46] <author> S. Guattery and G. L. Miller, </author> <title> "A contraction procedure for planar directed graphs," </title> <booktitle> Proc. 4th Annual ACM Symposium on Parallel Algorithms and Architectures (1992), </booktitle> <pages> 431-441. </pages>
Reference: [47] <author> T. Hagerup and R. Raman, </author> <title> "Waste makes haste: Tight bounds for loose parallel sorting," </title> <booktitle> Proceedings of the 33rd IEEE Symposium on Foundations of Computing (1992), </booktitle> <pages> 628-637. </pages>
Reference-contexts: If multiple processors attempt to write multiple values to a single location, the value written is the bitwise OR of the values. This model enables us to do processor allocation using a randomized constant-time algorithm due to Hagerup and Raman <ref> [47] </ref> for approximate prefix summation. Their algorithm runs in constant time with probability 1 2 n ffi for some positive constant ffi. Assuming the slightly weaker ARBITRARY CRCW PRAM, in which an arbitrary processor succeeds in writing, would entail using an O (log fl n)-time algorithm [42] for processor allocation. <p> Suppose e i is the number of such edges; then we can perform this computation in O (e i =p) time with high probability using the algorithm of <ref> [47] </ref> for processor allocation. Hence the time required to traverse k levels is O (e=p + k) with high probability. 48 3.2.1 Limited search The problem with this approach is that the time required grows linearly with the number of levels traversed.
Reference: [48] <author> R. Hassin, </author> <title> "Maximum flow in (s; t) planar networks," </title> <note> Information Processing Letters 13 (1981), 107. </note>
Reference-contexts: In the case when s and t belong to the same face, we can also efficiently obtain a maximum s-t flow, using the algorithm of Hassin <ref> [48] </ref>. Best previously known parallel algorithms for these problems relied on the algorithm of Pan and Reif, and hence required ~ O (n 1:5 ) work. Breadth-first search also has several applications. <p> We thus get the bounds of Theorem 20. To get our bounds for the related problems of computing a circulation, computing a maximum flow, etc., we just use our shortest-path algorithm as a subroutine in the algorithms given by Miller and Naor [77]. Hassin <ref> [48] </ref> (see also [49]) showed that computing a circulation in planar directed graph is equivalent to performing a single-source shortest computation in the dual graph. <p> In other words a new edge can be added if and only if it is consistent with the existing embedding. To get a fully-dynamic algorithm for maintaining a legal-circulation in an embedded planar network G we note that due to a reduction by Hassin <ref> [48] </ref> (see also [49,77]) the problem of computing a legal circulation in a planar network is equivalent to computing the single-source shortest-path distances from an arbitrary source s in the dual network 139 G 0 . <p> Let d (f 1 ) and d (f 2 ) denote the shortest-path distances to f 1 and f 2 respectively. Then the flow on e in the circulation is set to be d (f 2 ) d (f 1 ). Hassin <ref> [48] </ref> shows that this procedure gives a legal circulation in G. Thus to determine the flow on any particular edge in G we need to perform two shortest-path queries in the dual graph G 0 .
Reference: [49] <author> R. Hassin and D. B. Johnson, </author> <title> "An O(n log 2n) algorithm for maximum flow in undirected planar networks," </title> <journal> SIAM Journal on Computing 14 (1985), </journal> <pages> 612-624. </pages>
Reference-contexts: Using this algorithm, we can solve the longest-path problem in a dag. By using the technique of Hassin and Johnson <ref> [49] </ref> we can find the maximum flow in an undirected network where s and t are not necessarily on the same face, in polylog time using a linear number of processors. 1.2 Computing shortest paths in graphs with negative edge weights In Chapter 6 we investigate the problem of computing shortest <p> Using this algorithm, we can solve the longest-path problem in a dag. By using the technique of Hassin and Johnson <ref> [49] </ref>, we can find the maximum flow in an undirected 59 planar network where s and t are not necessarily on the same face, both in polylog time and using a linear number of processors. See section 4.5 for more details. <p> In this subsection we detail this procedure. Hassin and Johnson <ref> [49] </ref> have given an algorithm for computing the maximum flow in a planar undirected network by computing shortest paths in the dual network. We will use their results to get our bounds. We give a brief sketch of their algorithm here. For details see [49]. <p> Hassin and Johnson <ref> [49] </ref> have given an algorithm for computing the maximum flow in a planar undirected network by computing shortest paths in the dual network. We will use their results to get our bounds. We give a brief sketch of their algorithm here. For details see [49]. Their max-flow algorithm uses the following steps: 102 1. Let ~ s be a vertex on the dual face (in the dual network) corresponding to the source node s. Similarly let ~ t be a node on the dual face corresponding to the sink t. 2. <p> It does not include C i+1 . The band N 0 includes everything that is outside C 0 while the band N k includes C k and everything that is inside it. See Figure 4.5 for an example. Hassin Johnson <ref> [49] </ref> show that the shortest paths in the transformed dual network have a special property. <p> It does not go back and forth. We will therefore find the shortest paths in two stages. The first stage finds the portion of the shortest paths that traverse into the concentric bands and the second stage is used to find the portion 104 (from <ref> [49] </ref>). The figure also shows a normal shortest path from ~ 0 of the paths that come back out through the bands. To find the portion of the paths that traverses inwards we modify the dual network in the following manner. 1. <p> We thus get the bounds of Theorem 20. To get our bounds for the related problems of computing a circulation, computing a maximum flow, etc., we just use our shortest-path algorithm as a subroutine in the algorithms given by Miller and Naor [77]. Hassin [48] (see also <ref> [49] </ref>) showed that computing a circulation in planar directed graph is equivalent to performing a single-source shortest computation in the dual graph.
Reference: [50] <author> G.F. </author> <title> Italiano, "Amortized efficiency of a path retrieval data structure," </title> <booktitle> Theoretical Computer Science 48 (1986), </booktitle> <pages> 273-281. </pages>
Reference: [51] <author> G.F. </author> <title> Italiano, "Finding paths and deleting edges in directed acyclic graphs," </title> <booktitle> Information Processing Letters 28 (1988), </booktitle> <pages> 5-11. 146 </pages>
Reference: [52] <author> G.F. Italiano, A. Marchetti-Spaccamela, and U. Nanni, </author> <title> "Dynamic data structures for series-parallel graphs," </title> <booktitle> Proc. WADS' 89, LNCS 382 (1989), </booktitle> <pages> 352-372. </pages>
Reference-contexts: Data structures that support insertions only are given in [12,50,84]. Data structures that are restricted to acyclic digraphs and support only deletions can be found in [12,51]. We can obtain better results if we restrict ourselves to specific classes of graphs. For series-parallel digraphs, Italiano, Marchetti-Spaccamela, and Nanni <ref> [52] </ref> gave an O (n)-space data structure that handles both queries and updates in O (log n) time.
Reference: [53] <author> D.B. Johnson, </author> <title> "Efficient algorithms for shortest paths in sparse networks," </title> <journal> Journal of the Association for Computing Machinery 24 (1977), </journal> <pages> 1-13. </pages>
Reference: [54] <author> D.B. Johnson, </author> <title> "Parallel algorithms for minimum cuts and maximum flows in planar networks," </title> <journal> Journal of the Association for Computing Machinery 34 (1987), </journal> <pages> 950-967. </pages>
Reference: [55] <author> D.B. Johnson and S. M. Venkatesan, </author> <title> "Parallel algorithms for minimum cuts and maximum flows in planar networks," </title> <booktitle> Proc. 23rd Annual IEEE Symposium on Foundations of Computer Science (1982), </booktitle> <pages> 244-254. </pages>
Reference: [56] <author> D.B. Johnson and S.M. Venkatesan, </author> <title> "Using divide and conquer to find flows in directed planar networks in O(n 1:5 log n) time," </title> <booktitle> Proc. 20th Annual Allerton Conf. on Communication, Control, and Computing (1982), </booktitle> <pages> 898-905. </pages>
Reference-contexts: For planar graphs, shortest-path computation is closely related to network flow. Given a planar digraph and source and sink nodes s and t respectively on different faces of the graph, Miller and Naor [77] (see also Johnson and Venkatesan <ref> [56] </ref>) show how to solve the max-flow problem by performing a single-source shortest-path computation in a graph with negative lengths. <p> For planar graphs, shortest-path computation is closely related to network flow. Given a planar digraph and source and sink nodes s and t respectively on different faces of the graph, Miller and Naor [77] (see also Johnson and Venkatesan <ref> [56] </ref>) show how to 126 solve the max-flow problem by computing single-source shortest-path computation with negative lengths. They also use the same approach in solving the following problem: given multiple sources and multiple sinks, each with a specified supply or demand, find a feasible flow in the network.
Reference: [57] <author> L. R. Ford Jr. and D. R. Fulkerson, </author> <title> Flows in Networks, </title> <publisher> Princeton University Press, </publisher> <year> 1962. </year>
Reference: [58] <author> T. Kameda, </author> <title> "On the vector representation of the reachability in planar directed graphs," </title> <booktitle> Information Processing Letters 3 (1975), </booktitle> <pages> 75-77. </pages>
Reference: [59] <author> M. Kao and P. N. Klein, </author> <title> "Towards overcoming the transitive closure bottleneck: efficient parallel algorithms for planar digraphs," </title> <booktitle> Proc. 22nd Annual ACM Symposium on Theory of Computing (1990), </booktitle> <pages> 181-192. </pages>
Reference: [60] <author> R.M. Karp and V. Ramachandran, </author> <title> "A survey of parallel algorithms for shared memory machines," </title> <booktitle> in Handbook of Theoretical Computer Science, </booktitle> <publisher> North Holland, </publisher> <year> 1990, </year> <pages> 871-941. </pages>
Reference-contexts: In the parallel setting we use the PRAM <ref> [60] </ref> or the parallel random-access-memory model of computation. Different algorithms use different PRAM models. However, unless otherwise stated the parallel algorithms presented assume an ARBITRARY CRCW PRAM as the underlying model of computation. <p> It is not hard to see that these infinite-weight edges do not alter any shortest paths or destroy planarity. This computation can be accomplished in O (log n) time with n processors using standard techniques (see for example <ref> [60] </ref>). A planar layered digraph with exactly one source s (on the first layer) and one sink t ( on the last layer) is called a planar layered st-graph. <p> Given an n-vertex planar layered st-graph G the algorithm outlined above constructs the one-way separator of Theorem 13 and can be implemented in time O (log n) using n= log n processors on an EREW PRAM. 117 Proof : Steps 1 through 4 can be done using standard techniques (see <ref> [60] </ref>). Steps 5 and 6 can be completed in O (log n) time using techniques given in [94]. 2 Theorem 14 gives us a natural divide-and-conquer strategy for the shortest path problem.
Reference: [61] <author> D. Kelly, </author> <title> "On the Dimension of Partially Ordered Sets," </title> <booktitle> Discrete Mathematics 35 (1981), </booktitle> <pages> 135-156. </pages>
Reference-contexts: and &lt; R of the nodes in G such that a node v is reachable from another node u in G if and only if v occurs after u in both the orderings [11,58]." Unfortunately it seems unlikely that these methods can be extended to all planar digraphs, since Kelly <ref> [61] </ref> has shown that for general planar digraphs we might need a large number of orderings to represent all-pairs reachability information as an intersection of these orderings. In this chapter we give a fully dynamic data structure to maintain the all-pairs reachability information in planar digraphs.
Reference: [62] <author> P. N. Klein, S. Rao, M. Rauch, and S. Subramanian, </author> <title> "Faster shortest-path algorithms for planar graphs," </title> <booktitle> Proc. 26th Annual ACM Symposium on Theory of Computing (STOC) (1994). </booktitle> <pages> 147 </pages>
Reference-contexts: For each level i, the sum of the sizes of the pertinent graphs at that level is O (n), and the sum of the squares of the sizes of the splitting sets is ~ O (n). Recently in joint work with Klein, Rao, and Rauch <ref> [62] </ref> we have given a linear-time algorithm for finding single-source shortest paths in planar digraphs. Our algorithm uses a recursive decomposition tree similar to the one described above. Our parallel algorithm for single-source shortest paths in Chapter 4 uses the decomposition tree described here. <p> Since there are O (* 1 ) segment nodes, the entire computation can be carried out in O (* 1 n) time using the shortest-path algorithm of <ref> [62] </ref>. 27 2.1.2 Face-boundary shortest-path substitutes Let Q be a set of k selected nodes in G that lie on a constant number of faces, and let * &gt; 0 be an error parameter. <p> Coalescing the nodes 31 of A 2 into s preserves the planarity of G since all the nodes of A 2 are on a single face. We can therefore use the algorithm of <ref> [62] </ref> to find shortest paths from s. Thus we can implement procedure separate in O (n) time. To bound the size of the substitute we note that the substitute for shortest paths in any range [d; 2d] is constructed in O (log k) stages. <p> Such a cluster decomposition was used first by Fred-erickson [29] to speed up single-source shortest-path computation in planar graphs when edges have nonnegative weights. Recently, in joint work with Klein, Rao, and Rauch <ref> [62] </ref> we have used a recursive cluster decomposition scheme to derive an optimum linear time algorithm for single source shortest paths in planar digraphs when 131 edge weights are restricted to be nonnegative. 6.1.2 The three-phase algorithm Our algorithm uses the partitioning technique described above.
Reference: [63] <author> P. N. Klein and S. Sairam, </author> <title> "A parallel randomized approximation scheme for shortest paths," </title> <booktitle> Proc. 24th Annual ACM Symposium on Theory of Computing (1992), </booktitle> <pages> 750-758. </pages>
Reference: [64] <author> P. N. Klein and S. Subramanian, </author> <title> "A linear-processor polylog-time algorithm for shortest-paths in planar graphs," </title> <booktitle> Proc. 1993 IEEE Symposium on Foundations of Computer Science. </booktitle> <year> (1993), </year> <pages> 259-270. </pages>
Reference: [65] <author> P. N. Klein and S. Subramanian, </author> <title> "A randomized parallel algorithm for single-source shortest paths," </title> <type> Technical Report, </type> <institution> Brown University, </institution> <note> submitted for publication, </note> <year> 1994. </year>
Reference: [66] <author> P.N. Klein, </author> <title> "On the Gazit and Miller separator algorithm: a work-efficient algorithm for finding cycle separators in planar graphs," </title> <booktitle> Proc. 5th Annual Symposium on Parallel Algorithms and Architectures (1993). </booktitle>
Reference-contexts: A version of their algorithm can be used to find O ( p n polylog n) separators using n processors. Gazit and Miller [38,39] have also given slower but more work-efficient parallel algorithms for finding O ( p n) planar separators. Recently Klein <ref> [66] </ref> has given a more work-efficient (but not polylog-time) algorithm for finding planar separators. Algorithms for finding small separators in more general graphs are given in [4,78,79,80,99]. 1.4.2 One-way separators The separators we have examined so far separate the underlying undirected graph.
Reference: [67] <author> J. Lagergren, </author> <title> "Efficient parallel algorithms for tree-decomposition and related problems," </title> <booktitle> Proc. 30th Annual IEEE Symp. on Foundations of Computer Science (1990), </booktitle> <pages> 173-182. </pages>
Reference-contexts: Since the graph still has small separators, our method applies. The second stage of her method involves solving the problem exactly on k-outerplanar graphs. This stage can be done efficiently in parallel 5 using the algorithm of Lagergren <ref> [67] </ref> Our shortest-path algorithm can be generalized to handle negative lengths as long as no negative-length edge appears in a directed cycle. Using this algorithm, we can solve the longest-path problem in a dag.
Reference: [68] <author> F.T. Leighton, </author> <title> Complexity Issues in VLSI: Optimal Layouts for the Shu*e-Exchange Graph and other Networks, </title> <publisher> MIT Press, </publisher> <year> 1983. </year>
Reference-contexts: For the remainder of this chapter unless otherwise stated G will denote a sparse graph from a minor-closed family of graphs. Given such a G the following lemma can be proved using an argument due to Leighton <ref> [68] </ref> for lower-bounding the crossing number of a graph. Lemma 12 Let H be a summary of G such that the segment graph of H has m edges and n nodes and maximum edge-multiplicity 1. <p> Thus Lemma 21 is weaker than Lemma 12. Using this crossing theorem we can find a near-cover of size O ((m 0 +n) 2 =m) in the same manner as before. The proof of Lemma 21 is a little different from the original proof due to Leighton <ref> [68] </ref> used in Lemma 12. We therefore give the details of the proof in this section. <p> In subsection 4.4.1 we present the proof of Lemma 21 and in Subsection 4.4.2 we show how to extend our parallel algorithm to general graphs. 4.4.1 Counting intersections in summaries of general graphs Our proof of Lemma 21 uses the same inductive strategy as the proof by Leighton <ref> [68] </ref> for Lemma 12. However, the details of the various steps are somewhat different. Let g (n; m) denote the number of crossings in in H. Recall that two edges of H are said to cross if their corresponding paths in G 0 share a common node.
Reference: [69] <author> C. Leiserson, </author> <title> Area-efficient VLSI computation, </title> <booktitle> Foundations of Computing, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1983. </year>
Reference: [70] <author> A. Lempel, S. Even, and I. Cederbaum, </author> <title> "An algorithm for planarity testing of graphs," Theory of Graphs, </title> <booktitle> Int. Symposium (1966), </booktitle> <pages> 215-232. </pages>
Reference-contexts: These graphs were first introduced in the planarity testing algorithm of Lempel et al. <ref> [70] </ref>. We now define the concept of a left ordering of the vertices in a planar st-graph, which will prove useful in our algorithm. This ordering was introduced by Tamassia and Preparata [92].
Reference: [71] <author> A. Lingas, </author> <title> "Fast parallel algorithms for planar directed graphs," </title> <booktitle> Proc. SIGAL International Symposium on Algorithms (1990), </booktitle> <pages> 447-457. </pages>
Reference-contexts: Again, we use a parallel version of the Bellman-Ford algorithm to quickly find shortest paths in this auxiliary graph. To construct a graph that approximates shortest paths in the original graph we use similar but denser graphs on the separators. This idea was used by Lingas <ref> [71] </ref> in the context of breadth-first search and later by Cohen [14] for shortest-paths. However, in [14] the dense graphs on the separators were simply complete graphs where there was an direct edge uv representing the shortest path from u to v.
Reference: [72] <author> R. Lipton, D. Rose, and R.E. Tarjan, </author> <title> "Generalized nested dissection," </title> <note> SIAM J. Numerical Analysis 16 (1979), 346-358. </note>
Reference-contexts: The concept of a separator has played an important role in the development of algorithms; and starting with the planar separator theorem of Lipton and Tarjan [74] it 9 has led to a number of applications in VLSI [68,69,73,95,98] and numerical analysis <ref> [72, 82] </ref>. Lipton and Tarjan [74] first proved that all planar graphs have 2 p p n separators that 2=3-split the graph. Djidev [21,22,23] reduced the size of the separator (required to 2=3-split the graph) to p 6n.
Reference: [73] <author> R. J. Lipton and R. E. Tarjan, </author> <title> "Applications of a planar separator theorem," </title> <journal> SIAM Journal on Computing 9 (1980), </journal> <pages> 615-627. 148 </pages>
Reference-contexts: We then show how this division can be used to formulate a recursive solution to the single-source shortest-path problem. To show the existence of such separators we need the following lemma, which follows directly from the arguments in <ref> [73] </ref>: Lemma 32 Let G be any n-vertex planar layered st-graph containing layers 1 through p. Let S i denote the set of vertices in the ith layer, and let n i denote the size of the set S i .
Reference: [74] <author> R.J. Lipton and R.E. Tarjan, </author> <title> "A separator theorem for planar graphs," </title> <journal> SIAM Journal of Applied Mathematics 36 (1979), </journal> <pages> 177-189. </pages>
Reference-contexts: Several families of graphs have such separators of size O ( p n) where n is the number of nodes in the graph. Examples include planar graphs <ref> [74] </ref>, bounded-genus graphs [43], two-dimensional overlap graphs [78], and graphs excluding a fixed graph as a minor [4]. Of these families, for all but the last there are polylog-time parallel algorithms for finding such separators. <p> The concept of a separator has played an important role in the development of algorithms; and starting with the planar separator theorem of Lipton and Tarjan <ref> [74] </ref> it 9 has led to a number of applications in VLSI [68,69,73,95,98] and numerical analysis [72, 82]. Lipton and Tarjan [74] first proved that all planar graphs have 2 p p n separators that 2=3-split the graph. <p> The concept of a separator has played an important role in the development of algorithms; and starting with the planar separator theorem of Lipton and Tarjan <ref> [74] </ref> it 9 has led to a number of applications in VLSI [68,69,73,95,98] and numerical analysis [72, 82]. Lipton and Tarjan [74] first proved that all planar graphs have 2 p p n separators that 2=3-split the graph. Djidev [21,22,23] reduced the size of the separator (required to 2=3-split the graph) to p 6n. <p> Frederickson [29] introduced the idea of such a partition and showed how to obtain one in O (n log n) time. A cluster partition is obtained by starting with G and repeatedly dividing it using a planar separator <ref> [74] </ref> until all the pieces have at most k edges. His algorithm also makes sure that none of the pieces contain too many boundary nodes by redividing pieces when the ratio of boundary nodes to non boundary nodes crosses a threshold.
Reference: [75] <author> N. Megiddo, </author> <title> "Parallel algorithms for finding the minimum and the median almost surely in constant time," </title> <type> preprint, </type> <year> 1982. </year>
Reference-contexts: Finally, using the Bellman-Ford variant to compute single-source shortest paths requires O ( p n log n) stages (as noted above). Each stage can be implemented in constant time with high probability by using Megiddo's <ref> [75] </ref> algorithm for computing minimum. Therefore the shortest paths in H fl [ G can be found in O ( p n log n) time and O (m p n log n) work.
Reference: [76] <author> G. L. Miller, </author> <title> "Finding small simple cycle separators for 2-connected planar graphs," </title> <journal> Journal of Computer and System Sciences 32 (1986), </journal> <pages> 265-279. </pages>
Reference-contexts: Best previously known parallel algorithms for these problems relied on the algorithm of Pan and Reif, and hence required ~ O (n 1:5 ) work. Breadth-first search also has several applications. For example, using our algorithm in conjunction with the method of Miller <ref> [76] </ref>, we obtain the first polylog-time, linear-processor algorithm for finding O ( p n) separators in planar graphs. <p> This result and other extensions to it have paved the way to divide and conquer solutions for many problems in planar graphs. A parallel algorithm for finding a cycle separator for biconnected graphs was given by Miller <ref> [76] </ref> which uses n processors if the breadth first search tree of the graph is already known. An improved version of the algorithm was given by Gazit and Miller [40], which uses randomization to find a cycle separator with n 1+* processors. <p> In addition for each subgraph G i the boundary nodes are present on a constant number of faces (for a suitable constant f ). In order to construct a face-restricted cluster partition we make use of different separator algorithm by Miller <ref> [76] </ref>; one that constructs cycle separators. A cycle separator X is a separator such that all the nodes of X lie on a simple undirected cycle in the underlying planar graph G. The size of a separator in Miller's algorithm depends the number of edges on the maximum sized face.
Reference: [77] <author> G. L. Miller and J. Naor, </author> <title> "Flows in planar graphs with multiple sources and sinks," </title> <booktitle> Proc. 30th IEEE Symposium on Foundations of Computer Science (1989), </booktitle> <pages> 112-117. </pages>
Reference-contexts: For planar graphs, shortest-path computation is closely related to network flow. Given a planar digraph and source and sink nodes s and t respectively on different faces of the graph, Miller and Naor <ref> [77] </ref> (see also Johnson and Venkatesan [56]) show how to solve the max-flow problem by performing a single-source shortest-path computation in a graph with negative lengths. <p> For planar graphs, shortest-path computation is closely related to network flow. Given a planar digraph and source and sink nodes s and t respectively on different faces of the graph, Miller and Naor <ref> [77] </ref> (see also Johnson and Venkatesan [56]) show how to 126 solve the max-flow problem by computing single-source shortest-path computation with negative lengths. <p> Given a source node s in G the shortest paths from s to all the other nodes in G can be found in time O (n 4=3 log 2=3 D). Miller and Naor <ref> [77] </ref> show how to solve a number of flow-related problems on planar graphs by performing shortest-path computations on the dual graph. Our improved shortest-path algorithm gives improved algorithms for these problems as well. <p> Our task is to compute a feasible flow assignment to the edges of the network (if one exists) such that the sum of the flow into any node is equal to the demand at that node. Miller and Naor <ref> [77] </ref> show that a legal-circulation can be computed in a planar graph G by doing a single-source shortest-path computation in the dual graph. using our shortest-path algorithm we get the following bounds for computing a legal-circulation. <p> We thus get the bounds of Theorem 20. To get our bounds for the related problems of computing a circulation, computing a maximum flow, etc., we just use our shortest-path algorithm as a subroutine in the algorithms given by Miller and Naor <ref> [77] </ref>. Hassin [48] (see also [49]) showed that computing a circulation in planar directed graph is equivalent to performing a single-source shortest computation in the dual graph. Miller and Naor [77] showed that the problem of computing a perfect matching in a planar bipartite graph can be reduced to the problem <p> maximum flow, etc., we just use our shortest-path algorithm as a subroutine in the algorithms given by Miller and Naor <ref> [77] </ref>. Hassin [48] (see also [49]) showed that computing a circulation in planar directed graph is equivalent to performing a single-source shortest computation in the dual graph. Miller and Naor [77] showed that the problem of computing a perfect matching in a planar bipartite graph can be reduced to the problem of finding a circulation in the same graph. Therefore, we can use our shortest-path algorithm to get the bounds in Theorem 22 and corollary 6. <p> Therefore, we can use our shortest-path algorithm to get the bounds in Theorem 22 and corollary 6. The algorithms for maximum flow in <ref> [77] </ref> use O (log n) single-source computations in the dual (O (k 2 log n) if the sources and sinks are distributed over k faces). Therefore, using our shortest-path algorithm we get the bounds in Theorems 21 and 23. <p> Changes in the primal network correspond to obvious changes in the dual network, and the update algorithms remain the same. We therefore get the bounds in Corollary 10. The same algorithm essentially works for dynamic maintenance of perfect-matchings as well. By using the reduction due to Miller and Naor <ref> [77] </ref> we can reduce the perfect-matching problem to the problem of computing a legal circulation in the same graph such that an edge is in the matching if and only if the flow on the edge is non-zero.
Reference: [78] <author> G. L. Miller, S. Teng, and S. Vavasis, </author> <title> "A unified geometric approach to graph separators," </title> <booktitle> Proc. 31st Annual IEEE Symposium on Foundations of Computer Science (1991), </booktitle> <pages> 538-547. </pages>
Reference-contexts: Several families of graphs have such separators of size O ( p n) where n is the number of nodes in the graph. Examples include planar graphs [74], bounded-genus graphs [43], two-dimensional overlap graphs <ref> [78] </ref>, and graphs excluding a fixed graph as a minor [4]. Of these families, for all but the last there are polylog-time parallel algorithms for finding such separators. <p> Separators of size O ( p n) can be found for overlap graphs by an algorithm using only a linear number of processors <ref> [78] </ref>. The concept of a separator has played an important role in the development of algorithms; and starting with the planar separator theorem of Lipton and Tarjan [74] it 9 has led to a number of applications in VLSI [68,69,73,95,98] and numerical analysis [72, 82].
Reference: [79] <author> G. L. Miller and W. Thurston, </author> <title> "Separators in two and three dimensions," </title> <booktitle> Proc. 22nd Annual ACM Symposium on Theory of Computing (1990), </booktitle> <pages> 300-309. </pages>
Reference: [80] <author> G. L. Miller and S. A. Vavasis, </author> <title> "Density graphs and separators," </title> <booktitle> Proc. 2nd Annual ACM-SIAM Symposium on Discrete Algorithms (1991). </booktitle>
Reference: [81] <author> P. B. Miltersen, S. Subramanian, J. S. Vitter, and R. Tamassia, </author> <title> "Complexity models for incremental computation," </title> <note> Theoretical Computer Science: Special issue on Dynamic and On-line Algorithms (1994), (to appear). </note>
Reference-contexts: Unfortunately designing fully dynamic algorithms seems to be considerably harder than designing their sequential counterparts, and very few graph problems have fully 21 dynamic solutions. See [28,30,36,37] for fully dynamic data structures to various graph problems. See <ref> [81] </ref> for a complexity theoretic approach to dynamic computation. As we discussed in Chapter 1 the shortest-path problem is not very well understood in the dynamic realm.
Reference: [82] <author> V. Pan and J. H. Reif, </author> <title> "Fast and efficient solution of path algebra problems," </title> <journal> Journal of Computer and System Sciences 38 (1989), </journal> <pages> 494-510. </pages>
Reference-contexts: The concept of a separator has played an important role in the development of algorithms; and starting with the planar separator theorem of Lipton and Tarjan [74] it 9 has led to a number of applications in VLSI [68,69,73,95,98] and numerical analysis <ref> [72, 82] </ref>. Lipton and Tarjan [74] first proved that all planar graphs have 2 p p n separators that 2=3-split the graph. Djidev [21,22,23] reduced the size of the separator (required to 2=3-split the graph) to p 6n.
Reference: [83] <author> V. Pan and J. H. Reif, </author> <title> "The parallel computation of minimum cost paths in graphs by stream contraction," </title> <booktitle> Information Processing Letters 40 (1991), </booktitle> <pages> 79-83. </pages>
Reference-contexts: It can be used to obtain an efficient polylog-time algorithm for minimum st cut and maximum st-flow in planar graphs (see Section 4.5 for more details). Previous best algorithms for all these problems relied on the nested dissection algorithm of Pan and Reif <ref> [83] </ref> and therefore required ~ O (n 1:5 ) work. Our shortest-path algorithm can be generalized to handle negative lengths as long as no negative-length edge appears in a directed cycle. In particular we have the following theorem.
Reference: [84] <author> J.A. La Poutre and J. van Leeuwen, </author> <title> "Maintenance of transitive closures and transitive reductions of graphs," </title> <booktitle> Proc. WG '87, LNCS 314 (1988), </booktitle> <pages> 106-120. </pages>
Reference: [85] <author> V. Ramachandran and J.H. Reif, </author> <title> "An optimal parallel algorithm for graph planarity," </title> <booktitle> Proc. IEEE Symp. on Foundations of Computer Science (1989). </booktitle> <pages> 149 </pages>
Reference: [86] <author> V. Ramachandran and H. Yang, </author> <title> "An efficient parallel algorithm for general pla-nar monotone circuit value problem," </title> <booktitle> Proc. Fifth Annual SIAM Symposium on Discrete Algorithms (1994), </booktitle> <pages> 622-631. </pages>
Reference-contexts: Di Battista and Nardelli [20] give efficient algorithms to test if a layered digraph with only one source is planar. Kosaraju [19] has developed an efficient parallel algorithm to evaluate monotone planar layered circuits. Recently Ramchandran and Yang <ref> [86] </ref> have developed a linear-processor polylog-time algorithm for evaluating general monotone planar circuits.
Reference: [87] <author> J. H. Reif, </author> <title> "Minimum s-t cut of a planar undirected network in O(n log 2n) time," </title> <journal> SIAM Journal on Computing 12 (1983), </journal> <pages> 71-81. </pages>
Reference-contexts: These cycles can be found in polylog time with linear processors using our shortest path algorithm for nonnegative edge graphs along with a divide-and-conquer min-cut algorithm due to Reif <ref> [87] </ref>. 6. Transform the dual network by making two copies of the path and adding directed edges from the right copy ~ 00 i to the left copy ~ 0 i of every node ~ i .
Reference: [88] <author> H. Shi and T. Spencer, </author> <title> "Time-work tradeoffs for the single-source shortest paths problem," </title> <institution> Department of Computer Science University of Nebraska at Omaha, </institution> <type> Technical Report CS-TR-94-1, </type> <year> 1994. </year>
Reference-contexts: Her algorithm works in polylogarithmic time and is nearly work-optimal. However, her algorithm does not generalize to directed graphs; and there seems to be no way to use it to compute exact shortest paths by repeated approximation even if the underlying graph is undirected. More recently Shi and Spencer <ref> [88] </ref> have given a parallel shortest-path algorithm, for undirected graphs, with work-bounds that are similar to ours.
Reference: [89] <author> D.D. Sleator and R.E. Tarjan, </author> <title> "A data structure for dynamic trees," </title> <journal> Journal of Computer Systems Sciences 24 (1983), </journal> <pages> 362-381. </pages>
Reference-contexts: Recently Weihe [100] has given an O (n log n)-time algorithm for computing max-flow in a directed planar graph. His bounds improve upon our bounds for computing the max-flow and the related problem of bipartite perfect matching. However, his algorithm relies on the use of dynamic trees <ref> [89] </ref> while our algorithm does not use any complicated data structures. Thus, our algorithm may perform better in practice. <p> Thus his bounds improve upon our bounds for computing the max-flow and the related problem of bipartite perfect matching. However, his algorithm relies on the use of dynamic trees <ref> [89] </ref> while our algorithm does not use any complicated data structures. Thus, our algorithm may perform better in practice.
Reference: [90] <author> J. Spencer, </author> <title> "Ten Lectures on the Probabilistic Method," </title> <booktitle> Society for Industrial and Applied Mathematics (1987). </booktitle>
Reference-contexts: The expected number of edges in I 0 is m 0 =4. By the probabilistic method of Erdos <ref> [90] </ref> we therefore know that there is a way to color the nodes of I such that at least m 0 =4 of the edges in I go from a red nodes to blue nodes.
Reference: [91] <author> T. H. Spencer, </author> <title> "More time-work tradeoffs for parallel graph algorithms," </title> <booktitle> Proc. 3rd Annual ACM Symposium on Parallel Algorithms and Architectures (1991), </booktitle> <pages> 81-93. </pages>
Reference-contexts: The scaling technique presented in Section 3.1 is similar to the one used by Gabow [34] for sequential computation of shortest paths. In other related work, a parallel algorithm for shortest paths was discovered by Spencer <ref> [91] </ref>. Actually, his algorithm involves a tradeoff between time and work. Spencer specifies his bounds in terms of a parameter and an upper bound L on edge-lengths .
Reference: [92] <author> R. Tamassia and F.P. Preparata, </author> <title> "Dynamic maintenance of planar digraphs, with applications," </title> <booktitle> Algorithmica 5 (1990), </booktitle> <pages> 509-527. </pages>
Reference-contexts: For the class of planar st-graphs (acyclic planar digraphs with one source and one sink both of which are on the same face) Tamassia and Preparata <ref> [92] </ref> give an O (n)- space fully dynamic data structure that supports both updates and queries in O (log n) time. However, their algorithm is embedding-specific; i.e., only those changes that are consistent with the current embedding of the graph are allowed. <p> However, their algorithm is embedding-specific; i.e., only those changes that are consistent with the current embedding of the graph are allowed. Tamassia and Tollis [93] have extended the results of <ref> [92] </ref> to get a fully dynamic data structure for answering reachability queries in spherical st-graphs and planar digraphs with a single source and a single sink. Here too the updates are restricted to be embedding specific. <p> Here too the updates are restricted to be embedding specific. To our knowledge there is no previous work that handles general planar digraphs even if updates are restricted to be embedding-specific. The results in <ref> [92] </ref> and [93] are based on the well known result in dimension theory which (in graph theoretic terms) states: "Given an n-node planar directed acyclic graph G with one source and one sink, we can find two orderings &lt; L and &lt; R of the nodes in G such that a <p> These graphs were first introduced in the planarity testing algorithm of Lempel et al. [70]. We now define the concept of a left ordering of the vertices in a planar st-graph, which will prove useful in our algorithm. This ordering was introduced by Tamassia and Preparata <ref> [92] </ref>. We do this by making use of the dual graph of G (labeled G fl ) defined as follows. 1. Every internal face f in G corresponds to a vertex in G fl . 2.
Reference: [93] <author> R. Tamassia and I.G. Tollis, </author> <title> "Dynamic reachability in planar digraphs," </title> <note> Theoretical Computer Science (1993), (to appear). </note>
Reference-contexts: However, their algorithm is embedding-specific; i.e., only those changes that are consistent with the current embedding of the graph are allowed. Tamassia and Tollis <ref> [93] </ref> have extended the results of [92] to get a fully dynamic data structure for answering reachability queries in spherical st-graphs and planar digraphs with a single source and a single sink. Here too the updates are restricted to be embedding specific. <p> Here too the updates are restricted to be embedding specific. To our knowledge there is no previous work that handles general planar digraphs even if updates are restricted to be embedding-specific. The results in [92] and <ref> [93] </ref> are based on the well known result in dimension theory which (in graph theoretic terms) states: "Given an n-node planar directed acyclic graph G with one source and one sink, we can find two orderings &lt; L and &lt; R of the nodes in G such that a node v
Reference: [94] <author> R. Tamassia and J.S. Vitter, </author> <title> "Parallel transitive closure and point location in planar structures," </title> <note> SIAM Journal on Computing 20 (1991 ), 708-725. </note>
Reference-contexts: Proof : All the steps can be done in O (log n) time using techniques in <ref> [94] </ref>. 2 A planar layered st-graph is a special case of a planar st-graph which is defined as a planar acyclic digraph with exactly one source, s, and exactly one sink, t, embedded in the plane so that s and t are on the boundary of the external face. <p> A vertex x occurs before another vertex y in the ordering if either x ! y or x " Y . 113 A planar st-graph with its vertices numbered according to the left ordering is shown in Figure 5.4. Tamassia and Vitter <ref> [94] </ref> give optimal EREW algorithms to construct the left ordering of a planar st-graph. 5.2 Shortest paths in a planar layered st-graph Let G = (V; E) be a planar layered st-graph with source s and sink t. <p> Steps 5 and 6 can be completed in O (log n) time using techniques given in <ref> [94] </ref>. 2 Theorem 14 gives us a natural divide-and-conquer strategy for the shortest path problem. The only problem is that even though the separator from Theorem 14 divides the vertices in G into small pieces, it does not guarantee that the number of all-pairs subproblems in each piece is small. <p> To determine the processor and time complexity we note that the left ordering of the any planar st-graph with n vertices can be determined in O (log n) time with n= log n processors <ref> [94] </ref>. Thus, we can determine the orderings of S and T in O (log n) time with q n p = log n processors. The time complexity of the various steps are as follows. 1.
Reference: [95] <author> J. Ullman, </author> <title> Computational Aspects of VLSI , Computer Science Press, </title> <address> Rockville, MD, </address> <year> 1984. </year>
Reference: [96] <author> J. D. Ullman and M. Yannakakis, </author> <note> "High-probability parallel transitive-closure algorithms," SIAM Journal on Computing 20 (1991), 100-125. </note>
Reference-contexts: We then show how to solve the approximate problem by extending a breadth first search algorithm of Ullman and Yannakakis <ref> [96] </ref>. In Chapter 4 we investigate the single-source shortest-path problem in planar graphs. We give a parallel randomized algorithm that works in polylogarithmic time and uses a linear number of processors. Thus our algorithm is nearly work-optimal. <p> First we review some basic work on separators for planar graphs and discuss two types of decompositions that have proved useful both for our work and for solving a number of other problems. We then discuss a random-sampling technique due to Ullman and Yannakakis <ref> [96] </ref> that is at the core of the parallel shortest-path algorithms in Chapters 3 and 4. Finally we give a preview of the path-detour technique: a method for approximating shortest paths that cross a given separating path. <p> The exact problem is solved by repeatedly finding approximations and using a scaling technique similar to the one by Gabow [34] (see Section 3.1). 1.5 The Ullman-Yannakakis random-sampling technique We now describe a random-sampling technique due to Ullman and Yannakakis <ref> [96] </ref> that is at the core of our parallel algorithms for shortest paths (see Chapters 3 and 4). Definition 6 Let G be an n-node graph and let S be a subset of the nodes in G that are marked as distinguished. <p> The value of fi depends only on c and ff, and is independent of n. Ullman and Yannakakis <ref> [96] </ref> used this idea to devise an elegant parallel algorithm for computing single-source reachability and breadth-first search. The basic idea is the following. Let us fix in advance the set of paths from the source s to all the other nodes contained in some breadth-first-search tree. <p> Our algorithm is based on a parallel breadth-first search algorithm due to Ullman and Yannakakis <ref> [96] </ref>. Ullman and Yannakakis show that a breadth-first-search tree can be constructed in O ( n polylog n) time using a linear number of processors. Their algorithm is limited, however, in that it cannot handle lengths on nodes or edges. <p> Both these procedures are based on a combination of the random-sampling technique of Ullman and Yannakakis <ref> [96] </ref> (see Section 1.5) and our procedure Abbreviate for finding k-limited shortest paths. Intuitively, the goal of Abbreviate is to search k-hop paths between n nodes in a summary H with m ordinary edges. Naively this would take work proportional to nm, where m is typically around n 2 .
Reference: [97] <author> J. Valdes, R.E. Tarjan, and E.L. Lawler, </author> <title> "The recognition of series parallel digraphs," </title> <journal> SIAM Journal on Computing 11 (1982), </journal> <pages> 298-313. 150 </pages>
Reference-contexts: Efficient parallel algorithms for computing shortest paths have been devised for two special classes of planar digraphs: series-parallel digraphs and grid digraphs. A series-parallel digraph <ref> [97] </ref> is an acyclic digraph with exactly one source and exactly one sink that is recursively constructed by series and parallel compositions.
Reference: [98] <author> L. Valiant, </author> <title> "Universality considerations in VLSI circuits," </title> <journal> IEEE Transactions on Computers C-30 (1981), </journal> <pages> 135-140. </pages>
Reference: [99] <author> S. Vavasis, </author> <title> "Automatic domain partitioning in three dimensions," </title> <institution> Department of Computer Science, Cornell, </institution> <type> Technical Report 90-1082, </type> <year> 1990. </year>
Reference: [100] <author> K. Weihe, </author> <title> "Maximum (s; t)-flows in planar networks in O(V log V ) time," </title> <institution> Dept. of Mathematics, T.U. Berlin, </institution> <type> Technical report, </type> <year> 1994, </year> <note> (to appear in the proceedings of FOCS 1994). </note>
Reference-contexts: In particular, we obtain an O (n 4=3 log n)-time algorithm for planar bipartite perfect matching. We obtain an O (n 4=3 log n log C)-time algorithm for maximum flow, where C is the sum of (integral) capacities. Recently Weihe <ref> [100] </ref> has given an O (n log n)-time algorithm for computing max-flow in a directed planar graph. His bounds improve upon our bounds for computing the max-flow and the related problem of bipartite perfect matching. <p> Also, the data structure can be modified in O (n 9=7 log n) time to reflect additions and deletions of edges. The time for deletions is worst-case while the time for additions is amortized. Subsequent work: Recently Weihe <ref> [100] </ref> has given an O (n log n)-time algorithm for computing max-flow in a directed planar graph. Thus his bounds improve upon our bounds for computing the max-flow and the related problem of bipartite perfect matching.
Reference: [101] <author> S. Whitesides, </author> <title> "Forms of hierarchy: A selected bibliography," </title> <type> Gen. </type> <institution> Syst. </institution> <month> 14 </month> <year> (1969), </year> <pages> 3-15. </pages>
Reference-contexts: G is a planar layered digraph if it admits a planar p-line embedding. Figure 5.2 gives an example of a layered graph with a planar 5-line embedding. Layered graphs have been studied under the name of proper hierarchies in <ref> [101] </ref>. Di Battista and Nardelli [20] give efficient algorithms to test if a layered digraph with only one source is planar. Kosaraju [19] has developed an efficient parallel algorithm to evaluate monotone planar layered circuits.
References-found: 101

