URL: http://www.cs.wustl.edu/cs/techreports/1996/wucs-96-21.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: http://www.cs.wustl.edu
Title: Short Title: Continuous Compilation Plezbert, M.Sc. 1996  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Rajive Bagrodia, Wesley W. Chu, Leonard Kleinrock, and Gerald Popek. </author> <title> Vision, issues, and architecture for nomadic computing. </title> <journal> IEEE Personal Communication, </journal> <volume> 2(6), </volume> <month> December </month> <year> 1995. </year>
Reference-contexts: There are currently five options commonly available for wireless data transmission. These five options are described below <ref> [1, 10, 13, 17] </ref>. Spread-spectrum packet radio Wireless local area networks implemented using spread-spectrum packet radio are available. They have a raw data rate of up to 5.7 Mbps, but have a limited range, with a typical radius outside the LAN of 200 to 1000 feet.
Reference: [2] <author> A.P. Ershov. </author> <title> Mixed computation: potential applications and problems for study. </title> <journal> Theoretical Computer Science, </journal> <volume> 18 </volume> <pages> 41-67, </pages> <year> 1982. </year>
Reference-contexts: In Chapter 7 we give some concluding remarks and discuss future work. 7 Chapter 2 Related Work 2.1 Interpreters and Compilers The idea of combining interpreted and native-code text could be traced back to early work by Ershov and others <ref> [2] </ref>, and continues to this day, currently in the active field of partial evaluation. For languages such as C, which have long been implemented primarily by compilation to native code (an exception is the si system [4]), interpreters are experiencing somewhat of a comeback.
Reference: [3] <author> S. Feldman. </author> <title> Make A program for maintaining computer programs. </title> <journal> Software Practice and Experience, </journal> <volume> 9 </volume> <pages> 255-265, </pages> <year> 1979. </year>
Reference-contexts: The setup information for the simulator was not too difficult to obtain. The make utility was used to generate file dependencies <ref> [3] </ref>. The ctags utility determined which functions were contained in each source file. File sizes were obtained using wc. We gathered data on compilation times by compiling the programs with the gcc compiler and using the time utility to report the system and user time needed to compile each file.
Reference: [4] <author> Alan R. Feuer. </author> <title> si|an interpreter for the C language. </title> <booktitle> Proceedings of the 1995 Usenix Summer Conference, 1985. </booktitle> <address> Portland, OR. </address>
Reference-contexts: For example, languages like LISP and Smalltalk have traditionally been interpreted while those like C and Pascal are usually compiled. However, neither paradigm is inviolate. Compilers exist for many LISP variants [8] and interpreters exist for both C and Pascal <ref> [4] </ref>. Interpretation is often used for fields such as rapid prototyping, due to the interactive nature of development and the quick response to change. Compilation is generally used for production-level applications due to the performance advantage of executing a program in native-code form. <p> For languages such as C, which have long been implemented primarily by compilation to native code (an exception is the si system <ref> [4] </ref>), interpreters are experiencing somewhat of a comeback. For one explanation, consider that Proebsting and others are making interpreters much more efficient [19], by combining compiled with interpreted text. However, even optimized interpretation cannot compete with the speed of execution of native code.
Reference: [5] <author> Christopher Fraser and David Hanson. </author> <title> A retargetable C compiler: design and implementation. </title> <address> Benjamin/Cummings, </address> <year> 1995. </year>
Reference-contexts: Render was developed as a class project at Washington University. The performance of each program is, of course, dependent on its input. The input for each program is as follows. 37 Table 6.1: Real Programs Studied Program Description rcc Compiler portion of lcc <ref> [5] </ref> gzip GNU file compression utility gnuchess GNU chess playing program ghostview Postscript file previewer pico Simple text editor render Simple raytracing program rcc The input to rcc was the source file x86.c, which is lcc's code generation module for the Intel x86 architecture. gzip The input provided to gzip was
Reference: [6] <author> S. </author> <title> French. Sequencing and Scheduling. </title> <publisher> Ellis Horwood Limited, </publisher> <year> 1982. </year>
Reference-contexts: If the assumption can be made that the time required for compilation of a file is a monotonically nondecreasing function of file size, then the shortest-first strategy maximizes the throughput (files translated per minute) of the Compiler module. It is analogous to the shortest processing time scheduling algorithm <ref> [6] </ref>. However, it is important to note that maximizing the throughput of the Compiler module is not the same as maximizing the performance of the continuous compilation system as a whole.
Reference: [7] <author> K.J. Gough, C. Cifuentes, D. Corney, J. Hynd, and P. Kolb. </author> <title> An experiment in mixed compilation/interpretation. </title> <journal> Australian Computer Science, </journal> <volume> 14(1), </volume> <year> 1992. </year>
Reference-contexts: As the percentage of time spent in library routines increases, the performance of the program using the continuous compilation model should approach that of executing a native-code version of the program <ref> [7] </ref>. 27 ProGenitor thus focuses on the distinction between library routines and user routines since it was thought that this would be the factor that most influenced the performance of the continuous compiler.
Reference: [8] <author> Martin L. Griss, Eric Benson, and Anthony C. Hearn. </author> <title> Current status of a portable Lisp compiler. </title> <booktitle> In Proceedings of the ACM SIGPLAN '82 Symposium on Compiler Construction, </booktitle> <volume> volume 17, </volume> <pages> pages 276-283, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: In part this is because languages often lend themselves to one paradigm or the other. For example, languages like LISP and Smalltalk have traditionally been interpreted while those like C and Pascal are usually compiled. However, neither paradigm is inviolate. Compilers exist for many LISP variants <ref> [8] </ref> and interpreters exist for both C and Pascal [4]. Interpretation is often used for fields such as rapid prototyping, due to the interactive nature of development and the quick response to change.
Reference: [9] <author> Urs Holzle. </author> <title> Adaptive optimization for Self: Reconciling High Performance with Exploratory Programming. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1994. </year> <note> Report STAN-CS-TR-94-1520. </note>
Reference-contexts: In other related work, adaptive optimization has been considered for the Self language, with the idea of using a fast compiler to generate initial code while an optimizing compiler recompiles heavily used parts <ref> [9] </ref>. Kastens has considered how to generate interpreters automatically from compiler specifications [12].
Reference: [10] <author> Tomasz Imielinski and B.R. Badrinath. </author> <title> Mobile wireless computing. </title> <journal> Communications of the ACM, </journal> <volume> 37(10), </volume> <month> October </month> <year> 1994. </year> <month> 74 </month>
Reference-contexts: There are currently five options commonly available for wireless data transmission. These five options are described below <ref> [1, 10, 13, 17] </ref>. Spread-spectrum packet radio Wireless local area networks implemented using spread-spectrum packet radio are available. They have a raw data rate of up to 5.7 Mbps, but have a limited range, with a typical radius outside the LAN of 200 to 1000 feet.
Reference: [11] <author> Borland International. </author> <title> Interview with regis crelier. http://www.borland.com. 100 Borland Way, </title> <address> Scotts Valley, CA. </address>
Reference-contexts: While speeding up interpretation is always a win, there is inevitably a performance gap between interpretation and heavily optimized target-machine code. Perhaps closest in spirit to the paradigm we propose are the new "just-in-time" (JIT) compilers that are being developed for the Java language <ref> [11] </ref>. However, these compilers differ from the continuous compilation paradigm that we are proposing in several important aspects. First of all, the JIT compiler does not work in tandem with the interpreter; rather it is meant to replace the interpreter.
Reference: [12] <author> Uwe Kastens. </author> <title> Generating interpreters automatically from compiler specifications. </title> <type> Technical report, </type> <institution> Paderborn University, </institution> <month> August </month> <year> 1994. </year> <note> Report tr-ri-94-151. </note>
Reference-contexts: In other related work, adaptive optimization has been considered for the Self language, with the idea of using a fast compiler to generate initial code while an optimizing compiler recompiles heavily used parts [9]. Kastens has considered how to generate interpreters automatically from compiler specifications <ref> [12] </ref>. In comparing our work with the above, note that we are not as interested in maintaining two forms of language processors (a compiler and interpreter) as we are in examining the role of a common, machine-independent representation for applications.
Reference: [13] <author> Randy H. Katz. </author> <title> Adaptation and mobility in wireless information systems. </title> <journal> IEEE Personal Communications, </journal> <volume> 1(1), </volume> <year> 1994. </year>
Reference-contexts: There are currently five options commonly available for wireless data transmission. These five options are described below <ref> [1, 10, 13, 17] </ref>. Spread-spectrum packet radio Wireless local area networks implemented using spread-spectrum packet radio are available. They have a raw data rate of up to 5.7 Mbps, but have a limited range, with a typical radius outside the LAN of 200 to 1000 feet.
Reference: [14] <author> D.E. Knuth. </author> <title> An empirical study of fortran programs. </title> <journal> Software: Practice and Experience, </journal> <volume> 1 </volume> <pages> 105-133, </pages> <year> 1971. </year>
Reference-contexts: Such an endeavor would undoubtedly be helped by the examination of the properties of real programs. Unfortunately, such information is in short supply. The most famous study of the characteristics of real programs is the one performed by Donald Knuth on FORTRAN programs back in 1971 <ref> [14] </ref>. While this study was an invaluable asset to the understanding of the characteristics of actual programs, it is sorely out of date. Blindly assuming that the profiles of programs written in modern modular or object-oriented programming languages would match those of programs written in early FORTRAN seems unconscionable.
Reference: [15] <author> James R. Larus and Eric Schnarr. Eel: </author> <title> Machine-independent executable editing. </title> <booktitle> Proceedings of the SIGPLAN '95 Conference on Programming Langauge Design and Implementation (Sigplan NOTICES), </booktitle> <volume> 30(6), </volume> <year> 1995. </year>
Reference-contexts: Obtaining the behavior traces proved to be more difficult. Neither Gprof nor purify could supply us with the needed data. We were fortunate to have Jim Larus' excellent tool EEL <ref> [15] </ref> for instrumenting the executables to generate trace information. Noah Treuhaft 2 used EEL to create a utility (called eer) to modify binary executables of our test programs.
Reference: [16] <author> Henry Ledgard and Michael Marcotty. </author> <title> The Programming Language Landscape. </title> <institution> Science Research Associates, </institution> <year> 1981. </year>
Reference-contexts: Through the use of superoperators, Proebsting has achieved interpretation speeds only 3-9 times slower than executing unoptimized native code. Without superoperators that value jumps up to 8-16 [19]. Interpretation also has several other features to recommend it <ref> [16] </ref>. Foremost is the interactive nature of interpretation. Interpreted environments can respond immediately to change, without the impediment of lengthy compile times. In interactive applications this can be extremely important.
Reference: [17] <author> Metricom. </author> <title> A brief guide to wireless data solutions. </title> <address> http://www.metricom.com. 980 University Avenue, Los Gatos, CA. </address>
Reference-contexts: There are currently five options commonly available for wireless data transmission. These five options are described below <ref> [1, 10, 13, 17] </ref>. Spread-spectrum packet radio Wireless local area networks implemented using spread-spectrum packet radio are available. They have a raw data rate of up to 5.7 Mbps, but have a limited range, with a typical radius outside the LAN of 200 to 1000 feet. <p> They have a raw data rate of up to 5.7 Mbps, but have a limited range, with a typical radius outside the LAN of 200 to 1000 feet. Bridges using microwave radios are available, but with data rates of only about 1.6 Mbps. 10 The Ricochet Wireless Network Service <ref> [17] </ref> also uses spread-spectrum packet radio, but uses a different network topology to provide greater area coverage. However, the raw data rate for this network is 100 Kbps, with throughput in the 9.8-28.8 Kbps range.
Reference: [18] <author> Sun Microsystems. </author> <title> Sun offers a cupful of. . . hotjava. </title> <journal> Network world, </journal> <volume> 12(21), </volume> <month> May </month> <year> 1995. </year>
Reference-contexts: It is becoming feasible for vendors to maintain a single source for an application, distribute the application in machine-independent form (such as bytecodes), and rely on the remote user's platform to generate the native executable code. The explosive popularity of Sun Microsystems' Java <ref> [18] </ref> language gives testimony to the desire that exists for this computing model. For machine-independent application distribution, there is no choice but to deliver the application in platform-independent form.
Reference: [19] <author> Todd A. Proebsting. </author> <title> Optimizing an ANSI C interpreter with superoperators. </title> <booktitle> In Conference Record of POPL '95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 322-332, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year> <month> 75 </month>
Reference-contexts: With current transmission rates this can mean a difference of over 15 seconds in transmission time. The drawback to using interpretation is again execution performance. We generally assume that, interpreting a program incurs a penalty factor of 10 over executing the program in native-code form <ref> [19] </ref>. Reducing the time required to receive a program to one-sixth of its previous value may not provide any benefit if it takes ten times longer for the program to execute. The use of the continuous compilation model can provide the benefits of the short transmission time without sacrificing performance. <p> For languages such as C, which have long been implemented primarily by compilation to native code (an exception is the si system [4]), interpreters are experiencing somewhat of a comeback. For one explanation, consider that Proebsting and others are making interpreters much more efficient <ref> [19] </ref>, by combining compiled with interpreted text. However, even optimized interpretation cannot compete with the speed of execution of native code. Through the use of superoperators, Proebsting has achieved interpretation speeds only 3-9 times slower than executing unoptimized native code. Without superoperators that value jumps up to 8-16 [19]. <p> more efficient <ref> [19] </ref>, by combining compiled with interpreted text. However, even optimized interpretation cannot compete with the speed of execution of native code. Through the use of superoperators, Proebsting has achieved interpretation speeds only 3-9 times slower than executing unoptimized native code. Without superoperators that value jumps up to 8-16 [19]. Interpretation also has several other features to recommend it [16]. Foremost is the interactive nature of interpretation. Interpreted environments can respond immediately to change, without the impediment of lengthy compile times. In interactive applications this can be extremely important. <p> When using the longest-overall compilation strategy, the speedup is greater than 20%. 6.8 Various Interpretation Penalties Throughout this chapter we have been using an interpretation penalty of 10 for our continuous compiler. While this appears to be a reasonable value to use in light of recent work <ref> [19] </ref>, a quick look at the performance of the continuous compiler with other interpretation penalties would be worthwhile. 57 Table 6.24: Performance with Various Interpretation Penalties Program 3x 10x 100x ghostview 44.841 52.848 76.043 pico 63.536 63.608 64.517 render 137.620 139.956 144.610 Table 6.24 shows the performance of the continuous compiler
References-found: 19

