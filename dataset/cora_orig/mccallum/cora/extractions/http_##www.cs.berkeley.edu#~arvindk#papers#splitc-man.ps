URL: http://www.cs.berkeley.edu/~arvindk/papers/splitc-man.ps
Refering-URL: http://www.cs.berkeley.edu/~arvindk/
Root-URL: http://www.cs.berkeley.edu
Email: Split-C@boing.CS.Berkeley.EDU  
Title: Introduction to Split-C Version 1.0 concepts in Split-C and provides a general introduction to programming
Author: David E. Culler Andrea Dusseau Seth Copen Goldstein Arvind Krishnamurthy Steven Lumetta Steve Luna Thorsten von Eicken Katherine Yelick 
Note: This document describes the central  
Date: April 25, 1995  
Address: Berkeley, CA 94720  
Affiliation: Computer Science Division EECS University of California, Berkeley  
Abstract: Split-C is a parallel extension of the C programming language primarily intended for distributed memory multiprocessors. It is designed around two objectives. The first is to capture certain useful elements of shared memory, message passing, and data parallel programming in a familiar context, while eliminating the primary deficiencies of each paradigm. The second is to provide efficient access to the underlying machine, with no surprises. (This is similar to the original motivation for C|to provide a direct and obvious mapping from high-level programming constructs to low-level machine instructions.) Split-C does not try to obscure the inherent performance characteristics of the machine through sophisticated transformations. This combination of generality and transparency of the language gives the algorithm or library designer a concrete optimization target. 1 This work was supported in part by the National Science Foundation as a Presidential Faculty Fellowship (number CCR-9253705), Research Initiation Award (number CCR-9210260), and Infrastructure Grant (number CDA-8722788), by Lawrence Livermore National Laboratory (task number 33), by the Advanced Research Projects Agency of the Department of Defense monitored by the Office of Naval Research under contract DABT63-92-C-0026, by the Semiconductor Research Consortium under contracts 92-DC-008 and 93-DC-008, and by AT&T. The information presented here does not necessarily reflect the position or the policy of the Government and no official endorsement should be inferred. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Brian W. Kerninghan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <note> second edition, </note> <year> 1988. </year>
Reference-contexts: max); double y = (double) (rand ()&rand max)=(rand max); if ((xflx+yfly) 1.0) return (1); else return (0); g splitc main (int argc, char flflargv) f int i, total hits, hits = 0; double pi; int trials, my trials; if (argc 6= 2) trials = 1000000; else trials = atoi (argv <ref> [1] </ref>); my trials = (trials + PROCS - 1 - MYPROC)=PROCS; srand (MYPROCfl17); /fl Different seed on each processor fl/ for (i=0; i &lt; my trials; i++) hits += hit (); barrier (); total hits = all reduce to one add (hits); on one f pi = 4.0fltotal hits=trials; printf ("PI <p> 2flMYPROC + 1; int even child = 2flMYPROC + 2; int parity = MYPROC & 1; int flbuf = tolocal (&Tbuf [MYPROC][0]); int flglobal dest; if (MYPROC == 0) f if (PROCS == 1) return val; else f if (PROCS == 2) f store sync (4); return (val + buf <ref> [1] </ref>); g else f store sync (8); return (val + buf [1] + buf [0]); g g /fl For all processors but 0 fl/ dest = &Tbuf [parent][parity]; if (odd child PROCS) /fl no children fl/ fldest :- val; else f if (even child PROCS) f store sync (4); fldest :- <p> parity = MYPROC & 1; int flbuf = tolocal (&Tbuf [MYPROC][0]); int flglobal dest; if (MYPROC == 0) f if (PROCS == 1) return val; else f if (PROCS == 2) f store sync (4); return (val + buf <ref> [1] </ref>); g else f store sync (8); return (val + buf [1] + buf [0]); g g /fl For all processors but 0 fl/ dest = &Tbuf [parent][parity]; if (odd child PROCS) /fl no children fl/ fldest :- val; else f if (even child PROCS) f store sync (4); fldest :- val + buf [1]; g else f store sync (8); fldest <p> store sync (8); return (val + buf <ref> [1] </ref> + buf [0]); g g /fl For all processors but 0 fl/ dest = &Tbuf [parent][parity]; if (odd child PROCS) /fl no children fl/ fldest :- val; else f if (even child PROCS) f store sync (4); fldest :- val + buf [1]; g else f store sync (8); fldest :- val + buf [1] + buf [0]; g return val; g 10 LIBRARY EXTENSIONS 44 10 Library extensions This section describes the various libraries in libsplit-c that augment Split-C in the same way that libc augments C. <p> g /fl For all processors but 0 fl/ dest = &Tbuf [parent][parity]; if (odd child PROCS) /fl no children fl/ fldest :- val; else f if (even child PROCS) f store sync (4); fldest :- val + buf <ref> [1] </ref>; g else f store sync (8); fldest :- val + buf [1] + buf [0]; g return val; g 10 LIBRARY EXTENSIONS 44 10 Library extensions This section describes the various libraries in libsplit-c that augment Split-C in the same way that libc augments C. Almost all of the language extensions are library routines.
References-found: 1

