URL: ftp://ftp.cs.umd.edu/pub/realtime/compilers.ps.gz
Refering-URL: http://www.cs.umd.edu/projects/TimeWare/TimeWare-index-no-abs.html
Root-URL: 
Email: rich@cs.umd.edu sshong@cs.umd.edu  
Phone: (301) 405-2710  
Title: Compiler Support for Real-Time Programs  
Author: Richard Gerber and Seongsoo Hong 
Date: July 30, 1994  
Address: College Park, MD 20742  
Affiliation: Department of Computer Science University of Maryland  
Abstract: We present a compiler-based approach to automatically assist in constructing real-time systems. In this approach, source programs are written in TCEL (or Time Constrained Event Language) which possesses high-level timing constructs, and whose semantics characterizes time-constrained relationships between observable events. A TCEL program infers only those timing constraints necessary to achieve real-time correctness, without over-constraining the system. We exploit this looser semantics to help transform programs to automatically achieve schedulability. In this article we present two such transformations. The first is trace-scheduling, which we use to achieve consistency between a program's worst-case execution time and its real-time requirements. The second is program-slicing, which we use to automatically tune application programs driven by rate-monotonic scheduling.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken and A. Nicolau. </author> <title> A development environment for horizontal mi crocode. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 584-594, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Such a process is similar to that of code scheduling, which is a well-defined problem for automatic fine-grain (instruction level) parallelization for superscalar and VLIW processors <ref> [1, 4, 7, 8, 22, 28] </ref>. However, our problem context has a different goal. In what follows, we sketch a code scheduling algorithm, which moves code from sections that violate their duration constraints into those with more lenient constraints.
Reference: [2] <author> Alan Burns. </author> <title> Fixed priority scheduling with deadlines prior to completion. </title> <type> Technical Report YCS 212 (1993), </type> <institution> Department of Computer Science, University of York, </institution> <address> England, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: For example, recall that Method 1 successfully uses the original rate-monotonic scheduler. Thus the following question arises: when can a set of transformed TCEL tasks be scheduled under a fully preemptive, static-priority scheme? Burns <ref> [2] </ref> provides an answer to this question after identifying a simple, but essential fact about the TCEL task model. That is, whenever we let a task's deadline be greater than its period, this represents a relaxation of the classical rate-monotonic restrictions put forth in [21]. <p> In <ref> [2] </ref> Burns presents a search algorithm to generate the feasible static-priority order or to detect when no such order exists. Thus the approach includes the following components. Online Scheduler: This is a simple, preemptive dispatching mechanism, in which priority "ties" are broken in favor of the task dispatched first.
Reference: [3] <author> B. Dasarathy. </author> <title> Timing constraints of real-time systems: Constructs for ex pressing them, method for validating them. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(1) </volume> <pages> 80-86, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Functional requirements define valid translations from inputs into outputs. As such they are realized by a set of programs, which consume CPU time. Temporal requirements, on the other hand, place upper and lower bounds between occurrences of events <ref> [3, 14] </ref>. An example is the robot arm must receive a next-position update every 10 ms. Such a constraint arises from the system's requirements, or from a detailed analysis of the application environment. Thus temporal requirements implicitly limit the time that can be provided by the system's resources.
Reference: [4] <author> K. Ebcioglu and A. Nicolau. </author> <title> A global resource-constrained parallelization technique. </title> <booktitle> In International Conference on Supercomputing, </booktitle> <pages> pages 154-163. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Such a process is similar to that of code scheduling, which is a well-defined problem for automatic fine-grain (instruction level) parallelization for superscalar and VLIW processors <ref> [1, 4, 7, 8, 22, 28] </ref>. However, our problem context has a different goal. In what follows, we sketch a code scheduling algorithm, which moves code from sections that violate their duration constraints into those with more lenient constraints.
Reference: [5] <author> A. Mok et al. </author> <title> Evaluating tight execution time bounds of programs by anno tations. </title> <booktitle> In Proceedings IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 74-80, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Recall the robot controller program from Figure 3. Figure 5 illustrates its constituent sections, where the bracketed numbers are the maximum execution times for each instruction on the given CPU. These times are generated by a timing analysis tool, such as those found in <ref> [10, 5, 25, 27, 32] </ref>. The constraint-expression for S6 corresponds to the program's outer, periodic loop. 3.2 Deriving Code-Based Timing Constraints As seen in Figure 5, the code-based timing constraints can be expressed as conjunctions of linear inequalities between start-times and finish-times of different sections.
Reference: [6] <author> J. Ferrante and K. Ottenstein. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9 </volume> <pages> 319-345, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Briefly stated, a slice of program P with respect to program point p and variable v consists of P 's statements and control predicates that may affect the value of v at point p. To help carry out our slicing approach we use a program dependence graph <ref> [6, 12, 24] </ref>, whose vertices represent a program's instructions, and whose edges represents control, data, and loop-carried dependences between them. For example, the program dependence graph corresponding to our controller program t 3 is shown in Figure 11.
Reference: [7] <author> J. Fisher. </author> <title> Trace scheduling: A technique for global microcode compaction. </title> <journal> IEEE Transactions on Computer, </journal> <volume> 30 </volume> <pages> 478-490, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: Since these timing constraints may conflict with the task's execution time, it may appear to be inherently unschedulable. Hence the objective is to automatically achieve "internal" consistency between real-time requirements and elapsed execution time. Our approach is to use instruction-scheduling techniques <ref> [7] </ref>, with which our compiler moves code from blocks constrained by tight deadlines into blocks with sufficient slack. In Section 4 we address a more aggressive goal inter-task transformations for schedulability. <p> Such a process is similar to that of code scheduling, which is a well-defined problem for automatic fine-grain (instruction level) parallelization for superscalar and VLIW processors <ref> [1, 4, 7, 8, 22, 28] </ref>. However, our problem context has a different goal. In what follows, we sketch a code scheduling algorithm, which moves code from sections that violate their duration constraints into those with more lenient constraints. <p> If S4 violates its duration constraint, the algorithm attempts to reduce its surplus execution time by moving instructions to section S3. In turn, it processes section S3, which may now contain newly moved code. To actually perform greedy code motion, we have adapted the approach to Trace Scheduling in <ref> [7] </ref>, and we use it as a component of the code scheduling algorithm (please consult [11] for more details). Instructions lying on paths that exceed their section's duration constraints are considered for code motion. We distinguish such paths as critical traces.
Reference: [8] <author> F. Gasperoni. </author> <title> Compilation techniques for VLIW architectures. </title> <type> Technical Re port RC 14915(#66741), </type> <institution> IBM T. J. Watson Research Center, </institution> <month> September </month> <year> 1989. </year>
Reference-contexts: Such a process is similar to that of code scheduling, which is a well-defined problem for automatic fine-grain (instruction level) parallelization for superscalar and VLIW processors <ref> [1, 4, 7, 8, 22, 28] </ref>. However, our problem context has a different goal. In what follows, we sketch a code scheduling algorithm, which moves code from sections that violate their duration constraints into those with more lenient constraints.
Reference: [9] <author> R. Gerber and S. Hong. </author> <title> Semantics-based compiler transformations for en hanced schedulability. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 232-242. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1993. </year> <month> 23 </month>
Reference-contexts: Contents of this Chapter. This article summarizes our recent results in program transformations for real-time applications (for a more comprehensive treatment, see [11] and <ref> [9] </ref>). In Section 2 we present an overview of the TCEL language, stressing mainly the event-based semantics. Then, in Section 3 we show how we use code-motion optimizations to resolve conflicts within single tasks. <p> If the updated set is still deemed unschedulable, the procedure goes to work on t n1 , and so on. In <ref> [9] </ref> we present a detailed alternative to this approach, in which tasks are processed from t 1 to t n ; i.e., the first task found unschedulable is selected for slicing. One can imagine other alternatives as well. <p> We briefly sketch the method below (details can be found in <ref> [9] </ref>).
Reference: [10] <author> M. G. Harmon, T. P. Baker, and D. B. Whalley. </author> <title> A retargetable technique for predicting execution time. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 68-77. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1992. </year>
Reference-contexts: Recall the robot controller program from Figure 3. Figure 5 illustrates its constituent sections, where the bracketed numbers are the maximum execution times for each instruction on the given CPU. These times are generated by a timing analysis tool, such as those found in <ref> [10, 5, 25, 27, 32] </ref>. The constraint-expression for S6 corresponds to the program's outer, periodic loop. 3.2 Deriving Code-Based Timing Constraints As seen in Figure 5, the code-based timing constraints can be expressed as conjunctions of linear inequalities between start-times and finish-times of different sections.
Reference: [11] <author> S. Hong and R. Gerber. </author> <title> Compiling real-time programs into schedulable code. </title> <booktitle> In Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation. </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1993. </year> <journal> SIGPLAN Notices, </journal> <volume> 28(6) </volume> <pages> 166-176. </pages>
Reference-contexts: Contents of this Chapter. This article summarizes our recent results in program transformations for real-time applications (for a more comprehensive treatment, see <ref> [11] </ref> and [9]). In Section 2 we present an overview of the TCEL language, stressing mainly the event-based semantics. Then, in Section 3 we show how we use code-motion optimizations to resolve conflicts within single tasks. <p> In turn, it processes section S3, which may now contain newly moved code. To actually perform greedy code motion, we have adapted the approach to Trace Scheduling in [7], and we use it as a component of the code scheduling algorithm (please consult <ref> [11] </ref> for more details). Instructions lying on paths that exceed their section's duration constraints are considered for code motion. We distinguish such paths as critical traces.
Reference: [12] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12 </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Briefly stated, a slice of program P with respect to program point p and variable v consists of P 's statements and control predicates that may affect the value of v at point p. To help carry out our slicing approach we use a program dependence graph <ref> [6, 12, 24] </ref>, whose vertices represent a program's instructions, and whose edges represents control, data, and loop-carried dependences between them. For example, the program dependence graph corresponding to our controller program t 3 is shown in Figure 11.
Reference: [13] <author> Y. Ishikawa, H. Tokuda, and C. Mercer. </author> <title> Object-oriented real-time language design: Constructs for timing constraints. </title> <booktitle> In Proceedings of OOPSLA-90, </booktitle> <pages> pages 289-298, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: As we show in this article, it is precisely the TCEL semantics which makes the compiler transformations possible. The TCEL Language. TCEL contains constructs quite similar to those developed in other experimental languages <ref> [13, 16, 18, 20, 23, 31] </ref>. In these approaches, however, timing constraints are established between blocks of code. The TCEL semantics, on the other hand, establishes constraints between the observable events within the code.
Reference: [14] <author> F. Jahanian and Al Mok. </author> <title> Safety analysis of timing properties in real-time sys tems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(9) </volume> <pages> 890-904, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Functional requirements define valid translations from inputs into outputs. As such they are realized by a set of programs, which consume CPU time. Temporal requirements, on the other hand, place upper and lower bounds between occurrences of events <ref> [3, 14] </ref>. An example is the robot arm must receive a next-position update every 10 ms. Such a constraint arises from the system's requirements, or from a detailed analysis of the application environment. Thus temporal requirements implicitly limit the time that can be provided by the system's resources.
Reference: [15] <author> K. Kenny and K. J. Lin. </author> <title> Building flexible real-time systems using the Flex language. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 70-78, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Similarly, let S4.start and S4.finish represent the start and finish times of section S4. Using these variables we can represent the section decomposition of a TCEL construct in a manner similar to that found in the Flex language <ref> [15] </ref>. Recall the robot controller program from Figure 3. Figure 5 illustrates its constituent sections, where the bracketed numbers are the maximum execution times for each instruction on the given CPU. These times are generated by a timing analysis tool, such as those found in [10, 5, 25, 27, 32].
Reference: [16] <author> E. Kligerman and A. Stoyenko. </author> <title> Real-time Euclid: A language for reliable real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12 </volume> <pages> 941-949, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: As we show in this article, it is precisely the TCEL semantics which makes the compiler transformations possible. The TCEL Language. TCEL contains constructs quite similar to those developed in other experimental languages <ref> [13, 16, 18, 20, 23, 31] </ref>. In these approaches, however, timing constraints are established between blocks of code. The TCEL semantics, on the other hand, establishes constraints between the observable events within the code.
Reference: [17] <author> J. Krause. </author> <title> GN&C domain modeling: Functionality requirements for fixed rate algorithms. </title> <type> Technical Report (DRAFT) version 0.2, </type> <institution> Honeywell Systems and Research Center, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: While the former thread must finish by the original deadline, the latter is allowed to "slide" into the next frame. Thus the transformation effectively increases the original task's deadline, while maintaining its semantics. This approach is particularly appropriate for programs that drive guidance, navigation and control (GN&C) applications <ref> [17] </ref>. First, GN&C programs typically possess periodic behavior; thus they are amenable to fixed-priority, rate-driven scheduling. Second, these programs possess structure resembling that displayed in global state is updated, actuator commands are computed, which are then sent to a set of actuators.
Reference: [18] <author> I. Lee and V. Gehlot. </author> <title> Language constructs for real-time programming. </title> <booktitle> In Pro ceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 57-66. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1985. </year>
Reference-contexts: As we show in this article, it is precisely the TCEL semantics which makes the compiler transformations possible. The TCEL Language. TCEL contains constructs quite similar to those developed in other experimental languages <ref> [13, 16, 18, 20, 23, 31] </ref>. In these approaches, however, timing constraints are established between blocks of code. The TCEL semantics, on the other hand, establishes constraints between the observable events within the code. <p> We conclude in Section 5 with a discussion on the practical implications of our work. 2 Overview of TCEL In this section we present two of TCEL's constructs to denote timing constraints within a program. Both constructs are syntactic descendents of the temporal scope, introduced in <ref> [18] </ref>.
Reference: [19] <author> J. Lehoczky, L. Sha, and Y. Ding. </author> <title> The rate monotonic scheduling algorithm: Exact characterization and average case behavior. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 166-171. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> De-cember </month> <year> 1989. </year>
Reference-contexts: One of these is the exact (necessary and sufficient) test presented in <ref> [19] </ref>, which is based on critical instant analysis. To review, a task's critical instant occurs whenever it is initiated simultaneously with all higher-priority tasks [21].
Reference: [20] <author> K. J. Lin and S. Natarajan. </author> <title> Expressing and maintaining timing constraints in FLEX. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1988. </year>
Reference-contexts: As we show in this article, it is precisely the TCEL semantics which makes the compiler transformations possible. The TCEL Language. TCEL contains constructs quite similar to those developed in other experimental languages <ref> [13, 16, 18, 20, 23, 31] </ref>. In these approaches, however, timing constraints are established between blocks of code. The TCEL semantics, on the other hand, establishes constraints between the observable events within the code.
Reference: [21] <author> C. Liu and J. Layland. </author> <title> Scheduling algorithm for multiprogramming in a hard real-time environment. </title> <journal> Journal of the ACM, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: To accomplish this we apply the technique of program slicing [24, 29, 30], in which a single task is split into multiple threads, based on the application's real-time requirements. This method is particularly amenable to control-domain programs running under rate-monotonic scheduling <ref> [21] </ref>. Using this method, our algorithm converts an unschedulable task set into a schedulable one, by isolating the time-critical threads from each control task, and ensuring that they can be scheduled. In particular, this technique is a safe, automatic way to apply deadline postponement [26] to the unobservable threads. <p> One of these is the exact (necessary and sufficient) test presented in [19], which is based on critical instant analysis. To review, a task's critical instant occurs whenever it is initiated simultaneously with all higher-priority tasks <ref> [21] </ref>. Let T i and C i be the period and the worst case computation time of task t i , respectively, and assume that the t i 's are numbered in the increasing order of their T i 's. <p> That is, whenever we let a task's deadline be greater than its period, this represents a relaxation of the classical rate-monotonic restrictions put forth in <ref> [21] </ref>. Thus the rate-monotonic priority assignment may not be the optimal one; indeed, perhaps another static priority assignment will result in a feasible schedule when the rate-monotonic ordering fails.
Reference: [22] <author> A. Nicolau. </author> <title> Parallelism, Memory Anti-aliasing and Correctness Issues for a Trace Scheduling Compiler. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <month> June </month> <year> 1984. </year> <month> 24 </month>
Reference-contexts: Such a process is similar to that of code scheduling, which is a well-defined problem for automatic fine-grain (instruction level) parallelization for superscalar and VLIW processors <ref> [1, 4, 7, 8, 22, 28] </ref>. However, our problem context has a different goal. In what follows, we sketch a code scheduling algorithm, which moves code from sections that violate their duration constraints into those with more lenient constraints.
Reference: [23] <author> V. Nirkhe. </author> <title> Application of Partial Evaluation to Hard Real-Time Program ming. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Maryland at College Park, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: As we show in this article, it is precisely the TCEL semantics which makes the compiler transformations possible. The TCEL Language. TCEL contains constructs quite similar to those developed in other experimental languages <ref> [13, 16, 18, 20, 23, 31] </ref>. In these approaches, however, timing constraints are established between blocks of code. The TCEL semantics, on the other hand, establishes constraints between the observable events within the code.
Reference: [24] <author> K. Ottenstein and L. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: Our approach is to use instruction-scheduling techniques [7], with which our compiler moves code from blocks constrained by tight deadlines into blocks with sufficient slack. In Section 4 we address a more aggressive goal inter-task transformations for schedulability. To accomplish this we apply the technique of program slicing <ref> [24, 29, 30] </ref>, in which a single task is split into multiple threads, based on the application's real-time requirements. This method is particularly amenable to control-domain programs running under rate-monotonic scheduling [21]. <p> Many factors make this the case, among which are intertwined threads of control, nested control structures, complex data dependences between statements, procedure calls in the task code, etc. To cope with these problems in a systematic manner, we harness a novel application of program slicing <ref> [24, 29, 30] </ref>. Briefly stated, a slice of program P with respect to program point p and variable v consists of P 's statements and control predicates that may affect the value of v at point p. <p> Briefly stated, a slice of program P with respect to program point p and variable v consists of P 's statements and control predicates that may affect the value of v at point p. To help carry out our slicing approach we use a program dependence graph <ref> [6, 12, 24] </ref>, whose vertices represent a program's instructions, and whose edges represents control, data, and loop-carried dependences between them. For example, the program dependence graph corresponding to our controller program t 3 is shown in Figure 11.
Reference: [25] <author> C. Park and A. Shaw. </author> <title> Experimenting with a program timing tool based on source-level timing schema. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 72-81. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1990. </year>
Reference-contexts: Recall the robot controller program from Figure 3. Figure 5 illustrates its constituent sections, where the bracketed numbers are the maximum execution times for each instruction on the given CPU. These times are generated by a timing analysis tool, such as those found in <ref> [10, 5, 25, 27, 32] </ref>. The constraint-expression for S6 corresponds to the program's outer, periodic loop. 3.2 Deriving Code-Based Timing Constraints As seen in Figure 5, the code-based timing constraints can be expressed as conjunctions of linear inequalities between start-times and finish-times of different sections.
Reference: [26] <author> L. Sha, J. Lehoczky, and R. Rajkumar. </author> <title> Solutions for some practical problems in prioritized preemptive scheduling. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 181-191. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1986. </year>
Reference-contexts: Using this method, our algorithm converts an unschedulable task set into a schedulable one, by isolating the time-critical threads from each control task, and ensuring that they can be scheduled. In particular, this technique is a safe, automatic way to apply deadline postponement <ref> [26] </ref> to the unobservable threads. We conclude in Section 5 with a discussion on the practical implications of our work. 2 Overview of TCEL In this section we present two of TCEL's constructs to denote timing constraints within a program. <p> This can be done by postponing the deadline of t 3 (as 14 suggested by Sha et al. in <ref> [26] </ref>). However, since t 3 contains critical IO operations, this technique is not always safe with respect to the event-based semantics. In this section we show how to transform the task so that the original semantics is preserved.
Reference: [27] <author> A. Shaw. </author> <title> Reasoning about time in higher level language software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 875-889, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Recall the robot controller program from Figure 3. Figure 5 illustrates its constituent sections, where the bracketed numbers are the maximum execution times for each instruction on the given CPU. These times are generated by a timing analysis tool, such as those found in <ref> [10, 5, 25, 27, 32] </ref>. The constraint-expression for S6 corresponds to the program's outer, periodic loop. 3.2 Deriving Code-Based Timing Constraints As seen in Figure 5, the code-based timing constraints can be expressed as conjunctions of linear inequalities between start-times and finish-times of different sections.
Reference: [28] <author> M. Smith, M. Horowitz, and M. Lam. </author> <title> Efficient superscalar performance through boosting. </title> <booktitle> In Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 248-259. </pages> <publisher> ACM Press, </publisher> <month> October </month> <year> 1992. </year>
Reference-contexts: Such a process is similar to that of code scheduling, which is a well-defined problem for automatic fine-grain (instruction level) parallelization for superscalar and VLIW processors <ref> [1, 4, 7, 8, 22, 28] </ref>. However, our problem context has a different goal. In what follows, we sketch a code scheduling algorithm, which moves code from sections that violate their duration constraints into those with more lenient constraints.
Reference: [29] <author> G. Venkatesh. </author> <title> The semantic approach to program slicing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: Our approach is to use instruction-scheduling techniques [7], with which our compiler moves code from blocks constrained by tight deadlines into blocks with sufficient slack. In Section 4 we address a more aggressive goal inter-task transformations for schedulability. To accomplish this we apply the technique of program slicing <ref> [24, 29, 30] </ref>, in which a single task is split into multiple threads, based on the application's real-time requirements. This method is particularly amenable to control-domain programs running under rate-monotonic scheduling [21]. <p> Many factors make this the case, among which are intertwined threads of control, nested control structures, complex data dependences between statements, procedure calls in the task code, etc. To cope with these problems in a systematic manner, we harness a novel application of program slicing <ref> [24, 29, 30] </ref>. Briefly stated, a slice of program P with respect to program point p and variable v consists of P 's statements and control predicates that may affect the value of v at point p.
Reference: [30] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10 </volume> <pages> 352-357, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Our approach is to use instruction-scheduling techniques [7], with which our compiler moves code from blocks constrained by tight deadlines into blocks with sufficient slack. In Section 4 we address a more aggressive goal inter-task transformations for schedulability. To accomplish this we apply the technique of program slicing <ref> [24, 29, 30] </ref>, in which a single task is split into multiple threads, based on the application's real-time requirements. This method is particularly amenable to control-domain programs running under rate-monotonic scheduling [21]. <p> Many factors make this the case, among which are intertwined threads of control, nested control structures, complex data dependences between statements, procedure calls in the task code, etc. To cope with these problems in a systematic manner, we harness a novel application of program slicing <ref> [24, 29, 30] </ref>. Briefly stated, a slice of program P with respect to program point p and variable v consists of P 's statements and control predicates that may affect the value of v at point p.
Reference: [31] <author> V. Wolfe, S. Davidson, and I. Lee. RTC: </author> <title> Language support for real-time concurrency. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 43-52. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1991. </year>
Reference-contexts: As we show in this article, it is precisely the TCEL semantics which makes the compiler transformations possible. The TCEL Language. TCEL contains constructs quite similar to those developed in other experimental languages <ref> [13, 16, 18, 20, 23, 31] </ref>. In these approaches, however, timing constraints are established between blocks of code. The TCEL semantics, on the other hand, establishes constraints between the observable events within the code.
Reference: [32] <author> N. Zhang, A. Burns, and M. Nicholson. </author> <title> Pipelined processors and worst case execution times. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 5(4), </volume> <month> October </month> <year> 1993. </year> <month> 25 </month>
Reference-contexts: Recall the robot controller program from Figure 3. Figure 5 illustrates its constituent sections, where the bracketed numbers are the maximum execution times for each instruction on the given CPU. These times are generated by a timing analysis tool, such as those found in <ref> [10, 5, 25, 27, 32] </ref>. The constraint-expression for S6 corresponds to the program's outer, periodic loop. 3.2 Deriving Code-Based Timing Constraints As seen in Figure 5, the code-based timing constraints can be expressed as conjunctions of linear inequalities between start-times and finish-times of different sections.
References-found: 32

