URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS94-10.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Synchronization in Nested Transactions  
Author: Rodolfo Ferreira Resende 
Degree: A Dissertation submitted in partial satisfaction of the requirements for the degree of Doctor of Philosophy in Computer Science by  Committee in Charge: Professor Amr El Abbadi, Chairperson Professor Divyakant Agrawal Professor Oscar Ibarra  
Date: April 1994  
Affiliation: UNIVERSITY OF CALIFORNIA Santa Barbara  
Abstract-found: 0
Intro-found: 1
Reference: [AE92] <author> D. Agrawal and A. El Abbadi. </author> <title> A Non-restrictive Concurrency Control Protocol for Object Oriented Databases. </title> <booktitle> In Proceedings of the Third International Conference on Extending Data Base Technology (EDBT'92), volume 580 of Lecture Notes in Computer Science, </booktitle> <pages> pages 469-482. </pages> <publisher> Springer-Verlag, </publisher> <month> March </month> <year> 1992. </year> <note> An extended version of this paper will appear in Distributed and Parallel Databases: An International Journal. </note>
Reference-contexts: Earlier work on transaction management in object oriented databases has either ignored the issue of semantics [HH91], or have only used semantics partially <ref> [AE92] </ref>, or do not completely deal with referential sharing [MRW + 93]. <p> We have developed a locking-based concurrency control protocol for object-oriented databases. Our protocol generalizes Moss's original nested transaction protocol in that it incorporates the rich semantic information available in object oriented databases. Our protocol incorporates the notions of semantics of higher level objects [BBG89, MRW + 93], nested executions <ref> [HH91, AE92, MRW + 93] </ref> and dynamic conflicts. In particular, we address the issue of referentially shared objects where the referential sharing among objects is determined dynamically during the execution. <p> Consider top-level method executions that have operations conflicting with operations of other method executions. If simply one of these conflicts is not relieved then their corresponding top-level methods cannot be executed in an interleaved manner, potentially defeating the goal of more concurrency. Agrawal and El Abbadi <ref> [AE92] </ref> have proposed a concurrency control protocol for providing transactional access to object-oriented databases. They provided a uniform treatment for dealing with both class and instance objects and extend the two phase locking protocol to objects with arbitrary operations.
Reference: [BBG89] <author> C. Beeri, P. A. Bernstein, and N. Goodman. </author> <title> A Model for Concurrency in Nested Transactions Systems. </title> <journal> Journal of the ACM, </journal> <volume> 36(2) </volume> <pages> 230-269, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Hence we abandon conflict serializability as correctness criterion and we adopt semantic serializability for proving the correctness of our protocols. We have adopted the model of Beeri, Bernstein and Goodman <ref> [BBG89] </ref> as the framework for discussing the correctness of such executions. Its main advantage is that it is an extension of the classical theory, with extensions to deal with the added complexity of nested transactions. This thesis is divided into six chapters. <p> The model is essentially the same as developed by Beeri, Bernstein and Goodman <ref> [BBG89] </ref>. This model extends the classical model of Bernstein, Hadzilacos and Goodman [BHG87] by making explicit use of the concepts of states and return values, and by adding a hierarchical structure to the transaction component of an execution. <p> But we need a more complete model to justify formal aspects used in Chapter 4. To avoid the complexity of dealing with two models we use elements of the more elaborate model, i.e., <ref> [BBG89] </ref>, even when dealing with conflict serializability of nested transactions. The model basically defines the modeled components, and describes through axioms what is expected from executions or computations. Executions that obey these axioms are suitable to be used in equivalence-preserving transformations described later. <p> Recall that this result relates to flat transactions, our first contribution in this dissertation was to establish a similar theorem for nested transactions. In the next section we give an informal description of how the flat transaction model of [BHG87] extends to the nested transaction model of <ref> [BBG89] </ref>. 2.3 From flat to nested transactions Beeri, Bernstein and Goodman [BBG89] describe a model for nested transactions. We based our research in this model. In this section we discuss some of the important differences between flat and nested transactions model. <p> In the next section we give an informal description of how the flat transaction model of [BHG87] extends to the nested transaction model of <ref> [BBG89] </ref>. 2.3 From flat to nested transactions Beeri, Bernstein and Goodman [BBG89] describe a model for nested transactions. We based our research in this model. In this section we discuss some of the important differences between flat and nested transactions model. <p> In flat transactions models most of the complexity is in the level of the atomic operations, and the transaction component is quite simple. In the case of nested transactions the transaction component is more complex. In the nested transaction model of <ref> [BBG89] </ref> the level of the atomic operations is called a DM. This is to evoke that such level is an execution performed by the Data Manager component of a database. The Data Manager is the program or collection of database programs that execute the operations. <p> The Data Manager is the program or collection of database programs that execute the operations. The component of an execution that is related to transactions is now a hierarchical structure. One interesting insight of <ref> [BBG89] </ref> is how to operate or transform these two components, the hierarchical transactions and the DM, producing a new execution in a way that preserves equivalence. We will explore such transformations in later chapters of this dissertation. <p> We will explore such transformations in later chapters of this dissertation. The work of Bernstein, Hadzilacos and Goodman [BHG87] has some implicit as 11 sumptions about the computer and database systems that are explicit in <ref> [BBG89] </ref>. The work of [HH91] also has some implicit assumptions. In [BBG89] eight axioms are listed that describe how a system is expected to behave. There is a reasonable number of definitions connected to these axioms. <p> We will explore such transformations in later chapters of this dissertation. The work of Bernstein, Hadzilacos and Goodman [BHG87] has some implicit as 11 sumptions about the computer and database systems that are explicit in <ref> [BBG89] </ref>. The work of [HH91] also has some implicit assumptions. In [BBG89] eight axioms are listed that describe how a system is expected to behave. There is a reasonable number of definitions connected to these axioms. We adopt all these axioms since we think that systems that obey such axioms are in a certain sense intuitive and well behaved. <p> There is a reasonable number of definitions connected to these axioms. We adopt all these axioms since we think that systems that obey such axioms are in a certain sense intuitive and well behaved. Another difference between [BHG87] and <ref> [BBG89] </ref> is that the latter deals explicitly with the notion of database states and return values of operations in the model. Recall that in the read/write model of [BHG87] such notions are not elements of the model. <p> In [BHG87] it is required that all pairs of conflicting operations, in a history, are ordered. Moreover the notion of equivalence says that in an execution it is only the ordering of conflicting operations that matters. In <ref> [BBG89] </ref> this issue is axiomatized with the concept of Order Preserving Atomicity (OPA). They use partial orders in the definitions of transactions and executions. <p> They use partial orders in the definitions of transactions and executions. OPA is used to axiomatize that the partial order at the level of the operations (the DM level) is equivalent to some totally ordered sequence of the involved operations. In <ref> [BBG89] </ref> and [HH91] a transaction is defined as a partial order of operations. Hence a transaction is a flat structure. In [HH91] there exists a special object (environment) that can start transactions, such transactions are called top-level transactions. In [BBG89] a transaction can be started by a non specified object, and <p> In <ref> [BBG89] </ref> and [HH91] a transaction is defined as a partial order of operations. Hence a transaction is a flat structure. In [HH91] there exists a special object (environment) that can start transactions, such transactions are called top-level transactions. In [BBG89] a transaction can be started by a non specified object, and in this case it is a top-level transaction, or it can be started by another transaction (its parent) and in this case it is called a subtransaction. A subtransaction is viewed by its parent as an operation. <p> A subtransaction is viewed by its parent as an operation. They assume that there exists a convenient mapping between operations and transactions. In the next section we formally summarize the model of <ref> [BBG89] </ref>. 2.4 Nested transactions model The components of a computation are states, operations, transactions, return values, and a partial order. Each state represents the state of the entire database, states are denoted by St = fs 1 ; s 2 ; : : :g. <p> Proposition 2.1 <ref> [BBG89] </ref> Let c = (s 1 ; A; &lt;; r; s 2 ) be a CF. <p> Hence we assume that all D-computations are serial. 1 We will maintain the denomination "Computation Forest" or "CF", despite the introduction of T 0 . 15 We have presented the model of <ref> [BBG89] </ref>. We now would like to take advantage of this presentation, like we did for flat transactions, by also summarizing their correctness theory. In [BBG89] there are no graph based tool for serializability like in the case of flat transactions, they propose the use of transformations. <p> are serial. 1 We will maintain the denomination "Computation Forest" or "CF", despite the introduction of T 0 . 15 We have presented the model of <ref> [BBG89] </ref>. We now would like to take advantage of this presentation, like we did for flat transactions, by also summarizing their correctness theory. In [BBG89] there are no graph based tool for serializability like in the case of flat transactions, they propose the use of transformations. <p> In flat transactions if one wants to prove the correctness of a protocol the proof obligation is to show that for all the executions produced by such protocol their serialization graph is acyclic. The proposal of <ref> [BBG89] </ref> is that if one wants to prove the correctness of a protocol for nested transactions the proof obligation is to show that all executions produced by such protocol can be transformed in a certain form of serial sequence. <p> A CF c is serial if &lt; is a total order on the roots and on the children of each node. A CF c is serializable (SR) if it is equivalent to some serial CF. We now use some definitions from <ref> [BBG89] </ref>. Let &lt; be a partial order. For sets X and Y , we write X &lt; Y if, for all x 2 X and y 2 Y , x &lt; y holds. Let X be a set of nodes. <p> Let c be a CF, x a node separated by &lt;, and d a computation tree with root x such that d c x . Then ~c = c [c x ( d] is a CF and c ~c. The substitution theorem of <ref> [BBG89] </ref> is important in the sense that they put their correctness theory apart from the correctness theories that establish equivalence of the same system. Consider for example the flat transactions correctness theory, there we establish equivalence between histories involving the same operations. <p> Consider for example the flat transactions correctness theory, there we establish equivalence between histories involving the same operations. It is basically the substitution theorem that gives the correctness theory of <ref> [BBG89] </ref> its power and also its complexity. The substitution theorem can be specialized in reduction and expansion. <p> Expansion is the reverse of reduction, the substituted node is a leave and all the children of the node that is replacing it are leaves. We now present the definition of commutativity presented in <ref> [BBG89] </ref>. Let o 1 and o 2 be operations and s be a state. <p> Two operations (generally) commute if they commute with respect to all states. Operation o 1 conflicts with o 2 if o 1 does not commute with o 2 . The definition of commutativity of <ref> [BBG89] </ref> can be specialized for example in right backward commutativity [Wei89]: We say that o 1 right backwards commute with o 2 if for all states s where (s; fo 1 ; o 2 g; (o 1 ; o 2 ); r; s) 2 D then (s; fo 1 ; o <p> Relaxing the definitions of commutativity is one of the ways that enable a scheduler to accept more executions, we do not pursue this direction here. Observe that <ref> [BBG89] </ref> define commutativity only for operations. This may look restrictive but thanks to substitution, a node that is an internal node in one CF can correspond to a leaf in an equivalent CF, and then it may relate through commutativity to other operations, avoiding cautioning with respect to atomicity. <p> In Chapter 4 we will introduce a definition of commutativity that involves internal nodes. We will adopt the same definition of commutativity as here for atomic operations but extended to handle commutativity between internal nodes. We now continue our description of correctness in <ref> [BBG89] </ref> presenting more definitions that will enable the presentation of Commutativity-based reversal the second and last execution transformation. 17 Let &lt; be a partial order on A. <p> In later chapters we will try to be less formal, informally what we mean here is that x and y can be reversed in an execution if they commute and they are not algorithmically related. In <ref> [BBG89] </ref> the reversal of two operations obtaining a new execution is formally presented including the changes in &lt;. Commutativity Theorem. Let x and y be leaves of c whose order can be reversed, and let ~c be obtained from c by reversing their order. <p> Then ~c is a CF and c ~c. The commutativity theorem is the formal basis of the Commutativity-based reversal transformation. This theorem allows the use of commutativity to change the order of adjacent leaves. Our results in Chapter 3 are all related to commutativity-based reversals. Observe that <ref> [BBG89] </ref> define classes of computations that can be proved serializ-able using substitution and commutativity-based reversal. Classes of correctness are not distinguished here and a different nomenclature is adopted. A CF c is semantically equivalent to c if we can get c from c using substitution and commutativity-based reversal transformations. <p> In [HH91] a transaction corresponds to a method invocation. An operation in <ref> [BBG89] </ref> can correspond either to a method step or a local step. A local step corresponds to an operation executed by the DM whereas the method step is an operation that invokes a method execution, i.e., a transaction. <p> A local step corresponds to an operation executed by the DM whereas the method step is an operation that invokes a method execution, i.e., a transaction. In [HH91] the return values are tied directly to the local and message steps. Most of the the axioms of <ref> [BBG89] </ref> have their correspondents in [HH91]. In [HH91] the concept of a well-defined execution description is described as a legal history. In [HH91] (C1) and (C2) are for free simply by using the mathematical concept of functions instead of the tuples of [BBG89]. <p> Most of the the axioms of <ref> [BBG89] </ref> have their correspondents in [HH91]. In [HH91] the concept of a well-defined execution description is described as a legal history. In [HH91] (C1) and (C2) are for free simply by using the mathematical concept of functions instead of the tuples of [BBG89]. Axioms (C3) and (C8) correspond to conditions 2-(b) and (3) of legal histories. Axioms (C4) and (C5) does not have an explicit correspondence. Axiom (C6) corresponds to condition 2-(c) of legal histories, and axiom (C7) corresponds to condition 2-(a) of legal histories. <p> Using this notion we present a definition of conflict serializability for concurrency control of nested transactions. Although our approach is more restrictive than <ref> [BBG89] </ref> it allows the development of a serializability theory similar to the classical theory. Our contribution is a group of definitions and proofs that enable proofs of correctness of protocols for nested transactions. <p> We then contrast this definition with other definitions. We will adopt the same definition of commutativity as the one of <ref> [BBG89] </ref> also presented in Chapter model. Our definition of serial execution is also the same. But our definition of equivalence of executions is quite different. Let &lt; and &lt; 0 be total orders such that &lt; is a permutation of &lt; 0 . <p> Now we will prove that if two DM tuples are conflict equivalent and one of them is a D-computation then the other is also a D-computation. We will use the technique of reversing commutative operations presented in <ref> [BBG89] </ref> and [Pap86]. First we show that the DM-tuple obtained by inverting the order of two contiguous and commutative operations of a D-computation is also in D. <p> The combination of these two facts shows x precedes y in c 0 , contradicting the definition. 21 Our notion of serializability differs from previously proposed notions. In <ref> [BBG89] </ref> two CFs are equivalent if they have the same initial and final states and their roots have the same return values. In [HH91] the equivalence concept was strengthened by requiring not only the same roots but also the same forest (with the same return value for each node). <p> We consider states and return values only to take advantage of the state-dependent commutativity definition, thus remaining within the confines of the general theory presented in <ref> [BBG89] </ref>. Note that in [FLW90] serial correctness for T 0 corresponds to serializability in [BBG89]. To illustrate the difference between the equivalence definitions of [BBG89] and [HH91], consider a transaction that increments an integer data item, using a read and a write operation. <p> We consider states and return values only to take advantage of the state-dependent commutativity definition, thus remaining within the confines of the general theory presented in <ref> [BBG89] </ref>. Note that in [FLW90] serial correctness for T 0 corresponds to serializability in [BBG89]. To illustrate the difference between the equivalence definitions of [BBG89] and [HH91], consider a transaction that increments an integer data item, using a read and a write operation. Consider two increment subtransactions belonging to two different top-level transactions. In [BBG89] the order of the two increments is irrelevant as long <p> We consider states and return values only to take advantage of the state-dependent commutativity definition, thus remaining within the confines of the general theory presented in <ref> [BBG89] </ref>. Note that in [FLW90] serial correctness for T 0 corresponds to serializability in [BBG89]. To illustrate the difference between the equivalence definitions of [BBG89] and [HH91], consider a transaction that increments an integer data item, using a read and a write operation. Consider two increment subtransactions belonging to two different top-level transactions. In [BBG89] the order of the two increments is irrelevant as long as the underlying read and write operations are not interleaved. <p> [FLW90] serial correctness for T 0 corresponds to serializability in <ref> [BBG89] </ref>. To illustrate the difference between the equivalence definitions of [BBG89] and [HH91], consider a transaction that increments an integer data item, using a read and a write operation. Consider two increment subtransactions belonging to two different top-level transactions. In [BBG89] the order of the two increments is irrelevant as long as the underlying read and write operations are not interleaved. In contrast, in [HH91], the order is significant since all operations must return the same values, including the read and write that implement the increment operation. <p> Hence, for the subset of executions that strictly depends on conflict information from the leaves, our approach complements the theory of Beeri, Bernstein and Goodman <ref> [BBG89] </ref>. <p> Such a conflict cannot be determined a priori based on the static analysis rather it materializes as the particular methods are executed. Beeri, Bernstein, and Goodman <ref> [BBG89] </ref> developed a general theory to reason about nested executions with semantics that is summarized in Chapter 2. They have an 35 equivalence concept that we call semantic equivalence in contrast to our conflict equiv-alence presented in chapter 3. <p> A lock lock (x) can be granted to a method execution iff (a) No other method execution holds a conflicting lock, and (b) All the retainers of a conflicting lock are ancestors of the requesting method execution. It is shown in <ref> [BBG89, HH91] </ref> that N2PL ensures serializability. Since N2PL does not take advantage of any knowledge about the semantics of the methods being executed, we can prove its correctness using the techniques of Chapter 3. <p> This is because the commutativity of these two method executions is derived assuming the atomicity of the operations. In this execution the two method executions are not 38 executed atomically with respect to each other. Using the theory described in <ref> [BBG89] </ref> we can establish the semantic serializability of the execution showed in Figure 4.4. We can reduce the computations rooted at method executions "decrease-percent ()" since these computations are separated. <p> We have developed a locking-based concurrency control protocol for object-oriented databases. Our protocol generalizes Moss's original nested transaction protocol in that it incorporates the rich semantic information available in object oriented databases. Our protocol incorporates the notions of semantics of higher level objects <ref> [BBG89, MRW + 93] </ref>, nested executions [HH91, AE92, MRW + 93] and dynamic conflicts. In particular, we address the issue of referentially shared objects where the referential sharing among objects is determined dynamically during the execution. <p> In particular, we address the issue of referentially shared objects where the referential sharing among objects is determined dynamically during the execution. The correctness of our protocol is based on the theory of nested transactions proposed in <ref> [BBG89] </ref>. 5.1 Using semantics of methods We start by describing some of the salient aspects of object-oriented databases that are considered in the design of our protocol. In general, in object-oriented databases, the conflicts and commutativity relations between methods are defined on a per class basis. <p> For example, in Figure 4.5, semantic locking results in a deadlock. This occurs since both T 1 and T 2 are both blocked when trying to obtain locks on gadget2. To reason about the correctness of semantic locking we use the two transformations described in <ref> [BBG89] </ref>. We illustrate the use of these two transformations in Figure 5.1 using the example of Figure 4.4. Since each "decrease-percent ()" in execution (a) is separated we can reduce them. We can go from execution (a) to execution (b) by using four reductions. <p> In execution (c), since T 1 and T 2 are separated we can use two reductions to obtain execution (d) which is a serial execution. We now use the bottom-up proof paradigm of <ref> [BBG89] </ref> to informally argue about the correctness of semantic locking. The goal is to create a sequence of equivalent executions starting from an execution, c 0 , resulting from semantic locking and terminating with a serial execution, c serial , consisting of top-level transactions. <p> Theorem 5.1 Semantic locking allows only serializable executions. Proof. We first give a summary of the proof. We will use the theory in <ref> [BBG89] </ref> to show that all executions produced by semantic locking are equivalent to a serial execution. Let c 1 be an execution produced by semantic locking.
Reference: [BDK92] <editor> F. Bancilhon, C. Dolobel, and P. Kanellakis, editors. </editor> <title> Building an Object-Oriented database System: </title> <publisher> The story of O 2 . Morgan Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: Thus OH-semantic locking only produces semantically serializable executions. 2 5.4 Other works In traditional databases, the most commonly adopted correctness criterion is seri-alizability. Object-oriented database systems such as ORION [GK88, Kim90] and O 2 <ref> [CF90, BDK92] </ref> ensure the serializable execution of transactions. Both of these database systems employ a locking protocol based on multigranularity locking [Gra78].
Reference: [BHG87] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: That is, whenever a program execution starts with a database state that is consistent, it must leave the database in a consistent state after it terminates. Consistency preservation captures the concept of producing database states that are meaningful <ref> [BHG87] </ref>. A computer system may want to support more than one program executing at the same time, i.e., to support multiprogramming. This is done in order to benefit from the potential parallelism of processor and I/O activity. The superposition of processor and I/O activity provides efficiency. <p> Here what we mean by correct execution is an execution that preserves database consistency. However in a concurrent system, due to the interleaving of accesses, an execution that would be correct if the program was running alone, can result in an inconsistent database <ref> [Pap86, BHG87] </ref>. This is due to the non-controlled interference of operations over the shared data. <p> These two requirements are satisfied with the adoption of a database component called scheduler. The scheduler is a program or collection of programs that controls the concurrent execution of (application) programs <ref> [BHG87] </ref>. It exercises this control by restricting the order in which the accesses to the shared data are executed. The scheduler bases its decisions by following some set of rules known as a protocol. The interface between application programs and the scheduler gives origin to the concept of transaction [BHG87]. <p> programs <ref> [BHG87] </ref>. It exercises this control by restricting the order in which the accesses to the shared data are executed. The scheduler bases its decisions by following some set of rules known as a protocol. The interface between application programs and the scheduler gives origin to the concept of transaction [BHG87]. This is analogous to the concept of process at the interface of application programs and the operating system. Transactions add properties to the notion of process, we can informally consider that they are specialization of processes. <p> The properties of a transaction depends on the system implementation. However one important property that most database systems implement is transaction atomicity. Transaction atomicity captures the notion that the transaction is executed either with 2 out any interference or none of a transaction's operations are performed <ref> [BHG87] </ref>. If transaction atomicity can be guaranteed then the two requirements above are satisfyed as will be discussed more formally later in this dissertation. Among the operations at the interface of an application program and the sched-uler an operation called abortion is usually provided. <p> Informally conflict is a relation on database operations that captures the concept of whether an operation can interfere with another operation. There are basically two approaches for defining conflicts. One approach is to enumerate the operations of a system and to define the conflict relation explicitly <ref> [BHG87] </ref>. Another way of defining a conflict relation is to specify the conditions for conflict and leave the operations unspecified [Kor83]. An execution is conflict serializable if there exists a serial execution of the same transactions where the order of the conflicting pairs is the same in both. <p> Such a graph has nodes representing the transactions and edges representing the existence of operations that conflict. The fundamental theorem of the theory relates the conflict serializability of an execution with the absence of cycles in its corresponding graph <ref> [BHG87] </ref>. Most of the results of the classical theory of database are also available in terms of multilevel transactions [Wei91]. 5 Our first contribution presented in this dissertation is related to extending the re-sults of conflict serializability of the classical theory from flat to nested transactions. <p> The model is essentially the same as developed by Beeri, Bernstein and Goodman [BBG89]. This model extends the classical model of Bernstein, Hadzilacos and Goodman <ref> [BHG87] </ref> by making explicit use of the concepts of states and return values, and by adding a hierarchical structure to the transaction component of an execution. In Chapter 3 we will make use of only a few features of the model. <p> Executions that obey these axioms are suitable to be used in equivalence-preserving transformations described later. Before we present the nested transaction model, we will present a summary of serializability theory for flat transactions <ref> [BHG87] </ref>. 7 2.2 Flat transactions model The interface of an application program and the scheduler gives origin to the concept of transaction. A transaction corresponds to the trace of execution of an application program as seen by the database. The key property of a transaction is atomicity. <p> We discuss concurrency control issues. Serializability is the counterpart of transaction atomicity in terms of concurrency control. Serializability theory is a mathematical tool that allow us to prove whether or not a scheduler works correctly <ref> [BHG87] </ref>. We begin considering objects and operations. The shared data consists of a set of objects and each object supports certain operations. In some models only read and write operations are considered. These are referred to as read/write models. <p> In this latter model we have two formal definition of commutativity one that is state dependent and the other state independent. Transactions can be described as sequences of operations [Pap86], or as a partial order of operations <ref> [BHG87] </ref>. The advantage of modeling transactions as a partial order is that the transaction need not specify the ordering of every two operations that appear in it. Beyond being a sequence or a partial order of operations some conditions must be satisfied. <p> Beyond being a sequence or a partial order of operations some conditions must be satisfied. Lets review the formal definition of a transaction in <ref> [BHG87] </ref>. A transaction T i is a partial order with ordering relation &lt; i where 1. <p> Condition (1) defines the operations of their model. The model in <ref> [BHG87] </ref> is a read/write model. The operations a i and c i correspond to abortion and commit respectively. When dealing with an aborted transaction one should consider that its operations have no effects in the database. A committed transaction is a transaction that successfully operates a database state transformation. <p> Condition (2) says that a transaction either aborts or commits. Condition (3) says that the abortion or commitment of a transaction follows all the other operations. Condition (4) says that it is the responsibility of the transaction to order the conflicting operations. Commit and abort operations are included in <ref> [BHG87] </ref> because they also discuss recovery in their work. Since we do not discuss recovery issues in this dissertation we will not emphasize such operations. We will assume that we are only dealing with committed transactions. <p> Similarly to the case of transactions, histories can be described as sequence of operations or as a 9 partial order of operations. Some well-formedness criteria has to be added. Lets now review the concept of history in <ref> [BHG87] </ref>. Let T = fT 1 ; : : : ; T n g be a set of transactions. A history H over T is a partial order with ordering relation &lt; H where: 1. <p> Condition (1) says that the operations of H are the operations of the involved transactions. Condition (2) says that H must honor the orderings of the involved transactions Condition (3) says that all pairs of conflicting operations are ordered. Since <ref> [BHG87] </ref> wants to distinguish between a prefix and a complete history, the concept above is actually called in their work a complete history. We have presented the model of [BHG87]. We now would like to take advantage of this presentation by also summarizing their correctness theory. <p> Since <ref> [BHG87] </ref> wants to distinguish between a prefix and a complete history, the concept above is actually called in their work a complete history. We have presented the model of [BHG87]. We now would like to take advantage of this presentation by also summarizing their correctness theory. Recall that we want to be able to characterize atomic transactions. In terms of concurrency control this translates in serializable histories. <p> In terms of concurrency control this translates in serializable histories. Intuitively a history is serializable if it has the same effects of a history where transactions are executed one after the other, i.e., a serial history. Lets review how this is presented in <ref> [BHG87] </ref>. <p> As <ref> [BHG87] </ref> remark, the idea underlying this definition is that the outcome of a concurrent execution of transactions depends only on the relative ordering of conflicting operations. <p> A history H is serializable if it is equivalent to a serial history H s . Since we are not dealing with prefixes of histories as in <ref> [BHG87] </ref>, we do not have to care about them. 10 The determination of whether a history is serializable can be done by analyzing a graph derived from the history called a serialization graph. <p> The fundamental theorem of serializability theory says that a history H is serializ-able iff SG (H) is acyclic <ref> [BHG87] </ref>. Recall that this result relates to flat transactions, our first contribution in this dissertation was to establish a similar theorem for nested transactions. In the next section we give an informal description of how the flat transaction model of [BHG87] extends to the nested transaction model of [BBG89]. 2.3 From <p> a history H is serializ-able iff SG (H) is acyclic <ref> [BHG87] </ref>. Recall that this result relates to flat transactions, our first contribution in this dissertation was to establish a similar theorem for nested transactions. In the next section we give an informal description of how the flat transaction model of [BHG87] extends to the nested transaction model of [BBG89]. 2.3 From flat to nested transactions Beeri, Bernstein and Goodman [BBG89] describe a model for nested transactions. We based our research in this model. In this section we discuss some of the important differences between flat and nested transactions model. <p> One interesting insight of [BBG89] is how to operate or transform these two components, the hierarchical transactions and the DM, producing a new execution in a way that preserves equivalence. We will explore such transformations in later chapters of this dissertation. The work of Bernstein, Hadzilacos and Goodman <ref> [BHG87] </ref> has some implicit as 11 sumptions about the computer and database systems that are explicit in [BBG89]. The work of [HH91] also has some implicit assumptions. In [BBG89] eight axioms are listed that describe how a system is expected to behave. <p> There is a reasonable number of definitions connected to these axioms. We adopt all these axioms since we think that systems that obey such axioms are in a certain sense intuitive and well behaved. Another difference between <ref> [BHG87] </ref> and [BBG89] is that the latter deals explicitly with the notion of database states and return values of operations in the model. Recall that in the read/write model of [BHG87] such notions are not elements of the model. In [BHG87] it is required that all pairs of conflicting operations, in <p> Another difference between <ref> [BHG87] </ref> and [BBG89] is that the latter deals explicitly with the notion of database states and return values of operations in the model. Recall that in the read/write model of [BHG87] such notions are not elements of the model. In [BHG87] it is required that all pairs of conflicting operations, in a history, are ordered. Moreover the notion of equivalence says that in an execution it is only the ordering of conflicting operations that matters. <p> Another difference between <ref> [BHG87] </ref> and [BBG89] is that the latter deals explicitly with the notion of database states and return values of operations in the model. Recall that in the read/write model of [BHG87] such notions are not elements of the model. In [BHG87] it is required that all pairs of conflicting operations, in a history, are ordered. Moreover the notion of equivalence says that in an execution it is only the ordering of conflicting operations that matters. In [BBG89] this issue is axiomatized with the concept of Order Preserving Atomicity (OPA). <p> The difference between our notion of equivalence and that of [HH91] can be easily illustrated by any view serializable execution of flat transactions that is not conflict serializable <ref> [BHG87] </ref>. Although more restrictive, our approach allows for the development of a serializability theory similar to the classical theory for flat transactions. In the next section we develop a serialization graph for nested transactions and show that the acyclicity of the graph is both necessary and sufficient for conflict serializability. <p> on operational techniques such as commutativity-based reversals and substitution while conflict serializability can be proven using graph-theoretical techniques. 3.3 The Serializability Theorem In this section we prove a theorem which establishes a necessary and sufficient condition for conflict serializability of nested transactions, similar to the fundamental theorem of 22 serializability <ref> [BHG87] </ref> for flat transactions. First we define the serialization graph for nested transactions then we present the theorem. <p> A filled circle denotes a transaction or an operation and a solid line denotes a caller-callee relationship. Nodes T 1 and T 2 are transactions. Nodes w 1 [x], r 2 [x], and w 2 [x] are atomic operations using the same notation as in <ref> [BHG87] </ref>, with the same conflict relation, i.e. 25 two operations conflict if both are on the same object and at least one of them is a write (w) operation.
Reference: [CF90] <author> M. Cart and J. Ferrie. </author> <title> Integrating Concurrency Control into an Object-Oriented Database System. </title> <booktitle> In Proceedings of the International Conference on Extending Data Base Technology, </booktitle> <publisher> Springer-Verlag, LNCS 416, </publisher> <pages> pages 363-376, </pages> <year> 1990. </year>
Reference-contexts: Two method invocations x and y on the same object commute if and only if the two possible sequential executions of x and y are indistinguishable for both x and y and for all possible sequences of methods that may be invoked subsequently <ref> [CF90, HW91, MRW + 93] </ref>. Table 4.1 illustrates the commutativity relationships between the methods of class object I tem. The entry ? indicates that the relationship is undefined. <p> In general, in object-oriented databases, the conflicts and commutativity relations between methods are defined on a per class basis. Methods on different objects are generally assumed to commute with each other <ref> [GK88, CF90, HH91, MRW + 93] </ref>. This approach is reasonable for object-oriented databases with disjoint complex objects. However, in a system with referentially shared sub 44 objects, the commutativity relation needs to be redefined even for methods that are executed on different objects. <p> Thus OH-semantic locking only produces semantically serializable executions. 2 5.4 Other works In traditional databases, the most commonly adopted correctness criterion is seri-alizability. Object-oriented database systems such as ORION [GK88, Kim90] and O 2 <ref> [CF90, BDK92] </ref> ensure the serializable execution of transactions. Both of these database systems employ a locking protocol based on multigranularity locking [Gra78].
Reference: [EGLT76] <author> K. P. Eswaran, J. N. Gray, R. A. Lorie, and I. L. Traiger. </author> <title> The Notions of Consistency and Predicate Locks in a Database System. </title> <journal> Communications of the ACM, </journal> 19(11) 624-633, November 1976. <volume> 71 </volume>
Reference-contexts: Moss [Mos85] introduced the notion of nested transactions for modular composition of applications and programs in database systems. He proposed the nested two phase locking protocol (N2PL) which is a generalization of the well-known two-phase locking protocol for concurrency control <ref> [EGLT76] </ref>. We have developed a locking-based concurrency control protocol for object-oriented databases. Our protocol generalizes Moss's original nested transaction protocol in that it incorporates the rich semantic information available in object oriented databases.
Reference: [FLMW90] <author> A. Fekete, N. Lynch, M. Merrit, and W. Weihl. </author> <title> Commutativity-based locking for nested transactions. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 41(1) </volume> <pages> 65-156, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Most of the research in the area of database concurrency control uses a model where the scheduler is not described explicitly, rather the scheduler is described by the properties of the executions allowed by the protocol that it follows. Such model is sometimes referred as the classical model <ref> [FLMW90] </ref>. A model deals with at least the following three entities: * The shared data. Access to the data is provided by atomic operations that return a value and operate a state transition. * Application programs that access the shared data.
Reference: [FLW90] <author> A. Fekete, N. Lynch, and W. Weihl. </author> <title> A Serialization Graph Construction for Nested Transactions. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 94-108, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: The special case in which F is a one-level forest, c is also a DM tuple. Sometimes it is convenient to treat a given forest as a tree. This can be done by adding a root (in <ref> [FLW90] </ref> this root is called "mythical" T 0 ). <p> Axioms (C3) and (C8) correspond to conditions 2-(b) and (3) of legal histories. Axioms (C4) and (C5) does not have an explicit correspondence. Axiom (C6) corresponds to condition 2-(c) of legal histories, and axiom (C7) corresponds to condition 2-(a) of legal histories. The model of <ref> [FLW90] </ref> differs from the models that we have discussed more radically. They use the notion of input/output automaton. An input/output automaton describes events and state transformations of system components. Such formalism is very powerful but unfortunately more complex than the traditional theory. <p> We consider states and return values only to take advantage of the state-dependent commutativity definition, thus remaining within the confines of the general theory presented in [BBG89]. Note that in <ref> [FLW90] </ref> serial correctness for T 0 corresponds to serializability in [BBG89]. To illustrate the difference between the equivalence definitions of [BBG89] and [HH91], consider a transaction that increments an integer data item, using a read and a write operation. Consider two increment subtransactions belonging to two different top-level transactions. <p> This means that the serialization graph of [HH91] naot only has redundant edges, but possibly has redundant cycles when rejecting executions. The serialization graph of <ref> [FLW90] </ref> is defined in terms of the union of serialization graphs of individual transactions. A serialization graph for an individual transaction has its children as nodes and the edges are conflict and algorithmic edges. <p> A serialization graph for an individual transaction has its children as nodes and the edges are conflict and algorithmic edges. Hence their serialization graph does not have redundant edges nor redundant cycles, and it is quite similar to ours. The differences come only from the background models. In <ref> [FLW90] </ref> the serial correctness is defined as an external component, and not as the rearrangement of the same elements of an execution. <p> We will now describe the Children's Serialization Graph Testing, (CSGT) protocol [Jag90]. One interesting aspect of the protocol is the modular way it is defined. This protocol is the graph testing version of a serialization graph very similar to the serialization graph of <ref> [FLW90] </ref>. The proof of correctness we develop here indirectly connects our work to the work of [FLW90]. The Children's Serialization Graph of transaction t, CSG (t), is a directed graph where nodes are the children of t. <p> One interesting aspect of the protocol is the modular way it is defined. This protocol is the graph testing version of a serialization graph very similar to the serialization graph of <ref> [FLW90] </ref>. The proof of correctness we develop here indirectly connects our work to the work of [FLW90]. The Children's Serialization Graph of transaction t, CSG (t), is a directed graph where nodes are the children of t. <p> Furthermore, the referential sharing of objects may occur dynamically during execution. Our assumptions are as follows. We assume that for each class, conflict relations are defined for the atomic operations. This is the same assumption made by most previous work in both nested transactions and object oriented databases <ref> [Mos85, HH91, FLW90] </ref>. However, we enrich this model by exploiting semantic information, i.e., commutativity relations that are derived from the semantics of methods of classes. Specifically we assume that commutativity information about pairs of methods is potentially available. Such methods are known to commute a priori.
Reference: [GK88] <author> J. F. Garza and W. Kim. </author> <title> Transaction Management in an Object-oriented Data Model. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 37-55, </pages> <month> June 88. </month>
Reference-contexts: Another aspect of an object-oriented database system is executions hierarchies that map nicely on nested transactions we have presented in Chapter 2. An operation invoked on a higher level object results in an entire execution hierarchy on lower level objects, sometimes referred to as composite objects <ref> [GK88] </ref>. This aspect has a nice mapping with the nested transactions we presented in Chapter 2. If traditional approaches such as strict two phase locking are used to manage composite objects, the execution hierarchies of two conflicting operations must be completely disjoint from each other. <p> The complexity of these nested executions is increased by the fact that in general one object can have its methods called by methods of more than one object, i.e., the involved objects are referentially shared <ref> [GK88] </ref>. Unlike relational databases where all interactions to the database is via read and write operations, objects have rich semantics associated with them. This semantics can potentially be used to increase concurrency among concurrent transactions. In this dissertation, we present locking protocols for transaction management in an object oriented databases. <p> In general, in object-oriented databases, the conflicts and commutativity relations between methods are defined on a per class basis. Methods on different objects are generally assumed to commute with each other <ref> [GK88, CF90, HH91, MRW + 93] </ref>. This approach is reasonable for object-oriented databases with disjoint complex objects. However, in a system with referentially shared sub 44 objects, the commutativity relation needs to be redefined even for methods that are executed on different objects. <p> Thus OH-semantic locking only produces semantically serializable executions. 2 5.4 Other works In traditional databases, the most commonly adopted correctness criterion is seri-alizability. Object-oriented database systems such as ORION <ref> [GK88, Kim90] </ref> and O 2 [CF90, BDK92] ensure the serializable execution of transactions. Both of these database systems employ a locking protocol based on multigranularity locking [Gra78].
Reference: [Gra78] <author> J. N. Gray. </author> <title> Notes on database systems. </title> <editor> In R. Bayer, R. M. Graham, and G. Seegmuller, editors, </editor> <booktitle> Operating Systems: An Advanced Course, volume 60 of Lecture Notes in Computer Science, </booktitle> <pages> pages 393-481. </pages> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: Object-oriented database systems such as ORION [GK88, Kim90] and O 2 [CF90, BDK92] ensure the serializable execution of transactions. Both of these database systems employ a locking protocol based on multigranularity locking <ref> [Gra78] </ref>. Multigranularity locking was developed to reduce locking overhead by organizing the database in the form of a hierarchy, e.g., the database is composed of files, and each file is composed of a set of records etc.
Reference: [HDK + 90] <author> U. Herrmann, P. Dadam, K. Kuspert, E. Roman, and G. Schl ageter. </author> <title> A Lock Technique for Disjoint and Non-Disjoint Complex Objects. </title> <booktitle> In Proceedings of the International Conference on Extending Data Base Technology, </booktitle> <publisher> Springer-Verlag, LNCS 416, </publisher> <pages> pages 219-237, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: In particular, the proposed protocols allow concurrency between schema changes as well as user transactions. This approach was also applied to complex objects with pre-declaration of locks <ref> [HDK + 90] </ref>. We have shown a problem with the protocol of [MRW + 93]. Other aspects of the protocol have potential problems. This protocol requires locks not only for the atomic operations but also for method executions.
Reference: [HH91] <author> T. Hadzilacos and V. Hadzilacos. </author> <title> Transaction Synchronization in Object Bases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43(1) </volume> <pages> 2-24, </pages> <month> August </month> <year> 1991. </year> <booktitle> Special issue on the 7th Annual ACM SIGACT-SIGMOD Symposium on the Principles of Database Systems, </booktitle> <month> March 21-23, </month> <year> 1988. </year>
Reference-contexts: This aspect is also known as intra-transaction parallelism [HR93]. * In object oriented databases if the execution of a method is seen as a transaction then the execution of methods generates a hierarchy that maps in a convenient way into nested transactions <ref> [HH91] </ref>. * Nested transactions gives a great flexibility in terms of safe composition of application programs whose modules may be designed and implemented independently. One important aspect of this modularity is that we can associate semantics to each module or subtransaction. <p> We based our research in this model. In this section we discuss some of the important differences between flat and nested transactions model. The model of Hadzilacos and Hadzilacos <ref> [HH91] </ref> is not a "pure" model in nested transactions since they described it in the context of object oriented databases, where transactions are method executions. We will discuss their model trying to abstract from this specialization. <p> We will explore such transformations in later chapters of this dissertation. The work of Bernstein, Hadzilacos and Goodman [BHG87] has some implicit as 11 sumptions about the computer and database systems that are explicit in [BBG89]. The work of <ref> [HH91] </ref> also has some implicit assumptions. In [BBG89] eight axioms are listed that describe how a system is expected to behave. There is a reasonable number of definitions connected to these axioms. <p> They use partial orders in the definitions of transactions and executions. OPA is used to axiomatize that the partial order at the level of the operations (the DM level) is equivalent to some totally ordered sequence of the involved operations. In [BBG89] and <ref> [HH91] </ref> a transaction is defined as a partial order of operations. Hence a transaction is a flat structure. In [HH91] there exists a special object (environment) that can start transactions, such transactions are called top-level transactions. <p> In [BBG89] and <ref> [HH91] </ref> a transaction is defined as a partial order of operations. Hence a transaction is a flat structure. In [HH91] there exists a special object (environment) that can start transactions, such transactions are called top-level transactions. <p> This implies that both nodes implements the same operation i.e. that they have the same "semantics". 18 2.5 Other models We have mentioned that the model of <ref> [HH91] </ref> is similar to the model that we have adopted, despite the fact that it is specialized for object oriented databases. In [HH91] a transaction corresponds to a method invocation. An operation in [BBG89] can correspond either to a method step or a local step. <p> This implies that both nodes implements the same operation i.e. that they have the same "semantics". 18 2.5 Other models We have mentioned that the model of <ref> [HH91] </ref> is similar to the model that we have adopted, despite the fact that it is specialized for object oriented databases. In [HH91] a transaction corresponds to a method invocation. An operation in [BBG89] can correspond either to a method step or a local step. A local step corresponds to an operation executed by the DM whereas the method step is an operation that invokes a method execution, i.e., a transaction. In [HH91] <p> <ref> [HH91] </ref> a transaction corresponds to a method invocation. An operation in [BBG89] can correspond either to a method step or a local step. A local step corresponds to an operation executed by the DM whereas the method step is an operation that invokes a method execution, i.e., a transaction. In [HH91] the return values are tied directly to the local and message steps. Most of the the axioms of [BBG89] have their correspondents in [HH91]. In [HH91] the concept of a well-defined execution description is described as a legal history. In [HH91] (C1) and (C2) are for free simply by using <p> In <ref> [HH91] </ref> the return values are tied directly to the local and message steps. Most of the the axioms of [BBG89] have their correspondents in [HH91]. In [HH91] the concept of a well-defined execution description is described as a legal history. In [HH91] (C1) and (C2) are for free simply by using the mathematical concept of functions instead of the tuples of [BBG89]. <p> In <ref> [HH91] </ref> the return values are tied directly to the local and message steps. Most of the the axioms of [BBG89] have their correspondents in [HH91]. In [HH91] the concept of a well-defined execution description is described as a legal history. In [HH91] (C1) and (C2) are for free simply by using the mathematical concept of functions instead of the tuples of [BBG89]. Axioms (C3) and (C8) correspond to conditions 2-(b) and (3) of legal histories. <p> In <ref> [HH91] </ref> the return values are tied directly to the local and message steps. Most of the the axioms of [BBG89] have their correspondents in [HH91]. In [HH91] the concept of a well-defined execution description is described as a legal history. In [HH91] (C1) and (C2) are for free simply by using the mathematical concept of functions instead of the tuples of [BBG89]. Axioms (C3) and (C8) correspond to conditions 2-(b) and (3) of legal histories. Axioms (C4) and (C5) does not have an explicit correspondence. <p> Our definition of serial execution is also the same. But our definition of equivalence of executions is quite different. Let &lt; and &lt; 0 be total orders such that &lt; is a permutation of &lt; 0 . We say that &lt; 0 is conflict consistent <ref> [HH91] </ref> with &lt; if whenever o conflicts with and precedes o 0 in &lt; then o precedes o 0 in &lt; 0 . <p> In [BBG89] two CFs are equivalent if they have the same initial and final states and their roots have the same return values. In <ref> [HH91] </ref> the equivalence concept was strengthened by requiring not only the same roots but also the same forest (with the same return value for each node). <p> Note that in [FLW90] serial correctness for T 0 corresponds to serializability in [BBG89]. To illustrate the difference between the equivalence definitions of [BBG89] and <ref> [HH91] </ref>, consider a transaction that increments an integer data item, using a read and a write operation. Consider two increment subtransactions belonging to two different top-level transactions. In [BBG89] the order of the two increments is irrelevant as long as the underlying read and write operations are not interleaved. <p> Consider two increment subtransactions belonging to two different top-level transactions. In [BBG89] the order of the two increments is irrelevant as long as the underlying read and write operations are not interleaved. In contrast, in <ref> [HH91] </ref>, the order is significant since all operations must return the same values, including the read and write that implement the increment operation. The difference between our notion of equivalence and that of [HH91] can be easily illustrated by any view serializable execution of flat transactions that is not conflict serializable <p> In contrast, in <ref> [HH91] </ref>, the order is significant since all operations must return the same values, including the read and write that implement the increment operation. The difference between our notion of equivalence and that of [HH91] can be easily illustrated by any view serializable execution of flat transactions that is not conflict serializable [BHG87]. Although more restrictive, our approach allows for the development of a serializability theory similar to the classical theory for flat transactions. <p> Edges of type (b) correspond to the transaction order or algorithmic precedence relation between siblings. We first prove a technical lemma, then we show that the acyclicity of our graph is both necessary and sufficient for conflict serializability. Our sufficiency part of the proof follows the proof in <ref> [HH91] </ref>. Lemma 3.3 Given a graph G = (V; E), a set of vertices C V; jCj 2, and P , a set of two or more disjoint nonempty partitions of vertices in C. <p> to c. [Definition of &lt; s ] Let the level of a node in SG (c) be the number of its proper ancestors in A (thus root (A) is at level 0). &lt; s is the relation at the end of the execution of the following Hierarchical Topological Sort (HTS) <ref> [HH91] </ref>: 23 &lt; s := f (x; y) : there is an edge x ! y in SG (c)g for l := 1 to "max. level of any node in SG (c)" do "extend &lt; s to totally order all level l nodes" "further extend &lt; s by setting x &lt; <p> Thus no cycle can exist in SG (c). That is, if CF c is conflict serializable then SG (c) is acyclic. 2 The graph SG (c) that we have defined differs in two main ways from that defined by Hadzilacos and Hadzilacos <ref> [HH91] </ref> (which we refer to as SG HH (c)). Firstly, SG HH includes edges between incomparable nodes even if those nodes are not siblings. For example, condition (a) gives edges in SG HH between any incomparable ancestors of x and y. <p> It is easy to prove that c s 1 and c s 2 are the only serial executions involving the nodes of c. Also it is easy to show that c is not equivalent, as defined by <ref> [HH91] </ref>, to c s 1 , or c s 2 , and hence c is not serializable. The lower part of the figure shows the serialization graphs SG HH (c) and SG (c) of execution c. Execution c is non-serializable, however SG HH (c) is acyclic. <p> Execution c is non-serializable, however SG HH (c) is acyclic. Our serialization graph includes the operations and a cycle between T 2 and w 1 [x] and hence we reject the execution. We now argue that if the serialization graph of <ref> [HH91] </ref> is fixed with respect to the problem mentioned then their graph accepts the same class of executions as ours. Once fixed, their serialization graph includes the same nodes as ours. <p> Hence any cycle in the serialization graph of <ref> [HH91] </ref> involving edges not defined in our serialization graph implies a cycle in sibling nodes involving the edges defined in SG. This means that the serialization graph of [HH91] naot only has redundant edges, but possibly has redundant cycles when rejecting executions. <p> Hence any cycle in the serialization graph of <ref> [HH91] </ref> involving edges not defined in our serialization graph implies a cycle in sibling nodes involving the edges defined in SG. This means that the serialization graph of [HH91] naot only has redundant edges, but possibly has redundant cycles when rejecting executions. The serialization graph of [FLW90] is defined in terms of the union of serialization graphs of individual transactions. <p> Such techniques are also employed to derive protocols that ensure conflict serializability of nested transactions. The work of [Ree78] describes a protocol for nested transactions that uses timestamp technique. The work of [Mos81] describes a protocol for nested transactions that uses lock techniques. Hadzilacos and Hadzilacos <ref> [HH91] </ref> show proofs of correctness for these two protocols. The work of [Jag90] describes 27 a protocol that uses graph testing technique. We have proved [RA92] the correctness of this protocol in the framework of [HH91] and now we prove its correctness in our framework. <p> Hadzilacos and Hadzilacos <ref> [HH91] </ref> show proofs of correctness for these two protocols. The work of [Jag90] describes 27 a protocol that uses graph testing technique. We have proved [RA92] the correctness of this protocol in the framework of [HH91] and now we prove its correctness in our framework. We will now describe the Children's Serialization Graph Testing, (CSGT) protocol [Jag90]. One interesting aspect of the protocol is the modular way it is defined. <p> An object oriented database contains a set of objects. An object consists of variables and methods. These methods can invoke atomic operations on the object variables or invoke other methods. If we establish a correspondence between methods and transactions then the execution of methods maps conveniently into nested transactions <ref> [HH91] </ref>. In an object oriented database organized in the above way, we can identify the meaning of the method with its corresponding transaction. <p> We believe this is an important property of object oriented systems since new objects are composed from existing objects, hence referential sharing among unrelated objects is unavoidable. Earlier work on transaction management in object oriented databases has either ignored the issue of semantics <ref> [HH91] </ref>, or have only used semantics partially [AE92], or do not completely deal with referential sharing [MRW + 93]. <p> Users access objects by executing methods defined on objects or atomic operations associated with objects. A method execution is a partial order of method executions and atomic operations <ref> [HH91] </ref>. Such a caller-callee relationship between methods establishes a hierarchy that is known as nested transactions or nested method executions [Mos85]. These nested transactions are equivalent to the nested transactions presented in chapter 3 the only difference is that now we are specializing them to the object oriented database environment. <p> The method "total-list-price ()" defined in the class Order computes the list-price for the order. In the class Order, the method "report-status ()" is implemented with atomic operation "read (status)". Similarly in class Item, "report-price ()" is implemented with atomic operation "read (price)" . As in <ref> [HH91] </ref>, we assume that user transactions are methods of a distinct object called environment. We will be using the terms transaction and method execution interchangeably. We also assume the existence of a special method execution, T 0 , in the environment object that invokes the top-level method executions. <p> A lock lock (x) can be granted to a method execution iff (a) No other method execution holds a conflicting lock, and (b) All the retainers of a conflicting lock are ancestors of the requesting method execution. It is shown in <ref> [BBG89, HH91] </ref> that N2PL ensures serializability. Since N2PL does not take advantage of any knowledge about the semantics of the methods being executed, we can prove its correctness using the techniques of Chapter 3. <p> We have developed a locking-based concurrency control protocol for object-oriented databases. Our protocol generalizes Moss's original nested transaction protocol in that it incorporates the rich semantic information available in object oriented databases. Our protocol incorporates the notions of semantics of higher level objects [BBG89, MRW + 93], nested executions <ref> [HH91, AE92, MRW + 93] </ref> and dynamic conflicts. In particular, we address the issue of referentially shared objects where the referential sharing among objects is determined dynamically during the execution. <p> In general, in object-oriented databases, the conflicts and commutativity relations between methods are defined on a per class basis. Methods on different objects are generally assumed to commute with each other <ref> [GK88, CF90, HH91, MRW + 93] </ref>. This approach is reasonable for object-oriented databases with disjoint complex objects. However, in a system with referentially shared sub 44 objects, the commutativity relation needs to be redefined even for methods that are executed on different objects. <p> Furthermore, the referential sharing of objects may occur dynamically during execution. Our assumptions are as follows. We assume that for each class, conflict relations are defined for the atomic operations. This is the same assumption made by most previous work in both nested transactions and object oriented databases <ref> [Mos85, HH91, FLW90] </ref>. However, we enrich this model by exploiting semantic information, i.e., commutativity relations that are derived from the semantics of methods of classes. Specifically we assume that commutativity information about pairs of methods is potentially available. Such methods are known to commute a priori.
Reference: [Hoa85] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: In order to formalize these concepts, e.g., transactions, execution, equivalence, a model is used. In the models that we will adopt the scheduler is not described explicitly like for example it is possible using the model in <ref> [Hoa85] </ref>. Most of the research in the area of database concurrency control uses a model where the scheduler is not described explicitly, rather the scheduler is described by the properties of the executions allowed by the protocol that it follows. Such model is sometimes referred as the classical model [FLMW90].
Reference: [HR93] <author> Theo Harder and Kurt Rothermel. </author> <title> Concurrency control issues in nested transactions. </title> <journal> iThe VLDB Journal, </journal> <volume> 2(1) </volume> <pages> 39-74, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: This must be considered in contrast with flat transactions where abortion usually implies 4 losing everything that was done in the whole transaction unit unless some special mechanism is adopted. Such aspect of nested transactions is also known as intra transaction recovery <ref> [HR93] </ref>. * If the database is distributed then nested transactions provide a mechanism to distribute activities in different sites. * They provide synchronization between concurrently running parts of the same nested transactions, i.e., they can be used to express executions that can be carried in a concurrent way. <p> This aspect is also known as intra-transaction parallelism <ref> [HR93] </ref>. * In object oriented databases if the execution of a method is seen as a transaction then the execution of methods generates a hierarchy that maps in a convenient way into nested transactions [HH91]. * Nested transactions gives a great flexibility in terms of safe composition of application programs whose
Reference: [HW91] <author> M. P. Herlihy and W. E. Weihl. </author> <title> Hybrid Concurrency Control for Abstract Data Types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43(1) </volume> <pages> 25-61, </pages> <month> August </month> <year> 1991. </year> <booktitle> Special issue on the 7th Annual ACM SIGACT-SIGMOD Symposium on the Principles of Database Systems, </booktitle> <month> March 21-23, </month> <year> 1988. </year> <month> 72 </month>
Reference-contexts: Two method invocations x and y on the same object commute if and only if the two possible sequential executions of x and y are indistinguishable for both x and y and for all possible sequences of methods that may be invoked subsequently <ref> [CF90, HW91, MRW + 93] </ref>. Table 4.1 illustrates the commutativity relationships between the methods of class object I tem. The entry ? indicates that the relationship is undefined.
Reference: [Jag90] <author> T. Jagodits. </author> <title> Concurrency control in nested transactions: A new protocol and its comparative performance evaluation. </title> <type> Master's thesis, </type> <institution> University of California Santa Barbara, </institution> <year> 1990. </year>
Reference-contexts: The work of [Ree78] describes a protocol for nested transactions that uses timestamp technique. The work of [Mos81] describes a protocol for nested transactions that uses lock techniques. Hadzilacos and Hadzilacos [HH91] show proofs of correctness for these two protocols. The work of <ref> [Jag90] </ref> describes 27 a protocol that uses graph testing technique. We have proved [RA92] the correctness of this protocol in the framework of [HH91] and now we prove its correctness in our framework. We will now describe the Children's Serialization Graph Testing, (CSGT) protocol [Jag90]. <p> The work of <ref> [Jag90] </ref> describes 27 a protocol that uses graph testing technique. We have proved [RA92] the correctness of this protocol in the framework of [HH91] and now we prove its correctness in our framework. We will now describe the Children's Serialization Graph Testing, (CSGT) protocol [Jag90]. One interesting aspect of the protocol is the modular way it is defined. This protocol is the graph testing version of a serialization graph very similar to the serialization graph of [FLW90]. The proof of correctness we develop here indirectly connects our work to the work of [FLW90].
Reference: [Kim90] <author> Won Kim. </author> <title> Introduction to Object-Oriented Databases. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Object oriented databases differ from traditional databases by adopting some of the characteristics of object oriented systems <ref> [Kim90] </ref>. An object oriented database contains a set of objects. An object consists of variables and methods. These methods can invoke atomic operations on the object variables or invoke other methods. <p> Thus OH-semantic locking only produces semantically serializable executions. 2 5.4 Other works In traditional databases, the most commonly adopted correctness criterion is seri-alizability. Object-oriented database systems such as ORION <ref> [GK88, Kim90] </ref> and O 2 [CF90, BDK92] ensure the serializable execution of transactions. Both of these database systems employ a locking protocol based on multigranularity locking [Gra78].
Reference: [Kor83] <author> H. F. Korth. </author> <title> Locking primitives in a database system. </title> <journal> Journal of the ACM, </journal> <volume> 30(1) </volume> <pages> 55-79, </pages> <month> January </month> <year> 1983. </year>
Reference-contexts: There are basically two approaches for defining conflicts. One approach is to enumerate the operations of a system and to define the conflict relation explicitly [BHG87]. Another way of defining a conflict relation is to specify the conditions for conflict and leave the operations unspecified <ref> [Kor83] </ref>. An execution is conflict serializable if there exists a serial execution of the same transactions where the order of the conflicting pairs is the same in both. The theory prescribes how to construct a graph that represents the execution of transactions in a database system.
Reference: [Kri93] <author> Vasudha Krishnaswamy. </author> <title> Semantics Based Synchronization in Database Systems. </title> <type> PhD thesis, </type> <institution> University of California Santa Barbara, </institution> <year> 1993. </year>
Reference-contexts: This chapter discusses the issues involved in using the meaning or semantics of a transaction in this sense. It is also possible to consider semantics in terms of groups of atomic operations <ref> [Kri93] </ref>, or in terms of the context of an execution [Won93], but this is outside the scope of our work. Object-oriented databases are being increasingly used to model non-standard applications. These applications place new constraints on databases design. In particular, 30 they emphasize modularity, composition, and rapid prototyping.
Reference: [Mos81] <author> J. E. B. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1981. </year>
Reference-contexts: The other two techniques are timestamps and graph testing. Such techniques are also employed to derive protocols that ensure conflict serializability of nested transactions. The work of [Ree78] describes a protocol for nested transactions that uses timestamp technique. The work of <ref> [Mos81] </ref> describes a protocol for nested transactions that uses lock techniques. Hadzilacos and Hadzilacos [HH91] show proofs of correctness for these two protocols. The work of [Jag90] describes 27 a protocol that uses graph testing technique.
Reference: [Mos85] <author> J. E. B. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1985. </year>
Reference-contexts: The caller-callee relationship induced by such calls generate a hierarchical structure, and hence the name nested transactions <ref> [Mos85] </ref>. One nice aspect of flat transactions is the simplicity of their structure. Multilevel transactions are used basically because of the layered abstraction that they allow. <p> Users access objects by executing methods defined on objects or atomic operations associated with objects. A method execution is a partial order of method executions and atomic operations [HH91]. Such a caller-callee relationship between methods establishes a hierarchy that is known as nested transactions or nested method executions <ref> [Mos85] </ref>. These nested transactions are equivalent to the nested transactions presented in chapter 3 the only difference is that now we are specializing them to the object oriented database environment. Item, and Order. <p> We summarize the nested two-phase locking (N2PL) rules adapted from <ref> [Mos85] </ref> as follows. 1. A method execution t 0 can execute an atomic operation t, iff lock (t) is requested and is granted (we say that the method execution t 0 holds lock (t)). 2. A method execution cannot terminate (commit or abort) until all its children have terminated. <p> A proof of correctness of their protocol is not presented, and this is of fundamental importance. In the next chapter we introduce semantic locking protocols that ensures semantic serializability. 43 Chapter 5 Semantic Locking Protocols In traditional databases, the most commonly adopted correctness criterion is serializ-ability. Moss <ref> [Mos85] </ref> introduced the notion of nested transactions for modular composition of applications and programs in database systems. He proposed the nested two phase locking protocol (N2PL) which is a generalization of the well-known two-phase locking protocol for concurrency control [EGLT76]. <p> Furthermore, the referential sharing of objects may occur dynamically during execution. Our assumptions are as follows. We assume that for each class, conflict relations are defined for the atomic operations. This is the same assumption made by most previous work in both nested transactions and object oriented databases <ref> [Mos85, HH91, FLW90] </ref>. However, we enrich this model by exploiting semantic information, i.e., commutativity relations that are derived from the semantics of methods of classes. Specifically we assume that commutativity information about pairs of methods is potentially available. Such methods are known to commute a priori. <p> The designer provides semantic information at his/her own discretion. 5.2 Semantic locking protocol 5.2.1 Protocol In semantic locking each atomic operation has a lock associated with it. Before a method execution may execute an atomic operation, a lock must be requested and granted. This is similar to <ref> [Mos85] </ref>, locks are only required for the execution of atomic operations and contrasts with [MRW + 93] where locks are required for the execution of methods. Similar to [Mos85] when a method execution terminates its parent inherits all its locks. <p> Before a method execution may execute an atomic operation, a lock must be requested and granted. This is similar to <ref> [Mos85] </ref>, locks are only required for the execution of atomic operations and contrasts with [MRW + 93] where locks are required for the execution of methods. Similar to [Mos85] when a method execution terminates its parent inherits all its locks. The locks that a method execution x inherits from its children are said to be retained by x. In semantic locking, locks can be granted to conflicting operations if the corresponding operations have commuting ancestors.
Reference: [MRW + 93] <author> P. Muth, T. C. Rakow, G. Weikum, P. Brossler, and C. Hasse. </author> <title> Semantic Concurrency Control in Object-Oriented Database Systems. </title> <booktitle> In Proceedings of the 9th IEEE International Conference on Data Engineering, </booktitle> <pages> pages 233-242, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Observe that when a CF c is related to CF c by commutativity-based reversals, c and c have the same transactions and the same operations which means same system equivalence, We have adopted the term "semantic serializability" (as <ref> [MRW + 93] </ref> also did) because when we use substitution then we have to consider that a certain node can be substituted by another. <p> Earlier work on transaction management in object oriented databases has either ignored the issue of semantics [HH91], or have only used semantics partially [AE92], or do not completely deal with referential sharing <ref> [MRW + 93] </ref>. In this chapter, we present the model of object oriented database we have adopted, and we present the motivation for the development of such protocols. 4.2 Model An object oriented database is a collection of classes and instances of these classes. <p> These nested transactions are equivalent to the nested transactions presented in chapter 3 the only difference is that now we are specializing them to the object oriented database environment. Item, and Order. This example is similar to the one in <ref> [MRW + 93] </ref> but is extended to a more realistic setting that supports referentially shared objects. Each customer can have several orders and each order may mention one or more items. Furthermore, each item could have been mentioned by several orders. <p> Two method invocations x and y on the same object commute if and only if the two possible sequential executions of x and y are indistinguishable for both x and y and for all possible sequences of methods that may be invoked subsequently <ref> [CF90, HW91, MRW + 93] </ref>. Table 4.1 illustrates the commutativity relationships between the methods of class object I tem. The entry ? indicates that the relationship is undefined. <p> We will first present Moss' two-phase locking protocol. Then we show how semantic information can be used with the help of an example. We finish this chapter by presenting the work of Muth et al <ref> [MRW + 93] </ref>, that has similar objectives as part of our work, but has some problems. Locks are place holders for checking concurrency control predicates. Each atomic operation has a lock associated with it. Before a method execution may execute an atomic operation, a lock must be requested and granted. <p> Basically nested two phase locking does not have any mechanism that allows lower level conflicts (such as "read (price)", "write (price)" in Figure 4.4) to be ignored by using the semantics at higher level methods (e.g., "decrease-percent ()"). Muth et al. <ref> [MRW + 93] </ref> extend N2PL to use semantic information in the following way. First they assume that they have, for each object, compatibility matrices with entries for all the methods. An entry in such a compatibility matrix informs if the corresponding methods conflict or commute. <p> We now show that the interplay between semantic information and hierarchy of methods, can pose challenging problems for protocols that want to use semantic information. We will show an execution that is accepted by the protocol of Muth et al <ref> [MRW + 93] </ref> and nevertheless is not semantically serializable. It is a simple execution but nevertheless illustrates the type of problems that may occur. <p> N2PL would not accept this execution. Since lock (r () 2 ) conflicts with lock (w () 1 ) the N2PL scheduler grants lock (r () 2 ) only when T 1 terminates. One of the possible orders that the protocol of Muth et al. <ref> [MRW + 93] </ref> grants the locks in the execution of 1. lock (x 1 ), no other conflicting locks. 41 2. lock (x + 1), no other conflicting locks. 3. lock (r () 1 ), no other conflicting locks. 4. lock (w () 1 ) conflicts with lock (r () 1 <p> Then x=2, x 2 and T 2 complete. As shown by the above sequence, the execution of Figure 4.6 is accepted by the protocol of Muth et al. <ref> [MRW + 93] </ref>, but nevertheless it does not ensures the semantic serializability of the execution. The execution of Figure 4.6 is not semantically equivalent to any serial order T 1 T 2 or T 2 T 1 (both orders are equivalent since T 1 and T 2 invokes identity update. <p> For example if the primitive object of class pdec start with value 0:5 at the end of the execution instead of continuing to have the value of 0:5 it gets 1. The protocol of <ref> [MRW + 93] </ref> suffers from better formalization. The area of concur-rency control is famous with respect to how treacherous can be a solution that seems "reasonable and intuitive". A proof of correctness of their protocol is not presented, and this is of fundamental importance. <p> We have developed a locking-based concurrency control protocol for object-oriented databases. Our protocol generalizes Moss's original nested transaction protocol in that it incorporates the rich semantic information available in object oriented databases. Our protocol incorporates the notions of semantics of higher level objects <ref> [BBG89, MRW + 93] </ref>, nested executions [HH91, AE92, MRW + 93] and dynamic conflicts. In particular, we address the issue of referentially shared objects where the referential sharing among objects is determined dynamically during the execution. <p> We have developed a locking-based concurrency control protocol for object-oriented databases. Our protocol generalizes Moss's original nested transaction protocol in that it incorporates the rich semantic information available in object oriented databases. Our protocol incorporates the notions of semantics of higher level objects [BBG89, MRW + 93], nested executions <ref> [HH91, AE92, MRW + 93] </ref> and dynamic conflicts. In particular, we address the issue of referentially shared objects where the referential sharing among objects is determined dynamically during the execution. <p> In general, in object-oriented databases, the conflicts and commutativity relations between methods are defined on a per class basis. Methods on different objects are generally assumed to commute with each other <ref> [GK88, CF90, HH91, MRW + 93] </ref>. This approach is reasonable for object-oriented databases with disjoint complex objects. However, in a system with referentially shared sub 44 objects, the commutativity relation needs to be redefined even for methods that are executed on different objects. <p> Before a method execution may execute an atomic operation, a lock must be requested and granted. This is similar to [Mos85], locks are only required for the execution of atomic operations and contrasts with <ref> [MRW + 93] </ref> where locks are required for the execution of methods. Similar to [Mos85] when a method execution terminates its parent inherits all its locks. The locks that a method execution x inherits from its children are said to be retained by x. <p> In particular, the proposed protocols allow concurrency between schema changes as well as user transactions. This approach was also applied to complex objects with pre-declaration of locks [HDK + 90]. We have shown a problem with the protocol of <ref> [MRW + 93] </ref>. Other aspects of the protocol have potential problems. This protocol requires locks not only for the atomic operations but also for method executions.
Reference: [Pap86] <author> C. H. Papadimitriou. </author> <title> The Theory of Database Concurrency Control. </title> <publisher> Computer Science Press, </publisher> <year> 1986. </year>
Reference-contexts: Here what we mean by correct execution is an execution that preserves database consistency. However in a concurrent system, due to the interleaving of accesses, an execution that would be correct if the program was running alone, can result in an inconsistent database <ref> [Pap86, BHG87] </ref>. This is due to the non-controlled interference of operations over the shared data. <p> The model we will adopt for nested transactions interprets 8 the notion of state transformation and return values. In this latter model we have two formal definition of commutativity one that is state dependent and the other state independent. Transactions can be described as sequences of operations <ref> [Pap86] </ref>, or as a partial order of operations [BHG87]. The advantage of modeling transactions as a partial order is that the transaction need not specify the ordering of every two operations that appear in it. Beyond being a sequence or a partial order of operations some conditions must be satisfied. <p> Now we will prove that if two DM tuples are conflict equivalent and one of them is a D-computation then the other is also a D-computation. We will use the technique of reversing commutative operations presented in [BBG89] and <ref> [Pap86] </ref>. First we show that the DM-tuple obtained by inverting the order of two contiguous and commutative operations of a D-computation is also in D.
Reference: [RA92] <author> Rodolfo F. Resende and Amr El Abbadi. </author> <title> A graph testing concurrency control protocol for object bases. </title> <booktitle> In Proceedings of the 4th International Conference on Computing and Information, </booktitle> <pages> pages 316-319, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: The work of [Mos81] describes a protocol for nested transactions that uses lock techniques. Hadzilacos and Hadzilacos [HH91] show proofs of correctness for these two protocols. The work of [Jag90] describes 27 a protocol that uses graph testing technique. We have proved <ref> [RA92] </ref> the correctness of this protocol in the framework of [HH91] and now we prove its correctness in our framework. We will now describe the Children's Serialization Graph Testing, (CSGT) protocol [Jag90]. One interesting aspect of the protocol is the modular way it is defined.
Reference: [Ree78] <author> D. P. Reed. </author> <title> Naming and Synchronization in a Decentralized Computer System. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1978. </year>
Reference-contexts: Locking is the most used technique for concurrency control protocols. The other two techniques are timestamps and graph testing. Such techniques are also employed to derive protocols that ensure conflict serializability of nested transactions. The work of <ref> [Ree78] </ref> describes a protocol for nested transactions that uses timestamp technique. The work of [Mos81] describes a protocol for nested transactions that uses lock techniques. Hadzilacos and Hadzilacos [HH91] show proofs of correctness for these two protocols. The work of [Jag90] describes 27 a protocol that uses graph testing technique.
Reference: [SG91] <author> S. S. Simmel and I. Godard. </author> <title> The kala basket: a semantic primitive unifying object transactions, access control, versions, and configurations. </title> <booktitle> In Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 230-246, </pages> <month> October </month> <year> 1991. </year> <month> 73 </month>
Reference-contexts: However simulation parameters for nested transactions are almost non-existent in the literature. This is in part due to the fact that only recently commercial systems that use nested transactions have started to appear. Some examples of commercial systems are Encina [She93b, She93a] and Kala <ref> [SG91] </ref>. It seems that these systems do not use semantic information to enhance concurrency but they claim the use of nested transactions techniques. Beyond the investigation of opportunities for the use of semantics as mentioned above is the investigation of simulation parameters for nested transactions.
Reference: [She93a] <author> M. Sherman. </author> <title> Architecture of the encina distributed transaction processing family. </title> <booktitle> In SIGMOD Record, </booktitle> <pages> pages 460-463, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: However simulation parameters for nested transactions are almost non-existent in the literature. This is in part due to the fact that only recently commercial systems that use nested transactions have started to appear. Some examples of commercial systems are Encina <ref> [She93b, She93a] </ref> and Kala [SG91]. It seems that these systems do not use semantic information to enhance concurrency but they claim the use of nested transactions techniques. Beyond the investigation of opportunities for the use of semantics as mentioned above is the investigation of simulation parameters for nested transactions.
Reference: [She93b] <author> M. Sherman. </author> <title> Distributed transaction processing with encina. </title> <booktitle> In Proceedings of the Second International Conference on Parallel and Distributed Information Systems, </booktitle> <pages> pages 268-269, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: However simulation parameters for nested transactions are almost non-existent in the literature. This is in part due to the fact that only recently commercial systems that use nested transactions have started to appear. Some examples of commercial systems are Encina <ref> [She93b, She93a] </ref> and Kala [SG91]. It seems that these systems do not use semantic information to enhance concurrency but they claim the use of nested transactions techniques. Beyond the investigation of opportunities for the use of semantics as mentioned above is the investigation of simulation parameters for nested transactions.
Reference: [Wei89] <author> W. E. Weihl. </author> <title> The impact of recovery on concurrency control. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 259-269, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: Two operations (generally) commute if they commute with respect to all states. Operation o 1 conflicts with o 2 if o 1 does not commute with o 2 . The definition of commutativity of [BBG89] can be specialized for example in right backward commutativity <ref> [Wei89] </ref>: We say that o 1 right backwards commute with o 2 if for all states s where (s; fo 1 ; o 2 g; (o 1 ; o 2 ); r; s) 2 D then (s; fo 1 ; o 2 g; (o 2 ; o 1 ); r; s)
Reference: [Wei91] <author> G. Weikum. </author> <title> Principles and realization strategies of multilevel transaction management. </title> <journal> ACM Transactions On Database Systems, </journal> <volume> 16(1) </volume> <pages> 132-180, </pages> <year> 1991. </year>
Reference-contexts: Multilevel transactions. Such transactions occur in systems that offer to the programs the same type of operations to start and to terminate a transaction as before, but there exists two or more levels of transactions and database access operations <ref> [Wei91] </ref>. One operation that appears atomic at one level is implemented as a transaction, with operations in the immediately next lower level. 3. Nested transactions. <p> The fundamental theorem of the theory relates the conflict serializability of an execution with the absence of cycles in its corresponding graph [BHG87]. Most of the results of the classical theory of database are also available in terms of multilevel transactions <ref> [Wei91] </ref>. 5 Our first contribution presented in this dissertation is related to extending the re-sults of conflict serializability of the classical theory from flat to nested transactions. <p> We will show that it is possible that at a lower level an operation conflicts with another, but because of the semantics of a method that uses directly or indirectly such operations, we can ignore the lower level conflict. The idea is similar to multilevel transaction systems <ref> [Wei91] </ref>, but we will show that generic nesting imposes specific conditions. This chapter discusses the issues involved in using the meaning or semantics of a transaction in this sense.
Reference: [Won93] <author> Man Hon Wong. </author> <title> Context-Based Synchronization in Object-Oriented Databases. </title> <type> PhD thesis, </type> <institution> University of California Santa Barbara, </institution> <year> 1993. </year> <month> 74 </month>
Reference-contexts: This chapter discusses the issues involved in using the meaning or semantics of a transaction in this sense. It is also possible to consider semantics in terms of groups of atomic operations [Kri93], or in terms of the context of an execution <ref> [Won93] </ref>, but this is outside the scope of our work. Object-oriented databases are being increasingly used to model non-standard applications. These applications place new constraints on databases design. In particular, 30 they emphasize modularity, composition, and rapid prototyping.
References-found: 31

