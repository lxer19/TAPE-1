URL: ftp://ftp.cs.columbia.edu/reports/reports-1996/cucs-032-96.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1996.html
Root-URL: http://www.cs.columbia.edu
Email: li,kar@cs.columbia.edu  
Title: Fast Joins Using Join Indices  
Author: Zhe Li Kenneth A. Ross 
Keyword: Categories and Subject Descriptors: H.2.4 [Database Management]: Systems query processing Keywords: Relational databases, join, query optimization, decision support systems.  
Address: New York, NY 10027  
Affiliation: Department of Computer Science, Columbia University,  
Abstract: Columbia University Technical Report CUCS-032-96 June 26, 1996 Abstract Two new algorithms, "Jive-join" and "Slam-join," are proposed for computing the join of two relations using a join index. The algorithms are duals: Jive-join range-partitions input relation tuple-ids then processes each partition, while Slam-join forms ordered runs of input relation tuple-ids and then merges the results. Each algorithm has features that make it preferable to the other depending on the context in which it is being used. Both algorithms make a single sequential pass through each input relation, in addition to one pass through the join index and two passes through a temporary file whose size is half that of the join index. Both algorithms perform this efficiently even when the relations are much larger than main memory, as long as the number of blocks in main memory is of the order of the square root of the number of blocks in the smaller relation. By storing intermediate and final join results in a vertically partitioned fashion, our algorithms need to manipulate less data in memory at a given time than other algorithms. Almost all the I/O of our algorithms is sequential, thus minimizing the impact of seek and rotational latency. The algorithms are resistant to data skew and adaptive to memory fluctuations. They can be extended to handle joins of multiple relations by using multidimensional partitioning while still making only a single pass over each input relation. They can also be extended to handle joins of relations that do not satisfy the memory bound by recursively applying the algorithms. We also show how selection conditions can be incorporated into the algorithms. Using a detailed cost model, the algorithms are analyzed and compared with competing algorithms. For large input relations, our algorithms perform significantly better than Valduriez's algorithm and hash join algorithms. An experimental study is also conducted to validate the analytical results and to demonstrate the performance characteristics of each algorithm in practice. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Agrawal, R., et al. </author> <title> Quest: A project on database mining. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference (May 1994), </booktitle> <address> p. </address> <month> 514. </month>
Reference-contexts: 1 Introduction A number of applications need to process huge amounts of information in a reasonable time-frame. Examples include commercial decision-support systems, NASA's Earth Observing System with an estimated 1 terabyte of data per day of information [11], and data mining applications with massive amounts of transaction information <ref> [1] </ref>. Further, as technology improves, we expect that more applications will emerge to take advantage of techniques for rapidly processing large volumes of data. Thus, we focus on relational 1 databases in which relations are significantly larger than main memory.
Reference: [2] <author> Batory, D. S. </author> <title> On searching transposed files. </title> <journal> ACM Transactions on Database Systems 4, </journal> <volume> 4 (1979), </volume> <pages> 531-544. </pages>
Reference-contexts: that enables such efficient performance is the use of a vertically partitioned data structure for the join result. (We do not assume that the inputs are vertically partitioned.) Attributes from the first input relation are stored in a separate file from those of the second input relation, using transposed files <ref> [2] </ref>. Attributes that are common are placed arbitrarily in one of the two vertical fragments. There is a one-to-one correspondence between records in each vertical partition: The nth record in the first vertical fragment matches the nth record in the second. <p> The input relations may reside on the same disk. (This kind of configuration is recommended by most commercial vendors.) 2.1 A Vertically Partitioned Data Structure for the Join Result We use a vertically partitioned data structure known as a transposed file <ref> [2] </ref> to store the join result.
Reference: [3] <author> Bitton, D., DeWitt, D. J., and Turbyfill, C. </author> <title> Benchmarking database systems: a systematic approach. </title> <booktitle> In Proceedings of the 1983 VLDB conference (1983), </booktitle> <pages> pp. 8-19. </pages>
Reference-contexts: We implemented Valduriez's algorithm according to [31]. Two joining relations are produced using the Wisconsin synthetic database generator <ref> [3] </ref>. Each tuple consists of a four-byte integer as join attribute, plus any remaining padding bytes as a combination of integer and string attributes. The join result tuple is a concatenation of two joining tuples projecting out one of the join attributes.
Reference: [4] <author> Blakeley, J., and Martin, N. </author> <title> Join index, materialized view, and hybrid-hash join: a performance analysis. </title> <booktitle> In Proc. IEEE Int'l Conf. on Data Eng. </booktitle> <year> (1990), </year> <pages> pp. 256-263. </pages>
Reference-contexts: We assume that in-memory sorting is done in-place using an algorithm such as quicksort [15]. In this paper we do not address the cost of maintaining the join index. Blakeley and Martin have comprehensively analyzed the tradeoff between join index maintenance cost and the join speedup <ref> [4] </ref>. 4.2 Memory Requirements for Jive-Join We need Step J1 and Step J2 to fit in main memory. Ignoring insignificant terms, the following inequality must hold: y (x + v) m: (1) Step J3 must also fit in main memory. <p> However, they still access the full tuples in the first relation multiple times during an initial hashing phase and a subsequent matching phase. The performance analysis work closest to ours is <ref> [4] </ref>. Blakeley et. al. conducted a detailed simulation study comparing the performance of Valduriez's algorithm, materialized views and Hybrid-hash join in a centralized environment. That study includes the update cost of maintaining the join index and materialized view, so some of the results are not directly comparable to ours.
Reference: [5] <author> Blasgen, M., and Eswaran, K. </author> <title> Storage and access in relational data bases. </title> <journal> IBM Systems Journal 16, </journal> <month> 4 </month> <year> (1977). </year>
Reference-contexts: A number of techniques have been developed to perform joins in this setting <ref> [5, 6, 10, 16, 21, 28] </ref>. Decision support systems are characterized by complex ad-hoc join queries over large data sets. Relational systems relying on conventional data structures and ad-hoc join methods fail to deliver the needed response time for many such interactive queries.
Reference: [6] <author> Bratbergsengen, B. </author> <title> Hashing methods and relational algebra operations. </title> <booktitle> In Proceedings of the VLDB Conference (August 1984), </booktitle> <pages> pp. 323-333. </pages>
Reference-contexts: A number of techniques have been developed to perform joins in this setting <ref> [5, 6, 10, 16, 21, 28] </ref>. Decision support systems are characterized by complex ad-hoc join queries over large data sets. Relational systems relying on conventional data structures and ad-hoc join methods fail to deliver the needed response time for many such interactive queries.
Reference: [7] <author> Brown, K., et al. </author> <title> Resource allocation and scheduling for mixed database workloads. </title> <type> Tech. Rep. 1095, </type> <institution> University of Wisconsin, Madison, </institution> <year> 1992. </year>
Reference-contexts: A table of system constants, with their value (used in the analytic comparisons) is given in Table 2. The constants used follow <ref> [14, 7] </ref>, and correspond to the Fujitsu M2266 disk drive.
Reference: [8] <author> Chou, H., DeWitt, D. J., Katz, R. H., and Klug, A. C. </author> <title> Design and implementation of the Wisconsin storage system. </title> <journal> Software Practice and experience 15, </journal> <volume> 10 (1985), </volume> <pages> 943-962. </pages>
Reference-contexts: The underlying storage manager is a raw file system similar to WiSS <ref> [8] </ref>, which supports extent-based contiguous space allocation and bulk I/O requests. Memory management is done using a homegrown buffer manager, which avoids copying data blocks whenever possible. Therefore our system eliminates most of the performance disadvantages discussed in [30].
Reference: [9] <author> Colby, L. S., Martin, N. L., and Wehrmeister, R. M. </author> <title> Query processing for decision support: The SQLmmp solution. </title> <booktitle> In Proceedings of the Conference on Parallel and Distributed Information Systems (1994), </booktitle> <pages> pp. 121-130. </pages>
Reference-contexts: However, conclusions drawn after excluding the update cost are consistent with our results. Jive-join and Slam-join can be integrated into a query optimizer in the same way that any other join algorithm can. An example of the use of Jive-join would be in the SQLmmp system <ref> [9] </ref>. That system manipulates tuple-ids rather than full tuples to minimize the number of times that full tuples are looked up in processing a query. The final operation in the SQLmmp system is the computation of the full join given a join index, an operation they call MAKEREL. In [9] it <p> system <ref> [9] </ref>. That system manipulates tuple-ids rather than full tuples to minimize the number of times that full tuples are looked up in processing a query. The final operation in the SQLmmp system is the computation of the full join given a join index, an operation they call MAKEREL. In [9] it is implicitly assumed that the join result fits in memory. Jive-join and Slam-join solve the problem for cases in which the join result and input relations are much larger than main memory.
Reference: [10] <author> DeWitt, D. J., et al. </author> <title> Implementation techniques for main memory database systems. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference (June 1984), </booktitle> <pages> pp. 1-8. </pages>
Reference-contexts: A number of techniques have been developed to perform joins in this setting <ref> [5, 6, 10, 16, 21, 28] </ref>. Decision support systems are characterized by complex ad-hoc join queries over large data sets. Relational systems relying on conventional data structures and ad-hoc join methods fail to deliver the needed response time for many such interactive queries. <p> In [31], Valduriez proposed and analyzed a join algorithm that uses the join index. The most important conclusion of that study was that, under many circumstances, having the join index allows one to compute the join significantly faster than the "best" ad-hoc methods such as Hybrid hash-join <ref> [10] </ref>. However, when one analyzes Valduriez's algorithm, it becomes apparent that there is a significant amount of repetitious I/O. Blocks are accessed often for only a small fraction of their tuples. The same block may be read multiple times on different passes within the algorithm. <p> For joins without a join index, many join algorithms have been proposed, with joins of multiple relations being performed as a sequence of pairwise joins. For comparison purposes, one could consider a sequence of pairwise joins each using a conventional algorithm such as Hybrid hash join <ref> [10] </ref>. However, there is some difficulty asociated with measuring the cost of such a join sequence because it is necessary to optimize the order in which the component joins are performed [27]. The development of a join-ordering framework for conventional joins is beyond the scope of this paper.
Reference: [11] <author> Dozier, J. </author> <title> Access to data in NASA's Earth Observing System. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference (June 1992), </booktitle> <address> p. </address> <month> 1. </month>
Reference-contexts: 1 Introduction A number of applications need to process huge amounts of information in a reasonable time-frame. Examples include commercial decision-support systems, NASA's Earth Observing System with an estimated 1 terabyte of data per day of information <ref> [11] </ref>, and data mining applications with massive amounts of transaction information [1]. Further, as technology improves, we expect that more applications will emerge to take advantage of techniques for rapidly processing large volumes of data.
Reference: [12] <author> Graefe, G. </author> <title> Performance enhancements for hybrid hash join. </title> <type> Tech. Rep. 606, </type> <institution> University of Colorado, Boulder, </institution> <year> 1992. </year>
Reference-contexts: The multi-way versions of Jive-join and Slam-join do not retrieve or store tuples that don't contribute to the join result. 28 9 Extensions We outline below several extensions to Jive-join and Slam-join. 9.1 Multi-level Recursion Both Jive-join and Slam-join can use standard multi-level recursion <ref> [12] </ref> when the inputs are larger than the memory bound (Equation 3). The term "multi-level recursion" refers to techniques that are applied in a divide-and-conquer fashion. To apply multi-level partitioning for Jive-join, one creates many memory-sized partitions, and a small number of large partitions in the first phase (Step J1).
Reference: [13] <author> Graefe, G., Linville, A., and Shapiro, L. </author> <title> Sort versus hash revisited. </title> <journal> IEEE Transactions on knowledge and data enginnering 6, </journal> <month> 6 </month> <year> (1994). </year>
Reference: [14] <author> Haas, L. M., Carey, M. J., and Livny, M. </author> <title> Seeking the truth about ad hoc join costs. </title> <type> Tech. Rep. </type> <institution> RJ9368, IBM Almaden Research Center, </institution> <year> 1993. </year>
Reference-contexts: The extension of our analysis to cases where fewer attributes are required is straightforward. We do not assume that any indexes are available on the input relations. We also do not assume that either input relation is physically ordered by any attribute. Following <ref> [14] </ref>, we assume that join indexes and temporary files are stored on separate disk devices from each other and from the input relations, so that we do not encounter unnecessary disk seeks between accesses. <p> A table of system constants, with their value (used in the analytic comparisons) is given in Table 2. The constants used follow <ref> [14, 7] </ref>, and correspond to the Fujitsu M2266 disk drive. <p> N I=O Number of I/O requests in an algorithm. N X Number of block transfers in an algorithm. Table 1: Table of symbols Haas, Carey and Livny have proposed a detailed I/O cost model in which seek time and rotational latency are explicit <ref> [14] </ref>. These authors reexamine a number of ad-hoc join methods using their cost model, and demonstrate that the ranking of join methods obtained by using a block-transfer-only cost model for I/O may change when the same algorithms are analyzed using their more detailed cost model. <p> In this paper, we shall use the detailed cost model from <ref> [14] </ref> to measure the cost of various join algorithms. The total I/O cost of a join algorithm is measured as N S T S + N I=O T L + N X T X : In this paper we choose to ignore CPU cost, and focus on the I/O cost. <p> We use the detailed cost model of <ref> [14] </ref> for the comparison. A comparison with Hybrid hash-join may be considered unfair because Hybrid hash join does not have access to a join index. <p> Memory management is done using a homegrown buffer manager, which avoids copying data blocks whenever possible. Therefore our system eliminates most of the performance disadvantages discussed in [30]. Similar to <ref> [14] </ref>, a large chunk of memory is statically allocated for each algorithm execution at startup time. <p> Some of the blocks are then used to input relations, output temporary and join results, store auxiliary and data blocks of a hash table or other structures, based on the memory management scheme specific to each algorithm. Our Hybrid hash-join implementation is based on the description in <ref> [14] </ref>, which has been demonstrated to yield much higher performance than a vanilla implementation due to the enhanced memory and I/O management. We implemented Valduriez's algorithm according to [31]. Two joining relations are produced using the Wisconsin synthetic database generator [3]. <p> Hui Lei observed that techniques for multilevel recursion applied to Jive-join and Slam-join. Thanks also to Mike Carey for clarifying some of the details of <ref> [14] </ref>.
Reference: [15] <author> Hoare, C. A. R. </author> <title> Quicksort. </title> <journal> Computer Journal 5, </journal> <volume> 1 (1962), </volume> <pages> 10-15. </pages>
Reference-contexts: If there was contention on the disk device between cylinder accesses, then we would have to count one seek per cylinder, since the seeks between cylinders would not necessarily be small. We assume that in-memory sorting is done in-place using an algorithm such as quicksort <ref> [15] </ref>. In this paper we do not address the cost of maintaining the join index. Blakeley and Martin have comprehensively analyzed the tradeoff between join index maintenance cost and the join speedup [4]. 4.2 Memory Requirements for Jive-Join We need Step J1 and Step J2 to fit in main memory.
Reference: [16] <author> Kim, W. </author> <title> A new way to compute the product and join of relations. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference (May 1980), </booktitle> <pages> pp. 179-187. </pages>
Reference-contexts: A number of techniques have been developed to perform joins in this setting <ref> [5, 6, 10, 16, 21, 28] </ref>. Decision support systems are characterized by complex ad-hoc join queries over large data sets. Relational systems relying on conventional data structures and ad-hoc join methods fail to deliver the needed response time for many such interactive queries.
Reference: [17] <author> Kimball, R., and Strehlo, K. </author> <title> Why decision support fails and how to fix it. </title> <booktitle> SIGMOD RECORD 24, 3 (1995), </booktitle> <pages> 92-97. </pages>
Reference-contexts: One chooses a join order that minimizes the total cost. We can extend Jive-join (and Slam-join) to joins of more than two relations, assuming that we are given a join-index having a tuple-id column for every participating relation. Star-schema design, as advocated for decision support systems <ref> [17] </ref>, is particularly well-suited to the use of multi-way join indices. Multi-way join indices could be maintained by the system.
Reference: [18] <author> Li, Z., and Ross, K. </author> <title> Federated query processing on the Net using information servers. </title> <type> manuscript, </type> <year> 1995. </year>
Reference-contexts: Both of our algorithms could be used in a conventional database system. Jive-join and Slam-join can, under many circumstances, deliver better performance for decision support systems than previously proposed algorithms. We describe the benefits of using Jive-join in the context of distributed query processing in <ref> [18] </ref>. Acknowledgements The authors wish to thank Damianos Chatziantoniou, Shu-Wie Chen, Akira Kawaguchi, and Hui Lei for suggesting several improvements to the presentation of this paper. Hui Lei observed that techniques for multilevel recursion applied to Jive-join and Slam-join.
Reference: [19] <author> Li, Z., and Ross, K. A. </author> <title> A new client-server architecture for distributed query processing. </title> <type> Tech. Rep. </type> <institution> CUCS-014-94, Columbia University, </institution> <year> 1994. </year>
Reference-contexts: The horizontal partitions of the second relation, together with the corresponding temporary files can be processed independently. The communication overhead of such a scheme depends on the data layout and machine architecture, and is beyond the scope of this paper. In <ref> [19] </ref>, a scheme is presented where the join index is vertically partitioned among a number of processors, each of which is responsible for one of the input relations. 10 Related Work Valduriez first proposed and analyzed an efficient algorithm based on join indexes [31].
Reference: [20] <author> Lu, W., and Han, J. </author> <title> Distance-associated join index for spatial range search. </title> <booktitle> In Proc. IEEE Int'l Conf. on Data Eng. </booktitle> <year> (1992), </year> <pages> pp. 284-292. 31 </pages>
Reference-contexts: This graph is then used to help in parallelizing the join. Hierarchies of join indices are used in [32] to speed up navigation in object-oriented databases. Join indices have also been used in spatial databases <ref> [26, 20] </ref>. 11 Conclusions We have presented two new algorithms, called Jive-join and Slam-join, for performing joins given a join index. We have derived detailed analytic cost formulas for the performance of our algorithms.
Reference: [21] <author> Mishra, P., and Eich, M. </author> <title> Join processing in relational databases. </title> <journal> ACM Computing Surveys 24, </journal> <month> 1 (March </month> <year> 1992). </year>
Reference-contexts: A number of techniques have been developed to perform joins in this setting <ref> [5, 6, 10, 16, 21, 28] </ref>. Decision support systems are characterized by complex ad-hoc join queries over large data sets. Relational systems relying on conventional data structures and ad-hoc join methods fail to deliver the needed response time for many such interactive queries.
Reference: [22] <author> Mohan, C., Haderie, D., Wang, Y., and Cheng, J. </author> <title> Single table access using multiple indexes: optimization, execution and concurrency control techniques. </title> <booktitle> In Proc. International Conference on Extending Data Base Technology (1990). </booktitle>
Reference-contexts: Thus one could apply selection conditions to the input relations' indexes (which are much smaller than the input relations themselves), combine the lists of resulting tuple-ids (using union for an "or" condition and intersection for an "and" condition <ref> [22] </ref>), and use the result to semijoin the join index [31]. Jive-join or Slam-join can then be applied to the input relations and the reduced join index.
Reference: [23] <author> Murphy, M. C., and Rotem, D. </author> <title> Multiprocessor join scheduling. </title> <journal> IEEE Transactions on knowledge and data enginnering 5, </journal> <volume> 2 (1993), </volume> <pages> 322-338. </pages>
Reference-contexts: In [9] it is implicitly assumed that the join result fits in memory. Jive-join and Slam-join solve the problem for cases in which the join result and input relations are much larger than main memory. Join indices have been used in <ref> [23] </ref> to define a graph between pages in two relations based on whether the pages contain a pair of matching records. This graph is then used to help in parallelizing the join. Hierarchies of join indices are used in [32] to speed up navigation in object-oriented databases.
Reference: [24] <author> O'Neill, P., and Graefe, G. </author> <title> Multi-table joins through bitmapped join indices. </title> <booktitle> SIGMOD Record 24, </booktitle> <month> 3 </month> <year> (1995). </year>
Reference-contexts: In situations where joins are taken often, the cost of doing this maintenance can be more than offset by the savings achieved in performing the join. A number of commercial decision support systems are rumored to be using join indexes <ref> [24] </ref>. In [31], Valduriez proposed and analyzed a join algorithm that uses the join index. The most important conclusion of that study was that, under many circumstances, having the join index allows one to compute the join significantly faster than the "best" ad-hoc methods such as Hybrid hash-join [10].
Reference: [25] <author> Ross, K. A. </author> <title> Efficiently following object references for large object collections and small main memory. </title> <booktitle> In Proceedings of the International Conference on Deductive and Object-Oriented Databases (1995), </booktitle> <pages> pp. 73-90. </pages> <publisher> Springer LNCS 1013. </publisher>
Reference-contexts: By adopting a vertically partitioned data organization for join results, Slam-join can make just a single pass through R 2 . An extension of the Jive-join technique presented here to object-oriented databases is given in <ref> [25] </ref>. In that context, there is no join index; tuple-identifiers from one relation are effectively embedded in the other. 10 There are certain optimizations to this process that are beyond the scope of this paper. 29 Related techniques for pointer-based joins have been presented in [29].
Reference: [26] <author> Rotem, D. </author> <title> Spatial join indices. </title> <booktitle> In Proc. IEEE Int'l Conf. on Data Eng. </booktitle> <year> (1991), </year> <pages> pp. 500-509. </pages>
Reference-contexts: This graph is then used to help in parallelizing the join. Hierarchies of join indices are used in [32] to speed up navigation in object-oriented databases. Join indices have also been used in spatial databases <ref> [26, 20] </ref>. 11 Conclusions We have presented two new algorithms, called Jive-join and Slam-join, for performing joins given a join index. We have derived detailed analytic cost formulas for the performance of our algorithms.
Reference: [27] <author> Selinger, P. G., Astrahan, M., Chamberlin, D., Lorie, R., and Price, T. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference (June 1979). </booktitle>
Reference-contexts: However, there is some difficulty asociated with measuring the cost of such a join sequence because it is necessary to optimize the order in which the component joins are performed <ref> [27] </ref>. The development of a join-ordering framework for conventional joins is beyond the scope of this paper.
Reference: [28] <author> Shapiro, L. </author> <title> Join processing in database systems with large main memories. </title> <journal> ACM Transactions on Database Systems 11, </journal> <month> 3 </month> <year> (1986). </year>
Reference-contexts: A number of techniques have been developed to perform joins in this setting <ref> [5, 6, 10, 16, 21, 28] </ref>. Decision support systems are characterized by complex ad-hoc join queries over large data sets. Relational systems relying on conventional data structures and ad-hoc join methods fail to deliver the needed response time for many such interactive queries.
Reference: [29] <author> Shekita, E., and Carey, M. J. </author> <title> A performance evaluation of pointer-based joins. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference (1990), </booktitle> <pages> pp. 300-311. </pages>
Reference-contexts: In that context, there is no join index; tuple-identifiers from one relation are effectively embedded in the other. 10 There are certain optimizations to this process that are beyond the scope of this paper. 29 Related techniques for pointer-based joins have been presented in <ref> [29] </ref>. Shekita and Carey consider pointer--based versions of standard join algorithms and demonstrate their relative performance. Their pointer based version of Hybrid hash join is sometimes an improvement of standard Hybrid hash join for large relations.
Reference: [30] <author> Stonebraker, M. R. </author> <title> Operating system support for database management. </title> <booktitle> Communication of the ACM 24, 7 (1981), </booktitle> <pages> 412-418. </pages>
Reference-contexts: Memory management is done using a homegrown buffer manager, which avoids copying data blocks whenever possible. Therefore our system eliminates most of the performance disadvantages discussed in <ref> [30] </ref>. Similar to [14], a large chunk of memory is statically allocated for each algorithm execution at startup time.
Reference: [31] <author> Valduriez, P. </author> <title> Join indices. </title> <journal> ACM Transactions on Database Systems 12, </journal> <volume> 2 (1987), </volume> <pages> 218-246. </pages>
Reference-contexts: One commonly used technique for speeding up join query processing is the precomputation of some of the join information. In this paper, we consider joins of relations for which there exists a pre-computed access structure, namely a join index <ref> [31] </ref>. A join index between two relations maintains pairs of identifiers of tuples that would match in case of a join. The join index may be maintained by the database system, and updated when tuples are inserted and deleted in the underlying relations. <p> In situations where joins are taken often, the cost of doing this maintenance can be more than offset by the savings achieved in performing the join. A number of commercial decision support systems are rumored to be using join indexes [24]. In <ref> [31] </ref>, Valduriez proposed and analyzed a join algorithm that uses the join index. The most important conclusion of that study was that, under many circumstances, having the join index allows one to compute the join significantly faster than the "best" ad-hoc methods such as Hybrid hash-join [10]. <p> We shall treat the join index as a relation, and denote it by J . Following <ref> [31] </ref> we assume that the join index is physically ordered by one of the tuple-id fields of its tuples; without loss of generality we assume J is ordered by the R 1 tuple-id. <p> Thus one could apply selection conditions to the input relations' indexes (which are much smaller than the input relations themselves), combine the lists of resulting tuple-ids (using union for an "or" condition and intersection for an "and" condition [22]), and use the result to semijoin the join index <ref> [31] </ref>. Jive-join or Slam-join can then be applied to the input relations and the reduced join index. Similarly, if the join index also included the join attribute value (for easy maintenance) then selections on the join attribute could be made on the join index itself. <p> Our Hybrid hash-join implementation is based on the description in [14], which has been demonstrated to yield much higher performance than a vanilla implementation due to the enhanced memory and I/O management. We implemented Valduriez's algorithm according to <ref> [31] </ref>. Two joining relations are produced using the Wisconsin synthetic database generator [3]. Each tuple consists of a four-byte integer as join attribute, plus any remaining padding bytes as a combination of integer and string attributes. <p> Valduriez's algorithm <ref> [31] </ref> does not seem to be extendible to join indexes with more than two columns. Thus, we cannot compare the performance of Jive-join with other join-index based algorithms for r &gt; 2. <p> In [19], a scheme is presented where the join index is vertically partitioned among a number of processors, each of which is responsible for one of the input relations. 10 Related Work Valduriez first proposed and analyzed an efficient algorithm based on join indexes <ref> [31] </ref>. One very important contribution of that work was to demonstrate that, under many circumstances, having the join index allows one to compute the join significantly faster than Hybrid hash join. Slam-join is similar to Valduriez's algorithm in the initial phase.
Reference: [32] <author> Xie, Z., and Han, J. </author> <title> Join index hierarchies for supporting efficient navigations in object-oriented databases. </title> <booktitle> In Proceedings of the 1994 VLDB conference (1994), </booktitle> <pages> pp. 522-533. </pages>
Reference-contexts: Join indices have been used in [23] to define a graph between pages in two relations based on whether the pages contain a pair of matching records. This graph is then used to help in parallelizing the join. Hierarchies of join indices are used in <ref> [32] </ref> to speed up navigation in object-oriented databases. Join indices have also been used in spatial databases [26, 20]. 11 Conclusions We have presented two new algorithms, called Jive-join and Slam-join, for performing joins given a join index.
Reference: [33] <author> Yao, S. B. </author> <title> Approximating block accesses in database organizations. </title> <journal> Communications of the ACM 20, </journal> <volume> 4 (1977), </volume> <pages> 260-261. </pages>
Reference-contexts: Y (k; d; n) Function to estimate the number of block accesses needed to retrieve k tuples out of n tuples stored in d blocks <ref> [33] </ref>. m Size of main memory, in disk blocks. fi Number of blocks in an input relation buffer. N S Number of seeks in an algorithm. N I=O Number of I/O requests in an algorithm. N X Number of block transfers in an algorithm.
References-found: 33

