URL: ftp://cse.ogi.edu/pub/pacsoft/papers/reactive.ps
Refering-URL: http://www.cse.ogi.edu/~dick/dick.html
Root-URL: http://www.cse.ogi.edu
Title: Reactive Functional Programming  
Author: Richard B. Kieburtz 
Date: February 2, 1998  
Address: P.O. Box 91000, Portland, OR 97291-1000 USA  
Affiliation: Oregon Graduate Institute of Science Technology  
Abstract: Reactive systems respond to concurrent, possibly unsynchronized streams of input events. Programming reactive systems is challenging without language support for event-triggered actions. It is even more challenging to reason about reactive systems. This paper explores a new conceptual basis for applying functional programming techniques to the design and formal verification of reactive systems. The mathematical foundation for this approach is based upon signature coalgebras and derived proof rules for coinduction. The concepts are illustrated with an example that has been used with the language Esterel. 
Abstract-found: 1
Intro-found: 1
Reference: [Abr92] <author> Samson Abramsky. </author> <title> A domain equation for bisumulation. </title> <journal> Information and Computation, </journal> <volume> 92 </volume> <pages> 161-218, </pages> <year> 1992. </year>
Reference-contexts: Somewhat less familiar is the dual rule of coinduction. The possible observations of a codata object are enumerable composites of a finite basis of primitive witness functions. The coinduction principle is that the finitely observable properties of an object completely characterize it, even if the object is not finitary <ref> [Abr92, MT92, Pit94, Jac96, Fio96] </ref>. An exposition of coinduction is given by Paulson [Pau97]. To define a proof rule for a stream of elements of type a, generated from a carrier of type t, let P be a two-place, typed predicate symbol whose arguments range over t and a, respectively.
Reference: [AW77] <author> Edward A. Ashcroft and William W. Wadge. </author> <title> Lucid: A non-procedural language with iteration. </title> <journal> Communications of the ACM, </journal> <volume> 20(7) </volume> <pages> 519-526, </pages> <year> 1977. </year>
Reference-contexts: This is by no means the first time that the concepts of iterative control and synchronous data flow (i.e. streams) have been embedded into a programming notation. These concepts were the basis for the language Lucid <ref> [AW77] </ref>, and earlier, in Kahn-McQueen networks [Kah74]. These early language developments led directly to Lustre [HCRP91], a language that has found considerable use for programming reactive systems. 2 Covarieties of coalgebras A covariety is a class of coalgebras with a common signature.
Reference: [BG92] <author> G. Berry and G. Gonthier. </author> <title> The Esterel synchronous programming language: Design, semantics, </title> <booktitle> implementation. Science Of Computer Programming, </booktitle> <volume> 19(2) </volume> <pages> 87-152, </pages> <year> 1992. </year>
Reference-contexts: Formulating a reactive system as a coalgebra is more natural because the use of multiple sorts provides a detailed structure for the specification. We shall illustrate the technique with an example of a synchronous reactive system previously used to illustrate programming in Esterel <ref> [BG92] </ref>. Example 3.1 : The Reflex game The Reflex game is a coin-operated machine on which a player measures the time constant of her reflexes. After depositing a coin to start the game, she can depress a Ready button to signify that she is prepared to start a trial.
Reference: [Bir86] <author> Richard S. Bird. </author> <title> An introduction to the theory of lists. </title> <editor> In M. Broy, editor, </editor> <booktitle> Logic of Programming and Calculi of Discrete Design, volume 36 of NATO Series F. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Section 4 presents brief conclusions. 2 1.2 Iterative functional programming In the past, several researchers have observed that programming with terminating recursion schemes is algebraic in nature <ref> [Bur87, Bir86, Fre90, MFP91, KL95] </ref>.
Reference: [BRdSV90] <author> G. Boudol, V. Roy, R. de Simone, and D. Vergamini. </author> <title> Process calculi, from theory to practice: Verification tools. In Automatic Verification Methods for Finite State Systems, </title> <publisher> LNCS 407, </publisher> <pages> pages 1-10. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: This derived proposition can then be used to restrict the domain of antecedent clauses in a proof using the Reflex game coinduction rule. Verification logics have also been developed for proving safety properties of systems specified in Lustre [HLR92, HFB93] and Esterel <ref> [BRdSV90] </ref>. 3.2 Liveness properties of the Reflex game Liveness properties, which assert that a state or state sequence with the property is eventually reached in every unfolding of the game, require for their proof a specific measure of progress.
Reference: [Bry86] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference: [Bry92] <author> R. E. Bryant. </author> <title> Symbolic boolean manipulation with ordered binary decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <month> September </month> <year> 1992. </year>
Reference: [Bur87] <author> Rod Burstall. </author> <title> Inductively defined functions in functional programming languages. </title> <type> Technical Report ECS-LFCS-87-25, </type> <institution> Dept. of Computer Science, University of Edinburgh, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: Section 4 presents brief conclusions. 2 1.2 Iterative functional programming In the past, several researchers have observed that programming with terminating recursion schemes is algebraic in nature <ref> [Bur87, Bir86, Fre90, MFP91, KL95] </ref>.
Reference: [CGL92] <author> E. M. Clarke, O. Grumberg, and D. </author> <title> Long. Verification tools for finite-state concurrent systems. In A Decade of Concurrency: Reflections and Perspectives, </title> <booktitle> volume 803 of Lecture Notes in Computer Science, </booktitle> <pages> pages 124-175. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: We shall attend to the first clause. The most successful way yet developed to verify temporal properties of a finite state system uses model checking of temporal logic formulas <ref> [EC82, CGL92] </ref>. The safety and liveness properties of the Reflex game example can obviously be verified by symbolic model checking. We describe a variant of the stardard technique that uses symbolic inference to check monotonicity properties of state variables over transition paths. We have not yet implemented this method.
Reference: [EC82] <author> E. A. Emerson and E. M. Clarke. </author> <title> Using branching time temporal logic to synthesize synchronizations skeletons. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 2 </volume> <pages> 241-266, </pages> <year> 1982. </year> <month> 22 </month>
Reference-contexts: We shall attend to the first clause. The most successful way yet developed to verify temporal properties of a finite state system uses model checking of temporal logic formulas <ref> [EC82, CGL92] </ref>. The safety and liveness properties of the Reflex game example can obviously be verified by symbolic model checking. We describe a variant of the stardard technique that uses symbolic inference to check monotonicity properties of state variables over transition paths. We have not yet implemented this method.
Reference: [Fio96] <author> Marcelo P. Fiore. </author> <title> A coinduction principle for recursive data types based on bisimulation. </title> <journal> Information and Computation, </journal> <volume> 127(2) </volume> <pages> 186-198, </pages> <year> 1996. </year>
Reference-contexts: Somewhat less familiar is the dual rule of coinduction. The possible observations of a codata object are enumerable composites of a finite basis of primitive witness functions. The coinduction principle is that the finitely observable properties of an object completely characterize it, even if the object is not finitary <ref> [Abr92, MT92, Pit94, Jac96, Fio96] </ref>. An exposition of coinduction is given by Paulson [Pau97]. To define a proof rule for a stream of elements of type a, generated from a carrier of type t, let P be a two-place, typed predicate symbol whose arguments range over t and a, respectively.
Reference: [Fre90] <author> Peter Freyd. </author> <title> Recursive types reduced to inductive types. </title> <booktitle> In Fifth IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 498-507, </pages> <year> 1990. </year>
Reference-contexts: Section 4 presents brief conclusions. 2 1.2 Iterative functional programming In the past, several researchers have observed that programming with terminating recursion schemes is algebraic in nature <ref> [Bur87, Bir86, Fre90, MFP91, KL95] </ref>.
Reference: [HCRP91] <author> N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud. </author> <title> The synchronous dataflow programming language Lustre. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9) </volume> <pages> 1305-1320, </pages> <year> 1991. </year>
Reference-contexts: These concepts were the basis for the language Lucid [AW77], and earlier, in Kahn-McQueen networks [Kah74]. These early language developments led directly to Lustre <ref> [HCRP91] </ref>, a language that has found considerable use for programming reactive systems. 2 Covarieties of coalgebras A covariety is a class of coalgebras with a common signature.
Reference: [HFB93] <author> N. Halbwachs, J.-C. Fernandez, and A. Bouajjanni. </author> <title> An executable temporal logic to express safety properties and its connection with the language Lustre. </title> <booktitle> In Sixth International Symp. on Lucid and Intensional Programming, </booktitle> <address> ISLIP'93, Quebec City, Canada, </address> <month> April </month> <year> 1993. </year> <institution> Universite Laval. </institution>
Reference-contexts: This derived proposition can then be used to restrict the domain of antecedent clauses in a proof using the Reflex game coinduction rule. Verification logics have also been developed for proving safety properties of systems specified in Lustre <ref> [HLR92, HFB93] </ref> and Esterel [BRdSV90]. 3.2 Liveness properties of the Reflex game Liveness properties, which assert that a state or state sequence with the property is eventually reached in every unfolding of the game, require for their proof a specific measure of progress.
Reference: [HLR92] <author> N. Halbwachs, F. Lagnier, and C. Ratel. </author> <title> Programming and verifying real-time systems by means of the synchronous data-flow programming language lustre. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(9), </volume> <year> 1992. </year>
Reference-contexts: This derived proposition can then be used to restrict the domain of antecedent clauses in a proof using the Reflex game coinduction rule. Verification logics have also been developed for proving safety properties of systems specified in Lustre <ref> [HLR92, HFB93] </ref> and Esterel [BRdSV90]. 3.2 Liveness properties of the Reflex game Liveness properties, which assert that a state or state sequence with the property is eventually reached in every unfolding of the game, require for their proof a specific measure of progress.
Reference: [Jac96] <editor> Bart Jacobs. Mongruences and cofree coalgebras. </editor> <booktitle> In Algebraic Methodology and Software Technology - AMAST'95, volume 936 of Lecture Notes in Computer Science, </booktitle> <pages> pages 245-260. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Somewhat less familiar is the dual rule of coinduction. The possible observations of a codata object are enumerable composites of a finite basis of primitive witness functions. The coinduction principle is that the finitely observable properties of an object completely characterize it, even if the object is not finitary <ref> [Abr92, MT92, Pit94, Jac96, Fio96] </ref>. An exposition of coinduction is given by Paulson [Pau97]. To define a proof rule for a stream of elements of type a, generated from a carrier of type t, let P be a two-place, typed predicate symbol whose arguments range over t and a, respectively.
Reference: [Kah74] <author> Gilles Kahn. </author> <title> The semantics of a simple language for parallel programming. </title> <booktitle> In IFIP'74 Congress. </booktitle> <publisher> North Holland, </publisher> <year> 1974. </year>
Reference-contexts: This is by no means the first time that the concepts of iterative control and synchronous data flow (i.e. streams) have been embedded into a programming notation. These concepts were the basis for the language Lucid [AW77], and earlier, in Kahn-McQueen networks <ref> [Kah74] </ref>. These early language developments led directly to Lustre [HCRP91], a language that has found considerable use for programming reactive systems. 2 Covarieties of coalgebras A covariety is a class of coalgebras with a common signature.
Reference: [KL94] <author> Richard B. Kieburtz and Jeffrey Lewis. </author> <title> Algebraic Design Language| Preliminary definition. </title> <type> Technical report, </type> <institution> Pacific Software Research Center, Oregon Graduate Institute of Science & Technology, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: The notation is used in DUALITY, which is an experimental, functional language based upon algebras and coalgebras as its fundamental computational structures. In this paper we shall deal only with the coalgebraic part. An early version of this language has been implemented and is described in a technical report <ref> [KL94] </ref>. This is by no means the first time that the concepts of iterative control and synchronous data flow (i.e. streams) have been embedded into a programming notation. These concepts were the basis for the language Lucid [AW77], and earlier, in Kahn-McQueen networks [Kah74].
Reference: [KL95] <author> Richard B. Kieburtz and Jeffrey Lewis. </author> <title> Programming with algebras. </title> <booktitle> In Advanced Functional Programming, volume 925 of Lecture Notes in Computer Science, </booktitle> <pages> pages 267-307. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Section 4 presents brief conclusions. 2 1.2 Iterative functional programming In the past, several researchers have observed that programming with terminating recursion schemes is algebraic in nature <ref> [Bur87, Bir86, Fre90, MFP91, KL95] </ref>.
Reference: [MFP91] <author> Erik Meijer, Maarten Fokkinga, and Ross Paterson. </author> <title> Functional programming with bananas, lenses, envelopes and barbed wire. </title> <booktitle> In Proc. of 5th ACM Conf. on Functional Programming Languages and Computer Architecture, volume 523 of Lecture Notes in Computer Science, </booktitle> <pages> pages 124-144. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: Section 4 presents brief conclusions. 2 1.2 Iterative functional programming In the past, several researchers have observed that programming with terminating recursion schemes is algebraic in nature <ref> [Bur87, Bir86, Fre90, MFP91, KL95] </ref>. <p> To determine a generator, we must specify a coalgebra 1 Readers familiar with the notion of anamorphism <ref> [MFP91] </ref> may be tempted to identify 4 by naming a covariety, a type for the carrier and bindings of functions for the projectors. Coalgebras are first-class objects of DUALITY.
Reference: [MT92] <author> Robin Milner and Mads Tofte. </author> <title> Co-induction in relational semantics. </title> <journal> Theoretical Computer Science, </journal> <volume> 87 </volume> <pages> 209-220, </pages> <year> 1992. </year>
Reference-contexts: Somewhat less familiar is the dual rule of coinduction. The possible observations of a codata object are enumerable composites of a finite basis of primitive witness functions. The coinduction principle is that the finitely observable properties of an object completely characterize it, even if the object is not finitary <ref> [Abr92, MT92, Pit94, Jac96, Fio96] </ref>. An exposition of coinduction is given by Paulson [Pau97]. To define a proof rule for a stream of elements of type a, generated from a carrier of type t, let P be a two-place, typed predicate symbol whose arguments range over t and a, respectively.
Reference: [Pau97] <author> Lawrence C. Paulson. </author> <title> Mechanizing coinduction and corecursion in higher-order logic. </title> <journal> Journal of Logic and Computation, </journal> <volume> 7(2) </volume> <pages> 175-204, </pages> <year> 1997. </year>
Reference-contexts: The coinduction principle is that the finitely observable properties of an object completely characterize it, even if the object is not finitary [Abr92, MT92, Pit94, Jac96, Fio96]. An exposition of coinduction is given by Paulson <ref> [Pau97] </ref>. To define a proof rule for a stream of elements of type a, generated from a carrier of type t, let P be a two-place, typed predicate symbol whose arguments range over t and a, respectively.
Reference: [Pit94] <author> Andrew Pitts. </author> <title> A coinduction principle for recursively defined domains. </title> <journal> Theoretical Computer Science, </journal> <volume> 124(2) </volume> <pages> 195-219, </pages> <year> 1994. </year> <month> 23 </month>
Reference-contexts: Somewhat less familiar is the dual rule of coinduction. The possible observations of a codata object are enumerable composites of a finite basis of primitive witness functions. The coinduction principle is that the finitely observable properties of an object completely characterize it, even if the object is not finitary <ref> [Abr92, MT92, Pit94, Jac96, Fio96] </ref>. An exposition of coinduction is given by Paulson [Pau97]. To define a proof rule for a stream of elements of type a, generated from a carrier of type t, let P be a two-place, typed predicate symbol whose arguments range over t and a, respectively.
References-found: 23

