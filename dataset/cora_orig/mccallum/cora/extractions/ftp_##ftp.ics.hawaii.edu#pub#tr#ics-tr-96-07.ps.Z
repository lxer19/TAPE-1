URL: ftp://ftp.ics.hawaii.edu/pub/tr/ics-tr-96-07.ps.Z
Refering-URL: ftp://ftp.ics.hawaii.edu/pub/tr/INDEX.html
Root-URL: 
Title: Timing Analysis of Ada Tasking Programs  
Author: James C. Corbett 
Keyword: timing analysis, real-time systems, program verification, hybrid systems, Ada tasking.  
Date: 7, JULY 1996 1  
Note: IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 22, NO.  
Abstract: Concurrent real-time software is increasingly used in safety-critical embedded systems. Assuring the quality of such software requires the rigor of formal methods. In order to analyze a program formally, we must first construct a mathematical model of its behavior. In this paper, we consider the problem of constructing such models for concurrent real-time software. In particular, we provide a method for building mathematical models of real-time Ada tasking programs that are accurate enough to verify interesting timing properties, and yet abstract enough to yield a tractable analysis on nontrivial programs. Our approach differs from schedulability analysis in that we do not assume that the software has a highly restricted structure (e.g., a set of periodic tasks). Also, unlike most abstract models of real-time systems, we account for essential properties of real implementations, such as resource constraints and run-time overhead. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, C. Courcoubetis, N. Halbwachs, T. Henzinger, P. Ho, X. Nicollin, A. Olivero, J. Sifakis, and S. Yovine. </author> <title> The algorithmic analysis of hybrid systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 138 </volume> <pages> 3-34, </pages> <year> 1995. </year>
Reference-contexts: In order to insure that our model is a conservative abstraction of the program's timing properties, we also discuss how to account for various common sources of run-time overhead. A. Hybrid Automata We chose constant slope linear hybrid automata <ref> [1] </ref> as our timed model. Hybrid automata combine a finite-state control with a set of real-valued variables. The values of the variables change continuously while the automaton remains at a control location, and may change discretely with an instantaneous transition from one control location to another. <p> The constant accounts for the inaccuracy of the timer mechanism, which we discuss in Section IV-C.2. We give the formal definition for hybrid automata below. These definitions are a combination of those from <ref> [1] </ref> and [25]. A.1 Syntax A hybrid automaton M is a 6-tuple (Loc; Var; Lab; Edg; Act; Inv) where * Loc is a set of locations. * Var is a set of real-valued variables. <p> In a continuous time model, we could represent this region with a millisecond delay in the real interval [1027; 1937]. By changing the time unit to seconds and sacrificing some accuracy, we could instead represent the code region using a second delay in the real interval <ref> [1; 2] </ref>. Note that both of these representations are conservative abstractions|every program behavior is rep 16 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 22, NO. 7, JULY 1996 resented. <p> The analysis automaton is analyzed using the standard method for reachability analysis of hybrid systems, which is described in detail in <ref> [1] </ref>. The method determines the set of reachable states of a hybrid automaton using the fixpoint technique we sketch below. A region is a set of states of a hybrid automaton specified by a predicate. <p> For example, an upper bound on the value of a variable z can be obtained by solving for the parameter ff in post fl (I)" (z ff). The state reachability problem for hybrid automata is undecidable <ref> [1] </ref>. It follows that the above analysis algorithm provides only a semidecision procedure|there may be no fixpoint and thus the algorithm may not terminate. Nevertheless, Henzinger reports [25] that the algorithm usually does terminate in practice, and our own experience supports this. B.
Reference: [2] <author> R. Alur and D. Dill. </author> <title> Automata for modeling real-time systems. </title> <booktitle> In Proc. 17th Int. Colloq. </booktitle> <address> Aut. Lang. Prog., </address> <year> 1990. </year>
Reference-contexts: Such constraints are awkward to represent in most real-time specification languages, which provide mechanisms in which time advances uniformly for all components (e.g., timed automata <ref> [2] </ref>, which are hybrid automata in which all clocks advance at rate one in all locations). Whether real-time systems should be modeled with continuous or discrete time is still a topic of debate. Our second reason for choosing hybrid automata was to use a continuous model of time. <p> In a continuous time model, we could represent this region with a millisecond delay in the real interval [1027; 1937]. By changing the time unit to seconds and sacrificing some accuracy, we could instead represent the code region using a second delay in the real interval <ref> [1; 2] </ref>. Note that both of these representations are conservative abstractions|every program behavior is rep 16 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 22, NO. 7, JULY 1996 resented.
Reference: [3] <author> R. Alur and R. Kurshan. </author> <title> Timing verification by successive approximation. </title> <journal> Information and Computation, </journal> <volume> 118(1) </volume> <pages> 142-157, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: A variable representing an alarm is relevant only while the alarm is pending and is thus set to unknown when the timer signal occurs. Second, we polish <ref> [3] </ref> all the timing constraints in the program automaton so that all constants appearing in the constraints are multiples of some fixed value m.
Reference: [4] <author> E. Ashcroft and Z. Manna. </author> <title> Formalization of properties of parallel programs. </title> <journal> Machine Intelligence, </journal> <volume> 6 </volume> <pages> 17-41, </pages> <year> 1971. </year>
Reference-contexts: D. Reducing the Transition System The transition systems produced by the rewrite rules outlined in Section III-C are much larger than required for our analysis. In this section, we reduce the size of the transition system by applying virtual coarsening <ref> [4] </ref>, a well-known technique for reducing the size of concurrency models by collapsing invisible actions into adjacent visible actions.
Reference: [5] <author> G. S. Avrunin, U. A. Buy, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Time Iterations Time Robot 303 558 11 5 37 43 Target 289 715 8 6 48 2,486 TABLE III Performance of Tools on Case Studies Duration/Delay Range/Value ReadFrame [100; 200] CameraPeriod 4,000 Bodies of Image entries [100; 200] ImageExpire 4,000 AimInitial [400; 1100] AimRefine [400; 700] Bodies of Command entries <ref> [5; 10] </ref> AimAndFire [100; 300] TABLE IV Durations Used in Target Example The performance of the model building tool and HyTech on the case studies is given in Table III. Times are in seconds on a Sun SPARCstation 10 with 96 MB and include both user and system time. <p> For example, the delay statement need not be modeled at all in a concurrency analysis, and most rendezvous can be modeled with a single transition <ref> [5] </ref>.
Reference: [6] <author> G. S. Avrunin, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automatic derivation of time bounds in uniprocessor concurrent systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 20(9) </volume> <pages> 708-719, </pages> <year> 1994. </year>
Reference-contexts: Since then, however, advances in concurrent systems analysis (e.g., symbolic model checking, state space reductions) have greatly extended the size of the programs to which that basic modeling/analysis technique can be applied [12]. Indeed, several symbolic/approximate analysis techniques have already been proposed for simpler models of real-time programs <ref> [6, 13, 29] </ref>. VI. Conclusion We have presented a method for constructing mathematical models of general real-time Ada tasking programs suitable for verifying their timing properties, and have demonstrated the feasibility of our method by constructing and analyzing models of two nontrivial programs.
Reference: [7] <author> J. G. P. Barnes. </author> <title> Programming in Ada. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The case studies in Section II-C illustrate most of the concurrent and real-time constructs sketched above. A detailed description of the semantics of these constructs can be found in the Ada Language Reference Manual [36]. Many recent books on Ada (e.g., <ref> [7] </ref>) provide an overview of these features with examples of their use. B. Features Modeled Ada is a large language, even after restricting attention to its concurrency and real-time constructs.
Reference: [8] <author> B. Berthomieu and M. Diaz. </author> <title> Modeling and verification of time dependent systems using time Petri nets. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17 </volume> <pages> 259-273, </pages> <year> 1991. </year>
Reference: [9] <author> J. C. Corbett. </author> <title> Modeling and analysis of real-time Ada tasking programs. </title> <booktitle> In Ramamritham [32], </booktitle> <pages> pages 132-141. </pages>
Reference-contexts: The resulting hybrid automaton is then analyzed automatically. We use the HyTech verifier for hybrid systems [24] to analyze the hybrid automata produced by our method. This work extends that of <ref> [9] </ref> and [11] in several ways. First, we model several new constructs introduced in Ada 95 2 , including protected types, the delay until statement, and asynchronous transfer of control. Second, we explicitly represent the run-time system in the model. <p> C. Case Studies Many of the features of Ada described above are illustrated in our two case studies, which we introduce here. These two programs will be analyzed in Section V-C. C.1 Robot Example The first example is a robot controller analyzed in <ref> [9, 23] </ref> and based on the distributed robot system of [16]. The program collects sensor data and integrates this data to periodically send a command to a robot. There are two sensor tasks and one integrator task. <p> In <ref> [9, 11] </ref>, the composition operator was used to combine hybrid automata representing each task into a hybrid automaton representing the program. <p> This run can help the analyst understand how the program can violate the timing requirement, and perhaps suggest ways to modify the program in order to meet the requirement. For a version of this example, we showed in <ref> [9] </ref> that, if the integrator task is given the highest priority, then the timing requirement is met.
Reference: [10] <author> J. C. Corbett. </author> <title> A method for timing analysis of Ada tasking programs. </title> <type> Technical Report ICS-TR-95-17, </type> <institution> Information and Computer Science Department, University of Hawaii at Manoa, </institution> <month> De-cember </month> <year> 1995. </year>
Reference-contexts: Details of the representation of these constructs are given in a technical report <ref> [10] </ref>. D. Reducing the Transition System The transition systems produced by the rewrite rules outlined in Section III-C are much larger than required for our analysis. <p> CONSTRUCT Range/ Duration/Delay Value RENDEZVOUS Code to queue/pend call in caller (before blocking) [60; 80] Code to complete call in caller (after being signaled) <ref> [10; 20] </ref> Code to begin rendezvous in acceptor (before body) [25; 50] Code to complete rendezvous in acceptor (after body) [25; 50] PROTECTED OBJECT Code to queue/pend call in caller [25; 50] Code to complete call in caller [25; 50] DELAY Code to set timer request [25; 50] Code to process <p> Time Iterations Time Robot 303 558 11 5 37 43 Target 289 715 8 6 48 2,486 TABLE III Performance of Tools on Case Studies Duration/Delay Range/Value ReadFrame [100; 200] CameraPeriod 4,000 Bodies of Image entries [100; 200] ImageExpire 4,000 AimInitial [400; 1100] AimRefine [400; 700] Bodies of Command entries <ref> [5; 10] </ref> AimAndFire [100; 300] TABLE IV Durations Used in Target Example The performance of the model building tool and HyTech on the case studies is given in Table III. Times are in seconds on a Sun SPARCstation 10 with 96 MB and include both user and system time.
Reference: [11] <author> J. C. Corbett. </author> <title> Constructing abstract models of concurrent real-time software. </title> <editor> In S. Ziel, editor, </editor> <booktitle> Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA). </booktitle> <publisher> ACM Press, </publisher> <month> January </month> <year> 1996. </year>
Reference-contexts: The resulting hybrid automaton is then analyzed automatically. We use the HyTech verifier for hybrid systems [24] to analyze the hybrid automata produced by our method. This work extends that of [9] and <ref> [11] </ref> in several ways. First, we model several new constructs introduced in Ada 95 2 , including protected types, the delay until statement, and asynchronous transfer of control. Second, we explicitly represent the run-time system in the model. <p> A real-valued variable, x, which advances continuously as time passes, is reset to zero when the location representing the beginning of the 7 T fl -points are a formal characterization of the S-points from <ref> [11] </ref>. 14 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 22, NO. 7, JULY 1996 Fig. 11. <p> In <ref> [9, 11] </ref>, the composition operator was used to combine hybrid automata representing each task into a hybrid automaton representing the program.
Reference: [12] <author> J. C. Corbett. </author> <title> Evaluating deadlock detection methods for concurrent software. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 22(3) </volume> <pages> 161-180, </pages> <year> 1996. </year>
Reference-contexts: Since then, however, advances in concurrent systems analysis (e.g., symbolic model checking, state space reductions) have greatly extended the size of the programs to which that basic modeling/analysis technique can be applied <ref> [12] </ref>. Indeed, several symbolic/approximate analysis techniques have already been proposed for simpler models of real-time programs [6, 13, 29]. VI.
Reference: [13] <author> J. C. Corbett and G. S. Avrunin. </author> <title> A practical method for bounding the time between events in concurrent real-time systems. </title> <editor> In T. Ostrand and E. Weyuker, editors, </editor> <booktitle> Proceedings of the 1993 International Symposium on Software Testing and Analysis (IS-STA), </booktitle> <pages> pages 110-116, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Since then, however, advances in concurrent systems analysis (e.g., symbolic model checking, state space reductions) have greatly extended the size of the programs to which that basic modeling/analysis technique can be applied [12]. Indeed, several symbolic/approximate analysis techniques have already been proposed for simpler models of real-time programs <ref> [6, 13, 29] </ref>. VI. Conclusion We have presented a method for constructing mathematical models of general real-time Ada tasking programs suitable for verifying their timing properties, and have demonstrated the feasibility of our method by constructing and analyzing models of two nontrivial programs.
Reference: [14] <author> P. Cousot and N. Halbwachs. </author> <title> Automatic discovery of linear restraints among variables of a program. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1978. </year>
Reference-contexts: Further, existential quantification can be used to perform a parametric analysis in which the required constraints on one or more parameters can be derived automatically <ref> [14] </ref>. For example, an upper bound on the value of a variable z can be obtained by solving for the parameter ff in post fl (I)" (z ff). The state reachability problem for hybrid automata is undecidable [1].
Reference: [15] <author> A. N. Fredette and R. Cleaveland. RTSL: </author> <title> a formal language for real-time schedulability analysis. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <pages> pages 274-283, </pages> <year> 1993. </year>
Reference: [16] <author> R. Gerber and I. Lee. </author> <title> A layered approach to automating the verification of real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 18(9) </volume> <pages> 768-784, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: These two programs will be analyzed in Section V-C. C.1 Robot Example The first example is a robot controller analyzed in [9, 23] and based on the distributed robot system of <ref> [16] </ref>. The program collects sensor data and integrates this data to periodically send a command to a robot. There are two sensor tasks and one integrator task. The program's structure is shown in Fig. 1 and its source code is shown in Fig. 2.
Reference: [17] <author> C. Ghezzi, D. Mandriolli, S. Morasca, and M. Pezze. </author> <title> A unified high-level Petri net model for time-critical systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(2), </volume> <month> Feb. </month> <year> 1991. </year>
Reference: [18] <author> C. Ghezzi, D. Mandriolli, and A. Morzenti. </author> <title> Trio: A logic language for executable specifications of real-time systems. </title> <journal> Journal of Systems and Software, </journal> <volume> 12(2) </volume> <pages> 107-123, </pages> <month> May </month> <year> 1990. </year>
Reference: [19] <author> E. W. Giering and T. P. Baker. </author> <title> Using POSIX threads to implement Ada tasking: Description of work in progress. </title> <booktitle> In Proceedings of TriAda'92, </booktitle> <pages> pages 518-529, </pages> <year> 1992. </year>
Reference: [20] <author> E. W. Giering and T. P. Baker. </author> <title> The Gnu Ada runtime library (GNARL): </title> <booktitle> Design and implementation. In Proceedings of the Eleventh Annual Washington Ada Symposium and Summer ACM SIGAda Meeting (WAdaS '94), </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: The details of the data structures used to hold this information, as well as the code used to implement the constructs, varies from compiler to compiler. In order to understand how an Ada run-time system could be implemented, we looked at the GNU Ada Run-time Library (GNARL) <ref> [20] </ref>, the run-time system of the GNU Ada Translator (GNAT). The design and implementation of GNARL is described in several papers [19 21] and its source code is freely available. <p> A delay (until) alternative can also be used in a timed entry call to bound the time the caller will wait for the entry to be accepted. We use a simple source transformation given in <ref> [20] </ref> to implement a timed entry call using an asynchronous transfer of control. C.4 Other Constructs We can use the same basic method to model Ada's other concurrent and real-time constructs. <p> C.2 Timer Services Our representation of the overhead of timer services is based on the implementation of those services in GNARL <ref> [20] </ref>. We give a brief overview of this implementation and then describe how to account for the resulting overhead. <p> CONSTRUCT Range/ Duration/Delay Value RENDEZVOUS Code to queue/pend call in caller (before blocking) [60; 80] Code to complete call in caller (after being signaled) <ref> [10; 20] </ref> Code to begin rendezvous in acceptor (before body) [25; 50] Code to complete rendezvous in acceptor (after body) [25; 50] PROTECTED OBJECT Code to queue/pend call in caller [25; 50] Code to complete call in caller [25; 50] DELAY Code to set timer request [25; 50] Code to process
Reference: [21] <author> E. W. Giering, F. Mueller, and T. P. Baker. </author> <title> Implementing Ada 9X features using POSIX threads: </title> <booktitle> Design issues. In Proceedings of TriAda'93, </booktitle> <year> 1993. </year>
Reference: [22] <author> M. G. Harbour, M. H. Klein, and J. P. Lehoczky. </author> <title> Timing analysis for fixed-priority scheduling of hard real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 20(1) </volume> <pages> 13-28, </pages> <year> 1994. </year>
Reference: [23] <author> T. Henzinger and P.-H. Ho. HyTech: </author> <title> The Cornell Hybrid Technology Tool. </title> <booktitle> In Proceedings of the 1994 Workshop on Hybrid Systems and Autonomous Control, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: C. Case Studies Many of the features of Ada described above are illustrated in our two case studies, which we introduce here. These two programs will be analyzed in Section V-C. C.1 Robot Example The first example is a robot controller analyzed in <ref> [9, 23] </ref> and based on the distributed robot system of [16]. The program collects sensor data and integrates this data to periodically send a command to a robot. There are two sensor tasks and one integrator task.
Reference: [24] <author> T. A. Henzinger, P.-H. Ho, and H. Wong-Toi. HyTech: </author> <title> the next generation. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1995. </year>
Reference-contexts: The resulting hybrid automaton is then analyzed automatically. We use the HyTech verifier for hybrid systems <ref> [24] </ref> to analyze the hybrid automata produced by our method. This work extends that of [9] and [11] in several ways. First, we model several new constructs introduced in Ada 95 2 , including protected types, the delay until statement, and asynchronous transfer of control.
Reference: [25] <author> T. A. Henzinger, P.-H. Ho, and H. Wong-Toi. </author> <title> A user guide to HyTech. </title> <type> Technical Report CSD-TR-95-1532, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1995. </year>
Reference-contexts: The constant accounts for the inaccuracy of the timer mechanism, which we discuss in Section IV-C.2. We give the formal definition for hybrid automata below. These definitions are a combination of those from [1] and <ref> [25] </ref>. A.1 Syntax A hybrid automaton M is a 6-tuple (Loc; Var; Lab; Edg; Act; Inv) where * Loc is a set of locations. * Var is a set of real-valued variables. A valuation is a function v : Var ! R that assigns a value to each variable. <p> Fig. 14 and Fig. 15 show the property automata we use for our case studies. Hints for specifying other kinds of commonly occurring properties are given in <ref> [25] </ref>. The synchronization labels in the property automaton identify events in the program that are mentioned in the timing requirement. We label each transition in the program automaton that represents the occurrence of one of these events with the appropriate label. <p> The state reachability problem for hybrid automata is undecidable [1]. It follows that the above analysis algorithm provides only a semidecision procedure|there may be no fixpoint and thus the algorithm may not terminate. Nevertheless, Henzinger reports <ref> [25] </ref> that the algorithm usually does terminate in practice, and our own experience supports this. B. <p> HyTech composes the program and property automata, and then performs the analysis specified by the commands. We examine the output of HyTech to determine the result of the analysis. In order to improve the efficiency of the analysis, we use two techniques recommended in <ref> [25] </ref>. First, we explicitly set the values of variables that are no longer relevant to unknown. <p> CONSTRUCT Range/ Duration/Delay Value RENDEZVOUS Code to queue/pend call in caller (before blocking) [60; 80] Code to complete call in caller (after being signaled) [10; 20] Code to begin rendezvous in acceptor (before body) <ref> [25; 50] </ref> Code to complete rendezvous in acceptor (after body) [25; 50] PROTECTED OBJECT Code to queue/pend call in caller [25; 50] Code to complete call in caller [25; 50] DELAY Code to set timer request [25; 50] Code to process timer expiration [25; 50] Timer interrupt period () 100 Upper <p> CONSTRUCT Range/ Duration/Delay Value RENDEZVOUS Code to queue/pend call in caller (before blocking) [60; 80] Code to complete call in caller (after being signaled) [10; 20] Code to begin rendezvous in acceptor (before body) <ref> [25; 50] </ref> Code to complete rendezvous in acceptor (after body) [25; 50] PROTECTED OBJECT Code to queue/pend call in caller [25; 50] Code to complete call in caller [25; 50] DELAY Code to set timer request [25; 50] Code to process timer expiration [25; 50] Timer interrupt period () 100 Upper bound on atomic code segments (ffi) 80 TABLE I Durations <p> RENDEZVOUS Code to queue/pend call in caller (before blocking) [60; 80] Code to complete call in caller (after being signaled) [10; 20] Code to begin rendezvous in acceptor (before body) <ref> [25; 50] </ref> Code to complete rendezvous in acceptor (after body) [25; 50] PROTECTED OBJECT Code to queue/pend call in caller [25; 50] Code to complete call in caller [25; 50] DELAY Code to set timer request [25; 50] Code to process timer expiration [25; 50] Timer interrupt period () 100 Upper bound on atomic code segments (ffi) 80 TABLE I Durations used for Run-Time Overhead (microseconds) Duration/Delay Range/Value ReadSensor1 [500; 800] <p> blocking) [60; 80] Code to complete call in caller (after being signaled) [10; 20] Code to begin rendezvous in acceptor (before body) <ref> [25; 50] </ref> Code to complete rendezvous in acceptor (after body) [25; 50] PROTECTED OBJECT Code to queue/pend call in caller [25; 50] Code to complete call in caller [25; 50] DELAY Code to set timer request [25; 50] Code to process timer expiration [25; 50] Timer interrupt period () 100 Upper bound on atomic code segments (ffi) 80 TABLE I Durations used for Run-Time Overhead (microseconds) Duration/Delay Range/Value ReadSensor1 [500; 800] Sensor1Expire 4,000 ReadSensor2 [1500; 1700] Sensor2Expire 8,000 PeriodLength <p> caller (after being signaled) [10; 20] Code to begin rendezvous in acceptor (before body) <ref> [25; 50] </ref> Code to complete rendezvous in acceptor (after body) [25; 50] PROTECTED OBJECT Code to queue/pend call in caller [25; 50] Code to complete call in caller [25; 50] DELAY Code to set timer request [25; 50] Code to process timer expiration [25; 50] Timer interrupt period () 100 Upper bound on atomic code segments (ffi) 80 TABLE I Durations used for Run-Time Overhead (microseconds) Duration/Delay Range/Value ReadSensor1 [500; 800] Sensor1Expire 4,000 ReadSensor2 [1500; 1700] Sensor2Expire 8,000 PeriodLength 6,000 ProximityExpire 10,000 Compute [3100; 4800] Signal [500; <p> to begin rendezvous in acceptor (before body) <ref> [25; 50] </ref> Code to complete rendezvous in acceptor (after body) [25; 50] PROTECTED OBJECT Code to queue/pend call in caller [25; 50] Code to complete call in caller [25; 50] DELAY Code to set timer request [25; 50] Code to process timer expiration [25; 50] Timer interrupt period () 100 Upper bound on atomic code segments (ffi) 80 TABLE I Durations used for Run-Time Overhead (microseconds) Duration/Delay Range/Value ReadSensor1 [500; 800] Sensor1Expire 4,000 ReadSensor2 [1500; 1700] Sensor2Expire 8,000 PeriodLength 6,000 ProximityExpire 10,000 Compute [3100; 4800] Signal [500; 600] TABLE II Durations Used in Robot
Reference: [26] <author> F. Jahanian and A. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 12(5) </volume> <pages> 890-904, </pages> <year> 1986. </year>
Reference: [27] <author> S. Lim, Y. Bae, G. T. Jang, B. Rhee, S. Min, C. Y. Park, H. Shin, K. Park, and C. S. Kim. </author> <title> An accurate worst case timing analysis technique for RISC processors. </title> <booktitle> In Ramamritham [32], </booktitle> <pages> pages 97-108. </pages>
Reference-contexts: The second kind constrains the actual time that a task waits for a timer signal. We discuss each in turn. As noted in Section I, timing analysis of sequential code is a difficult problem that we do not address in this paper. We assume that existing techniques (e.g., <ref> [27, 31] </ref>) can be used to obtain upper and lower bounds on the execution time of a sequential code region between two T fl -points.
Reference: [28] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard-real-time environment. </title> <journal> J. ACM, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <year> 1973. </year>
Reference: [29] <author> X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> Compiling real-time specifications into extended automata. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 18(9) </volume> <pages> 794-804, </pages> <year> 1992. </year>
Reference-contexts: Since then, however, advances in concurrent systems analysis (e.g., symbolic model checking, state space reductions) have greatly extended the size of the programs to which that basic modeling/analysis technique can be applied [12]. Indeed, several symbolic/approximate analysis techniques have already been proposed for simpler models of real-time programs <ref> [6, 13, 29] </ref>. VI. Conclusion We have presented a method for constructing mathematical models of general real-time Ada tasking programs suitable for verifying their timing properties, and have demonstrated the feasibility of our method by constructing and analyzing models of two nontrivial programs.
Reference: [30] <author> J. S. Ostroff. </author> <title> Deciding properties of timed transition models. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(2) </volume> <pages> 170-183, </pages> <year> 1990. </year> <title> CORBETT: TIMING ANALYSIS OF ADA TASKING PROGRAMS 23 </title>
Reference: [31] <author> C. Y. Park and A. C. Shaw. </author> <title> Experiments with a program timing tool based on source-level timing schema. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 48-57, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The second kind constrains the actual time that a task waits for a timer signal. We discuss each in turn. As noted in Section I, timing analysis of sequential code is a difficult problem that we do not address in this paper. We assume that existing techniques (e.g., <ref> [27, 31] </ref>) can be used to obtain upper and lower bounds on the execution time of a sequential code region between two T fl -points.
Reference: [32] <author> K. Ramamritham, </author> <title> editor. </title> <booktitle> Proceedings of the Real-Time Systems Symposium. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> Dec. </month> <year> 1994. </year>
Reference: [33] <author> G. M. Reed and A. W. Roscoe. </author> <title> A timed model for communicating sequential processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 58 </volume> <pages> 249-261, </pages> <month> June </month> <year> 1988. </year>
Reference: [34] <author> A. C. Shaw. </author> <title> Reasoning about time in higher-level language software. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 15(7) </volume> <pages> 875-889, </pages> <year> 1989. </year>
Reference-contexts: C.4 Interrupts On any system, the CPU will spend some small part of its time running interrupt handlers. This overhead, though small, must be accounted for in a conservative abstraction. We use the technique described in <ref> [34] </ref>, which uses bounds on the interrupt frequency and handler execution time to inflate the upper bounds of all task code regions.
Reference: [35] <author> R. N. Taylor. </author> <title> A general-purpose algorithm for analyzing concurrent programs. </title> <journal> Commun. ACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Nevertheless, we have shown the technique can still be useful on programs that are far too difficult to analyze by hand. Further, additional abstractions/reductions should extend the range of applicability to larger programs in the future. When reachability analysis was first proposed for concurrent Ada programs <ref> [35] </ref>, it too was infeasible for most programs of realistic size. Since then, however, advances in concurrent systems analysis (e.g., symbolic model checking, state space reductions) have greatly extended the size of the programs to which that basic modeling/analysis technique can be applied [12].
Reference: [36] <author> U. S. </author> <title> Department of Defense, Washington, </title> <editor> D. C. </editor> <title> Reference Manual for the Ada Programming Language, </title> <address> ANSI/MIL-STD-1815A edition, </address> <month> January </month> <year> 1983. </year>
Reference-contexts: Tasks are scheduled by their active priorities using a preemptive priority scheduling policy. The case studies in Section II-C illustrate most of the concurrent and real-time constructs sketched above. A detailed description of the semantics of these constructs can be found in the Ada Language Reference Manual <ref> [36] </ref>. Many recent books on Ada (e.g., [7]) provide an overview of these features with examples of their use. B. Features Modeled Ada is a large language, even after restricting attention to its concurrency and real-time constructs. <p> Our use of the terms open and closed to describe calls and accepts is analogous to the use of the terms to describe entries in the Ada LRM <ref> [36] </ref>. An entry call/accept is open if a communication partner is ready and thus a rendezvous can begin immediately. The first task to arrive at the rendezvous statement will execute the closed code, while the second task will execute the open code, which begins the rendezvous.
Reference: [37] <author> W. Zhao, K. Ramamritham, and J. A. Stankovic. </author> <title> Scheduling tasks with resource requirements in hard real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 12(5), </volume> <year> 1987. </year> <editor> James C. </editor> <title> Corbett received the B.S. degree in computer science from Rensselaer Polytechnic Institute and the M.S. and Ph.D. degrees in computer science from the University of Mas-sachusetts at Amherst. He is currently an Assistant Professor in the Department of Information and Computer Sciences at the University of Hawaii at Manoa. His research is directed toward the construction of automated tools for the analysis and verification of concurrent and real-time software. </title>
References-found: 37

