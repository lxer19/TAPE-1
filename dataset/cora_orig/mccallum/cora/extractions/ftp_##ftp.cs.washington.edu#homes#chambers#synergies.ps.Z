URL: ftp://ftp.cs.washington.edu/homes/chambers/synergies.ps.Z
Refering-URL: http://www.cs.washington.edu/research/projects/cecil/www/Papers/synergies.html
Root-URL: 
Title: Synergies Between Object-Oriented Programming Language Design and Implementation Research  
Author: Craig Chambers 
Address: Box 352350, Seattle, WA 98195-2350 USA  
Affiliation: Department of Computer Science and Engineering University of Washington  
Date: March 1996.  
Note: Invited talk for the ISOTAS 96 Conference, Kanazawa, Japan,  
Abstract: By pursuing language design and language implementation research in parallel, interactions between the two research areas can be exploited to make faster, better progress in both. We report on our experiences working on the Cecil language design project and the Vortex optimizing compiler project, highlighting how each project has encouraged and challenged the other. 
Abstract-found: 1
Intro-found: 1
Reference: [Agesen 95] <author> Ole Agesen. </author> <title> The Cartesian Product Algorithm. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming (ECOOP 95), </booktitle> <address> rhus, Denmark, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: Some early results for languages like Concurrent Aggregates [Plevyak & Chien 94] and Self <ref> [Agesen 95, Agesen & Hlzle 95] </ref> are encouraging, but these analyses were for relatively small programs on the order of a few hundred or a few thousand lines.
Reference: [Agesen & Hlzle 95] <author> Ole Agesen and Urs Hlzle. </author> <title> Type Feedback vs. Concrete Type Analysis: A Comparison of Optimization Techniques for Object-Oriented Languages. </title> <booktitle> In Proceedings of the 1995 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA 95), </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Some early results for languages like Concurrent Aggregates [Plevyak & Chien 94] and Self <ref> [Agesen 95, Agesen & Hlzle 95] </ref> are encouraging, but these analyses were for relatively small programs on the order of a few hundred or a few thousand lines.
Reference: [Apple 92] <author> Dylan, </author> <title> an Object-Oriented Dynamic Language. </title> <institution> Apple Computer, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Because class hierarchy analysis can identify when a method is overridden, it subsumes user-level mechanisms in some languages for indicating when a method is not overridden or when a class will have no subclasses (e.g. non-virtual methods in C++, sealed classes in Dylan <ref> [Apple 92] </ref>, and final classes and methods in Java [Sun 95]).
Reference: [Bobrow et al. 88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> In SIGPLAN Notices 23(Special Issue), </journal> <month> September </month> <year> 1988. </year>
Reference-contexts: how this new level of implementation sophistication can be exploited to design a language as efficient as C++ but with significantly more uniformity and exibility. 2 Language Design Research The Cecil language design began in 1991 as an attempt to combine the advantages of Self [Ungar & Smith 87], CLOS <ref> [Bobrow et al. 88, Steele 90] </ref>, and Trellis [Schaffert et al. 85, Schaffert et al. 86]: a simple, uniform language based on dynamic dispatching, the use of multiple dispatching, and a sound static type system.
Reference: [Chambers & Ungar 90] <author> Craig Chambers and David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <booktitle> In Proceedings of the SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 150-164, </pages> <address> White Plains, NY, </address> <month> June </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(6), </note> <month> June </month> <year> 1990. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: A simple technique is to apply a standard intraprocedural dataow analysis to propagate static class information within a procedure <ref> [Chambers & Ungar 90] </ref>. For example, if a new C expression appears in the procedure, instantiating a new instance of class C, then this expression will be known to produce the set -C-. Similarly, constants like 17 and hi have known singleton class sets.
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <booktitle> In ECOOP 92 Conference Proceedings, </booktitle> <pages> pp. 33-56, </pages> <address> Utrecht, the Netherlands, </address> <month> June/July </month> <year> 1992. </year> <note> Published as Lecture Notes in Computer Science 615, Springer-Verlag, Berlin, </note> <year> 1992. </year>
Reference-contexts: In this paper we will relate some of our own experiences in conducting interacting language design and implementation research. We will begin with our work on the design of the Cecil programming language <ref> [Chambers 92, Chambers 93a, Chambers 93b, Chambers & Leavens 94] </ref>, highlighting the main language design principles and explaining how they led to the resulting design. We will then describe how this design virtually demanded the development of a collection of new implementation techniques.
Reference: [Chambers 93a] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale. </title> <type> Technical report #93-03-05, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: In this paper we will relate some of our own experiences in conducting interacting language design and implementation research. We will begin with our work on the design of the Cecil programming language <ref> [Chambers 92, Chambers 93a, Chambers 93b, Chambers & Leavens 94] </ref>, highlighting the main language design principles and explaining how they led to the resulting design. We will then describe how this design virtually demanded the development of a collection of new implementation techniques.
Reference: [Chambers 93b] <author> Craig Chambers. </author> <title> Predicate Classes. </title> <booktitle> In ECOOP 93 Conference Proceedings, </booktitle> <pages> pp. 268-296, </pages> <address> Kaiserslautern, Germany, </address> <month> July </month> <year> 1993. </year> <note> Published as Lecture Notes in Computer Science 707, Springer-Verlag, Berlin, </note> <year> 1993. </year>
Reference-contexts: In this paper we will relate some of our own experiences in conducting interacting language design and implementation research. We will begin with our work on the design of the Cecil programming language <ref> [Chambers 92, Chambers 93a, Chambers 93b, Chambers & Leavens 94] </ref>, highlighting the main language design principles and explaining how they led to the resulting design. We will then describe how this design virtually demanded the development of a collection of new implementation techniques.
Reference: [Chambers & Leavens 94] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and Modules for Multi-Methods. </title> <booktitle> In OOPSLA 94 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year> <note> Published as SIGPLAN Notices 29(10), October 1994. An expanded version appears in technical report #94-03-01, </note> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: In this paper we will relate some of our own experiences in conducting interacting language design and implementation research. We will begin with our work on the design of the Cecil programming language <ref> [Chambers 92, Chambers 93a, Chambers 93b, Chambers & Leavens 94] </ref>, highlighting the main language design principles and explaining how they led to the resulting design. We will then describe how this design virtually demanded the development of a collection of new implementation techniques.
Reference: [Chambers et al. 95] <author> Craig Chambers, Jeffrey Dean, and David Grove. </author> <title> A Framework for Selective Recompilation in the Presence of Complex Intermodule Dependencies. </title> <booktitle> In Proceedings of the 17th International Conference on Software Engineering (ICSE 95), </booktitle> <pages> pp. 221-230, </pages> <address> Seattle, WA, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: When a change is made to the source program, the dependency links are consulted to determine with some precision the set of compiled files that need to be regenerated, leading to a compilation model based on selective recompilation rather than separate compilation <ref> [Chambers et al. 95] </ref>. For separately-developed libraries, the client application still can be optimized with class hierarchy analysis as long as the class hierarchy structure of the library is made available to the client application (for example by including it in the librarys header files).
Reference: [Dean et al. 95] <author> Jeffrey Dean, David Grove, and Craig Chambers. </author> <title> Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming (ECOOP 95), </booktitle> <address> rhus, Denmark, </address> <month> August </month> <year> 1995. </year> <month> 11 </month>
Reference-contexts: Class hierarchy analysis, an alternative to full interprocedural analysis, examines the structure of the complete programs class hierarchy but does not examine the implementations of the methods in the program <ref> [Dean et al. 95] </ref>. By examining only declarations, class hierarchy analysis is very cheap, but it can provide crucial information for optimization. With class hierarchy analysis, the compiler can tell exactly the set of subclasses of a class.
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: As another example, all control structures are implemented in Cecil in terms of messages and first-class closure objects (as is done in Self and, to a large extent, Smalltalk <ref> [Goldberg & Robson 83] </ref>). In this approach, it becomes natural for abstractions to define their own specialized control structures and iterators, since there is no difference between built-in control structures and user-defined control structures. 3 Like Trellis, Cecil includes a static type system.
Reference: [Grove 95] <author> David Grove. </author> <title> The Impact of Interprocedural Class Analysis on Optimization. </title> <booktitle> In Proceedings of CASCON 95, </booktitle> <pages> pp. 195-203, </pages> <address> Toronto, Canada, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Our initial experiments with interprocedural analysis in the Vortex compiler suggest that programs of that size can be analyzed fairly quickly and effectively, but that (for simple algorithms at least) programs on the order of 20,000 lines or 50,000 lines consume exorbitant amounts of analysis time <ref> [Grove 95] </ref>. Class hierarchy analysis, an alternative to full interprocedural analysis, examines the structure of the complete programs class hierarchy but does not examine the implementations of the methods in the program [Dean et al. 95].
Reference: [Grove et al. 95] <author> David Grove, Jeffrey Dean, Charles Garrett, and Craig Chambers. </author> <title> Profile-Guided Receiver Class Prediction. </title> <booktitle> In Proceedings of the 1995 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA 95), </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: When static class analysis cannot determine a tight bound on the set of possible classes of the receiver of some message, dynamic profile information can be used to predict which receiver classes are most likely in practice <ref> [Hlzle & Ungar 94, Grove et al. 95] </ref>. This prediction is exploited by inserting run-time class tests for the predicted class (es), with a successful prediction branching to optimized code for that case.
Reference: [Hlzle & Ungar 94] <author> Urs Hlzle and David Ungar. </author> <title> Optimizing Dynamically-Dispatched Calls with Run-Time Type Feedback. </title> <booktitle> In Proceedings of the SIGPLAN 94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 326-336, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year> <note> Published as SIGPLAN Notices 29(6), </note> <month> June </month> <year> 1994. </year>
Reference-contexts: When static class analysis cannot determine a tight bound on the set of possible classes of the receiver of some message, dynamic profile information can be used to predict which receiver classes are most likely in practice <ref> [Hlzle & Ungar 94, Grove et al. 95] </ref>. This prediction is exploited by inserting run-time class tests for the predicted class (es), with a successful prediction branching to optimized code for that case.
Reference: [Kristensen et al. 87] <author> B. B. Kristensen, Ole Lehrmann Madsen, Birger Mller-Pedersen, and Kristen Nygaard. </author> <title> The BETA Programming Language. </title> <booktitle> In Research Directions in Object-Oriented Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: Instance variables can be reimplemented as methods, procedures can be overridden with multi-methods, and so on. There are no variables or expressions where this subtype polymorphism is restricted, unlike C++ [Stroustrup 91], Modula-3 [Nelson 91], Eiffel [Meyer 92], Sather [Omohundro 93], and Beta <ref> [Kristensen et al. 87] </ref>. This design is uniform and more exible than most languages. However, it would run slowly using standard implementation techniques.
Reference: [Meyer 92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Instance variables can be reimplemented as methods, procedures can be overridden with multi-methods, and so on. There are no variables or expressions where this subtype polymorphism is restricted, unlike C++ [Stroustrup 91], Modula-3 [Nelson 91], Eiffel <ref> [Meyer 92] </ref>, Sather [Omohundro 93], and Beta [Kristensen et al. 87]. This design is uniform and more exible than most languages. However, it would run slowly using standard implementation techniques.
Reference: [Nelson 91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: Instance variables can be reimplemented as methods, procedures can be overridden with multi-methods, and so on. There are no variables or expressions where this subtype polymorphism is restricted, unlike C++ [Stroustrup 91], Modula-3 <ref> [Nelson 91] </ref>, Eiffel [Meyer 92], Sather [Omohundro 93], and Beta [Kristensen et al. 87]. This design is uniform and more exible than most languages. However, it would run slowly using standard implementation techniques.
Reference: [Omohundro 93] <author> Stephen Omohundro. </author> <title> The Sather 1.0 Specification. Unpublished manual, </title> <month> June </month> <year> 1993. </year>
Reference-contexts: Instance variables can be reimplemented as methods, procedures can be overridden with multi-methods, and so on. There are no variables or expressions where this subtype polymorphism is restricted, unlike C++ [Stroustrup 91], Modula-3 [Nelson 91], Eiffel [Meyer 92], Sather <ref> [Omohundro 93] </ref>, and Beta [Kristensen et al. 87]. This design is uniform and more exible than most languages. However, it would run slowly using standard implementation techniques.
Reference: [Plevyak & Chien 94] <author> John Plevyak and Andrew A. Chien. </author> <title> Precise Concrete Type Inference for Object-Oriented Languages. </title> <booktitle> In OOPSLA 94 Conference Proceedings, </booktitle> <pages> pp. 324-340, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year> <note> Published as SIGPLAN Notices 29(10), </note> <month> October </month> <year> 1994. </year>
Reference-contexts: Some early results for languages like Concurrent Aggregates <ref> [Plevyak & Chien 94] </ref> and Self [Agesen 95, Agesen & Hlzle 95] are encouraging, but these analyses were for relatively small programs on the order of a few hundred or a few thousand lines.
Reference: [Schaffert et al. 85] <author> Craig Schaffert, Topher Cooper, and Carrie Wilpolt. </author> <title> Trellis Object-Based Environment, Language Reference Manual. </title> <type> Technical report DEC-TR-372, </type> <month> November </month> <year> 1985. </year>
Reference-contexts: be exploited to design a language as efficient as C++ but with significantly more uniformity and exibility. 2 Language Design Research The Cecil language design began in 1991 as an attempt to combine the advantages of Self [Ungar & Smith 87], CLOS [Bobrow et al. 88, Steele 90], and Trellis <ref> [Schaffert et al. 85, Schaffert et al. 86] </ref>: a simple, uniform language based on dynamic dispatching, the use of multiple dispatching, and a sound static type system.
Reference: [Schaffert et al. 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 9-16, </pages> <address> Portland, OR, </address> <month> September </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November </month> <year> 1986. </year>
Reference-contexts: be exploited to design a language as efficient as C++ but with significantly more uniformity and exibility. 2 Language Design Research The Cecil language design began in 1991 as an attempt to combine the advantages of Self [Ungar & Smith 87], CLOS [Bobrow et al. 88, Steele 90], and Trellis <ref> [Schaffert et al. 85, Schaffert et al. 86] </ref>: a simple, uniform language based on dynamic dispatching, the use of multiple dispatching, and a sound static type system.
Reference: [Steele 90] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language (Second Edition). </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1990. </year>
Reference-contexts: how this new level of implementation sophistication can be exploited to design a language as efficient as C++ but with significantly more uniformity and exibility. 2 Language Design Research The Cecil language design began in 1991 as an attempt to combine the advantages of Self [Ungar & Smith 87], CLOS <ref> [Bobrow et al. 88, Steele 90] </ref>, and Trellis [Schaffert et al. 85, Schaffert et al. 86]: a simple, uniform language based on dynamic dispatching, the use of multiple dispatching, and a sound static type system.
Reference: [Stroustrup 91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language (Second Edition). </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1991. </year>
Reference-contexts: Instance variables can be reimplemented as methods, procedures can be overridden with multi-methods, and so on. There are no variables or expressions where this subtype polymorphism is restricted, unlike C++ <ref> [Stroustrup 91] </ref>, Modula-3 [Nelson 91], Eiffel [Meyer 92], Sather [Omohundro 93], and Beta [Kristensen et al. 87]. This design is uniform and more exible than most languages. However, it would run slowly using standard implementation techniques.
Reference: [Sun 95] <author> Sun Microsystems. </author> <title> The Java Language Specification. Unpublished manual, </title> <month> May </month> <year> 1995. </year>
Reference-contexts: hierarchy analysis can identify when a method is overridden, it subsumes user-level mechanisms in some languages for indicating when a method is not overridden or when a class will have no subclasses (e.g. non-virtual methods in C++, sealed classes in Dylan [Apple 92], and final classes and methods in Java <ref> [Sun 95] </ref>).
Reference: [Ungar & Smith 87] <author> David Ungar and Randall B. Smith. </author> <title> Self: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-241, </pages> <address> Orlando, FL, </address> <month> October </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: we will conclude by considering how this new level of implementation sophistication can be exploited to design a language as efficient as C++ but with significantly more uniformity and exibility. 2 Language Design Research The Cecil language design began in 1991 as an attempt to combine the advantages of Self <ref> [Ungar & Smith 87] </ref>, CLOS [Bobrow et al. 88, Steele 90], and Trellis [Schaffert et al. 85, Schaffert et al. 86]: a simple, uniform language based on dynamic dispatching, the use of multiple dispatching, and a sound static type system.
References-found: 26

