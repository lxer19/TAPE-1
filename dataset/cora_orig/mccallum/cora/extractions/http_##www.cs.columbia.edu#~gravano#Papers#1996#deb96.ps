URL: http://www.cs.columbia.edu/~gravano/Papers/1996/deb96.ps
Refering-URL: http://www.cs.columbia.edu/~gravano/publications.html
Root-URL: http://www.cs.columbia.edu
Email: surajitc@microsoft.com  gravano@cs.stanford.edu  
Title: Optimizing Queries over Multimedia Repositories  
Author: Surajit Chaudhuri Luis Gravano 
Affiliation: Microsoft Research  Stanford University  
Abstract: Multimedia repositories and applications that retrieve multimedia information are becoming increasingly popular. In this paper, we study the problem of selecting objects from multimedia repositories, and show how this problem relates to the processing and optimization of selection queries in other contexts, e.g., when some of the selection conditions are expensive user-defined predicates. We find that the problem has unique characteristics that lead to interesting new research questions and results. This article presents an overview of the results in [1]. An expanded version of that paper is in preparation [2].
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Surajit Chaudhuri and Luis Gravano. </author> <title> Optimizing queries over multimedia repositories. </title> <booktitle> In Proceedings of the 1996 ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 91-102, </pages> <address> Montreal, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: In other words, we would like to know whether we can "embed" the filter condition F in a new ranking expression R F such that the top objects according to R F are the top objects for R that satisfy F . In <ref> [1] </ref>, we show that the above is not possible. In other words, our query model would be less expressive without filter conditions. 1.2 Related Query Models Relational query models do not support ranking and grades of match in the sense of Section 1.1. <p> execution space: (a) Given a filter condition f and a search condition a, what is the residual predicate R (a; f ) that an object retrieved via search on a must satisfy to be in the answer set? (b) How do we determine the optimal search-minimal condition set? Our paper <ref> [1, 2] </ref> provides polynomial time algorithms to answer both questions under broad assumptions of cost models. We illustrate the step of determining residual predicates in the example below. The algorithm to determine an optimal search-minimal condition set for an independent filter condition is in [1]. <p> We illustrate the step of determining residual predicates in the example below. The algorithm to determine an optimal search-minimal condition set for an independent filter condition is in <ref> [1] </ref>. Intuitively, the algorithm traverses the AND-OR condition tree in a bottom-up fashion. <p> The example above shows how we can process a ranking expression e as a filter condition f followed by a sorting step. But the key point in mapping the ranking problem to a (modified) filtering problem is finding the grade G to use in f . In <ref> [1] </ref>, we present the algorithm Grade Rank, which given the number of objects desired k, a ranking expression e, and selectivity statistics, produces the grade G for the filter condition f . <p> We will investigate strategies to lower G as part of our future work. It is natural to ask how our algorithm compares with Fagin's in terms of retrieval efficiency. In <ref> [1] </ref>, we show that if we process a ranking expression (and its associated number k of objects requested) by using a filter condition F with grade G as determined by algorithm Grade Rank, we can expect to retrieve no more objects than Fagin's algorithm, under some assumptions on the repositories.
Reference: [2] <author> Surajit Chaudhuri and Luis Gravano. </author> <title> Optimizing queries over multimedia repositories. </title> <type> Technical report, </type> <year> 1996. </year> <note> In preparation. </note>
Reference-contexts: execution space: (a) Given a filter condition f and a search condition a, what is the residual predicate R (a; f ) that an object retrieved via search on a must satisfy to be in the answer set? (b) How do we determine the optimal search-minimal condition set? Our paper <ref> [1, 2] </ref> provides polynomial time algorithms to answer both questions under broad assumptions of cost models. We illustrate the step of determining residual predicates in the example below. The algorithm to determine an optimal search-minimal condition set for an independent filter condition is in [1]. <p> However, our model would require that we extend the existing results, since Probe costs are not zero anylonger. Furthermore, not only would we need to choose the superset of a search-minimal set to search, but we should also address the more complex ordering of search-result merges and probes <ref> [2] </ref>. 3.2 Processing Ranking Expressions We now look at queries consisting only of ranking expressions.
Reference: [3] <author> Ronald Fagin. </author> <title> Combining fuzzy information from multiple systems. </title> <booktitle> In 15 th ACM Symposium on Principles of Database Systems, </booktitle> <month> June </month> <year> 1996. </year> <note> Also available as IBM Almaden Research Center Technical Report RJ 9980. </note>
Reference-contexts: Second, rarely does a user expect a multimedia object to match a given attribute value exactly. Rather, users are interested in the grade of match with which objects match the given attribute values <ref> [3] </ref>. Thus, given an object o, an attribute attr, and a constant value, the associated grade of match Grade (attr, value)(o) is a real number between 0 and 1, and expresses how well o:attr matches value. <p> However, the process of querying and browsing over a multimedia repository is likely to be interactive, and users will tend to ask for only "a few best matches" according to a ranking criterion. Therefore, a query in our model contains a ranking expression <ref> [3, 5] </ref> in addition to the filter condition that we described above. The ranking expression of a query assigns an order to each object in the repository that satisfies the filter condition in the query. <p> Fagin presented a novel approach to take advantage of k in processing a query consisting of a ranking expression such as R = Min (a 1 ; : : :; a n ), where the a i 's are independent atomic expressions <ref> [3] </ref>. Fagin has proved the important result that his algorithm to retrieve k top objects for an expression R that is a Min of independent atomic expressions is asymptotically optimal with arbitrarily high probability in terms of the number of objects retrieved.
Reference: [4] <author> Jim Gray et al. </author> <title> Data cube: A relation aggregation operator generalizing group by, cross-tab, and sub-totals. Data Mining and Knowledge Discovery, </title> <type> 1(1), </type> <year> 1996. </year>
Reference-contexts: Traditional selection queries ask for all tuples that match the selection condition, perhaps ordered using the values of a column, or a user-defined function <ref> [4] </ref>. However, the process of querying and browsing over a multimedia repository is likely to be interactive, and users will tend to ask for only "a few best matches" according to a ranking criterion.
Reference: [5] <author> F. Rabitti. </author> <title> Retrieval of multimedia documents by imprecise query specification. </title> <booktitle> In Proceedings of the 1990 EDBT, </booktitle> <address> Venice, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: However, the process of querying and browsing over a multimedia repository is likely to be interactive, and users will tend to ask for only "a few best matches" according to a ranking criterion. Therefore, a query in our model contains a ranking expression <ref> [3, 5] </ref> in addition to the filter condition that we described above. The ranking expression of a query assigns an order to each object in the repository that satisfies the filter condition in the query.
Reference: [6] <author> Virginia E. Ogle and Michael Stonebraker. Chabot: </author> <title> Retrieval from a relational database of images. </title> <journal> IEEE Computer, </journal> <volume> 28(9), </volume> <month> September </month> <year> 1995. </year>
Reference-contexts: On the other hand, extensible architectures of the universal servers can be exploited to support our proposed query model to some extent. An example of how to exploit an extensible architecture is Chabot <ref> [6] </ref>, an image server based on Postgres. Chabot indirectly manages non-exact matches of, say, color histograms through a user-defined predicate MeetsCriteria. Given a color histogram h and some "criterion" Mostly Red, the predicate MeetsCriteria ("Mostly Red", h) holds if histogram h is "sufficiently red," according to some hard-coded specification.
Reference: [7] <author> Gerard Salton. </author> <title> Automatic text processing: the transformation, analysis, and retrieval of information by computer. </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: However, an interesting open question is to study how and to what extent we can exploit the capabilities of an extensible architecture like that of Postgres to implement our proposed query model. The models developed by the information retrieval community to query text repositories support ranking extensively <ref> [7] </ref>. In particular, the vector-space retrieval model typically uses lists of words as queries. Given a list of words, each document is assigned a grade of match for the query, which expresses how similar the document and the query are.
Reference: [8] <author> J. M. Hellerstein and M. Stonebraker. </author> <title> Predicate migration: Optimizing queries with expensive predicates. </title> <booktitle> In Proceedings of the 1993 ACM SIGMOD Conference on Management of Data, </booktitle> <address> Wash-ington D. C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The optimal order is the same as the ascending order of the rank c 1s of each condition, where c is the cost of evaluating the atomic condition for one object, and s is the selectivity of the condition <ref> [8] </ref>. These plans require executing a Probe for each condition and for each object that has a chance to be in the final result. Therefore, for a large repository, this step can be prohibitively expensive.
Reference: [9] <author> L. T. Reinwald and R. M. Soland. </author> <title> Conversion of limited entry decision tables to optimal computer programs I: Minimum average processing time. </title> <journal> Journal of the ACM, </journal> <volume> 13(3), </volume> <year> 1966. </year>
Reference-contexts: Unfortunately, unlike the case of conjunctive queries, the problem of ordering the evaluation of atomic conditions for an arbitrary propositional condition is intractable <ref> [9] </ref>, hence the need to rely on one of the well known heuristics [10] (cf. [11]).
Reference: [10] <author> A. Kemper, G. Moerkotte, and M. Steinbrunn. </author> <title> Optimizing boolean expressions in object bases. </title> <booktitle> In Proceedings of the 18th VLDB Conference, </booktitle> <address> Vancouver, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: The answer contains the top 10 such acceptable records. (For simplicity, we omitted the parameter oid in the atomic conditions below.) SELECT oid FROM Repository WHERE (Grade (v, V) &gt;= .5 AND Grade (p, `on parole') &gt;= .9) OR Grade (f, F) &gt;= .9 ORDER <ref> [10] </ref> BY Max (Grade (f, F), Grade (v, V)) 2 An interesting expressivity question is whether we actually need both the filter condition F and the ranking condition R. <p> Unfortunately, unlike the case of conjunctive queries, the problem of ordering the evaluation of atomic conditions for an arbitrary propositional condition is intractable [9], hence the need to rely on one of the well known heuristics <ref> [10] </ref> (cf. [11]). How can we exploit the search interface of repositories for processing arbitrary filter conditions? Unlike the case of conjunctive queries, it is not sufficient to use GradeSearch on only one atomic condition to avoid "scanning" all the objects.
Reference: [11] <author> A. Kemper, G. Moerkotte, K. Peithner, and M. Steinbrunn. </author> <title> Optimizing disjunctive queries with expensive predicates. </title> <booktitle> In Proceedings of the 1994 ACM SIGMOD Conference on Management of Data, </booktitle> <address> Minneapolis, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Unfortunately, unlike the case of conjunctive queries, the problem of ordering the evaluation of atomic conditions for an arbitrary propositional condition is intractable [9], hence the need to rely on one of the well known heuristics [10] (cf. <ref> [11] </ref>). How can we exploit the search interface of repositories for processing arbitrary filter conditions? Unlike the case of conjunctive queries, it is not sufficient to use GradeSearch on only one atomic condition to avoid "scanning" all the objects. Thus, the problem of identifying the search-minimal condition sets arises.
Reference: [12] <author> C. Mohan. </author> <title> Single table access using multiple indexes: Optimization, execution and concurrency control techniques. </title> <booktitle> In Proceedings of the 1990 EDBT, </booktitle> <address> Venice, </address> <month> March </month> <year> 1990. </year> <note> Also available as IBM Almaden Research Center Technical Report RJ 7341. </note>
Reference-contexts: Further complexity arises if we step beyond the search-minimal execution space. This corresponds to doing index intersections to evaluate a query (e.g., for processing a conjunctive filter condition). In this case, our problem would become closely related to that of query processing with index AND-ing and OR-ing <ref> [12] </ref>. However, our model would require that we extend the existing results, since Probe costs are not zero anylonger.
Reference: [13] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Optimization of queries with user-defined predicates. </title> <booktitle> In Proceedings of the 22nd VLDB Conference, </booktitle> <address> Bombay, India, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: Although past work on expensive predicates addresses the case where only condition (b) holds <ref> [13, 14] </ref>, it does not address the case where condition (a) holds as well. Finally, note that the algorithms and results of the previous section are completely independent of the nature of the atomic predicates as long as a selectivity and a cost measure are available.
Reference: [14] <author> J. Hellerstein. </author> <title> Optimization techniques for queries with expensive methods. </title> <type> Technical Report CS-TR-96-1304, </type> <institution> University of Wisconsin, Madison, </institution> <month> February </month> <year> 1996. </year> <type> Ph.D. dissertation. 8 </type>
Reference-contexts: Although past work on expensive predicates addresses the case where only condition (b) holds <ref> [13, 14] </ref>, it does not address the case where condition (a) holds as well. Finally, note that the algorithms and results of the previous section are completely independent of the nature of the atomic predicates as long as a selectivity and a cost measure are available.
References-found: 14

