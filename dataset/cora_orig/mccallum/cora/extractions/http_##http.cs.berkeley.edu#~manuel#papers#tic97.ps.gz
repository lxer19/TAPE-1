URL: http://http.cs.berkeley.edu/~manuel/papers/tic97.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~manuel/publications.html
Root-URL: http://www.cs.berkeley.edu
Title: Refined Type Inference for ML (Abstract)  
Author: Manuel F ahndrich and Alexander Aiken 
Affiliation: University of California, Berkeley  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Aiken and E. Wimmers. </author> <title> Type Inclusion Constraints and Type Inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Inclusion constraints over set-expressions <ref> [1, 4] </ref> provide a general formalism to express a large class of program analyses. Over the past two years, we have experimented with inclusion constraints to model dataflow in type-based analyses. <p> The prototype can analyze core SML, which requires the following extensions: * Let-polymorphism is handled as described in <ref> [1] </ref>. * Datatypes hide the internal structure of values. We must ensure that exceptions do not disappear into datatypes. To this end, we extend datatypes containing exception values (directly or through functions) with a single extra s-type parameter to capture these exceptions. * ML has mutable references.
Reference: [2] <author> L. O. Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year> <type> DIKU report 94/19. </type>
Reference-contexts: Program analyses with O (n 3 ) complexity bounds often exhibit their worst-case complexity in practice and consequently do not scale beyond programs of a few thousand lines. As a result, coarser but faster analyses are usually used <ref> [2, 10] </ref>. Scaling behavior and precision are intimately connected and in an ideal formalism, one can be traded for the other. Unfortunately, inclusion constraints over set-expressions do not provide enough control over this precision-efficiency tradeoff. As an example, consider Hindley-Milner type inference.
Reference: [3] <author> Juan Carlos Guzman and Ascander Suarez. </author> <title> An extended type system for exceptions. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on ML and its Applications, </booktitle> <pages> pages 127-135, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: As a result, effect sets that are joined by dataflow paths have to be equal, an approximation that does not arise in our formulation. Two earlier approaches to uncaught exception detection for ML are found in <ref> [3] </ref> and [12]. Guzman and Suarez describe an extended type system for ML similar to, but less powerful than, the one presented here. Their approach is based on equality constraints, does not treat exceptions as first class values, and ignores value-carrying exceptions. <p> Their approach is based on equality constraints, does not treat exceptions as first class values, and ignores value-carrying exceptions. Yi describes a collecting interpretation for estimating uncaught exceptions in ML. His analysis handles the entire ML language and is much finer grained than <ref> [3] </ref> or the system described here, but is also slow in practice.
Reference: [4] <author> N. Heintze. </author> <title> Set Based Program Analysis. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: 1 Introduction Inclusion constraints over set-expressions <ref> [1, 4] </ref> provide a general formalism to express a large class of program analyses. Over the past two years, we have experimented with inclusion constraints to model dataflow in type-based analyses.
Reference: [5] <author> Pierre Jouvelot and David K. Gifford. </author> <title> Algebraic reconstruction of types and effects. </title> <booktitle> In Proceedings of the 18th Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 303-310, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: To our knowledge, all published algorithms for effect systems are based on equality constraints and solved using specialized unification to deal with sets <ref> [5, 11] </ref>. As a result, effect sets that are joined by dataflow paths have to be equal, an approximation that does not arise in our formulation. Two earlier approaches to uncaught exception detection for ML are found in [3] and [12].
Reference: [6] <author> John M. Lucassen. </author> <title> Types and Effects Towards the Integration of Functional and Imperative Programming. </title> <type> Ph.D. thesis, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: Our formulation of exception inference improves upon earlier work by providing precise information at a cost close to Hindley-Milner type inference. 2 Uncaught Exception Inference We formulate our uncaught exception inference as an effect system <ref> [6] </ref> for Mini-ML, a typed lambda calculus with exception constructors and raise and handle expressions. e ::= x j fn x =&gt; e j e 1 e 2 j raise e j e handle p i =&gt; e i p ::= c j c (x) Handle expressions use pattern matching to <p> Our running time however improves upon Yi's approach by three orders of magnitude. 4 Related Work Effect systems <ref> [6] </ref> naturally contain a mixture of Hindley-Milner types and sets for effects. To our knowledge, all published algorithms for effect systems are based on equality constraints and solved using specialized unification to deal with sets [5, 11].
Reference: [7] <author> David McAllester. </author> <title> Inferring Recursive Data Types. </title> <address> http://www.ai.mit.edu/people/dam/rectypes.ps. </address>
Reference-contexts: The equality constraints arising in the formulation of algorithm W [8] can be solved as symmetric inclusion constraints using a standard inclusion constraint solver. This approach results however in an algorithm with cubic time complexity, instead of the nearly linear time algorithm based on unification <ref> [7] </ref>. A key to the efficiency of Hindley-Milner type inference is that types are terms. Terms have unique head constructors, whereas set expressions generally do not. This propertywhether a quantity has a unique head constructoris a prime determinant of the cost of solving type constraints.
Reference: [8] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Unfortunately, inclusion constraints over set-expressions do not provide enough control over this precision-efficiency tradeoff. As an example, consider Hindley-Milner type inference. The equality constraints arising in the formulation of algorithm W <ref> [8] </ref> can be solved as symmetric inclusion constraints using a standard inclusion constraint solver. This approach results however in an algorithm with cubic time complexity, instead of the nearly linear time algorithm based on unification [7]. A key to the efficiency of Hindley-Milner type inference is that types are terms.
Reference: [9] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Not only does the new formalism provide fine control over the precision-efficiency tradeoff, it also enables novel analyses. The rest of this abstract briefly describes one such analysis: Uncaught exception inference for ML <ref> [9] </ref>.
Reference: [10] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Proceedings of the 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Program analyses with O (n 3 ) complexity bounds often exhibit their worst-case complexity in practice and consequently do not scale beyond programs of a few thousand lines. As a result, coarser but faster analyses are usually used <ref> [2, 10] </ref>. Scaling behavior and precision are intimately connected and in an ideal formalism, one can be traded for the other. Unfortunately, inclusion constraints over set-expressions do not provide enough control over this precision-efficiency tradeoff. As an example, consider Hindley-Milner type inference.
Reference: [11] <author> M. Tofte and J.-P. Talpin. </author> <title> Implementation of the typed call-by-value -calculus using a stack of regions. </title> <booktitle> In Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 188-201, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: To our knowledge, all published algorithms for effect systems are based on equality constraints and solved using specialized unification to deal with sets <ref> [5, 11] </ref>. As a result, effect sets that are joined by dataflow paths have to be equal, an approximation that does not arise in our formulation. Two earlier approaches to uncaught exception detection for ML are found in [3] and [12].
Reference: [12] <author> Kwangkeun Yi. </author> <title> Compile-time detection of uncaught exceptions for Standard ML programs. </title> <booktitle> In Proceedings of the 1st International Static Analysis Symposium, volume 864 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: The analysis infers the following type for the main function lexGen: lexGen : string -(Match "/ eof "/ error "/ lex_error "/ Subscript)-&gt; unit The five uncaught exceptions correspond exactly to the results reported by Yi <ref> [12] </ref>. Our running time however improves upon Yi's approach by three orders of magnitude. 4 Related Work Effect systems [6] naturally contain a mixture of Hindley-Milner types and sets for effects. <p> As a result, effect sets that are joined by dataflow paths have to be equal, an approximation that does not arise in our formulation. Two earlier approaches to uncaught exception detection for ML are found in [3] and <ref> [12] </ref>. Guzman and Suarez describe an extended type system for ML similar to, but less powerful than, the one presented here. Their approach is based on equality constraints, does not treat exceptions as first class values, and ignores value-carrying exceptions.
References-found: 12

