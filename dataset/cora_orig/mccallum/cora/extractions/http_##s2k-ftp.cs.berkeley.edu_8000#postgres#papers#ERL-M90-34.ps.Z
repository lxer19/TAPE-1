URL: http://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/ERL-M90-34.ps.Z
Refering-URL: http://www.cs.umd.edu/projects/hpsl/classes/818s-s98/cmcs818s-s98.htm
Root-URL: 
Title: THE IMPLEMENTATION OF POSTGRES  
Author: Michael Stonebraker, Lawrence A. Rowe and Michael Hirohama 
Address: Berkeley  
Affiliation: EECS Department University of California,  
Abstract: Currently, POSTGRES is about 90,000 lines of code in C and is being used by assorted ``bold and brave'' early users. The system has been constructed by a team of 5 part time students led by a full time chief programmer over the last three years. During this period, we have made a large number of design and implementation choices. Moreover, in some areas we would do things quite differently if we were to start from scratch again. The purpose of this paper is to reflect on the design and implementation decisions we made and to offer advice to implementors who might follow some of our paths. In this paper we restrict our attention to the DBMS ``backend'' functions. In another paper some of us treat PICASSO, the application development environment that is being built on top of POSTGRES. 
Abstract-found: 1
Intro-found: 1
Reference: [AGRA89] <author> Agrawal, R. and Gehani, N., </author> <title> "ODE: The Language and the Data Model," </title> <booktitle> Proc. 1989 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Portland, Or., </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Such an approach would offer persistence for variables in this programming language, as well as a query language integrated with the control statements of the language. This approach has been followed in ODE <ref> [AGRA89] </ref> and many of the recent commercial start-ups doing object-oriented data bases. Our point of view is that most data bases are accessed by programs written in several different languages, and we do not see any programming language Esperanto on the horizon.
Reference: [ATKI89] <author> Atkinson, M. et. al., </author> <title> ``The Object-oriented Database System Manifesto,'' </title> <type> Altair Technical Report 30-89, </type> <institution> Rocquencourt, France, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: POSTGRES could be accurately described as an object-oriented system because it includes unique identity for objects, abstract data types, classes (constructed types), methods (functions), and inheritance for both data and functions. Others (e.g. <ref> [ATKI89] </ref>) are suggesting definitions for the word "object-oriented", and POSTGRES satisfies virtually all of the proposed litmus tests. On the other hand, POSTGRES could also be considered an extended relational system.
Reference: [ANON85] <editor> Anon et. al., </editor> <title> ``A Measure of Transaction Processing Power,'' Tandem Computers, Cupertino, CA, </title> <type> Technical Report 85.1, </type> <year> 1985. </year>
Reference-contexts: Since POSTQUEL functions can reference other POSTQUEL functions, arbitrary structures of complex objects can be assembled. Lastly, POST-QUEL functions allow collections of commands such as the 5 SQL commands that make up TP1 <ref> [ANON85] </ref> to be assembled into a single function and stored inside the DBMS. Then, one can execute TP1 by executing the single function. This approach is preferred to having to submit the 5 SQL commands in TP1 one by one from an application program.
Reference: [AOKI89] <author> Aoki, P., </author> <title> ``Implementation of Extended Indexes in POSTGRES,'' </title> <institution> Electronics Research Laboratory, University of California, </institution> <type> Technical Report 89-62, </type> <month> July </month> <year> 1989. </year>
Reference-contexts: The utility of indexes on functions of values is discussed in [LYNC88], and the capability was retrofitted, rather inelegantly, into one version of POSTGRES <ref> [AOKI89] </ref>. Another comment on the access method design concerns extendibility.
Reference: [BANC86] <author> Bancilhon, F. and Ramakrishnan, R., </author> <title> ``An Amateur's Introduction to Recursive Query Processing,'' </title> <booktitle> Proc. 1986 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Washington, D.C., </address> <month> May </month> <year> 1986. </year>
Reference-contexts: Here, a rule would be applied by converting a user query to an alternate form prior to execution. This transformation is performed between the query language parser and the optimizer. Support for views [STON75] is done this way along with many of the proposals for recursive query support <ref> [BANC86, ULLM85] </ref>. Such an implementation will be very efficient when there are a small number of rules on any given constructed type and most rules cover the whole constructed type.
Reference: [BANE87] <author> Banerjee, J. et. al., </author> <title> ``Semantics and Implementation of Schema Evolution in Object-oriented Databases,'' </title> <booktitle> Proc. 1987 ACM SIGMOD Conference on Management of Data, </booktitle> <address> San Francisco, Ca., </address> <month> May </month> <year> 1987. </year>
Reference-contexts: It is also possible to interact with a POSTGRES data base by utilizing a navigational interface. Such interfaces were popularized by the CODASYL proposals of the 1970's and are enjoying a renaissance in recent object-oriented proposals such as ORION <ref> [BANE87] </ref> or O2 [VELE89]. Because POSTGRES gives each record a unique identifier (OID), it is possible to use the identifier for one record as a data item in a second record.
Reference: [BITT83] <author> Bitton, D. et. al., </author> <title> ``Benchmarking Database Systems: A Systematic Approach,'' </title> <booktitle> Proc. 1983 VLDB Conference, </booktitle> <address> Cannes, France, </address> <month> Sept. </month> <year> 1983. </year>
Reference-contexts: In this section we discuss how we interfaced to the operating system, our choice of programming languages and some of our implementation philosophy. The final section concludes with some performance measurements of POSTGRES. Specifically, we report the results of some of the queries in the Wisconsin benchmark <ref> [BITT83] </ref>. 2. THE POSTGRES DATA MODEL AND QUERY LANGUAGE 2.1. Introduction Traditional relational DBMSs support a data model consisting of a collection of named relations, each attribute of which has a specific type. In current commercial systems possible types are floating point 2 numbers, integers, character strings, and dates.
Reference: [BORG85] <author> Borgida, A., </author> <title> Language Features for Flexible Handling of Exceptions in Informa tion Systems, </title> <address> ACM-TODS, </address> <month> Dec. </month> <year> 1985. </year>
Reference-contexts: Moreover, a query rewrite system has great difficulty with exceptions <ref> [BORG85] </ref>. For example consider the rule ``all employees have a steel desk'' together with the exception ``Jones is an employee who has a wood desk''.
Reference: [CARE88] <author> Carey, M. et. al., </author> <title> ``A Data Model and Query Language for EXODUS,'' </title> <booktitle> Proc. 1988 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Chicago, Ill., </address> <month> June </month> <year> 1988. </year>
Reference-contexts: First, we are uneasy about the complexity of the POSTGRES data model. The comments in Section 2 all contain 32 suggestions to make it more complex. Moreover, other research teams have tended to construct even more complex data models, e.g. EXTRA <ref> [CARE88] </ref>. Consequently, a simple concept such as referential integrity, which can be done in only one way in existing commercial systems, can be done in several different ways in POSTGRES.
Reference: [COPE84] <author> Copeland, G. and D. Maier, </author> <title> ``Making Smalltalk a Database System,'' </title> <booktitle> Proc. 1984 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Boston, Mass. </address> <month> June </month> <year> 1984. </year> <month> 34 </month>
Reference-contexts: A persuasive example (similar to one from <ref> [COPE84] </ref>) is that employees can be on loan to another plant or on loan to a customer.
Reference: [DADA86] <author> Dadam, P. et. al., </author> <title> ``A DBMS Prototype to Support NF2 Relations,'' </title> <booktitle> Proc. 1986 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Washington, D.C., </address> <month> May </month> <year> 1986. </year>
Reference-contexts: This support for POSTQUEL as a type allows the system to simulate non-normalized relations as found in NF**2 <ref> [DADA86] </ref>. POSTQUEL functions can appear in the query language in the same manner as normal functions.
Reference: [DATE81] <author> Date, C., </author> <title> Referential Integrity, </title> <booktitle> Proc. Seventh International VLDB Conference, </booktitle> <address> Cannes, France, </address> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: In retrospect, we should included general support for arrays or no support at all. 3. THE RULES SYSTEM 3.1. Introduction It is clear to us that all DBMSs need a rules system. Current commercial systems are required to support referential integrity <ref> [DATE81] </ref>, which is merely a simple-minded collection of rules. In addition, most current systems have special purpose rules systems to support relational views, protection, and integrity constraints. Lastly, a rules system allows users to do event-driven programming as well as enforce integrity constraints that cannot be performed in other ways.
Reference: [ESWA76] <author> Eswaren, K., </author> <title> ``Specification, Implementation and Interactions of a Rule Subsys tem in an Integrated Database System,'' </title> <institution> IBM Research, </institution> <address> San Jose, Ca., </address> <note> Research Report RJ1820, </note> <month> August </month> <year> 1976. </year>
Reference-contexts: There are three high level decisions that the POSTGRES team had to make concerning the philosophy of rule systems. First, a decision was required concerning how many rule syntaxes there would be. Some approaches, e.g. <ref> [ESWA76, WIDO89] </ref> propose rule systems oriented toward application designers that would augment other rule systems present for DBMS internal purposes. Hence, such systems would contain several independently functioning rules systems. <p> A conventional production system consisting of collections of if-then rules has been explored in the past <ref> [ESWA76, STON82] </ref>, and is a readily available alternative. However, such a scheme lacks expressive power. For example, suppose one wants to enforce a rule that Joe makes the same salary as Fred. In this case, one must specify two different if-then rules.
Reference: [FALO87] <author> Faloutsos, C. et. al., </author> <title> ``Analysis of Object Oriented Spatial Access Methods,'' </title> <booktitle> Proc. 1987 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> San Francisco, Ca., </address> <month> May </month> <year> 1987. </year>
Reference-contexts: Other Comments Historical indexes will usually be on a combined key consisting of a time range together with one or more keys from the record itself. Such two-dimensional indexes can be stored using the technology of R-trees [GUTM84], R+-trees <ref> [FALO87] </ref> or perhaps in some new way. We are not particularly comfortable that good ways to index time ranges have been found, and we encourage additional work in this area. A possible approach is segmented R-trees which we are studying [KOLE89]. Another comment concerns POSTGRES support for time travel.
Reference: [GUTM84] <author> Gutman, A., ``R-trees: </author> <title> A Dynamic Index Structure for Spatial Searching,'' </title> <booktitle> Proc. 1984 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Boston, Mass. </address> <month> June </month> <year> 1984. </year>
Reference-contexts: The standard example of this capability is the use of R-trees <ref> [GUTM84] </ref> to speed access to geometric objects. We have now designed and/or coded three access methods for POSTGRES in addition to B+-trees. Our experience has consistently been that adding an access method is VERY HARD. There are four problems that complicate the situation. <p> Other Comments Historical indexes will usually be on a combined key consisting of a time range together with one or more keys from the record itself. Such two-dimensional indexes can be stored using the technology of R-trees <ref> [GUTM84] </ref>, R+-trees [FALO87] or perhaps in some new way. We are not particularly comfortable that good ways to index time ranges have been found, and we encourage additional work in this area. A possible approach is segmented R-trees which we are studying [KOLE89].
Reference: [KOLE89] <author> Kolovson, C. and Stonebraker, M., </author> <title> ``Segmented Search Trees and their Applica tion to Data Bases,'' </title> <note> (in preparation). </note>
Reference-contexts: We are considering several solutions to this problem. First, we have generalized B+-trees to efficiently store interval data as well as point data. Such ``segmented B+-trees'' are the subject of a separate paper <ref> [KOLE89] </ref>. This will remove the space overhead in the index for the dominant form of access method. Second, to lower the overhead on data records, we will probably implement markers at the physical block level as well as at the instance and constructed type levels. <p> We are not particularly comfortable that good ways to index time ranges have been found, and we encourage additional work in this area. A possible approach is segmented R-trees which we are studying <ref> [KOLE89] </ref>. Another comment concerns POSTGRES support for time travel. There are many tasks that are very difficult to express with our mechanisms. For example, the query to find the time at which Sam's salary increased from $5000 to $6000 is very tricky in POSTQUEL.
Reference: [LYNC88] <author> Lynch, C. and Stonebraker, M., </author> <title> ``Extended User-Defined Indexing with Applica tion to Textual Databases,'' </title> <booktitle> Proc. 1988 VLDB Conference, </booktitle> <address> Los Angeles, Ca., </address> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: Another failure concerned the access method design and was the decision to support indexing only on the value of a field and not on a function of a value. The utility of indexes on functions of values is discussed in <ref> [LYNC88] </ref>, and the capability was retrofitted, rather inelegantly, into one version of POSTGRES [AOKI89]. Another comment on the access method design concerns extendibility.
Reference: [MAIE89] <author> Maier, D., </author> <title> ``Why Isn't There an Object-oriented Data Model?'' Proc. </title> <booktitle> 11th IFIP World Congress, </booktitle> <address> San Francisco, Ca., </address> <month> August </month> <year> 1989. </year>
Reference-contexts: As noted in a previous footnote, Section 2 could have been equally well written with the word "constructed type" and "instance" replaced by the words "relation" and "tuple". In fact, in previous descriptions of POSTGRES [STON86], this notation was employed. Hence, others, e.g. <ref> [MAIE89] </ref> have characterized POSTGRES as an extended relational system. 11 Lastly, POSTGRES supports the POSTQUEL type, which is exactly a nested relational structure. Consequently, POSTGRES could be classified as a nested relational system as well. As a result POSTGRES could be described using any of the three adjectives above.
Reference: [OSBO86] <author> Osborne, S. and Heaven, T., </author> <title> ``The Design of a Relational System with Abstract Data Types as Domains,'' </title> <journal> ACM TODS, </journal> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: The POSTGRES Data Model As mentioned in the previous section POSTGRES leverages types and functions as fundamental constructs. There are three kinds of types in POSTGRES and three kinds of functions and we discuss the six possibilities in this section. Some researchers, e.g. <ref> [STON86b, OSBO86] </ref>, have argued that one should be able to construct new base types such as bits, bitstrings, encoded character strings, bitmaps, compressed integers, packed decimal numbers, radix 50 decimal numbers, money, etc.
Reference: [RICH87] <author> Richardson, J. and Carey, M., </author> <title> ``Programming Constructs for Database System Implementation in EXODUS,'' </title> <booktitle> Proc. 1987 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> San Francisco, Ca., </address> <month> May </month> <year> 1987. </year>
Reference-contexts: In addition he can define functions which in turn make calls on POSTGRES internals. In this way, he can have considerable control over the low level flow of control, much as is available through a DBMS toolkit such as Exodus <ref> [RICH87] </ref>, but without all the effort involved in configuring a tailored DBMS from the toolkit. Moreover, should the user wish to interact with his data base by making a collection of function calls (method invocations), this facility allows the possibility.
Reference: [ROWE87] <author> Rowe, L. and Stonebraker, M., </author> <title> "The POSTGRES Data Model," </title> <booktitle> Proc. 1987 VLDB Conference, </booktitle> <address> Brighton, England, </address> <month> Sept </month> <year> 1987. </year>
Reference-contexts: Then, in Section 4 we discuss the novel no-overwrite storage manager that we implemented in POSTGRES. Other papers have explained the major POSTGRES design decisions in these areas, and we assume that the reader is familiar with <ref> [ROWE87] </ref> on the data model, [STON88] on rule management, and [STON87] on storage management. Hence, in these three sections we stress considerations that led to our design, what we liked about the design, and the mistakes that we felt we made.
Reference: [ROWE89] <author> Rowe, L. et. al., </author> <title> ``The Design and Implementation of Picasso,'' </title> <note> (in preparation). </note>
Reference-contexts: No such security problem arises with POSTQUEL functions. An better approach might have been to support POSTQUEL functions written in the 4th generation language (4GL) being designed for PICASSO <ref> [ROWE89] </ref>. This programming system leaves type information in the system catalogs. Consequently, there would be no need for a separate registrations step to indicate type information to POSTGRES. Moreover, a processor for the language is available for integration in POSTGRES.
Reference: [SELL86] <author> Sellis, T., </author> <title> ``Global Query Optimization,'' </title> <booktitle> Proc 1986 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Washington, D.C., </address> <month> June </month> <year> 1986. </year>
Reference-contexts: ``wood'') where EMP.name= ``Sam'' and EMP.age &gt; 40 retrieve (desk = null) where EMP.name = ``Sam'' and EMP.dept = ``candy'' Hence, a user query must be rewritten for each rule, resulting in a serious degradation of performance unless all queries are processed as a group using multiple query optimization techniques <ref> [SELL86] </ref>. Moreover, a query rewrite system has great difficulty with exceptions [BORG85]. For example consider the rule ``all employees have a steel desk'' together with the exception ``Jones is an employee who has a wood desk''.
Reference: [STON75] <author> Stonebraker, M., </author> <title> ``Implementation of Integrity Constraints and Views by Query Modification,'' </title> <booktitle> Proc. 1975 ACM-SIGMOD Conference, </booktitle> <address> San Jose, Ca., </address> <month> May </month> <year> 1975. </year> <month> 35 </month>
Reference-contexts: The first is a query rewrite implementation. Here, a rule would be applied by converting a user query to an alternate form prior to execution. This transformation is performed between the query language parser and the optimizer. Support for views <ref> [STON75] </ref> is done this way along with many of the proposals for recursive query support [BANC86, ULLM85]. Such an implementation will be very efficient when there are a small number of rules on any given constructed type and most rules cover the whole constructed type. <p> "shoe" Any query utilizing such a rule, e.g: retrieve (SHOE-EMP.name) where SHOE-EMP.age &lt; 40 would be processed by the rewrite implementation to: retrieve (EMP.name) where EMP.age &lt; 40 and EMP.dept = ``shoe'' As can be seen, this is identical to the query modification performed in relational view processing 23 techniques <ref> [STON75] </ref>. This rule could also be processed by the triggering system, in which case the rule would materialize the records in SHOE-EMP iteratively. Moreover, it is straightforward to support additional functionality, such as allowing multiple queries in the definition of a view.
Reference: [STON82] <author> Stonebraker, M. et. al., </author> <title> ``A Rules System for a Relational Data Base Management System,'' </title> <booktitle> Proc. 2nd International Conference on Databases,'' </booktitle> <address> Jerusalem, Israel, </address> <note> June 1982 (available from Academic press). </note>
Reference-contexts: Some approaches, e.g. [ESWA76, WIDO89] propose rule systems oriented toward application designers that would augment other rule systems present for DBMS internal purposes. Hence, such systems would contain several independently functioning rules systems. On the other hand, <ref> [STON82] </ref> proposed a rule system that tried to support user functionality as well as needed DBMS internal functions in a single syntax. From the beginning, a goal of the POSTGRES rules system was to have only one syntax. <p> A conventional production system consisting of collections of if-then rules has been explored in the past <ref> [ESWA76, STON82] </ref>, and is a readily available alternative. However, such a scheme lacks expressive power. For example, suppose one wants to enforce a rule that Joe makes the same salary as Fred. In this case, one must specify two different if-then rules.
Reference: [STON86] <author> Stonebraker, M. and Rowe, L., </author> <title> ``The Design of POSTGRES,'' </title> <booktitle> Proc. 1986 ACM SIGMOD Conference, </booktitle> <address> Washington, D.C., </address> <month> June </month> <year> 1986. </year>
Reference-contexts: Support for such rules is desirable in this application. We believe that most real world data management problems are three dimensional. Like the newspaper application, they will require a three dimensional solution. The fundamental goal of POSTGRES <ref> [STON86, WENS88] </ref> is to provide support for such three dimensional applications. To the best of our knowledge it is the first three dimensional data manager. However, we expect that most DBMSs will follow the lead of POSTGRES into these new dimensions. <p> On the other hand, POSTGRES could also be considered an extended relational system. As noted in a previous footnote, Section 2 could have been equally well written with the word "constructed type" and "instance" replaced by the words "relation" and "tuple". In fact, in previous descriptions of POSTGRES <ref> [STON86] </ref>, this notation was employed. Hence, others, e.g. [MAIE89] have characterized POSTGRES as an extended relational system. 11 Lastly, POSTGRES supports the POSTQUEL type, which is exactly a nested relational structure. Consequently, POSTGRES could be classified as a nested relational system as well. <p> The PICASSO team stated that this approach placed an unacceptably difficult burden on them, and therefore position 1 was rejected. Position 2 offers some support for union types but has problems. Consider the example of employees and their hobbies from <ref> [STON86] </ref>: create EMP (name = c12, hobbies = POSTQUEL) Here the hobbies field is a POSTQUEL function, one per employee, which retrieves all hobby information about that particular employee.
Reference: [STON86b] <author> Stonebraker, M., </author> <title> Inclusion of New Types in Relational Data Base Systems, </title> <booktitle> Proc. Second International Conference on Data Engineering, </booktitle> <address> Los Angeles, Ca., </address> <month> Feb. </month> <year> 1986. </year>
Reference-contexts: The POSTGRES Data Model As mentioned in the previous section POSTGRES leverages types and functions as fundamental constructs. There are three kinds of types in POSTGRES and three kinds of functions and we discuss the six possibilities in this section. Some researchers, e.g. <ref> [STON86b, OSBO86] </ref>, have argued that one should be able to construct new base types such as bits, bitstrings, encoded character strings, bitmaps, compressed integers, packed decimal numbers, radix 50 decimal numbers, money, etc.
Reference: [STON87] <author> Stonebraker, M., </author> <title> "The POSTGRES Storage System," </title> <booktitle> Proc. 1987 VLDB Confer ence, </booktitle> <address> Brighton, England, </address> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: Then, in Section 4 we discuss the novel no-overwrite storage manager that we implemented in POSTGRES. Other papers have explained the major POSTGRES design decisions in these areas, and we assume that the reader is familiar with [ROWE87] on the data model, [STON88] on rule management, and <ref> [STON87] </ref> on storage management. Hence, in these three sections we stress considerations that led to our design, what we liked about the design, and the mistakes that we felt we made. Where appropriate we make suggestions for future implementors based on our experience. <p> Hence, there is no possibility of instantaneous crash recovery. 25 Clearly a no-overwrite storage manager is superior to a conventional one if it can be implemented at comparable performance. There is a brief hand-wave of an argument in <ref> [STON87] </ref> that alleges this might be the case. In our opinion, the argument hinges around the existence of stable main memory. In the absence of stable memory, a no-overwrite storage manager must force to disk at commit time all pages written by a transaction.
Reference: [STON87b] <author> Stonebraker, M. et. al., </author> <title> ``Extensibility in POSTGRES,'' </title> <journal> IEEE Database Engineer ing, </journal> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: This index can support efficient access for the class of operators -ALT, ALE, AE, AGT, AGE-. Information on the access paths available to the various operators is recorded in the POSTGRES system catalogs. As pointed out in <ref> [STON87b] </ref> it is imperative that a user be able to construct new access methods to provide efficient access to instances of non-traditional base types. For example, suppose a user introduces a new operator "!!" defined on polygons that returns true if two polygons overlap.
Reference: [STON88] <author> Stonebraker, M. et. al., </author> <title> "The POSTGRES Rules System," </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> July </month> <year> 1988. </year>
Reference-contexts: Then, in Section 4 we discuss the novel no-overwrite storage manager that we implemented in POSTGRES. Other papers have explained the major POSTGRES design decisions in these areas, and we assume that the reader is familiar with [ROWE87] on the data model, <ref> [STON88] </ref> on rule management, and [STON87] on storage management. Hence, in these three sections we stress considerations that led to our design, what we liked about the design, and the mistakes that we felt we made. Where appropriate we make suggestions for future implementors based on our experience. <p> this case, any query, e.g: retrieve (EMP.age) where EMP.name = "Sam" will be altered prior to execution by the query rewrite implementation to: retrieve (age = 40) where EMP.name = "Sam" and EMP.name != "Bill" 19 At the current time much of the POSTGRES Rules System (PRS) as described in <ref> [STON88] </ref> is operational, and there are three aspects of the design which we wish to discuss in the next three subsections, namely: complexity absence of needed function and efficiency Then, we close with the second version of the POSTGRES Rules system (PRS II) which we are currently designing.
Reference: [STON89] <author> Stonebraker, M. et. al., </author> <title> ``Commentary on the POSTGRES Rules System,'' </title> <journal> SIG MOD RECORD, </journal> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: This rules system is described in more detail in <ref> [STON89, STON89b] </ref>. 3.2. Complexity The first problem with PRS is that the implementation is exceedingly complex. It is difficult to explain the marking mechanisms that cause rule wake-up even to a sophisticated person. Moreover, some of us have an uneasy feeling that the implementation may not be quite correct.
Reference: [STON89b] <author> Stonebraker, M. et. al., </author> <title> ``Rules, Procedures and Views,'' </title> <note> (in preparation). </note>
Reference-contexts: This rules system is described in more detail in <ref> [STON89, STON89b] </ref>. 3.2. Complexity The first problem with PRS is that the implementation is exceedingly complex. It is difficult to explain the marking mechanisms that cause rule wake-up even to a sophisticated person. Moreover, some of us have an uneasy feeling that the implementation may not be quite correct. <p> This rules system has much in common with the first implementation, but returns to the traditional production rule paradigm to obtain sufficient control to perform view updates correctly. This section outlines our thinking, and a complete proposal appears in <ref> [STON89b] </ref>. 22 The production rule syntax we are using in PRS II has the form: ON event TO object WHERE POSTQUEL-qualification THEN DO POSTQUEL-command (s) Here, event is retrieve, replace, delete, append, new (i. e. replace or append) or old (i.e. delete or replace). <p> PRS II has both a query rewrite implementation and a trigger implementation, and it is an optimization decision which one to use as noted in <ref> [STON89b] </ref>. <p> This corresponds to moving the rule to early evaluation. Lastly, supporting views that are partly materialized and partly specified as procedures as well as views that involve recursion appears fairly simple. In <ref> [STON89b] </ref> we present details on these extensions. <p> On the other hand, all rules, except retrieve always commands, can be alternately implemented using POSTQUEL functions. We expect to merge the two concepts in Version 2, and our proposal appears in <ref> [STON89b] </ref>. In the areas of rules and storage management, we are basically satisfied with POSTGRES capabilities. The syntax of the rule system should be changed as noted in Section 3; however this is not a significant issue and it should be available easily in Version 2.
Reference: [ULLM85] <author> Ullman, J., </author> <title> ``Implementation of Logical Query Languages for Databases,'' </title> <address> ACM-TODS, </address> <month> Sept. </month> <year> 1985. </year>
Reference-contexts: Here, a rule would be applied by converting a user query to an alternate form prior to execution. This transformation is performed between the query language parser and the optimizer. Support for views [STON75] is done this way along with many of the proposals for recursive query support <ref> [BANC86, ULLM85] </ref>. Such an implementation will be very efficient when there are a small number of rules on any given constructed type and most rules cover the whole constructed type.
Reference: [VELE89] <author> Velez, F. et. al., </author> <title> ``The O2 Object manager: An Overview,'' </title> <type> GIP ALTAIR, </type> <institution> Le Chesnay, France, </institution> <type> Technical Report 27-89, </type> <month> February </month> <year> 1989. </year>
Reference-contexts: It is also possible to interact with a POSTGRES data base by utilizing a navigational interface. Such interfaces were popularized by the CODASYL proposals of the 1970's and are enjoying a renaissance in recent object-oriented proposals such as ORION [BANE87] or O2 <ref> [VELE89] </ref>. Because POSTGRES gives each record a unique identifier (OID), it is possible to use the identifier for one record as a data item in a second record.
Reference: [WENS88] <author> Wensel, S. (ed.), </author> <title> ``The POSTGRES Reference Manual,'' </title> <institution> Electronics Research Laboratory, University of California, Berkeley, CA, Report M88/20, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Support for such rules is desirable in this application. We believe that most real world data management problems are three dimensional. Like the newspaper application, they will require a three dimensional solution. The fundamental goal of POSTGRES <ref> [STON86, WENS88] </ref> is to provide support for such three dimensional applications. To the best of our knowledge it is the first three dimensional data manager. However, we expect that most DBMSs will follow the lead of POSTGRES into these new dimensions. <p> Such types can be added to the system while it is executing and require the defining user to specify functions to convert instances of the type to and from the character string data type. Details of the syntax appear in 4 <ref> [WENS88] </ref>. The second kind of type available in POSTGRES is a constructed type.** A user can create a new type by constructing a record of base types and instances of other constructed types. <p> The user who is interested in retaining duplicates can do so by ensuring that the OID field of some instance is included in the target list being selected. For a full description of POST-QUEL the interested reader should consult <ref> [WENS88] </ref>. 2.4. Fast Path There are three reasons why we chose to implement a fast path feature. First, a user who wishes to interact with a data base by executing a sequence of functions to navigate to desired data can use fast path to accomplish his objective.
Reference: [WIDO89] <author> Widom, J. and Finkelstein, S., </author> <title> ``A Syntax and Semantics for Set-oriented Produc tion Rules in Relational Data Bases, </title> <institution> IBM Research, </institution> <address> San Jose, Ca., </address> <month> June </month> <year> 1989. </year> <month> 36 </month>
Reference-contexts: There are three high level decisions that the POSTGRES team had to make concerning the philosophy of rule systems. First, a decision was required concerning how many rule syntaxes there would be. Some approaches, e.g. <ref> [ESWA76, WIDO89] </ref> propose rule systems oriented toward application designers that would augment other rule systems present for DBMS internal purposes. Hence, such systems would contain several independently functioning rules systems.
References-found: 36

