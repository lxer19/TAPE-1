URL: http://www.it.kth.se/docs/Reports/se/oo-modal-lp.ps.Z
Refering-URL: http://www.it.kth.se/docs/Reports/se/
Root-URL: http://www.it.kth.se
Title: Combining ObjectOriented and Logic Paradigms: A Modal Logic Programming Approach  
Author: Tarmo Uustalu 
Address: Akadeemia tee 21, EE-0108 Tallinn, Estonia  
Affiliation: Dept. of Mathematics, Institute of Cybernetics, Estonian Acad. Sci.  
Abstract: In this paper, a number of existing solutions and suggestions towards combining the objectoriented (OO) and logic programming paradigms have been briefly studied and categorized, and a sketch of a new solution has been proposed which tries to capture the essence of OO in terms of modal logic, and which could be implemented as a modal logic programming system. The proposal is based on the belief that two orthogonal dimensions - object hierarchy and time - are involved in OO that in many respects are similar. For the one-dimensional (static) case, three logics - MU, MU , and MU - have been designed, each allowing a different variety of inheritance modes. The two-dimensional (dynamic) case has been treated in a logic 2MU and its corresponding variants. Under certain OO-motivated definitions of Horn clause, the resolution calculi of these logics turn out to be complete. 
Abstract-found: 1
Intro-found: 1
Reference: [AN86] <author> H. At-Kaci and R. Nasr. </author> <title> LOGIN: A logic programming language with built-in inheritance. </title> <editor> J. </editor> <booktitle> Logic Programming , 3(3) </booktitle> <pages> 185-215, </pages> <year> 1986. </year>
Reference-contexts: To provide a counterpart for subtype/supertype (i.e. isa) relation, order-sorted logics have been developed (for overview, see [Obe89]). In those, a partial ordering on sorts is assumed which basically is a subsort/supersort relation . A good example of an ordersorted logic programming language is EPOS [HV87]. The LOGIN <ref> [AN86] </ref> language (which served as a starting point for the ALF [Mel88] merger of OO and logic) can also be regarded as relying on a variant of ordersorted logic ( feature types ), its peculiarity being that there are no sorts there, and individuals are ordered instead.
Reference: [BMS90] <author> M. v. Biema, G. Q. Maquire, and S. Stolfo. </author> <title> The constraint-based paradigm: Integrating objectoriented and rule-based programming. </title> <booktitle> In Proc. 23rd Annual Hawa Int'l Conf. on Syst. Sci. , Kailua-Kona, Jan 1990, </booktitle> <volume> Vol 2, </volume> <pages> pp 358-66. </pages> <address> Los Alamitos, CA: </address> <publisher> IEEE Comp. Soc. Press, </publisher> <year> 1990. </year>
Reference-contexts: The examples of mergers with an OO base language are Orient84/K [IT86], KSL/Logic [IT90], and CBL <ref> [BMS90] </ref>. In Orient84/K and KSL/Logic, deductive retrieval is facilitated through built-in methods. Besides that, in KSL/Logic, all logical constructs are viewed as objects. In CBL, an OO base language has been extended with means for expressing complex conditionals (rules).
Reference: [Cat88] <author> L. Catach. </author> <title> Normal multimodal logics. </title> <booktitle> In AAAI-88: Proc. 7th Nat'l Conf. on AI , St Paul, Aug 1988, </booktitle> <volume> Vol 2, </volume> <pages> pp 491-5. </pages> <year> 1988. </year>
Reference-contexts: In the conventional OO notation, this clause could be written as: object v is ... method p is q; self:r, z:s ... 4.2 Formal In the formal presentation, we adhere to the terminology and denotations from [Che80] and <ref> [Cat88] </ref>. Proofs and technicalities can be found in [Uus91]. To simplify the presentation, we shall consider propositional fragments everywhere. Section 4.3 gives hints for generalizations into the full predicate logic. <p> A / [ u ] A , u D . [ u ] A fi u A , u 4 . [ z ] A fi [ u ][z] A , u,z MU is normal in the sense of <ref> [Cat88] </ref>. <p> any w , w , w W if wR u z w then wR z v . quasi-euclidity: for any w , w , w W if wR u z w then w R z The completeness of this semantics follows from the Catach completeness theorem for normal multimodal logics <ref> [Cat88] </ref>.
Reference: [Che80] <author> B.F.Chellas. </author> <title> Modal Logic: An Introduction . Cambridge, </title> <publisher> UK: Univ. Press, </publisher> <year> 1980. </year>
Reference-contexts: In the conventional OO notation, this clause could be written as: object v is ... method p is q; self:r, z:s ... 4.2 Formal In the formal presentation, we adhere to the terminology and denotations from <ref> [Che80] </ref> and [Cat88]. Proofs and technicalities can be found in [Uus91]. To simplify the presentation, we shall consider propositional fragments everywhere. Section 4.3 gives hints for generalizations into the full predicate logic.
Reference: [Che87] <author> W. Chen. </author> <title> A theory of modules based on second-order logic. </title> <booktitle> In Proc. 1987 Symp. on Logic Programming , San Fransisco, Aug/Sept 1987, </booktitle> <pages> pp 24-33. </pages> <address> Washington, DC: </address> <publisher> IEEE Comp. Soc. Press, </publisher> <year> 1987. </year>
Reference-contexts: Two orthogonal directions of structuring can be observed in logic programming: modularization (structuring of programs) and sorting (structuring of data, i.e. grouping of individuals; sort type). As examples of research in the direction of modularization , we mention [Mil86] and <ref> [Che87] </ref>. In a number of studies, modules are viewed as worlds , with more or less explicit parallels drawn to the possible-worlds' semantics of modal logics . From among the merger systems, mentioned in Section 2.1, Prolog/KR, Mandala and CPU take this approach.
Reference: [Chi84] <author> T. Chikayama. </author> <title> Unique features of ESP. </title> <booktitle> In Proc. 1984 Int'l Conf. on 5th Gener. Comp. Syst. </booktitle> , <address> Tokyo, </address> <month> Nov </month> <year> 1984, </year> <pages> pp 292-8. </pages> <address> Amsterdam: North-Hol-land, </address> <year> 1984. </year> <month> 14 </month>
Reference-contexts: The concept of attribute is often understood more generally in mergers than in conventional OO (see Section 3 for details). Attribute value changes. Zaniolo's approach enables no dynamics. ESP <ref> [Chi84] </ref>, SPOOL [FH86], and Prolog ++ [Mos90] make use of imperative assignments. Predominantly, states are revised exploiting the assert and retract built-in predicates. In ObjVProlog [MLV89], semantically cleaner predicates - assume and forget - are made use of.
Reference: [Con88] <author> J. S. Conery. </author> <title> Logical objects. </title> <booktitle> In Logical Programming: Proc. 5th Int'l Conf. and Symp. </booktitle> , <address> Seattle, </address> <month> Aug </month> <year> 1988, </year> <pages> pp 420-34. </pages> <address> Cambridge, MA: </address> <publisher> The MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: Objects, therefore, are literals, with arguments instantiated with concrete attribute values. In Mandala [FTK..84], objects are predicates, with one argument meant for indicating the revision (in the form of a stream ), and others for attribute values. In Conery's merger <ref> [Con88] </ref>, where predicate interpretation changes during the program execution, classes are predicates, with one argument meant for an atomic object name, and others corresponding to attributes. In "Objects as Intensions" [CW88], an object is an individual variable, standing for the infinite list of its states during history.
Reference: [CW88] <author> W. Chen and D. S. Warren. </author> <title> Objects as intensions. </title> <booktitle> In Logical Programming: Proc. 5th Int'l Conf. and Symp. </booktitle> , <address> Seattle, </address> <month> Aug </month> <year> 1988, </year> <pages> pp 404-19. </pages> <address> Cambridge, MA: </address> <publisher> The MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: In Conery's merger [Con88], where predicate interpretation changes during the program execution, classes are predicates, with one argument meant for an atomic object name, and others corresponding to attributes. In "Objects as Intensions" <ref> [CW88] </ref>, an object is an individual variable, standing for the infinite list of its states during history. The concept of attribute is often understood more generally in mergers than in conventional OO (see Section 3 for details). Attribute value changes. Zaniolo's approach enables no dynamics.
Reference: [Far86] <author> L. Farias del Cerro. MOLOG: </author> <title> A system that extends Prolog with modal logic. New Gener. </title> <booktitle> Computing , 4(1) </booktitle> <pages> 35-50, </pages> <year> 1986. </year>
Reference-contexts: From among the merger systems, mentioned in Section 2.1, Prolog/KR, Mandala and CPU take this approach. From proper modal extensions of Prolog, we mention MULTILOG [KG86] and MOLOG <ref> [Far86] </ref>. In OO applications of the modal logic paradigm, the accessibility relation between worlds correlates with the isa relation. Sorting relies on many-sorted logics . Plain many-sorted logics offer no relation between sorts.
Reference: [FH86] <author> K. Fukunaga and S. Hirose. </author> <title> An experience with a Prolog-based object-oriented language. In OOPSLA'86: OOP Syst., Lang. and Appl.: </title> <booktitle> Conf. Proc. </booktitle> , <address> Portland, </address> <month> Sept/Oct </month> <year> 1986, </year> <pages> pp 224-31. </pages> <year> 1986. </year> ( <journal> SIGPLAN Notices , 21(11)). </journal>
Reference-contexts: The concept of attribute is often understood more generally in mergers than in conventional OO (see Section 3 for details). Attribute value changes. Zaniolo's approach enables no dynamics. ESP [Chi84], SPOOL <ref> [FH86] </ref>, and Prolog ++ [Mos90] make use of imperative assignments. Predominantly, states are revised exploiting the assert and retract built-in predicates. In ObjVProlog [MLV89], semantically cleaner predicates - assume and forget - are made use of.
Reference: [FTK..84] <editor> K. Furukawa et al. Mandala: </editor> <title> A logic-based knowledge programming system. </title> <booktitle> In Proc 1984 Int'l Conf. on 5th Gener. Comp. Syst. </booktitle> , <address> Tokyo, </address> <month> Nov </month> <year> 1984, </year> <pages> pp 613-22. </pages> <address> Amsterdam: </address> <publisher> North-Holland, </publisher> <year> 1984. </year>
Reference-contexts: Attributes, thereby, are either nonlogical (imperative) variables, or predicates that are given values in the clause sets of objects. In Zaniolo's proposal, classes are predicates, with argument places corresponding to attributes. Objects, therefore, are literals, with arguments instantiated with concrete attribute values. In Mandala <ref> [FTK..84] </ref>, objects are predicates, with one argument meant for indicating the revision (in the form of a stream ), and others for attribute values.
Reference: [Gal86] <author> H. Gallaire. </author> <title> Merging objects and logic programming: Relational semantics. </title> <booktitle> In AAAI-86: Proc. 5th Nat'l Conf. on AI, Philadelfia , Aug 1986, </booktitle> <volume> Vol 2, </volume> <pages> pp 754-8. </pages> <address> Los Altos, CA: </address> <publisher> Morgan Kaufmann, </publisher> <year> 1986. </year>
Reference-contexts: In mergers with logic, it seems equally reasonable to allow further pursuing until either success will be achieved, or the space of appropriate definitions will be used up. Such inheritance is called cumulative . <ref> [Gal86] </ref> terms these modes of inheritance as call/return and success/failure , respectively. Most mergers use overriding inheritance. In Prolog/KR [Nak84], ESP, and POL [Gal86], cumulation is the default. Overriding is facilitated through special language constructs (the simplest of them - cut - is readily available in Prolog). <p> Such inheritance is called cumulative . <ref> [Gal86] </ref> terms these modes of inheritance as call/return and success/failure , respectively. Most mergers use overriding inheritance. In Prolog/KR [Nak84], ESP, and POL [Gal86], cumulation is the default. Overriding is facilitated through special language constructs (the simplest of them - cut - is readily available in Prolog). In CPU [MN87], the user has to metaprogram the inheritance semantics. Our proposal, MU, falls under the third group of the above classification.
Reference: [GM87] <author> J. A. Goguen and J. Meseguer. </author> <title> Unifying functional, objectoriented and relational programming with logical semantics. </title> <editor> In B. Shriver and P. Wegner, eds, </editor> <booktitle> Research Directions in ObjectOriented Programming , pp 417-77. </booktitle> <address> Cambrdige, MA: </address> <publisher> The MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: In CPU [MN87], the user has to metaprogram the inheritance semantics. Our proposal, MU, falls under the third group of the above classification. There are solutions that do not restrict logic to mean just Horn clause logic, like FOOPlog <ref> [GM87] </ref> and Maude [Mes90], which put much emphasis on algebra (algebraic 3 specifications, rewriting), or PRIZ [MT90], where deduction is used for synthesizing algorithms from specifications and not in execution.
Reference: [GW91] <author> J. A. Goguen and D. Wolfram. </author> <title> On types and FOOPS. </title> <editor> In R. Meersman et al., eds., </editor> <title> Object Oriented Databases: Analysis, Design and Construction , pp 1-22. </title> <publisher> Amsterdam: North-Holland, </publisher> <year> 1991. </year>
Reference-contexts: Hidden sorts are defined as sets of algebrae, which are nothing less than 4 semantic counterparts of theories or modules. A thorough justification of this approach can be found in <ref> [GW91] </ref>. 3 Principles and Terminology The principles of OO have two aspects, facilitating and restrictive . An OO language must possess constructs for working with objects ( modularity ).
Reference: [HV87] <author> M. Huber and I. Varsek. </author> <title> Extended Prolog for ordersorted resolution. </title> <booktitle> In Proc. 1987 Symp. on Logic Programming , San Fransisco, Aug/Sept 1987, </booktitle> <pages> pp 34-43. </pages> <address> Washington, DC: </address> <publisher> IEEE Comp. Soc. Press, </publisher> <year> 1987. </year>
Reference-contexts: To provide a counterpart for subtype/supertype (i.e. isa) relation, order-sorted logics have been developed (for overview, see [Obe89]). In those, a partial ordering on sorts is assumed which basically is a subsort/supersort relation . A good example of an ordersorted logic programming language is EPOS <ref> [HV87] </ref>. The LOGIN [AN86] language (which served as a starting point for the ALF [Mel88] merger of OO and logic) can also be regarded as relying on a variant of ordersorted logic ( feature types ), its peculiarity being that there are no sorts there, and individuals are ordered instead.
Reference: [IC90] <author> M. H. Ibrahim and F. A. Cummins. KSL/Logic: </author> <title> Integration of logic with objects. </title> <booktitle> In Proc. 1990 Int'l Conf. on Comp. </booktitle> <address> Lang. , New Orleans, </address> <month> March </month> <year> 1990, </year> <pages> pp 228-35. </pages> <address> Los Alamitos, CA: </address> <publisher> IEEE Comp. Soc Press, </publisher> <year> 1990. </year>
Reference: [IT86] <author> Y. Ishikawa and M. Tokoro. </author> <title> Concurrent objectoriented knowledge representation language Orient84/K: Its features and implementation. In OOPSLA'86: OOP Syst., Lang. and Appl.: </title> <booktitle> Conf. Proc. </booktitle> , <address> Portland, </address> <month> Sept/Oct </month> <year> 1986, </year> <pages> pp 232-41. </pages> <year> 1986. </year> ( <journal> SIGPLAN Notices ,21(11)). </journal>
Reference-contexts: The examples of mergers with an OO base language are Orient84/K <ref> [IT86] </ref>, KSL/Logic [IT90], and CBL [BMS90]. In Orient84/K and KSL/Logic, deductive retrieval is facilitated through built-in methods. Besides that, in KSL/Logic, all logical constructs are viewed as objects. In CBL, an OO base language has been extended with means for expressing complex conditionals (rules).
Reference: [KE88] <author> T. Koschmann and M. W. Evens. </author> <title> Bridging the gap between objectoriented and logic programming. </title> <booktitle> IEEE Software , 5(5) </booktitle> <pages> 36-42, </pages> <year> 1988. </year>
Reference-contexts: In Orient84/K and KSL/Logic, deductive retrieval is facilitated through built-in methods. Besides that, in KSL/Logic, all logical constructs are viewed as objects. In CBL, an OO base language has been extended with means for expressing complex conditionals (rules). The example of a language interface is Prolog/Loops <ref> [KE88] </ref>, where facilities have been provided for making calls to Loops objects from Prolog, and for setting Prolog goals from Loops (in the form of messages). Mergers with a logic base language are the most numerous.
Reference: [KG86] <author> H. Kauffmann and A. Grumbach. MULTILOG: </author> <booktitle> MULtiple worlds in LOGic programming. In ECAI'86: Proc. 7th Europ. Conf. on AI , Brighton, July 1986, </booktitle> <volume> Vol 1, </volume> <pages> pp 291-305. </pages> <year> 1986. </year>
Reference-contexts: From among the merger systems, mentioned in Section 2.1, Prolog/KR, Mandala and CPU take this approach. From proper modal extensions of Prolog, we mention MULTILOG <ref> [KG86] </ref> and MOLOG [Far86]. In OO applications of the modal logic paradigm, the accessibility relation between worlds correlates with the isa relation. Sorting relies on many-sorted logics . Plain many-sorted logics offer no relation between sorts. <p> Note that this approach also solves the frame (or persistence ) problem : at a transition to a new revision, the 5 values that are not being changed require no updating. The analogy between objects and revisions was pointed out in <ref> [KG86] </ref>. In our approach, we will not distinguish between objects and classes (classless system). Both attributes and methods will be called properties , and both objects and time instants will be called units (with the latter we follow the tradition of [MN87], [MP90]) .
Reference: [KLW90] <author> M. Kifer, G. Lausen and J. Wu. </author> <title> Logical foundations of objectoriented and frame-based languages. </title> <type> Technical Report 90/14, </type> <institution> SUNY at Stony Brook, Dept. of Comput. Sci., </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: Dynamic object hierarchies. At the present stage, the designed logics enable only objects be dynamic, whereas the isa links between them have to be static. Only when the research was in the stage of completion, the author got to know about the work by M. Kifer et al. <ref> [KLW90] </ref>. The connection between their formalism and ours needs to be studied yet. Acknowledgements I am grateful to my scientific advisors Reidar Conradi and Jan Komorowski. I also thank Tore Amble and Antonio Porto for the inspiration they provoked directly and indirectly, and the anonymous referees for their helpful remarks.
Reference: [KTMB87] <editor> K. Kahn et al. Vulcan: </editor> <title> Logical concurrent objects. </title> <editor> In B. Shriver and P. Wegner, eds, </editor> <booktitle> Research Directions in ObjectOriented Programming , pp 75-112. </booktitle> <address> Cambridge, MA: </address> <publisher> The MIT Press, </publisher> <year> 1987. </year> <month> 15 </month>
Reference-contexts: ESP [Chi84], SPOOL [FH86], and Prolog ++ [Mos90] make use of imperative assignments. Predominantly, states are revised exploiting the assert and retract built-in predicates. In ObjVProlog [MLV89], semantically cleaner predicates - assume and forget - are made use of. Shapiro and Takeuchi, Mandala, and Vulcan <ref> [KTMB87] </ref> (on its hidden underlying level) exploit streams . These lists of as yet unprocessed messages serve there as object revision identifiers. Conery's proposal and "Objects as Intensions" change states at resolution and through stepwise instantiation of the history lists, respectively. Inheritance .
Reference: [LM88] <author> L. Leonardi and P. Mello. </author> <title> Combining logic and objectoriented program-ming language paradigms. </title> <booktitle> In Proc. 21st Annual Hawa Int'l Conf. on Syst. Sci. </booktitle> , <volume> Vol 2, </volume> <pages> pp 376-85. </pages> <address> Washington, DC: </address> <publisher> IEEE Comp. Soc. Press, </publisher> <year> 1988. </year>
Reference-contexts: Proofs, as well as other technicalities, have been omitted in this paper. They can be found in [Uus91]. 2 Related Work 2.1 Mergers A good classification and study of mergers that had been suggested until 1987, has been presented in <ref> [LM88] </ref>. In the majority of mergers, logic means Horn clause logic, and we propose to distinguish between three main groups of such mergers: OO base language, extended with logical constructs, two base languages (OO and logic), interfaced, logic base language, extended with OO constructs.
Reference: [LVV89] <author> E. Laenens, D. Vermeir, and B. Verdonk. LOCO, </author> <title> a LOgic-based language for Complex Objects. </title> <booktitle> In ESPRIT'89: Proc. 6th Annual Esprit Conf. </booktitle> , <address> Brussels, </address> <month> Nov/Dec </month> <year> 1989, </year> <pages> pp 604-16. </pages> <address> Dordrecht: </address> <publisher> Kluwer Acad. Publ., </publisher> <year> 1989. </year>
Reference-contexts: Attributes are dynamic, methods are static (and both are predicates). This is so in many mergers, and it is specifically emphasized in SCOOP [VLM88] and ObjVProlog [MLV89]. Now not only may an attribute be "multivalued" (the predicate be non-functional - only LOCO <ref> [LVV89] </ref> has a construct for requiring univaluedness), but it can also be "parametric" (the predicate has input argument places) and "conditional" (the definition clauses do have bodies - in SCOOP and ObjVProlog, however, dynamic predicate definition clauses are restricted to facts only). From this position we can make one reformulation.
Reference: [McC88] <author> F. McCabe. </author> <title> Logic and Objects . London: </title> <institution> Imperial College, </institution> <year> 1988. </year>
Reference-contexts: Moreover, resolution calculi can be constructed for these logics which for classes of formulae corresponding to the actual OO practice prove to be complete. There are similarities in our approach to that of McCabe's <ref> [McC88] </ref>, where the main tool, however, is classical logic. The organization of the paper is as follows. Section 2 is a brief summary of the ongoing work on merging the OO and logic paradigms and on the "OO-independent" structuring trends within the logic paradigm.
Reference: [Mel88] <author> F. Mellender. </author> <title> An integration of logic and objectoriented programming. </title> <journal> SIGPLAN Notices , 23(10) </journal> <pages> 181-5, </pages> <year> 1988. </year>
Reference-contexts: In those, a partial ordering on sorts is assumed which basically is a subsort/supersort relation . A good example of an ordersorted logic programming language is EPOS [HV87]. The LOGIN [AN86] language (which served as a starting point for the ALF <ref> [Mel88] </ref> merger of OO and logic) can also be regarded as relying on a variant of ordersorted logic ( feature types ), its peculiarity being that there are no sorts there, and individuals are ordered instead.
Reference: [Mes90] <author> J. Meseguer. </author> <title> A logical theory of concurrent objects. </title> <booktitle> In OOPSLA ECOOP '90 Proc.: Conf. on OOP Syst., Lang. and Appl., Europ. Conf. on OOP , Ottawa, </booktitle> <month> Oct </month> <year> 1990, </year> <pages> pp 101-15. </pages> <year> 1990. </year> ( <journal> SIGPLAN Notices , 20(10)). </journal>
Reference-contexts: In CPU [MN87], the user has to metaprogram the inheritance semantics. Our proposal, MU, falls under the third group of the above classification. There are solutions that do not restrict logic to mean just Horn clause logic, like FOOPlog [GM87] and Maude <ref> [Mes90] </ref>, which put much emphasis on algebra (algebraic 3 specifications, rewriting), or PRIZ [MT90], where deduction is used for synthesizing algorithms from specifications and not in execution.
Reference: [Mil86] <author> D. Miller. </author> <title> A theory of modules for logic programming. </title> <booktitle> In Proc. 1986 Symp. on Logic Programming , Salt Lake City, </booktitle> <month> Sept </month> <year> 1986, </year> <pages> pp 106-14. </pages> <address> Washington, DC: </address> <publisher> IEEE Comp. Soc. Press, </publisher> <year> 1986. </year>
Reference-contexts: Two orthogonal directions of structuring can be observed in logic programming: modularization (structuring of programs) and sorting (structuring of data, i.e. grouping of individuals; sort type). As examples of research in the direction of modularization , we mention <ref> [Mil86] </ref> and [Che87]. In a number of studies, modules are viewed as worlds , with more or less explicit parallels drawn to the possible-worlds' semantics of modal logics . From among the merger systems, mentioned in Section 2.1, Prolog/KR, Mandala and CPU take this approach.
Reference: [MLV89] <author> J. Malenfant, G. Lapalme, and J. Vaucher. ObjVProlog: </author> <title> Metaclasses in logic. </title> <booktitle> In ECOOP'89: Proc. Europ. Conf. on OOP , Nottingham, </booktitle> <month> July </month> <year> 1989, </year> <pages> pp 257-69. </pages> <address> Cambridge, UK: </address> <publisher> Univ. Press, </publisher> <year> 1989. </year>
Reference-contexts: Attribute value changes. Zaniolo's approach enables no dynamics. ESP [Chi84], SPOOL [FH86], and Prolog ++ [Mos90] make use of imperative assignments. Predominantly, states are revised exploiting the assert and retract built-in predicates. In ObjVProlog <ref> [MLV89] </ref>, semantically cleaner predicates - assume and forget - are made use of. Shapiro and Takeuchi, Mandala, and Vulcan [KTMB87] (on its hidden underlying level) exploit streams . These lists of as yet unprocessed messages serve there as object revision identifiers. <p> Attributes are dynamic, methods are static (and both are predicates). This is so in many mergers, and it is specifically emphasized in SCOOP [VLM88] and ObjVProlog <ref> [MLV89] </ref>.
Reference: [MN87] <author> P. Mello and A. Natali. </author> <title> Objects as communicating Prolog units. </title> <booktitle> In ECOOP'87: Proc. Europ. Conf. on OOP , Paris, </booktitle> <month> June </month> <year> 1987, </year> <pages> pp 181-92. </pages> <address> Berlin: </address> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> ( <note> LNCS , 276). </note>
Reference-contexts: Most mergers use overriding inheritance. In Prolog/KR [Nak84], ESP, and POL [Gal86], cumulation is the default. Overriding is facilitated through special language constructs (the simplest of them - cut - is readily available in Prolog). In CPU <ref> [MN87] </ref>, the user has to metaprogram the inheritance semantics. Our proposal, MU, falls under the third group of the above classification. <p> In our approach, we will not distinguish between objects and classes (classless system). Both attributes and methods will be called properties , and both objects and time instants will be called units (with the latter we follow the tradition of <ref> [MN87] </ref>, [MP90]) . A unit hierarchy is formally a pair U , isa , where U is a nonempty finite set, and isa is a partial ordering on U . isa * will further denote the reflexive-transitive closure of isa. 4 MU "Modal Units" 4.1 Motivation L. Monteiro and A.
Reference: [Mos90] <author> C. Moss. </author> <title> An introduction to Prolog ++ . Research Report DOC 90/10, </title> <institution> Imperial College, </institution> <address> London, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: The concept of attribute is often understood more generally in mergers than in conventional OO (see Section 3 for details). Attribute value changes. Zaniolo's approach enables no dynamics. ESP [Chi84], SPOOL [FH86], and Prolog ++ <ref> [Mos90] </ref> make use of imperative assignments. Predominantly, states are revised exploiting the assert and retract built-in predicates. In ObjVProlog [MLV89], semantically cleaner predicates - assume and forget - are made use of. Shapiro and Takeuchi, Mandala, and Vulcan [KTMB87] (on its hidden underlying level) exploit streams .
Reference: [MP90] <author> L. Monteiro and A. Porto. </author> <title> Semantic and syntactic inheritance in logic programming. </title> <type> Draft report, </type> <institution> Departamento di Informatica, Universidade Nova de Lisboa, </institution> <month> Dec </month> <year> 1990. </year>
Reference-contexts: In our approach, we will not distinguish between objects and classes (classless system). Both attributes and methods will be called properties , and both objects and time instants will be called units (with the latter we follow the tradition of [MN87], <ref> [MP90] </ref>) . A unit hierarchy is formally a pair U , isa , where U is a nonempty finite set, and isa is a partial ordering on U . isa * will further denote the reflexive-transitive closure of isa. 4 MU "Modal Units" 4.1 Motivation L. Monteiro and A. Porto [MP90] <p> <ref> [MP90] </ref>) . A unit hierarchy is formally a pair U , isa , where U is a nonempty finite set, and isa is a partial ordering on U . isa * will further denote the reflexive-transitive closure of isa. 4 MU "Modal Units" 4.1 Motivation L. Monteiro and A. Porto [MP90] point out that in addition to the overriding/cumulation dimension, one more dimension in modes of inheritance can be discerned - that of syntactic/semantic . These two dimensions yield four different modes. In this section, we will study cumulative modes, postponing the discussion of overriding until Section 8. <p> u K [ u ] p [ u ] [ v ] q ,[ u ] r ,[ u ][ z ] s u,v u,z This clause involves a mixture of syntactic and semantic inheritance, but also message passing, showing MU to be even more powerful than the formalism of <ref> [MP90] </ref>. In the conventional OO notation, this clause could be written as: object v is ... method p is q; self:r, z:s ... 4.2 Formal In the formal presentation, we adhere to the terminology and denotations from [Che80] and [Cat88]. Proofs and technicalities can be found in [Uus91].
Reference: [MT90] <author> G. E. Mints and E. H. Tyugu. </author> <title> Propositional logic programing and the PRIZ system. </title> <editor> J. </editor> <booktitle> Logic Programming , 9(3) </booktitle> <pages> 179-93, </pages> <year> 1990. </year>
Reference-contexts: Our proposal, MU, falls under the third group of the above classification. There are solutions that do not restrict logic to mean just Horn clause logic, like FOOPlog [GM87] and Maude [Mes90], which put much emphasis on algebra (algebraic 3 specifications, rewriting), or PRIZ <ref> [MT90] </ref>, where deduction is used for synthesizing algorithms from specifications and not in execution.
Reference: [Nak84] <author> H. Nakashima. </author> <title> Knowledge representation in Prolog/KR. </title> <booktitle> In Proc. 1984 Int'l Symp. on Logic Programming , Atlantic City, </booktitle> <month> Feb </month> <year> 1984, </year> <pages> pp 126-30. </pages> <address> Silver Spring, MD: </address> <publisher> IEEE Comp. Soc. Press, </publisher> <year> 1984. </year>
Reference-contexts: Such inheritance is called cumulative . [Gal86] terms these modes of inheritance as call/return and success/failure , respectively. Most mergers use overriding inheritance. In Prolog/KR <ref> [Nak84] </ref>, ESP, and POL [Gal86], cumulation is the default. Overriding is facilitated through special language constructs (the simplest of them - cut - is readily available in Prolog). In CPU [MN87], the user has to metaprogram the inheritance semantics.
Reference: [Obe89] <author> A. </author> <title> Oberschelp. Ordersorted predicate logic. </title> <booktitle> In Sorts and Types in AI: Workshop Proc. </booktitle> , <address> Eringerfeld, </address> <month> April </month> <year> 1989, </year> <pages> pp 8-17. </pages> <address> Berlin: </address> <publisher> Springer-Verlag, </publisher> <address> 1989. </address> ( <publisher> LNAI , 418). </publisher>
Reference-contexts: In OO applications of the modal logic paradigm, the accessibility relation between worlds correlates with the isa relation. Sorting relies on many-sorted logics . Plain many-sorted logics offer no relation between sorts. To provide a counterpart for subtype/supertype (i.e. isa) relation, order-sorted logics have been developed (for overview, see <ref> [Obe89] </ref>). In those, a partial ordering on sorts is assumed which basically is a subsort/supersort relation . A good example of an ordersorted logic programming language is EPOS [HV87].
Reference: [ST83] <author> E. Shapiro and A. Takeuchi. </author> <title> Objectoriented programming in Concurrent Prolog. New Gener. </title> <booktitle> Computing , 1(1) </booktitle> <pages> 25-48, </pages> <year> 1983. </year>
Reference-contexts: 1 Introduction Since 1983-4 <ref> [ST83, Zan84] </ref>, more than 20 mergers of the OO and logic paradigms (see Section 2) have been proposed by different authors. Most of these aim at achieving some synergic effect, since the advantages that the two paradigms exhibit, are different. <p> Mergers with a logic base language are the most numerous. The historically earliest proposals by Shapiro and Takeuchi <ref> [ST83] </ref> and Zaniolo [Zan84] have had strong influence on the development of this group, and may thus be also viewed as belonging here, 2 even though they add no new syntax to their logic base languages, and only show how to program in the OO spirit, using the existing means.
Reference: [Uus91] <author> T. Uustalu. </author> <title> Combination of objectoriented and logic paradigms. </title> <type> MSc Thesis, </type> <institution> Tallinn Technical University, </institution> <year> 1991. </year>
Reference-contexts: Section 8 discusses practical issues in using the mentioned logics for programming. Section 9 points out conclusions and possible directions for future work. Proofs, as well as other technicalities, have been omitted in this paper. They can be found in <ref> [Uus91] </ref>. 2 Related Work 2.1 Mergers A good classification and study of mergers that had been suggested until 1987, has been presented in [LM88]. <p> In the conventional OO notation, this clause could be written as: object v is ... method p is q; self:r, z:s ... 4.2 Formal In the formal presentation, we adhere to the terminology and denotations from [Che80] and [Cat88]. Proofs and technicalities can be found in <ref> [Uus91] </ref>. To simplify the presentation, we shall consider propositional fragments everywhere. Section 4.3 gives hints for generalizations into the full predicate logic.
Reference: [VLM88] <author> J. Vaucher, G. Lapalme, and J. Malenfant. SCOOP: </author> <title> Structured Concurrent ObjectOriented Prolog. </title> <booktitle> In ECOOP'88: Proc. Europ. Conf. on OOP , Oslo, </booktitle> <month> Aug </month> <year> 1988, </year> <pages> pp 191-211. </pages> <address> Berlin: </address> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> ( <note> LNCS , 322). </note>
Reference-contexts: As it implies that attributes are dynamic, and as the most dynamic thing in generally static Prolog is predicates, there is ground for further generalizations. Attributes are dynamic, methods are static (and both are predicates). This is so in many mergers, and it is specifically emphasized in SCOOP <ref> [VLM88] </ref> and ObjVProlog [MLV89].
Reference: [Zan84] <author> C. Zaniolo. </author> <title> Objectoriented programming in Prolog. </title> <booktitle> In Proc. 1984 Int'l Symp. on Logic Programming , Atlantic City, </booktitle> <month> Feb </month> <year> 1984, </year> <pages> pp 265-70. </pages> <address> Silver Spring, MD: </address> <publisher> IEEE Comp. Soc. Press, </publisher> <year> 1984. </year> <month> 16 </month>
Reference-contexts: 1 Introduction Since 1983-4 <ref> [ST83, Zan84] </ref>, more than 20 mergers of the OO and logic paradigms (see Section 2) have been proposed by different authors. Most of these aim at achieving some synergic effect, since the advantages that the two paradigms exhibit, are different. <p> Mergers with a logic base language are the most numerous. The historically earliest proposals by Shapiro and Takeuchi [ST83] and Zaniolo <ref> [Zan84] </ref> have had strong influence on the development of this group, and may thus be also viewed as belonging here, 2 even though they add no new syntax to their logic base languages, and only show how to program in the OO spirit, using the existing means.
References-found: 38

