URL: http://www.ri.cmu.edu/afs/cs/user/fp/www/papers/CMU-CS-97-125.ps.gz
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/fp/www/homepage.html
Root-URL: 
Title: A Linear Spine Calculus  
Author: Iliano Cervesato and Frank Pfenning 
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: April 10, 1997  
Pubnum: CMU-CS-97-125  
Abstract: We present the spine calculus S !ffi&&gt; as an efficient representation for the linear -calculus !ffi&&gt; which includes intuitionistic functions (!), linear functions (ffi), additive pairing (&), and additive unit (&gt;). S !ffi&&gt; enhances the representation of Church's simply typed -calculus as abstract Bohm trees by enforcing extensionality and by incorporating linear constructs. This approach permits procedures such as unification to retain the efficient head access that characterizes first-order term languages without the overhead of performing -conversions at run time. Potential applications lie in proof search, logic programming, and logical frameworks based on linear type theories. We define the spine calculus, give translations of !ffi&&gt; into S !ffi&&gt; and vice-versa, prove their soundness and completeness with respect to typing and reductions, and show that the spine calculus is strongly normalizing and admits unique canonical forms. 
Abstract-found: 1
Intro-found: 1
Reference: [ACCL91] <author> Martn Abadi, Luca Cardelli, Pierre-Louis Curien, and Jean-Jacques Levy. </author> <title> Explicit substitutions. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(4) </volume> <pages> 375-416, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Systems embedding a higher-order term language, the logic programming languages Elf [Pfe91, Pfe94] and Prolog [NM88] for example, typically represent terms in a way that mimics the traditional definition of a -calculus. Ignoring common orthogonal optimizations such as the use of DeBruijn indices [dB72] or explicit substitutions <ref> [ACCL91] </ref>, the above term is parsed and encoded as (((f a) b) c). During unification, three applications (here represented as juxtaposition) must be traversed before accessing its head, possibly just to discover that it differs from the head of the term being unified. <p> An extension to the full language, which includes dependent types, does not appear to be problematic. The adoption of a spine calculus as an internal representation device appears to integrate well with the simultaneous use of explicit substitutions <ref> [ACCL91] </ref>. However, the details of the amalgamation of these two techniques in the presence of linearity still need to be worked out.
Reference: [Bar80] <author> H. P. Barendregt. </author> <title> The Lambda-Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <year> 1980. </year>
Reference-contexts: This approach, known as the Bohm tree representation, has been studied extensively for different purposes <ref> [Bar80, Her95] </ref>. However, the complex equational theory that characterizes a -calculus leads to difficulties in procedures such as unification and normalization. In particular, -conversion rules can yield instances of a same function symbol applied to a different number of arguments. <p> This approach was suggested by an empirical study of higher-order logic programs based on ! terms [MP92] and is reminiscent of the notion of abstract Bohm trees <ref> [Bar80, Her95] </ref>; its practical merits in our setting are currently assessed in an experimental implementation of a unification algorithm for LLF [Cer96, CP96] and a complete system for an extension of LF . <p> Notice that the target type of a well-typed spine is a base type. This has the desirable effect of permitting only -long terms to be derivable in this calculus: allowing arbitrary types on the right-hand side of the spine typing judgment corresponds to dropping this property. Abstract Bohm trees <ref> [Bar80, Her95] </ref> are obtained in this manner. The mutual definition of the two typing judgments of S !ffi&&gt; is given in Figure 3. The rules concerning terms resemble very closely the definition of the pre-canonical judgment of !ffi&&gt; , except for the treatment of heads. <p> In particular the absence of a stoup forces him to consider permutative conversions. The term calculus he proposes differs from Herbelin's by the absence of explicit concatenation operators and substitutions. It is therefore more similar to our spine calculus. Barendregt <ref> [Bar80] </ref> relies on an term language akin to our spine calculus to study the notion of normalization in the untyped -calculus. <p> The resulting language, the spine calculus S !ffi&&gt; , strengthens the natural adaptation of the notion of abstract Bohm tree <ref> [Bar80, Her95] </ref> to encompass extensional products (&), a unit type (&gt;) and linearity (ffi), with the further requirement that well-typed terms be in -long form. S !ffi&&gt; terms of base type are structured similarly to the objects found in first-order term languages.
Reference: [Bar96] <author> Andrew Barber. </author> <title> Dual intuitionistic linear logic. </title> <type> Technical Report ECS-LFCS-96-347, </type> <institution> Laboratory for Foundations of Computer Sciences, University if Edinburgh, </institution> <year> 1996. </year>
Reference-contexts: Its theoretical relevance derives from the fact that it is the biggest linear -calculus that admits unique long fi-normal forms. !ffi&&gt; shares similarities with the calculus proposed in <ref> [Bar96] </ref> and with the term language of the system RLF [IP96].
Reference: [Cer96] <author> Iliano Cervesato. </author> <title> A Linear Logical Framework. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Torino, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: wholesale translation investigated here (which is closer to an efficient implementation). !ffi&&gt; corresponds, via a natural extension of the Curry-Howard isomorphism, to the (! ffi &&gt;) fragment of intuitionistic linear logic, which constitutes the propositional core of the logic programming language Lolli [HM94] and of the linear logical framework LLF <ref> [Cer96, CP96] </ref>. !ffi&&gt; is also the simply-typed variant of the term language of LLF . <p> Linear terms provide a statically checkable notation for natural deductions [IP96] or sequent derivations [CP96] in substructural logics. In the realm of programming languages, linear terms naturally model computations in imperative languages [CP96] or sequences of moves in games <ref> [Cer96] </ref>. When we want to specify, manipulate, or reason about such objects (which is common in logic and the theory of programming languages), then internal linearity constraints are critical in practice (see, for example, the first formalizations of cut-elimination in linear logic and type preservation for Mini-ML with references [CP96]). <p> More precisely, we give its syntax in Section 2.1, present its typing semantics in Section 2.2 and its reduction semantics in Section 2.3. !ffi&&gt; is the simply-typed variant of the linear type theory ffi&&gt; , thoroughly analyzed in <ref> [Cer96] </ref>. <p> If we remove it, only -long fi-normal (or more succinctly canonical) terms can be derived. This formulation of the typing semantics of !ffi&&gt; is the simply-typed variant of the pre-canonical system which defines the semantics of the linear type theory underlying LLF <ref> [Cer96, CP96] </ref>. We direct the interested reader to these references for the proofs of the statements in this section. <p> Extensionality is formalized in the following lemma, which proof can be easily adapted from <ref> [Cer96] </ref>. Lemma 2.1 (Extensionality) i. If ; ` M * a, then M is one of c; x; fst N; snd N; N 1 ^N 2 ; N 1 N 2 ; ii . If ; ` M * &gt;, then M = hi; iii. <p> We adopt the standard terminology and call a term M that does not contain fi-redices normal, or fi-normal. When emphasizing the fact that our well-typed terms are -long, we will instead use the term canonical. Similarly to ! , !ffi&&gt; enjoys a number of highly desirable properties <ref> [Cer96] </ref>. <p> This approach was suggested by an empirical study of higher-order logic programs based on ! terms [MP92] and is reminiscent of the notion of abstract Bohm trees [Bar80, Her95]; its practical merits in our setting are currently assessed in an experimental implementation of a unification algorithm for LLF <ref> [Cer96, CP96] </ref> and a complete system for an extension of LF . The following grammar describes the syntax of S !ffi&&gt; : we write constructors as in !ffi&&gt; , but use new symbols to distinguish a spine operator from the corresponding term destructor. <p> The fragment of linear logic obtained by considering the types of !ffi&&gt; and S !ffi&&gt; as logic formulas is known as the language of (propositional) linear hereditary Harrop formulas <ref> [HM94, Cer96] </ref>. We denoted it ILL !ffi&&gt; in Section 2. This formalism is an abstract logic programming language and a uniform proof system for it, adapted from [Cer96], is reported in Figure 9. <p> We denoted it ILL !ffi&&gt; in Section 2. This formalism is an abstract logic programming language and a uniform proof system for it, adapted from <ref> [Cer96] </ref>, is reported in Figure 9. The uniform provability judgment ; ! A is subject to the application of the right introduction rules of a sequent calculus presentation of ILL !ffi&&gt; . <p> In particular, the spine calculus S !ffi&&gt; has been designed as a first approximation of an internal representation for the type theory ffi&&gt; underlying the linear logical framework LLF <ref> [Cer96, CP96] </ref>. An extension to the full language, which includes dependent types, does not appear to be problematic. The adoption of a spine calculus as an internal representation device appears to integrate well with the simultaneous use of explicit substitutions [ACCL91].
Reference: [Chu40] <author> Alonzo Church. </author> <title> A formulation of a simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year> <month> 31 </month>
Reference-contexts: In order to facilitate our description, we must assume the reader familiar with linear logic [Gir87]. 2 The Linear Simply-Typed Lambda Calculus !ffi&&gt; In this section, we introduce the linear simply-typed -calculus !ffi&&gt; , which augments Church's simply-typed -calculus ! <ref> [Chu40] </ref> with a number of operators from linear logic [Gir87]. More precisely, we give its syntax in Section 2.1, present its typing semantics in Section 2.2 and its reduction semantics in Section 2.3. !ffi&&gt; is the simply-typed variant of the linear type theory ffi&&gt; , thoroughly analyzed in [Cer96].
Reference: [CP96] <author> Iliano Cervesato and Frank Pfenning. </author> <title> A linear logical framework. </title> <editor> In E. Clarke, editor, </editor> <booktitle> Proceedings of the Eleventh Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 264-275, </pages> <address> New Brunswick, New Jersey, July 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: wholesale translation investigated here (which is closer to an efficient implementation). !ffi&&gt; corresponds, via a natural extension of the Curry-Howard isomorphism, to the (! ffi &&gt;) fragment of intuitionistic linear logic, which constitutes the propositional core of the logic programming language Lolli [HM94] and of the linear logical framework LLF <ref> [Cer96, CP96] </ref>. !ffi&&gt; is also the simply-typed variant of the term language of LLF . <p> The adoption of linear term languages in LLF and RLF has been motivated by a number of applications. Linear terms provide a statically checkable notation for natural deductions [IP96] or sequent derivations <ref> [CP96] </ref> in substructural logics. In the realm of programming languages, linear terms naturally model computations in imperative languages [CP96] or sequences of moves in games [Cer96]. <p> Linear terms provide a statically checkable notation for natural deductions [IP96] or sequent derivations <ref> [CP96] </ref> in substructural logics. In the realm of programming languages, linear terms naturally model computations in imperative languages [CP96] or sequences of moves in games [Cer96]. <p> When we want to specify, manipulate, or reason about such objects (which is common in logic and the theory of programming languages), then internal linearity constraints are critical in practice (see, for example, the first formalizations of cut-elimination in linear logic and type preservation for Mini-ML with references <ref> [CP96] </ref>). The principal contribution of this work is the definition of spine calculi (1) as a new representation technique for generic -calculi that permits both simple meta-reasoning and efficient implementations, and (2) as a term assignment system for the logic programming notion of uniform provability. <p> If we remove it, only -long fi-normal (or more succinctly canonical) terms can be derived. This formulation of the typing semantics of !ffi&&gt; is the simply-typed variant of the pre-canonical system which defines the semantics of the linear type theory underlying LLF <ref> [Cer96, CP96] </ref>. We direct the interested reader to these references for the proofs of the statements in this section. <p> This approach was suggested by an empirical study of higher-order logic programs based on ! terms [MP92] and is reminiscent of the notion of abstract Bohm trees [Bar80, Her95]; its practical merits in our setting are currently assessed in an experimental implementation of a unification algorithm for LLF <ref> [Cer96, CP96] </ref> and a complete system for an extension of LF . The following grammar describes the syntax of S !ffi&&gt; : we write constructors as in !ffi&&gt; , but use new symbols to distinguish a spine operator from the corresponding term destructor. <p> In particular, the spine calculus S !ffi&&gt; has been designed as a first approximation of an internal representation for the type theory ffi&&gt; underlying the linear logical framework LLF <ref> [Cer96, CP96] </ref>. An extension to the full language, which includes dependent types, does not appear to be problematic. The adoption of a spine calculus as an internal representation device appears to integrate well with the simultaneous use of explicit substitutions [ACCL91].
Reference: [CP97] <author> Iliano Cervesato and Frank Pfenning. </author> <title> Linear higher-order pre-unification. </title> <type> Technical report, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <year> 1997. </year> <month> Forthcoming. </month>
Reference-contexts: In particular, the implementation of formalisms based on a linear -calculus must perform higher-order unification on linear terms in order to instantiate existential variables <ref> [CP97] </ref>. The spine calculus S !ffi&&gt; was designed as an efficient representation for unification and normalization over the linear -expressions that can appear in an LLF specification. The adoption of linear term languages in LLF and RLF has been motivated by a number of applications. <p> Note that the interactions of rules unit and lapp can flatten distinct proofs to the same !ffi&&gt; term. Extensionality, i.e., the property of validating only -long terms, contributes to achieving the simple and elegant formulation of the pre-unification algorithm for !ffi&&gt; described in <ref> [CP97] </ref>. <p> Notice that x corresponds to the -long form of the variable x. 3 The Spine Calculus S !ffi&&gt; In this section, we present an alternative formulation of !ffi&&gt; , the spine calculus S !ffi&&gt; , that we suspect permits achieving more efficient implementation of critical procedures such as unification <ref> [CP97] </ref>. We describe the syntax, typing and reduction semantics of S !ffi&&gt; in Sections 3.1, 3.2 and 3.3, respectively.
Reference: [dB72] <author> N. G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: Systems embedding a higher-order term language, the logic programming languages Elf [Pfe91, Pfe94] and Prolog [NM88] for example, typically represent terms in a way that mimics the traditional definition of a -calculus. Ignoring common orthogonal optimizations such as the use of DeBruijn indices <ref> [dB72] </ref> or explicit substitutions [ACCL91], the above term is parsed and encoded as (((f a) b) c). During unification, three applications (here represented as juxtaposition) must be traversed before accessing its head, possibly just to discover that it differs from the head of the term being unified.
Reference: [DJ90] <editor> Nachum Dershowitz and Jean-Pierre Jouannaud. </editor> <booktitle> Handbook of Theoretical Computer Science, volume B, chapter Rewrite Systems, </booktitle> <pages> pages 243-320. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Proof. By simultaneous induction on the structure of R 0 and R 00 . 2 X Well-known results in term rewriting theory <ref> [DJ90] </ref> allow lifting this property, in the presence of termination, to the reflexive and transitive closure of S Corollary 3.6 (Confluence) If R 0 :: U ! fl S nil U 00 , then there is a term V such that R fl :: U 0 S ! fl and R
Reference: [Gir87] <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: In this paper, we will instead focus on the simply-typed linear -calculus !ffi&&gt; , which extends ! with the type constructors ffi, & and &gt;, derived from the identically denoted connectives of linear logic <ref> [Gir87] </ref>. We will define the cor 1 responding spine calculus S !ffi&&gt; , present translations between the two, and prove the meta-theoretical properties of S !ffi&&gt; that make it adequate as an internal representation language for !ffi&&gt; . <p> Further remarks are made in Section 6. Finally, Section 7 summarizes the work done, discusses applications and hints at future development. In order to facilitate our description, we must assume the reader familiar with linear logic <ref> [Gir87] </ref>. 2 The Linear Simply-Typed Lambda Calculus !ffi&&gt; In this section, we introduce the linear simply-typed -calculus !ffi&&gt; , which augments Church's simply-typed -calculus ! [Chu40] with a number of operators from linear logic [Gir87]. <p> In order to facilitate our description, we must assume the reader familiar with linear logic <ref> [Gir87] </ref>. 2 The Linear Simply-Typed Lambda Calculus !ffi&&gt; In this section, we introduce the linear simply-typed -calculus !ffi&&gt; , which augments Church's simply-typed -calculus ! [Chu40] with a number of operators from linear logic [Gir87]. More precisely, we give its syntax in Section 2.1, present its typing semantics in Section 2.2 and its reduction semantics in Section 2.3. !ffi&&gt; is the simply-typed variant of the linear type theory ffi&&gt; , thoroughly analyzed in [Cer96].
Reference: [Her95] <author> Hugo Herbelin. </author> <title> A -calculus structure isomorphic to Genzten-style sequent calculus structure. </title> <editor> In L. Pacholski and J. Tiuryn, editors, </editor> <booktitle> Computer Science Logic, Eighth Workshop | CSL'94, </booktitle> <pages> pages 61-75, </pages> <address> Kazimierz, Poland, 1995. </address> <publisher> Springer Verlag LNCS 933. </publisher>
Reference-contexts: This approach, known as the Bohm tree representation, has been studied extensively for different purposes <ref> [Bar80, Her95] </ref>. However, the complex equational theory that characterizes a -calculus leads to difficulties in procedures such as unification and normalization. In particular, -conversion rules can yield instances of a same function symbol applied to a different number of arguments. <p> A thorough investigation of a related calculus on the ! fragment has been conducted by Herbelin <ref> [Her95] </ref>. <p> This approach was suggested by an empirical study of higher-order logic programs based on ! terms [MP92] and is reminiscent of the notion of abstract Bohm trees <ref> [Bar80, Her95] </ref>; its practical merits in our setting are currently assessed in an experimental implementation of a unification algorithm for LLF [Cer96, CP96] and a complete system for an extension of LF . <p> Notice that the target type of a well-typed spine is a base type. This has the desirable effect of permitting only -long terms to be derivable in this calculus: allowing arbitrary types on the right-hand side of the spine typing judgment corresponds to dropping this property. Abstract Bohm trees <ref> [Bar80, Her95] </ref> are obtained in this manner. The mutual definition of the two typing judgments of S !ffi&&gt; is given in Figure 3. The rules concerning terms resemble very closely the definition of the pre-canonical judgment of !ffi&&gt; , except for the treatment of heads. <p> A first indirect reference appears in the seminal work of Howard on the types-as-formulas correspondence [How69], although a formal spine-like calculus is not defined. In <ref> [Her95] </ref>, Herbelin presents a systematic account of the relationship between the system LJT and the term language , which extends the ! restriction of our spine calculus with a spine concatenation operator and explicit substitutions. <p> The resulting language, the spine calculus S !ffi&&gt; , strengthens the natural adaptation of the notion of abstract Bohm tree <ref> [Bar80, Her95] </ref> to encompass extensional products (&), a unit type (&gt;) and linearity (ffi), with the further requirement that well-typed terms be in -long form. S !ffi&&gt; terms of base type are structured similarly to the objects found in first-order term languages.
Reference: [HHP93] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The benefits of the spine calculus representation, in conjunction with explicit substitutions, are currently assessed in a new implementation of the logical framework LF <ref> [HHP93] </ref> as the higher-order logic programming language Twelf, the successor of Elf [Pfe91, Pfe94]. LF is based on the type theory , a refinement of Church's simply-typed -calculus ! with dependent types. <p> The novel Twelf implementation of LF <ref> [HHP93] </ref> takes precisely these steps. The above corollary decrees that this way of proceeding is correct since if S produces a well-typed term, then the original !ffi&&gt; object is well-typed. In a similar fashion, we prove the completeness of S with respect to typing. <p> A variant of the spine calculus deprived of linear constructs, but featuring dependent types and explicit substitutions is currently tested in a new implementation of the linear framework LF <ref> [HHP93] </ref> as a higher-order constraint logic programming language. This system, called Twelf, is expected to supersede the Elf implementation of LF currently in use [Pfe91, Pfe94]. It will be available later this year.
Reference: [HM94] <author> Joshua Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuitionistic linear logic. </title> <journal> Information and Computation, </journal> <volume> 110(2) </volume> <pages> 327-365, </pages> <year> 1994. </year> <booktitle> A preliminary version appeared in the Proceedings of the Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 32-42, </pages> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: system which incorporates permutative conversions, instead of the wholesale translation investigated here (which is closer to an efficient implementation). !ffi&&gt; corresponds, via a natural extension of the Curry-Howard isomorphism, to the (! ffi &&gt;) fragment of intuitionistic linear logic, which constitutes the propositional core of the logic programming language Lolli <ref> [HM94] </ref> and of the linear logical framework LLF [Cer96, CP96]. !ffi&&gt; is also the simply-typed variant of the term language of LLF . <p> The implementation of a language based on a linear type theories such as LLF and RLF raises new challenges that do not emerge neither for intuitionistic languages such as Elf [Pfe94], nor in linear logic programming languages featuring plain intuitionistic terms such as Lolli <ref> [HM94] </ref> or Forum [Mil94]. In particular, the implementation of formalisms based on a linear -calculus must perform higher-order unification on linear terms in order to instantiate existential variables [CP97]. <p> If we ignore the terms and the distinction between the pre-canonical and the pre-atomic judgments, the rules in Figure 1 correspond to the specification of the familiar inference rules for the (! ffi&&gt;) fragment of intuitionistic linear logic, ILL !ffi&&gt; <ref> [HM94] </ref>, presented in a natural deduction style. <p> The fragment of linear logic obtained by considering the types of !ffi&&gt; and S !ffi&&gt; as logic formulas is known as the language of (propositional) linear hereditary Harrop formulas <ref> [HM94, Cer96] </ref>. We denoted it ILL !ffi&&gt; in Section 2. This formalism is an abstract logic programming language and a uniform proof system for it, adapted from [Cer96], is reported in Figure 9.
Reference: [How69] <author> W. A. Howard. </author> <title> The formulae-as-types notion of construction. </title> <type> Unpublished manuscript, </type> <year> 1969. </year> <note> Reprinted in To H. </note> <editor> B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <year> 1980. </year>
Reference-contexts: A similar proposal for term representation was already mentioned in passing by Howard in his seminal paper <ref> [How69] </ref>. The normal forms of the spine calculus also arise as a term assignment language for uniform proofs, which form the basis for abstract logic programming languages and is based on a much richer set of connectives [MNPS91]. <p> The similarity between the inference rules of uniform provability and the typing rules of S !ffi&&gt; indicates that our spine calculus is a natural term assignment system for uniform derivations. This sets the basis for a form of the Curry-Howard isomorphism <ref> [How69] </ref> between normal, well-typed S !ffi&&gt; terms and valid uniform derivations in ILL !ffi&&gt; . 6.3 Related Work The uniform derivation system given in Figure 9 is a presentation of the sequent calculus for ILL !ffi&&gt; that embeds restrictions on the applicability of inference rules. <p> The strong relationship between intuition istic fragment of sequent calculi (not necessarily linear) and term languages akin to our spine calculus has been already noticed in the literature. A first indirect reference appears in the seminal work of Howard on the types-as-formulas correspondence <ref> [How69] </ref>, although a formal spine-like calculus is not defined. In [Her95], Herbelin presents a systematic account of the relationship between the system LJT and the term language , which extends the ! restriction of our spine calculus with a spine concatenation operator and explicit substitutions.
Reference: [IP96] <author> Samin Ishtiaq and David Pym. </author> <title> A relevant analysis of natural deduction, </title> <month> December </month> <year> 1996. </year> <type> Manuscript. </type>
Reference-contexts: Its theoretical relevance derives from the fact that it is the biggest linear -calculus that admits unique long fi-normal forms. !ffi&&gt; shares similarities with the calculus proposed in [Bar96] and with the term language of the system RLF <ref> [IP96] </ref>. The implementation of a language based on a linear type theories such as LLF and RLF raises new challenges that do not emerge neither for intuitionistic languages such as Elf [Pfe94], nor in linear logic programming languages featuring plain intuitionistic terms such as Lolli [HM94] or Forum [Mil94]. <p> The adoption of linear term languages in LLF and RLF has been motivated by a number of applications. Linear terms provide a statically checkable notation for natural deductions <ref> [IP96] </ref> or sequent derivations [CP96] in substructural logics. In the realm of programming languages, linear terms naturally model computations in imperative languages [CP96] or sequences of moves in games [Cer96].
Reference: [JG95] <author> C. Barry Jay and Neil Ghani. </author> <title> The virtues of eta-expansion. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(5) </volume> <pages> 135-154, </pages> <year> 1995. </year>
Reference-contexts: Moreover, -calculi featuring a unit type and a unit element do not admit subject reduction unless all terms are -expanded <ref> [JG95] </ref>: this means that typing information must be stored and maintained in otherwise type-free procedures such as unification.
Reference: [Mil94] <editor> Dale Miller. A multiple-conclusion meta-logic. In S. Abramsky, editor, </editor> <booktitle> Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 272-281, </pages> <address> Paris, France, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: The implementation of a language based on a linear type theories such as LLF and RLF raises new challenges that do not emerge neither for intuitionistic languages such as Elf [Pfe94], nor in linear logic programming languages featuring plain intuitionistic terms such as Lolli [HM94] or Forum <ref> [Mil94] </ref>. In particular, the implementation of formalisms based on a linear -calculus must perform higher-order unification on linear terms in order to instantiate existential variables [CP97].
Reference: [MNPS91] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: The normal forms of the spine calculus also arise as a term assignment language for uniform proofs, which form the basis for abstract logic programming languages and is based on a much richer set of connectives <ref> [MNPS91] </ref>. A thorough investigation of a related calculus on the ! fragment has been conducted by Herbelin [Her95]. <p> Further flexibility can be achieved by relieving the user from the requirement of writing terms in -long form only: subterms can be expanded as soon as their type has been inferred as a result of type checking. 6.2 Relationship to Uniform Provability An abstract logic programming language <ref> [MNPS91] </ref> is a fragment of a logic such that every derivable se quent has a uniform derivation.
Reference: [MP92] <author> Spiro Michaylov and Frank Pfenning. </author> <title> An empirical study of the runtime behavior of higher-order logic programs. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proceedings of the Workshop on the Prolog Programming Language, </booktitle> <pages> pages 257-271, </pages> <address> Philadelphia, Pennsylvania, </address> <month> July </month> <year> 1992. </year> <institution> University of Pennsylvania. </institution> <note> Available as Technical Report MS-CIS-92-86. </note>
Reference-contexts: Application and ";" have opposite associativity so that M 1 is the innermost subterm of M while U 1 is outermost in the spine of U . This approach was suggested by an empirical study of higher-order logic programs based on ! terms <ref> [MP92] </ref> and is reminiscent of the notion of abstract Bohm trees [Bar80, Her95]; its practical merits in our setting are currently assessed in an experimental implementation of a unification algorithm for LLF [Cer96, CP96] and a complete system for an extension of LF .
Reference: [NM88] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Fifth International Logic Programming Conference, </booktitle> <pages> pages 810-827, </pages> <address> Seattle, Wash-ington, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: This is sensible from the point of view of unification since the head of a terms must be analyzed before its arguments. Systems embedding a higher-order term language, the logic programming languages Elf [Pfe91, Pfe94] and Prolog <ref> [NM88] </ref> for example, typically represent terms in a way that mimics the traditional definition of a -calculus. Ignoring common orthogonal optimizations such as the use of DeBruijn indices [dB72] or explicit substitutions [ACCL91], the above term is parsed and encoded as (((f a) b) c).
Reference: [Pfe91] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: This is sensible from the point of view of unification since the head of a terms must be analyzed before its arguments. Systems embedding a higher-order term language, the logic programming languages Elf <ref> [Pfe91, Pfe94] </ref> and Prolog [NM88] for example, typically represent terms in a way that mimics the traditional definition of a -calculus. Ignoring common orthogonal optimizations such as the use of DeBruijn indices [dB72] or explicit substitutions [ACCL91], the above term is parsed and encoded as (((f a) b) c). <p> The benefits of the spine calculus representation, in conjunction with explicit substitutions, are currently assessed in a new implementation of the logical framework LF [HHP93] as the higher-order logic programming language Twelf, the successor of Elf <ref> [Pfe91, Pfe94] </ref>. LF is based on the type theory , a refinement of Church's simply-typed -calculus ! with dependent types. <p> This system, called Twelf, is expected to supersede the Elf implementation of LF currently in use <ref> [Pfe91, Pfe94] </ref>. It will be available later this year. Acknowledgments We would like to thank Carsten Schurmann for the insight he provided as a co-implementor of Twelf and through numerous discussions.
Reference: [Pfe94] <author> Frank Pfenning. </author> <title> Elf: A meta-language for deductive systems. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <pages> pages 811-815, </pages> <address> Nancy, France, </address> <month> June </month> <year> 1994. </year> <note> Springer-Verlag LNAI 814. System abstract. </note>
Reference-contexts: This is sensible from the point of view of unification since the head of a terms must be analyzed before its arguments. Systems embedding a higher-order term language, the logic programming languages Elf <ref> [Pfe91, Pfe94] </ref> and Prolog [NM88] for example, typically represent terms in a way that mimics the traditional definition of a -calculus. Ignoring common orthogonal optimizations such as the use of DeBruijn indices [dB72] or explicit substitutions [ACCL91], the above term is parsed and encoded as (((f a) b) c). <p> The benefits of the spine calculus representation, in conjunction with explicit substitutions, are currently assessed in a new implementation of the logical framework LF [HHP93] as the higher-order logic programming language Twelf, the successor of Elf <ref> [Pfe91, Pfe94] </ref>. LF is based on the type theory , a refinement of Church's simply-typed -calculus ! with dependent types. <p> The implementation of a language based on a linear type theories such as LLF and RLF raises new challenges that do not emerge neither for intuitionistic languages such as Elf <ref> [Pfe94] </ref>, nor in linear logic programming languages featuring plain intuitionistic terms such as Lolli [HM94] or Forum [Mil94]. In particular, the implementation of formalisms based on a linear -calculus must perform higher-order unification on linear terms in order to instantiate existential variables [CP97]. <p> This system, called Twelf, is expected to supersede the Elf implementation of LF currently in use <ref> [Pfe91, Pfe94] </ref>. It will be available later this year. Acknowledgments We would like to thank Carsten Schurmann for the insight he provided as a co-implementor of Twelf and through numerous discussions.
Reference: [Sch97] <author> Helmut Schwichtenberg. </author> <title> Termination of permutative conversions in intuitionistic Gentzen calculi. </title> <type> Manuscript, </type> <month> March </month> <year> 1997. </year> <month> 32 </month>
Reference-contexts: A thorough investigation of a related calculus on the ! fragment has been conducted by Herbelin [Her95]. Schwichtenberg <ref> [Sch97] </ref> studies a version of the intuitionistic spine representation and ordinary -calculi in a single system which incorporates permutative conversions, instead of the wholesale translation investigated here (which is closer to an efficient implementation). !ffi&&gt; corresponds, via a natural extension of the Curry-Howard isomorphism, to the (! ffi &&gt;) fragment of <p> Indeed, its reduction rules 30 correspond to the steps in a cut-elimination procedure for LJT, so that strong normalization theorem for subsumes the cut-elimination property for this logic. Schwichtenberg <ref> [Sch97] </ref> adopts a similar approach relatively to a richer logic consisting of implication, conjunction and universal quantification. He starts from a more traditional presentation of the sequent calculus. In particular the absence of a stoup forces him to consider permutative conversions.
References-found: 23

