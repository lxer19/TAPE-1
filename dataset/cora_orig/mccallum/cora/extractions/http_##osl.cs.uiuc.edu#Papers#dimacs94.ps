URL: http://osl.cs.uiuc.edu/Papers/dimacs94.ps
Refering-URL: http://osl.cs.uiuc.edu/Papers/Parallel.html
Root-URL: http://www.cs.uiuc.edu
Title: Actor Languages for Specification of Parallel Computations  
Author: GUL AGHA, WOOYOUNG KIM AND RAJENDRA PANWAR 
Note: DIMACS Series in Discrete Mathematics and Theoretical Computer Science Volume 00, 0000  
Abstract: We describe high-level language constructs for specifying parallel programs and show how they may be used to provide modular specification of communication, synchronization and placement. The high-level constructs are translated into actors which provide flexible low-level primitives for interconnecting distributed components and efficient execution on concurrent computers. We argue that our linguistic constructs allow parallel program specifications that are easier to reason about and efficient to implement. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> G. Agha, </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems, </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Moreover, we define a meta-architecture which provides a flexible execution model for actors. In particular, this meta-architecture is used to specify the placement or migration policy for a group of actors. The Actor model was first described by Hewitt [17] and later developed in <ref> [1] </ref>. A mathematical theory of actors is developed in [4]. ACTOR LANGUAGES FOR SPECIFICATION 5 3. Cholesky Factorization in Actors We illustrate the actor operators by providing some example programs.
Reference: 2. <author> G. Agha, S. Frtlund, W. Kim, R. Panwar, A. Patterson, and D. Sturman, </author> <title> Abstraction and Modularity Mechanisms for Concurrent Computing, </title> <booktitle> IEEE Parallel and Distributed Technology: Systems and Applications 1 (1993), </booktitle> <volume> no. 2, </volume> <pages> 3-14. </pages>
Reference-contexts: If the replacement behavior of the sender is dependent on the result, a continuation method will be generated. Otherwise, a continuation actor will be generated <ref> [21, 2] </ref>. <p> It should be observed that the synchronization constraints we discuss have some important limitations: because they depend only on the local state of a single actor, they are unsatisfactory for describing collective multiactor coordination patterns. Such coordination patterns may be expressed in the form of synchronizers <ref> [2, 15] </ref>. Synchronizers allow us to specify multiactor constraints such as temporal ordering constraints on invocations and invocation atomicity constraints. A synchronizer is specified in terms of the interface of a group of actors, and independently of their functionality.
Reference: 3. <author> G. Agha, C. Houck, and R. Panwar, </author> <title> Distributed Execution of Actor Systems, Languages and Compilers for Parallel Computing (D. </title> <editor> Gelernter, T. Gross, A. Nicolau, and D. Padua, eds.), </editor> <publisher> Springer-Verlag, </publisher> <year> 1992, </year> <booktitle> Lecture Notes in Computer Science 589, </booktitle> <pages> pp. 1-17. </pages>
Reference-contexts: In fact, without such pipelining, the Cholesky Decomposition algorithm is not scalable. We show this by looking at a specific analytic measure for scalability. An experimental measurements, reported elsewhere, also confirm the prediction of the analytic model <ref> [3] </ref>. The isoefficiency function specifies how a problem size must grow to keep the constant efficiency as the number of processors, p, increases.
Reference: 4. <author> G. Agha, I. Mason, S. Smith, and C. Talcott, </author> <title> Towards a Theory of Actor Computation, </title> <booktitle> Third International Conference on Concurrency Theory (CONCUR '92), </booktitle> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1992, </year> <pages> LNCS, pp. 565-579. </pages>
Reference-contexts: In particular, this meta-architecture is used to specify the placement or migration policy for a group of actors. The Actor model was first described by Hewitt [17] and later developed in [1]. A mathematical theory of actors is developed in <ref> [4] </ref>. ACTOR LANGUAGES FOR SPECIFICATION 5 3. Cholesky Factorization in Actors We illustrate the actor operators by providing some example programs. In particular, because we are extending a sequential language, actor programs with different concurrency characteristics may be specified to implement the same algorithm.
Reference: 5. <editor> G. Agha, P. Wegner, and A. Yonezawa (eds.), </editor> <booktitle> Research Directions in Concurrent Object-Oriented Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Massachussets, </address> <year> 1993. </year>
Reference-contexts: A member actor is referred to by ACTOR LANGUAGES FOR SPECIFICATION 11 specifying its group identifier and an index expression. For example, the execu tion of the following method fragment: a = B.grpnew (16); a <ref> [5] </ref> a message (); sends a message message to the fifth member actor of the group. In order to allow member actors to name the group to which they belong, Hal provides for pseudo-variables mygrp and mygrpidx . <p> For a more detailed discussion of modular placement specifications, see [25]. 8. Discussion Concurrent object oriented programming is an active area of research interest <ref> [5, 9] </ref>. The programming constructs used in many concurrent object oriented 18 GUL AGHA, WOOYOUNG KIM AND RAJENDRA PANWAR languages are closely related to those in actors (e.g., Cantor [6], ABCL [26], Concurrent Aggregates [11] and Charm [20]).
Reference: 6. <author> W. Athas and C. Seitz, </author> <title> Multicomputers: Message-Passing Concurrent Computers, </title> <booktitle> IEEE Computer (1988), </booktitle> <pages> 9-23. </pages>
Reference-contexts: Discussion Concurrent object oriented programming is an active area of research interest [5, 9]. The programming constructs used in many concurrent object oriented 18 GUL AGHA, WOOYOUNG KIM AND RAJENDRA PANWAR languages are closely related to those in actors (e.g., Cantor <ref> [6] </ref>, ABCL [26], Concurrent Aggregates [11] and Charm [20]). In some cases, there are also fundamental differences between the different models of concurrent objects. For example, CC++ is one of several proposals to extend C++ with concurrency constructs.
Reference: 7. <author> P. Mehrotra C. Koelbel, </author> <title> Compiling Global Name-space Parallel loops for Distibuted Execution, </title> <journal> IEEE Transactions on Parallel and Distributed Systems 2 (1991), </journal> <volume> no. 4, </volume> <pages> 440-451. </pages>
Reference-contexts: For irregular problems, such as PDEs on unstructured mesh or sparse matrix algorithms, the communication pattern depends on the input data. In this case, it is not feasible to figure out the necessary data distribution a priori. To address this problem, PARTI [13] and Kali <ref> [7] </ref> transform a user-defined for loop to a inspector/executor pair. The inspector loop determines what data are needed for each processor and where they are and prefetches them to localize them. Later, the executor uses the prefetched data to perform the computation specified in the original loop.
Reference: 8. <author> C. J. Callsen and G. A. Agha, </author> <title> Open Heterogeneous Computing in ActorSpace, </title> <journal> Journal of Parallel and Distributed Computing (1994), </journal> <pages> 289-300. </pages>
Reference-contexts: Moreover, copying the message for each member actor may be avoided. A general framework for modeling groups is the ActorSpace paradigm <ref> [8] </ref> which provides group abstractions as a key component of its semantics. Ac-torSpace adopts the pattern-based model of communication. Messages may be sent to groups of actors; patterns are used to define such groups. <p> By contrast, an actor provides both a data abstraction boundary and a unit of concurrency. The operational semantics of the group abstraction we use here is a particular form of the ActorSpace paradigm <ref> [8] </ref>. ActorSpace uses communication based on destination patterns. In Hal, a restricted model of patterns provides greater efficiency at the cost of expressiveness. Another restrict model of actor groups is Concurrent Aggregates which supports static membership [11].
Reference: 9. <author> Denis Caromel, </author> <title> Toward a Method of Object-Oriented Concurrent Programming, </title> <journal> Communications of the ACM 36 (1993), </journal> <volume> no. 9, </volume> <pages> 90-102. </pages>
Reference-contexts: For a more detailed discussion of modular placement specifications, see [25]. 8. Discussion Concurrent object oriented programming is an active area of research interest <ref> [5, 9] </ref>. The programming constructs used in many concurrent object oriented 18 GUL AGHA, WOOYOUNG KIM AND RAJENDRA PANWAR languages are closely related to those in actors (e.g., Cantor [6], ABCL [26], Concurrent Aggregates [11] and Charm [20]).
Reference: 10. <author> K. M. Chandy and C. Kesselman, </author> <title> Compositional C++: Compositional parallel programming, Research Directions in Object-Oriented Programming (G. </title> <editor> Agha, P. Wegner, and A. Yonezawa, eds.), </editor> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: In some cases, there are also fundamental differences between the different models of concurrent objects. For example, CC++ is one of several proposals to extend C++ with concurrency constructs. CC++ adds parallel programming constructs such as par , parfor and spawn to C++ <ref> [10] </ref>. Much as message passing and actor creation do in actors, such constructs provide for functional parallelism as well as explicit concurrency. However, unlike actors, CC++ objects do not necessarily represent units of con-currency: multiple threads may be active in a given object.
Reference: 11. <author> A. Chien, </author> <title> Supporting Modularity in Highly-Parallel Programs, Research Directions in Object-Oriented Programming (G. </title> <editor> Agha, P. Wegner, and A. Yonezawa, eds.), </editor> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Discussion Concurrent object oriented programming is an active area of research interest [5, 9]. The programming constructs used in many concurrent object oriented 18 GUL AGHA, WOOYOUNG KIM AND RAJENDRA PANWAR languages are closely related to those in actors (e.g., Cantor [6], ABCL [26], Concurrent Aggregates <ref> [11] </ref> and Charm [20]). In some cases, there are also fundamental differences between the different models of concurrent objects. For example, CC++ is one of several proposals to extend C++ with concurrency constructs. CC++ adds parallel programming constructs such as par , parfor and spawn to C++ [10]. <p> ActorSpace uses communication based on destination patterns. In Hal, a restricted model of patterns provides greater efficiency at the cost of expressiveness. Another restrict model of actor groups is Concurrent Aggregates which supports static membership <ref> [11] </ref>. It should be observed that the synchronization constraints we discuss have some important limitations: because they depend only on the local state of a single actor, they are unsatisfactory for describing collective multiactor coordination patterns. Such coordination patterns may be expressed in the form of synchronizers [2, 15].
Reference: 12. <author> W. Clinger, </author> <title> Foundations of Actor Semantics, </title> <type> AI-TR- 633, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> May </month> <year> 1981. </year>
Reference-contexts: Note that events in a distributed system are partially ordered but may be mapped to a linear global time as they may be observed by a hypothetical observer <ref> [12] </ref>. In intuitive terms, a fixed placement policy for a computation performed by a group of actors places the actors before the computation starts and doesn't change their location during the computation. A placement policy which is not fixed is said to be dynamic.
Reference: 13. <author> R. Das, R. Ponnusamy, J. Saltz, and D. Mavriplis, </author> <title> Distributed Memory Compiler Methods for Irregular Problems Data Copy Reuse and Runtime Partitioning, Languages, Compilers and Run-Time Environments for Distributed Memory Machines (J. </title> <editor> Saltz and P. Mehrotra, eds.), </editor> <publisher> Elsevier Science Publishers, </publisher> <year> 1992. </year>
Reference-contexts: For irregular problems, such as PDEs on unstructured mesh or sparse matrix algorithms, the communication pattern depends on the input data. In this case, it is not feasible to figure out the necessary data distribution a priori. To address this problem, PARTI <ref> [13] </ref> and Kali [7] transform a user-defined for loop to a inspector/executor pair. The inspector loop determines what data are needed for each processor and where they are and prefetches them to localize them. Later, the executor uses the prefetched data to perform the computation specified in the original loop.
Reference: 14. <author> S. Frtlund, </author> <title> Inheritance of Synchronization Constraints in Concurrent Object-Oriented Programming Languages, </title> <booktitle> ECOOP'92 European Conference on Object-Oriented Programming (O. </booktitle> <editor> Lehrmann Madsen, ed.), </editor> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1992, </year> <booktitle> Lecture Notes in Computer Science 615, </booktitle> <pages> pp. 185-196. </pages>
Reference-contexts: Moreover, synchronization constraints can be incrementally modified when used with an inheritance mechanism, provided that they are specified on a per class basis and separated from method definitions <ref> [14] </ref>. In particular, such constraints may be incrementally weakened allowing substitutability of subclasses 10 GUL AGHA, WOOYOUNG KIM AND RAJENDRA PANWAR with respect to liveness properties, strengthened allowing substitutability of subclasses with respect to safety properties, or replaced entirely. 5.
Reference: 15. <author> S. Frtlund and G. Agha, </author> <title> A Language Framework for Multi-Object Coordination, </title> <booktitle> Proceedings of the European Conference on Object-Oriented Programming '93, </booktitle> <publisher> Springer Verlag, </publisher> <address> 1993, </address> <publisher> LNCS 707, </publisher> <pages> pp. 346-360. </pages>
Reference-contexts: It should be observed that the synchronization constraints we discuss have some important limitations: because they depend only on the local state of a single actor, they are unsatisfactory for describing collective multiactor coordination patterns. Such coordination patterns may be expressed in the form of synchronizers <ref> [2, 15] </ref>. Synchronizers allow us to specify multiactor constraints such as temporal ordering constraints on invocations and invocation atomicity constraints. A synchronizer is specified in terms of the interface of a group of actors, and independently of their functionality.
Reference: 16. <author> G. Golub and C. Van Loan, </author> <title> Matrix Computations, </title> <publisher> The Johns Hopkins University Press, </publisher> <year> 1983. </year>
Reference-contexts: For a given symmetric positive definite matrix A of size n fi n the Cholesky Factorization algorithm computes a lower triangular matrix L, of size n fi n such that A = LL T <ref> [16] </ref>. The algorithm may be described as follows: A i1 = A i1 = A 11 , 1 i n (0) A ij = A ij k=1 A ij = A ij = A jj , j i n (2) the Cholesky Decomposition algorithm.
Reference: 17. <author> C. Hewitt, </author> <title> Viewing Control Structures as Patterns of Passing Messages, </title> <journal> Journal of Artificial Intelligence 8 (1977), </journal> <volume> no. 3, </volume> <pages> 323-364. </pages>
Reference-contexts: Moreover, we define a meta-architecture which provides a flexible execution model for actors. In particular, this meta-architecture is used to specify the placement or migration policy for a group of actors. The Actor model was first described by Hewitt <ref> [17] </ref> and later developed in [1]. A mathematical theory of actors is developed in [4]. ACTOR LANGUAGES FOR SPECIFICATION 5 3. Cholesky Factorization in Actors We illustrate the actor operators by providing some example programs.
Reference: 18. <author> S. Hiranandani, K. Kennedy, and C.-W. Tseng, </author> <title> Compiling Fortran-D for MIMD Dis 20 GUL AGHA, WOOYOUNG KIM AND RAJENDRA PANWAR tributed Memory Machines, </title> <journal> Communications of the ACM 35 (1992), </journal> <volume> no. 8, </volume> <pages> 66-80. </pages>
Reference-contexts: Thus synchronizers separate the code for coordination from that for the actors' functionality, enabling better description, reasoning, and modification. Our methodology for modular specification of placement and migration of actors bears resemblance to some extensions of Fortran. In particular, Fortran-D <ref> [18] </ref> and High Performance Fortran (HPF) [23] allow explicit specification of data decomposition and distribution policies to improve execution on distributed memory computers. For irregular problems, such as PDEs on unstructured mesh or sparse matrix algorithms, the communication pattern depends on the input data.
Reference: 19. <author> C. A. R. Hoare, </author> <title> Communicating Sequential Processes, </title> <journal> Communications of the ACM 21 (1978), </journal> <volume> no. 8, </volume> <pages> 666-677. </pages>
Reference-contexts: By explicitly postponing certain messages, synchronization constraints can guarantee the correct order of message reception, and thus, data consistency of the receiving actor. Moreover, synchronization constraints, unlike input guards in conventional process oriented languages <ref> [19] </ref>, do not cause the ACTOR LANGUAGES FOR SPECIFICATION 9 sender to wait until such time when the recipient is in a state in which it can process the message. Thus synchronization constraints ensure maximal overlap of computation and communication.
Reference: 20. <author> L. V. Kale and S. Krishnan, CHARM++: </author> <title> A Portable Concurrent Object Oriented System Based On C++, OOPSLA 93' (Andreas Paepcke, </title> <editor> ed.), </editor> <publisher> ACM Press, </publisher> <month> October </month> <year> 1993, </year> <journal> ACM SIGPLAN Notices 28(10). </journal>
Reference-contexts: Discussion Concurrent object oriented programming is an active area of research interest [5, 9]. The programming constructs used in many concurrent object oriented 18 GUL AGHA, WOOYOUNG KIM AND RAJENDRA PANWAR languages are closely related to those in actors (e.g., Cantor [6], ABCL [26], Concurrent Aggregates [11] and Charm <ref> [20] </ref>). In some cases, there are also fundamental differences between the different models of concurrent objects. For example, CC++ is one of several proposals to extend C++ with concurrency constructs. CC++ adds parallel programming constructs such as par , parfor and spawn to C++ [10].
Reference: 21. <author> W. Kim and G. Agha, </author> <title> Compilation of a Highly Parallel Actor-Based Language, </title> <booktitle> Proceedings of the Workshop on Languages and Compilers for Parallel Computing (U. </booktitle> <editor> Banerjee, D. Gelernter, A. Nicolau, and D. Padua, eds.), </editor> <publisher> Yale University, Springer-Verlag, </publisher> <year> 1993, </year> <note> LNCS 757. </note>
Reference-contexts: If the replacement behavior of the sender is dependent on the result, a continuation method will be generated. Otherwise, a continuation actor will be generated <ref> [21, 2] </ref>.
Reference: 22. <author> V. Kumar, A. Grama, A. Gupta, and G. Karypis, </author> <title> Introduction to Parallel Computing: Design and Analysis of Algorithms, </title> <publisher> Benjamin/Cummings Publishing Company, Inc., </publisher> <year> 1994. </year>
Reference-contexts: A small isoefficiency function means that a small increment in the problem size is sufficient for the efficient utilization of an increasing number of processors, indicating the parallel algorithm is highly scalable. For more detailed discussion of the isoefficiency function, see <ref> [22] </ref>. Using isoefficiency functions, Table 1 compares the scalability of the Cholesky Decomposition algorithm using sequentialized iterations with that using pipelined iterations on a mesh multicomputer. <p> Figures 6 and 7 show the calling pattern of the execution before and after the transformation, respectively. In this case, the transformation has generated a continuation actor. We illustrate the use of call/return communication with the implementation of bitonic merge network used in bitonic sort algorithm <ref> [22] </ref>. The behavior template BitonicMergingNetwork in Figure 8 implements a key operation of the bitonic sorting network which rearranges a bitonic sequence into a monotonically increasing sequence. A member actor encapsulates an element of the input bitonic sequence. <p> A dense 16 GUL AGHA, WOOYOUNG KIM AND RAJENDRA PANWAR matrix may be partitioned on a parallel computer using different placement strategies (see, for example, <ref> [22] </ref>). In general, the problem of finding an optimal policy is intractable. However, a developer might be able to determine the most efficient policy for a given algorithm and a given architecture.
Reference: 23. <author> David. B. Loveman, </author> <title> High Performance Fortran, </title> <booktitle> Parallel & Distributed Technology, Systems & Applications 1 (1993), </booktitle> <volume> no. 1, </volume> <pages> 25-42. </pages>
Reference-contexts: Thus synchronizers separate the code for coordination from that for the actors' functionality, enabling better description, reasoning, and modification. Our methodology for modular specification of placement and migration of actors bears resemblance to some extensions of Fortran. In particular, Fortran-D [18] and High Performance Fortran (HPF) <ref> [23] </ref> allow explicit specification of data decomposition and distribution policies to improve execution on distributed memory computers. For irregular problems, such as PDEs on unstructured mesh or sparse matrix algorithms, the communication pattern depends on the input data.
Reference: 24. <editor> P. Mehrotra, J. Saltz, and R. Voigt (eds.), </editor> <title> Unstructured Scientific Computation on Scalable Multiprocessors, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachussets, </address> <year> 1992. </year>
Reference-contexts: Similarly, the topology between nodes in a binary search tree and its structure may depend on the order in which the data elements are added to the tree. For a good review of parallel algorithms which naturally use dynamic data structures, see <ref> [24] </ref>. Dynamic placement policies may need to interact with the ongoing computation to place newly created actors or to migrate existing ones. In some cases, installation of placement decisions for dynamic placement policies may be triggered by messages which mark the beginning of a particular phase of the computation.
Reference: 25. <author> Rajendra Panwar and Gul Agha, </author> <title> A Methodology for Programming Scalable Architectures, </title> <journal> Journal of Parallel and Distributed Computing (1994), </journal> <note> (to appear). </note>
Reference-contexts: For a more detailed discussion of modular placement specifications, see <ref> [25] </ref>. 8. Discussion Concurrent object oriented programming is an active area of research interest [5, 9].
Reference: 26. <author> K. Taura, S. Matsuoka, and A. Yonezawa, </author> <title> An Efficient Implementation Scheme of Concurrent Object-Oriented Languages on Stock Multicomputers, </title> <booktitle> Fourth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming PPOPP, </booktitle> <month> May </month> <year> 1993, </year> <pages> pp. 218-228. </pages>
Reference-contexts: Discussion Concurrent object oriented programming is an active area of research interest [5, 9]. The programming constructs used in many concurrent object oriented 18 GUL AGHA, WOOYOUNG KIM AND RAJENDRA PANWAR languages are closely related to those in actors (e.g., Cantor [6], ABCL <ref> [26] </ref>, Concurrent Aggregates [11] and Charm [20]). In some cases, there are also fundamental differences between the different models of concurrent objects. For example, CC++ is one of several proposals to extend C++ with concurrency constructs.
Reference: 27. <author> C. Tomlinson and V. Singh, </author> <title> Inheritance and Synchronization with Enabled-Sets, </title> <booktitle> OOPSLA Proceedings, </booktitle> <year> 1989. </year> <institution> Open Systems Laboratory, Department of Computer Science, 1304 W. Springfield Avenue, University of Illinois at Urbana-Champaign, Urbana, </institution> <address> IL 61801, USA E-mail address: fagha j wooyoung j panwarg@cs.uiuc.edu </address>
Reference-contexts: Such messages are put into the actor's pending queue and wait to be processed until the state changes cause it to be no longer disabled. Using synchronization constraints is similar to, but more general than, the notion of enabled sets <ref> [27] </ref>. In enabled sets, a method cannot be enabled for some messages while disabled for others.
References-found: 27

