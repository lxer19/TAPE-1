URL: ftp://athos.rutgers.edu/pub/technical-reports/lcsr-tr-201.ps.Z
Refering-URL: http://www.csd.uu.se/~thomasl/wpo/alias-papers.html
Root-URL: 
Email: blandi@scr.siemens.com  
Title: Interprocedural Modification Side Effect Analysis With Pointer Aliasing  
Author: William Landi Barbara G. Ryder Sean Zhang 
Address: 755 College Rd. East Princeton, NJ 08540  
Affiliation: Siemens Corporate Research Inc  
Abstract: Department of Computer Science Rutgers University Hill Center, Busch Campus New Brunswick, NJ 08903 ryder@cs.rutgers.edu xxzhang@cs.rutgers.edu Abstract We present a new interprocedural modification side effects algorithm for C programs, that can discern side effects through general-purpose pointer usage. Ours is the first complete design and implementation of such an algorithm. Preliminary performance findings support the practicality of the technique, which is based on our previous approximation algorithm for pointer aliases [LR92]. Each indirect store through a pointer variable is found, on average, to correspond to a store into 1.2 locations. This indicates that our program-point-specific pointer aliasing information is quite precise when used to determine the effects of these stores.
Abstract-found: 1
Intro-found: 1
Reference: [All74] <author> F. E. Allen. </author> <title> Interprocedural data flow analysis. </title> <booktitle> In Proceedings of 1974 IFIP Congress, </booktitle> <pages> pages 398-402, </pages> <address> Amsterdam, Holland, 1974. </address> <publisher> Institute of Electrical and Electronics Engineers, Inc., North Holland Publishing Company. </publisher>
Reference-contexts: Existing techniques for FORTRAN cannot supply this information; they only handle call-by-reference induced aliasing and are insufficient for languages with general-purpose pointer usage. Interprocedural modification side effects were first handled by Allen for acyclic call multigraphs <ref> [All74, Spi71] </ref>. Later, Barth explored the use of relations to capture side effects in recursive programs fl The research reported here was supported, in part, by Siemens Corporate Research and NSF grants CISE-CCR-92-08632 and CCR-9023628 2/5.
Reference: [ASU86] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization <ref> [ASU86] </ref>, practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change analysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84]. <p> The in-traprocedural propagation of aliases through pointer assignment statements is conceptually similar to the single level pointer aliasing algorithm in Chapter 10 of <ref> [ASU86] </ref> with extensions to handle multiple level pointers. Interprocedurally, a call to procedure Q, call Q , creates reaching aliases at the entry of Q.
Reference: [Ban79] <author> J. Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> In Conference Record of the Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 29-41, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: This technical report supersedes an earlier version on this research: LCSR-TR-195, Rutgers University, November 1992. 1 [Bar78]. Banning <ref> [Ban79] </ref> first noted the decomposition of the problem for FORTRAN (and other languages where aliasing is imposed only by call-by-reference parameter passing); he separated out two flow insensitive 1 calculations on the call multigraph: one for side effects and a separate one for aliases.
Reference: [Ban88] <author> Utpal Banerjee. </author> <title> Dependence Analysis for Supercomputing. </title> <publisher> Kluwer Academic Publishers, Norwell, </publisher> <address> MA, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls <ref> [Ban88, BC86, Wol89] </ref>, data-flow based testing [RW82, OW91], incremental semantic change analysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84].
Reference: [Bar78] <author> J. M. Barth. </author> <title> A practical interprocedural data flow analysis algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 21(9) </volume> <pages> 724-736, </pages> <year> 1978. </year>
Reference-contexts: This technical report supersedes an earlier version on this research: LCSR-TR-195, Rutgers University, November 1992. 1 <ref> [Bar78] </ref>. Banning [Ban79] first noted the decomposition of the problem for FORTRAN (and other languages where aliasing is imposed only by call-by-reference parameter passing); he separated out two flow insensitive 1 calculations on the call multigraph: one for side effects and a separate one for aliases.
Reference: [BC86] <author> M. Burke and R. Cytron. </author> <title> Interprocedural depenodence analysis and parallelization. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 162-175, </pages> <month> June </month> <year> 1986. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 21, No 6. </volume>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls <ref> [Ban88, BC86, Wol89] </ref>, data-flow based testing [RW82, OW91], incremental semantic change analysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84].
Reference: [Bur90] <author> M. Burke. </author> <title> An interval-based approach to exhaustive and incremental interprocedural data flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 341-395, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Cooper and Kennedy [Coo85, CK88, CK87] further decomposed the problem into side effects on global variables and side effects accomplished through parameter passing. Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition <ref> [Bur90] </ref>. Choi, Burke, and Carini mention a modification side effects algorithm for languages with pointers based on their pointer aliasing calculation [CBC93]; it is difficult to compare our work to theirs, because they give no description of their algorithm. <p> An interprocedural problem is flow insensitive if it can be solved solely by propagation on call graphs, using summary information for each procedure <ref> [Cal88, Bur90] </ref>. 2 result indicates that our pointer aliasing is very precise, because we are not overestimating the effects of the assignments by reporting many spurious aliases. This paper is organized as follows. Section 2 discusses our pointer aliasing algorithm and presents our decomposition of the modification side effects problem.
Reference: [Cal88] <author> D. Callahan. </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 47-56, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: An interprocedural problem is flow insensitive if it can be solved solely by propagation on call graphs, using summary information for each procedure <ref> [Cal88, Bur90] </ref>. 2 result indicates that our pointer aliasing is very precise, because we are not overestimating the effects of the assignments by reporting many spurious aliases. This paper is organized as follows. Section 2 discusses our pointer aliasing algorithm and presents our decomposition of the modification side effects problem.
Reference: [Car88] <author> M. D. Carroll. </author> <title> A new pointer-removing program transformation. </title> <type> Unpublished manuscript, </type> <year> 1988. </year>
Reference: [CB] <author> Jong-Deok Choi and Michael Burke. </author> <type> personal communication. </type>
Reference-contexts: Choi et. al. use the last call site encountered as their encoding of the run-time stack in their flow sensitive aliasing algorithm <ref> [CBC93, CB] </ref>. They also describe an algorithm variant that uses alias sets of unrestricted size, called source alias sets, as its encoding. We are jointly studying the precision and complexity effects of our two approaches and hope to compare algorithm performance in practice [MLR + 93]. 2.2 Pointer-induced Aliasing.
Reference: [CBC93] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition [Bur90]. Choi, Burke, and Carini mention a modification side effects algorithm for languages with pointers based on their pointer aliasing calculation <ref> [CBC93] </ref>; it is difficult to compare our work to theirs, because they give no description of their algorithm. <p> Choi et. al. use the last call site encountered as their encoding of the run-time stack in their flow sensitive aliasing algorithm <ref> [CBC93, CB] </ref>. They also describe an algorithm variant that uses alias sets of unrestricted size, called source alias sets, as its encoding. We are jointly studying the precision and complexity effects of our two approaches and hope to compare algorithm performance in practice [MLR + 93]. 2.2 Pointer-induced Aliasing.
Reference: [CK87] <author> K. Cooper and K. Kennedy. </author> <title> Complexity of interprocedural side-effect analysis. </title> <institution> Computer Science Department Technical Report TR87-61, Rice University, </institution> <month> October </month> <year> 1987. </year>
Reference-contexts: Banning [Ban79] first noted the decomposition of the problem for FORTRAN (and other languages where aliasing is imposed only by call-by-reference parameter passing); he separated out two flow insensitive 1 calculations on the call multigraph: one for side effects and a separate one for aliases. Cooper and Kennedy <ref> [Coo85, CK88, CK87] </ref> further decomposed the problem into side effects on global variables and side effects accomplished through parameter passing. Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition [Bur90]. <p> The function b call Q , specific to call Q , maps names from the called procedure (Q) to the calling procedure (P ) according to scoping rules <ref> [CK87] </ref> and only returns fixed-locations.
Reference: [CK88] <author> K. Cooper and K. Kennedy. </author> <title> Interprocedural side-effect analysis in linear time. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 57-66, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Banning [Ban79] first noted the decomposition of the problem for FORTRAN (and other languages where aliasing is imposed only by call-by-reference parameter passing); he separated out two flow insensitive 1 calculations on the call multigraph: one for side effects and a separate one for aliases. Cooper and Kennedy <ref> [Coo85, CK88, CK87] </ref> further decomposed the problem into side effects on global variables and side effects accomplished through parameter passing. Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition [Bur90].
Reference: [Coo85] <author> K. Cooper. </author> <title> Analyzing aliases of reference formal parameters. </title> <booktitle> In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 281-290, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Banning [Ban79] first noted the decomposition of the problem for FORTRAN (and other languages where aliasing is imposed only by call-by-reference parameter passing); he separated out two flow insensitive 1 calculations on the call multigraph: one for side effects and a separate one for aliases. Cooper and Kennedy <ref> [Coo85, CK88, CK87] </ref> further decomposed the problem into side effects on global variables and side effects accomplished through parameter passing. Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition [Bur90].
Reference: [Hec77] <author> M. S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> Elsevier North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: Iterative data flow analysis is a fixed point calculation for recursive equations defined on a graph representing a program, that safely approximates the meet over all paths solution <ref> [Hec77] </ref> for the graph. For interprocedural data flow, not all paths in the obvious graph representation correspond to real program executions. A realizable path is a path on which every procedure returns to the call site which invoked it [LR92].
Reference: [HRB88] <author> Susan Horwitz, Thomas Reps, and David Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 35-46, </pages> <month> June </month> <year> 1988. </year> <month> 17 </month>
Reference-contexts: Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change analysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing <ref> [HRB88, OO84, Ven91, Wei84] </ref>. These are key problems in parallel and sequential programming environments; the utility of tools to solve these problems is directly dependent on the accuracy of the data flow information available to them. We need an efficient method to report program-point-specific data flow information for these applications.
Reference: [JM82] <author> N. D. Jones and S. S. Muchnick. </author> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: Paths on which a procedure does not return to the call site which invoked it, are unrealizable and can never happen in an actual execution 2 . A fundamental problem of interprocedural analysis is how to restrict the propagation of data flow information to realizable paths. Jones and Muchnick <ref> [JM82] </ref> give a general approach for handling this problem. They associate with each data flow fact, an abstraction of the run-time stack on paths on which the fact is created.
Reference: [Lan92] <author> W. Landi. </author> <title> Interprocedural Aliasing in the Presence of Pointers. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <month> January </month> <year> 1992. </year> <month> LCSR-TR-174. </month>
Reference-contexts: The precision and safety of our MOD calculation depends upon the precision and safety of the underlying alias analysis. Our alias algorithm safely approximates 7 the alias solution as must all polynomial time alias algorithms <ref> [Lan92] </ref>. Therefore, Calias (n; RA) at any program point n is a safe approximation of the aliases that could occur at n conditional on RA reaching the entry of the procedure containing n.
Reference: [LR91] <author> W. Landi and B. G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Measurements of average and maximum number of side effects found per assignment statement, per assignment through dereference (i.e., *p=), per procedure and per call site have been made, as well as calculations of analysis times and the relative extra cost imposed by using our conditional analysis technique <ref> [LR91, LR92] </ref>. Most importantly, our results over the twelve programs show that on average 1.2 locations are assigned values per assignment statement through a dereferenced pointer variable (e.g., *p= ), indicating that often there is only one alias for such a variable at a program point. <p> This abstraction, created by a call, is associated with data flow facts in the called procedure; it is used at procedure exit to determine to which call site (s), the data flow information should be propagated. Our conditional aliasing approach <ref> [LR91, LR92] </ref> can be seen as an application of this idea. The data flow fact that x and y are aliased at program point n is represented by an unordered pair h x,y i at n. <p> Use of this encoding yields a precise solution for aliasing in the presence of one level of dereferencing; for multiple levels of dereferencing, this yields a safe approximate solution for aliasing <ref> [LR91] </ref>. Choi et. al. use the last call site encountered as their encoding of the run-time stack in their flow sensitive aliasing algorithm [CBC93, CB]. They also describe an algorithm variant that uses alias sets of unrestricted size, called source alias sets, as its encoding.
Reference: [LR92] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximation algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Our algorithm reports program-point-specific possible modification side effects (i.e., MOD); our results are more precise than information derivable using the same alias summary for all statements of a procedure. Our algorithm is based on an initial interprocedural pass that computes a flow sensitive approximation of program-point-specific pointer-induced aliases <ref> [LR92] </ref>. These are used to gather procedure summary modification information, with subsequent flow insensitive propagation of modifications through the program call multigraph. Finally, call site modification information is calculated using the results of the procedure side effects summary. <p> Finally, call site modification information is calculated using the results of the procedure side effects summary. We have implemented our MOD algorithm as a back-end analysis on our pointer aliasing implementation <ref> [LR92] </ref>. Initial experiments have been run with eleven of the programs which appeared in [LR92] and one more. <p> Finally, call site modification information is calculated using the results of the procedure side effects summary. We have implemented our MOD algorithm as a back-end analysis on our pointer aliasing implementation <ref> [LR92] </ref>. Initial experiments have been run with eleven of the programs which appeared in [LR92] and one more. <p> Measurements of average and maximum number of side effects found per assignment statement, per assignment through dereference (i.e., *p=), per procedure and per call site have been made, as well as calculations of analysis times and the relative extra cost imposed by using our conditional analysis technique <ref> [LR91, LR92] </ref>. Most importantly, our results over the twelve programs show that on average 1.2 locations are assigned values per assignment statement through a dereferenced pointer variable (e.g., *p= ), indicating that often there is only one alias for such a variable at a program point. <p> For interprocedural data flow, not all paths in the obvious graph representation correspond to real program executions. A realizable path is a path on which every procedure returns to the call site which invoked it <ref> [LR92] </ref>. Paths on which a procedure does not return to the call site which invoked it, are unrealizable and can never happen in an actual execution 2 . A fundamental problem of interprocedural analysis is how to restrict the propagation of data flow information to realizable paths. <p> This abstraction, created by a call, is associated with data flow facts in the called procedure; it is used at procedure exit to determine to which call site (s), the data flow information should be propagated. Our conditional aliasing approach <ref> [LR91, LR92] </ref> can be seen as an application of this idea. The data flow fact that x and y are aliased at program point n is represented by an unordered pair h x,y i at n. <p> The RAs can be used to determine to which call sites, aliases at the exit of a called procedure should be propagated. In <ref> [LR92] </ref>, we safely restricted the size of the reaching alias sets to one, yielding a compact and effective encoding of 2 We do not allow setjump or longjump in programs analyzed. 3 Reaching aliases were referred to by the term assumed aliases in [LR92]. 3 the run-time stack. <p> In <ref> [LR92] </ref>, we safely restricted the size of the reaching alias sets to one, yielding a compact and effective encoding of 2 We do not allow setjump or longjump in programs analyzed. 3 Reaching aliases were referred to by the term assumed aliases in [LR92]. 3 the run-time stack. Use of this encoding yields a precise solution for aliasing in the presence of one level of dereferencing; for multiple levels of dereferencing, this yields a safe approximate solution for aliasing [LR91]. <p> Our MOD solution procedure requires the results of our pointer aliasing approximation algorithm. Therefore, in what follows, we give a brief overview of the algorithm, described in detail in <ref> [LR92] </ref>. Intraprocedurally, aliases induced by a reaching alias at a procedure entry, are associated with that reaching alias. Aliases that are created regardless of any reaching aliases, could legitimately be associated with any reaching alias, but for practicality, we only associate them with a special reaching alias, . <p> We use Calias (n; RA) to represent the set of aliases at program point n under the condition that the alias RA reaches the entry of the procedure containing n <ref> [LR92] </ref> 4 . The in-traprocedural propagation of aliases through pointer assignment statements is conceptually similar to the single level pointer aliasing algorithm in Chapter 10 of [ASU86] with extensions to handle multiple level pointers. <p> The actual algorithm includes details of name space mappings between the calling and called procedures <ref> [LR92] </ref>; for brevity, we omit them here. 2.3 Decomposition of the MOD problem. We are solving for modification side effects to fixed-locations at program points. Fixed-locations are either user-defined variables or heap storage creation site names/field accesses. For example, in C syntax x and x.f are fixed-locations whereas 4 In [LR92], <p> <ref> [LR92] </ref>; for brevity, we omit them here. 2.3 Decomposition of the MOD problem. We are solving for modification side effects to fixed-locations at program points. Fixed-locations are either user-defined variables or heap storage creation site names/field accesses. For example, in C syntax x and x.f are fixed-locations whereas 4 In [LR92], we used may-holds to represent conditional aliasing information. Calias (n; RA) = fP A j may-holds (n; RA; P A)g. 4 flp and p-&gt;f are not. We have named each dynamic allocation site, similar to [RM88]. Each dynamically allocated fixed-location is identified by the site that created it. <p> The side effects reported are differentiated by fixed-location type: global, local, dynamically-created, and non visible (within that procedure). The non visibles are local variables of other procedures or an earlier instantiation of the current procedure <ref> [LR92] </ref>. In solving for modification side effects, we decompose the MOD problem into subproblems that are individually easier to solve than the monolithic problem. We first solve the conditional aliasing problem (i.e., ALI AS). <p> b call Q factors out all local variables of Q (including formal parameters of Q), maps global fixed-locations (global variables and dynamic storage locations) to themselves, and maps non visibles in Q to their corresponding fixed-locations in P , which are either locals of P or non visibles in P <ref> [LR92] </ref>. We now specify the modification side effects for calls and assignments. <p> Therefore, Calias (n; RA) at any program point n is a safe approximation of the aliases that could occur at n conditional on RA reaching the entry of the procedure containing n. In <ref> [LR92] </ref>, aliases that depend on two or more reaching aliases are associated arbitrarily with only one of the reaching aliases. This may introduce an additional approximation, but it is safe. We address the issue of safety below, and address the issue of empirically measured precision in Section 3. <p> Thus, the cost for each (call P ; RA) pair is O (M RA fl N fixed ). * MOD: O (N ICFG fl M RA fl C union ) 3 Empirical Results We have implemented our MOD decomposition and have empirical results for eleven of the programs analyzed in <ref> [LR92] </ref> plus compiler, a compiler for a subset of Pascal. Our implementation is written in C and analyzes a reduced version of C that excludes: union types, casting 5 , pointers to functions, exception handling, setjump and longjump. <p> In our implementation <ref> [LR92] </ref>, for efficiency we use one placeholder to represent all non visible fixed-locations within a procedure. This corresponds to all the locations modified when the object name non visible is modified. <p> This corresponds to all the locations modified when the object name non visible is modified. We do not discuss non visible in this paper, as it is not important to the MOD problem, but is necessary for the safety of our pointer aliasing algorithm; further details are available in <ref> [LR92] </ref>. * tot: MOD information for all fixed-locations. We give three different summary statistics. Average/assign (Maximum/assign) is the average (maximum) number of fixed-locations modified by assignment statements. Average percent/assign is more complicated. <p> We have empirically bounded the precision of our calculation in a similar manner as we did in <ref> [LR92] </ref>. There we explained the two sources of imprecision in the aliasing calculation: k-limiting, resulting from the necessity for approximation to handle a priori unboundable dynamic data structures and control-flow, resulting from safe assumptions about the actual execution paths with which aliases are associated. <p> Our algorithm is based on our conditional analysis approach that already has been used successfully in the approximation of pointer-induced aliases <ref> [LR92] </ref> and interprocedural reaching definitions [PRL91, PLR92]. Prelimi 16 nary results from our prototype implementation indicate that our algorithm is practical, efficient and quite accurate. Future work includes broadening the class of C programs handled by our prototype, making our algorithms incremental, and scaling up to handle large C systems.
Reference: [MLR + 93] <author> Thomas J. Marlowe, William Landi, Barbara G. Ryder, Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> A cost-precision comparison of two flow sensitive interprocedural algorithms for pointer-induced aliasing. </title> <type> Technical report, </type> <institution> Laboratory for Computer Science Research Technical Report, </institution> <month> June </month> <year> 1993. </year> <note> in preparation. </note>
Reference-contexts: They also describe an algorithm variant that uses alias sets of unrestricted size, called source alias sets, as its encoding. We are jointly studying the precision and complexity effects of our two approaches and hope to compare algorithm performance in practice <ref> [MLR + 93] </ref>. 2.2 Pointer-induced Aliasing. Our MOD solution procedure requires the results of our pointer aliasing approximation algorithm. Therefore, in what follows, we give a brief overview of the algorithm, described in detail in [LR92].
Reference: [OO84] <author> K. J. Ottenstein and L. M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change analysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing <ref> [HRB88, OO84, Ven91, Wei84] </ref>. These are key problems in parallel and sequential programming environments; the utility of tools to solve these problems is directly dependent on the accuracy of the data flow information available to them. We need an efficient method to report program-point-specific data flow information for these applications.
Reference: [OW91] <author> T. J. Ostrand and E. Weyuker. </author> <title> Data flow based test adequecy analysis for languages with pointers. </title> <booktitle> In Proceedings of the 1991 Symposium on Software Testing, Analysis and Verification (TAV4), </booktitle> <month> October </month> <year> 1991. </year> <institution> Victoria, B.C., Canada. </institution>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing <ref> [RW82, OW91] </ref>, incremental semantic change analysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84].
Reference: [PLR92] <author> H. D. Pande, W. Landi, and B. G. Ryder. </author> <title> Interprocedural def-use associations in the presence of single level pointers. </title> <institution> Laboratory for Computer Science Research Technical Report LCSR-TR-193, Department of Computer Science, Rutgers University, </institution> <year> 1992. </year> <note> being revised for journal publication. </note>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change analysis of software [Ryd89], interprocedural def-use relations <ref> [PRL91, PLR92] </ref> and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84]. These are key problems in parallel and sequential programming environments; the utility of tools to solve these problems is directly dependent on the accuracy of the data flow information available to them. <p> Our algorithm is based on our conditional analysis approach that already has been used successfully in the approximation of pointer-induced aliases [LR92] and interprocedural reaching definitions <ref> [PRL91, PLR92] </ref>. Prelimi 16 nary results from our prototype implementation indicate that our algorithm is practical, efficient and quite accurate. Future work includes broadening the class of C programs handled by our prototype, making our algorithms incremental, and scaling up to handle large C systems.
Reference: [PRL91] <author> H. Pande, B. G. Ryder, and W. Landi. </author> <title> Interprocedural def-use associations for C programs. </title> <booktitle> In Proceedings of the ACM SIGSOFT Conference on Testing, Analysis and Validation, </booktitle> <pages> pages 139-153, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change analysis of software [Ryd89], interprocedural def-use relations <ref> [PRL91, PLR92] </ref> and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84]. These are key problems in parallel and sequential programming environments; the utility of tools to solve these problems is directly dependent on the accuracy of the data flow information available to them. <p> Our algorithm is based on our conditional analysis approach that already has been used successfully in the approximation of pointer-induced aliases [LR92] and interprocedural reaching definitions <ref> [PRL91, PLR92] </ref>. Prelimi 16 nary results from our prototype implementation indicate that our algorithm is practical, efficient and quite accurate. Future work includes broadening the class of C programs handled by our prototype, making our algorithms incremental, and scaling up to handle large C systems.
Reference: [RM88] <author> C. Ruggieri and T. Murtagh. </author> <title> Lifetime analysis of dynamically allocated objects. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285-293, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: For example, in C syntax x and x.f are fixed-locations whereas 4 In [LR92], we used may-holds to represent conditional aliasing information. Calias (n; RA) = fP A j may-holds (n; RA; P A)g. 4 flp and p-&gt;f are not. We have named each dynamic allocation site, similar to <ref> [RM88] </ref>. Each dynamically allocated fixed-location is identified by the site that created it. Therefore, while we cannot distinguish between two fixed-locations created at the same site, we can distinguish those created at different sites.
Reference: [RW82] <author> S. Rapps and E. Weyuker. </author> <title> Data flow analysis techniques for program test data selection. </title> <booktitle> In Proceedings of the Sixth International Conference on Software Engineering, </booktitle> <pages> pages 272-278, </pages> <month> September </month> <year> 1982. </year>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing <ref> [RW82, OW91] </ref>, incremental semantic change analysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84].
Reference: [Ryd89] <author> B. G. Ryder. </author> <title> Ismm: Incremental software maintenance manager. </title> <booktitle> In Proceedings of the IEEE Computer Society Conference on Software Maintenance, </booktitle> <pages> pages 142-164, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change analysis of software <ref> [Ryd89] </ref>, interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84]. These are key problems in parallel and sequential programming environments; the utility of tools to solve these problems is directly dependent on the accuracy of the data flow information available to them.
Reference: [Spi71] <author> T. Spillman. </author> <title> Exposing side effects in a PL-I optimizing compiler. </title> <booktitle> In Proceedings of IFIPS Conference, </booktitle> <pages> pages TA-3-56:TA-3-62, </pages> <year> 1971. </year>
Reference-contexts: Existing techniques for FORTRAN cannot supply this information; they only handle call-by-reference induced aliasing and are insufficient for languages with general-purpose pointer usage. Interprocedural modification side effects were first handled by Allen for acyclic call multigraphs <ref> [All74, Spi71] </ref>. Later, Barth explored the use of relations to capture side effects in recursive programs fl The research reported here was supported, in part, by Siemens Corporate Research and NSF grants CISE-CCR-92-08632 and CCR-9023628 2/5.
Reference: [Ven91] <author> G. A. Venkatesh. </author> <title> The semantic approach to program slicing. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 107-119, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change analysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing <ref> [HRB88, OO84, Ven91, Wei84] </ref>. These are key problems in parallel and sequential programming environments; the utility of tools to solve these problems is directly dependent on the accuracy of the data flow information available to them. We need an efficient method to report program-point-specific data flow information for these applications.
Reference: [Wei84] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change analysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing <ref> [HRB88, OO84, Ven91, Wei84] </ref>. These are key problems in parallel and sequential programming environments; the utility of tools to solve these problems is directly dependent on the accuracy of the data flow information available to them. We need an efficient method to report program-point-specific data flow information for these applications.
Reference: [Wol89] <author> Michael Wolfe. </author> <title> Optimizing Supercompilers for Supercomputers. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls <ref> [Ban88, BC86, Wol89] </ref>, data-flow based testing [RW82, OW91], incremental semantic change analysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84].
References-found: 32

