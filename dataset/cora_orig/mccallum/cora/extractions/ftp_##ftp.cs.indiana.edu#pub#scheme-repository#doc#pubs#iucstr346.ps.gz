URL: ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/iucstr346.ps.gz
Refering-URL: http://www.cs.indiana.edu/scheme-repository/doc.publications.html
Root-URL: http://www.cs.indiana.edu
Title: Towards Leakage Containment  
Author: Julia L. Lawall and Daniel P. Friedman 
Address: Bloomington, IN 47405  
Affiliation: Indiana University Computer Science Department  
Abstract: Functional programs are organized into procedures, each encapsulating a specific task. A procedure should not cause its callers to repeat its work. This forced repetition of work we call leakage. In this paper we describe several common instances of leakage, and show how they can be eliminated using an extension of continuation-passing style.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Danvy, O., </author> <title> Programming with tighter control. Special issue of the BIGRE journal Putting the Scheme Language to Work, </title> <address> Brest, France (July 1989) 10-29. </address>
Reference-contexts: Single threading analysis is another way of eliminating the unnecessary creation of internal data structures. It shows where assignments can be introduced [12]. Danvy explores the use of continuations to solve the intermediate list problem <ref> [1] </ref>. He further exploits the technique of using continuations in non-tail position. The emphasis of these approaches is different from ours. Our primary concern is with the interface between procedures, whereas they are interested in the flow of data within a procedure.
Reference: [2] <author> Danvy, O. and Filinski, A., </author> <title> A functional abstraction of typed contexts. </title> <type> DIKU Report 89/12. </type> <institution> DIKU Computer Science Department, University of Copenhagen (Aug. </institution> <year> 1989). </year>
Reference-contexts: When it can be used, however, the result can be rewritten in a more direct style using either Felleisen's F and prompt operators [4], or Danvy and Filinski's shift and reset <ref> [2] </ref>. 8 (define extend (lambda (env formals args nk xf xa) (letrec ([loop (lambda (formals args k) (cond [(and (null? formals) (null? args)) (nk (k env))] [(null? args) (xf (k env) formals)] [(null? formals) (xa (k env) args)] [else (let ([new (cons (car formals) (car args))]) (loop (cdr formals) (cdr args)
Reference: [3] <author> Dybvig, K., and Hieb R. </author> <title> A variable-arity procedural interface. </title> <booktitle> In Proceedings of the 1988 ACM Symposium on Lisp and Functional Programming, </booktitle> <address> Snowbird, Utah (July 1988), </address> <pages> 106-115. </pages>
Reference-contexts: Our primary concern is with the interface between procedures, whereas they are interested in the flow of data within a procedure. Dybvig and Hieb consider the creation of unnecessary data structures in the implementation of a lambda taking a variable number of arguments <ref> [3] </ref>. They allow a set of argument patterns with a different action for each case. These argument patterns and associated actions are similar to the continuations we pass in when multiple conditions need to be signalled. Their approach addresses a specific design problem, whereas ours is a general programming technique.
Reference: [4] <author> Felleisen, M., </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, California (Jan. </address> <year> 1988) </year> <month> 180-190. </month>
Reference-contexts: In leakage elimination it is often the case that the continuations do not take exactly one argument so this technique cannot generally be applied. When it can be used, however, the result can be rewritten in a more direct style using either Felleisen's F and prompt operators <ref> [4] </ref>, or Danvy and Filinski's shift and reset [2]. 8 (define extend (lambda (env formals args nk xf xa) (letrec ([loop (lambda (formals args k) (cond [(and (null? formals) (null? args)) (nk (k env))] [(null? args) (xf (k env) formals)] [(null? formals) (xa (k env) args)] [else (let ([new (cons (car
Reference: [5] <author> Filinski, A., </author> <title> Declarative continuations and categorical duality. </title> <type> Master's thesis. </type> <institution> DIKU, University of Copenhagen, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: Their approach addresses a specific design problem, whereas ours is a general programming technique. Our use of continuations in the interface between a procedure and its caller is related to Filinski's notion of a symmetric language <ref> [5] </ref>. In a symmetric language a procedure's value argument and continuation argument have equal importance and are equally accessible.
Reference: [6] <author> Fischer, M.J., </author> <title> Lambda Calculus Schemata. </title> <booktitle> In Proceedings of the ACM Conference Proving Assertions about Programs, SIGPLAN Notices 7, 1 and SIGACT News 14 (Jan. </booktitle> <year> 1972) </year> <month> 104-109. </month>
Reference: [7] <author> Georgeff, </author> <title> M.P., A scheme for implementing functional values on a stack machine. </title> <booktitle> In Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming, </booktitle> <address> Pittsburgh, </address> <month> Pennsylvania (August </month> <year> 1982), </year> <pages> 188-195. </pages>
Reference-contexts: Of course, if exactly the right number of arguments are present the body is evaluated normally. This feature has been advocated as a way to avoid using the heap in some cases when returning higher order functions <ref> [7] </ref>. We examine the leakage problems that arise in adding this feature to a Scheme interpreter. We assume the existence of an interpreter and concentrate on two procedures, make-closure and extend. We have arbitrarily chosen to use flat association lists to represent the environment.
Reference: [8] <author> Harper R., MacQueen D., Milner R., </author> <title> Standard ML. </title> <institution> Laboratory for Foundations of Computer Science. University of Edinburgh. ECS-LFCS-86-2. </institution> <year> 1986. </year> <month> 10 </month>
Reference-contexts: Any value that the lookup procedure might return to indicate that the key is not in the table might also be the value associated with the key. One solution is to return an element of a union type, as might be done in a typed language such as ML <ref> [8] </ref>. Valid values are injected into one element of the union and the failure indicator is injected into another. This solution causes leakage in two ways. <p> It is also easy to forget which element of the list represents which value. Type constructors of a language like ML can partially alleviate this problem <ref> [8] </ref>. Such languages provide a special pattern matching syntax to extract the components of these structures in a concise way. The type must, however, be defined in the scope of all the procedures that might call the associated structure-returning procedure. Usually it must be defined globally.
Reference: [9] <author> Morris, J.H. Jr., </author> <title> A bonus from Van Wijngaarden's device. </title> <journal> Comm. of the ACM 15 (Aug. </journal> <year> 1972) </year> <month> 773. </month>
Reference: [10] <author> Plotkin, G.D., </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <journal> Theor. Comput. Sci. </journal> <volume> 1, </volume> <year> 1975, </year> <pages> 129-159. </pages>
Reference-contexts: The called procedure is then responsible for passing its return value to this procedure. Algorithms exist to convert any sequential program to continuation-passing style without changing the program's extensional behavior <ref> [10] </ref>. There are two characteristics that define continuation-passing style. Because in most applicative languages procedures may only return one value, continuations always take just one argument. Continuations are always invoked in tail position.
Reference: [11] <editor> Rees, J.A., et al. </editor> <title> Revised 3 report on the algorithmic language Scheme. </title> <journal> SIGPLAN Notices 21 (Dec. </journal> <year> 1986). </year>
Reference-contexts: To illustrate this difficulty we consider a third example, an extension of Scheme's lambda facility. In Scheme, procedures created using lambda take either a fixed or a minimum number of arguments <ref> [11] </ref>. In a curried language, like Miranda [17], a function can be applied to any number of arguments. If not enough arguments are present a new function is built.
Reference: [12] <author> Schmidt, D.A., </author> <title> Detecting global variables in denotational specifications. </title> <journal> ACM Trans. on Prog. Lang. and Sys. </journal> <month> 7 </month> <year> (1985) </year> <month> 299-310. </month>
Reference-contexts: The emphasis there is on allowing the programmer to write inefficient looking code, whereas ours is on providing him with a motivation to write better programs. Single threading analysis is another way of eliminating the unnecessary creation of internal data structures. It shows where assignments can be introduced <ref> [12] </ref>. Danvy explores the use of continuations to solve the intermediate list problem [1]. He further exploits the technique of using continuations in non-tail position. The emphasis of these approaches is different from ours.
Reference: [13] <author> Schmidt, D.A., </author> <title> Denotational Semantics. </title> <publisher> Allyn and Bacon, </publisher> <address> Boston, </address> <year> 1986. </year> <pages> pp. 202-204. </pages>
Reference-contexts: A table lookup program written in this style is shown below. Because the caller wants to know the value, not just whether one was found, the value is an argument to the success continuation <ref> [13] </ref>, k.
Reference: [14] <author> Steele, G.L. Jr, </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: The emphasis is, thus, not on returning a single value, but on passing to the rest of the computation the values it needs. In this section we discuss another example where the continuation needs a number of arguments other than one. Some languages support multiple return values <ref> [14] </ref>. A possible solution in other functional languages when multiple return values are needed, is to package them into a list. The list is then returned to the caller who is responsible for decoding it to find the intended values. The list itself, however, conveys no information.
Reference: [15] <author> Stoy, </author> <title> J.E., The congruence of two programming language definitions. </title> <note> Theoretical Comp. Science 13 (1981) 151-174. </note>
Reference-contexts: It may be a major undertaking to convert an existing semantics to continuation-passing style <ref> [15] </ref>, but once the conversion has been done the result is more expressive. Similarly the conversion from a direct style of building ordinary programs to the continuation-constructing style we have discussed, may initially seem complicated. Again the result is clearer and more extensible.
Reference: [16] <author> Strachey, C. and Wadsworth, </author> <title> C.P., Continuations a mathematical semantics for handling full jumps. </title> <type> Technical Monograph PRG-11, </type> <institution> Programming Research Group, University of Oxford (1974). </institution>
Reference-contexts: Our solution to the leakage problem forces the caller to pass to the procedure not only values, but also continuations. 9 6 Conclusion In denotational semantics continuation-passing style has made it possible to express complicated control structures that it would be clumsy to express in direct style <ref> [16] </ref>. It may be a major undertaking to convert an existing semantics to continuation-passing style [15], but once the conversion has been done the result is more expressive. Similarly the conversion from a direct style of building ordinary programs to the continuation-constructing style we have discussed, may initially seem complicated.
Reference: [17] <author> Turner, D.A., Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In Proceedings of the 2nd International Conference on Functional Programming Languages and Computer Architecture LNCS 201, </booktitle> <address> Nancy, France (Sept. </address> <year> 1985) </year> <month> Springer-Verlag </month> <year> 1985, </year> <pages> 1-16. </pages>
Reference-contexts: To illustrate this difficulty we consider a third example, an extension of Scheme's lambda facility. In Scheme, procedures created using lambda take either a fixed or a minimum number of arguments [11]. In a curried language, like Miranda <ref> [17] </ref>, a function can be applied to any number of arguments. If not enough arguments are present a new function is built. If too many are present the body of the function is expected to return a function that will accept the remaining arguments.
Reference: [18] <author> Wadler, P., </author> <title> Listlessness is better than laziness: lazy evaluation and garbage collection at compile-time. </title> <booktitle> In Conference Record of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <address> Austin, Texas (Aug. </address> <year> 1984), </year> <pages> 45-52. 11 </pages>
Reference-contexts: A number of researchers have addressed the creation of unnecessary data structures within procedures. Wadler describes a compilation scheme that automatically converts programs that use many intermediate lists into a machine code that is more efficient <ref> [18] </ref>. The emphasis there is on allowing the programmer to write inefficient looking code, whereas ours is on providing him with a motivation to write better programs. Single threading analysis is another way of eliminating the unnecessary creation of internal data structures. It shows where assignments can be introduced [12].
References-found: 18

