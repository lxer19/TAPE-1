URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/westbrook/two-backtrack.ps.Z
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/westbrook/
Root-URL: http://www.cs.yale.edu
Title: Dynamic Two-Connectivity with Backtracking  
Author: Johannes A. La Poutre AND Jeffery Westbrook 
Keyword: Key words. Dynamic graph algorithms, backtracking.  
Note: AMS subject classifications. 68Q20, 68Q25  
Abstract: We give algorithms and data structures that maintain the 2-edge and 2-vertex connected components of a graph under insertions and deletions of edges and vertices, where deletions occur in a backtracking fashion (i.e., deletions undo the insertions in the reverse order). Our algorithms run in O(log n) worst-case time per operation and use O(n) space, where n is the number of vertices. Using our data structure we can answer queries, which ask whether vertices u and v belong to the same 2-connected component, in O(log n) worst-case time. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. D. Battista and R. Tamassia, </author> <title> On-line graph algorithms with SPQR-trees, </title> <booktitle> in Proc. 17th ICALP, </booktitle> <year> 1990. </year>
Reference-contexts: A number of different problems on incremental and fully dynamic graphs have been studied, including 2- and 3-edge-connectivity, 2- and 3-vertex connectivity, spanning trees, and planarity testing <ref> [1] </ref> [5] [7] [8] [9] [10] [12] [13] [20] [17] [18] [19] [21] [25] [26] [29] [30] [32].
Reference: [2] <author> S. Bent, D. D. Sleator, and R. E. Tarjan, </author> <title> Biased search trees, </title> <journal> SIAM J. Comput., </journal> <volume> 14 (1985), </volume> <pages> pp. 545-568. </pages>
Reference: [3] <author> N. Blum, </author> <title> On the single-operation worst-case time complexity of the disjoint set union problem, </title> <journal> SIAM J. Comput., </journal> <volume> 15 (1986), </volume> <pages> pp. 1021-1024. </pages>
Reference-contexts: value in O (1) time, when paths are split during splices and slices. (We defer explaining how to implement +1 for the moment.) Unions and finds on the block partitions can be done in worst-case time fi (log n= log log n) per operation using a data structure of Blum <ref> [3] </ref>. Hence, the result of this section is an incremental algorithm that runs in worst-case time per operation O (log n) 2 . 4.4. The Undo Operation. The algorithms for 2-vertex connectivity are more complicated than those for 2-edge connectivity, and the Undo operation is correspondingly more complex.
Reference: [4] <author> T. Cormen, C. Leiserson, and R. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1990. </year>
Reference-contexts: The simplest one is to push each edge on a stack as it is added, popping the stack for each undo. A test query is answered by copying the edges on the stack, constructing the graph, and running a standard biconnectivity algorithm <ref> [4] </ref>. Updates require O (1) time in the worst case, queries take O (m) time, and the space required is O (m), where m is the maximum number of edges ever in the graph. Another possibility is to use the techniques of persistence [6].
Reference: [5] <author> G. Di Battista and R. Tamassia, </author> <title> Incremental planarity testing, </title> <booktitle> in Proc. 30th IEEE Symp. on Foundations of Computer Science, </booktitle> <year> 1989, </year> <pages> pp. 436-441. </pages>
Reference-contexts: A number of different problems on incremental and fully dynamic graphs have been studied, including 2- and 3-edge-connectivity, 2- and 3-vertex connectivity, spanning trees, and planarity testing [1] <ref> [5] </ref> [7] [8] [9] [10] [12] [13] [20] [17] [18] [19] [21] [25] [26] [29] [30] [32].
Reference: [6] <author> J. Driscoll, H. N. Gabow, N. Sarnak, and R. E. Tarjan, </author> <title> Making data structures persistent, </title> <booktitle> in Proc. 18th Symp. of Foundations of Computer Science, </booktitle> <year> 1986, </year> <pages> pp. 109-121. </pages>
Reference-contexts: Updates require O (1) time in the worst case, queries take O (m) time, and the space required is O (m), where m is the maximum number of edges ever in the graph. Another possibility is to use the techniques of persistence <ref> [6] </ref>. A normal data structure is ephemeral in the sense that after an update the old version is destroyed, replaced by the updated version. Using the techniques of Driscoll et al.[6], a pointer TWO-CONNECTIVITY WITH BACKTRACKING 3 based data structure in which all nodes have constant bounded in-degree and out-degree can
Reference: [7] <author> D. Eppstein, Z. Galil, G. Italiano, and A. Nissiweig, </author> <title> Sparsification: a general technique for dynamic graph algorithms, </title> <booktitle> in Proc. 33nd Symp. of Foundations of Computer Science, </booktitle> <year> 1992. </year>
Reference-contexts: A number of different problems on incremental and fully dynamic graphs have been studied, including 2- and 3-edge-connectivity, 2- and 3-vertex connectivity, spanning trees, and planarity testing [1] [5] <ref> [7] </ref> [8] [9] [10] [12] [13] [20] [17] [18] [19] [21] [25] [26] [29] [30] [32]. <p> Those algorithms require fi (n) time per operation in the worst-case. A fully dynamic algorithm for 2-edge connectivity running in O ( p n) time is given by Eppstein et al. <ref> [7] </ref> and an O ( m log n) time algorithm for fully dynamic 2-vertex connectivity algorithm is given by Rauch [26]. (Again, m is the maximum number of edges and n the maximum number of vertices.) Thus, there is a substantial gap in time complexity between the incremental and fully dynamic
Reference: [8] <author> D. Eppstein, Z. Galil, G. Italiano, and T. Spencer, </author> <title> Separator based sparsification for dynamic planar graph algorithms, </title> <booktitle> in Proc. 25th Symp. on Theory of Computing, </booktitle> <year> 1993, </year> <pages> pp. 208-217. </pages>
Reference-contexts: A number of different problems on incremental and fully dynamic graphs have been studied, including 2- and 3-edge-connectivity, 2- and 3-vertex connectivity, spanning trees, and planarity testing [1] [5] [7] <ref> [8] </ref> [9] [10] [12] [13] [20] [17] [18] [19] [21] [25] [26] [29] [30] [32].
Reference: [9] <author> G. N. Frederickson, </author> <title> Data structures for on-line updating of minimum spanning trees, with applications, </title> <journal> SIAM J. Comput., </journal> <volume> 14 (1985), </volume> <pages> pp. </pages> <month> 781-798. </month> <title> [10] , Ambivalent data structures for dynamic 2-edge-connectivity and k smallest spanning trees, </title> <booktitle> in Proc. 32nd Symp. on Foundations of Computer Science, </booktitle> <year> 1991, </year> <pages> pp. 632-641. </pages>
Reference-contexts: A number of different problems on incremental and fully dynamic graphs have been studied, including 2- and 3-edge-connectivity, 2- and 3-vertex connectivity, spanning trees, and planarity testing [1] [5] [7] [8] <ref> [9] </ref> [10] [12] [13] [20] [17] [18] [19] [21] [25] [26] [29] [30] [32].
Reference: [11] <author> Z. Galil and G. F. </author> <title> Italiano, Data structures and algorithms for disjoint set union problems, </title> <type> Tech. Report CUCS-473-89, </type> <institution> Department of Computer Science, Columbia University, </institution> <year> 1989. </year> <title> [12] , Fully dynamic algorithms for 2-edge connectivity, </title> <journal> SIAM J. Comput., </journal> <volume> 21 (1992), </volume> <pages> pp. </pages> <month> 1047-1069. </month> <title> [13] , Maintaining the 3-edge connected components of a graph on-line, </title> <journal> SIAM J. Comput., </journal> <volume> 22 (1993), </volume> <pages> pp. 11-28. </pages>
Reference: [14] <author> G. Gambiosi, G. F. Italiano, and M. Talamo, </author> <title> The set union problem with dynamic weighted backtracking, </title> <booktitle> in Proc. 26th Annual Allerton Conf. on Communication, Control and Computing, </booktitle> <year> 1988. </year>
Reference: [15] <author> F. Harary, </author> <title> Graph Theory, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA., </address> <year> 1972. </year>
Reference-contexts: These are presented in Section 4. There we first give an intermediate and simpler solution that runs in O (log 2 n) time per operation, and then present the O (log n) solution. 2. Preliminaries. 2.1. Terminology. In this paper, we use the standard graph terminology in Harary <ref> [15] </ref>. Let G = (V; E) be a graph. A path is a sequence of vertices v 0 ; v 1 ; : : : ; v k such that fv i ; v i+1 g 2 E; 0 i &lt; k.
Reference: [16] <author> G. F. Italiano, J. A. La Poutr e, and M. H. Rauch, </author> <title> Fully dynamic planarity testing in planar embedded graphs, </title> <editor> in T. Lengauer (Ed.), </editor> <booktitle> Algorithms - ESA '93, Lecture Notes in Computer Science 726, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993, </year> <pages> pp. 212-223. </pages>
Reference-contexts: that essentially is an algorithm with undo operations for maintaining an embedded planar st-orientable graph (such a graph is 2-connected if one edge (s; t) is added) under a restricted set of modifications; it thus gives a better time complexity than its fully-dynamic counterpart for general, unrestricted embedded planar graphs <ref> [16] </ref>, but only by a factor log n.
Reference: [17] <author> J. A. La Poutr e, </author> <title> Maintenance of 2-and 3-connected components of graphs, part ii: 2-and 3-edge-connected components and 2-vertex-connected components, </title> <type> Tech. Report RUU-CS-90-27, </type> <institution> Utrecht University, </institution> <year> 1990. </year>
Reference-contexts: A number of different problems on incremental and fully dynamic graphs have been studied, including 2- and 3-edge-connectivity, 2- and 3-vertex connectivity, spanning trees, and planarity testing [1] [5] [7] [8] [9] [10] [12] [13] [20] <ref> [17] </ref> [18] [19] [21] [25] [26] [29] [30] [32]. Algorithms for incremental 2-edge and 2-vertex connectivity running in O (ff (m; n)) amortized time per operation, where m is the maximum number of edges and n the maximum number of vertices, are described in [17, 32]. <p> Algorithms for incremental 2-edge and 2-vertex connectivity running in O (ff (m; n)) amortized time per operation, where m is the maximum number of edges and n the maximum number of vertices, are described in <ref> [17, 32] </ref>. Those algorithms require fi (n) time per operation in the worst-case.
Reference: [18] <author> J. A. La Poutr e, </author> <title> Dynamic Graph Algorithms and Data Structures, </title> <type> PhD thesis, </type> <institution> University of Utrecht, Netherlands, </institution> <year> 1991. </year>
Reference-contexts: A number of different problems on incremental and fully dynamic graphs have been studied, including 2- and 3-edge-connectivity, 2- and 3-vertex connectivity, spanning trees, and planarity testing [1] [5] [7] [8] [9] [10] [12] [13] [20] [17] <ref> [18] </ref> [19] [21] [25] [26] [29] [30] [32]. Algorithms for incremental 2-edge and 2-vertex connectivity running in O (ff (m; n)) amortized time per operation, where m is the maximum number of edges and n the maximum number of vertices, are described in [17, 32].
Reference: [19] <author> J. A. La Poutr e, </author> <title> Maintenance of triconnected components of graphs, </title> <booktitle> in Proc. Int. Colloquium on Automata, Languages, and Programming (ICALP '92), Springer-Verlag Lecture Notes in Computer Science 623, </booktitle> <year> 1992, </year> <pages> pp. 354-365. </pages>
Reference-contexts: A number of different problems on incremental and fully dynamic graphs have been studied, including 2- and 3-edge-connectivity, 2- and 3-vertex connectivity, spanning trees, and planarity testing [1] [5] [7] [8] [9] [10] [12] [13] [20] [17] [18] <ref> [19] </ref> [21] [25] [26] [29] [30] [32]. Algorithms for incremental 2-edge and 2-vertex connectivity running in O (ff (m; n)) amortized time per operation, where m is the maximum number of edges and n the maximum number of vertices, are described in [17, 32].
Reference: [20] <author> J. A. La Poutr e, J. van Leeuwen, and M. H. Overmars, </author> <title> Maintenance of 2-and 3-edge-connected components of graphs, </title> <journal> Discrete Mathematics, </journal> <volume> 114 (1993), </volume> <pages> pp. 329-359. </pages>
Reference-contexts: A number of different problems on incremental and fully dynamic graphs have been studied, including 2- and 3-edge-connectivity, 2- and 3-vertex connectivity, spanning trees, and planarity testing [1] [5] [7] [8] [9] [10] [12] [13] <ref> [20] </ref> [17] [18] [19] [21] [25] [26] [29] [30] [32]. Algorithms for incremental 2-edge and 2-vertex connectivity running in O (ff (m; n)) amortized time per operation, where m is the maximum number of edges and n the maximum number of vertices, are described in [17, 32].
Reference: [21] <author> J. A. La Poutr e, </author> <title> Alpha-Algorithms for Incremental Planarity Testing, </title> <booktitle> in Proc. 26th ACM Symp. on Theory of Computing, </booktitle> <year> 1994, </year> <pages> pp. 706-715. </pages>
Reference-contexts: A number of different problems on incremental and fully dynamic graphs have been studied, including 2- and 3-edge-connectivity, 2- and 3-vertex connectivity, spanning trees, and planarity testing [1] [5] [7] [8] [9] [10] [12] [13] [20] [17] [18] [19] <ref> [21] </ref> [25] [26] [29] [30] [32]. Algorithms for incremental 2-edge and 2-vertex connectivity running in O (ff (m; n)) amortized time per operation, where m is the maximum number of edges and n the maximum number of vertices, are described in [17, 32].
Reference: [22] <author> H. Mannila and E. Ukkonen, </author> <title> On the complexity of unification sequences, </title> <booktitle> in Third International Conference on Logic Programming, Lecture Notes in Computer Science, </booktitle> <volume> vol. 225, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1986, </year> <pages> pp. </pages> <month> 122-133. </month> <title> [23] , The set union problem with backtracking, </title> <booktitle> in Proc. 13th International Colloquium on Automata, Languages, and Programming (ICALP 86), Lecture Notes in Computer Science, </booktitle> <volume> vol. 226, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1986, </year> <pages> pp. 236-243. </pages> <note> TWO-CONNECTIVITY WITH BACKTRACKING 17 </note>
Reference: [24] <author> G. </author> <title> Port. </title> <type> Private communication, </type> <year> 1988. </year>
Reference-contexts: Research par tially supported by National Science Foundation Grant CCR-9009753. 1 2 LA POUTR E AND WESTBROOK in Prolog <ref> [24] </ref>. Furthermore, dynamic graphs with backtracking suffice for many interactive system applications like, e.g., CAD/CAM systems and VLSI layout. Maintaining 2-vertex connected components could potentially be used for problems in reliable network design, or for designing VLSI layouts.
Reference: [25] <author> M.H. Rauch, </author> <title> Fully dynamic biconnectivity, </title> <booktitle> in Proc. 33nd Symp. of Foundations of Computer Science, </booktitle> <year> 1992. </year>
Reference-contexts: A number of different problems on incremental and fully dynamic graphs have been studied, including 2- and 3-edge-connectivity, 2- and 3-vertex connectivity, spanning trees, and planarity testing [1] [5] [7] [8] [9] [10] [12] [13] [20] [17] [18] [19] [21] <ref> [25] </ref> [26] [29] [30] [32]. Algorithms for incremental 2-edge and 2-vertex connectivity running in O (ff (m; n)) amortized time per operation, where m is the maximum number of edges and n the maximum number of vertices, are described in [17, 32].
Reference: [26] <author> M.H. Rauch, </author> <title> Improved Data Structures for Fully Dynamic Biconnectivity, </title> <booktitle> in Proc. 26th ACM Symp. on Theory of Computing, </booktitle> <year> 1994, </year> <pages> pp. 686-695. </pages>
Reference-contexts: A number of different problems on incremental and fully dynamic graphs have been studied, including 2- and 3-edge-connectivity, 2- and 3-vertex connectivity, spanning trees, and planarity testing [1] [5] [7] [8] [9] [10] [12] [13] [20] [17] [18] [19] [21] [25] <ref> [26] </ref> [29] [30] [32]. Algorithms for incremental 2-edge and 2-vertex connectivity running in O (ff (m; n)) amortized time per operation, where m is the maximum number of edges and n the maximum number of vertices, are described in [17, 32]. <p> A fully dynamic algorithm for 2-edge connectivity running in O ( p n) time is given by Eppstein et al. [7] and an O ( m log n) time algorithm for fully dynamic 2-vertex connectivity algorithm is given by Rauch <ref> [26] </ref>. (Again, m is the maximum number of edges and n the maximum number of vertices.) Thus, there is a substantial gap in time complexity between the incremental and fully dynamic problems.
Reference: [27] <author> D. D. Sleator and R. E. Tarjan, </author> <title> A data structure for dynamic trees, </title> <journal> J. Comput. System Sci., </journal> <volume> 26 (1983), </volume> <pages> pp. 362-391. </pages>
Reference-contexts: This is in contrast with connected components, where only 2 connected components may be joined or separated by an insertion or Undo operation. 2.2. Dynamic Trees. In <ref> [27] </ref>, Sleator and Tarjan presented their dynamic tree data structure. For later reference, we briefly describe the main features of this data structure. The data structure maintains a rooted tree with costs on each edge, or, alternatively, on each vertex. <p> To show the correctness of the backtracking procedure, it suffices to confirm that an undo performed immediately after an insertion restores the data structure to its condition prior to the insertion. The time bound follows from <ref> [27] </ref>. The space complexity follows since the size of the stack (i.e., the number of records in it) is bounded by the size of G 0 . 2 4. 2-vertex connectivity. In this section, we describe algorithms and data structures for maintaining the 2-vertex-connectivity relation in dynamic graphs with backtracking. <p> The inverse of splitting is a concatenation, which produces a single path p consisting of p 1 , followed by v, followed by p 2 . The path decomposition is manipulated by means of three functions: expose, conceal, and reverse <ref> [27] </ref>. An expose creates a solid path starting at a specified node v and ending at the root. The new path may not necessarily contain only heavy edges.
Reference: [28] <author> R. Tamassia, </author> <title> A dynamic data structure for planar graph embedding, </title> <booktitle> in Proc. 15th Int. Conf. on Automata, Languages, and Programming, (ICALP 1988), Lecture Notes in Computer Science, </booktitle> <volume> vol. 317, </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988, </year> <pages> pp. 576-590. </pages>
Reference-contexts: In [29] it is observed that backtracking graph connectivity could be solved in fi (log n= log log n) time by a straightforward application of the backtracking union-find algorithm (as incremental graph connectivity can be solved by straightforwardly applying standard Union-Find). Tamassia <ref> [28] </ref> gave an algorithm for a hierarchical embedding problem related to VLSI design that essentially is an algorithm with undo operations for maintaining an embedded planar st-orientable graph (such a graph is 2-connected if one edge (s; t) is added) under a restricted set of modifications; it thus gives a better
Reference: [29] <author> J. Westbrook, </author> <title> Algorithms and Data Structures for Dynamic Graph Problems, </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Princeton University, Princeton, NJ, </institution> <month> October </month> <year> 1989. </year> <title> [30] , Fast incremental planarity testing, </title> <booktitle> in Proc. Int. Symp. on Automata, Languages and Programming (ICALP '92), Lecture Notes in Computer Science, </booktitle> <address> New York, 1992, </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: A number of different problems on incremental and fully dynamic graphs have been studied, including 2- and 3-edge-connectivity, 2- and 3-vertex connectivity, spanning trees, and planarity testing [1] [5] [7] [8] [9] [10] [12] [13] [20] [17] [18] [19] [21] [25] [26] <ref> [29] </ref> [30] [32]. Algorithms for incremental 2-edge and 2-vertex connectivity running in O (ff (m; n)) amortized time per operation, where m is the maximum number of edges and n the maximum number of vertices, are described in [17, 32]. <p> Man-nila and Ukkonen [22][23] first formalized and studied this problem and proposed several algorithms which Westbrook and Tarjan [31] subsequently analyzed: each operation can be performed in fi (log n= log log n) time. Variants and extensions of this problem are studied in [11][14]. In <ref> [29] </ref> it is observed that backtracking graph connectivity could be solved in fi (log n= log log n) time by a straightforward application of the backtracking union-find algorithm (as incremental graph connectivity can be solved by straightforwardly applying standard Union-Find). <p> If costs are associated with nodes, add cost (u; x) adds value x to the cost of all nodes on the path from u to the root, and find min (u) returns the node of minimal cost on the path from u to the root. As observed in <ref> [29] </ref>, maintaining the connectivity relation with backtracking can be performed in fi (log = log log n) time per operation, and O (n) space, by using a Union-Find structure with backtracking.
Reference: [31] <author> J. Westbrook and R. E. Tarjan, </author> <title> Amortized analysis of algorithms for set union with backtracking, </title> <journal> SIAM J. Computing, </journal> <volume> 18 (1989), </volume> <pages> pp. </pages> <month> 1-11. </month> <title> [32] , Maintaining bridge-connected and biconnected components on-line, </title> <journal> Algorithmica, </journal> <year> (1992), </year> <pages> pp. 433-464. </pages>
Reference-contexts: Man-nila and Ukkonen [22][23] first formalized and studied this problem and proposed several algorithms which Westbrook and Tarjan <ref> [31] </ref> subsequently analyzed: each operation can be performed in fi (log n= log log n) time. Variants and extensions of this problem are studied in [11][14]. <p> The space bound follows from the proof of Theorem 4.2. 5. Remarks. The only lower bound known for backtracking problems is one of (log n= log log n) for disjoint set union with backtracking <ref> [31] </ref>. This bound can be applied to any class of algorithms for backtracking graph problems that keep disjoint data structures for distinct components of the graph. Our algorithms fall into that class.
References-found: 26

