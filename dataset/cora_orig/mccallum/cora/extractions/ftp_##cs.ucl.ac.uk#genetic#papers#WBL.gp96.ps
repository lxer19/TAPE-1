URL: ftp://cs.ucl.ac.uk/genetic/papers/WBL.gp96.ps
Refering-URL: http://www.cs.bham.ac.uk/~wbl/biblio/gp-bibliography.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: W.Langdon@cs.ucl.ac.uk  
Phone: Tel: +44 (0) 171 380 7214, Fax: +44 (0) 171 387 1397  
Title: Using Data Structures within Genetic Programming  with indexed memory or with stack data structures.  
Author: John R. Koza and David E. Goldberg and David B. Fogel and W. B. Langdon 
Web: www: http://www.cs.ucl.ac.uk/staff/W.Langdon/  
Address: Gower Street, London WC1E 6BT, UK  
Affiliation: Genetic Programming Group, Dept. of Computer Science, University College, London,  
Note: Genetic Programming 1996: Proceedings of the First Annual Conference,  Rick L. Riolo (eds), MIT Press  Comparisons are made between GP attempting to solve these problems when provided  
Abstract: Three "classic" problems are solved. The first two require the GP to distinguish between sentences that are in a context free language and those that are not given positive and negative training examples of the language. The two languages are, correctly nested brackets and a Dyck language (correctly nested brackets of different types). The third problem is to evaluate integer Reverse Polish (postfix) expressions. 
Abstract-found: 1
Intro-found: 1
Reference: [ Andre, 1994 ] <author> David Andre. </author> <title> Evolution of mapmaking ability: Strategies for the evolution of learning, planning, and memory using genetic programming. </title> <booktitle> In Proceedings of the 1994 IEEE World Congress on Computational Intelligence, </booktitle> <volume> volume 1, </volume> <pages> pages 250-255, </pages> <address> Or-lando, Florida, USA, 27-29 June 1994. </address> <publisher> IEEE Press. </publisher>
Reference-contexts: This is achieved by using abstract data structures, such as stacks, queues and lists, to provide an interface between programs and memory. We seek to show that data abstraction can be beneficially used within genetic programming (GP). So far work by Teller [ Teller, 1994 ] , Andre <ref> [ Andre, 1994 ] </ref> and others shows GP can automatically create programs which explicitly use directly addressable (indexed) memory to solve problems which cannot be solved without memory and we have demonstrated that GP can automatically generate abstract data structures such as stacks, queues [ Langdon, 1995 ] and lists [
Reference: [ Collins, 1992 ] <author> Robert J. Collins. </author> <title> Studies in Artificial Evolution. </title> <type> PhD thesis, </type> <institution> UCLA, Artificial Life Laboratory, Department of Computer Science, University of California, </institution> <address> Los Angeles, LA CA 90024, USA, </address> <year> 1992. </year>
Reference-contexts: Each time a new individual is created a 3 fi 3 square neigbourhood on the torus (known as a deme) is selected at random. Parents and the individual their offspring will replace are selected from this deme rather than from the whole population <ref> [ Langdon, 1995; Tackett, 1994; Collins, 1992 ] </ref> . 2.2 Fitness Function The fitness of each trial program was evaluated on a fixed set of 175 example sentences containing both correctly nested (positive) and incorrectly nested brackets (negative).
Reference: [ Dunay and Petry, 1995 ] <author> Bertrand Daniel Dunay and Frederic E. Petry. </author> <title> Solving complex problems with genetic algorithms. </title> <editor> In L. Eshelman, editor, </editor> <booktitle> Genetic Algorithms: Proceedings of the Sixth International Conference (ICGA95), </booktitle> <pages> pages 264-270, </pages> <address> Pittsburgh, PA, USA, 15-19 July 1995. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Balanced Bracket Problem Other work on GP evolving language recognizers has concentrated upon using GP to evolve tree based specifications for abstract machines, such as finite state machines [ Dunay et al., 1994 ] , deterministic push down automata [ Zomorodian, 1995 ] , machines composed of simple Tur-ing machines <ref> [ Dunay and Petry, 1995 ] </ref> or special memory nodes within the tree [ Iba et al., 1995 ] . In contrast we wish to investigate the impact of providing data structures v. indexed memory and so our GP executes the GP tree directly.
Reference: [ Dunay et al., 1994 ] <author> B. D. Dunay, F. E. Petry, and W. P Buckles. </author> <title> Regular language induction with genetic programming. </title> <booktitle> In Proceedings of the 1994 IEEE World Congress on Computational Intelligence, </booktitle> <pages> pages 396-400, </pages> <address> Orlando, Florida, USA, 27-29 June 1994. </address> <publisher> IEEE Press. </publisher>
Reference-contexts: These were chosen in the expectation that data structures at least as powerful as stacks would be required to solve them. 2 Balanced Bracket Problem Other work on GP evolving language recognizers has concentrated upon using GP to evolve tree based specifications for abstract machines, such as finite state machines <ref> [ Dunay et al., 1994 ] </ref> , deterministic push down automata [ Zomorodian, 1995 ] , machines composed of simple Tur-ing machines [ Dunay and Petry, 1995 ] or special memory nodes within the tree [ Iba et al., 1995 ] .
Reference: [ Goldberg, 1989 ] <author> David E. Goldberg. </author> <title> Genetic Algorithms in Search Optimization and Machine Learning. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Each program's fitness now contains two orthogonal terms, the original score and the baveragec number of instructions run per program execution. Tournament selection is still used for reproduction and deletion but now uses Pareto comparison <ref> [ Goldberg, 1989 ] </ref> , so passing tests and using little CPU are equally important. In the event of no member of the tournament being better than all the others the best members of the tournament are compared with a sample of the adjacent population.
Reference: [ Horn et al., 1993 ] <author> Jeffrey Horn, Nicholas Nafpliotis, and David E. Goldberg. </author> <title> Multiobjective optimization using the niched pareto genetic algorithm. </title> <type> IlliGAL Report no. 93005, </type> <institution> Illinois Genetic Algorithm Laboratory, University of Illinois at Urbana-Champaign, 117 Transportation Building, </institution> <address> 104 South Mathews Avenue, Urbana, IL 61801-2296, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: The one that is dominated the least by the rest of the population is selected. This introduces a selection pressure to be different from the rest the population so allowing high scoring and low CPU programs to co-exist. This is similar to fitness niching <ref> [ Horn et al., 1993 ] </ref> . 3.3 Results In three runs given the stack primitives general solutions were evolved by generation seven to 23 (in three identical runs but using simple non-demic (normal) populations, two runs produced solutions in generations 30 and 39).
Reference: [ Iba et al., 1995 ] <author> Hitoshi Iba, Hugo de Garis, and Taisuke Sato. </author> <title> Temporal data processing using genetic programming. </title> <editor> In L. Eshelman, editor, </editor> <booktitle> Genetic Algorithms: Proceedings of the Sixth International Conference (ICGA95), </booktitle> <pages> pages 279-286, </pages> <address> Pittsburgh, PA, USA, 15-19 July 1995. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: using GP to evolve tree based specifications for abstract machines, such as finite state machines [ Dunay et al., 1994 ] , deterministic push down automata [ Zomorodian, 1995 ] , machines composed of simple Tur-ing machines [ Dunay and Petry, 1995 ] or special memory nodes within the tree <ref> [ Iba et al., 1995 ] </ref> . In contrast we wish to investigate the impact of providing data structures v. indexed memory and so our GP executes the GP tree directly.
Reference: [ Kinnear, Jr., 1994 ] <author> Kenneth E. Kinnear, Jr. </author> <title> A perspective on the work in this book. </title> <editor> In Kenneth E. Kinnear, Jr., editor, </editor> <booktitle> Advances in Genetic Programming, chapter 1, </booktitle> <pages> pages 3-19. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: The two more complex examples (Dyck and RPN) proved to be more difficult (no solution has been found to date) for GP when provided with indexed memory than when provided with a stack, despite indexed memory being more powerful. It has often been argued, e.g. <ref> [ Kinnear, Jr., 1994, page 12 ] </ref> , that functional primitives used with GP should be as powerful as possible, in these examples we have shown appropriate data structures are advantageous, that is GP can benefit from data abstraction.
Reference: [ Koza, 1994 ] <author> John R. Koza. </author> <title> Genetic Programming II: Automatic Discovery of Reusable Programs. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: The balanced bracket problem is to recognise sentences composed of sequences of two symbols, ( and ), which are correctly nested. E.g. (()) is correctly nested but ()) is not. A limit of ten symbols per sentence was assumed. 2.1 Architecture Two automatically defined functions (ADFs) <ref> [ Koza, 1994 ] </ref> are available to assist the main result producing branch (or tree). The first, adf1, has no arguments and has the same terminal and function sets (except arg1) as 141 the main tree. <p> This allows a cache of previous values returned by it to be maintained, thus reducing run time. Table 1 shows the parameters used and the terminals and functions provided, n.b. they include indexed memory but not stacks. Parameters not shown are as <ref> [ Koza, 1994, page 655 ] </ref> . Table 9 gives the actions of most terminals and functions. Earlier work with indexed memory had shown even large population had a great tendency to converge to partial solutions which effectively trapped the whole population preventing further progress.
Reference: [ Langdon, 1995 ] <author> W. B. Langdon. </author> <title> Evolving data structures using genetic programming. </title> <editor> In L. Eshelman, editor, </editor> <booktitle> Genetic Algorithms: Proceedings of the Sixth International Conference (ICGA95), </booktitle> <pages> pages 295-302, </pages> <address> Pittsburgh, PA, USA, 15-19 July 1995. </address> <publisher> Morgan Kauf-mann. </publisher>
Reference-contexts: [ Teller, 1994 ] , Andre [ Andre, 1994 ] and others shows GP can automatically create programs which explicitly use directly addressable (indexed) memory to solve problems which cannot be solved without memory and we have demonstrated that GP can automatically generate abstract data structures such as stacks, queues <ref> [ Langdon, 1995 ] </ref> and lists [ Langdon, 1996 ] . In this paper we show that GP can evolve programs which solve problems using such data structures. In two cases we show better GP performance when using data structures compared to directly addressable memory. <p> Each time a new individual is created a 3 fi 3 square neigbourhood on the torus (known as a deme) is selected at random. Parents and the individual their offspring will replace are selected from this deme rather than from the whole population <ref> [ Langdon, 1995; Tackett, 1994; Collins, 1992 ] </ref> . 2.2 Fitness Function The fitness of each trial program was evaluated on a fixed set of 175 example sentences containing both correctly nested (positive) and incorrectly nested brackets (negative). <p> Two sets of experiments have been conducted, the first provided the GP with primitives which implement a stack for it and the second provided primitives like those from which it has been shown GP can evolve stack data structures <ref> [ Langdon, 1995 ] </ref> . 3.1 Architecture In the first experiments (stack given) no ADFs were used, whilst in the second there are three ADFs, having 0, 1 and 0 arguments. It was hoped that these could evolve to operate like pop, push and top.
Reference: [ Langdon, 1996 ] <author> William B. Langdon. </author> <title> Data structures and genetic programming. </title> <editor> In Peter J. Angeline and K. E. Kinnear, Jr., editors, </editor> <booktitle> Advances in Genetic Programming 2, chapter 20. </booktitle> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: [ Andre, 1994 ] and others shows GP can automatically create programs which explicitly use directly addressable (indexed) memory to solve problems which cannot be solved without memory and we have demonstrated that GP can automatically generate abstract data structures such as stacks, queues [ Langdon, 1995 ] and lists <ref> [ Langdon, 1996 ] </ref> . In this paper we show that GP can evolve programs which solve problems using such data structures. In two cases we show better GP performance when using data structures compared to directly addressable memory.
Reference: [ Tackett, 1994 ] <author> Walter Alden Tackett. </author> <title> Recombination, Selection, and the Genetic Construction of Computer Programs. </title> <type> PhD thesis, </type> <institution> University of Southern Cali-fornia, Department of Electrical Engineering Systems, </institution> <year> 1994. </year>
Reference-contexts: Each time a new individual is created a 3 fi 3 square neigbourhood on the torus (known as a deme) is selected at random. Parents and the individual their offspring will replace are selected from this deme rather than from the whole population <ref> [ Langdon, 1995; Tackett, 1994; Collins, 1992 ] </ref> . 2.2 Fitness Function The fitness of each trial program was evaluated on a fixed set of 175 example sentences containing both correctly nested (positive) and incorrectly nested brackets (negative).
Reference: [ Teller, 1994 ] <author> Astro Teller. </author> <title> The evolution of mental models. </title> <editor> In Kenneth E. Kinnear, Jr., editor, </editor> <booktitle> Advances in Genetic Programming, chapter 9, </booktitle> <pages> pages 199-219. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: This is achieved by using abstract data structures, such as stacks, queues and lists, to provide an interface between programs and memory. We seek to show that data abstraction can be beneficially used within genetic programming (GP). So far work by Teller <ref> [ Teller, 1994 ] </ref> , Andre [ Andre, 1994 ] and others shows GP can automatically create programs which explicitly use directly addressable (indexed) memory to solve problems which cannot be solved without memory and we have demonstrated that GP can automatically generate abstract data structures such as stacks, queues [
Reference: [ Zomorodian, 1995 ] <author> Afra Zomorodian. </author> <title> Context-free language induction by evolution of deterministic pushdown automata using genetic programming. </title> <editor> In E. S. Siegel and J. R. Koza, editors, </editor> <booktitle> Working Notes for the AAAI Symposium on Genetic Programming, </booktitle> <pages> pages 127-133, </pages> <publisher> MIT, </publisher> <address> Cambridge, MA, USA, 10-12 Novem-ber 1995. </address> <publisher> AAAI. </publisher> <pages> 149 </pages>
Reference-contexts: as powerful as stacks would be required to solve them. 2 Balanced Bracket Problem Other work on GP evolving language recognizers has concentrated upon using GP to evolve tree based specifications for abstract machines, such as finite state machines [ Dunay et al., 1994 ] , deterministic push down automata <ref> [ Zomorodian, 1995 ] </ref> , machines composed of simple Tur-ing machines [ Dunay and Petry, 1995 ] or special memory nodes within the tree [ Iba et al., 1995 ] . <p> A simplified version of it is shown in Figure 1. In contrast to earlier work <ref> [ Zomorodian, 1995 ] </ref> where GP was obliged to evolved push down automata the evolved solution is effectively a register machine (n.b. less powerful that a push down automata). The evolved solution (cf.
References-found: 14

