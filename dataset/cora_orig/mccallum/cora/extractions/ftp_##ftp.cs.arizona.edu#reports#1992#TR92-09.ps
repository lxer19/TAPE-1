URL: ftp://ftp.cs.arizona.edu/reports/1992/TR92-09.ps
Refering-URL: http://www.cs.arizona.edu/research/reports.html
Root-URL: http://www.cs.arizona.edu
Title: SR A Language for Parallel and Distributed Programming  
Author: Ronald A. Olsson Gregory R. Andrews Michael H. Coffin Gregg M. Townsend 
Note: TR 92-09  
Affiliation: DEPARTMENT OF COMPUTER SCIENCE  
Abstract-found: 0
Intro-found: 1
Reference: [Andr81] <author> Andrews, </author> <title> G.R. Synchronizing resources. </title> <journal> ACM Trans. on Prog. Languages and Systems 3, </journal> <month> 4 (Oct. </month> <year> 1981), </year> <pages> 405-430. </pages>
Reference: [Andr82] <author> Andrews, </author> <title> G.R. </title> <booktitle> The distributed programming language SRmechanisms, design and implementation. SoftwarePractice and Experience 12, </booktitle> <month> 8 (Aug. </month> <year> 1982), </year> <pages> 719-754. </pages>
Reference: [Andr86] <author> Andrews, G.R., and Olsson, R.A. </author> <title> The evolution of the SR language. </title> <booktitle> Distributed Computing 1, </booktitle> <month> 3 (July </month> <year> 1986), </year> <pages> 133-149. </pages>
Reference-contexts: Experience using SR 0 substantiated the general appropriateness of the language, but also pointed out several deficiencies. That experience led us to redesign the language <ref> [Andr86] </ref>. The result (SR version 1) [Olss86,Andr88] provided additional mechanisms for remote procedure call, dynamic process creation, and semaphores, as well as a means for specifying distribution of program modules. Experience using version 1 of SR has led to further evolution of the language.
Reference: [Andr88] <author> Andrews, G.R., Olsson, R.A., Coffin, M., Elshoff, I., Nilsen, K., Purdin, T., and Townsend, G. </author> <title> An overview of the SR language and implementation. </title> <journal> ACM Trans. on Prog. Lang. and Systems 10, </journal> <month> 1 (Jan. </month> <year> 1988), </year> <pages> 51-86. </pages>
Reference: [Andr91] <author> Andrews, </author> <title> G.R. Concurrent Programming: </title> <booktitle> Principles and Practice. </booktitle> <publisher> Benjamin/Cummings Publishing Company, </publisher> <year> 1991. </year>
Reference-contexts: Since the barrier is executed only once, this approach is reasonable for this program. In general, however, one will want to use one of the more efficient barriers described in <ref> [Andr91] </ref> or [MCS91]. 4 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh global sizes var N := 10 # matrix dimension, default 10 var PR := 2 # number of processes, default 2 var S: int # strip size body sizes getarg (1, N); getarg (2, PR); S := N/PR if N mod PR != 0 -&gt; write <p> These are useful, for example, in programming conversational continuity. In such an interaction, a client process interacts with a server process and wishes to carry out a private conversation with it (see <ref> [Andr91] </ref>). In many ways, the mechanisms that SR provides for sharing, distribution, and synchronization are a superset of those found in other languages, such as Ada [US83], Concurrent C [Geha89], Argus [Lisk83], and occam [Burn88].
Reference: [AnOl92] <author> Andrews, G.R., and Olsson, R.A. </author> <title> The SR Programming Language: Concurrency in Practice. Benjamin/Cummings Publishing Company, </title> <note> to appear 1992. </note>
Reference-contexts: This paper introduces version 2 of SR, henceforth referred to as simply SR. It illustrates how a single language can provide support for different execution environments, ranging from shared-memory multiprocessors to distributed systems. This paper focuses on the highlights of the language; details can be found in <ref> [AnOl92] </ref>. The rest of this paper is organized as follows. Section 2 gives an overview of the SR model of computation. Section 3 describes how synchronization, sharing, and distribution are supported in SR. Section 4 illustrates, by means of examples, SR's language mechanisms that support parallel and distributed programming. <p> For this problem, a task corresponds to the finding the N inner products for a given row of the result matrix c. More generally, the worker processes often generate new taskscorresponding to subproblemsthat are put into the bag. This is the case in one solution to adaptive quadrature <ref> [AnOl92] </ref>. There, worker processes are given tasks of approximating the area for a given interval; they add new taskscorresponding to finding areas for two sub-intervalsto the bag if their approximation was not acceptable. In this section, we present a matrix multiplication program that implements a shared bag of tasks solution.
Reference: [Atki88] <author> Atkins, M.S., and Olsson, R.A. </author> <title> Performance of multitasking and synchronization mechanisms in the programming language SR. </title> <journal> SoftwarePractice and Experience 18, </journal> <month> 9 (Sept. </month> <year> 1988), </year> <pages> 879-895. </pages>
Reference-contexts: The version 1 SR compiler, for example, optimizes certain message passing scenarios to use low-cost semaphores, and certain remote procedure call scenarios to use conventional procedure call. The results are that the cost of synchronization in SR is competitive with those reported for other languages <ref> [Atki88] </ref>. One current effort involves identifying further optimization of synchronization mechanisms, including those that cross resource boundaries. Our overall approach applies source-level transformations to concurrent programs, replacing costly synchronization mechanisms with less costly ones [McOl90a,OlMc91].
Reference: [Burn88] <author> Burns, A. </author> <title> Programming in occam 2. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: In many ways, the mechanisms that SR provides for sharing, distribution, and synchronization are a superset of those found in other languages, such as Ada [US83], Concurrent C [Geha89], Argus [Lisk83], and occam <ref> [Burn88] </ref>. SR achieves this flexibility by having just a few well-integrated mechanisms, which can be used alone or freely in combination with others. One interesting question is whether such generalization is inherently more costly.
Reference: [Geha89] <author> Gehani, N. </author> <title> The Concurrent C Programming Language. </title> <publisher> Silicon Press, Summit, </publisher> <address> New Jersey, </address> <year> 1989. </year>
Reference-contexts: In many ways, the mechanisms that SR provides for sharing, distribution, and synchronization are a superset of those found in other languages, such as Ada [US83], Concurrent C <ref> [Geha89] </ref>, Argus [Lisk83], and occam [Burn88]. SR achieves this flexibility by having just a few well-integrated mechanisms, which can be used alone or freely in combination with others. One interesting question is whether such generalization is inherently more costly.
Reference: [HiLa90] <author> Hill, M.D., and Larus, J.R. </author> <title> Cache considerations for multiprocessor programmers. </title> <journal> Comm. ACM 33, </journal> <month> 8 (Aug. </month> <year> 1990), </year> <pages> 97-102. </pages>
Reference-contexts: Hill and Larus <ref> [HiLa90] </ref> give three rules-of-thumb programmers need to keep in mind: g Perform all operations on a variable, especially updates, in one process (processor). g Align data so that variables updated by different processors are in different cache blocks. g Re-use data quickly when possible so that it remains in the cache
Reference: [Lisk83] <author> Liskov, B., and Scheifler, R. </author> <title> Guardians and actions: linguistic support for robust, distributed programs. </title> <journal> ACM Trans. on Prog. Lang. and Systems 5, </journal> <month> 3 (July </month> <year> 1983), </year> <pages> 381-404. </pages>
Reference-contexts: In many ways, the mechanisms that SR provides for sharing, distribution, and synchronization are a superset of those found in other languages, such as Ada [US83], Concurrent C [Geha89], Argus <ref> [Lisk83] </ref>, and occam [Burn88]. SR achieves this flexibility by having just a few well-integrated mechanisms, which can be used alone or freely in combination with others. One interesting question is whether such generalization is inherently more costly.
Reference: [Manb89] <author> Manber, U. </author> <title> Introduction to Algorithms: A Creative Approach. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: As in the broadcast algorithm, we will use N 2 processes, one to compute each element of matrix c. Again, each initially also has the corresponding elements of a and b. The algorithm consists of three stages <ref> [Manb89] </ref>. In the first, processes shift values in a circularly to the left; values in row i are shifted left i columns. Second, processes shift values in b circularly up; values in column j are shift up j rows.
Reference: [McOl90a] <author> McNamee, C.M., and Olsson, R.A. </author> <title> Transformations for optimizing interprocess communication and synchronization mechanisms. </title> <journal> International Journal of Parallel Programming 19, </journal> <volume> 5 (Oct. </volume> <pages> 1990) pages 357-387. </pages>
Reference: [McOl90b] <author> McNamee, C.M., and Olsson, R.A. </author> <title> An attribute grammar approach to compiler optimization of intra-module interprocess communication. </title> <note> Submitted for publication. (An earlier version appears as CSE-89-11, </note> <institution> Div. of Computer Science, The University of California, Davis, </institution> <year> 1989.) </year>
Reference-contexts: The techniques involve the application of dataflow analysis and an extension of interprocedural analysis and inter-module analysis to concurrent programs. An interesting aspect of this work is the use of attribute grammars to perform such analysis <ref> [McOl90b] </ref>. These techniques are also applicable to other programming languages, e.g., Ada, Concurrent C, Argus, and occam. Version 2 of SR works on a variety of UNIX-based systems, including a Sequent multiprocessor, and is in the public domain.
Reference: [MCS91] <author> Mellor-Crummey, J.M., and Scott, </author> <title> M.L. Algorithms for scalable synchronization on shared-memory multiprocessors. </title> <journal> ACM Trans. on Computer Systems 9, </journal> <month> 1 (Feb. </month> <year> 1991), </year> <pages> 21-65. </pages>
Reference-contexts: Since the barrier is executed only once, this approach is reasonable for this program. In general, however, one will want to use one of the more efficient barriers described in [Andr91] or <ref> [MCS91] </ref>. 4 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh global sizes var N := 10 # matrix dimension, default 10 var PR := 2 # number of processes, default 2 var S: int # strip size body sizes getarg (1, N); getarg (2, PR); S := N/PR if N mod PR != 0 -&gt; write ("N must
Reference: [OlMc91] <author> Olsson, R.A., and McNamee, </author> <title> C.M. An overview of compiler optimization of interprocess communication and synchronization mechanisms. </title> <booktitle> Proceedings of the 1991 International Conference on Parallel Processing, </booktitle> <address> St. Charles, IL, </address> <note> II-31 to II-35, </note> <month> August 12-17, </month> <year> 1991. </year>
Reference: [Olss86] <author> Olsson, R.A. </author> <title> Issues in Distributed Programming Languages: The Evolution of SR. </title> <type> TR 86-21 (Ph.D. Dissertation), </type> <institution> Dept. of Computer Science, The University of Arizona, </institution> <month> August </month> <year> 1986. </year>
Reference: [US83] <author> U.S. </author> <title> Department of Defense. Reference Manual for the Ada Programming Language. </title> <address> ANSI/MIL-STD-1815A, </address> <year> 1983. </year>
Reference-contexts: In such an interaction, a client process interacts with a server process and wishes to carry out a private conversation with it (see [Andr91]). In many ways, the mechanisms that SR provides for sharing, distribution, and synchronization are a superset of those found in other languages, such as Ada <ref> [US83] </ref>, Concurrent C [Geha89], Argus [Lisk83], and occam [Burn88]. SR achieves this flexibility by having just a few well-integrated mechanisms, which can be used alone or freely in combination with others. One interesting question is whether such generalization is inherently more costly.
Reference: [Wirt82] <author> Wirth, N. </author> <title> Programming in Modula-2. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1982. </year> <month> 12 </month>
Reference-contexts: Each of these components contains two parts: a specification (aka a spec) and an implementation (aka a body). An import mechanism is used to make available in one component objects declared in the spec of another. In these two ways, globals and resources are similar to modules in Modula-2 <ref> [Wirt82] </ref> but they are created differently. Instances of resources are created dynamically, by an explicit create statement. These instances, and the services they provide, are referenced indirectly through resource capability variables. Instances of globals are also created dynamically.
References-found: 19

