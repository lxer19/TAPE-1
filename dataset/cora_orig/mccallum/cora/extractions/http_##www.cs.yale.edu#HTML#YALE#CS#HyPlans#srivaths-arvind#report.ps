URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/srivaths-arvind/report.ps
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/srivaths-arvind/
Root-URL: http://www.cs.yale.edu
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Drew Dean and Dan S. Wallach, </author> <title> Security Flaws in the HotJava Web Browser, </title> <month> November 3, </month> <year> 1995. </year> <note> Available via ftp://ftp.cs.princeton.edu/reports/1995/501.ps.Z </note>
Reference-contexts: Later, I propose some schemes by which some applets can be treated as trusted and given greater privileges. As pointed out in <ref> [1] </ref>, the byte code verifier, the interpreter, the runtime libraries must all cooperate to achieve security. Therefore, to ensure security, every one of those components have to be water-tight. <p> The distribution of the security code has made it difficult to plug all loopholes in the code and 5 offers a lot of scope to hackers, who are more than willing to spend time finding them. Another area which deserves attention, as indicated in <ref> [1] </ref>, is accountability. Currently, accountability provided by the browser is limited to a log of all the programs downloaded by the user.
Reference: 2. <author> Joseph A. Bank, </author> <title> Java Security, </title> <note> December 8, 1995. Avialable via http://www-swiss.ai.mit.edu/ jbank/javapaper/javapaper.html </note>
Reference-contexts: Network access can be configured to prevent the applet from opening network connections to any machine other than the server. This prevents the applet from connecting to machines that trust the client and using the user's privileges on those machines. For further details refer <ref> [2] </ref>. 3 Analysis 3.1 Kinds of attacks The ways in which malicious code can inflict damage on the local system or the user include: * Denial of service : This can be done by consuming enormous ammounts of system resources like memory or disk space (if the applet is allowed to
Reference: 3. <author> James Gosling and Henry McGilton, </author> <title> The Java Language Environment: A White Paper, Sun Microsystems, </title> <month> May </month> <year> 1995. </year> <note> Available via ftp://java.sun.com/docs/JavaBook.ps.tar.Z </note>
Reference: 4. <author> Sun Microsystems, HotJava(tm): </author> <title> The Security Story. </title> <note> Available via http://java.sun.com/1.0alpha3/doc/security/security.html </note>
Reference-contexts: doesn't violate access restrictions. 2 * That there are no incorrect type casts eg. to change the type of an input file stream to output file stream. * That it calls methods with appropriate arguments of the appropriate type. * That there are no stack overflows." For details refer to <ref> [4] </ref> and [6]. The byte code verifier can statically determine the type state of the execution frame at any point of program execution. The type state is the collection of type information of all the slots on the stack (including local variables).
Reference: 5. <author> Sun Microsystems, </author> <title> The Java Language Specifications: </title> <note> Version 1.0 Beta. Available via http://java.sun.com/JDK-beta/psfiles/javaspec.ps </note>
Reference: 6. <author> Frank Yellin, </author> <title> Low Level Security in Java. </title> <note> Available via http://www.w3.org/pub/Conferences/WWW4/Papers/197/40.html 9 </note>
Reference-contexts: access restrictions. 2 * That there are no incorrect type casts eg. to change the type of an input file stream to output file stream. * That it calls methods with appropriate arguments of the appropriate type. * That there are no stack overflows." For details refer to [4] and <ref> [6] </ref>. The byte code verifier can statically determine the type state of the execution frame at any point of program execution. The type state is the collection of type information of all the slots on the stack (including local variables).
References-found: 6

