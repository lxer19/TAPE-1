URL: http://www.cs.brandeis.edu/~mairson/Papers/OOP-types.ps.gz
Refering-URL: http://www.cs.brandeis.edu/~mairson/
Root-URL: http://www.cs.brandeis.edu
Title: A Constructive Logic of Multiple Subtyping  
Author: Harry G. Mairson 
Note: On leave from Brandeis University, Waltham, Mas-sachusetts. Supported in part by NSF Grant CCR-9017125, and grants from Texas Instruments and from the Tyson Foundation.  
Address: Cambridge, Massachusetts 02139  
Affiliation: Cambridge Research Laboratory Digital Equipment Corporation  
Abstract: We show how a higher order logic, the calculus of constructions, can be used to give a simple, first principles treatment of record calculi, polymorphism, and subtyp-ing. The development follows the constructive idiom of extracting implementations of equationally specified programs from proofs of their termination, with a logic for reasoning about programs, and a semantics that comes as a gratuity. In this framework, records are finitely specified functions where equality is decidable over the domain, with types that are a particular kind of logical assertion. By proving that a record specification satisfies its type, we can extract its implementation. While program extraction serves as a sort of compiler, proof normalization serves as an interpreter; the latter serves to ensure in some sense the coherence of the translation embedded in the former. This simple minded approach lets us show, for example, that many inference rules found in record and object calculi can be derived | they are just provable lemmas in higher order logic. We see explicitly how from subtyping proofs we can extract, using conventional methods, coercion functions between underlying representations of data types. By further exploiting the computational metaphor of higher order logic, we can realize an interpreter for recursively defined objects, as well as subtype and inheritance relations between them. Recursive types for objects are explained by primitive recursion in higher types. The approach also gives a computational understanding of F-bounded polymorphism. 
Abstract-found: 1
Intro-found: 1
Reference: [AC91] <author> R. M. Amadio and L. Cardelli. </author> <title> Subtyp-ing recursive types. </title> <booktitle> In Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1991, </year> <pages> pp. 104-118. </pages>
Reference-contexts: It would be interesting to see if the expressiveness of the primitive recursive iterators is sufficient to formalize more sophisticated arguments about subtyping, for instance <ref> [AC91] </ref>. In reasoning about equational theories where the control is distributed, the robustness of the approach is not clear.
Reference: [BB85] <author> C. Bohm and A. Berarducci. </author> <title> Automatic synthesis of typed -programs on term algebras. </title> <booktitle> Theoretical Computer Science 39, </booktitle> <pages> pp. 135-154. </pages>
Reference-contexts: This contraction procedure is the essence of extracting programs from proofs <ref> [BB85, Gir72, GLT89, Lei90] </ref>. 4 The bracket notation hei abbreviates iterated use of apply : Term ! Term ! Term to build term e. 4 1.5 Subtyping and coercion We can now define subtyping, and an example "type" Even that is meant to be a subtype of Int: Subtype = [A
Reference: [BGS90] <author> V. Breazu-Tannen, C. A. Gunter, A. Sce-drov. </author> <title> Computing with coercions. </title> <booktitle> 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 44-60. </pages>
Reference-contexts: proposed a justification of record calculi via a translation into a variant of the Girard/Reynolds type system F 2 , augmented with subtyping rules [Car91]; Breazu-Tannen, Coquand, Gunter, and Scedrov have also described how programs in a type discipline with subsumption can be translated into one with explicit coercion instead <ref> [BCGS91, BGS90] </ref>. In a similar spirit, Church invented an informal "justification" of arithmetic via a translation into lambda calculus, i.e., Church numerals.
Reference: [BCGS91] <author> V. Breazu-Tannen, T. Coquand, C. A. Gunter, A. Scedrov. </author> <title> Inheritance as implicit coercion. </title> <institution> Research Report MS-CIS-89-01, Department of Computer and Information Science, University of Pennsylvania. </institution>
Reference-contexts: proposed a justification of record calculi via a translation into a variant of the Girard/Reynolds type system F 2 , augmented with subtyping rules [Car91]; Breazu-Tannen, Coquand, Gunter, and Scedrov have also described how programs in a type discipline with subsumption can be translated into one with explicit coercion instead <ref> [BCGS91, BGS90] </ref>. In a similar spirit, Church invented an informal "justification" of arithmetic via a translation into lambda calculus, i.e., Church numerals. <p> Normalizing a proof does not change its conclusion, this the logical interpretation of the -calculus subject reduction lemma. Hence the conclusion of a normalized proof, where the conclusion is an inductively defined type (roughly equivalent to the idea of observable type in <ref> [BCGS91] </ref>), could be alternately produced by pure equational reasoning. If using two different proofs of the same logical assertion leads to two different answers, it would mean that our equational axioms were inconsistent. 2 Records Records are functions.
Reference: [Bru92] <author> K. Bruce. </author> <title> A Paradigmatic Object-Oriented Programming Language: Design, Static Typing and Semantics. </title> <type> Technical Report CS-92-01, </type> <institution> Williams College. </institution>
Reference-contexts: Here is a typical "rule" for subtyping in a programming language (see, e.g., <ref> [Car89, Bru92] </ref>): ` A 0 &lt;: A ` B &lt;: B 0 Why does this rule need to be mandated ex nihilo when it follows, in the right framework, from principles of logic? It ought to be a derived rule.
Reference: [CCHOM89] <author> P. Canning, W. Cook, W. Hill, W. Olthoff, and J. C. Mitchell. </author> <title> F-bounded polymorphism for object-oriented programming. </title> <booktitle> In Fourth ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <year> 1989, </year> <pages> pp. 273-280. 10 </pages>
Reference-contexts: We argue that inheritance is not subtyping [CHC90] because inheritance is not logical. We also show how our general approach provides a computational interpretation of F-bounded polymorphism <ref> [CCHOM89] </ref>. In this watered-down Principia Mathematica of typed objects and records, we realize that many people are searching for an aestheic way to talk about these computational phenomena; as a consequence, differing perceptions of beauty provoke differing opinions as to the appropriateness of various calculi. <p> How far can this simple analogy be pushed to solve new problems with old technology? Given that powerful calculi have been proposed for developing typed objects and records, where the computational feasibility of ML-inspired calculi (e.g., [Rem89, Wan89]) has been traded for abstract mathematical power (e.g., <ref> [CCHOM89, CHC90, CM91] </ref>) |type inference for systems based on Girard's F 2 is a well known open problem, and in fact, type checking for a variant of F 2 with subtyping has been proven undecidable [Pie91]|why not see what happens when the inspiration of the Curry-Howard correspondence is followed up with <p> Bool hf lesseq gi must be provable if f is truly an Order; an impossibility, since f lesseq g cannot be reduced by the equational axioms to either true or false|the object g is not equipped with a value message. 3.5 F-bounded polymorphism The idea of F-bounded polymorphism proposed in <ref> [CCHOM89] </ref> is meant to get around such anomalies, in particular to "type" functions like 8 1 xy:min x y = if (x lesseq y) x y.
Reference: [Car88] <author> L. Cardelli. </author> <title> A semantics of multiple inher-itance. </title> <journal> Information and Computation 76:2/3, </journal> <year> 1988, </year> <pages> pp. 138-164. </pages>
Reference-contexts: Records provide a simple and well defined functional programming metaphor for object oriented programming, since records associate labels (object oriented messages) with values (object oriented methods) <ref> [Car88] </ref>. Adding and removing fields from a record then corresponds to adding and removing messages and methods from an object; these values can of course be procedures in a functional programming setting. Adding and removing fields from a record type similarly corresponds to mutation of object oriented class declarations.
Reference: [Car89] <author> L. Cardelli. </author> <title> Typeful programming. </title> <booktitle> Lecture Notes for the IFIP Advanced Seminar on Formal Methods in Programming Language Semantics, </booktitle> <address> Rio de Janeiro, Brazil, </address> <year> 1989. </year> <note> See also SRC Report 45, </note> <institution> Digital Equipment Corporation. </institution>
Reference-contexts: Here is a typical "rule" for subtyping in a programming language (see, e.g., <ref> [Car89, Bru92] </ref>): ` A 0 &lt;: A ` B &lt;: B 0 Why does this rule need to be mandated ex nihilo when it follows, in the right framework, from principles of logic? It ought to be a derived rule.
Reference: [Car91] <author> L. Cardelli. </author> <title> Extensible records in a pure calculus of subtyping. </title> <type> Unpublished draft. </type>
Reference-contexts: Also discussed is the issue of realizability in the context of logic. In recent work, for example, Cardelli has proposed a justification of record calculi via a translation into a variant of the Girard/Reynolds type system F 2 , augmented with subtyping rules <ref> [Car91] </ref>; Breazu-Tannen, Coquand, Gunter, and Scedrov have also described how programs in a type discipline with subsumption can be translated into one with explicit coercion instead [BCGS91, BGS90]. In a similar spirit, Church invented an informal "justification" of arithmetic via a translation into lambda calculus, i.e., Church numerals.
Reference: [CM91] <author> L. Cardelli and J. C. Mitchell. </author> <note> Operations on records. Mathematical Structures in Computer Science 1:1, </note> <year> 1991, </year> <pages> pp. 3-48. </pages>
Reference-contexts: How far can this simple analogy be pushed to solve new problems with old technology? Given that powerful calculi have been proposed for developing typed objects and records, where the computational feasibility of ML-inspired calculi (e.g., [Rem89, Wan89]) has been traded for abstract mathematical power (e.g., <ref> [CCHOM89, CHC90, CM91] </ref>) |type inference for systems based on Girard's F 2 is a well known open problem, and in fact, type checking for a variant of F 2 with subtyping has been proven undecidable [Pie91]|why not see what happens when the inspiration of the Curry-Howard correspondence is followed up with <p> For example, we can show that the type inference rules of a variant of Cardelli and Mitchell's record calculus <ref> [CM91] </ref> are sound, by showing that they follow from principles of "pure logic." This way, we can bypass a lot of unnecessary model theory. We choose two examples from their paper.
Reference: [CW85] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, </title> <journal> and polymor-phism. Computing Surveys 17(4) </journal> <pages> 471-522, </pages> <year> 1985. </year>
Reference-contexts: Prototypes can be augmented by adding an assertion about a field label and associated data type: Augment = [ : Term ! Term ! Prop][lab : Term][T : Pred] [rec : Term][` : Term] cond (Q ` lab) (T hrec `i) ( rec `) Variant records <ref> [CW85] </ref> can of course be developed by augmenting Augment, replacing conjunction with disjunction.
Reference: [Col91] <author> L. Colson. </author> <title> About primitive recursive algorithms. </title> <booktitle> Theoretical Computer Science 83 (1991), </booktitle> <pages> pp. 57-69. </pages>
Reference-contexts: Our introduction of higher-order iterators eliminates the need for unbounded computation for a host of well-known canonical (read "toy") examples, and appears sufficient for situations where the pieces of code satisfy a sort of "master-slave" relationship: anomalous behavior evidenced by programs without this property have been inves tigated by Colson <ref> [Col91] </ref>. It would be interesting to see if the expressiveness of the primitive recursive iterators is sufficient to formalize more sophisticated arguments about subtyping, for instance [AC91]. In reasoning about equational theories where the control is distributed, the robustness of the approach is not clear.
Reference: [CHC90] <author> W. R. Cook, W. L. Hill, and P. S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1990, </year> <pages> pp. 125-135. </pages>
Reference-contexts: This construction allows us to simulate all the usual examples of objects, and to show the soundness of a standard rule for proving a subtyping relation between recursively defined types. We argue that inheritance is not subtyping <ref> [CHC90] </ref> because inheritance is not logical. We also show how our general approach provides a computational interpretation of F-bounded polymorphism [CCHOM89]. <p> How far can this simple analogy be pushed to solve new problems with old technology? Given that powerful calculi have been proposed for developing typed objects and records, where the computational feasibility of ML-inspired calculi (e.g., [Rem89, Wan89]) has been traded for abstract mathematical power (e.g., <ref> [CCHOM89, CHC90, CM91] </ref>) |type inference for systems based on Girard's F 2 is a well known open problem, and in fact, type checking for a variant of F 2 with subtyping has been proven undecidable [Pie91]|why not see what happens when the inspiration of the Curry-Howard correspondence is followed up with
Reference: [CH88] <author> T. Coquand and G. Huet. </author> <title> The calculus of constructions. </title> <journal> Information and Computation 76:2/3, </journal> <year> 1988, </year> <pages> pp. 95-120. </pages>
Reference-contexts: We do this by giving a higher-order logical specification of what records are, as well as showing how to code types as record specifications. Record types are represented explicitly as dependent products in a logical sense. This formalization is carried out in the calculus of constructions <ref> [CH88] </ref>, a computational framework for formalizing intuitionistic arguments. As a consequence, we show that the Cardelli-Mitchell inference rules follow from principles of "pure logic." Questions about confluence, normalization, and soundness can then be deferred to their general treatment in the calculus of constructions. <p> The CC terms will then be "proof objects" that show how to construct proofs of our assertions. This may all sound complicated, but it isn't: the calculus of constructions is just a functional notation for manipulating proofs. A number of summaries of the calculus of constructions exist <ref> [Hue90, CH88] </ref>; we provide here the bare minimum to understand what follows. Abstraction is denoted by square brackets, and type quantification denoted by curly brackets.
Reference: [Gir72] <institution> J.-Y. Girard, Interpretation Fonctionnelle et Elimination des Coupures de l'Arithmetique d'Ordre Superieur. These de Doctorat d'Etat, Universite de Paris VII, </institution> <year> 1972. </year>
Reference-contexts: This contraction procedure is the essence of extracting programs from proofs <ref> [BB85, Gir72, GLT89, Lei90] </ref>. 4 The bracket notation hei abbreviates iterated use of apply : Term ! Term ! Term to build term e. 4 1.5 Subtyping and coercion We can now define subtyping, and an example "type" Even that is meant to be a subtype of Int: Subtype = [A
Reference: [GLT89] <author> J.-Y. Girard, Y. Lafont, and P. Taylor. </author> <title> Proofs and Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: This contraction procedure is the essence of extracting programs from proofs <ref> [BB85, Gir72, GLT89, Lei90] </ref>. 4 The bracket notation hei abbreviates iterated use of apply : Term ! Term ! Term to build term e. 4 1.5 Subtyping and coercion We can now define subtyping, and an example "type" Even that is meant to be a subtype of Int: Subtype = [A
Reference: [Hue90] <author> G. Huet. </author> <title> A uniform approach to type theory. In Logical Foundations of Functional Programming, </title> <editor> ed. G. </editor> <booktitle> Huet, </booktitle> <pages> pp. 337-398. </pages> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The CC terms will then be "proof objects" that show how to construct proofs of our assertions. This may all sound complicated, but it isn't: the calculus of constructions is just a functional notation for manipulating proofs. A number of summaries of the calculus of constructions exist <ref> [Hue90, CH88] </ref>; we provide here the bare minimum to understand what follows. Abstraction is denoted by square brackets, and type quantification denoted by curly brackets.
Reference: [Lei90] <author> D. Leivant. </author> <title> Contracting proofs to programs. </title> <booktitle> In Logic and Computer Science, </booktitle> <editor> ed. P. </editor> <booktitle> Odifreddi, </booktitle> <pages> pp. 279-328. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: This contraction procedure is the essence of extracting programs from proofs <ref> [BB85, Gir72, GLT89, Lei90] </ref>. 4 The bracket notation hei abbreviates iterated use of apply : Term ! Term ! Term to build term e. 4 1.5 Subtyping and coercion We can now define subtyping, and an example "type" Even that is meant to be a subtype of Int: Subtype = [A
Reference: [Mai91] <author> H. G. Mairson. </author> <title> Outline of a proof theory of parametricity. </title> <booktitle> In Fifth ACM Conference on Functional Programming Languages and Computer Architecture. LNCS 523, </booktitle> <year> 1991, </year> <pages> pp. 313-327. </pages>
Reference-contexts: Acknowledgements. It was Jeff Sanders who suggested that the approach of some earlier work <ref> [Mai91] </ref> on reasoning about programs based their on polymorphic data types be extended; I thank him for his encouragement and suggestions. Luca Cardelli has been particularly helpful with constructive comments and copious criticism.
Reference: [Pie91] <author> B. Pierce. </author> <title> Bounded quantification is undecidable. </title> <institution> Research Report CMU-CS-91-161, School of Computer Science, Carnegie Mel-lon University, </institution> <year> 1991. </year>
Reference: [Rem89] <author> D. Remy. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1989, </year> <pages> pp. 60-76. </pages>
Reference-contexts: How far can this simple analogy be pushed to solve new problems with old technology? Given that powerful calculi have been proposed for developing typed objects and records, where the computational feasibility of ML-inspired calculi (e.g., <ref> [Rem89, Wan89] </ref>) has been traded for abstract mathematical power (e.g., [CCHOM89, CHC90, CM91]) |type inference for systems based on Girard's F 2 is a well known open problem, and in fact, type checking for a variant of F 2 with subtyping has been proven undecidable [Pie91]|why not see what happens when
Reference: [Wan89] <author> M. Wand. </author> <title> Type inference for record concatenation and simple objects. </title> <booktitle> Fourth IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1989, </year> <pages> pp. 92-97. </pages>
Reference-contexts: How far can this simple analogy be pushed to solve new problems with old technology? Given that powerful calculi have been proposed for developing typed objects and records, where the computational feasibility of ML-inspired calculi (e.g., <ref> [Rem89, Wan89] </ref>) has been traded for abstract mathematical power (e.g., [CCHOM89, CHC90, CM91]) |type inference for systems based on Girard's F 2 is a well known open problem, and in fact, type checking for a variant of F 2 with subtyping has been proven undecidable [Pie91]|why not see what happens when
References-found: 22

