URL: ftp://ftp.cs.utexas.edu/pub/predator/subjectivity-icsr95.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Email: batory@cs.utexas.edu  
Title: Subjectivity and GenVoca Generators  
Author: Don Batory 
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas,  
Abstract: 1 The tenet of subjectivity is that no single interface can adequately describe any object; interfaces to the same object will vary among different applications. Thus, objects with standardized interfaces seem too brittle a concept to meet the demands of a wide variety of applications. Yet, objects with standardized interfaces is a central idea in domain modeling and software generation. Standard interfaces make objects plug-compatible and interchangeable, and it is this feature that is exploited by generators to synthesize high-performance, domain-specific software systems. Interestingly, generated systems have customized interfaces that can be quite different from the interfaces of their constituent objects. In this paper, we reconcile this apparent contradiction by showing that the objects (components) in the GenVoca model of software generation are not typical software modules; their interfaces and bodies mutate upon instantiation to a standard that is application-dependent. 
Abstract-found: 1
Intro-found: 1
Reference: [Bat92] <author> D. Batory and S. OMalley, </author> <title> The Design and Implementation of Hierarchical Software Systems with Reusable Components, </title> <journal> ACM TOSEM, </journal> <month> October </month> <year> 1992. </year>
Reference-contexts: How- ever, objects with standardized interfaces seems at odds with the need for generators to produce customized interfaces for the software that they generate. In this paper, we explore the relationship of subjectivity to a class of generators called GenVoca generators <ref> [Bat92] </ref>. (We believe that subjectivity impacts all generators, but in this paper we focus exclusively on its impact on GenVoca). <p> Indeed, when GenVoca interfaces are defined, there are operations that most people would agree are core or intrinsic, but many other operations are optional or subjective. 2. A domain abstraction is often defined by an interrelated network of objects/classes <ref> [Jon88, Bat92, Gam94, Oss92-95] </ref>. Stan- dardizing the interface of a domain abstraction is accomplished by standardizing the interfaces of its constituent objects/classes. Example. P2 is a GenVoca generator for container data structures [Bat93-94a]. The core operations that one can perform on containers are element retrievals, updates, insertions, and deletions. <p> It is this perspective that one should keep in mind when reviewing the following generator implementations. Genesis. Genesis was the first GenVoca generator; it demonstrated that customized database management systems (in excess of 50,000 lines of code) could be assembled from prefabricated components <ref> [Bat92] </ref>. Genesis relied on a rather rigid (and in hindsight) inexible way of accommodating subjectivity; realm interfaces evolved as new components were written. <p> We discovered that once the first few components were added, realm interfaces quickly reached a steady state. So backtracking and global updating was minimal. Avoca. Avoca/x-kernel demonstrated that highly layered communications protocols could be more efficient and more extensible than monolithic protocols <ref> [Hut91, Bat92] </ref>. Avoca realm interfaces were rigid (i.e., cast-in-concrete) sets of operations. Microproto- cols, the name given to Avoca components, implemented a fixed-set of core operations for transmitting messages and opening and closing sessions, plus an additional operation control. <p> The combinations of concrete classes that can work together can be defined in a variety of ways (e.g., informally or using factory design patterns [Gam94]); there is no fixed rule about how concrete classes can be paired. Realms and frameworks are indeed similar <ref> [Bat92] </ref>: the n classes of a realms interface correspond to the n abstract classes of a framework. Each GenVoca/P++ component specifies an n-tuple of concrete classes (one concrete class per abstract class) that work together as a unit.
Reference: [Bat93] <author> D. Batory, et al., </author> <title> Scalable Software Libraries, </title> <booktitle> ACM SIGSOFT 1993. </booktitle>
Reference-contexts: Automatic design rule checking was needed to validate compositions [Bat95]. 4. The relatively small size of GenVoca libraries is not a consequence of limited prototypes, but rather the scalability of Gen- Voca domain models <ref> [Bat93, Big94] </ref>. 5. Components were added to realms in the order that maximally stressed realm interfaces. We discovered that once the first few components were added, realm interfaces quickly reached a steady state. So backtracking and global updating was minimal. Avoca. <p> Extensions and their compositions are similar to the GenVoca concepts of components and type equations. Moreover, similar scalability arguments have been advanced independently for both models and that not all compositions of extensions (or GenVoca components) may be semantically correct (c.f., <ref> [Bat93] </ref> and [Oss92]). The models are not the same, however, as (for example) extensions have no counterparts to realms and realm parameters.
Reference: [Bat94a] <author> D. Batory, J. Thomas, and M. Sirkin, </author> <title> Re- engineering a Complex Application Using a Scalable Data Structure Compiler, </title> <booktitle> ACM SIGSOFT 1994. </booktitle>
Reference: [Bat94b] <author> D. Batory, et al., </author> <title> The GenVoca Model of Software-System Generators, </title> <journal> IEEE Software, </journal> <month> September </month> <year> 1994. </year>
Reference-contexts: In this section, we propose a model of these mechanisms as extensions to the P++ language <ref> [Sin93, Bat94b] </ref>. P++ is a super- set of C++ that is specifically designed to support the GenVoca model. Among its extensions are declarations for realms, components, and parameters.
Reference: [Bat95] <author> D. Batory and B.J. Geraci, </author> <title> Validating Component Compositions in Software System Generators, </title> <note> ICSR 1996 (this proceedings). </note>
Reference-contexts: The constraints on using components in type equations i.e., their compatibility or incompatibility with other components is directly encoded as composition rules (a.k.a. design rules) in the generators domain model <ref> [Bat95] </ref>. However, recognizing composition constraints and adding these constraints to the domain model is the responsibility of domain analysts and component implementors. There is no tool support or automatic way of recognizing the compatibilities and incompatibilities of components; deep domain knowledge is required. <p> This meant that components of R were not always interchangeable and that not all syntactically correct compositions of Genesis components were semantically correct. Automatic design rule checking was needed to validate compositions <ref> [Bat95] </ref>. 4. The relatively small size of GenVoca libraries is not a consequence of limited prototypes, but rather the scalability of Gen- Voca domain models [Bat93, Big94]. 5. Components were added to realms in the order that maximally stressed realm interfaces. <p> This means that size_of cannot be composed with L to yield a valid type equation. Such a constraint can be expressed using design rules <ref> [Bat95] </ref>. Alternatively, size_of could be made compatible with L if it defines rewrites for the element insertion and deletion operations of L. <p> Another challenging problem is how to encapsulate design rules within P++ components. Presently, design rule checking is accomplished with a tool external to P++ <ref> [Bat95] </ref>. Thus, design rules for components are specified separately from P++ component definitions. The difficulty of integration is that 8.
Reference: [Big94] <author> T. Biggerstaff, </author> <title> The Library Scaling Problem and the Limits of Concrete Component Reuse, </title> <address> ICSR 1994 (Rio de Janeiro). </address>
Reference-contexts: Automatic design rule checking was needed to validate compositions [Bat95]. 4. The relatively small size of GenVoca libraries is not a consequence of limited prototypes, but rather the scalability of Gen- Voca domain models <ref> [Bat93, Big94] </ref>. 5. Components were added to realms in the order that maximally stressed realm interfaces. We discovered that once the first few components were added, realm interfaces quickly reached a steady state. So backtracking and global updating was minimal. Avoca.
Reference: [Cha94] <author> C. Chambers and G.T. Leavens, </author> <title> Type Checking and Modules for Multi-Methods, </title> <booktitle> OOPSLA 1994. </booktitle>
Reference-contexts: Many exciting and challenging open issues remain: support for run- time compositions, integration of design rule checking with P++, experimentation with the proposed features, development of domain modeling techniques that incorporate interface subjectivity, and formalization of GenVoca concepts <ref> [Cha94, Nen95] </ref>. Acknowledgments. I thank Reed Little (SEI) for pointing out the similarity of method wrapper mechanisms in CLOS and FLAVORS to the operation bypasses in GenVoca components.
Reference: [Cog93] <author> L. Coglianese and R. Szymanski, </author> <title> DSSA- ADAGE: An Environment for Architecture-based Avionics Development, </title> <booktitle> Proc. </booktitle> <address> AGARD, </address> <year> 1993. </year>
Reference: [Elm89] <author> R. Elmasri and S.B. Navathe, </author> <title> Fundamentals of Database Systems, </title> <address> Benjamin/Cummings, </address> <year> 1989. </year>
Reference-contexts: Subjectivity. Subjectivity arose from the need for simplifying programming abstractions, e.g., defining views that emphasize relevant aspects of objects and that hide irrelevant details [Shi89, Hai90, Gam94]. This lead to a connection of object modeling with view integration in databases <ref> [Elm89] </ref>, namely, objects models can be defined as a result of integrating different application (or sub-application) views of objects [Gol81, Har92]. Ossher and Harrison took an important step further by recognizing that application-specific views of inheritance hierarchies can be produced automatically by composing building blocks called extensions [Oss92].
Reference: [For95] <author> I.R. Forman, et al. </author> <title> Composition of Before/ After Metaclasses in SOM, </title> <booktitle> OOPSLA 1994. </booktitle>
Reference-contexts: Wrappers in CLOS are different than in P++ as they are defined on a per- operation basis. A model of wrappers that is closer to P++ is that of SOM metaclasses, where all (or selected) operations of a class can be wrapped by before and after methods <ref> [For95] </ref>. Wrappers are defined in SOM by overriding the dispatch methods of metaclasses.
Reference: [Gam94] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software, </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Indeed, when GenVoca interfaces are defined, there are operations that most people would agree are core or intrinsic, but many other operations are optional or subjective. 2. A domain abstraction is often defined by an interrelated network of objects/classes <ref> [Jon88, Bat92, Gam94, Oss92-95] </ref>. Stan- dardizing the interface of a domain abstraction is accomplished by standardizing the interfaces of its constituent objects/classes. Example. P2 is a GenVoca generator for container data structures [Bat93-94a]. The core operations that one can perform on containers are element retrievals, updates, insertions, and deletions. <p> An object-oriented framework is a set of abstract classes with their own set of concrete classes. The combinations of concrete classes that can work together can be defined in a variety of ways (e.g., informally or using factory design patterns <ref> [Gam94] </ref>); there is no fixed rule about how concrete classes can be paired. Realms and frameworks are indeed similar [Bat92]: the n classes of a realms interface correspond to the n abstract classes of a framework. <p> Subjectivity. Subjectivity arose from the need for simplifying programming abstractions, e.g., defining views that emphasize relevant aspects of objects and that hide irrelevant details <ref> [Shi89, Hai90, Gam94] </ref>. This lead to a connection of object modeling with view integration in databases [Elm89], namely, objects models can be defined as a result of integrating different application (or sub-application) views of objects [Gol81, Har92].
Reference: [Gog86] <author> J.A. Goguen, </author> <title> Reusing and Interconnecting Software Components, </title> <booktitle> Computer, </booktitle> <month> February </month> <year> 1986. </year>
Reference-contexts: The models are not the same, however, as (for example) extensions have no counterparts to realms and realm parameters. It is worth noting that a rather different and powerful approach to views and software reuse has been pro 9 posed by Goguen <ref> [Gog86] </ref>, Novak [Nov95], and Van Hilst [Van95]. The essential idea is to define generic packages that present a customized interface to an object (or sets of objects). A view defines a mapping of each object to its customized perspective. Module Interconnection Languages (MILs). <p> As another example, Goguens model of parameterized programming (LIL) permits simple transforms on modules, such as combining modules by merging their operations and types; types, operations, and exceptions can be added, exchanged, removed, or renamed, etc. <ref> [Gog86, Tra93] </ref>. While the basic transforms are present to achieve subjectivity, there are no higher- order transforms that query module interfaces, wrap all or selected operations of a module, and propagate operations to other modules; such capabilities can only be specified manually on a per module basis. Reectivity.
Reference: [Gol81] <author> P. Goldstein et al., </author> <title> An Experimental Description-Based Programming Environment: Four Reports, </title> <journal> TR CSL-81-3, </journal> <note> Xerox PARC, </note> <month> March </month> <year> 1981. </year>
Reference-contexts: This lead to a connection of object modeling with view integration in databases [Elm89], namely, objects models can be defined as a result of integrating different application (or sub-application) views of objects <ref> [Gol81, Har92] </ref>. Ossher and Harrison took an important step further by recognizing that application-specific views of inheritance hierarchies can be produced automatically by composing building blocks called extensions [Oss92].
Reference: [Hai90] <author> B. Hailpern and H. Ossher, </author> <title> Extending Objects to Support Multiple Interfaces and Access Control, </title> <journal> IEEE TSE, </journal> <month> November </month> <year> 1990. </year>
Reference-contexts: Subjectivity. Subjectivity arose from the need for simplifying programming abstractions, e.g., defining views that emphasize relevant aspects of objects and that hide irrelevant details <ref> [Shi89, Hai90, Gam94] </ref>. This lead to a connection of object modeling with view integration in databases [Elm89], namely, objects models can be defined as a result of integrating different application (or sub-application) views of objects [Gol81, Har92].
Reference: [Har92] <author> W. Harrison, et al., </author> <title> Integrating Coarse-grained and Fine-Grained Tool Integration, </title> <booktitle> Workshop on Computer-Aided Software Engineering, </booktitle> <month> July </month> <year> 1992. </year>
Reference-contexts: This lead to a connection of object modeling with view integration in databases [Elm89], namely, objects models can be defined as a result of integrating different application (or sub-application) views of objects <ref> [Gol81, Har92] </ref>. Ossher and Harrison took an important step further by recognizing that application-specific views of inheritance hierarchies can be produced automatically by composing building blocks called extensions [Oss92].
Reference: [Har93] <author> W. Harrison and H. Ossher, </author> <title> Subject-Oriented Programming (A Critique of Pure Objects), </title> <booktitle> OOPSLA 1993. </booktitle>
Reference: [Har94] <author> W. Harrison, H. Ossher, R.B. Smith, and D. Ungar, </author> <booktitle> Subjectivity in Object-Oriented Systems: Workshop Summary, Addendum to OOPSLA 1994. </booktitle>
Reference: [Hei93] <author> J. Heidemann and G. Popek, </author> <title> File System Development with Stackable Layers, </title> <journal> ACM TCS, </journal> <month> March </month> <year> 1993. </year>
Reference-contexts: Calling a control function essentially requires polling each component of a type equation to test if it could process the function. Control functions were not called frequently enough in Avoca for their inefficiencies to be problematic. Ficus. Ficus builds customized file systems from a single realm of components <ref> [Hei93] </ref>. All Ficus layers 6. Note that a nondefault method, i.e., something other than transmitting the control function call to lower layers, could easily be encoded in this scheme. 5 support the same set of core operations plus any number of layer-specific operations. <p> However, several important open problems remain. P++ components are presently compos- able only at application compile-time; ideally, components should also be composable at run-time. Such a capability would permit software systems to evolve dynamically. Although there are several possibilities on how to proceed (e.g., <ref> [For94, Hei93, Hut91] </ref>), it is not clear what run-time capabilities should be added to P++ to support the dynamic composition of components with bypass methods. Another challenging problem is how to encapsulate design rules within P++ components. Presently, design rule checking is accomplished with a tool external to P++ [Bat95].
Reference: [Hei95] <author> J. Heidemann, </author> <title> email correspondence, </title> <year> 1995. </year>
Reference: [Hut91] <author> N. Hutchinson and L. Peterson, </author> <title> The x-kernel: An Architecture for Implementing Network Protocols, </title> <journal> IEEE TSE, </journal> <month> January </month> <year> 1991. </year>
Reference-contexts: We discovered that once the first few components were added, realm interfaces quickly reached a steady state. So backtracking and global updating was minimal. Avoca. Avoca/x-kernel demonstrated that highly layered communications protocols could be more efficient and more extensible than monolithic protocols <ref> [Hut91, Bat92] </ref>. Avoca realm interfaces were rigid (i.e., cast-in-concrete) sets of operations. Microproto- cols, the name given to Avoca components, implemented a fixed-set of core operations for transmitting messages and opening and closing sessions, plus an additional operation control. <p> However, several important open problems remain. P++ components are presently compos- able only at application compile-time; ideally, components should also be composable at run-time. Such a capability would permit software systems to evolve dynamically. Although there are several possibilities on how to proceed (e.g., <ref> [For94, Hei93, Hut91] </ref>), it is not clear what run-time capabilities should be added to P++ to support the dynamic composition of components with bypass methods. Another challenging problem is how to encapsulate design rules within P++ components. Presently, design rule checking is accomplished with a tool external to P++ [Bat95].
Reference: [Joh88] <author> R.E. Johnson and B. Foote, </author> <title> Designing Reusable Classes, </title> <journal> Journal of Object-Oriented Programming, </journal> <month> June/July </month> <year> 1988. </year>
Reference-contexts: Coding function calls via switch statements and marshalling arguments are well-known to be obscure ways of programming <ref> [Joh88] </ref>. Moreover, there can be a considerable performance overhead in processing control operations. Calling a control function essentially requires polling each component of a type equation to test if it could process the function. Control functions were not called frequently enough in Avoca for their inefficiencies to be problematic. Ficus.
Reference: [Kic91] <author> G. Kiczales, J. des Rivieres, and D.G. Bobrow, </author> <title> The Art of the Metaobject Protocol, </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Reectivity. Bypass methods correspond to method wrappers or before and after methods in metaobject protocols <ref> [Kic91] </ref>. CLOS was among the first languages to have method wrappers. Wrappers in CLOS are different than in P++ as they are defined on a per- operation basis.
Reference: [Mic95] <author> Microsoft, </author> <title> The Component Object Model Specification, </title> <month> March </month> <year> 1995. </year>
Reference-contexts: Module Interconnection Languages (MILs). Lim- ited forms of subjectivity can be achieved through MILs. Microsofts Common Object Model (COM) permits objects to have a set of (upwards compatible) interfaces to maintain backwards compatibility with old views of objects <ref> [Mic95] </ref>. As another example, Goguens model of parameterized programming (LIL) permits simple transforms on modules, such as combining modules by merging their operations and types; types, operations, and exceptions can be added, exchanged, removed, or renamed, etc. [Gog86, Tra93].
Reference: [Nen95] <author> M. Nenninger and F. Nickl, </author> <title> Implementing Data Structures by Composition of Reusable Components: A Formal Approach, </title> <booktitle> ICSE-17 Workshop on Formal Methods Applications in Software Engineering Practice, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: Many exciting and challenging open issues remain: support for run- time compositions, integration of design rule checking with P++, experimentation with the proposed features, development of domain modeling techniques that incorporate interface subjectivity, and formalization of GenVoca concepts <ref> [Cha94, Nen95] </ref>. Acknowledgments. I thank Reed Little (SEI) for pointing out the similarity of method wrapper mechanisms in CLOS and FLAVORS to the operation bypasses in GenVoca components.
Reference: [Nov95] <author> G.S. Novak, </author> <title> Creation of Views for Reuse of Software with Different Data Representations, </title> <journal> IEEE TOSE, </journal> <month> December </month> <year> 1995. </year>
Reference-contexts: The models are not the same, however, as (for example) extensions have no counterparts to realms and realm parameters. It is worth noting that a rather different and powerful approach to views and software reuse has been pro 9 posed by Goguen [Gog86], Novak <ref> [Nov95] </ref>, and Van Hilst [Van95]. The essential idea is to define generic packages that present a customized interface to an object (or sets of objects). A view defines a mapping of each object to its customized perspective. Module Interconnection Languages (MILs).
Reference: [Oss92] <author> H. Ossher and W. Harrison, </author> <title> Combination of Inheritance Hierarchies, </title> <booktitle> OOPSLA 1992. </booktitle>
Reference-contexts: Ossher and Harrison took an important step further by recognizing that application-specific views of inheritance hierarchies can be produced automatically by composing building blocks called extensions <ref> [Oss92] </ref>. An extension encapsulates a primitive aspect or view of a hierarchy, whose implementation requires a set of additions (e.g., new data and method members) to one or more classes of the hierarchy. A customized view of an inheritance hierarchy could therefore be defined by composing extensions. <p> Extensions and their compositions are similar to the GenVoca concepts of components and type equations. Moreover, similar scalability arguments have been advanced independently for both models and that not all compositions of extensions (or GenVoca components) may be semantically correct (c.f., [Bat93] and <ref> [Oss92] </ref>). The models are not the same, however, as (for example) extensions have no counterparts to realms and realm parameters. It is worth noting that a rather different and powerful approach to views and software reuse has been pro 9 posed by Goguen [Gog86], Novak [Nov95], and Van Hilst [Van95].
Reference: [Oss95] <author> H. Ossher, et al., </author> <title> Subject-Oriented Composition Rules, </title> <booktitle> OOPSLA 1995. </booktitle>
Reference-contexts: Once again, there are possibilities on how to proceed (e.g., <ref> [Oss95] </ref>). 3 Related Work Frameworks. An object-oriented framework is a set of abstract classes with their own set of concrete classes.
Reference: [Shi89] <author> J.J. Shilling and P.F. Sweeney, </author> <title> Three Steps to Views: Extending the Object-Oriented Paradigm, </title> <booktitle> OOPSLA 1989. </booktitle>
Reference-contexts: Subjectivity. Subjectivity arose from the need for simplifying programming abstractions, e.g., defining views that emphasize relevant aspects of objects and that hide irrelevant details <ref> [Shi89, Hai90, Gam94] </ref>. This lead to a connection of object modeling with view integration in databases [Elm89], namely, objects models can be defined as a result of integrating different application (or sub-application) views of objects [Gol81, Har92].
Reference: [Sin93] <author> V. Singhal and D. Batory, </author> <title> P++: A Language for Large-Scale Reusable Software Components, </title> <address> WISR (Owego, New York), </address> <month> November </month> <year> 1993. </year>
Reference-contexts: In this section, we propose a model of these mechanisms as extensions to the P++ language <ref> [Sin93, Bat94b] </ref>. P++ is a super- set of C++ that is specifically designed to support the GenVoca model. Among its extensions are declarations for realms, components, and parameters.
Reference: [Sym84] <author> Symbolics, Inc., </author> <title> Intermediate Lisp Programming, </title> <month> September </month> <year> 1984. </year>
Reference: [Tra93] <author> W. Tracz, LILEANNA: </author> <title> A Parameterized Programming Language, </title> <booktitle> ICSR 1993, Lucca, </booktitle> <address> Italy. </address>
Reference-contexts: As another example, Goguens model of parameterized programming (LIL) permits simple transforms on modules, such as combining modules by merging their operations and types; types, operations, and exceptions can be added, exchanged, removed, or renamed, etc. <ref> [Gog86, Tra93] </ref>. While the basic transforms are present to achieve subjectivity, there are no higher- order transforms that query module interfaces, wrap all or selected operations of a module, and propagate operations to other modules; such capabilities can only be specified manually on a per module basis. Reectivity.
Reference: [Van95] <author> M. Van Hilst and D. Notkin, </author> <title> Using C++ Templates to Implement Role-Based Designs, </title> <institution> Dept. Computer Science and Engineering, University of Washington, </institution> <note> TR 95-07-02. </note>
Reference-contexts: The models are not the same, however, as (for example) extensions have no counterparts to realms and realm parameters. It is worth noting that a rather different and powerful approach to views and software reuse has been pro 9 posed by Goguen [Gog86], Novak [Nov95], and Van Hilst <ref> [Van95] </ref>. The essential idea is to define generic packages that present a customized interface to an object (or sets of objects). A view defines a mapping of each object to its customized perspective. Module Interconnection Languages (MILs). Lim- ited forms of subjectivity can be achieved through MILs.
References-found: 32

