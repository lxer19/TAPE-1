URL: http://www.cam.sri.com/tr/crc008/paper.ps.Z
Refering-URL: http://www.cam.sri.com/tr/ABSTRACTS.html
Root-URL: 
Title: Overview of the Core Language Engine  
Author: H. Alshawi, D.M. Carter, J. van Eijck, R.C. Moore, D.B. Moran S.G. Pulman 
Affiliation: SRI International Cambridge Computer Science Research Centre  University of Cambridge Computer Laboratory and SRI International Cambridge Computer Science Research Centre  
Date: 1988  September, 1988  
Note: of Future Generation Computing Systems, Tokyo,  
Web: URL: http://www.cam.sri.com/tr/crc008/paper.ps.ZProceedings  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: <author> Alshawi, H., D. M. Carter, J. van Eijck, R. C. Moore, D. B. Moran, F. C. N. Pereira, S. G. Pulman and A. G. Smith. </author> <title> (1988) Interim Report on the SRI Core Language Engine. </title> <type> Technical Report CCSRC-5, </type> <institution> Cambridge Computer Science Research Centre, SRI International, </institution> <address> Cambridge, England. </address>
Reference-contexts: A well-formed substring table is also used to avoid re-analysis of already parsed constituents after backtracking. The implementation of these elaborations of the basic algorithm allows for the possibility of fully general CLE categories containing variables <ref> (see Alshawi, et al, 1988) </ref>. Another parser based on Prolog unification and a bottom-up strategy is the BUP system (Matsumoto, et al, 1983).
Reference: <author> Chomsky, N. </author> <title> (1965) Aspects of the Theory of Syntax. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts. </address>
Reference-contexts: Thus a phrase like give a book to me will have a structure like: [[[give] vp [a book] np ] vp [to me] pp ] vp 2. Syntactically predictable alternations are handled by rules which capture the effect of what in Standard Theory Transformational Grammar <ref> (Chomsky, 1965) </ref> were `lexically governed' transformations. Thus a rule like: vp:[subcat=[], subjform=it,...] --&gt; vp:[subcat=[], extraposes=y,...] s:[...] will allow verbs and adjectives like bother and obvious to appear in a frame like it [bothers him / is obvious] that S as well as that S [bothers him / is obvious].
Reference: <author> Cooper, R. </author> <title> (1983) Quantification and Syntactic Theory. </title> <address> D. </address> <publisher> Reidel, Dordrecht, Holland. </publisher>
Reference: <author> Gazdar, G., E. Klein, G. K. Pullum, and I. A. </author> <title> Sag (1985) Generalised Phrase Structure Grammar. </title> <publisher> Blackwell, Oxford. </publisher>
Reference-contexts: computational efficiency. 2 Category and Feature System Information about the syntactic and semantic properties of linguistic constituents is represented in the CLE using complex categories that include a principal category symbol and specifications of constraints on the values of syntactic and semantic features - cf. the feature systems of GPSG <ref> (Gazdar, et al, 1985) </ref> and PATR-II (Shieber, 1986). Categories appear in syntax rules, semantic interpretation rules, and lexical entries. Two categories can be unified if the constraints on their feature values are compatible.
Reference: <author> Hobbs, J. R., and S. M. </author> <title> Shieber (1987) An Algorithm for Generating Quantifier Scopings. </title> <journal> Computational Linguistics, </journal> <volume> Vol. 13, no 1-2. </volume>
Reference: <author> Matsumoto, Y., H. Tanaka, H. Hirakawa, H. Miyoshi, and H. </author> <title> Yasukawa (1983) BUP: a bottom-up parser embedded in Prolog. </title> <journal> New Generation Computing, </journal> <volume> Vol. 1, no 2, </volume> <pages> pp. 145-158. </pages>
Reference-contexts: The implementation of these elaborations of the basic algorithm allows for the possibility of fully general CLE categories containing variables (see Alshawi, et al, 1988). Another parser based on Prolog unification and a bottom-up strategy is the BUP system <ref> (Matsumoto, et al, 1983) </ref>. Our parser is an extension of this in that its top- down filtering uses feature values as well as major categories, and its well-formed substring table construction is sound since it is based on subsumption checking.
Reference: <author> Mellish, C. S. </author> <title> (1987) Implementing Systemic Classification by Unification. </title> <journal> Computational Linguistics, </journal> <volume> Vol. 14, no 1, </volume> <pages> pp. 40-51. </pages>
Reference-contexts: These values are compiled into terms which unify if and only if the expressions are compatible <ref> (see Mellish, 1987) </ref>. More generally, category compilation in the CLE ensures that category unification is implemented efficiently as Prolog term unification. <p> The term for an argument sort is an encoding of the sort of a class of individuals according to a classification hierarchy <ref> (Mellish 1987) </ref>. Mutually exclusive classes are encoded as terms with different functors, ensuring that they do not unify: abstract (_) object (_,_,_) Further instantiation of these terms gives finer degrees of classification: the term for a `human animate object' might be object (animate (human,_),_,_).
Reference: <author> Montague, R. </author> <title> (1974) Formal Philosophy: Selected Papers of Richard Montague. Ed. by Richmond Thomason, </title> <publisher> Yale University Press, </publisher> <address> New Haven. </address>
Reference-contexts: Rather than using lambda expressions in the way they are traditionally employed in compositional semantics <ref> (Montague 1974) </ref>, we normally employ unification to compress the work of functional application and lambda reduction into one step. Thus arguments are immediately plugged into slots in the logical form that are 5 marked by Prolog variables.
Reference: <author> Moran, D. B. </author> <title> (1988) Quantifier Scoping in the SRI Core Language Engine. </title> <booktitle> Proceedings of the 26th Annual Meeting of the Association for Computational Linguistics, </booktitle> <address> Buffalo, New York. </address>
Reference-contexts: mother logical form is extracted from the rule and a sorted version of the form is built, making sure that it does not violate any sortal restrictions. 9 Quantifier Scoping An algorithm for generating the possible quantifier scopings for a sentence, in order of preference, has been developed and implemented <ref> (Moran, 1988) </ref>. Quantifier scoping generates the two possible readings for A bishop wanted to visit every college from the unscoped LF (given in Section 4 above) by replacing the qterms with quant expressions corresponding to generalized quantifiers.
Reference: <author> Pereira, F. C. N., and S. M. </author> <title> Shieber (1987) Prolog and Natural-Language Analysis. Center for the Study of Language and Information, </title> <publisher> Stanford. </publisher>
Reference-contexts: The existence of the former is predictable from that of the latter. 3. Unbounded dependency constructions like wh-questions and relative clauses are treated by list valued features which `thread' the dependency through a tree <ref> (see Pereira and Shieber, 1987) </ref>. A rule introducing such a dependency will `push' a `gap' onto the head of the GapsSoughtIn list, and a rule discharging such a dependency will `pop' a gap present on the GapsSoughtIn list, resulting in a GapsSoughtOut list with one fewer gap on it.
Reference: <author> Rosenkrantz, D. J., and P. M. </author> <title> Lewis (1970) Deterministic Left Corner Parsing. </title> <booktitle> Conference Record of the 11th Annual Symposium on Switching and Automata Theory, IEEE, </booktitle> <pages> pp. 139-152. </pages>
Reference-contexts: Word parsing and sense derivation are similar to the processes of sentence parsing and interpretation, but simpler because packing is not used at the sub-lexical level of analysis. The parser in the CLE uses a `left-corner' parsing strategy with top-down filtering <ref> (Rosenkrantz and Lewis, 1970) </ref>. This is primarily a bottom-up strategy, but it does a limited amount of top-down processing in order to use the left context to decide whether a particular constituent could occur at a given position in the input.
Reference: <author> Tomita, M. </author> <title> (1985) An Efficient Context-Free Parsing Algorithm for Natural Languages. </title> <booktitle> Proceedings of the Ninth International Joint Conference on Artificial Intelligence, </booktitle> <address> Los Angeles, California, </address> <pages> pp. 756-764. </pages>
Reference: <author> Woods, W. A. </author> <title> (1977) Semantics and Quantification in Natural Language Question Answering. </title> <booktitle> In: Advances in Computers, </booktitle> <volume> Volume 17, </volume> <publisher> Academic Press, </publisher> <address> New York, New York: </address> <pages> 1-87. 13 </pages>
Reference-contexts: Unlike the flat stores of Cooper (1983) and the LUNAR system <ref> (Woods, 1977) </ref>, our algorithm uses a store in which the structure of the quantifier terms reflects their relative positions in the unscoped logical form, so we can apply order-dependent linguistic preferences.
References-found: 13

