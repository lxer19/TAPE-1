URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-10.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-10.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Catriel Beeri and Yoram Kornatzky, </author> <title> "Algebraic Optimization of Object-Oriented Query Languages," </title> <booktitle> Proceedings of the International Con ference on Database Theory (1990), </booktitle> <pages> 72-83. </pages>
Reference-contexts: With cells, we could have the same object represented as two different nodes, as the identity of the cells provides the uniqueness. 3 Related Work Much of the previous work with ordering deals with order as in sequences or arrays. Beeri and Kornatzky <ref> [1] </ref> discuss trees in their paper. However, there is no known work with directed acyclic graphs or graphs. Beeri and Kornatzky [1] propose an object-oriented query processing paradigm where the objects are built of primitive objects, an explicit object identity type constructor, and bulk type constructors. <p> Beeri and Kornatzky <ref> [1] </ref> discuss trees in their paper. However, there is no known work with directed acyclic graphs or graphs. Beeri and Kornatzky [1] propose an object-oriented query processing paradigm where the objects are built of primitive objects, an explicit object identity type constructor, and bulk type constructors. Then operations and optimizations are presented, which apply to any bulk type constructor definable in their paradigm. <p> In this approach, lists, arrays, and trees can all be defined, and a subset of the useful operations on such structures is described in the paper. These operations include a "pump" function, which is similar to AQUA's fold operation. Since the operations described in <ref> [1] </ref> are intended to be applicable to any bulk type, not just to lists and trees, they are too general for our purposes we wish to distinguish between ordered and unordered types, and provide a richer set of operations. Furthermore, many of the operations listed in [1] are not described precisely, <p> the operations described in <ref> [1] </ref> are intended to be applicable to any bulk type, not just to lists and trees, they are too general for our purposes we wish to distinguish between ordered and unordered types, and provide a richer set of operations. Furthermore, many of the operations listed in [1] are not described precisely, and their existence is assumed. Here we remove that assumption. Graphs are not discussed in [1], and it is not clear how (or if) they would fit into the paradigm presented there. <p> Furthermore, many of the operations listed in <ref> [1] </ref> are not described precisely, and their existence is assumed. Here we remove that assumption. Graphs are not discussed in [1], and it is not clear how (or if) they would fit into the paradigm presented there. MDM [8] talks about a query algebra to support lists in an object-oriented data model. Operators from a discrete, linear-time temporal logic provide the basis for the algebra.
Reference: [2] <author> James C. French, Anita K. Jones, and John L. Pfaltz, </author> <title> "Summary of the Final Report of the NSF Workshop on Scientific Database Mgmt.," </title> <booktitle> SIGMOD Record 19 (1990), </booktitle> <pages> 32-40. </pages>
Reference: [3] <author> Karen A. Frenkel, </author> <title> "The Human Genome Project and Informatics," </title> <booktitle> Communications of the ACM 34 (1991), </booktitle> <pages> 41-51. </pages>
Reference: [4] <author> Seymour Ginsburg and Xiaoyang Wang, </author> <title> "Pat tern Matching by Rs-Operations: Towards a Unified Approach to Querying Sequenced Data," </title> <booktitle> Proceedings of the 11th ACM Principles of Database Systems (1992), </booktitle> <pages> 293-300. </pages>
Reference-contexts: As a result, most of the operators are not commutative. Duplicates are allowed in lists, however union and intersection eliminate duplicates from the result set. A tree-like structure in a document (paragraphs under sections) is handled by treating it as a nested sequence of sequences. Rs-operations <ref> [4] </ref> are sequence operations that are based on pattern matching. Along with these operations, sequence logic (SL), which is a first-order logic, is also introduced. Ginsburg and Wang define a set of powerful operations based on regular expressions, 3 which act as a kind of template for the operation.
Reference: [5] <author> Ralf Harmut Guting, Roberto Zicari, and David M. Choy, </author> <title> "An Algebra for Structured Office Documents," </title> <booktitle> ACM Transactions on Office In formation Systems 7 (1989), </booktitle> <pages> 123-157. </pages>
Reference-contexts: Union and difference are similar to the corresponding operators in EXTRA/EXCESS [9]. However, the MDM algebra does not provide for operations on trees or graphs. The NST algebra <ref> [5] </ref> is specifically designed for structured office documents and is an extension of relational algebra. The data model is based on nested sequences of tuples. It tries to maintain the order of the input lists whenever possible, with a higher preference for the order of the first input list.
Reference: [6] <author> Eric S. Lander, Robert Langridge, and Damien M. Saccocio, </author> <title> "Mapping and Interpreting Biological Information," </title> <booktitle> Communications of the ACM 34 (1991), </booktitle> <pages> 33-39. </pages>
Reference: [7] <author> T. Leung, G. Mitchell, B. Subramanian, B. Vance, S. Vandenberg, and S. Zdonik, </author> <title> "The AQUA Data Model and Algebra," </title> <type> Tech. </type> <note> Rpt. CS-93-09, Submitted to the Fourth Intl. Workshop on Database Programming Languages (1993). </note>
Reference-contexts: By and large, these operations have been confined to manipulations of sets. While there has been some recent work on extending query languages to other bulk types like sequences [4,8], additional research is needed. This paper presents an extension to the AQUA (A QUery Algebra) query algebra <ref> [7] </ref> to include ordered types like graphs, lists, and trees. N-dimensional arrays are a topic for future work. We begin by defining algebraic operations over graphs. Graphs are used as the fundamental building block out of which the operations for the other types are derived. <p> This is followed by a discussion of the specific operators that we support for graphs, trees, and lists. We close 1 with a few examples of how these operators are used and some suggestions for future research. 2 AQUA Model The AQUA query algebra <ref> [7] </ref> is based on an object-oriented data model. All objects have identity, and these identities allow us to distinguish between objects using identity-based equalities. The type-system in AQUA is a 3-tiered system. New types are created using the existing type constructors and types. <p> Lists and trees do not participate in subtyping. 5 Operators In this section, we describe in detail the various operations on graphs, trees and lists. The functionality of most operators is similar across all the ordered types. The syntax of the operations is similar to the operations defined in <ref> [7] </ref>, but for the sake of completeness we give a brief overview here. All expressions in the algebra are represented by terms. <p> Current and future research includes investigation of additional operators on ordered bulk types (e.g. LFP, as described in <ref> [7] </ref>) and predicate specification sub-languages for ordered bulk types. For example, we can specify regular expression-like predicates on ordered objects, but more powerful mechanisms (such as context-free grammars) need to be examined. Indexable ordered types in AQUA (such as N-dimensional arrays) will be discussed in a future paper.
Reference: [8] <author> Joel Richardson, </author> <title> "Supporting Lists in a Data Model (A Timely Approach)," </title> <booktitle> Proceedings of the 18th VLDB Conference (1992). </booktitle>
Reference-contexts: Furthermore, many of the operations listed in [1] are not described precisely, and their existence is assumed. Here we remove that assumption. Graphs are not discussed in [1], and it is not clear how (or if) they would fit into the paradigm presented there. MDM <ref> [8] </ref> talks about a query algebra to support lists in an object-oriented data model. Operators from a discrete, linear-time temporal logic provide the basis for the algebra.
Reference: [9] <author> Scott L. Vandenberg and David J. DeWitt, </author> <title> "Al gebraic Support for Complex Objects with Arrays, Identity, and Inheritance," </title> <booktitle> SIGMOD Pro ceedings (1991), </booktitle> <pages> 158-167. 12 </pages>
Reference-contexts: The salient feature of the algebra is the extension of the predicate language to allow position-dependent queries, which adds a lot more flexibility to the kind of queries that can be posed to the database. Union and difference are similar to the corresponding operators in EXTRA/EXCESS <ref> [9] </ref>. However, the MDM algebra does not provide for operations on trees or graphs. The NST algebra [5] is specifically designed for structured office documents and is an extension of relational algebra. The data model is based on nested sequences of tuples. <p> Ginsburg and Wang define a set of powerful operations based on regular expressions, 3 which act as a kind of template for the operation. However, the manipulation of the input lists seems to be more at a physical level rather than at a logical level. The EXTRA/EXCESS system <ref> [9] </ref> contains an array type constructor; arrays can be fixed- or variable-length and can contain entities of any EXTRA type. The elements of an array are accessed using their array indices, but there is no ability to traverse from one element to another in these arrays.
References-found: 9

