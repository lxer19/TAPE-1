URL: http://www.cs.tamu.edu/research/robotics/Amato/Papers/ftcs-cr.ps.gz
Refering-URL: http://www.cs.tamu.edu/faculty/amato/dsmft/publications.html
Root-URL: http://www.cs.tamu.edu
Title: Checking Linked Data Structures  
Author: Nancy M. Amato Michael C. Loui 
Address: 1308 W. Main St., Urbana, IL 61801  
Affiliation: Coordinated Science Laboratory, University of Illinois,  
Abstract: In the program checking paradigm, the original program is run on the desired input, and its output is checked by another program called a checker. Recently, the notion of program checking has been extended from its original formulation of checking functions to checking a sequence of operations which query and alter the state of an object external to the program, e.g., checking the interactions between a client and the manager (server) of a data structure. In this expanded paradigm, the checker acts as an intermediary between the client, which generates the requests, and the server, which processes them. The checker is allowed a small amount of reliable memory and may provide a probabilistic guarantee of correctness for the client. We present off-line and on-line checkers for data structures such as linked lists, trees, and graphs. Previously, the only data structures for which such checkers existed were random access memories, stacks, and queues. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Avizienis. </author> <title> The n-version approach to fault-tolerant software. </title> <journal> IEEE Transactions Software Engineering, </journal> <volume> 11(12) </volume> <pages> 1491-1501, </pages> <year> 1985. </year>
Reference-contexts: Program checkers can be used to achieve hardware and/or software fault-tolerance. For example, they can be used as acceptance tests in the recovery-block approach [15], or as alternatives to N -version programming <ref> [1] </ref>, algorithm-based fault-tolerance, or the certification-trail technique. Recently, Blum et al. [5] expanded the concept of program checking to include an important class of nonfunctional problems: checking the interactions between a user (client) and the manager (server) of some resource.
Reference: [2] <author> V. Balasubramanian and P. Banerjee. </author> <title> Compiler-assisted synthesis of algorithm-based checking in multiprocessors. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(4) </volume> <pages> 436-459, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Algorithm-based fault tolerance is a method that checks an operation by tailoring the fault-tolerance scheme to the algorithm used to perform the operation. Introduced by Huang and Abraham [10], this method has since been studied extensively (see, e.g., <ref> [2, 3, 4] </ref>).
Reference: [3] <author> P. Banerjee and J. A. Abraham. </author> <title> Bounds on algorithm-based fault tolerance in multiple processor systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 35(4) </volume> <pages> 296-306, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Algorithm-based fault tolerance is a method that checks an operation by tailoring the fault-tolerance scheme to the algorithm used to perform the operation. Introduced by Huang and Abraham [10], this method has since been studied extensively (see, e.g., <ref> [2, 3, 4] </ref>).
Reference: [4] <author> P. Banerjee, J. T. Rahmeh, C. Stunkel, V. S. Nair, K. Roy, V. Balasubramanian, and J. A. Abra-ham. </author> <title> Algorithm-based fault tolerance on a hypercube multiprocessor. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(9) </volume> <pages> 1132-1245, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Algorithm-based fault tolerance is a method that checks an operation by tailoring the fault-tolerance scheme to the algorithm used to perform the operation. Introduced by Huang and Abraham [10], this method has since been studied extensively (see, e.g., <ref> [2, 3, 4] </ref>).
Reference: [5] <author> M. Blum, W. Evans, P. Gemmell, S. Kannan, and M. Naor. </author> <title> Checking the correctness of memories. </title> <booktitle> In Proceedings of the 32nd Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 90-99, </pages> <year> 1991. </year>
Reference-contexts: Program checkers can be used to achieve hardware and/or software fault-tolerance. For example, they can be used as acceptance tests in the recovery-block approach [15], or as alternatives to N -version programming [1], algorithm-based fault-tolerance, or the certification-trail technique. Recently, Blum et al. <ref> [5] </ref> expanded the concept of program checking to include an important class of nonfunctional problems: checking the interactions between a user (client) and the manager (server) of some resource. <p> In this paper, using the checking model proposed by Blum et al. <ref> [5] </ref>, we provide checkers, both off-line and on-line, for linked data structures such as lists, trees, and graphs. Previously, such checkers were only known for random access memories, stacks, and queues [5]. <p> In this paper, using the checking model proposed by Blum et al. <ref> [5] </ref>, we provide checkers, both off-line and on-line, for linked data structures such as lists, trees, and graphs. Previously, such checkers were only known for random access memories, stacks, and queues [5]. Our checkers resemble those previous checkers, but are necessarily more complex because we are interested in verifying the dynamic relationships (e.g., links) among the elements in the data structure, in addition to checking the data values stored in each element. <p> We defer further discussion of our results until we have formally defined the program checking model. After we describe our checkers, we observe in Section 6 that the off-line data structure checkers presented in this paper and user and the manager of the resource. in <ref> [5] </ref> bear striking similarities to the certification-trail methods of Sullivan and Masson [17, 18]. <p> Due to space constraints, some details have been omitted from this paper; they will be included in the full version. 2 The Program Checking Model In this paper we adopt the program checking model proposed by Blum et al. <ref> [5] </ref> for checking the interactions between a user (client) and the manager (server) of a resource. We review this model here. There are three participants in the checking process: the user U , the (manager of the) resource R, and the checker C. <p> i ; v j ), neighbors (v i ) (returns the set of vertices incident to v i ), read (v i ), and write (v i ). 3 4 Off-Line Checkers The off-line checkers given here resemble the off-line checkers for RAMs, stacks, and queues of Blum et al. <ref> [5] </ref>. In its reliable and private (but not necessarily secret) memory, the checker holds: 1. The description of an *-biased hash function h. <p> Other information that facilitates verification of the data structure. In order to make the above description more concrete, we give a simple example illustrating the off-line queue checker of Blum et al. <ref> [5] </ref>. The checker maintains two counters, n e and n d , that record the number of items that have (ever) been enqueued or de-queued, respectively. <p> The above example illustrates a general strategy used by the checkers of Blum et al. <ref> [5] </ref>, which is also adopted by our checkers. In particular, the checker makes entries to the I and D logs so that I = D if and only if R performs all of the operations correctly. <p> We represent the logs by binary strings, and we adopt the method suggested by Blum et al. <ref> [5] </ref> for encoding log entries in these strings: an entry of the form (e:id; e:sid; e:data; ts) corresponds to a 1 bit in the (e:data + e:id fl v + e:sid fl v 2 + ts fl v 3 ) th bit of the string, where v is the largest possible <p> Instead of keeping the head and the counter i of each list in its reliable memory, the checker stores these values as records in an array indexed by lid. The array can be checked by a RAM checker <ref> [5] </ref>, which requires an additional O (k) bits of reliable memory for the hashed values of its logs. 5 procedure Check split (par; lsib; v) t c := t c + 1; add E (lsib; lsib:ts) to D; add E (v; v:ts) to D; P rocess split (lef tchild (v)); split <p> trees can be verified off-line by a checker with O (log t + k) bits of reliable memory. 4.3 Off-Line Checkers for Graphs If the graph G = (V; E), jV j = g, is stored in an adjacency matrix, then we use the RAM checker of Blum et al. <ref> [5] </ref>. If G is stored in an adjacency list, then we use the technique discussed in Section 4.1 that checks O (g) linked lists. <p> Finally, the on-line graph checker discussed next gives an alternative on-line tree checker which uses less space, but requires cryptographic assumptions. 5.3 An On-Line Checker for Graphs Since graph algorithms tend to require random access to vertices, it appears that the RAM checkers of Blum et al. <ref> [5] </ref> are needed for an on-line graph checker. The on-line RAM checkers given in [5] differ from the checkers thus far described in this paper because they use cryptographic assumptions. In particular, they use either pseudorandom functions [9] or universal one-way hash functions [14, 16]. <p> tree checker which uses less space, but requires cryptographic assumptions. 5.3 An On-Line Checker for Graphs Since graph algorithms tend to require random access to vertices, it appears that the RAM checkers of Blum et al. <ref> [5] </ref> are needed for an on-line graph checker. The on-line RAM checkers given in [5] differ from the checkers thus far described in this paper because they use cryptographic assumptions. In particular, they use either pseudorandom functions [9] or universal one-way hash functions [14, 16]. <p> k &gt; 1, where f is the time necessary to evaluate a pseudorandom function or a universal one-way hash function. 6 The Certification-Trail Technique The certification-trail fault-tolerance technique, recently proposed by Sullivan and Masson [17, 18], bears striking similarities to the data structure checkers described in this paper and in <ref> [5] </ref>. Briefly, the certification-trail technique consists of two phases. In the first phase, a modified version of the original program is run, producing both the expected output and a trail of data called a certification trail.
Reference: [6] <author> M. Blum and S. Kannan. </author> <title> Designing programs that check their work. </title> <booktitle> In Proceedings of the 21st ACM Symposium on Theory of Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1989. </year>
Reference-contexts: A technique called program checking, which bears conceptual similarities to both algorithm-based fault tolerance and the certification-trail technique, has evolved in an environment largely isolated from the traditional fault tolerance community. In the program checking paradigm proposed by Blum and Kannan <ref> [6] </ref>, the original program is run on the desired input, and its output is checked by another program called a checker. In contrast to algorithm-based fault tolerance and the certification-trail technique, the checker treats the original program as a black box controlled by an adversary.
Reference: [7] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self-testing/correcting with applications to numerical problems. </title> <booktitle> In Proceedings of the 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 73-83, </pages> <year> 1990. </year>
Reference-contexts: This basic model of program result checking was extended by Blum, Luby, and Rubinfeld <ref> [7] </ref> to include the idea of using several different programs (a library) to check another program, and the concept of a self-testing/correcting pair of programs that enable one to 1 use a program that is not too faulty on average to com-pute a correct output.
Reference: [8] <author> Jonathon Bright and Gregory F. Sullivan. </author> <title> Checking mergeable priority queues. </title> <booktitle> In Digest of the 1994 International Symposium on Fault-Tolerant Computing, </booktitle> <month> June </month> <year> 1994, </year> <note> to appear. </note>
Reference-contexts: Note that this same technique could be performed online, and that each data structure operation would be processed and checked in constant time. We remark that, to our knowledge, all proposed certification-trail methods <ref> [17, 18, 8] </ref> have been off-line, i.e., a determination of correctness can be made only after the entire certification trail has been output by the modified original program and processed by the certifier. <p> Some of this latency could be removed by, e.g., checking subsequences of operations <ref> [8] </ref>, but the proposed methods remain primarily off-line. 9 Finally, we note that certification-trail methods cannot necessarily be transformed into checkers: the checker trusts only its small reliable memory, but the certifier implicitly trusts the certification trail created by the modified original program. 7 Open Problems It would be interesting to
Reference: [9] <author> O. Goldreich, S. Goldwasser, and S. Micali. </author> <title> How to construct random functions. </title> <journal> Journal of the ACM, </journal> <volume> 33(4) </volume> <pages> 792-807, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: The on-line RAM checkers given in [5] differ from the checkers thus far described in this paper because they use cryptographic assumptions. In particular, they use either pseudorandom functions <ref> [9] </ref> or universal one-way hash functions [14, 16].
Reference: [10] <author> K. Huang and J. A. Abraham. </author> <title> Algorithm-based fault tolerance for matrix operations. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 33(6) </volume> <pages> 518-528, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: Email: amato@cs.uiuc.edu. z Email: m-loui@uiuc.edu. pose alternative methods for verifying the output of computations. Algorithm-based fault tolerance is a method that checks an operation by tailoring the fault-tolerance scheme to the algorithm used to perform the operation. Introduced by Huang and Abraham <ref> [10] </ref>, this method has since been studied extensively (see, e.g., [2, 3, 4]). <p> in an application of this technique, the input data are encoded, and the algorithm is designed to operate on encoded input data and produce encoded output data; for example, many matrix operations can be checked by adding a checksum row and a checksum column to the input and output matrices <ref> [10] </ref>. Another interesting method for achieving fault tolerance is the certification-trail technique proposed by Sullivan and Masson [17, 18]. Briefly, the certification-trail technique consists of two phases.
Reference: [11] <author> B. W. Johnson. </author> <title> Design and Analysis of Fault Tolerant Digital Systems. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: In this expanded version of program checking, the checker might use some limited amount of reliable memory|achieved through hardware fault-tolerance techniques such as hardware or information redundancy <ref> [11] </ref>. Then, if the resource resides in some larger unreliable memory, the checker can use its own smaller reliable memory to detect faults in the unreliable memory, i.e., faults in the larger memory can be detected without incurring the cost of making it fault-tolerant.
Reference: [12] <author> K. Kant and A. Ravichandran. </author> <title> Synthesizing robust data structures an introduction. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(2) </volume> <pages> 161-173, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: In addition to the uses mentioned above for program result checking, checkers of this type could be used for purposes such as developing robust data structures <ref> [12, 19] </ref>. In this expanded version of program checking, the checker might use some limited amount of reliable memory|achieved through hardware fault-tolerance techniques such as hardware or information redundancy [11].
Reference: [13] <author> J. Naor and M. Naor. </author> <title> Small-bias probability spaces: Efficient constructions and applications. </title> <journal> SIAM Journal on Computing, </journal> <volume> 22(4) </volume> <pages> 838-856, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: In its reliable and private (but not necessarily secret) memory, the checker holds: 1. The description of an *-biased hash function h. An *-biased hash function h <ref> [13] </ref> can be described using O (log d+k) random bits and can distinguish between two d-bit binary strings A and B as follows: if A 6= B, then h (A) = h (B) with probability at most 1=2 k .
Reference: [14] <author> M. Naor and M. Yung. </author> <title> Universal one-way hash functions and their cyptographic applications. </title> <booktitle> In Proceedings of the 21st ACM Symposium on Theory of Computing, </booktitle> <pages> pages 33-43, </pages> <year> 1989. </year>
Reference-contexts: The on-line RAM checkers given in [5] differ from the checkers thus far described in this paper because they use cryptographic assumptions. In particular, they use either pseudorandom functions [9] or universal one-way hash functions <ref> [14, 16] </ref>.
Reference: [15] <author> B. Randell. </author> <title> System structure for software fault tolerance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 1(2) </volume> <pages> 220-232, </pages> <year> 1975. </year>
Reference-contexts: Program checkers can be used to achieve hardware and/or software fault-tolerance. For example, they can be used as acceptance tests in the recovery-block approach <ref> [15] </ref>, or as alternatives to N -version programming [1], algorithm-based fault-tolerance, or the certification-trail technique. Recently, Blum et al. [5] expanded the concept of program checking to include an important class of nonfunctional problems: checking the interactions between a user (client) and the manager (server) of some resource.
Reference: [16] <author> J. Rompel. </author> <title> One way hash functions are necessary and sufficient for secure signatures. </title> <booktitle> In Proceedings of the 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 387-394, </pages> <year> 1990. </year>
Reference-contexts: The on-line RAM checkers given in [5] differ from the checkers thus far described in this paper because they use cryptographic assumptions. In particular, they use either pseudorandom functions [9] or universal one-way hash functions <ref> [14, 16] </ref>.
Reference: [17] <author> G. Sullivan and G. </author> <title> Masson. Using certification trails to achieve software fault tolerance. </title> <booktitle> In Digest of the 1990 International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 423-431, </pages> <year> 1990. </year>
Reference-contexts: Another interesting method for achieving fault tolerance is the certification-trail technique proposed by Sullivan and Masson <ref> [17, 18] </ref>. Briefly, the certification-trail technique consists of two phases. In the first phase, a modified version of the original program is run, producing both the expected output and a trail of data called a certification trail. <p> After we describe our checkers, we observe in Section 6 that the off-line data structure checkers presented in this paper and user and the manager of the resource. in [5] bear striking similarities to the certification-trail methods of Sullivan and Masson <ref> [17, 18] </ref>. <p> reliable memory, and detects errors with probability at least 1 1=2 k , for any integer k &gt; 1, where f is the time necessary to evaluate a pseudorandom function or a universal one-way hash function. 6 The Certification-Trail Technique The certification-trail fault-tolerance technique, recently proposed by Sullivan and Masson <ref> [17, 18] </ref>, bears striking similarities to the data structure checkers described in this paper and in [5]. Briefly, the certification-trail technique consists of two phases. <p> Note that this same technique could be performed online, and that each data structure operation would be processed and checked in constant time. We remark that, to our knowledge, all proposed certification-trail methods <ref> [17, 18, 8] </ref> have been off-line, i.e., a determination of correctness can be made only after the entire certification trail has been output by the modified original program and processed by the certifier.
Reference: [18] <author> G. Sullivan and G. </author> <title> Masson. Certification trails for data structures. </title> <booktitle> In Proceedings of the 21st International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 240-247, </pages> <year> 1991. </year>
Reference-contexts: Another interesting method for achieving fault tolerance is the certification-trail technique proposed by Sullivan and Masson <ref> [17, 18] </ref>. Briefly, the certification-trail technique consists of two phases. In the first phase, a modified version of the original program is run, producing both the expected output and a trail of data called a certification trail. <p> After we describe our checkers, we observe in Section 6 that the off-line data structure checkers presented in this paper and user and the manager of the resource. in [5] bear striking similarities to the certification-trail methods of Sullivan and Masson <ref> [17, 18] </ref>. <p> reliable memory, and detects errors with probability at least 1 1=2 k , for any integer k &gt; 1, where f is the time necessary to evaluate a pseudorandom function or a universal one-way hash function. 6 The Certification-Trail Technique The certification-trail fault-tolerance technique, recently proposed by Sullivan and Masson <ref> [17, 18] </ref>, bears striking similarities to the data structure checkers described in this paper and in [5]. Briefly, the certification-trail technique consists of two phases. <p> Note that this same technique could be performed online, and that each data structure operation would be processed and checked in constant time. We remark that, to our knowledge, all proposed certification-trail methods <ref> [17, 18, 8] </ref> have been off-line, i.e., a determination of correctness can be made only after the entire certification trail has been output by the modified original program and processed by the certifier.
Reference: [19] <author> D. J. Taylor. </author> <title> Error models for robust storage structures. </title> <booktitle> In Proceedings of the 20th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 416-422, </pages> <year> 1990. </year>
Reference-contexts: In addition to the uses mentioned above for program result checking, checkers of this type could be used for purposes such as developing robust data structures <ref> [12, 19] </ref>. In this expanded version of program checking, the checker might use some limited amount of reliable memory|achieved through hardware fault-tolerance techniques such as hardware or information redundancy [11].
References-found: 19

