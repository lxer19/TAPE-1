URL: http://dimacs.rutgers.edu/techps/1993/93-71.ps
Refering-URL: http://dimacs.rutgers.edu/TechnicalReports/1993.html
Root-URL: http://www.cs.rutgers.edu
Title: A Randomized Linear-Time Algorithm for Finding Minimum Spanning Trees  
Author: Philip N. Klein Robert E. Tarjan 
Date: October 12, 1993  
Abstract: We present a randomized linear-time algorithm for finding a minimum spanning tree in a connected graph with edge weights. The algorithm is a modification of one proposed by Karger and uses random sampling in combination with a recently discovered linear-time algorithm for verifying a minimum spanning tree. Our computational model is a unit-cost random-access machine with the restriction that the only operations allowed on edge weights are binary comparisons.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Alon and J. H. Spencer, </author> <title> The Probabilistic Method, </title> <publisher> John Wiley & Sons, Inc., New York, </publisher> <editor> N. Y., </editor> <year> 1992, </year> <note> p. 223. </note>
Reference-contexts: An appropriate recurrence then yields a running time that is O (m) with high probability. The number of edges m 1 in the sample graph H is binomially distributed with mean m 0 =2 m=2. A standard bound on the tail of the binomial distribution <ref> [1, 15] </ref> implies that the probability that m 1 &gt; m 2 (1 + ffi 1 ) is exponentially small, namely exp ( (m)), for any constant ffi 1 &gt; 0. Choosing ffi 1 = 1=10, we have m 1 &gt; 11 m=20 with probability exp ( (m)).
Reference: [2] <author> M. Blum, R. W. Floyd, V. R. Pratt, R. L. Rivest, and R. E. Tarjan, </author> <title> "Time bounds for selection," </title> <journal> J. Comput. System Sci. </journal> <volume> 7, </volume> <year> 1973, </year> <pages> pp. 448-461. </pages>
Reference-contexts: It follows that the expected running time is linear. The recurrence relation resembles the one arising in the analysis of a linear-time selection algorithm <ref> [2] </ref>. Here is a complete specification of the algorithm. Step 1. For each vertex, select the minimum-weight edge incident to the vertex.
Reference: [3] <author> O. Bor-uvka, "O jistem problemu minimaln im, Praca Moravske Pr irodovedecke Spolecnosti 3, </author> <year> 1926, </year> <pages> pp. 37-58. </pages> <note> (In Czech.) </note>
Reference-contexts: 1 Introduction We consider the problem of finding a minimum spanning tree in a connected graph with real-valued edge weights. This problem has a long and rich history; the first fully realized algorithm was devised by Bor-uvka in the 1920's <ref> [3] </ref>. An informative survey paper by Graham and Hell [9] describes the history of the problem up to 1985. <p> Remark. Lemma 1 has an immediate generalization to matroids. See [11]. 3 The Algorithm The algorithm intermeshes steps of Bor-uvka's minimum-spanning-tree algorithm <ref> [3] </ref> with random-sampling steps that discard edges that cannot be in the minimum spanning tree. Each Bor-uvka step reduces the number of vertices by at least a factor of two.
Reference: [4] <author> J. Cheriyan, T. Hagerup, and K. Mehlhorn, </author> <title> "Can a maximum flow be computed in O(nm) time?", </title> <booktitle> Proc. 17th International Colloquium on Automata, Languages, and Programming, published as Lecture Notes in Computer Science, </booktitle> <volume> Vol. 443, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990, </year> <pages> pp. 235-248. </pages>
Reference-contexts: Can randomization be used to simplify the linear-time verification algorithm? 3. Can randomization be used fruitfully to solve other network optimization problems, such as the shortest-path problem? Randomization has already proved valuable in solving the maximum-flow <ref> [4] </ref> and minimum-cut [10] problems. Acknowledgments We thank David Karger, Satish Rao, and David Zuckerman for fruitful discussions.
Reference: [5] <author> B. Dixon, M. Rauch, and R. E. Tarjan, </author> <title> "Verification and sensitivity analysis of minimum spanning trees in linear time," </title> <journal> SIAM J. on Computing 21, </journal> <year> 1992, </year> <pages> pp. 1184-1192. </pages>
Reference-contexts: Later, Komlos [13] showed that a minimum spanning tree can be verified in O (m) binary comparisons of edge weights, but with nonlinear overhead to decide which comparisons to make. Dixon, Rauch and Tarjan <ref> [5] </ref> recently combined these algorithms with a table lookup technique to obtain an O (m)-time verification algorithm. In this paper we describe a randomized algorithm for finding a minimum spanning tree. It has an expected running time of O (m) in the restricted random-access model. <p> Given a forest F in G, the F -heavy edges of G can be computed in time linear in the number of edges of G, using an adaptation of the verification algorithm of Dixon, Rauch, and Tarjan. (Page 1188 in <ref> [5] </ref> describes the changes needed in the algorithm.) Lemma 1 Let H be a subgraph obtained from G by including each edge independently with probability p, and let F be the minimum spanning forest of H.
Reference: [6] <author> M. Fredman and D. E. Willard, </author> <title> "Trans-dichotomous algorithms for minimum spanning trees and shortest paths," </title> <booktitle> Proc. 31st Annual IEEE Symp. on Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1990, </year> <pages> pp. 719-725. </pages>
Reference-contexts: NSF-STC88-09648. 1 This and earlier algorithms used as a computational model the sequential unit-cost random-access machine with the restriction that the only operations allowed on the edge weights are binary comparisons. Fredman and Willard <ref> [6] </ref> considered a more powerful model that allows bit manipulation of the binary representations of the edge weights. In this model they were able to devise a linear-time algorithm. Still, the question of whether a linear-time algorithm exists for the restricted random-access model remained open.
Reference: [7] <author> H. N. Gabow, Z. Galil, and T. H. Spencer, </author> <title> "Efficient implementation of graph algorithms using contraction," </title> <booktitle> Proc. 25th Annual IEEE Symp. on Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1984, </year> <pages> pp. 338-346. 8 </pages>
Reference-contexts: An informative survey paper by Graham and Hell [9] describes the history of the problem up to 1985. In the last two decades faster and faster algorithms were found, the fastest being an algorithm of Gabow, Galil, and Spencer <ref> [7] </ref> (see also [8]), with a running time of O (m log fi (m; n)) on a graph of n vertices and m edges. Here fi (m; n) = minfi j log (i) n m=ng. fl Department of Computer Science, Brown University, Providence, RI 02912-1910.
Reference: [8] <author> H. N. Gabow, Z. Galil, T. Spencer, and R. E. Tarjan, </author> <title> "Efficient algorithms for finding minimum spanning trees in undirected and directed graphs," </title> <type> Combinatorica 6, </type> <year> 1986, </year> <pages> pp. 109-122. </pages>
Reference-contexts: An informative survey paper by Graham and Hell [9] describes the history of the problem up to 1985. In the last two decades faster and faster algorithms were found, the fastest being an algorithm of Gabow, Galil, and Spencer [7] (see also <ref> [8] </ref>), with a running time of O (m log fi (m; n)) on a graph of n vertices and m edges. Here fi (m; n) = minfi j log (i) n m=ng. fl Department of Computer Science, Brown University, Providence, RI 02912-1910.
Reference: [9] <author> R. L. Graham and P. Hell, </author> <title> "On the history of the minimum spanning tree problem," </title> <booktitle> Annals of the History of Computing 7, </booktitle> <year> 1985, </year> <pages> pp. 43-57. </pages>
Reference-contexts: 1 Introduction We consider the problem of finding a minimum spanning tree in a connected graph with real-valued edge weights. This problem has a long and rich history; the first fully realized algorithm was devised by Bor-uvka in the 1920's [3]. An informative survey paper by Graham and Hell <ref> [9] </ref> describes the history of the problem up to 1985.
Reference: [10] <author> D. R. Karger, </author> <title> "Global min-cuts in RNC and other ramifications of a simple mincut algorithm," </title> <booktitle> Proc. 4th Annual ACM-SIAM Symposium on Discrete Algorithms, Association for Computing Machinery, </booktitle> <address> New York, NY, </address> <institution> and Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA, </address> <year> 1993, </year> <pages> pp. 21-30. </pages>
Reference-contexts: In this paper we describe a randomized algorithm for finding a minimum spanning tree. It has an expected running time of O (m) in the restricted random-access model. The algorithm is a modification of one proposed by Karger <ref> [10] </ref>, who obtained an expected time bound of O (m + n log n). Our algorithm uses the random-sampling technique of Karger in combination with the verification algorithm of Dixon, Rauch, and Tarjan to discard edges that cannot be in the minimum spanning tree. <p> Can randomization be used to simplify the linear-time verification algorithm? 3. Can randomization be used fruitfully to solve other network optimization problems, such as the shortest-path problem? Randomization has already proved valuable in solving the maximum-flow [4] and minimum-cut <ref> [10] </ref> problems. Acknowledgments We thank David Karger, Satish Rao, and David Zuckerman for fruitful discussions.
Reference: [11] <author> D. R. </author> <title> Karger "Random sampling in matroids, with applications to graph connectivity and minimum spanning trees," </title> <booktitle> Proc. 34st Annual IEEE Symp. on Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> , <year> 1993, </year> <note> to appear. </note>
Reference-contexts: Since the number of occurences of heads could be any i from 0 to n 1, the probability of this happening is at most P n1 i )p i (1 p) ki . Remark. Lemma 1 has an immediate generalization to matroids. See <ref> [11] </ref>. 3 The Algorithm The algorithm intermeshes steps of Bor-uvka's minimum-spanning-tree algorithm [3] with random-sampling steps that discard edges that cannot be in the minimum spanning tree. Each Bor-uvka step reduces the number of vertices by at least a factor of two. <p> In joint work with Richard Cole to be described in a future paper, we have adapted our algorithm to run in parallel. The parallel algorithm does linear work and runs in O (log n2 log fl n ) time on a PRIORITY PRAM [12]. In contrast, Karger <ref> [11] </ref> claims an algorithm running on an EREW PRAM that requires O (log n) time and m= log n + n 1+* processors for any constant * &gt; 0. Among remaining open problems, we note especially the following three: 7 1.
Reference: [12] <author> R. M. Karp and V. Ramachandran, </author> <title> "A survey of parallel algorithms for shared-memory machines," Chapter 17 in Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity J. </title> <editor> van Leeuwen, ed., </editor> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990, </year> <pages> pp. 869-941. </pages>
Reference-contexts: In joint work with Richard Cole to be described in a future paper, we have adapted our algorithm to run in parallel. The parallel algorithm does linear work and runs in O (log n2 log fl n ) time on a PRIORITY PRAM <ref> [12] </ref>. In contrast, Karger [11] claims an algorithm running on an EREW PRAM that requires O (log n) time and m= log n + n 1+* processors for any constant * &gt; 0. Among remaining open problems, we note especially the following three: 7 1.
Reference: [13] <author> J. Komlos, </author> <title> "Linear verification for spanning trees," </title> <type> Combinatorica 5, </type> <year> 1985, </year> <pages> pp. 57-65. </pages>
Reference-contexts: A problem related to finding minimum spanning trees is that of verifying that a given spanning tree is minimum. Tarjan [16] gave a verification algorithm running in O (m ff (m; n)) time, where ff is a functional inverse of Ackermann's function. Later, Komlos <ref> [13] </ref> showed that a minimum spanning tree can be verified in O (m) binary comparisons of edge weights, but with nonlinear overhead to decide which comparisons to make. Dixon, Rauch and Tarjan [5] recently combined these algorithms with a table lookup technique to obtain an O (m)-time verification algorithm.
Reference: [14] <author> J. B. Kruskal, </author> <title> "On the shortest spanning subtree of a graph and the traveling salesman problem," </title> <journal> Proc. Amer. Math Soc. </journal> <volume> 7, </volume> <year> 1956, </year> <pages> pp. 48-50. </pages>
Reference-contexts: Proof. Let e 1 ; e 2 ; :::; e m be the edges of G, arranged in increasing order by weight. Consider the following computation, a variant of Kruskal's minimum spanning tree algorithm <ref> [14] </ref>. Begin with an empty forest F . Process the edges e j in increasing order on j. To process an edge e j , first flip a coin that has probability p of coming up heads. If the coin does come up heads, include e j in H.
Reference: [15] <author> P. Raghavan, </author> <title> "Lecture Notes on Randomized Algorithms," </title> <type> Research Report RC 15340 (#68237), </type> <institution> Computer Science/Mathematics IBM Research Division, T.J. Watson Research Center, </institution> <address> Yorktown Heights, NY, </address> <year> 1990, </year> <month> 54. </month>
Reference-contexts: An appropriate recurrence then yields a running time that is O (m) with high probability. The number of edges m 1 in the sample graph H is binomially distributed with mean m 0 =2 m=2. A standard bound on the tail of the binomial distribution <ref> [1, 15] </ref> implies that the probability that m 1 &gt; m 2 (1 + ffi 1 ) is exponentially small, namely exp ( (m)), for any constant ffi 1 &gt; 0. Choosing ffi 1 = 1=10, we have m 1 &gt; 11 m=20 with probability exp ( (m)).
Reference: [16] <author> R. E. Tarjan, </author> <title> "Applications of path compression on balanced trees," </title> <journal> J. Assoc. Comput. Mach. </journal> <volume> 26, </volume> <year> 1979, </year> <pages> pp. 690-715. </pages>
Reference-contexts: In this model they were able to devise a linear-time algorithm. Still, the question of whether a linear-time algorithm exists for the restricted random-access model remained open. A problem related to finding minimum spanning trees is that of verifying that a given spanning tree is minimum. Tarjan <ref> [16] </ref> gave a verification algorithm running in O (m ff (m; n)) time, where ff is a functional inverse of Ackermann's function.
Reference: [17] <author> R. E. Tarjan, </author> <title> Data Structures and Network Algorithms, </title> <type> Chapter 6, </type> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, </address> <year> 1983. </year> <month> 9 </month>
Reference-contexts: Our algorithm actually solves the slightly more general problem of finding a minimum spanning forest in a possibly disconnected graph. We assume familiarity with standard results on minimum spanning trees, as presented, for example, in <ref> [17] </ref>. 2 2 A Sampling Lemma In order to present the sampling result, we need a little terminology. Let G be a graph with weighted edges. We denote by w (x; y) the weight of edge fx; yg.
References-found: 17

