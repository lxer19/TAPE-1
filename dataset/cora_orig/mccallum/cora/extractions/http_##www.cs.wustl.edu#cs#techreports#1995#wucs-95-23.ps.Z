URL: http://www.cs.wustl.edu/cs/techreports/1995/wucs-95-23.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: 
Title: Redesigning the BSD Callout and Timer Facilities  
Author: Adam M. Costello and George Varghese wucs-- 
Note: This work supported by a grant from the NSF.  
Address: Campus Box 1045  One Brookings Drive St. Louis, MO 63130-4899  
Affiliation: Department of Computer Science  Washington University  
Date: 2 Nov 1995  
Abstract: We describe a new implementation of the BSD callout and timer facilities. Current BSD kernels take time proportional to the number of outstanding timers to set or cancel timers. Our implementation takes constant time to start, stop, and maintain timers; this leads to a highly scalable design that can support thousands of outstanding timers without much overhead. Unlike the existing implementation, our routines are guaranteed to lock out interrupts only for a small, bounded amount of time. We also extend the setitimer() interface to allow a process to have multiple outstanding timers, thereby reducing the need for users to maintain their own timer packages. The changes to the BSD kernel are small (548 lines of code added, 80 removed) and are available on the World Wide Web. 
Abstract-found: 1
Intro-found: 1
Reference: [Bro88] <author> R. Brown. </author> <title> Calendar queues: A fast O(1) priority queue implementation for the simulation event set problem. </title> <journal> Communications of the ACM, </journal> <volume> 31(10) </volume> <pages> 1220-1227, </pages> <month> Oc-tober </month> <year> 1988. </year>
Reference-contexts: A few fairly well known networking implementations (e.g., [CJRS89, TNML93]) have used the ideas in [VL87] in specialized timer packages for their networking routines (as opposed to a general operating system facility). Brown <ref> [Bro88] </ref> extends hashed timing wheels to what he calls calendar queues; the major difference is that calendar queue implementations also periodically resize the wheel in order to reduce the overhead 4 of stepping through empty buckets.
Reference: [CJRS89] <author> D.D. Clark, V. Jacobson, J. Romkey, and H. Salwen. </author> <title> An analysis of TCP processing overhead. </title> <journal> IEEE Communications, </journal> <volume> 27(6) </volume> <pages> 23-29, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Network protocol implementations provide the easiest example. Typically, for every packet sent by a reliable transport protocol such as TCP, a retransmission timer is started. If an acknowledgement arrives promptly, the timer is cancelled; when the timer expires, the packet is re-transmitted. Several recent network implementations <ref> [CJRS89] </ref> have been tuned to send packets at a rate of 25,000-40,000 packets per second. <p> Rather than have every protocol duplicate these efficient algorithms <ref> [CJRS89, TNML93] </ref>, it is better to have the kernel directly provide an efficient callout facility. Besides networking applications, process control and other real-time applications will also benefit from large numbers of fine granularity timers. <p> A few fairly well known networking implementations (e.g., <ref> [CJRS89, TNML93] </ref>) have used the ideas in [VL87] in specialized timer packages for their networking routines (as opposed to a general operating system facility).
Reference: [Dav89] <author> G. Davison. </author> <title> Calendar p's and q's. </title> <journal> Communications of the ACM, </journal> <volume> 32(10) </volume> <pages> 1241-1242, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Also, the number of users on a system may grow large enough to lead to a large number of outstanding timers. This is the reason cited (for redesigning the timer facility) by the developers of the IBM VM/XA SP1 operating system <ref> [Dav89] </ref>. With a large number of outstanding callouts, it becomes important to bound the amount of time that interrupts can be locked out. Finally, regardless of the number of callouts, the current UNIX limit of one timer per process seems too restrictive. <p> For timer applications, the clock time must be incremented on every clock tick anyway; thus adding a few instructions to step through empty buckets is not significant. Davison <ref> [Dav89] </ref> describes a timer implementation for the IBM VM/XA SP1 operating system based on calendar queues. In our setting, the small improvement in per tick bookkeeping (from resizing the wheel periodically) does not appear to warrant the extra complexity of resizing.
Reference: [TNML93] <author> C. Thekkath, T. Nguyen, E. Moy, and E. Lazowska. </author> <title> Implementing network protocols at user level. </title> <journal> IEEE Transactions on Networking, </journal> <volume> 1(5) </volume> <pages> 554-564, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Rather than have every protocol duplicate these efficient algorithms <ref> [CJRS89, TNML93] </ref>, it is better to have the kernel directly provide an efficient callout facility. Besides networking applications, process control and other real-time applications will also benefit from large numbers of fine granularity timers. <p> A few fairly well known networking implementations (e.g., <ref> [CJRS89, TNML93] </ref>) have used the ideas in [VL87] in specialized timer packages for their networking routines (as opposed to a general operating system facility).
Reference: [VL87] <author> G. Varghese and A. Lauck. </author> <title> Hashed and hierarchical timing wheels: Data structures for the efficient implementation of a timer facility. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 171-180, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Thus, considering the general environments in which UNIX kernels are and will be deployed, the new implementation appears to be a wise and cheap piece of insurance. Previous Work: Varghese and Lauck <ref> [VL87] </ref> described a number of new schemes to implement timers. The basis of our implementation is Scheme 6 in [VL87], which is based on a data structure called a hashed timing wheel. <p> Previous Work: Varghese and Lauck <ref> [VL87] </ref> described a number of new schemes to implement timers. The basis of our implementation is Scheme 6 in [VL87], which is based on a data structure called a hashed timing wheel. <p> While packet loss due to corruption is rare today, packet loss due to congestion is still quite common. in <ref> [VL87] </ref> is mostly theoretical and does not consider some of the issues that occur in actual operating systems; for example, it assumes that all the per tick bookkeeping can be done at the interrupt level, which is clearly infeasible in a real system. <p> A few fairly well known networking implementations (e.g., [CJRS89, TNML93]) have used the ideas in <ref> [VL87] </ref> in specialized timer packages for their networking routines (as opposed to a general operating system facility). <p> Organization: The rest of the paper is organized as follows. Section 2 describes the existing NetBSD 1.0 kernel implementation of the callout facility. Section 3 reviews a timing wheel algorithm proposed in <ref> [VL87] </ref>. Section 4 illustrates how we implemented this algorithm in the NetBSD 1.0 kernel and the implementation issues that we encountered. <p> Replacement Callout Algorithm The algorithm used by the existing implementation is very similar to Scheme 2 of <ref> [VL87] </ref>. The new implementation is based on Scheme 6 of [VL87]. Instead of a single sorted list of callout structures, we use a circular array of unsorted lists. The array, called callwheel (see Figure 2), contains callwheelsize entries. <p> Replacement Callout Algorithm The algorithm used by the existing implementation is very similar to Scheme 2 of <ref> [VL87] </ref>. The new implementation is based on Scheme 6 of [VL87]. Instead of a single sorted list of callout structures, we use a circular array of unsorted lists. The array, called callwheel (see Figure 2), contains callwheelsize entries.
References-found: 5

