URL: http://www.cs.washington.edu/homes/rex/papers/pp-tr.ps
Refering-URL: http://www.cs.washington.edu/homes/rex/papers/
Root-URL: 
Title: Persistent Programming Languages: The Best of Both Worlds  
Author: Rex Jakobovits 
Date: December 9, 1993  
Address: Seattle, Washington 98195  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington  
Abstract: users are not computationally complete, precluding arbitrarily complex processing of data. Furthermore, they support only primitive data types, making them inappropriate for modeling certain real world applications. Processing must be done off-line in a host language, but translation between the database and the language results in an im-pedence mismatch problem. One solution is to extend an existing programming language with the notion of persistence, enabling it to seamlessly interact with the storage manager. This paper is a survey of such efforts and the issues involved, focusing primarily on persistent object-oriented languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agrawal and N. Gehani. </author> <title> Ode: Object database & environment. </title> <booktitle> SIGMOD, </booktitle> <year> 1989. </year>
Reference: [2] <author> R. Agrawal and N. Gehani. </author> <title> Ode: Rationale for the design of persistence and query processing facilities in the database programming language o++. </title> <booktitle> In 2nd International Workshop on Database Programming Languages, </booktitle> <address> Portland, Oregon, </address> <year> 1989. </year>
Reference: [3] <author> T. Andrews and C. Harris. </author> <title> Combining language and database advances in an object-oriented development environment. </title> <booktitle> In Proceedings of the 1987 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 430-440, </pages> <address> Orlando, </address> <month> October </month> <year> 1987. </year>
Reference: [4] <author> M. Atkinson and et. al. P. Bailey. </author> <title> An approach to persistent programming. </title> <journal> Computer Journal, </journal> <volume> 26(4), </volume> <month> November </month> <year> 1983. </year>
Reference: [5] <editor> F. Bancilhon and P. Buneman. </editor> <booktitle> Advances in Database Programing Languages. </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1990. </year>
Reference: [6] <author> A. Brown. </author> <title> Object-Oriented Databases: </title> <booktitle> Applications in Software Engineering. </booktitle> <publisher> McGraw-Hill, </publisher> <address> Berkshire, England, </address> <year> 1991. </year>
Reference: [7] <author> G. Copeland and D. Maier. </author> <title> Making smalltalk a database system. </title> <booktitle> In Proceedings of SIGMOD 84, </booktitle> <volume> volume 14, </volume> <pages> pages 316-325, </pages> <month> June </month> <year> 1984. </year>
Reference: [8] <author> K. Dittrich, W. Gotthard, and P. Lockemann. Damokles: </author> <title> A database system for software engineering environments. </title> <booktitle> In Proceedings of the IFIP Workshop on Advanced Programming Environments, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Lecture Notes in Computer Science. </note>
Reference-contexts: B.5 Versioning representation of multiple object versions is essential to many applications, particularly engineering design activities. 3 approaches: 1. versioning is so fundamental that language primitives should be provided for versioning. ie. part of data model. example is DAMOKLES <ref> [8] </ref>, which allows classes to be versionable. 2. versions not considered part of data model, but a version service is provided by s/w layer implemented directly on top of kernel data model.
Reference: [9] <author> C. Delobel F. Bancilhon and P. Kanellakis. </author> <title> Building an Object-Oriented Database System: </title> <publisher> The Story of O 2 . Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference-contexts: of formal foundations, and strong experimental activity. clear specification exists for rdb data model and query langauge, but not for oodbs. no consensus on data model. logic programming has strong theoretical framework, but not oodbs. thus ill-defined semantics of such concepts as types. characteristics it should possess: B.1 Mandatory Features <ref> [9] </ref> support complex objects. minimal set of constructors: sets, tuples, lists. sets for representing collections, tuples for representing properties, lists to capture order. all 3 things occur in real world. these 3 constructors should appy to any object, i.e. be orthogonal to type of obj. relational model constructors don't meet this
Reference: [10] <author> B. Freeman-Benson and A. Borning. </author> <title> Integrating constraints with an object-oriented language. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming, </booktitle> <pages> pages 268-286, </pages> <year> 1992. </year> <month> 31 </month>
Reference-contexts: CIP Identity Gap D.2 Kaleidoscope From <ref> [10] </ref>: constraints useful because they are declarative: emphasize relation itself instead of procedural steps necessary to maintain the relation. obstacle to thorough integration of constraints in an object-language: objects provide a larger, arbitrarily general computational domain, which cannot be solved by an efficient constraint solver. like kaleidoscope, ode's constraints obey the
Reference: [11] <author> N. Gehani and H. Jagadish. </author> <title> Ode as an active database: Constraints and triggers. </title> <booktitle> In VLDB 1991, </booktitle> <year> 1992. </year>
Reference-contexts: obj is updated. inter = condition evaluated for multiple objects. for inter, would need to list trigger 16 in definition of each obj involved. alternatively: use a mechanism based on "friend". physical locality makes intra-object constraints and triggers more efficient. when event occurs, object being updated is already in memory. <ref> [11] </ref> says that "most inter-object constraints and triggers can be implemented using one or more intra-object constraint or triggers...A typical case is the "employee's salary no greater than the manager's salary" example.
Reference: [12] <author> T. Irving. </author> <title> A generalized interface between prolog and relational databases. </title> <editor> In P. Gray and R. Lucas, editors, </editor> <title> Prolog and Databases: </title> <booktitle> Implementations and New Directions, </booktitle> <pages> pages 81-94. </pages> <publisher> Ellis Horwood, </publisher> <address> Chich-ester, England, </address> <year> 1988. </year>
Reference: [13] <author> C. Laffra and P. Oosterom. </author> <title> Persistent graphical object. </title> <booktitle> In Advances in Object-Oriented Graphics I, </booktitle> <pages> pages 95-129. </pages> <publisher> EUROGRAPHICS Seminars, </publisher> <address> Germany, </address> <year> 1991. </year>
Reference-contexts: C.2 PROCOL PROCOL <ref> [13] </ref> object-oriented language given persistence. major motivation: GIS, geometric and graphic data. upward compatible: existing non-persistent procol programs can be com piled by procol compiler. transparent persistent objects: persistence independence (i.e. persistent and volatile objects interchangeable as parameters), and persistence data 22 type orthogonality: all objects allowed to be persistent, no
Reference: [14] <author> G. Lopez, B. Freeman-Benson, and A. Borning. </author> <title> Constraints and object identity. </title> <booktitle> In European Conference on Object-Oriented Programming, </booktitle> <year> 1994. </year> <note> Submitted. </note>
Reference-contexts: D Constraint-Based Imperative Languages D.1 Constraints and Object Identity From <ref> [14] </ref>: constraint imperative programming = integrate declarative constraints and imperative oo programming. goal: use constraints to express relations among objects explicitly instead of implicitly. but object-identity can result in implicit relations. solution: identity constraints.
Reference: [15] <author> R. Lucas. </author> <title> Database Applications Using Prolog. </title> <publisher> Ellis Horwood, </publisher> <address> Chich-ester, England, </address> <year> 1988. </year>
Reference-contexts: A special parser is used to build a structure representing the SQL query before translating it into prolog query. <ref> [15] </ref> equi-join: relates data between tables. i.e. here's a join on MANUF field SELECT ADDRESS FROM SUPPLIERS WHERE CARS.MODEL = 'Metro' AND SUPPLIERS.MANUF = CARS.MANUF here's the prolog version: ?-car (Man,metro,_,_,_,_,_),supplier (Man,Address,_),write (Address),nl. key fields = fields for which an index will be created allowing direct access retrieval of entire record <p> E.6 MIMER: A Back End to Prolog Mimer = relational database used by <ref> [15] </ref> as back-end to prolog. prolog search mechanism duplicated via: stack of cursors. new search on a table opens a new cursor, which is pushed onto stack whenever there remained furthre rows in the table that cold be retrieved via sleect condition. to continue search, pop cursor. selection conditions established via
Reference: [16] <author> D. Maier and J. Stein. </author> <title> Development of an object-oriented dbms. </title> <booktitle> In Proceedings of the 1986 Object-Oriented Programming Systems and Languages Conference, </booktitle> <pages> pages 472-482, </pages> <year> 1986. </year>
Reference-contexts: The first object-oriented langauge to be extended with persistence was Smalltalk in the early 1980's, which lead to the Gemstone system <ref> [16] </ref>. The software engineering benefits of object-oriented databases make them commercially viable for such CAD tools, office information systems, graphical information systems, and image processing applications. Soon, numerous implementations of persistent object-oriented languages began to arise, most of which were an extension to C++. <p> Encore [23] implements versioning as a seperate layer on top of basic data model. 3. versions considered to be application issue. apps must set up their own types for recording version control. GemStone <ref> [16] </ref> takes this approach.
Reference: [17] <institution> Persistence in beta. Technical Report MIA 91-20-0.3, Mjolner Informat-ics, </institution> <year> 1992. </year>
Reference-contexts: C Other Ob ject-Oriented Systems C.1 BETA BETA <ref> [17] </ref> when an object is made persistent, all objects that can be reached via references will also be persistent. this includes statically enclosing objects. transitive closure of the object. persistent store is itself a BETA object. = collection of persistent objs. current implementation: obj in one pers.store cannot refer to obj
Reference: [18] <author> F. Mouta, M. Williams, and J. Neves. </author> <title> Implementing query languages in prolog. </title> <editor> In P. Gray and R. Lucas, editors, </editor> <title> Prolog and Databases: </title> <booktitle> Implementations and New Directions, </booktitle> <pages> pages 13-21. </pages> <publisher> Ellis Horwood, </publisher> <address> Chichester, England, </address> <year> 1988. </year>
Reference-contexts: 2-D tables of records. set of facts all with same functor and same number of components. unlike prolog, columns of tables have LABELS. in prolog, field position replaces names of columns. select conditions are set via variable instantiation. [show prolog facts and table] gateway = inter-query-language translation between dbs. 27 <ref> [18] </ref> describes how to implement SQL and QBE queries in prolog. each relation comprises a set oftuples. each tuple can be represented as a ground unit clause in prolog: emp (1,'fernando'2,30,3). emp (2,'carlos',3,60,3). emp (3,'jose',1,25,4).
Reference: [19] <author> J.E. Richardson and M.J. Carey. </author> <title> Persistence in the e language: Issues and implementation. </title> <type> Sciences 791, </type> <institution> Univ. Wisconsin, Madision, </institution> <month> Septem-ber </month> <year> 1988. </year>
Reference: [20] <author> L. Rowe and K. Shoens. </author> <title> Data abstraction, views and updates in rigel. </title> <booktitle> In Proceedings of ACM SIGMOD, </booktitle> <year> 1979. </year>
Reference: [21] <author> N. Gehani S. Dar and H. Jagadish. Cql++: </author> <title> A sql for a c++ based object-oriented dbms. </title> <booktitle> In EDBT 92, </booktitle> <address> Vienna, Austria, </address> <year> 1992. </year> <month> 32 </month>
Reference-contexts: CQL++ users are not given access to private methods and data members. There are 3 views of an object: the CQL++ view, the O++ definition, and the object manager's view, which consists of an &lt;object id,state&gt; pair <ref> [21] </ref>. The state corresponds to the private and public data members of the O++ object. The O++ object also consists of computed attributes, update methods, and other methods (non-updates).
Reference: [22] <author> J.W. Schmidt. </author> <title> Some high level language constructs for data of type rela-tion. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 2(3) </volume> <pages> 247-281, </pages> <month> September </month> <year> 1977. </year>
Reference-contexts: object manager. 2 In such a system, persistent structures can be directly manipulated by the language, and facilities are provided to support relational query techniques over sets of data. 2.1 Milestones in Persistent Programming Langauge Development The integration of database management facilities with a programming language was pioneered in Pascal/R <ref> [22] </ref>, an extension of Pascal designed and implemented in the mid 1970's. The success of the Pascal/R system demonstrated that it was possible to extend the type system of a language to accomodate the relational model.
Reference: [23] <author> A. Skarra and S. Zdonik. </author> <title> The management of changing types in an object-oriented database. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 483-495, </pages> <year> 1986. </year>
Reference-contexts: Encore <ref> [23] </ref> implements versioning as a seperate layer on top of basic data model. 3. versions considered to be application issue. apps must set up their own types for recording version control. GemStone [16] takes this approach.
Reference: [24] <author> D. Stemple and T. Sheard. </author> <booktitle> Construction and Calculus of Types for Database Systems, </booktitle> <pages> pages 3-22. </pages> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1990. </year> <month> 33 </month>
References-found: 24

