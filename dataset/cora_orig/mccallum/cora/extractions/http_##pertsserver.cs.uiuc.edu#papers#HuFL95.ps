URL: http://pertsserver.cs.uiuc.edu/papers/HuFL95.ps
Refering-URL: http://pertsserver.cs.uiuc.edu/members/wfeng/paper/paper.html
Root-URL: http://www.cs.uiuc.edu
Email: janeliug@cs.uiuc.edu  
Title: Enhancing the Performance and Dependability of Real-Time Systems  
Author: D. L. Hull, W. Feng, and J. W.-S. Liu fhull, feng, 
Address: 1304 W. Springfield Ave. Urbana, IL 61801  
Affiliation: Real-Time Systems Laboratory Department of Computer Science University of Illinois at Urbana-Champaign  
Date: April 1995.  
Note: Appeared in: IEEE International Computer Performance and Dependability Symposium, pages 174-182, Erlangen, Germany,  
Abstract: The imprecise-computation technique was proposed as a way to handle transient overloads and enhance the dependability of real-time systems. In a system based on this technique, each time-critical task produces an approximate but usable result whenever a failure or overload prevents the system from producing a precise result. This approach makes meeting deadlines easier, increases the availability of data and services, reduces the need for error-recovery operations, and minimizes the costs in replication. In this paper, we provide an overview of ways to implement and schedule imprecise computations. We then describe the Imprecise Computation Server (ICS) and how it is used to ensure real-time performance of time-critical applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: A new kernel foundation for Unix development. </title> <booktitle> In Proceedings of the Summer USENIX Conference, </booktitle> <month> July </month> <year> 1986. </year>
Reference-contexts: The supervisor restores the callee's state to the state saved by the last checkpoint operation and resumes its execution from that state. 5.2 Implementation The Imprecise Computation Server (ICS) is implemented on top of the Mach operating system <ref> [1] </ref>. It makes use of IMIG, a modified version of the Mach Interface Generator (MIG) [13]. Client Side Server Side ICS-supplied service stub service_server service_save User-supplied service service_checkpoint service_restart Table 1: ICS functions and their classifications There is a server type for each imprecise service provided by the application system.
Reference: [2] <author> M. Boddy and T. Dean. </author> <title> Decision-theoretic deliberation scheduling for problem solving in time-constrained environments. </title> <journal> Artificial Intelligence, </journal> <year> 1992. </year>
Reference-contexts: This method for returning approximate results is called the milestone method. It is applicable whenever there are monotone (or simply incremental) algorithms, including all iterative algorithms, statistical detection and estimation, incremental voice and video transmissions [14], incremental query processing [21], and AI anytime algorithms <ref> [2] </ref>. In particular, a task based on an anytime algorithm is either entirely optional or has a mandatory portion that takes a negligible amount of time to complete compared with the rest of the task.
Reference: [3] <author> J.-Y. Chung, J. W.-S. Liu, and K.-J. Lin. </author> <title> Scheduling periodic jobs that allow imprecise results. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(9) </volume> <pages> 1156-1173, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Examples of optimal and sub-optimal algorithms which minimize the total amount of discarded work can be found in <ref> [3, 18, 19] </ref>. The qualities of results produced by some tasks (e.g., those based on most iterative algorithms and statistical methods) improve faster during the early part of their execution, and the rates of improvement slow as the tasks execute.
Reference: [4] <author> W. Feng and J. W.-S. Liu. </author> <title> Algorithms for scheduling tasks with input error and end-to-end deadlines. </title> <type> Technical Report UIUCDCS-R-94-1888, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: Several heuristic algorithms for scheduling tasks with imprecise inputs and end-to-end timing constraints can be found in <ref> [4] </ref>. These algorithms deal with composite tasks, each of which is a chain of component tasks. The composite tasks are independent of each other. <p> The jth component task becomes ready when the (j 1)th component task completes, and its input is the output of the (j 1)th component task. The heuristic algorithms in <ref> [4] </ref> support a two-level scheduling strategy. At the higher level, the scheduler uses an algorithm, such as those that minimize the maximum fraction of discarded work [6, 17], to distribute the total available processor time among independent composite tasks as evenly as possible subject to their ready times and deadlines. <p> We plan to experiment with several extensions; these include heuristic scheduling algorithms, algorithms for server selection in systems with multiple identical servers, and replicated execution on multiple servers. In particular, the scheduling algorithms described in <ref> [6, 17, 7, 19, 4] </ref> can be seamlessly integrated with ICS by treating the algorithms as a preprocessing step to the client's call to the service stub routine. Many real-time applications can benefit from using ICS by taking advantage of the services that it offers. <p> However, the track records will be noisy. There may be more false returns | records associated with nonexistent targets. As a result, the data processor must spend additional processing time in associating tracks. We plan to implement the algorithms for end-to-end scheduling of dependent tasks described in <ref> [4] </ref> in ICS to make it ideally suited for these types of applications. 7 Acknowledgements This work was partially supported by the NASA contract NAG1613, by the US Navy ONR contract N00014-92-J-1146, and by a fellowship from TRW Sys tem Development Division.
Reference: [5] <author> B. N. Freeman-Benson, J. Maloney, and A. Born-ing. </author> <title> An incremental constraint solver. </title> <journal> Communications of the ACM, </journal> <volume> 33(1) </volume> <pages> 54-63, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: When constrained objects are more complex in nature, real-time response is difficult due to the extensive computations involved in satisfying complex geometric constraints. A possible solution would be to restrict the power of the constraint solver by employing propagational algorithms <ref> [5] </ref> whose implementation can be simplified with ICS. Radar tracking is another real-time application which would benefit from ICS. In this application, the mandatory part consists of processing the returned radar signal and creating track records for detected targets by a signal processor.
Reference: [6] <author> K. I. J. Ho, J. Y. T. Leung, and W. D. Wei. </author> <title> Minimizing maximum weighted error of imprecise computation tasks. </title> <type> Technical report, </type> <institution> University of Nebraska, </institution> <year> 1992. </year>
Reference-contexts: The maximum fraction of discarded work of a set of tasks fT i g with identical weights is max i f (o i i )=o i g. Polynomial-time algorithms for finding optimal schedules with the smallest maximum fraction of discarded work can be found in <ref> [6, 17] </ref>. On the other hand, the result of a task may improve in quality at a faster as it executes longer. The optional part of such a task should be scheduled as much as possible or not at all. <p> The heuristic algorithms in [4] support a two-level scheduling strategy. At the higher level, the scheduler uses an algorithm, such as those that minimize the maximum fraction of discarded work <ref> [6, 17] </ref>, to distribute the total available processor time among independent composite tasks as evenly as possible subject to their ready times and deadlines. The time allocated to each composite task is then partitioned among component tasks. <p> We plan to experiment with several extensions; these include heuristic scheduling algorithms, algorithms for server selection in systems with multiple identical servers, and replicated execution on multiple servers. In particular, the scheduling algorithms described in <ref> [6, 17, 7, 19, 4] </ref> can be seamlessly integrated with ICS by treating the algorithms as a preprocessing step to the client's call to the service stub routine. Many real-time applications can benefit from using ICS by taking advantage of the services that it offers.
Reference: [7] <author> K. I. J. Ho, J. Y. T. Leung, and W. D. Wei. </author> <title> Scheduling imprecise computation tasks with 0/1 constraints. </title> <type> Technical report, </type> <institution> University of Ne-braska, </institution> <year> 1992. </year>
Reference-contexts: A task that implements a sieve function is a task with the 0/1 constraint. From a scheduling point of view, a task with two versions is a mandatory task followed by one with this constraint. Algorithms for scheduling tasks with the 0/1 constraint can be found in <ref> [7, 19] </ref>. All the aforementioned scheduling algorithms assume that the inputs of the tasks are precise and that the release times and deadlines of individual tasks are given. In many applications, however, these assumptions are not valid. <p> We plan to experiment with several extensions; these include heuristic scheduling algorithms, algorithms for server selection in systems with multiple identical servers, and replicated execution on multiple servers. In particular, the scheduling algorithms described in <ref> [6, 17, 7, 19, 4] </ref> can be seamlessly integrated with ICS by treating the algorithms as a preprocessing step to the client's call to the service stub routine. Many real-time applications can benefit from using ICS by taking advantage of the services that it offers.
Reference: [8] <author> S. Karsenty, J. Landay, and C. Weikart. </author> <title> Inferring graphical constraints with Rockit. </title> <type> Technical report, </type> <institution> Digital Equipement Corporation, Paris Research Laboratory, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Many real-time applications can benefit from using ICS by taking advantage of the services that it offers. For example, in constraint-based graphics such as Rockit <ref> [8] </ref>, GITS [16], and Oak [20], the constraint solver must be fast enough to produce interactive response. Specifically, it must be fast enough for constrained visual objects (e.g., two lines constrained to be perpendicular to one another) to follow the motion of the mouse cursor in real time.
Reference: [9] <author> B. Koo and S. Toueg. </author> <title> Checkpointing and rollback-recovery for distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> January </month> <year> 1987. </year>
Reference-contexts: The fault can be tolerated and no recovery action is needed if the result allows the system to maintain track of the targets. In embedded systems, this technique can be used with traditional checkpointing and replication techniques <ref> [9, 15] </ref>. The result is a reduction of the costs for providing fault tolerance and enhanced availability. After describing ways to implement imprecise computations, we provide an overview on methods to schedule imprecise computations.
Reference: [10] <author> K.-J. Lin, S. Natarajan, and J. W.-S. Liu. </author> <title> Im--precise results: Utilizing partial computations in real-time systems. </title> <booktitle> In Proceedings of 8th IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1987. </year>
Reference: [11] <author> J. W.-S. Liu, K.-J. Lin, and C. L. Liu. </author> <title> A position paper for the 1987 IEEE workshop on real-time operating systems. </title> <booktitle> In Proceedings of the 1987 IEEE Workshop on Real-Time Operating Systems, </booktitle> <month> May </month> <year> 1987. </year>
Reference: [12] <author> J. W.-S. Liu, K.-J. Lin, and S. Natarajan. </author> <title> Scheduling real-time, periodic jobs using imprecise results. </title> <booktitle> In Proceedings of 8th IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1987. </year>
Reference: [13] <author> Keith Loepere, </author> <title> editor. Mach 3 Server Writer's Guide. </title> <institution> Open Software Foundation and Carnagie Mellon University, </institution> <year> 1990. </year>
Reference-contexts: It makes use of IMIG, a modified version of the Mach Interface Generator (MIG) <ref> [13] </ref>. Client Side Server Side ICS-supplied service stub service_server service_save User-supplied service service_checkpoint service_restart Table 1: ICS functions and their classifications There is a server type for each imprecise service provided by the application system.
Reference: [14] <author> G. Mongatti, L. Alparone, G. Benelli, S. Baronti, F. Lotti, and A. Casini. </author> <title> Progressive image transmission by content driven laplacian pyramid encoding. </title> <journal> IEE Proceedings-I, </journal> <volume> 139(5), </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: This method for returning approximate results is called the milestone method. It is applicable whenever there are monotone (or simply incremental) algorithms, including all iterative algorithms, statistical detection and estimation, incremental voice and video transmissions <ref> [14] </ref>, incremental query processing [21], and AI anytime algorithms [2]. In particular, a task based on an anytime algorithm is either entirely optional or has a mandatory portion that takes a negligible amount of time to complete compared with the rest of the task.
Reference: [15] <author> M. Obradovic and P. Berman. </author> <title> Voting as the optimal static pessimistic scheme for managing replicated data. </title> <booktitle> In Proceedings of 9th IEEE Symposium on Reliable Distributed Systems, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: The fault can be tolerated and no recovery action is needed if the result allows the system to maintain track of the targets. In embedded systems, this technique can be used with traditional checkpointing and replication techniques <ref> [9, 15] </ref>. The result is a reduction of the costs for providing fault tolerance and enhanced availability. After describing ways to implement imprecise computations, we provide an overview on methods to schedule imprecise computations.
Reference: [16] <author> D. R. Olsen and K. Allan. </author> <title> Creating interactive techniques by symbolically solving geometric constraints. </title> <booktitle> In Proceedings of ACM SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <year> 1990. </year>
Reference-contexts: Many real-time applications can benefit from using ICS by taking advantage of the services that it offers. For example, in constraint-based graphics such as Rockit [8], GITS <ref> [16] </ref>, and Oak [20], the constraint solver must be fast enough to produce interactive response. Specifically, it must be fast enough for constrained visual objects (e.g., two lines constrained to be perpendicular to one another) to follow the motion of the mouse cursor in real time.
Reference: [17] <author> W.-K. Shih and J. W.-S. Liu. </author> <title> Algorithms for scheduling imprecise computations with timing cons traints to minimize maximum error. </title> <note> To appear in IEEE Transactions on Computers. </note>
Reference-contexts: The maximum fraction of discarded work of a set of tasks fT i g with identical weights is max i f (o i i )=o i g. Polynomial-time algorithms for finding optimal schedules with the smallest maximum fraction of discarded work can be found in <ref> [6, 17] </ref>. On the other hand, the result of a task may improve in quality at a faster as it executes longer. The optional part of such a task should be scheduled as much as possible or not at all. <p> The heuristic algorithms in [4] support a two-level scheduling strategy. At the higher level, the scheduler uses an algorithm, such as those that minimize the maximum fraction of discarded work <ref> [6, 17] </ref>, to distribute the total available processor time among independent composite tasks as evenly as possible subject to their ready times and deadlines. The time allocated to each composite task is then partitioned among component tasks. <p> We plan to experiment with several extensions; these include heuristic scheduling algorithms, algorithms for server selection in systems with multiple identical servers, and replicated execution on multiple servers. In particular, the scheduling algorithms described in <ref> [6, 17, 7, 19, 4] </ref> can be seamlessly integrated with ICS by treating the algorithms as a preprocessing step to the client's call to the service stub routine. Many real-time applications can benefit from using ICS by taking advantage of the services that it offers.
Reference: [18] <author> W.-K. Shih and J. W.-S. Liu. </author> <title> On-line scheduling of imprecise computations to minimize error. </title> <booktitle> In Proceedings of the 13th IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1992. </year>
Reference-contexts: Examples of optimal and sub-optimal algorithms which minimize the total amount of discarded work can be found in <ref> [3, 18, 19] </ref>. The qualities of results produced by some tasks (e.g., those based on most iterative algorithms and statistical methods) improve faster during the early part of their execution, and the rates of improvement slow as the tasks execute.
Reference: [19] <author> W.-K. Shih, J. W.-S. Liu, and J.-Y. Chung. </author> <title> Algorithms for scheduling imprecise computations to minimize total error. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(3) </volume> <pages> 537-552, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: While the sieve and multiple-version methods may be more widely applicable, they are not ideal for two reasons. First, the system must anticipate and decide ahead of time whether to schedule a sieve or primary version. This leads to a higher scheduling overhead <ref> [19] </ref>. Second, and more importantly, these methods, unlike the milestone method, cannot be easily integrated with traditional fault-tolerance methods. <p> Examples of optimal and sub-optimal algorithms which minimize the total amount of discarded work can be found in <ref> [3, 18, 19] </ref>. The qualities of results produced by some tasks (e.g., those based on most iterative algorithms and statistical methods) improve faster during the early part of their execution, and the rates of improvement slow as the tasks execute. <p> A task that implements a sieve function is a task with the 0/1 constraint. From a scheduling point of view, a task with two versions is a mandatory task followed by one with this constraint. Algorithms for scheduling tasks with the 0/1 constraint can be found in <ref> [7, 19] </ref>. All the aforementioned scheduling algorithms assume that the inputs of the tasks are precise and that the release times and deadlines of individual tasks are given. In many applications, however, these assumptions are not valid. <p> We plan to experiment with several extensions; these include heuristic scheduling algorithms, algorithms for server selection in systems with multiple identical servers, and replicated execution on multiple servers. In particular, the scheduling algorithms described in <ref> [6, 17, 7, 19, 4] </ref> can be seamlessly integrated with ICS by treating the algorithms as a preprocessing step to the client's call to the service stub routine. Many real-time applications can benefit from using ICS by taking advantage of the services that it offers.
Reference: [20] <author> T. Tonouchi, K. Nakayama, S. Matsuoka, and S. Kawai. </author> <title> Creating visual objects by direct manipulation. </title> <booktitle> In Proceedings of ACM SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <year> 1992. </year>
Reference-contexts: Many real-time applications can benefit from using ICS by taking advantage of the services that it offers. For example, in constraint-based graphics such as Rockit [8], GITS [16], and Oak <ref> [20] </ref>, the constraint solver must be fast enough to produce interactive response. Specifically, it must be fast enough for constrained visual objects (e.g., two lines constrained to be perpendicular to one another) to follow the motion of the mouse cursor in real time.
Reference: [21] <author> S. V. Vrbsky and J. W.-S. Liu. </author> <title> Approximate: A query processor that produces monotonically improving approximate answers. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5(6) </volume> <pages> 1056-1068, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: This method for returning approximate results is called the milestone method. It is applicable whenever there are monotone (or simply incremental) algorithms, including all iterative algorithms, statistical detection and estimation, incremental voice and video transmissions [14], incremental query processing <ref> [21] </ref>, and AI anytime algorithms [2]. In particular, a task based on an anytime algorithm is either entirely optional or has a mandatory portion that takes a negligible amount of time to complete compared with the rest of the task.
References-found: 21

