URL: http://www.cs.wisc.edu/wpis/papers/diku-topps-d212.ps
Refering-URL: http://www.cs.wisc.edu/wpis/papers/
Root-URL: 
Title: On the Sequential Nature of Interprocedural Program-Analysis Problems Obtaining meet-over-all-valid-paths solutions to interprocedural gen/kill dataow
Author: Thomas Reps P. 
Note: hard.  
Address: 1  
Affiliation: University of Copenhagen  
Abstract: In this paper, we study two interprocedural program-analysis problemsinterprocedural slicing and inter-procedural dataow analysisand present the following results: These results provide evidence that there do not exist fast (NC-class) parallel algorithms for interprocedural slicing and interprocedural dataow analysis (unless P NC). That is, it is unlikely that there are algorithms for interprocedural slicing and interprocedural dataow analysis for which the number of processors is bounded by a polynomial in the size of the input, and whose running time is bounded by a polynomial in the logarithm of the size of the input. This suggests that there are limitations on the ability to use parallelism to overcome compiler bottlenecks due to expensive interproce-dural-analysis computations. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Badger, L. and Weiser, M., </author> <title> Minimizing communication for synchronizing parallel dataow programs, </title> <booktitle> in Proceedings of the 1988 International Conference on Parallel Processing, </booktitle> <address> (St. Charles, IL, </address> <month> Aug. </month> <pages> 15-19, </pages> <year> 1988), </year> <institution> Pennsylvania State University Press, University Park, </institution> <address> PA (1988). </address>
Reference: 2. <author> Callahan, D., </author> <title> The program summary graph and ow-sensitive interprocedural data ow analysis, </title> <booktitle> Proceedings of the ACM SIG-PLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 47-56 (July </month> <year> 1988). </year>
Reference: 3. <author> Deransart, P., Jourdan, M., and Lorho, B., </author> <title> Attribute Grammars: Definitions, Systems and Bibliography, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 323, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1988). </address>
Reference: 4. <author> Dwork, C., Kanellakis, P.C., and Mitchell, </author> <title> J.C., On the sequential nature of unification, </title> <journal> Journal of Logic Programming 1 pp. </journal> <month> 35-50 </month> <year> (1984). </year>
Reference-contexts: In terms of the impact on the programming-languages area, our results can be viewed as being complementary to the results of Dwork, Kanellakis, and Mitchell, who showed that there are limitations on the ability to use parallelism to speed up unification <ref> [4] </ref>. The Dwork-Kanellakis-Mitchell result demonstrates that there are limitations on the use of parallelism to speed up the execution of programs (specifically, programs written in languages such as Prolog that use unification for parameter passing). <p> Robinson's comments on the Dwork-Kanellakis-Mitchell result [21].) The gadgets used in the constructions in Sections 3 and 4 have some similarities to the ones used in the proofs that the unification problem <ref> [4] </ref> and the left-linear semi-unification problem [6] are log-space complete for P.
Reference: 5. <author> Goldschlager, L., </author> <title> The monotone and planar circuit value problems are log-space complete for P, </title> <journal> ACM SIGACT News 9(2) pp. </journal> <month> 25-29 </month> <year> (1977). </year>
Reference-contexts: The proof that interprocedural slicing is log-space complete for P is by a log-space reduction from a known P-complete problem, the monotone circuit value problem <ref> [5] </ref>, which is defined as follows: Definition 3.2.
Reference: 6. <author> Henglein, F., </author> <title> Fast left-linear semi-unification, pp. </title> <booktitle> 82-91 in Proceedings of the International Conference on Computing and Information, </booktitle> <month> (May </month> <year> 1990), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 468, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1990). </address>
Reference-contexts: Robinson's comments on the Dwork-Kanellakis-Mitchell result [21].) The gadgets used in the constructions in Sections 3 and 4 have some similarities to the ones used in the proofs that the unification problem [4] and the left-linear semi-unification problem <ref> [6] </ref> are log-space complete for P.
Reference: 7. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> A CM SIGPLAN Notices 23(7) pp. </journal> <month> 35-46 (July </month> <year> 1988). </year>
Reference: 8. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 11(3) pp. </pages> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: This concept, originally discussed by Mark Weiser in [24], allows one to isolate individual computation threads within a program. Slicing can be used for such diverse activities as helping a programmer understand complicated code, aiding debugging [17], automatically parallelizing programs [23,1], and automatically combining program variants <ref> [8] </ref>. In Weiser's terminology, a slicing criterion is a pair &lt; p, V &gt;, where p is a program point and V is a subset of the program's variables.
Reference: 9. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, ACM T rans. Program. </title> <journal> Lang. Syst. </journal> <pages> 12(1) pp. </pages> <month> 26-60 (January </month> <year> 1990). </year> <month> - 16 </month> - 
Reference-contexts: For even richer languages the interprocedural slicing and interprocedural dataow analysis problems are P-hard, but they may not be P-complete (because for richer languages these problems may not be solvable in polynomial time). Following Sharir and Pnueli [22] and Horwitz, Reps, and Binkley <ref> [9] </ref>, we assume that the programs being analyzed do not contain aliasing and that they do not use procedure-valued variables. We also make some simplifying assumptions about global variables. <p> &lt; 11 do call A (i) od procedure A (y) call Increment ( y) return procedure Add (a, b) a : = a + b return procedure Increment (z) call Add (z, 1) return This set of program elements is computed by the slicing algorithms of Horwitz, Reps, and Binkley <ref> [9] </ref>, and Hwang, Du, and Chou [10]. End of Example. The algorithms of Horwitz, Reps, and Binkley and Hwang, Du, and Chou improve on Weiser's algorithm by only considering effects transmitted along interprocedurally valid paths. <p> End of Example. The algorithms of Horwitz, Reps, and Binkley and Hwang, Du, and Chou improve on Weiser's algorithm by only considering effects transmitted along interprocedurally valid paths. However, whereas the running time of the Horwitz-Reps-Binkley algorithm has been shown to be polynomial in the size of the program <ref> [9] </ref>, it is possible to show that the Hwang-Du-Chou algorithm is exponential. That is, there is a family of examples on which the algorithm takes time exponential in the size of the program being sliced. <p> The notion of a valid path is most easily understood in terms of the concept of a system dependence graph, a graph used to represent multi-procedure programs (systems) and to implement the Horwitz-Reps-Binkley slicing algorithm <ref> [9] </ref>. The system dependence graph extends previous dependence-graph representations to incorporate collections of procedures (with procedure calls) rather than just monolithic programs. The system dependence graph for the example program discussed above is shown in Figure 1. <p> results reported in this paper, i t is not really important to understand the details of how program dependence graphs are constructed or even the exact nature of the various kinds of edges that occur in them, and for this reason such material is not included in the paper (see <ref> [9] </ref>). (However, it i s important to know that the dependence graph for a program can be constructed in time polynomial in the size of the program.) For the purposes of this paper, it is really only necessary to understand the manner in which dependence graphs for different procedures are linked <p> Theorem 3.3. The problem of interprocedural slicing is log-space complete for P. - 8 - Proof. It was shown in <ref> [9] </ref> that the Horwitz-Reps-Binkley algorithm for interprocedural slicing runs in polynomial time. 3 The proof that interprocedural slicing is P-hard is by reduction from the monotone circuit value problem via a log-space Turing machine program. 4 Given a circuit C and a truth-value assignment a on the input tape, the construction <p> Linkage grammars were introduced by Horwitz, Reps, and Binkley as an abstraction of the system dependence graph <ref> [9] </ref>. 5 3 More precisely, it was shown in [9] that the running time of the Horwitz-Reps-Binkley algorithm is bounded by O (P . (Sites + 1) 3 . (Globals + Params) 4 ), where P is the number of procedures in the program, Sites is the largest number of call <p> Linkage grammars were introduced by Horwitz, Reps, and Binkley as an abstraction of the system dependence graph <ref> [9] </ref>. 5 3 More precisely, it was shown in [9] that the running time of the Horwitz-Reps-Binkley algorithm is bounded by O (P . (Sites + 1) 3 . (Globals + Params) 4 ), where P is the number of procedures in the program, Sites is the largest number of call sites in any procedure, Params is the largest number
Reference: 10. <author> Hwang, J.C., Du, M.W., and Chou, C.R., </author> <title> Finding program slices for recursive procedures, </title> <booktitle> in Proceedings of IEEE COMPSAC 88, </booktitle> <address> (Chicago, IL, </address> <month> Oct. </month> <pages> 3-7, </pages> <address> 1988), </address> <publisher> IEEE Computer Society, </publisher> <address> Washington, DC (1988). </address>
Reference-contexts: The Calling-Context Problem and Valid Paths One algorithm for interprocedural slicing was presented by Weiser [24]. However, as p ointed out independently by Horwitz, Reps, and Binkley [7,9] and Hwang, Du, and Chou <ref> [10] </ref>, Weiser's algorithm is imprecise in the sense that it can report effects that are transmitted (only) through paths in a graph representation of the program that do not represent feasible (valid) execution paths. <p> od procedure A (y) call Increment ( y) return procedure Add (a, b) a : = a + b return procedure Increment (z) call Add (z, 1) return This set of program elements is computed by the slicing algorithms of Horwitz, Reps, and Binkley [9], and Hwang, Du, and Chou <ref> [10] </ref>. End of Example. The algorithms of Horwitz, Reps, and Binkley and Hwang, Du, and Chou improve on Weiser's algorithm by only considering effects transmitted along interprocedurally valid paths.
Reference: 11. <author> Jones, N.D. and Laaser, W.T., </author> <title> Complete problems for deterministic polynomial time, </title> <note> Theoretical Computer Science 3 pp. </note> <month> 105-117 </month> <year> (1977). </year>
Reference-contexts: Terminology and Assumptions A problem that is log-space complete for P (or P-complete under log-space reductions) has the property that if it is recognizable in space log k ( . ) then every language in P (a.k.a. PTIME) is also recognizable in space log k ( . ) <ref> [11] </ref>.
Reference: 12. <author> Kastens, U., </author> <title> Ordered attribute grammars, </title> <note> Acta Informatica 13(3) pp. </note> <month> 229-256 </month> <year> (1980). </year>
Reference-contexts: Remark. Theorem 3.3 also has consequences for the computation of IO graphs of attribute grammars [13,3,18] and other similar approximations to the characteristic graphs of an attribute grammar's nontermi-nals that can be computed in polynomial time, such as TDS graphs of ordered attribute grammars <ref> [12] </ref>. To establish the connection between Theorem 3.3 and attribute grammars it is necessary to introduce the concept of a linkage grammaran attribute grammar that models the call structure of a program together with the (intraprocedural) transitive dependences among a procedure's p arameter vertices. <p> Proof. By an argument along the lines of the one given by Kastens that shows that TDS graphs of ordered attribute grammars can be computed in polynomial time <ref> [12] </ref>, it can be shown that the IO graphs of an attribute grammar's nonterminals can be computed in polynomial time. The proof that the problem is P-hard is by reduction from the monotone circuit value problem.
Reference: 13. <author> Kennedy, K. and Warren, </author> <title> S.K., Automatic generation of efficient evaluators for attribute grammars, pp. </title> <booktitle> 32-49 in Conference Record of the Third ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Atlanta, GA, </address> <month> Jan. </month> <pages> 19-21, </pages> <address> 1976), </address> <publisher> ACM, </publisher> <address> New York, NY (1976). </address>
Reference: 14. <author> Kildall, G., </author> <title> A unified approach to global program optimization, pp. </title> <booktitle> 194-206 in Conference Record of the First ACM Symposium on Principles of Programming Languages, ACM, </booktitle> <address> New York, NY (1973). </address>
Reference-contexts: The concept of valid paths arises in both the interprocedural-slicing problem [9,10] and in ow-sensitive interpro-cedural dataow analysis problems [22,19,2,16,15]. In particular, Sharir and Pnueli have generalized Kil-dall's concept of the meet-over-all-paths solution of an intraprocedural dataow analysis problem <ref> [14] </ref> to the meet-over-all-valid-paths solution of an interprocedural dataow analysis problem [22]. Interprocedural analysis is generally expensive, and can be the bottleneck in compilers that employ it. This raises the question of whether it might be possible to devise fast parallel algorithms for interprocedural analysis problems. <p> We also assume that dataow functions are members of a space of monotonic (or distributive) functions F L fi L and that F contains the identity function. Sharir and Pnueli's functional approach to interprocedural dataow analysis generalizes Kildall's concept of the meet-over-all-paths solution of an intraprocedural dataow analysis problem <ref> [14] </ref> to the meet-over-all-valid-paths solution of an interprocedural dataow analysis problem [22]. This framework for interprocedural dataow analysis is reviewed below.
Reference: 15. <author> Knoop, J. and Steffen, B., </author> <title> The interprocedural coincidence theorem, pp. </title> <booktitle> 125-140 in Proceedings of the Fourth International Conference on Compiler Construction, (Paderborn, </booktitle> <address> FRG, </address> <month> October 5-7, </month> <year> 1992), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 641, </volume> <editor> ed. U. Kastens and P. Pfahler, </editor> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1992). </address>
Reference: 16. <author> Landi, W. and Ryder, B .G., </author> <title> Pointer-induced aliasing: A problem classification, pp. </title> <booktitle> 93-103 in Conference Record of the Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Orlando, FL, </address> <month> January </month> <year> 1991), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1991). </address>
Reference-contexts: affected by assignments to y that reach p and by the loops and conditionals that enclose p. 2 See also the discussion in Section 5 relating the work reported in this paper with Landi and Ryder's work on other aspects of interpro-cedural analysis and the inherent computational limitations they introduce <ref> [16] </ref>. - 3 - In intraprocedural slicingthe problem of slicing a program that consists of just a single monolithic pro-cedurea slice can be determined from the closure of the directly-affects relation. Ottenstein and Otten-stein pointed out how well-suited program dependence graphs are for this kind of slicing [20]. <p> Landi and Ryder have also investigated the computational complexity of interprocedural dataow a naly-sis under the assumption that only valid paths are to be considered <ref> [16] </ref>. (Valid paths are called realizable paths in [16].) Their work shows that when the program-analysis problem to be solved involves certain kinds of constructs (e.g., single or multiple levels of pointers, reference parameters, etc.) one faces certain kinds of computational limitations (e.g., NP-hardness, undecidability, etc.). <p> Landi and Ryder have also investigated the computational complexity of interprocedural dataow a naly-sis under the assumption that only valid paths are to be considered <ref> [16] </ref>. (Valid paths are called realizable paths in [16].) Their work shows that when the program-analysis problem to be solved involves certain kinds of constructs (e.g., single or multiple levels of pointers, reference parameters, etc.) one faces certain kinds of computational limitations (e.g., NP-hardness, undecidability, etc.).
Reference: 17. <author> Lyle, J. and Weiser, M., </author> <title> Experiments on slicing-based debugging tools, </title> <booktitle> in Proceedings of the First Conference on Empirical Studies of Programming, </booktitle> <address> (June 1986), </address> <publisher> Ablex Publishing Co. </publisher> <year> (1986). </year>
Reference-contexts: This concept, originally discussed by Mark Weiser in [24], allows one to isolate individual computation threads within a program. Slicing can be used for such diverse activities as helping a programmer understand complicated code, aiding debugging <ref> [17] </ref>, automatically parallelizing programs [23,1], and automatically combining program variants [8]. In Weiser's terminology, a slicing criterion is a pair &lt; p, V &gt;, where p is a program point and V is a subset of the program's variables.
Reference: 18. <author> Mo ncke, U. and Wilhelm, R., </author> <title> Grammar ow analysis, pp. 151-186 in Attribute Grammars, </title> <booktitle> Applications and Systems, (International Summer School SAGA, </booktitle> <address> Prague, Czechoslovakia, </address> <month> June </month> <year> 1991), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 545, </volume> <editor> ed. H. Alblas and B. Melichar, </editor> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1991). </address>
Reference: 19. <author> Myers, E., </author> <title> A precise inter-procedural data ow algorithm, pp. </title> <booktitle> 219-230 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1981). </address>
Reference: 20. <author> Ottenstein, K.J. and Ottenstein, L.M., </author> <title> The program dependence graph in a software development environment, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> Apr. </month> <pages> 23-25, </pages> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 177-184 (May </month> <year> 1984). </year>
Reference-contexts: Ottenstein and Otten-stein pointed out how well-suited program dependence graphs are for this kind of slicing <ref> [20] </ref>.
Reference: 21. <author> Robinson, </author> <title> J.A., </title> <journal> Logic and logic programming, Commun. of the ACM 35(3) pp. </journal> <month> 40-65 (March </month> <year> 1992). </year>
Reference-contexts: Robinson's comments on the Dwork-Kanellakis-Mitchell result <ref> [21] </ref>.) The gadgets used in the constructions in Sections 3 and 4 have some similarities to the ones used in the proofs that the unification problem [4] and the left-linear semi-unification problem [6] are log-space complete for P.
Reference: 22. <author> Sharir, M. and Pnueli, A., </author> <title> Two approaches to interprocedural data ow analysis, pp. 189-233 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones, </editor> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: In particular, Sharir and Pnueli have generalized Kil-dall's concept of the meet-over-all-paths solution of an intraprocedural dataow analysis problem [14] to the meet-over-all-valid-paths solution of an interprocedural dataow analysis problem <ref> [22] </ref>. Interprocedural analysis is generally expensive, and can be the bottleneck in compilers that employ it. This raises the question of whether it might be possible to devise fast parallel algorithms for interprocedural analysis problems. <p> For even richer languages the interprocedural slicing and interprocedural dataow analysis problems are P-hard, but they may not be P-complete (because for richer languages these problems may not be solvable in polynomial time). Following Sharir and Pnueli <ref> [22] </ref> and Horwitz, Reps, and Binkley [9], we assume that the programs being analyzed do not contain aliasing and that they do not use procedure-valued variables. We also make some simplifying assumptions about global variables. <p> Sharir and Pnueli's functional approach to interprocedural dataow analysis generalizes Kildall's concept of the meet-over-all-paths solution of an intraprocedural dataow analysis problem [14] to the meet-over-all-valid-paths solution of an interprocedural dataow analysis problem <ref> [22] </ref>. This framework for interprocedural dataow analysis is reviewed below. <p> Definition 4.1. (Sharir and Pnueli <ref> [22] </ref>). Define G = - G p | p is a procedure in the program -, where, for each p, G p = (N p , E p , r p ). <p> The second graph representation, in which the ow graphs of the different procedures are connected together, is used to define the notion of interprocedurally valid paths. Definition 4.2. (Sharir and Pnueli <ref> [22] </ref>). Define G * * * , r main ), where N * p * 0 E , where E 0 p 0 p is the collection of all ordinary control-ow edges, and an edge (m, n) E 2 represents either a call or return edge. <p> The notion of interprocedurally valid paths captures the idea that not all paths through G * represent potentially valid execution paths: Definition 4.3. (Sharir and Pnueli <ref> [22] </ref>). For each n N , we define IVP (r main , n) as the set of all interpro-cedurally valid paths in G * that lead from r main to n. <p> Definition 4.4. (Sharir and Pnueli <ref> [22] </ref>). If q is a path in G * , let f q denote the (path) function obtained by composing the functions associated with q's edges (in the order that they a ppear in path q). <p> Proof. Sharir and Pnueli have shown that if the edge functions are distributive, t he meet-over-all-valid-paths solution can be determined via a two-phase process, where each phase involves finding the greatest solution to a set of equations <ref> [22] </ref>. The meet-over-all-valid-paths solution is not obtained directly from the equations of Definition 4.4, but from two other systems of equations, which are solved in separate phases. In Phase I, the equations deal with summary dataow functions, which are defined in terms of dataow functions and other summary dataow functions.
Reference: 23. <author> Weiser, M., </author> <title> Reconstructing sequential behavior from parallel behavior projections, </title> <note> Information Processing Letters 17 pp. </note> <month> 129-135 (October </month> <year> 1983). </year>
Reference: 24. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference-contexts: Interprocedural Slicing The slice of a program with respect to program-point p and variable x consists of all statements and predicates of the program that might affect the value of x at point p. This concept, originally discussed by Mark Weiser in <ref> [24] </ref>, allows one to isolate individual computation threads within a program. Slicing can be used for such diverse activities as helping a programmer understand complicated code, aiding debugging [17], automatically parallelizing programs [23,1], and automatically combining program variants [8]. <p> This section concerns the problem of interprocedural slicinggenerating a slice of an entire program, where the slice crosses the boundaries of procedure calls. 3.1. The Calling-Context Problem and Valid Paths One algorithm for interprocedural slicing was presented by Weiser <ref> [24] </ref>. <p> Such paths fail to account correctly for the calling context (e.g., c 1 in Main) of a called procedure (e.g., P). Weiser describes his method for interprocedural slicing as follows <ref> [24] </ref>: For each criterion C for a procedure P, there is a set of criteria UP 0 (C) which are those needed to slice callers of P, and a set of criteria DOWN 0 (C) which are those needed to slice procedures called by P. . . .
References-found: 24

