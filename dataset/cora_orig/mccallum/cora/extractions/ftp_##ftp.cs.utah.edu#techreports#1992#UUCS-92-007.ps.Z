URL: ftp://ftp.cs.utah.edu/techreports/1992/UUCS-92-007.ps.Z
Refering-URL: http://www.cs.utah.edu/~gary/MSO-publications.html
Root-URL: 
Title: THE PROGRAMMING LANGUAGE JIGSAW: MIXINS, MODULARITY AND MULTIPLE INHERITANCE  
Degree: by Gilad Bracha A dissertation submitted to the faculty of The University of Utah in partial fulfillment of the requirements for the degree of Doctor of Philosophy  
Date: March 1992  
Affiliation: Department of Computer Science The University of Utah  
Abstract-found: 0
Intro-found: 1
Reference: [1] <institution> Reference manual for the Ada programming language. ANSI/MIL-STD-1815 A, </institution> <year> 1983. </year>
Reference-contexts: No static typechecking is performed across module boundaries. There is also poor support for encapsulation; typically, all globals in a module are available to other modules. Later languages such as CLU [43], Ada <ref> [1] </ref>, Modula-2 [74], Modula-3 and others provide a structured way of specifying modules and their interconnection. Formal notions of module and interface are part of the language. The language semantics guarantee that modules are used in accordance with their interface. <p> Such abstractions are the topic of the next subsection. 3.2.1 Mixins and Type Abstraction Many programming languages support abstractions over "second-class" entities, such as types, classes or modules <ref> [43, 1, 62, 51, 55, 23, 26] </ref>. These constructs are often referred to as generics. In some languages, generics are merely macros, separately expanded and recompiled for every application of the abstraction. This is the case in Ada, Modula-3 and C++. Such constructs are easily incorporated into almost any language.
Reference: [2] <author> Agha, G. </author> <title> Actors: A Model of Concurrent Computing in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: The main exception is CommonObjects [63, 65], which is discussed in Chapter 8 in the context of related work. 3.1.2 SELF SELF, like CLOS, is dynamically typed. Unlike CLOS, it is not based upon a linear form of inheritance, but rather upon delegation <ref> [2, 6, 41, 66] </ref>. Delegation is a form of inheritance that occurs between objects (often referred to as prototypes) at execution time, rather than between classes at the time of compilation. Like CLOS, SELF has a built-in mechanism for accessing overridden methods (known as resend).
Reference: [3] <author> Agrawal, R., DeMichiel, L. G., and Lindsay, B. G. </author> <title> Static type checking of multi-methods. </title> <booktitle> In Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (Oct. </booktitle> <year> 1991), </year> <pages> pp. 113-127. </pages>
Reference-contexts: Given 126 that a program with that many object types is clearly a substantial one, the overhead of 120 kilobytes of storage is not unreasonable. Still, reliance on a quadratic algorithm is worrisome. A third option is described in <ref> [3] </ref>. A compressed transitive closure of the subtype relation is maintained. This structure allows testing in at worst O (logn) time, but in practice gives constant time performance. 3. Garbage Collection. Each subobject should have a pointer to the beginning of the entire object.
Reference: [4] <author> America, P. </author> <title> A parallel object-oriented language with inheritance and sub-typing. </title> <booktitle> In Proc. of the Joint ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications and the European Conference on Object-Oriented Programming (Oct. </booktitle> <year> 1990), </year> <pages> pp. 161-168. </pages>
Reference-contexts: In the case of unsound type systems, the problems may be rectified by use of dynamic typing, as in Beta [48]. 2.3.1.3 Other Considerations The separation of classes and types makes it easier to define orthogonal constructs for renaming <ref> [4, pp. 168] </ref> and visibility control. There are other reasons for separating classes and types. These have less to do with modularity. The interested reader is referred to [8, 9, 19, 48]. It is worth noting that there are arguments for merging the concepts of type and class.
Reference: [5] <author> Bentley, J. L. </author> <title> More Programming Pearls. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: In the new framework, the distinction between single and multiple inheritance disappears, but the desired functionality remains available. Jigsaw provides a notion of modularity independent of a particular computational paradigm. Jigsaw can therefore be applied to a wide variety of languages, 8 especially special-purpose and "little-languages" <ref> [5, Column 9] </ref>, where the effort of designing specific mechanisms for modularity is difficult to justify, but which could still benefit from such mechanisms. Jigsaw can be thought of as an abstraction, to be reified by application to a computational sublanguage, L c . <p> Similar utilities that save and retrieve compiled modules are also required. 4.5 Adding Modules to Existing Languages Many languages do not have adequate modularity constructs. These include widely used programming languages (e.g., C [36], Pascal [32]), as well as countless special-purpose and "little-languages" <ref> [5, Column 9] </ref>, where the effort of designing specific mechanisms for modularity is difficult to justify, but which could still benefit from such mechanisms. 63 The simple notions of module and interface defined above are largely language independent.
Reference: [6] <author> Borning, A. H. </author> <title> Classes versus prototypes in object-oriented languages. </title> <booktitle> In ACM/IEEE Fall Joint Computer Conference (1986). </booktitle>
Reference-contexts: The main exception is CommonObjects [63, 65], which is discussed in Chapter 8 in the context of related work. 3.1.2 SELF SELF, like CLOS, is dynamically typed. Unlike CLOS, it is not based upon a linear form of inheritance, but rather upon delegation <ref> [2, 6, 41, 66] </ref>. Delegation is a form of inheritance that occurs between objects (often referred to as prototypes) at execution time, rather than between classes at the time of compilation. Like CLOS, SELF has a built-in mechanism for accessing overridden methods (known as resend).
Reference: [7] <author> Bracha, G., and Cook, W. </author> <title> Mixin-based inheritance. </title> <booktitle> In Proc. of the Joint ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications and the European Conference on Object-Oriented Programming (Oct. </booktitle> <year> 1990). </year>
Reference-contexts: The C++ Annotated Reference Manual. As mentioned in Chapter 2, mixins can be used as the basis of a powerful form of inheritance, mixin-based inheritance <ref> [7] </ref>. Now is the time to investigate mixins more thoroughly. This chapter examines different ways in which mixins can be incorporated as full-fledged constructs in programming languages, and demonstrates the usefulness of such an endeavor. A more theoretical treatment of mixins is left for section 5.2. <p> This can be interpreted as stating that W is a class whose instances have type Window (or some subtype of Window). The most common situation is 2 In fact, that is one of several semantic views of mixins, and not exactly the one originally developed in <ref> [7] </ref>. See section 5.2 for more details. <p> A mixin is complete if it does not refer to its parent parameter, and defines all fields that it refers to in itself. Otherwise, it is partial. Only complete mixins may be instantiated meaningfully. This can easily be enforced by the type system. This approach was first presented in <ref> [7] </ref>. The advantages of uniformity are: * It makes the language simpler. * As shown above, this simplifies the expression of useful classes. 47 * It allows inheritance to viewed as an operator over a uniform space of values (mixins). This represents a radical shift in thinking about inheritance. <p> These include single inheritance languages such as Beta, Smalltalk or Modula-3 <ref> [7] </ref>. It also includes languages such as CLOS, which use linear multiple inheritance. CLOS is a particularly attractive candidate for experimentation, because it incorporates a meta-object protocol (MOP)[37] that was specifically designed to allow for easy language modification. <p> M 3 ) = s:j:M 1 (s)(j) r [M 2 (s)(j r M 1 (s)(j)) r Assuming that r is associative, then (M 1 w M 2 ) w M 3 = s:j:M 1 (s)(j) r M 2 (s)(j r M 1 (s)(j)) r This operator was first defined in <ref> [7] </ref>. 2 That account deliberately omitted the discussion of self-reference, in order to simplify the presentation. 5.2.2 Mixin Composition as Function Composition Here is another formulation of mixins, which seems more intuitive. A mixin is modeled as an abstract subclass. <p> Section 6.2 presents a review of the salient features of Modula-3, for those unfamiliar with the language. Section 6.3 then discusses the extension, Modula-. 1 An early, less ambitious version of this work appeared in <ref> [7] </ref>. 101 6.1 Choice of Language Modula-3 [11] was chosen as a basis for an extension incorporating Jigsaw style inheritance operators. The particular form of inheritance developed below will be referred to as operator-based inheritance. Modula-3 is well suited for such an extension, because 1. It supports single inheritance. <p> Tree inheritance is therefore not a purely linear approach, but rather, as its name implies, a tree structured one. Classes in CommonObjects could be viewed as mixins with multiple arguments. 129 8.1.3 Mixins This work grew out of an earlier study of mixin-based inheritance <ref> [7] </ref>. Some of the limitations of mixin based inheritance have been addressed here. These include the absence of fine-grain sharing, of renaming facilities and of a symmetric merge operation. Until now, mixins have been modeled as parametric abstractions called wrappers. <p> Until now, mixins have been modeled as parametric abstractions called wrappers. Cook used an operator combining a generator and a wrapper in his compositional semantics of inheritance [18]. This operator was also used by Hense [28]. In <ref> [7] </ref>, the override operation was defined as a binary operation on wrappers, enabling composition of mixins. Here, an alternate formulation of wrappers as functions from generators to generators has been given. The main purpose of wrappers was to allow access to overridden definitions.
Reference: [8] <author> Canning, P., Cook, W., Hill, W., Mitchell, J., and Olthoff, W. </author> <title> F-bounded polymorphism for object-oriented programming. </title> <booktitle> In Proc. of Conf. on Functional Programming Languages and Computer Architecture (1989), </booktitle> <pages> pp. 273-280. </pages>
Reference-contexts: Multiple implementations of an interface are also possible. Inheritance is, however, restricted to create subtypes only. This limits the ways in which modules can be manipulated. The literature contains many examples of cases in which such restrictions are too harsh <ref> [8, 9, 19] </ref>. Current languages which unify types and classes, either restrict expressiveness in this way (e.g, C++), or have unsound type systems (e.g., Eiffel). <p> There are other reasons for separating classes and types. These have less to do with modularity. The interested reader is referred to <ref> [8, 9, 19, 48] </ref>. It is worth noting that there are arguments for merging the concepts of type and class. Programming languages have a long tradition of using type information for implementation purposes.
Reference: [9] <author> Canning, P., Cook, W., Hill, W., and Olthoff, W. </author> <title> Interfaces for strongly-typed object-oriented programming. </title> <booktitle> In Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (1989), </booktitle> <pages> pp. 457-467. </pages>
Reference-contexts: Multiple implementations of an interface are also possible. Inheritance is, however, restricted to create subtypes only. This limits the ways in which modules can be manipulated. The literature contains many examples of cases in which such restrictions are too harsh <ref> [8, 9, 19] </ref>. Current languages which unify types and classes, either restrict expressiveness in this way (e.g, C++), or have unsound type systems (e.g., Eiffel). <p> There are other reasons for separating classes and types. These have less to do with modularity. The interested reader is referred to <ref> [8, 9, 19, 48] </ref>. It is worth noting that there are arguments for merging the concepts of type and class. Programming languages have a long tradition of using type information for implementation purposes.
Reference: [10] <author> Cardelli, L. </author> <title> A semantics of multiple inheritance. </title> <booktitle> In Semantics of Data Types (1984), vol. 173 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 51-68. 139 </pages>
Reference-contexts: If inheritance is divorced from subtyping, a language can support single inheritance simultaneously with overlapping (graph structured) classification. The fact that subtyping does indeed induce a lattice structure was demonstrated in the classic paper by Cardelli <ref> [10] </ref>. 2 There are, however, valid arguments against the restriction to single inheritance. Viewed as a modularity mechanism, single inheritance seems very constraining. It allows modification to a module, but does not allow for combination of modules. <p> Jean-Yves Girard This chapter presents the theoretical basis of the dissertation. The work presented here is an application of denotational models of inheritance, as pioneered by Reddy [59] and especially by Cook [18]. It also builds on the extensive body of work on typing object-oriented languages, starting with <ref> [10] </ref>. Readers unfamiliar with the details of the aforementioned work need not worry; the background section provides all the requisite information for understanding this chapter. Those readers whose primary interest is pragmatic can skip this chapter altogether, without loss of continuity. <p> Using this representation for records, all operators used here are also easily expressed. Records are not self-referential. Other mechanisms such as generators are needed to induce self-reference. See <ref> [10] </ref> for more details. Each record operator has a corresponding operator for generators (see section 5.3).
Reference: [11] <author> Cardelli, L., Donahue, J., Glassman, L., Jordan, M., Kalsow, B., and Nelson, G. </author> <type> Modula-3 report (revised). Tech. Rep. 52, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: Section 6.2 presents a review of the salient features of Modula-3, for those unfamiliar with the language. Section 6.3 then discusses the extension, Modula-. 1 An early, less ambitious version of this work appeared in [7]. 101 6.1 Choice of Language Modula-3 <ref> [11] </ref> was chosen as a basis for an extension incorporating Jigsaw style inheritance operators. The particular form of inheritance developed below will be referred to as operator-based inheritance. Modula-3 is well suited for such an extension, because 1. It supports single inheritance.
Reference: [12] <author> Cardelli, L., Donahue, J., Jordan, M., Kalsow, B., and Nelson, G. </author> <title> The Modula-3 type system. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages (Jan. 1989), Association for Computing Machinery, </booktitle> <pages> pp. 202-212. </pages>
Reference-contexts: This typecode is also needed to support the typecode expression of Modula-3. For single inheritance, a dynamic typecheck may be implemented in constant time and linear space <ref> [12] </ref>. Under the new subtyping rules, this is no longer possible. It is possible to determine whether one type is a subtype of another in linear time and space, for instance by maintaining a list of each object type's supertypes, and testing recursively against this list. <p> However, there are technical difficulties related to the typing of existential data types. A related issue is the use of structural subtyping, in contrast to "name-based" subtyping in [53]. Both forms are useful; here, the focus is on structural subtyping, which is more appropriate between different modules or programs <ref> [12] </ref>. Finally, unlike [53], precise semantic definitions of all operations have been given. 8.2 Future Work 8.2.1 Name-based Typing Jigsaw, as presently formulated, does not support name based typing. However, this does not seem to present a serious difficulty.
Reference: [13] <author> Cardelli, L., and Mitchell, J. C. </author> <title> Operations on records. </title> <type> Tech. Rep. 48, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: The difficulty is that while useful mixins are polymorphic, it appears that without exact type information, one cannot guarantee the type safety of inheritance. Various typing schemes have been developed in an attempt to address this problem <ref> [13, 27] </ref>. 3 None seems to present a solution that is simple and understandable enough to be useable by programmers, efficiently implementable, and covers the important cases. The problem is an exceedingly difficult one, and remains the subject of intense research. Related typing problems will arise repeatedly in this dissertation. <p> Similar operations have been used in the study of typed record calculi <ref> [13, 27, 71, 60] </ref>. However, this dissertation is not concerned with the typing problems raised by these operators. Here, record operations are only used in the definitions of module operators.
Reference: [14] <author> Cardelli, L., and Wegner, P. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys 17, </journal> <volume> 4 (1985), </volume> <pages> 471-522. </pages>
Reference-contexts: This makes the benefits of extensibility and modifiability associated with object-oriented programming available at the language design level. These points are demonstrated via the module manipulation language Jigsaw. For concreteness, assume that Jigsaw manipulates modules written in an applicative language with a type system based upon bounded universal quantification <ref> [14] </ref>. However, the discussion remains virtually unchanged if modules are written in another language. For instance, although a subtype relation is assumed, its particulars are not relied upon. Hence the approach applies to languages without subtyping as well. These have type equivalence as a degenerate subtyping relation.
Reference: [15] <author> Cargill, T. </author> <title> Controversy: The case against multiple inheritance in C++. </title> <booktitle> In Usenix Winter Conference (Jan. </booktitle> <year> 1991). </year>
Reference-contexts: This section illustrates restrictions on the way a module can be constructed. Object-oriented languages originally supported single inheritance. The question whether single inheritance is sufficient is still the topic of some controversy <ref> [15] </ref>. Proponents of single inheritance argue that multiple inheritance is complex and poorly understood, that it is frequently abused, and that cases in which it is used could be better handled by single inheritance. Conversely, supporters of multiple inheritance argue that it is both natural and required.
Reference: [16] <author> Chambers, C., and Ungar, D. </author> <title> Making pure object-oriented languages practical. </title> <booktitle> In Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (Oct. </booktitle> <year> 1991), </year> <pages> pp. 1-15. </pages>
Reference-contexts: These restrictions, coupled with the fact that Jigsaw modules never have any free variables, lead to an implementation based upon a straightforward extension of standard dispatch table techniques. This dissertation presents no new techniques for implementing interface-based type systems such as Jigsaw's. It has been noted in the literature <ref> [16, 31] </ref> that interface-based type systems contribute little to efficient implementation, in contrast to more traditional type systems. Operator-based inheritance was derived from Jigsaw by modifying the notion of interface to reveal enough about the structure of modules for an efficient implementation.
Reference: [17] <author> Connor, R., Dearle, A., Morrison, R., and Brown, A. </author> <title> An object addressing mechanism for statically typed languages with multiple inheritance. </title> <booktitle> In Proc. of the Joint ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications and the European Conference on Object-Oriented Programming (Oct. </booktitle> <year> 1989), </year> <pages> pp. 279-285. </pages>
Reference-contexts: Even the best such schemes are not competitive with the approaches discussed in this chapter. Recently, alternative schemes have been proposed <ref> [17] </ref>. While still not as efficient as the scheme proposed below, the gap is smaller than with cache based lookup techniques. 7.1 Implementation of Modula This section describes the proposed implementation technique for operator-based inheritance in Modula-.
Reference: [18] <author> Cook, W. </author> <title> A Denotational Semantics of Inheritance. </title> <type> PhD thesis, </type> <institution> Brown University, </institution> <year> 1989. </year>
Reference-contexts: The interaction between Jigsaw and the language of computation is potentially bidirectional. This structure is exactly analogous to that typical of abstract classes and frameworks in object-oriented languages. 1.4 Semantics Jigsaw has a rigorous semantics, based upon a denotational model of inheritance <ref> [18, 59] </ref>. Indeed, Jigsaw would not have been conceived without the insights derived from the study of the denotational semantics of object-oriented languages. The Jigsaw framework maps very directly to the underlying semantics. Modules have simple denotations, which are just functions from records to records. <p> Jean-Yves Girard This chapter presents the theoretical basis of the dissertation. The work presented here is an application of denotational models of inheritance, as pioneered by Reddy [59] and especially by Cook <ref> [18] </ref>. It also builds on the extensive body of work on typing object-oriented languages, starting with [10]. Readers unfamiliar with the details of the aforementioned work need not worry; the background section provides all the requisite information for understanding this chapter. <p> Objects are thus inherently self-referential. The standard technique for modeling self-reference is fixpoint theory [50]. Using fixpoint theory, an object may be modeled using a record-generating function (called a generator following Cook <ref> [18] </ref>). Figure 5.1 shows a simple object and its associated generator function. This function takes a record as a parameter, and returns a record as a result. The result record is similar to the object being modeled. <p> The desired object is the least fixed point of the generator function Y (P gen). An abstract class may be modeled as an inconsistent generator. An inconsistent generator has the form s : :e, where e : 0 and is a subtype of 0 <ref> [18] </ref>. This captures the fact that self-reference within the class () assumes more methods than the class provides ( 0 ). One cannot take the fixpoint of such a generator, since its domain is a proper subtype of its range. <p> The use of the word project is by analogy with relational algebra. The result of this operation 1 For a record operator r , g is usually what is referred to in <ref> [18] </ref> as the distributed version of . 75 consists exclusively of the fields named in A. The names in A must be defined in r. * Select, : r . r: r a returns the value of the attribute named a in r. <p> record 2 j record [label 1 label 2 ] label list ::= label j label label list def list ::= nonempty def list j empty nonempty def list ::= def j def; nonempty def list def ::= label = expr 5.1.3 Inheritance This subsection discusses the denotational semantics of inheritance <ref> [34, 59, 18] </ref>. Inheritance provides a way of modifying self-referential structures [18]. When a value is modified via inheritance, all self-reference within the result refers to the modified value. Inheritance involves manipulating the self-reference within objects. Technically, this is achieved by manipulating generators, before taking their fixpoint 76 [59], [18]. <p> Inheritance provides a way of modifying self-referential structures <ref> [18] </ref>. When a value is modified via inheritance, all self-reference within the result refers to the modified value. Inheritance involves manipulating the self-reference within objects. Technically, this is achieved by manipulating generators, before taking their fixpoint 76 [59], [18]. Figure 5.2 illustrates this process. <p> Inheritance provides a way of modifying self-referential structures <ref> [18] </ref>. When a value is modified via inheritance, all self-reference within the result refers to the modified value. Inheritance involves manipulating the self-reference within objects. Technically, this is achieved by manipulating generators, before taking their fixpoint 76 [59], [18]. Figure 5.2 illustrates this process. The object MP inherits from P, but specializes the dist method. MP is modeled by a generator that invokes the generator for P. <p> The following section shows that the semantic notion of wrapper corresponds to the linguistic notion of mixin. 5.2 Modeling Mixins This section shows how to model a language with mixins, as discussed in Chapter 3. Two approaches are presented. Subsection 5.2.1 discusses a direct generalization of <ref> [18] </ref>. Subsection 5.2.2 gives an alternative approach in which mixin composition is viewed as a special kind of function composition. 5.2.1 A Mixin Composition Operator Mixins can be modeled as special functions called wrappers. <p> The module operators defined in section 5.3 are no longer sufficient. However, entirely analogous definitions that are cognizant of imperative constructs, can be substituted for the applicative module operator definitions. In [29], Andreas Hense showed how the applicative semantics of inheritance given by Cook <ref> [18] </ref> could be extended to model imperative object oriented languages. The key problem is how to formulate the domains. In particular, the domains of generators must somehow model the fact that instantiation effects the store. <p> These include the absence of fine-grain sharing, of renaming facilities and of a symmetric merge operation. Until now, mixins have been modeled as parametric abstractions called wrappers. Cook used an operator combining a generator and a wrapper in his compositional semantics of inheritance <ref> [18] </ref>. This operator was also used by Hense [28]. In [7], the override operation was defined as a binary operation on wrappers, enabling composition of mixins. Here, an alternate formulation of wrappers as functions from generators to generators has been given. <p> This allows the use of generators instead of wrappers, simplifying definitions. This reflects the strategy of simplifying the structure and pushing more functionality into the operator set. 8.1.4 Generator Operations Many of the operators presented here were first proposed by Cook in <ref> [18] </ref>. There, a general mechanism for deriving generator operations from record operations was described. However, the operators defined by Cook were used to illustrate the principle of manipulating self-reference by means of generators. In modeling programming language constructs, more elaborate operators were used.
Reference: [19] <author> Cook, W., Hill, W., and Canning, P. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages (1990), </booktitle> <pages> pp. 125-135. </pages>
Reference-contexts: Multiple implementations of an interface are also possible. Inheritance is, however, restricted to create subtypes only. This limits the ways in which modules can be manipulated. The literature contains many examples of cases in which such restrictions are too harsh <ref> [8, 9, 19] </ref>. Current languages which unify types and classes, either restrict expressiveness in this way (e.g, C++), or have unsound type systems (e.g., Eiffel). <p> There are other reasons for separating classes and types. These have less to do with modularity. The interested reader is referred to <ref> [8, 9, 19, 48] </ref>. It is worth noting that there are arguments for merging the concepts of type and class. Programming languages have a long tradition of using type information for implementation purposes. <p> A richer notion of module subtyping would allow Jigsaw to support these highly expressive constructs. Use of dynamic typing, as in Beta is one option, but a costly one. In <ref> [19] </ref> static type systems that address some of these problems are discusses. 8.2.6 Process Calculi Object orientation presents a natural model of concurrency, and concurrent object-oriented programming has been the focus of considerable attention [75].
Reference: [20] <author> Cox, B. J., and Novobilski, A. </author> <title> Object-oriented Programming: An Evolutionary Approach, 2nd ed. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: Each such additional module now has the same problems of multiple versions and recompilation. Furthermore, if source code is not available for both conflicting modules, renaming by editing is not possible. If large scale reuse <ref> [20] </ref> becomes a reality, object modules provided by different vendors have to be combined, and name conflicts will become harder to avoid. In practice, verbose naming conventions are used to minimize name conflicts, and the scale of reuse is presently small enough for the problem to be kept under control. <p> Nested modules in principle also support the notion of class variables found in languages like Smalltalk. Class variables are variables shared by all instances of a class. A module that nests another module inside it, can serve as a "factory" <ref> [20] </ref> and produce initialized instances of the nested module. The surrounding module serves as a repository of shared data among all instances of the nested module. 136 Again, module subtyping restricts the usefulness of such designs.
Reference: [21] <author> Dahl, O., and Nygaard, K. </author> <title> Simula: An Algol-based simulation language. </title> <booktitle> Communications of the ACM 9 (1966), </booktitle> <pages> 671-678. </pages>
Reference-contexts: Here, only highlights are given, with the objective of reviewing fundamental concepts, and establishing that a problem does in fact exist. 1.1.1 Inheritance The first and foremost concept in this dissertation is inheritance itself. Inheritance is a powerful linguistic mechanism, introduced by object-oriented languages <ref> [21, 24] </ref>. Inheritance allows an incremental style of programming. Given an existing piece of software, the programmer can create a new one, simply by specifying how the new piece differs from a preexisting one. The term "piece of software" is rather imprecise.
Reference: [22] <author> Ducournau, R., and Habib, M. </author> <title> On some algorithms for multiple inheritance in object-oriented programming. </title> <booktitle> In European Conference on Object-Oriented Programming (1987), </booktitle> <pages> pp. 243-252. </pages>
Reference-contexts: In CLOS, mixins are available as a result of two factors: dynamic typing and the notion of linearization. In CLOS, all classes that contribute to an object's behavior are ordered linearly in a class precedence list. The ordering is determined by a linearization algorithm. Various algorithms may be used <ref> [22] </ref>, but they all produce a linear ordering that preserves the partial ordering inherent in the original graph. Each contributing class occurs only once in the resulting precedence list. Linearization serves to disambiguate name clashes in multiple inheritance, but has serious negative consequences.
Reference: [23] <author> Ellis, M. A., and Stroustrup, B. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1990. </year> <month> 140 </month>
Reference-contexts: In some languages, abstract classes have no special linguistic support. Programmers define "dummy" routines that typically produce an error if executed. More recent languages <ref> [23, 51] </ref> explicitly recognize abstract classes. In these languages, methods that are undefined in the abstract class are identified by special syntax. Here such methods are referred to as pure virtuals, using the terminology of C++. Abstract classes are essential to the definition of frameworks [33]. <p> The representations of corresponding instances are also manipulated in a similar manner. The exact scheme used is presented in Chapter 7. It is an extension of existing techniques for implementation of object oriented languages <ref> [23] </ref>. The performance of this scheme is on a par with the methods employed by the highest performance object-oriented language processors currently available. <p> Such abstractions are the topic of the next subsection. 3.2.1 Mixins and Type Abstraction Many programming languages support abstractions over "second-class" entities, such as types, classes or modules <ref> [43, 1, 62, 51, 55, 23, 26] </ref>. These constructs are often referred to as generics. In some languages, generics are merely macros, separately expanded and recompiled for every application of the abstraction. This is the case in Ada, Modula-3 and C++. Such constructs are easily incorporated into almost any language. <p> This chapter argues that inheritance, properly formulated, is a powerful modularity mechanism that can constitute the basis of a module manipulation language. The formulation of inheritance presented herein is derived by observing that in languages supporting multiple inheritance (e.g., <ref> [23, 51, 62] </ref>), classes are burdened with too many roles. The class construct is "large" and monolithic. Here classes are simplified, and their functionality is partitioned among separate operators. Classes are reduced to a simple notion of module amutually recursive scope. <p> This technique has been used to implement multiple inheritance in C++ <ref> [23] </ref>, and was pioneered by Krogdahl [40]. Other approaches are possible, but I focus on this one, since it forms the basis for my implementation of operator-based inheritance. <p> The address of aT is added to the offset stored in the same entry in the mtbl, and passed as the first parameter to the procedure. This is the same procedure used in <ref> [23] </ref>.
Reference: [24] <author> Goldberg, A., and Robson, D. </author> <title> Smalltalk-80: the Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Here, only highlights are given, with the objective of reviewing fundamental concepts, and establishing that a problem does in fact exist. 1.1.1 Inheritance The first and foremost concept in this dissertation is inheritance itself. Inheritance is a powerful linguistic mechanism, introduced by object-oriented languages <ref> [21, 24] </ref>. Inheritance allows an incremental style of programming. Given an existing piece of software, the programmer can create a new one, simply by specifying how the new piece differs from a preexisting one. The term "piece of software" is rather imprecise.
Reference: [25] <author> Guimaraes, N. </author> <title> Building generic user interface tools: an experience with multiple inheritance. </title> <booktitle> In Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (Oct. </booktitle> <year> 1991), </year> <pages> pp. 89-96. </pages>
Reference-contexts: In Owl, heirs have access to a subtype visible interface. Similar ideas appear under the names of "internal" and "external" interfaces, in [53]. While these constructs do not strictly violate modularity, they seem overly complex, and introduce a subtle anomaly, pointed out in <ref> [25] </ref>. Once certain features of a class have been placed in the protected interface, those features can be accessed only via inheritance. A nested instance of the class does not provide access to that feature, since it is not in the public interface. This constrains the designers of client software.
Reference: [26] <author> Harper, R., MacQueen, D., and Milner, R. </author> <title> Standard ML. </title> <type> Internal Report ECS-LFCS-86-2, </type> <institution> Edinburgh University, </institution> <month> Mar. </month> <year> 1986. </year>
Reference-contexts: Such abstractions are the topic of the next subsection. 3.2.1 Mixins and Type Abstraction Many programming languages support abstractions over "second-class" entities, such as types, classes or modules <ref> [43, 1, 62, 51, 55, 23, 26] </ref>. These constructs are often referred to as generics. In some languages, generics are merely macros, separately expanded and recompiled for every application of the abstraction. This is the case in Ada, Modula-3 and C++. Such constructs are easily incorporated into almost any language.
Reference: [27] <author> Harper, R., and Pierce, B. </author> <title> A record calculus based on symmetric concatenation. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages (Jan. </booktitle> <year> 1991), </year> <pages> pp. 131-142. </pages>
Reference-contexts: The difficulty is that while useful mixins are polymorphic, it appears that without exact type information, one cannot guarantee the type safety of inheritance. Various typing schemes have been developed in an attempt to address this problem <ref> [13, 27] </ref>. 3 None seems to present a solution that is simple and understandable enough to be useable by programmers, efficiently implementable, and covers the important cases. The problem is an exceedingly difficult one, and remains the subject of intense research. Related typing problems will arise repeatedly in this dissertation. <p> Similar operations have been used in the study of typed record calculi <ref> [13, 27, 71, 60] </ref>. However, this dissertation is not concerned with the typing problems raised by these operators. Here, record operations are only used in the definitions of module operators.
Reference: [28] <author> Hense, A. V. </author> <title> Denotational semantics of an object oriented programming language with explicit wrappers. </title> <type> Tech. Rep. </type> <institution> A 11/90, Fachbereich Informatik, Universitaet des Saarlandes, </institution> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: No implicit linearization is performed. The linear order is determined explicitly by the programmer. If the other precepts of [65] are followed, this form of inheritance does not violate encapsulation. The formulation described up until now provides essentially the same level of functionality provided in <ref> [28] </ref>. Further refinements are developed below. The next logical step is to define combinations of classes as mixins, so that when the new combination is used, the same flexibility is available. Instead of writing C [B [A [Base]]], define mixin CBA [X] C [B [A [X]]] end. <p> Until now, mixins have been modeled as parametric abstractions called wrappers. Cook used an operator combining a generator and a wrapper in his compositional semantics of inheritance [18]. This operator was also used by Hense <ref> [28] </ref>. In [7], the override operation was defined as a binary operation on wrappers, enabling composition of mixins. Here, an alternate formulation of wrappers as functions from generators to generators has been given. The main purpose of wrappers was to allow access to overridden definitions.
Reference: [29] <author> Hense, A. V. </author> <title> Wrapper semantics of an object oriented programming language with state. </title> <type> Tech. Rep. </type> <institution> A 14/90, Fachbereich Informatik, Universitaet des Saarlandes, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: One cannot just "plug in" an imperative language as L c . The module operators defined in section 5.3 are no longer sufficient. However, entirely analogous definitions that are cognizant of imperative constructs, can be substituted for the applicative module operator definitions. In <ref> [29] </ref>, Andreas Hense showed how the applicative semantics of inheritance given by Cook [18] could be extended to model imperative object oriented languages. The key problem is how to formulate the domains. In particular, the domains of generators must somehow model the fact that instantiation effects the store. <p> The key problem is how to formulate the domains. In particular, the domains of generators must somehow model the fact that instantiation effects the store. The semantics given below use the solution proposed in <ref> [29] </ref>, applied to the operator based formulation of Jigsaw. 97 The basic intuition behind these semantics is that when the fixpoint of a gen erator is taken, the result is a constructor function that may be invoked upon a particular store, to create an instance.
Reference: [30] <author> Hense, A. V. </author> <title> Explicit wrappers and multiple inheritance, </title> <month> Feb. </month> <year> 1991. </year> <type> Unpublished manuscript, </type> <institution> Fachbereich Informatik, Universitaet des Saarlandes. </institution>
Reference-contexts: This policy, suggested in <ref> [30] </ref>, does not violate encapsulation, since information about the inheritance graph is not exposed through the type system. Multiple implementations of an interface are also possible. Inheritance is, however, restricted to create subtypes only. This limits the ways in which modules can be manipulated.
Reference: [31] <author> Holzle, U. </author> <title> Why static typing is not important for efficiency, or why you shouldn't be afraid to separate interface from implementation. Position paper in ECOOP'91 workshop on Types, Inheritance and Assignments, </title> <editor> J. Palsberg and M. Schwartzbach, </editor> <publisher> editors. </publisher>
Reference-contexts: These restrictions, coupled with the fact that Jigsaw modules never have any free variables, lead to an implementation based upon a straightforward extension of standard dispatch table techniques. This dissertation presents no new techniques for implementing interface-based type systems such as Jigsaw's. It has been noted in the literature <ref> [16, 31] </ref> that interface-based type systems contribute little to efficient implementation, in contrast to more traditional type systems. Operator-based inheritance was derived from Jigsaw by modifying the notion of interface to reveal enough about the structure of modules for an efficient implementation.
Reference: [32] <author> Jensen, K., and Wirth, N. </author> <title> Pascal User Manual and Report, second ed. </title> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: This file can then be retrieved in a later interpreter session. Similar utilities that save and retrieve compiled modules are also required. 4.5 Adding Modules to Existing Languages Many languages do not have adequate modularity constructs. These include widely used programming languages (e.g., C [36], Pascal <ref> [32] </ref>), as well as countless special-purpose and "little-languages" [5, Column 9], where the effort of designing specific mechanisms for modularity is difficult to justify, but which could still benefit from such mechanisms. 63 The simple notions of module and interface defined above are largely language independent.
Reference: [33] <author> Johnson, R. E., and Russo, V. F. </author> <title> Reusing object-oriented designs. </title> <type> Tech. Rep. </type> <institution> UIUCDCS 91-1696, University of Illinois at Urbana-Champagne, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: More recent languages [23, 51] explicitly recognize abstract classes. In these languages, methods that are undefined in the abstract class are identified by special syntax. Here such methods are referred to as pure virtuals, using the terminology of C++. Abstract classes are essential to the definition of frameworks <ref> [33] </ref>. A framework is a collection of classes designed to support a particular application in a modifiable and extensible manner. A framework is used as a basis for an application. Typically, some of the framework's abstract classes are modified and extended by inheritance to tailor them to specific needs.
Reference: [34] <author> Kamin, S. </author> <title> Inheritance in Smalltalk-80: A denotational definition. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages. Association for Computing Machinery, </booktitle> <year> 1988, </year> <pages> pp. 80-87. </pages>
Reference-contexts: record 2 j record [label 1 label 2 ] label list ::= label j label label list def list ::= nonempty def list j empty nonempty def list ::= def j def; nonempty def list def ::= label = expr 5.1.3 Inheritance This subsection discusses the denotational semantics of inheritance <ref> [34, 59, 18] </ref>. Inheritance provides a way of modifying self-referential structures [18]. When a value is modified via inheritance, all self-reference within the result refers to the modified value. Inheritance involves manipulating the self-reference within objects. Technically, this is achieved by manipulating generators, before taking their fixpoint 76 [59], [18].
Reference: [35] <author> Keene, S. E. </author> <title> Object-Oriented Programming in Common Lisp. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: This solution relieves the programmer from the tedious task of resolving many of the conflicts that arise in practice. This is the policy followed by Eiffel [51], Owl 25 @ @ @ @I &% &% &% @ @ @ @I &% Ellipse FillEllipse Circle FillCircle [62], CLOS <ref> [35] </ref> and SELF [68, 69]. The reader may wish to ponder the obvious common sense of this approach before continuing. The only modular solution is to treat the name collisions as errors, just as if the conflicting names had been defined in different classes.
Reference: [36] <author> Kernighan, B. W., and Ritchie, D. M. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1978. </year>
Reference-contexts: This file can then be retrieved in a later interpreter session. Similar utilities that save and retrieve compiled modules are also required. 4.5 Adding Modules to Existing Languages Many languages do not have adequate modularity constructs. These include widely used programming languages (e.g., C <ref> [36] </ref>, Pascal [32]), as well as countless special-purpose and "little-languages" [5, Column 9], where the effort of designing specific mechanisms for modularity is difficult to justify, but which could still benefit from such mechanisms. 63 The simple notions of module and interface defined above are largely language independent.
Reference: [37] <author> Kiczales, G., des Rivieres, J., and Bobrow, D. G. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year> <month> 141 </month>
Reference: [38] <author> Kristensen, B. B., Madsen, O. L., Moller-Pedersen, B., and Ny-gaard, K. </author> <title> The Beta Programming Language. </title> <booktitle> In Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987, </year> <pages> pp. 7-48. </pages>
Reference-contexts: Some languages support this using the notion of nonvirtual attributes (static binding). However, this does not allow for changing the status of a virtual attribute to nonvirtual (e.g., as in Beta <ref> [38] </ref>). In addition, it complicates the model, since not all methods are defined in the same way there are two kinds, declared differently. In the Jigsaw model, it is preferable to have only virtual attributes declared, and perform the change by means of an operator on modules.
Reference: [39] <author> Kristensen, B. B., Madsen, O. L., Moller-Pederson, B., and Ny-gaard, K. </author> <title> The Beta programming language a Scandinavian approach to object-oriented programming, </title> <booktitle> Oct. 1989. OOPSLA Tutorial Notes. </booktitle>
Reference-contexts: When a subpattern of Person is defined, the inner statement will execute the corresponding display method in the subpattern. 1 This syntax is used by the implementors of Beta for tutorial purposes <ref> [39] </ref>. Person: class (# name : string; display: virtual proc (# do name.display; inner #); #); Graduate: class Person (# degree: string; display: extended proc (# do degree.display; inner #); #); 37 The subpattern Graduate extends the behavior of the Person display method by supplying inner behavior.
Reference: [40] <author> Krogdahl, S. </author> <title> Multiple inheritance in Simula-like languages. </title> <booktitle> BIT 25 (1985), </booktitle> <pages> 318-326. </pages>
Reference-contexts: This technique has been used to implement multiple inheritance in C++ [23], and was pioneered by Krogdahl <ref> [40] </ref>. Other approaches are possible, but I focus on this one, since it forms the basis for my implementation of operator-based inheritance. Instances of a class that does not inherit from any other class (a base class), can be represented by a record of their instance variables.
Reference: [41] <author> Lieberman, H. </author> <title> Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems. </title> <booktitle> In Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (1986), </booktitle> <pages> pp. 214-223. </pages>
Reference-contexts: The main exception is CommonObjects [63, 65], which is discussed in Chapter 8 in the context of related work. 3.1.2 SELF SELF, like CLOS, is dynamically typed. Unlike CLOS, it is not based upon a linear form of inheritance, but rather upon delegation <ref> [2, 6, 41, 66] </ref>. Delegation is a form of inheritance that occurs between objects (often referred to as prototypes) at execution time, rather than between classes at the time of compilation. Like CLOS, SELF has a built-in mechanism for accessing overridden methods (known as resend).
Reference: [42] <author> Linton, M. A., Calder, P. R., and M.Vlissides, J. InterViews: </author> <title> A C++ graphical interface toolkit. </title> <type> Tech. Rep. </type> <institution> CSL-TR-88-358, Stanford University, </institution> <month> July </month> <year> 1988. </year>
Reference-contexts: A framework is used as a basis for an application. Typically, some of the framework's abstract classes are modified and extended by inheritance to tailor them to specific needs. Examples of frameworks are <ref> [42, 45, 70, 73] </ref>. Abstract classes support a powerful form of parameterization, unique to the object-oriented paradigm.
Reference: [43] <author> Liskov, B., and Guttag, J. </author> <title> Abstraction and Specification in Program Design. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: No static typechecking is performed across module boundaries. There is also poor support for encapsulation; typically, all globals in a module are available to other modules. Later languages such as CLU <ref> [43] </ref>, Ada [1], Modula-2 [74], Modula-3 and others provide a structured way of specifying modules and their interconnection. Formal notions of module and interface are part of the language. The language semantics guarantee that modules are used in accordance with their interface. <p> Such abstractions are the topic of the next subsection. 3.2.1 Mixins and Type Abstraction Many programming languages support abstractions over "second-class" entities, such as types, classes or modules <ref> [43, 1, 62, 51, 55, 23, 26] </ref>. These constructs are often referred to as generics. In some languages, generics are merely macros, separately expanded and recompiled for every application of the abstraction. This is the case in Ada, Modula-3 and C++. Such constructs are easily incorporated into almost any language.
Reference: [44] <author> MacQueen, D. </author> <title> Modules for Standard ML. </title> <booktitle> In Proc. of the ACM Conf. on Lisp and Functional Programming (Aug. </booktitle> <year> 1984), </year> <pages> pp. 198-207. </pages>
Reference-contexts: However, there are usually only very limited facilities for manipulating modules. Mechanisms are provided for module interconnection, but these are usually ad hoc. An important exception is ML [52], which provides a well developed module manipulation language <ref> [44] </ref>. Integration of inheritance into ML in a modular fashion is the subject of ongoing research [53]. This thesis argues that inheritance is really an essential module manipulation mechanism. In languages without inheritance, its effects are obtained by extra-linguistic means (e.g., text editing). <p> A module is a self-referential scope, binding names to values. A binding of name to a value is a definition. Unlike ML <ref> [44] </ref>, modules do not bind names to types. Type abbreviations may be used, as syntactic sugar. 1 Typing in Jigsaw is purely structural. Modules may include not only definitions, but declarations. A declaration gives the type of an attribute, but no value for it. <p> Mitchell also chose to incorporate inheritance into a module language, an extension of the ML module system <ref> [44] </ref>. Some similar operations are supported, embedded in a more conventional syntax. Underlying both systems are denotational models involving the manipulation of self-reference, and typing based on bounded quantification. There are many differences, however.
Reference: [45] <author> Madany, P. W., Campbell, R. H., Russo, V. F., and Leyens, D. E. </author> <title> A class hierarchy for building stream-oriented file systems. </title> <booktitle> In European Conference on Object-Oriented Programming (July 1989), </booktitle> <editor> S. Cook, Ed., </editor> <booktitle> British Computer Society Workshop Series, </booktitle> <publisher> Cambridge University Press, </publisher> <pages> pp. 311-328. </pages>
Reference-contexts: A framework is used as a basis for an application. Typically, some of the framework's abstract classes are modified and extended by inheritance to tailor them to specific needs. Examples of frameworks are <ref> [42, 45, 70, 73] </ref>. Abstract classes support a powerful form of parameterization, unique to the object-oriented paradigm.
Reference: [46] <author> Madhav, N., </author> <month> September </month> <year> 1991. </year> <type> Personal communication. </type>
Reference-contexts: A consequence of the semantics of copy except, copy only is that separate compilation is compromised. A parent module must always be compiled before its use, and any change to it requires recompilation of its heir modules <ref> [46] </ref>. Jigsaw supports inheriting from separately compiled modules without restriction. The approach presented in this dissertation has the benefits of simplicity and modularity. It does not rely upon dependent sums or products, or on multiple universes of types.
Reference: [47] <author> Madsen, O. L., </author> <month> November </month> <year> 1990. </year> <type> Personal communication. </type>
Reference-contexts: Support for mixins in Beta is not deliberate, however; until an early version of this work was circulated, no one, including Beta's designers, had investigated use of mixins in Beta <ref> [47] </ref>. This explains why it is rather awkward to define a mixin in Beta. The idea that mixins can be treated as functions from classes to classes is valuable.
Reference: [48] <author> Madsen, O. L., Magnusson, B., and Moller-Pederson, B. </author> <title> Strong typing of object-oriented languages revisited. </title> <booktitle> In Proc. of the Joint ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications and the European Conference on Object-Oriented Programming (Oct. </booktitle> <year> 1990), </year> <pages> pp. 140-149. </pages>
Reference-contexts: Current languages which unify types and classes, either restrict expressiveness in this way (e.g, C++), or have unsound type systems (e.g., Eiffel). In the case of unsound type systems, the problems may be rectified by use of dynamic typing, as in Beta <ref> [48] </ref>. 2.3.1.3 Other Considerations The separation of classes and types makes it easier to define orthogonal constructs for renaming [4, pp. 168] and visibility control. There are other reasons for separating classes and types. These have less to do with modularity. <p> There are other reasons for separating classes and types. These have less to do with modularity. The interested reader is referred to <ref> [8, 9, 19, 48] </ref>. It is worth noting that there are arguments for merging the concepts of type and class. Programming languages have a long tradition of using type information for implementation purposes.
Reference: [49] <author> Madsen, O. L., and Moller-Pederson, B. </author> <title> Virtual classes, a powerful mechanism in object-oriented programming. </title> <booktitle> In Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (Oct. </booktitle> <year> 1989), </year> <pages> pp. 397-406. </pages>
Reference-contexts: The solution takes advantage of Beta's unusual ability to nest classes in an arbitrary fashion, and redefine nested classes via inheritance. The approach taken here is closely related to Beta's use of nested patterns to represent genericity or procedures as parameters <ref> [49] </ref>. Support for mixins in Beta is not deliberate, however; until an early version of this work was circulated, no one, including Beta's designers, had investigated use of mixins in Beta [47]. This explains why it is rather awkward to define a mixin in Beta. <p> Another distinction is that Beta identifies classes and types. This has the disadvantages mentioned in Chapter 2, but allows Beta to support type abstraction using the same virtual pattern mechanism used for inheritance <ref> [49] </ref>. Nested modules in principle also support the notion of class variables found in languages like Smalltalk. Class variables are variables shared by all instances of a class. A module that nests another module inside it, can serve as a "factory" [20] and produce initialized instances of the nested module.
Reference: [50] <author> Manna, Z. </author> <title> The Mathematical Theory of Computation. </title> <publisher> McGraw-Hill, </publisher> <year> 1974. </year>
Reference-contexts: Section 5.5 presents denotational semantics for an imperative version of Jigsaw. 73 5.1 Background 5.1.1 Generators In object oriented programming, objects include data, and code that operates upon that data. Objects are thus inherently self-referential. The standard technique for modeling self-reference is fixpoint theory <ref> [50] </ref>. Using fixpoint theory, an object may be modeled using a record-generating function (called a generator following Cook [18]). Figure 5.1 shows a simple object and its associated generator function. This function takes a record as a parameter, and returns a record as a result.
Reference: [51] <author> Meyer, B. </author> <title> Object Oriented Software Construction. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Hertfordshire, England, </address> <year> 1988. </year> <month> 142 </month>
Reference-contexts: In some languages, abstract classes have no special linguistic support. Programmers define "dummy" routines that typically produce an error if executed. More recent languages <ref> [23, 51] </ref> explicitly recognize abstract classes. In these languages, methods that are undefined in the abstract class are identified by special syntax. Here such methods are referred to as pure virtuals, using the terminology of C++. Abstract classes are essential to the definition of frameworks [33]. <p> This solution relieves the programmer from the tedious task of resolving many of the conflicts that arise in practice. This is the policy followed by Eiffel <ref> [51] </ref>, Owl 25 @ @ @ @I &% &% &% @ @ @ @I &% Ellipse FillEllipse Circle FillCircle [62], CLOS [35] and SELF [68, 69]. The reader may wish to ponder the obvious common sense of this approach before continuing. <p> Such abstractions are the topic of the next subsection. 3.2.1 Mixins and Type Abstraction Many programming languages support abstractions over "second-class" entities, such as types, classes or modules <ref> [43, 1, 62, 51, 55, 23, 26] </ref>. These constructs are often referred to as generics. In some languages, generics are merely macros, separately expanded and recompiled for every application of the abstraction. This is the case in Ada, Modula-3 and C++. Such constructs are easily incorporated into almost any language. <p> This chapter argues that inheritance, properly formulated, is a powerful modularity mechanism that can constitute the basis of a module manipulation language. The formulation of inheritance presented herein is derived by observing that in languages supporting multiple inheritance (e.g., <ref> [23, 51, 62] </ref>), classes are burdened with too many roles. The class construct is "large" and monolithic. Here classes are simplified, and their functionality is partitioned among separate operators. Classes are reduced to a simple notion of module amutually recursive scope.
Reference: [52] <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: However, there are usually only very limited facilities for manipulating modules. Mechanisms are provided for module interconnection, but these are usually ad hoc. An important exception is ML <ref> [52] </ref>, which provides a well developed module manipulation language [44]. Integration of inheritance into ML in a modular fashion is the subject of ongoing research [53]. This thesis argues that inheritance is really an essential module manipulation mechanism.
Reference: [53] <author> Mitchell, J., Meldal, S., and Madhav, N. </author> <title> An extension of Standard ML modules with subtyping and inheritance. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages (Jan. </booktitle> <year> 1991), </year> <pages> pp. 270-278. </pages>
Reference-contexts: Mechanisms are provided for module interconnection, but these are usually ad hoc. An important exception is ML [52], which provides a well developed module manipulation language [44]. Integration of inheritance into ML in a modular fashion is the subject of ongoing research <ref> [53] </ref>. This thesis argues that inheritance is really an essential module manipulation mechanism. In languages without inheritance, its effects are obtained by extra-linguistic means (e.g., text editing). Thus, inheritance represents a natural step in the progression of linguistic support for modularity. <p> In C++, these interfaces are known as public (for users) and protected (for heirs). In Owl, heirs have access to a subtype visible interface. Similar ideas appear under the names of "internal" and "external" interfaces, in <ref> [53] </ref>. While these constructs do not strictly violate modularity, they seem overly complex, and introduce a subtle anomaly, pointed out in [25]. Once certain features of a class have been placed in the protected interface, those features can be accessed only via inheritance. <p> In addition, the uniform use of generators to model all definitional structures is new. The operator suite also includes new operations (namely hide, show, freeze, freeze-except and copy-as). 130 8.1.5 Mitchell Mitchell, in <ref> [53] </ref>, presented an extension to the ML module system that is in some ways similar to this work. Mitchell also chose to incorporate inheritance into a module language, an extension of the ML module system [44]. Some similar operations are supported, embedded in a more conventional syntax. <p> Instead, the ML notions of structures and functors are used to define and interconnect modules. Some of the inheritance constructs defined in <ref> [53] </ref> violate encapsulation (viz. copy except, copy only). These constructs inherently require knowledge of the internal structure of the "parent" module. A consequence of the semantics of copy except, copy only is that separate compilation is compromised. <p> Lan 131 guage designers may easily add or modify operations as necessary. An expression based language also allows users to compose operations more freely. The Jigsaw framework supports abstract classes and mixins. 1 Mixins cannot be expressed in the framework of <ref> [53] </ref>, and there is no explicit support for abstract classes (though the traditional device of giving dummy definitions for pure virtual methods is always available, with its concomitant disadvantages). On the other hand, Mitchell's approach supports modules implementing abstract data types. <p> It would be desirable to extend the framework with an analogous set of operators for abstract data types. However, there are technical difficulties related to the typing of existential data types. A related issue is the use of structural subtyping, in contrast to "name-based" subtyping in <ref> [53] </ref>. Both forms are useful; here, the focus is on structural subtyping, which is more appropriate between different modules or programs [12]. Finally, unlike [53], precise semantic definitions of all operations have been given. 8.2 Future Work 8.2.1 Name-based Typing Jigsaw, as presently formulated, does not support name based typing. <p> A related issue is the use of structural subtyping, in contrast to "name-based" subtyping in <ref> [53] </ref>. Both forms are useful; here, the focus is on structural subtyping, which is more appropriate between different modules or programs [12]. Finally, unlike [53], precise semantic definitions of all operations have been given. 8.2 Future Work 8.2.1 Name-based Typing Jigsaw, as presently formulated, does not support name based typing. However, this does not seem to present a serious difficulty. <p> The uniqueness of brands can be enforced syntactically, as in Modula-3. Within a Jigsaw module, a brand can be given by the user only once. When modules are combined, it is 1 Abstract classes are mentioned in <ref> [53] </ref>, but only as substitutes for interfaces. 132 necessary to guarantee that brands are unique across modules. In effect, the brands introduced by a module are part of its interface, and may not be duplicated by other modules. This can be checked when modules are combined.
Reference: [54] <author> Moon, D. A. </author> <title> Object-oriented programming with Flavors. </title> <booktitle> In Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (1986), </booktitle> <pages> pp. 1-8. </pages>
Reference-contexts: It was first used by the developers of the Flavors <ref> [54] </ref> language. In CLOS, mixins are available as a result of two factors: dynamic typing and the notion of linearization. In CLOS, all classes that contribute to an object's behavior are ordered linearly in a class precedence list. The ordering is determined by a linearization algorithm.
Reference: [55] <author> Nelson, G., Ed. </author> <title> Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: That is one phase in a two phase process. The second step is using the understanding gleaned in the first phase to design better languages. This dissertation is concerned with this second phase. 9 1.5 Modula Modula- is an extension of Modula-3 <ref> [55] </ref> that supports some of the key operations of the Jigsaw framework. The purpose of this extension is to demonstrate the applicability of Jigsaw to realistic programming languages. Extending an existing language has several benefits. An upwardly compatible extension means that existing code is not invalidated. <p> Such abstractions are the topic of the next subsection. 3.2.1 Mixins and Type Abstraction Many programming languages support abstractions over "second-class" entities, such as types, classes or modules <ref> [43, 1, 62, 51, 55, 23, 26] </ref>. These constructs are often referred to as generics. In some languages, generics are merely macros, separately expanded and recompiled for every application of the abstraction. This is the case in Ada, Modula-3 and C++. Such constructs are easily incorporated into almost any language. <p> One of the goals of this extension was to show how Jigsaw style operations could be incorporated in a high-performance language. 3. It employs structural subtyping. Jigsaw already employs a form of structural subtyping, because structural subtyping is preferable to name based typing when separately developed modules must interact <ref> [55, section 8.1] </ref>. 6.2 A Review of Modula-3 The purpose of this section is to present an overview of the key Modula-3 features necessary to understand the language extension. Readers are referred to [55] for a complete language definition. 6.2.1 Modula-3 Inheritance Modula-3 supports inheritance via object types. <p> Readers are referred to <ref> [55] </ref> for a complete language definition. 6.2.1 Modula-3 Inheritance Modula-3 supports inheritance via object types. Object types are roughly analogous to classes in most object-oriented languages. <p> In Chapter 6, the brand mechanism of Modula-3 was used to obtain the functionality of named types in a structural-type setting. This is a generally applicable solution. Brands are viewed as parameters to type constructors, and are components of a type's structure <ref> [55] </ref>. The uniqueness of brands can be enforced syntactically, as in Modula-3. Within a Jigsaw module, a brand can be given by the user only once. <p> An exception is Modula-3, where one can inherit from a separately compiled object type. Specifying how to do this is challenging, and is done informally, in English. For some excellent examples, see <ref> [55, Chapter 6] </ref>. The semantic framework of Jigsaw may suggest a starting point of attacking this problem. Traditional specification deals with the behavior of records with function valued attributes.
Reference: [56] <author> Nierstrasz, O. </author> <title> Towards an object calculus. </title> <booktitle> In ECOOP'91 Workshop on Object-based Concurrent Computing (July 1991). </booktitle>
Reference-contexts: The operator based approach advocated in Jigsaw seems to fit well with process calculus models of concurrency in the style of CCS [61]. Nierstrasz has investigated such calculi in an object-oriented context [57]. More recent work by Nierstrasz investigates the integration of process and calculi <ref> [56] </ref>. In [56], it is shown how to express the fixpoint operator in such an integrated calculus. It should therefore be possible to integrate Jigsaw style generator definitions into this framework. <p> The operator based approach advocated in Jigsaw seems to fit well with process calculus models of concurrency in the style of CCS [61]. Nierstrasz has investigated such calculi in an object-oriented context [57]. More recent work by Nierstrasz investigates the integration of process and calculi <ref> [56] </ref>. In [56], it is shown how to express the fixpoint operator in such an integrated calculus. It should therefore be possible to integrate Jigsaw style generator definitions into this framework.
Reference: [57] <author> Nierstrasz, O., and Papathomas, M. </author> <title> Viewing objects as patterns of communicating agents. </title> <booktitle> In Proc. of the Joint ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications and the European Conference on Object-Oriented Programming (Oct. </booktitle> <year> 1990), </year> <pages> pp. 38-43. </pages>
Reference-contexts: The operator based approach advocated in Jigsaw seems to fit well with process calculus models of concurrency in the style of CCS [61]. Nierstrasz has investigated such calculi in an object-oriented context <ref> [57] </ref>. More recent work by Nierstrasz investigates the integration of process and calculi [56]. In [56], it is shown how to express the fixpoint operator in such an integrated calculus. It should therefore be possible to integrate Jigsaw style generator definitions into this framework.
Reference: [58] <author> Raj, R. K., and Levy, H. M. </author> <title> A Compositional Model for Software Reuse. </title> <booktitle> In European Conference on Object-Oriented Programming (July 1989), </booktitle> <editor> S. Cook, Ed., </editor> <booktitle> British Computer Society Workshop Series, </booktitle> <publisher> Cambridge University Press, </publisher> <pages> pp. 3-24. </pages>
Reference-contexts: In practice, modular programming languages provide no notation to express inheritance. Usually, there is no notation for manipulating modules at all. Even languages that do support module manipulation (e.g., ML, Jade <ref> [58] </ref> ) are hampered 20 by lack of inheritance. Modification is achieved using an extra-linguistic tool, a text editor. Again, all disadvantages noted earlier apply. Access to source code is required. Recompilation is necessary. Multiple copies of modules are introduced. No semantic constraints are enforced. <p> External dependencies are expressed using habitats, a compile time parameterization mechanism. This is similar to the use of declarations in Jigsaw for module interconnection. However, habitats support parameterization of components but not inheritance. Modifications to components must be done either manually or with environmental support. In <ref> [58] </ref>, the idea of automating such operations using "simple set theoretic operators" is suggested, but not explored.
Reference: [59] <author> Reddy, U. S. </author> <title> Objects as closures: Abstract semantics of object-oriented languages. </title> <booktitle> In Proc. ACM Conf. on Lisp and Functional Programming (1988), </booktitle> <pages> pp. 289-297. </pages>
Reference-contexts: The interaction between Jigsaw and the language of computation is potentially bidirectional. This structure is exactly analogous to that typical of abstract classes and frameworks in object-oriented languages. 1.4 Semantics Jigsaw has a rigorous semantics, based upon a denotational model of inheritance <ref> [18, 59] </ref>. Indeed, Jigsaw would not have been conceived without the insights derived from the study of the denotational semantics of object-oriented languages. The Jigsaw framework maps very directly to the underlying semantics. Modules have simple denotations, which are just functions from records to records. <p> CHAPTER 5 SEMANTICS The formalism remains an unaccommodating object of study, without true structure, a piece of soft camembert. Jean-Yves Girard This chapter presents the theoretical basis of the dissertation. The work presented here is an application of denotational models of inheritance, as pioneered by Reddy <ref> [59] </ref> and especially by Cook [18]. It also builds on the extensive body of work on typing object-oriented languages, starting with [10]. Readers unfamiliar with the details of the aforementioned work need not worry; the background section provides all the requisite information for understanding this chapter. <p> record 2 j record [label 1 label 2 ] label list ::= label j label label list def list ::= nonempty def list j empty nonempty def list ::= def j def; nonempty def list def ::= label = expr 5.1.3 Inheritance This subsection discusses the denotational semantics of inheritance <ref> [34, 59, 18] </ref>. Inheritance provides a way of modifying self-referential structures [18]. When a value is modified via inheritance, all self-reference within the result refers to the modified value. Inheritance involves manipulating the self-reference within objects. Technically, this is achieved by manipulating generators, before taking their fixpoint 76 [59], [18]. <p> Inheritance provides a way of modifying self-referential structures [18]. When a value is modified via inheritance, all self-reference within the result refers to the modified value. Inheritance involves manipulating the self-reference within objects. Technically, this is achieved by manipulating generators, before taking their fixpoint 76 <ref> [59] </ref>, [18]. Figure 5.2 illustrates this process. The object MP inherits from P, but specializes the dist method. MP is modeled by a generator that invokes the generator for P.
Reference: [60] <author> Remy, D. </author> <title> Typechecking records and variants in a natural extension to ML. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages (1989), </booktitle> <pages> pp. 77-88. </pages>
Reference-contexts: Similar operations have been used in the study of typed record calculi <ref> [13, 27, 71, 60] </ref>. However, this dissertation is not concerned with the typing problems raised by these operators. Here, record operations are only used in the definitions of module operators.
Reference: [61] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, New Jersey, </address> <year> 1989. </year>
Reference-contexts: The operator based approach advocated in Jigsaw seems to fit well with process calculus models of concurrency in the style of CCS <ref> [61] </ref>. Nierstrasz has investigated such calculi in an object-oriented context [57]. More recent work by Nierstrasz investigates the integration of process and calculi [56]. In [56], it is shown how to express the fixpoint operator in such an integrated calculus.
Reference: [62] <author> Schaffert, C., Cooper, T., Bullis, B., Kilian, M., and Wilpolt, C. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (1986), </booktitle> <pages> pp. 9-16. </pages>
Reference-contexts: This solution relieves the programmer from the tedious task of resolving many of the conflicts that arise in practice. This is the policy followed by Eiffel [51], Owl 25 @ @ @ @I &% &% &% @ @ @ @I &% Ellipse FillEllipse Circle FillCircle <ref> [62] </ref>, CLOS [35] and SELF [68, 69]. The reader may wish to ponder the obvious common sense of this approach before continuing. The only modular solution is to treat the name collisions as errors, just as if the conflicting names had been defined in different classes. <p> This is illustrated in Figure 2.6. Care must be taken that such access is allowed only within the inheriting class, and that only immediate ancestors may be referenced this way. Languages like Owl <ref> [62] </ref> that allow arbitrary ancestors to be accessed this way, expose the use of inheritance to clients. Consider Figure 2.7. <p> Such abstractions are the topic of the next subsection. 3.2.1 Mixins and Type Abstraction Many programming languages support abstractions over "second-class" entities, such as types, classes or modules <ref> [43, 1, 62, 51, 55, 23, 26] </ref>. These constructs are often referred to as generics. In some languages, generics are merely macros, separately expanded and recompiled for every application of the abstraction. This is the case in Ada, Modula-3 and C++. Such constructs are easily incorporated into almost any language. <p> This chapter argues that inheritance, properly formulated, is a powerful modularity mechanism that can constitute the basis of a module manipulation language. The formulation of inheritance presented herein is derived by observing that in languages supporting multiple inheritance (e.g., <ref> [23, 51, 62] </ref>), classes are burdened with too many roles. The class construct is "large" and monolithic. Here classes are simplified, and their functionality is partitioned among separate operators. Classes are reduced to a simple notion of module amutually recursive scope.
Reference: [63] <author> Snyder, A. CommonObjects: </author> <title> An overview. </title> <journal> SIGPLAN Notices 21, </journal> <volume> 10 (1986), </volume> <pages> 19-28. </pages>
Reference-contexts: Mixins are not expressed as explicit abstractions, nor do 35 they have any formal language support. CLOS is representative of the approach taken by a variety of LISP dialects with respect to inheritance. The main exception is CommonObjects <ref> [63, 65] </ref>, which is discussed in Chapter 8 in the context of related work. 3.1.2 SELF SELF, like CLOS, is dynamically typed. Unlike CLOS, it is not based upon a linear form of inheritance, but rather upon delegation [2, 6, 41, 66]. <p> In conjunction with that study, Sny-der developed an object-oriented LISP dialect called CommonObjects <ref> [63] </ref>. Com-monObjects was the first object-oriented language that did not violate encapsulation. It also allowed the definition of mixins. However, the language was dynamically typed, reflecting its LISP heritage. Though encapsulation is a key aspect of modularity, it is not the only one.
Reference: [64] <author> Snyder, A. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (1986), </booktitle> <pages> pp. 38-45. 143 </pages>
Reference-contexts: No existing language meets all the criteria for a modular programming language. Special scrutiny is reserved for languages with inheritance. These languages have a variety of problems with respect to modularity. The well known encapsulation problems first demonstrated by Snyder <ref> [64, 65] </ref> are reviewed. In the process of evaluating current language designs with respect to modularity, some novel insights are gained. Inheritance is identified as a necessary module manipulation mechanism. In addition, another important limitation on modularity, the absence of mixins, is discussed.
Reference: [65] <author> Snyder, A. </author> <title> Inheritance and the Development of Encapsulated Software Components. </title> <booktitle> In Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987, </year> <pages> pp. 165-188. </pages>
Reference-contexts: The graph induced is a DAG (directed acyclic graph). Single inheritance has won substantial acceptance as a useful technique for structuring programs. Multiple inheritance is much more controversial. There is no agreement on the appropriate semantics for multiple inheritance. In most current languages, multiple inheritance violates encapsulation <ref> [65] </ref>. The rules governing &% &% 6 road vehicle eighteen wheeler 4 multiple inheritance are complex. Proponents of multiple inheritance argue that it is essential, while critics contend that the perceived need for multiple inheritance is a symptom of poor program design, and that single inheritance is sufficient. <p> No existing language meets all the criteria for a modular programming language. Special scrutiny is reserved for languages with inheritance. These languages have a variety of problems with respect to modularity. The well known encapsulation problems first demonstrated by Snyder <ref> [64, 65] </ref> are reviewed. In the process of evaluating current language designs with respect to modularity, some novel insights are gained. Inheritance is identified as a necessary module manipulation mechanism. In addition, another important limitation on modularity, the absence of mixins, is discussed. <p> This section discusses the modularity problems that arise in languages that incorporate inheritance. Snyder's classic paper <ref> [65] </ref> showed how inheritance commonly undermines modularity. Snyder's observations are recalled here, since they are central to this work. A modularity problem not discussed in [65] is that certain program constructs cannot be effectively modularized. This is addressed in section 2.3.5. <p> This section discusses the modularity problems that arise in languages that incorporate inheritance. Snyder's classic paper <ref> [65] </ref> showed how inheritance commonly undermines modularity. Snyder's observations are recalled here, since they are central to this work. A modularity problem not discussed in [65] is that certain program constructs cannot be effectively modularized. This is addressed in section 2.3.5. The next three subsections illustrate different manifestations of essentially the same problem: exposure of a class' use of inheritance to its clients. This violates criterion 1 encapsulation. <p> Mixins are not expressed as explicit abstractions, nor do 35 they have any formal language support. CLOS is representative of the approach taken by a variety of LISP dialects with respect to inheritance. The main exception is CommonObjects <ref> [63, 65] </ref>, which is discussed in Chapter 8 in the context of related work. 3.1.2 SELF SELF, like CLOS, is dynamically typed. Unlike CLOS, it is not based upon a linear form of inheritance, but rather upon delegation [2, 6, 41, 66]. <p> Note that modularity need not be violated here. No implicit linearization is performed. The linear order is determined explicitly by the programmer. If the other precepts of <ref> [65] </ref> are followed, this form of inheritance does not violate encapsulation. The formulation described up until now provides essentially the same level of functionality provided in [28]. Further refinements are developed below. <p> The essential difference between such 128 operators (if they were developed) and those of Jigsaw is that the bidirectional relationship between abstraction and parameter characteristic of abstract classes is not available. 8.1.2 CommonObjects The definitive study of inheritance with respect to encapsulation is <ref> [65] </ref>, which has been cited extensively in this dissertation. In conjunction with that study, Sny-der developed an object-oriented LISP dialect called CommonObjects [63]. Com-monObjects was the first object-oriented language that did not violate encapsulation. It also allowed the definition of mixins. <p> It also allowed the definition of mixins. However, the language was dynamically typed, reflecting its LISP heritage. Though encapsulation is a key aspect of modularity, it is not the only one. Other issues, such as hierarchy, were not considered. Mixins were recognized as an important programming idiom in <ref> [65] </ref> but were not considered as a full fledged construct. CommonObjects employed a formulation of inheritance called tree inheritance. The terminology reflects the operational, graph-oriented approach to inheritance prevalent at the time the study was undertaken.
Reference: [66] <author> Taivalsaari, A. </author> <title> Towards a taxonomy of inheritance mechanisms in object-oriented programming, </title> <month> September </month> <year> 1991. </year> <note> Licentiate thesis. </note>
Reference-contexts: The main exception is CommonObjects [63, 65], which is discussed in Chapter 8 in the context of related work. 3.1.2 SELF SELF, like CLOS, is dynamically typed. Unlike CLOS, it is not based upon a linear form of inheritance, but rather upon delegation <ref> [2, 6, 41, 66] </ref>. Delegation is a form of inheritance that occurs between objects (often referred to as prototypes) at execution time, rather than between classes at the time of compilation. Like CLOS, SELF has a built-in mechanism for accessing overridden methods (known as resend). <p> As a consequence, the state of the delegate is shared with all its delegators. The principle difference between Jigsaw's semantics and those of a delegation based language like SELF is that between copy semantics and reference semantics. An equivalent conclusion is reached independently by Taivalsaari in <ref> [66] </ref>. Based on this insight, SELF style delegation can be supported with a suite of inheritance operators. The description will have an uncomfortably operational flavor, but remember, delegation is an inherently operational notion. At this point, a single example will be shown, to give some insight.
Reference: [67] <author> Tennent, R. </author> <booktitle> Principles of Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: The idea that mixins can be treated as functions from classes to classes is valuable. In the next section this idea will be made readily apparent, free of Beta's somewhat idiosyncratic syntactic and conceptual baggage. 3.2 Mixins as Abstractions Tennent's principle of abstraction <ref> [67, page 114] </ref> states that "any semantically meaningful syntactic class...can in principle be used as the body of a form of abstract." The introduction of mixins into object-oriented languages is a direct application of this principle.
Reference: [68] <author> Ungar, D., Chambers, C., Chang, B.-W., and Holzle, U. </author> <title> Parents are shared parts of objects: Inheritance and encapsulation in SELF, 1990. In The SELF papers, compiled by Urs Holzle. </title>
Reference-contexts: This is the policy followed by Eiffel [51], Owl 25 @ @ @ @I &% &% &% @ @ @ @I &% Ellipse FillEllipse Circle FillCircle [62], CLOS [35] and SELF <ref> [68, 69] </ref>. The reader may wish to ponder the obvious common sense of this approach before continuing. The only modular solution is to treat the name collisions as errors, just as if the conflicting names had been defined in different classes.
Reference: [69] <author> Ungar, D., Chambers, C., Chang, B.-W., and Holzle, U. </author> <title> The SELF manual, </title> <note> version 1.0, </note> <month> July </month> <year> 1990. </year>
Reference-contexts: This is the policy followed by Eiffel [51], Owl 25 @ @ @ @I &% &% &% @ @ @ @I &% Ellipse FillEllipse Circle FillCircle [62], CLOS [35] and SELF <ref> [68, 69] </ref>. The reader may wish to ponder the obvious common sense of this approach before continuing. The only modular solution is to treat the name collisions as errors, just as if the conflicting names had been defined in different classes.
Reference: [70] <author> Vlissides, J., and Linton, M. Unidraw: </author> <title> A framework for building domain-specific graphical editors. </title> <type> Tech. Rep. </type> <institution> CSL-TR-89-380, Stanford University, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: A framework is used as a basis for an application. Typically, some of the framework's abstract classes are modified and extended by inheritance to tailor them to specific needs. Examples of frameworks are <ref> [42, 45, 70, 73] </ref>. Abstract classes support a powerful form of parameterization, unique to the object-oriented paradigm.
Reference: [71] <author> Wand, M. </author> <title> Type inference for record concatenation and multiple inheritance. </title> <booktitle> In Proc. IEEE Symposium on Logic in Computer Science (1989), </booktitle> <pages> pp. 92-97. </pages>
Reference-contexts: Similar operations have been used in the study of typed record calculi <ref> [13, 27, 71, 60] </ref>. However, this dissertation is not concerned with the typing problems raised by these operators. Here, record operations are only used in the definitions of module operators.
Reference: [72] <author> Wegner, P. </author> <title> The object-oriented classification paradigm. </title> <booktitle> In Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987, </year> <pages> pp. 479-560. </pages>
Reference-contexts: Also, the solution chosen here is more natural, since modules do denote a different kind of value than objects. This will be discussed in Chapter 5. Another reason for keeping modules and instances distinct is that the decision to make module instances first class values (as in "Class-based" languages <ref> [72] </ref>) need not imply that modules themselves are first class values. If modules are identified with instances, the two decisions cannot be separated. The use of Jigsaw should not constrain language designers in this way.
Reference: [73] <author> Weinand, A., Gamma, E., and Marty, R. </author> <title> ET++ an object-oriented application framework in C++. </title> <booktitle> In Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (1988), </booktitle> <pages> pp. 46-57. </pages>
Reference-contexts: A framework is used as a basis for an application. Typically, some of the framework's abstract classes are modified and extended by inheritance to tailor them to specific needs. Examples of frameworks are <ref> [42, 45, 70, 73] </ref>. Abstract classes support a powerful form of parameterization, unique to the object-oriented paradigm.
Reference: [74] <author> Wirth, N. </author> <title> Programming in Modula-2. </title> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: No static typechecking is performed across module boundaries. There is also poor support for encapsulation; typically, all globals in a module are available to other modules. Later languages such as CLU [43], Ada [1], Modula-2 <ref> [74] </ref>, Modula-3 and others provide a structured way of specifying modules and their interconnection. Formal notions of module and interface are part of the language. The language semantics guarantee that modules are used in accordance with their interface.
Reference: [75] <editor> Yonezawa, A., and Tokoro, M., Eds. </editor> <booktitle> Object-Oriented Concurrent Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Use of dynamic typing, as in Beta is one option, but a costly one. In [19] static type systems that address some of these problems are discusses. 8.2.6 Process Calculi Object orientation presents a natural model of concurrency, and concurrent object-oriented programming has been the focus of considerable attention <ref> [75] </ref>. The operator based approach advocated in Jigsaw seems to fit well with process calculus models of concurrency in the style of CCS [61]. Nierstrasz has investigated such calculi in an object-oriented context [57]. More recent work by Nierstrasz investigates the integration of process and calculi [56].
References-found: 75

